<!DOCTYPE html><html><head><title>Help for package distributions3</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distributions3}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply_dpqr'><p>Utilities for <code>distributions3</code> objects</p></a></li>
<li><a href='#Bernoulli'><p>Create a Bernoulli distribution</p></a></li>
<li><a href='#Beta'><p>Create a Beta distribution</p></a></li>
<li><a href='#Binomial'><p>Create a Binomial distribution</p></a></li>
<li><a href='#Categorical'><p>Create a Categorical distribution</p></a></li>
<li><a href='#Cauchy'><p>Create a Cauchy distribution</p></a></li>
<li><a href='#cdf'><p>Evaluate the cumulative distribution function of a probability distribution</p></a></li>
<li><a href='#cdf.Bernoulli'><p>Evaluate the cumulative distribution function of a Bernoulli distribution</p></a></li>
<li><a href='#cdf.Beta'><p>Evaluate the cumulative distribution function of a Beta distribution</p></a></li>
<li><a href='#cdf.Binomial'><p>Evaluate the cumulative distribution function of a Binomial distribution</p></a></li>
<li><a href='#cdf.Categorical'><p>Evaluate the cumulative distribution function of a Categorical distribution</p></a></li>
<li><a href='#cdf.Cauchy'><p>Evaluate the cumulative distribution function of a Cauchy distribution</p></a></li>
<li><a href='#cdf.ChiSquare'><p>Evaluate the cumulative distribution function of a chi square distribution</p></a></li>
<li><a href='#cdf.Erlang'><p>Evaluate the cumulative distribution function of an Erlang distribution</p></a></li>
<li><a href='#cdf.Exponential'><p>Evaluate the cumulative distribution function of an Exponential distribution</p></a></li>
<li><a href='#cdf.FisherF'><p>Evaluate the cumulative distribution function of an F distribution</p></a></li>
<li><a href='#cdf.Frechet'><p>Evaluate the cumulative distribution function of a Frechet distribution</p></a></li>
<li><a href='#cdf.Gamma'><p>Evaluate the cumulative distribution function of a Gamma distribution</p></a></li>
<li><a href='#cdf.Geometric'><p>Evaluate the cumulative distribution function of a Geometric distribution</p></a></li>
<li><a href='#cdf.GEV'><p>Evaluate the cumulative distribution function of a GEV distribution</p></a></li>
<li><a href='#cdf.GP'><p>Evaluate the cumulative distribution function of a GP distribution</p></a></li>
<li><a href='#cdf.Gumbel'><p>Evaluate the cumulative distribution function of a Gumbel distribution</p></a></li>
<li><a href='#cdf.HurdleNegativeBinomial'><p>Evaluate the cumulative distribution function of a hurdle negative binomial distribution</p></a></li>
<li><a href='#cdf.HurdlePoisson'><p>Evaluate the cumulative distribution function of a hurdle Poisson distribution</p></a></li>
<li><a href='#cdf.HyperGeometric'><p>Evaluate the cumulative distribution function of a HyperGeometric distribution</p></a></li>
<li><a href='#cdf.Logistic'><p>Evaluate the cumulative distribution function of a Logistic distribution</p></a></li>
<li><a href='#cdf.LogNormal'><p>Evaluate the cumulative distribution function of a LogNormal distribution</p></a></li>
<li><a href='#cdf.NegativeBinomial'><p>Evaluate the cumulative distribution function of a negative binomial distribution</p></a></li>
<li><a href='#cdf.Normal'><p>Evaluate the cumulative distribution function of a Normal distribution</p></a></li>
<li><a href='#cdf.Poisson'><p>Evaluate the cumulative distribution function of a Poisson distribution</p></a></li>
<li><a href='#cdf.RevWeibull'><p>Evaluate the cumulative distribution function of an RevWeibull distribution</p></a></li>
<li><a href='#cdf.StudentsT'><p>Evaluate the cumulative distribution function of a StudentsT distribution</p></a></li>
<li><a href='#cdf.Tukey'><p>Evaluate the cumulative distribution function of a Tukey distribution</p></a></li>
<li><a href='#cdf.Uniform'><p>Evaluate the cumulative distribution function of a continuous Uniform distribution</p></a></li>
<li><a href='#cdf.Weibull'><p>Evaluate the cumulative distribution function of a Weibull distribution</p></a></li>
<li><a href='#cdf.ZINegativeBinomial'><p>Evaluate the cumulative distribution function of a zero-inflated negative binomial distribution</p></a></li>
<li><a href='#cdf.ZIPoisson'><p>Evaluate the cumulative distribution function of a zero-inflated Poisson distribution</p></a></li>
<li><a href='#cdf.ZTNegativeBinomial'><p>Evaluate the cumulative distribution function of a zero-truncated negative binomial distribution</p></a></li>
<li><a href='#cdf.ZTPoisson'><p>Evaluate the cumulative distribution function of a zero-truncated Poisson distribution</p></a></li>
<li><a href='#ChiSquare'><p>Create a Chi-Square distribution</p></a></li>
<li><a href='#dhnbinom'><p>The hurdle negative binomial distribution</p></a></li>
<li><a href='#dhpois'><p>The hurdle Poisson distribution</p></a></li>
<li><a href='#distributions3-package'><p>distributions3: Probability Distributions as S3 Objects</p></a></li>
<li><a href='#dzinbinom'><p>The zero-inflated negative binomial distribution</p></a></li>
<li><a href='#dzipois'><p>The zero-inflated Poisson distribution</p></a></li>
<li><a href='#dztnbinom'><p>The zero-truncated negative binomial distribution</p></a></li>
<li><a href='#dztpois'><p>The zero-truncated Poisson distribution</p></a></li>
<li><a href='#Erlang'><p>Create an Erlang distribution</p></a></li>
<li><a href='#Exponential'><p>Create an Exponential distribution</p></a></li>
<li><a href='#FIFA2018'><p>Goals scored in all 2018 FIFA World Cup matches</p></a></li>
<li><a href='#FisherF'><p>Create an F distribution</p></a></li>
<li><a href='#fit_mle'><p>Fit a distribution to data</p></a></li>
<li><a href='#fit_mle.Bernoulli'><p>Fit a Bernoulli distribution to data</p></a></li>
<li><a href='#fit_mle.Binomial'><p>Fit a Binomial distribution to data</p></a></li>
<li><a href='#fit_mle.Exponential'><p>Fit an Exponential distribution to data</p></a></li>
<li><a href='#fit_mle.Gamma'><p>Fit a Gamma distribution to data</p></a></li>
<li><a href='#fit_mle.Geometric'><p>Fit a Geometric distribution to data</p></a></li>
<li><a href='#fit_mle.LogNormal'><p>Fit a Log Normal distribution to data</p></a></li>
<li><a href='#fit_mle.Normal'><p>Fit a Normal distribution to data</p></a></li>
<li><a href='#fit_mle.Poisson'><p>Fit an Poisson distribution to data</p></a></li>
<li><a href='#Frechet'><p>Create a Frechet distribution</p></a></li>
<li><a href='#Gamma'><p>Create a Gamma distribution</p></a></li>
<li><a href='#Geometric'><p>Create a Geometric distribution</p></a></li>
<li><a href='#GEV'><p>Create a Generalised Extreme Value (GEV) distribution</p></a></li>
<li><a href='#GP'><p>Create a Generalised Pareto (GP) distribution</p></a></li>
<li><a href='#Gumbel'><p>Create a Gumbel distribution</p></a></li>
<li><a href='#HurdleNegativeBinomial'><p>Create a hurdle negative binomial distribution</p></a></li>
<li><a href='#HurdlePoisson'><p>Create a hurdle Poisson distribution</p></a></li>
<li><a href='#HyperGeometric'><p>Create a HyperGeometric distribution</p></a></li>
<li><a href='#is_discrete'><p>Determine whether a distribution is discrete or continuous</p></a></li>
<li><a href='#is_distribution'><p>Is an object a distribution?</p></a></li>
<li><a href='#log_likelihood'><p>Compute the (log-)likelihood of a probability distribution given data</p></a></li>
<li><a href='#Logistic'><p>Create a Logistic distribution</p></a></li>
<li><a href='#LogNormal'><p>Create a LogNormal distribution</p></a></li>
<li><a href='#Multinomial'><p>Create a Multinomial distribution</p></a></li>
<li><a href='#NegativeBinomial'><p>Create a negative binomial distribution</p></a></li>
<li><a href='#Normal'><p>Create a Normal distribution</p></a></li>
<li><a href='#pdf'><p>Evaluate the probability density of a probability distribution</p></a></li>
<li><a href='#pdf.Bernoulli'><p>Evaluate the probability mass function of a Bernoulli distribution</p></a></li>
<li><a href='#pdf.Beta'><p>Evaluate the probability mass function of a Beta distribution</p></a></li>
<li><a href='#pdf.Binomial'><p>Evaluate the probability mass function of a Binomial distribution</p></a></li>
<li><a href='#pdf.Categorical'><p>Evaluate the probability mass function of a Categorical discrete distribution</p></a></li>
<li><a href='#pdf.Cauchy'><p>Evaluate the probability mass function of a Cauchy distribution</p></a></li>
<li><a href='#pdf.ChiSquare'><p>Evaluate the probability mass function of a chi square distribution</p></a></li>
<li><a href='#pdf.Erlang'><p>Evaluate the probability mass function of an Erlang distribution</p></a></li>
<li><a href='#pdf.Exponential'><p>Evaluate the probability density function of an Exponential distribution</p></a></li>
<li><a href='#pdf.FisherF'><p>Evaluate the probability mass function of an F distribution</p></a></li>
<li><a href='#pdf.Frechet'><p>Evaluate the probability mass function of a Frechet distribution</p></a></li>
<li><a href='#pdf.Gamma'><p>Evaluate the probability mass function of a Gamma distribution</p></a></li>
<li><a href='#pdf.Geometric'><p>Evaluate the probability mass function of a Geometric distribution</p></a></li>
<li><a href='#pdf.GEV'><p>Evaluate the probability mass function of a GEV distribution</p></a></li>
<li><a href='#pdf.GP'><p>Evaluate the probability mass function of a GP distribution</p></a></li>
<li><a href='#pdf.Gumbel'><p>Evaluate the probability mass function of a Gumbel distribution</p></a></li>
<li><a href='#pdf.HurdleNegativeBinomial'><p>Evaluate the probability mass function of a hurdle negative binomial distribution</p></a></li>
<li><a href='#pdf.HurdlePoisson'><p>Evaluate the probability mass function of a hurdle Poisson distribution</p></a></li>
<li><a href='#pdf.HyperGeometric'><p>Evaluate the probability mass function of a HyperGeometric distribution</p></a></li>
<li><a href='#pdf.Logistic'><p>Evaluate the probability mass function of a Logistic distribution</p></a></li>
<li><a href='#pdf.LogNormal'><p>Evaluate the probability mass function of a LogNormal distribution</p></a></li>
<li><a href='#pdf.Multinomial'><p>Evaluate the probability mass function of a Multinomial distribution</p></a></li>
<li><a href='#pdf.NegativeBinomial'><p>Evaluate the probability mass function of a NegativeBinomial distribution</p></a></li>
<li><a href='#pdf.Normal'><p>Evaluate the probability mass function of a Normal distribution</p></a></li>
<li><a href='#pdf.Poisson'><p>Evaluate the probability mass function of a Poisson distribution</p></a></li>
<li><a href='#pdf.RevWeibull'><p>Evaluate the probability mass function of an RevWeibull distribution</p></a></li>
<li><a href='#pdf.StudentsT'><p>Evaluate the probability mass function of a StudentsT distribution</p></a></li>
<li><a href='#pdf.Uniform'><p>Evaluate the probability mass function of a continuous Uniform distribution</p></a></li>
<li><a href='#pdf.Weibull'><p>Evaluate the probability mass function of a Weibull distribution</p></a></li>
<li><a href='#pdf.ZINegativeBinomial'><p>Evaluate the probability mass function of a zero-inflated negative binomial distribution</p></a></li>
<li><a href='#pdf.ZIPoisson'><p>Evaluate the probability mass function of a zero-inflated Poisson distribution</p></a></li>
<li><a href='#pdf.ZTNegativeBinomial'><p>Evaluate the probability mass function of a zero-truncated negative binomial distribution</p></a></li>
<li><a href='#pdf.ZTPoisson'><p>Evaluate the probability mass function of a zero-truncated Poisson distribution</p></a></li>
<li><a href='#plot_cdf'><p>Plot the CDF of a distribution</p></a></li>
<li><a href='#plot_pdf'><p>Plot the PDF of a distribution</p></a></li>
<li><a href='#plot.distribution'><p>Plot the p.m.f, p.d.f or c.d.f. of a univariate distribution</p></a></li>
<li><a href='#Poisson'><p>Create a Poisson distribution</p></a></li>
<li><a href='#prodist'><p>Extracting fitted or predicted probability distributions from models</p></a></li>
<li><a href='#quantile.Bernoulli'><p>Determine quantiles of a Bernoulli distribution</p></a></li>
<li><a href='#quantile.Beta'><p>Determine quantiles of a Beta distribution</p></a></li>
<li><a href='#quantile.Binomial'><p>Determine quantiles of a Binomial distribution</p></a></li>
<li><a href='#quantile.Categorical'><p>Determine quantiles of a Categorical discrete distribution</p></a></li>
<li><a href='#quantile.Cauchy'><p>Determine quantiles of a Cauchy distribution</p></a></li>
<li><a href='#quantile.ChiSquare'><p>Determine quantiles of a chi square distribution</p></a></li>
<li><a href='#quantile.Erlang'><p>Determine quantiles of an Erlang distribution</p></a></li>
<li><a href='#quantile.Exponential'><p>Determine quantiles of an Exponential distribution</p></a></li>
<li><a href='#quantile.FisherF'><p>Determine quantiles of an F distribution</p></a></li>
<li><a href='#quantile.Frechet'><p>Determine quantiles of a Frechet distribution</p></a></li>
<li><a href='#quantile.Gamma'><p>Determine quantiles of a Gamma distribution</p></a></li>
<li><a href='#quantile.Geometric'><p>Determine quantiles of a Geometric distribution</p></a></li>
<li><a href='#quantile.GEV'><p>Determine quantiles of a GEV distribution</p></a></li>
<li><a href='#quantile.GP'><p>Determine quantiles of a GP distribution</p></a></li>
<li><a href='#quantile.Gumbel'><p>Determine quantiles of a Gumbel distribution</p></a></li>
<li><a href='#quantile.HurdleNegativeBinomial'><p>Determine quantiles of a hurdle negative binomial distribution</p></a></li>
<li><a href='#quantile.HurdlePoisson'><p>Determine quantiles of a hurdle Poisson distribution</p></a></li>
<li><a href='#quantile.HyperGeometric'><p>Determine quantiles of a HyperGeometric distribution</p></a></li>
<li><a href='#quantile.Logistic'><p>Determine quantiles of a Logistic distribution</p></a></li>
<li><a href='#quantile.LogNormal'><p>Determine quantiles of a LogNormal distribution</p></a></li>
<li><a href='#quantile.NegativeBinomial'><p>Determine quantiles of a NegativeBinomial distribution</p></a></li>
<li><a href='#quantile.Normal'><p>Determine quantiles of a Normal distribution</p></a></li>
<li><a href='#quantile.Poisson'><p>Determine quantiles of a Poisson distribution</p></a></li>
<li><a href='#quantile.RevWeibull'><p>Determine quantiles of a RevWeibull distribution</p></a></li>
<li><a href='#quantile.StudentsT'><p>Determine quantiles of a StudentsT distribution</p></a></li>
<li><a href='#quantile.Tukey'><p>Determine quantiles of a Tukey distribution</p></a></li>
<li><a href='#quantile.Uniform'><p>Determine quantiles of a continuous Uniform  distribution</p></a></li>
<li><a href='#quantile.Weibull'><p>Determine quantiles of a Weibull distribution</p></a></li>
<li><a href='#quantile.ZINegativeBinomial'><p>Determine quantiles of a zero-inflated negative binomial distribution</p></a></li>
<li><a href='#quantile.ZIPoisson'><p>Determine quantiles of a zero-inflated Poisson distribution</p></a></li>
<li><a href='#quantile.ZTNegativeBinomial'><p>Determine quantiles of a zero-truncated negative binomial distribution</p></a></li>
<li><a href='#quantile.ZTPoisson'><p>Determine quantiles of a zero-truncated Poisson distribution</p></a></li>
<li><a href='#random'><p>Draw a random sample from a probability distribution</p></a></li>
<li><a href='#random.Bernoulli'><p>Draw a random sample from a Bernoulli distribution</p></a></li>
<li><a href='#random.Beta'><p>Draw a random sample from a Beta distribution</p></a></li>
<li><a href='#random.Binomial'><p>Draw a random sample from a Binomial distribution</p></a></li>
<li><a href='#random.Categorical'><p>Draw a random sample from a Categorical distribution</p></a></li>
<li><a href='#random.Cauchy'><p>Draw a random sample from a Cauchy distribution</p></a></li>
<li><a href='#random.ChiSquare'><p>Draw a random sample from a chi square distribution</p></a></li>
<li><a href='#random.Erlang'><p>Draw a random sample from an Erlang distribution</p></a></li>
<li><a href='#random.Exponential'><p>Draw a random sample from an Exponential distribution</p></a></li>
<li><a href='#random.FisherF'><p>Draw a random sample from an F distribution</p></a></li>
<li><a href='#random.Frechet'><p>Draw a random sample from a Frechet distribution</p></a></li>
<li><a href='#random.Gamma'><p>Draw a random sample from a Gamma distribution</p></a></li>
<li><a href='#random.Geometric'><p>Draw a random sample from a Geometric distribution</p></a></li>
<li><a href='#random.GEV'><p>Draw a random sample from a GEV distribution</p></a></li>
<li><a href='#random.GP'><p>Draw a random sample from a GP distribution</p></a></li>
<li><a href='#random.Gumbel'><p>Draw a random sample from a Gumbel distribution</p></a></li>
<li><a href='#random.HurdleNegativeBinomial'><p>Draw a random sample from a hurdle negative binomial distribution</p></a></li>
<li><a href='#random.HurdlePoisson'><p>Draw a random sample from a hurdle Poisson distribution</p></a></li>
<li><a href='#random.HyperGeometric'><p>Draw a random sample from a HyperGeometric distribution</p></a></li>
<li><a href='#random.Logistic'><p>Draw a random sample from a Logistic distribution</p></a></li>
<li><a href='#random.LogNormal'><p>Draw a random sample from a LogNormal distribution</p></a></li>
<li><a href='#random.Multinomial'><p>Draw a random sample from a Multinomial distribution</p></a></li>
<li><a href='#random.NegativeBinomial'><p>Draw a random sample from a negative binomial distribution</p></a></li>
<li><a href='#random.Normal'><p>Draw a random sample from a Normal distribution</p></a></li>
<li><a href='#random.Poisson'><p>Draw a random sample from a Poisson distribution</p></a></li>
<li><a href='#random.RevWeibull'><p>Draw a random sample from an RevWeibull distribution</p></a></li>
<li><a href='#random.StudentsT'><p>Draw a random sample from a StudentsT distribution</p></a></li>
<li><a href='#random.Tukey'><p>Draw a random sample from a Tukey distribution</p></a></li>
<li><a href='#random.Uniform'><p>Draw a random sample from a continuous Uniform distribution</p></a></li>
<li><a href='#random.Weibull'><p>Draw a random sample from a Weibull distribution</p></a></li>
<li><a href='#random.ZINegativeBinomial'><p>Draw a random sample from a zero-inflated negative binomial distribution</p></a></li>
<li><a href='#random.ZIPoisson'><p>Draw a random sample from a zero-inflated Poisson distribution</p></a></li>
<li><a href='#random.ZTNegativeBinomial'><p>Draw a random sample from a zero-truncated negative binomial distribution</p></a></li>
<li><a href='#random.ZTPoisson'><p>Draw a random sample from a zero-truncated Poisson distribution</p></a></li>
<li><a href='#RevWeibull'><p>Create a reversed Weibull distribution</p></a></li>
<li><a href='#stat_auc'><p>Fill out area under the curve for a plotted PDF</p></a></li>
<li><a href='#StudentsT'><p>Create a Student's T distribution</p></a></li>
<li><a href='#suff_stat'><p>Compute the sufficient statistics of a distribution from data</p></a></li>
<li><a href='#suff_stat.Bernoulli'><p>Compute the sufficient statistics for a Bernoulli distribution from data</p></a></li>
<li><a href='#suff_stat.Binomial'><p>Compute the sufficient statistics for the Binomial distribution from data</p></a></li>
<li><a href='#suff_stat.Exponential'><p>Compute the sufficient statistics of an Exponential distribution from data</p></a></li>
<li><a href='#suff_stat.Gamma'><p>Compute the sufficient statistics for a Gamma distribution from data</p></a></li>
<li><a href='#suff_stat.Geometric'><p>Compute the sufficient statistics for the Geometric distribution from data</p></a></li>
<li><a href='#suff_stat.LogNormal'><p>Compute the sufficient statistics for a Log-normal distribution from data</p></a></li>
<li><a href='#suff_stat.Normal'><p>Compute the sufficient statistics for a Normal distribution from data</p></a></li>
<li><a href='#suff_stat.Poisson'><p>Compute the sufficient statistics of an Poisson distribution from data</p></a></li>
<li><a href='#support'><p>Return the support of a distribution</p></a></li>
<li><a href='#support.Bernoulli'><p>Return the support of the Bernoulli distribution</p></a></li>
<li><a href='#support.Beta'><p>Return the support of the Beta distribution</p></a></li>
<li><a href='#support.Binomial'><p>Return the support of the Binomial distribution</p></a></li>
<li><a href='#support.Cauchy'><p>Return the support of the Cauchy distribution</p></a></li>
<li><a href='#support.ChiSquare'><p>Return the support of the ChiSquare distribution</p></a></li>
<li><a href='#support.Erlang'><p>Return the support of the Erlang distribution</p></a></li>
<li><a href='#support.Exponential'><p>Return the support of the Exponential distribution</p></a></li>
<li><a href='#support.FisherF'><p>Return the support of the FisherF distribution</p></a></li>
<li><a href='#support.Frechet'><p>Return the support of the Frechet distribution</p></a></li>
<li><a href='#support.Gamma'><p>Return the support of the Gamma distribution</p></a></li>
<li><a href='#support.Geometric'><p>Return the support of the Geometric distribution</p></a></li>
<li><a href='#support.GEV'><p>Return the support of a GEV distribution</p></a></li>
<li><a href='#support.GP'><p>Return the support of the GP distribution</p></a></li>
<li><a href='#support.Gumbel'><p>Return the support of the Gumbel distribution</p></a></li>
<li><a href='#support.HurdleNegativeBinomial'><p>Return the support of the hurdle negative binomial distribution</p></a></li>
<li><a href='#support.HurdlePoisson'><p>Return the support of the hurdle Poisson distribution</p></a></li>
<li><a href='#support.HyperGeometric'><p>Return the support of the HyperGeometric distribution</p></a></li>
<li><a href='#support.Logistic'><p>Return the support of the Logistic distribution</p></a></li>
<li><a href='#support.LogNormal'><p>Return the support of the LogNormal distribution</p></a></li>
<li><a href='#support.NegativeBinomial'><p>Return the support of the NegativeBinomial distribution</p></a></li>
<li><a href='#support.Normal'><p>Return the support of the Normal distribution</p></a></li>
<li><a href='#support.Poisson'><p>Return the support of the Poisson distribution</p></a></li>
<li><a href='#support.RevWeibull'><p>Return the support of the RevWeibull distribution</p></a></li>
<li><a href='#support.StudentsT'><p>Return the support of the StudentsT distribution</p></a></li>
<li><a href='#support.Tukey'><p>Return the support of the Tukey distribution</p></a></li>
<li><a href='#support.Uniform'><p>Return the support of the Uniform distribution</p></a></li>
<li><a href='#support.Weibull'><p>Return the support of the Weibull distribution</p></a></li>
<li><a href='#support.ZINegativeBinomial'><p>Return the support of the zero-inflated negative binomial distribution</p></a></li>
<li><a href='#support.ZIPoisson'><p>Return the support of the zero-inflated Poisson distribution</p></a></li>
<li><a href='#support.ZTNegativeBinomial'><p>Return the support of the zero-truncated negative binomial distribution</p></a></li>
<li><a href='#support.ZTPoisson'><p>Return the support of the zero-truncated Poisson distribution</p></a></li>
<li><a href='#Tukey'><p>Create a Tukey distribution</p></a></li>
<li><a href='#Uniform'><p>Create a Continuous Uniform distribution</p></a></li>
<li><a href='#variance'><p>Compute the moments of a probability distribution</p></a></li>
<li><a href='#Weibull'><p>Create a Weibull distribution</p></a></li>
<li><a href='#ZINegativeBinomial'><p>Create a zero-inflated negative binomial distribution</p></a></li>
<li><a href='#ZIPoisson'><p>Create a zero-inflated Poisson distribution</p></a></li>
<li><a href='#ZTNegativeBinomial'><p>Create a zero-truncated negative binomial distribution</p></a></li>
<li><a href='#ZTPoisson'><p>Create a zero-truncated Poisson distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Probability Distributions as S3 Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to create and manipulate probability distributions
    using S3.  Generics pdf(), cdf(), quantile(), and random() provide
    replacements for base R's d/p/q/r style functions.  Functions and
    arguments have been named carefully to minimize confusion for students
    in intro stats courses. The documentation for each distribution
    contains detailed mathematical notes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexpghayes/distributions3">https://github.com/alexpghayes/distributions3</a>,
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alexpghayes/distributions3/issues">https://github.com/alexpghayes/distributions3/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ellipsis, ggplot2, glue</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, cowplot, knitr, revdbayes (&ge; 1.3.5), rmarkdown,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1.9000</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-07 04:17:10 UTC; alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Hayes <a href="https://orcid.org/0000-0002-4985-5160"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Ralph Moller-Trane [aut],
  Emil Hvitfeldt <a href="https://orcid.org/0000-0002-0679-1945"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Daniel Jordan [aut],
  Paul Northrop [aut],
  Moritz N. Lang <a href="https://orcid.org/0000-0002-2533-9903"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bruna Wundervald [ctb],
  Alessandro Gasparini [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Hayes &lt;alexpghayes@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-07 06:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply_dpqr'>Utilities for <code>distributions3</code> objects</h2><span id='topic+apply_dpqr'></span><span id='topic+make_support'></span><span id='topic+make_positive_integer'></span>

<h3>Description</h3>

<p>Various utility functions to implement methods for distributions with a
unified workflow, in particular to facilitate working with vectorized
<code>distributions3</code> objects.
These are particularly useful in the computation of densities, probabilities, quantiles,
and random samples when classical d/p/q/r functions are readily available for
the distribution of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_dpqr(d, FUN, at, elementwise = NULL, drop = TRUE, type = NULL, ...)

make_support(min, max, d, drop = TRUE)

make_positive_integer(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_dpqr_+3A_d">d</code></td>
<td>
<p>A <code>distributions3</code> object.</p>
</td></tr>
<tr><td><code id="apply_dpqr_+3A_fun">FUN</code></td>
<td>
<p>Function to be computed. Function should be of type <code>FUN(at, d)</code>, where
<code>at</code> is the argument at which the function should be evaluated (e.g., a quantile,
probability, or sample size) and <code>d</code> is a <code>distributions3</code> object.</p>
</td></tr>
<tr><td><code id="apply_dpqr_+3A_at">at</code></td>
<td>
<p>Specification of values at which <code>FUN</code> should be evaluated, typically a
numeric vector (e.g., of quantiles, probabilities, etc.) but possibly also a matrix or data
frame.</p>
</td></tr>
<tr><td><code id="apply_dpqr_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each element of <code>d</code> only be evaluated at the
corresponding element of <code>at</code> (<code>elementwise = TRUE</code>) or at all elements
in <code>at</code> (<code>elementwise = FALSE</code>). Elementwise evaluation is only possible
if the length of <code>d</code> and <code>at</code> is the same and in that case a vector of
the same length is returned. Otherwise a matrix is returned. The default is to use
<code>elementwise = TRUE</code> if possible, and otherwise <code>elementwise = FALSE</code>.</p>
</td></tr>
<tr><td><code id="apply_dpqr_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible (by
dropping the dimension attribute)? If <code>FALSE</code> a matrix is always returned.</p>
</td></tr>
<tr><td><code id="apply_dpqr_+3A_type">type</code></td>
<td>
<p>Character string used for naming, typically one of <code>"density"</code>, <code>"logLik"</code>,
<code>"probability"</code>, <code>"quantile"</code>, and <code>"random"</code>. Note that the <code>"random"</code>
case is processed differently internally in order to vectorize the random number
generation more efficiently.</p>
</td></tr>
<tr><td><code id="apply_dpqr_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to  <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="apply_dpqr_+3A_min">min</code>, <code id="apply_dpqr_+3A_max">max</code></td>
<td>
<p>Numeric vectors. Minima and maxima of the supports of a <code>distributions3</code> object.</p>
</td></tr>
<tr><td><code id="apply_dpqr_+3A_n">n</code></td>
<td>
<p>numeric. Number of observations for computing random draws. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required (consistent with base R as, e.g., for <code>rnorm()</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Implementing a new distribution based on the provided utility functions
## Illustration: Gaussian distribution
## Note: Gaussian() is really just a copy of Normal() with a different class/distribution name


## Generator function for the distribution object.
Gaussian &lt;- function(mu = 0, sigma = 1) {
  stopifnot(
    "parameter lengths do not match (only scalars are allowed to be recycled)" =
      length(mu) == length(sigma) | length(mu) == 1 | length(sigma) == 1
  )
  d &lt;- data.frame(mu = mu, sigma = sigma)
  class(d) &lt;- c("Gaussian", "distribution")
  d
}

## Set up a vector Y containing four Gaussian distributions:
Y &lt;- Gaussian(mu = 1:4, sigma = c(1, 1, 2, 2))
Y

## Extract the underlying parameters:
as.matrix(Y)


## Extractor functions for moments of the distribution include
## mean(), variance(), skewness(), kurtosis().
## These can be typically be defined as functions of the list of parameters.
mean.Gaussian &lt;- function(x, ...) {
  ellipsis::check_dots_used()
  setNames(x$mu, names(x))
}
## Analogously for other moments, see distributions3:::variance.Normal etc.

mean(Y)


## The support() method should return a matrix of "min" and "max" for the
## distribution. The make_support() function helps to set the right names and
## dimension.
support.Gaussian &lt;- function(d, drop = TRUE, ...) {
  min &lt;- rep(-Inf, length(d))
  max &lt;- rep(Inf, length(d))
  make_support(min, max, d, drop = drop)
}

support(Y)


## Evaluating certain functions associated with the distribution, e.g.,
## pdf(), log_pdf(), cdf() quantile(), random(), etc. The apply_dpqr()
## function helps to call the typical d/p/q/r functions (like dnorm,
## pnorm, etc.) and set suitable names and dimension.
pdf.Gaussian &lt;- function(d, x, elementwise = NULL, drop = TRUE, ...) {
  FUN &lt;- function(at, d) dnorm(x = at, mean = d$mu, sd = d$sigma, ...)
  apply_dpqr(d = d, FUN = FUN, at = x, type = "density", elementwise = elementwise, drop = drop)
}

## Evaluate all densities at the same argument (returns vector):
pdf(Y, 0)

## Evaluate all densities at several arguments (returns matrix):
pdf(Y, c(0, 5))

## Evaluate each density at a different argument (returns vector):
pdf(Y, 4:1)

## Force evaluation of each density at a different argument (returns vector)
## or at all arguments (returns matrix):
pdf(Y, 4:1, elementwise = TRUE)
pdf(Y, 4:1, elementwise = FALSE)

## Drawing random() samples also uses apply_dpqr() with the argument
## n assured to be a positive integer.
random.Gaussian &lt;- function(x, n = 1L, drop = TRUE, ...) {
  n &lt;- make_positive_integer(n)
  if (n == 0L) {
    return(numeric(0L))
  }
  FUN &lt;- function(at, d) rnorm(n = at, mean = d$mu, sd = d$sigma)
  apply_dpqr(d = x, FUN = FUN, at = n, type = "random", drop = drop)
}

## One random sample for each distribution (returns vector):
random(Y, 1)

## Several random samples for each distribution (returns matrix):
random(Y, 3)


## For further analogous methods see the "Normal" distribution provided
## in distributions3.
methods(class = "Normal")

</code></pre>

<hr>
<h2 id='Bernoulli'>Create a Bernoulli distribution</h2><span id='topic+Bernoulli'></span>

<h3>Description</h3>

<p>Bernoulli distributions are used to represent events like coin flips
when there is single trial that is either successful or unsuccessful.
The Bernoulli distribution is a special case of the <code><a href="#topic+Binomial">Binomial()</a></code>
distribution with <code>n = 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bernoulli(p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bernoulli_+3A_p">p</code></td>
<td>
<p>The success probability for the distribution. <code>p</code> can be any
value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>, and defaults to <code>0.5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail.
</p>
<p>In the following, let <code class="reqn">X</code> be a Bernoulli random variable with parameter
<code>p</code> = <code class="reqn">p</code>. Some textbooks also define <code class="reqn">q = 1 - p</code>, or use
<code class="reqn">\pi</code> instead of <code class="reqn">p</code>.
</p>
<p>The Bernoulli probability  distribution is widely used to model
binary variables, such as 'failure' and 'success'. The most
typical example is the flip of a coin, when  <code class="reqn">p</code> is thought as the
probability of flipping a head, and <code class="reqn">q = 1 - p</code> is the
probability of flipping a tail.
</p>
<p><strong>Support</strong>: <code class="reqn">\{0, 1\}</code>
</p>
<p><strong>Mean</strong>: <code class="reqn">p</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">p \cdot (1 - p) = p \cdot q</code>
</p>
<p><strong>Probability mass function (p.m.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = x) = p^x (1 - p)^{1-x} = p^x q^{1-x}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X \le x) =
    \left \{
      \begin{array}{ll}
        0 &amp; x &lt; 0 \\
        1 - p &amp; 0 \leq x &lt; 1 \\
        1 &amp; x \geq 1
      \end{array}
    \right.
  </code>
</p>

<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    E(e^{tX}) = (1 - p) + p e^t
  </code>
</p>



<h3>Value</h3>

<p>A <code>Bernoulli</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Bernoulli(0.7)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)
pdf(X, 1)
log_pdf(X, 1)
cdf(X, 0)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='Beta'>Create a Beta distribution</h2><span id='topic+Beta'></span>

<h3>Description</h3>

<p>Create a Beta distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Beta(alpha = 1, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Beta_+3A_alpha">alpha</code></td>
<td>
<p>The alpha parameter. <code>alpha</code> can be any value strictly
greater than zero. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="Beta_+3A_beta">beta</code></td>
<td>
<p>The beta parameter. <code>beta</code> can be any value strictly
greater than zero. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>beta</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Beta(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

mean(X)
variance(X)
skewness(X)
kurtosis(X)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='Binomial'>Create a Binomial distribution</h2><span id='topic+Binomial'></span>

<h3>Description</h3>

<p>Binomial distributions are used to represent situations can that can
be thought as the result of <code class="reqn">n</code> Bernoulli experiments (here the
<code class="reqn">n</code> is defined as the <code>size</code> of the experiment). The classical
example is <code class="reqn">n</code> independent coin flips, where each coin flip has
probability <code>p</code> of success. In this case, the individual probability of
flipping heads or tails is given by the  Bernoulli(p) distribution,
and the probability of having <code class="reqn">x</code> equal results (<code class="reqn">x</code> heads,
for example), in <code class="reqn">n</code> trials is given by the Binomial(n, p) distribution.
The equation of the Binomial distribution is directly derived from
the equation of the Bernoulli distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Binomial(size, p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Binomial_+3A_size">size</code></td>
<td>
<p>The number of trials. Must be an integer greater than or equal
to one. When <code>size = 1L</code>, the Binomial distribution reduces to the
bernoulli distribution. Often called <code>n</code> in textbooks.</p>
</td></tr>
<tr><td><code id="Binomial_+3A_p">p</code></td>
<td>
<p>The success probability for a given trial. <code>p</code> can be any
value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>, and defaults to <code>0.5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Binomial distribution comes up when you are interested in the portion
of people who do a thing. The Binomial distribution
also comes up in the sign test, sometimes called the Binomial test
(see <code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>), where you may need the Binomial C.D.F. to
compute p-values.
</p>
<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail.
</p>
<p>In the following, let <code class="reqn">X</code> be a Binomial random variable with parameter
<code>size</code> = <code class="reqn">n</code> and <code>p</code> = <code class="reqn">p</code>. Some textbooks define <code class="reqn">q = 1 - p</code>,
or called <code class="reqn">\pi</code> instead of <code class="reqn">p</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">\{0, 1, 2, ..., n\}</code>
</p>
<p><strong>Mean</strong>: <code class="reqn">np</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">np \cdot (1 - p) = np \cdot q</code>
</p>
<p><strong>Probability mass function (p.m.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = {n \choose k} p^k (1 - p)^{n-k}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X \le k) = \sum_{i=0}^{\lfloor k \rfloor} {n \choose i} p^i (1 - p)^{n-i}
  </code>
</p>

<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    E(e^{tX}) = (1 - p + p e^t)^n
  </code>
</p>



<h3>Value</h3>

<p>A <code>Binomial</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Binomial(10, 0.2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2L)
log_pdf(X, 2L)

cdf(X, 4L)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='Categorical'>Create a Categorical distribution</h2><span id='topic+Categorical'></span>

<h3>Description</h3>

<p>Create a Categorical distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Categorical(outcomes, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Categorical_+3A_outcomes">outcomes</code></td>
<td>
<p>A vector specifying the elements in the sample
space. Can be numeric, factor, character, or logical.</p>
</td></tr>
<tr><td><code id="Categorical_+3A_p">p</code></td>
<td>
<p>A vector of success probabilities for each outcome.
Each element of <code>p</code> can be any positive value &ndash; the vector gets
normalized internally. Defaults to <code>NULL</code>, in which case the
distribution is assumed to be uniform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Categorical</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Categorical(1:3, p = c(0.4, 0.1, 0.5))
X

Y &lt;- Categorical(LETTERS[1:4])
Y

random(X, 10)
random(Y, 10)

pdf(X, 1)
log_pdf(X, 1)

cdf(X, 1)
quantile(X, 0.5)

# cdfs are only defined for numeric sample spaces. this errors!
# cdf(Y, "a")

# same for quantiles. this also errors!
# quantile(Y, 0.7)
</code></pre>

<hr>
<h2 id='Cauchy'>Create a Cauchy distribution</h2><span id='topic+Cauchy'></span>

<h3>Description</h3>

<p>Note that the Cauchy distribution is the student's t distribution
with one degree of freedom. The Cauchy distribution does not have
a well defined mean or variance. Cauchy distributions often appear
as priors in Bayesian contexts due to their heavy tails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cauchy(location = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cauchy_+3A_location">location</code></td>
<td>
<p>The location parameter. Can be any real number. Defaults
to <code>0</code>.</p>
</td></tr>
<tr><td><code id="Cauchy_+3A_scale">scale</code></td>
<td>
<p>The scale parameter. Must be greater than zero (?). Defaults
to <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a Cauchy variable with mean
<code style="white-space: pre;">&#8288;location =&#8288;</code> <code class="reqn">x_0</code> and <code>scale</code> = <code class="reqn">\gamma</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">R</code>, the set of all real numbers
</p>
<p><strong>Mean</strong>: Undefined.
</p>
<p><strong>Variance</strong>: Undefined.
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{1}{\pi \gamma \left[1 + \left(\frac{x - x_0}{\gamma} \right)^2 \right]}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    F(t) = \frac{1}{\pi} \arctan \left( \frac{t - x_0}{\gamma} \right) +
      \frac{1}{2}
  </code>
</p>

<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p>Does not exist.
</p>


<h3>Value</h3>

<p>A <code>Cauchy</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Cauchy(10, 0.2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 2)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='cdf'>Evaluate the cumulative distribution function of a probability distribution</h2><span id='topic+cdf'></span>

<h3>Description</h3>

<p>Generic function for computing probabilities from distribution objects based
on the cumulative distribution function (CDF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf(d, x, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf_+3A_d">d</code></td>
<td>
<p>An object. The package provides methods for distribution
objects such as those from <code><a href="#topic+Normal">Normal()</a></code> or <code><a href="#topic+Binomial">Binomial()</a></code> etc.</p>
</td></tr>
<tr><td><code id="cdf_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probabilities corresponding to the vector <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## distribution object
X &lt;- Normal()
## probabilities from CDF
cdf(X, c(1, 2, 3, 4, 5))
</code></pre>

<hr>
<h2 id='cdf.Bernoulli'>Evaluate the cumulative distribution function of a Bernoulli distribution</h2><span id='topic+cdf.Bernoulli'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Bernoulli distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bernoulli'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Bernoulli_+3A_d">d</code></td>
<td>
<p>A <code>Bernoulli</code> object created by a call to <code><a href="#topic+Bernoulli">Bernoulli()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Bernoulli_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Bernoulli_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Bernoulli_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Bernoulli_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pbinom">pbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Bernoulli(0.7)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)
pdf(X, 1)
log_pdf(X, 1)
cdf(X, 0)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='cdf.Beta'>Evaluate the cumulative distribution function of a Beta distribution</h2><span id='topic+cdf.Beta'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Beta distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Beta'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Beta_+3A_d">d</code></td>
<td>
<p>A <code>Beta</code> object created by a call to <code><a href="#topic+Beta">Beta()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Beta_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Beta_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Beta_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Beta_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pbeta">pbeta</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Beta(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

mean(X)
variance(X)
skewness(X)
kurtosis(X)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='cdf.Binomial'>Evaluate the cumulative distribution function of a Binomial distribution</h2><span id='topic+cdf.Binomial'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Binomial'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Binomial_+3A_d">d</code></td>
<td>
<p>A <code>Binomial</code> object created by a call to <code><a href="#topic+Binomial">Binomial()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Binomial_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Binomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Binomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Binomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pbinom">pbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Binomial(10, 0.2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2L)
log_pdf(X, 2L)

cdf(X, 4L)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='cdf.Categorical'>Evaluate the cumulative distribution function of a Categorical distribution</h2><span id='topic+cdf.Categorical'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Categorical distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Categorical'
cdf(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Categorical_+3A_d">d</code></td>
<td>
<p>A <code>Categorical</code> object created by a call to <code><a href="#topic+Categorical">Categorical()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Categorical_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Categorical_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of probabilities, one for each element of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Categorical(1:3, p = c(0.4, 0.1, 0.5))
X

Y &lt;- Categorical(LETTERS[1:4])
Y

random(X, 10)
random(Y, 10)

pdf(X, 1)
log_pdf(X, 1)

cdf(X, 1)
quantile(X, 0.5)

# cdfs are only defined for numeric sample spaces. this errors!
# cdf(Y, "a")

# same for quantiles. this also errors!
# quantile(Y, 0.7)
</code></pre>

<hr>
<h2 id='cdf.Cauchy'>Evaluate the cumulative distribution function of a Cauchy distribution</h2><span id='topic+cdf.Cauchy'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Cauchy distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cauchy'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Cauchy_+3A_d">d</code></td>
<td>
<p>A <code>Cauchy</code> object created by a call to <code><a href="#topic+Cauchy">Cauchy()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Cauchy_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Cauchy_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Cauchy_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Cauchy_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pcauchy">pcauchy</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Cauchy(10, 0.2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 2)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='cdf.ChiSquare'>Evaluate the cumulative distribution function of a chi square distribution</h2><span id='topic+cdf.ChiSquare'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a chi square distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ChiSquare'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.ChiSquare_+3A_d">d</code></td>
<td>
<p>A <code>ChiSquare</code> object created by a call to <code><a href="#topic+ChiSquare">ChiSquare()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.ChiSquare_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.ChiSquare_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.ChiSquare_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.ChiSquare_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pchisq">pchisq</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- ChiSquare(5)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='cdf.Erlang'>Evaluate the cumulative distribution function of an Erlang distribution</h2><span id='topic+cdf.Erlang'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of an Erlang distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Erlang'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Erlang_+3A_d">d</code></td>
<td>
<p>An <code>Erlang</code> object created by a call to <code><a href="#topic+Erlang">Erlang()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Erlang_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Erlang_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Erlang_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Erlang_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pgamma">pgamma</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Erlang(5, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='cdf.Exponential'>Evaluate the cumulative distribution function of an Exponential distribution</h2><span id='topic+cdf.Exponential'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of an Exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Exponential'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Exponential_+3A_d">d</code></td>
<td>
<p>An <code>Exponential</code> object created by a call to <code><a href="#topic+Exponential">Exponential()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Exponential_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Exponential_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Exponential_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Exponential_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pexp">pexp</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Exponential(5)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='cdf.FisherF'>Evaluate the cumulative distribution function of an F distribution</h2><span id='topic+cdf.FisherF'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of an F distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FisherF'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.FisherF_+3A_d">d</code></td>
<td>
<p>A <code>FisherF</code> object created by a call to <code><a href="#topic+FisherF">FisherF()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.FisherF_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.FisherF_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.FisherF_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.FisherF_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pf">pf</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- FisherF(5, 10, 0.2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='cdf.Frechet'>Evaluate the cumulative distribution function of a Frechet distribution</h2><span id='topic+cdf.Frechet'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Frechet distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Frechet'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Frechet_+3A_d">d</code></td>
<td>
<p>A <code>Frechet</code> object created by a call to <code><a href="#topic+Frechet">Frechet()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Frechet_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Frechet_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Frechet_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Frechet_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+pgev">pgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Frechet(0, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='cdf.Gamma'>Evaluate the cumulative distribution function of a Gamma distribution</h2><span id='topic+cdf.Gamma'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gamma'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Gamma_+3A_d">d</code></td>
<td>
<p>A <code>Gamma</code> object created by a call to <code><a href="#topic+Gamma">Gamma()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Gamma_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Gamma_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Gamma_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Gamma_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pgamma">pgamma</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Gamma(5, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='cdf.Geometric'>Evaluate the cumulative distribution function of a Geometric distribution</h2><span id='topic+cdf.Geometric'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Geometric distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Geometric'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Geometric_+3A_d">d</code></td>
<td>
<p>A <code>Geometric</code> object created by a call to <code><a href="#topic+Geometric">Geometric()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Geometric_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Geometric_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Geometric_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Geometric_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pgeom">pgeom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other Geometric distribution: 
<code><a href="#topic+pdf.Geometric">pdf.Geometric</a>()</code>,
<code><a href="#topic+quantile.Geometric">quantile.Geometric</a>()</code>,
<code><a href="#topic+random.Geometric">random.Geometric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Geometric(0.3)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='cdf.GEV'>Evaluate the cumulative distribution function of a GEV distribution</h2><span id='topic+cdf.GEV'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a GEV distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GEV'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.GEV_+3A_d">d</code></td>
<td>
<p>A <code>GEV</code> object created by a call to <code><a href="#topic+GEV">GEV()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.GEV_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.GEV_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.GEV_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.GEV_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+pgev">pgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- GEV(1, 2, 0.1)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='cdf.GP'>Evaluate the cumulative distribution function of a GP distribution</h2><span id='topic+cdf.GP'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a GP distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GP'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.GP_+3A_d">d</code></td>
<td>
<p>A <code>GP</code> object created by a call to <code><a href="#topic+GP">GP()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.GP_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.GP_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.GP_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.GP_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+pgp">pgp</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- GP(0, 2, 0.1)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='cdf.Gumbel'>Evaluate the cumulative distribution function of a Gumbel distribution</h2><span id='topic+cdf.Gumbel'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Gumbel distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gumbel'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Gumbel_+3A_d">d</code></td>
<td>
<p>A <code>Gumbel</code> object created by a call to <code><a href="#topic+Gumbel">Gumbel()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Gumbel_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Gumbel_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Gumbel_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Gumbel_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+pgev">pgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Gumbel(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='cdf.HurdleNegativeBinomial'>Evaluate the cumulative distribution function of a hurdle negative binomial distribution</h2><span id='topic+cdf.HurdleNegativeBinomial'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a hurdle negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HurdleNegativeBinomial'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.HurdleNegativeBinomial_+3A_d">d</code></td>
<td>
<p>A <code>HurdleNegativeBinomial</code> object created by a call to <code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.HurdleNegativeBinomial_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.HurdleNegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.HurdleNegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.HurdleNegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+phnbinom">phnbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a hurdle negative binomial distribution
X &lt;- HurdleNegativeBinomial(mu = 2.5, theta = 1, pi = 0.75)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='cdf.HurdlePoisson'>Evaluate the cumulative distribution function of a hurdle Poisson distribution</h2><span id='topic+cdf.HurdlePoisson'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a hurdle Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HurdlePoisson'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.HurdlePoisson_+3A_d">d</code></td>
<td>
<p>A <code>HurdlePoisson</code> object created by a call to <code><a href="#topic+HurdlePoisson">HurdlePoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.HurdlePoisson_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.HurdlePoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.HurdlePoisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.HurdlePoisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+phpois">phpois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a hurdle Poisson distribution
X &lt;- HurdlePoisson(lambda = 2.5, pi = 0.75)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='cdf.HyperGeometric'>Evaluate the cumulative distribution function of a HyperGeometric distribution</h2><span id='topic+cdf.HyperGeometric'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a HyperGeometric distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HyperGeometric'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.HyperGeometric_+3A_d">d</code></td>
<td>
<p>A <code>HyperGeometric</code> object created by a call to <code><a href="#topic+HyperGeometric">HyperGeometric()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.HyperGeometric_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.HyperGeometric_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.HyperGeometric_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.HyperGeometric_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+phyper">phyper</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other HyperGeometric distribution: 
<code><a href="#topic+pdf.HyperGeometric">pdf.HyperGeometric</a>()</code>,
<code><a href="#topic+quantile.HyperGeometric">quantile.HyperGeometric</a>()</code>,
<code><a href="#topic+random.HyperGeometric">random.HyperGeometric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- HyperGeometric(4, 5, 8)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='cdf.Logistic'>Evaluate the cumulative distribution function of a Logistic distribution</h2><span id='topic+cdf.Logistic'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Logistic distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Logistic'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Logistic_+3A_d">d</code></td>
<td>
<p>A <code>Logistic</code> object created by a call to <code><a href="#topic+Logistic">Logistic()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Logistic_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Logistic_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Logistic_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Logistic_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+plogis">plogis</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other Logistic distribution: 
<code><a href="#topic+pdf.Logistic">pdf.Logistic</a>()</code>,
<code><a href="#topic+quantile.Logistic">quantile.Logistic</a>()</code>,
<code><a href="#topic+random.Logistic">random.Logistic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Logistic(2, 4)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='cdf.LogNormal'>Evaluate the cumulative distribution function of a LogNormal distribution</h2><span id='topic+cdf.LogNormal'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a LogNormal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LogNormal'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.LogNormal_+3A_d">d</code></td>
<td>
<p>A <code>LogNormal</code> object created by a call to <code><a href="#topic+LogNormal">LogNormal()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.LogNormal_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.LogNormal_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.LogNormal_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.LogNormal_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+plnorm">plnorm</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other LogNormal distribution: 
<code><a href="#topic+fit_mle.LogNormal">fit_mle.LogNormal</a>()</code>,
<code><a href="#topic+pdf.LogNormal">pdf.LogNormal</a>()</code>,
<code><a href="#topic+quantile.LogNormal">quantile.LogNormal</a>()</code>,
<code><a href="#topic+random.LogNormal">random.LogNormal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- LogNormal(0.3, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='cdf.NegativeBinomial'>Evaluate the cumulative distribution function of a negative binomial distribution</h2><span id='topic+cdf.NegativeBinomial'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NegativeBinomial'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.NegativeBinomial_+3A_d">d</code></td>
<td>
<p>A <code>NegativeBinomial</code> object created by a call to
<code><a href="#topic+NegativeBinomial">NegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.NegativeBinomial_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.NegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.NegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.NegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pnbinom">pnbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other NegativeBinomial distribution: 
<code><a href="#topic+pdf.NegativeBinomial">pdf.NegativeBinomial</a>()</code>,
<code><a href="#topic+quantile.NegativeBinomial">quantile.NegativeBinomial</a>()</code>,
<code><a href="#topic+random.NegativeBinomial">random.NegativeBinomial</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- NegativeBinomial(size = 5, p = 0.1)
X

random(X, 10)

pdf(X, 50)
log_pdf(X, 50)

cdf(X, 50)
quantile(X, 0.7)

## alternative parameterization of X
Y &lt;- NegativeBinomial(mu = 45, size = 5)
Y
cdf(Y, 50)
quantile(Y, 0.7)
</code></pre>

<hr>
<h2 id='cdf.Normal'>Evaluate the cumulative distribution function of a Normal distribution</h2><span id='topic+cdf.Normal'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Normal'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Normal_+3A_d">d</code></td>
<td>
<p>A <code>Normal</code> object created by a call to <code><a href="#topic+Normal">Normal()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Normal_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Normal_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Normal_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Normal_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pnorm">pnorm</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other Normal distribution: 
<code><a href="#topic+fit_mle.Normal">fit_mle.Normal</a>()</code>,
<code><a href="#topic+pdf.Normal">pdf.Normal</a>()</code>,
<code><a href="#topic+quantile.Normal">quantile.Normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Normal(5, 2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

### example: calculating p-values for two-sided Z-test

# here the null hypothesis is H_0: mu = 3
# and we assume sigma = 2

# exactly the same as: Z &lt;- Normal(0, 1)
Z &lt;- Normal()

# data to test
x &lt;- c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2)
nx &lt;- length(x)

# calculate the z-statistic
z_stat &lt;- (mean(x) - 3) / (2 / sqrt(nx))
z_stat

# calculate the two-sided p-value
1 - cdf(Z, abs(z_stat)) + cdf(Z, -abs(z_stat))

# exactly equivalent to the above
2 * cdf(Z, -abs(z_stat))

# p-value for one-sided test
# H_0: mu &lt;= 3   vs   H_A: mu &gt; 3
1 - cdf(Z, z_stat)

# p-value for one-sided test
# H_0: mu &gt;= 3   vs   H_A: mu &lt; 3
cdf(Z, z_stat)

### example: calculating a 88 percent Z CI for a mean

# same `x` as before, still assume `sigma = 2`

# lower-bound
mean(x) - quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# upper-bound
mean(x) + quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# equivalent to
mean(x) + c(-1, 1) * quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# also equivalent to
mean(x) + quantile(Z, 0.12 / 2) * 2 / sqrt(nx)
mean(x) + quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

### generating random samples and plugging in ks.test()

set.seed(27)

# generate a random sample
ns &lt;- random(Normal(3, 7), 26)

# test if sample is Normal(3, 7)
ks.test(ns, pnorm, mean = 3, sd = 7)

# test if sample is gamma(8, 3) using base R pgamma()
ks.test(ns, pgamma, shape = 8, rate = 3)

### MISC

# note that the cdf() and quantile() functions are inverses
cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='cdf.Poisson'>Evaluate the cumulative distribution function of a Poisson distribution</h2><span id='topic+cdf.Poisson'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Poisson'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Poisson_+3A_d">d</code></td>
<td>
<p>A <code>Poisson</code> object created by a call to <code><a href="#topic+Poisson">Poisson()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Poisson_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Poisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Poisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Poisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+ppois">ppois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Poisson(2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='cdf.RevWeibull'>Evaluate the cumulative distribution function of an RevWeibull distribution</h2><span id='topic+cdf.RevWeibull'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of an RevWeibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RevWeibull'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.RevWeibull_+3A_d">d</code></td>
<td>
<p>A <code>RevWeibull</code> object created by a call to <code><a href="#topic+RevWeibull">RevWeibull()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.RevWeibull_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.RevWeibull_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.RevWeibull_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.RevWeibull_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+pgev">pgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- RevWeibull(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='cdf.StudentsT'>Evaluate the cumulative distribution function of a StudentsT distribution</h2><span id='topic+cdf.StudentsT'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a StudentsT distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'StudentsT'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.StudentsT_+3A_d">d</code></td>
<td>
<p>A <code>StudentsT</code> object created by a call to <code><a href="#topic+StudentsT">StudentsT()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.StudentsT_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.StudentsT_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.StudentsT_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.StudentsT_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pt">pt</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other StudentsT distribution: 
<code><a href="#topic+pdf.StudentsT">pdf.StudentsT</a>()</code>,
<code><a href="#topic+quantile.StudentsT">quantile.StudentsT</a>()</code>,
<code><a href="#topic+random.StudentsT">random.StudentsT</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- StudentsT(3)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

### example: calculating p-values for two-sided T-test

# here the null hypothesis is H_0: mu = 3

# data to test
x &lt;- c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2)
nx &lt;- length(x)

# calculate the T-statistic
t_stat &lt;- (mean(x) - 3) / (sd(x) / sqrt(nx))
t_stat

# null distribution of statistic depends on sample size!
T &lt;- StudentsT(df = nx - 1)

# calculate the two-sided p-value
1 - cdf(T, abs(t_stat)) + cdf(T, -abs(t_stat))

# exactly equivalent to the above
2 * cdf(T, -abs(t_stat))

# p-value for one-sided test
# H_0: mu &lt;= 3   vs   H_A: mu &gt; 3
1 - cdf(T, t_stat)

# p-value for one-sided test
# H_0: mu &gt;= 3   vs   H_A: mu &lt; 3
cdf(T, t_stat)

### example: calculating a 88 percent T CI for a mean

# lower-bound
mean(x) - quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# upper-bound
mean(x) + quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# equivalent to
mean(x) + c(-1, 1) * quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# also equivalent to
mean(x) + quantile(T, 0.12 / 2) * sd(x) / sqrt(nx)
mean(x) + quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)
</code></pre>

<hr>
<h2 id='cdf.Tukey'>Evaluate the cumulative distribution function of a Tukey distribution</h2><span id='topic+cdf.Tukey'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Tukey distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Tukey'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Tukey_+3A_d">d</code></td>
<td>
<p>A <code>Tukey</code> distribution created by a call to <code><a href="#topic+Tukey">Tukey()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Tukey_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Tukey_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Tukey_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Tukey_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+ptukey">ptukey</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other Tukey distribution: 
<code><a href="#topic+quantile.Tukey">quantile.Tukey</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Tukey(4L, 16L, 2L)
X

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='cdf.Uniform'>Evaluate the cumulative distribution function of a continuous Uniform distribution</h2><span id='topic+cdf.Uniform'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a continuous Uniform distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Uniform'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Uniform_+3A_d">d</code></td>
<td>
<p>A <code>Uniform</code> object created by a call to <code><a href="#topic+Uniform">Uniform()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Uniform_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Uniform_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Uniform_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Uniform_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+punif">punif</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Uniform(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='cdf.Weibull'>Evaluate the cumulative distribution function of a Weibull distribution</h2><span id='topic+cdf.Weibull'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a Weibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Weibull'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.Weibull_+3A_d">d</code></td>
<td>
<p>A <code>Weibull</code> object created by a call to <code><a href="#topic+Weibull">Weibull()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.Weibull_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.Weibull_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.Weibull_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.Weibull_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+pweibull">pweibull</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other Weibull distribution: 
<code><a href="#topic+pdf.Weibull">pdf.Weibull</a>()</code>,
<code><a href="#topic+quantile.Weibull">quantile.Weibull</a>()</code>,
<code><a href="#topic+random.Weibull">random.Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Weibull(0.3, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='cdf.ZINegativeBinomial'>Evaluate the cumulative distribution function of a zero-inflated negative binomial distribution</h2><span id='topic+cdf.ZINegativeBinomial'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a zero-inflated negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZINegativeBinomial'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.ZINegativeBinomial_+3A_d">d</code></td>
<td>
<p>A <code>ZINegativeBinomial</code> object created by a call to <code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.ZINegativeBinomial_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.ZINegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.ZINegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.ZINegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+pzinbinom">pzinbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-inflated negative binomial distribution
X &lt;- ZINegativeBinomial(mu = 2.5, theta = 1, pi = 0.25)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='cdf.ZIPoisson'>Evaluate the cumulative distribution function of a zero-inflated Poisson distribution</h2><span id='topic+cdf.ZIPoisson'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a zero-inflated Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZIPoisson'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.ZIPoisson_+3A_d">d</code></td>
<td>
<p>A <code>ZIPoisson</code> object created by a call to <code><a href="#topic+ZIPoisson">ZIPoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.ZIPoisson_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.ZIPoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.ZIPoisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.ZIPoisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+pzipois">pzipois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-inflated Poisson distribution
X &lt;- ZIPoisson(lambda = 2.5, pi = 0.25)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='cdf.ZTNegativeBinomial'>Evaluate the cumulative distribution function of a zero-truncated negative binomial distribution</h2><span id='topic+cdf.ZTNegativeBinomial'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a zero-truncated negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZTNegativeBinomial'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.ZTNegativeBinomial_+3A_d">d</code></td>
<td>
<p>A <code>ZTNegativeBinomial</code> object created by a call to <code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.ZTNegativeBinomial_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.ZTNegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.ZTNegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.ZTNegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+pztnbinom">pztnbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-truncated negative binomial distribution
X &lt;- ZTNegativeBinomial(mu = 2.5, theta = 1)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='cdf.ZTPoisson'>Evaluate the cumulative distribution function of a zero-truncated Poisson distribution</h2><span id='topic+cdf.ZTPoisson'></span>

<h3>Description</h3>

<p>Evaluate the cumulative distribution function of a zero-truncated Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZTPoisson'
cdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.ZTPoisson_+3A_d">d</code></td>
<td>
<p>A <code>ZTPoisson</code> object created by a call to <code><a href="#topic+ZTPoisson">ZTPoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="cdf.ZTPoisson_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="cdf.ZTPoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="cdf.ZTPoisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="cdf.ZTPoisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+pztpois">pztpois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-truncated Poisson distribution
X &lt;- ZTPoisson(lambda = 2.5)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='ChiSquare'>Create a Chi-Square distribution</h2><span id='topic+ChiSquare'></span>

<h3>Description</h3>

<p>Chi-square distributions show up often in frequentist settings
as the sampling distribution of test statistics, especially
in maximum likelihood estimation settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChiSquare(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ChiSquare_+3A_df">df</code></td>
<td>
<p>Degrees of freedom. Must be positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a <code class="reqn">\chi^2</code> random variable with
<code>df</code> = <code class="reqn">k</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">R^+</code>, the set of positive real numbers
</p>
<p><strong>Mean</strong>: <code class="reqn">k</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">2k</code>
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-(x - \mu)^2 / 2 \sigma^2}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p>The cumulative distribution function has the form
</p>
<p style="text-align: center;"><code class="reqn">
    F(t) = \int_{-\infty}^t \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-(x - \mu)^2 / 2 \sigma^2} dx
  </code>
</p>

<p>but this integral does not have a closed form solution and must be
approximated numerically. The c.d.f. of a standard normal is sometimes
called the &quot;error function&quot;. The notation <code class="reqn">\Phi(t)</code> also stands
for the c.d.f. of a standard normal evaluated at <code class="reqn">t</code>. Z-tables
list the value of <code class="reqn">\Phi(t)</code> for various <code class="reqn">t</code>.
</p>
<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    E(e^{tX}) = e^{\mu t + \sigma^2 t^2 / 2}
  </code>
</p>



<h3>Value</h3>

<p>A <code>ChiSquare</code> object.
</p>


<h3>Transformations</h3>

<p>A squared standard <code><a href="#topic+Normal">Normal()</a></code> distribution is equivalent to a
<code class="reqn">\chi^2_1</code> distribution with one degree of freedom. The
<code class="reqn">\chi^2</code> distribution is a special case of the <code><a href="#topic+Gamma">Gamma()</a></code>
distribution with shape (TODO: check this) parameter equal
to a half. Sums of <code class="reqn">\chi^2</code> distributions
are also distributed as <code class="reqn">\chi^2</code> distributions, where the
degrees of freedom of the contributing distributions get summed.
The ratio of two <code class="reqn">\chi^2</code> distributions is a <code><a href="#topic+FisherF">FisherF()</a></code>
distribution. The ratio of a <code><a href="#topic+Normal">Normal()</a></code> and the square root
of a scaled <code><a href="#topic+ChiSquare">ChiSquare()</a></code> is a <code><a href="#topic+StudentsT">StudentsT()</a></code> distribution.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- ChiSquare(5)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='dhnbinom'>The hurdle negative binomial distribution</h2><span id='topic+dhnbinom'></span><span id='topic+phnbinom'></span><span id='topic+qhnbinom'></span><span id='topic+rhnbinom'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random
generation for the zero-hurdle negative binomial distribution with
parameters <code>mu</code>, <code>theta</code> (or <code>size</code>), and <code>pi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhnbinom(x, mu, theta, size, pi, log = FALSE)

phnbinom(q, mu, theta, size, pi, lower.tail = TRUE, log.p = FALSE)

qhnbinom(p, mu, theta, size, pi, lower.tail = TRUE, log.p = FALSE)

rhnbinom(n, mu, theta, size, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dhnbinom_+3A_x">x</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dhnbinom_+3A_mu">mu</code></td>
<td>
<p>vector of (non-negative) negative binomial location parameters.</p>
</td></tr>
<tr><td><code id="dhnbinom_+3A_theta">theta</code>, <code id="dhnbinom_+3A_size">size</code></td>
<td>
<p>vector of (non-negative) negative binomial overdispersion parameters.
Only <code>theta</code> or, equivalently, <code>size</code> may be specified.</p>
</td></tr>
<tr><td><code id="dhnbinom_+3A_pi">pi</code></td>
<td>
<p>vector of zero-hurdle probabilities in the unit interval.</p>
</td></tr>
<tr><td><code id="dhnbinom_+3A_log">log</code>, <code id="dhnbinom_+3A_log.p">log.p</code></td>
<td>
<p>logical indicating whether probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dhnbinom_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dhnbinom_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical indicating whether probabilities are <code class="reqn">P[X \le x]</code> (lower tail) or <code class="reqn">P[X &gt; x]</code> (upper tail).</p>
</td></tr>
<tr><td><code id="dhnbinom_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dhnbinom_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions follow the usual conventions of d/p/q/r functions
in base R. In particular, all four <code>hnbinom</code> functions for the
hurdle negative binomial distribution call the corresponding <code>nbinom</code>
functions for the negative binomial distribution from base R internally.
</p>
<p>Note, however, that the precision of <code>qhnbinom</code> for very large
probabilities (close to 1) is limited because the probabilities
are internally handled in levels and not in logs (even if <code>log.p = TRUE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a></code>, <code><a href="stats.html#topic+dnbinom">dnbinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## theoretical probabilities for a hurdle negative binomial distribution
x &lt;- 0:8
p &lt;- dhnbinom(x, mu = 2.5, theta = 1, pi = 0.75)
plot(x, p, type = "h", lwd = 2)

## corresponding empirical frequencies from a simulated sample
set.seed(0)
y &lt;- rhnbinom(500, mu = 2.5, theta = 1, pi = 0.75)
hist(y, breaks = -1:max(y) + 0.5)

</code></pre>

<hr>
<h2 id='dhpois'>The hurdle Poisson distribution</h2><span id='topic+dhpois'></span><span id='topic+phpois'></span><span id='topic+qhpois'></span><span id='topic+rhpois'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random
generation for the zero-hurdle Poisson distribution with
parameters <code>lambda</code> and <code>pi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhpois(x, lambda, pi, log = FALSE)

phpois(q, lambda, pi, lower.tail = TRUE, log.p = FALSE)

qhpois(p, lambda, pi, lower.tail = TRUE, log.p = FALSE)

rhpois(n, lambda, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dhpois_+3A_x">x</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dhpois_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) Poisson parameters.</p>
</td></tr>
<tr><td><code id="dhpois_+3A_pi">pi</code></td>
<td>
<p>vector of zero-hurdle probabilities in the unit interval.</p>
</td></tr>
<tr><td><code id="dhpois_+3A_log">log</code>, <code id="dhpois_+3A_log.p">log.p</code></td>
<td>
<p>logical indicating whether probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dhpois_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dhpois_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical indicating whether probabilities are <code class="reqn">P[X \le x]</code> (lower tail) or <code class="reqn">P[X &gt; x]</code> (upper tail).</p>
</td></tr>
<tr><td><code id="dhpois_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dhpois_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions follow the usual conventions of d/p/q/r functions
in base R. In particular, all four <code>hpois</code> functions for the
hurdle Poisson distribution call the corresponding <code>pois</code>
functions for the Poisson distribution from base R internally.
</p>
<p>Note, however, that the precision of <code>qhpois</code> for very large
probabilities (close to 1) is limited because the probabilities
are internally handled in levels and not in logs (even if <code>log.p = TRUE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HurdlePoisson">HurdlePoisson</a></code>, <code><a href="stats.html#topic+dpois">dpois</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## theoretical probabilities for a hurdle Poisson distribution
x &lt;- 0:8
p &lt;- dhpois(x, lambda = 2.5, pi = 0.75)
plot(x, p, type = "h", lwd = 2)

## corresponding empirical frequencies from a simulated sample
set.seed(0)
y &lt;- rhpois(500, lambda = 2.5, pi = 0.75)
hist(y, breaks = -1:max(y) + 0.5)

</code></pre>

<hr>
<h2 id='distributions3-package'>distributions3: Probability Distributions as S3 Objects</h2><span id='topic+distributions3'></span><span id='topic+distributions3-package'></span>

<h3>Description</h3>

<p>Tools to create and manipulate probability distributions using S3. Generics pdf(), cdf(), quantile(), and random() provide replacements for base R's d/p/q/r style functions. Functions and arguments have been named carefully to minimize confusion for students in intro stats courses. The documentation for each distribution contains detailed mathematical notes.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alex Hayes <a href="mailto:alexpghayes@gmail.com">alexpghayes@gmail.com</a> (<a href="https://orcid.org/0000-0002-4985-5160">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Ralph Moller-Trane
</p>
</li>
<li><p> Daniel Jordan <a href="mailto:dandermotj@gmail.com">dandermotj@gmail.com</a>
</p>
</li>
<li><p> Paul Northrop <a href="mailto:p.northrop@ucl.ac.uk">p.northrop@ucl.ac.uk</a>
</p>
</li>
<li><p> Moritz N. Lang <a href="mailto:moritz.n.lang@gmail.com">moritz.n.lang@gmail.com</a> (<a href="https://orcid.org/0000-0002-2533-9903">ORCID</a>)
</p>
</li>
<li><p> Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a> (<a href="https://orcid.org/0000-0003-0918-3766">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Emil Hvitfeldt <a href="mailto:emilhhvitfeldt@gmail.com">emilhhvitfeldt@gmail.com</a> (<a href="https://orcid.org/0000-0002-0679-1945">ORCID</a>) [contributor]
</p>
</li>
<li><p> Bruna Wundervald <a href="mailto:brunadaviesw@gmail.com">brunadaviesw@gmail.com</a> [contributor]
</p>
</li>
<li><p> Alessandro Gasparini <a href="mailto:alessandro.gasparini@ki.se">alessandro.gasparini@ki.se</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/alexpghayes/distributions3">https://github.com/alexpghayes/distributions3</a>
</p>
</li>
<li> <p><a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/alexpghayes/distributions3/issues">https://github.com/alexpghayes/distributions3/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dzinbinom'>The zero-inflated negative binomial distribution</h2><span id='topic+dzinbinom'></span><span id='topic+pzinbinom'></span><span id='topic+qzinbinom'></span><span id='topic+rzinbinom'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random
generation for the zero-inflated negative binomial distribution with
parameters <code>mu</code>, <code>theta</code> (or <code>size</code>), and <code>pi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzinbinom(x, mu, theta, size, pi, log = FALSE)

pzinbinom(q, mu, theta, size, pi, lower.tail = TRUE, log.p = FALSE)

qzinbinom(p, mu, theta, size, pi, lower.tail = TRUE, log.p = FALSE)

rzinbinom(n, mu, theta, size, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dzinbinom_+3A_x">x</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_mu">mu</code></td>
<td>
<p>vector of (non-negative) negative binomial location parameters.</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_theta">theta</code>, <code id="dzinbinom_+3A_size">size</code></td>
<td>
<p>vector of (non-negative) negative binomial overdispersion parameters.
Only <code>theta</code> or, equivalently, <code>size</code> may be specified.</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_pi">pi</code></td>
<td>
<p>vector of zero-inflation probabilities in the unit interval.</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_log">log</code>, <code id="dzinbinom_+3A_log.p">log.p</code></td>
<td>
<p>logical indicating whether probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical indicating whether probabilities are <code class="reqn">P[X \le x]</code> (lower tail) or <code class="reqn">P[X &gt; x]</code> (upper tail).</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions follow the usual conventions of d/p/q/r functions
in base R. In particular, all four <code>zinbinom</code> functions for the
zero-inflated negative binomial distribution call the corresponding <code>nbinom</code>
functions for the negative binomial distribution from base R internally.
</p>
<p>Note, however, that the precision of <code>qzinbinom</code> for very large
probabilities (close to 1) is limited because the probabilities
are internally handled in levels and not in logs (even if <code>log.p = TRUE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a></code>, <code><a href="stats.html#topic+dnbinom">dnbinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## theoretical probabilities for a zero-inflated negative binomial distribution
x &lt;- 0:8
p &lt;- dzinbinom(x, mu = 2.5, theta = 1, pi = 0.25)
plot(x, p, type = "h", lwd = 2)

## corresponding empirical frequencies from a simulated sample
set.seed(0)
y &lt;- rzinbinom(500, mu = 2.5, theta = 1, pi = 0.25)
hist(y, breaks = -1:max(y) + 0.5)

</code></pre>

<hr>
<h2 id='dzipois'>The zero-inflated Poisson distribution</h2><span id='topic+dzipois'></span><span id='topic+pzipois'></span><span id='topic+qzipois'></span><span id='topic+rzipois'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random
generation for the zero-inflated Poisson distribution with
parameters <code>lambda</code> and <code>pi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzipois(x, lambda, pi, log = FALSE)

pzipois(q, lambda, pi, lower.tail = TRUE, log.p = FALSE)

qzipois(p, lambda, pi, lower.tail = TRUE, log.p = FALSE)

rzipois(n, lambda, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dzipois_+3A_x">x</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dzipois_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) Poisson parameters.</p>
</td></tr>
<tr><td><code id="dzipois_+3A_pi">pi</code></td>
<td>
<p>vector of zero-inflation probabilities in the unit interval.</p>
</td></tr>
<tr><td><code id="dzipois_+3A_log">log</code>, <code id="dzipois_+3A_log.p">log.p</code></td>
<td>
<p>logical indicating whether probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dzipois_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dzipois_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical indicating whether probabilities are <code class="reqn">P[X \le x]</code> (lower tail) or <code class="reqn">P[X &gt; x]</code> (upper tail).</p>
</td></tr>
<tr><td><code id="dzipois_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dzipois_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions follow the usual conventions of d/p/q/r functions
in base R. In particular, all four <code>zipois</code> functions for the
zero-inflated Poisson distribution call the corresponding <code>pois</code>
functions for the Poisson distribution from base R internally.
</p>
<p>Note, however, that the precision of <code>qzipois</code> for very large
probabilities (close to 1) is limited because the probabilities
are internally handled in levels and not in logs (even if <code>log.p = TRUE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ZIPoisson">ZIPoisson</a></code>, <code><a href="stats.html#topic+dpois">dpois</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## theoretical probabilities for a zero-inflated Poisson distribution
x &lt;- 0:8
p &lt;- dzipois(x, lambda = 2.5, pi = 0.25)
plot(x, p, type = "h", lwd = 2)

## corresponding empirical frequencies from a simulated sample
set.seed(0)
y &lt;- rzipois(500, lambda = 2.5, pi = 0.25)
hist(y, breaks = -1:max(y) + 0.5)

</code></pre>

<hr>
<h2 id='dztnbinom'>The zero-truncated negative binomial distribution</h2><span id='topic+dztnbinom'></span><span id='topic+pztnbinom'></span><span id='topic+qztnbinom'></span><span id='topic+rztnbinom'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random
generation for the zero-truncated negative binomial distribution with
parameters <code>mu</code> and <code>theta</code> (or <code>size</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dztnbinom(x, mu, theta, size, log = FALSE)

pztnbinom(q, mu, theta, size, lower.tail = TRUE, log.p = FALSE)

qztnbinom(p, mu, theta, size, lower.tail = TRUE, log.p = FALSE)

rztnbinom(n, mu, theta, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dztnbinom_+3A_x">x</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dztnbinom_+3A_mu">mu</code></td>
<td>
<p>vector of (non-negative) negative binomial location parameters.</p>
</td></tr>
<tr><td><code id="dztnbinom_+3A_theta">theta</code>, <code id="dztnbinom_+3A_size">size</code></td>
<td>
<p>vector of (non-negative) negative binomial overdispersion parameters.
Only <code>theta</code> or, equivalently, <code>size</code> may be specified.</p>
</td></tr>
<tr><td><code id="dztnbinom_+3A_log">log</code>, <code id="dztnbinom_+3A_log.p">log.p</code></td>
<td>
<p>logical indicating whether probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dztnbinom_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dztnbinom_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical indicating whether probabilities are <code class="reqn">P[X \le x]</code> (lower tail) or <code class="reqn">P[X &gt; x]</code> (upper tail).</p>
</td></tr>
<tr><td><code id="dztnbinom_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dztnbinom_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The negative binomial distribution left-truncated at zero (or zero-truncated
negative binomial for short) is the distribution obtained, when considering
a negative binomial variable Y conditional on Y being greater than zero.
</p>
<p>All functions follow the usual conventions of d/p/q/r functions
in base R. In particular, all four <code>ztnbinom</code> functions for the
zero-truncated negative binomial distribution call the corresponding <code>nbinom</code>
functions for the negative binomial distribution from base R internally.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a></code>, <code><a href="stats.html#topic+dnbinom">dnbinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## theoretical probabilities for a zero-truncated negative binomial distribution
x &lt;- 0:8
p &lt;- dztnbinom(x, mu = 2.5, theta = 1)
plot(x, p, type = "h", lwd = 2)

## corresponding empirical frequencies from a simulated sample
set.seed(0)
y &lt;- rztnbinom(500, mu = 2.5, theta = 1)
hist(y, breaks = -1:max(y) + 0.5)

</code></pre>

<hr>
<h2 id='dztpois'>The zero-truncated Poisson distribution</h2><span id='topic+dztpois'></span><span id='topic+pztpois'></span><span id='topic+qztpois'></span><span id='topic+rztpois'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random
generation for the zero-truncated Poisson distribution with
parameter <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dztpois(x, lambda, log = FALSE)

pztpois(q, lambda, lower.tail = TRUE, log.p = FALSE)

qztpois(p, lambda, lower.tail = TRUE, log.p = FALSE)

rztpois(n, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dztpois_+3A_x">x</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dztpois_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) Poisson parameters.</p>
</td></tr>
<tr><td><code id="dztpois_+3A_log">log</code>, <code id="dztpois_+3A_log.p">log.p</code></td>
<td>
<p>logical indicating whether probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dztpois_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dztpois_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical indicating whether probabilities are <code class="reqn">P[X \le x]</code> (lower tail) or <code class="reqn">P[X &gt; x]</code> (upper tail).</p>
</td></tr>
<tr><td><code id="dztpois_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dztpois_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Poisson distribution left-truncated at zero (or zero-truncated
Poisson for short) is the distribution obtained, when considering
a Poisson variable Y conditional on Y being greater than zero.
</p>
<p>All functions follow the usual conventions of d/p/q/r functions
in base R. In particular, all four <code>ztpois</code> functions for the
zero-truncated Poisson distribution call the corresponding <code>pois</code>
functions for the Poisson distribution from base R internally.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ZTPoisson">ZTPoisson</a></code>, <code><a href="stats.html#topic+dpois">dpois</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## theoretical probabilities for a zero-truncated Poisson distribution
x &lt;- 0:8
p &lt;- dztpois(x, lambda = 2.5)
plot(x, p, type = "h", lwd = 2)

## corresponding empirical frequencies from a simulated sample
set.seed(0)
y &lt;- rztpois(500, lambda = 2.5)
hist(y, breaks = -1:max(y) + 0.5)

</code></pre>

<hr>
<h2 id='Erlang'>Create an Erlang distribution</h2><span id='topic+Erlang'></span>

<h3>Description</h3>

<p>The Erlang distribution is a two-parameter family of continuous probability
distributions with support <code class="reqn">x \in [0,\infty)</code>.
The two parameters are a positive integer shape parameter <code class="reqn">k</code> and a
positive real rate parameter <code class="reqn">\lambda</code>.
The Erlang distribution with shape parameter <code class="reqn">k = 1</code> simplifies to the
exponential distribution, and it is a special case of the gamma distribution.
It corresponds to a sum of <code class="reqn">k</code> independent exponential variables with mean
<code class="reqn">1 / \lambda</code> each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Erlang(k, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Erlang_+3A_k">k</code></td>
<td>
<p>The shape parameter. Can be any positive integer number.</p>
</td></tr>
<tr><td><code id="Erlang_+3A_lambda">lambda</code></td>
<td>
<p>The rate parameter. Can be any positive number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Erlang</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Erlang(5, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='Exponential'>Create an Exponential distribution</h2><span id='topic+Exponential'></span>

<h3>Description</h3>

<p>Exponential distributions are frequently used for modeling the amount
of time that passes until a specific event occurs. For example, exponential
distributions could be used to model the time between two earthquakes,
the amount of delay between internet packets, or the amount of time a piece
of machinery can run before needing repair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Exponential(rate = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exponential_+3A_rate">rate</code></td>
<td>
<p>The rate parameter, written <code class="reqn">\lambda</code> in textbooks.
Can be any positive number. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be an Exponential random variable with
rate parameter <code>rate</code> = <code class="reqn">\lambda</code>.
</p>
<p><strong>Support</strong>: x in [0, <code class="reqn">\infty</code>)
</p>
<p><strong>Mean</strong>: 1 / <code class="reqn">\lambda</code>
</p>
<p><strong>Variance</strong>: 1 / <code class="reqn">\lambda^2</code>
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \lambda e^{-\lambda x}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    F(x) = 1 - e^{-\lambda x}
  </code>
</p>

<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    \frac{\lambda}{\lambda - t}, for t &lt; \lambda
  </code>
</p>



<h3>Value</h3>

<p>An <code>Exponential</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Exponential(5)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='FIFA2018'>Goals scored in all 2018 FIFA World Cup matches</h2><span id='topic+FIFA2018'></span>

<h3>Description</h3>

<p>Data from all 64 matches in the 2018 FIFA World Cup along with predicted
ability differences based on bookmakers odds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("FIFA2018", package = "distributions3")
</code></pre>


<h3>Format</h3>

<p>A data frame with 128 rows and 7 columns.
</p>

<dl>
<dt>goals</dt><dd><p>integer. Number of goals scored in normal time (90 minutes), \
i.e., excluding potential extra time or penalties in knockout matches.</p>
</dd>
<dt>team</dt><dd><p>character. 3-letter FIFA code for the team.</p>
</dd>
<dt>match</dt><dd><p>integer. Match ID ranging from 1 (opening match) to 64 (final).</p>
</dd>
<dt>type</dt><dd><p>factor. Type of match for groups A to H, round of 16 (R16), quarter final,
semi-final, match for 3rd place, and final.</p>
</dd>
<dt>stage</dt><dd><p>factor. Group vs. knockout tournament stage.</p>
</dd>
<dt>logability</dt><dd><p>numeric. Estimated log-ability for each team based on
bookmaker consensus model.</p>
</dd>
<dt>difference</dt><dd><p>numeric. Difference in estimated log-abilities between
a team and its opponent in each match.</p>
</dd>
</dl>



<h3>Details</h3>

<p>To investigate the number of goals scored per match in the 2018 FIFA World Cup,
<code>FIFA2018</code> provides two rows, one for each team, for each of the matches
during the tournament. In addition some basic meta-information for the matches
(an ID, team name abbreviations, type of match, group vs. knockout stage),
information on the estimated log-ability for each team is provided. These
have been estimated by Zeileis et al. (2018) prior to the start of the
tournament (2018-05-20) based on quoted odds from 26 online bookmakers using
the bookmaker consensus model of Leitner et al. (2010). The difference in
log-ability between a team and its opponent is a useful predictor for the
number of goals scored.
</p>
<p>To model the data a basic Poisson regression model provides a good fit.
This treats the number of goals by the two teams as independent given the
ability difference which is a reasonable assumption in this data set.
</p>


<h3>Source</h3>

<p>The goals for each match have been obtained from Wikipedia
(<a href="https://en.wikipedia.org/wiki/2018_FIFA_World_Cup">https://en.wikipedia.org/wiki/2018_FIFA_World_Cup</a>) and the log-abilities
from Zeileis et al. (2018) based on quoted odds from Oddschecker.com and Bwin.com.
</p>


<h3>References</h3>

<p>Leitner C, Zeileis A, Hornik K (2010).
Forecasting Sports Tournaments by Ratings of (Prob)abilities: A Comparison for the EURO 2008.
<em>International Journal of Forecasting</em>, <b>26</b>(3), 471-481.
<a href="https://doi.org/10.1016/j.ijforecast.2009.10.001">doi:10.1016/j.ijforecast.2009.10.001</a>
</p>
<p>Zeileis A, Leitner C, Hornik K (2018).
Probabilistic Forecasts for the 2018 FIFA World Cup Based on the Bookmaker Consensus Model.
Working Paper 2018-09, Working Papers in Economics and Statistics,
Research Platform Empirical and Experimental Economics, University of Innsbruck.
<a href="https://EconPapers.RePEc.org/RePEc:inn:wpaper:2018-09">https://EconPapers.RePEc.org/RePEc:inn:wpaper:2018-09</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data
data("FIFA2018", package = "distributions3")

## observed relative frequencies of goals in all matches
obsrvd &lt;- prop.table(table(FIFA2018$goals))

## expected probabilities assuming a simple Poisson model,
## using the average number of goals across all teams/matches
## as the point estimate for the mean (lambda) of the distribution
p_const &lt;- Poisson(lambda = mean(FIFA2018$goals))
p_const
expctd &lt;- pdf(p_const, 0:6)

## comparison: observed vs. expected frequencies
## frequencies for 3 and 4 goals are slightly overfitted
## while 5 and 6 goals are slightly underfitted
cbind("observed" = obsrvd, "expected" = expctd)

## instead of fitting the same average Poisson model to all
## teams/matches, take ability differences into account
m &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson)
summary(m)
## when the ratio of abilities increases by 1 percent, the
## expected number of goals increases by around 0.4 percent

## this yields a different predicted Poisson distribution for
## each team/match
p_reg &lt;- Poisson(lambda = fitted(m))
head(p_reg)

## as an illustration, the following goal distributions
## were expected for the final (that France won 4-2 against Croatia)
p_final &lt;- tail(p_reg, 2)
p_final
pdf(p_final, 0:6)
## clearly France was expected to score more goals than Croatia
## but both teams scored more goals than expected, albeit not unlikely many

## assuming independence of the number of goals scored, obtain
## table of possible match results (after normal time), along with
## overall probabilities of win/draw/lose
res &lt;- outer(pdf(p_final[1], 0:6), pdf(p_final[2], 0:6))
sum(res[lower.tri(res)]) ## France wins
sum(diag(res))           ## draw
sum(res[upper.tri(res)]) ## France loses

## update expected frequencies table based on regression model
expctd &lt;- pdf(p_reg, 0:6)
head(expctd)
expctd &lt;- colMeans(expctd)
cbind("observed" = obsrvd, "expected" = expctd)
</code></pre>

<hr>
<h2 id='FisherF'>Create an F distribution</h2><span id='topic+FisherF'></span>

<h3>Description</h3>

<p>Create an F distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FisherF(df1, df2, lambda = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FisherF_+3A_df1">df1</code></td>
<td>
<p>Numerator degrees of freedom. Can be any positive number.</p>
</td></tr>
<tr><td><code id="FisherF_+3A_df2">df2</code></td>
<td>
<p>Denominator degrees of freedom. Can be any positive number.</p>
</td></tr>
<tr><td><code id="FisherF_+3A_lambda">lambda</code></td>
<td>
<p>Non-centrality parameter. Can be any positive number.
Defaults to <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail.
</p>
<p>TODO
</p>


<h3>Value</h3>

<p>A <code>FisherF</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- FisherF(5, 10, 0.2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='fit_mle'>Fit a distribution to data</h2><span id='topic+fit_mle'></span>

<h3>Description</h3>

<p>Generic function for fitting maximum-likelihood estimates (MLEs) of
a distribution based on empirical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mle(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mle_+3A_d">d</code></td>
<td>
<p>An object. The package provides methods for distribution
objects such as those from <code><a href="#topic+Normal">Normal()</a></code> or <code><a href="#topic+Binomial">Binomial()</a></code> etc.</p>
</td></tr>
<tr><td><code id="fit_mle_+3A_x">x</code></td>
<td>
<p>A vector of data to compute the likelihood.</p>
</td></tr>
<tr><td><code id="fit_mle_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distribution (the same kind as <code>d</code>) where the parameters
are the MLE estimates based on <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- Normal()
fit_mle(X, c(-1, 0, 0, 0, 3))
</code></pre>

<hr>
<h2 id='fit_mle.Bernoulli'>Fit a Bernoulli distribution to data</h2><span id='topic+fit_mle.Bernoulli'></span>

<h3>Description</h3>

<p>Fit a Bernoulli distribution to data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bernoulli'
fit_mle(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mle.Bernoulli_+3A_d">d</code></td>
<td>
<p>A <code>Bernoulli</code> object.</p>
</td></tr>
<tr><td><code id="fit_mle.Bernoulli_+3A_x">x</code></td>
<td>
<p>A vector of zeroes and ones.</p>
</td></tr>
<tr><td><code id="fit_mle.Bernoulli_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Bernoulli</code> object
</p>

<hr>
<h2 id='fit_mle.Binomial'>Fit a Binomial distribution to data</h2><span id='topic+fit_mle.Binomial'></span>

<h3>Description</h3>

<p>The fit distribution will inherit the same <code>size</code> parameter as
the <code>Binomial</code> object passed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Binomial'
fit_mle(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mle.Binomial_+3A_d">d</code></td>
<td>
<p>A <code>Binomial</code> object.</p>
</td></tr>
<tr><td><code id="fit_mle.Binomial_+3A_x">x</code></td>
<td>
<p>A vector of zeroes and ones.</p>
</td></tr>
<tr><td><code id="fit_mle.Binomial_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Binomial</code> object
</p>

<hr>
<h2 id='fit_mle.Exponential'>Fit an Exponential distribution to data</h2><span id='topic+fit_mle.Exponential'></span>

<h3>Description</h3>

<p>Fit an Exponential distribution to data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Exponential'
fit_mle(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mle.Exponential_+3A_d">d</code></td>
<td>
<p>An <code>Exponential</code> object created by a call to <code><a href="#topic+Exponential">Exponential()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_mle.Exponential_+3A_x">x</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="fit_mle.Exponential_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Exponential</code> object.
</p>

<hr>
<h2 id='fit_mle.Gamma'>Fit a Gamma distribution to data</h2><span id='topic+fit_mle.Gamma'></span>

<h3>Description</h3>

<p>Fit a Gamma distribution to data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gamma'
fit_mle(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mle.Gamma_+3A_d">d</code></td>
<td>
<p>A <code>Gamma</code> object created by a call to <code><a href="#topic+Gamma">Gamma()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_mle.Gamma_+3A_x">x</code></td>
<td>
<p>A vector to fit the Gamma distribution to.</p>
</td></tr>
<tr><td><code id="fit_mle.Gamma_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Gamma</code> object
</p>

<hr>
<h2 id='fit_mle.Geometric'>Fit a Geometric distribution to data</h2><span id='topic+fit_mle.Geometric'></span>

<h3>Description</h3>

<p>Fit a Geometric distribution to data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Geometric'
fit_mle(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mle.Geometric_+3A_d">d</code></td>
<td>
<p>A <code>Geometric</code> object.</p>
</td></tr>
<tr><td><code id="fit_mle.Geometric_+3A_x">x</code></td>
<td>
<p>A vector of zeroes and ones.</p>
</td></tr>
<tr><td><code id="fit_mle.Geometric_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Geometric</code> object
</p>

<hr>
<h2 id='fit_mle.LogNormal'>Fit a Log Normal distribution to data</h2><span id='topic+fit_mle.LogNormal'></span>

<h3>Description</h3>

<p>Fit a Log Normal distribution to data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LogNormal'
fit_mle(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mle.LogNormal_+3A_d">d</code></td>
<td>
<p>A <code>LogNormal</code> object created by a call to <code><a href="#topic+LogNormal">LogNormal()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_mle.LogNormal_+3A_x">x</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="fit_mle.LogNormal_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>LogNormal</code> object.
</p>


<h3>See Also</h3>

<p>Other LogNormal distribution: 
<code><a href="#topic+cdf.LogNormal">cdf.LogNormal</a>()</code>,
<code><a href="#topic+pdf.LogNormal">pdf.LogNormal</a>()</code>,
<code><a href="#topic+quantile.LogNormal">quantile.LogNormal</a>()</code>,
<code><a href="#topic+random.LogNormal">random.LogNormal</a>()</code>
</p>

<hr>
<h2 id='fit_mle.Normal'>Fit a Normal distribution to data</h2><span id='topic+fit_mle.Normal'></span>

<h3>Description</h3>

<p>Fit a Normal distribution to data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Normal'
fit_mle(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mle.Normal_+3A_d">d</code></td>
<td>
<p>A <code>Normal</code> object created by a call to <code><a href="#topic+Normal">Normal()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_mle.Normal_+3A_x">x</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="fit_mle.Normal_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Normal</code> object.
</p>


<h3>See Also</h3>

<p>Other Normal distribution: 
<code><a href="#topic+cdf.Normal">cdf.Normal</a>()</code>,
<code><a href="#topic+pdf.Normal">pdf.Normal</a>()</code>,
<code><a href="#topic+quantile.Normal">quantile.Normal</a>()</code>
</p>

<hr>
<h2 id='fit_mle.Poisson'>Fit an Poisson distribution to data</h2><span id='topic+fit_mle.Poisson'></span>

<h3>Description</h3>

<p>Fit an Poisson distribution to data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Poisson'
fit_mle(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mle.Poisson_+3A_d">d</code></td>
<td>
<p>An <code>Poisson</code> object created by a call to <code><a href="#topic+Poisson">Poisson()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_mle.Poisson_+3A_x">x</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="fit_mle.Poisson_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Poisson</code> object.
</p>

<hr>
<h2 id='Frechet'>Create a Frechet distribution</h2><span id='topic+Frechet'></span>

<h3>Description</h3>

<p>The Frechet distribution is a special case of the <code style="white-space: pre;">&#8288;\link{GEV}&#8288;</code> distribution,
obtained when the GEV shape parameter <code class="reqn">\xi</code> is positive.
It may be referred to as a type II extreme value distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Frechet(location = 0, scale = 1, shape = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Frechet_+3A_location">location</code></td>
<td>
<p>The location (minimum) parameter <code class="reqn">m</code>.
<code>location</code> can be any real number.  Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_scale">scale</code></td>
<td>
<p>The scale parameter <code class="reqn">s</code>.
<code>scale</code> can be any positive number.  Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_shape">shape</code></td>
<td>
<p>The shape parameter <code class="reqn">\alpha</code>.
<code>shape</code> can be any positive number.  Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a Frechet random variable with location
parameter  <code>location</code> = <code class="reqn">m</code>, scale parameter <code>scale</code> =
<code class="reqn">s</code>, and shape parameter <code>shape</code> = <code class="reqn">\alpha</code>.
A Frechet(<code class="reqn">m, s, \alpha</code>) distribution is equivalent to a
<code style="white-space: pre;">&#8288;\link{GEV}&#8288;</code>(<code class="reqn">m + s, s / \alpha, 1 / \alpha</code>) distribution.
</p>
<p><strong>Support</strong>: <code class="reqn">(m, \infty)</code>.
</p>
<p><strong>Mean</strong>: <code class="reqn">m + s\Gamma(1 - 1/\alpha)</code>, for <code class="reqn">\alpha &gt; 1</code>; undefined
otherwise.
</p>
<p><strong>Median</strong>: <code class="reqn">m + s(\ln 2)^{-1/\alpha}</code>.
</p>
<p><strong>Variance</strong>:
<code class="reqn">s^2 [\Gamma(1 - 2 / \alpha) - \Gamma(1 - 1 / \alpha)^2]</code>
for <code class="reqn">\alpha &gt; 2</code>; undefined otherwise.
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \alpha s ^ {-1} [(x - m) / s] ^ {-(1 + \alpha)}%
        \exp\{-[(x - m) / s] ^ {-\alpha} \}</code>
</p>

<p>for <code class="reqn">x &gt; m</code>.  The p.d.f. is 0 for <code class="reqn">x \leq m</code>.
</p>
<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \exp\{-[(x - m) / s] ^ {-\alpha} \}</code>
</p>

<p>for <code class="reqn">x &gt; m</code>.  The c.d.f. is 0 for <code class="reqn">x \leq m</code>.
</p>


<h3>Value</h3>

<p>A <code>Frechet</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Frechet(0, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='Gamma'>Create a Gamma distribution</h2><span id='topic+Gamma'></span>

<h3>Description</h3>

<p>Several important distributions are special cases of the Gamma
distribution. When the shape parameter is <code>1</code>, the Gamma is an
exponential distribution with parameter <code class="reqn">1/\beta</code>. When the
<code class="reqn">shape = n/2</code> and <code class="reqn">rate = 1/2</code>, the Gamma is a equivalent to
a chi squared distribution with n degrees of freedom. Moreover, if
we have <code class="reqn">X_1</code> is <code class="reqn">Gamma(\alpha_1, \beta)</code> and
<code class="reqn">X_2</code> is <code class="reqn">Gamma(\alpha_2, \beta)</code>, a function of these two variables
of the form <code class="reqn">\frac{X_1}{X_1 + X_2}</code> <code class="reqn">Beta(\alpha_1, \alpha_2)</code>.
This last property frequently appears in another distributions, and it
has extensively been used in multivariate methods. More about the Gamma
distribution will be added soon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gamma(shape, rate = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gamma_+3A_shape">shape</code></td>
<td>
<p>The shape parameter. Can be any positive number.</p>
</td></tr>
<tr><td><code id="Gamma_+3A_rate">rate</code></td>
<td>
<p>The rate parameter. Can be any positive number. Defaults
to <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail.
</p>
<p>In the following, let <code class="reqn">X</code> be a Gamma random variable
with parameters
<code>shape</code> = <code class="reqn">\alpha</code> and
<code>rate</code> = <code class="reqn">\beta</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">x \in (0, \infty)</code>
</p>
<p><strong>Mean</strong>: <code class="reqn">\frac{\alpha}{\beta}</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">\frac{\alpha}{\beta^2}</code>
</p>
<p><strong>Probability density function (p.m.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{\beta^{\alpha}}{\Gamma(\alpha)} x^{\alpha - 1} e^{-\beta x}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{\Gamma(\alpha, \beta x)}{\Gamma{\alpha}}
  </code>
</p>

<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    E(e^{tX}) = \Big(\frac{\beta}{ \beta - t}\Big)^{\alpha}, \thinspace t &lt; \beta
  </code>
</p>



<h3>Value</h3>

<p>A <code>Gamma</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Gamma(5, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='Geometric'>Create a Geometric distribution</h2><span id='topic+Geometric'></span>

<h3>Description</h3>

<p>The Geometric distribution can be thought of as a generalization
of the <code><a href="#topic+Bernoulli">Bernoulli()</a></code> distribution where we ask: &quot;if I keep flipping a
coin with probability <code>p</code> of heads, what is the probability I need
<code class="reqn">k</code> flips before I get my first heads?&quot; The Geometric
distribution is a special case of Negative Binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Geometric(p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Geometric_+3A_p">p</code></td>
<td>
<p>The success probability for the distribution. <code>p</code> can be
any value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>, and defaults to <code>0.5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a Geometric random variable with
success probability <code>p</code> = <code class="reqn">p</code>. Note that there are multiple
parameterizations of the Geometric distribution.
</p>
<p><strong>Support</strong>: 0 &lt; p &lt; 1, <code class="reqn">x = 0, 1, \dots</code>
</p>
<p><strong>Mean</strong>: <code class="reqn">\frac{1-p}{p}</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">\frac{1-p}{p^2}</code>
</p>
<p><strong>Probability mass function (p.m.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = x) = p(1-p)^x,
   </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X \le x) = 1 - (1-p)^{x+1}
  </code>
</p>

<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    E(e^{tX}) = \frac{pe^t}{1 - (1-p)e^t}
  </code>
</p>



<h3>Value</h3>

<p>A <code>Geometric</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Geometric(0.3)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='GEV'>Create a Generalised Extreme Value (GEV) distribution</h2><span id='topic+GEV'></span>

<h3>Description</h3>

<p>The GEV distribution arises from the Extremal Types Theorem, which is rather
like the Central Limit Theorem (see <code style="white-space: pre;">&#8288;\link{Normal}&#8288;</code>) but it relates to
the <em>maximum</em> of <code class="reqn">n</code> i.i.d. random variables rather than to the sum.
If, after a suitable linear rescaling, the distribution of this maximum
tends to a non-degenerate limit as <code class="reqn">n</code> tends to infinity then this limit
must be a GEV distribution. The requirement that the variables are independent
can be relaxed substantially. Therefore, the GEV distribution is often used
to model the maximum of a large number of random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEV(mu = 0, sigma = 1, xi = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEV_+3A_mu">mu</code></td>
<td>
<p>The location parameter, written <code class="reqn">\mu</code> in textbooks.
<code>mu</code> can be any real number.  Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="GEV_+3A_sigma">sigma</code></td>
<td>
<p>The scale parameter, written <code class="reqn">\sigma</code> in textbooks.
<code>sigma</code> can be any positive number.  Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="GEV_+3A_xi">xi</code></td>
<td>
<p>The shape parameter, written <code class="reqn">\xi</code> in textbooks.
<code>xi</code> can be any real number.  Defaults to <code>0</code>, which corresponds to a
Gumbel distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a GEV random variable with location
parameter  <code>mu</code> = <code class="reqn">\mu</code>, scale parameter <code>sigma</code> = <code class="reqn">\sigma</code> and
shape parameter <code>xi</code> = <code class="reqn">\xi</code>.
</p>
<p><strong>Support</strong>:
<code class="reqn">(-\infty, \mu - \sigma / \xi)</code> for <code class="reqn">\xi &lt; 0</code>;
<code class="reqn">(\mu - \sigma / \xi, \infty)</code> for <code class="reqn">\xi &gt; 0</code>;
and <code class="reqn">R</code>, the set of all real numbers, for <code class="reqn">\xi = 0</code>.
</p>
<p><strong>Mean</strong>: <code class="reqn">\mu + \sigma[\Gamma(1 - \xi) - 1]/\xi</code> for
<code class="reqn">\xi &lt; 1, \xi \neq 0</code>;
<code class="reqn">\mu + \sigma\gamma</code> for <code class="reqn">\xi = 0</code>, where <code class="reqn">\gamma</code>
is Euler's constant, approximately equal to 0.57722; undefined otherwise.
</p>
<p><strong>Median</strong>: <code class="reqn">\mu + \sigma[(\ln 2) ^ {-\xi} - 1]/\xi</code> for <code class="reqn">\xi \neq 0</code>;
<code class="reqn">\mu - \sigma\ln(\ln 2)</code> for <code class="reqn">\xi = 0</code>.
</p>
<p><strong>Variance</strong>:
<code class="reqn">\sigma^2 [\Gamma(1 - 2 \xi) - \Gamma(1 - \xi)^2] / \xi^2</code>
for <code class="reqn">\xi &lt; 1 / 2, \xi \neq 0</code>;
<code class="reqn">\sigma^2 \pi^2 / 6</code> for <code class="reqn">\xi = 0</code>; undefined otherwise.
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p>If <code class="reqn">\xi \neq 0</code> then
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \sigma ^ {-1} [1 + \xi (x - \mu) / \sigma] ^ {-(1 + 1/\xi)}%
         \exp\{-[1 + \xi (x - \mu) / \sigma] ^ {-1/\xi} \}</code>
</p>

<p>for <code class="reqn">1 + \xi (x - \mu) / \sigma &gt; 0</code>.  The p.d.f. is 0 outside the
support.
</p>
<p>In the <code class="reqn">\xi = 0</code> (Gumbel) special case
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \sigma ^ {-1} \exp[-(x - \mu) / \sigma]%
        \exp\{-\exp[-(x - \mu) / \sigma] \}</code>
</p>

<p>for <code class="reqn">x</code> in <code class="reqn">R</code>, the set of all real numbers.
</p>
<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p>If <code class="reqn">\xi \neq 0</code> then
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \exp\{-[1 + \xi (x - \mu) / \sigma] ^ {-1/\xi} \}</code>
</p>

<p>for <code class="reqn">1 + \xi (x - \mu) / \sigma &gt; 0</code>.  The c.d.f. is 0 below the
support and 1 above the support.
</p>
<p>In the <code class="reqn">\xi = 0</code> (Gumbel) special case
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \exp\{-\exp[-(x - \mu) / \sigma] \}</code>
</p>

<p>for <code class="reqn">x</code> in <code class="reqn">R</code>, the set of all real numbers.
</p>


<h3>Value</h3>

<p>A <code>GEV</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- GEV(1, 2, 0.1)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='GP'>Create a Generalised Pareto (GP) distribution</h2><span id='topic+GP'></span>

<h3>Description</h3>

<p>The GP distribution has a link to the <code style="white-space: pre;">&#8288;\link{GEV}&#8288;</code> distribution.
Suppose that the maximum of <code class="reqn">n</code> i.i.d. random variables has
approximately a GEV distribution. For a sufficiently large threshold
<code class="reqn">u</code>, the conditional distribution of the amount (the threshold
excess) by which a variable exceeds <code class="reqn">u</code> given that it exceeds <code class="reqn">u</code>
has approximately a GP distribution.  Therefore, the GP distribution is
often used to model the threshold excesses of a high threshold <code class="reqn">u</code>.
The requirement that the variables are independent can be relaxed
substantially, but then exceedances of <code class="reqn">u</code> may cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GP(mu = 0, sigma = 1, xi = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GP_+3A_mu">mu</code></td>
<td>
<p>The location parameter, written <code class="reqn">\mu</code> in textbooks.
<code>mu</code> can be any real number.  Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="GP_+3A_sigma">sigma</code></td>
<td>
<p>The scale parameter, written <code class="reqn">\sigma</code> in textbooks.
<code>sigma</code> can be any positive number.  Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="GP_+3A_xi">xi</code></td>
<td>
<p>The shape parameter, written <code class="reqn">\xi</code> in textbooks.
<code>xi</code> can be any real number.  Defaults to <code>0</code>, which corresponds to a
Gumbel distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a GP random variable with location
parameter  <code>mu</code> = <code class="reqn">\mu</code>, scale parameter <code>sigma</code> = <code class="reqn">\sigma</code> and
shape parameter <code>xi</code> = <code class="reqn">\xi</code>.
</p>
<p><strong>Support</strong>:
<code class="reqn">[\mu, \mu - \sigma / \xi]</code> for <code class="reqn">\xi &lt; 0</code>;
<code class="reqn">[\mu, \infty)</code> for <code class="reqn">\xi \geq 0</code>.
</p>
<p><strong>Mean</strong>: <code class="reqn">\mu + \sigma/(1 - \xi)</code> for
<code class="reqn">\xi &lt; 1</code>; undefined otherwise.
</p>
<p><strong>Median</strong>: <code class="reqn">\mu + \sigma[2 ^ \xi - 1]/\xi</code> for <code class="reqn">\xi \neq 0</code>;
<code class="reqn">\mu + \sigma\ln 2</code> for <code class="reqn">\xi = 0</code>.
</p>
<p><strong>Variance</strong>:
<code class="reqn">\sigma^2 / (1 - \xi)^2 (1 - 2\xi)</code>
for <code class="reqn">\xi &lt; 1 / 2</code>; undefined otherwise.
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p>If <code class="reqn">\xi \neq 0</code> then
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \sigma^{-1} [1 + \xi (x - \mu) / \sigma] ^ {-(1 + 1/\xi)}</code>
</p>

<p>for <code class="reqn">1 + \xi (x - \mu) / \sigma &gt; 0</code>.  The p.d.f. is 0 outside the
support.
</p>
<p>In the <code class="reqn">\xi = 0</code> special case
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \sigma ^ {-1} \exp[-(x - \mu) / \sigma]</code>
</p>

<p>for <code class="reqn">x</code> in [<code class="reqn">\mu, \infty</code>).  The p.d.f. is 0 outside the support.
</p>
<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p>If <code class="reqn">\xi \neq 0</code> then
</p>
<p style="text-align: center;"><code class="reqn">F(x) = 1 - \exp\{-[1 + \xi (x - \mu) / \sigma] ^ {-1/\xi} \}</code>
</p>

<p>for <code class="reqn">1 + \xi (x - \mu) / \sigma &gt; 0</code>.  The c.d.f. is 0 below the
support and 1 above the support.
</p>
<p>In the <code class="reqn">\xi = 0</code> special case
</p>
<p style="text-align: center;"><code class="reqn">F(x) = 1 - \exp[-(x - \mu) / \sigma] \}</code>
</p>

<p>for <code class="reqn">x</code> in <code class="reqn">R</code>, the set of all real numbers.
</p>


<h3>Value</h3>

<p>A <code>GP</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- GP(0, 2, 0.1)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='Gumbel'>Create a Gumbel distribution</h2><span id='topic+Gumbel'></span>

<h3>Description</h3>

<p>The Gumbel distribution is a special case of the <code style="white-space: pre;">&#8288;\link{GEV}&#8288;</code> distribution,
obtained when the GEV shape parameter <code class="reqn">\xi</code> is equal to 0.
It may be referred to as a type I extreme value distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gumbel(mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gumbel_+3A_mu">mu</code></td>
<td>
<p>The location parameter, written <code class="reqn">\mu</code> in textbooks.
<code>mu</code> can be any real number.  Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_sigma">sigma</code></td>
<td>
<p>The scale parameter, written <code class="reqn">\sigma</code> in textbooks.
<code>sigma</code> can be any positive number.  Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a Gumbel random variable with location
parameter  <code>mu</code> = <code class="reqn">\mu</code>, scale parameter <code>sigma</code> = <code class="reqn">\sigma</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">R</code>, the set of all real numbers.
</p>
<p><strong>Mean</strong>: <code class="reqn">\mu + \sigma\gamma</code>, where <code class="reqn">\gamma</code> is Euler's
constant, approximately equal to 0.57722.
</p>
<p><strong>Median</strong>: <code class="reqn">\mu - \sigma\ln(\ln 2)</code>.
</p>
<p><strong>Variance</strong>: <code class="reqn">\sigma^2 \pi^2 / 6</code>.
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \sigma ^ {-1} \exp[-(x - \mu) / \sigma]%
        \exp\{-\exp[-(x - \mu) / \sigma] \}</code>
</p>

<p>for <code class="reqn">x</code> in <code class="reqn">R</code>, the set of all real numbers.
</p>
<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p>In the <code class="reqn">\xi = 0</code> (Gumbel) special case
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \exp\{-\exp[-(x - \mu) / \sigma] \}</code>
</p>

<p>for <code class="reqn">x</code> in <code class="reqn">R</code>, the set of all real numbers.
</p>


<h3>Value</h3>

<p>A <code>Gumbel</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Gumbel(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='HurdleNegativeBinomial'>Create a hurdle negative binomial distribution</h2><span id='topic+HurdleNegativeBinomial'></span>

<h3>Description</h3>

<p>Hurdle negative binomial distributions are frequently used to model counts
with overdispersion and many zero observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HurdleNegativeBinomial(mu, theta, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HurdleNegativeBinomial_+3A_mu">mu</code></td>
<td>
<p>Location parameter of the negative binomial component of the distribution.
Can be any positive number.</p>
</td></tr>
<tr><td><code id="HurdleNegativeBinomial_+3A_theta">theta</code></td>
<td>
<p>Overdispersion parameter of the negative binomial component of the distribution.
Can be any positive number.</p>
</td></tr>
<tr><td><code id="HurdleNegativeBinomial_+3A_pi">pi</code></td>
<td>
<p>Zero-hurdle probability, can be any value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail.
</p>
<p>In the following, let <code class="reqn">X</code> be a hurdle negative binomial random variable with parameters
<code>mu</code> = <code class="reqn">\mu</code> and <code>theta</code> = <code class="reqn">\theta</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">\{0, 1, 2, 3, ...\}</code>
</p>
<p><strong>Mean</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    \mu \cdot \frac{\pi}{1 - F(0; \mu, \theta)}
  </code>
</p>

<p>where <code class="reqn">F(k; \mu)</code> is the c.d.f. of the <code><a href="#topic+NegativeBinomial">NegativeBinomial</a></code> distribution.
</p>
<p><strong>Variance</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    m \cdot \left(1 + \frac{\mu}{\theta} + \mu - m \right)
  </code>
</p>

<p>where <code class="reqn">m</code> is the mean above.
</p>
<p><strong>Probability mass function (p.m.f.)</strong>: <code class="reqn">P(X = 0) = 1 - \pi</code> and for <code class="reqn">k &gt; 0</code>
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = \pi \cdot \frac{f(k; \mu, \theta)}{1 - F(0; \mu, \theta)}
  </code>
</p>

<p>where <code class="reqn">f(k; \mu, \theta)</code> is the p.m.f. of the <code><a href="#topic+NegativeBinomial">NegativeBinomial</a></code>
distribution.
</p>
<p><strong>Cumulative distribution function (c.d.f.)</strong>: <code class="reqn">P(X \le 0) = 1 - \pi</code> and for <code class="reqn">k &gt; 0</code>
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = 1 - \pi + \pi \cdot \frac{F(k; \mu, \theta)}{1 - F(0; \mu, \theta)}
  </code>
</p>

<p><strong>Moment generating function (m.g.f.)</strong>:
</p>
<p>Omitted for now.
</p>


<h3>Value</h3>

<p>A <code>HurdleNegativeBinomial</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a hurdle negative binomial distribution
X &lt;- HurdleNegativeBinomial(mu = 2.5, theta = 1, pi = 0.75)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='HurdlePoisson'>Create a hurdle Poisson distribution</h2><span id='topic+HurdlePoisson'></span>

<h3>Description</h3>

<p>Hurdle Poisson distributions are frequently used to model counts
with many zero observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HurdlePoisson(lambda, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HurdlePoisson_+3A_lambda">lambda</code></td>
<td>
<p>Parameter of the Poisson component of the distribution.
Can be any positive number.</p>
</td></tr>
<tr><td><code id="HurdlePoisson_+3A_pi">pi</code></td>
<td>
<p>Zero-hurdle probability, can be any value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail.
</p>
<p>In the following, let <code class="reqn">X</code> be a hurdle Poisson random variable with parameter
<code>lambda</code> = <code class="reqn">\lambda</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">\{0, 1, 2, 3, ...\}</code>
</p>
<p><strong>Mean</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda \cdot \frac{\pi}{1 - e^{-\lambda}}
  </code>
</p>

<p><strong>Variance</strong>: <code class="reqn">m \cdot (\lambda + 1 - m)</code>, where <code class="reqn">m</code> is the mean above.
</p>
<p><strong>Probability mass function (p.m.f.)</strong>: <code class="reqn">P(X = 0) = 1 - \pi</code> and for <code class="reqn">k &gt; 0</code>
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = \pi \cdot \frac{f(k; \lambda)}{1 - f(0; \lambda)}
  </code>
</p>

<p>where <code class="reqn">f(k; \lambda)</code> is the p.m.f. of the <code><a href="#topic+Poisson">Poisson</a></code>
distribution.
</p>
<p><strong>Cumulative distribution function (c.d.f.)</strong>: <code class="reqn">P(X \le 0) = 1 - \pi</code> and for <code class="reqn">k &gt; 0</code>
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = 1 - \pi + \pi \cdot \frac{F(k; \lambda)}{1 - F(0; \lambda)}
  </code>
</p>

<p>where <code class="reqn">F(k; \lambda)</code> is the c.d.f. of the <code><a href="#topic+Poisson">Poisson</a></code> distribution.
</p>
<p><strong>Moment generating function (m.g.f.)</strong>:
</p>
<p>Omitted for now.
</p>


<h3>Value</h3>

<p>A <code>HurdlePoisson</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a hurdle Poisson distribution
X &lt;- HurdlePoisson(lambda = 2.5, pi = 0.75)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='HyperGeometric'>Create a HyperGeometric distribution</h2><span id='topic+HyperGeometric'></span>

<h3>Description</h3>

<p>To understand the HyperGeometric distribution, consider a set of
<code class="reqn">r</code> objects, of which <code class="reqn">m</code> are of the type I and
<code class="reqn">n</code> are of the type II. A sample with size <code class="reqn">k</code> (<code class="reqn">k&lt;r</code>)
with no replacement is randomly chosen. The number of observed
type I elements observed in this sample is set to be our random
variable <code class="reqn">X</code>. For example, consider that in a set of 20
car parts, there are 4 that are defective (type I).
If we take a sample of size 5 from those car parts, the
probability of finding 2 that are defective will be given by
the HyperGeometric distribution (needs double checking).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HyperGeometric(m, n, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HyperGeometric_+3A_m">m</code></td>
<td>
<p>The number of type I elements available.</p>
</td></tr>
<tr><td><code id="HyperGeometric_+3A_n">n</code></td>
<td>
<p>The number of type II elements available.</p>
</td></tr>
<tr><td><code id="HyperGeometric_+3A_k">k</code></td>
<td>
<p>The size of the sample taken.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a HyperGeometric random variable with
success probability <code>p</code> = <code class="reqn">p = m/(m+n)</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">x \in { \{\max{(0, k-n)}, \dots, \min{(k,m)}}\}</code>
</p>
<p><strong>Mean</strong>: <code class="reqn">\frac{km}{n+m} = kp</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">\frac{km(n)(n+m-k)}{(n+m)^2 (n+m-1)} =
  kp(1-p)(1 - \frac{k-1}{m+n-1})</code>
</p>
<p><strong>Probability mass function (p.m.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = x) = \frac{{m \choose x}{n \choose k-x}}{{m+n \choose k}}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X \le k) \approx \Phi\Big(\frac{x - kp}{\sqrt{kp(1-p)}}\Big)
 </code>
</p>

<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p>Not useful.
</p>


<h3>Value</h3>

<p>A <code>HyperGeometric</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- HyperGeometric(4, 5, 8)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='is_discrete'>Determine whether a distribution is discrete or continuous</h2><span id='topic+is_discrete'></span><span id='topic+is_continuous'></span>

<h3>Description</h3>

<p>Generic functions for determining whether a certain probability distribution
is discrete or continuous, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_discrete(d, ...)

is_continuous(d, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_discrete_+3A_d">d</code></td>
<td>
<p>An object. The package provides methods for distribution
objects such as those from <code><a href="#topic+Normal">Normal()</a></code> or <code><a href="#topic+Binomial">Binomial()</a></code> etc.</p>
</td></tr>
<tr><td><code id="is_discrete_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic function <code>is_discrete</code> is intended to return <code>TRUE</code>
for every distribution whose entire support is discrete and <code>FALSE</code>
otherwise. Analogously, <code>is_continuous</code> is intended to return <code>TRUE</code>
for every distribution whose entire support is continuous and <code>FALSE</code>
otherwise. For mixed discrete-continuous distributions both methods should
return <code>FALSE</code>.
</p>
<p>Methods for both generics are provided for all <code>distribution</code> classes
set up in this package.
</p>


<h3>Value</h3>

<p>A logical vector indicating whether the distribution(s) in <code>d</code>
is/are discrete or continuous, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- Normal()
is_discrete(X)
is_continuous(X)
Y &lt;- Binomial(size = 10, p = c(0.2, 0.5, 0.8))
is_discrete(Y)
is_continuous(Y)
</code></pre>

<hr>
<h2 id='is_distribution'>Is an object a distribution?</h2><span id='topic+is_distribution'></span>

<h3>Description</h3>

<p><code>is_distribution</code> tests if <code>x</code> inherits from <code>"distribution"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_distribution(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_distribution_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
Z &lt;- Normal()

is_distribution(Z)
is_distribution(1L)
</code></pre>

<hr>
<h2 id='log_likelihood'>Compute the (log-)likelihood of a probability distribution given data</h2><span id='topic+log_likelihood'></span><span id='topic+likelihood'></span>

<h3>Description</h3>

<p>Functions for computing the (log-)likelihood based on a distribution
object and observed data. The log-likelihood is computed as the sum of
log-density contributions and the likelihood by taking the exponential thereof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_likelihood(d, x, ...)

likelihood(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_likelihood_+3A_d">d</code></td>
<td>
<p>An object. The package provides methods for distribution
objects such as those from <code><a href="#topic+Normal">Normal()</a></code> or <code><a href="#topic+Binomial">Binomial()</a></code> etc.</p>
</td></tr>
<tr><td><code id="log_likelihood_+3A_x">x</code></td>
<td>
<p>A vector of data to compute the likelihood.</p>
</td></tr>
<tr><td><code id="log_likelihood_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value of the (log-)likelihood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## distribution object
X &lt;- Normal()
## sum of log_pdf() contributions
log_likelihood(X, c(-1, 0, 0, 0, 3))
## exp of log_likelihood()
likelihood(X, c(-1, 0, 0, 0, 3))
</code></pre>

<hr>
<h2 id='Logistic'>Create a Logistic distribution</h2><span id='topic+Logistic'></span>

<h3>Description</h3>

<p>A continuous distribution on the real line. For binary outcomes
the model given by <code class="reqn">P(Y = 1 | X) = F(X \beta)</code> where
<code class="reqn">F</code> is the Logistic <code><a href="#topic+cdf">cdf()</a></code> is called <em>logistic regression</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Logistic(location = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Logistic_+3A_location">location</code></td>
<td>
<p>The location parameter for the distribution. For Logistic
distributions, the location parameter is the mean, median and also mode.
Defaults to zero.</p>
</td></tr>
<tr><td><code id="Logistic_+3A_scale">scale</code></td>
<td>
<p>The scale parameter for the distribution. Defaults to one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a Logistic random variable with
<code>location</code> = <code class="reqn">\mu</code> and <code>scale</code> = <code class="reqn">s</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">R</code>, the set of all real numbers
</p>
<p><strong>Mean</strong>: <code class="reqn">\mu</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">s^2 \pi^2 / 3</code>
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{e^{-(\frac{x - \mu}{s})}}{s [1 + \exp(-(\frac{x - \mu}{s})) ]^2}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    F(t) = \frac{1}{1 + e^{-(\frac{t - \mu}{s})}}
  </code>
</p>

<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    E(e^{tX}) = e^{\mu t} \beta(1 - st, 1 + st)
  </code>
</p>

<p>where <code class="reqn">\beta(x, y)</code> is the Beta function.
</p>


<h3>Value</h3>

<p>A <code>Logistic</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Logistic(2, 4)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='LogNormal'>Create a LogNormal distribution</h2><span id='topic+LogNormal'></span>

<h3>Description</h3>

<p>A random variable created by exponentiating a <code><a href="#topic+Normal">Normal()</a></code>
distribution. Taking the log of LogNormal data returns in
<code><a href="#topic+Normal">Normal()</a></code> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogNormal(log_mu = 0, log_sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogNormal_+3A_log_mu">log_mu</code></td>
<td>
<p>The location parameter, written <code class="reqn">\mu</code> in textbooks.
Can be any real number. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="LogNormal_+3A_log_sigma">log_sigma</code></td>
<td>
<p>The scale parameter, written <code class="reqn">\sigma</code> in textbooks.
Can be any positive real number. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a LogNormal random variable with
success probability <code>p</code> = <code class="reqn">p</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">R^+</code>
</p>
<p><strong>Mean</strong>: <code class="reqn">\exp(\mu + \sigma^2/2)</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">[\exp(\sigma^2)-1]\exp(2\mu+\sigma^2)</code>
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{1}{x \sigma \sqrt{2 \pi}} \exp \left(-\frac{(\log x - \mu)^2}{2 \sigma^2} \right)
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \frac{1}{2} + \frac{1}{2\sqrt{pi}}\int_{-x}^x e^{-t^2} dt</code>
</p>

<p><strong>Moment generating function (m.g.f)</strong>:
Undefined.
</p>


<h3>Value</h3>

<p>A <code>LogNormal</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- LogNormal(0.3, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='Multinomial'>Create a Multinomial distribution</h2><span id='topic+Multinomial'></span>

<h3>Description</h3>

<p>The multinomial distribution is a generalization of the binomial
distribution to multiple categories. It is perhaps easiest to think
that we first extend a <code><a href="#topic+Bernoulli">Bernoulli()</a></code> distribution to include more
than two categories, resulting in a <code><a href="#topic+Categorical">Categorical()</a></code> distribution.
We then extend repeat the Categorical experiment several (<code class="reqn">n</code>)
times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Multinomial(size, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Multinomial_+3A_size">size</code></td>
<td>
<p>The number of trials. Must be an integer greater than or equal
to one. When <code>size = 1L</code>, the Multinomial distribution reduces to the
categorical distribution (also called the discrete uniform).
Often called <code>n</code> in textbooks.</p>
</td></tr>
<tr><td><code id="Multinomial_+3A_p">p</code></td>
<td>
<p>A vector of success probabilities for each trial. <code>p</code> can
take on any positive value, and the vector is normalized internally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X = (X_1, ..., X_k)</code> be a Multinomial
random variable with success probability <code>p</code> = <code class="reqn">p</code>. Note that
<code class="reqn">p</code> is vector with <code class="reqn">k</code> elements that sum to one. Assume
that we repeat the Categorical experiment <code>size</code> = <code class="reqn">n</code> times.
</p>
<p><strong>Support</strong>: Each <code class="reqn">X_i</code> is in <code class="reqn">{0, 1, 2, ..., n}</code>.
</p>
<p><strong>Mean</strong>: The mean of <code class="reqn">X_i</code> is <code class="reqn">n p_i</code>.
</p>
<p><strong>Variance</strong>: The variance of <code class="reqn">X_i</code> is <code class="reqn">n p_i (1 - p_i)</code>.
For <code class="reqn">i \neq j</code>, the covariance of <code class="reqn">X_i</code> and <code class="reqn">X_j</code>
is <code class="reqn">-n p_i p_j</code>.
</p>
<p><strong>Probability mass function (p.m.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X_1 = x_1, ..., X_k = x_k) = \frac{n!}{x_1! x_2! ... x_k!} p_1^{x_1} \cdot p_2^{x_2} \cdot ... \cdot p_k^{x_k}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p>Omitted for multivariate random variables for the time being.
</p>
<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    E(e^{tX}) = \left(\sum_{i=1}^k p_i e^{t_i}\right)^n
  </code>
</p>



<h3>Value</h3>

<p>A <code>Multinomial</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Multinomial(size = 5, p = c(0.3, 0.4, 0.2, 0.1))
X

random(X, 10)

# pdf(X, 2)
# log_pdf(X, 2)
</code></pre>

<hr>
<h2 id='NegativeBinomial'>Create a negative binomial distribution</h2><span id='topic+NegativeBinomial'></span>

<h3>Description</h3>

<p>A generalization of the geometric distribution. It is the number
of failures in a sequence of i.i.d. Bernoulli trials before
a specified target number (<code class="reqn">r</code>) of successes occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NegativeBinomial(size, p = 0.5, mu = size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NegativeBinomial_+3A_size">size</code></td>
<td>
<p>The target number of successes (greater than <code class="reqn">0</code>)
until the experiment is stopped. Denoted <code class="reqn">r</code> below.</p>
</td></tr>
<tr><td><code id="NegativeBinomial_+3A_p">p</code></td>
<td>
<p>The success probability for a given trial. <code>p</code> can be any
value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>, and defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="NegativeBinomial_+3A_mu">mu</code></td>
<td>
<p>Alternative parameterization via the non-negative mean
of the distribution (instead of the probability <code>p</code>), defaults to <code>size</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a negative binomial random variable with
success probability <code>p</code> = <code class="reqn">p</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">\{0, 1, 2, 3, ...\}</code>
</p>
<p><strong>Mean</strong>: <code class="reqn">\frac{(1 - p) r}{p} = \mu</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">\frac{(1 - p) r}{p^2}</code>
</p>
<p><strong>Probability mass function (p.m.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
     f(k) = {k + r - 1 \choose k} \cdot p^r (1-p)^k
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f.)</strong>:
</p>
<p>Omitted for now.
</p>
<p><strong>Moment generating function (m.g.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
     \left(\frac{p}{1 - (1 -p) e^t}\right)^r, t &lt; -\log (1-p)
  </code>
</p>

<p><strong>Alternative parameterization</strong>: Sometimes, especially when used in
regression models, the negative binomial distribution is parameterized
by its mean <code class="reqn">\mu</code> (as listed above) plus the size parameter <code class="reqn">r</code>.
This implies a success probability of <code class="reqn">p = r/(r + \mu)</code>. This can
also be seen as a generalization of the Poisson distribution where the
assumption of equidispersion (i.e., variance equal to mean) is relaxed.
The negative binomial distribution is overdispersed (i.e., variance greater than mean)
and its variance can also be written as <code class="reqn">\mu + 1/r \mu^2</code>. The Poisson
distribution is then obtained as <code class="reqn">r</code> goes to infinity. Note that in this
view it is natural to also allow for non-integer <code class="reqn">r</code> parameters.
The factorials in the equations above are then expressed in terms of the
gamma function.
</p>


<h3>Value</h3>

<p>A <code>NegativeBinomial</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- NegativeBinomial(size = 5, p = 0.1)
X

random(X, 10)

pdf(X, 50)
log_pdf(X, 50)

cdf(X, 50)
quantile(X, 0.7)

## alternative parameterization of X
Y &lt;- NegativeBinomial(mu = 45, size = 5)
Y
cdf(Y, 50)
quantile(Y, 0.7)
</code></pre>

<hr>
<h2 id='Normal'>Create a Normal distribution</h2><span id='topic+Normal'></span>

<h3>Description</h3>

<p>The Normal distribution is ubiquitous in statistics, partially because
of the central limit theorem, which states that sums of i.i.d. random
variables eventually become Normal. Linear transformations of Normal
random variables result in new random variables that are also Normal. If
you are taking an intro stats course, you'll likely use the Normal
distribution for Z-tests and in simple linear regression. Under
regularity conditions, maximum likelihood estimators are
asymptotically Normal. The Normal distribution is also called the
gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normal(mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normal_+3A_mu">mu</code></td>
<td>
<p>The location parameter, written <code class="reqn">\mu</code> in textbooks,
which is also the mean of the distribution. Can be any real number.
Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="Normal_+3A_sigma">sigma</code></td>
<td>
<p>The scale parameter, written <code class="reqn">\sigma</code> in textbooks,
which is also the <strong>standard deviation</strong> of the distribution. Can be any
positive number. Defaults to <code>1</code>. If you would like a Normal
distribution with <strong>variance</strong> <code class="reqn">\sigma^2</code>, be sure to take the
square root, as this is a common source of errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a Normal random variable with mean
<code>mu</code> = <code class="reqn">\mu</code> and standard deviation <code>sigma</code> = <code class="reqn">\sigma</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">R</code>, the set of all real numbers
</p>
<p><strong>Mean</strong>: <code class="reqn">\mu</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">\sigma^2</code>
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-(x - \mu)^2 / 2 \sigma^2}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p>The cumulative distribution function has the form
</p>
<p style="text-align: center;"><code class="reqn">
    F(t) = \int_{-\infty}^t \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-(x - \mu)^2 / 2 \sigma^2} dx
  </code>
</p>

<p>but this integral does not have a closed form solution and must be
approximated numerically. The c.d.f. of a standard Normal is sometimes
called the &quot;error function&quot;. The notation <code class="reqn">\Phi(t)</code> also stands
for the c.d.f. of a standard Normal evaluated at <code class="reqn">t</code>. Z-tables
list the value of <code class="reqn">\Phi(t)</code> for various <code class="reqn">t</code>.
</p>
<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    E(e^{tX}) = e^{\mu t + \sigma^2 t^2 / 2}
  </code>
</p>



<h3>Value</h3>

<p>A <code>Normal</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Normal(5, 2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

### example: calculating p-values for two-sided Z-test

# here the null hypothesis is H_0: mu = 3
# and we assume sigma = 2

# exactly the same as: Z &lt;- Normal(0, 1)
Z &lt;- Normal()

# data to test
x &lt;- c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2)
nx &lt;- length(x)

# calculate the z-statistic
z_stat &lt;- (mean(x) - 3) / (2 / sqrt(nx))
z_stat

# calculate the two-sided p-value
1 - cdf(Z, abs(z_stat)) + cdf(Z, -abs(z_stat))

# exactly equivalent to the above
2 * cdf(Z, -abs(z_stat))

# p-value for one-sided test
# H_0: mu &lt;= 3   vs   H_A: mu &gt; 3
1 - cdf(Z, z_stat)

# p-value for one-sided test
# H_0: mu &gt;= 3   vs   H_A: mu &lt; 3
cdf(Z, z_stat)

### example: calculating a 88 percent Z CI for a mean

# same `x` as before, still assume `sigma = 2`

# lower-bound
mean(x) - quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# upper-bound
mean(x) + quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# equivalent to
mean(x) + c(-1, 1) * quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# also equivalent to
mean(x) + quantile(Z, 0.12 / 2) * 2 / sqrt(nx)
mean(x) + quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

### generating random samples and plugging in ks.test()

set.seed(27)

# generate a random sample
ns &lt;- random(Normal(3, 7), 26)

# test if sample is Normal(3, 7)
ks.test(ns, pnorm, mean = 3, sd = 7)

# test if sample is gamma(8, 3) using base R pgamma()
ks.test(ns, pgamma, shape = 8, rate = 3)

### MISC

# note that the cdf() and quantile() functions are inverses
cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='pdf'>Evaluate the probability density of a probability distribution</h2><span id='topic+pdf'></span><span id='topic+log_pdf'></span><span id='topic+pmf'></span>

<h3>Description</h3>

<p>Generic function for computing probability density function (PDF)
contributions based on a distribution object and observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdf(d, x, drop = TRUE, ...)

log_pdf(d, x, ...)

pmf(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf_+3A_d">d</code></td>
<td>
<p>An object. The package provides methods for distribution
objects such as those from <code><a href="#topic+Normal">Normal()</a></code> or <code><a href="#topic+Binomial">Binomial()</a></code> etc.</p>
</td></tr>
<tr><td><code id="pdf_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic function <code>pdf()</code> computes the probability density,
both for continuous and discrete distributions. <code>pmf()</code> (for the
probability mass function) is an alias that just calls <code>pdf()</code> internally.
For computing log-density contributions (e.g., to a log-likelihood)
either <code>pdf(..., log = TRUE)</code> can be used or the generic function
<code>log_pdf()</code>.
</p>


<h3>Value</h3>

<p>Probabilities corresponding to the vector <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## distribution object
X &lt;- Normal()
## probability density
pdf(X, c(1, 2, 3, 4, 5))
pmf(X, c(1, 2, 3, 4, 5))
## log-density
pdf(X, c(1, 2, 3, 4, 5), log = TRUE)
log_pdf(X, c(1, 2, 3, 4, 5))
</code></pre>

<hr>
<h2 id='pdf.Bernoulli'>Evaluate the probability mass function of a Bernoulli distribution</h2><span id='topic+pdf.Bernoulli'></span><span id='topic+log_pdf.Bernoulli'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a Bernoulli distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bernoulli'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Bernoulli'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Bernoulli_+3A_d">d</code></td>
<td>
<p>A <code>Bernoulli</code> object created by a call to <code><a href="#topic+Bernoulli">Bernoulli()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Bernoulli_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Bernoulli_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Bernoulli_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Bernoulli_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dbinom">dbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Bernoulli(0.7)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)
pdf(X, 1)
log_pdf(X, 1)
cdf(X, 0)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='pdf.Beta'>Evaluate the probability mass function of a Beta distribution</h2><span id='topic+pdf.Beta'></span><span id='topic+log_pdf.Beta'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a Beta distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Beta'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Beta'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Beta_+3A_d">d</code></td>
<td>
<p>A <code>Beta</code> object created by a call to <code><a href="#topic+Beta">Beta()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Beta_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Beta_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Beta_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Beta_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dbeta">dbeta</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Beta(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

mean(X)
variance(X)
skewness(X)
kurtosis(X)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='pdf.Binomial'>Evaluate the probability mass function of a Binomial distribution</h2><span id='topic+pdf.Binomial'></span><span id='topic+log_pdf.Binomial'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a Binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Binomial'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Binomial'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Binomial_+3A_d">d</code></td>
<td>
<p>A <code>Binomial</code> object created by a call to <code><a href="#topic+Binomial">Binomial()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Binomial_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Binomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Binomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Binomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dbinom">dbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Binomial(10, 0.2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2L)
log_pdf(X, 2L)

cdf(X, 4L)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='pdf.Categorical'>Evaluate the probability mass function of a Categorical discrete distribution</h2><span id='topic+pdf.Categorical'></span><span id='topic+log_pdf.Categorical'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a Categorical discrete distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Categorical'
pdf(d, x, ...)

## S3 method for class 'Categorical'
log_pdf(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Categorical_+3A_d">d</code></td>
<td>
<p>A <code>Categorical</code> object created by a call to <code><a href="#topic+Categorical">Categorical()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Categorical_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Categorical_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of probabilities, one for each element of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Categorical(1:3, p = c(0.4, 0.1, 0.5))
X

Y &lt;- Categorical(LETTERS[1:4])
Y

random(X, 10)
random(Y, 10)

pdf(X, 1)
log_pdf(X, 1)

cdf(X, 1)
quantile(X, 0.5)

# cdfs are only defined for numeric sample spaces. this errors!
# cdf(Y, "a")

# same for quantiles. this also errors!
# quantile(Y, 0.7)
</code></pre>

<hr>
<h2 id='pdf.Cauchy'>Evaluate the probability mass function of a Cauchy distribution</h2><span id='topic+pdf.Cauchy'></span><span id='topic+log_pdf.Cauchy'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a Cauchy distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cauchy'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Cauchy'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Cauchy_+3A_d">d</code></td>
<td>
<p>A <code>Cauchy</code> object created by a call to <code><a href="#topic+Cauchy">Cauchy()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Cauchy_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Cauchy_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Cauchy_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Cauchy_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dcauchy">dcauchy</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Cauchy(10, 0.2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 2)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='pdf.ChiSquare'>Evaluate the probability mass function of a chi square distribution</h2><span id='topic+pdf.ChiSquare'></span><span id='topic+log_pdf.ChiSquare'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a chi square distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ChiSquare'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'ChiSquare'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.ChiSquare_+3A_d">d</code></td>
<td>
<p>A <code>ChiSquare</code> object created by a call to <code><a href="#topic+ChiSquare">ChiSquare()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.ChiSquare_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.ChiSquare_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.ChiSquare_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.ChiSquare_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dchisq">dchisq</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- ChiSquare(5)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='pdf.Erlang'>Evaluate the probability mass function of an Erlang distribution</h2><span id='topic+pdf.Erlang'></span><span id='topic+log_pdf.Erlang'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of an Erlang distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Erlang'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Erlang'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Erlang_+3A_d">d</code></td>
<td>
<p>An <code>Erlang</code> object created by a call to <code><a href="#topic+Erlang">Erlang()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Erlang_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Erlang_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Erlang_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Erlang_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dgamma">dgamma</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Erlang(5, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='pdf.Exponential'>Evaluate the probability density function of an Exponential distribution</h2><span id='topic+pdf.Exponential'></span><span id='topic+log_pdf.Exponential'></span>

<h3>Description</h3>

<p>Evaluate the probability density function of an Exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Exponential'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Exponential'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Exponential_+3A_d">d</code></td>
<td>
<p>An <code>Exponential</code> object created by a call to <code><a href="#topic+Exponential">Exponential()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Exponential_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Exponential_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Exponential_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Exponential_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dexp">dexp</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Exponential(5)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='pdf.FisherF'>Evaluate the probability mass function of an F distribution</h2><span id='topic+pdf.FisherF'></span><span id='topic+log_pdf.FisherF'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of an F distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FisherF'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'FisherF'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.FisherF_+3A_d">d</code></td>
<td>
<p>A <code>FisherF</code> object created by a call to <code><a href="#topic+FisherF">FisherF()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.FisherF_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.FisherF_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.FisherF_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.FisherF_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+df">df</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- FisherF(5, 10, 0.2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='pdf.Frechet'>Evaluate the probability mass function of a Frechet distribution</h2><span id='topic+pdf.Frechet'></span><span id='topic+log_pdf.Frechet'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a Frechet distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Frechet'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Frechet'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Frechet_+3A_d">d</code></td>
<td>
<p>A <code>Frechet</code> object created by a call to <code><a href="#topic+Frechet">Frechet()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Frechet_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Frechet_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Frechet_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Frechet_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+dgev">dgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Frechet(0, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='pdf.Gamma'>Evaluate the probability mass function of a Gamma distribution</h2><span id='topic+pdf.Gamma'></span><span id='topic+log_pdf.Gamma'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a Gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gamma'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Gamma'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Gamma_+3A_d">d</code></td>
<td>
<p>A <code>Gamma</code> object created by a call to <code><a href="#topic+Gamma">Gamma()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Gamma_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Gamma_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Gamma_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Gamma_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dgamma">dgamma</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Gamma(5, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='pdf.Geometric'>Evaluate the probability mass function of a Geometric distribution</h2><span id='topic+pdf.Geometric'></span><span id='topic+log_pdf.Geometric'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+Geometric">Geometric()</a></code> for some properties
of the Geometric distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Geometric'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Geometric'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Geometric_+3A_d">d</code></td>
<td>
<p>A <code>Geometric</code> object created by a call to <code><a href="#topic+Geometric">Geometric()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Geometric_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Geometric_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Geometric_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Geometric_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dgeom">dgeom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other Geometric distribution: 
<code><a href="#topic+cdf.Geometric">cdf.Geometric</a>()</code>,
<code><a href="#topic+quantile.Geometric">quantile.Geometric</a>()</code>,
<code><a href="#topic+random.Geometric">random.Geometric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Geometric(0.3)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='pdf.GEV'>Evaluate the probability mass function of a GEV distribution</h2><span id='topic+pdf.GEV'></span><span id='topic+log_pdf.GEV'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a GEV distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GEV'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'GEV'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.GEV_+3A_d">d</code></td>
<td>
<p>A <code>GEV</code> object created by a call to <code><a href="#topic+GEV">GEV()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.GEV_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.GEV_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.GEV_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.GEV_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+dgev">dgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- GEV(1, 2, 0.1)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='pdf.GP'>Evaluate the probability mass function of a GP distribution</h2><span id='topic+pdf.GP'></span><span id='topic+log_pdf.GP'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a GP distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GP'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'GP'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.GP_+3A_d">d</code></td>
<td>
<p>A <code>GP</code> object created by a call to <code><a href="#topic+GP">GP()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.GP_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.GP_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.GP_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.GP_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+dgp">dgp</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- GP(0, 2, 0.1)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='pdf.Gumbel'>Evaluate the probability mass function of a Gumbel distribution</h2><span id='topic+pdf.Gumbel'></span><span id='topic+log_pdf.Gumbel'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a Gumbel distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gumbel'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Gumbel'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Gumbel_+3A_d">d</code></td>
<td>
<p>A <code>Gumbel</code> object created by a call to <code><a href="#topic+Gumbel">Gumbel()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Gumbel_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Gumbel_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Gumbel_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Gumbel_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+dgev">dgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Gumbel(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='pdf.HurdleNegativeBinomial'>Evaluate the probability mass function of a hurdle negative binomial distribution</h2><span id='topic+pdf.HurdleNegativeBinomial'></span><span id='topic+log_pdf.HurdleNegativeBinomial'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a hurdle negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HurdleNegativeBinomial'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'HurdleNegativeBinomial'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.HurdleNegativeBinomial_+3A_d">d</code></td>
<td>
<p>A <code>HurdleNegativeBinomial</code> object created by a call to <code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.HurdleNegativeBinomial_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.HurdleNegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.HurdleNegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.HurdleNegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+dhnbinom">dhnbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a hurdle negative binomial distribution
X &lt;- HurdleNegativeBinomial(mu = 2.5, theta = 1, pi = 0.75)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='pdf.HurdlePoisson'>Evaluate the probability mass function of a hurdle Poisson distribution</h2><span id='topic+pdf.HurdlePoisson'></span><span id='topic+log_pdf.HurdlePoisson'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a hurdle Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HurdlePoisson'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'HurdlePoisson'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.HurdlePoisson_+3A_d">d</code></td>
<td>
<p>A <code>HurdlePoisson</code> object created by a call to <code><a href="#topic+HurdlePoisson">HurdlePoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.HurdlePoisson_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.HurdlePoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.HurdlePoisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.HurdlePoisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+dhpois">dhpois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a hurdle Poisson distribution
X &lt;- HurdlePoisson(lambda = 2.5, pi = 0.75)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='pdf.HyperGeometric'>Evaluate the probability mass function of a HyperGeometric distribution</h2><span id='topic+pdf.HyperGeometric'></span><span id='topic+log_pdf.HyperGeometric'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+HyperGeometric">HyperGeometric()</a></code> for some properties
of the HyperGeometric distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HyperGeometric'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'HyperGeometric'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.HyperGeometric_+3A_d">d</code></td>
<td>
<p>A <code>HyperGeometric</code> object created by a call to <code><a href="#topic+HyperGeometric">HyperGeometric()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.HyperGeometric_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.HyperGeometric_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.HyperGeometric_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.HyperGeometric_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dhyper">dhyper</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other HyperGeometric distribution: 
<code><a href="#topic+cdf.HyperGeometric">cdf.HyperGeometric</a>()</code>,
<code><a href="#topic+quantile.HyperGeometric">quantile.HyperGeometric</a>()</code>,
<code><a href="#topic+random.HyperGeometric">random.HyperGeometric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- HyperGeometric(4, 5, 8)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='pdf.Logistic'>Evaluate the probability mass function of a Logistic distribution</h2><span id='topic+pdf.Logistic'></span><span id='topic+log_pdf.Logistic'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+Logistic">Logistic()</a></code> for some properties
of the Logistic distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Logistic'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Logistic'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Logistic_+3A_d">d</code></td>
<td>
<p>A <code>Logistic</code> object created by a call to <code><a href="#topic+Logistic">Logistic()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Logistic_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Logistic_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Logistic_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Logistic_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dlogis">dlogis</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other Logistic distribution: 
<code><a href="#topic+cdf.Logistic">cdf.Logistic</a>()</code>,
<code><a href="#topic+quantile.Logistic">quantile.Logistic</a>()</code>,
<code><a href="#topic+random.Logistic">random.Logistic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Logistic(2, 4)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='pdf.LogNormal'>Evaluate the probability mass function of a LogNormal distribution</h2><span id='topic+pdf.LogNormal'></span><span id='topic+log_pdf.LogNormal'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+LogNormal">LogNormal()</a></code> for some properties
of the LogNormal distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LogNormal'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'LogNormal'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.LogNormal_+3A_d">d</code></td>
<td>
<p>A <code>LogNormal</code> object created by a call to <code><a href="#topic+LogNormal">LogNormal()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.LogNormal_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.LogNormal_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.LogNormal_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.LogNormal_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dlnorm">dlnorm</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other LogNormal distribution: 
<code><a href="#topic+cdf.LogNormal">cdf.LogNormal</a>()</code>,
<code><a href="#topic+fit_mle.LogNormal">fit_mle.LogNormal</a>()</code>,
<code><a href="#topic+quantile.LogNormal">quantile.LogNormal</a>()</code>,
<code><a href="#topic+random.LogNormal">random.LogNormal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- LogNormal(0.3, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='pdf.Multinomial'>Evaluate the probability mass function of a Multinomial distribution</h2><span id='topic+pdf.Multinomial'></span><span id='topic+log_pdf.Multinomial'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+Multinomial">Multinomial()</a></code> for some properties
of the Multinomial distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Multinomial'
pdf(d, x, ...)

## S3 method for class 'Multinomial'
log_pdf(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Multinomial_+3A_d">d</code></td>
<td>
<p>A <code>Multinomial</code> object created by a call to <code><a href="#topic+Multinomial">Multinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Multinomial_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Multinomial_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of probabilities, one for each element of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other Multinomial distribution: 
<code><a href="#topic+random.Multinomial">random.Multinomial</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Multinomial(size = 5, p = c(0.3, 0.4, 0.2, 0.1))
X

random(X, 10)

# pdf(X, 2)
# log_pdf(X, 2)
</code></pre>

<hr>
<h2 id='pdf.NegativeBinomial'>Evaluate the probability mass function of a NegativeBinomial distribution</h2><span id='topic+pdf.NegativeBinomial'></span><span id='topic+log_pdf.NegativeBinomial'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a NegativeBinomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NegativeBinomial'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'NegativeBinomial'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.NegativeBinomial_+3A_d">d</code></td>
<td>
<p>A <code>NegativeBinomial</code> object created by a call to
<code><a href="#topic+NegativeBinomial">NegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.NegativeBinomial_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.NegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.NegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.NegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dnbinom">dnbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other NegativeBinomial distribution: 
<code><a href="#topic+cdf.NegativeBinomial">cdf.NegativeBinomial</a>()</code>,
<code><a href="#topic+quantile.NegativeBinomial">quantile.NegativeBinomial</a>()</code>,
<code><a href="#topic+random.NegativeBinomial">random.NegativeBinomial</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- NegativeBinomial(size = 5, p = 0.1)
X

random(X, 10)

pdf(X, 50)
log_pdf(X, 50)

cdf(X, 50)
quantile(X, 0.7)

## alternative parameterization of X
Y &lt;- NegativeBinomial(mu = 45, size = 5)
Y
cdf(Y, 50)
quantile(Y, 0.7)
</code></pre>

<hr>
<h2 id='pdf.Normal'>Evaluate the probability mass function of a Normal distribution</h2><span id='topic+pdf.Normal'></span><span id='topic+log_pdf.Normal'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+Normal">Normal()</a></code> for some properties
of the Normal distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Normal'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Normal'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Normal_+3A_d">d</code></td>
<td>
<p>A <code>Normal</code> object created by a call to <code><a href="#topic+Normal">Normal()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Normal_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Normal_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Normal_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Normal_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dnorm">dnorm</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other Normal distribution: 
<code><a href="#topic+cdf.Normal">cdf.Normal</a>()</code>,
<code><a href="#topic+fit_mle.Normal">fit_mle.Normal</a>()</code>,
<code><a href="#topic+quantile.Normal">quantile.Normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Normal(5, 2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

### example: calculating p-values for two-sided Z-test

# here the null hypothesis is H_0: mu = 3
# and we assume sigma = 2

# exactly the same as: Z &lt;- Normal(0, 1)
Z &lt;- Normal()

# data to test
x &lt;- c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2)
nx &lt;- length(x)

# calculate the z-statistic
z_stat &lt;- (mean(x) - 3) / (2 / sqrt(nx))
z_stat

# calculate the two-sided p-value
1 - cdf(Z, abs(z_stat)) + cdf(Z, -abs(z_stat))

# exactly equivalent to the above
2 * cdf(Z, -abs(z_stat))

# p-value for one-sided test
# H_0: mu &lt;= 3   vs   H_A: mu &gt; 3
1 - cdf(Z, z_stat)

# p-value for one-sided test
# H_0: mu &gt;= 3   vs   H_A: mu &lt; 3
cdf(Z, z_stat)

### example: calculating a 88 percent Z CI for a mean

# same `x` as before, still assume `sigma = 2`

# lower-bound
mean(x) - quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# upper-bound
mean(x) + quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# equivalent to
mean(x) + c(-1, 1) * quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# also equivalent to
mean(x) + quantile(Z, 0.12 / 2) * 2 / sqrt(nx)
mean(x) + quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

### generating random samples and plugging in ks.test()

set.seed(27)

# generate a random sample
ns &lt;- random(Normal(3, 7), 26)

# test if sample is Normal(3, 7)
ks.test(ns, pnorm, mean = 3, sd = 7)

# test if sample is gamma(8, 3) using base R pgamma()
ks.test(ns, pgamma, shape = 8, rate = 3)

### MISC

# note that the cdf() and quantile() functions are inverses
cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='pdf.Poisson'>Evaluate the probability mass function of a Poisson distribution</h2><span id='topic+pdf.Poisson'></span><span id='topic+log_pdf.Poisson'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Poisson'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Poisson'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Poisson_+3A_d">d</code></td>
<td>
<p>A <code>Poisson</code> object created by a call to <code><a href="#topic+Poisson">Poisson()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Poisson_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Poisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Poisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Poisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dpois">dpois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Poisson(2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='pdf.RevWeibull'>Evaluate the probability mass function of an RevWeibull distribution</h2><span id='topic+pdf.RevWeibull'></span><span id='topic+log_pdf.RevWeibull'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of an RevWeibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RevWeibull'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'RevWeibull'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.RevWeibull_+3A_d">d</code></td>
<td>
<p>A <code>RevWeibull</code> object created by a call to <code><a href="#topic+RevWeibull">RevWeibull()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.RevWeibull_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.RevWeibull_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.RevWeibull_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.RevWeibull_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+dgev">dgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- RevWeibull(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='pdf.StudentsT'>Evaluate the probability mass function of a StudentsT distribution</h2><span id='topic+pdf.StudentsT'></span><span id='topic+log_pdf.StudentsT'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+StudentsT">StudentsT()</a></code> for some properties
of the StudentsT distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'StudentsT'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'StudentsT'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.StudentsT_+3A_d">d</code></td>
<td>
<p>A <code>StudentsT</code> object created by a call to <code><a href="#topic+StudentsT">StudentsT()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.StudentsT_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.StudentsT_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.StudentsT_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.StudentsT_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dt">dt</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other StudentsT distribution: 
<code><a href="#topic+cdf.StudentsT">cdf.StudentsT</a>()</code>,
<code><a href="#topic+quantile.StudentsT">quantile.StudentsT</a>()</code>,
<code><a href="#topic+random.StudentsT">random.StudentsT</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- StudentsT(3)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

### example: calculating p-values for two-sided T-test

# here the null hypothesis is H_0: mu = 3

# data to test
x &lt;- c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2)
nx &lt;- length(x)

# calculate the T-statistic
t_stat &lt;- (mean(x) - 3) / (sd(x) / sqrt(nx))
t_stat

# null distribution of statistic depends on sample size!
T &lt;- StudentsT(df = nx - 1)

# calculate the two-sided p-value
1 - cdf(T, abs(t_stat)) + cdf(T, -abs(t_stat))

# exactly equivalent to the above
2 * cdf(T, -abs(t_stat))

# p-value for one-sided test
# H_0: mu &lt;= 3   vs   H_A: mu &gt; 3
1 - cdf(T, t_stat)

# p-value for one-sided test
# H_0: mu &gt;= 3   vs   H_A: mu &lt; 3
cdf(T, t_stat)

### example: calculating a 88 percent T CI for a mean

# lower-bound
mean(x) - quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# upper-bound
mean(x) + quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# equivalent to
mean(x) + c(-1, 1) * quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# also equivalent to
mean(x) + quantile(T, 0.12 / 2) * sd(x) / sqrt(nx)
mean(x) + quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)
</code></pre>

<hr>
<h2 id='pdf.Uniform'>Evaluate the probability mass function of a continuous Uniform distribution</h2><span id='topic+pdf.Uniform'></span><span id='topic+log_pdf.Uniform'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a continuous Uniform distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Uniform'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Uniform'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Uniform_+3A_d">d</code></td>
<td>
<p>A <code>Uniform</code> object created by a call to <code><a href="#topic+Uniform">Uniform()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Uniform_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Uniform_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Uniform_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Uniform_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dunif">dunif</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Uniform(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='pdf.Weibull'>Evaluate the probability mass function of a Weibull distribution</h2><span id='topic+pdf.Weibull'></span><span id='topic+log_pdf.Weibull'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+Weibull">Weibull()</a></code> for some properties
of the Weibull distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Weibull'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'Weibull'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.Weibull_+3A_d">d</code></td>
<td>
<p>A <code>Weibull</code> object created by a call to <code><a href="#topic+Weibull">Weibull()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.Weibull_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.Weibull_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.Weibull_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.Weibull_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+dweibull">dweibull</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>See Also</h3>

<p>Other Weibull distribution: 
<code><a href="#topic+cdf.Weibull">cdf.Weibull</a>()</code>,
<code><a href="#topic+quantile.Weibull">quantile.Weibull</a>()</code>,
<code><a href="#topic+random.Weibull">random.Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Weibull(0.3, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='pdf.ZINegativeBinomial'>Evaluate the probability mass function of a zero-inflated negative binomial distribution</h2><span id='topic+pdf.ZINegativeBinomial'></span><span id='topic+log_pdf.ZINegativeBinomial'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a zero-inflated negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZINegativeBinomial'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'ZINegativeBinomial'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.ZINegativeBinomial_+3A_d">d</code></td>
<td>
<p>A <code>ZINegativeBinomial</code> object created by a call to <code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.ZINegativeBinomial_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.ZINegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.ZINegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.ZINegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+dzinbinom">dzinbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-inflated negative binomial distribution
X &lt;- ZINegativeBinomial(mu = 2.5, theta = 1, pi = 0.25)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='pdf.ZIPoisson'>Evaluate the probability mass function of a zero-inflated Poisson distribution</h2><span id='topic+pdf.ZIPoisson'></span><span id='topic+log_pdf.ZIPoisson'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a zero-inflated Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZIPoisson'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'ZIPoisson'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.ZIPoisson_+3A_d">d</code></td>
<td>
<p>A <code>ZIPoisson</code> object created by a call to <code><a href="#topic+ZIPoisson">ZIPoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.ZIPoisson_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.ZIPoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.ZIPoisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.ZIPoisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+dzipois">dzipois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-inflated Poisson distribution
X &lt;- ZIPoisson(lambda = 2.5, pi = 0.25)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='pdf.ZTNegativeBinomial'>Evaluate the probability mass function of a zero-truncated negative binomial distribution</h2><span id='topic+pdf.ZTNegativeBinomial'></span><span id='topic+log_pdf.ZTNegativeBinomial'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a zero-truncated negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZTNegativeBinomial'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'ZTNegativeBinomial'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.ZTNegativeBinomial_+3A_d">d</code></td>
<td>
<p>A <code>ZTNegativeBinomial</code> object created by a call to <code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.ZTNegativeBinomial_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.ZTNegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.ZTNegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.ZTNegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+dztnbinom">dztnbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-truncated negative binomial distribution
X &lt;- ZTNegativeBinomial(mu = 2.5, theta = 1)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='pdf.ZTPoisson'>Evaluate the probability mass function of a zero-truncated Poisson distribution</h2><span id='topic+pdf.ZTPoisson'></span><span id='topic+log_pdf.ZTPoisson'></span>

<h3>Description</h3>

<p>Evaluate the probability mass function of a zero-truncated Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZTPoisson'
pdf(d, x, drop = TRUE, elementwise = NULL, ...)

## S3 method for class 'ZTPoisson'
log_pdf(d, x, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf.ZTPoisson_+3A_d">d</code></td>
<td>
<p>A <code>ZTPoisson</code> object created by a call to <code><a href="#topic+ZTPoisson">ZTPoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="pdf.ZTPoisson_+3A_x">x</code></td>
<td>
<p>A vector of elements whose probabilities you would like to
determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="pdf.ZTPoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="pdf.ZTPoisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>d</code> be evaluated
at all elements of <code>x</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>d</code> and <code>x</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="pdf.ZTPoisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+dztpois">dztpois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(x)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized distribution
object, a matrix with <code>length(x)</code> columns containing all possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-truncated Poisson distribution
X &lt;- ZTPoisson(lambda = 2.5)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='plot_cdf'>Plot the CDF of a distribution</h2><span id='topic+plot_cdf'></span>

<h3>Description</h3>

<p>A function to easily plot the CDF of a distribution using <code>ggplot2</code>. Requires <code>ggplot2</code> to be loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cdf(d, limits = NULL, p = 0.001, plot_theme = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cdf_+3A_d">d</code></td>
<td>
<p>A <code>distribution</code> object</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_limits">limits</code></td>
<td>
<p>either <code>NULL</code> (default) or a vector of length 2 that specifies the range of the x-axis</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_p">p</code></td>
<td>
<p>If <code>limits</code> is <code>NULL</code>, the range of the x-axis will be the support of <code>d</code> if this is a bounded
interval, or <code>quantile(d, p)</code> and <code>quantile(d, 1 - p)</code> if lower and/or upper limits of the support is
<code>-Inf</code>/<code>Inf</code>.  Defaults to 0.001.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_plot_theme">plot_theme</code></td>
<td>
<p>specify theme of resulting plot using <code>ggplot2</code>. Default is <code>theme_minimal</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
N1 &lt;- Normal()
plot_cdf(N1)

N2 &lt;- Normal(0, c(1, 2))
plot_cdf(N2)

B1 &lt;- Binomial(10, 0.2)
plot_cdf(B1)

B2 &lt;- Binomial(10, c(0.2, 0.5))
plot_cdf(B2)
</code></pre>

<hr>
<h2 id='plot_pdf'>Plot the PDF of a distribution</h2><span id='topic+plot_pdf'></span>

<h3>Description</h3>

<p>A function to easily plot the PDF of a distribution using <code>ggplot2</code>. Requires <code>ggplot2</code> to be loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pdf(d, limits = NULL, p = 0.001, plot_theme = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pdf_+3A_d">d</code></td>
<td>
<p>A <code>distribution</code> object</p>
</td></tr>
<tr><td><code id="plot_pdf_+3A_limits">limits</code></td>
<td>
<p>either <code>NULL</code> (default) or a vector of length 2 that specifies the range of the x-axis</p>
</td></tr>
<tr><td><code id="plot_pdf_+3A_p">p</code></td>
<td>
<p>If <code>limits</code> is <code>NULL</code>, the range of the x-axis will be the support of <code>d</code> if this is a bounded
interval, or <code>quantile(d, p)</code> and <code>quantile(d, 1 - p)</code> if lower and/or upper limits of the support is
<code>-Inf</code>/<code>Inf</code>.  Defaults to 0.001.</p>
</td></tr>
<tr><td><code id="plot_pdf_+3A_plot_theme">plot_theme</code></td>
<td>
<p>specify theme of resulting plot using <code>ggplot2</code>. Default is <code>theme_minimal</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
N1 &lt;- Normal()
plot_pdf(N1)

N2 &lt;- Normal(0, c(1, 2))
plot_pdf(N2)

B1 &lt;- Binomial(10, 0.2)
plot_pdf(B1)

B2 &lt;- Binomial(10, c(0.2, 0.5))
plot_pdf(B2)
</code></pre>

<hr>
<h2 id='plot.distribution'>Plot the p.m.f, p.d.f or c.d.f. of a univariate distribution</h2><span id='topic+plot.distribution'></span>

<h3>Description</h3>

<p>Plot method for an object inheriting from class <code>"distribution"</code>.
By default the probability density function (p.d.f.), for a continuous
variable, or the probability mass function (p.m.f.), for a discrete
variable, is plotted.  The cumulative distribution function (c.d.f.)
will be plotted if <code>cdf = TRUE</code>.  Multiple functions are included
in the plot if any of the parameter vectors in <code>x</code> has length greater
than 1.  See the argument <code>all</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'distribution'
plot(
  x,
  cdf = FALSE,
  p = c(0.1, 99.9),
  len = 1000,
  all = FALSE,
  legend_args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.distribution_+3A_x">x</code></td>
<td>
<p>an object of class <code>c("name", "distribution")</code>, where
<code>"name"</code> is the name of the distribution.</p>
</td></tr>
<tr><td><code id="plot.distribution_+3A_cdf">cdf</code></td>
<td>
<p>A logical scalar.  If <code>cdf = TRUE</code> then the cumulative
distribution function (c.d.f.) is plotted.  Otherwise, the probability
density function (p.d.f.), for a continuous variable, or the probability
mass function (p.m.f.), for a discrete variable, is plotted.</p>
</td></tr>
<tr><td><code id="plot.distribution_+3A_p">p</code></td>
<td>
<p>A numeric vector.  If <code>xlim</code> is not passed in <code>...</code>
then <code>p</code> is the fallback option for setting the range of values
over which the p.m.f, p.d.f. or c.d.f is plotted.  See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="plot.distribution_+3A_len">len</code></td>
<td>
<p>An integer scalar.  If <code>x</code> is a continuous distribution
object then <code>len</code> is the number of values at which the p.d.f or
c.d.f. is evaluated to produce the plot.  The larger <code>len</code> is the
smoother is the curve.</p>
</td></tr>
<tr><td><code id="plot.distribution_+3A_all">all</code></td>
<td>
<p>A logical scalar.  If <code>all = TRUE</code> then a separate
distribution is plotted for all the combinations of parameter
values present in the parameter vectors present in <code>x</code>.  These
combinations are generated using <code><a href="base.html#topic+expand.grid">expand.grid</a></code>.  If
<code>all = FALSE</code> then the number of distributions plotted is equal to
the maximum of the lengths of these parameter vectors, with shorter
vectors recycled to this length if necessary using <code><a href="base.html#topic+rep_len">rep_len</a></code>.</p>
</td></tr>
<tr><td><code id="plot.distribution_+3A_legend_args">legend_args</code></td>
<td>
<p>A list of arguments to be passed to
<code><a href="graphics.html#topic+legend">legend</a></code>.  In particular, the argument <code>x</code>
(perhaps in conjunction with <code>legend_args$y</code>) can be used to set the
position of the legend.  If <code>legend_args$x</code> is not supplied then
<code>"bottomright"</code> is used if <code>cdf = TRUE</code> and <code>"topright"</code> if
<code>cdf = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.distribution_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="stats.html#topic+ecdf">plot.ecdf</a></code> and <code><a href="graphics.html#topic+lines">lines</a></code>,
such as <code>xlim, ylim, xlab, ylab, main, lwd, lty, col, pch</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>xlim</code> is passed in <code>...</code> then this determines the
range of values of the variable to be plotted on the horizontal axis.
If <code>x</code> is a discrete distribution object then the values for which
the p.m.f. or c.d.f. is plotted is the smallest set of consecutive
integers that contains both components of <code>xlim</code>.  Otherwise,
<code>xlim</code> is used directly.
</p>
<p>If <code>xlim</code> is not passed in <code>...</code> then the range of values spans
the support of the distribution, with the following proviso: if the
lower (upper) endpoint of the distribution is <code>-Inf</code> (<code>Inf</code>)
then the lower (upper) limit of the plotting range is set to the
<code>p[1]</code>\
</p>
<p>If the name of <code>x</code> is a single upper case letter then that name is
used to labels the axes of the plot.  Otherwise, <code>x</code> and
<code>P(X = x)</code> or <code>f(x)</code> are used.
</p>
<p>A legend is included only if at least one of the parameter vectors in
<code>x</code> has length greater than 1.
</p>
<p>Plots of c.d.f.s are produced using calls to
<code><a href="stats.html#topic+approxfun">approxfun</a></code> and <code><a href="stats.html#topic+ecdf">plot.ecdf</a></code>.
</p>


<h3>Value</h3>

<p>An object with the same class as <code>x</code>, in which the parameter
vectors have been expanded to contain a parameter combination for each
function plotted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- Binomial(20, 0.7)
plot(B)
plot(B, cdf = TRUE)

B2 &lt;- Binomial(20, c(0.1, 0.5, 0.9))
plot(B2, legend_args = list(x = "top"))
x &lt;- plot(B2, cdf = TRUE)
x$size
x$p

X &lt;- Poisson(2)
plot(X)
plot(X, cdf = TRUE)

G &lt;- Gamma(c(1, 3), 1:2)
plot(G)
plot(G, all = TRUE)
plot(G, cdf = TRUE)

C &lt;- Cauchy()
plot(C, p = c(1, 99), len = 10000)
plot(C, cdf = TRUE, p = c(1, 99))
</code></pre>

<hr>
<h2 id='Poisson'>Create a Poisson distribution</h2><span id='topic+Poisson'></span>

<h3>Description</h3>

<p>Poisson distributions are frequently used to model counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Poisson(lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Poisson_+3A_lambda">lambda</code></td>
<td>
<p>The shape parameter, which is also the mean and the
variance of the distribution. Can be any positive number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail.
</p>
<p>In the following, let <code class="reqn">X</code> be a Poisson random variable with parameter
<code>lambda</code> = <code class="reqn">\lambda</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">\{0, 1, 2, 3, ...\}</code>
</p>
<p><strong>Mean</strong>: <code class="reqn">\lambda</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">\lambda</code>
</p>
<p><strong>Probability mass function (p.m.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = \frac{\lambda^k e^{-\lambda}}{k!}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X \le k) = e^{-\lambda}
    \sum_{i = 0}^{\lfloor k \rfloor} \frac{\lambda^i}{i!}
  </code>
</p>

<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    E(e^{tX}) = e^{\lambda (e^t - 1)}
  </code>
</p>



<h3>Value</h3>

<p>A <code>Poisson</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Poisson(2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='prodist'>Extracting fitted or predicted probability distributions from models</h2><span id='topic+prodist'></span><span id='topic+prodist.lm'></span><span id='topic+prodist.glm'></span><span id='topic+prodist.negbin'></span><span id='topic+prodist.Arima'></span><span id='topic+prodist.hurdle'></span><span id='topic+prodist.zeroinfl'></span><span id='topic+prodist.zerotrunc'></span>

<h3>Description</h3>

<p>Generic function with methods for various model classes for extracting
fitted (in-sample) or predicted (out-of-sample) probability <code>distributions3</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prodist(object, ...)

## S3 method for class 'lm'
prodist(object, ..., sigma = "ML")

## S3 method for class 'glm'
prodist(object, ..., dispersion = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodist_+3A_object">object</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="prodist_+3A_...">...</code></td>
<td>
<p>Arguments passed on to methods, typically for calling the
underlying <code><a href="stats.html#topic+predict">predict</a></code> methods, e.g., <code>newdata</code> for
<code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code> objects or <code>n.ahead</code>
for <code><a href="stats.html#topic+arima">arima</a></code> objects.</p>
</td></tr>
<tr><td><code id="prodist_+3A_sigma">sigma</code></td>
<td>
<p>character or numeric or <code>NULL</code>. Specification of the standard
deviation <code>sigma</code> to be used for the <code><a href="#topic+Normal">Normal</a></code> distribution in the
<code>lm</code> method. The default <code>"ML"</code> (or equivalently <code>"MLE"</code> or <code>NULL</code>)
uses the maximum likelihood estimate based on the residual sum of squares divided
by the number of observations, n. Alternatively, <code>sigma = "OLS"</code> uses the
least-squares estimate (divided by the residual degrees of freedom, n - k). Finally,
a concrete numeric value can also be specified in <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="prodist_+3A_dispersion">dispersion</code></td>
<td>
<p>character or numeric or <code>NULL</code>. Specification of the
dispersion parameter in the <code>glm</code> method. The default <code>NULL</code>
(or equivalently <code>"deviance"</code>) is to use the <code><a href="stats.html#topic+deviance">deviance</a></code>
divided by the number of observations, n. Alternatively, <code>dispersion = "Chisquared"</code>
uses the Chi-squared statistic divided by the residual degrees of freedom, n - k.
Finally, a concrete numeric value can also be specified in <code>dispersion</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To facilitate making probabilistic forecasts based on regression and time
series model objects, the function <code>prodist</code> extracts fitted or
predicted probability <code>distribution</code> objects. Currently, methods are
provided for objects fitted by <code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, and <code><a href="stats.html#topic+arima">arima</a></code> in base R as
well as <code>glm.nb</code> from the <span class="pkg">MASS</span> package and
<code>hurdle</code>/<code>zeroinfl</code>/<code>zerotrunc</code> from the <span class="pkg">pscl</span> or
<span class="pkg">countreg</span> packages.
</p>
<p>All methods essentially
proceed in two steps: First, the standard <code><a href="stats.html#topic+predict">predict</a></code>
method for these model objects is used to compute fitted (in-sample, default)
or predicted (out-of-sample) distribution parameters. Typically, this includes
the mean plus further parameters describing scale, dispersion, shape, etc.).
Second, the <code>distributions</code> objects are set up using the generator
functions from <span class="pkg">distributions3</span>.
</p>
<p>Note that these probability distributions only reflect the random variation in
the dependent variable based on the model employed (and its associated
distributional assumpation for the dependent variable). This does not capture
the uncertainty in the parameter estimates.
</p>
<p>For both linear regression models and generalized linear models, estimated
by <code>lm</code> and <code>glm</code> respectively, there is some ambiguity as to which
estimate for the dispersion parameter of the model is to be used. While the
<code><a href="stats.html#topic+logLik">logLik</a></code> methods use the maximum-likelihood (ML) estimate
implicitly, the <code>summary</code> methods report an estimate that is standardized
with the residual degrees of freedom, n - k (rather than the number of
observations, n). The <code>prodist</code> methods for these objects follow
the <code>logLik</code> method by default but the <code>summary</code> behavior can be
mimicked by setting the <code>sigma</code> or <code>dispersion</code> arguments
accordingly.
</p>


<h3>Value</h3>

<p>An object inheriting from <code>distribution</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+arima">arima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Model: Linear regression
## Fit: lm
## Data: 1920s cars data
data("cars", package = "datasets")

## Stopping distance (ft) explained by speed (mph)
reg &lt;- lm(dist ~ speed, data = cars)

## Extract fitted normal distributions (in-sample, with constant variance)
pd &lt;- prodist(reg)
head(pd)

## Extract log-likelihood from model object
logLik(reg)

## Replicate log-likelihood via distributions object
sum(log_pdf(pd, cars$dist))
log_likelihood(pd, cars$dist)

## Compute corresponding medians and 90% interval
qd &lt;- quantile(pd, c(0.05, 0.5, 0.95))
head(qd)

## Visualize observations with predicted quantiles
plot(dist ~ speed, data = cars)
matplot(cars$speed, qd, add = TRUE, type = "l", col = 2, lty = 1)

## Sigma estimated by maximum-likelihood estimate (default, used in logLik)
## vs. least-squares estimate (used in summary)
nd &lt;- data.frame(speed = 50)
prodist(reg, newdata = nd, sigma = "ML")
prodist(reg, newdata = nd, sigma = "OLS")
summary(reg)$sigma


## Model: Poisson generalized linear model
## Fit: glm
## Data: FIFA 2018 World Cup data
data("FIFA2018", package = "distributions3")

## Number of goals per team explained by ability differences
poisreg &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson)
summary(poisreg)
## Interpretation: When the ratio of abilities increases by 1 percent,
## the expected number of goals increases by around 0.4 percent

## Predict fitted Poisson distributions for teams with equal ability (out-of-sample)
nd &lt;- data.frame(difference = 0)
prodist(poisreg, newdata = nd)

## Extract fitted Poisson distributions (in-sample)
pd &lt;- prodist(poisreg)
head(pd)

## Extract log-likelihood from model object
logLik(poisreg)

## Replicate log-likelihood via distributions object
sum(log_pdf(pd, FIFA2018$goals))
log_likelihood(pd, FIFA2018$goals)


## Model: Autoregressive integrated moving average model
## Fit: arima
## Data: Quarterly approval ratings of U.S. presidents (1945-1974)
data("presidents", package = "datasets")

## ARMA(2,1) model
arma21 &lt;- arima(presidents, order = c(2, 0, 1))

## Extract predicted normal distributions for next two years
p &lt;- prodist(arma21, n.ahead = 8)
p

## Compute median (= mean) forecast along with 80% and 95% interval
quantile(p, c(0.5, 0.1, 0.9, 0.025, 0.975))

</code></pre>

<hr>
<h2 id='quantile.Bernoulli'>Determine quantiles of a Bernoulli distribution</h2><span id='topic+quantile.Bernoulli'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bernoulli'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Bernoulli_+3A_x">x</code></td>
<td>
<p>A <code>Bernoulli</code> object created by a call to <code><a href="#topic+Bernoulli">Bernoulli()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Bernoulli_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Bernoulli_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Bernoulli_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Bernoulli_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qbinom">qbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Bernoulli(0.7)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)
pdf(X, 1)
log_pdf(X, 1)
cdf(X, 0)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='quantile.Beta'>Determine quantiles of a Beta distribution</h2><span id='topic+quantile.Beta'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Beta'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Beta_+3A_x">x</code></td>
<td>
<p>A <code>Beta</code> object created by a call to <code><a href="#topic+Beta">Beta()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Beta_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Beta_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Beta_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Beta_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qbeta">qbeta</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Beta(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

mean(X)
variance(X)
skewness(X)
kurtosis(X)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='quantile.Binomial'>Determine quantiles of a Binomial distribution</h2><span id='topic+quantile.Binomial'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Binomial'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Binomial_+3A_x">x</code></td>
<td>
<p>A <code>Binomial</code> object created by a call to <code><a href="#topic+Binomial">Binomial()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Binomial_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Binomial_+3A_drop">drop</code></td>
<td>
<p>logical. Shoul the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Binomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Binomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qbinom">qbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Binomial(10, 0.2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2L)
log_pdf(X, 2L)

cdf(X, 4L)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='quantile.Categorical'>Determine quantiles of a Categorical discrete distribution</h2><span id='topic+quantile.Categorical'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Categorical'
quantile(x, probs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Categorical_+3A_x">x</code></td>
<td>
<p>A <code>Categorical</code> object created by a call to <code><a href="#topic+Categorical">Categorical()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Categorical_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Categorical_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of quantiles, one for each element of <code>probs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Categorical(1:3, p = c(0.4, 0.1, 0.5))
X

Y &lt;- Categorical(LETTERS[1:4])
Y

random(X, 10)
random(Y, 10)

pdf(X, 1)
log_pdf(X, 1)

cdf(X, 1)
quantile(X, 0.5)

# cdfs are only defined for numeric sample spaces. this errors!
# cdf(Y, "a")

# same for quantiles. this also errors!
# quantile(Y, 0.7)
</code></pre>

<hr>
<h2 id='quantile.Cauchy'>Determine quantiles of a Cauchy distribution</h2><span id='topic+quantile.Cauchy'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cauchy'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Cauchy_+3A_x">x</code></td>
<td>
<p>A <code>Cauchy</code> object created by a call to <code><a href="#topic+Cauchy">Cauchy()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Cauchy_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Cauchy_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Cauchy_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Cauchy_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qcauchy">qcauchy</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Cauchy(10, 0.2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 2)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='quantile.ChiSquare'>Determine quantiles of a chi square distribution</h2><span id='topic+quantile.ChiSquare'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ChiSquare'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.ChiSquare_+3A_x">x</code></td>
<td>
<p>A <code>ChiSquare</code> object created by a call to <code><a href="#topic+ChiSquare">ChiSquare()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.ChiSquare_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.ChiSquare_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.ChiSquare_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.ChiSquare_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qchisq">qchisq</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- ChiSquare(5)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='quantile.Erlang'>Determine quantiles of an Erlang distribution</h2><span id='topic+quantile.Erlang'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Erlang'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Erlang_+3A_x">x</code></td>
<td>
<p>An <code>Erlang</code> object created by a call to <code><a href="#topic+Erlang">Erlang()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Erlang_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Erlang_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Erlang_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Erlang_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qgamma">qgamma</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Erlang(5, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='quantile.Exponential'>Determine quantiles of an Exponential distribution</h2><span id='topic+quantile.Exponential'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Exponential'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Exponential_+3A_x">x</code></td>
<td>
<p>An <code>Exponential</code> object created by a call to <code><a href="#topic+Exponential">Exponential()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Exponential_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Exponential_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Exponential_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Exponential_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qexp">qexp</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Exponential(5)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='quantile.FisherF'>Determine quantiles of an F distribution</h2><span id='topic+quantile.FisherF'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FisherF'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.FisherF_+3A_x">x</code></td>
<td>
<p>A <code>FisherF</code> object created by a call to <code><a href="#topic+FisherF">FisherF()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.FisherF_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.FisherF_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.FisherF_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.FisherF_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qf">qf</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- FisherF(5, 10, 0.2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='quantile.Frechet'>Determine quantiles of a Frechet distribution</h2><span id='topic+quantile.Frechet'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Frechet'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Frechet_+3A_x">x</code></td>
<td>
<p>A <code>Frechet</code> object created by a call to <code><a href="#topic+Frechet">Frechet()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Frechet_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Frechet_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Frechet_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Frechet_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+qgev">qgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Frechet(0, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='quantile.Gamma'>Determine quantiles of a Gamma distribution</h2><span id='topic+quantile.Gamma'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gamma'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Gamma_+3A_x">x</code></td>
<td>
<p>A <code>Gamma</code> object created by a call to <code><a href="#topic+Gamma">Gamma()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Gamma_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Gamma_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Gamma_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Gamma_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qgamma">qgamma</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Gamma(5, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='quantile.Geometric'>Determine quantiles of a Geometric distribution</h2><span id='topic+quantile.Geometric'></span>

<h3>Description</h3>

<p>Determine quantiles of a Geometric distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Geometric'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Geometric_+3A_x">x</code></td>
<td>
<p>A <code>Geometric</code> object created by a call to <code><a href="#topic+Geometric">Geometric()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Geometric_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Geometric_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Geometric_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Geometric_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qgeom">qgeom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>See Also</h3>

<p>Other Geometric distribution: 
<code><a href="#topic+cdf.Geometric">cdf.Geometric</a>()</code>,
<code><a href="#topic+pdf.Geometric">pdf.Geometric</a>()</code>,
<code><a href="#topic+random.Geometric">random.Geometric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Geometric(0.3)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='quantile.GEV'>Determine quantiles of a GEV distribution</h2><span id='topic+quantile.GEV'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GEV'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.GEV_+3A_x">x</code></td>
<td>
<p>A <code>GEV</code> object created by a call to <code><a href="#topic+GEV">GEV()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.GEV_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.GEV_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.GEV_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.GEV_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+qgev">qgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- GEV(1, 2, 0.1)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='quantile.GP'>Determine quantiles of a GP distribution</h2><span id='topic+quantile.GP'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GP'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.GP_+3A_x">x</code></td>
<td>
<p>A <code>GP</code> object created by a call to <code><a href="#topic+GP">GP()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.GP_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.GP_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.GP_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.GP_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+qgp">qgp</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- GP(0, 2, 0.1)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='quantile.Gumbel'>Determine quantiles of a Gumbel distribution</h2><span id='topic+quantile.Gumbel'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gumbel'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Gumbel_+3A_x">x</code></td>
<td>
<p>A <code>Gumbel</code> object created by a call to <code><a href="#topic+Gumbel">Gumbel()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Gumbel_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Gumbel_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Gumbel_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Gumbel_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+qgev">qgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Gumbel(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='quantile.HurdleNegativeBinomial'>Determine quantiles of a hurdle negative binomial distribution</h2><span id='topic+quantile.HurdleNegativeBinomial'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HurdleNegativeBinomial'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.HurdleNegativeBinomial_+3A_x">x</code></td>
<td>
<p>A <code>HurdleNegativeBinomial</code> object created by a call to <code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.HurdleNegativeBinomial_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.HurdleNegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.HurdleNegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.HurdleNegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+qhnbinom">qhnbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a hurdle negative binomial distribution
X &lt;- HurdleNegativeBinomial(mu = 2.5, theta = 1, pi = 0.75)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='quantile.HurdlePoisson'>Determine quantiles of a hurdle Poisson distribution</h2><span id='topic+quantile.HurdlePoisson'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HurdlePoisson'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.HurdlePoisson_+3A_x">x</code></td>
<td>
<p>A <code>HurdlePoisson</code> object created by a call to <code><a href="#topic+HurdlePoisson">HurdlePoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.HurdlePoisson_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.HurdlePoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.HurdlePoisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.HurdlePoisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+qhpois">qhpois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a hurdle Poisson distribution
X &lt;- HurdlePoisson(lambda = 2.5, pi = 0.75)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='quantile.HyperGeometric'>Determine quantiles of a HyperGeometric distribution</h2><span id='topic+quantile.HyperGeometric'></span>

<h3>Description</h3>

<p>Determine quantiles of a HyperGeometric distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HyperGeometric'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.HyperGeometric_+3A_x">x</code></td>
<td>
<p>A <code>HyperGeometric</code> object created by a call to <code><a href="#topic+HyperGeometric">HyperGeometric()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.HyperGeometric_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.HyperGeometric_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.HyperGeometric_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.HyperGeometric_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qhyper">qhyper</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>See Also</h3>

<p>Other HyperGeometric distribution: 
<code><a href="#topic+cdf.HyperGeometric">cdf.HyperGeometric</a>()</code>,
<code><a href="#topic+pdf.HyperGeometric">pdf.HyperGeometric</a>()</code>,
<code><a href="#topic+random.HyperGeometric">random.HyperGeometric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- HyperGeometric(4, 5, 8)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='quantile.Logistic'>Determine quantiles of a Logistic distribution</h2><span id='topic+quantile.Logistic'></span>

<h3>Description</h3>

<p>Determine quantiles of a Logistic distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Logistic'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Logistic_+3A_x">x</code></td>
<td>
<p>A <code>Logistic</code> object created by a call to <code><a href="#topic+Logistic">Logistic()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Logistic_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Logistic_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Logistic_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Logistic_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qlogis">qlogis</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>See Also</h3>

<p>Other Logistic distribution: 
<code><a href="#topic+cdf.Logistic">cdf.Logistic</a>()</code>,
<code><a href="#topic+pdf.Logistic">pdf.Logistic</a>()</code>,
<code><a href="#topic+random.Logistic">random.Logistic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Logistic(2, 4)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='quantile.LogNormal'>Determine quantiles of a LogNormal distribution</h2><span id='topic+quantile.LogNormal'></span>

<h3>Description</h3>

<p>Determine quantiles of a LogNormal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LogNormal'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.LogNormal_+3A_x">x</code></td>
<td>
<p>A <code>LogNormal</code> object created by a call to <code><a href="#topic+LogNormal">LogNormal()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.LogNormal_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.LogNormal_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.LogNormal_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.LogNormal_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qlnorm">qlnorm</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>See Also</h3>

<p>Other LogNormal distribution: 
<code><a href="#topic+cdf.LogNormal">cdf.LogNormal</a>()</code>,
<code><a href="#topic+fit_mle.LogNormal">fit_mle.LogNormal</a>()</code>,
<code><a href="#topic+pdf.LogNormal">pdf.LogNormal</a>()</code>,
<code><a href="#topic+random.LogNormal">random.LogNormal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- LogNormal(0.3, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='quantile.NegativeBinomial'>Determine quantiles of a NegativeBinomial distribution</h2><span id='topic+quantile.NegativeBinomial'></span>

<h3>Description</h3>

<p>Determine quantiles of a NegativeBinomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NegativeBinomial'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.NegativeBinomial_+3A_x">x</code></td>
<td>
<p>A <code>NegativeBinomial</code> object created by a call to
<code><a href="#topic+NegativeBinomial">NegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.NegativeBinomial_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.NegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.NegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.NegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qnbinom">qnbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>See Also</h3>

<p>Other NegativeBinomial distribution: 
<code><a href="#topic+cdf.NegativeBinomial">cdf.NegativeBinomial</a>()</code>,
<code><a href="#topic+pdf.NegativeBinomial">pdf.NegativeBinomial</a>()</code>,
<code><a href="#topic+random.NegativeBinomial">random.NegativeBinomial</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- NegativeBinomial(size = 5, p = 0.1)
X

random(X, 10)

pdf(X, 50)
log_pdf(X, 50)

cdf(X, 50)
quantile(X, 0.7)

## alternative parameterization of X
Y &lt;- NegativeBinomial(mu = 45, size = 5)
Y
cdf(Y, 50)
quantile(Y, 0.7)
</code></pre>

<hr>
<h2 id='quantile.Normal'>Determine quantiles of a Normal distribution</h2><span id='topic+quantile.Normal'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+Normal">Normal()</a></code> for some properties
of the Normal distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
<code>quantile()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Normal'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Normal_+3A_x">x</code></td>
<td>
<p>A <code>Normal</code> object created by a call to <code><a href="#topic+Normal">Normal()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Normal_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Normal_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Normal_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Normal_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qnorm">qnorm</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the same values that you get from a Z-table. Note
<code>quantile()</code> is the inverse of <code>cdf()</code>. Please see the documentation of <code><a href="#topic+Normal">Normal()</a></code> for some properties
of the Normal distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>See Also</h3>

<p>Other Normal distribution: 
<code><a href="#topic+cdf.Normal">cdf.Normal</a>()</code>,
<code><a href="#topic+fit_mle.Normal">fit_mle.Normal</a>()</code>,
<code><a href="#topic+pdf.Normal">pdf.Normal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Normal(5, 2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

### example: calculating p-values for two-sided Z-test

# here the null hypothesis is H_0: mu = 3
# and we assume sigma = 2

# exactly the same as: Z &lt;- Normal(0, 1)
Z &lt;- Normal()

# data to test
x &lt;- c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2)
nx &lt;- length(x)

# calculate the z-statistic
z_stat &lt;- (mean(x) - 3) / (2 / sqrt(nx))
z_stat

# calculate the two-sided p-value
1 - cdf(Z, abs(z_stat)) + cdf(Z, -abs(z_stat))

# exactly equivalent to the above
2 * cdf(Z, -abs(z_stat))

# p-value for one-sided test
# H_0: mu &lt;= 3   vs   H_A: mu &gt; 3
1 - cdf(Z, z_stat)

# p-value for one-sided test
# H_0: mu &gt;= 3   vs   H_A: mu &lt; 3
cdf(Z, z_stat)

### example: calculating a 88 percent Z CI for a mean

# same `x` as before, still assume `sigma = 2`

# lower-bound
mean(x) - quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# upper-bound
mean(x) + quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# equivalent to
mean(x) + c(-1, 1) * quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# also equivalent to
mean(x) + quantile(Z, 0.12 / 2) * 2 / sqrt(nx)
mean(x) + quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

### generating random samples and plugging in ks.test()

set.seed(27)

# generate a random sample
ns &lt;- random(Normal(3, 7), 26)

# test if sample is Normal(3, 7)
ks.test(ns, pnorm, mean = 3, sd = 7)

# test if sample is gamma(8, 3) using base R pgamma()
ks.test(ns, pgamma, shape = 8, rate = 3)

### MISC

# note that the cdf() and quantile() functions are inverses
cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='quantile.Poisson'>Determine quantiles of a Poisson distribution</h2><span id='topic+quantile.Poisson'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Poisson'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Poisson_+3A_x">x</code></td>
<td>
<p>A <code>Poisson</code> object created by a call to <code><a href="#topic+Poisson">Poisson()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Poisson_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Poisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Poisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Poisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qpois">qpois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Poisson(2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='quantile.RevWeibull'>Determine quantiles of a RevWeibull distribution</h2><span id='topic+quantile.RevWeibull'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RevWeibull'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.RevWeibull_+3A_x">x</code></td>
<td>
<p>A <code>RevWeibull</code> object created by a call to <code><a href="#topic+RevWeibull">RevWeibull()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.RevWeibull_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.RevWeibull_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.RevWeibull_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.RevWeibull_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="revdbayes.html#topic+qgev">qgev</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- RevWeibull(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='quantile.StudentsT'>Determine quantiles of a StudentsT distribution</h2><span id='topic+quantile.StudentsT'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+StudentsT">StudentsT()</a></code> for some properties
of the StudentsT distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
<code>quantile()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'StudentsT'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.StudentsT_+3A_x">x</code></td>
<td>
<p>A <code>StudentsT</code> object created by a call to <code><a href="#topic+StudentsT">StudentsT()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.StudentsT_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.StudentsT_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.StudentsT_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.StudentsT_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qt">qt</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the same values that you get from a Z-table. Note
<code>quantile()</code> is the inverse of <code>cdf()</code>. Please see the documentation of
<code><a href="#topic+StudentsT">StudentsT()</a></code> for some properties
of the StudentsT distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>See Also</h3>

<p>Other StudentsT distribution: 
<code><a href="#topic+cdf.StudentsT">cdf.StudentsT</a>()</code>,
<code><a href="#topic+pdf.StudentsT">pdf.StudentsT</a>()</code>,
<code><a href="#topic+random.StudentsT">random.StudentsT</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- StudentsT(3)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

### example: calculating p-values for two-sided T-test

# here the null hypothesis is H_0: mu = 3

# data to test
x &lt;- c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2)
nx &lt;- length(x)

# calculate the T-statistic
t_stat &lt;- (mean(x) - 3) / (sd(x) / sqrt(nx))
t_stat

# null distribution of statistic depends on sample size!
T &lt;- StudentsT(df = nx - 1)

# calculate the two-sided p-value
1 - cdf(T, abs(t_stat)) + cdf(T, -abs(t_stat))

# exactly equivalent to the above
2 * cdf(T, -abs(t_stat))

# p-value for one-sided test
# H_0: mu &lt;= 3   vs   H_A: mu &gt; 3
1 - cdf(T, t_stat)

# p-value for one-sided test
# H_0: mu &gt;= 3   vs   H_A: mu &lt; 3
cdf(T, t_stat)

### example: calculating a 88 percent T CI for a mean

# lower-bound
mean(x) - quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# upper-bound
mean(x) + quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# equivalent to
mean(x) + c(-1, 1) * quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# also equivalent to
mean(x) + quantile(T, 0.12 / 2) * sd(x) / sqrt(nx)
mean(x) + quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)
</code></pre>

<hr>
<h2 id='quantile.Tukey'>Determine quantiles of a Tukey distribution</h2><span id='topic+quantile.Tukey'></span>

<h3>Description</h3>

<p>Determine quantiles of a Tukey distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Tukey'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Tukey_+3A_x">x</code></td>
<td>
<p>A vector of elements whose cumulative probabilities you would
like to determine given the distribution <code>d</code>.</p>
</td></tr>
<tr><td><code id="quantile.Tukey_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Tukey_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Tukey_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Tukey_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qtukey">qtukey</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>See Also</h3>

<p>Other Tukey distribution: 
<code><a href="#topic+cdf.Tukey">cdf.Tukey</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Tukey(4L, 16L, 2L)
X

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='quantile.Uniform'>Determine quantiles of a continuous Uniform  distribution</h2><span id='topic+quantile.Uniform'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Uniform'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Uniform_+3A_x">x</code></td>
<td>
<p>A <code>Uniform</code> object created by a call to <code><a href="#topic+Uniform">Uniform()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Uniform_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Uniform_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Uniform_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Uniform_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qunif">qunif</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Uniform(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='quantile.Weibull'>Determine quantiles of a Weibull distribution</h2><span id='topic+quantile.Weibull'></span>

<h3>Description</h3>

<p>Determine quantiles of a Weibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Weibull'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.Weibull_+3A_x">x</code></td>
<td>
<p>A <code>Weibull</code> object created by a call to <code><a href="#topic+Weibull">Weibull()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.Weibull_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.Weibull_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.Weibull_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.Weibull_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="stats.html#topic+qweibull">qweibull</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>See Also</h3>

<p>Other Weibull distribution: 
<code><a href="#topic+cdf.Weibull">cdf.Weibull</a>()</code>,
<code><a href="#topic+pdf.Weibull">pdf.Weibull</a>()</code>,
<code><a href="#topic+random.Weibull">random.Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Weibull(0.3, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='quantile.ZINegativeBinomial'>Determine quantiles of a zero-inflated negative binomial distribution</h2><span id='topic+quantile.ZINegativeBinomial'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZINegativeBinomial'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.ZINegativeBinomial_+3A_x">x</code></td>
<td>
<p>A <code>ZINegativeBinomial</code> object created by a call to <code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.ZINegativeBinomial_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.ZINegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.ZINegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.ZINegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+qzinbinom">qzinbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-inflated negative binomial distribution
X &lt;- ZINegativeBinomial(mu = 2.5, theta = 1, pi = 0.25)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='quantile.ZIPoisson'>Determine quantiles of a zero-inflated Poisson distribution</h2><span id='topic+quantile.ZIPoisson'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZIPoisson'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.ZIPoisson_+3A_x">x</code></td>
<td>
<p>A <code>ZIPoisson</code> object created by a call to <code><a href="#topic+ZIPoisson">ZIPoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.ZIPoisson_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.ZIPoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.ZIPoisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.ZIPoisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+qzipois">qzipois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-inflated Poisson distribution
X &lt;- ZIPoisson(lambda = 2.5, pi = 0.25)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='quantile.ZTNegativeBinomial'>Determine quantiles of a zero-truncated negative binomial distribution</h2><span id='topic+quantile.ZTNegativeBinomial'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZTNegativeBinomial'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.ZTNegativeBinomial_+3A_x">x</code></td>
<td>
<p>A <code>ZTNegativeBinomial</code> object created by a call to <code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.ZTNegativeBinomial_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.ZTNegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.ZTNegativeBinomial_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.ZTNegativeBinomial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+qztnbinom">qztnbinom</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-truncated negative binomial distribution
X &lt;- ZTNegativeBinomial(mu = 2.5, theta = 1)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='quantile.ZTPoisson'>Determine quantiles of a zero-truncated Poisson distribution</h2><span id='topic+quantile.ZTPoisson'></span>

<h3>Description</h3>

<p><code>quantile()</code> is the inverse of <code>cdf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZTPoisson'
quantile(x, probs, drop = TRUE, elementwise = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.ZTPoisson_+3A_x">x</code></td>
<td>
<p>A <code>ZTPoisson</code> object created by a call to <code><a href="#topic+ZTPoisson">ZTPoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile.ZTPoisson_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.ZTPoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="quantile.ZTPoisson_+3A_elementwise">elementwise</code></td>
<td>
<p>logical. Should each distribution in <code>x</code> be evaluated
at all elements of <code>probs</code> (<code>elementwise = FALSE</code>, yielding a matrix)?
Or, if <code>x</code> and <code>probs</code> have the same length, should the evaluation be
done element by element (<code>elementwise = TRUE</code>, yielding a vector)? The
default of <code>NULL</code> means that <code>elementwise = TRUE</code> is used if the
lengths match and otherwise <code>elementwise = FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="quantile.ZTPoisson_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+qztpois">qztpois</a></code>.
Unevaluated arguments will generate a warning to catch mispellings or other
possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, either a numeric
vector of length <code>probs</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with
<code>length(probs)</code> columns (if <code>drop = FALSE</code>). In case of a vectorized
distribution object, a matrix with <code>length(probs)</code> columns containing all
possible combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-truncated Poisson distribution
X &lt;- ZTPoisson(lambda = 2.5)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='random'>Draw a random sample from a probability distribution</h2><span id='topic+random'></span><span id='topic+simulate.distribution'></span>

<h3>Description</h3>

<p>Generic function for drawing random samples from distribution objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random(x, n = 1L, drop = TRUE, ...)

## S3 method for class 'distribution'
simulate(object, nsim = 1L, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_+3A_x">x</code>, <code id="random_+3A_object">object</code></td>
<td>
<p>An object. The package provides methods for distribution
objects such as those from <code><a href="#topic+Normal">Normal()</a></code> or <code><a href="#topic+Binomial">Binomial()</a></code> etc.</p>
</td></tr>
<tr><td><code id="random_+3A_n">n</code>, <code id="random_+3A_nsim">nsim</code></td>
<td>
<p>The number of samples to draw. Should be a positive
integer. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
<tr><td><code id="random_+3A_seed">seed</code></td>
<td>
<p>An optional random seed that is to be set using <code><a href="base.html#topic+set.seed">set.seed</a></code>
prior to drawing the random sample. The previous random seed from the global
environment (if any) is restored afterwards.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>random</code> is a new generic for drawing random samples from
the S3 <code>distribution</code> objects provided in this package, such as
<code><a href="#topic+Normal">Normal</a></code> or <code><a href="#topic+Binomial">Binomial</a></code> etc. The respective
methods typically call the &quot;r&quot; function for the corresponding
distribution functions provided in base R such as <code>rnorm</code>,
<code>rbinom</code> etc.
</p>
<p>In addition to the new <code>random</code> generic there is also a
<code><a href="stats.html#topic+simulate">simulate</a></code> method for distribution objects which simply
calls the <code>random</code> method internally.
</p>


<h3>Value</h3>

<p>Random samples drawn from the distriubtion <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## distribution object
X &lt;- Normal()
## 10 random samples
random(X, 10)
</code></pre>

<hr>
<h2 id='random.Bernoulli'>Draw a random sample from a Bernoulli distribution</h2><span id='topic+random.Bernoulli'></span>

<h3>Description</h3>

<p>Draw a random sample from a Bernoulli distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bernoulli'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Bernoulli_+3A_x">x</code></td>
<td>
<p>A <code>Bernoulli</code> object created by a call to <code><a href="#topic+Bernoulli">Bernoulli()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Bernoulli_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Bernoulli_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Bernoulli_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Bernoulli(0.7)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)
pdf(X, 1)
log_pdf(X, 1)
cdf(X, 0)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='random.Beta'>Draw a random sample from a Beta distribution</h2><span id='topic+random.Beta'></span>

<h3>Description</h3>

<p>Draw a random sample from a Beta distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Beta'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Beta_+3A_x">x</code></td>
<td>
<p>A <code>Beta</code> object created by a call to <code><a href="#topic+Beta">Beta()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Beta_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Beta_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Beta_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Values in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>. In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Beta(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

mean(X)
variance(X)
skewness(X)
kurtosis(X)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='random.Binomial'>Draw a random sample from a Binomial distribution</h2><span id='topic+random.Binomial'></span>

<h3>Description</h3>

<p>Draw a random sample from a Binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Binomial'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Binomial_+3A_x">x</code></td>
<td>
<p>A <code>Binomial</code> object created by a call to <code><a href="#topic+Binomial">Binomial()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Binomial_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Binomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Binomial_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integers containing values between <code>0</code> and <code>x$size</code>.
In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Binomial(10, 0.2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2L)
log_pdf(X, 2L)

cdf(X, 4L)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='random.Categorical'>Draw a random sample from a Categorical distribution</h2><span id='topic+random.Categorical'></span>

<h3>Description</h3>

<p>Draw a random sample from a Categorical distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Categorical'
random(x, n = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Categorical_+3A_x">x</code></td>
<td>
<p>A <code>Categorical</code> object created by a call to <code><a href="#topic+Categorical">Categorical()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Categorical_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Categorical_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing values from <code>outcomes</code> of length <code>n</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Categorical(1:3, p = c(0.4, 0.1, 0.5))
X

Y &lt;- Categorical(LETTERS[1:4])
Y

random(X, 10)
random(Y, 10)

pdf(X, 1)
log_pdf(X, 1)

cdf(X, 1)
quantile(X, 0.5)

# cdfs are only defined for numeric sample spaces. this errors!
# cdf(Y, "a")

# same for quantiles. this also errors!
# quantile(Y, 0.7)
</code></pre>

<hr>
<h2 id='random.Cauchy'>Draw a random sample from a Cauchy distribution</h2><span id='topic+random.Cauchy'></span>

<h3>Description</h3>

<p>Draw a random sample from a Cauchy distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cauchy'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Cauchy_+3A_x">x</code></td>
<td>
<p>A <code>Cauchy</code> object created by a call to <code><a href="#topic+Cauchy">Cauchy()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Cauchy_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Cauchy_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Cauchy_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Cauchy(10, 0.2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 2)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='random.ChiSquare'>Draw a random sample from a chi square distribution</h2><span id='topic+random.ChiSquare'></span>

<h3>Description</h3>

<p>Draw a random sample from a chi square distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ChiSquare'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.ChiSquare_+3A_x">x</code></td>
<td>
<p>A <code>ChiSquare</code> object created by a call to <code><a href="#topic+ChiSquare">ChiSquare()</a></code>.</p>
</td></tr>
<tr><td><code id="random.ChiSquare_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.ChiSquare_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.ChiSquare_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- ChiSquare(5)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='random.Erlang'>Draw a random sample from an Erlang distribution</h2><span id='topic+random.Erlang'></span>

<h3>Description</h3>

<p>Draw a random sample from an Erlang distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Erlang'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Erlang_+3A_x">x</code></td>
<td>
<p>An <code>Erlang</code> object created by a call to <code><a href="#topic+Erlang">Erlang()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Erlang_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Erlang_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Erlang_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Erlang(5, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='random.Exponential'>Draw a random sample from an Exponential distribution</h2><span id='topic+random.Exponential'></span>

<h3>Description</h3>

<p>Draw a random sample from an Exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Exponential'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Exponential_+3A_x">x</code></td>
<td>
<p>An <code>Exponential</code> object created by a call to <code><a href="#topic+Exponential">Exponential()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Exponential_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Exponential_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Exponential_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Exponential(5)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='random.FisherF'>Draw a random sample from an F distribution</h2><span id='topic+random.FisherF'></span>

<h3>Description</h3>

<p>Draw a random sample from an F distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FisherF'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.FisherF_+3A_x">x</code></td>
<td>
<p>A <code>FisherF</code> object created by a call to <code><a href="#topic+FisherF">FisherF()</a></code>.</p>
</td></tr>
<tr><td><code id="random.FisherF_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.FisherF_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.FisherF_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- FisherF(5, 10, 0.2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='random.Frechet'>Draw a random sample from a Frechet distribution</h2><span id='topic+random.Frechet'></span>

<h3>Description</h3>

<p>Draw a random sample from a Frechet distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Frechet'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Frechet_+3A_x">x</code></td>
<td>
<p>A <code>Frechet</code> object created by a call to <code><a href="#topic+Frechet">Frechet()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Frechet_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Frechet_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Frechet_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Frechet(0, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='random.Gamma'>Draw a random sample from a Gamma distribution</h2><span id='topic+random.Gamma'></span>

<h3>Description</h3>

<p>Draw a random sample from a Gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gamma'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Gamma_+3A_x">x</code></td>
<td>
<p>A <code>Gamma</code> object created by a call to <code><a href="#topic+Gamma">Gamma()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Gamma_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Gamma_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Gamma_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Gamma(5, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='random.Geometric'>Draw a random sample from a Geometric distribution</h2><span id='topic+random.Geometric'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+Geometric">Geometric()</a></code> for some properties
of the Geometric distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Geometric'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Geometric_+3A_x">x</code></td>
<td>
<p>A <code>Geometric</code> object created by a call to <code><a href="#topic+Geometric">Geometric()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Geometric_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Geometric_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Geometric_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>See Also</h3>

<p>Other Geometric distribution: 
<code><a href="#topic+cdf.Geometric">cdf.Geometric</a>()</code>,
<code><a href="#topic+pdf.Geometric">pdf.Geometric</a>()</code>,
<code><a href="#topic+quantile.Geometric">quantile.Geometric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Geometric(0.3)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='random.GEV'>Draw a random sample from a GEV distribution</h2><span id='topic+random.GEV'></span>

<h3>Description</h3>

<p>Draw a random sample from a GEV distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GEV'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.GEV_+3A_x">x</code></td>
<td>
<p>A <code>GEV</code> object created by a call to <code><a href="#topic+GEV">GEV()</a></code>.</p>
</td></tr>
<tr><td><code id="random.GEV_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.GEV_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.GEV_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- GEV(1, 2, 0.1)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='random.GP'>Draw a random sample from a GP distribution</h2><span id='topic+random.GP'></span>

<h3>Description</h3>

<p>Draw a random sample from a GP distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GP'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.GP_+3A_x">x</code></td>
<td>
<p>A <code>GP</code> object created by a call to <code><a href="#topic+GP">GP()</a></code>.</p>
</td></tr>
<tr><td><code id="random.GP_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.GP_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.GP_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- GP(0, 2, 0.1)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='random.Gumbel'>Draw a random sample from a Gumbel distribution</h2><span id='topic+random.Gumbel'></span>

<h3>Description</h3>

<p>Draw a random sample from a Gumbel distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gumbel'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Gumbel_+3A_x">x</code></td>
<td>
<p>A <code>Gumbel</code> object created by a call to <code><a href="#topic+Gumbel">Gumbel()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Gumbel_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Gumbel_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Gumbel_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Gumbel(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='random.HurdleNegativeBinomial'>Draw a random sample from a hurdle negative binomial distribution</h2><span id='topic+random.HurdleNegativeBinomial'></span>

<h3>Description</h3>

<p>Draw a random sample from a hurdle negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HurdleNegativeBinomial'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.HurdleNegativeBinomial_+3A_x">x</code></td>
<td>
<p>A <code>HurdleNegativeBinomial</code> object created by a call to <code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="random.HurdleNegativeBinomial_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.HurdleNegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.HurdleNegativeBinomial_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a hurdle negative binomial distribution
X &lt;- HurdleNegativeBinomial(mu = 2.5, theta = 1, pi = 0.75)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='random.HurdlePoisson'>Draw a random sample from a hurdle Poisson distribution</h2><span id='topic+random.HurdlePoisson'></span>

<h3>Description</h3>

<p>Draw a random sample from a hurdle Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HurdlePoisson'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.HurdlePoisson_+3A_x">x</code></td>
<td>
<p>A <code>HurdlePoisson</code> object created by a call to <code><a href="#topic+HurdlePoisson">HurdlePoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="random.HurdlePoisson_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.HurdlePoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.HurdlePoisson_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a hurdle Poisson distribution
X &lt;- HurdlePoisson(lambda = 2.5, pi = 0.75)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='random.HyperGeometric'>Draw a random sample from a HyperGeometric distribution</h2><span id='topic+random.HyperGeometric'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+HyperGeometric">HyperGeometric()</a></code> for some properties
of the HyperGeometric distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HyperGeometric'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.HyperGeometric_+3A_x">x</code></td>
<td>
<p>A <code>HyperGeometric</code> object created by a call to <code><a href="#topic+HyperGeometric">HyperGeometric()</a></code>.</p>
</td></tr>
<tr><td><code id="random.HyperGeometric_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.HyperGeometric_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.HyperGeometric_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>See Also</h3>

<p>Other HyperGeometric distribution: 
<code><a href="#topic+cdf.HyperGeometric">cdf.HyperGeometric</a>()</code>,
<code><a href="#topic+pdf.HyperGeometric">pdf.HyperGeometric</a>()</code>,
<code><a href="#topic+quantile.HyperGeometric">quantile.HyperGeometric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- HyperGeometric(4, 5, 8)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='random.Logistic'>Draw a random sample from a Logistic distribution</h2><span id='topic+random.Logistic'></span>

<h3>Description</h3>

<p>Draw a random sample from a Logistic distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Logistic'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Logistic_+3A_x">x</code></td>
<td>
<p>A <code>Logistic</code> object created by a call to <code><a href="#topic+Logistic">Logistic()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Logistic_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Logistic_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Logistic_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>See Also</h3>

<p>Other Logistic distribution: 
<code><a href="#topic+cdf.Logistic">cdf.Logistic</a>()</code>,
<code><a href="#topic+pdf.Logistic">pdf.Logistic</a>()</code>,
<code><a href="#topic+quantile.Logistic">quantile.Logistic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Logistic(2, 4)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='random.LogNormal'>Draw a random sample from a LogNormal distribution</h2><span id='topic+random.LogNormal'></span>

<h3>Description</h3>

<p>Draw a random sample from a LogNormal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LogNormal'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.LogNormal_+3A_x">x</code></td>
<td>
<p>A <code>LogNormal</code> object created by a call to <code><a href="#topic+LogNormal">LogNormal()</a></code>.</p>
</td></tr>
<tr><td><code id="random.LogNormal_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.LogNormal_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.LogNormal_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>See Also</h3>

<p>Other LogNormal distribution: 
<code><a href="#topic+cdf.LogNormal">cdf.LogNormal</a>()</code>,
<code><a href="#topic+fit_mle.LogNormal">fit_mle.LogNormal</a>()</code>,
<code><a href="#topic+pdf.LogNormal">pdf.LogNormal</a>()</code>,
<code><a href="#topic+quantile.LogNormal">quantile.LogNormal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- LogNormal(0.3, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='random.Multinomial'>Draw a random sample from a Multinomial distribution</h2><span id='topic+random.Multinomial'></span>

<h3>Description</h3>

<p>Draw a random sample from a Multinomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Multinomial'
random(x, n = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Multinomial_+3A_x">x</code></td>
<td>
<p>A <code>Multinomial</code> object created by a call to <code><a href="#topic+Multinomial">Multinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Multinomial_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Multinomial_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of length <code>n</code>.
</p>


<h3>See Also</h3>

<p>Other Multinomial distribution: 
<code><a href="#topic+pdf.Multinomial">pdf.Multinomial</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Multinomial(size = 5, p = c(0.3, 0.4, 0.2, 0.1))
X

random(X, 10)

# pdf(X, 2)
# log_pdf(X, 2)
</code></pre>

<hr>
<h2 id='random.NegativeBinomial'>Draw a random sample from a negative binomial distribution</h2><span id='topic+random.NegativeBinomial'></span>

<h3>Description</h3>

<p>Draw a random sample from a negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NegativeBinomial'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.NegativeBinomial_+3A_x">x</code></td>
<td>
<p>A <code>NegativeBinomial</code> object created by a call to
<code><a href="#topic+NegativeBinomial">NegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="random.NegativeBinomial_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.NegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.NegativeBinomial_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>See Also</h3>

<p>Other NegativeBinomial distribution: 
<code><a href="#topic+cdf.NegativeBinomial">cdf.NegativeBinomial</a>()</code>,
<code><a href="#topic+pdf.NegativeBinomial">pdf.NegativeBinomial</a>()</code>,
<code><a href="#topic+quantile.NegativeBinomial">quantile.NegativeBinomial</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- NegativeBinomial(size = 5, p = 0.1)
X

random(X, 10)

pdf(X, 50)
log_pdf(X, 50)

cdf(X, 50)
quantile(X, 0.7)

## alternative parameterization of X
Y &lt;- NegativeBinomial(mu = 45, size = 5)
Y
cdf(Y, 50)
quantile(Y, 0.7)
</code></pre>

<hr>
<h2 id='random.Normal'>Draw a random sample from a Normal distribution</h2><span id='topic+random.Normal'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+Normal">Normal()</a></code> for some properties
of the Normal distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Normal'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Normal_+3A_x">x</code></td>
<td>
<p>A <code>Normal</code> object created by a call to <code><a href="#topic+Normal">Normal()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Normal_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Normal_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Normal_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Normal(5, 2)
X

mean(X)
variance(X)
skewness(X)
kurtosis(X)

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

### example: calculating p-values for two-sided Z-test

# here the null hypothesis is H_0: mu = 3
# and we assume sigma = 2

# exactly the same as: Z &lt;- Normal(0, 1)
Z &lt;- Normal()

# data to test
x &lt;- c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2)
nx &lt;- length(x)

# calculate the z-statistic
z_stat &lt;- (mean(x) - 3) / (2 / sqrt(nx))
z_stat

# calculate the two-sided p-value
1 - cdf(Z, abs(z_stat)) + cdf(Z, -abs(z_stat))

# exactly equivalent to the above
2 * cdf(Z, -abs(z_stat))

# p-value for one-sided test
# H_0: mu &lt;= 3   vs   H_A: mu &gt; 3
1 - cdf(Z, z_stat)

# p-value for one-sided test
# H_0: mu &gt;= 3   vs   H_A: mu &lt; 3
cdf(Z, z_stat)

### example: calculating a 88 percent Z CI for a mean

# same `x` as before, still assume `sigma = 2`

# lower-bound
mean(x) - quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# upper-bound
mean(x) + quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# equivalent to
mean(x) + c(-1, 1) * quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

# also equivalent to
mean(x) + quantile(Z, 0.12 / 2) * 2 / sqrt(nx)
mean(x) + quantile(Z, 1 - 0.12 / 2) * 2 / sqrt(nx)

### generating random samples and plugging in ks.test()

set.seed(27)

# generate a random sample
ns &lt;- random(Normal(3, 7), 26)

# test if sample is Normal(3, 7)
ks.test(ns, pnorm, mean = 3, sd = 7)

# test if sample is gamma(8, 3) using base R pgamma()
ks.test(ns, pgamma, shape = 8, rate = 3)

### MISC

# note that the cdf() and quantile() functions are inverses
cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='random.Poisson'>Draw a random sample from a Poisson distribution</h2><span id='topic+random.Poisson'></span>

<h3>Description</h3>

<p>Draw a random sample from a Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Poisson'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Poisson_+3A_x">x</code></td>
<td>
<p>A <code>Poisson</code> object created by a call to <code><a href="#topic+Poisson">Poisson()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Poisson_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Poisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Poisson_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Poisson(2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 7))
</code></pre>

<hr>
<h2 id='random.RevWeibull'>Draw a random sample from an RevWeibull distribution</h2><span id='topic+random.RevWeibull'></span>

<h3>Description</h3>

<p>Draw a random sample from an RevWeibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RevWeibull'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.RevWeibull_+3A_x">x</code></td>
<td>
<p>A <code>RevWeibull</code> object created by a call to <code><a href="#topic+RevWeibull">RevWeibull()</a></code>.</p>
</td></tr>
<tr><td><code id="random.RevWeibull_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.RevWeibull_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.RevWeibull_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- RevWeibull(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='random.StudentsT'>Draw a random sample from a StudentsT distribution</h2><span id='topic+random.StudentsT'></span>

<h3>Description</h3>

<p>Please see the documentation of <code><a href="#topic+StudentsT">StudentsT()</a></code> for some properties
of the T distribution, as well as extensive examples
showing to how calculate p-values and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'StudentsT'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.StudentsT_+3A_x">x</code></td>
<td>
<p>A <code>StudentsT</code> object created by a call to <code><a href="#topic+StudentsT">StudentsT()</a></code>.</p>
</td></tr>
<tr><td><code id="random.StudentsT_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.StudentsT_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.StudentsT_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>See Also</h3>

<p>Other StudentsT distribution: 
<code><a href="#topic+cdf.StudentsT">cdf.StudentsT</a>()</code>,
<code><a href="#topic+pdf.StudentsT">pdf.StudentsT</a>()</code>,
<code><a href="#topic+quantile.StudentsT">quantile.StudentsT</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- StudentsT(3)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

### example: calculating p-values for two-sided T-test

# here the null hypothesis is H_0: mu = 3

# data to test
x &lt;- c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2)
nx &lt;- length(x)

# calculate the T-statistic
t_stat &lt;- (mean(x) - 3) / (sd(x) / sqrt(nx))
t_stat

# null distribution of statistic depends on sample size!
T &lt;- StudentsT(df = nx - 1)

# calculate the two-sided p-value
1 - cdf(T, abs(t_stat)) + cdf(T, -abs(t_stat))

# exactly equivalent to the above
2 * cdf(T, -abs(t_stat))

# p-value for one-sided test
# H_0: mu &lt;= 3   vs   H_A: mu &gt; 3
1 - cdf(T, t_stat)

# p-value for one-sided test
# H_0: mu &gt;= 3   vs   H_A: mu &lt; 3
cdf(T, t_stat)

### example: calculating a 88 percent T CI for a mean

# lower-bound
mean(x) - quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# upper-bound
mean(x) + quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# equivalent to
mean(x) + c(-1, 1) * quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# also equivalent to
mean(x) + quantile(T, 0.12 / 2) * sd(x) / sqrt(nx)
mean(x) + quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)
</code></pre>

<hr>
<h2 id='random.Tukey'>Draw a random sample from a Tukey distribution</h2><span id='topic+random.Tukey'></span>

<h3>Description</h3>

<p>Draw a random sample from a Tukey distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Tukey'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Tukey_+3A_x">x</code></td>
<td>
<p>A <code>Tukey</code> object created by a call to <code><a href="#topic+Tukey">Tukey()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Tukey_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Tukey_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Tukey_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Tukey(4L, 16L, 2L)
X

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='random.Uniform'>Draw a random sample from a continuous Uniform distribution</h2><span id='topic+random.Uniform'></span>

<h3>Description</h3>

<p>Draw a random sample from a continuous Uniform distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Uniform'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Uniform_+3A_x">x</code></td>
<td>
<p>A <code>Uniform</code> object created by a call to <code><a href="#topic+Uniform">Uniform()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Uniform_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Uniform_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Uniform_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Values in <code style="white-space: pre;">&#8288;[a, b]&#8288;</code>. In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Uniform(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='random.Weibull'>Draw a random sample from a Weibull distribution</h2><span id='topic+random.Weibull'></span>

<h3>Description</h3>

<p>Draw a random sample from a Weibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Weibull'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.Weibull_+3A_x">x</code></td>
<td>
<p>A <code>Weibull</code> object created by a call to <code><a href="#topic+Weibull">Weibull()</a></code>.</p>
</td></tr>
<tr><td><code id="random.Weibull_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.Weibull_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.Weibull_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>See Also</h3>

<p>Other Weibull distribution: 
<code><a href="#topic+cdf.Weibull">cdf.Weibull</a>()</code>,
<code><a href="#topic+pdf.Weibull">pdf.Weibull</a>()</code>,
<code><a href="#topic+quantile.Weibull">quantile.Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Weibull(0.3, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='random.ZINegativeBinomial'>Draw a random sample from a zero-inflated negative binomial distribution</h2><span id='topic+random.ZINegativeBinomial'></span>

<h3>Description</h3>

<p>Draw a random sample from a zero-inflated negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZINegativeBinomial'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.ZINegativeBinomial_+3A_x">x</code></td>
<td>
<p>A <code>ZINegativeBinomial</code> object created by a call to <code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="random.ZINegativeBinomial_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.ZINegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.ZINegativeBinomial_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-inflated negative binomial distribution
X &lt;- ZINegativeBinomial(mu = 2.5, theta = 1, pi = 0.25)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='random.ZIPoisson'>Draw a random sample from a zero-inflated Poisson distribution</h2><span id='topic+random.ZIPoisson'></span>

<h3>Description</h3>

<p>Draw a random sample from a zero-inflated Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZIPoisson'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.ZIPoisson_+3A_x">x</code></td>
<td>
<p>A <code>ZIPoisson</code> object created by a call to <code><a href="#topic+ZIPoisson">ZIPoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="random.ZIPoisson_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.ZIPoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.ZIPoisson_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-inflated Poisson distribution
X &lt;- ZIPoisson(lambda = 2.5, pi = 0.25)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='random.ZTNegativeBinomial'>Draw a random sample from a zero-truncated negative binomial distribution</h2><span id='topic+random.ZTNegativeBinomial'></span>

<h3>Description</h3>

<p>Draw a random sample from a zero-truncated negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZTNegativeBinomial'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.ZTNegativeBinomial_+3A_x">x</code></td>
<td>
<p>A <code>ZTNegativeBinomial</code> object created by a call to <code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="random.ZTNegativeBinomial_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.ZTNegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.ZTNegativeBinomial_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-truncated negative binomial distribution
X &lt;- ZTNegativeBinomial(mu = 2.5, theta = 1)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='random.ZTPoisson'>Draw a random sample from a zero-truncated Poisson distribution</h2><span id='topic+random.ZTPoisson'></span>

<h3>Description</h3>

<p>Draw a random sample from a zero-truncated Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZTPoisson'
random(x, n = 1L, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.ZTPoisson_+3A_x">x</code></td>
<td>
<p>A <code>ZTPoisson</code> object created by a call to <code><a href="#topic+ZTPoisson">ZTPoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="random.ZTPoisson_+3A_n">n</code></td>
<td>
<p>The number of samples to draw. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="random.ZTPoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="random.ZTPoisson_+3A_...">...</code></td>
<td>
<p>Unused. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object or <code>n = 1</code>, either a numeric
vector of length <code>n</code> (if <code>drop = TRUE</code>, default) or a <code>matrix</code> with <code>n</code> columns
(if <code>drop = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-truncated Poisson distribution
X &lt;- ZTPoisson(lambda = 2.5)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='RevWeibull'>Create a reversed Weibull distribution</h2><span id='topic+RevWeibull'></span>

<h3>Description</h3>

<p>The reversed (or negated) Weibull distribution is a special case of the
<code style="white-space: pre;">&#8288;\link{GEV}&#8288;</code> distribution, obtained when the GEV shape parameter <code class="reqn">\xi</code>
is negative.  It may be referred to as a type III extreme value
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RevWeibull(location = 0, scale = 1, shape = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RevWeibull_+3A_location">location</code></td>
<td>
<p>The location (maximum) parameter <code class="reqn">m</code>.
<code>location</code> can be any real number.  Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="RevWeibull_+3A_scale">scale</code></td>
<td>
<p>The scale parameter <code class="reqn">s</code>.
<code>scale</code> can be any positive number.  Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="RevWeibull_+3A_shape">shape</code></td>
<td>
<p>The scale parameter <code class="reqn">\alpha</code>.
<code>shape</code> can be any positive number.  Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a reversed Weibull random variable with
location parameter  <code>location</code> = <code class="reqn">m</code>, scale parameter <code>scale</code> =
<code class="reqn">s</code>, and shape parameter <code>shape</code> = <code class="reqn">\alpha</code>.
An RevWeibull(<code class="reqn">m, s, \alpha</code>) distribution is equivalent to a
<code style="white-space: pre;">&#8288;\link{GEV}&#8288;</code>(<code class="reqn">m - s, s / \alpha, -1 / \alpha</code>) distribution.
</p>
<p>If <code class="reqn">X</code> has an RevWeibull(<code class="reqn">m, \lambda, k</code>) distribution then
<code class="reqn">m - X</code> has a <code style="white-space: pre;">&#8288;\link{Weibull}&#8288;</code>(<code class="reqn">k, \lambda</code>) distribution,
that is, a Weibull distribution with shape parameter <code class="reqn">k</code> and scale
parameter <code class="reqn">\lambda</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">(-\infty, m)</code>.
</p>
<p><strong>Mean</strong>: <code class="reqn">m + s\Gamma(1 + 1/\alpha)</code>.
</p>
<p><strong>Median</strong>: <code class="reqn">m + s(\ln 2)^{1/\alpha}</code>.
</p>
<p><strong>Variance</strong>:
<code class="reqn">s^2 [\Gamma(1 + 2 / \alpha) - \Gamma(1 + 1 / \alpha)^2]</code>.
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \alpha s ^ {-1} [-(x - m) / s] ^ {\alpha - 1}%
        \exp\{-[-(x - m) / s] ^ {\alpha} \}</code>
</p>

<p>for <code class="reqn">x &lt; m</code>.  The p.d.f. is 0 for <code class="reqn">x \geq m</code>.
</p>
<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \exp\{-[-(x - m) / s] ^ {\alpha} \}</code>
</p>

<p>for <code class="reqn">x &lt; m</code>.  The c.d.f. is 1 for <code class="reqn">x \geq m</code>.
</p>


<h3>Value</h3>

<p>A <code>RevWeibull</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- RevWeibull(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='stat_auc'>Fill out area under the curve for a plotted PDF</h2><span id='topic+stat_auc'></span><span id='topic+StatAuc'></span><span id='topic+geom_auc'></span><span id='topic+GeomAuc'></span>

<h3>Description</h3>

<p>Fill out area under the curve for a plotted PDF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_auc(
  mapping = NULL,
  data = NULL,
  geom = "auc",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  from = -Inf,
  to = Inf,
  annotate = FALSE,
  digits = 3,
  ...
)

geom_auc(
  mapping = NULL,
  data = NULL,
  stat = "auc",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  from = -Inf,
  to = Inf,
  annotate = FALSE,
  digits = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_auc_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_from">from</code></td>
<td>
<p>Left end-point of interval</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_to">to</code></td>
<td>
<p>Right end-point of interval</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_annotate">annotate</code></td>
<td>
<p>Should P() be added in the upper left corner as an annotation?
Works also with a colour character, e.g., &quot;red&quot;.</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_digits">digits</code></td>
<td>
<p>Number of digits shown in annotation</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_auc_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
N1 &lt;- Normal()
plot_pdf(N1) + geom_auc(to = -0.645)
plot_pdf(N1) + geom_auc(from = -0.645, to = 0.1, annotate = TRUE)

N2 &lt;- Normal(0, c(1, 2))
plot_pdf(N2) + geom_auc(to = 0)
plot_pdf(N2) + geom_auc(from = -2, to = 2, annotate = TRUE)
</code></pre>

<hr>
<h2 id='StudentsT'>Create a Student's T distribution</h2><span id='topic+StudentsT'></span>

<h3>Description</h3>

<p>The Student's T distribution is closely related to the <code><a href="#topic+Normal">Normal()</a></code>
distribution, but has heavier tails. As <code class="reqn">\nu</code> increases to <code class="reqn">\infty</code>,
the Student's T converges to a Normal. The T distribution appears
repeatedly throughout classic frequentist hypothesis testing when
comparing group means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StudentsT(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StudentsT_+3A_df">df</code></td>
<td>
<p>Degrees of freedom. Can be any positive number. Often
called <code class="reqn">\nu</code> in textbooks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a Students T random variable with
<code>df</code> = <code class="reqn">\nu</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">R</code>, the set of all real numbers
</p>
<p><strong>Mean</strong>: Undefined unless <code class="reqn">\nu \ge 2</code>, in which case the mean is
zero.
</p>
<p><strong>Variance</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    \frac{\nu}{\nu - 2}
  </code>
</p>

<p>Undefined if <code class="reqn">\nu &lt; 1</code>, infinite when <code class="reqn">1 &lt; \nu \le 2</code>.
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{\Gamma(\frac{\nu + 1}{2})}{\sqrt{\nu \pi} \Gamma(\frac{\nu}{2})} (1 + \frac{x^2}{\nu} )^{- \frac{\nu + 1}{2}}
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p>Nasty, omitted.
</p>
<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p>Undefined.
</p>


<h3>Value</h3>

<p>A <code>StudentsT</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- StudentsT(3)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)

### example: calculating p-values for two-sided T-test

# here the null hypothesis is H_0: mu = 3

# data to test
x &lt;- c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2)
nx &lt;- length(x)

# calculate the T-statistic
t_stat &lt;- (mean(x) - 3) / (sd(x) / sqrt(nx))
t_stat

# null distribution of statistic depends on sample size!
T &lt;- StudentsT(df = nx - 1)

# calculate the two-sided p-value
1 - cdf(T, abs(t_stat)) + cdf(T, -abs(t_stat))

# exactly equivalent to the above
2 * cdf(T, -abs(t_stat))

# p-value for one-sided test
# H_0: mu &lt;= 3   vs   H_A: mu &gt; 3
1 - cdf(T, t_stat)

# p-value for one-sided test
# H_0: mu &gt;= 3   vs   H_A: mu &lt; 3
cdf(T, t_stat)

### example: calculating a 88 percent T CI for a mean

# lower-bound
mean(x) - quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# upper-bound
mean(x) + quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# equivalent to
mean(x) + c(-1, 1) * quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)

# also equivalent to
mean(x) + quantile(T, 0.12 / 2) * sd(x) / sqrt(nx)
mean(x) + quantile(T, 1 - 0.12 / 2) * sd(x) / sqrt(nx)
</code></pre>

<hr>
<h2 id='suff_stat'>Compute the sufficient statistics of a distribution from data</h2><span id='topic+suff_stat'></span>

<h3>Description</h3>

<p>Generic function for computing the sufficient statistics of
a distribution based on empirical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suff_stat(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suff_stat_+3A_d">d</code></td>
<td>
<p>An object. The package provides methods for distribution
objects such as those from <code><a href="#topic+Normal">Normal()</a></code> or <code><a href="#topic+Binomial">Binomial()</a></code> etc.</p>
</td></tr>
<tr><td><code id="suff_stat_+3A_x">x</code></td>
<td>
<p>A vector of data to compute the likelihood.</p>
</td></tr>
<tr><td><code id="suff_stat_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of sufficient statistics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- Normal()
suff_stat(X, c(-1, 0, 0, 0, 3))
</code></pre>

<hr>
<h2 id='suff_stat.Bernoulli'>Compute the sufficient statistics for a Bernoulli distribution from data</h2><span id='topic+suff_stat.Bernoulli'></span>

<h3>Description</h3>

<p>Compute the sufficient statistics for a Bernoulli distribution from data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bernoulli'
suff_stat(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suff_stat.Bernoulli_+3A_d">d</code></td>
<td>
<p>A <code>Bernoulli</code> object.</p>
</td></tr>
<tr><td><code id="suff_stat.Bernoulli_+3A_x">x</code></td>
<td>
<p>A vector of zeroes and ones.</p>
</td></tr>
<tr><td><code id="suff_stat.Bernoulli_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of the sufficient statistics of the Bernoulli
distribution:
</p>

<ul>
<li> <p><code>successes</code>: The number of successful trials (<code>sum(x == 1)</code>)
</p>
</li>
<li> <p><code>failures</code>: The number of failed trials (<code>sum(x == 0)</code>).
</p>
</li></ul>


<hr>
<h2 id='suff_stat.Binomial'>Compute the sufficient statistics for the Binomial distribution from data</h2><span id='topic+suff_stat.Binomial'></span>

<h3>Description</h3>

<p>Compute the sufficient statistics for the Binomial distribution from data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Binomial'
suff_stat(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suff_stat.Binomial_+3A_d">d</code></td>
<td>
<p>A <code>Binomial</code> object.</p>
</td></tr>
<tr><td><code id="suff_stat.Binomial_+3A_x">x</code></td>
<td>
<p>A vector of zeroes and ones.</p>
</td></tr>
<tr><td><code id="suff_stat.Binomial_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of the sufficient statistics of the Binomial
distribution:
</p>

<ul>
<li> <p><code>successes</code>: The total number of successful trials.
</p>
</li>
<li> <p><code>experiments</code>: The number of experiments run.
</p>
</li>
<li> <p><code>trials</code>: The number of trials run per experiment.
</p>
</li></ul>


<hr>
<h2 id='suff_stat.Exponential'>Compute the sufficient statistics of an Exponential distribution from data</h2><span id='topic+suff_stat.Exponential'></span>

<h3>Description</h3>

<p>Compute the sufficient statistics of an Exponential distribution from data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Exponential'
suff_stat(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suff_stat.Exponential_+3A_d">d</code></td>
<td>
<p>An <code>Exponential</code> object created by a call to <code><a href="#topic+Exponential">Exponential()</a></code>.</p>
</td></tr>
<tr><td><code id="suff_stat.Exponential_+3A_x">x</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="suff_stat.Exponential_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of the sufficient statistics of the exponential
distribution:
</p>

<ul>
<li> <p><code>sum</code>: The sum of the observations.
</p>
</li>
<li> <p><code>samples</code>: The number of observations.
</p>
</li></ul>


<hr>
<h2 id='suff_stat.Gamma'>Compute the sufficient statistics for a Gamma distribution from data</h2><span id='topic+suff_stat.Gamma'></span>

<h3>Description</h3>


<ul>
<li> <p><code>sum</code>: The sum of the data.
</p>
</li>
<li> <p><code>log_sum</code>: The log of the sum of the data.
</p>
</li>
<li> <p><code>samples</code>: The number of samples in the data.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gamma'
suff_stat(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suff_stat.Gamma_+3A_d">d</code></td>
<td>
<p>A <code>Gamma</code> object created by a call to <code><a href="#topic+Gamma">Gamma()</a></code>.</p>
</td></tr>
<tr><td><code id="suff_stat.Gamma_+3A_x">x</code></td>
<td>
<p>A vector to fit the Gamma distribution to.</p>
</td></tr>
<tr><td><code id="suff_stat.Gamma_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Gamma</code> object
</p>

<hr>
<h2 id='suff_stat.Geometric'>Compute the sufficient statistics for the Geometric distribution from data</h2><span id='topic+suff_stat.Geometric'></span>

<h3>Description</h3>

<p>Compute the sufficient statistics for the Geometric distribution from data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Geometric'
suff_stat(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suff_stat.Geometric_+3A_d">d</code></td>
<td>
<p>A <code>Geometric</code> object.</p>
</td></tr>
<tr><td><code id="suff_stat.Geometric_+3A_x">x</code></td>
<td>
<p>A vector of zeroes and ones.</p>
</td></tr>
<tr><td><code id="suff_stat.Geometric_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of the sufficient statistics of the Geometric
distribution:
</p>

<ul>
<li> <p><code>trials</code>: The total number of trials ran until the first success.
</p>
</li>
<li> <p><code>experiments</code>: The number of experiments run.
</p>
</li></ul>


<hr>
<h2 id='suff_stat.LogNormal'>Compute the sufficient statistics for a Log-normal distribution from data</h2><span id='topic+suff_stat.LogNormal'></span>

<h3>Description</h3>

<p>Compute the sufficient statistics for a Log-normal distribution from data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LogNormal'
suff_stat(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suff_stat.LogNormal_+3A_d">d</code></td>
<td>
<p>A <code>LogNormal</code> object created by a call to <code><a href="#topic+LogNormal">LogNormal()</a></code>.</p>
</td></tr>
<tr><td><code id="suff_stat.LogNormal_+3A_x">x</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="suff_stat.LogNormal_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of the sufficient statistics of the normal distribution:
</p>

<ul>
<li> <p><code>mu</code>: The sample mean of the log of the data.
</p>
</li>
<li> <p><code>sigma</code>: The sample standard deviation of the log of the data.
</p>
</li>
<li> <p><code>samples</code>: The number of samples in the data.
</p>
</li></ul>


<hr>
<h2 id='suff_stat.Normal'>Compute the sufficient statistics for a Normal distribution from data</h2><span id='topic+suff_stat.Normal'></span>

<h3>Description</h3>

<p>Compute the sufficient statistics for a Normal distribution from data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Normal'
suff_stat(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suff_stat.Normal_+3A_d">d</code></td>
<td>
<p>A <code>Normal</code> object created by a call to <code><a href="#topic+Normal">Normal()</a></code>.</p>
</td></tr>
<tr><td><code id="suff_stat.Normal_+3A_x">x</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="suff_stat.Normal_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of the sufficient statistics of the normal
distribution:
</p>

<ul>
<li> <p><code>mu</code>: The sample mean of the data.
</p>
</li>
<li> <p><code>sigma</code>: The sample standard deviation of the data.
</p>
</li>
<li> <p><code>samples</code>: The number of samples in the data.
</p>
</li></ul>


<hr>
<h2 id='suff_stat.Poisson'>Compute the sufficient statistics of an Poisson distribution from data</h2><span id='topic+suff_stat.Poisson'></span>

<h3>Description</h3>

<p>Compute the sufficient statistics of an Poisson distribution from data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Poisson'
suff_stat(d, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suff_stat.Poisson_+3A_d">d</code></td>
<td>
<p>An <code>Poisson</code> object created by a call to <code><a href="#topic+Poisson">Poisson()</a></code>.</p>
</td></tr>
<tr><td><code id="suff_stat.Poisson_+3A_x">x</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="suff_stat.Poisson_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of the sufficient statistics of the Poisson
distribution:
</p>

<ul>
<li> <p><code>sum</code>: The sum of the data.
</p>
</li>
<li> <p><code>samples</code>: The number of samples in the data.
</p>
</li></ul>


<hr>
<h2 id='support'>Return the support of a distribution</h2><span id='topic+support'></span>

<h3>Description</h3>

<p>Generic function for computing the support interval (minimum and maximum)
for a given probability distribution object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support_+3A_d">d</code></td>
<td>
<p>An object. The package provides methods for distribution
objects such as those from <code><a href="#topic+Normal">Normal()</a></code> or <code><a href="#topic+Binomial">Binomial()</a></code> etc.</p>
</td></tr>
<tr><td><code id="support_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (or matrix) with two elements (or columns) indicating the
range (minimum and maximum) of the support.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- Normal()
support(X)
Y &lt;- Uniform(-1, 1:3)
support(Y)
</code></pre>

<hr>
<h2 id='support.Bernoulli'>Return the support of the Bernoulli distribution</h2><span id='topic+support.Bernoulli'></span>

<h3>Description</h3>

<p>Return the support of the Bernoulli distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bernoulli'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Bernoulli_+3A_d">d</code></td>
<td>
<p>An <code>Bernoulli</code> object created by a call to <code><a href="#topic+Bernoulli">Bernoulli()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Bernoulli_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Bernoulli_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Beta'>Return the support of the Beta distribution</h2><span id='topic+support.Beta'></span>

<h3>Description</h3>

<p>Return the support of the Beta distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Beta'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Beta_+3A_d">d</code></td>
<td>
<p>An <code>Beta</code> object created by a call to <code><a href="#topic+Beta">Beta()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Beta_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Beta_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Binomial'>Return the support of the Binomial distribution</h2><span id='topic+support.Binomial'></span>

<h3>Description</h3>

<p>Return the support of the Binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Binomial'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Binomial_+3A_d">d</code></td>
<td>
<p>An <code>Binomial</code> object created by a call to <code><a href="#topic+Binomial">Binomial()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Binomial_+3A_drop">drop</code></td>
<td>
<p>logical. Shoul the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Binomial_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Cauchy'>Return the support of the Cauchy distribution</h2><span id='topic+support.Cauchy'></span>

<h3>Description</h3>

<p>Return the support of the Cauchy distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cauchy'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Cauchy_+3A_d">d</code></td>
<td>
<p>An <code>Cauchy</code> object created by a call to <code><a href="#topic+Cauchy">Cauchy()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Cauchy_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Cauchy_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.ChiSquare'>Return the support of the ChiSquare distribution</h2><span id='topic+support.ChiSquare'></span>

<h3>Description</h3>

<p>Return the support of the ChiSquare distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ChiSquare'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.ChiSquare_+3A_d">d</code></td>
<td>
<p>An <code>ChiSquare</code> object created by a call to <code><a href="#topic+ChiSquare">ChiSquare()</a></code>.</p>
</td></tr>
<tr><td><code id="support.ChiSquare_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.ChiSquare_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Erlang'>Return the support of the Erlang distribution</h2><span id='topic+support.Erlang'></span>

<h3>Description</h3>

<p>Return the support of the Erlang distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Erlang'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Erlang_+3A_d">d</code></td>
<td>
<p>An <code>Erlang</code> object created by a call to <code><a href="#topic+Erlang">Erlang()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Erlang_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Erlang_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Exponential'>Return the support of the Exponential distribution</h2><span id='topic+support.Exponential'></span>

<h3>Description</h3>

<p>Return the support of the Exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Exponential'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Exponential_+3A_d">d</code></td>
<td>
<p>An <code>Exponential</code> object created by a call to <code><a href="#topic+Exponential">Exponential()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Exponential_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Exponential_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.FisherF'>Return the support of the FisherF distribution</h2><span id='topic+support.FisherF'></span>

<h3>Description</h3>

<p>Return the support of the FisherF distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FisherF'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.FisherF_+3A_d">d</code></td>
<td>
<p>An <code>FisherF</code> object created by a call to <code><a href="#topic+FisherF">FisherF()</a></code>.</p>
</td></tr>
<tr><td><code id="support.FisherF_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.FisherF_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Frechet'>Return the support of the Frechet distribution</h2><span id='topic+support.Frechet'></span>

<h3>Description</h3>

<p>Return the support of the Frechet distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Frechet'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Frechet_+3A_d">d</code></td>
<td>
<p>An <code>Frechet</code> object created by a call to <code><a href="#topic+Frechet">Frechet()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Frechet_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Frechet_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, a numeric vector of length 2
with the minimum and maximum value of the support (if <code>drop = TRUE</code>, default)
or a <code>matrix</code> with 2 columns. In case of a vectorized distribution object, a
matrix with 2 columns containing all minima and maxima.
</p>

<hr>
<h2 id='support.Gamma'>Return the support of the Gamma distribution</h2><span id='topic+support.Gamma'></span>

<h3>Description</h3>

<p>Return the support of the Gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gamma'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Gamma_+3A_d">d</code></td>
<td>
<p>An <code>Gamma</code> object created by a call to <code><a href="#topic+Gamma">Gamma()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Gamma_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Gamma_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Geometric'>Return the support of the Geometric distribution</h2><span id='topic+support.Geometric'></span>

<h3>Description</h3>

<p>Return the support of the Geometric distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Geometric'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Geometric_+3A_d">d</code></td>
<td>
<p>An <code>Geometric</code> object created by a call to <code><a href="#topic+Geometric">Geometric()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Geometric_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Geometric_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.GEV'>Return the support of a GEV distribution</h2><span id='topic+support.GEV'></span>

<h3>Description</h3>

<p>Return the support of a GEV distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GEV'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.GEV_+3A_d">d</code></td>
<td>
<p>An <code>GEV</code> object created by a call to <code><a href="#topic+GEV">GEV()</a></code>.</p>
</td></tr>
<tr><td><code id="support.GEV_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.GEV_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, a numeric vector of length 2
with the minimum and maximum value of the support (if <code>drop = TRUE</code>, default)
or a <code>matrix</code> with 2 columns. In case of a vectorized distribution object, a
matrix with 2 columns containing all minima and maxima.
</p>

<hr>
<h2 id='support.GP'>Return the support of the GP distribution</h2><span id='topic+support.GP'></span>

<h3>Description</h3>

<p>Return the support of the GP distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GP'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.GP_+3A_d">d</code></td>
<td>
<p>An <code>GP</code> object created by a call to <code><a href="#topic+GP">GP()</a></code>.</p>
</td></tr>
<tr><td><code id="support.GP_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.GP_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, a numeric vector of length 2
with the minimum and maximum value of the support (if <code>drop = TRUE</code>, default)
or a <code>matrix</code> with 2 columns. In case of a vectorized distribution object, a
matrix with 2 columns containing all minima and maxima.
</p>

<hr>
<h2 id='support.Gumbel'>Return the support of the Gumbel distribution</h2><span id='topic+support.Gumbel'></span>

<h3>Description</h3>

<p>Return the support of the Gumbel distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gumbel'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Gumbel_+3A_d">d</code></td>
<td>
<p>An <code>Gumbel</code> object created by a call to <code><a href="#topic+Gumbel">Gumbel()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Gumbel_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Gumbel_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, a numeric vector of length 2
with the minimum and maximum value of the support (if <code>drop = TRUE</code>, default)
or a <code>matrix</code> with 2 columns. In case of a vectorized distribution object, a
matrix with 2 columns containing all minima and maxima.
</p>

<hr>
<h2 id='support.HurdleNegativeBinomial'>Return the support of the hurdle negative binomial distribution</h2><span id='topic+support.HurdleNegativeBinomial'></span>

<h3>Description</h3>

<p>Return the support of the hurdle negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HurdleNegativeBinomial'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.HurdleNegativeBinomial_+3A_d">d</code></td>
<td>
<p>An <code>HurdleNegativeBinomial</code> object created by a call to <code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="support.HurdleNegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.HurdleNegativeBinomial_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.HurdlePoisson'>Return the support of the hurdle Poisson distribution</h2><span id='topic+support.HurdlePoisson'></span>

<h3>Description</h3>

<p>Return the support of the hurdle Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HurdlePoisson'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.HurdlePoisson_+3A_d">d</code></td>
<td>
<p>An <code>HurdlePoisson</code> object created by a call to <code><a href="#topic+HurdlePoisson">HurdlePoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="support.HurdlePoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.HurdlePoisson_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.HyperGeometric'>Return the support of the HyperGeometric distribution</h2><span id='topic+support.HyperGeometric'></span>

<h3>Description</h3>

<p>Return the support of the HyperGeometric distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HyperGeometric'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.HyperGeometric_+3A_d">d</code></td>
<td>
<p>An <code>HyperGeometric</code> object created by a call to <code><a href="#topic+HyperGeometric">HyperGeometric()</a></code>.</p>
</td></tr>
<tr><td><code id="support.HyperGeometric_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.HyperGeometric_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Logistic'>Return the support of the Logistic distribution</h2><span id='topic+support.Logistic'></span>

<h3>Description</h3>

<p>Return the support of the Logistic distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Logistic'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Logistic_+3A_d">d</code></td>
<td>
<p>An <code>Logistic</code> object created by a call to <code><a href="#topic+Logistic">Logistic()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Logistic_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Logistic_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.LogNormal'>Return the support of the LogNormal distribution</h2><span id='topic+support.LogNormal'></span>

<h3>Description</h3>

<p>Return the support of the LogNormal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LogNormal'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.LogNormal_+3A_d">d</code></td>
<td>
<p>An <code>LogNormal</code> object created by a call to <code><a href="#topic+LogNormal">LogNormal()</a></code>.</p>
</td></tr>
<tr><td><code id="support.LogNormal_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.LogNormal_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.NegativeBinomial'>Return the support of the NegativeBinomial distribution</h2><span id='topic+support.NegativeBinomial'></span>

<h3>Description</h3>

<p>Return the support of the NegativeBinomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NegativeBinomial'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.NegativeBinomial_+3A_d">d</code></td>
<td>
<p>An <code>NegativeBinomial</code> object created by a call to <code><a href="#topic+NegativeBinomial">NegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="support.NegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.NegativeBinomial_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Normal'>Return the support of the Normal distribution</h2><span id='topic+support.Normal'></span>

<h3>Description</h3>

<p>Return the support of the Normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Normal'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Normal_+3A_d">d</code></td>
<td>
<p>An <code>Normal</code> object created by a call to <code><a href="#topic+Normal">Normal()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Normal_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Normal_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a single distribution object, a numeric vector of length 2
with the minimum and maximum value of the support (if <code>drop = TRUE</code>, default)
or a <code>matrix</code> with 2 columns. In case of a vectorized distribution object, a
matrix with 2 columns containing all minima and maxima.
</p>

<hr>
<h2 id='support.Poisson'>Return the support of the Poisson distribution</h2><span id='topic+support.Poisson'></span>

<h3>Description</h3>

<p>Return the support of the Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Poisson'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Poisson_+3A_d">d</code></td>
<td>
<p>An <code>Poisson</code> object created by a call to <code><a href="#topic+Poisson">Poisson()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Poisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Poisson_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.RevWeibull'>Return the support of the RevWeibull distribution</h2><span id='topic+support.RevWeibull'></span>

<h3>Description</h3>

<p>Return the support of the RevWeibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RevWeibull'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.RevWeibull_+3A_d">d</code></td>
<td>
<p>An <code>RevWeibull</code> object created by a call to <code><a href="#topic+RevWeibull">RevWeibull()</a></code>.</p>
</td></tr>
<tr><td><code id="support.RevWeibull_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.RevWeibull_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.StudentsT'>Return the support of the StudentsT distribution</h2><span id='topic+support.StudentsT'></span>

<h3>Description</h3>

<p>Return the support of the StudentsT distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'StudentsT'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.StudentsT_+3A_d">d</code></td>
<td>
<p>An <code>StudentsT</code> object created by a call to <code><a href="#topic+StudentsT">StudentsT()</a></code>.</p>
</td></tr>
<tr><td><code id="support.StudentsT_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.StudentsT_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Tukey'>Return the support of the Tukey distribution</h2><span id='topic+support.Tukey'></span>

<h3>Description</h3>

<p>Return the support of the Tukey distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Tukey'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Tukey_+3A_d">d</code></td>
<td>
<p>An <code>Tukey</code> object created by a call to <code><a href="#topic+Tukey">Tukey()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Tukey_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Tukey_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Uniform'>Return the support of the Uniform distribution</h2><span id='topic+support.Uniform'></span>

<h3>Description</h3>

<p>Return the support of the Uniform distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Uniform'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Uniform_+3A_d">d</code></td>
<td>
<p>An <code>Uniform</code> object created by a call to <code><a href="#topic+Uniform">Uniform()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Uniform_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Uniform_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.Weibull'>Return the support of the Weibull distribution</h2><span id='topic+support.Weibull'></span>

<h3>Description</h3>

<p>Return the support of the Weibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Weibull'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.Weibull_+3A_d">d</code></td>
<td>
<p>An <code>Weibull</code> object created by a call to <code><a href="#topic+Weibull">Weibull()</a></code>.</p>
</td></tr>
<tr><td><code id="support.Weibull_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.Weibull_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.ZINegativeBinomial'>Return the support of the zero-inflated negative binomial distribution</h2><span id='topic+support.ZINegativeBinomial'></span>

<h3>Description</h3>

<p>Return the support of the zero-inflated negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZINegativeBinomial'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.ZINegativeBinomial_+3A_d">d</code></td>
<td>
<p>An <code>ZINegativeBinomial</code> object created by a call to <code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="support.ZINegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.ZINegativeBinomial_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.ZIPoisson'>Return the support of the zero-inflated Poisson distribution</h2><span id='topic+support.ZIPoisson'></span>

<h3>Description</h3>

<p>Return the support of the zero-inflated Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZIPoisson'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.ZIPoisson_+3A_d">d</code></td>
<td>
<p>An <code>ZIPoisson</code> object created by a call to <code><a href="#topic+ZIPoisson">ZIPoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="support.ZIPoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.ZIPoisson_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.ZTNegativeBinomial'>Return the support of the zero-truncated negative binomial distribution</h2><span id='topic+support.ZTNegativeBinomial'></span>

<h3>Description</h3>

<p>Return the support of the zero-truncated negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZTNegativeBinomial'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.ZTNegativeBinomial_+3A_d">d</code></td>
<td>
<p>An <code>ZTNegativeBinomial</code> object created by a call to <code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial()</a></code>.</p>
</td></tr>
<tr><td><code id="support.ZTNegativeBinomial_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.ZTNegativeBinomial_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='support.ZTPoisson'>Return the support of the zero-truncated Poisson distribution</h2><span id='topic+support.ZTPoisson'></span>

<h3>Description</h3>

<p>Return the support of the zero-truncated Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZTPoisson'
support(d, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support.ZTPoisson_+3A_d">d</code></td>
<td>
<p>An <code>ZTPoisson</code> object created by a call to <code><a href="#topic+ZTPoisson">ZTPoisson()</a></code>.</p>
</td></tr>
<tr><td><code id="support.ZTPoisson_+3A_drop">drop</code></td>
<td>
<p>logical. Should the result be simplified to a vector if possible?</p>
</td></tr>
<tr><td><code id="support.ZTPoisson_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the minimum and maximum value of the support.
</p>

<hr>
<h2 id='Tukey'>Create a Tukey distribution</h2><span id='topic+Tukey'></span>

<h3>Description</h3>

<p>Tukey's studentized range distribution, used for Tukey's
honestly significant differences test in ANOVA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tukey(nmeans, df, nranges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tukey_+3A_nmeans">nmeans</code></td>
<td>
<p>Sample size for each range.</p>
</td></tr>
<tr><td><code id="Tukey_+3A_df">df</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code id="Tukey_+3A_nranges">nranges</code></td>
<td>
<p>Number of groups being compared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p><strong>Support</strong>: <code class="reqn">R^+</code>, the set of positive real numbers.
</p>
<p>Other properties of Tukey's Studentized Range Distribution
are omitted, largely because the distribution is not fun
to work with.
</p>


<h3>Value</h3>

<p>A <code>Tukey</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Tukey(4L, 16L, 2L)
X

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='Uniform'>Create a Continuous Uniform distribution</h2><span id='topic+Uniform'></span>

<h3>Description</h3>

<p>A distribution with constant density on an interval. The
continuous analogue to the <code><a href="#topic+Categorical">Categorical()</a></code> distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Uniform(a = 0, b = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Uniform_+3A_a">a</code></td>
<td>
<p>The a parameter. <code>a</code> can be any value in the set of real
numbers. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="Uniform_+3A_b">b</code></td>
<td>
<p>The a parameter. <code>b</code> can be any value in the set of real
numbers. It should be strictly bigger than <code>a</code>, but if is not, the
order of the parameters is inverted. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Uniform</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Weibull">Weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Uniform(1, 2)
X

random(X, 10)

pdf(X, 0.7)
log_pdf(X, 0.7)

cdf(X, 0.7)
quantile(X, 0.7)

cdf(X, quantile(X, 0.7))
quantile(X, cdf(X, 0.7))
</code></pre>

<hr>
<h2 id='variance'>Compute the moments of a probability distribution</h2><span id='topic+variance'></span><span id='topic+skewness'></span><span id='topic+kurtosis'></span>

<h3>Description</h3>

<p>Generic functions for computing moments (variance, skewness, excess kurtosis)
from probability distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance(x, ...)

skewness(x, ...)

kurtosis(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variance_+3A_x">x</code></td>
<td>
<p>An object. The package provides methods for distribution
objects such as those from <code><a href="#topic+Normal">Normal()</a></code> or <code><a href="#topic+Binomial">Binomial()</a></code> etc.</p>
</td></tr>
<tr><td><code id="variance_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods. Unevaluated arguments will generate a warning to
catch mispellings or other possible errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>variance</code>, <code>skewness</code>, and <code>kurtosis</code> are new
generic functions for computing moments of probability distributions such as
those provided in this package. Additionally, the probability distributions
from <span class="pkg">distributions3</span> all have methods for the <code><a href="base.html#topic+mean">mean</a></code>
generic. Moreover, quantiles can be computed with methods for
<code><a href="stats.html#topic+quantile">quantile</a></code>. For examples illustrating the usage with
probability distribution objects, see the manual pages of the respective
distributions, e.g., <code><a href="#topic+Normal">Normal</a></code> or <code><a href="#topic+Binomial">Binomial</a></code> etc.
</p>


<h3>Value</h3>

<p>Numeric vector with the values of the moments.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>,
<code><a href="#topic+cdf">cdf</a></code>, <code><a href="#topic+random">random</a></code>
</p>

<hr>
<h2 id='Weibull'>Create a Weibull distribution</h2><span id='topic+Weibull'></span>

<h3>Description</h3>

<p>Generalization of the gamma distribution. Often used in survival and
time-to-event analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Weibull(shape, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Weibull_+3A_shape">shape</code></td>
<td>
<p>The shape parameter <code class="reqn">k</code>. Can be any positive real number.</p>
</td></tr>
<tr><td><code id="Weibull_+3A_scale">scale</code></td>
<td>
<p>The scale parameter <code class="reqn">\lambda</code>. Can be any positive real
number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail and much greater clarity.
</p>
<p>In the following, let <code class="reqn">X</code> be a Weibull random variable with
success probability <code>p</code> = <code class="reqn">p</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">R^+</code> and zero.
</p>
<p><strong>Mean</strong>: <code class="reqn">\lambda \Gamma(1+1/k)</code>, where <code class="reqn">\Gamma</code> is
the gamma function.
</p>
<p><strong>Variance</strong>: <code class="reqn">\lambda [ \Gamma (1 + \frac{2}{k} ) - (\Gamma(1+ \frac{1}{k}))^2 ]</code>
</p>
<p><strong>Probability density function (p.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{k}{\lambda}(\frac{x}{\lambda})^{k-1}e^{-(x/\lambda)^k}, x \ge 0
  </code>
</p>

<p><strong>Cumulative distribution function (c.d.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = 1 - e^{-(x/\lambda)^k}, x \ge 0</code>
</p>

<p><strong>Moment generating function (m.g.f)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{n=0}^\infty \frac{t^n\lambda^n}{n!} \Gamma(1+n/k), k \ge 1</code>
</p>



<h3>Value</h3>

<p>A <code>Weibull</code> object.
</p>


<h3>See Also</h3>

<p>Other continuous distributions: 
<code><a href="#topic+Beta">Beta</a>()</code>,
<code><a href="#topic+Cauchy">Cauchy</a>()</code>,
<code><a href="#topic+ChiSquare">ChiSquare</a>()</code>,
<code><a href="#topic+Erlang">Erlang</a>()</code>,
<code><a href="#topic+Exponential">Exponential</a>()</code>,
<code><a href="#topic+FisherF">FisherF</a>()</code>,
<code><a href="#topic+Frechet">Frechet</a>()</code>,
<code><a href="#topic+GEV">GEV</a>()</code>,
<code><a href="#topic+GP">GP</a>()</code>,
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Gumbel">Gumbel</a>()</code>,
<code><a href="#topic+LogNormal">LogNormal</a>()</code>,
<code><a href="#topic+Logistic">Logistic</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+RevWeibull">RevWeibull</a>()</code>,
<code><a href="#topic+StudentsT">StudentsT</a>()</code>,
<code><a href="#topic+Tukey">Tukey</a>()</code>,
<code><a href="#topic+Uniform">Uniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(27)

X &lt;- Weibull(0.3, 2)
X

random(X, 10)

pdf(X, 2)
log_pdf(X, 2)

cdf(X, 4)
quantile(X, 0.7)
</code></pre>

<hr>
<h2 id='ZINegativeBinomial'>Create a zero-inflated negative binomial distribution</h2><span id='topic+ZINegativeBinomial'></span>

<h3>Description</h3>

<p>Zero-inflated negative binomial distributions are frequently used to model counts
with overdispersion and many zero observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZINegativeBinomial(mu, theta, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZINegativeBinomial_+3A_mu">mu</code></td>
<td>
<p>Location parameter of the negative binomial component of the distribution.
Can be any positive number.</p>
</td></tr>
<tr><td><code id="ZINegativeBinomial_+3A_theta">theta</code></td>
<td>
<p>Overdispersion parameter of the negative binomial component of the distribution.
Can be any positive number.</p>
</td></tr>
<tr><td><code id="ZINegativeBinomial_+3A_pi">pi</code></td>
<td>
<p>Zero-inflation probability, can be any value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail.
</p>
<p>In the following, let <code class="reqn">X</code> be a zero-inflated negative binomial random variable with parameters
<code>mu</code> = <code class="reqn">\mu</code> and <code>theta</code> = <code class="reqn">\theta</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">\{0, 1, 2, 3, ...\}</code>
</p>
<p><strong>Mean</strong>: <code class="reqn">(1 - \pi) \cdot \mu</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">(1 - \pi) \cdot \mu \cdot (1 + (\pi + 1/\theta) \cdot \mu)</code>
</p>
<p><strong>Probability mass function (p.m.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = \pi \cdot I_{0}(k) + (1 - \pi) \cdot f(k; \mu, \theta)
  </code>
</p>

<p>where <code class="reqn">I_{0}(k)</code> is the indicator function for zero and
<code class="reqn">f(k; \mu, \theta)</code> is the p.m.f. of the <code><a href="#topic+NegativeBinomial">NegativeBinomial</a></code>
distribution.
</p>
<p><strong>Cumulative distribution function (c.d.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X \le k) = \pi + (1 - \pi) \cdot F(k; \mu, \theta)
  </code>
</p>

<p>where <code class="reqn">F(k; \mu, \theta)</code> is the c.d.f. of the <code><a href="#topic+NegativeBinomial">NegativeBinomial</a></code> distribution.
</p>
<p><strong>Moment generating function (m.g.f.)</strong>:
</p>
<p>Omitted for now.
</p>


<h3>Value</h3>

<p>A <code>ZINegativeBinomial</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-inflated negative binomial distribution
X &lt;- ZINegativeBinomial(mu = 2.5, theta = 1, pi = 0.25)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='ZIPoisson'>Create a zero-inflated Poisson distribution</h2><span id='topic+ZIPoisson'></span>

<h3>Description</h3>

<p>Zero-inflated Poisson distributions are frequently used to model counts
with many zero observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZIPoisson(lambda, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZIPoisson_+3A_lambda">lambda</code></td>
<td>
<p>Parameter of the Poisson component of the distribution.
Can be any positive number.</p>
</td></tr>
<tr><td><code id="ZIPoisson_+3A_pi">pi</code></td>
<td>
<p>Zero-inflation probability, can be any value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail.
</p>
<p>In the following, let <code class="reqn">X</code> be a zero-inflated Poisson random variable with parameter
<code>lambda</code> = <code class="reqn">\lambda</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">\{0, 1, 2, 3, ...\}</code>
</p>
<p><strong>Mean</strong>: <code class="reqn">(1 - \pi) \cdot \lambda</code>
</p>
<p><strong>Variance</strong>: <code class="reqn">(1 - \pi) \cdot \lambda \cdot (1 + \pi \cdot \lambda)</code>
</p>
<p><strong>Probability mass function (p.m.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = \pi \cdot I_{0}(k) + (1 - \pi) \cdot f(k; \lambda)
  </code>
</p>

<p>where <code class="reqn">I_{0}(k)</code> is the indicator function for zero and
<code class="reqn">f(k; \lambda)</code> is the p.m.f. of the <code><a href="#topic+Poisson">Poisson</a></code>
distribution.
</p>
<p><strong>Cumulative distribution function (c.d.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X \le k) = \pi + (1 - \pi) \cdot F(k; \lambda)
  </code>
</p>

<p>where <code class="reqn">F(k; \lambda)</code> is the c.d.f. of the <code><a href="#topic+Poisson">Poisson</a></code> distribution.
</p>
<p><strong>Moment generating function (m.g.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    E(e^{tX}) = \pi + (1 - \pi) \cdot e^{\lambda (e^t - 1)}
  </code>
</p>



<h3>Value</h3>

<p>A <code>ZIPoisson</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-inflated Poisson distribution
X &lt;- ZIPoisson(lambda = 2.5, pi = 0.25)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='ZTNegativeBinomial'>Create a zero-truncated negative binomial distribution</h2><span id='topic+ZTNegativeBinomial'></span>

<h3>Description</h3>

<p>Zero-truncated negative binomial distributions are frequently used to model counts
where zero observations cannot occur or have been excluded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZTNegativeBinomial(mu, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZTNegativeBinomial_+3A_mu">mu</code></td>
<td>
<p>Location parameter of the negative binomial component of the distribution.
Can be any positive number.</p>
</td></tr>
<tr><td><code id="ZTNegativeBinomial_+3A_theta">theta</code></td>
<td>
<p>Overdispersion parameter of the negative binomial component of the distribution.
Can be any positive number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail.
</p>
<p>In the following, let <code class="reqn">X</code> be a zero-truncated negative binomial random variable with parameter
<code>mu</code> = <code class="reqn">\mu</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">\{1, 2, 3, ...\}</code>
</p>
<p><strong>Mean</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    \mu \cdot \frac{1}{1 - F(0; \mu, \theta)}
  </code>
</p>

<p>where <code class="reqn">F(k; \mu, \theta)</code> is the c.d.f. of the <code><a href="#topic+NegativeBinomial">NegativeBinomial</a></code> distribution.
</p>
<p><strong>Variance</strong>: <code class="reqn">m \cdot (\mu + 1 - m)</code>, where <code class="reqn">m</code> is the mean above.
</p>
<p><strong>Probability mass function (p.m.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = \frac{f(k; \mu, \theta)}{1 - F(0; \mu, \theta)}
  </code>
</p>

<p>where <code class="reqn">f(k; \mu, \theta)</code> is the p.m.f. of the <code><a href="#topic+NegativeBinomial">NegativeBinomial</a></code>
distribution.
</p>
<p><strong>Cumulative distribution function (c.d.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = \frac{F(k; \mu, \theta)}{1 - F(0; \mu, \theta)}
  </code>
</p>

<p><strong>Moment generating function (m.g.f.)</strong>:
</p>
<p>Omitted for now.
</p>


<h3>Value</h3>

<p>A <code>ZTNegativeBinomial</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTPoisson">ZTPoisson</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-truncated negative binomial distribution
X &lt;- ZTNegativeBinomial(mu = 2.5, theta = 1)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

<hr>
<h2 id='ZTPoisson'>Create a zero-truncated Poisson distribution</h2><span id='topic+ZTPoisson'></span>

<h3>Description</h3>

<p>Zero-truncated Poisson distributions are frequently used to model counts
where zero observations cannot occur or have been excluded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZTPoisson(lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZTPoisson_+3A_lambda">lambda</code></td>
<td>
<p>Parameter of the underlying untruncated Poisson distribution.
Can be any positive number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We recommend reading this documentation on
<a href="https://alexpghayes.github.io/distributions3/">https://alexpghayes.github.io/distributions3/</a>, where the math
will render with additional detail.
</p>
<p>In the following, let <code class="reqn">X</code> be a zero-truncated Poisson random variable with parameter
<code>lambda</code> = <code class="reqn">\lambda</code>.
</p>
<p><strong>Support</strong>: <code class="reqn">\{1, 2, 3, ...\}</code>
</p>
<p><strong>Mean</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda \cdot \frac{1}{1 - e^{-\lambda}}
  </code>
</p>

<p><strong>Variance</strong>: <code class="reqn">m \cdot (\lambda + 1 - m)</code>, where <code class="reqn">m</code> is the mean above.
</p>
<p><strong>Probability mass function (p.m.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = \frac{f(k; \lambda)}{1 - f(0; \lambda)}
  </code>
</p>

<p>where <code class="reqn">f(k; \lambda)</code> is the p.m.f. of the <code><a href="#topic+Poisson">Poisson</a></code>
distribution.
</p>
<p><strong>Cumulative distribution function (c.d.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    P(X = k) = \frac{F(k; \lambda)}{1 - F(0; \lambda)}
  </code>
</p>

<p>where <code class="reqn">F(k; \lambda)</code> is the c.d.f. of the <code><a href="#topic+Poisson">Poisson</a></code> distribution.
</p>
<p><strong>Moment generating function (m.g.f.)</strong>:
</p>
<p style="text-align: center;"><code class="reqn">
    E(e^{tX}) = \frac{1}{1 - e^{-\lambda}} \cdot e^{\lambda (e^t - 1)}
  </code>
</p>



<h3>Value</h3>

<p>A <code>ZTPoisson</code> object.
</p>


<h3>See Also</h3>

<p>Other discrete distributions: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Binomial">Binomial</a>()</code>,
<code><a href="#topic+Categorical">Categorical</a>()</code>,
<code><a href="#topic+Geometric">Geometric</a>()</code>,
<code><a href="#topic+HurdleNegativeBinomial">HurdleNegativeBinomial</a>()</code>,
<code><a href="#topic+HurdlePoisson">HurdlePoisson</a>()</code>,
<code><a href="#topic+HyperGeometric">HyperGeometric</a>()</code>,
<code><a href="#topic+Multinomial">Multinomial</a>()</code>,
<code><a href="#topic+NegativeBinomial">NegativeBinomial</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+ZINegativeBinomial">ZINegativeBinomial</a>()</code>,
<code><a href="#topic+ZIPoisson">ZIPoisson</a>()</code>,
<code><a href="#topic+ZTNegativeBinomial">ZTNegativeBinomial</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a zero-truncated Poisson distribution
X &lt;- ZTPoisson(lambda = 2.5)
X

## standard functions
pdf(X, 0:8)
cdf(X, 0:8)
quantile(X, seq(0, 1, by = 0.25))

## cdf() and quantile() are inverses for each other
quantile(X, cdf(X, 3))

## density visualization
plot(0:8, pdf(X, 0:8), type = "h", lwd = 2)

## corresponding sample with histogram of empirical frequencies
set.seed(0)
x &lt;- random(X, 500)
hist(x, breaks = -1:max(x) + 0.5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
