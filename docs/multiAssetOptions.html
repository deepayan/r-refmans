<!DOCTYPE html><html lang="en"><head><title>Help for package multiAssetOptions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multiAssetOptions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multiAssetOptions-package'>
<p>Finite Difference Method for Multi-Asset Option Valuation</p></a></li>
<li><a href='#matrixFDM'>
<p>Finite Difference Matrix Generator</p></a></li>
<li><a href='#multiAssetOption'>
<p>Finite Difference Method for Multi-Asset Option Valuation</p></a></li>
<li><a href='#nodeSpacer'>
<p>Non-Uniform Finite Difference Node Spacer</p></a></li>
<li><a href='#payoff'>
<p>Multi-Asset Option Payoff Calculator</p></a></li>
<li><a href='#plotOptionValues'>
<p>Plot Option Values Over Time</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Finite Difference Method for Multi-Asset Option Valuation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Eichenberger and Carlo Rosa</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Eichenberger &lt;mike.eichenberger@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, graphics</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient finite difference method for valuing European and American multi-asset options.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-20 14:27:41 UTC; mike</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-20 14:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='multiAssetOptions-package'>
Finite Difference Method for Multi-Asset Option Valuation
</h2><span id='topic+multiAssetOptions-package'></span><span id='topic+multiAssetOptions'></span>

<h3>Description</h3>

<p>This package implements an efficient finite difference method for valuing multi-asset options in the Black-Scholes world. The model assumes static volatilities and correlations. The implementation allows users to vary the option setup (number of underlying assets, call vs. put, European vs. American, etc.) as well as some of the features of the numerical method (mesh spacing, timestepping scheme, etc.).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> multiAssetOptions</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-04-20</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package contains the function <code>multiAssetOption</code>, which implements a generalized version of the finite difference method for option valuation. Several sub-functions are included in this package to improve code clarity and presentation.
</p>


<h3>Author(s)</h3>

<p>Michael Eichenberger and Carlo Rosa
</p>
<p>Maintainer: Michael Eichenberger &lt;mike.eichenberger@gmail.com&gt;
</p>

<hr>
<h2 id='matrixFDM'>
Finite Difference Matrix Generator
</h2><span id='topic+matrixFDM'></span>

<h3>Description</h3>

<p>Generates a modified coefficient matrix (<b>M</b>-matrix) used in the finite difference method from the option inputs. See Tavella and Randall (2000) for more on the standard formulation of the <b>M</b>-matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixFDM(S, rf, q, vol, rho)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrixFDM_+3A_s">S</code></td>
<td>

<p>list containing the vectors of spatial grid points associated with each underlying. Vector sizes of underlying spatial grid points need not be equal.
</p>
</td></tr>
<tr><td><code id="matrixFDM_+3A_rf">rf</code></td>
<td>

<p>scalar; applicable risk-free rate (domestic risk-free rate).
</p>
</td></tr>
<tr><td><code id="matrixFDM_+3A_q">q</code></td>
<td>

<p>vector; holding costs of the option's underlyings (dividends, foreign risk-free rates, etc.).
</p>
</td></tr>
<tr><td><code id="matrixFDM_+3A_vol">vol</code></td>
<td>

<p>vector; volatilities of the option's underlyings.
</p>
</td></tr>
<tr><td><code id="matrixFDM_+3A_rho">rho</code></td>
<td>

<p>matrix; correlation matrix of the option's underlyings.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>matrixFDM</code> first constructs the non-zero diagonals of the <b>M</b>-matrix and stores them as columns.  The <code>bandSparse</code> function from the <span class="pkg">Matrix</span> package then constructs a sparse banded matrix from the columns of the previously contructed matrix. Spatial domain boundaries are calculated first-order inwards with second difference terms dropped, maintaining block tridiagonality.
</p>


<h3>Value</h3>

<p><code>matrixFDM</code> returns a <code>CsparseMatrix</code>-class matrix used for timestepping in the finite difference method.
</p>


<h3>Author(s)</h3>

<p>Michael Eichenberger and Carlo Rosa
</p>


<h3>References</h3>

<p>Tavella, D., Randall, C., 2000. Pricing Financial Instruments: The Finite Difference Method. John Wiley &amp; Sons, Inc., New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># finite difference matrix for uniformly-spaced two-asset option
S1 &lt;- list(seq(0, 5, by=1), seq(0, 5, by=1))
rf &lt;- 0.1
q &lt;- c(0.05, 0.04)
vol &lt;- c(0.20, 0.25)
rho &lt;- matrix(c(1,-0.5,-0.5,1), 2, 2)
matrixFDM(S1, rf, q, vol, rho)
</code></pre>

<hr>
<h2 id='multiAssetOption'>
Finite Difference Method for Multi-Asset Option Valuation
</h2><span id='topic+multiAssetOption'></span>

<h3>Description</h3>

<p><code>multiAssetOption</code> generalizes the standard finite difference method to handle mulitple underlying assets, non-uniform grid spacing, non-uniform timestepping, and American exercise. The implementation allows users to vary the option setup (number of underlying assets, call vs. put, European vs. American, etc.) as well as the features of the numerical method (grid spacing, timestepping scheme, etc.). Strike shifting the mesh and Rannacher smoothing are optionally included to remedy problems arising from potential spurious oscillations in the solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiAssetOption(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiAssetOption_+3A_x">X</code></td>
<td>

<p>list of inputs. List items given in the <b>Details</b> section.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Items of the input list <code>X</code> are as follows:
</p>

<dl>
<dt><code>X$opt$nAsset</code></dt><dd>
<p>integer; number of underlying assets.
</p>
</dd>
<dt><code>X$opt$payType</code></dt><dd>
<p>case; if 0, digital payoff, if 1, best-of payoff, if 2, worst-of payoff.
</p>
</dd>
<dt><code>X$opt$exerType</code></dt><dd>
<p>case; if 0, European exercise, if 1, American exercise.
</p>
</dd>
<dt><code>X$opt$pcFlag</code></dt><dd>
<p>case vector; if 0, call, if 1, put.
</p>
</dd>
<dt><code>X$opt$ttm</code></dt><dd>
<p>scalar; time to maturity.
</p>
</dd>
<dt><code>X$opt$strike</code></dt><dd>
<p>vector; option strikes.
</p>
</dd>
<dt><code>X$opt$rf</code></dt><dd>
<p>scalar; applicable risk-free rate (domestic risk-free rate).
</p>
</dd>
<dt><code>X$opt$q</code></dt><dd>
<p>vector; holding costs of the option's underlyings (dividends, foreign risk-free rates, etc.).
</p>
</dd>
<dt><code>X$opt$vol</code></dt><dd>
<p>vector; volatilities of the option's underlyings.
</p>
</dd>
<dt><code>X$opt$rho</code></dt><dd>
<p>matrix; correlation matrix of the option's underlyings.
</p>
</dd>
<dt><code>X$fd$m</code></dt><dd>
<p>vector; number of spatial steps for each underlying's domain discretization.
</p>
</dd>
<dt><code>X$fd$leftBound</code></dt><dd>
<p>vector; near spatial boundaries of each underlying's domain.
</p>
</dd>
<dt><code>X$fd$kMult</code></dt><dd>
<p>vector; right boundary strike multiples. If 0, far domain boundary calculated via formula given in Kangro and Nicolaides (2000). Otherwise, far domain boundary calculated as the strike multiplied by the strike multiple.
</p>
</dd>
<dt><code>X$fd$density</code></dt><dd>
<p>vector; impacts the concentration of nodes around the option strike. At 0, nodes are uniformly distributed between the near and far boundaries. Increasing the parameter increases the node concentration around the strike.
</p>
</dd>
<dt><code>X$fd$kShift</code></dt><dd>
<p>case vector; if 0, no mesh shifting, if 1, adjusts the node spacing such that the strike falls exactly between two nodes, if 2, adjusts the node spacing such that the strike falls exactly on a node. See Tavella and Randall (2000).
</p>
</dd>
<dt><code>X$fd$theta</code></dt><dd>
<p>scalar; implicitness parameter of the theta method. Chosen between 0 (fully explicit) and 1 (fully implicit).
</p>
</dd>
<dt><code>X$fd$maxSmooth</code></dt><dd>
<p>integer; number of Rannacher smoothing steps. See Rannacher (1984).
</p>
</dd>
<dt><code>X$fd$tol</code></dt><dd>
<p>scalar; error tolerance in penalty iteration for American exercise.
</p>
</dd>
<dt><code>X$fd$maxIter</code></dt><dd>
<p>integer; maximum number of iterations per penalty loop for American exercise.
</p>
</dd>
<dt><code>X$time$tsType</code></dt><dd>
<p>case; if 0, constant timestep size, if 1, adaptive timestep size. See Forsyth and Vetzal (2002).
</p>
</dd>
<dt><code>X$time$N</code></dt><dd>
<p>integer; number of total timesteps if not using adaptive timesteps.
</p>
</dd>
<dt><code>X$time$dtInit</code></dt><dd>
<p>scalar; inital timestep size for adaptive timesteps.
</p>
</dd>
<dt><code>X$time$dNorm</code></dt><dd>
<p>scalar; target relative change for adaptive timesteps.
</p>
</dd>
<dt><code>X$time$D</code></dt><dd>
<p>scalar; normalizing parameter for adaptive timesteps.
</p>
</dd>
</dl>

<p>The classical order for the state vectors output from the function is illustrated by example. With two underlying assets, option values in each state vector are stored in the order: [11, 21, 31, ... , M1, 12, 22, ... , MN] with M being the total number of nodes used in the first asset spatial discretization and N being the total number of nodes in the second.
</p>


<h3>Value</h3>

<p><code>multiAssetOption</code> returns a list:
</p>
<table role = "presentation">
<tr><td><code>value</code></td>
<td>
<p>matrix of per-unit option values. Each column stores the state of the option value array (collection of option values for all nodes of the spatial mesh) as a vector following the classical order (see <b>Details</b> section). The columns of the matrix are indexed over time, with the first column beginning at option maturity, and subsequent columns moving backward in time.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>list containing the vectors of spatial grid points associated with each underlying. Vector sizes of underlying spatial grid points need not be equal.</p>
</td></tr>
<tr><td><code>dimS</code></td>
<td>
<p>dimension of option value array. This item can be used to reshape the column vectors in <code>value</code> into an appropriately dimensioned array using <code>array( ...  , dim=dimS)</code>.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>vector of times associated with each column of the <code>value</code> item.</p>
</td></tr>
</table>
<p>For each column (time) of the <code>value</code> item, the option value at that time can be calculated as the option's notional amount multiplied by the unit option value interpolated over the <code>S</code> item at the current underlying prices.
</p>


<h3>Author(s)</h3>

<p>Michael Eichenberger and Carlo Rosa
</p>


<h3>References</h3>

<p>Forsyth, P.A., Vetzal, K.R., 2002. Quadratic convergence for valuing American options using a penalty method. <em>SIAM Journal on Scientific Computing</em>, <b>23</b> (6), 2095&ndash;2122.
</p>
<p>Kangro, R., Nicolaides, R., 2000. Far field boundary conditions for Black-Scholes equations. <em>SIAM Journal on Numerical Analysis</em>, <b>38</b> (4), 1357&ndash;1368.
</p>
<p>Rannacher, R., 1984. Finite element solution of diffusion problems with irregular data. <em>Numberische Mathematik</em>, <b>43</b>, 309&ndash;327.
</p>
<p>Tavella, D., Randall, C., 2000. Pricing Financial Instruments: The Finite Difference Method. John Wiley &amp; Sons, Inc., New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># european dual-asset digital option example

# initialize inputs list
X &lt;- list()

# option inputs
X$opt$nAsset &lt;- 2
X$opt$payType &lt;- 0
X$opt$exerType &lt;- 0
X$opt$pcFlag &lt;- c(1, 0)
X$opt$ttm &lt;- 0.5
X$opt$strike &lt;- c(110, 90)
X$opt$rf &lt;- 0.10
X$opt$q &lt;- c(0.05, 0.04)
X$opt$vol &lt;- c(0.20, 0.25)
X$opt$rho &lt;- matrix(c(1, -0.5, -0.5, 1), X$opt$nAsset, X$opt$nAsset)

# finite difference inputs
X$fd$m &lt;- c(20, 20)
X$fd$leftBound &lt;- c(0, 0)
X$fd$kMult &lt;- c(0, 0)
X$fd$density &lt;- c(5, 5)
X$fd$kShift &lt;- c(1, 1)
X$fd$theta &lt;- 0.5
X$fd$maxSmooth &lt;- 2
X$fd$tol &lt;- 1e-7
X$fd$maxIter &lt;- 3

# timestep inputs
X$time$tsType &lt;- 0
X$time$N &lt;- min(X$fd$m) * 4
X$time$dtInit &lt;- 0.1 / 4^log2(min(X$fd$m)/5)
X$time$dNorm &lt;- 5 / 2^log2(min(X$fd$m)/5)
X$time$D &lt;- 0.05

# function check
output &lt;- multiAssetOption(X)
</code></pre>

<hr>
<h2 id='nodeSpacer'>
Non-Uniform Finite Difference Node Spacer
</h2><span id='topic+nodeSpacer'></span>

<h3>Description</h3>

<p><code>nodeSpacer</code> implements the spatial discretization scheme from Hout and Foulon (2010) with arbitrary left and right bounds. The function additionally includes logic for mesh shifting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodeSpacer(K, leftBound, rightBound, nodes, density, kShift)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nodeSpacer_+3A_k">K</code></td>
<td>

<p>scalar; option strike.
</p>
</td></tr>
<tr><td><code id="nodeSpacer_+3A_leftbound">leftBound</code></td>
<td>

<p>scalar; near spatial boundary of the underlying domain.
</p>
</td></tr>
<tr><td><code id="nodeSpacer_+3A_rightbound">rightBound</code></td>
<td>

<p>scalar; far spatial boundary of the underlying domain.
</p>
</td></tr>
<tr><td><code id="nodeSpacer_+3A_nodes">nodes</code></td>
<td>

<p>integer; number of nodes used in the spatial discretization.
</p>
</td></tr>
<tr><td><code id="nodeSpacer_+3A_density">density</code></td>
<td>

<p>scalar; impacts the concentration of nodes around the option strike. At 0, nodes are uniformly distributed between the <code>leftBound</code> and <code>rightBound</code>. Increasing the parameter increases the node concentration around the strike.
</p>
</td></tr>
<tr><td><code id="nodeSpacer_+3A_kshift">kShift</code></td>
<td>

<p>case; if 0, no mesh shifting, if 1, adjusts the node spacing such that the strike falls exactly between two nodes, if 2, adjusts the node spacing such that the strike falls exactly on a node. See Tavella and Randall (2000).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mesh shifting is accomplished by multiplying the vector of gridpoints by a scalar. For multi-asset options, this <code>nodeSpacer</code> is called iteratively to discretize each underlying's spatial domain.
</p>


<h3>Value</h3>

<p><code>nodeSpacer</code> returns a vector of gridpoints used in spatial discretization in the finite difference method. The <code>nodes</code> input determines the length of the output vector.
</p>


<h3>Author(s)</h3>

<p>Michael Eichenberger and Carlo Rosa
</p>


<h3>References</h3>

<p>Hout, K. J., Foulon, S., 2010. ADI finite difference schemes for option pricing in the Heston model with correlation. <em>International Journal of Numerical Analysis and Modeling</em>, <b>7</b> (2), 303&ndash;320.
<a href="http://www.math.ualberta.ca/ijnam/Volume-7-2010/No-2-10/2010-02-06.pdf">http://www.math.ualberta.ca/ijnam/Volume-7-2010/No-2-10/2010-02-06.pdf</a>
</p>
<p>Pooley, D. M., Vetzal, K. R., Forsyth, P. A., 2002. Convergence remedies for non-smooth payoffs in option pricing.
<a href="https://cs.uwaterloo.ca/~paforsyt/report.pdf">https://cs.uwaterloo.ca/~paforsyt/report.pdf</a>
</p>
<p>Tavella, D., Randall, C., 2000. Pricing Financial Instruments: The Finite Difference Method. John Wiley &amp; Sons, Inc., New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample mesh spacing
plot(nodeSpacer(100, 0, 500, 26, 5, 1), rep(0, times=26), main='Non-Uniform Mesh Spacing',
  xlab='Underlying Price (Strike = 100)', ylab='', yaxt='n', type='p', cex=0.5, pch=16)
</code></pre>

<hr>
<h2 id='payoff'>
Multi-Asset Option Payoff Calculator
</h2><span id='topic+payoff'></span>

<h3>Description</h3>

<p><code>payoff</code> calculates the per-unit option payoff for digital, best-of, and worst-of multi-asset options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>payoff(payType, pcFlag, strike, S)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="payoff_+3A_paytype">payType</code></td>
<td>

<p>case; if 0, digital payoff, if 1, best-of payoff, if 2, worst-of payoff.
</p>
</td></tr>
<tr><td><code id="payoff_+3A_pcflag">pcFlag</code></td>
<td>

<p>case vector; if 0, call, if 1, put.
</p>
</td></tr>
<tr><td><code id="payoff_+3A_strike">strike</code></td>
<td>

<p>vector; option strikes.
</p>
</td></tr>
<tr><td><code id="payoff_+3A_s">S</code></td>
<td>

<p>list containing the vectors of spatial grid points associated with each underlying. Vector sizes of underlying spatial grid points need not be equal.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>payoff</code> returns an array of the unit option values at each point spanned by the list of underlying vectors. Dimension of array is inhereted from <code>S</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Eichenberger and Carlo Rosa
</p>


<h3>Examples</h3>

<pre><code class='language-R'># payoff of a dual-asset digital call with strikes at 100 and 90.
S &lt;- list(seq(0, 500, by=1), seq(0, 500, by=1))
payoff(0, c(0, 0), c(100, 90), S)
</code></pre>

<hr>
<h2 id='plotOptionValues'>
Plot Option Values Over Time
</h2><span id='topic+plotOptionValues'></span>

<h3>Description</h3>

<p><code>plotOptionValues</code> plots the solution of the option PDE over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOptionValues(Y, fps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotOptionValues_+3A_y">Y</code></td>
<td>

<p>list containing the items resulting from the <code>multiAssetOption</code> function.
</p>
</td></tr>
<tr><td><code id="plotOptionValues_+3A_fps">fps</code></td>
<td>

<p>integer; number of frames per second of the animation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Animation occurs in backwards time, beginning from the option's expiry date, moving toward time = 0. This function applies only to options written on one or two underlying assets. Higher dimensional options are not plotted.
</p>


<h3>Author(s)</h3>

<p>Michael Eichenberger and Carlo Rosa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiAssetOption">multiAssetOption</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot test

# initialize inputs list
X &lt;- list()

# option inputs
X$opt$nAsset &lt;- 2
X$opt$payType &lt;- 0
X$opt$exerType &lt;- 0
X$opt$pcFlag &lt;- c(0, 0)
X$opt$ttm &lt;- 0.5
X$opt$strike &lt;- c(110, 90)
X$opt$rf &lt;- 0.10
X$opt$q &lt;- c(0.05, 0.04)
X$opt$vol &lt;- c(0.20, 0.25)
X$opt$rho &lt;- matrix(c(1, -0.5, -0.5, 1), X$opt$nAsset, X$opt$nAsset)

# finite difference inputs
X$fd$m &lt;- c(10, 10)
X$fd$leftBound &lt;- c(0, 0)
X$fd$kMult &lt;- c(0, 0)
X$fd$density &lt;- c(5, 5)
X$fd$kShift &lt;- c(1, 1)
X$fd$theta &lt;- 0.5
X$fd$maxSmooth &lt;- 2
X$fd$tol &lt;- 1e-7
X$fd$maxIter &lt;- 3

# timestep inputs
X$time$tsType &lt;- 0
X$time$N &lt;- min(X$fd$m) * 4
X$time$dtInit &lt;- 0.1 / 4^log2(min(X$fd$m)/5)
X$time$dNorm &lt;- 5 / 2^log2(min(X$fd$m)/5)
X$time$D &lt;- 0.05

Y &lt;- multiAssetOption(X)

# function check
plotOptionValues(Y, 40)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
