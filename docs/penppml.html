<!DOCTYPE html><html><head><title>Help for package penppml</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {penppml}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#AtA'><p>Computing A'A</p></a></li>
<li><a href='#bootstrap'><p>Bootstrap Lasso Implementation (in development)</p></a></li>
<li><a href='#cluster_matrix'><p>Cluster-robust Standard Error Estimation</p></a></li>
<li><a href='#collinearity_check'><p>Checking for Perfect Multicollinearity</p></a></li>
<li><a href='#compute_fes'><p>Fixed Effects Computation</p></a></li>
<li><a href='#countries'><p>Country ISO Codes</p></a></li>
<li><a href='#eigenMatMult'><p>Faster Matrix Multiplication</p></a></li>
<li><a href='#fastolsCpp'><p>Faster Least Squares Estimation</p></a></li>
<li><a href='#fastridge'><p>Finding Ridge Regression Solutions</p></a></li>
<li><a href='#fastridgeCpp'><p>Faster Ridge Regression</p></a></li>
<li><a href='#faststddev'><p>Faster Standard Deviation</p></a></li>
<li><a href='#fastwmean'><p>Faster Weighted Mean</p></a></li>
<li><a href='#genfes'><p>Generating a List of Fixed Effects</p></a></li>
<li><a href='#genmodel'><p>Generating Model Structure</p></a></li>
<li><a href='#hdfeppml'><p>PPML Estimation with HDFE</p></a></li>
<li><a href='#hdfeppml_int'><p>PPML Estimation with HDFE</p></a></li>
<li><a href='#iceberg'><p>Iceberg Lasso Implementation (in development)</p></a></li>
<li><a href='#manyouter'><p>Many Outer Products</p></a></li>
<li><a href='#mlfitppml'><p>General Penalized PPML Estimation</p></a></li>
<li><a href='#mlfitppml_int'><p>General Penalized PPML Estimation</p></a></li>
<li><a href='#penhdfeppml'><p>One-Shot Penalized PPML Estimation with HDFE</p></a></li>
<li><a href='#penhdfeppml_cluster'><p>Plugin Lasso Estimation</p></a></li>
<li><a href='#penhdfeppml_cluster_int'><p>Plugin Lasso Estimation</p></a></li>
<li><a href='#penhdfeppml_int'><p>One-Shot Penalized PPML Estimation with HDFE</p></a></li>
<li><a href='#penppml-package'><p>penppml: Penalized Poisson Pseudo Maximum Likelihood Regression</p></a></li>
<li><a href='#plugin_lasso_int'><p>Iceberg Lasso Implementation (in development)</p></a></li>
<li><a href='#select_fes'><p>Filtering fixed effect lists</p></a></li>
<li><a href='#standardize_wt'><p>Weighted Standardization</p></a></li>
<li><a href='#trade'><p>International trade agreements data set</p></a></li>
<li><a href='#xeex'><p>XeeX Matrix Computation</p></a></li>
<li><a href='#xvalidate'><p>Implementing Cross Validation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Penalized Poisson Pseudo Maximum Likelihood Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools that enables efficient estimation of penalized 
    Poisson Pseudo Maximum Likelihood regressions, using lasso or ridge penalties, for models 
    that feature one or more sets of high-dimensional fixed effects. The methodology is based on 
    Breinlich, Corradi, Rocha, Ruta, Santos Silva, and Zylkin (2021) <a href="http://hdl.handle.net/10986/35451">http://hdl.handle.net/10986/35451</a> 
    and takes advantage of the method of alternating projections of Gaure (2013) 
    &lt;<a href="https://doi.org/10.1016%2Fj.csda.2013.03.024">doi:10.1016/j.csda.2013.03.024</a>&gt; for dealing with HDFE, as well as 
    the coordinate descent algorithm of Friedman, Hastie and Tibshirani (2010) 
    &lt;<a href="https://doi.org/10.18637%2Fjss.v033.i01">doi:10.18637/jss.v033.i01</a>&gt; for fitting lasso regressions. The package is also able to carry out 
    cross-validation and to implement the plugin lasso of Belloni, Chernozhukov, Hansen and Kozbur (2016) 
    &lt;<a href="https://doi.org/10.1080%2F07350015.2015.1102733">doi:10.1080/07350015.2015.1102733</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>gzip</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, glmnet, fixest, collapse, rlang, magrittr, matrixStats,
dplyr, devtools</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tomzylkin/penppml">https://github.com/tomzylkin/penppml</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tomzylkin/penppml/issues">https://github.com/tomzylkin/penppml/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), MASS, knitr, rmarkdown, ggplot2,
reshape2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-08 13:32:06 UTC; joaoa</td>
</tr>
<tr>
<td>Author:</td>
<td>Diego Ferreras Garrucho [aut],
  Tom Zylkin [aut],
  Joao Cruz [cre],
  Nicolas Apfel [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joao Cruz &lt;jm01780@surrey.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-08 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='AtA'>Computing A'A</h2><span id='topic+AtA'></span>

<h3>Description</h3>

<p>Computes A'A using C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AtA(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AtA_+3A_a">A</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='bootstrap'>Bootstrap Lasso Implementation (in development)</h2><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p>This function performs standard plugin lasso PPML estimation for <code>bootreps</code> samples drawn again with
replacement and reports
those regressors selected in at least a certain fraction of the bootstrap repetitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(
  data,
  dep,
  indep = NULL,
  cluster_id = NULL,
  fixed = NULL,
  selectobs = NULL,
  bootreps = 250,
  boot_threshold = 0.01,
  colcheck_x = FALSE,
  colcheck_x_fes = FALSE,
  post = FALSE,
  gamma_val = NULL,
  verbose = FALSE,
  tol = 1e-06,
  hdfetol = 0.01,
  penweights = NULL,
  maxiter = 1000,
  phipost = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_data">data</code></td>
<td>
<p>A data frame containing all relevant variables.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_dep">dep</code></td>
<td>
<p>A string with the names of the independent variables or their column numbers.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_indep">indep</code></td>
<td>
<p>A vector with the names or column numbers of the regressors. If left unspecified,
all remaining variables (excluding fixed effects) are included in the regressor matrix.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_cluster_id">cluster_id</code></td>
<td>
<p>A string denoting the cluster-id with which to perform
cluster bootstrap.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_fixed">fixed</code></td>
<td>
<p>A vector with the names or column numbers of factor variables identifying the fixed effects,
or a list with the desired interactions between variables in <code>data</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_selectobs">selectobs</code></td>
<td>
<p>Optional. A vector indicating which observations to use (either a logical vector
or a numeric vector with row numbers, as usual when subsetting in R).</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_bootreps">bootreps</code></td>
<td>
<p>Number of bootstrap repetitions.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_boot_threshold">boot_threshold</code></td>
<td>
<p>Minimal threshold. If a variable is selected in at least this
fraction of times, it is reported at the end of the iterations.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_colcheck_x">colcheck_x</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks collinearity between the independent variables and drops the
collinear variables.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_colcheck_x_fes">colcheck_x_fes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks whether the independent variables are perfectly explained
by the fixed effects drops those that are perfectly explained.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_post">post</code></td>
<td>
<p>Logical. If <code>TRUE</code>, estimates a post-penalty regression with the selected variables.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_gamma_val">gamma_val</code></td>
<td>
<p>Numerical value that determines the regularization threshold as defined in Belloni, Chernozhukov, Hansen, and Kozbur (2016). NULL default sets parameter to 0.1/log(n).</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it prints information to the screen while evaluating.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for convergence of the IRLS algorithm.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_hdfetol">hdfetol</code></td>
<td>
<p>Tolerance parameter for the within-transformation step,
passed on to <code>collapse::fhdwithin</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_penweights">penweights</code></td>
<td>
<p>Optional: a vector of coefficient-specific penalties to use in plugin lasso when
<code>method == "plugin"</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations (a number).</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_phipost">phipost</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plugin coefficient-specific penalty weights are iteratively
calculated using estimates from a post-penalty regression. Otherwise,
these are calculated using estimates from a penalty regression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enables users to implement the &quot;bootstrap&quot; step in the procedure described in
Breinlich, Corradi, Rocha, Ruta, Santos Silva and Zylkin (2020). To do this, Plugin Lasso is run B times.
The function can also perform a post-selection estimation.
</p>


<h3>Value</h3>

<p>A matrix with coefficient estimates for all dependent variables.
</p>


<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: bs1 &lt;- bootstrap(data=trade3, dep="export",
                 cluster_id="clus",
                 fixed=list(c("exp", "time"),
                 c("imp", "time"), c("exp", "imp")),
                 indep=7:22, bootreps=10, colcheck_x = TRUE,
                 colcheck_x_fes = TRUE,
                 boot_threshold = 0.01,
                 post=TRUE, gamma_val=0.01, verbose=FALSE)
## End(Not run)

</code></pre>

<hr>
<h2 id='cluster_matrix'>Cluster-robust Standard Error Estimation</h2><span id='topic+cluster_matrix'></span>

<h3>Description</h3>

<p><code>cluster_matrix</code> is a helper for computation of cluster-robust standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_matrix(e, cluster, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_matrix_+3A_e">e</code></td>
<td>
<p>Vector of residuals.</p>
</td></tr>
<tr><td><code id="cluster_matrix_+3A_cluster">cluster</code></td>
<td>
<p>Vector of clusters.</p>
</td></tr>
<tr><td><code id="cluster_matrix_+3A_x">x</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gives the XeeX matrix.
</p>

<hr>
<h2 id='collinearity_check'>Checking for Perfect Multicollinearity</h2><span id='topic+collinearity_check'></span>

<h3>Description</h3>

<p><code>collinearity_check</code> checks for perfect multicollinearity in a model with high-dimensional
fixed effects. It calls <code>lfe::demeanlist</code> in order to partial out the fixed effects, and then
uses <code>stats::lm.wfit</code> to discard linearly dependent variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collinearity_check(
  y,
  x = NULL,
  fes = NULL,
  hdfetol,
  colcheck_x_fes = TRUE,
  colcheck_x = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collinearity_check_+3A_y">y</code></td>
<td>
<p>Dependent variable (a numeric vector).</p>
</td></tr>
<tr><td><code id="collinearity_check_+3A_x">x</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="collinearity_check_+3A_fes">fes</code></td>
<td>
<p>List of fixed effects.</p>
</td></tr>
<tr><td><code id="collinearity_check_+3A_hdfetol">hdfetol</code></td>
<td>
<p>Tolerance for the centering, passed on to <code>lfe::demeanlist</code>.</p>
</td></tr>
<tr><td><code id="collinearity_check_+3A_colcheck_x_fes">colcheck_x_fes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks whether the independent variables are perfectly explained
by the fixed effects drops those that are perfectly explained.</p>
</td></tr>
<tr><td><code id="collinearity_check_+3A_colcheck_x">colcheck_x</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks collinearity between the independent variables and drops the
collinear variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the variables that pass the collinearity check.
</p>

<hr>
<h2 id='compute_fes'>Fixed Effects Computation</h2><span id='topic+compute_fes'></span>

<h3>Description</h3>

<p>This function is a helper for <code>xvalidate</code> that computes FEs using PPML First Order Conditions
(FOCs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_fes(
  y,
  fes,
  x,
  b,
  insample_obs = rep(1, n),
  onlymus = FALSE,
  tol = 1e-08,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_fes_+3A_y">y</code></td>
<td>
<p>Dependent variable (a vector).</p>
</td></tr>
<tr><td><code id="compute_fes_+3A_fes">fes</code></td>
<td>
<p>List of fixed effects.</p>
</td></tr>
<tr><td><code id="compute_fes_+3A_x">x</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="compute_fes_+3A_b">b</code></td>
<td>
<p>A vector of coefficient estimates.</p>
</td></tr>
<tr><td><code id="compute_fes_+3A_insample_obs">insample_obs</code></td>
<td>
<p>Vector of observations used to estimate the <code>b</code> coefficients..</p>
</td></tr>
<tr><td><code id="compute_fes_+3A_onlymus">onlymus</code></td>
<td>
<p>Logical. If <code>TRUE</code>, returns only the conditional means.</p>
</td></tr>
<tr><td><code id="compute_fes_+3A_tol">tol</code></td>
<td>
<p>A tolerance parameter.</p>
</td></tr>
<tr><td><code id="compute_fes_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints messages to the console while evaluating.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>onlymus = TRUE</code>, the vector of conditional means. Otherwise, a list with two
elements:
</p>

<ul>
<li> <p><code>mu</code>: conditional means.
</p>
</li>
<li> <p><code>fe_values</code>: fixed effects.
</p>
</li></ul>


<hr>
<h2 id='countries'>Country ISO Codes</h2><span id='topic+countries'></span>

<h3>Description</h3>

<p>An auxiliary data set with basic geographic information about country ISO 3166 codes included in the
<code>trade</code> data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countries
</code></pre>


<h3>Format</h3>

<p>A data frame with 249 rows and 4 variables.
</p>

<ul>
<li><p> iso: Country ISO 3166 code.
</p>
</li>
<li><p> name: Country name.
</p>
</li>
<li><p> region: Continent.
</p>
</li>
<li><p> subregion: sub-continental region.
</p>
</li></ul>



<h3>Source</h3>

<p>The source of the data set is Luke Duncalfe's ISO-3166-Countries-with-Regional-Codes repository
on GitHub (<a href="https://github.com/lukes/ISO-3166-Countries-with-Regional-Codes#readme">https://github.com/lukes/ISO-3166-Countries-with-Regional-Codes#readme</a>).
</p>

<hr>
<h2 id='eigenMatMult'>Faster Matrix Multiplication</h2><span id='topic+eigenMatMult'></span><span id='topic+eigenMapMatMult'></span>

<h3>Description</h3>

<p>Faster matrix multiplication using C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenMatMult(A, B)

eigenMapMatMult(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenMatMult_+3A_a">A</code>, <code id="eigenMatMult_+3A_b">B</code></td>
<td>
<p>Matrices.</p>
</td></tr>
</table>

<hr>
<h2 id='fastolsCpp'>Faster Least Squares Estimation</h2><span id='topic+fastolsCpp'></span>

<h3>Description</h3>

<p>Finds Least Squares solutions using C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastolsCpp(X, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastolsCpp_+3A_x">X</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="fastolsCpp_+3A_y">y</code></td>
<td>
<p>Dependent variable (a vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of parameter (beta) estimates.
</p>

<hr>
<h2 id='fastridge'>Finding Ridge Regression Solutions</h2><span id='topic+fastridge'></span>

<h3>Description</h3>

<p>A wrapper around <code>fastridgeCpp</code>, for faster computation of the analytical solution for
ridge regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastridge(x, y, weights = rep(1/n, n), lambda, standardize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastridge_+3A_x">x</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="fastridge_+3A_y">y</code></td>
<td>
<p>Dependent variable (a numeric vector).</p>
</td></tr>
<tr><td><code id="fastridge_+3A_weights">weights</code></td>
<td>
<p>Vector of weights.</p>
</td></tr>
<tr><td><code id="fastridge_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter.</p>
</td></tr>
<tr><td><code id="fastridge_+3A_standardize">standardize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, x is standardized using the <code>weights</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of coefficient (beta) estimates.
</p>

<hr>
<h2 id='fastridgeCpp'>Faster Ridge Regression</h2><span id='topic+fastridgeCpp'></span>

<h3>Description</h3>

<p>Finds Ridge solutions using C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastridgeCpp(X, y, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastridgeCpp_+3A_x">X</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="fastridgeCpp_+3A_y">y</code></td>
<td>
<p>Dependent variable (a vector).</p>
</td></tr>
<tr><td><code id="fastridgeCpp_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter (a number).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of parameter (beta) estimates.
</p>

<hr>
<h2 id='faststddev'>Faster Standard Deviation</h2><span id='topic+faststddev'></span>

<h3>Description</h3>

<p>Computes standard deviation using C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faststddev(X, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faststddev_+3A_x">X</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="faststddev_+3A_w">w</code></td>
<td>
<p>Weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of standard deviations of the parameter estimates.
</p>

<hr>
<h2 id='fastwmean'>Faster Weighted Mean</h2><span id='topic+fastwmean'></span>

<h3>Description</h3>

<p>Computes weighted mean using C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastwmean(X, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastwmean_+3A_x">X</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="fastwmean_+3A_w">w</code></td>
<td>
<p>Weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Weighted mean.
</p>

<hr>
<h2 id='genfes'>Generating a List of Fixed Effects</h2><span id='topic+genfes'></span>

<h3>Description</h3>

<p><code>genfes</code> generates a list of fixed effects by creating interactions of paired factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genfes(data, inter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genfes_+3A_data">data</code></td>
<td>
<p>A data frame including the factors.</p>
</td></tr>
<tr><td><code id="genfes_+3A_inter">inter</code></td>
<td>
<p>A list: each element includes the variables to be interacted (both names and column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the desired interactions of <code>vars</code>, with the same length as <code>inter</code>.
</p>

<hr>
<h2 id='genmodel'>Generating Model Structure</h2><span id='topic+genmodel'></span>

<h3>Description</h3>

<p><code>genmodel</code> transforms a data frame into the needed components for our main functions (a y vector,
a x matrix and a fes list).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genmodel(
  data,
  dep = NULL,
  indep = NULL,
  fixed = NULL,
  cluster = NULL,
  selectobs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genmodel_+3A_data">data</code></td>
<td>
<p>A data frame containing all relevant variables.</p>
</td></tr>
<tr><td><code id="genmodel_+3A_dep">dep</code></td>
<td>
<p>A string with the name of the independent variable or a column number.</p>
</td></tr>
<tr><td><code id="genmodel_+3A_indep">indep</code></td>
<td>
<p>A vector with the names or column numbers of the regressors. If left unspecified,
all remaining variables (excluding fixed effects) are included in the regressor matrix.</p>
</td></tr>
<tr><td><code id="genmodel_+3A_fixed">fixed</code></td>
<td>
<p>A vector with the names or column numbers of factor variables identifying the fixed effects,
or a list with the desired interactions between variables in <code>data</code>.</p>
</td></tr>
<tr><td><code id="genmodel_+3A_cluster">cluster</code></td>
<td>
<p>Optional. A string with the name of the clustering variable or a column number.
It's also possible to input a vector with several variables, in which case the interaction of
all of them is taken as the clustering variable.</p>
</td></tr>
<tr><td><code id="genmodel_+3A_selectobs">selectobs</code></td>
<td>
<p>Optional. A vector indicating which observations to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four elements:
</p>

<ul>
<li> <p><code>y</code>: y vector.
</p>
</li>
<li> <p><code>x</code>: x matrix.
</p>
</li>
<li> <p><code>fes</code>: list of fixed effects.
</p>
</li>
<li> <p><code>cluster</code>: cluster vector.
</p>
</li></ul>


<hr>
<h2 id='hdfeppml'>PPML Estimation with HDFE</h2><span id='topic+hdfeppml'></span>

<h3>Description</h3>

<p><code>hdfeppml</code> fits an (unpenalized) Poisson Pseudo Maximum Likelihood (PPML) model with
high-dimensional fixed effects (HDFE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdfeppml(
  data,
  dep = 1,
  indep = NULL,
  fixed = NULL,
  cluster = NULL,
  selectobs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hdfeppml_+3A_data">data</code></td>
<td>
<p>A data frame containing all relevant variables.</p>
</td></tr>
<tr><td><code id="hdfeppml_+3A_dep">dep</code></td>
<td>
<p>A string with the name of the independent variable or a column number.</p>
</td></tr>
<tr><td><code id="hdfeppml_+3A_indep">indep</code></td>
<td>
<p>A vector with the names or column numbers of the regressors. If left unspecified,
all remaining variables (excluding fixed effects) are included in the regressor matrix.</p>
</td></tr>
<tr><td><code id="hdfeppml_+3A_fixed">fixed</code></td>
<td>
<p>A vector with the names or column numbers of factor variables identifying the fixed effects,
or a list with the desired interactions between variables in <code>data</code>.</p>
</td></tr>
<tr><td><code id="hdfeppml_+3A_cluster">cluster</code></td>
<td>
<p>Optional. A string with the name of the clustering variable or a column number.
It's also possible to input a vector with several variables, in which case the interaction of
all of them is taken as the clustering variable.</p>
</td></tr>
<tr><td><code id="hdfeppml_+3A_selectobs">selectobs</code></td>
<td>
<p>Optional. A vector indicating which observations to use (either a logical vector
or a numeric vector with row numbers, as usual when subsetting in R).</p>
</td></tr>
<tr><td><code id="hdfeppml_+3A_...">...</code></td>
<td>
<p>Further options. For a full list, see <a href="#topic+hdfeppml_int">hdfeppml_int</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a thin wrapper around <a href="#topic+hdfeppml_int">hdfeppml_int</a>, providing a more convenient interface for
data frames. Whereas the internal function requires some preliminary handling of data sets (<code>y</code>
must be a vector, <code>x</code> must be a matrix and fixed effects <code>fes</code> must be provided in a list),
the wrapper takes a full data frame in the <code>data</code> argument, and users can simply specify which
variables correspond to y, x and the fixed effects, using either variable names or column numbers.
</p>
<p>More formally, <code>hdfeppml_int</code> performs iteratively re-weighted least squares (IRLS) on a
transformed model, as described in Correia, Guimarães and Zylkin (2020) and similar to the
<code>ppmlhdfe</code> package in Stata. In each iteration, the function calculates the transformed dependent
variable, partials out the fixed effects (calling <code>collapse:fhdwithin</code>) and then solves a weighted
least squares problem (using fast C++ implementation).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>coefficients</code>: a 1 x <code>ncol(x)</code> matrix with coefficient (beta) estimates.
</p>
</li>
<li> <p><code>residuals</code>: a 1 x <code>length(y)</code> matrix with the residuals of the model.
</p>
</li>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>:
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li>
<li> <p><code>se</code>: standard errors of the coefficients.
</p>
</li></ul>



<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To reduce run time, we keep only countries in the Americas:
americas &lt;- countries$iso[countries$region == "Americas"]
test &lt;- hdfeppml(data = trade[, -(5:6)],
                   dep = "export",
                   fixed = list(c("exp", "time"),
                                c("imp", "time"),
                                c("exp", "imp")),
                   selectobs = (trade$imp %in% americas) &amp; (trade$exp %in% americas))

## End(Not run)

</code></pre>

<hr>
<h2 id='hdfeppml_int'>PPML Estimation with HDFE</h2><span id='topic+hdfeppml_int'></span>

<h3>Description</h3>

<p><code>hdfeppml_int</code> is the internal algorithm called by <code>hdfeppml</code> to fit an (unpenalized)
Poisson Pseudo Maximum Likelihood (PPML) regression with high-dimensional fixed effects (HDFE). It
takes a vector with the dependent variable, a regressor matrix and a set of fixed effects (in list
form: each element in the list should be a separate HDFE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdfeppml_int(
  y,
  x = NULL,
  fes = NULL,
  tol = 1e-08,
  hdfetol = 1e-04,
  mu = NULL,
  saveX = TRUE,
  colcheck = TRUE,
  colcheck_x = colcheck,
  colcheck_x_fes = colcheck,
  init_z = NULL,
  verbose = FALSE,
  maxiter = 1000,
  cluster = NULL,
  vcv = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hdfeppml_int_+3A_y">y</code></td>
<td>
<p>Dependent variable (a vector)</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_x">x</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_fes">fes</code></td>
<td>
<p>List of fixed effects.</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for convergence of the IRLS algorithm.</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_hdfetol">hdfetol</code></td>
<td>
<p>Tolerance parameter for the within-transformation step,
passed on to <code>collapse::fhdwithin</code>.</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_mu">mu</code></td>
<td>
<p>A vector of initial values for mu that can be passed to the command.</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_savex">saveX</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it returns the values of x and z after partialling out the
fixed effects.</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_colcheck">colcheck</code></td>
<td>
<p>Logical. If <code>TRUE</code>, performs both checks in <code>colcheck_x</code> and <code>colcheck_x_fes</code>.
If the user specifies <code>colcheck_x</code> and <code>colcheck_x_fes</code> individually, this option is overwritten.</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_colcheck_x">colcheck_x</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks collinearity between the independent variables and drops the
collinear variables.</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_colcheck_x_fes">colcheck_x_fes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks whether the independent variables are perfectly explained
by the fixed effects drops those that are perfectly explained.</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_init_z">init_z</code></td>
<td>
<p>Optional: initial values of the transformed dependent variable, to be used in the
first iteration of the algorithm.</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it prints information to the screen while evaluating.</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations (a number).</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_cluster">cluster</code></td>
<td>
<p>Optional: a vector classifying observations into clusters (to use when calculating SEs).</p>
</td></tr>
<tr><td><code id="hdfeppml_int_+3A_vcv">vcv</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), it returns standard errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More formally, <code>hdfeppml_int</code> performs iteratively re-weighted least squares (IRLS) on a
transformed model, as described in Correia, Guimarães and Zylkin (2020) and similar to the
<code>ppmlhdfe</code> package in Stata. In each iteration, the function calculates the transformed dependent
variable, partials out the fixed effects (calling <code>collapse::fhdwithin</code>, which uses the algorithm in
Gaure (2013)) and then solves a weighted least squares problem (using fast C++ implementation).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>coefficients</code>: a 1 x <code>ncol(x)</code> matrix with coefficient (beta) estimates.
</p>
</li>
<li> <p><code>residuals</code>: a 1 x <code>length(y)</code> matrix with the residuals of the model.
</p>
</li>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>:
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li>
<li> <p><code>se</code>: standard errors of the coefficients.
</p>
</li></ul>



<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To reduce run time, we keep only countries in the Americas:
americas &lt;- countries$iso[countries$region == "Americas"]
trade &lt;- trade[(trade$imp %in% americas) &amp; (trade$exp %in% americas), ]
# Now generate the needed x, y and fes objects:
y &lt;- trade$export
x &lt;- data.matrix(trade[, -1:-6])
fes &lt;- list(exp_time = interaction(trade$exp, trade$time),
            imp_time = interaction(trade$imp, trade$time),
            pair     = interaction(trade$exp, trade$imp))
# Finally, the call to hdfeppml_int:
reg &lt;- hdfeppml_int(y = y, x = x, fes = fes)

## End(Not run)

</code></pre>

<hr>
<h2 id='iceberg'>Iceberg Lasso Implementation (in development)</h2><span id='topic+iceberg'></span>

<h3>Description</h3>

<p>A function performs standard plugin lasso PPML estimation (without fixed effects) for several
dependent variables in a single step. This is still IN DEVELOPMENT: at the current stage, only
coefficient estimates are are provided and there is no support for clustered errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iceberg(data, dep, indep = NULL, selectobs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iceberg_+3A_data">data</code></td>
<td>
<p>A data frame containing all relevant variables.</p>
</td></tr>
<tr><td><code id="iceberg_+3A_dep">dep</code></td>
<td>
<p>A string with the names of the independent variables or their column numbers.</p>
</td></tr>
<tr><td><code id="iceberg_+3A_indep">indep</code></td>
<td>
<p>A vector with the names or column numbers of the regressors. If left unspecified,
all remaining variables (excluding fixed effects) are included in the regressor matrix.</p>
</td></tr>
<tr><td><code id="iceberg_+3A_selectobs">selectobs</code></td>
<td>
<p>Optional. A vector indicating which observations to use (either a logical vector
or a numeric vector with row numbers, as usual when subsetting in R).</p>
</td></tr>
<tr><td><code id="iceberg_+3A_...">...</code></td>
<td>
<p>Further arguments, including:
</p>

<ul>
<li> <p><code>tol</code>: Tolerance parameter for convergence of the IRLS algorithm.
</p>
</li>
<li> <p><code>glmnettol</code>: Tolerance parameter to be passed on to <code>glmnet::glmnet</code>.
</p>
</li>
<li> <p><code>penweights</code>: Optional: a vector of coefficient-specific penalties to use in plugin lasso.
</p>
</li>
<li> <p><code>colcheck</code>: Logical. If <code>TRUE</code>, checks for perfect multicollinearity in <code>x</code>.
</p>
</li>
<li> <p><code>K</code>: Maximum number of iterations.
</p>
</li>
<li> <p><code>verbose</code>: Logical. If <code>TRUE</code>, prints information to the screen while evaluating.
</p>
</li>
<li> <p><code>lambda</code>: Penalty parameter (a number).
</p>
</li>
<li> <p><code>icepost</code>: Logical. If <code>TRUE</code>, it carries out a post-lasso estimation with just the
selected variables and reports the coefficients from this regression.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions enables users to implement the &quot;iceberg&quot; step in the two-step procedure described in
Breinlich, Corradi, Rocha, Ruta, Santos Silva and Zylkin (2020). To do this after using the plugin
method in <code>mlfitppml</code>, just select all the variables with non-zero coefficients in
<code>dep</code> and the remaining regressors in <code>indep</code>. The function will then perform separate
lasso estimation on each of the selected dependent variables and report the coefficients.
</p>


<h3>Value</h3>

<p>A matrix with coefficient estimates for all dependent variables.
</p>


<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iceberg_results &lt;- iceberg(data = trade[, -(1:6)],
                                    dep = c("ad_prov_14", "cp_prov_23", "tbt_prov_07",
                                            "tbt_prov_33", "tf_prov_41", "tf_prov_45"),
                                    selectobs = (trade$time == "2016"))

</code></pre>

<hr>
<h2 id='manyouter'>Many Outer Products</h2><span id='topic+manyouter'></span>

<h3>Description</h3>

<p>Compute a large number of outer products (useful for clustered SEs) using C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manyouter(A, B, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manyouter_+3A_a">A</code>, <code id="manyouter_+3A_b">B</code></td>
<td>
<p>Numeric vectors.</p>
</td></tr>
<tr><td><code id="manyouter_+3A_c">c</code></td>
<td>
<p>Integer.</p>
</td></tr>
</table>

<hr>
<h2 id='mlfitppml'>General Penalized PPML Estimation</h2><span id='topic+mlfitppml'></span>

<h3>Description</h3>

<p><code>mlfitppml</code> is a general-purpose wrapper function for penalized PPML estimation. This is a
flexible tool that allows users to select:
</p>

<ul>
<li><p> Penalty type: either lasso or ridge.
</p>
</li>
<li><p> Penalty parameter: users can provide a single global value for lambda (a single regression
is estimated), a vector of lambda values (the function estimates the regression using each of them,
sequentially) or even coefficient-specific penalty weights.
</p>
</li>
<li><p> Method: plugin lasso estimates can be obtained directly from this function too.
</p>
</li>
<li><p> Cross-validation: if this option is enabled, the function uses IDs provided by the user
to perform k-fold cross-validation and reports the resulting RMSE for all lambda values.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mlfitppml(
  data,
  dep = 1,
  indep = NULL,
  fixed = NULL,
  cluster = NULL,
  selectobs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlfitppml_+3A_data">data</code></td>
<td>
<p>A data frame containing all relevant variables.</p>
</td></tr>
<tr><td><code id="mlfitppml_+3A_dep">dep</code></td>
<td>
<p>A string with the name of the independent variable or a column number.</p>
</td></tr>
<tr><td><code id="mlfitppml_+3A_indep">indep</code></td>
<td>
<p>A vector with the names or column numbers of the regressors. If left unspecified,
all remaining variables (excluding fixed effects) are included in the regressor matrix.</p>
</td></tr>
<tr><td><code id="mlfitppml_+3A_fixed">fixed</code></td>
<td>
<p>A vector with the names or column numbers of factor variables identifying the fixed effects,
or a list with the desired interactions between variables in <code>data</code>.</p>
</td></tr>
<tr><td><code id="mlfitppml_+3A_cluster">cluster</code></td>
<td>
<p>Optional. A string with the name of the clustering variable or a column number.
It's also possible to input a vector with several variables, in which case the interaction of
all of them is taken as the clustering variable.</p>
</td></tr>
<tr><td><code id="mlfitppml_+3A_selectobs">selectobs</code></td>
<td>
<p>Optional. A vector indicating which observations to use (either a logical vector
or a numeric vector with row numbers, as usual when subsetting in R).</p>
</td></tr>
<tr><td><code id="mlfitppml_+3A_...">...</code></td>
<td>
<p>Further arguments, including:
</p>

<ul>
<li> <p><code>penalty</code>: A string indicating the penalty type. Currently supported: &quot;lasso&quot; and &quot;ridge&quot;.
</p>
</li>
<li> <p><code>method</code>: The user can set this equal to &quot;plugin&quot; to perform the plugin algorithm with
coefficient-specific penalty weights (see details). Otherwise, a single global penalty is used.
</p>
</li>
<li> <p><code>post</code>: Logical. If <code>TRUE</code>, estimates a post-penalty regression with the
selected variables.
</p>
</li>
<li> <p><code>xval</code>: Logical. If <code>TRUE</code>, cross-validation is performed using the IDs provided
in the <code>IDs</code> argument as folds. Note that, by default, observations are assigned
individual IDs, which makes the cross-validation algorithm very time-consuming.
</p>
</li></ul>

<p>For a full list of options, see <a href="#topic+mlfitppml_int">mlfitppml_int</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a thin wrapper around <code>mlfitppml_int</code>, providing a more convenient interface for
data frames. Whereas the internal function requires some preliminary handling of data sets (<code>y</code>
must be a vector, <code>x</code> must be a matrix and <code>fes</code> must be provided in a list), the wrapper
takes a full data frame in the <code>data</code> argument, and users can simply specify which variables
correspond to y, x and the fixed effects, using either variable names or column numbers.
</p>
<p>For technical details on the algorithms used, see <a href="#topic+hdfeppml">hdfeppml</a> (post-lasso regression),
<a href="#topic+penhdfeppml">penhdfeppml</a> (standard penalized regression), <a href="#topic+penhdfeppml_cluster">penhdfeppml_cluster</a> (plugin lasso),
and <a href="#topic+xvalidate">xvalidate</a> (cross-validation).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>beta</code>: if <code>post = FALSE</code>, a <code>length(lambdas)</code> x <code>ncol(x)</code> matrix with
coefficient (beta) estimates from the penalized regressions. If <code>post = TRUE</code>, this is
the matrix of coefficients from the post-penalty regressions.
</p>
</li>
<li> <p><code>beta_pre</code>: if <code>post = TRUE</code>, a <code>length(lambdas)</code> x <code>ncol(x)</code> matrix with
coefficient (beta) estimates from the penalized regressions.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>lambdas</code>: vector of penalty parameters.
</p>
</li>
<li> <p><code>ses</code>: standard errors of the coefficients of the post-penalty regression. Note that
these are only provided when <code>post = TRUE</code>.
</p>
</li>
<li> <p><code>rmse</code>: if <code>xval = TRUE</code>, a matrix with the root mean squared error (RMSE - column 2)
for each value of lambda (column 1), obtained by cross-validation.
</p>
</li>
<li> <p><code>phi</code>: coefficient-specific penalty weights (only if <code>method == "plugin"</code>).
</p>
</li></ul>



<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To reduce run time, we keep only countries in the Americas:
americas &lt;- countries$iso[countries$region == "Americas"]
# Now we can use our main functions on the reduced trade data set:
test &lt;- mlfitppml(data = trade[, -(5:6)],
                    dep = "export",
                    fixed = list(c("exp", "time"),
                                 c("imp", "time"),
                                 c("exp", "imp")),
                    selectobs = (trade$imp %in% americas) &amp; (trade$exp %in% americas),
                    lambdas = c(0.01, 0.001),
                    tol = 1e-6, hdfetol = 1e-2)

## End(Not run)

</code></pre>

<hr>
<h2 id='mlfitppml_int'>General Penalized PPML Estimation</h2><span id='topic+mlfitppml_int'></span>

<h3>Description</h3>

<p><code>mlfitppml_int</code> is the internal wrapper called by <code>mlfitppml</code> for penalized PPML estimation.
This in turn calls <code>penhdfeppml_int</code>, <code>penhdfeppml_cluster_int</code> and <code>hdfeppml_int</code>
as needed. It takes a vector with the dependent variable, a regressor matrix and a set of fixed
effects (in list form: each element in the list should be a separate HDFE). This is a flexible tool
that allows users to select:
</p>

<ul>
<li><p> Penalty type: either lasso or ridge.
</p>
</li>
<li><p> Penalty parameter: users can provide a single global value for lambda (a single regression
is estimated), a vector of lambda values (the function estimates the regression using each of them,
sequentially) or even coefficient-specific penalty weights.
</p>
</li>
<li><p> Method: plugin lasso estimates can be obtained directly from this function too.
</p>
</li>
<li><p> Cross-validation: if this option is enabled, the function uses IDs provided by the user
to perform k-fold cross-validation and reports the resulting RMSE for all lambda values.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mlfitppml_int(
  y,
  x,
  fes,
  lambdas,
  penalty = "lasso",
  tol = 1e-08,
  hdfetol = 1e-04,
  colcheck = TRUE,
  colcheck_x = colcheck,
  colcheck_x_fes = colcheck,
  post = TRUE,
  cluster = NULL,
  method = "bic",
  IDs = 1:n,
  verbose = FALSE,
  xval = FALSE,
  standardize = TRUE,
  vcv = TRUE,
  phipost = TRUE,
  penweights = NULL,
  K = 15,
  gamma_val = NULL,
  mu = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlfitppml_int_+3A_y">y</code></td>
<td>
<p>Dependent variable (a vector)</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_x">x</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_fes">fes</code></td>
<td>
<p>List of fixed effects.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_lambdas">lambdas</code></td>
<td>
<p>Vector of penalty parameters.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_penalty">penalty</code></td>
<td>
<p>A string indicating the penalty type. Currently supported: &quot;lasso&quot; and &quot;ridge&quot;.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for convergence of the IRLS algorithm.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_hdfetol">hdfetol</code></td>
<td>
<p>Tolerance parameter for the within-transformation step,
passed on to <code>collapse::fhdwithin</code>.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_colcheck">colcheck</code></td>
<td>
<p>Logical. If <code>TRUE</code>, performs both checks in <code>colcheck_x</code> and <code>colcheck_x_fes</code>.
If the user specifies <code>colcheck_x</code> and <code>colcheck_x_fes</code> individually, this option is overwritten.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_colcheck_x">colcheck_x</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks collinearity between the independent variables and drops the
collinear variables.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_colcheck_x_fes">colcheck_x_fes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks whether the independent variables are perfectly explained
by the fixed effects drops those that are perfectly explained.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_post">post</code></td>
<td>
<p>Logical. If <code>TRUE</code>, estimates a post-penalty regression with the selected variables.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_cluster">cluster</code></td>
<td>
<p>Optional: a vector classifying observations into clusters (to use when calculating SEs).</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_method">method</code></td>
<td>
<p>The user can set this equal to &quot;plugin&quot; to perform the plugin algorithm with
coefficient-specific penalty weights (see details). Otherwise, a single global penalty is used.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_ids">IDs</code></td>
<td>
<p>A vector of fold IDs for k-fold cross validation. If left unspecified, each observation
is assigned to a different fold (warning: this is likely to be very resource-intensive).</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it prints information to the screen while evaluating.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_xval">xval</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it carries out cross-validation.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_standardize">standardize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, x variables are standardized before estimation.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_vcv">vcv</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), the post-estimation model includes standard errors.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_phipost">phipost</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plugin coefficient-specific penalty weights are iteratively
calculated using estimates from a post-penalty regression when <code>method == "plugin"</code>. Otherwise,
these are calculated using estimates from a penalty regression.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_penweights">penweights</code></td>
<td>
<p>Optional: a vector of coefficient-specific penalties to use in plugin lasso when
<code>method == "plugin"</code>.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_k">K</code></td>
<td>
<p>Maximum number of iterations for the plugin algorithm to converge.</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_gamma_val">gamma_val</code></td>
<td>
<p>Numerical value that determines the regularization threshold as defined in Belloni, Chernozhukov, Hansen, and Kozbur (2016). NULL default sets parameter to 0.1/log(n).</p>
</td></tr>
<tr><td><code id="mlfitppml_int_+3A_mu">mu</code></td>
<td>
<p>A vector of initial values for mu that can be passed to the command.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For technical details on the algorithms used, see <a href="#topic+hdfeppml_int">hdfeppml_int</a> (post-lasso regression),
<a href="#topic+penhdfeppml_int">penhdfeppml_int</a> (standard penalized regression), <a href="#topic+penhdfeppml_cluster_int">penhdfeppml_cluster_int</a> (plugin lasso),
and <a href="#topic+xvalidate">xvalidate</a> (cross-validation).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>beta</code>: if <code>post = FALSE</code>, a <code>length(lambdas)</code> x <code>ncol(x)</code> matrix with
coefficient (beta) estimates from the penalized regressions. If <code>post = TRUE</code>, this is
the matrix of coefficients from the post-penalty regressions.
</p>
</li>
<li> <p><code>beta_pre</code>: if <code>post = TRUE</code>, a <code>length(lambdas)</code> x <code>ncol(x)</code> matrix with
coefficient (beta) estimates from the penalized regressions.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>lambdas</code>: vector of penalty parameters.
</p>
</li>
<li> <p><code>ses</code>: standard errors of the coefficients of the post-penalty regression. Note that
these are only provided when <code>post = TRUE</code>.
</p>
</li>
<li> <p><code>rmse</code>: if <code>xval = TRUE</code>, a matrix with the root mean squared error (RMSE - column 2)
for each value of lambda (column 1), obtained by cross-validation.
</p>
</li>
<li> <p><code>phi</code>: coefficient-specific penalty weights (only if <code>method == "plugin"</code>).
</p>
</li></ul>



<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# First, we need to transform the data (this is what mlfitppml handles internally). Start by
# filtering the data set to keep only countries in the Americas:
americas &lt;- countries$iso[countries$region == "Americas"]
trade &lt;- trade[(trade$imp %in% americas) &amp; (trade$exp %in% americas), ]
# Now generate the needed x, y and fes objects:
y &lt;- trade$export
x &lt;- data.matrix(trade[, -1:-6])
fes &lt;- list(exp_time = interaction(trade$exp, trade$time),
            imp_time = interaction(trade$imp, trade$time),
            pair     = interaction(trade$exp, trade$imp))
# Finally, we try mlfitppml_int with a lasso penalty (the default) and two lambda values:
reg &lt;- mlfitppml_int(y = y, x = x, fes = fes, lambdas = c(0.1, 0.01))

# We can also try plugin lasso:
\donttest{reg &lt;- mlfitppml_int(y = y, x = x, fes = fes, cluster = fes$pair, method = "plugin")}

# For an example with cross-validation, please see the vignette.

## End(Not run)

</code></pre>

<hr>
<h2 id='penhdfeppml'>One-Shot Penalized PPML Estimation with HDFE</h2><span id='topic+penhdfeppml'></span>

<h3>Description</h3>

<p><code>penhdfeppml</code> fits a penalized PPML regression for a given type of penalty and a given
value of the penalty parameter.  The penalty can be either lasso or ridge, and the plugin method
can be enabled via the <code>method</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penhdfeppml(
  data,
  dep = 1,
  indep = NULL,
  fixed = NULL,
  cluster = NULL,
  selectobs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penhdfeppml_+3A_data">data</code></td>
<td>
<p>A data frame containing all relevant variables.</p>
</td></tr>
<tr><td><code id="penhdfeppml_+3A_dep">dep</code></td>
<td>
<p>A string with the name of the independent variable or a column number.</p>
</td></tr>
<tr><td><code id="penhdfeppml_+3A_indep">indep</code></td>
<td>
<p>A vector with the names or column numbers of the regressors. If left unspecified,
all remaining variables (excluding fixed effects) are included in the regressor matrix.</p>
</td></tr>
<tr><td><code id="penhdfeppml_+3A_fixed">fixed</code></td>
<td>
<p>A vector with the names or column numbers of factor variables identifying the fixed effects,
or a list with the desired interactions between variables in <code>data</code>.</p>
</td></tr>
<tr><td><code id="penhdfeppml_+3A_cluster">cluster</code></td>
<td>
<p>Optional. A string with the name of the clustering variable or a column number.
It's also possible to input a vector with several variables, in which case the interaction of
all of them is taken as the clustering variable.</p>
</td></tr>
<tr><td><code id="penhdfeppml_+3A_selectobs">selectobs</code></td>
<td>
<p>Optional. A vector indicating which observations to use (either a logical vector
or a numeric vector with row numbers, as usual when subsetting in R).</p>
</td></tr>
<tr><td><code id="penhdfeppml_+3A_...">...</code></td>
<td>
<p>Further options, including:
</p>

<ul>
<li> <p><code>penalty</code>: A string indicating the penalty type. Currently supported: &quot;lasso&quot; and &quot;ridge&quot;.
</p>
</li>
<li> <p><code>method</code>: The user can set this equal to &quot;plugin&quot; to perform the plugin algorithm with
coefficient-specific penalty weights (see details). Otherwise, a single global penalty is used.
</p>
</li></ul>

<p>For a full list of options, see <a href="#topic+penhdfeppml_int">penhdfeppml_int</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a thin wrapper around <a href="#topic+penhdfeppml_int">penhdfeppml_int</a>, providing a more convenient interface
for data frames. Whereas the internal function requires some preliminary handling of data sets (<code>y</code>
must be a vector, <code>x</code> must be a matrix and <code>fes</code> must be provided in a list), the wrapper
takes a full data frame in the <code>data</code> argument, and users can simply specify which variables
correspond to y, x and the fixed effects, using either variable names or column numbers.
</p>
<p>More formally, <code>penhdfeppml_int</code> performs iteratively re-weighted least squares (IRLS) on a
transformed model, as described in Breinlich, Corradi, Rocha, Ruta, Santos Silva and Zylkin (2021).
In each iteration, the function calculates the transformed dependent variable, partials out the fixed
effects (calling <code>lfe::fhdwithin</code>) and then and then calls <code>glmnet::glmnet</code> if the selected
penalty is lasso (the default). If the user has selected ridge, the analytical solution is instead
computed directly using fast C++ implementation.
</p>
<p>For information on how the plugin lasso method works, see <a href="#topic+penhdfeppml_cluster">penhdfeppml_cluster</a>.
</p>


<h3>Value</h3>

<p>If <code>method == "lasso"</code> (the default), an object of class <code>elnet</code> with the elements
described in <a href="glmnet.html#topic+glmnet">glmnet</a>, as well as:
</p>

<ul>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>phi</code>: coefficient-specific penalty weights (only if <code>method == "plugin"</code>.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li></ul>

<p>If <code>method == "ridge"</code>, a list with the following elements:
</p>

<ul>
<li> <p><code>beta</code>: a 1 x <code>ncol(x)</code> matrix with coefficient (beta) estimates.
</p>
</li>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li></ul>



<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To reduce run time, we keep only countries in the Americas:
americas &lt;- countries$iso[countries$region == "Americas"]
test &lt;- penhdfeppml(data = trade[, -(5:6)],
                      dep = "export",
                      fixed = list(c("exp", "time"),
                                   c("imp", "time"),
                                   c("exp", "imp")),
                      lambda = 0.05,
                      selectobs = (trade$imp %in% americas) &amp; (trade$exp %in% americas))

## End(Not run)

</code></pre>

<hr>
<h2 id='penhdfeppml_cluster'>Plugin Lasso Estimation</h2><span id='topic+penhdfeppml_cluster'></span>

<h3>Description</h3>

<p>Performs plugin lasso - PPML estimation with HDFE. This is an internal function, called by
<code>mlfitppml</code> and <code>penhdfeppml</code> when users select the <code>method = "plugin"</code>
option, but it's made available as a stand-alone option for advanced users who may prefer to avoid
some overhead imposed by the wrappers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penhdfeppml_cluster(
  data,
  dep = 1,
  indep = NULL,
  fixed = NULL,
  cluster = NULL,
  selectobs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penhdfeppml_cluster_+3A_data">data</code></td>
<td>
<p>A data frame containing all relevant variables.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_+3A_dep">dep</code></td>
<td>
<p>A string with the name of the independent variable or a column number.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_+3A_indep">indep</code></td>
<td>
<p>A vector with the names or column numbers of the regressors. If left unspecified,
all remaining variables (excluding fixed effects) are included in the regressor matrix.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_+3A_fixed">fixed</code></td>
<td>
<p>A vector with the names or column numbers of factor variables identifying the fixed effects,
or a list with the desired interactions between variables in <code>data</code>.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_+3A_cluster">cluster</code></td>
<td>
<p>A string with the name of the clustering variable or a column number.
It's also possible to input a vector with several variables, in which case the interaction of
all of them is taken as the clustering variable. Note that this is NOT OPTIONAL in this case:
our plugin algorithm requires clusters to be specified.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_+3A_selectobs">selectobs</code></td>
<td>
<p>Optional. A vector indicating which observations to use (either a logical vector
or a numeric vector with row numbers, as usual when subsetting in R).</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_+3A_...">...</code></td>
<td>
<p>Further options. For a full list of options, see <a href="#topic+penhdfeppml_cluster_int">penhdfeppml_cluster_int</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a thin wrapper around <code>penppml_cluster_int</code>, providing a more convenient interface
for data frames. Whereas the internal function requires some preliminary handling of data sets (<code>y</code>
must be a vector, <code>x</code> must be a matrix and <code>fes</code> must be provided in a list), the wrapper
takes a full data frame in the <code>data</code> argument, and users can simply specify which variables
correspond to y, x and the fixed effects, using either variable names or column numbers.
</p>
<p>The plugin method uses coefficient-specific penalty weights that account for heteroskedasticity. The
penalty parameters are calculated automatically by the function using statistical theory - for a
brief discussion of this, see Breinlich, Corradi, Rocha, Ruta, Santos Silva and Zylkin (2021), and
for a more in-depth analysis, check Belloni, Chernozhukov, Hansen, and Kozbur (2016), which introduced
the specific implementation used in this package. Heuristically, the penalty parameters are set at
a level high enough so that the absolute value of the score for each regressor must be statistically
large relative to its standard error in order for the regressors to be selected.
</p>


<h3>Value</h3>

<p>An object of class <code>elnet</code> with the elements described in <a href="glmnet.html#topic+glmnet">glmnet</a>, as
well as the following:
</p>

<ul>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>phi</code>: coefficient-specific penalty weights.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li></ul>



<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To reduce run time, we keep only countries in the Americas:
americas &lt;- countries$iso[countries$region == "Americas"]
test &lt;- penhdfeppml_cluster(data = trade[, -(5:6)],
                              dep = "export",
                              fixed = list(c("exp", "time"),
                                           c("imp", "time"),
                                           c("exp", "imp")),
                              cluster = c("exp", "imp"),
                              selectobs = (trade$imp %in% americas) &amp; (trade$exp %in% americas),
                              tol = 1e-5, hdfetol = 1e-1)

## End(Not run)

</code></pre>

<hr>
<h2 id='penhdfeppml_cluster_int'>Plugin Lasso Estimation</h2><span id='topic+penhdfeppml_cluster_int'></span>

<h3>Description</h3>

<p>Performs plugin lasso - PPML estimation with HDFE. This is an internal function, called by <code>mlfitppml_int</code> and
<code>penhdfeppml_int</code> when users select the <code>method = "plugin"</code> option, but it's made available
as a stand-alone option for advanced users who may prefer to avoid some overhead imposed by the
wrappers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penhdfeppml_cluster_int(
  y,
  x,
  fes,
  cluster,
  tol = 1e-08,
  hdfetol = 1e-04,
  glmnettol = 1e-12,
  penalty = "lasso",
  penweights = NULL,
  saveX = TRUE,
  mu = NULL,
  colcheck = TRUE,
  colcheck_x = colcheck,
  colcheck_x_fes = colcheck,
  K = 15,
  init_z = NULL,
  post = FALSE,
  verbose = FALSE,
  lambda = NULL,
  phipost = TRUE,
  gamma_val = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penhdfeppml_cluster_int_+3A_y">y</code></td>
<td>
<p>Dependent variable (a vector)</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_x">x</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_fes">fes</code></td>
<td>
<p>List of fixed effects.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_cluster">cluster</code></td>
<td>
<p>Optional: a vector classifying observations into clusters (to use when calculating SEs).</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for convergence of the IRLS algorithm.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_hdfetol">hdfetol</code></td>
<td>
<p>Tolerance parameter for the within-transformation step,
passed on to <code>collapse::fhdwithin</code>.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_glmnettol">glmnettol</code></td>
<td>
<p>Tolerance parameter to be passed on to <code>glmnet</code>.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_penalty">penalty</code></td>
<td>
<p>Only &quot;lasso&quot; is supported at the present stage.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_penweights">penweights</code></td>
<td>
<p>Optional: a vector of coefficient-specific penalties to use in plugin lasso when
<code>method == "plugin"</code>.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_savex">saveX</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it returns the values of x and z after partialling out the
fixed effects.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_mu">mu</code></td>
<td>
<p>A vector of initial values for mu that can be passed to the command.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_colcheck">colcheck</code></td>
<td>
<p>Logical. If <code>TRUE</code>, performs both checks in <code>colcheck_x</code> and <code>colcheck_x_fes</code>.
If the user specifies <code>colcheck_x</code> and <code>colcheck_x_fes</code> individually, this option is overwritten.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_colcheck_x">colcheck_x</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks collinearity between the independent variables and drops the
collinear variables.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_colcheck_x_fes">colcheck_x_fes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks whether the independent variables are perfectly explained
by the fixed effects drops those that are perfectly explained.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_k">K</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_init_z">init_z</code></td>
<td>
<p>Optional: initial values of the transformed dependent variable, to be used in the
first iteration of the algorithm.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_post">post</code></td>
<td>
<p>Logical. If <code>TRUE</code>, estimates a post-penalty regression with the selected variables.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it prints information to the screen while evaluating.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter (a number).</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_phipost">phipost</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plugin coefficient-specific penalty weights are iteratively
calculated using estimates from a post-penalty regression. Otherwise, these are calculated using
estimates from a penalty regression.</p>
</td></tr>
<tr><td><code id="penhdfeppml_cluster_int_+3A_gamma_val">gamma_val</code></td>
<td>
<p>Numerical value that determines the regularization threshold as defined in Belloni, Chernozhukov, Hansen, and Kozbur (2016). NULL default sets parameter to 0.1/log(n).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plugin method uses coefficient-specific penalty weights that account for heteroskedasticity. The
penalty parameters are calculated automatically by the function using statistical theory - for a
brief discussion of this, see Breinlich, Corradi, Rocha, Ruta, Santos Silva and Zylkin (2021), and
for a more in-depth analysis, check Belloni, Chernozhukov, Hansen, and Kozbur (2016), which introduced
the specific implementation used in this package. Heuristically, the penalty parameters are set at
a level high enough so that the absolute value of the score for each regressor must be statistically
large relative to its standard error in order for the regressors to be selected.
</p>


<h3>Value</h3>

<p>An object of class <code>elnet</code> with the elements described in <a href="glmnet.html#topic+glmnet">glmnet</a>, as
well as the following:
</p>

<ul>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>phi</code>: coefficient-specific penalty weights.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li></ul>



<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To reduce run time, we keep only countries in Latin America and the Caribbean:
LatAmericaCar &lt;- countries$iso[countries$sub.region == "Latin America and the Caribbean"]
trade &lt;- trade[(trade$imp %in% LatAmericaCar) &amp; (trade$exp %in% LatAmericaCar), ]
# Now generate the needed x, y and fes objects:
y &lt;- trade$export
x &lt;- data.matrix(trade[, -1:-6])
fes &lt;- list(exp_time = interaction(trade$exp, trade$time),
            imp_time = interaction(trade$imp, trade$time),
            pair     = interaction(trade$exp, trade$imp))
# Finally, we try penhdfeppml_cluster_int:
reg &lt;- penhdfeppml_cluster_int(y = y, x = x, fes = fes, cluster = fes$pair)

## End(Not run)

</code></pre>

<hr>
<h2 id='penhdfeppml_int'>One-Shot Penalized PPML Estimation with HDFE</h2><span id='topic+penhdfeppml_int'></span>

<h3>Description</h3>

<p><code>penhdfeppml_int</code> is the internal algorithm called by <code>penhdfeppml</code> to fit a penalized PPML
regression for a given type of penalty and a given value of the penalty parameter. It takes a vector
with the dependent variable, a regressor matrix and a set of fixed effects (in list form: each element
in the list should be a separate HDFE). The penalty can be either lasso or ridge, and the plugin
method can be enabled via the <code>method</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penhdfeppml_int(
  y,
  x,
  fes,
  lambda,
  tol = 1e-08,
  hdfetol = 1e-04,
  glmnettol = 1e-12,
  penalty = "lasso",
  penweights = NULL,
  saveX = TRUE,
  mu = NULL,
  colcheck = TRUE,
  colcheck_x = colcheck,
  colcheck_x_fes = colcheck,
  init_z = NULL,
  post = FALSE,
  verbose = FALSE,
  phipost = TRUE,
  standardize = TRUE,
  method = "placeholder",
  cluster = NULL,
  debug = FALSE,
  gamma_val = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penhdfeppml_int_+3A_y">y</code></td>
<td>
<p>Dependent variable (a vector)</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_x">x</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_fes">fes</code></td>
<td>
<p>List of fixed effects.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter (a number).</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for convergence of the IRLS algorithm.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_hdfetol">hdfetol</code></td>
<td>
<p>Tolerance parameter for the within-transformation step,
passed on to <code>collapse::fhdwithin</code>.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_glmnettol">glmnettol</code></td>
<td>
<p>Tolerance parameter to be passed on to <code>glmnet</code>.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_penalty">penalty</code></td>
<td>
<p>A string indicating the penalty type. Currently supported: &quot;lasso&quot; and &quot;ridge&quot;.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_penweights">penweights</code></td>
<td>
<p>Optional: a vector of coefficient-specific penalties to use in plugin lasso when
<code>method == "plugin"</code>.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_savex">saveX</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it returns the values of x and z after partialling out the
fixed effects.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_mu">mu</code></td>
<td>
<p>A vector of initial values for mu that can be passed to the command.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_colcheck">colcheck</code></td>
<td>
<p>Logical. If <code>TRUE</code>, performs both checks in <code>colcheck_x</code> and <code>colcheck_x_fes</code>.
If the user specifies <code>colcheck_x</code> and <code>colcheck_x_fes</code> individually, this option is overwritten.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_colcheck_x">colcheck_x</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks collinearity between the independent variables and drops the
collinear variables.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_colcheck_x_fes">colcheck_x_fes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks whether the independent variables are perfectly explained
by the fixed effects drops those that are perfectly explained.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_init_z">init_z</code></td>
<td>
<p>Optional: initial values of the transformed dependent variable, to be used in the
first iteration of the algorithm.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_post">post</code></td>
<td>
<p>Logical. If <code>TRUE</code>, estimates a post-penalty regression with the selected variables.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it prints information to the screen while evaluating.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_phipost">phipost</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plugin coefficient-specific penalty weights are iteratively
calculated using estimates from a post-penalty regression when <code>method == "plugin"</code>. Otherwise,
these are calculated using estimates from a penalty regression.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_standardize">standardize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, x variables are standardized before estimation.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_method">method</code></td>
<td>
<p>The user can set this equal to &quot;plugin&quot; to perform the plugin algorithm with
coefficient-specific penalty weights (see details). Otherwise, a single global penalty is used.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_cluster">cluster</code></td>
<td>
<p>Optional: a vector classifying observations into clusters (to use when calculating SEs).</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_debug">debug</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this helps with debugging penalty weights by printing output
of the first iteration to the console and stopping the estimation algorithm.</p>
</td></tr>
<tr><td><code id="penhdfeppml_int_+3A_gamma_val">gamma_val</code></td>
<td>
<p>Numerical value that determines the regularization threshold as defined in Belloni, Chernozhukov, Hansen, and Kozbur (2016). NULL default sets parameter to 0.1/log(n).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More formally, <code>penhdfeppml_int</code> performs iteratively re-weighted least squares (IRLS) on a
transformed model, as described in Breinlich, Corradi, Rocha, Ruta, Santos Silva and Zylkin (2020).
In each iteration, the function calculates the transformed dependent variable, partials out the fixed
effects (calling <code>collapse::fhdwithin</code>) and then and then calls <code>glmnet</code> if the selected
penalty is lasso (the default). If the user selects ridge, the analytical solution is instead
computed directly using fast C++ implementation.
</p>
<p>For information on the plugin lasso method, see <a href="#topic+penhdfeppml_cluster_int">penhdfeppml_cluster_int</a>.
</p>


<h3>Value</h3>

<p>If <code>method == "lasso"</code> (the default), an object of class <code>elnet</code> with the elements
described in <a href="glmnet.html#topic+glmnet">glmnet</a>, as well as:
</p>

<ul>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>phi</code>: coefficient-specific penalty weights (only if <code>method == "plugin"</code>.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li></ul>

<p>If <code>method == "ridge"</code>, a list with the following elements:
</p>

<ul>
<li> <p><code>beta</code>: a 1 x <code>ncol(x)</code> matrix with coefficient (beta) estimates.
</p>
</li>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li></ul>



<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To reduce run time, we keep only countries in the Americas:
americas &lt;- countries$iso[countries$region == "Americas"]
trade &lt;- trade[(trade$imp %in% americas) &amp; (trade$exp %in% americas), ]
# Now generate the needed x, y and fes objects:
y &lt;- trade$export
x &lt;- data.matrix(trade[, -1:-6])
fes &lt;- list(exp_time = interaction(trade$exp, trade$time),
            imp_time = interaction(trade$imp, trade$time),
            pair     = interaction(trade$exp, trade$imp))
# Finally, we try penhdfeppml_int with a lasso penalty (the default):
reg &lt;- penhdfeppml_int(y = y, x = x, fes = fes, lambda = 0.1)

# We can also try ridge:
\donttest{reg &lt;- penhdfeppml_int(y = y, x = x, fes = fes, lambda = 0.1, penalty = "ridge")}

## End(Not run)

</code></pre>

<hr>
<h2 id='penppml-package'>penppml: Penalized Poisson Pseudo Maximum Likelihood Regression</h2><span id='topic+penppml'></span><span id='topic+penppml-package'></span>

<h3>Description</h3>

<p>A set of tools that enables efficient estimation of penalized Poisson Pseudo Maximum Likelihood regressions, using lasso or ridge penalties, for models that feature one or more sets of high-dimensional fixed effects. The methodology is based on Breinlich, Corradi, Rocha, Ruta, Santos Silva, and Zylkin (2021) <a href="http://hdl.handle.net/10986/35451">http://hdl.handle.net/10986/35451</a> and takes advantage of the method of alternating projections of Gaure (2013) <a href="https://doi.org/10.1016/j.csda.2013.03.024">doi:10.1016/j.csda.2013.03.024</a> for dealing with HDFE, as well as the coordinate descent algorithm of Friedman, Hastie and Tibshirani (2010) <a href="https://doi.org/10.18637/jss.v033.i01">doi:10.18637/jss.v033.i01</a> for fitting lasso regressions. The package is also able to carry out cross-validation and to implement the plugin lasso of Belloni, Chernozhukov, Hansen and Kozbur (2016) <a href="https://doi.org/10.1080/07350015.2015.1102733">doi:10.1080/07350015.2015.1102733</a>.
</p>


<h3>Functions</h3>

<p>The workhorse of this package is the <code>mlfitppml</code> function, which allows users to carry out
penalized HDFE-PPML estimation with a wide variety of options. The syntax is very simple, allowing
users to select a data frame with all the relevant variables and then select dependent, independent
and fixed effects variables by name or column number.
</p>
<p>In addition, the internals <code>hdfeppml</code> (post-lasso regression), <code>penhdfeppml</code> (penalized
regression for a single lambda), <code>penhdfeppml_cluster</code> (plugin lasso), and <code>xvalidate</code> (cross-
validation) are made available on a stand-alone basis for advanced users.
</p>
<p>The package also includes alternative versions of <code>mlfitppml</code>, <code>hdfeppml</code>, <code>penhdfeppml</code>
and <code>penhdfeppml_cluster</code>. These (<code>mlfitppml_int</code>, <code>hdfeppml_int</code>, <code>penhdfeppml_int</code>
and <code>penhdfeppml_cluster_int</code>) use an alternative syntax: users must provide the dependent variable
in a vector, the regressors in a matrix and the fixed effects in a list.
</p>
<p>Finally, support for the iceberg lasso method in Breinlich, Corradi, Rocha, Ruta, Santos Silva,
and Zylkin (2021) is in development and can be accessed at its current stage via the <code>iceberg</code>
function.
</p>


<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joao Cruz <a href="mailto:jm01780@surrey.ac.uk">jm01780@surrey.ac.uk</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Diego Ferreras Garrucho <a href="mailto:d.ferreras-garrucho@lse.ac.uk">d.ferreras-garrucho@lse.ac.uk</a>
</p>
</li>
<li><p> Tom Zylkin <a href="mailto:tzylkin@richmond.edu">tzylkin@richmond.edu</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Nicolas Apfel <a href="mailto:n.apfel@soton.ac.uk">n.apfel@soton.ac.uk</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tomzylkin/penppml">https://github.com/tomzylkin/penppml</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tomzylkin/penppml/issues">https://github.com/tomzylkin/penppml/issues</a>
</p>
</li></ul>


<hr>
<h2 id='plugin_lasso_int'>Iceberg Lasso Implementation (in development)</h2><span id='topic+plugin_lasso_int'></span>

<h3>Description</h3>

<p>This is the internal function upon which the <code>iceberg</code> wrapper is built. It performs standard
plugin lasso PPML estimation without fixed effects, relying on <code>glmnet::glmnet</code>. As the other
internals in the package, it needs a y vector and an x matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plugin_lasso_int(
  y,
  x,
  tol = 1e-08,
  glmnettol = 1e-12,
  penweights = NULL,
  colcheck = FALSE,
  K = 50,
  verbose = FALSE,
  lambda = NULL,
  icepost = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plugin_lasso_int_+3A_y">y</code></td>
<td>
<p>Dependent variable (a vector).</p>
</td></tr>
<tr><td><code id="plugin_lasso_int_+3A_x">x</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="plugin_lasso_int_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for convergence of the IRLS algorithm.</p>
</td></tr>
<tr><td><code id="plugin_lasso_int_+3A_glmnettol">glmnettol</code></td>
<td>
<p>Tolerance parameter to be passed on to <code>glmnet::glmnet</code>.</p>
</td></tr>
<tr><td><code id="plugin_lasso_int_+3A_penweights">penweights</code></td>
<td>
<p>Optional: a vector of coefficient-specific penalties to use in plugin lasso.</p>
</td></tr>
<tr><td><code id="plugin_lasso_int_+3A_colcheck">colcheck</code></td>
<td>
<p>Logical. If <code>TRUE</code>, checks for perfect multicollinearity in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plugin_lasso_int_+3A_k">K</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="plugin_lasso_int_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints information to the screen while evaluating.</p>
</td></tr>
<tr><td><code id="plugin_lasso_int_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter (a number).</p>
</td></tr>
<tr><td><code id="plugin_lasso_int_+3A_icepost">icepost</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it carries out a post-lasso estimation with just the
selected variables and reports the coefficients from this regression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 14 elements, including <code>beta</code>, which is the only one we use in the wrapper.
For a full list, see <a href="glmnet.html#topic+glmnet">glmnet</a>.
</p>

<hr>
<h2 id='select_fes'>Filtering fixed effect lists</h2><span id='topic+select_fes'></span>

<h3>Description</h3>

<p>A helper function for <code>xvalidate</code> that filters a list of fixed effects and returns the modified
list. Used to split the fixed effects for cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_fes(fe_list, select_obs, list = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_fes_+3A_fe_list">fe_list</code></td>
<td>
<p>A list of fixed effects.</p>
</td></tr>
<tr><td><code id="select_fes_+3A_select_obs">select_obs</code></td>
<td>
<p>A vector of selected observations / rows.</p>
</td></tr>
<tr><td><code id="select_fes_+3A_list">list</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it returns a list. Otherwise, a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified list of fixed effects.
</p>

<hr>
<h2 id='standardize_wt'>Weighted Standardization</h2><span id='topic+standardize_wt'></span>

<h3>Description</h3>

<p>Performs weighted standardization of x variables. Used in <code>fastridge</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_wt(x, weights = rep(1/n, n), intercept = TRUE, return.sd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_wt_+3A_x">x</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="standardize_wt_+3A_weights">weights</code></td>
<td>
<p>Weights.</p>
</td></tr>
<tr><td><code id="standardize_wt_+3A_intercept">intercept</code></td>
<td>
<p>Logical. If <code>TRUE</code>, adds an intercept.</p>
</td></tr>
<tr><td><code id="standardize_wt_+3A_return.sd">return.sd</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it returns standard errors for the means.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return.sd == FALSE</code>, it gives the matrix of standardized regressors. If
<code>return.sd == TRUE</code>, then it returns the vector of standard errors of the means of the
variables.
</p>

<hr>
<h2 id='trade'>International trade agreements data set</h2><span id='topic+trade'></span>

<h3>Description</h3>

<p>A panel data set containing bilateral trade flows between 210 exporters and 262 importers between
1964 and 2016. The data set also contains information about trade agreements in force between
country pairs, as well as 16 dummies for specific provisions in those agreements (a small selection
from a broader data set).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trade
</code></pre>


<h3>Format</h3>

<p>A data frame with 194,092 rows and 22 variables:
</p>

<dl>
<dt>exp</dt><dd><p>Exporter country (ISO 3166 code)</p>
</dd>
<dt>imp</dt><dd><p>Importer country (ISO 3166 code).</p>
</dd>
<dt>time</dt><dd><p>Year.</p>
</dd>
<dt>export</dt><dd><p>Merchandise trade exports in USD.</p>
</dd>
<dt>id</dt><dd><p>Agreement ID code.</p>
</dd>
<dt>agreement</dt><dd><p>Agreement name.</p>
</dd>
<dt>ad_prov_14</dt><dd><p>Anti-dumping actions allowed and with specific provisions for material injury.</p>
</dd>
<dt>cp_prov_23</dt><dd><p>Does the agreement contain provisions that promote transparency?</p>
</dd>
<dt>tbt_prov_07</dt><dd><p>Technical Regulations - Is the use of international standards promoted?</p>
</dd>
<dt>tbt_prov_33</dt><dd><p>Does the agreement go beyond the TBT (Technical Barriers to Trade) Agreement?</p>
</dd>
<dt>tf_prov_41</dt><dd><p>Harmonization and common legal framework</p>
</dd>
<dt>tf_prov_45</dt><dd><p>Issuance of proof of origin</p>
</dd>
<dt>ser_prov_47</dt><dd><p>Does the agreement contain a standstill provision?</p>
</dd>
<dt>inv_prov_22</dt><dd><p>Does the agreement grant Fair and Equitable Treatment (FET)?</p>
</dd>
<dt>et_prov_38</dt><dd><p>Prohibits export-related performance requirements, subject to exemptions.</p>
</dd>
<dt>ipr_prov_44</dt><dd><p>Stipulates that GIs can be registered and protected through a TM system</p>
</dd>
<dt>env_prov_18</dt><dd><p>Does the agreement require states to control ozone-depleting substances?</p>
</dd>
<dt>ipr_prov_15</dt><dd><p>Incorporates/reaffirms all multilateral agreements to which both parties are a
party (general obligation)</p>
</dd>
<dt>moc_prov_21</dt><dd><p>Does the transfer provision explicitly exclude “good faith and non-discriminatory
application of its laws” related to bankruptcy, insolvency or creditor rights protection?</p>
</dd>
<dt>ste_prov_30</dt><dd><p>Does the agreement regulate subsidization to state enterprises?</p>
</dd>
<dt>lm_prov_10</dt><dd><p>Does the agreement include reference to internationally recognized labor standards?</p>
</dd>
<dt>cp_prov_26</dt><dd><p>Does the agreement regulate consumer protection?</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data on international trade flows was obtained from Comtrade.
Provision data comes from:
Mattoo, A., N. Rocha, M. Ruta (2020). Handbook of deep trade agreements. Washington, DC: World Bank.
</p>

<hr>
<h2 id='xeex'>XeeX Matrix Computation</h2><span id='topic+xeex'></span>

<h3>Description</h3>

<p>Given matrix ee' and matrix X, compute X(k)'ee'X(k) for each regressor X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xeex(X, e, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xeex_+3A_x">X</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="xeex_+3A_e">e</code></td>
<td>
<p>Residuals.</p>
</td></tr>
<tr><td><code id="xeex_+3A_s">S</code></td>
<td>
<p>Cluster sizes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix product X(k)'ee'X(k).
</p>

<hr>
<h2 id='xvalidate'>Implementing Cross Validation</h2><span id='topic+xvalidate'></span>

<h3>Description</h3>

<p>This is the internal function called by <code>mlfitppml_int</code> to perform cross-validation, if the
option is enabled. It is available also on a stand-alone basis in case it is needed, but generally
users will be better served by using the wrapper <code>mlfitppml</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xvalidate(
  y,
  x,
  fes,
  IDs,
  testID = NULL,
  tol = 1e-08,
  hdfetol = 1e-04,
  colcheck_x = TRUE,
  colcheck_x_fes = TRUE,
  init_mu = NULL,
  init_x = NULL,
  init_z = NULL,
  verbose = FALSE,
  cluster = NULL,
  penalty = "lasso",
  method = "placeholder",
  standardize = TRUE,
  penweights = rep(1, ncol(x_reg)),
  lambda = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xvalidate_+3A_y">y</code></td>
<td>
<p>Dependent variable (a vector)</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_x">x</code></td>
<td>
<p>Regressor matrix.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_fes">fes</code></td>
<td>
<p>List of fixed effects.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_ids">IDs</code></td>
<td>
<p>A vector of fold IDs for k-fold cross validation. If left unspecified, each observation
is assigned to a different fold (warning: this is likely to be very resource-intensive).</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_testid">testID</code></td>
<td>
<p>Optional. A number indicating which ID to hold out during cross-validation. If left
unspecified, the function cycles through all IDs and reports the average RMSE.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_tol">tol</code></td>
<td>
<p>Tolerance parameter for convergence of the IRLS algorithm.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_hdfetol">hdfetol</code></td>
<td>
<p>Tolerance parameter for the within-transformation step,
passed on to <code>collapse::fhdwithin</code>.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_colcheck_x">colcheck_x</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks collinearity between the independent variables and drops the
collinear variables.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_colcheck_x_fes">colcheck_x_fes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks whether the independent variables are perfectly explained
by the fixed effects drops those that are perfectly explained.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_init_mu">init_mu</code></td>
<td>
<p>Optional: initial values of the conditional mean <code class="reqn">\mu</code>, to be used as weights in the
first iteration of the algorithm.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_init_x">init_x</code></td>
<td>
<p>Optional: initial values of the independent variables.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_init_z">init_z</code></td>
<td>
<p>Optional: initial values of the transformed dependent variable, to be used in the
first iteration of the algorithm.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it prints information to the screen while evaluating.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_cluster">cluster</code></td>
<td>
<p>Optional: a vector classifying observations into clusters (to use when calculating SEs).</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_penalty">penalty</code></td>
<td>
<p>A string indicating the penalty type. Currently supported: &quot;lasso&quot; and &quot;ridge&quot;.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_method">method</code></td>
<td>
<p>The user can set this equal to &quot;plugin&quot; to perform the plugin algorithm with
coefficient-specific penalty weights (see details). Otherwise, a single global penalty is used.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_standardize">standardize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, x variables are standardized before estimation.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_penweights">penweights</code></td>
<td>
<p>Optional: a vector of coefficient-specific penalties to use in plugin lasso when
<code>method == "plugin"</code>.</p>
</td></tr>
<tr><td><code id="xvalidate_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter, to be passed on to penhdfeppml_int or penhdfeppml_cluster_int.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xvalidate</code> carries out cross-validation with the user-provided IDs by holding out each one of
them, sequentially, as in the k-fold procedure (unless <code>testID</code> is specified, in which case
it just uses this ID for validation). After filtering out the holdout sample, the function simply
calls <a href="#topic+penhdfeppml_int">penhdfeppml_int</a> and <a href="#topic+penhdfeppml_cluster_int">penhdfeppml_cluster_int</a> to estimate the coefficients, it
predicts the conditional means for the held-out observations and finally it calculates the root mean
squared error (RMSE).
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>

<ul>
<li> <p><code>rmse</code>: root mean squared error (RMSE).
</p>
</li>
<li> <p><code>mu</code>: conditional means.
</p>
</li></ul>



<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
&quot;Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements&quot;,
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). &quot;Fast Poisson estimation with high dimensional
fixed effects&quot;, <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). &quot;OLS with multiple high dimensional category variables&quot;,
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). &quot;Regularization paths for generalized linear
models via coordinate descent&quot;, <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). &quot;Inference in high dimensional panel
models with an application to gun control&quot;, <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, we need to transform the data. Start by filtering the data set to keep only countries in
# the Americas:
americas &lt;- countries$iso[countries$region == "Americas"]
trade &lt;- trade[(trade$imp %in% americas) &amp; (trade$exp %in% americas), ]
# Now generate the needed x, y and fes objects:
y &lt;- trade$export
x &lt;- data.matrix(trade[, -1:-6])
fes &lt;- list(exp_time = interaction(trade$exp, trade$time),
            imp_time = interaction(trade$imp, trade$time),
            pair     = interaction(trade$exp, trade$imp))
# We also need to create the IDs. We split the data set by agreement, not observation:
id &lt;- unique(trade[, 5])
nfolds &lt;- 10
unique_ids &lt;- data.frame(id = id, fold = sample(1:nfolds, size = length(id), replace = TRUE))
cross_ids &lt;- merge(trade[, 5, drop = FALSE], unique_ids, by = "id", all.x = TRUE)
# Finally, we try xvalidate with a lasso penalty (the default) and two lambda values:
## Not run: reg &lt;- xvalidate(y = y, x = x, fes = fes, lambda = 0.001,
                         IDs = cross_ids$fold, verbose = TRUE)
## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
