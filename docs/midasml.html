<!DOCTYPE html><html lang="en"><head><title>Help for package midasml</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {midasml}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#midasml-package'><p>midasml</p></a></li>
<li><a href='#alfred_vintages'><p>ALFRED monthly and quarterly series vintages</p></a></li>
<li><a href='#cv.panel.sglfit'><p>Cross-validation fit for panel sg-LASSO</p></a></li>
<li><a href='#cv.panel.sglpath'><p>Sorts cross-validation output for panel data regressions</p></a></li>
<li><a href='#cv.sglfit'><p>Cross-validation fit for sg-LASSO</p></a></li>
<li><a href='#cv.sglpath'><p>Sorts cross-validation output</p></a></li>
<li><a href='#data_freq'><p>Identify data frequency</p></a></li>
<li><a href='#date_vec'><p>Transform date vector to numeric matrix</p></a></li>
<li><a href='#dateMatch'><p>Match dates</p></a></li>
<li><a href='#diff_time_mf'><p>Computes the difference between two dates.</p></a></li>
<li><a href='#gb'><p>Gegenbauer polynomials shifted to [a,b]</p></a></li>
<li><a href='#ic.panel.sglfit'><p>Information criteria fit for panel sg-LASSO</p></a></li>
<li><a href='#ic.pen'><p>Compute the penalty based on chosen information criteria</p></a></li>
<li><a href='#ic.sglfit'><p>Information criteria fit for sg-LASSO</p></a></li>
<li><a href='#lag_num'><p>Compute the number of lags</p></a></li>
<li><a href='#lb'><p>Legendre polynomials shifted to [a,b]</p></a></li>
<li><a href='#market_ret'><p>SNP500 returns</p></a></li>
<li><a href='#midas.ardl'><p>MIDAS regression</p></a></li>
<li><a href='#mixed_freq_data'><p>MIDAS data structure</p></a></li>
<li><a href='#mixed_freq_data_single'><p>MIDAS data structure</p></a></li>
<li><a href='#mode_midasml'><p>Compute mode of a vector</p></a></li>
<li><a href='#monthBegin'><p>Beginning of the month date</p></a></li>
<li><a href='#monthEnd'><p>End of the month date</p></a></li>
<li><a href='#predict.cv.panel.sglfit'><p>Computes prediction</p></a></li>
<li><a href='#predict.cv.sglfit'><p>Computes prediction</p></a></li>
<li><a href='#predict.ic.panel.sglfit'><p>Computes prediction</p></a></li>
<li><a href='#predict.ic.sglfit'><p>Computes prediction</p></a></li>
<li><a href='#predict.sglpath'><p>Computes prediction</p></a></li>
<li><a href='#reg.panel.sgl'><p>Regression fit for panel sg-LASSO</p></a></li>
<li><a href='#reg.sgl'><p>Fit for sg-LASSO regression</p></a></li>
<li><a href='#rgdp_dates'><p>Real GDP release dates</p></a></li>
<li><a href='#rgdp_vintages'><p>Real GDP vintages</p></a></li>
<li><a href='#sglfit'><p>Fits sg-LASSO regression</p></a></li>
<li><a href='#thetafit'><p>Nodewise LASSO regressions to fit the precision matrix &Theta;</p></a></li>
<li><a href='#tscv.sglfit'><p>Time series cross-validation fit for sg-LASSO</p></a></li>
<li><a href='#tscv.sglpath'><p>Sorts time series cross-validation output</p></a></li>
<li><a href='#us_rgdp'><p>US real GDP data with several high-frequency predictors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation and Prediction Methods for High-Dimensional Mixed
Frequency Time Series Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'midasml' package implements estimation and prediction methods for high-dimensional mixed-frequency (MIDAS) time-series and panel data regression models. The regularized MIDAS models are estimated using orthogonal (e.g. Legendre) polynomials and sparse-group LASSO (sg-LASSO) estimator. For more information on the 'midasml' approach see Babii, Ghysels, and Striaukas (2021, JBES forthcoming) &lt;<a href="https://doi.org/10.1080%2F07350015.2021.1899933">doi:10.1080/07350015.2021.1899933</a>&gt;. The package is equipped with the fast implementation of the sg-LASSO estimator by means of proximal block coordinate descent. High-dimensional mixed frequency time-series data can also be easily manipulated with functions provided in the package.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jstriaukas/midasml/issues">https://github.com/jstriaukas/midasml/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doRNG, doParallel, foreach, graphics, randtoolbox, snow,
methods, lubridate, stats</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-28 23:16:47 UTC; Utilisateur</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonas Striaukas [cre, aut],
  Andrii Babii [aut],
  Eric Ghysels [aut],
  Alex Kostrov [ctb] (Contributions to analytical gradients for
    non-linear low-dimensional MIDAS estimation code)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-29 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='midasml-package'>midasml</h2><span id='topic+midasml-package'></span><span id='topic+midasml'></span>

<h3>Description</h3>

<p>Estimation and Prediction Methods for High-Dimensional Mixed Frequency Time Series Data
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas (maintainer) <a href="mailto:jonas.striaukas@gmail.com">jonas.striaukas@gmail.com</a>, Andrii Babii <a href="mailto:andrii@email.unc.edu">andrii@email.unc.edu</a>, Eric Ghysels <a href="mailto:eghysels@unc.edu">eghysels@unc.edu</a>
</p>

<hr>
<h2 id='alfred_vintages'>ALFRED monthly and quarterly series vintages</h2><span id='topic+alfred_vintages'></span>

<h3>Description</h3>

<p>ALFRED monthly and quarterly series vintages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(alfred_vintages)
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> objects
</p>


<h3>Source</h3>

<p><a href="https://alfred.stlouisfed.org/">ALFRED</a> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(alfred_vintages)
i &lt;- 1
alfred_vintages[[i]] # ith variable

</code></pre>

<hr>
<h2 id='cv.panel.sglfit'>Cross-validation fit for panel sg-LASSO</h2><span id='topic+cv.panel.sglfit'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for panel data sg-LASSO regression model.
</p>
<p>The function runs <a href="#topic+sglfit">sglfit</a> <code>nfolds+1</code> times; the first to get the path solution in &lambda; sequence, the rest to compute the fit with each of the folds omitted. 
The average error and standard deviation over the folds is computed, and the optimal regression coefficients are returned for <code>lam.min</code> and <code>lam.1se</code>. Solutions are computed for a fixed &gamma;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.panel.sglfit(x, y, lambda = NULL, gamma = 1.0, gindex = 1:p, nfolds = 10, 
  foldid, method = c("pooled", "fe"), nf = NULL, parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.panel.sglfit_+3A_x">x</code></td>
<td>
<p>NT by p data matrix, where NT and p respectively denote the sample size of pooled data and the number of regressors.</p>
</td></tr>
<tr><td><code id="cv.panel.sglfit_+3A_y">y</code></td>
<td>
<p>NT by 1 response variable.</p>
</td></tr>
<tr><td><code id="cv.panel.sglfit_+3A_lambda">lambda</code></td>
<td>
<p>a user-supplied lambda sequence. By leaving this option unspecified (recommended), users can have the program compute its own &lambda; sequence based on <code>nlambda</code> and &gamma; <code>lambda.factor.</code> It is better to supply, if necessary, a decreasing sequence of lambda values than a single (small) value, as warm-starts are used in the optimization algorithm. The program will ensure that the user-supplied <code>lambda</code> sequence is sorted in decreasing order before fitting the model.</p>
</td></tr>
<tr><td><code id="cv.panel.sglfit_+3A_gamma">gamma</code></td>
<td>
<p>sg-LASSO mixing parameter. &gamma; = 1 gives LASSO solution and &gamma; = 0 gives group LASSO solution.</p>
</td></tr>
<tr><td><code id="cv.panel.sglfit_+3A_gindex">gindex</code></td>
<td>
<p>p by 1 vector indicating group membership of each covariate.</p>
</td></tr>
<tr><td><code id="cv.panel.sglfit_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds of the cv loop. Default set to <code>10</code>.</p>
</td></tr>
<tr><td><code id="cv.panel.sglfit_+3A_foldid">foldid</code></td>
<td>
<p>the fold assignments used.</p>
</td></tr>
<tr><td><code id="cv.panel.sglfit_+3A_method">method</code></td>
<td>
<p>choose between 'pooled' and 'fe'; 'pooled' forces the intercept to be fitted in <a href="#topic+sglfit">sglfit</a>, 'fe' computes the fixed effects. User must input the number of fixed effects <code>nf</code> for <code>method = 'fe'</code>, and it is recommended to do so for <code>method = 'pooled'</code>. Program uses supplied <code>nf</code> to construct <code>foldsid</code>. Default is set to <code>method = 'pooled'</code>.</p>
</td></tr>
<tr><td><code id="cv.panel.sglfit_+3A_nf">nf</code></td>
<td>
<p>number of fixed effects. Used only if <code>method = 'fe'</code>.</p>
</td></tr>
<tr><td><code id="cv.panel.sglfit_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, use parallel foreach to fit each fold. Must register parallel before hand, such as doMC or others. See the example below.</p>
</td></tr>
<tr><td><code id="cv.panel.sglfit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <a href="#topic+sglfit">sglfit</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

The cross-validation is run for sg-LASSO linear model. The sequence of linear regression models implied by &lambda; vector is fit by block coordinate-descent. The objective function is (case <code>method='pooled'</code>) <br><br> ||y - &iota;&alpha; - x&beta;||<sup>2</sup><sub>NT</sub> + 2&lambda;  &Omega;<sub>&gamma;</sub>(&beta;), <br> where &iota;&#8712;R<sup>NT</sup> and &alpha; is common intercept to all N items or (case <code>method='fe'</code>) <br><br> ||y - B&alpha; - x&beta;||<sup>2</sup><sub>NT</sub> + 2&lambda;  &Omega;<sub>&gamma;</sub>(&beta;), <br> where B = I<sub>N</sub>&#8855;&iota; and ||u||<sup>2</sup><sub>NT</sub>=&#60;u,u&#62;/NT is the empirical inner product. The penalty function &Omega;<sub>&gamma;</sub>(.) is applied on  &beta; coefficients and is <br> <br> &Omega;<sub>&gamma;</sub>(&beta;) = &gamma; |&beta;|<sub>1</sub> + (1-&gamma;)|&beta;|<sub>2,1</sub>, <br> a convex combination of LASSO and group LASSO penalty functions.


<h3>Value</h3>

<p>cv.panel.sglfit object.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100 * 20), 100, 20)
beta = c(5,4,3,2,1,rep(0, times = 15))
y = x%*%beta + rnorm(100)
gindex = sort(rep(1:4,times=5))
cv.panel.sglfit(x = x, y = y, gindex = gindex, gamma = 0.5, method = "fe", nf = 10, 
  standardize = FALSE, intercept = FALSE)
## Not run:  
# Parallel
require(doMC)
registerDoMC(cores = 2)
x = matrix(rnorm(1000 * 20), 1000, 20)
beta = c(5,4,3,2,1,rep(0, times = 15))
y = x%*%beta + rnorm(1000)
gindex = sort(rep(1:4,times=5))
system.time(cv.panel.sglfit(x = x, y = y, gindex = gindex, gamma = 0.5, method = "fe", nf = 10, 
  standardize = FALSE, intercept = FALSE))
system.time(cv.panel.sglfit(x = x, y = y, gindex = gindex, gamma = 0.5, method = "fe", nf = 10, 
  standardize = FALSE, intercept = FALSE, parallel = TRUE))

## End(Not run)  
</code></pre>

<hr>
<h2 id='cv.panel.sglpath'>Sorts cross-validation output for panel data regressions</h2><span id='topic+cv.panel.sglpath'></span>

<h3>Description</h3>

<p>Computes <code>cvm</code> and <code>cvsd</code> based on cross-validation fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.panel.sglpath(outlist, lambda, x, y, foldid, method, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.panel.sglpath_+3A_outlist">outlist</code></td>
<td>
<p>list of cross-validation fits.</p>
</td></tr>
<tr><td><code id="cv.panel.sglpath_+3A_lambda">lambda</code></td>
<td>
<p>a sequence of <code class="reqn">\lambda</code> parameter.</p>
</td></tr>
<tr><td><code id="cv.panel.sglpath_+3A_x">x</code></td>
<td>
<p>regressors</p>
</td></tr>
<tr><td><code id="cv.panel.sglpath_+3A_y">y</code></td>
<td>
<p>response</p>
</td></tr>
<tr><td><code id="cv.panel.sglpath_+3A_foldid">foldid</code></td>
<td>
<p>the fold assignment</p>
</td></tr>
<tr><td><code id="cv.panel.sglpath_+3A_method">method</code></td>
<td>
<p>'pooled' or 'fe'.</p>
</td></tr>
<tr><td><code id="cv.panel.sglpath_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>predict.sgl</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cvm</code> and <code>cvsd</code>.
</p>

<hr>
<h2 id='cv.sglfit'>Cross-validation fit for sg-LASSO</h2><span id='topic+cv.sglfit'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for sg-LASSO regression model.
</p>
<p>The function runs <a href="#topic+sglfit">sglfit</a> <code>nfolds+1</code> times; the first to get the path solution in &lambda; sequence, the rest to compute the fit with each of the folds omitted. 
The average error and standard deviation over the folds is computed, and the optimal regression coefficients are returned for <code>lam.min</code> and <code>lam.1se</code>. Solutions are computed for a fixed &gamma;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.sglfit(x, y, lambda = NULL, gamma = 1.0, gindex = 1:p, 
  nfolds = 10, foldid, parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.sglfit_+3A_x">x</code></td>
<td>
<p>T by p data matrix, where T and p respectively denote the sample size and the number of regressors.</p>
</td></tr>
<tr><td><code id="cv.sglfit_+3A_y">y</code></td>
<td>
<p>T by 1 response variable.</p>
</td></tr>
<tr><td><code id="cv.sglfit_+3A_lambda">lambda</code></td>
<td>
<p>a user-supplied lambda sequence. By leaving this option unspecified (recommended), users can have the program compute its own &lambda; sequence based on <code>nlambda</code> and &gamma; <code>lambda.factor.</code> It is better to supply, if necessary, a decreasing sequence of lambda values than a single (small) value, as warm-starts are used in the optimization algorithm. The program will ensure that the user-supplied <code>lambda</code> sequence is sorted in decreasing order before fitting the model.</p>
</td></tr>
<tr><td><code id="cv.sglfit_+3A_gamma">gamma</code></td>
<td>
<p>sg-LASSO mixing parameter. &gamma; = 1 gives LASSO solution and &gamma; = 0 gives group LASSO solution.</p>
</td></tr>
<tr><td><code id="cv.sglfit_+3A_gindex">gindex</code></td>
<td>
<p>p by 1 vector indicating group membership of each covariate.</p>
</td></tr>
<tr><td><code id="cv.sglfit_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds of the cv loop. Default set to <code>10</code>.</p>
</td></tr>
<tr><td><code id="cv.sglfit_+3A_foldid">foldid</code></td>
<td>
<p>the fold assignments used.</p>
</td></tr>
<tr><td><code id="cv.sglfit_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, use parallel foreach to fit each fold. Must register parallel before hand, such as doMC or others. See the example below.</p>
</td></tr>
<tr><td><code id="cv.sglfit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <a href="#topic+sglfit">sglfit</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

The cross-validation is run for sg-LASSO linear model. The sequence of linear regression models implied by &lambda; vector is fit by block coordinate-descent. The objective function is  <br><br> ||y - &iota;&alpha; - x&beta;||<sup>2</sup><sub>T</sub> + 2&lambda;  &Omega;<sub>&gamma;</sub>(&beta;), <br> where &iota;&#8712;R<sup>T</sup>enter> and ||u||<sup>2</sup><sub>T</sub>=&#60;u,u&#62;/T is the empirical inner product. The penalty function &Omega;<sub>&gamma;</sub>(.) is applied on  &beta; coefficients and is <br><br> &Omega;<sub>&gamma;</sub>(&beta;) = &gamma; |&beta;|<sub>1</sub> + (1-&gamma;)|&beta;|<sub>2,1</sub>, <br> a convex combination of LASSO and group LASSO penalty functions.


<h3>Value</h3>

<p>cv.sglfit object.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100 * 20), 100, 20)
beta = c(5,4,3,2,1,rep(0, times = 15))
y = x%*%beta + rnorm(100)
gindex = sort(rep(1:4,times=5))
cv.sglfit(x = x, y = y, gindex = gindex, gamma = 0.5, 
  standardize = FALSE, intercept = FALSE)
## Not run:  
# Parallel
require(doMC)
registerDoMC(cores = 2)
x = matrix(rnorm(1000 * 20), 1000, 20)
beta = c(5,4,3,2,1,rep(0, times = 15))
y = x%*%beta + rnorm(1000)
gindex = sort(rep(1:4,times=5))
system.time(cv.sglfit(x = x, y = y, gindex = gindex, gamma = 0.5, 
  standardize = FALSE, intercept = FALSE))
system.time(cv.sglfit(x = x, y = y, gindex = gindex, gamma = 0.5, 
  standardize = FALSE, intercept = FALSE, parallel = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='cv.sglpath'>Sorts cross-validation output</h2><span id='topic+cv.sglpath'></span>

<h3>Description</h3>

<p>Computes <code>cvm</code> and <code>cvsd</code> based on cross-validation fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.sglpath(outlist, lambda, x, y, foldid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.sglpath_+3A_outlist">outlist</code></td>
<td>
<p>list of cross-validation fits.</p>
</td></tr>
<tr><td><code id="cv.sglpath_+3A_lambda">lambda</code></td>
<td>
<p>a sequence of <code class="reqn">\lambda</code> parameter.</p>
</td></tr>
<tr><td><code id="cv.sglpath_+3A_x">x</code></td>
<td>
<p>regressors</p>
</td></tr>
<tr><td><code id="cv.sglpath_+3A_y">y</code></td>
<td>
<p>response</p>
</td></tr>
<tr><td><code id="cv.sglpath_+3A_foldid">foldid</code></td>
<td>
<p>the fold assignment.</p>
</td></tr>
<tr><td><code id="cv.sglpath_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>predict.sgl</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cvm</code> and <code>cvsd</code>.
</p>

<hr>
<h2 id='data_freq'>Identify data frequency</h2><span id='topic+data_freq'></span>

<h3>Description</h3>

<p>Identify data frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_freq(DateVec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_freq_+3A_datevec">DateVec</code></td>
<td>
<p>n by 6 vector format dates: [year,month,day,hour,min,sec]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of arguments that define data frequency. 'period' - length of two consecutive dates. 'unit' - unit of length measure (=1 year;=2 month;=3 day;=4 hour;=5 minutes;=6 seconds)
</p>

<hr>
<h2 id='date_vec'>Transform date vector to numeric matrix</h2><span id='topic+date_vec'></span>

<h3>Description</h3>

<p>Transform date vector to numeric matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_vec(s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_vec_+3A_s">s</code></td>
<td>
<p>date vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix of date vector.
</p>

<hr>
<h2 id='dateMatch'>Match dates</h2><span id='topic+dateMatch'></span>

<h3>Description</h3>

<p>Change the date to the beginning of the month date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dateMatch(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dateMatch_+3A_x">x</code></td>
<td>
<p>date vector to match with y date vector.</p>
</td></tr>
<tr><td><code id="dateMatch_+3A_y">y</code></td>
<td>
<p>date vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>changed date vector.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(as.Date("2020-01-01"),as.Date("2020-12-01"), by = "day")
set.seed(100)
x &lt;- x[-sample(1:336, 100)]
y &lt;- seq(as.Date("2020-01-01"),as.Date("2020-12-01"), by = "month")
dateMatch(x,y)
</code></pre>

<hr>
<h2 id='diff_time_mf'>Computes the difference between two dates.</h2><span id='topic+diff_time_mf'></span>

<h3>Description</h3>

<p>Computes the difference between two dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_time_mf(
  time1,
  time2,
  origin,
  units = c("auto", "secs", "mins", "hours", "days", "weeks")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_time_mf_+3A_time1">time1</code></td>
<td>
<p>date 1.</p>
</td></tr>
<tr><td><code id="diff_time_mf_+3A_time2">time2</code></td>
<td>
<p>date 2.</p>
</td></tr>
<tr><td><code id="diff_time_mf_+3A_origin">origin</code></td>
<td>
<p>date origin.</p>
</td></tr>
<tr><td><code id="diff_time_mf_+3A_units">units</code></td>
<td>
<p>units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of difference in two dates.
</p>

<hr>
<h2 id='gb'>Gegenbauer polynomials shifted to [a,b]</h2><span id='topic+gb'></span>

<h3>Description</h3>

<p>For a given set of points in X, computes the orthonormal Gegenbauer polynomials basis of L2 [a,b] for a given degree and <code class="reqn">\alpha</code> parameter. The Gegenbauer polynomials are a special case of more general Jacobi polynomials. In turn, you may get Legendre polynomials from Gegenbauer by setting <code class="reqn">\alpha</code> = 0, or Chebychev's polynomials 
by setting <code class="reqn">\alpha</code> = 1/2 or -1/2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gb(degree, alpha, a = 0, b = 1, jmax = NULL, X = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gb_+3A_degree">degree</code></td>
<td>
<p>polynomial degree.</p>
</td></tr>
<tr><td><code id="gb_+3A_alpha">alpha</code></td>
<td>
<p>Gegenbauer polynomials parameter.</p>
</td></tr>
<tr><td><code id="gb_+3A_a">a</code></td>
<td>
<p>lower shift value (default - 0).</p>
</td></tr>
<tr><td><code id="gb_+3A_b">b</code></td>
<td>
<p>upper shift value (default - 1).</p>
</td></tr>
<tr><td><code id="gb_+3A_jmax">jmax</code></td>
<td>
<p>number of high-frequency lags.</p>
</td></tr>
<tr><td><code id="gb_+3A_x">X</code></td>
<td>
<p>optional evaluation grid vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Psi weight matrix with Gegenbauer functions upto <code>degree</code>.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>degree &lt;- 3
alpha &lt;- 1
jmax &lt;- 66
gb(degree = degree, alpha = alpha, a = 0, b = 1, jmax = jmax)
</code></pre>

<hr>
<h2 id='ic.panel.sglfit'>Information criteria fit for panel sg-LASSO</h2><span id='topic+ic.panel.sglfit'></span>

<h3>Description</h3>

<p>Does information criteria for panel data sg-LASSO regression model.
</p>
<p>The function runs <a href="#topic+sglfit">sglfit</a> 1 time; computes the path solution in <code>lambda</code> sequence.
Solutions for <code>BIC</code>, <code>AIC</code> and <code>AICc</code> information criteria are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic.panel.sglfit(x, y, lambda = NULL, gamma = 1.0, gindex = 1:p, 
                method = c("pooled","fe"), nf = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ic.panel.sglfit_+3A_x">x</code></td>
<td>
<p>NT by p data matrix, where NT and p respectively denote the sample size of pooled data and the number of regressors.</p>
</td></tr>
<tr><td><code id="ic.panel.sglfit_+3A_y">y</code></td>
<td>
<p>NT by 1 response variable.</p>
</td></tr>
<tr><td><code id="ic.panel.sglfit_+3A_lambda">lambda</code></td>
<td>
<p>a user-supplied lambda sequence. By leaving this option unspecified (recommended), users can have the program compute its own <code class="reqn">\lambda</code> sequence based on <code>nlambda</code> and <code>lambda.factor.</code> It is better to supply, if necessary, a decreasing sequence of lambda values than a single (small) value, as warm-starts are used in the optimization algorithm. The program will ensure that the user-supplied <code class="reqn">\lambda</code> sequence is sorted in decreasing order before fitting the model.</p>
</td></tr>
<tr><td><code id="ic.panel.sglfit_+3A_gamma">gamma</code></td>
<td>
<p>sg-LASSO mixing parameter. <code class="reqn">\gamma</code> = 1 gives LASSO solution and <code class="reqn">\gamma</code> = 0 gives group LASSO solution.</p>
</td></tr>
<tr><td><code id="ic.panel.sglfit_+3A_gindex">gindex</code></td>
<td>
<p>p by 1 vector indicating group membership of each covariate.</p>
</td></tr>
<tr><td><code id="ic.panel.sglfit_+3A_method">method</code></td>
<td>
<p>choose between 'pooled' and 'fe'; 'pooled' forces the intercept to be fitted in <a href="#topic+sglfit">sglfit</a>, 'fe' computes the fixed effects. User must input the number of fixed effects <code>nf</code> for <code>method = 'fe'</code>. Default is set to <code>method = 'pooled'</code>.</p>
</td></tr>
<tr><td><code id="ic.panel.sglfit_+3A_nf">nf</code></td>
<td>
<p>number of fixed effects. Used only if <code>method = 'fe'</code>.</p>
</td></tr>
<tr><td><code id="ic.panel.sglfit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <a href="#topic+sglfit">sglfit</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

The sequence of linear regression models implied by &lambda; vector is fit by block coordinate-descent. The objective function is (case <code>method='pooled'</code>) <br><br> ||y - &iota;&alpha; - x&beta;||<sup>2</sup><sub>NT</sub> + 2&lambda;  &Omega;<sub>&gamma;</sub>(&beta;), <br> where &iota;&#8712;R<sup>NT</sup> and &alpha; is common intercept to all N items or (case <code>method='fe'</code>) <br><br> ||y - B&alpha; - x&beta;||<sup>2</sup><sub>NT</sub> + 2&lambda;  &Omega;<sub>&gamma;</sub>(&beta;), <br> where B = I<sub>N</sub>&#8855;&iota; and ||u||<sup>2</sup><sub>NT</sub>=&#60;u,u&#62;/NT is the empirical inner product. The penalty function &Omega;<sub>&gamma;</sub>(.) is applied on  &beta; coefficients and is <br> <br> &Omega;<sub>&gamma;</sub>(&beta;) = &gamma; |&beta;|<sub>1</sub> + (1-&gamma;)|&beta;|<sub>2,1</sub>, <br> a convex combination of LASSO and group LASSO penalty functions.


<h3>Value</h3>

<p>ic.panel.sglfit object.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100 * 20), 100, 20)
beta = c(5,4,3,2,1,rep(0, times = 15))
y = x%*%beta + rnorm(100)
gindex = sort(rep(1:4,times=5))
ic.panel.sglfit(x = x, y = y, gindex = gindex, gamma = 0.5, 
  standardize = FALSE, intercept = FALSE)
</code></pre>

<hr>
<h2 id='ic.pen'>Compute the penalty based on chosen information criteria</h2><span id='topic+ic.pen'></span>

<h3>Description</h3>

<p>Compute the penalty based on chosen information criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic.pen(ic_choice, df, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ic.pen_+3A_ic_choice">ic_choice</code></td>
<td>
<p>information criteria choice: BIC, AIC or AICc.</p>
</td></tr>
<tr><td><code id="ic.pen_+3A_df">df</code></td>
<td>
<p>effective degrees of freedom.</p>
</td></tr>
<tr><td><code id="ic.pen_+3A_t">t</code></td>
<td>
<p>sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>penalty value.
</p>

<hr>
<h2 id='ic.sglfit'>Information criteria fit for sg-LASSO</h2><span id='topic+ic.sglfit'></span>

<h3>Description</h3>

<p>Does information criteria for sg-LASSO regression model.
</p>
<p>The function runs <a href="#topic+sglfit">sglfit</a> 1 time; computes the path solution in <code>lambda</code> sequence.
Solutions for <code>BIC</code>, <code>AIC</code> and <code>AICc</code> information criteria are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic.sglfit(x, y, lambda = NULL, gamma = 1.0, gindex = 1:p,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ic.sglfit_+3A_x">x</code></td>
<td>
<p>T by p data matrix, where T and p respectively denote the sample size and the number of regressors.</p>
</td></tr>
<tr><td><code id="ic.sglfit_+3A_y">y</code></td>
<td>
<p>T by 1 response variable.</p>
</td></tr>
<tr><td><code id="ic.sglfit_+3A_lambda">lambda</code></td>
<td>
<p>a user-supplied lambda sequence. By leaving this option unspecified (recommended), users can have the program compute its own <code class="reqn">\lambda</code> sequence based on <code>nlambda</code> and <code>lambda.factor.</code> It is better to supply, if necessary, a decreasing sequence of lambda values than a single (small) value, as warm-starts are used in the optimization algorithm. The program will ensure that the user-supplied <code class="reqn">\lambda</code> sequence is sorted in decreasing order before fitting the model.</p>
</td></tr>
<tr><td><code id="ic.sglfit_+3A_gamma">gamma</code></td>
<td>
<p>sg-LASSO mixing parameter. <code class="reqn">\gamma</code> = 1 gives LASSO solution and <code class="reqn">\gamma</code> = 0 gives group LASSO solution.</p>
</td></tr>
<tr><td><code id="ic.sglfit_+3A_gindex">gindex</code></td>
<td>
<p>p by 1 vector indicating group membership of each covariate.</p>
</td></tr>
<tr><td><code id="ic.sglfit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <a href="#topic+sglfit">sglfit</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

The sequence of linear regression models implied by &lambda; vector is fit by block coordinate-descent. The objective function is  <br><br> ||y - &iota;&alpha; - x&beta;||<sup>2</sup><sub>T</sub> + 2&lambda;  &Omega;<sub>&gamma;</sub>(&beta;), <br> where &iota;&#8712;R<sup>T</sup>enter> and ||u||<sup>2</sup><sub>T</sub>=&#60;u,u&#62;/T is the empirical inner product. The penalty function &Omega;<sub>&gamma;</sub>(.) is applied on  &beta; coefficients and is <br><br> &Omega;<sub>&gamma;</sub>(&beta;) = &gamma; |&beta;|<sub>1</sub> + (1-&gamma;)|&beta;|<sub>2,1</sub>, <br> a convex combination of LASSO and group LASSO penalty functions.


<h3>Value</h3>

<p>ic.sglfit object.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100 * 20), 100, 20)
beta = c(5,4,3,2,1,rep(0, times = 15))
y = x%*%beta + rnorm(100)
gindex = sort(rep(1:4,times=5))
ic.sglfit(x = x, y = y, gindex = gindex, gamma = 0.5, 
  standardize = FALSE, intercept = FALSE)
</code></pre>

<hr>
<h2 id='lag_num'>Compute the number of lags</h2><span id='topic+lag_num'></span>

<h3>Description</h3>

<p>Compute the number of lags
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lag_num(x.lag, period, unit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lag_num_+3A_x.lag">x.lag</code></td>
<td>
<p>number of high-frequency lags to construct in high-frequency time units.</p>
</td></tr>
<tr><td><code id="lag_num_+3A_period">period</code></td>
<td>
<p>high-frequency data period.</p>
</td></tr>
<tr><td><code id="lag_num_+3A_unit">unit</code></td>
<td>
<p>units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of the number of lags.
</p>

<hr>
<h2 id='lb'>Legendre polynomials shifted to [a,b]</h2><span id='topic+lb'></span>

<h3>Description</h3>

<p>For a given set of points in X, computes the orthonormal Legendre polynomials basis of L2 [a,b] for a given degree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lb(degree, a = 0, b = 1, jmax = NULL, X = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lb_+3A_degree">degree</code></td>
<td>
<p>polynomial degree.</p>
</td></tr>
<tr><td><code id="lb_+3A_a">a</code></td>
<td>
<p>lower shift value (default - 0).</p>
</td></tr>
<tr><td><code id="lb_+3A_b">b</code></td>
<td>
<p>upper shift value (default - 1).</p>
</td></tr>
<tr><td><code id="lb_+3A_jmax">jmax</code></td>
<td>
<p>number of high-frequency lags.</p>
</td></tr>
<tr><td><code id="lb_+3A_x">X</code></td>
<td>
<p>optional evaluation grid vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Psi weight matrix with Legendre functions upto <code>degree</code>.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>degree &lt;- 3
jmax &lt;- 66
lb(degree = degree, a = 0, b = 1, jmax = jmax)
</code></pre>

<hr>
<h2 id='market_ret'>SNP500 returns</h2><span id='topic+market_ret'></span>

<h3>Description</h3>

<p>SNP500 returns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(market_ret)
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.a
</p>


<h3>Source</h3>

<p><code>market_ret</code> - <a href="https://fred.stlouisfed.org/series/SP500">FRED</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(market_ret)
market_ret$snp500ret

</code></pre>

<hr>
<h2 id='midas.ardl'>MIDAS regression</h2><span id='topic+midas.ardl'></span>

<h3>Description</h3>

<p>Fits MIDAS regression model with single high-frequency covariate. Options include linear-in-parameters polynomials (e.g. Legendre) or non-linear polynomials (e.g. exponential Almon).
Nonlinear polynomial optimization routines are equipped with analytical gradients, which allows fast and accurate optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midas.ardl(y, x, z = NULL, loss_choice = c("mse","logit"), 
           poly_choice = c("legendre","expalmon","beta"), 
           poly_spec = 0, legendre_degree = 3, nbtrials = 500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="midas.ardl_+3A_y">y</code></td>
<td>
<p>response variable. Continuous for <code>loss_choice = "mse"</code>, binary for <code>loss_choice = "logit"</code>.</p>
</td></tr>
<tr><td><code id="midas.ardl_+3A_x">x</code></td>
<td>
<p>high-frequency covariate lags.</p>
</td></tr>
<tr><td><code id="midas.ardl_+3A_z">z</code></td>
<td>
<p>other lower-frequency covariate(s) or AR lags (both can be supplied in an appended matrix). Either must be supplied.</p>
</td></tr>
<tr><td><code id="midas.ardl_+3A_loss_choice">loss_choice</code></td>
<td>
<p>which loss function to fit: <code>loss_choice="mse"</code> fits least squares MIDAS regression, <code>loss_choice="logit"</code> fits logit MIDAS regression.</p>
</td></tr>
<tr><td><code id="midas.ardl_+3A_poly_choice">poly_choice</code></td>
<td>
<p>which MIDAS lag polynomial function to use: <code>poly_choice="expalmon"</code> - exponential Almon polynomials, <code>poly_choice="beta"</code> - Beta density function (need to set <code>poly_spec</code>), <code>poly_choice="legendre"</code> - legendre polynomials (need to set <code>legendre_degree</code>). Default is set to <code>poly_choice="expalmon"</code>.</p>
</td></tr>
<tr><td><code id="midas.ardl_+3A_poly_spec">poly_spec</code></td>
<td>
<p>which Beta density function specification to apply (applicable only for <code>poly_choice="beta"</code>). <code>poly_spec = 0</code> - all three parameters are fitted,  <code>poly_spec = 1</code> (<code class="reqn">\theta_2,\theta_3</code>) are fitted, <code>poly_spec = 2</code> (<code class="reqn">\theta_1,\theta_2</code>) are fitted, <code>poly_spec = 3</code> (<code class="reqn">\theta_2</code>) is fitted. Default is set to <code>poly_spec = 0</code>.</p>
</td></tr>
<tr><td><code id="midas.ardl_+3A_legendre_degree">legendre_degree</code></td>
<td>
<p>the degree of legendre polynomials (applicable only for <code>legendre="beta"</code>). Default is set to 3.</p>
</td></tr>
<tr><td><code id="midas.ardl_+3A_nbtrials">nbtrials</code></td>
<td>
<p>number of initial values tried in multistart optimization. Default is set to <code>poly_spec = 500</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

Several polynomial functional forms are available (<code>poly_choice</code>): <br><br> - <code>beta</code>: Beta polynomial <br> - <code>expalmon</code>: exponential Almon polynomial <br> - <code>legendre</code>: Legendre polynomials. <br> <br> The ARDL-MIDAS model is: <br> y<sub>t</sub> =  &mu; + &Sigma;<sub>p</sub> &rho;<sub>p</sub> y<sub>t-p</sub> + &beta;  &Sigma;<sub>j</sub> &omega;<sub>j</sub>(&theta;)x<sub>t-1</sub> <br> where &mu;, &beta;, &theta; and  &rho;<sub>p</sub> are model parameters, p is the number of low-frequency lags and &omega; is the weight function.


<h3>Value</h3>

<p>midas.ardl object.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100 * 20), 100, 20)
z = rnorm(100)
y = rnorm(100)
midas.ardl(y = y, x = x, z = z)
</code></pre>

<hr>
<h2 id='mixed_freq_data'>MIDAS data structure</h2><span id='topic+mixed_freq_data'></span>

<h3>Description</h3>

<p>Creates a MIDAS data structure for a single high-frequency covariate and a single low-frequency dependent variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixed_freq_data(data.y, data.ydate, data.x, data.xdate, x.lag, y.lag, 
  horizon, est.start, est.end, disp.flag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixed_freq_data_+3A_data.y">data.y</code></td>
<td>
<p>n by 1 low-frequency time series data vector.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_+3A_data.ydate">data.ydate</code></td>
<td>
<p>n by 1 low-frequency time series date vector.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_+3A_data.x">data.x</code></td>
<td>
<p>m by 1 high-frequency time series data vector.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_+3A_data.xdate">data.xdate</code></td>
<td>
<p>m by 1 high-frequency time series date vector.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_+3A_x.lag">x.lag</code></td>
<td>
<p>number of high-frequency lags to construct in high-frequency time units.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_+3A_y.lag">y.lag</code></td>
<td>
<p>number of low-frequency lags to construct in low-frequency time units.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_+3A_horizon">horizon</code></td>
<td>
<p>forecast horizon relative to <code>data.ydate</code> date in high-frequency time units.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_+3A_est.start">est.start</code></td>
<td>
<p>estimation start date, taken as the first ... .</p>
</td></tr>
<tr><td><code id="mixed_freq_data_+3A_est.end">est.end</code></td>
<td>
<p>estimation end date, taken as the last ... . Remaining data after this date is dropped to out-of-sample evaluation data.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_+3A_disp.flag">disp.flag</code></td>
<td>
<p>display flag to indicate whether or not to display obtained MIDAS data structure in console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of MIDAS data structure.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_rgdp)
rgdp &lt;- us_rgdp$rgdp
payems &lt;- us_rgdp$payems
payems[-1, 2] &lt;- log(payems[-1, 2]/payems[-dim(payems)[1], 2])*100
payems &lt;- payems[-1, ]
rgdp[-1, 2] &lt;- ((rgdp[-1, 2]/rgdp[-dim(rgdp)[1], 2])^4-1)*100
rgdp &lt;- rgdp[-1, ]
est.start &lt;- as.Date("1990-01-01")
est.end &lt;- as.Date("2002-03-01")
mixed_freq_data(rgdp[,2], as.Date(rgdp[,1]), payems[,2], 
  as.Date(payems[,1]), x.lag = 9, y.lag = 4, horizon = 1, 
  est.start, est.end, disp.flag = FALSE)
</code></pre>

<hr>
<h2 id='mixed_freq_data_single'>MIDAS data structure</h2><span id='topic+mixed_freq_data_single'></span>

<h3>Description</h3>

<p>Creates a MIDAS data structure for a single high-frequency covariate based on low-frequency reference date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixed_freq_data_single(data.refdate, data.x, data.xdate, x.lag, horizon,
  est.start, est.end, disp.flag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixed_freq_data_single_+3A_data.refdate">data.refdate</code></td>
<td>
<p>n by 1 date vector.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_single_+3A_data.x">data.x</code></td>
<td>
<p>m by 1 high-frequency time series data vector.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_single_+3A_data.xdate">data.xdate</code></td>
<td>
<p>m by 1 high-frequency time series date vector.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_single_+3A_x.lag">x.lag</code></td>
<td>
<p>number of high-frequency lags to construct in high-frequency time units.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_single_+3A_horizon">horizon</code></td>
<td>
<p>forecast horizon relative to <code>data.refdate</code> date in high-frequency time units.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_single_+3A_est.start">est.start</code></td>
<td>
<p>estimation start date, taken as the first ... .</p>
</td></tr>
<tr><td><code id="mixed_freq_data_single_+3A_est.end">est.end</code></td>
<td>
<p>estimation end date, taken as the last ... . Remaining data after this date is dropped to out-of-sample evaluation data.</p>
</td></tr>
<tr><td><code id="mixed_freq_data_single_+3A_disp.flag">disp.flag</code></td>
<td>
<p>display flag to indicate whether or not to display obtained MIDAS data strcuture in console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of midas data structure.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_rgdp)
rgdp &lt;- us_rgdp$rgdp
cfnai &lt;- us_rgdp$cfnai
data.refdate &lt;- rgdp$date
data.x &lt;- cfnai$cfnai
data.xdate &lt;- cfnai$date
est.start &lt;- as.Date("1990-01-01")
est.end &lt;- as.Date("2002-03-01")
mixed_freq_data_single(data.refdate, data.x, data.xdate, x.lag = 12, horizon = 1,
 est.start, est.end, disp.flag = FALSE)
</code></pre>

<hr>
<h2 id='mode_midasml'>Compute mode of a vector</h2><span id='topic+mode_midasml'></span>

<h3>Description</h3>

<p>Compute mode of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_midasml(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mode_midasml_+3A_data">data</code></td>
<td>
<p>data vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of arguments.
</p>

<hr>
<h2 id='monthBegin'>Beginning of the month date</h2><span id='topic+monthBegin'></span>

<h3>Description</h3>

<p>Change the date to the beginning of the month date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monthBegin(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monthBegin_+3A_x">x</code></td>
<td>
<p>date value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>changed date value.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>monthBegin(as.Date("2020-05-15"))
</code></pre>

<hr>
<h2 id='monthEnd'>End of the month date</h2><span id='topic+monthEnd'></span>

<h3>Description</h3>

<p>Change the date to the end of the month date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monthEnd(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monthEnd_+3A_x">x</code></td>
<td>
<p>date value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>changed date value.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>monthEnd(as.Date("2020-05-15"))
</code></pre>

<hr>
<h2 id='predict.cv.panel.sglfit'>Computes prediction</h2><span id='topic+predict.cv.panel.sglfit'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this functions predicts fitted values from a fitted sglfit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.panel.sglfit'
predict(
  object,
  newx,
  s = c("lam.min", "lam.1se"),
  type = c("response"),
  method = c("pooled", "fe"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cv.panel.sglfit_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cv.panel.sglfit">cv.panel.sglfit</a></code> model object.</p>
</td></tr>
<tr><td><code id="predict.cv.panel.sglfit_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for x at which predictions are to be made. NOTE: <code>newx</code> must be a matrix, predict function does not accept a vector or other formats of newx.</p>
</td></tr>
<tr><td><code id="predict.cv.panel.sglfit_+3A_s">s</code></td>
<td>
<p>choose between 'lam.min' and 'lam.1se'.</p>
</td></tr>
<tr><td><code id="predict.cv.panel.sglfit_+3A_type">type</code></td>
<td>
<p>type of prediction required. Only response is available. Gives predicted response for regression problems.</p>
</td></tr>
<tr><td><code id="predict.cv.panel.sglfit_+3A_method">method</code></td>
<td>
<p>choose between 'pooled', and 'fe'.</p>
</td></tr>
<tr><td><code id="predict.cv.panel.sglfit_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are to be made. If s is not in the lambda sequence used for fitting the model, the predict function will use linear interpolation to make predictions. The new values are interpolated using a fraction of predicted values from both left and right <code class="reqn">lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>

<hr>
<h2 id='predict.cv.sglfit'>Computes prediction</h2><span id='topic+predict.cv.sglfit'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this functions predicts fitted values from a fitted sglfit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.sglfit'
predict(object, newx, s = c("lam.min", "lam.1se"), type = c("response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cv.sglfit_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cv.sglfit">cv.sglfit</a></code> model object.</p>
</td></tr>
<tr><td><code id="predict.cv.sglfit_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for x at which predictions are to be made. NOTE: <code>newx</code> must be a matrix, predict function does not accept a vector or other formats of newx.</p>
</td></tr>
<tr><td><code id="predict.cv.sglfit_+3A_s">s</code></td>
<td>
<p>choose between 'lam.min' and 'lam.1se'.</p>
</td></tr>
<tr><td><code id="predict.cv.sglfit_+3A_type">type</code></td>
<td>
<p>type of prediction required. Only response is available. Gives predicted response for regression problems.</p>
</td></tr>
<tr><td><code id="predict.cv.sglfit_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
<tr><td><code id="predict.cv.sglfit_+3A_method">method</code></td>
<td>
<p>choose between 'single', 'pooled', and 'fe'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are to be made. If s is not in the lambda sequence used for fitting the model, the predict function will use linear interpolation to make predictions. The new values are interpolated using a fraction of predicted values from both left and right <code class="reqn">lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>

<hr>
<h2 id='predict.ic.panel.sglfit'>Computes prediction</h2><span id='topic+predict.ic.panel.sglfit'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this functions predicts fitted values from a fitted sglfit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ic.panel.sglfit'
predict(
  object,
  newx,
  s = c("bic", "aic", "aicc"),
  type = c("response"),
  method = c("pooled", "fe"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ic.panel.sglfit_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+ic.panel.sglfit">ic.panel.sglfit</a></code> model object.</p>
</td></tr>
<tr><td><code id="predict.ic.panel.sglfit_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for x at which predictions are to be made. NOTE: <code>newx</code> must be a matrix, predict function does not accept a vector or other formats of newx.</p>
</td></tr>
<tr><td><code id="predict.ic.panel.sglfit_+3A_s">s</code></td>
<td>
<p>choose between 'bic', 'aic', and 'aicc'.</p>
</td></tr>
<tr><td><code id="predict.ic.panel.sglfit_+3A_type">type</code></td>
<td>
<p>type of prediction required. Only response is available. Gives predicted response for regression problems.</p>
</td></tr>
<tr><td><code id="predict.ic.panel.sglfit_+3A_method">method</code></td>
<td>
<p>choose between 'pooled', and 'fe'.</p>
</td></tr>
<tr><td><code id="predict.ic.panel.sglfit_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are to be made. If s is not in the lambda sequence used for fitting the model, the predict function will use linear interpolation to make predictions. The new values are interpolated using a fraction of predicted values from both left and right <code class="reqn">lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>

<hr>
<h2 id='predict.ic.sglfit'>Computes prediction</h2><span id='topic+predict.ic.sglfit'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this functions predicts fitted values from a fitted sglfit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ic.sglfit'
predict(object, newx, s = c("bic", "aic", "aicc"), type = c("response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ic.sglfit_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cv.sglfit">cv.sglfit</a></code> model object.</p>
</td></tr>
<tr><td><code id="predict.ic.sglfit_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for x at which predictions are to be made. NOTE: <code>newx</code> must be a matrix, predict function does not accept a vector or other formats of newx.</p>
</td></tr>
<tr><td><code id="predict.ic.sglfit_+3A_s">s</code></td>
<td>
<p>choose between 'bic', 'aic', and 'aicc'.</p>
</td></tr>
<tr><td><code id="predict.ic.sglfit_+3A_type">type</code></td>
<td>
<p>type of prediction required. Only response is available. Gives predicted response for regression problems.</p>
</td></tr>
<tr><td><code id="predict.ic.sglfit_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are to be made. If s is not in the lambda sequence used for fitting the model, the predict function will use linear interpolation to make predictions. The new values are interpolated using a fraction of predicted values from both left and right <code class="reqn">lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>

<hr>
<h2 id='predict.sglpath'>Computes prediction</h2><span id='topic+predict.sglpath'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this functions predicts fitted values from a fitted sglfit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sglpath'
predict(
  object,
  newx,
  s = NULL,
  type = c("response"),
  method = c("single", "pooled", "fe"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.sglpath_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+sglfit">sglfit</a></code> model object.</p>
</td></tr>
<tr><td><code id="predict.sglpath_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for x at which predictions are to be made. NOTE: <code>newx</code> must be a matrix, predict function does not accept a vector or other formats of newx.</p>
</td></tr>
<tr><td><code id="predict.sglpath_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code class="reqn">lambda</code> at which predictions are to be made. Default is the entire sequence used to create the model.</p>
</td></tr>
<tr><td><code id="predict.sglpath_+3A_type">type</code></td>
<td>
<p>type of prediction required. Only response is available. Gives predicted response for regression problems.</p>
</td></tr>
<tr><td><code id="predict.sglpath_+3A_method">method</code></td>
<td>
<p>choose between 'single', 'pooled', and 'fe'.</p>
</td></tr>
<tr><td><code id="predict.sglpath_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are to be made. If s is not in the lambda sequence used for fitting the model, the predict function will use linear interpolation to make predictions. The new values are interpolated using a fraction of predicted values from both left and right <code class="reqn">lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>

<hr>
<h2 id='reg.panel.sgl'>Regression fit for panel sg-LASSO</h2><span id='topic+reg.panel.sgl'></span>

<h3>Description</h3>

<p>Fits panel data sg-LASSO regression model.
</p>
<p>The function fits sg-LASSO regression based on chosen tuning parameter selection method_choice. Options include cross-validation and information criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg.panel.sgl(x, y, gamma = NULL, gindex, intercept = TRUE, 
              method_choice = c("ic","cv"), nfolds = 10, 
              method = c("pooled", "fe"), nf = NULL, 
              verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reg.panel.sgl_+3A_x">x</code></td>
<td>
<p>NT by p data matrix, where NT and p respectively denote the sample size of pooled data and the number of regressors.</p>
</td></tr>
<tr><td><code id="reg.panel.sgl_+3A_y">y</code></td>
<td>
<p>NT by 1 response variable.</p>
</td></tr>
<tr><td><code id="reg.panel.sgl_+3A_gamma">gamma</code></td>
<td>
<p>sg-LASSO mixing parameter. <code class="reqn">\gamma</code> = 1 gives LASSO solution and <code class="reqn">\gamma</code> = 0 gives group LASSO solution.</p>
</td></tr>
<tr><td><code id="reg.panel.sgl_+3A_gindex">gindex</code></td>
<td>
<p>p by 1 vector indicating group membership of each covariate.</p>
</td></tr>
<tr><td><code id="reg.panel.sgl_+3A_intercept">intercept</code></td>
<td>
<p>whether intercept be fitted (<code>TRUE</code>) or set to zero (<code>FALSE</code>). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="reg.panel.sgl_+3A_method_choice">method_choice</code></td>
<td>
<p>choose between <code>ic</code> and <code>cv</code>. <code>ic</code> gives fit based on information criteria (BIC, AIC or AICc) by running <code>ic.fit</code>, while <code>cv</code> gives fit based on cross-validation by running <code>cv.sglfit</code>. If <code>cv</code> is chosen, optional number of folds <code>nfolds</code> can be supplied.</p>
</td></tr>
<tr><td><code id="reg.panel.sgl_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds of the cv loop. Default set to <code>10</code>.</p>
</td></tr>
<tr><td><code id="reg.panel.sgl_+3A_method">method</code></td>
<td>
<p>choose between 'pooled' and 'fe'; 'pooled' forces the intercept to be fitted in <a href="#topic+sglfit">sglfit</a>, 'fe' computes the fixed effects. User must input the number of fixed effects <code>nf</code> for <code>method = 'fe'</code>, and it is recommended to do so for <code>method = 'pooled'</code>. Program uses supplied <code>nf</code> to construct <code>foldsid</code> if <code>method_choice = 'cv'</code> is chosen. Default is set to <code>method = 'pooled'</code>.</p>
</td></tr>
<tr><td><code id="reg.panel.sgl_+3A_nf">nf</code></td>
<td>
<p>number of fixed effects. Used only if <code>method = 'fe'</code>.</p>
</td></tr>
<tr><td><code id="reg.panel.sgl_+3A_verbose">verbose</code></td>
<td>
<p>flag to print information.</p>
</td></tr>
<tr><td><code id="reg.panel.sgl_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>sglfit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

The sequence of linear regression models implied by &lambda; vector is fit by block coordinate-descent. The objective function is either (case <code>method='pooled'</code>) <br><br> ||y - &iota;&alpha; - x&beta;||<sup>2</sup><sub>NT</sub> + 2&lambda;  &Omega;<sub>&gamma;</sub>(&beta;), <br> where &iota;&#8712;R<sup>NT</sup> and &alpha; is common intercept to all N items or (case <code>method='fe'</code>) <br><br> ||y - B&alpha; - x&beta;||<sup>2</sup><sub>NT</sub> + 2&lambda;  &Omega;<sub>&gamma;</sub>(&beta;), <br> where B = I<sub>N</sub>&#8855;&iota; and ||u||<sup>2</sup><sub>NT</sub>=&#60;u,u&#62;/NT is the empirical inner product. The penalty function &Omega;<sub>&gamma;</sub>(.) is applied on  &beta; coefficients and is <br><br> &Omega;<sub>&gamma;</sub>(&beta;) = &gamma; |&beta;|<sub>1</sub> + (1-&gamma;)|&beta;|<sub>2,1</sub>, <br> a convex combination of LASSO and group LASSO penalty functions.


<h3>Value</h3>

<p>reg.panel.sgl object.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100 * 20), 100, 20)
beta = c(5,4,3,2,1,rep(0, times = 15))
y = x%*%beta + rnorm(100)
gindex = sort(rep(1:4,times=5))
reg.panel.sgl(x = x, y = y, 
  gindex = gindex, gamma = 0.5, 
  method = "fe", nf = 10, 
  standardize = FALSE, intercept = FALSE)
</code></pre>

<hr>
<h2 id='reg.sgl'>Fit for sg-LASSO regression</h2><span id='topic+reg.sgl'></span>

<h3>Description</h3>

<p>Fits sg-LASSO regression model.
</p>
<p>The function fits sg-LASSO regression based on chosen tuning parameter selection <code>method_choice</code>. Options include cross-validation and information criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg.sgl(x, y, gamma = NULL, gindex, intercept = TRUE, 
        method_choice = c("tscv","ic","cv"), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reg.sgl_+3A_x">x</code></td>
<td>
<p>T by p data matrix, where T and p respectively denote the sample size and the number of regressors.</p>
</td></tr>
<tr><td><code id="reg.sgl_+3A_y">y</code></td>
<td>
<p>T by 1 response variable.</p>
</td></tr>
<tr><td><code id="reg.sgl_+3A_gamma">gamma</code></td>
<td>
<p>sg-LASSO mixing parameter. <code class="reqn">\gamma</code> = 1 gives LASSO solution and <code class="reqn">\gamma</code> = 0 gives group LASSO solution.</p>
</td></tr>
<tr><td><code id="reg.sgl_+3A_gindex">gindex</code></td>
<td>
<p>p by 1 vector indicating group membership of each covariate.</p>
</td></tr>
<tr><td><code id="reg.sgl_+3A_intercept">intercept</code></td>
<td>
<p>whether intercept be fitted (<code>TRUE</code>) or set to zero (<code>FALSE</code>). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="reg.sgl_+3A_method_choice">method_choice</code></td>
<td>
<p>choose between <code>tscv</code> <code>ic</code> and <code>cv</code>. <code>tscv</code> fits sg-LASSO based on time series cross-validation (see <a href="#topic+tscv.sglfit">tscv.sglfit</a>), <code>ic</code> fits sg-LASSO based on information criteria (BIC, AIC or AICc, see <a href="#topic+ic.sglfit">ic.sglfit</a>), <code>cv</code> fits sg-LASSO based on cross-validation (see <a href="#topic+cv.sglfit">cv.sglfit</a>). Additional arguments for each method choice are passed on to the relevant functions.</p>
</td></tr>
<tr><td><code id="reg.sgl_+3A_verbose">verbose</code></td>
<td>
<p>flag to print information.</p>
</td></tr>
<tr><td><code id="reg.sgl_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>sglfit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

The sequence of linear regression models implied by &lambda; vector is fit by block coordinate-descent. The objective function is  <br><br> ||y - &iota;&alpha; - x&beta;||<sup>2</sup><sub>T</sub> + 2&lambda;  &Omega;<sub>&gamma;</sub>(&beta;), <br> where &iota;&#8712;R<sup>T</sup>enter> and ||u||<sup>2</sup><sub>T</sub>=&#60;u,u&#62;/T is the empirical inner product. The penalty function &Omega;<sub>&gamma;</sub>(.) is applied on  &beta; coefficients and is <br> <br> &Omega;<sub>&gamma;</sub>(&beta;) = &gamma; |&beta;|<sub>1</sub> + (1-&gamma;)|&beta;|<sub>2,1</sub>, <br> a convex combination of LASSO and group LASSO penalty functions.


<h3>Value</h3>

<p>reg.sgl object.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100 * 20), 100, 20)
beta = c(5,4,3,2,1,rep(0, times = 15))
y = x%*%beta + rnorm(100)
gindex = sort(rep(1:4,times=5))
reg.sgl(x = x, y = y, gamma = 0.5, gindex = gindex)
</code></pre>

<hr>
<h2 id='rgdp_dates'>Real GDP release dates</h2><span id='topic+rgdp_dates'></span>

<h3>Description</h3>

<p>Real GDP release dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rgdp_dates)
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> objects
</p>


<h3>Source</h3>

<p><a href="https://alfred.stlouisfed.org/">ALFRED</a> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(rgdp_dates)
rgdp_dates$Quarter_q # reference quarters in quarters
rgdp_dates$Quarter_m # reference quarters in months
rgdp_dates$Quarter_d # reference quarters in days
rgdp_dates$`First release` # first release date for the reference
rgdp_dates$`Second release` # second release date for the reference
rgdp_dates$`Third release` # third release date for the reference

</code></pre>

<hr>
<h2 id='rgdp_vintages'>Real GDP vintages</h2><span id='topic+rgdp_vintages'></span>

<h3>Description</h3>

<p>Real GDP vintages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rgdp_vintages)
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> objects
</p>


<h3>Source</h3>

<p><a href="https://alfred.stlouisfed.org/">ALFRED</a> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(rgdp_vintages)
rgdp_vintages$date # dates
rgdp_vintages$time_series # series, q-q annual rate
rgdp_vintages$realtime_period # real time dates 

</code></pre>

<hr>
<h2 id='sglfit'>Fits sg-LASSO regression</h2><span id='topic+sglfit'></span>

<h3>Description</h3>

<p>Fits sg-LASSO regression model.
The function fits sg-LASSO regression model for a sequence of <code class="reqn">\lambda</code> tuning parameter and fixed <code class="reqn">\gamma</code> tuning parameter. The optimization is based on block coordinate-descent. Optionally, fixed effects are fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sglfit(x, y, gamma = 1.0, nlambda = 100L, method = c("single", "pooled", "fe"), 
       nf = NULL, lambda.factor = ifelse(nobs &lt; nvars, 1e-02, 1e-04), 
       lambda = NULL, pf = rep(1, nvars), gindex = 1:nvars, 
       dfmax = nvars + 1, pmax = min(dfmax * 1.2, nvars), standardize = FALSE, 
       intercept = FALSE, eps = 1e-08, maxit = 1000000L, peps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sglfit_+3A_x">x</code></td>
<td>
<p>T by p data matrix, where T and p respectively denote the sample size and the number of regressors.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_y">y</code></td>
<td>
<p>T by 1 response variable.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_gamma">gamma</code></td>
<td>
<p>sg-LASSO mixing parameter. <code class="reqn">\gamma</code> = 1 gives LASSO solution and <code class="reqn">\gamma</code> = 0 gives group LASSO solution.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_nlambda">nlambda</code></td>
<td>
<p>number of <code class="reqn">\lambda</code>'s to use in the regularization path; used if <code>lambda = NULL</code>.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_method">method</code></td>
<td>
<p>choose between 'single', 'pooled' and 'fe'; 'single' implies standard sg-LASSO regression, 'pooled' forces the intercept to be fitted, 'fe' computes the fixed effects. User needs to input the number of fixed effects <code>nf</code>. Default is set to 'single'.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_nf">nf</code></td>
<td>
<p>number of fixed effects. Used only if <code>method = 'fe'</code>.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_lambda.factor">lambda.factor</code></td>
<td>
<p>The factor for getting the minimal <code class="reqn">\lambda</code> in the <code class="reqn">\lambda</code> sequence, where <code>min(lambda) = lambda.factor * max(lambda)</code>. max(lambda) is the smallest value of lambda for which all coefficients are zero. &lambda; <sub>max</sub> is determined for each <code class="reqn">\gamma</code> tuning parameter separately. The default depends on the relationship between <code>T</code> (the sample size) and <code>p</code> (the number of predictors). If <code>T &lt; p</code>, the default is <code>0.01</code>. If <code>T &gt; p</code>, the default is <code>0.0001</code>, closer to zero. The smaller the value of <code>lambda.factor</code> is, the denser is the fit for &lambda;<sub>min</sub>. Used only if <code>lambda = NULL</code>.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_lambda">lambda</code></td>
<td>
<p>a user-supplied lambda sequence. By leaving this option unspecified (recommended), users can have the program compute its own <code>lambda</code> sequence based on <code>nlambda</code> and <code>lambda.factor.</code> It is better to supply, if necessary, a decreasing sequence of lambda values than a single (small) value, as warm-starts are used in the optimization algorithm. The program will ensure that the user-supplied <code class="reqn">\lambda</code> sequence is sorted in decreasing order before fitting the model.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_pf">pf</code></td>
<td>
<p>the &#8467;<sub>1</sub> penalty factor of length <code>p</code> used for the adaptive sg-LASSO. Separate &#8467;<sub>1</sub> penalty weights can be applied to each coefficient to allow different &#8467;<sub>1</sub> + &#8467;<sub>2,1</sub> shrinkage. Can be 0 for some variables, which imposes no shrinkage, and results in that variable always be included in the model. Default is 1 for all variables.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_gindex">gindex</code></td>
<td>
<p>p by 1 vector indicating group membership of each covariate.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_dfmax">dfmax</code></td>
<td>
<p>the maximum number of variables allowed in the model. Useful for very large <code>p</code> when a partial path is desired. Default is <code>p+1</code>. In case <code>method='fe'</code>, <code>dfmax</code> is ignored.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_pmax">pmax</code></td>
<td>
<p>the maximum number of coefficients allowed ever to be nonzero. For example, once &beta;<sub>i</sub> &#8800; 0  for some i &#8712; [p], no matter how many times it exits or re-enters the model through the path, it will be counted only once. Default is <code>min(dfmax*1.2, p)</code>.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_standardize">standardize</code></td>
<td>
<p>logical flag for variable standardization, prior to fitting the model sequence. The coefficients are always returned to the original scale. It is recommended to keep <code>standardize=TRUE</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_intercept">intercept</code></td>
<td>
<p>whether intercept be fitted (<code>TRUE</code>) or set to zero (<code>FALSE</code>). Default is <code>FALSE</code>. In case <code>method='pooled'</code>, <code>intercept=TRUE</code> is forced. In case <code>method='fe'</code>, <code>intercept=FALSE</code> is forced and <code>entity</code> specific intercepts are fitted in a separate output variable <code>a0</code>.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_eps">eps</code></td>
<td>
<p>convergence threshold for block coordinate descent. Each inner block coordinate-descent loop continues until the maximum change in the objective after any coefficient update is less than thresh times the null deviance. Defaults value is <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of outer-loop iterations allowed at fixed lambda values. Default is <code>1e6</code>. If the algorithm does not converge, consider increasing <code>maxit</code>.</p>
</td></tr>
<tr><td><code id="sglfit_+3A_peps">peps</code></td>
<td>
<p>convergence threshold for proximal map of sg-LASSO penalty. Each loop continues until G group difference sup-norm, || &beta;<sup>k</sup><sub>G</sub> - &beta;<sup>k-1</sup><sub>G</sub> ||<sub>&#8734;</sub>, is less than <code>peps</code>. Defaults value is <code>1e-8</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

The sequence of linear regression models implied by &lambda; vector is fit by block coordinate-descent. The objective function is  <br><br> ||y - &iota;&alpha; - x&beta;||<sup>2</sup><sub>T</sub> + 2&lambda;  &Omega;<sub>&gamma;</sub>(&beta;), <br> where &iota;&#8712;R<sup>T</sup>enter> and ||u||<sup>2</sup><sub>T</sub>=&#60;u,u&#62;/T is the empirical inner product. The penalty function &Omega;<sub>&gamma;</sub>(.) is applied on  &beta; coefficients and is <br> <br> &Omega;<sub>&gamma;</sub>(&beta;) = &gamma; |&beta;|<sub>1</sub> + (1-&gamma;)|&beta;|<sub>2,1</sub>, <br> a convex combination of LASSO and group LASSO penalty functions.


<h3>Value</h3>

<p>sglfit object.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100 * 20), 100, 20)
beta = c(5,4,3,2,1,rep(0, times = 15))
y = x%*%beta + rnorm(100)
gindex = sort(rep(1:4,times=5))
sglfit(x = x, y = y, gindex = gindex, gamma = 0.5)
</code></pre>

<hr>
<h2 id='thetafit'>Nodewise LASSO regressions to fit the precision matrix &Theta;</h2><span id='topic+thetafit'></span>

<h3>Description</h3>

<p>Fits the precision matrix &Theta; by running nodewise LASSO regressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thetafit(x, parallel = FALSE, ncores = getOption("mc.cores", NULL), 
         intercept = FALSE, K = 20, l = 5, seed = NULL, verbose = FALSE, 
         registerpar = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thetafit_+3A_x">x</code></td>
<td>
<p>T by p data matrix, where T and p respectively denote the sample size and the number of regressors.</p>
</td></tr>
<tr><td><code id="thetafit_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, use parallel foreach to fit nodewise LASSO regressions. Parallel registered within the function.</p>
</td></tr>
<tr><td><code id="thetafit_+3A_ncores">ncores</code></td>
<td>
<p>number of cores used in parallelization</p>
</td></tr>
<tr><td><code id="thetafit_+3A_intercept">intercept</code></td>
<td>
<p>whether intercept be fitted (<code>TRUE</code>) or set to zero (<code>FALSE</code>). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="thetafit_+3A_k">K</code></td>
<td>
<p>number of folds of the cv loop. Default set to <code>20</code>.</p>
</td></tr>
<tr><td><code id="thetafit_+3A_l">l</code></td>
<td>
<p>the gap used to drop observations round test set data. See <a href="#topic+tscv.sglfit">tscv.sglfit</a> for more details.</p>
</td></tr>
<tr><td><code id="thetafit_+3A_seed">seed</code></td>
<td>
<p>set a value for seed to control results replication, i.e. <code>set.seed(seed)</code> is used. <code>seed</code> is stored in the output list. Default set to <code>as.numeric(Sys.Date())</code>.</p>
</td></tr>
<tr><td><code id="thetafit_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, prints progress bar. Default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="thetafit_+3A_registerpar">registerpar</code></td>
<td>
<p>if <code>TRUE</code>, register parallelization using <code>registerDoParallel</code>. Default set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="thetafit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <a href="#topic+tscv.sglfit">tscv.sglfit</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <a href="#topic+tscv.sglfit">tscv.sglfit</a> <code>p</code> times by regressing <code>j</code>-th covariate on all other covariates excluding <code>j</code>-th covariate. The precision matrix is then constructed based on LASSO estimates. Each nodewise LASSO regression tuning parameter &lambda; is optimized using time series cross-validation. See <a href="#topic+tscv.sglfit">tscv.sglfit</a> for more details on cross-validation implementation.
</p>


<h3>Value</h3>

<p>thetafit object.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100 * 20), 100, 20)
thetafit(x = x, parallel = FALSE)
</code></pre>

<hr>
<h2 id='tscv.sglfit'>Time series cross-validation fit for sg-LASSO</h2><span id='topic+tscv.sglfit'></span>

<h3>Description</h3>

<p>Does k-fold time series cross-validation for sg-LASSO regression model.
</p>
<p>The function runs <a href="#topic+sglfit">sglfit</a> <code>K+1</code> times; the first to get the path solution in &lambda; sequence, the rest to compute the fit with each of the test observation k &isin; K 
The average error and standard deviation over the folds is computed, and the optimal regression coefficients are returned for <code>lam.min</code> and <code>lam.1se</code>. Solutions are computed for a fixed &gamma;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tscv.sglfit(x, y, lambda = NULL, gamma = 1.0, gindex = 1:p, 
  K = 20, l = 5, parallel = FALSE, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tscv.sglfit_+3A_x">x</code></td>
<td>
<p>T by p data matrix, where T and p respectively denote the sample size and the number of regressors.</p>
</td></tr>
<tr><td><code id="tscv.sglfit_+3A_y">y</code></td>
<td>
<p>T by 1 response variable.</p>
</td></tr>
<tr><td><code id="tscv.sglfit_+3A_lambda">lambda</code></td>
<td>
<p>a user-supplied lambda sequence. By leaving this option unspecified (recommended), users can have the program compute its own &lambda; sequence based on <code>nlambda</code> and &gamma; <code>lambda.factor.</code> It is better to supply, if necessary, a decreasing sequence of lambda values than a single (small) value, as warm-starts are used in the optimization algorithm. The program will ensure that the user-supplied <code>lambda</code> sequence is sorted in decreasing order before fitting the model.</p>
</td></tr>
<tr><td><code id="tscv.sglfit_+3A_gamma">gamma</code></td>
<td>
<p>sg-LASSO mixing parameter. &gamma; = 1 gives LASSO solution and &gamma; = 0 gives group LASSO solution.</p>
</td></tr>
<tr><td><code id="tscv.sglfit_+3A_gindex">gindex</code></td>
<td>
<p>p by 1 vector indicating group membership of each covariate.</p>
</td></tr>
<tr><td><code id="tscv.sglfit_+3A_k">K</code></td>
<td>
<p>number of observations drawn for the test set. Default set to <code>20</code>.</p>
</td></tr>
<tr><td><code id="tscv.sglfit_+3A_l">l</code></td>
<td>
<p>the gap used to drop observations round the test set data point. Default set to <code>5</code>.</p>
</td></tr>
<tr><td><code id="tscv.sglfit_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, use parallel foreach to fit each fold. Must register parallel before hand, such as doMC or others. See the example below.</p>
</td></tr>
<tr><td><code id="tscv.sglfit_+3A_seed">seed</code></td>
<td>
<p>set a value for seed to control results replication, i.e. <code>set.seed(seed)</code> is used. <code>seed</code> is stored in the output list. Default set to <code>as.numeric(Sys.Date())</code>.</p>
</td></tr>
<tr><td><code id="tscv.sglfit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <a href="#topic+sglfit">sglfit</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

The cross-validation is run for sg-LASSO linear model. The sequence of linear regression models implied by &lambda; vector is fit by block coordinate-descent. The objective function is  <br><br> ||y - &iota;&alpha; - x&beta;||<sup>2</sup><sub>T</sub> + 2&lambda;  &Omega;<sub>&gamma;</sub>(&beta;), <br> where &iota;&#8712;R<sup>T</sup>enter> and ||u||<sup>2</sup><sub>T</sub>=&#60;u,u&#62;/T is the empirical inner product. The penalty function &Omega;<sub>&gamma;</sub>(.) is applied on  &beta; coefficients and is <br> <br> &Omega;<sub>&gamma;</sub>(&beta;) = &gamma; |&beta;|<sub>1</sub> + (1-&gamma;)|&beta;|<sub>2,1</sub>, <br> a convex combination of LASSO and group LASSO penalty functions.


<h3>Value</h3>

<p>tscv.sglfit object.
</p>


<h3>Author(s)</h3>

<p>Jonas Striaukas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100 * 20), 100, 20)
beta = c(5,4,3,2,1,rep(0, times = 15))
y = x%*%beta + rnorm(100)
gindex = sort(rep(1:4,times=5))
tscv.sglfit(x = x, y = y, gindex = gindex, gamma = 0.5, 
  standardize = FALSE, intercept = FALSE)
## Not run:  
# Parallel
require(doMC)
registerDoMC(cores = 2)
x = matrix(rnorm(1000 * 20), 1000, 20)
beta = c(5,4,3,2,1,rep(0, times = 15))
y = x%*%beta + rnorm(1000)
gindex = sort(rep(1:4,times=5))
system.time(tscv.sglfit(x = x, y = y, gindex = gindex, gamma = 0.5, 
  standardize = FALSE, intercept = FALSE))
system.time(tscv.sglfit(x = x, y = y, gindex = gindex, gamma = 0.5, 
  standardize = FALSE, intercept = FALSE, parallel = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='tscv.sglpath'>Sorts time series cross-validation output</h2><span id='topic+tscv.sglpath'></span>

<h3>Description</h3>

<p>Computes <code>cvm</code> and <code>cvsd</code> based on times series cross-validation fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tscv.sglpath(outlist, lambda, x, y, foldid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tscv.sglpath_+3A_outlist">outlist</code></td>
<td>
<p>list of cross-validation fits.</p>
</td></tr>
<tr><td><code id="tscv.sglpath_+3A_lambda">lambda</code></td>
<td>
<p>a sequence of <code class="reqn">\lambda</code> parameter.</p>
</td></tr>
<tr><td><code id="tscv.sglpath_+3A_x">x</code></td>
<td>
<p>regressors</p>
</td></tr>
<tr><td><code id="tscv.sglpath_+3A_y">y</code></td>
<td>
<p>response</p>
</td></tr>
<tr><td><code id="tscv.sglpath_+3A_foldid">foldid</code></td>
<td>
<p>the fold assignment.</p>
</td></tr>
<tr><td><code id="tscv.sglpath_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>predict.sgl</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cvm</code> and <code>cvsd</code>.
</p>

<hr>
<h2 id='us_rgdp'>US real GDP data with several high-frequency predictors</h2><span id='topic+us_rgdp'></span>

<h3>Description</h3>

<p>US real GDP, Chicago National Activity Index, Nonfarm payrolls and ADS Index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(us_rgdp)
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> object.a
</p>


<h3>Source</h3>

<p><a href="https://fred.stlouisfed.org/series/GDPC1">rgdp</a> <br />
<a href="https://www.chicagofed.org/research/data/cfnai/current-data">cfnai</a> <br />
<a href="https://fred.stlouisfed.org/series/PAYEMS">payems</a> <br />
<a href="https://www.philadelphiafed.org/research-and-data/real-time-center/business-conditions-index">ads</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(us_rgdp)
us_rgdp$rgdp # - GDP data
us_rgdp$cfnai # - CFNAI predictor data
us_rgdp$payems # - Nonfarm payrolls predictor data 
us_rgdp$ads # - ADS predictor data

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
