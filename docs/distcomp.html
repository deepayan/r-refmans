<!DOCTYPE html><html><head><title>Help for package distcomp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distcomp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.makeOpencpuURL'><p>Make an appropriate opencpu URL for a specified function and url prefix for the</p>
distcomp package</a></li>
<li><a href='#availableComputations'><p>Return the currently available (implemented) computations</p></a></li>
<li><a href='#availableDataSources'><p>Return currently implemented data sources</p></a></li>
<li><a href='#CoxMaster'><p>Create a master object to control <code>CoxWorker</code> worker objects</p></a></li>
<li><a href='#CoxWorker'><p>R6 class for object to use as a worker with <code>CoxMaster</code> master objects</p></a></li>
<li><a href='#createHEWorkerInstance'><p>Given the definition identifier of an object, instantiate and store</p>
object in workspace</a></li>
<li><a href='#createNCPInstance'><p>Given the definition identifier of an object, instantiate and store</p>
object in workspace</a></li>
<li><a href='#createWorkerInstance'><p>Given the definition identifier of an object, instantiate and store object in workspace</p></a></li>
<li><a href='#dccoxph'><p>Functions copied and modified from survival package</p></a></li>
<li><a href='#defineNewComputation'><p>Define a new computation</p></a></li>
<li><a href='#destroyInstanceObject'><p>Destroy an instance object given its identifier</p></a></li>
<li><a href='#distcomp'><p>Distributed Computing with R</p></a></li>
<li><a href='#distcompSetup'><p>Setup a workspace and configuration for a distributed computation</p></a></li>
<li><a href='#executeHEMethod'><p>Given the id of a serialized object, invoke a method on the object</p>
with arguments using homomorphic encryption</a></li>
<li><a href='#executeMethod'><p>Given the id of a serialized object, invoke a method on the object</p>
with arguments</a></li>
<li><a href='#generateId'><p>Generate an identifier for an object</p></a></li>
<li><a href='#getComputationInfo'><p>Get the value of a variable from the global store</p></a></li>
<li><a href='#getConfig'><p>Return the workspace and configuration setup values</p></a></li>
<li><a href='#HEMaster'><p>Create a HEMaster process for use in a distributed homomorphic</p>
encrypted (HE) computation</a></li>
<li><a href='#HEQueryCountMaster'><p>Create a homomorphic computation query count master object to employ worker objects generated by <code>HEQueryCountWorker()</code></p></a></li>
<li><a href='#HEQueryCountWorker'><p>Create a homomorphic computation query count worker object for use with master objects generated by <code>HEQueryCountMaster()</code></p></a></li>
<li><a href='#makeDefinition'><p>Make a computation definition given the computation type</p></a></li>
<li><a href='#makeHEMaster'><p>Instantiate a master process for HE operations</p></a></li>
<li><a href='#makeMaster'><p>Make a master object given a definition</p></a></li>
<li><a href='#makeNCP'><p>Instantiate an noncooperating party</p></a></li>
<li><a href='#makeWorker'><p>Make a worker object given a definition and data</p></a></li>
<li><a href='#NCP'><p>R6 object to use as non-cooperating party in a distributed homomorphic computation</p></a></li>
<li><a href='#QueryCountMaster'><p>Create a master object to control worker objects generated by <code>QueryCountWorker()</code></p></a></li>
<li><a href='#QueryCountWorker'><p>R6 worker object for use as a worker with master objects generated by <code>QueryCountMaster()</code></p></a></li>
<li><a href='#resetComputationInfo'><p>Clear the contents of the global store</p></a></li>
<li><a href='#runDistcompApp'><p>Run a specified distcomp web application</p></a></li>
<li><a href='#saveNewComputation'><p>Save a computation instance, given the computation definition, associated data and</p>
possibly a data file name to use</a></li>
<li><a href='#saveNewNCP'><p>Save an NCP instance, given the sites as associated data and</p>
possibly a data file name to use</a></li>
<li><a href='#setComputationInfo'><p>Set a name to a value in a global variable</p></a></li>
<li><a href='#setupMaster'><p>Setup a computation master</p></a></li>
<li><a href='#setupWorker'><p>Setup a worker site</p></a></li>
<li><a href='#SVDMaster'><p>R6 class for SVD master object to control worker objects generated by <code>SVDWorker()</code></p></a></li>
<li><a href='#SVDWorker'><p>R6 class for a SVD worker object to use with master objects generated by <code>SVDMaster()</code></p></a></li>
<li><a href='#uploadNewComputation'><p>Upload a new computation and data to an opencpu server</p></a></li>
<li><a href='#uploadNewNCP'><p>Upload a new Non-Cooperating Party (NCP) information and sites to</p>
an opencpu server</a></li>
<li><a href='#writeCode'><p>Write the code necessary to run a master process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Computations over Distributed Data without Aggregation</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Balasubramanian Narasimhan &lt;naras@stat.Stanford.EDU&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://dx.doi.org/10.18637/jss.v077.i13">http://dx.doi.org/10.18637/jss.v077.i13</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>survival, stats, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, shiny, httr (&ge; 1.0.0), digest, jsonlite, stringr, R6
(&ge; 2.0), dplyr, rlang, magrittr, homomorpheR, gmp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>opencpu, knitr, covr, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementing algorithms and fitting models when sites (possibly remote) share
  computation summaries rather than actual data over HTTP with a master R process (using
  'opencpu', for example). A stratified Cox model and a singular value decomposition are
  provided. The former makes direct use of code from the R 'survival' package. (That is,
  the underlying Cox model code is derived from that in the R 'survival' package.)
  Sites may provide data via several means: CSV files, Redcap API, etc. An extensible
  design allows for new methods to be added in the future and includes facilities
  for local prototyping and testing. Web applications are provided (via 'shiny') for
  the implemented methods to help in designing and deploying the computations.</td>
</tr>
<tr>
<td>Copyright:</td>
<td>inst/COPYRIGHTS</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-01 18:28:23 UTC; naras</td>
</tr>
<tr>
<td>Author:</td>
<td>Balasubramanian Narasimhan [aut, cre],
  Marina Bendersky [aut],
  Sam Gross [aut],
  Terry M. Therneau [ctb],
  Thomas Lumley [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-01 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.makeOpencpuURL'>Make an appropriate opencpu URL for a specified function and url prefix for the
distcomp package</h2><span id='topic+.makeOpencpuURL'></span><span id='topic+.defnOK'></span><span id='topic+.deSerialize'></span>

<h3>Description</h3>

<p>.makeOpencpuURL returns an appropriate URL to call a function in the distcomp
package given the name of the function and a url prefix.
</p>
<p>.defnOK returns TRUE or FALSE depending on whether the definition object
meets minimimal requirements.
</p>
<p>.deSerialize will convert the JSON result of a http response as needed,
else the raw content is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.makeOpencpuURL(fn, urlPrefix, package = "distcomp")

.defnOK(defn)

.deSerialize(q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".makeOpencpuURL_+3A_fn">fn</code></td>
<td>
<p>is the name of the function in the distcomp package</p>
</td></tr>
<tr><td><code id=".makeOpencpuURL_+3A_urlprefix">urlPrefix</code></td>
<td>
<p>is the URL of the opencpu server with the distcomp package installed</p>
</td></tr>
<tr><td><code id=".makeOpencpuURL_+3A_defn">defn</code></td>
<td>
<p>is the definition object passed</p>
</td></tr>
<tr><td><code id=".makeOpencpuURL_+3A_q">q</code></td>
<td>
<p>the result of a httr response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the formatted url as a string
</p>
<p>TRUE or FALSE depending on the result
</p>
<p>the converted result, if JSON, or the raw content
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distcomp:::.makeOpencpuURL("foo", "http://localhost:9999/ocpu")

distcomp:::.defnOK(data.frame()) ## FALSE
distcomp:::.defnOK(data.frame(id = "ABC", stringsAsFactors=FALSE)) ## TRUE

</code></pre>

<hr>
<h2 id='availableComputations'>Return the currently available (implemented) computations</h2><span id='topic+availableComputations'></span>

<h3>Description</h3>

<p>The function <code>availableComputations</code> returns a list
of available computations with various components. The names of this list
(with no spaces) are unique canonical tags that are used throughout the
package to unambiguously refer to the type of computation; web applications
particularly rely on this list to instantiate objects. As more computations
are implemented, this list is augmented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availableComputations()
</code></pre>


<h3>Value</h3>

<p>a list with the components corresponding to a computation
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>a textual description (25 chars at most)</p>
</td></tr>
<tr><td><code>definitionApp</code></td>
<td>
<p>the name of a function that will fire up a shiny webapp
for defining the particular computation</p>
</td></tr>
<tr><td><code>workerApp</code></td>
<td>
<p>the name of a function that will fire up a shiny webapp
for setting up a worker site for the particular computation</p>
</td></tr>
<tr><td><code>masterApp</code></td>
<td>
<p>the name of a function that will fire up a shiny webapp
for setting up a master for the particular computation</p>
</td></tr>
<tr><td><code>makeDefinition</code></td>
<td>
<p>the name of a function that will return a data frame
with appropriate fields needed to define the particular computation assuming
that they are populated in a global variable. This function is used by web
applications to construct a definition object based on inputs specified
by the users. Since the full information is often gathered incrementally by
several web applications, the inputs are set in a global variable and
therefore retrieved here using the function <code>getComputationInfo</code>
designed for the purpose</p>
</td></tr>
<tr><td><code>makeMaster</code></td>
<td>
<p>a function that will construct a master object for the
computation given the definition and a logical flag indicating
if debugging is desired</p>
</td></tr>
<tr><td><code>makeWorker</code></td>
<td>
<p>a function that will construct
a worker object for that computation given the definition and data</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+getComputationInfo">getComputationInfo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>availableComputations()
</code></pre>

<hr>
<h2 id='availableDataSources'>Return currently implemented data sources</h2><span id='topic+availableDataSources'></span>

<h3>Description</h3>

<p>The function <code>availableDataSources</code> returns the
currently implemented data sources such as CSV files, Redcap etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availableDataSources()
</code></pre>


<h3>Value</h3>

<p>a list of named arguments, each of which is another list, with
required fields named <code>desc</code>, a textual description and
<code>requiredPackages</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>availableDataSources()
</code></pre>

<hr>
<h2 id='CoxMaster'>Create a master object to control <code>CoxWorker</code> worker objects</h2><span id='topic+CoxMaster'></span>

<h3>Description</h3>

<p><code>CoxMaster</code> objects instantiate and run a distributed Cox model
computation fit
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CoxMaster-new"><code>CoxMaster$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxMaster-kosher"><code>CoxMaster$kosher()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxMaster-logLik"><code>CoxMaster$logLik()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxMaster-addSite"><code>CoxMaster$addSite()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxMaster-run"><code>CoxMaster$run()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxMaster-summary"><code>CoxMaster$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxMaster-clone"><code>CoxMaster$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CoxMaster-new"></a>



<h4>Method <code>new()</code></h4>

<p><code>CoxMaster</code> objects instantiate and run a distributed Cox model
computation fit
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxMaster$new(defn, debug = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>defn</code></dt><dd><p>a computation definition</p>
</dd>
<dt><code>debug</code></dt><dd><p>a flag for debugging, default <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>R6 <code>CoxMaster</code> object
</p>


<hr>
<a id="method-CoxMaster-kosher"></a>



<h4>Method <code>kosher()</code></h4>

<p>Check if inputs and state of object are sane. For future use
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxMaster$kosher()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<hr>
<a id="method-CoxMaster-logLik"></a>



<h4>Method <code>logLik()</code></h4>

<p>Return the partial log likelihood on all data for given <code>beta</code> parameter.
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxMaster$logLik(beta)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta</code></dt><dd><p>the parameter vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a named list with three components: <code>value</code> contains the value of the
log likelihood, <code>gradient</code> contains the score vector, and <code>hessian</code> contains
the estimated hessian matrix
</p>


<hr>
<a id="method-CoxMaster-addSite"></a>



<h4>Method <code>addSite()</code></h4>

<p>Add a url or worker object for a site for participating in the distributed computation. The worker object can be used to avoid complications in debugging remote calls during prototyping.
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxMaster$addSite(name, url = NULL, worker = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>of the site</p>
</dd>
<dt><code>url</code></dt><dd><p>web url of the site; exactly one of <code>url</code> or <code>worker</code> should be specified</p>
</dd>
<dt><code>worker</code></dt><dd><p>worker object for the site; exactly one of <code>url</code> or <code>worker</code> should be specified</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CoxMaster-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run the distributed Cox model fit and return the estimates
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxMaster$run(control = coxph.control())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>control</code></dt><dd><p>parameters, same as <code>survival::coxph.control()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a named list of <code>beta</code>, <code>var</code>, <code>gradient</code>, <code>iter</code>, and <code>returnCode</code>
#' @description ' Return the summary of fit as a data frame
</p>


<hr>
<a id="method-CoxMaster-summary"></a>



<h4>Method <code>summary()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CoxMaster$summary()</pre></div>



<h5>Returns</h5>

<p>a summary data frame columns for <code>coef</code>,
<code>exp(coef)</code>, ' standard error, z-score, and p-value for each
parameter in the model following the same format as the
<code>survival</code> package
</p>


<hr>
<a id="method-CoxMaster-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxMaster$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code>CoxWorker</code> which generates objects matched to such a master object
</p>

<hr>
<h2 id='CoxWorker'>R6 class for object to use as a worker with <code>CoxMaster</code> master objects</h2><span id='topic+CoxWorker'></span>

<h3>Description</h3>

<p><code>CoxWorker</code> objects are worker objects at each data site of
a distributed Cox model computation
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CoxWorker-new"><code>CoxWorker$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxWorker-getP"><code>CoxWorker$getP()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxWorker-getStateful"><code>CoxWorker$getStateful()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxWorker-logLik"><code>CoxWorker$logLik()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxWorker-var"><code>CoxWorker$var()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxWorker-kosher"><code>CoxWorker$kosher()</code></a>
</p>
</li>
<li> <p><a href="#method-CoxWorker-clone"><code>CoxWorker$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CoxWorker-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>CoxWorker</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxWorker$new(defn, data, stateful = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>defn</code></dt><dd><p>the computation definition</p>
</dd>
<dt><code>data</code></dt><dd><p>the local data</p>
</dd>
<dt><code>stateful</code></dt><dd><p>a boolean flag indicating if state needs to be preserved between REST calls</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new <code>CoxWorker</code> object
</p>


<hr>
<a id="method-CoxWorker-getP"></a>



<h4>Method <code>getP()</code></h4>

<p>Return the dimension of the parameter vector.
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxWorker$getP(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>other args ignored</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the dimension of the parameter vector
</p>


<hr>
<a id="method-CoxWorker-getStateful"></a>



<h4>Method <code>getStateful()</code></h4>

<p>Return the stateful status of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxWorker$getStateful()</pre></div>



<h5>Returns</h5>

<p>the stateful flag, <code>TRUE</code> or <code>FALSE</code>
</p>


<hr>
<a id="method-CoxWorker-logLik"></a>



<h4>Method <code>logLik()</code></h4>

<p>Return the partial log likelihood on local data for given <code>beta</code> parameter.
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxWorker$logLik(beta, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta</code></dt><dd><p>the parameter vector</p>
</dd>
<dt><code>...</code></dt><dd><p>further arguments, currently unused</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a named list with three components: <code>value</code> contains the value of the
log likelihood, <code>gradient</code> contains the score vector, and <code>hessian</code> contains
the estimated hessian matrix
</p>


<hr>
<a id="method-CoxWorker-var"></a>



<h4>Method <code>var()</code></h4>

<p>Return the variance of estimate for given <code>beta</code> parameter on local data.
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxWorker$var(beta, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta</code></dt><dd><p>the parameter vector</p>
</dd>
<dt><code>...</code></dt><dd><p>further arguments, currently unused</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>variance vector
</p>


<hr>
<a id="method-CoxWorker-kosher"></a>



<h4>Method <code>kosher()</code></h4>

<p>Check if inputs and state of object are sane. For future use
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxWorker$kosher()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<hr>
<a id="method-CoxWorker-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CoxWorker$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code>CoxMaster</code> which goes hand-in-hand with this object
</p>

<hr>
<h2 id='createHEWorkerInstance'>Given the definition identifier of an object, instantiate and store
object in workspace</h2><span id='topic+createHEWorkerInstance'></span>

<h3>Description</h3>

<p>The function <code>createHEWorkerInstance</code> uses a
definition identified by defnId to create the appropriate
object instance for HE computations. The instantiated object is
searched for in the instance path and loaded if already
present, otherwise it is created and assigned the instanceId
and saved under the dataFileName if the latter is specified.
This instantiated object may change state between iterations
when a computation executes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createHEWorkerInstance(
  defnId,
  instanceId,
  pubkey_bits = NULL,
  pubkey_n = NULL,
  den_bits = NULL,
  dataFileName = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createHEWorkerInstance_+3A_defnid">defnId</code></td>
<td>
<p>the identifier of an already defined computation</p>
</td></tr>
<tr><td><code id="createHEWorkerInstance_+3A_instanceid">instanceId</code></td>
<td>
<p>an indentifier to use for the created instance</p>
</td></tr>
<tr><td><code id="createHEWorkerInstance_+3A_pubkey_bits">pubkey_bits</code></td>
<td>
<p>number of bits for public key</p>
</td></tr>
<tr><td><code id="createHEWorkerInstance_+3A_pubkey_n">pubkey_n</code></td>
<td>
<p>the <code>n</code> for public key</p>
</td></tr>
<tr><td><code id="createHEWorkerInstance_+3A_den_bits">den_bits</code></td>
<td>
<p>the number of bits for the denominator</p>
</td></tr>
<tr><td><code id="createHEWorkerInstance_+3A_datafilename">dataFileName</code></td>
<td>
<p>a file name to use for saving the
data. Typically <code>NULL</code>, this is only needed when one is using a
single opencpu server to behave like multiple sites in which
case the data file name serves to distinguish the site-specific
data files.  When it is <code>NULL</code>, the data file name is taken
from the configuration settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if everything goes well
</p>


<h3>See Also</h3>

<p><code><a href="#topic+availableComputations">availableComputations()</a></code>
</p>

<hr>
<h2 id='createNCPInstance'>Given the definition identifier of an object, instantiate and store
object in workspace</h2><span id='topic+createNCPInstance'></span>

<h3>Description</h3>

<p>This function uses an identifier (<code>defnId</code>) to locate
a stored definition in the workspace to create the appropriate
object instance. The instantiated object is assigned the
instanceId and saved under the dataFileName if the latter is
not <code>NULL</code>.  This instantiated object may change state between
iterations when a computation executes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createNCPInstance(
  name,
  ncpId,
  instanceId,
  pubkey_bits,
  pubkey_n,
  den_bits,
  dataFileName = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createNCPInstance_+3A_name">name</code></td>
<td>
<p>identifying the NC party</p>
</td></tr>
<tr><td><code id="createNCPInstance_+3A_ncpid">ncpId</code></td>
<td>
<p>the id indicating the NCP definition</p>
</td></tr>
<tr><td><code id="createNCPInstance_+3A_instanceid">instanceId</code></td>
<td>
<p>an indentifier to use for the created instance</p>
</td></tr>
<tr><td><code id="createNCPInstance_+3A_pubkey_bits">pubkey_bits</code></td>
<td>
<p>the public key number of bits</p>
</td></tr>
<tr><td><code id="createNCPInstance_+3A_pubkey_n">pubkey_n</code></td>
<td>
<p>the pubkey n</p>
</td></tr>
<tr><td><code id="createNCPInstance_+3A_den_bits">den_bits</code></td>
<td>
<p>the denominator number of bits for for rational
approximations</p>
</td></tr>
<tr><td><code id="createNCPInstance_+3A_datafilename">dataFileName</code></td>
<td>
<p>a file name to use for saving the
data. Typically <code>NULL</code>, this is only needed when one is using a
single opencpu server to behave like multiple sites in which
case the data file name serves to distinguish the site-specific
data files.  When it is <code>NULL</code>, the data file name is taken
from the configuration settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if everything goes well
</p>

<hr>
<h2 id='createWorkerInstance'>Given the definition identifier of an object, instantiate and store object in workspace</h2><span id='topic+createWorkerInstance'></span>

<h3>Description</h3>

<p>The function <code>createWorkerInstance</code> uses a definition identified by
defnId to create the appropriate object instance. The instantiated object is assigned
the instanceId and saved under the dataFileName if the latter is specified.
This instantiated object may change state between iterations when a computation executes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createWorkerInstance(
  defnId,
  instanceId,
  pubkey_bits = NULL,
  pubkey_n = NULL,
  den_bits = NULL,
  dataFileName = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createWorkerInstance_+3A_defnid">defnId</code></td>
<td>
<p>the identifier of an already defined computation</p>
</td></tr>
<tr><td><code id="createWorkerInstance_+3A_instanceid">instanceId</code></td>
<td>
<p>an indentifier to use for the created instance</p>
</td></tr>
<tr><td><code id="createWorkerInstance_+3A_pubkey_bits">pubkey_bits</code></td>
<td>
<p>number of bits for public key</p>
</td></tr>
<tr><td><code id="createWorkerInstance_+3A_pubkey_n">pubkey_n</code></td>
<td>
<p>the <code>n</code> for public key</p>
</td></tr>
<tr><td><code id="createWorkerInstance_+3A_den_bits">den_bits</code></td>
<td>
<p>the number of bits for the denominator</p>
</td></tr>
<tr><td><code id="createWorkerInstance_+3A_datafilename">dataFileName</code></td>
<td>
<p>a file name to use for saving the data. Typically <code>NULL</code>, this
is only needed when one is using a single opencpu server to behave like multiple
sites in which case the data file name serves to distinguish the site-specific data files.
When it is <code>NULL</code>, the data file name is taken from the configuration settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if everything goes well
</p>


<h3>See Also</h3>

<p><code><a href="#topic+availableComputations">availableComputations()</a></code>
</p>

<hr>
<h2 id='dccoxph'>Functions copied and modified from survival package</h2><span id='topic+dccoxph'></span><span id='topic+dccoxph.fit'></span>

<h3>Description</h3>

<p>The distcomp package makes use of code from the survival package,
with the permission of the original authors. This includes R code as well as C code.
That is, the underlying Cox model code is derived from that in the R survival package.
The original copyrights are retained for these files and the notices preserved.
However, these are for internal use and future implementations may change how we use them.
In order to avoid confusion and any name collision, the names of these functions have
been modified to include a prefix &quot;dc&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dccoxph(
  formula,
  data,
  weights,
  subset,
  na.action,
  init,
  control,
  ties = c("efron", "breslow", "exact"),
  singular.ok = TRUE,
  robust = FALSE,
  model = FALSE,
  x = FALSE,
  y = TRUE,
  tt,
  method = ties,
  ...
)

dccoxph.fit(x, y, strata, offset, init, control, weights, method, rownames)
</code></pre>

<hr>
<h2 id='defineNewComputation'>Define a new computation</h2><span id='topic+defineNewComputation'></span>

<h3>Description</h3>

<p>This function just calls <code><a href="#topic+runDistcompApp">runDistcompApp()</a></code> with the
parameter &quot;definition&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineNewComputation()
</code></pre>


<h3>Value</h3>

<p>the results of running the web application
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runDistcompApp">runDistcompApp()</a></code>
</p>

<hr>
<h2 id='destroyInstanceObject'>Destroy an instance object given its identifier</h2><span id='topic+destroyInstanceObject'></span>

<h3>Description</h3>

<p>The function <code>destroyInstanceObject</code> deletes an object associated
with the instanceId. This is typically done after a computation completes and results
have been obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>destroyInstanceObject(instanceId)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="destroyInstanceObject_+3A_instanceid">instanceId</code></td>
<td>
<p>the id of the object to destroy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if everything goes well
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createWorkerInstance">createWorkerInstance()</a></code>
</p>

<hr>
<h2 id='distcomp'>Distributed Computing with R</h2><span id='topic+distcomp'></span>

<h3>Description</h3>

<p><code>distcomp</code> is a collection of methods to fit models to data that may be
distributed at various sites. The package arose as a way of addressing the
issues regarding data aggregation; by allowing sites to have control over
local data and transmitting only summaries, some privacy controls can be
maintained. Even when participants have no objections in principle to data
aggregation, it may still be useful to keep data local and expose just the
computations. For further details, please see the reference cited below.
</p>


<h3>Details</h3>

<p>The initial implementation consists of a stratified Cox model fit with
distributed survival data and a Singular Value Decomposition
of a distributed matrix. General Linear Models will soon be added.
Although some sanity checks and balances are present, many more are needed
to make this truly robust. We also hope that other methods will be added by users.
</p>
<p>We make the following assumptions in the implementation:
(a) the aggregate data is logically a stacking of data at each site, i.e.,
the full data is row-partitioned into sites where the rows are observations;
(b) Each site has the package <code>distcomp</code> installed and a workspace setup
for (writeable) use by the <code>opencpu</code> server
(see <code><a href="#topic+distcompSetup">distcompSetup()</a></code>; and (c) each site is exposing <code>distcomp</code>
via an <code>opencpu</code> server.
</p>
<p>The main computation happens via a master process, a script of R code,
that makes calls to <code>distcomp</code> functions at worker sites via <code>opencpu</code>.
The use of <code>opencpu</code> allows developers to prototype their distributed implementations
on a local machine using the <code>opencpu</code> package that runs such a server locally
using <code>localhost</code> ports.
</p>
<p>Note that <code>distcomp</code> computations are not intended for speed/efficiency;
indeed, they are orders of magnitude slower. However, the models that are fit are
not meant to be recomputed often. These and other details are discussed in the
paper mentioned above.
</p>
<p>The current implementation, particularly the Stratified Cox Model, makes direct use of
code from <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>. That is, the underlying Cox model code is
derived from that in the R <code>survival</code> survival package.
</p>
<p>For an understanding of how this package is meant to be used, please see the documented
examples and the reference.
</p>


<h3>References</h3>

<p>Software for Distributed Computation on Medical Databases:
A Demonstration Project. Journal of Statistical Software, 77(13), 1-22.
doi:10.18637/jss.v077.i13
</p>
<p>Appendix E of Modeling Survival Data: Extending the Cox Model by
Terry M. Therneau and Patricia Grambsch. Springer Verlag, 2000.
</p>


<h3>See Also</h3>

<p>The examples in <code>system.file("doc", "examples.html", package="distcomp")</code>
</p>
<p>The source for the examples: <code>system.file("doc_src", "examples.Rmd", package="distcomp")</code>.
</p>

<hr>
<h2 id='distcompSetup'>Setup a workspace and configuration for a distributed computation</h2><span id='topic+distcompSetup'></span>

<h3>Description</h3>

<p>The function <code>distcompSetup</code> sets up a distributed computation
and configures some global parameters such as definition file names,
data file names, instance object file names, and ssl configuration parameters. The
function creates some of necessary subdirectories if not already present and throws
an error if the workspace areas are not writeable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distcompSetup(
  workspacePath = "",
  defnPath = paste(workspacePath, "defn", sep = .Platform$file.sep),
  instancePath = paste(workspacePath, "instances", sep = .Platform$file.sep),
  defnFileName = "defn.rds",
  dataFileName = "data.rds",
  instanceFileName = "instance.rds",
  resultsCacheFileName = "results_cache.rds",
  ssl_verifyhost = 1L,
  ssl_verifypeer = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distcompSetup_+3A_workspacepath">workspacePath</code></td>
<td>
<p>a folder specifying the workspace path. This
has to be writable by the opencpu process. On a cloud opencpu
server on Ubuntu, for example, this requires a one-time
modification of apparmor profiles to enable write permissions
to this path</p>
</td></tr>
<tr><td><code id="distcompSetup_+3A_defnpath">defnPath</code></td>
<td>
<p>the path where definition files will reside,
organized by computation identifiers</p>
</td></tr>
<tr><td><code id="distcompSetup_+3A_instancepath">instancePath</code></td>
<td>
<p>the path where instance objects will reside</p>
</td></tr>
<tr><td><code id="distcompSetup_+3A_defnfilename">defnFileName</code></td>
<td>
<p>the name for the compdef definition files</p>
</td></tr>
<tr><td><code id="distcompSetup_+3A_datafilename">dataFileName</code></td>
<td>
<p>the name for the data files</p>
</td></tr>
<tr><td><code id="distcompSetup_+3A_instancefilename">instanceFileName</code></td>
<td>
<p>the name for the instance files</p>
</td></tr>
<tr><td><code id="distcompSetup_+3A_resultscachefilename">resultsCacheFileName</code></td>
<td>
<p>the name for the instance results cache files for HE computations</p>
</td></tr>
<tr><td><code id="distcompSetup_+3A_ssl_verifyhost">ssl_verifyhost</code></td>
<td>
<p>integer value, usually <code>1L</code>, but for
testing with snake-oil certs, one might set this to <code>0L</code></p>
</td></tr>
<tr><td><code id="distcompSetup_+3A_ssl_verifypeer">ssl_verifypeer</code></td>
<td>
<p>integer value, usually <code>1L</code>, but for
testing with snake-oil certs, one might set this to <code>0L</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if all is well
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getConfig">getConfig()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
distcompSetup(workspacePath="./workspace")

## End(Not run)
</code></pre>

<hr>
<h2 id='executeHEMethod'>Given the id of a serialized object, invoke a method on the object
with arguments using homomorphic encryption</h2><span id='topic+executeHEMethod'></span>

<h3>Description</h3>

<p>The function <code>executeHEMethod</code> is a homomorphic
encryption wrapper around <code>executeMethod</code>. It ensures any
returned result is encrypted using the homomorphic encryption
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>executeHEMethod(objectId, method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="executeHEMethod_+3A_objectid">objectId</code></td>
<td>
<p>the (instance) identifier of the object on which to
invoke a method</p>
</td></tr>
<tr><td><code id="executeHEMethod_+3A_method">method</code></td>
<td>
<p>the name of the method to invoke</p>
</td></tr>
<tr><td><code id="executeHEMethod_+3A_...">...</code></td>
<td>
<p>further arguments as appropriate for the method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing an integer and a fractional result converted to characters
</p>

<hr>
<h2 id='executeMethod'>Given the id of a serialized object, invoke a method on the object
with arguments</h2><span id='topic+executeMethod'></span>

<h3>Description</h3>

<p>The function <code>executeMethod</code> is really the heart of
distcomp.  It executes an arbitrary method on an object that
has been serialized to the distcomp workspace with any
specified arguments. The result, which is dependent on the
computation that is executed, is returned. If the object needs
to save state between iterations on it, it is automatically
serialized back for the ensuing iterations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>executeMethod(objectId, method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="executeMethod_+3A_objectid">objectId</code></td>
<td>
<p>the (instance) identifier of the object on which to invoke a method</p>
</td></tr>
<tr><td><code id="executeMethod_+3A_method">method</code></td>
<td>
<p>the name of the method to invoke</p>
</td></tr>
<tr><td><code id="executeMethod_+3A_...">...</code></td>
<td>
<p>further arguments as appropriate for the method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a result that depends on the computation being executed
</p>

<hr>
<h2 id='generateId'>Generate an identifier for an object</h2><span id='topic+generateId'></span>

<h3>Description</h3>

<p>A hash is generated based on the contents of the object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateId(object, algo = "xxhash64")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateId_+3A_object">object</code></td>
<td>
<p>the object for which a hash is desired</p>
</td></tr>
<tr><td><code id="generateId_+3A_algo">algo</code></td>
<td>
<p>the algorithm to use, default is &quot;xxhash64&quot; from
<code><a href="digest.html#topic+digest">digest::digest()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the hash as a string
</p>


<h3>See Also</h3>

<p><code><a href="digest.html#topic+digest">digest::digest()</a></code>
</p>

<hr>
<h2 id='getComputationInfo'>Get the value of a variable from the global store</h2><span id='topic+getComputationInfo'></span>

<h3>Description</h3>

<p>In distcomp, several web applications need to communicate
between themselves. Since only one application is expected to be
active at any time, they do so via a global store, essentially a hash table.
This function retrieves the value of a name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getComputationInfo(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getComputationInfo_+3A_name">name</code></td>
<td>
<p>the name for the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value for the variable, <code>NULL</code> if not set
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setComputationInfo">setComputationInfo()</a></code>
</p>

<hr>
<h2 id='getConfig'>Return the workspace and configuration setup values</h2><span id='topic+getConfig'></span>

<h3>Description</h3>

<p>The function <code>getConfig</code> returns the values of the
configuration parameters set up by <code>distcompSetup</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConfig(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConfig_+3A_...">...</code></td>
<td>
<p>any further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list consisting of
</p>
<table>
<tr><td><code>workspacePath</code></td>
<td>
<p>a folder specifying the workspace path. This has to be
writable by the opencpu process. On a cloud opencpu server on Ubuntu, for example,
this requires a one-time modification of apparmor profiles to enable write
permissions to this path</p>
</td></tr>
<tr><td><code>defnPath</code></td>
<td>
<p>the path where definition files will reside, organized by
computation identifiers</p>
</td></tr>
<tr><td><code>instancePath</code></td>
<td>
<p>the path where instance objects will reside</p>
</td></tr>
<tr><td><code>defnFileName</code></td>
<td>
<p>the name for the compdef definition files</p>
</td></tr>
<tr><td><code>dataFileName</code></td>
<td>
<p>the name for the data files</p>
</td></tr>
<tr><td><code>instanceFileName</code></td>
<td>
<p>the name for the instance files</p>
</td></tr>
<tr><td><code>ssl_verifyhost</code></td>
<td>
<p>integer value, usually <code>1L</code>, but for testing with
snake-oil certs, one might set this to <code>0L</code></p>
</td></tr>
<tr><td><code>ssl_verifypeer</code></td>
<td>
<p>integer value, usually <code>1L</code>, but for testing with
snake-oil certs, one might set this to <code>0L</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+distcompSetup">distcompSetup()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getConfig()

## End(Not run)
</code></pre>

<hr>
<h2 id='HEMaster'>Create a HEMaster process for use in a distributed homomorphic
encrypted (HE) computation</h2><span id='topic+HEMaster'></span>

<h3>Description</h3>

<p><code>HEMaster</code> objects run a distributed computation based
upon a definition file that encapsulates all information
necessary to perform a computation. A master makes use of two
non-cooperating parties which communicate with sites that
perform the actual computations using local data.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>den</code></dt><dd><p>denominator for rational arithmetic</p>
</dd>
<dt><code>den_bits</code></dt><dd><p>number of bits for denominator for rational arithmetic</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HEMaster-new"><code>HEMaster$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HEMaster-getNC_party"><code>HEMaster$getNC_party()</code></a>
</p>
</li>
<li> <p><a href="#method-HEMaster-getPubkey"><code>HEMaster$getPubkey()</code></a>
</p>
</li>
<li> <p><a href="#method-HEMaster-addNCP"><code>HEMaster$addNCP()</code></a>
</p>
</li>
<li> <p><a href="#method-HEMaster-run"><code>HEMaster$run()</code></a>
</p>
</li>
<li> <p><a href="#method-HEMaster-clone"><code>HEMaster$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HEMaster-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>HEMaster</code> object to run homomorphic encrypted computation
</p>


<h5>Usage</h5>

<div class="r"><pre>HEMaster$new(defn)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>defn</code></dt><dd><p>the homomorphic computation definition</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <code>HEMaster</code> object
</p>


<hr>
<a id="method-HEMaster-getNC_party"></a>



<h4>Method <code>getNC_party()</code></h4>

<p>Return a list of noncooperating parties (NCPs)
</p>


<h5>Usage</h5>

<div class="r"><pre>HEMaster$getNC_party()</pre></div>



<h5>Returns</h5>

<p>a named list of length 2 of noncooperating party information
</p>


<hr>
<a id="method-HEMaster-getPubkey"></a>



<h4>Method <code>getPubkey()</code></h4>

<p>Return the public key from the public private key pair
</p>


<h5>Usage</h5>

<div class="r"><pre>HEMaster$getPubkey()</pre></div>



<h5>Returns</h5>

<p>an R6 <code>Pubkey</code> object
</p>


<hr>
<a id="method-HEMaster-addNCP"></a>



<h4>Method <code>addNCP()</code></h4>

<p>Add a noncooperating party to this master either using a url or an object in session for prototyping
</p>


<h5>Usage</h5>

<div class="r"><pre>HEMaster$addNCP(ncp_defn, url = NULL, ncpWorker = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ncp_defn</code></dt><dd><p>the definition of the NCP</p>
</dd>
<dt><code>url</code></dt><dd><p>the url for the NCP; only one of url and ncpWorker should be non-null</p>
</dd>
<dt><code>ncpWorker</code></dt><dd><p>an instantiated worker object; only one of url and ncpWorker should be non-null</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HEMaster-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run a distributed homomorphic encrypted computation and return the result
</p>


<h5>Usage</h5>

<div class="r"><pre>HEMaster$run(debug = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>debug</code></dt><dd><p>a flag for debugging, default <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the result of the distributed homomorphic computation
</p>


<hr>
<a id="method-HEMaster-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HEMaster$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+NCP">NCP()</a></code>
</p>

<hr>
<h2 id='HEQueryCountMaster'>Create a homomorphic computation query count master object to employ worker objects generated by <code><a href="#topic+HEQueryCountWorker">HEQueryCountWorker()</a></code></h2><span id='topic+HEQueryCountMaster'></span>

<h3>Description</h3>

<p><code>HEQueryCountMaster</code> objects instantiate and run a distributed homomorphic query count computation; they're instantiated by non-cooperating parties (NCPs)
</p>


<h3>Super class</h3>

<p><code>distcomp::QueryCountMaster</code> -&gt; <code>HEQueryCountMaster</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>pubkey</code></dt><dd><p>the master's public key visible to everyone</p>
</dd>
<dt><code>pubkey_bits</code></dt><dd><p>the number of bits in the public key (used for reconstructing public key remotely by serializing to character)</p>
</dd>
<dt><code>pubkey_n</code></dt><dd><p>the <code>n</code> for the public key used for reconstructing public key remotely</p>
</dd>
<dt><code>den</code></dt><dd><p>the denominator for rational arithmetic</p>
</dd>
<dt><code>den_bits</code></dt><dd><p>the number of bits in the denominator used for reconstructing denominator remotely</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HEQueryCountMaster-new"><code>HEQueryCountMaster$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HEQueryCountMaster-setParams"><code>HEQueryCountMaster$setParams()</code></a>
</p>
</li>
<li> <p><a href="#method-HEQueryCountMaster-kosher"><code>HEQueryCountMaster$kosher()</code></a>
</p>
</li>
<li> <p><a href="#method-HEQueryCountMaster-queryCount"><code>HEQueryCountMaster$queryCount()</code></a>
</p>
</li>
<li> <p><a href="#method-HEQueryCountMaster-cleanup"><code>HEQueryCountMaster$cleanup()</code></a>
</p>
</li>
<li> <p><a href="#method-HEQueryCountMaster-run"><code>HEQueryCountMaster$run()</code></a>
</p>
</li>
<li> <p><a href="#method-HEQueryCountMaster-clone"><code>HEQueryCountMaster$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="distcomp" data-topic="QueryCountMaster" data-id="addSite"><a href='../../distcomp/html/QueryCountMaster.html#method-QueryCountMaster-addSite'><code>distcomp::QueryCountMaster$addSite()</code></a></span></li>
<li><span class="pkg-link" data-pkg="distcomp" data-topic="QueryCountMaster" data-id="getSites"><a href='../../distcomp/html/QueryCountMaster.html#method-QueryCountMaster-getSites'><code>distcomp::QueryCountMaster$getSites()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-HEQueryCountMaster-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>HEQueryCountMaster</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>HEQueryCountMaster$new(defn, partyNumber, debug = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>defn</code></dt><dd><p>the computation definition</p>
</dd>
<dt><code>partyNumber</code></dt><dd><p>the party number of the NCP that this object belongs to (1 or 2)</p>
</dd>
<dt><code>debug</code></dt><dd><p>a flag for debugging, default <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new <code>HEQueryCountMaster</code> object
</p>


<hr>
<a id="method-HEQueryCountMaster-setParams"></a>



<h4>Method <code>setParams()</code></h4>

<p>Set some parameters of the <code>HEQueryCountMaster</code> object for homomorphic computations
</p>


<h5>Usage</h5>

<div class="r"><pre>HEQueryCountMaster$setParams(pubkey_bits, pubkey_n, den_bits)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pubkey_bits</code></dt><dd><p>the number of bits in public key</p>
</dd>
<dt><code>pubkey_n</code></dt><dd><p>the <code>n</code> for the public key</p>
</dd>
<dt><code>den_bits</code></dt><dd><p>the number of bits in the denominator (power of 2) used in rational approximations</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HEQueryCountMaster-kosher"></a>



<h4>Method <code>kosher()</code></h4>

<p>Check if inputs and state of object are sane. For future use
</p>


<h5>Usage</h5>

<div class="r"><pre>HEQueryCountMaster$kosher()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<hr>
<a id="method-HEQueryCountMaster-queryCount"></a>



<h4>Method <code>queryCount()</code></h4>

<p>Run the distributed query count, associate it with a token, and return the result
</p>


<h5>Usage</h5>

<div class="r"><pre>HEQueryCountMaster$queryCount(token)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>a token to use as key</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the partial result as a list of encrypted items with components <code>int</code> and <code>frac</code>
</p>


<hr>
<a id="method-HEQueryCountMaster-cleanup"></a>



<h4>Method <code>cleanup()</code></h4>

<p>Cleanup the instance objects
</p>


<h5>Usage</h5>

<div class="r"><pre>HEQueryCountMaster$cleanup()</pre></div>


<hr>
<a id="method-HEQueryCountMaster-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run the homomorphic encrypted distributed query count computation
</p>


<h5>Usage</h5>

<div class="r"><pre>HEQueryCountMaster$run(token)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>a token to use as key</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the partial result as a list of encrypted items with components <code>int</code> and <code>frac</code>
</p>


<hr>
<a id="method-HEQueryCountMaster-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HEQueryCountMaster$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+HEQueryCountWorker">HEQueryCountWorker()</a></code> which goes hand-in-hand with this object
</p>

<hr>
<h2 id='HEQueryCountWorker'>Create a homomorphic computation query count worker object for use with master objects generated by <code><a href="#topic+HEQueryCountMaster">HEQueryCountMaster()</a></code></h2><span id='topic+HEQueryCountWorker'></span>

<h3>Description</h3>

<p><code>HEQueryCountWorker</code> objects are worker objects at each site of
a distributed query count model computation using homomorphic encryption
</p>


<h3>Super class</h3>

<p><code>distcomp::QueryCountWorker</code> -&gt; <code>HEQueryCountWorker</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>pubkey</code></dt><dd><p>the master's public key visible to everyone</p>
</dd>
<dt><code>den</code></dt><dd><p>the denominator for rational arithmetic</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HEQueryCountWorker-new"><code>HEQueryCountWorker$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HEQueryCountWorker-setParams"><code>HEQueryCountWorker$setParams()</code></a>
</p>
</li>
<li> <p><a href="#method-HEQueryCountWorker-queryCount"><code>HEQueryCountWorker$queryCount()</code></a>
</p>
</li>
<li> <p><a href="#method-HEQueryCountWorker-clone"><code>HEQueryCountWorker$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="distcomp" data-topic="QueryCountWorker" data-id="getStateful"><a href='../../distcomp/html/QueryCountWorker.html#method-QueryCountWorker-getStateful'><code>distcomp::QueryCountWorker$getStateful()</code></a></span></li>
<li><span class="pkg-link" data-pkg="distcomp" data-topic="QueryCountWorker" data-id="kosher"><a href='../../distcomp/html/QueryCountWorker.html#method-QueryCountWorker-kosher'><code>distcomp::QueryCountWorker$kosher()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-HEQueryCountWorker-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>HEQueryMaster</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>HEQueryCountWorker$new(
  defn,
  data,
  pubkey_bits = NULL,
  pubkey_n = NULL,
  den_bits = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>defn</code></dt><dd><p>the computation definition</p>
</dd>
<dt><code>data</code></dt><dd><p>the data which is usually the list of sites</p>
</dd>
<dt><code>pubkey_bits</code></dt><dd><p>the number of bits in public key</p>
</dd>
<dt><code>pubkey_n</code></dt><dd><p>the <code>n</code> for the public key</p>
</dd>
<dt><code>den_bits</code></dt><dd><p>the number of bits in the denominator (power of 2) used in rational approximations</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new <code>HEQueryMaster</code> object
</p>


<hr>
<a id="method-HEQueryCountWorker-setParams"></a>



<h4>Method <code>setParams()</code></h4>

<p>Set some parameters for homomorphic computations
</p>


<h5>Usage</h5>

<div class="r"><pre>HEQueryCountWorker$setParams(pubkey_bits, pubkey_n, den_bits)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pubkey_bits</code></dt><dd><p>the number of bits in public key</p>
</dd>
<dt><code>pubkey_n</code></dt><dd><p>the <code>n</code> for the public key</p>
</dd>
<dt><code>den_bits</code></dt><dd><p>the number of bits in the denominator (power of 2) used in rational approximations</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HEQueryCountWorker-queryCount"></a>



<h4>Method <code>queryCount()</code></h4>

<p>Run the query count on local data and return the appropriate encrypted result to the party
</p>


<h5>Usage</h5>

<div class="r"><pre>HEQueryCountWorker$queryCount(partyNumber, token)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>partyNumber</code></dt><dd><p>the NCP party number (1 or 2)</p>
</dd>
<dt><code>token</code></dt><dd><p>a token to use for identifying parts of the same computation for NCP1 and NCP2</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the count as a list of encrypted items with components <code>int</code> and <code>frac</code>
</p>


<hr>
<a id="method-HEQueryCountWorker-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HEQueryCountWorker$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+HEQueryCountMaster">HEQueryCountMaster()</a></code> which goes hand-in-hand with this object
</p>

<hr>
<h2 id='makeDefinition'>Make a computation definition given the computation type</h2><span id='topic+makeDefinition'></span>

<h3>Description</h3>

<p>The function <code>makeDefinition</code> returns a computational
definition based on current inputs (from the global store) given a
canonical computation type tag. This is a utility function for web
applications to use as input is being gathered
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDefinition(compType)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDefinition_+3A_comptype">compType</code></td>
<td>
<p>the canonical computation type tag</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame corresponding to the computation type
</p>


<h3>See Also</h3>

<p><code><a href="#topic+availableComputations">availableComputations()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
makeDefinition(names(availableComputations())[1])

## End(Not run)
</code></pre>

<hr>
<h2 id='makeHEMaster'>Instantiate a master process for HE operations</h2><span id='topic+makeHEMaster'></span>

<h3>Description</h3>

<p>Instantiate a master process for HE operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeHEMaster(defn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeHEMaster_+3A_defn">defn</code></td>
<td>
<p>the computation definition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an master object for HE operations
</p>

<hr>
<h2 id='makeMaster'>Make a master object given a definition</h2><span id='topic+makeMaster'></span>

<h3>Description</h3>

<p>The function <code>makeMaster</code> returns a master object
corresponding to the definition. The types of master objects
that can be created depend upon the available computations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMaster(defn, partyNumber = NULL, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMaster_+3A_defn">defn</code></td>
<td>
<p>the computation definition</p>
</td></tr>
<tr><td><code id="makeMaster_+3A_partynumber">partyNumber</code></td>
<td>
<p>the number of the noncooperating party, which
can be optionally set if HE is desired</p>
</td></tr>
<tr><td><code id="makeMaster_+3A_debug">debug</code></td>
<td>
<p>a debug flag</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a master object of the appropriate class based on the
definition
</p>


<h3>See Also</h3>

<p><code><a href="#topic+availableComputations">availableComputations()</a></code>
</p>

<hr>
<h2 id='makeNCP'>Instantiate an noncooperating party</h2><span id='topic+makeNCP'></span>

<h3>Description</h3>

<p>Instantiate an noncooperating party
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeNCP(
  ncp_defn,
  comp_defn,
  sites = list(),
  pubkey_bits = NULL,
  pubkey_n = NULL,
  den_bits = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeNCP_+3A_ncp_defn">ncp_defn</code></td>
<td>
<p>the NCP definition</p>
</td></tr>
<tr><td><code id="makeNCP_+3A_comp_defn">comp_defn</code></td>
<td>
<p>the computation definition</p>
</td></tr>
<tr><td><code id="makeNCP_+3A_sites">sites</code></td>
<td>
<p>a list of sites each entry a named list of name, url, worker</p>
</td></tr>
<tr><td><code id="makeNCP_+3A_pubkey_bits">pubkey_bits</code></td>
<td>
<p>number of bits for public key</p>
</td></tr>
<tr><td><code id="makeNCP_+3A_pubkey_n">pubkey_n</code></td>
<td>
<p>the n for the public key</p>
</td></tr>
<tr><td><code id="makeNCP_+3A_den_bits">den_bits</code></td>
<td>
<p>the log to base 2 of the denominator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an NCP object
</p>

<hr>
<h2 id='makeWorker'>Make a worker object given a definition and data</h2><span id='topic+makeWorker'></span>

<h3>Description</h3>

<p>The function <code>makeWorker</code> returns an object of the
appropriate type based on a computation definition and sets the
data for the object. The types of objects that can be created
depend upon the available computations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWorker(defn, data, pubkey_bits = NULL, pubkey_n = NULL, den_bits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWorker_+3A_defn">defn</code></td>
<td>
<p>the computation definition</p>
</td></tr>
<tr><td><code id="makeWorker_+3A_data">data</code></td>
<td>
<p>the data for the computation</p>
</td></tr>
<tr><td><code id="makeWorker_+3A_pubkey_bits">pubkey_bits</code></td>
<td>
<p>the number of bits for the public key (used only
if <code>he</code> is <code>TRUE</code> in computation definition)</p>
</td></tr>
<tr><td><code id="makeWorker_+3A_pubkey_n">pubkey_n</code></td>
<td>
<p>the <code>n</code> for public key (used only if <code>he</code> is <code>TRUE</code>
in computation definition)</p>
</td></tr>
<tr><td><code id="makeWorker_+3A_den_bits">den_bits</code></td>
<td>
<p>the number of bits for the denominator (used only
if <code>he</code> is <code>TRUE</code> in computation definition)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a worker object of the appropriate class based on the
definition
</p>


<h3>See Also</h3>

<p><code><a href="#topic+availableComputations">availableComputations()</a></code>
</p>

<hr>
<h2 id='NCP'>R6 object to use as non-cooperating party in a distributed homomorphic computation</h2><span id='topic+NCP'></span>

<h3>Description</h3>

<p><code>NCP</code> objects are worker objects that separate a
master process from communicating directly with the worker
processes. Typically two such are needed for a distributed
homomorphic computation. A master process can communicate with
<code>NCP</code> objects and the <code>NCP</code> objects can communicate
with worker processes. However, the two <code>NCP</code> objects,
designated by numbers 1 and 2, are non-cooperating in the sense
that they don't communicate with each other and are isolated
from each other.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>pubkey</code></dt><dd><p>the master's public key visible to everyone</p>
</dd>
<dt><code>pubkey_bits</code></dt><dd><p>the number of bits in the public key (used for reconstructing public key remotely by serializing to character)</p>
</dd>
<dt><code>pubkey_n</code></dt><dd><p>the <code>n</code> for the public key used for reconstructing public key remotely</p>
</dd>
<dt><code>den</code></dt><dd><p>the denominator for rational arithmetic</p>
</dd>
<dt><code>den_bits</code></dt><dd><p>the number of bits in the denominator used for reconstructing denominator remotely</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NCP-new"><code>NCP$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NCP-getStateful"><code>NCP$getStateful()</code></a>
</p>
</li>
<li> <p><a href="#method-NCP-setParams"><code>NCP$setParams()</code></a>
</p>
</li>
<li> <p><a href="#method-NCP-getSites"><code>NCP$getSites()</code></a>
</p>
</li>
<li> <p><a href="#method-NCP-setSites"><code>NCP$setSites()</code></a>
</p>
</li>
<li> <p><a href="#method-NCP-addSite"><code>NCP$addSite()</code></a>
</p>
</li>
<li> <p><a href="#method-NCP-cleanupInstance"><code>NCP$cleanupInstance()</code></a>
</p>
</li>
<li> <p><a href="#method-NCP-run"><code>NCP$run()</code></a>
</p>
</li>
<li> <p><a href="#method-NCP-clone"><code>NCP$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-NCP-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>NCP</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>NCP$new(
  ncp_defn,
  comp_defn,
  sites = list(),
  pubkey_bits = NULL,
  pubkey_n = NULL,
  den_bits = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ncp_defn</code></dt><dd><p>the NCP definition; see example</p>
</dd>
<dt><code>comp_defn</code></dt><dd><p>the computation definition</p>
</dd>
<dt><code>sites</code></dt><dd><p>list of sites</p>
</dd>
<dt><code>pubkey_bits</code></dt><dd><p>the number of bits in public key</p>
</dd>
<dt><code>pubkey_n</code></dt><dd><p>the <code>n</code> for the public key</p>
</dd>
<dt><code>den_bits</code></dt><dd><p>the number of bits in the denominator (power of 2) used in rational approximations</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new <code>NCP</code> object
</p>


<hr>
<a id="method-NCP-getStateful"></a>



<h4>Method <code>getStateful()</code></h4>

<p>Retrieve the value of the <code>stateful</code> field
</p>


<h5>Usage</h5>

<div class="r"><pre>NCP$getStateful()</pre></div>


<hr>
<a id="method-NCP-setParams"></a>



<h4>Method <code>setParams()</code></h4>

<p>Set some parameters of the <code>NCP</code> object for homomorphic computations
</p>


<h5>Usage</h5>

<div class="r"><pre>NCP$setParams(pubkey_bits, pubkey_n, den_bits)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pubkey_bits</code></dt><dd><p>the number of bits in public key</p>
</dd>
<dt><code>pubkey_n</code></dt><dd><p>the <code>n</code> for the public key</p>
</dd>
<dt><code>den_bits</code></dt><dd><p>the number of bits in the denominator (power of 2) used in rational approximations</p>
</dd>
</dl>

</div>


<hr>
<a id="method-NCP-getSites"></a>



<h4>Method <code>getSites()</code></h4>

<p>Retrieve the value of the private <code>sites</code> field
</p>


<h5>Usage</h5>

<div class="r"><pre>NCP$getSites()</pre></div>


<hr>
<a id="method-NCP-setSites"></a>



<h4>Method <code>setSites()</code></h4>

<p>Set the value of the private <code>sites</code> field
</p>


<h5>Usage</h5>

<div class="r"><pre>NCP$setSites(sites)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sites</code></dt><dd><p>the list of sites</p>
</dd>
</dl>

</div>


<hr>
<a id="method-NCP-addSite"></a>



<h4>Method <code>addSite()</code></h4>

<p>Add a url or worker object for a site for participating in the distributed computation. The worker object can be used to avoid complications in debugging remote calls during prototyping.
</p>


<h5>Usage</h5>

<div class="r"><pre>NCP$addSite(name, url = NULL, worker = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>of the site</p>
</dd>
<dt><code>url</code></dt><dd><p>web url of the site; exactly one of <code>url</code> or <code>worker</code> should be specified</p>
</dd>
<dt><code>worker</code></dt><dd><p>worker object for the site; exactly one of <code>url</code> or <code>worker</code> should be specified</p>
</dd>
</dl>

</div>


<hr>
<a id="method-NCP-cleanupInstance"></a>



<h4>Method <code>cleanupInstance()</code></h4>

<p>Clean up by destroying instance objects created in workspace.
</p>


<h5>Usage</h5>

<div class="r"><pre>NCP$cleanupInstance(token)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>the token for the instance</p>
</dd>
</dl>

</div>


<hr>
<a id="method-NCP-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run the distributed homomorphic computation
</p>


<h5>Usage</h5>

<div class="r"><pre>NCP$run(token)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>token</code></dt><dd><p>a unique token for the run, used to ensure that correct parts of cached results are returned appropriately</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the result of the computation
</p>


<hr>
<a id="method-NCP-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NCP$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='QueryCountMaster'>Create a master object to control worker objects generated by <code><a href="#topic+QueryCountWorker">QueryCountWorker()</a></code></h2><span id='topic+QueryCountMaster'></span>

<h3>Description</h3>

<p><code>QueryCountMaster</code> objects instantiate and run a distributed query count computation
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-QueryCountMaster-new"><code>QueryCountMaster$new()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryCountMaster-kosher"><code>QueryCountMaster$kosher()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryCountMaster-queryCount"><code>QueryCountMaster$queryCount()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryCountMaster-getSites"><code>QueryCountMaster$getSites()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryCountMaster-addSite"><code>QueryCountMaster$addSite()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryCountMaster-run"><code>QueryCountMaster$run()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryCountMaster-clone"><code>QueryCountMaster$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-QueryCountMaster-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>QueryCountMaster</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountMaster$new(defn, debug = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>defn</code></dt><dd><p>the computation definition</p>
</dd>
<dt><code>debug</code></dt><dd><p>a flag for debugging, default <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new <code>QueryCountMaster</code> object
</p>


<hr>
<a id="method-QueryCountMaster-kosher"></a>



<h4>Method <code>kosher()</code></h4>

<p>Check if inputs and state of object are sane. For future use
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountMaster$kosher()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<hr>
<a id="method-QueryCountMaster-queryCount"></a>



<h4>Method <code>queryCount()</code></h4>

<p>Run the distributed query count and return the result
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountMaster$queryCount()</pre></div>



<h5>Returns</h5>

<p>the count
</p>


<hr>
<a id="method-QueryCountMaster-getSites"></a>



<h4>Method <code>getSites()</code></h4>

<p>Retrieve the value of the private <code>sites</code> field
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountMaster$getSites()</pre></div>


<hr>
<a id="method-QueryCountMaster-addSite"></a>



<h4>Method <code>addSite()</code></h4>

<p>Add a url or worker object for a site for participating in the distributed computation. The worker object can be used to avoid complications in debugging remote calls during prototyping.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountMaster$addSite(name, url = NULL, worker = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>of the site</p>
</dd>
<dt><code>url</code></dt><dd><p>web url of the site; exactly one of <code>url</code> or <code>worker</code> should be specified</p>
</dd>
<dt><code>worker</code></dt><dd><p>worker object for the site; exactly one of <code>url</code> or <code>worker</code> should be specified</p>
</dd>
</dl>

</div>


<hr>
<a id="method-QueryCountMaster-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run the distributed query count
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountMaster$run()</pre></div>



<h5>Returns</h5>

<p>the count
</p>


<hr>
<a id="method-QueryCountMaster-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountMaster$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+QueryCountWorker">QueryCountWorker()</a></code> which goes hand-in-hand with this object
</p>

<hr>
<h2 id='QueryCountWorker'>R6 worker object for use as a worker with master objects generated by <code><a href="#topic+QueryCountMaster">QueryCountMaster()</a></code></h2><span id='topic+QueryCountWorker'></span>

<h3>Description</h3>

<p><code>QueryCountWorker</code> objects are worker objects at each site of
a distributed QueryCount model computation
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-QueryCountWorker-new"><code>QueryCountWorker$new()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryCountWorker-getStateful"><code>QueryCountWorker$getStateful()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryCountWorker-kosher"><code>QueryCountWorker$kosher()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryCountWorker-queryCount"><code>QueryCountWorker$queryCount()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryCountWorker-clone"><code>QueryCountWorker$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-QueryCountWorker-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>QueryCountWorker</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountWorker$new(defn, data, stateful = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>defn</code></dt><dd><p>the computation definition</p>
</dd>
<dt><code>data</code></dt><dd><p>the local data</p>
</dd>
<dt><code>stateful</code></dt><dd><p>the statefulness flag, default <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new <code>QueryCountWorker</code> object
</p>


<hr>
<a id="method-QueryCountWorker-getStateful"></a>



<h4>Method <code>getStateful()</code></h4>

<p>Retrieve the value of the <code>stateful</code> field
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountWorker$getStateful()</pre></div>


<hr>
<a id="method-QueryCountWorker-kosher"></a>



<h4>Method <code>kosher()</code></h4>

<p>Check if inputs and state of object are sane. For future use
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountWorker$kosher()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<hr>
<a id="method-QueryCountWorker-queryCount"></a>



<h4>Method <code>queryCount()</code></h4>

<p>Return the query count on the local data
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountWorker$queryCount()</pre></div>


<hr>
<a id="method-QueryCountWorker-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryCountWorker$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+QueryCountMaster">QueryCountMaster()</a></code> which goes hand-in-hand with this object
</p>

<hr>
<h2 id='resetComputationInfo'>Clear the contents of the global store</h2><span id='topic+resetComputationInfo'></span>

<h3>Description</h3>

<p>In distcomp, several web applications need to communicate
between themselves. Since only one application is expected to be
active at any time, they do so via a global store, essentially a hash table.
This function clears the store, except for the working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetComputationInfo()
</code></pre>


<h3>Value</h3>

<p>an empty list
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setComputationInfo">setComputationInfo()</a></code>, <code><a href="#topic+getComputationInfo">getComputationInfo()</a></code>
</p>

<hr>
<h2 id='runDistcompApp'>Run a specified distcomp web application</h2><span id='topic+runDistcompApp'></span>

<h3>Description</h3>

<p>Web applications can define computation, setup worker sites or masters.
This function invokes the appropriate web application depending on the task
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runDistcompApp(appType = c("definition", "setupWorker", "setupMaster"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runDistcompApp_+3A_apptype">appType</code></td>
<td>
<p>one of three values: &quot;definition&quot;, &quot;setupWorker&quot;, &quot;setupMaster&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the results of running the web application
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defineNewComputation">defineNewComputation()</a></code>, <code><a href="#topic+setupWorker">setupWorker()</a></code>, <code><a href="#topic+setupMaster">setupMaster()</a></code>
</p>

<hr>
<h2 id='saveNewComputation'>Save a computation instance, given the computation definition, associated data and
possibly a data file name to use</h2><span id='topic+saveNewComputation'></span>

<h3>Description</h3>

<p>The function <code>saveNewComputation</code> uses the computation definition to save
a new computation instance. This is typically done for every site that wants to participate
in a computation with its own local data. The function examines the computation definition
and uses the identifier therein to uniquely refer to the computation instance at the site.
This function is invoked (maybe remotely) on the opencpu server by
<code><a href="#topic+uploadNewComputation">uploadNewComputation()</a></code> when a worker site is being set up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveNewComputation(defn, data, dataFileName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveNewComputation_+3A_defn">defn</code></td>
<td>
<p>an already defined computation</p>
</td></tr>
<tr><td><code id="saveNewComputation_+3A_data">data</code></td>
<td>
<p>the (local) data to use</p>
</td></tr>
<tr><td><code id="saveNewComputation_+3A_datafilename">dataFileName</code></td>
<td>
<p>a file name to use for saving the data. Typically <code>NULL</code>, this
is only needed when one is using a single opencpu server to behave like multiple
sites in which case the data file name serves to distinguish the site-specific data files.
When it is <code>NULL</code>, the data file name is taken from the configuration settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if everything goes well
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uploadNewComputation">uploadNewComputation()</a></code>
</p>

<hr>
<h2 id='saveNewNCP'>Save an NCP instance, given the sites as associated data and
possibly a data file name to use</h2><span id='topic+saveNewNCP'></span>

<h3>Description</h3>

<p>The function <code>saveNewNCP</code> uses the list of sites
definition to save a new NCP instance. This is
typically done for every pair of NCPs used in a computation. The function examines the
computation definition and uses the identifier therein to
uniquely refer to the computation instance at the site.  This
function is invoked (maybe remotely) on the opencpu server by
<code><a href="#topic+uploadNewComputation">uploadNewComputation()</a></code> when a worker site is being set up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveNewNCP(defn, comp_defn, data, dataFileName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveNewNCP_+3A_defn">defn</code></td>
<td>
<p>a definition of the ncp</p>
</td></tr>
<tr><td><code id="saveNewNCP_+3A_comp_defn">comp_defn</code></td>
<td>
<p>the computation definition</p>
</td></tr>
<tr><td><code id="saveNewNCP_+3A_data">data</code></td>
<td>
<p>the list of sites with name and url to use</p>
</td></tr>
<tr><td><code id="saveNewNCP_+3A_datafilename">dataFileName</code></td>
<td>
<p>a file name to use for saving the
data. Typically <code>NULL</code>, this is only needed when one is using a
single opencpu server to behave like multiple sites in which
case the data file name serves to distinguish the site-specific
data files.  When it is <code>NULL</code>, the data file name is taken
from the definition settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if everything goes well
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uploadNewNCP">uploadNewNCP()</a></code>
</p>

<hr>
<h2 id='setComputationInfo'>Set a name to a value in a global variable</h2><span id='topic+setComputationInfo'></span>

<h3>Description</h3>

<p>In distcomp, several web applications need to communicate
between themselves. Since only one application is expected to be
active at any time, they do so via a global store, essentially a hash table.
This function sets a name to a value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setComputationInfo(name, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setComputationInfo_+3A_name">name</code></td>
<td>
<p>the name for the object</p>
</td></tr>
<tr><td><code id="setComputationInfo_+3A_value">value</code></td>
<td>
<p>the value for the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns the all the name value pairs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getComputationInfo">getComputationInfo()</a></code>
</p>

<hr>
<h2 id='setupMaster'>Setup a computation master</h2><span id='topic+setupMaster'></span>

<h3>Description</h3>

<p>This function just calls <code><a href="#topic+runDistcompApp">runDistcompApp()</a></code> with the
parameter &quot;setupMaster&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupMaster()
</code></pre>


<h3>Value</h3>

<p>the results of running the web application
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runDistcompApp">runDistcompApp()</a></code>
</p>

<hr>
<h2 id='setupWorker'>Setup a worker site</h2><span id='topic+setupWorker'></span>

<h3>Description</h3>

<p>This function just calls <code><a href="#topic+runDistcompApp">runDistcompApp()</a></code> with the
parameter &quot;setupWorker&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupWorker()
</code></pre>


<h3>Value</h3>

<p>the results of running the web application
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runDistcompApp">runDistcompApp()</a></code>
</p>

<hr>
<h2 id='SVDMaster'>R6 class for SVD master object to control worker objects generated by <code><a href="#topic+SVDWorker">SVDWorker()</a></code></h2><span id='topic+SVDMaster'></span>

<h3>Description</h3>

<p><code>SVDMaster</code> objects instantiate and run a distributed SVD computation
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SVDMaster-new"><code>SVDMaster$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDMaster-kosher"><code>SVDMaster$kosher()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDMaster-updateV"><code>SVDMaster$updateV()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDMaster-updateU"><code>SVDMaster$updateU()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDMaster-fixFit"><code>SVDMaster$fixFit()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDMaster-reset"><code>SVDMaster$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDMaster-addSite"><code>SVDMaster$addSite()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDMaster-run"><code>SVDMaster$run()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDMaster-summary"><code>SVDMaster$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDMaster-clone"><code>SVDMaster$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SVDMaster-new"></a>



<h4>Method <code>new()</code></h4>

<p><code>SVDMaster</code> objects instantiate and run a distributed SVD computation
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDMaster$new(defn, debug = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>defn</code></dt><dd><p>a computation definition</p>
</dd>
<dt><code>debug</code></dt><dd><p>a flag for debugging, default <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>R6 <code>SVDMaster</code> object
</p>


<hr>
<a id="method-SVDMaster-kosher"></a>



<h4>Method <code>kosher()</code></h4>

<p>Check if inputs and state of object are sane. For future use
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDMaster$kosher()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<hr>
<a id="method-SVDMaster-updateV"></a>



<h4>Method <code>updateV()</code></h4>

<p>Return an updated value for the <code>V</code> vector, normalized by <code>arg</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDMaster$updateV(arg)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>arg</code></dt><dd><p>the normalizing value</p>
</dd>
<dt><code>...</code></dt><dd><p>other args ignored</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>updated <code>V</code>
</p>


<hr>
<a id="method-SVDMaster-updateU"></a>



<h4>Method <code>updateU()</code></h4>

<p>Update <code>U</code> and return the updated norm of <code>U</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDMaster$updateU(arg)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>arg</code></dt><dd><p>the normalizing value</p>
</dd>
<dt><code>...</code></dt><dd><p>other args ignored</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>updated norm of <code>U</code>
</p>


<hr>
<a id="method-SVDMaster-fixFit"></a>



<h4>Method <code>fixFit()</code></h4>

<p>Construct the residual matrix using given the <code>V</code> vector and <code>d</code> so far
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDMaster$fixFit(v, d)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>the value for <code>v</code></p>
</dd>
<dt><code>d</code></dt><dd><p>the value for <code>d</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>result
</p>


<hr>
<a id="method-SVDMaster-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the computation state by initializing work matrix and set up starting values for iterating
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDMaster$reset()</pre></div>


<hr>
<a id="method-SVDMaster-addSite"></a>



<h4>Method <code>addSite()</code></h4>

<p>Add a url or worker object for a site for participating in the distributed computation. The worker object can be used to avoid complications in debugging remote calls during prototyping.
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDMaster$addSite(name, url = NULL, worker = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>of the site</p>
</dd>
<dt><code>url</code></dt><dd><p>web url of the site; exactly one of <code>url</code> or <code>worker</code> should be specified</p>
</dd>
<dt><code>worker</code></dt><dd><p>worker object for the site; exactly one of <code>url</code> or <code>worker</code> should be specified</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SVDMaster-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run the distributed Cox model fit and return the estimates
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDMaster$run(thr = 1e-08, max.iter = 100)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>thr</code></dt><dd><p>the threshold for convergence, default 1e-8</p>
</dd>
<dt><code>max.iter</code></dt><dd><p>the maximum number of iterations, default 100</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a named list of <code>V</code>, <code>d</code>
</p>


<hr>
<a id="method-SVDMaster-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Return the summary result
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDMaster$summary()</pre></div>



<h5>Returns</h5>

<p>a named list of <code>V</code>, <code>d</code>
</p>


<hr>
<a id="method-SVDMaster-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDMaster$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+SVDWorker">SVDWorker()</a></code> which goes hand-in-hand with this object
</p>

<hr>
<h2 id='SVDWorker'>R6 class for a SVD worker object to use with master objects generated by <code><a href="#topic+SVDMaster">SVDMaster()</a></code></h2><span id='topic+SVDWorker'></span>

<h3>Description</h3>

<p><code>SVDWorker</code> objects are worker objects at each site of a distributed SVD model computation
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SVDWorker-new"><code>SVDWorker$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDWorker-reset"><code>SVDWorker$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDWorker-dimX"><code>SVDWorker$dimX()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDWorker-updateV"><code>SVDWorker$updateV()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDWorker-updateU"><code>SVDWorker$updateU()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDWorker-normU"><code>SVDWorker$normU()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDWorker-fixU"><code>SVDWorker$fixU()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDWorker-getN"><code>SVDWorker$getN()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDWorker-getP"><code>SVDWorker$getP()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDWorker-getStateful"><code>SVDWorker$getStateful()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDWorker-kosher"><code>SVDWorker$kosher()</code></a>
</p>
</li>
<li> <p><a href="#method-SVDWorker-clone"><code>SVDWorker$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SVDWorker-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>SVDWorker</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$new(defn, data, stateful = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>defn</code></dt><dd><p>the computation definition</p>
</dd>
<dt><code>data</code></dt><dd><p>the local <code>x</code> matrix</p>
</dd>
<dt><code>stateful</code></dt><dd><p>a boolean flag indicating if state needs to be preserved between REST calls, <code>TRUE</code> by default</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new <code>SVDWorker</code> object
</p>


<hr>
<a id="method-SVDWorker-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the computation state by initializing work matrix and set up starting values for iterating
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$reset()</pre></div>


<hr>
<a id="method-SVDWorker-dimX"></a>



<h4>Method <code>dimX()</code></h4>

<p>Return the dimensions of the matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$dimX(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>other args ignored</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the dimension of the matrix
</p>


<hr>
<a id="method-SVDWorker-updateV"></a>



<h4>Method <code>updateV()</code></h4>

<p>Return an updated value for the <code>V</code> vector, normalized by <code>arg</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$updateV(arg, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>arg</code></dt><dd><p>the normalizing value</p>
</dd>
<dt><code>...</code></dt><dd><p>other args ignored</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>updated <code>V</code>
</p>


<hr>
<a id="method-SVDWorker-updateU"></a>



<h4>Method <code>updateU()</code></h4>

<p>Update <code>U</code> and return the updated norm of <code>U</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$updateU(arg, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>arg</code></dt><dd><p>the initial value</p>
</dd>
<dt><code>...</code></dt><dd><p>other args ignored</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>updated norm of <code>U</code>
</p>


<hr>
<a id="method-SVDWorker-normU"></a>



<h4>Method <code>normU()</code></h4>

<p>Normalize <code>U</code> vector
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$normU(arg, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>arg</code></dt><dd><p>the normalizing value</p>
</dd>
<dt><code>...</code></dt><dd><p>other args ignored</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> invisibly
</p>


<hr>
<a id="method-SVDWorker-fixU"></a>



<h4>Method <code>fixU()</code></h4>

<p>Construct residual matrix using <code>arg</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$fixU(arg, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>arg</code></dt><dd><p>the value to use for residualizing</p>
</dd>
<dt><code>...</code></dt><dd><p>other args ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SVDWorker-getN"></a>



<h4>Method <code>getN()</code></h4>

<p>Getthe number of rows of <code>x</code> matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$getN()</pre></div>



<h5>Returns</h5>

<p>the number of rows of <code>x</code> matrix
</p>


<hr>
<a id="method-SVDWorker-getP"></a>



<h4>Method <code>getP()</code></h4>

<p>Getthe number of columnsof <code>x</code> matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$getP()</pre></div>



<h5>Returns</h5>

<p>the number of columns of <code>x</code> matrix
</p>


<hr>
<a id="method-SVDWorker-getStateful"></a>



<h4>Method <code>getStateful()</code></h4>

<p>Return the stateful status of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$getStateful()</pre></div>



<h5>Returns</h5>

<p>the stateful flag, <code>TRUE</code> or <code>FALSE</code>
</p>


<hr>
<a id="method-SVDWorker-kosher"></a>



<h4>Method <code>kosher()</code></h4>

<p>Check if inputs and state of object are sane. For future use
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$kosher()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<hr>
<a id="method-SVDWorker-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SVDWorker$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+SVDMaster">SVDMaster()</a></code> which goes hand-in-hand with this object
</p>

<hr>
<h2 id='uploadNewComputation'>Upload a new computation and data to an opencpu server</h2><span id='topic+uploadNewComputation'></span>

<h3>Description</h3>

<p>The function <code>uploadNewComputation</code> is really a remote version
of <code><a href="#topic+saveNewComputation">saveNewComputation()</a></code>, invoking that function on an opencpu server.
This is typically done for every site that wants to participate in a computation
with its own local data. Note that a site is always a list of at least a unique
name element (distinguishing the site from others) and a url element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uploadNewComputation(site, defn, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uploadNewComputation_+3A_site">site</code></td>
<td>
<p>a list of two items, a unique <code>name</code> and a <code>url</code></p>
</td></tr>
<tr><td><code id="uploadNewComputation_+3A_defn">defn</code></td>
<td>
<p>the identifier of an already defined computation</p>
</td></tr>
<tr><td><code id="uploadNewComputation_+3A_data">data</code></td>
<td>
<p>the (local) data to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if everything goes well
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saveNewComputation">saveNewComputation()</a></code>
</p>

<hr>
<h2 id='uploadNewNCP'>Upload a new Non-Cooperating Party (NCP) information and sites to
an opencpu server</h2><span id='topic+uploadNewNCP'></span>

<h3>Description</h3>

<p>The function <code>uploadNewNCP</code> is really a remote version
of <code><a href="#topic+saveNewNCP">saveNewNCP()</a></code>, invoking that function on an opencpu server.
This is typically done for the two NCPs participating in a
computation with the list of sites. Note that sites are always
a list of at least a unique name element (distinguishing the
site from others) and a url element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uploadNewNCP(defn, comp_defn, url = NULL, worker = NULL, sites)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uploadNewNCP_+3A_defn">defn</code></td>
<td>
<p>a definition for the NCP</p>
</td></tr>
<tr><td><code id="uploadNewNCP_+3A_comp_defn">comp_defn</code></td>
<td>
<p>the computation definition</p>
</td></tr>
<tr><td><code id="uploadNewNCP_+3A_url">url</code></td>
<td>
<p>the url for the NCP. Only one of url and worker can be
non-null</p>
</td></tr>
<tr><td><code id="uploadNewNCP_+3A_worker">worker</code></td>
<td>
<p>the worker for the NCP if local. Only one of url and
worker can be non-null</p>
</td></tr>
<tr><td><code id="uploadNewNCP_+3A_sites">sites</code></td>
<td>
<p>a list of lists, each containing two items, a unique
<code>name</code> and a (not necessarily unique) <code>url</code>. This is the data
for the NCP!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if everything goes well
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saveNewNCP">saveNewNCP()</a></code>
</p>

<hr>
<h2 id='writeCode'>Write the code necessary to run a master process</h2><span id='topic+writeCode'></span>

<h3>Description</h3>

<p>Once a computation is defined, worker sites are set
up, the master process code is written by this function. The
current implementation does not allow one to mix localhost URLs
with non-localhost URLs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeCode(defn, sites, outputFilenamePrefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeCode_+3A_defn">defn</code></td>
<td>
<p>the computation definition</p>
</td></tr>
<tr><td><code id="writeCode_+3A_sites">sites</code></td>
<td>
<p>a named list of site URLs participating in the
computation</p>
</td></tr>
<tr><td><code id="writeCode_+3A_outputfilenameprefix">outputFilenamePrefix</code></td>
<td>
<p>the name of the output file prefix
using which code and data will be written</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value <code>TRUE</code> if all goes well
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setupMaster">setupMaster()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
