<!DOCTYPE html><html lang="en"><head><title>Help for package multicool</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multicool}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allPerm'><p>Generate and return all permutations of a multiset</p></a></li>
<li><a href='#Bell'><p>Compute the Bell numbers</p></a></li>
<li><a href='#genComp'><p>Generate all, or a subset, of the integer partitions of an integer n.</p></a></li>
<li><a href='#initMC'><p>Initialise the permutation object</p></a></li>
<li><a href='#multinom'><p>Calculate multinomial coefficients</p></a></li>
<li><a href='#nextPerm'><p>Return the next permutation of the multiset</p></a></li>
<li><a href='#Stirling2'><p>Compute Stirling numbers of the second kind</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Permutations of Multisets in Cool-Lex Order</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-05</td>
</tr>
<tr>
<td>Author:</td>
<td>James Curran, Aaron Williams, Jerome Kelleher, Dave Barber</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Curran &lt;j.curran@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools to permute multisets without loops or hash tables and to generate integer partitions. The permutation functions are based on C code from Aaron Williams. Cool-lex order is similar to colexicographical order. The algorithm is described in Williams, A. Loopless Generation of Multiset Permutations by Prefix Shifts. SODA 2009, Symposium on Discrete Algorithms, New York, United States. The permutation code is distributed without restrictions. The code for stable and efficient computation of multinomial coefficients comes from Dave Barber. The code can be download from <a href="http://tamivox.org/dave/multinomial/index.html">http://tamivox.org/dave/multinomial/index.html</a> and is distributed without conditions. The package also generates the integer partitions of a positive, non-zero integer n. The C++ code for this is based on Python code from Jerome Kelleher which can be found here <a href="https://jeromekelleher.net/category/combinatorics.html">https://jeromekelleher.net/category/combinatorics.html</a>. The C++ code and Python code are distributed without conditions.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jmcurran/multicool">https://github.com/jmcurran/multicool</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmcurran/multicool/issues">https://github.com/jmcurran/multicool/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, Rcpp (&ge; 0.11.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RcppModules:</td>
<td>Multicool</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 01:22:16 UTC; james</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 12:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='allPerm'>Generate and return all permutations of a multiset</h2><span id='topic+allPerm'></span>

<h3>Description</h3>

<p>This function will return all permutations of a multiset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allPerm(mcObj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allPerm_+3A_mcobj">mcObj</code></td>
<td>
<p>an object of class mc - usually generated by <code>initMC</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will return all permutations of a multiset. It makes no check
to see if this is a sensible thing to do. Users are advised to check how
many permutations are possible using the <code>multinom</code> function in this
package.
</p>


<h3>Value</h3>

<p>A matrix with each row being a different permutation of the multiset
</p>


<h3>Note</h3>

<p>This function does not warn the user that the requested set of
permutations may be very large. In addition, all working is handled entirely
in memory, and so this may cause it to crash if the request is
execeptionally large.
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initMC">initMC</a></code>, <code><a href="#topic+multinom">multinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## a small numeric example with 6 permuations
x = c(1,1,2,2)
m = initMC(x)
allPerm(m)

## a large character example - 60 possibilities
x = rep(letters[1:3], 3:1)
multinom(x) ## calculate the number of permutations
m = initMC(x)
allPerm(m)

</code></pre>

<hr>
<h2 id='Bell'>Compute the Bell numbers</h2><span id='topic+Bell'></span><span id='topic+B'></span>

<h3>Description</h3>

<p>This function computes the Bell numbers, which is the summ of Stirling
numbers of the second kind, <code class="reqn">S(n, k)</code>, over <code class="reqn">k = 1,\ldots,
n</code>, i.e.  </p>
<p style="text-align: center;"><code class="reqn">B_n = \sum_{k=1}^{n}S(n, k),n \ge 1</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Bell(n)

B(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bell_+3A_n">n</code></td>
<td>
<p>A vector of one or more non-zero positive integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An vector of Bell numbers
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>B()</code>: Compute the Bell numbers
</p>
</li></ul>


<h3>Author(s)</h3>

<p>James Curran
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind#Recurrence_relation">https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind#Recurrence_relation</a>
</p>


<h3>See Also</h3>

<p>Stirling2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## returns B(6)
Bell(6)

## returns B(1), B(2), ..., B(6)
B(1:6)

</code></pre>

<hr>
<h2 id='genComp'>Generate all, or a subset, of the integer partitions of an integer n.</h2><span id='topic+genComp'></span>

<h3>Description</h3>

<p>This function will return either all, or a length restricted subset of the
integer partitions of an integer n. The method works by considering
compositions rather than partions, hence the name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genComp(n, len = TRUE, addZeros = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genComp_+3A_n">n</code></td>
<td>
<p>A positive non-zero integer</p>
</td></tr>
<tr><td><code id="genComp_+3A_len">len</code></td>
<td>
<p>Either logical <code>TRUE</code>, or an integer less than or equal to
<code>n</code>. If the latter form is used then only those partions of length less
than or equal to len are returned</p>
</td></tr>
<tr><td><code id="genComp_+3A_addzeros">addZeros</code></td>
<td>
<p>If true then the empty partitions are added to the list of
partitions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will return all partions, or a subset, of an integer n. It
makes no check to see if this is a sensible thing to do. It also does it in
a lazy way in that in the restricted case it generates all partitions and
then only returns those that satistfy the length constraint. Users are
advised to check how many partitions are possible using partition number
function which is implemented the <code>P</code> function in the <span class="pkg">partions</span>
package. Having said this P(50) is approximately 200 thousand, and P(100)
around 190 million, so the function should work well for smallish n.
</p>


<h3>Value</h3>

<p>A list with each list element representing an integer partition
</p>


<h3>Note</h3>

<p>This function does not warn the user that the requested set of
partitions may be very large. In addition, all working is handled entirely
in memory, and so this may cause it to crash if the request is
execeptionally large.
</p>


<h3>Author(s)</h3>

<p>Jerome Kelleher (algorithm and Python version) and James M. Curran
(C++ version/R interface)
</p>


<h3>References</h3>

<p>Kelleher, J. (2005), Encoding Partitions As Ascending
Compositions, PhD thesis, University College Cork.
</p>
<p>Kelleher, J. and O'Sullivan, B. (2009), Generating All Partitions: A
Comparison Of Two Encodings, <a href="https://arxiv.org/abs/0909.2331">https://arxiv.org/abs/0909.2331</a>.
</p>
<p>Kelleher, J. (2010) Generating Integer
Partitions,<a href="https://jeromekelleher.net/tag/integer-partitions.html">https://jeromekelleher.net/tag/integer-partitions.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## a small numeric example with all 11 partitions of 6
genComp(6)

## a small example with the integer partitions of 6 of length 3 with empty partitions added
genComp(6, 3, TRUE)

## a larger example - 627 partions of 20, but restricted to those of length 3 or smaller
genComp(20, 3)

</code></pre>

<hr>
<h2 id='initMC'>Initialise the permutation object</h2><span id='topic+initMC'></span>

<h3>Description</h3>

<p>This function initialises the permutation object. It must be called before
<code>nextPerm</code> can be called
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initMC(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initMC_+3A_x">x</code></td>
<td>
<p>a vector of integers, reals, logicals or characters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a object of class <code>mc</code> which is a list containing elements
</p>
<table role = "presentation">
<tr><td><code>mode</code></td>
<td>
<p> - the mode of the original data in <code>x</code>, &quot;integer&quot;,
&quot;double&quot;, or <code>mode(x)</code></p>
</td></tr>
<tr><td><code>set</code></td>
<td>
<p> - either the multiset being permuted if <code>mode</code> is &quot;integer&quot; or
a set of integers corresponding to the elements of the multiset</p>
</td></tr>
<tr><td><code>elements</code></td>
<td>
<p> - if <code>mode</code> is not &quot;integer&quot; then this contains the
elements being permuted otherwise <code>NULL</code> </p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p> - the length of the multiset </p>
</td></tr>
<tr><td><code>mc</code></td>
<td>
<p> - a pointer to the internal C++ Multicool object. Users
should not use this unless they really know what they are doing</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>nextPerm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = c(1,1,2,2)
m1 = initMC(x)
m1

## a non-integer example

x = rep(letters[1:4],c(2,1,2,2))
m2 = initMC(x)
m2

</code></pre>

<hr>
<h2 id='multinom'>Calculate multinomial coefficients</h2><span id='topic+multinom'></span>

<h3>Description</h3>

<p>This function calculates the number of permutations of a multiset, this
being the multinomial coefficient. If a set <code class="reqn">X</code> contains <code class="reqn">k</code> unique
elements <code class="reqn">x_1, x_2, \ldots, x_k</code> with associate counts (or
multiplicities) of <code class="reqn">n_1, n_2, \ldots, n_k</code>, then this function returns
</p>
<p style="text-align: center;"><code class="reqn">\frac{n!}{n_1!n_2!\ldots n_k!}</code>
</p>
<p> where <code class="reqn">n
= \sum_{i=1}{k}n_i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinom(x, counts = FALSE, useDouble = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multinom_+3A_x">x</code></td>
<td>
<p>Either a multiset (with one or more potentially non-unique
elements), or if <code>counts</code> is <code>TRUE</code> a set of counts of the unique
elements of <code class="reqn">X</code>. If <code>counts</code> is <code>FALSE</code> and <code>x</code> is not
numeric, then x will be coerced into an integer vector internally. If
<code>counts</code> is <code>TRUE</code> then <code>x</code> must be a vector of integers that
are greater than, or equal to zero.</p>
</td></tr>
<tr><td><code id="multinom_+3A_counts">counts</code></td>
<td>
<p>if <code>counts</code> is TRUE, then this means x is the set of
counts <code class="reqn">n_1, n_2, \ldots, n_k</code> rather than the set itself</p>
</td></tr>
<tr><td><code id="multinom_+3A_usedouble">useDouble</code></td>
<td>
<p>if <code>useDouble</code> is TRUE then the computation will be
done using double precision floating point arithmetic. This option was added
because the internal code cannot handle integer overflow. The double
precision code will may a result that is closer to the truth for large
values, but this is not guaranteed. Ideally something like the GMP library
should be used, but this is not a priority at this point in time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>multinom depends on C++ code written by Dave Barber which can be found at
<a href="http://tamivox.org/dave/multinomial/code.html">http://tamivox.org/dave/multinomial/code.html</a>. The code may require
the STL algorithm library to be included in order to compile it.
</p>


<h3>Value</h3>

<p>A single integer representing the multinomial coefficient for the
given multiset, or given set of multiplicities.
</p>


<h3>Author(s)</h3>

<p>James M. Curran, Dave Barber
</p>


<h3>References</h3>

<p><a href="http://tamivox.org/dave/multinomial/code.html">http://tamivox.org/dave/multinomial/code.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## An example with a multiset X = (a,a,a,b,b,c)
## There are 3 a s, 2 b s and 1 c, so the answer should be
## (3+2+1)!/(3!2!1!) = 6!/3!2!1! = 60
x = rep(letters[1:3],3:1)
multinom(x)

## in this example x is a vector of counts
## the answer should be the same as above as x = c(3,2,1)
x = rep(letters[1:3],3:1)
x = as.vector(table(x)) #coerce x into a vector of counts
multinom(x, counts = TRUE)


## An example of integer overflow. x is a vector of counts
## c(12,11,8,8,6,5). The true answer from Maple is
## 11,324,718,121,789,252,764,532,876,767,840,000
## The error in the integer based answer is obvious.
## The error using floating point is not, but from Maple is
## 0.705057123232160000e+10
## Thanks to Lev Dashevskiy for calling my attention to this.
## Not run: x = c(12,11,8,8,6,5)
multinom(x, counts = TRUE, useDouble = FALSE)
multinom(x, counts = TRUE, useDouble = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='nextPerm'>Return the next permutation of the multiset</h2><span id='topic+nextPerm'></span>

<h3>Description</h3>

<p>This function returns the next permuation of the multiset if there is one.
<code>initMC</code> called before <code>nextPerm</code> can be called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextPerm(mcObj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nextPerm_+3A_mcobj">mcObj</code></td>
<td>
<p>an S3 object of class <code>mc</code> which must be created with
<code>initMC</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a vector with the next permutation of the multiset or
<code>FALSE</code> when all permutations have been returned
</p>


<h3>Author(s)</h3>

<p>James M. Curran
</p>


<h3>See Also</h3>

<p>nextPerm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = c(1,1,2,2)
m1 = initMC(x)

for(i in 1:6){
  cat(paste(paste(nextPerm(m1),collapse=","),"\n"))
}

## an example with letters
x = letters[1:4]
m2 = initMC(x)
nextPerm(m2)
nextPerm(m2)
## and so on

</code></pre>

<hr>
<h2 id='Stirling2'>Compute Stirling numbers of the second kind</h2><span id='topic+Stirling2'></span><span id='topic+S2'></span>

<h3>Description</h3>

<p>This function computes Stirling numbers of the second kind, <code class="reqn">S(n,
k)</code>, which count the number of ways of partitioning n distinct
objects in to k non-empty sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Stirling2(n, k)

S2(n, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Stirling2_+3A_n">n</code></td>
<td>
<p>A vector of one or more positive integers</p>
</td></tr>
<tr><td><code id="Stirling2_+3A_k">k</code></td>
<td>
<p>A vector of one or more positive integers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation on this function is a simple recurrence relation which
defines </p>
<p style="text-align: center;"><code class="reqn">S(n, k) = kS(n - 1, k), + S(n - 1, k - 1)</code>
</p>
<p> for <code class="reqn">k &gt; 0</code>
with the inital conditions <code class="reqn">S(0, 0) = 1</code> and <code class="reqn">S(n, 0) = S(0, n) =
0</code>. If <code>n</code> and <code>n</code> have different lengths then <code>expand.grid</code>
is used to construct a vector of (n, k) pairs
</p>


<h3>Value</h3>

<p>An vector of Stirling numbers of the second kind
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>S2()</code>: Compute Stirling numbers of the second kind
</p>
</li></ul>


<h3>Author(s)</h3>

<p>James Curran
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind#Recurrence_relation">https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind#Recurrence_relation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## returns S(6, 3)
Stirling2(6, 3)

## returns S(6,1), S(6,2), ..., S(6,6)
S2(6, 1:6)

## returns S(6,1), S(5, 2), S(4, 3)
S2(6:4, 1:3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
