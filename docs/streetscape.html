<!DOCTYPE html><html><head><title>Help for package streetscape</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {streetscape}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#available-field-and-filter'><p>available-field-and-filter</p></a></li>
<li><a href='#decode_detections'><p>decode_detections</p></a></li>
<li><a href='#install_mvt'><p>install_mvt</p></a></li>
<li><a href='#scdataframe'><p>streetscape dataframe</p></a></li>
<li><a href='#see_streetscape_class'><p>see_streetscape_class</p></a></li>
<li><a href='#Streetscape-class'><p>Streetscape-Class</p></a></li>
<li><a href='#StreetscapeDataFrame-class'><p>Class <code>"StreetscapeDataFrame"</code></p></a></li>
<li><a href='#strview_search'><p>strview_search</p></a></li>
<li><a href='#strview2qualtrics'><p>strview2qualtrics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Collect And Investigate Street Views For Urban Science</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to search and download street view imagery 
             ('Mapilary' <a href="https://www.mapillary.com/developer/api-documentation">https://www.mapillary.com/developer/api-documentation</a>) and 
             to extract, quantify, and visualize visual features. Moreover, there are 
             functions provided to generate Qualtrics survey in TXT format using 
             the collection of street views for various research purposes. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en_GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, methods, dplyr, sf, sp, httr, reticulate, osmdata,
quickPWCR, mapview, SuperpixelImageSegmentation, OpenImageR,
pbmcapply, parallelly</td>
</tr>
<tr>
<td>Config/reticulate:</td>
<td>list( packages = list( list(package =
"mapbox_vector_tile", pip = TRUE) ) )</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-07 19:13:04 UTC; yangxiaohao</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiaohao Yang [aut, cre, cph],
  Derek Van Berkel [aut],
  Mark Lindquist [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiaohao Yang &lt;xiaohaoy@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-07 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='available-field-and-filter'>available-field-and-filter</h2><span id='topic+available-field-and-filter'></span><span id='topic+available_field'></span><span id='topic+available_filter'></span>

<h3>Description</h3>

<p>available_field provides a list of available fields.
</p>
<p>available_filter provides a list of available filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_field()

available_filter()
</code></pre>


<h3>Details</h3>

<p>Field and Filter List
</p>


<h3>Value</h3>

<p>dataframe, including field names and their descriptions.
</p>
<p>dataframe, including filter names and their descriptions.
</p>


<h3>Note</h3>

<p>More information about fields and filter
at <a href="https://www.mapillary.com/developer/api-documentation">https://www.mapillary.com/developer/api-documentation</a>
</p>

<hr>
<h2 id='decode_detections'>decode_detections</h2><span id='topic+decode_detections'></span>

<h3>Description</h3>

<p>convert Mapillary object detection into sf polygons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_detections(detections_string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_detections_+3A_detections_string">detections_string</code></td>
<td>
<p>character, an endcoded string of semantic segmentation,
for example, &quot;Gmt4AgoGbXB5L==&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf polygon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
detection &lt;- readLines(system.file('detection.txt', package = 'streetscape'))
streetscape::decode_detections(detection)

</code></pre>

<hr>
<h2 id='install_mvt'>install_mvt</h2><span id='topic+install_mvt'></span>

<h3>Description</h3>

<p>install_mvt is a wrapped function of py_install
in the reticulate package for installing the python package
mapbox_vector_tile, which will be installed in a virtual environment -
&quot;r-mvt&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_mvt(envname = "r-mvt", method = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_mvt_+3A_envname">envname</code></td>
<td>
<p>The name, or full path, of the environment
in which Python packages are to be installed.</p>
</td></tr>
<tr><td><code id="install_mvt_+3A_method">method</code></td>
<td>
<p>character, indicating installation method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='scdataframe'>streetscape dataframe</h2><span id='topic+scdataframe'></span>

<h3>Description</h3>

<p>streetscape dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(scdataframe)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"StreetscapeDataFrame"</code>; see <code><a href="#topic+see_streetscape_class">see_streetscape_class()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scdataframe)
</code></pre>

<hr>
<h2 id='see_streetscape_class'>see_streetscape_class</h2><span id='topic+see_streetscape_class'></span>

<h3>Description</h3>

<p>A function to call out help page of <code>StreetscapeDataFrame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>see_streetscape_class()
</code></pre>


<h3>Details</h3>

<p>see_streetscape_class
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Note</h3>

<p>User can also directly use ?StreetscapeDataFrame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>see_streetscape_class()
</code></pre>

<hr>
<h2 id='Streetscape-class'>Streetscape-Class</h2><span id='topic+Streetscape-class'></span><span id='topic+StreetscapeDataFrame'></span>

<h3>Description</h3>

<p>The output of strview_search family
functions is constructed in this data format -
A specialized data frame for streetscape package for
initializing the object with streetscape data and
extracting and decoding segmentation information
of streetscape dataframe.
</p>


<h3>Fields</h3>


<dl>
<dt><code>data</code></dt><dd><p>A data frame containing metadata of Mapillary
street view images</p>
</dd>
<dt><code>epsg</code></dt><dd><p>A numeric epsg code</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>decodeDetection()</code></dt><dd><p>Regenerate a dataframe with decoded segmentation.
'detections' column will be updated and
a new column 'segmentation' will be added.</p>
</dd>
<dt><code>download_data(path, items)</code></dt><dd><p>Download street view images (and segmentations in sf format if applicable)</p>
</dd>
<dt><code>get_mask(index)</code></dt><dd><p>Convert the semantic segmentation of a street view image
from the StreetscapeDataFrame into sf polygons</p>
</dd>
<dt><code>gvi(level)</code></dt><dd><p>Calculate green view index (GVI) for each collected image by
segmenting green pixels and quantifing the percentage in
street view images. This method adds a new column of
greeness percetage to the dataframe</p>
</dd>
<dt><code>mapPreview(maptype = "meta", fields = c())</code></dt><dd><p>Plot data points in an ineractive map view</p>
</dd>
</dl>


<h3>Class Methods</h3>



<h4>Method list</h4>


<ul>
<li> <p><a href="#method-decodeDetection"><code>StreetscapeDataFrame$decodeDetection()</code></a>
</p>
</li>
<li> <p><a href="#method-gvi"><code>StreetscapeDataFrame$gvi()</code></a>
</p>
</li>
<li> <p><a href="#method-get_mask"><code>StreetscapeDataFrame$get_mask()</code></a>
</p>
</li>
<li> <p><a href="#method-mapPreview"><code>StreetscapeDataFrame$mapPreview()</code></a>
</p>
</li>
<li> <p><a href="#method-download_data"><code>StreetscapeDataFrame$download_data()</code></a>
</p>
</li></ul>


<hr>
<a id="method-decodeDetection"></a>


<h4>Method <code>decodeDetection()</code></h4>



<h5>Usage</h5>

<p><code>scdataframe$decodeDetection()</code>
</p>


<hr>
<a id="method-gvi"></a>


<h4>Method <code>gvi()</code></h4>



<h5>Usage</h5>

<p><code>scdataframe$gvi(level = 1)</code>
</p>



<h5>Arguments</h5>


<dl>
<dt><code>level</code></dt><dd><p>numeric, indicating the resolution level of images
for calculating the green view index.
1 - the 256px wide thumbnail;
2 - the 1024px wide thumbnail;
3 - the 2048px wide thumbnail;
4 - the original wide thumbnail.
The default is level = 1
</p>
</dd>
</dl>



<hr>
<a id="method-get_mask"></a>


<h4>Method <code>get_mask()</code></h4>



<h5>Usage</h5>

<p><code>scdataframe$get_mask(index = 1)</code>
</p>



<h5>Arguments</h5>


<dl>
<dt><code>index</code></dt><dd><p>numeric, the row index of the dataframe
of StreetscapeDataFrame class</p>
</dd>
</dl>



<hr>
<a id="method-mapPreview"></a>


<h4>Method <code>mapPreview()</code></h4>



<h5>Usage</h5>

<p><code>scdataframe$mapPreview(maptype = 'meta')</code>
</p>



<h5>Arguments</h5>


<dl>
<dt><code>maptype</code></dt><dd><p>character or character,
specifying what type of information to be mapped:
'meta' - image meta,
'seg' - segmentation proportion,
and 'gvi' - GVI&quot;.</p>
</dd>
<dt><code>fields</code></dt><dd><p>vector (optional), a vector of fields
indicates the information of images to be included
for the 'meta' map. The fields of 'id', 'is_pano',
'height', 'width', 'lon', and 'lat' are already included</p>
</dd>
</dl>



<hr>
<a id="method-download_data"></a>


<h4>Method <code>download_data()</code></h4>



<h5>Usage</h5>

<p><code>scdataframe$download_data(path = 'path/to/download',
 items = c('image', 'mask'))</code>
</p>



<h5>Arguments</h5>


<dl>
<dt><code>path</code></dt><dd><p>character, directory for downloading street view images
or segmentation masks or both</p>
</dd>
<dt><code>items</code></dt><dd><p>character or vector, specifying what to download:
'image' - 'original street view image;
'mask' - semantic segmentation (sf objects in .geojson format)&quot;</p>
</dd>
</dl>




<hr>
<h2 id='StreetscapeDataFrame-class'>Class <code>"StreetscapeDataFrame"</code></h2><span id='topic+StreetscapeDataFrame-class'></span>

<h3>Description</h3>

<p>&quot;The output of strview_search family
functions is constructed in this data format -
A specialized data frame for streetscape package for
initializing the object with streetscape data and
extracting and decoding segmentation information
of streetscape dataframe.&quot;
</p>


<h3>Extends</h3>

<p>All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>data.frame</code> ~~ </p>
</dd>
<dt><code>epsg</code>:</dt><dd><p>Object of class <code>numeric</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>download_data(path, items)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>get_mask(index)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>gvi()</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>decodeDetection()</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>mapPreview(maptype, fields)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>initialize(data, epsg)</code>:</dt><dd><p> ~~ </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>&quot;Xiaohao Yang&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("StreetscapeDataFrame")
</code></pre>

<hr>
<h2 id='strview_search'>strview_search</h2><span id='topic+strview_search'></span><span id='topic+strview_searchByGeo'></span><span id='topic+strview_search_nnb'></span><span id='topic+strview_search_osm'></span><span id='topic+strview_search_multi'></span>

<h3>Description</h3>

<p>strview_searchByGeo: Search for and download the meta information
of street view images via Mapillary API (See detials) based on coordinates
of a spatial point with a given distance or a bounding box.
</p>
<p>strview_search_nnb: Search for the nearest (within 10m buffer)
available street view images and download meta information
via Mapillary API (See detials) given coordinates of a spatial point.
</p>
<p>strview_search_osm: Search for street view images by
sampling locations along the OSM road lines and download meta information
via Mapillary API (See detials) given a bounding box.
</p>
<p>strview_search_multi: Search for and download the meta information
of street view images via Mapillary API (See detials) based on multiple coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strview_searchByGeo(
  x,
  y,
  r,
  epsg,
  bbox,
  token = "",
  limit = 10,
  fields = c(),
  ...
)

strview_search_nnb(x, y, epsg, token = "", fields = c(), ...)

strview_search_osm(bbox, epsg, token, fields = c(), size, ...)

strview_search_multi(viewpoints, epsg, token, fields = c(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strview_search_+3A_x">x</code></td>
<td>
<p>numeric, indicating Longtitude degree of the center point.</p>
</td></tr>
<tr><td><code id="strview_search_+3A_y">y</code></td>
<td>
<p>numeric, indicating latitude degree of the center point.</p>
</td></tr>
<tr><td><code id="strview_search_+3A_r">r</code></td>
<td>
<p>numeric, indicating search distance (meter or feet) for LiDAR data.</p>
</td></tr>
<tr><td><code id="strview_search_+3A_epsg">epsg</code></td>
<td>
<p>numeric, the EPSG code specifying the coordinate reference system.</p>
</td></tr>
<tr><td><code id="strview_search_+3A_bbox">bbox</code></td>
<td>
<p>vector, a bounding box defining the geographical area for downloading data.</p>
</td></tr>
<tr><td><code id="strview_search_+3A_token">token</code></td>
<td>
<p>character, API token of Mapillary.</p>
</td></tr>
<tr><td><code id="strview_search_+3A_limit">limit</code></td>
<td>
<p>numeric, indicating the number of returns. The maximum is 2000.</p>
</td></tr>
<tr><td><code id="strview_search_+3A_fields">fields</code></td>
<td>
<p>vector, a vector of fields indicates the information of images
to be retrieved (See details). 'is_pano', 'thumb_256_url', 'height', 'width',
'computed_geometry', 'computed_altitude', and 'detections' are retrieved
as a default setting.</p>
</td></tr>
<tr><td><code id="strview_search_+3A_...">...</code></td>
<td>
<p>indicating filters (see details)</p>
</td></tr>
<tr><td><code id="strview_search_+3A_size">size</code></td>
<td>
<p>numeric, (approximate) number of locations sampled on OSM spatial lines
(this is for strview_search_osm only).</p>
</td></tr>
<tr><td><code id="strview_search_+3A_viewpoints">viewpoints</code></td>
<td>
<p>sf or matrix, indicating multiple degress-based coordinates
for searching available street views (this is for strview_search_multi only).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>strview_search
</p>
<p>To request an API token of Mapillary,
please create your access token at https://mapillary.com/developer.
For 'fields', one can review all available fields in this package
by calling streetscape::field_list().
</p>


<h3>Value</h3>

<p>For strview_searchByGeo(), a StreetscapeDataFrame returned combining
a dataframe of the image information.
</p>
<p>For strview_search_nnb(), a StreetscapeDataFrame with one-row dataframe
will be returned if there is any available images near to the given point
</p>
<p>For strview_search_osm(), a StreetscapeDataFrame that combines the information
of street views from all sampled points along the OSM lines within
the specified bounding box.
</p>
<p>For strview_search_multi(), a StreetscapeDataFrame that combines the information
of street views based on the coordinates of multiple spatial points
</p>


<h3>Note</h3>

<p>If there is no street view images within the search area,
the function only returns an integer 0.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+available_field">available_field()</a></code> <code><a href="#topic+available_filter">available_filter()</a></code> <code><a href="#topic+see_streetscape_class">see_streetscape_class()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bbox &lt;- c(-83.751812,42.272984,-83.741255,42.279716)
data &lt;- streetscape::strview_searchByGeo(bbox = bbox,
                                         epsg = 2253,
                                         token = "token",
                                         is_pano = TRUE)
data &lt;- streetscape::strview_searchByGeo(x = -83.741289,
                                         y = 42.270146,
                                         r = 100,
                                         epsg = 2253,
                                         token = "token",
                                         is_pano = TRUE)



data &lt;- streetscape::strview_search_nnb(
        x = -83.743460634278,
        y = 42.277848830294,
        epsg = 2253,
        token = 'token')


bbox &lt;- c(-83.752041,42.274896,-83.740711,42.281945)
data &lt;- streetscape::strview_search_osm(
        bbox = bbox,
        epsg = 2253,
        token = 'token',
        size = 100)


x &lt;- c(-83.752041, -83.740711)
y &lt;- c(42.274896, 42.281945)
viewpoints &lt;- cbind(x, y)
data &lt;- streetscape::strview_search_multi(
        viewpoints = viewpoints,
        epsg = 2253,
        token = 'token')

</code></pre>

<hr>
<h2 id='strview2qualtrics'>strview2qualtrics</h2><span id='topic+strview2qualtrics'></span><span id='topic+strview2rate'></span><span id='topic+strview2pwc'></span>

<h3>Description</h3>

<p>strview2rate: pack street views as a Qualtrics survey file that
can be imported to Qualtrics platform
</p>
<p>strview2pwc: pack street views as a Qualtrics survey file for
pair-wised comparison
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strview2rate(df, header, questions, choices, file)

strview2pwc(df, k, header, questions, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strview2qualtrics_+3A_df">df</code></td>
<td>
<p>StreetscapeDataFrame</p>
</td></tr>
<tr><td><code id="strview2qualtrics_+3A_header">header</code></td>
<td>
<p>character, indicating the task for a question.
For example, &quot;Please review the following picture:&quot;</p>
</td></tr>
<tr><td><code id="strview2qualtrics_+3A_questions">questions</code></td>
<td>
<p>vector, a list of questions (see details)</p>
</td></tr>
<tr><td><code id="strview2qualtrics_+3A_choices">choices</code></td>
<td>
<p>list, a list of choices (see details)
(this is only for strview2rate)</p>
</td></tr>
<tr><td><code id="strview2qualtrics_+3A_file">file</code></td>
<td>
<p>character, indicating the directory and file name
(without extension) for saving the Qualtrics survey file</p>
</td></tr>
<tr><td><code id="strview2qualtrics_+3A_k">k</code></td>
<td>
<p>numeric, indicating how many street views each street view will
be paired with for pair-wised comparison (this is only for strview2pwc)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>strview2qualtrics
</p>
<p>For strview2rate(), the lengths of questions and choices must match.
For example, when questions = c('1. To what existence you can feel pleasant
if you were in this environment', '2. To what existence you can feel safe
if you were in this environment'), choices could be list(c('Unpleasant',
'Less pleasant', 'More pleasant', 'Pleasant'), c('Unsafe', 'Less safe', 'Safer',
'Safe'))
For strview2pwc, the choices are always c('left', 'right') for the coparison
purposes.
</p>


<h3>Value</h3>

<p>character if argument 'file' is not specified
</p>
<p>character if argument 'file' is not specified
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('scdataframe')
header &lt;- "Please review the following picture(s):"
questions &lt;- c('1. To what extent you feel pleasant if you were in this environment',
              '2. To what extent you feel safe if you were in this environment')
choices &lt;- list(c('Unpleasant','Less pleasant', 'Pleasant', 'More pleasant'),
                c('Unsafe', 'Less safe','Safe', 'Safer'))
txt &lt;- streetscape::strview2rate(scdataframe, header, questions, choices)

data('scdataframe')
header &lt;- "Please review the following picture(s):"
questions &lt;- 'which one is more beautiful?'
txt &lt;- streetscape::strview2pwc(scdataframe, k=1, header, questions)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
