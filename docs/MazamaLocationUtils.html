<!DOCTYPE html><html><head><title>Help for package MazamaLocationUtils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MazamaLocationUtils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#APIKeys'><p>API keys for data services.</p></a></li>
<li><a href='#clusterByDistance'><p>Add distance-clustering information to a dataframe</p></a></li>
<li><a href='#coreMetadataNames'><p>Names of standard spatial metadata columns</p></a></li>
<li><a href='#getLocationDataDir'><p>Get location data directory</p></a></li>
<li><a href='#id_monitors_500'><p>Idaho monitor locations dataset</p></a></li>
<li><a href='#initializeMazamaSpatialUtils'><p>Initialize MazamaSpatialUtils package</p></a></li>
<li><a href='#location_createID'><p>Create one or more unique locationIDs</p></a></li>
<li><a href='#location_getCensusBlock'><p>Get census block data from the FCC API</p></a></li>
<li><a href='#location_getOpenCageInfo'><p>Get location information from OpenCage</p></a></li>
<li><a href='#location_getSingleAddress_Photon'><p>Get address data from the Photon API to OpenStreetMap</p></a></li>
<li><a href='#location_getSingleAddress_TexasAM'><p>Get an address from the Texas A&amp;M reverse geocoding service</p></a></li>
<li><a href='#location_getSingleElevation_USGS'><p>Get elevation data from a USGS web service</p></a></li>
<li><a href='#location_initialize'><p>Create known location record with core metadata</p></a></li>
<li><a href='#LocationDataDir'><p>Directory for location data</p></a></li>
<li><a href='#MazamaLocationUtils'><p>Manage Spatial Metadata for Known Locations</p></a></li>
<li><a href='#or_monitors_500'><p>Oregon monitor locations dataset</p></a></li>
<li><a href='#setLocationDataDir'><p>Set location data directory</p></a></li>
<li><a href='#table_addClustering'><p>Add clustering information to a dataframe</p></a></li>
<li><a href='#table_addColumn'><p>Add a new column of metadata to a table</p></a></li>
<li><a href='#table_addCoreMetadata'><p>Add missing core metadata columns to a known location table</p></a></li>
<li><a href='#table_addLocation'><p>Add new known location records to a table</p></a></li>
<li><a href='#table_addOpenCageInfo'><p>Add address fields to a known location table</p></a></li>
<li><a href='#table_addSingleLocation'><p>Add a single new known location record to a table</p></a></li>
<li><a href='#table_filterByDistance'><p>Return known locations near a target location</p></a></li>
<li><a href='#table_findAdjacentDistances'><p>Find distances between adjacent locations in a known locations table</p></a></li>
<li><a href='#table_findAdjacentLocations'><p>Finds adjacent locations in a known locations table.</p></a></li>
<li><a href='#table_getDistanceFromTarget'><p>Return distances and directions from a target location to known locations</p></a></li>
<li><a href='#table_getLocationID'><p>Return IDs of known locations</p></a></li>
<li><a href='#table_getNearestDistance'><p>Return distances to nearest known locations</p></a></li>
<li><a href='#table_getNearestLocation'><p>Return known locations</p></a></li>
<li><a href='#table_getRecordIndex'><p>Return indexes of known location records</p></a></li>
<li><a href='#table_initialize'><p>Create an empty known location table</p></a></li>
<li><a href='#table_initializeExisting'><p>Converts an existing table into a known location table</p></a></li>
<li><a href='#table_leaflet'><p>Leaflet interactive map for known locations</p></a></li>
<li><a href='#table_leafletAdd'><p>Add to a leaflet interactive map for known locations</p></a></li>
<li><a href='#table_load'><p>Load a known location table</p></a></li>
<li><a href='#table_removeColumn'><p>Remove a column of metadata in a table</p></a></li>
<li><a href='#table_removeRecord'><p>Remove location records from a table</p></a></li>
<li><a href='#table_save'><p>Save a known location table</p></a></li>
<li><a href='#table_updateColumn'><p>Update a column of metadata in a table</p></a></li>
<li><a href='#table_updateSingleRecord'><p>Update a single known location record in a table</p></a></li>
<li><a href='#validateLocationTbl'><p>Validate a location table</p></a></li>
<li><a href='#validateLonLat'><p>Validate longitude and latitude values</p></a></li>
<li><a href='#validateLonsLats'><p>Validate longitude and latitude vectors</p></a></li>
<li><a href='#validateMazamaSpatialUtils'><p>Validate proper setup of MazamaSpatialUtils</p></a></li>
<li><a href='#wa_airfire_meta'><p>Washington monitor metadata dataset</p></a></li>
<li><a href='#wa_monitors_500'><p>Wshington monitor locations dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.3</td>
</tr>
<tr>
<td>Title:</td>
<td>Manage Spatial Metadata for Known Locations</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan Callahan &lt;jonathan.s.callahan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Utility functions for discovering and managing metadata 
    associated with spatially unique "known locations". Applications include
    all fields of environmental monitoring (e.g. air and water quality) where 
    data are collected at stationary sites.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MazamaScience/MazamaLocationUtils">https://github.com/MazamaScience/MazamaLocationUtils</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MazamaScience/MazamaLocationUtils/issues">https://github.com/MazamaScience/MazamaLocationUtils/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, dplyr, geodist (&ge; 0.0.8), httr, jsonlite, leaflet,
lubridate, magrittr, methods, MazamaCoreUtils (&ge; 0.5.1),
MazamaSpatialUtils (&ge; 0.8.6), readr, rlang, stringr,
tidygeocoder</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, testthat (&ge; 2.1.0), rmarkdown, roxygen2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 19:16:16 UTC; jonathancallahan</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan Callahan [aut, cre],
  Eli Grosman [ctb],
  Oliver Fogelin [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 15:22:53 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='APIKeys'>API keys for data services.</h2><span id='topic+APIKeys'></span><span id='topic+getAPIKey'></span><span id='topic+setAPIKey'></span><span id='topic+showAPIKeys'></span>

<h3>Description</h3>

<p>This package maintains an internal set of API keys which
users can set using <code>setAPIKey()</code>. These keys will be remembered for
the duration of an R session. This functionality provides an abstraction
layer in dependent packages so that data access functions can test for and
access specific API keys with generic code.
</p>


<h3>Format</h3>

<p>Character strings.
</p>


<h3>Details</h3>

<p>The following functions help with the management of API keys:
</p>
<p><code>getAPIKey()</code> &ndash; Returns the API key associated with a web service.
If <code>provider == NULL</code> a list is returned containing all recognized
API keys.
</p>
<p><code>setAPIKey()</code> &ndash; Sets the API key associated with a web service.
Silently returns previous value of the API key.
</p>
<p><code>showAPIKeys()</code> &ndash; Returns a list of all currently set API keys.
</p>

<hr>
<h2 id='clusterByDistance'>Add distance-clustering information to a dataframe</h2><span id='topic+clusterByDistance'></span>

<h3>Description</h3>

<p>Distance clustering is used to identify unique deployments of a
sensor in an environmental monitoring field study. GPS-reported locations can
be jittery and result in a sensor self-reporting from a cluster of nearby locations.
Clustering helps resolve this by assigning a single location to the cluster.
</p>
<p>Standard <code>kmeans</code> clustering does not work well when clusters can have
widely differing numbers of members. A much better result is acheived with
the Partitioning Around Medoids method available in <code>cluster::pam()</code>.
</p>
<p>The value of <code>clusterDiameter</code> is compared with the output of
<code>cluster::pam(...)$clusinfo[,'av_diss']</code> to determine the number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterByDistance(
  tbl,
  clusterDiameter = 1000,
  lonVar = "longitude",
  latVar = "latitude",
  maxClusters = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterByDistance_+3A_tbl">tbl</code></td>
<td>
<p>Tibble with geolocation information.</p>
</td></tr>
<tr><td><code id="clusterByDistance_+3A_clusterdiameter">clusterDiameter</code></td>
<td>
<p>Diameter in meters used to determine the number of
clusters (see description).</p>
</td></tr>
<tr><td><code id="clusterByDistance_+3A_lonvar">lonVar</code></td>
<td>
<p>Name of longitude variable in the incoming tibble.</p>
</td></tr>
<tr><td><code id="clusterByDistance_+3A_latvar">latVar</code></td>
<td>
<p>Name of the latitude variable in the incoming tibble.</p>
</td></tr>
<tr><td><code id="clusterByDistance_+3A_maxclusters">maxClusters</code></td>
<td>
<p>Maximum number of clusters to try.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input tibble with additional columns: <code>clusterLon, clusterLat, clusterID</code>.
</p>


<h3>Note</h3>

<p>In most applications, the <a href="#topic+table_addClustering">table_addClustering</a> function should be
used as it implements two-stage clustering using <code>clusterbyDistance()</code>.
</p>


<h3>References</h3>

<p><a href="https://working-with-data.mazamascience.com/2021/07/15/when-k-means-clustering-fails/">When k-means clustering fails</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+table_removeRecord">table_removeRecord</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

# Fremont, Seattle 47.6504, -122.3509
# Magnolia, Seattle 47.6403, -122.3997
# Downtown Seattle 47.6055, -122.3370

fremont_x &lt;- jitter(rep(-122.3509, 10), .0005)
fremont_y &lt;- jitter(rep(47.6504, 10), .0005)

magnolia_x &lt;- jitter(rep(-122.3997, 8), .0005)
magnolia_y &lt;- jitter(rep(47.6403, 8), .0005)

downtown_x &lt;- jitter(rep(-122.3370, 3), .0005)
downtown_y &lt;- jitter(rep(47.6055, 3), .0005)

# Apply clustering
tbl &lt;-
  dplyr::tibble(
    longitude = c(fremont_x, magnolia_x, downtown_x),
    latitude = c(fremont_y, magnolia_y, downtown_y)
  ) %&gt;%
  clusterByDistance(
    clusterDiameter = 1000
  )

plot(tbl$longitude, tbl$latitude, pch = tbl$clusterID)
</code></pre>

<hr>
<h2 id='coreMetadataNames'>Names of standard spatial metadata columns</h2><span id='topic+coreMetadataNames'></span>

<h3>Description</h3>

<p>Character string identifiers of the minimum set of fields
required for a table to be considered a valid &quot;known locations&quot; table.
</p>
<pre>
coreMetadataNames &lt;- c(
  "locationID",           # from MazamaLocationUtils::location_createID()
  "locationName",         # from MazamaLocationUtils::location_initialize()
  "longitude",            # user supplied
  "latitude",             # user supplied
  "elevation",            # from MazamaLocationUtils::getSingleElevation_USGS()
  "countryCode",          # from MazamaSpatialUtils::getCountryCode()
  "stateCode",            # from MazamaSpatialUtils::getStateCode()
  "countyName",           # from MazamaSpatialUtils::getUSCounty()
  "timezone",             # from MazamaSpatialUtils::getTimezone()
  "houseNumber",          # from MazamaLocationUtils::getSingleAddress_Photon()
  "street",               # from MazamaLocationUtils::getSingleAddress_Photon()
  "city",                 # from MazamaLocationUtils::getSingleAddress_Photon()
  "postalCode"            # from MazamaLocationUtils::getSingleAddress_Photon()
)
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>coreMetadataNames
</code></pre>


<h3>Format</h3>

<p>A vector with 3 elements
</p>


<h3>Details</h3>

<p>coreMetadataNames
</p>

<hr>
<h2 id='getLocationDataDir'>Get location data directory</h2><span id='topic+getLocationDataDir'></span>

<h3>Description</h3>

<p>Returns the directory path where known location data tables are located.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLocationDataDir()
</code></pre>


<h3>Value</h3>

<p>Absolute path string.
</p>


<h3>See Also</h3>

<p><a href="#topic+LocationDataDir">LocationDataDir</a>
</p>
<p><a href="#topic+setLocationDataDir">setLocationDataDir</a>
</p>

<hr>
<h2 id='id_monitors_500'>Idaho monitor locations dataset</h2><span id='topic+id_monitors_500'></span>

<h3>Description</h3>

<p>The <code>id_monitor_500</code> dataset provides a set of known
locations associated with Idaho state air quality monitors.
This dataset was generated on 2023-10-24 by running:
</p>
<pre>
library(AirMonitor)
library(MazamaLocationUtils)

initializeMazamaSpatialUtils()
setLocationDataDir("./data")

monitor &lt;- monitor_loadLatest() %&gt;% monitor_filter(stateCode == "ID")
lons &lt;- monitor$meta$longitude
lats &lt;- monitor$meta$latitude

table_initialize() %&gt;%
  table_addLocation(
    lons, lats,
    distanceThreshold = 500,
    elevationService = "usgs",
    addressService = "photon"
  ) %&gt;%
  table_save("id_monitors_500")
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>id_monitors_500
</code></pre>


<h3>Format</h3>

<p>A tibble with 30 rows and 13 columns of data.
</p>


<h3>See Also</h3>

<p><a href="#topic+or_monitors_500">or_monitors_500</a>
</p>
<p><a href="#topic+wa_monitors_500">wa_monitors_500</a>
</p>

<hr>
<h2 id='initializeMazamaSpatialUtils'>Initialize MazamaSpatialUtils package</h2><span id='topic+initializeMazamaSpatialUtils'></span>

<h3>Description</h3>

<p>Convenience function that wraps:
</p>
<pre>
  MazamaSpatialUtils::setSpatialDataDir("~/Data/Spatial")
  MazamaSpatialUtils::loadSpatialData("EEZCountries.rda")
.  MazamaSpatialUtils::loadSpatialData("OSMTimezones.rda")
  MazamaSpatialUtils::loadSpatialData("NaturalEarthAdm1.rda")
  MazamaSpatialUtils::loadSpatialData("USCensusCounties.rda")
</pre>
<p>If spatial data has not yet been installed, an error is returned with an
extended message detailing how to install the appropriate data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initializeMazamaSpatialUtils(spatialDataDir = "~/Data/Spatial")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initializeMazamaSpatialUtils_+3A_spatialdatadir">spatialDataDir</code></td>
<td>
<p>Directory where <span class="pkg">MazamaSpatialUtils</span> datasets are found.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MazamaLocationUtils)

# Fail gracefully if any resources are not available
try({

  # Set up directory for spatial data
  spatialDataDir &lt;- tempdir() # typically "~/Data/Spatial"
  MazamaSpatialUtils::setSpatialDataDir(spatialDataDir)

  exists("NaturalEarthAdm1")
  initializeMazamaSpatialUtils(spatialDataDir)
  exists("NaturalEarthAdm1")
  class(NaturalEarthAdm1)
  
}, silent = FALSE)

</code></pre>

<hr>
<h2 id='location_createID'>Create one or more unique locationIDs</h2><span id='topic+location_createID'></span>

<h3>Description</h3>

<p>A unique locationID is created for each incoming
<code>longitude</code> and <code>latitude</code>.
</p>
<p>See <code>MazamaCoreUtils::<a href="MazamaCoreUtils.html#topic+createLocationID">createLocationID</a></code> for details.
</p>
<p>At <code>precision = 10</code>, this results in a maximum error of 0.6 meters which
is more than precise enough for environmental monitoring studies making use
of this package.
</p>
<p>An excellent way to become familiar with geohash is through the
<a href="https://geohash.softeng.co">GeoHash Explorer</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>location_createID(
  longitude = NULL,
  latitude = NULL,
  algorithm = c("geohash", "digest"),
  precision = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="location_createID_+3A_longitude">longitude</code></td>
<td>
<p>Vector of longitudes in decimal degrees E.</p>
</td></tr>
<tr><td><code id="location_createID_+3A_latitude">latitude</code></td>
<td>
<p>Vector of latitudes in decimal degrees N.</p>
</td></tr>
<tr><td><code id="location_createID_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm to use &ndash; either <code>"geohash"</code> or <code>"digest"</code>.</p>
</td></tr>
<tr><td><code id="location_createID_+3A_precision">precision</code></td>
<td>
<p><code>precision</code> argument used when encoding with <code>"geohash"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of character locationIDs.
</p>


<h3>Note</h3>

<p>The <code>"digest"</code> algorithm is deprecated but provided for backwards
compatibility with databases that were built using locationIDs generated
with this algorithm.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Decimal_degrees">https://en.wikipedia.org/wiki/Decimal_degrees</a>
</p>
<p><a href="https://www.johndcook.com/blog/2017/01/10/probability-of-secure-hash-collisions/">https://www.johndcook.com/blog/2017/01/10/probability-of-secure-hash-collisions/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

# Wenatchee
lon &lt;- -120.325278
lat &lt;- 47.423333
locationID &lt;- location_createID(lon, lat)
print(locationID)

location_createID(lon, lat, algorithm = "geohash")
location_createID(lon, lat, algorithm = "geohash", precision = 7)

</code></pre>

<hr>
<h2 id='location_getCensusBlock'>Get census block data from the FCC API</h2><span id='topic+location_getCensusBlock'></span>

<h3>Description</h3>

<p>The FCC Block API is used get census block, county, and state FIPS associated with
the <code>longitude</code> and <code>latitude</code>. The following list of data
is returned:
</p>

<ul>
<li><p><code>stateCode</code>
</p>
</li>
<li><p><code>countyName</code>
</p>
</li>
<li><p><code>censusBlock</code>
</p>
</li></ul>

<p>The data from this function should be considered to be the gold standard for state and county.
i.e. this information could and should be used to override information we get elsewhere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>location_getCensusBlock(
  longitude = NULL,
  latitude = NULL,
  censusYear = 2010,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="location_getCensusBlock_+3A_longitude">longitude</code></td>
<td>
<p>Single longitude in decimal degrees E.</p>
</td></tr>
<tr><td><code id="location_getCensusBlock_+3A_latitude">latitude</code></td>
<td>
<p>Single latitude in decimal degrees N.</p>
</td></tr>
<tr><td><code id="location_getCensusBlock_+3A_censusyear">censusYear</code></td>
<td>
<p>Year the census was taken.</p>
</td></tr>
<tr><td><code id="location_getCensusBlock_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of census block/county/state data.
</p>


<h3>References</h3>

<p><a href="https://geo.fcc.gov/api/census/">https://geo.fcc.gov/api/census/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MazamaLocationUtils)

# Fail gracefully if any resources are not available
try({

  # Wenatchee
  lon &lt;- -120.325278
  lat &lt;- 47.423333

  censusList &lt;- location_getCensusBlock(lon, lat)
  str(censusList)
  
}, silent = FALSE)

</code></pre>

<hr>
<h2 id='location_getOpenCageInfo'>Get location information from OpenCage</h2><span id='topic+location_getOpenCageInfo'></span>

<h3>Description</h3>

<p>The OpenCage reverse geocoding service is used to obtain all
available information for a specific location.
</p>
<p>The data from OpenCage should be considered to be the gold standard for address
information could and should be used to override information we get elsewhere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>location_getOpenCageInfo(longitude = NULL, latitude = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="location_getOpenCageInfo_+3A_longitude">longitude</code></td>
<td>
<p>Single longitude in decimal degrees E.</p>
</td></tr>
<tr><td><code id="location_getOpenCageInfo_+3A_latitude">latitude</code></td>
<td>
<p>Single latitude in decimal degrees N.</p>
</td></tr>
<tr><td><code id="location_getOpenCageInfo_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single-row tibble with OpenCage information.
</p>


<h3>Note</h3>

<p>The OpenCage service requires an API key which can be obtained from
their web site. This API key must be set as an environment variable with:
</p>
<pre>
Sys.setenv("OPENCAGE_KEY" = "YOUR_PERSONAL_API_KEY")
</pre>
<p>The OpenCage &quot;free trial&quot; level allows for 1 request/sec and a maximum of
2500 requests per day.
</p>


<h3>References</h3>

<p><a href="https://opencagedata.com">https://opencagedata.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MazamaLocationUtils)

# Fail gracefully if any resources are not available
try({

  # Wenatchee
  lon &lt;- -120.325278
  lat &lt;- 47.423333

  Sys.setenv("OPENCAGE_KEY" = "YOUR_PERSONAL_API_KEY")

  openCageTbl &lt;- location_getOpenCageInfo(lon, lat)
  dplyr::glimpse(openCageTbl)
  
}, silent = FALSE)


</code></pre>

<hr>
<h2 id='location_getSingleAddress_Photon'>Get address data from the Photon API to OpenStreetMap</h2><span id='topic+location_getSingleAddress_Photon'></span>

<h3>Description</h3>

<p>The Photon API is used get address data associated with
the <code>longitude</code> and <code>latitude</code>. The following list of data
is returned:
</p>

<ul>
<li><p><code>houseNumber</code>
</p>
</li>
<li><p><code>street</code>
</p>
</li>
<li><p><code>city</code>
</p>
</li>
<li><p><code>stateCode</code>
</p>
</li>
<li><p><code>stateName</code>
</p>
</li>
<li><p><code>postalCode</code>
</p>
</li>
<li><p><code>countryCode</code>
</p>
</li>
<li><p><code>countryName</code>
</p>
</li></ul>

<p>The function makes an effort to convert both <code>state</code> and <code>country</code>
<code>Name</code> into <code>Code</code> with codes defaulting to <code>NA</code>. Both
<code>Name</code> and <code>Code</code> are returned so that improvements can be made in
the conversion algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>location_getSingleAddress_Photon(
  longitude = NULL,
  latitude = NULL,
  baseUrl = "https://photon.komoot.io/reverse",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="location_getSingleAddress_Photon_+3A_longitude">longitude</code></td>
<td>
<p>Single longitude in decimal degrees E.</p>
</td></tr>
<tr><td><code id="location_getSingleAddress_Photon_+3A_latitude">latitude</code></td>
<td>
<p>Single latitude in decimal degrees N.</p>
</td></tr>
<tr><td><code id="location_getSingleAddress_Photon_+3A_baseurl">baseUrl</code></td>
<td>
<p>Base URL for data queries.</p>
</td></tr>
<tr><td><code id="location_getSingleAddress_Photon_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of address components.
</p>


<h3>References</h3>

<p><a href="https://photon.komoot.io">https://photon.komoot.io</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MazamaLocationUtils)

# Fail gracefully if any resources are not available
try({

  # Set up standard directories and spatial data
  spatialDataDir &lt;- tempdir() # typically "~/Data/Spatial"
  initializeMazamaSpatialUtils(spatialDataDir)

  # Wenatchee
  lon &lt;- -120.325278
  lat &lt;- 47.423333

  addressList &lt;- location_getSingleAddress_Photon(lon, lat)
  str(addressList)
  
}, silent = FALSE)


</code></pre>

<hr>
<h2 id='location_getSingleAddress_TexasAM'>Get an address from the Texas A&amp;M reverse geocoding service</h2><span id='topic+location_getSingleAddress_TexasAM'></span>

<h3>Description</h3>

<p>Texas A&amp;M APIs are used to determine the address associated with
the <code>longitude</code> and <code>latitude</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>location_getSingleAddress_TexasAM(
  longitude = NULL,
  latitude = NULL,
  apiKey = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="location_getSingleAddress_TexasAM_+3A_longitude">longitude</code></td>
<td>
<p>Single longitude in decimal degrees E.</p>
</td></tr>
<tr><td><code id="location_getSingleAddress_TexasAM_+3A_latitude">latitude</code></td>
<td>
<p>Single latitude in decimal degrees N.</p>
</td></tr>
<tr><td><code id="location_getSingleAddress_TexasAM_+3A_apikey">apiKey</code></td>
<td>
<p>Texas A&amp;M Geocoding requires an API key. The first 2500 requests
are free.</p>
</td></tr>
<tr><td><code id="location_getSingleAddress_TexasAM_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric elevation value.
</p>


<h3>References</h3>

<p><a href="https://geoservices.tamu.edu/Services/ReverseGeocoding/WebService/v04_01/HTTP.aspx">https://geoservices.tamu.edu/Services/ReverseGeocoding/WebService/v04_01/HTTP.aspx</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(MazamaLocationUtils)

# Fail gracefully if any resources are not available
try({

  # Wenatchee
  longitude &lt;- -122.47
  latitude &lt;- 47.47
  apiKey &lt;- YOUR_PERSONAL_API_KEY

  location_getSingleAddress_TexasAM(longitude, latitude, apiKey)
  
}, silent = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='location_getSingleElevation_USGS'>Get elevation data from a USGS web service</h2><span id='topic+location_getSingleElevation_USGS'></span>

<h3>Description</h3>

<p>USGS APIs are used to determine the elevation in meters
associated with the <code>longitude</code> and <code>latitude</code>.
</p>
<p><em>Note: The conversion factor for meters to feet is 3.28084.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>location_getSingleElevation_USGS(
  longitude = NULL,
  latitude = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="location_getSingleElevation_USGS_+3A_longitude">longitude</code></td>
<td>
<p>Single longitude in decimal degrees E.</p>
</td></tr>
<tr><td><code id="location_getSingleElevation_USGS_+3A_latitude">latitude</code></td>
<td>
<p>Single latitude in decimal degrees N.</p>
</td></tr>
<tr><td><code id="location_getSingleElevation_USGS_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric elevation value.
</p>


<h3>References</h3>

<p><a href="https://epqs.nationalmap.gov/v1/docs">https://epqs.nationalmap.gov/v1/docs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MazamaLocationUtils)

# Fail gracefully if any resources are not available
try({

  # Wenatchee
  longitude &lt;- -120.325278
  latitude &lt;- 47.423333

  location_getSingleElevation_USGS(longitude, latitude)
  
}, silent = FALSE)


</code></pre>

<hr>
<h2 id='location_initialize'>Create known location record with core metadata</h2><span id='topic+location_initialize'></span>

<h3>Description</h3>

<p>Creates a known location record with the following columns
of core metadata:
</p>

<ul>
<li><p>locationID
</p>
</li>
<li><p>locationName
</p>
</li>
<li><p>longitude
</p>
</li>
<li><p>latitude
</p>
</li>
<li><p>elevation
</p>
</li>
<li><p>countryCode
</p>
</li>
<li><p>stateCode
</p>
</li>
<li><p>countyName
</p>
</li>
<li><p>timezone
</p>
</li>
<li><p>houseNumber
</p>
</li>
<li><p>street
</p>
</li>
<li><p>city
</p>
</li>
<li><p>postalCode
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>location_initialize(
  longitude = NULL,
  latitude = NULL,
  stateDataset = "NaturalEarthAdm1",
  elevationService = NULL,
  addressService = NULL,
  precision = 10,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="location_initialize_+3A_longitude">longitude</code></td>
<td>
<p>Single longitude in decimal degrees E.</p>
</td></tr>
<tr><td><code id="location_initialize_+3A_latitude">latitude</code></td>
<td>
<p>Single latitude in decimal degrees N.</p>
</td></tr>
<tr><td><code id="location_initialize_+3A_statedataset">stateDataset</code></td>
<td>
<p>Name of spatial dataset to use for determining state</p>
</td></tr>
<tr><td><code id="location_initialize_+3A_elevationservice">elevationService</code></td>
<td>
<p>Name of the elevation service to use for determining
the elevation. Default: NULL skips this step. Accepted values: &quot;usgs&quot;.</p>
</td></tr>
<tr><td><code id="location_initialize_+3A_addressservice">addressService</code></td>
<td>
<p>Name of the address service to use for determining
the street address. Default: NULL skips this step. Accepted values: &quot;photon&quot;.</p>
</td></tr>
<tr><td><code id="location_initialize_+3A_precision">precision</code></td>
<td>
<p><code>precision</code> argument passed on to <a href="#topic+location_createID">location_createID</a>.</p>
</td></tr>
<tr><td><code id="location_initialize_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble with a single new known location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MazamaLocationUtils)

# Fail gracefully if any resources are not available
try({

  # Set up standard directories and spatial data
  spatialDataDir &lt;- tempdir() # typically "~/Data/Spatial"
  initializeMazamaSpatialUtils(spatialDataDir)

  # Wenatchee
  lon &lt;- -120.325278
  lat &lt;- 47.423333
  
  locationRecord &lt;- location_initialize(lon, lat)
  str(locationRecord)
  
}, silent = FALSE)

</code></pre>

<hr>
<h2 id='LocationDataDir'>Directory for location data</h2><span id='topic+LocationDataDir'></span>

<h3>Description</h3>

<p>This package maintains an internal directory path which
users can set using <code>setLocationDataDir()</code>. All package functions use
this directory whenever known location tables are accessed.
</p>
<p>The default setting when the package is loaded is <code>getwd()</code>.
</p>


<h3>Format</h3>

<p>Absolute path string.
</p>


<h3>See Also</h3>

<p><a href="#topic+getLocationDataDir">getLocationDataDir</a>
</p>
<p><a href="#topic+setLocationDataDir">setLocationDataDir</a>
</p>

<hr>
<h2 id='MazamaLocationUtils'>Manage Spatial Metadata for Known Locations</h2><span id='topic+MazamaLocationUtils'></span><span id='topic+MazamaLocationUtils-package'></span>

<h3>Description</h3>

<p>A suite of utility functions for discovering and managing
metadata associated with sets of spatially unique &quot;known locations&quot;.
</p>
<p>This package is intended to be used in support of data management activities
associated with fixed locations in space. The motivating fields include both
air and water quality monitoring where fixed sensors report at regular time
intervals.
</p>


<h3>Details</h3>

<p>When working with environmental monitoring time series, one of the first things
you have to do is create unique identifiers for each individual time series. In
an ideal world, each environmental time series would have both a
<code>locationID</code> and a <code>deviceID</code> that uniquely identify the specific instrument
making measurements and the physical location where measurements are made. A
unique <code>timeseriesID</code> could
be produced as <code>locationID_deviceID</code>. Metadata associated with each
<code>timeseriesID</code> would contain basic information needed for downstream analysis
including at least:
</p>
<pre>
  timeseriesID, locationID, deviceID, longitude, latitude, ...
</pre>

<ul>
<li><p>An extended time series for an occasionally re-positioned sensor would group by <code>deviceID</code>.
</p>
</li>
<li><p>Multiple sensors placed at a single location could be be grouped by <code>locationID</code>.
</p>
</li>
<li><p>Maps would be created using <code>longitude, latitude</code>.
</p>
</li>
<li><p>Time series would be accessed from a secondary <code>data</code> table with <code>timeseriesID</code>.
</p>
</li></ul>

<p>Unfortunately, we are rarely supplied with a truly unique and truly spatial
<code>locationID</code>. Instead we often use <code>deviceID</code> or an associated non-spatial
identifier as a stand-in for <code>locationID</code>.
</p>
<p>Complications we have seen include:
</p>

<ul>
<li><p>GPS-reported longitude and latitude can have <em>jitter</em> in the fourth or fifth
decimal place making it challenging to use them to create a unique <code>locationID</code>.
</p>
</li>
<li><p>Sensors are sometimes <em>re-positioned</em> in what the scientist considers the &quot;same
location&quot;.
</p>
</li>
<li><p>Data for a single sensor goes through different processing pipelines using
different identifiers and is later brought together as two separate time series.
</p>
</li>
<li><p>The spatial scale of what constitutes a &quot;single location&quot; depends on the
instrumentation and scientific question being asked.
</p>
</li>
<li><p>Deriving location-based metadata from spatial datasets is computationally
intensive unless saved and identified with a unique <code>locationID</code>.
</p>
</li>
<li><p>Automated searches for spatial metadata occasionally produce incorrect results
because of the non-infinite resolution of spatial datasets.
</p>
</li></ul>

<p>This package attempts to address all of these issues by maintaining a table
of known locations for which CPU intensive spatial data calculations have
already been performed. While requests to add new locations to the table may
take some time, searches for spatial metadata associated with existing
locations are simple lookups.
</p>
<p>Working in this manner will solve the problems initially mentioned but also
provides further useful functionality.
</p>

<ul>
<li><p>Administrators can correct entries in the <code>collectionName</code> table.
(<em>e.g.</em> locations in river bends that even high resolution spatial datasets mis-assign)
</p>
</li>
<li><p>Additional, non-automatable metadata can be added to <code>collectionName</code>.
(<em>e.g.</em> commonly used location names within a community of practice)
</p>
</li>
<li><p>Different field campaigns can have separate <code>collectionName</code> tables.
</p>
</li>
<li><p><code>.csv</code> or <code>.rda</code> versions of well populated tables can be downloaded from a
URL and used locally, giving scientists working with known locations instant
access to spatial data that otherwise requires special skills, large datasets
and lots of compute cycles.
</p>
</li></ul>


<hr>
<h2 id='or_monitors_500'>Oregon monitor locations dataset</h2><span id='topic+or_monitors_500'></span>

<h3>Description</h3>

<p>The <code>or_monitor_500</code> dataset provides a set of known
locations associated with Oregon state air quality monitors.
This dataset was generated on 2023-10-24 by running:
</p>
<pre>
library(AirMonitor)
library(MazamaLocationUtils)

initializeMazamaSpatialUtils()
setLocationDataDir("./data")

monitor &lt;- monitor_loadLatest() %&gt;% monitor_filter(stateCode == "OR")
lons &lt;- monitor$meta$longitude
lats &lt;- monitor$meta$latitude

table_initialize() %&gt;%
  table_addLocation(
    lons, lats, 
      distanceThreshold = 500,
      elevationService = "usgs",
      addressService = "photon"
    ) %&gt;%
  table_save("or_monitors_500")
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>or_monitors_500
</code></pre>


<h3>Format</h3>

<p>A tibble with 64 rows and 13 columns of data.
</p>


<h3>See Also</h3>

<p><a href="#topic+id_monitors_500">id_monitors_500</a>
</p>
<p><a href="#topic+wa_monitors_500">wa_monitors_500</a>
</p>

<hr>
<h2 id='setLocationDataDir'>Set location data directory</h2><span id='topic+setLocationDataDir'></span>

<h3>Description</h3>

<p>Sets the data directory where known location data tables are located.
If the directory does not exist, it will be created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLocationDataDir(dataDir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setLocationDataDir_+3A_datadir">dataDir</code></td>
<td>
<p>Directory where location tables are stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Silently returns previous value of the data directory.
</p>


<h3>See Also</h3>

<p><a href="#topic+LocationDataDir">LocationDataDir</a>
</p>
<p><a href="#topic+getLocationDataDir">getLocationDataDir</a>
</p>

<hr>
<h2 id='table_addClustering'>Add clustering information to a dataframe</h2><span id='topic+table_addClustering'></span>

<h3>Description</h3>

<p>Clustering is used to identify unique deployments of a
sensor in an environmental monitoring field study.
</p>
<p>Sensors will be moved around from time to time, sometimes across the country
and sometimes across the street.  We would like to assign unique identifiers
to each new &quot;deployment&quot; but not when the sensor is moved a short distance.
</p>
<p>We use clustering to find an appropriate number of unique &quot;deployments&quot;.
The sensitivity of this algorithm can be adjused with the clusterDiameter argument.
</p>
<p>Standard <code>kmeans</code> clustering does not work well when clusters can have widely
differing numbers of members. A much better result is acheived with
the Partitioning Around Medoids method available in <code>cluster::pam()</code>.
</p>
<p>The value of <code>clusterRadius</code> is compared with the output of
<code>cluster::pam(...)$clusinfo[,'av_diss']</code> to determine the number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_addClustering(
  tbl,
  clusterDiameter = 1000,
  lonVar = "longitude",
  latVar = "latitude",
  maxClusters = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_addClustering_+3A_tbl">tbl</code></td>
<td>
<p>Tibble with geolocation information (<em>e.g.</em>.</p>
</td></tr>
<tr><td><code id="table_addClustering_+3A_clusterdiameter">clusterDiameter</code></td>
<td>
<p>Diameter in meters used to determine the number of
clusters (see description).</p>
</td></tr>
<tr><td><code id="table_addClustering_+3A_lonvar">lonVar</code></td>
<td>
<p>Name of longitude variable in the incoming tibble.</p>
</td></tr>
<tr><td><code id="table_addClustering_+3A_latvar">latVar</code></td>
<td>
<p>Name of the latitude variable in the incoming tibble.</p>
</td></tr>
<tr><td><code id="table_addClustering_+3A_maxclusters">maxClusters</code></td>
<td>
<p>Maximum number of clusters to try.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input tibble with additional columns: <code>clusterLon, clusterLat</code>.
</p>


<h3>Note</h3>

<p>The <code>table_addClustering()</code> function implements two-stage clustering
using <a href="#topic+clusterByDistance">clusterByDistance</a>. If the first attempt at clustering produces
clustered locations that are still too close to eachother, another round
of clustering is performed using the results of the previous attempt. This
two-stage approach seems to work well in. practice.
</p>


<h3>References</h3>

<p><a href="https://working-with-data.mazamascience.com/2021/07/15/when-k-means-clustering-fails/">When k-means clustering fails</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+clusterByDistance">clusterByDistance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

# Fremont, Seattle 47.6504, -122.3509
# Magnolia, Seattle 47.6403, -122.3997
# Downtown Seattle 47.6055, -122.3370

fremont_x &lt;- jitter(rep(-122.3509, 10), .0005)
fremont_y &lt;- jitter(rep(47.6504, 10), .0005)

magnolia_x &lt;- jitter(rep(-122.3997, 8), .0005)
magnolia_y &lt;- jitter(rep(47.6403, 8), .0005)

downtown_x &lt;- jitter(rep(-122.3370, 3), .0005)
downtown_y &lt;- jitter(rep(47.6055, 3), .0005)

# Apply clustering
tbl &lt;-
  dplyr::tibble(
    longitude = c(fremont_x, magnolia_x, downtown_x),
    latitude = c(fremont_y, magnolia_y, downtown_y)
  ) %&gt;%
  table_addClustering(
    clusterDiameter = 1000
  )

plot(tbl$longitude, tbl$latitude, pch = tbl$clusterID)
</code></pre>

<hr>
<h2 id='table_addColumn'>Add a new column of metadata to a table</h2><span id='topic+table_addColumn'></span>

<h3>Description</h3>

<p>A new metadata column is added to the <code>locationTbl</code>. For
matching <code>locationID</code> records, the associated <code>locationData</code> is
inserted. Otherwise, the new column will be initialized with <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_addColumn(
  locationTbl = NULL,
  columnName = NULL,
  locationID = NULL,
  locationData = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_addColumn_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_addColumn_+3A_columnname">columnName</code></td>
<td>
<p>Name to use for the new column.</p>
</td></tr>
<tr><td><code id="table_addColumn_+3A_locationid">locationID</code></td>
<td>
<p>Vector of <code>locationID</code> strings.</p>
</td></tr>
<tr><td><code id="table_addColumn_+3A_locationdata">locationData</code></td>
<td>
<p>Vector of data to used at matching records.</p>
</td></tr>
<tr><td><code id="table_addColumn_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated tibble of known locations.
</p>


<h3>See Also</h3>

<p><a href="#topic+table_removeColumn">table_removeColumn</a>
</p>
<p><a href="#topic+table_updateColumn">table_updateColumn</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

# Starting table
locationTbl &lt;- get(data("wa_monitors_500")) 
names(locationTbl)

# Add an empty column
locationTbl &lt;-
  locationTbl %&gt;%
  table_addColumn("AQSID")
  
names(locationTbl)

</code></pre>

<hr>
<h2 id='table_addCoreMetadata'>Add missing core metadata columns to a known location table</h2><span id='topic+table_addCoreMetadata'></span>

<h3>Description</h3>

<p>An existing table will be amended to guarantee that it includes
the following core metadata columns.
</p>

<ul>
<li><p>locationID
</p>
</li>
<li><p>locationName
</p>
</li>
<li><p>longitude
</p>
</li>
<li><p>latitude
</p>
</li>
<li><p>elevation
</p>
</li>
<li><p>countryCode
</p>
</li>
<li><p>stateCode
</p>
</li>
<li><p>countyName
</p>
</li>
<li><p>timezone
</p>
</li>
<li><p>houseNumber
</p>
</li>
<li><p>street
</p>
</li>
<li><p>city
</p>
</li>
<li><p>postalCode
</p>
</li></ul>

<p>The <code>longitude</code> and <code>latitude</code> columns are required to exist in the
incoming tibble but all others are optional.
</p>
<p>If any of these core metadata columns are found, they will be retained.
</p>
<p>The <code>locationID</code> will be generated (anew if already found) from existing
longitude and latitude data.
</p>
<p>Other core metadata columns will be filled with <code>NA</code> values of the
proper type.
</p>
<p>The result is a tibble with all of the core metadata columns. Theses columns
must then be filled in to create a usable &quot;known locations&quot; table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_addCoreMetadata(locationTbl = NULL, precision = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_addCoreMetadata_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations. This input tibble need not be a
standardized &quot;known location&quot; with all required columns. They will be added.</p>
</td></tr>
<tr><td><code id="table_addCoreMetadata_+3A_precision">precision</code></td>
<td>
<p><code>precision</code> argument passed on to <a href="#topic+location_createID">location_createID</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble with the metadata columns required in a &quot;known locations&quot; table.
</p>


<h3>Note</h3>

<p>No check is performed for overlapping locations. The returned tibble
has the structure of a &quot;known locations&quot; table and is a good starting place
for investigation. But further work is required to produce a valid table of
&quot;known locations&quot; associated with a specific spatial scale.
</p>

<hr>
<h2 id='table_addLocation'>Add new known location records to a table</h2><span id='topic+table_addLocation'></span>

<h3>Description</h3>

<p>Incoming <code>longitude</code> and <code>latitude</code> values are compared
against the incoming <code>locationTbl</code> to see if they are already within
<code>distanceThreshold</code> meters of an existing entry. A new record is created for
each location that is not already found in <code>locationTbl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_addLocation(
  locationTbl = NULL,
  longitude = NULL,
  latitude = NULL,
  distanceThreshold = NULL,
  stateDataset = "NaturalEarthAdm1",
  elevationService = NULL,
  addressService = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_addLocation_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_addLocation_+3A_longitude">longitude</code></td>
<td>
<p>Vector of longitudes in decimal degrees E.</p>
</td></tr>
<tr><td><code id="table_addLocation_+3A_latitude">latitude</code></td>
<td>
<p>Vector of latitudes in decimal degrees N.</p>
</td></tr>
<tr><td><code id="table_addLocation_+3A_distancethreshold">distanceThreshold</code></td>
<td>
<p>Distance in meters.</p>
</td></tr>
<tr><td><code id="table_addLocation_+3A_statedataset">stateDataset</code></td>
<td>
<p>Name of spatial dataset to use for determining state
codes, Default: 'NaturalEarthAdm1'</p>
</td></tr>
<tr><td><code id="table_addLocation_+3A_elevationservice">elevationService</code></td>
<td>
<p>Name of the elevation service to use for determining
the elevation. Default: NULL skips this step. Accepted values: &quot;usgs&quot;.</p>
</td></tr>
<tr><td><code id="table_addLocation_+3A_addressservice">addressService</code></td>
<td>
<p>Name of the address service to use for determining
the street address. Default: NULL skips this step. Accepted values: &quot;photon&quot;.</p>
</td></tr>
<tr><td><code id="table_addLocation_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated tibble of known locations.
</p>


<h3>Note</h3>

<p>This function is a vectorized version of <code>table_addSingleLocation()</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+table_addSingleLocation">table_addSingleLocation</a>
</p>
<p><a href="#topic+table_removeRecord">table_removeRecord</a>
</p>
<p><a href="#topic+table_updateSingleRecord">table_updateSingleRecord</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MazamaLocationUtils)

# Fail gracefully if any resources are not available
try({

  # Set up standard directories and spatial data
  spatialDataDir &lt;- tempdir() # typically "~/Data/Spatial"
  initializeMazamaSpatialUtils(spatialDataDir)

  locationTbl &lt;- get(data("wa_monitors_500"))

  # Coulee City, WA
  lon &lt;- -119.290904
  lat &lt;- 47.611942

  locationTbl &lt;- 
    locationTbl %&gt;%
    table_addLocation(lon, lat, distanceThreshold = 500)
  
  dplyr::glimpse(locationTbl)
  
}, silent = FALSE)

</code></pre>

<hr>
<h2 id='table_addOpenCageInfo'>Add address fields to a known location table</h2><span id='topic+table_addOpenCageInfo'></span>

<h3>Description</h3>

<p>The OpenCage reverse geocoding service is used to update an
existing table. Updated columns include:
</p>

<ul>
<li><p>countryCode
</p>
</li>
<li><p>stateCode
</p>
</li>
<li><p>countyName
</p>
</li>
<li><p>timezone
</p>
</li>
<li><p>houseNumber
</p>
</li>
<li><p>street
</p>
</li>
<li><p>city
</p>
</li>
<li><p>postalCode
</p>
</li>
<li><p>address
</p>
</li></ul>

<p>When <code>replaceExisting = TRUE</code>, all existing address fields are discarded
in favor of the OpenCage versions. To only fill in missing values in
<code>locationTbl</code>, use <code>replaceExisting = FALSE</code>.
</p>
<p>The OpenCage service returns a large number of fields, some of which may be
useful. To add all OpenCage fields to a location table, use
<code>retainOpenCage = TRUE</code>. This will append 78+ fields of information,
each each named with a prefix of <code>"opencage_"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_addOpenCageInfo(
  locationTbl = NULL,
  replaceExisting = FALSE,
  retainOpenCage = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_addOpenCageInfo_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_addOpenCageInfo_+3A_replaceexisting">replaceExisting</code></td>
<td>
<p>Logical specifying whether to replace existing data
with data obtained from OpenCage.</p>
</td></tr>
<tr><td><code id="table_addOpenCageInfo_+3A_retainopencage">retainOpenCage</code></td>
<td>
<p>Logical specifying whether to retain all fields obtained
from OpenCage, each named with a prefix of <code>opencage_</code>.</p>
</td></tr>
<tr><td><code id="table_addOpenCageInfo_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of &quot;known locations&quot; enhanced with information from the
OpenCage reverse geocoding service.
</p>


<h3>Note</h3>

<p>The OpenCage service requires an API key which can be obtained from
their web site. This API key must be set as an environment variable with:
</p>
<pre>
Sys.setenv("OPENCAGE_KEY" = "&lt;your api key&gt;")
</pre>
<p>Parameters are set for use at the OpenCage &quot;free trial&quot; level which allows
for 1 request/sec and a maximum of 2500 requests per day.
</p>
<p>Because of the 1 request/sec default, it is recommended that
<code>table_addOpenCageInfo()</code> only be used in an interactive session when
updating a table with a large number of records.
</p>


<h3>References</h3>

<p><a href="https://opencagedata.com">https://opencagedata.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MazamaLocationUtils)

# Fail gracefully if any resources are not available
try({

  myTbl &lt;- id_monitors_500[1:3,]
  myTbl$countryCode[1] &lt;- NA
  myTbl$countryCode[2] &lt;- "WRONG"
  myTbl$countyName[3] &lt;- "WRONG"
  myTbl$timezone &lt;- NA

  dplyr::glimpse(myTbl)

  Sys.setenv("OPENCAGE_KEY" = "&lt;YOUR_KEY&gt;")

  table_addOpenCageInfo(myTbl) %&gt;% 
    dplyr::glimpse()

  table_addOpenCageInfo(myTbl, replaceExisting = TRUE) %&gt;% 
    dplyr::glimpse()

  table_addOpenCageInfo(myTbl, replaceExisting = TRUE, retainOpenCage = TRUE) %&gt;% 
    dplyr::glimpse()
  
}, silent = FALSE)

</code></pre>

<hr>
<h2 id='table_addSingleLocation'>Add a single new known location record to a table</h2><span id='topic+table_addSingleLocation'></span>

<h3>Description</h3>

<p>Incoming <code>longitude</code> and <code>latitude</code> values are compared
against the incoming <code>locationTbl</code> to see if they are already within
<code>distanceThreshold</code> meters of an existing entry.  A new record is created for
if the location is not already found in <code>locationTbl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_addSingleLocation(
  locationTbl = NULL,
  longitude = NULL,
  latitude = NULL,
  distanceThreshold = NULL,
  stateDataset = "NaturalEarthAdm1",
  elevationService = NULL,
  addressService = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_addSingleLocation_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_addSingleLocation_+3A_longitude">longitude</code></td>
<td>
<p>Single longitude in decimal degrees E.</p>
</td></tr>
<tr><td><code id="table_addSingleLocation_+3A_latitude">latitude</code></td>
<td>
<p>Single latitude in decimal degrees N.</p>
</td></tr>
<tr><td><code id="table_addSingleLocation_+3A_distancethreshold">distanceThreshold</code></td>
<td>
<p>Distance in meters.</p>
</td></tr>
<tr><td><code id="table_addSingleLocation_+3A_statedataset">stateDataset</code></td>
<td>
<p>Name of spatial dataset to use for determining state
codes, Default: &quot;NaturalEarthAdm1&quot;.</p>
</td></tr>
<tr><td><code id="table_addSingleLocation_+3A_elevationservice">elevationService</code></td>
<td>
<p>Name of the elevation service to use for determining
the elevation. Default: NULL. Accepted values: &quot;usgs&quot;.</p>
</td></tr>
<tr><td><code id="table_addSingleLocation_+3A_addressservice">addressService</code></td>
<td>
<p>Name of the address service to use for determining
the street address. Default: NULL. Accepted values: &quot;photon&quot;.</p>
</td></tr>
<tr><td><code id="table_addSingleLocation_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated tibble of known locations.
</p>


<h3>See Also</h3>

<p><a href="#topic+table_addLocation">table_addLocation</a>
</p>
<p><a href="#topic+table_removeRecord">table_removeRecord</a>
</p>
<p><a href="#topic+table_updateSingleRecord">table_updateSingleRecord</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MazamaLocationUtils)

# Fail gracefully if any resources are not available
try({

  # Set up standard directories and spatial data
  spatialDataDir &lt;- tempdir() # typically "~/Data/Spatial"
  initializeMazamaSpatialUtils(spatialDataDir)

  locationTbl &lt;- get(data("wa_monitors_500"))
  
  nrow(locationTbl)

  # Coulee City, WA
  lon &lt;- -119.290904
  lat &lt;- 47.611942

  locationTbl &lt;- 
    locationTbl %&gt;%
    table_addSingleLocation(lon, lat, distanceThreshold = 500)
    
  nrow(locationTbl)
  
}, silent = FALSE)


</code></pre>

<hr>
<h2 id='table_filterByDistance'>Return known locations near a target location</h2><span id='topic+table_filterByDistance'></span>

<h3>Description</h3>

<p>Returns a tibble of the known locations from <code>locationTbl</code>
that are within <code>distanceThreshold</code> meters of the target location
specified by <code>longitude</code> and <code>latitude</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_filterByDistance(
  locationTbl = NULL,
  longitude = NULL,
  latitude = NULL,
  distanceThreshold = NULL,
  measure = c("geodesic", "haversine", "vincenty", "cheap")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_filterByDistance_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_filterByDistance_+3A_longitude">longitude</code></td>
<td>
<p>Target longitude in decimal degrees E.</p>
</td></tr>
<tr><td><code id="table_filterByDistance_+3A_latitude">latitude</code></td>
<td>
<p>Target latitude in decimal degrees N.</p>
</td></tr>
<tr><td><code id="table_filterByDistance_+3A_distancethreshold">distanceThreshold</code></td>
<td>
<p>Distance in meters.</p>
</td></tr>
<tr><td><code id="table_filterByDistance_+3A_measure">measure</code></td>
<td>
<p>One of &quot;haversine&quot; &quot;vincenty&quot;, &quot;geodesic&quot;, or &quot;cheap&quot;
specifying desired method of geodesic distance calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of known locations.
</p>


<h3>Note</h3>

<p>Only a single target location is allowed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

locationTbl &lt;- get(data("wa_monitors_500"))

# Too small a distanceThreshold will not find a match
locationTbl %&gt;%
  table_filterByDistance(
    longitude = -117.3647, 
    latitude = 47.6725, 
    distanceThreshold = 10
  ) %&gt;% 
  dplyr::glimpse()

# Expanding the distanceThreshold will find several
locationTbl %&gt;%
  table_filterByDistance(
    longitude = -117.3647, 
    latitude = 47.6725, 
    distanceThreshold = 10000
  ) %&gt;%
  dplyr::glimpse()
</code></pre>

<hr>
<h2 id='table_findAdjacentDistances'>Find distances between adjacent locations in a known locations table</h2><span id='topic+table_findAdjacentDistances'></span>

<h3>Description</h3>

<p>Calculate distances between all locations within a known
locations table and return a tibble with the row indices and separation
distances of those records separated by less than <code>distanceThreshold</code>
meters. Records are returned in order of distance.
</p>
<p>It is useful when working with new metadata tables to identify adjacent
locations early on so that decisions can be made about the appropriateness
of the specified <code>distanceThreshold</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_findAdjacentDistances(
  locationTbl = NULL,
  distanceThreshold = NULL,
  measure = c("geodesic", "haversine", "vincenty", "cheap")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_findAdjacentDistances_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_findAdjacentDistances_+3A_distancethreshold">distanceThreshold</code></td>
<td>
<p>Distance in meters.</p>
</td></tr>
<tr><td><code id="table_findAdjacentDistances_+3A_measure">measure</code></td>
<td>
<p>One of &quot;haversine&quot; &quot;vincenty&quot;, &quot;geodesic&quot;, or &quot;cheap&quot;
specifying desired method of geodesic distance calculation.
</p>
<p>See <code>geodist::<a href="geodist.html#topic+geodist">geodist</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of row indices and distances for those locations separated by
less than <code>distanceThreshold</code> meters.
</p>


<h3>Note</h3>

<p>The measure <code>"cheap"</code> may be used to speed things up depending on
the spatial scale being considered. Distances calculated with
<code>measure = "cheap"</code> will vary by a few meters compared with those
calculated using <code>measure = "geodesic"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

meta &lt;- wa_airfire_meta

# Any locations closer than 2 km?
table_findAdjacentDistances(meta, distanceThreshold = 2000)

# How about 4 km?
table_findAdjacentDistances(meta, distanceThreshold = 4000)


</code></pre>

<hr>
<h2 id='table_findAdjacentLocations'>Finds adjacent locations in a known locations table.</h2><span id='topic+table_findAdjacentLocations'></span>

<h3>Description</h3>

<p>Calculate distances between all locations within a known
locations table and return a tibble containing all records that have an
adjacent location separated by less than <code>distanceThreshold</code> meters.
The return tibble is ordered by separation distance.
</p>
<p>It is useful when working with new metadata tables to identify adjacent
locations early on so that decisions can be made about the appropriateness
of the specified <code>distanceThreshold</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_findAdjacentLocations(
  locationTbl = NULL,
  distanceThreshold = NULL,
  measure = c("geodesic", "haversine", "vincenty", "cheap")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_findAdjacentLocations_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_findAdjacentLocations_+3A_distancethreshold">distanceThreshold</code></td>
<td>
<p>Distance in meters.</p>
</td></tr>
<tr><td><code id="table_findAdjacentLocations_+3A_measure">measure</code></td>
<td>
<p>One of &quot;haversine&quot; &quot;vincenty&quot;, &quot;geodesic&quot;, or &quot;cheap&quot;
specifying desired method of geodesic distance calculation.
</p>
<p>See <code>geodist::<a href="geodist.html#topic+geodist">geodist</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of known locations separated by less than
<code>distanceThreshold</code> meters.
</p>


<h3>Note</h3>

<p>The measure <code>"cheap"</code> may be used to speed things up depending on
the spatial scale being considered. Distances calculated with
<code>measure = "cheap"</code> will vary by a few meters compared with those
calculated using <code>measure = "geodesic"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

meta &lt;- wa_airfire_meta

# Any locations closer than 2 km?
meta %&gt;%
  table_findAdjacentLocations(distanceThreshold = 2000) %&gt;%
  dplyr::select(AQSID, timezone)

# How about 4 km?
meta %&gt;%
  table_findAdjacentLocations(distanceThreshold = 4000) %&gt;%
  dplyr::select(AQSID, timezone)

</code></pre>

<hr>
<h2 id='table_getDistanceFromTarget'>Return distances and directions from a target location to known locations</h2><span id='topic+table_getDistanceFromTarget'></span>

<h3>Description</h3>

<p>Returns a tibble with the same number of rows as <code>locationTbl</code>
containing the distance and direction from the target location specified by
<code>longitude</code> and <code>latitude</code> to each known location found in
<code>locationTbl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_getDistanceFromTarget(
  locationTbl = NULL,
  longitude = NULL,
  latitude = NULL,
  measure = c("geodesic", "haversine", "vincenty", "cheap")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_getDistanceFromTarget_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_getDistanceFromTarget_+3A_longitude">longitude</code></td>
<td>
<p>Target longitude in decimal degrees E.</p>
</td></tr>
<tr><td><code id="table_getDistanceFromTarget_+3A_latitude">latitude</code></td>
<td>
<p>Target latitude in decimal degrees N.</p>
</td></tr>
<tr><td><code id="table_getDistanceFromTarget_+3A_measure">measure</code></td>
<td>
<p>One of &quot;geodesic&quot;, &quot;haversine&quot;, &quot;vincenty&quot; or &quot;cheap&quot;
specifying desired method of geodesic distance calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of distances in meters and cardinal directions from a target location.
</p>


<h3>Note</h3>

<p>Only a single target location is allowed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

locationTbl &lt;- get(data("wa_monitors_500"))

locationTbl %&gt;%
  table_getDistanceFromTarget(
    longitude = -117.3647, 
    latitude = 47.6725
  ) %&gt;% 
  dplyr::glimpse()

</code></pre>

<hr>
<h2 id='table_getLocationID'>Return IDs of known locations</h2><span id='topic+table_getLocationID'></span>

<h3>Description</h3>

<p>Returns a vector of <code>locationID</code>s for the known locations
that each incoming location will be assigned to within the given. If more
than one known location exists within the given <code>distanceThreshold</code>, the closest will be
assigned.  <code>NA</code> will be returned for each incoming that cannot be
assigned to a known location in <code>locationTbl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_getLocationID(
  locationTbl = NULL,
  longitude = NULL,
  latitude = NULL,
  distanceThreshold = NULL,
  measure = c("geodesic", "haversine", "vincenty", "cheap")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_getLocationID_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_getLocationID_+3A_longitude">longitude</code></td>
<td>
<p>Vector of longitudes in decimal degrees E.</p>
</td></tr>
<tr><td><code id="table_getLocationID_+3A_latitude">latitude</code></td>
<td>
<p>Vector of latitudes in decimal degrees N.</p>
</td></tr>
<tr><td><code id="table_getLocationID_+3A_distancethreshold">distanceThreshold</code></td>
<td>
<p>Distance in meters.</p>
</td></tr>
<tr><td><code id="table_getLocationID_+3A_measure">measure</code></td>
<td>
<p>One of &quot;geodesic&quot;, &quot;haversine&quot;, &quot;vincenty&quot; or &quot;cheap&quot;
specifying desired method of geodesic distance calculation.
See <code><a href="geodist.html#topic+geodist">geodist</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of known <code>locationID</code>s.
</p>


<h3>Note</h3>

<p>The measure <code>"cheap"</code> may be used to speed things up depending on
the spatial scale being considered. Distances calculated with
<code>measure = "cheap"</code> will vary by a few meters compared with those
calculated using <code>measure = "geodesic"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>locationTbl &lt;- get(data("wa_monitors_500"))

# Wenatchee
lon &lt;- -120.325278
lat &lt;- 47.423333

# Too small a distanceThreshold will not find a match
table_getLocationID(locationTbl, lon, lat, distanceThreshold = 50)

# Expanding the distanceThreshold will find one
table_getLocationID(locationTbl, lon, lat, distanceThreshold = 5000)

</code></pre>

<hr>
<h2 id='table_getNearestDistance'>Return distances to nearest known locations</h2><span id='topic+table_getNearestDistance'></span>

<h3>Description</h3>

<p>Returns distances between target locations and the closest
location found in <code>locationTbl</code> (if any). Target locations are specified
with <code>longitude</code> and <code>latitude</code>.
</p>
<p>For each target location, only a single distance to the closest known location
is returned. If no known location is found within
<code>distanceThreshold</code>, the distance associated with that target location
will be <code>NA</code>. The length and order of resulting distances will match the
order of the incoming target locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_getNearestDistance(
  locationTbl = NULL,
  longitude = NULL,
  latitude = NULL,
  distanceThreshold = NULL,
  measure = c("geodesic", "haversine", "vincenty", "cheap")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_getNearestDistance_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_getNearestDistance_+3A_longitude">longitude</code></td>
<td>
<p>Vector of target longitudes in decimal degrees E.</p>
</td></tr>
<tr><td><code id="table_getNearestDistance_+3A_latitude">latitude</code></td>
<td>
<p>Vector of target latitudes in decimal degrees N.</p>
</td></tr>
<tr><td><code id="table_getNearestDistance_+3A_distancethreshold">distanceThreshold</code></td>
<td>
<p>Distance in meters.</p>
</td></tr>
<tr><td><code id="table_getNearestDistance_+3A_measure">measure</code></td>
<td>
<p>One of &quot;geodesic&quot;, &quot;haversine&quot;, &quot;vincenty&quot; or &quot;cheap&quot;
specifying desired method of geodesic distance calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of closest distances between target locations and known locations.
</p>


<h3>Use Case</h3>

<p>You may have a set of locations of interest for which you want to assess whether
any monitoring locations are nearby. In this case, the locations of interest
will provide <code>longitude</code> and <code>latitude</code> while <code>locationTbl</code>
will be the known location table associated with the monitoring locations.
</p>
<p>The resulting vector of distances will tell you the distance, for each
target location, to the nearst monitoring location.
</p>


<h3>Note</h3>

<p>The measure <code>"cheap"</code> may be used to speed things up depending on
the spatial scale being considered. Distances calculated with
<code>measure = "cheap"</code> will vary by a few meters compared with those
calculated using <code>measure = "geodesic"</code>.
</p>
<p>See <code><a href="geodist.html#topic+geodist">geodist</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

locationTbl &lt;- get(data("wa_monitors_500"))

# Wenatchee
lon &lt;- -120.325278
lat &lt;- 47.423333

# Too small a distanceThreshold will not find a match
table_getNearestDistance(locationTbl, lon, lat, distanceThreshold = 50)

# Expanding the distanceThreshold will find one
table_getNearestDistance(locationTbl, lon, lat, distanceThreshold = 5000)

</code></pre>

<hr>
<h2 id='table_getNearestLocation'>Return known locations</h2><span id='topic+table_getNearestLocation'></span>

<h3>Description</h3>

<p>Returns a tibble of the known locations from <code>locationTbl</code>
that are closest to the vector of target locations specified by <code>longitude</code>
and <code>latitude</code>. Only a single known location is returned for each
incoming target location. If no known location is found for a particular
incoming location, that record in the tibble will contain all <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_getNearestLocation(
  locationTbl = NULL,
  longitude = NULL,
  latitude = NULL,
  distanceThreshold = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_getNearestLocation_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_getNearestLocation_+3A_longitude">longitude</code></td>
<td>
<p>Vector of longitudes in decimal degrees E.</p>
</td></tr>
<tr><td><code id="table_getNearestLocation_+3A_latitude">latitude</code></td>
<td>
<p>Vector of latitudes in decimal degrees N.</p>
</td></tr>
<tr><td><code id="table_getNearestLocation_+3A_distancethreshold">distanceThreshold</code></td>
<td>
<p>Distance in meters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of known locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

locationTbl &lt;- get(data("wa_monitors_500"))

# Wenatchee
lon &lt;- -120.325278
lat &lt;- 47.423333

# Too small a distanceThreshold will not find a match
table_getNearestLocation(locationTbl, lon, lat, distanceThreshold = 50) %&gt;% str()

# Expanding the distanceThreshold will find one
table_getNearestLocation(locationTbl, lon, lat, distanceThreshold = 5000) %&gt;% str()
</code></pre>

<hr>
<h2 id='table_getRecordIndex'>Return indexes of known location records</h2><span id='topic+table_getRecordIndex'></span>

<h3>Description</h3>

<p>Returns a vector of <code>locationTbl</code> row indexes for the
locations associated with each <code>locationID</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_getRecordIndex(locationTbl = NULL, locationID = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_getRecordIndex_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_getRecordIndex_+3A_locationid">locationID</code></td>
<td>
<p>Vector of <code>locationID</code> strings.</p>
</td></tr>
<tr><td><code id="table_getRecordIndex_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of <code>locationTbl</code> row indexes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

locationTbl &lt;- get(data("wa_monitors_500"))

# Wenatchee
lon &lt;- -120.325278
lat &lt;- 47.423333

# Get the locationID first
locationID &lt;- table_getLocationID(locationTbl, lon, lat, distanceThreshold = 5000)

# Now find the row associated with this ID
recordIndex &lt;- table_getRecordIndex(locationTbl, locationID)

str(locationTbl[recordIndex,])

</code></pre>

<hr>
<h2 id='table_initialize'>Create an empty known location table</h2><span id='topic+table_initialize'></span>

<h3>Description</h3>

<p>Creates an empty known location tibble with the following
columns of core metadata:
</p>

<ul>
<li><p>locationID
</p>
</li>
<li><p>locationName
</p>
</li>
<li><p>longitude
</p>
</li>
<li><p>latitude
</p>
</li>
<li><p>elevation
</p>
</li>
<li><p>countryCode
</p>
</li>
<li><p>stateCode
</p>
</li>
<li><p>countyName
</p>
</li>
<li><p>timezone
</p>
</li>
<li><p>houseNumber
</p>
</li>
<li><p>street
</p>
</li>
<li><p>city
</p>
</li>
<li><p>postalCode
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>table_initialize()
</code></pre>


<h3>Value</h3>

<p>Empty known location tibble with the specified metadata columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

# Create an empty Tbl
emptyTbl &lt;- table_initialize()
dplyr::glimpse(emptyTbl)

</code></pre>

<hr>
<h2 id='table_initializeExisting'>Converts an existing table into a known location table</h2><span id='topic+table_initializeExisting'></span>

<h3>Description</h3>

<p>An existing table may have much of the data that is needed
for a known location table. This function accepts an incoming table and
searches for required columns:
</p>

<ul>
<li><p>locationID
</p>
</li>
<li><p>locationName
</p>
</li>
<li><p>longitude
</p>
</li>
<li><p>latitude
</p>
</li>
<li><p>elevation
</p>
</li>
<li><p>countryCode
</p>
</li>
<li><p>stateCode
</p>
</li>
<li><p>countyName
</p>
</li>
<li><p>timezone
</p>
</li>
<li><p>houseNumber
</p>
</li>
<li><p>street
</p>
</li>
<li><p>city
</p>
</li>
<li><p>postalCode
</p>
</li></ul>

<p>The <code>longitude</code> and <code>latitude</code> columns are required but all others
are optional.
</p>
<p>If any of these optional columns are found, they will be used and the often
slow and sometimes slightly inaccurate steps to generate that information
will be skipped for locations that have non-missing data. Any additional
columns of information that are
not part of the required core metadata will be retained.
</p>
<p>This method skips the assignment of columns like <code>elevation</code> and all
address related fields that require web service requests.
</p>
<p>Compared to initializing a brand new table and populating it one record at a
time, this is a much faster way of creating a known location table from a
pre-existing table of metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_initializeExisting(
  locationTbl = NULL,
  stateDataset = "NaturalEarthAdm1",
  countryCodes = NULL,
  distanceThreshold = NULL,
  measure = c("geodesic", "haversine", "vincenty", "cheap"),
  precision = 10,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_initializeExisting_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations. This input tibble need not be a
standardized &quot;known location&quot; table with all required columns. Missing
columns will be added.</p>
</td></tr>
<tr><td><code id="table_initializeExisting_+3A_statedataset">stateDataset</code></td>
<td>
<p>Name of spatial dataset to use for determining state
codes, Default: 'NaturalEarthAdm1'</p>
</td></tr>
<tr><td><code id="table_initializeExisting_+3A_countrycodes">countryCodes</code></td>
<td>
<p>Vector of country codes used to optimize spatial
searching. (See ?MazamaSpatialUtils::getStateCode())</p>
</td></tr>
<tr><td><code id="table_initializeExisting_+3A_distancethreshold">distanceThreshold</code></td>
<td>
<p>Distance in meters.</p>
</td></tr>
<tr><td><code id="table_initializeExisting_+3A_measure">measure</code></td>
<td>
<p>One of &quot;haversine&quot; &quot;vincenty&quot;, &quot;geodesic&quot;, or &quot;cheap&quot;
specifying desired method of geodesic distance calculation. See
<code>?geodist::geodist</code>.</p>
</td></tr>
<tr><td><code id="table_initializeExisting_+3A_precision">precision</code></td>
<td>
<p><code>precision</code> argument passed on to <a href="#topic+location_createID">location_createID</a>.</p>
</td></tr>
<tr><td><code id="table_initializeExisting_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Known location tibble with the specified metadata columns. Any
locations whose circles (as defined by <code>distanceThreshold</code>) overlap will
generate warning messages.
</p>
<p>It is incumbent upon the user to address overlapping locations by one of:
</p>

<ol>
<li><p>reduce the distanceThreshold until no overlaps occur
</p>
</li>
<li><p>assign one of the overlapping locations to the other location
</p>
</li></ol>



<h3>Note</h3>

<p>The measure <code>"cheap"</code> may be used to speed things up depending on
the spatial scale being considered. Distances calculated with
<code>measure = "cheap"</code> will vary by a few meters compared with those
calculated using <code>measure = "geodesic"</code>.
</p>

<hr>
<h2 id='table_leaflet'>Leaflet interactive map for known locations</h2><span id='topic+table_leaflet'></span>

<h3>Description</h3>

<p>This function creates interactive maps that will be displayed in
RStudio's 'Viewer' tab. The default setting of <code>jitter</code> will move locations
randomly within an ~50 meter radius so that overlapping locations can be
identified. Set <code>jitter = 0</code> to see precise locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_leaflet(
  locationTbl = NULL,
  maptype = c("terrain", "roadmap", "satellite", "toner"),
  extraVars = NULL,
  jitter = 5e-04,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_leaflet_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_leaflet_+3A_maptype">maptype</code></td>
<td>
<p>Optional name of leaflet ProviderTiles to use, e.g. <code>terrain</code>.</p>
</td></tr>
<tr><td><code id="table_leaflet_+3A_extravars">extraVars</code></td>
<td>
<p>Character vector of addition <code>locationTbl</code> column names
to be shown in leaflet popups.</p>
</td></tr>
<tr><td><code id="table_leaflet_+3A_jitter">jitter</code></td>
<td>
<p>Amount to use to slightly adjust locations so that multiple
monitors at the same location can be seen. Use zero or <code>NA</code> to see
precise locations.</p>
</td></tr>
<tr><td><code id="table_leaflet_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>leaflet::addCircleMarker()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>maptype</code> argument is mapped onto leaflet &quot;ProviderTile&quot;
names. Current mappings include:
</p>

<ul>
<li><p>&quot;roadmap&quot; =&gt; &quot;OpenStreetMap&quot;
</p>
</li>
<li><p>&quot;satellite&quot; =&gt; &quot;Esri.WorldImagery&quot;
</p>
</li>
<li><p>&quot;terrain&quot; =&gt; &quot;Esri.WorldTopoMap&quot;
</p>
</li>
<li><p>&quot;toner&quot; =&gt; &quot;Stamen.Toner&quot;
</p>
</li></ul>

<p>If a character string not listed above is provided, it will be used as the
underlying map tile if available. See
<a href="https://leaflet-extras.github.io/leaflet-providers/">https://leaflet-extras.github.io/leaflet-providers/</a> for a list of
&quot;provider tiles&quot; to use as the background map.
</p>


<h3>Value</h3>

<p>A leaflet &quot;plot&quot; object which, if not assigned, is rendered in
Rstudio's 'Viewer' tab.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(MazamaLocationUtils)

# A table with all core metadata
table_leaflet(wa_monitors_500)
  
# A table missing some core metadata
table_leaflet(
  wa_airfire_meta,
  extraVars = c("stateCode", "countyName", "msaName")
)

# Customizing the map
table_leaflet(
  wa_airfire_meta,
  extraVars = c("stateCode", "countyName", "msaName"),
  radius = 6,
  color = "black",
  weight = 2,
  fillColor = "red",
  fillOpacity = 0.3
)

## End(Not run)
</code></pre>

<hr>
<h2 id='table_leafletAdd'>Add to a leaflet interactive map for known locations</h2><span id='topic+table_leafletAdd'></span>

<h3>Description</h3>

<p>This function adds a layer to an interactive map displayed in
RStudio's 'Viewer' tab. The default setting of <code>jitter</code> will move locations
randomly within an ~50 meter radius so that overlapping locations can be
identified. Set <code>jitter = 0</code> to see precise locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_leafletAdd(
  map = NULL,
  locationTbl = NULL,
  extraVars = NULL,
  jitter = 5e-04,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_leafletAdd_+3A_map">map</code></td>
<td>
<p>Leaflet map.</p>
</td></tr>
<tr><td><code id="table_leafletAdd_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_leafletAdd_+3A_extravars">extraVars</code></td>
<td>
<p>Character vector of addition <code>locationTbl</code> column names
to be shown in leaflet popups.</p>
</td></tr>
<tr><td><code id="table_leafletAdd_+3A_jitter">jitter</code></td>
<td>
<p>Amount to use to slightly adjust locations so that multiple
monitors at the same location can be seen. Use zero or <code>NA</code> to see
precise locations.</p>
</td></tr>
<tr><td><code id="table_leafletAdd_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>leaflet::addCircleMarkers()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A leaflet &quot;plot&quot; object which, if not assigned, is rendered in
Rstudio's 'Viewer' tab.
</p>

<hr>
<h2 id='table_load'>Load a known location table</h2><span id='topic+table_load'></span>

<h3>Description</h3>

<p>Load a tibble of known locations from the preferred directory.
</p>
<p>The known location table must be named either <code>&lt;collectionName&gt;.rda</code>
or <code>&lt;collectionName&gt;.csv</code>. If both are found, only
<code>&lt;collectionName&gt;.rda</code> will be loaded to ensure that columns will have
the proper type assigned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_load(collectionName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_load_+3A_collectionname">collectionName</code></td>
<td>
<p>Character identifier for this table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of known locations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setLocationDataDir">setLocationDataDir</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

# Set the directory for saving location tables
setLocationDataDir(tempdir())

# Load an example table and check the dimensions
locationTbl &lt;- get(data("wa_monitors_500"))
dim(locationTbl)

# Save it as "table_load_example"
table_save(locationTbl, "table_load_example")

# Load it and check the dimensions
my_table &lt;- table_load("table_load_example")
dim(my_table)

# Check the locationDataDir
list.files(getLocationDataDir(), pattern = "table_load_example")
</code></pre>

<hr>
<h2 id='table_removeColumn'>Remove a column of metadata in a table</h2><span id='topic+table_removeColumn'></span>

<h3>Description</h3>

<p>Remove the column matching <code>columnName</code>. This function
can be used in pipelines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_removeColumn(locationTbl = NULL, columnName = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_removeColumn_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_removeColumn_+3A_columnname">columnName</code></td>
<td>
<p>Name of the colun to be removed.</p>
</td></tr>
<tr><td><code id="table_removeColumn_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated tibble of known locations.
</p>


<h3>See Also</h3>

<p><a href="#topic+table_addColumn">table_addColumn</a>
</p>
<p><a href="#topic+table_removeColumn">table_removeColumn</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

# Starting table
locationTbl &lt;- get(data("wa_monitors_500")) 
names(locationTbl)

# Add a new column
locationTbl &lt;-
  locationTbl %&gt;%
  table_addColumn("AQSID")
  
names(locationTbl)

# Now remove it
locationTbl &lt;-
  locationTbl %&gt;%
  table_removeColumn("AQSID")

names(locationTbl)

try({
  # Cannot remove "core" metadata
  locationTbl &lt;-
    locationTbl %&gt;%
    table_removeColumn("longitude")
}, silent = FALSE)

</code></pre>

<hr>
<h2 id='table_removeRecord'>Remove location records from a table</h2><span id='topic+table_removeRecord'></span>

<h3>Description</h3>

<p>Incoming <code>locationID</code> values are compared
against the incoming <code>locationTbl</code> and any matches are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_removeRecord(locationTbl = NULL, locationID = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_removeRecord_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_removeRecord_+3A_locationid">locationID</code></td>
<td>
<p>Vector of <code>locationID</code> strings.</p>
</td></tr>
<tr><td><code id="table_removeRecord_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated tibble of known locations.
</p>


<h3>See Also</h3>

<p><a href="#topic+table_addLocation">table_addLocation</a>
</p>
<p><a href="#topic+table_addSingleLocation">table_addSingleLocation</a>
</p>
<p><a href="#topic+table_updateSingleRecord">table_updateSingleRecord</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

locationTbl &lt;- get(data("wa_monitors_500"))
dim(locationTbl)

# Wenatchee
lon &lt;- -120.325278
lat &lt;- 47.423333

# Get the locationID first
locationID &lt;- table_getLocationID(locationTbl, lon, lat, distanceThreshold = 500)

# Remove it
locationTbl &lt;- table_removeRecord(locationTbl, locationID)
dim(locationTbl)

# Test
table_getLocationID(locationTbl, lon, lat, distanceThreshold = 500)

</code></pre>

<hr>
<h2 id='table_save'>Save a known location table</h2><span id='topic+table_save'></span>

<h3>Description</h3>

<p>Save a tibble of known locations to the preferred directory. If
<code>outputType</code> is a vector, the known locations table will be saved to the
preferred directory in multiple formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_save(
  locationTbl = NULL,
  collectionName = NULL,
  backup = TRUE,
  outputType = "rda"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_save_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_save_+3A_collectionname">collectionName</code></td>
<td>
<p>Character identifier for this table.</p>
</td></tr>
<tr><td><code id="table_save_+3A_backup">backup</code></td>
<td>
<p>Logical specifying whether to save a backup version of any
existing tables sharing <code>collectionName</code>.</p>
</td></tr>
<tr><td><code id="table_save_+3A_outputtype">outputType</code></td>
<td>
<p>Vecctor of output formats. (Currently only &quot;rda&quot; or &quot;csv&quot; are supported.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Backup files are saved with &quot;YYYY-mm-ddTHH:MM:SS&quot;
</p>


<h3>Value</h3>

<p>File path of saved file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

# Set the directory for saving location tables
setLocationDataDir(tempdir())

# Load an example table and check the dimensions
locationTbl &lt;- get(data("wa_monitors_500"))
dim(locationTbl)

# Save it as "table_save_example"
table_save(locationTbl, "table_save_example")

# Add a column and save again 
locationTbl %&gt;% 
  table_addColumn("my_column") %&gt;% 
  table_save("table_save_example")
  
# Check the locationDataDir
list.files(getLocationDataDir(), pattern = "table_save_example")

</code></pre>

<hr>
<h2 id='table_updateColumn'>Update a column of metadata in a table</h2><span id='topic+table_updateColumn'></span>

<h3>Description</h3>

<p>Updates records in a location table. Records are identified
by <code>locationID</code> and the data found in <code>locationData</code> is used to
replace any existing value in the <code>columnName</code> column.
<code>locationID</code> and <code>locationData</code> must be of the same length.
Any <code>NA</code> values in <code>locationID</code> will be ignored.
</p>
<p>If <code>columnName</code> is not a named column within <code>locationTbl</code>, a new
column will be created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_updateColumn(
  locationTbl = NULL,
  columnName = NULL,
  locationID = NULL,
  locationData = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_updateColumn_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_updateColumn_+3A_columnname">columnName</code></td>
<td>
<p>Name of an existing/new column in <code>locationTbl</code> whose data
will be updated/created.</p>
</td></tr>
<tr><td><code id="table_updateColumn_+3A_locationid">locationID</code></td>
<td>
<p>Vector of <code>locationID</code> strings.</p>
</td></tr>
<tr><td><code id="table_updateColumn_+3A_locationdata">locationData</code></td>
<td>
<p>Vector of data to be inserted at records identified by
<code>locationID</code>.</p>
</td></tr>
<tr><td><code id="table_updateColumn_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated tibble of known locations.
</p>


<h3>See Also</h3>

<p><a href="#topic+table_addColumn">table_addColumn</a>
</p>
<p><a href="#topic+table_removeColumn">table_removeColumn</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

locationTbl &lt;- get(data("wa_monitors_500"))
wa &lt;- get(data("wa_airfire_meta"))

# We will merge some metadata from wa into locationTbl

# Record indices for wa
wa_indices &lt;- seq(5,65,5)
wa_sub &lt;- wa[wa_indices,]

locationID &lt;- 
  table_getLocationID(
    locationTbl, 
    wa_sub$longitude, 
    wa_sub$latitude, 
    distanceThreshold = 500
  )
  
locationData &lt;- wa_sub$AQSID

locationTbl &lt;- 
  table_updateColumn(locationTbl, "AQSID", locationID, locationData)

# Look at the data we attempted to merge
wa$AQSID[wa_indices]

# And two columns from the updated locationTbl
locationTbl_indices &lt;- table_getRecordIndex(locationTbl, locationID)
locationTbl[locationTbl_indices, c("city", "AQSID")]

</code></pre>

<hr>
<h2 id='table_updateSingleRecord'>Update a single known location record in a table</h2><span id='topic+table_updateSingleRecord'></span>

<h3>Description</h3>

<p>Information in the <code>locationList</code> is used to replace
existing information found in <code>locationTbl</code>. This function can be used
for small tweaks to an existing <code>locationTbl</code>. Wholesale replacement of
records should be performed with <code>table_removeRecord()</code> followed by
<code>table_addLocation()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_updateSingleRecord(
  locationTbl = NULL,
  locationList = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_updateSingleRecord_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="table_updateSingleRecord_+3A_locationlist">locationList</code></td>
<td>
<p>List containing <code>locationID</code> and one or more named
columns whose values are to be replaced.</p>
</td></tr>
<tr><td><code id="table_updateSingleRecord_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the generation of progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated tibble of known locations.
</p>


<h3>See Also</h3>

<p><a href="#topic+table_addLocation">table_addLocation</a>
</p>
<p><a href="#topic+table_addSingleLocation">table_addSingleLocation</a>
</p>
<p><a href="#topic+table_removeRecord">table_removeRecord</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaLocationUtils)

locationTbl &lt;- get(data("wa_monitors_500"))

# Wenatchee
wenatcheeRecord &lt;- 
  locationTbl %&gt;% 
  dplyr::filter(city == "Wenatchee")

str(wenatcheeRecord)

wenatcheeID &lt;- wenatcheeRecord$locationID

locationTbl &lt;- table_updateSingleRecord(
  locationTbl,
  locationList = list(
    locationID = wenatcheeID,
    locationName = "Wenatchee-Fifth St"
  )
)

# Look at the new record
locationTbl %&gt;% 
  dplyr::filter(city == "Wenatchee") %&gt;%
  str()

</code></pre>

<hr>
<h2 id='validateLocationTbl'>Validate a location table</h2><span id='topic+validateLocationTbl'></span>

<h3>Description</h3>

<p>Ensures that the incoming table has numeric <code>longitude</code> and
<code>latitude</code> columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateLocationTbl(locationTbl = NULL, locationOnly = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateLocationTbl_+3A_locationtbl">locationTbl</code></td>
<td>
<p>Tibble of known locations.</p>
</td></tr>
<tr><td><code id="validateLocationTbl_+3A_locationonly">locationOnly</code></td>
<td>
<p>Logical specifying whether to check for all standard
columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>TRUE</code> if no error message has been generated.
</p>

<hr>
<h2 id='validateLonLat'>Validate longitude and latitude values</h2><span id='topic+validateLonLat'></span>

<h3>Description</h3>

<p>See <code>MazamaCoreUtils::<a href="MazamaCoreUtils.html#topic+validateLonLat">validateLonLat</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateLonLat(longitude = NULL, latitude = NULL)
</code></pre>

<hr>
<h2 id='validateLonsLats'>Validate longitude and latitude vectors</h2><span id='topic+validateLonsLats'></span>

<h3>Description</h3>

<p>See <code>MazamaCoreUtils::<a href="MazamaCoreUtils.html#topic+validateLonsLats">validateLonsLats</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateLonsLats(longitude = NULL, latitude = NULL, na.rm = FALSE)
</code></pre>

<hr>
<h2 id='validateMazamaSpatialUtils'>Validate proper setup of MazamaSpatialUtils</h2><span id='topic+validateMazamaSpatialUtils'></span>

<h3>Description</h3>

<p>The <span class="pkg">MazamaSpatialUtils</span> package mus be properly installed
and initialized before using functions from the <span class="pkg">MazamaLocationUtils</span>
package. This function tests for this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateMazamaSpatialUtils()
</code></pre>


<h3>Value</h3>

<p>Invisibly returns <code>TRUE</code> if no error message has been generated.
</p>

<hr>
<h2 id='wa_airfire_meta'>Washington monitor metadata dataset</h2><span id='topic+wa_airfire_meta'></span>

<h3>Description</h3>

<p>The <code>wa_pwfsl_meta</code> dataset provides a set of Washington
state air quality monitor metadata used by the USFS AirFire group.
This dataset was generated on 2023-10-24 by running:
</p>
<pre>
library(AirMonitor)

wa_airfire_meta &lt;-
  airnow_loadLatest() %&gt;%
  monitor_filter(stateCode == "WA") %&gt;%
  monitor_getMeta() %&gt;%
  # On 2023-10-24, this metdata still uses zip instead of postalCode
  dplyr::rename(postalCode = zip) %&gt;%
  # Remove internal fields
  dplyr::select(-dplyr::starts_with("airnow_"))

save(wa_airfire_meta, file = "data/wa_airfire_meta.rda")
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>wa_airfire_meta
</code></pre>


<h3>Format</h3>

<p>A tibble with 92 rows and 29 columns of data.
</p>

<hr>
<h2 id='wa_monitors_500'>Wshington monitor locations dataset</h2><span id='topic+wa_monitors_500'></span>

<h3>Description</h3>

<p>The <code>wa_monitor_500</code> dataset provides a set of known
locations associated with Washington state air quality monitors.
This dataset was generated on 2023-10-24 by running:
</p>
<pre>
library(AirMonitor)
library(MazamaLocationUtils)

initializeMazamaSpatialUtils()
setLocationDataDir("./data")

monitor &lt;- monitor_loadLatest() %&gt;% monitor_filter(stateCode == "WA")
lons &lt;- monitor$meta$longitude
lats &lt;- monitor$meta$latitude

table_initialize() %&gt;%
  table_addLocation(
    lons, lats,
    distanceThreshold = 500,
    elevationService = "usgs",
    addressService = "photon"
  ) %&gt;%
  table_save("wa_monitors_500")
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>wa_monitors_500
</code></pre>


<h3>Format</h3>

<p>A tibble with 78 rows and 13 columns of data.
</p>


<h3>See Also</h3>

<p><a href="#topic+id_monitors_500">id_monitors_500</a>
</p>
<p><a href="#topic+or_monitors_500">or_monitors_500</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
