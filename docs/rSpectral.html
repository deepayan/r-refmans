<!DOCTYPE html><html><head><title>Help for package rSpectral</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rSpectral}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rSpectral'><p>rSpectral</p></a></li>
<li><a href='#spectral_graphNEL'><p>Spectral clustering for <code>graphNEL</code> objects</p></a></li>
<li><a href='#spectral_igraph_communities'><p>Spectral clustering for <code>igraph</code> objects</p></a></li>
<li><a href='#spectral_igraph_membership'><p>Spectral clustering for <code>igraph</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spectral Modularity Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0.10</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the network clustering algorithm described in 
            Newman (2006) &lt;<a href="https://doi.org/10.1103%2FPhysRevE.74.036104">doi:10.1103/PhysRevE.74.036104</a>&gt;. The complete 
            iterative algorithm comprises of two steps. In the first step, the 
            network is expressed in terms of its leading eigenvalue and 
            eigenvector and recursively partition into two communities. 
            Partitioning occurs if the maximum positive 
            eigenvalue is greater than the tolerance (10e-5) for the current 
            partition, and if it results in a positive contribution to the 
            Modularity.
            Given an initial separation using the leading eigen step, 'rSpectral' 
            then continues to maximise for the change in Modularity using a 
            fine-tuning step - or variate thereof. The first stage here is to 
            find the node which, when moved from one community to another, 
            gives the maximum change in Modularity. This node’s community is 
            then fixed and we repeat the process until all nodes have been moved. 
            The whole process is repeated from this new state until the change 
            in the Modularity, between the new and old state, is less than the 
            predefined tolerance.
            A slight variant of the fine-tuning step, which can improve speed 
            of the calculation, is also provided. Instead of moving each node 
            into each community in turn, we only consider moves of neighbouring 
            nodes, found in different communities, to the community of the 
            current node of interest. The two steps process is repeatedly 
            applied to each new community found, subdivided each community 
            into two new communities, until we are unable to find any division 
            that results in a positive change in Modularity. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cmclean5/rSpectral">https://github.com/cmclean5/rSpectral</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cmclean5/rSpectral/issues/">https://github.com/cmclean5/rSpectral/issues/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8.3), Rdpack, igraph, graph</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo(&ge; 0.11.2.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RColorBrewer, Rgraphviz, igraphdata, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-18 04:56:48 UTC; anatolii-sorokin</td>
</tr>
<tr>
<td>Author:</td>
<td>Colin Mclean [aut] (algorithm implementation in Rcpp functions),
  Anatoly Sorokin [aut, cre] (R functions, cranification, documentation,
    testing, maintenance)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anatoly Sorokin &lt;lptolik@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-18 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rSpectral'>rSpectral</h2><span id='topic+rSpectral'></span><span id='topic+rSpectral-package'></span>

<h3>Description</h3>

<p>This package implements the Spectral Modularity clustering algorithm for
<code><a href="igraph.html#topic+igraph">igraph</a></code> and <code><a href="graph.html#topic+graphNEL">graphNEL</a></code> graphs. The algorithm 
was proposed in (Newman 2006) and an example
of its application to the real biological network could be found in
(Roy et al. 2018).
</p>


<h3>Author(s)</h3>

<p>Colin Mclean &lt;Colin.D.Mclean@ed.ac.uk&gt;
</p>


<h3>References</h3>

<p>Newman MEJ (2006).
&ldquo;Finding community structure in networks using the eigenvectors of matrices.&rdquo;
<em>Phys. Rev. E</em>, <b>74</b>(3), 036104.
<a href="https://doi.org/10.1103/PhysRevE.74.036104">doi:10.1103/PhysRevE.74.036104</a>, <a href="https://link.aps.org/doi/10.1103/PhysRevE.74.036104">https://link.aps.org/doi/10.1103/PhysRevE.74.036104</a>.<br /><br /> Roy M, Sorokina O, McLean C, Tapia-González S, DeFelipe J, Armstrong JD, Grant SGN (2018).
&ldquo;Regional Diversity in the Postsynaptic Proteome of the Mouse Brain.&rdquo;
<em>Proteomes</em>, <b>6</b>(3), 31.
ISSN 2227-7382, <a href="https://doi.org/10.3390/proteomes6030031">doi:10.3390/proteomes6030031</a>, <a href="https://www.mdpi.com/2227-7382/6/3/31">https://www.mdpi.com/2227-7382/6/3/31</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cmclean5/rSpectral">https://github.com/cmclean5/rSpectral</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/cmclean5/rSpectral/issues/">https://github.com/cmclean5/rSpectral/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='spectral_graphNEL'>Spectral clustering for <code><a href="graph.html#topic+graphNEL">graphNEL</a></code> objects</h2><span id='topic+spectral_graphNEL'></span>

<h3>Description</h3>

<p>Spectral clustering for <code><a href="graph.html#topic+graphNEL">graphNEL</a></code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_graphNEL(g, Cn_min = 1L, tol = 1e-05, names = 1L, fix_neig = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_graphNEL_+3A_g">g</code></td>
<td>
<p><code><a href="graph.html#topic+graphNEL">graphNEL</a></code> object</p>
</td></tr>
<tr><td><code id="spectral_graphNEL_+3A_cn_min">Cn_min</code></td>
<td>
<p>minimum cluster size</p>
</td></tr>
<tr><td><code id="spectral_graphNEL_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="spectral_graphNEL_+3A_names">names</code></td>
<td>
<p>are we dealing with alphaNumeric (1) or numeric (!1) ids</p>
</td></tr>
<tr><td><code id="spectral_graphNEL_+3A_fix_neig">fix_neig</code></td>
<td>
<p>whether to fix neighbouring nodes found in same community</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with node names and membership information
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectral_igraph_membership">spectral_igraph_membership</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(graph)
V = letters[1:12]
g2 = randomEGraph(V, edges=20)
mem.df = spectral_graphNEL(g2)
head(mem.df)
</code></pre>

<hr>
<h2 id='spectral_igraph_communities'>Spectral clustering for <code>igraph</code> objects</h2><span id='topic+spectral_igraph_communities'></span>

<h3>Description</h3>

<p>This function invoke <code><a href="#topic+spectral_igraph_membership">spectral_igraph_membership</a></code> to calculate
clustering and convert it into <code><a href="igraph.html#topic+communities">communities</a></code> object for
seamless work with native <code><a href="igraph.html#topic+igraph">igraph</a></code> clustering functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_igraph_communities(
  g,
  Cn_min = 1L,
  tol = 1e-05,
  names = 1L,
  fix_neig = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_igraph_communities_+3A_g">g</code></td>
<td>
<p><code>igraph</code> object</p>
</td></tr>
<tr><td><code id="spectral_igraph_communities_+3A_cn_min">Cn_min</code></td>
<td>
<p>minimum cluster size</p>
</td></tr>
<tr><td><code id="spectral_igraph_communities_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="spectral_igraph_communities_+3A_names">names</code></td>
<td>
<p>are we dealing with alphaNumeric (1) or numeric (!1) ids</p>
</td></tr>
<tr><td><code id="spectral_igraph_communities_+3A_fix_neig">fix_neig</code></td>
<td>
<p>whether to fix neighbouring nodes found in same community</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="igraph.html#topic+communities">communities</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate,package='igraphdata')
c&lt;-spectral_igraph_communities(karate)
</code></pre>

<hr>
<h2 id='spectral_igraph_membership'>Spectral clustering for <code>igraph</code> objects</h2><span id='topic+spectral_igraph_membership'></span>

<h3>Description</h3>

<p>This function implements the network clustering algorithm described in
(M. E. J. Newman, 2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_igraph_membership(
  g,
  Cn_min = 1L,
  tol = 1e-05,
  names = 1L,
  fix_neig = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_igraph_membership_+3A_g">g</code></td>
<td>
<p><code>igraph</code> object</p>
</td></tr>
<tr><td><code id="spectral_igraph_membership_+3A_cn_min">Cn_min</code></td>
<td>
<p>minimum cluster size</p>
</td></tr>
<tr><td><code id="spectral_igraph_membership_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="spectral_igraph_membership_+3A_names">names</code></td>
<td>
<p>are we dealing with alphaNumeric (1) or numeric (!1) ids</p>
</td></tr>
<tr><td><code id="spectral_igraph_membership_+3A_fix_neig">fix_neig</code></td>
<td>
<p>whether to fix neighbouring nodes found in same community</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The complete iterative algorithm comprises of two steps. In the
first step, the network is expressed in terms of its leading eigenvalue and eigenvector
and recursively partition into two communities. Partitioning occurs if the maximum
positive eigenvalue is greater than the tolerance (<code>tol=10-5</code>) for the current
partition, and if it results in a positive contribution to the Modularity.
</p>
<p>Given an initial separation using the leading eigen step, the function then continues to
maximise for the change in Modularity using a fine-tuning step - or variate thereof. The
first stage here is to find the node which, when moved from one community to another,
gives the maximum change in Modularity. This node’s community is then fixed and we repeat
the process until all nodes have been moved. The whole process is repeated from this new
state until the change in the Modularity, between the new and old state, is less than the
predefined tolerance (<code>tol</code>).
</p>
<p>A slight variant of the fine-tuning step, which can reduce execution time by factor 2 to
5, is also provided. Instead of moving each node into each community in turn, we only
consider moves of neighbouring nodes, found in different communities, to the community of
the current node of interest. This variant of the node-moving algorithm effectively 'fixes'
neigbouring nodes <code>fix_neig</code> in the community being considered.
</p>
<p>The two steps process is repeatedly applied to each new community found, subdivided each community
into two new communities, until we are unable to find any division that results in a positive change
in Modularity. An additional stopping criteria, based on the minimum cluster size <code>Cn_min</code>, is
also provided.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with node names and membership information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate,package='igraphdata')
df.mem&lt;-spectral_igraph_membership(karate)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
