<!DOCTYPE html><html lang="en"><head><title>Help for package regressinator</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {regressinator}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#regressinator-package'><p>regressinator: Simulate and Diagnose (Generalized) Linear Models</p></a></li>
<li><a href='#augment_longer'><p>Augment a model fit with residuals, in &quot;long&quot; format</p></a></li>
<li><a href='#augment_quantile'><p>Augment data with randomized quantile residuals</p></a></li>
<li><a href='#bin_by_interval'><p>Group a data frame into bins</p></a></li>
<li><a href='#binned_residuals'><p>Obtain binned residuals for a model</p></a></li>
<li><a href='#by_level'><p>Convert factor levels to numeric values</p></a></li>
<li><a href='#check_data_arg'><p>Check that the model fit uses the data argument to provide data</p></a></li>
<li><a href='#custom_family'><p>Family representing a GLM with custom distribution and link function</p></a></li>
<li><a href='#decrypt'><p>Decrypt message giving the location of the true plot in a lineup</p></a></li>
<li><a href='#detect_transmutation'><p>Detect transmutation in formulas, such as factor(), and raise an error</p></a></li>
<li><a href='#drop_factors'><p>Drop factor columns from a data frame</p></a></li>
<li><a href='#empirical_link'><p>Empirically estimate response values on the link scale</p></a></li>
<li><a href='#factor_columns'><p>Check whether each column in a data frame is a factor</p></a></li>
<li><a href='#in_interaction'><p>Determine if a predictor is involved in an interaction</p></a></li>
<li><a href='#model_lineup'><p>Produce a lineup for a fitted model</p></a></li>
<li><a href='#normalize_family'><p>Accept family arguments in the same way as glm(), convert to standardized</p>
form, and throw comprehensible errors.</a></li>
<li><a href='#ols_with_error'><p>Family representing a linear relationship with non-Gaussian errors</p></a></li>
<li><a href='#parametric_boot_distribution'><p>Simulate the distribution of estimates by parametric bootstrap</p></a></li>
<li><a href='#partial_residuals'><p>Augment a model fit with partial residuals for all terms</p></a></li>
<li><a href='#population'><p>Define the population generalized regression relationship</p></a></li>
<li><a href='#population_predictors'><p>Get the predictors of a population</p></a></li>
<li><a href='#population_response'><p>Get the response variables of a population</p></a></li>
<li><a href='#predictor'><p>Specify the distribution of a predictor variable</p></a></li>
<li><a href='#prototype_for'><p>Get a prototype data frame for partial residuals</p></a></li>
<li><a href='#response'><p>Specify a response variable in terms of predictors</p></a></li>
<li><a href='#rfactor'><p>Draw random values from a factor variable</p></a></li>
<li><a href='#sample_x'><p>Draw a data frame from the specified population.</p></a></li>
<li><a href='#sampling_distribution'><p>Simulate the sampling distribution of estimates from a population</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate and Diagnose (Generalized) Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-16</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate samples from populations with known covariate
    distributions, generate response variables according to common linear and
    generalized linear model families, draw from sampling distributions of
    regression estimates, and perform visual inference on diagnostics from model
    fits.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.refsmmat.com/regressinator/">https://www.refsmmat.com/regressinator/</a>,
<a href="https://github.com/capnrefsmmat/regressinator">https://github.com/capnrefsmmat/regressinator</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/capnrefsmmat/regressinator/issues">https://github.com/capnrefsmmat/regressinator/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, cli, DHARMa, dplyr, ggplot2, insight, nullabor, purrr,
rlang, tibble, tidyr, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, mvtnorm, palmerpenguins, patchwork,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-16 15:07:24 UTC; alexreinhart</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Reinhart <a href="https://orcid.org/0000-0002-6658-514X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Reinhart &lt;areinhar@stat.cmu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-16 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='regressinator-package'>regressinator: Simulate and Diagnose (Generalized) Linear Models</h2><span id='topic+regressinator'></span><span id='topic+regressinator-package'></span>

<h3>Description</h3>

<p>Simulate samples from populations with known covariate distributions, generate response variables according to common linear and generalized linear model families, draw from sampling distributions of regression estimates, and perform visual inference on diagnostics from model fits.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alex Reinhart <a href="mailto:areinhar@stat.cmu.edu">areinhar@stat.cmu.edu</a> (<a href="https://orcid.org/0000-0002-6658-514X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.refsmmat.com/regressinator/">https://www.refsmmat.com/regressinator/</a>
</p>
</li>
<li> <p><a href="https://github.com/capnrefsmmat/regressinator">https://github.com/capnrefsmmat/regressinator</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/capnrefsmmat/regressinator/issues">https://github.com/capnrefsmmat/regressinator/issues</a>
</p>
</li></ul>


<hr>
<h2 id='augment_longer'>Augment a model fit with residuals, in &quot;long&quot; format</h2><span id='topic+augment_longer'></span>

<h3>Description</h3>

<p>Use <code>broom::augment()</code> to augment a model fit with residual and fit
information, then reformat the resulting data frame into a &quot;long&quot; format with
one row per predictor per observation, to facilitate plotting of the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augment_longer(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augment_longer_+3A_x">x</code></td>
<td>
<p>A model fit object, such as those returned by <code>lm()</code> or <code>glm()</code>. See
the broom documentation for the full list of model types supported.</p>
</td></tr>
<tr><td><code id="augment_longer_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>broom::augment()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name comes by analogy to <code>tidyr::pivot_longer()</code>, and the concept of long
versus wide data formats.
</p>


<h3>Value</h3>

<p>A data frame (tibble) in similar form to those produced by
<code>broom::augment()</code>, but expanded to have one row per predictor per
observation. Columns <code>.predictor_name</code> and <code>.predictor_value</code> identify the
predictor and its value. An additional column <code>.obs</code> records the original
observation numbers so results can be matched to observations in the
original model data.
</p>


<h3>Limitations</h3>

<p>Factor predictors (as factors, logical, or character vectors) can't coexist
with numeric variables in the <code>.predictor_value</code> column. If there are some
numeric and some factor predictors, the factor predictors will automatically
be omitted. If all predictors are factors, they will be combined into one
factor with all levels. However, if a numeric variable is converted to factor
in the model formula, such as with <code>y ~ factor(x)</code>, the function cannot
determine the appropriate types and will raise an error. Create factors as
needed in the source data frame <em>before</em> fitting the model to avoid this
issue.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partial_residuals">partial_residuals()</a></code>, <code><a href="#topic+binned_residuals">binned_residuals()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(mpg ~ cyl + disp + hp, data = mtcars)

# each observation appears 3 times, once per predictor:
augment_longer(fit)
</code></pre>

<hr>
<h2 id='augment_quantile'>Augment data with randomized quantile residuals</h2><span id='topic+augment_quantile'></span><span id='topic+augment_quantile_longer'></span>

<h3>Description</h3>

<p>Generates a data frame containing a model's predictors, the residuals, and
the randomized quantile residuals as additional columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augment_quantile(x, ...)

augment_quantile_longer(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augment_quantile_+3A_x">x</code></td>
<td>
<p>Fitted model to obtain randomized quantile residuals from</p>
</td></tr>
<tr><td><code id="augment_quantile_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>broom::augment()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Randomized quantile residuals provide more interpretable residuals for
generalized linear models (GLMs), such as logistic regression. See Dunn and
Smyth (1996) for details, or review the examples provided in
<code>vignette("DHARMa", package="DHARMa")</code>.
</p>
<p>Let <code class="reqn">F_Y(y; x, \beta)</code> be the predicted cumulative distribution function
for <code class="reqn">Y</code> when <code class="reqn">X = x</code>, using the fitted GLM. When the response is
continuous, the randomized quantile residual for observation <code class="reqn">i</code> is
</p>
<p style="text-align: center;"><code class="reqn">r_{q,i} = F_Y(y_i; x_i, \hat \beta).</code>
</p>

<p>When the response is discrete, let
</p>
<p style="text-align: center;"><code class="reqn">a_i = \lim_{y \uparrow y_i} F_Y(y; x_i, \hat \beta)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">b_i = F_Y(y_i; x_i, \hat \beta),</code>
</p>

<p>then draw the randomized quantile residual as
</p>
<p style="text-align: center;"><code class="reqn">r_{q,i} \sim \text{Uniform}(a_i, b_i).</code>
</p>

<p>As cumulative distributions are left-continuous, this &quot;jitters&quot; the values
between the discrete steps, resulting in a residual that is uniformly
distributed when the model is correct.
</p>
<p>Some definitions of randomized quantile residuals transform the resulting
values using the standard normal inverse cdf, so they are normally
distributed. That step is omitted here, as uniform residuals are easy to work
with.
</p>


<h3>Value</h3>

<p>Data frame with one row per observation used to fit <code>x</code>, including a
<code>.quantile.resid</code> column containing the quantile residuals. See
<code>broom::augment()</code> and its methods for details of other columns.
</p>
<p>For <code>augment_quantile_longer()</code>, the output is in &quot;long&quot; format with one row
per predictor per observation. Columns <code>.predictor_name</code> and
<code>.predictor_value</code> identify the predictor and its value. An additional column
<code>.obs</code> records the original observation numbers so results can be matched to
observations in the original model data. See Limitations in
<code>augment_longer()</code> for limitations on factor predictors.
</p>


<h3>Implementation details</h3>

<p>Uses <code>broom::augment()</code> to generate the data frame, then uses the <a href="https://cran.r-project.org/package=DHARMa">DHARMa package</a> to generate randomized
quantile residuals for the model.
</p>


<h3>References</h3>

<p>Dunn, Peter K., and Gordon K. Smyth (1996).
&quot;Randomized Quantile Residuals.&quot; <em>Journal of Computational and Graphical
Statistics</em> 5 (3): 236â€“44. <a href="https://doi.org/10.2307/1390802">doi:10.2307/1390802</a>
</p>


<h3>See Also</h3>

<p><code>vignette("logistic-regression-diagnostics")</code> and
<code>vignette("other-glm-diagnostics")</code> for examples of plotting and
interpreting randomized quantile residuals; <code><a href="#topic+augment_longer">augment_longer()</a></code>;
<code><a href="broom.html#topic+reexports">broom::augment()</a></code>
</p>

<hr>
<h2 id='bin_by_interval'>Group a data frame into bins</h2><span id='topic+bin_by_interval'></span><span id='topic+bin_by_quantile'></span>

<h3>Description</h3>

<p>Groups a data frame (similarly to <code>dplyr::group_by()</code>) based on the values of
a column, either by dividing up the range into equal pieces or by quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_by_interval(.data, col, breaks = NULL)

bin_by_quantile(.data, col, breaks = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bin_by_interval_+3A_.data">.data</code></td>
<td>
<p>Data frame to bin</p>
</td></tr>
<tr><td><code id="bin_by_interval_+3A_col">col</code></td>
<td>
<p>Column to bin by</p>
</td></tr>
<tr><td><code id="bin_by_interval_+3A_breaks">breaks</code></td>
<td>
<p>Number of bins to create. <code>bin_by_interval()</code> also accepts a
numeric vector of two or more unique cut points to use. If <code>NULL</code>, a
default number of breaks is chosen based on the number of rows in the data.
In <code>bin_by_quantile()</code>, if the number of unique values of the column is
smaller than <code>breaks</code>, fewer bins will be produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bin_by_interval()</code> breaks the numerical range of that column into
equal-sized intervals, or into intervals specified by <code>breaks</code>.
<code>bin_by_quantile()</code> splits the range into pieces based on quantiles of the
data, so each interval contains roughly an equal number of observations.
</p>


<h3>Value</h3>

<p>Grouped data frame, similar to those returned by <code>dplyr::group_by()</code>.
An additional column <code>.bin</code> indicates the bin number for each group. Use
<code>dplyr::summarize()</code> to calculate values within each group, or other dplyr
operations that work on groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressMessages(library(dplyr))
cars |&gt;
  bin_by_interval(speed, breaks = 5) |&gt;
  summarize(mean_speed = mean(speed),
            mean_dist = mean(dist))

cars |&gt;
  bin_by_quantile(speed, breaks = 5) |&gt;
  summarize(mean_speed = mean(speed),
            mean_dist = mean(dist))
</code></pre>

<hr>
<h2 id='binned_residuals'>Obtain binned residuals for a model</h2><span id='topic+binned_residuals'></span>

<h3>Description</h3>

<p>Construct a data frame by binning the fitted values or predictors of a model
into discrete bins of equal width, and calculating the average value of the
residuals within each bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binned_residuals(fit, predictors = !".fitted", breaks = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binned_residuals_+3A_fit">fit</code></td>
<td>
<p>The model to obtain residuals for. This can be a model fit with
<code>lm()</code> or <code>glm()</code>, or any model that has <code>residuals()</code> and <code>fitted()</code>
methods.</p>
</td></tr>
<tr><td><code id="binned_residuals_+3A_predictors">predictors</code></td>
<td>
<p>Predictors to calculate binned residuals for. Defaults to
all predictors, skipping factors. Predictors can be specified using
tidyselect syntax; see <code>help("language", package = "tidyselect")</code> and the
examples below. Specify <code>predictors = .fitted</code> to obtain binned residuals
versus fitted values.</p>
</td></tr>
<tr><td><code id="binned_residuals_+3A_breaks">breaks</code></td>
<td>
<p>Number of bins to create. If <code>NULL</code>, a default number of breaks
is chosen based on the number of rows in the data.</p>
</td></tr>
<tr><td><code id="binned_residuals_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>residuals()</code>. The most useful
additional argument is typically <code>type</code>, to select the type of residuals to
produce (such as standardized residuals or deviance residuals).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many generalized linear models, the residual plots (Pearson or deviance)
are not useful because the response variable takes on very few possible
values, causing strange patterns in the residuals. For instance, in logistic
regression, plotting the residuals versus covariates usually produces two
curved lines.
</p>
<p>If we first bin the data, i.e. divide up the observations into <code>breaks</code> bins
based on their fitted values, we can calculate the average residual within
each bin. This can be more informative: if a region has 20 observations and
its average residual value is large, this suggests those observations are
collectively poorly fit. We can also bin each predictor and calculate
averages within those bins, allowing the detection of misspecification for
specific model terms.
</p>


<h3>Value</h3>

<p>Data frame (tibble) with one row per bin <em>per selected predictor</em>,
and the following columns:
</p>
<table role = "presentation">
<tr><td><code>.bin</code></td>
<td>
<p>Bin number.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations in this bin.</p>
</td></tr>
<tr><td><code>predictor_name</code></td>
<td>
<p>Name of the predictor that has been binned.</p>
</td></tr>
<tr><td><code>predictor_min</code>, <code>predictor_max</code>, <code>predictor_mean</code>, <code>predictor_sd</code></td>
<td>
<p>Minimum,
maximum, mean, and standard deviation of the predictor (or fitted values).</p>
</td></tr>
<tr><td><code>resid_mean</code></td>
<td>
<p>Mean residual in this bin.</p>
</td></tr>
<tr><td><code>resid_sd</code></td>
<td>
<p>Standard deviation of residuals in this bin.</p>
</td></tr>
</table>


<h3>Limitations</h3>

<p>Factor predictors (as factors, logical, or character vectors) are detected
automatically and omitted. However, if a numeric variable is converted to
factor in the model formula, such as with <code>y ~ factor(x)</code>, the function
cannot determine the appropriate type and will raise an error. Create factors
as needed in the source data frame <em>before</em> fitting the model to avoid this
issue.
</p>


<h3>References</h3>

<p>Gelman, A., Hill, J., and Vehtari, A. (2021). <em>Regression and
Other Stories</em>. Section 14.5. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partial_residuals">partial_residuals()</a></code> for the related partial residuals;
<code>vignette("logistic-regression-diagnostics")</code> and
<code>vignette("other-glm-diagnostics")</code> for examples of use and interpretation
of binned residuals in logistic regression and GLMs; <code><a href="#topic+bin_by_interval">bin_by_interval()</a></code>
and <code><a href="#topic+bin_by_quantile">bin_by_quantile()</a></code> to bin data and calculate other values in each bin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(mpg ~ disp + hp, data = mtcars)

# Automatically bins both predictors:
binned_residuals(fit, breaks = 5)

# Just bin one predictor, selected with tidyselect syntax. Multiple could be
# selected with c().
binned_residuals(fit, disp, breaks = 5)

# Bin the fitted values:
binned_residuals(fit, predictors = .fitted)

# Bins are made using the predictor, not regressors derived from it, so here
# disp is binned, not its polynomial
fit2 &lt;- lm(mpg ~ poly(disp, 2), data = mtcars)
binned_residuals(fit2)
</code></pre>

<hr>
<h2 id='by_level'>Convert factor levels to numeric values</h2><span id='topic+by_level'></span>

<h3>Description</h3>

<p>Replace each entry in a vector with its corresponding numeric value, for
instance to use a factor variable to specify intercepts for different groups
in a regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>by_level(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by_level_+3A_x">x</code></td>
<td>
<p>Vector of factor values</p>
</td></tr>
<tr><td><code id="by_level_+3A_...">...</code></td>
<td>
<p>Mapping from factor levels to values. Can be provided either as a
series of named arguments, whose names correspond to factor levels, or as a
single named vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector of same length as <code>x</code>, with values replaced with those
specified. Names are the original factor level name.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfactor">rfactor()</a></code> to draw random factor levels, and the <code>forcats</code> package
<a href="https://forcats.tidyverse.org/">https://forcats.tidyverse.org/</a> for additional factor manipulation tools
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- factor(c("spam", "ham", "spam", "ducks"))

by_level(foo, spam = 4, ham = 10, ducks = 16.7)

by_level(foo, c("spam" = 4, "ham" = 10, "ducks" = 16.7))

# to define a population with a factor that affects the regression intercept
intercepts &lt;- c("foo" = 2, "bar" = 30, "baz" = 7)
pop &lt;- population(
  group = predictor(rfactor,
                    levels = c("foo", "bar", "baz"),
                    prob = c(0.1, 0.6, 0.3)),
  x = predictor(runif, min = 0, max = 10),
  y = response(by_level(group, intercepts) + 0.3 * x,
               error_scale = 1.5)
)
sample_x(pop, 5)
</code></pre>

<hr>
<h2 id='check_data_arg'>Check that the model fit uses the data argument to provide data</h2><span id='topic+check_data_arg'></span>

<h3>Description</h3>

<p>We simulate by passing simulated data arguments to update(). If the original
fit does not use the data argument, and instead refers directly to variables
in the environment, the simulations will not behave as expected. This may
result in the &quot;simulated&quot; fits all using the original data, for instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_arg(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_data_arg_+3A_fit">fit</code></td>
<td>
<p>A fitted model object, whose call is to be examined</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, in <code>lm(mtcars$mpg ~ mtcars$drat)</code>, simulating new data and
providing it in <code style="white-space: pre;">&#8288;data =&#8288;</code> will not change the data used for fitting.
</p>
<p>Detect a missing <code>data</code> argument and abort. It is still possible to provide
<code>data</code> but also refer directly to the calling environment, but this is harder
to detect.
</p>


<h3>Value</h3>

<p>No value. Raises an error if no <code>data</code> argument was used in <code>fit</code>.
</p>

<hr>
<h2 id='custom_family'>Family representing a GLM with custom distribution and link function</h2><span id='topic+custom_family'></span>

<h3>Description</h3>

<p>Allows specification of the random component and link function for a response
variable. In principle this could be used to specify any GLM family, but it
is usually easier to use the predefined families, such as <code>gaussian()</code> and
<code>binomial()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_family(distribution, inverse_link)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="custom_family_+3A_distribution">distribution</code></td>
<td>
<p>The distribution of the random component. This should be
in the form of a function taking one argument, the vector of values on the
inverse link scale, and returning a vector of draws from the distribution.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_inverse_link">inverse_link</code></td>
<td>
<p>The inverse link function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A GLM is specified by a combination of:
</p>

<ul>
<li><p> Random component, i.e. the distribution that Y is drawn from
</p>
</li>
<li><p> Link function relating the mean of the random component to the linear predictor
</p>
</li>
<li><p> Linear predictor
</p>
</li></ul>

<p>Using <code>custom_family()</code> we can specify the random component and link
function, while the linear predictor is set in <code>population()</code> when setting up
the population relationships. A family specified this way can be used to
specify a population (via <code>population()</code>), but can't be used to estimate a
model (such as with <code>glm()</code>).
</p>


<h3>Value</h3>

<p>A family object representing this family
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ols_with_error">ols_with_error()</a></code> for the special case of linear regression with
custom error distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A zero-inflated Poisson family
rzeroinfpois &lt;- function(ys) {
  n &lt;- length(ys)
  rpois(n, lambda = ys * rbinom(n, 1, prob = 0.4))
}

custom_family(rzeroinfpois, exp)
</code></pre>

<hr>
<h2 id='decrypt'>Decrypt message giving the location of the true plot in a lineup</h2><span id='topic+decrypt'></span>

<h3>Description</h3>

<p>Decrypts the message printed by <code>model_lineup()</code> indicating the location of
the true diagnostics in the lineup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decrypt(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decrypt_+3A_...">...</code></td>
<td>
<p>Message to decrypt, specifying the location of the true
diagnostics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The decrypted message.
</p>

<hr>
<h2 id='detect_transmutation'>Detect transmutation in formulas, such as factor(), and raise an error</h2><span id='topic+detect_transmutation'></span>

<h3>Description</h3>

<p>We rely on predictors to occur in models with only one type (such as numeric
or factor), but the use of factor() would make it possible for a predictor to
appear both as a factor or as numeric. The use of factor() also makes it
harder to correctly detect the types of predictors, since the methods for
obtaining model predictors provide them before they are converted to factor,
not after. So we reject formulas that transmute types inside the formula,
such as with factor().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_transmutation(formula, call = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect_transmutation_+3A_formula">formula</code></td>
<td>
<p>Model formula</p>
</td></tr>
<tr><td><code id="detect_transmutation_+3A_call">call</code></td>
<td>
<p>Environment in which to raise the error, defaulting to the
calling environment. As this function is recursive, this reduces the
complexity of backtraces.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Presently only factor() calls are rejected, but if other transmutations (such
as conversions to logical or numeric) prove to be problems, they can be
rejected as well.
</p>


<h3>Value</h3>

<p>No value. Raises an error if transmutation is present.
</p>

<hr>
<h2 id='drop_factors'>Drop factor columns from a data frame</h2><span id='topic+drop_factors'></span>

<h3>Description</h3>

<p>Issues messages for the columns dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_factors(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_factors_+3A_df">df</code></td>
<td>
<p>Data frame to process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame without columns that are factors
</p>

<hr>
<h2 id='empirical_link'>Empirically estimate response values on the link scale</h2><span id='topic+empirical_link'></span>

<h3>Description</h3>

<p>Calculates the average value of the response variable, and places this on the
link scale. Plotting these against a predictor (by dividing the dataset into
bins) can help assess the choice of link function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empirical_link(response, family, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="empirical_link_+3A_response">response</code></td>
<td>
<p>Vector of response variable values.</p>
</td></tr>
<tr><td><code id="empirical_link_+3A_family">family</code></td>
<td>
<p>Family object representing the response distribution and link
function. Only the link function will be used.</p>
</td></tr>
<tr><td><code id="empirical_link_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values of the response be stripped? Passed to
<code>mean()</code> when calculating the mean of the response.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean response value, on the link scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressMessages(library(dplyr))
suppressMessages(library(ggplot2))

mtcars |&gt;
  bin_by_interval(disp, breaks = 5) |&gt;
  summarize(
    mean_disp = mean(disp),
    link = empirical_link(am, binomial())
  ) |&gt;
  ggplot(aes(x = mean_disp, y = link)) +
  geom_point()
</code></pre>

<hr>
<h2 id='factor_columns'>Check whether each column in a data frame is a factor</h2><span id='topic+factor_columns'></span>

<h3>Description</h3>

<p>Check whether each column in a data frame is a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_columns(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="factor_columns_+3A_df">df</code></td>
<td>
<p>Data frame to process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector with same number of entries as columns in <code>df</code>. Each
entry is <code>TRUE</code> if the corresponding column is a factor.
</p>

<hr>
<h2 id='in_interaction'>Determine if a predictor is involved in an interaction</h2><span id='topic+in_interaction'></span>

<h3>Description</h3>

<p>This presently does not work for any term like <code>poly(x, 3)</code> or <code>I(x^2)</code>,
since the terms object contains those names, not the names of the underlying
predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_interaction(formula, predictor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="in_interaction_+3A_formula">formula</code></td>
<td>
<p>Model formula</p>
</td></tr>
<tr><td><code id="in_interaction_+3A_predictor">predictor</code></td>
<td>
<p>Predictor to check for, as character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if in an interaction, <code>FALSE</code> otherwise
</p>

<hr>
<h2 id='model_lineup'>Produce a lineup for a fitted model</h2><span id='topic+model_lineup'></span>

<h3>Description</h3>

<p>A lineup hides diagnostics among &quot;null&quot; diagnostics, i.e. the same
diagnostics calculated using models fit to data where all model assumptions
are correct. For each null diagnostic, <code>model_lineup()</code> simulates new
responses from the model using the fitted covariate values and the model's
error distribution, link function, and so on. Hence the new response values
are generated under ideal conditions: the fitted model is true and all
assumptions hold. <code>decrypt()</code> reveals which diagnostics are the true
diagnostics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_lineup(fit, fn = augment, nsim = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_lineup_+3A_fit">fit</code></td>
<td>
<p>A model fit to data, such as by <code>lm()</code> or <code>glm()</code></p>
</td></tr>
<tr><td><code id="model_lineup_+3A_fn">fn</code></td>
<td>
<p>A diagnostic function. The function's first argument should be the
fitted model, and it must return a data frame. Defaults to
<code>broom::augment()</code>, which produces a data frame containing the original
data and additional columns <code>.fitted</code>, <code>.resid</code>, and so on. To see a list
of model types supported by <code>broom::augment()</code>, and to find documentation
on the columns reported for each type of model, load the <code>broom</code> package
and use <code>methods(augment)</code>.</p>
</td></tr>
<tr><td><code id="model_lineup_+3A_nsim">nsim</code></td>
<td>
<p>Number of total diagnostics. For example, if <code>nsim = 20</code>, the
diagnostics for <code>fit</code> are hidden among 19 null diagnostics.</p>
</td></tr>
<tr><td><code id="model_lineup_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fn</code> each time it is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To generate different kinds of diagnostics, the user can provide a custom
<code>fn</code>. The <code>fn</code> should take a model fit as its argument and return a data
frame. For instance, the data frame might contain one row per observation and
include the residuals and fitted values for each observation; or it might be
a single row containing a summary statistic or test statistic.
</p>
<p><code>fn</code> will be called on the original <code>fit</code> provided. Then
<code>parametric_boot_distribution()</code> will be used to simulate data from the model
fit <code>nsim - 1</code> times, refit the model to each simulated dataset, and run <code>fn</code>
on each refit model. The null distribution is conditional on X, i.e. the
covariates used will be identical, and only the response values will be
simulated. The data frames are concatenated with an additional <code>.sample</code>
column identifying which fit each row came from.
</p>
<p>When called, this function will print a message such as
<code>decrypt("sD0f gCdC En JP2EdEPn ZY")</code>. This is how to get the location of the
true diagnostics among the null diagnostics: evaluating this in the R console
will produce a string such as <code>"True data in position 5"</code>.
</p>


<h3>Value</h3>

<p>A data frame (tibble) with columns corresponding to the columns
returned by <code>fn</code>. The additional column <code>.sample</code> indicates which set of
diagnostics each row is from. For instance, if the true data is in position
5, selecting rows with <code>.sample == 5</code> will retrieve the diagnostics from
the original model fit.
</p>


<h3>Model limitations</h3>

<p>Because this function uses S3 generic methods such as <code>model.frame()</code>,
<code>simulate()</code>, and <code>update()</code>, it can be used with any model fit for which
methods are provided. In base R, this includes <code>lm()</code> and <code>glm()</code>.
</p>
<p>The model provided as <code>fit</code> must be fit using the <code>data</code> argument to provide
a data frame. For example:
</p>
<div class="sourceCode"><pre>fit &lt;- lm(dist ~ speed, data = cars)
</pre></div>
<p>When simulating new data, this function provides the simulated data as the
<code>data</code> argument and re-fits the model. If you instead refer directly to local
variables in the model formula, this will not work. For example, if you fit a
model this way:
</p>
<div class="sourceCode"><pre># will not work
fit &lt;- lm(cars$dist ~ cars$speed)
</pre></div>
<p>It will not be possible to refit the model using simulated datasets, as that
would require modifying your environment to edit <code>cars</code>.
</p>


<h3>References</h3>

<p>Buja et al. (2009). Statistical inference for exploratory data
analysis and model diagnostics. <em>Philosophical Transactions of the Royal
Society A</em>, 367 (1906), pp. 4361-4383. <a href="https://doi.org/10.1098/rsta.2009.0120">doi:10.1098/rsta.2009.0120</a>
</p>
<p>Wickham et al. (2010). Graphical inference for infovis. <em>IEEE Transactions on
Visualization and Computer Graphics</em>, 16 (6), pp. 973-979.
<a href="https://doi.org/10.1109/TVCG.2010.161">doi:10.1109/TVCG.2010.161</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parametric_boot_distribution">parametric_boot_distribution()</a></code> to simulate draws by using the
fitted model to draw new response values; <code><a href="#topic+sampling_distribution">sampling_distribution()</a></code> to
simulate draws from the population distribution, rather than from the model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(dist ~ speed, data = cars)
model_lineup(fit, nsim = 5)

resids_vs_speed &lt;- function(f) {
  data.frame(resid = residuals(f),
             speed = model.frame(f)$speed)
}
model_lineup(fit, fn = resids_vs_speed, nsim = 5)

</code></pre>

<hr>
<h2 id='normalize_family'>Accept family arguments in the same way as glm(), convert to standardized
form, and throw comprehensible errors.</h2><span id='topic+normalize_family'></span>

<h3>Description</h3>

<p>Accept family arguments in the same way as glm(), convert to standardized
form, and throw comprehensible errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_family(family, arg = caller_arg(family))
</code></pre>

<hr>
<h2 id='ols_with_error'>Family representing a linear relationship with non-Gaussian errors</h2><span id='topic+ols_with_error'></span>

<h3>Description</h3>

<p>The <code>ols_with_error()</code> family can represent any non-Gaussian error, provided
random variates can be drawn by an R function. A family specified this way
can be used to specify a population (via <code>population()</code>), but can't be used
to estimate a model (such as with <code>glm()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ols_with_error(error, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ols_with_error_+3A_error">error</code></td>
<td>
<p>Function that can draw random variables from the non-Gaussian
distribution, or a string giving the name of the function. For example,
<code>rt</code> draws <em>t</em>-distributed random variates. The function must take an
argument <code>n</code> indicating how many random variates to draw (as all random
generation functions built into R do).</p>
</td></tr>
<tr><td><code id="ols_with_error_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>error</code> function to draw random
variates, such as to specify degrees of freedom, shape parameters, or other
parameters of the distribution. These arguments are evaluated with the
model data in the environment, so they can be expressions referring to
model data, such as values of the predictors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A family object representing this family.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom_family">custom_family()</a></code> for fully custom families, including for GLMs
</p>


<h3>Examples</h3>

<pre><code class='language-R'># t-distributed errors with 3 degrees of freedom
ols_with_error(rt, df = 3)

# A linear regression with t-distributed error, using error_scale to make
# errors large
population(
  x1 = predictor(rnorm, mean = 4, sd = 10),
  x2 = predictor(runif, min = 0, max = 10),
  y = response(0.7 + 2.2 * x1 - 0.2 * x2,
               family = ols_with_error(rt, df = 4),
               error_scale = 2.5)
)

# Cauchy-distributed errors
ols_with_error(rcauchy, scale = 3)

# A contaminated error distribution, where
# 95% of observations are Gaussian and 5% are Cauchy
rcontaminated &lt;- function(n) {
  contaminant &lt;- rbinom(n, 1, prob = 0.05)

  return(ifelse(contaminant == 1,
                rcauchy(n, scale = 20),
                rnorm(n, sd = 1)))
}
ols_with_error(rcontaminated)
</code></pre>

<hr>
<h2 id='parametric_boot_distribution'>Simulate the distribution of estimates by parametric bootstrap</h2><span id='topic+parametric_boot_distribution'></span>

<h3>Description</h3>

<p>Repeatedly simulates new response values by using the fitted model, holding
the covariates fixed. By default, refits the same model to each simulated
dataset, but an alternative model can be provided. Estimates, confidence
intervals, or other quantities are extracted from each fitted model and
returned as a tidy data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parametric_boot_distribution(
  fit,
  alternative_fit = fit,
  data = model.frame(fit),
  fn = tidy,
  nsim = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parametric_boot_distribution_+3A_fit">fit</code></td>
<td>
<p>A model fit to data, such as by <code>lm()</code> or <code>glm()</code>, to simulate new
response values from.</p>
</td></tr>
<tr><td><code id="parametric_boot_distribution_+3A_alternative_fit">alternative_fit</code></td>
<td>
<p>A model fit to data, to refit to the data sampled from
<code>fit</code>. Defaults to <code>fit</code>, but an alternative model can be provided to
examine its behavior when <code>fit</code> is the true model.</p>
</td></tr>
<tr><td><code id="parametric_boot_distribution_+3A_data">data</code></td>
<td>
<p>Data frame to be used in the simulation. Must contain the
predictors needed for both <code>fit</code> and <code>alternative_fit</code>. Defaults to the
predictors used in <code>fit</code>.</p>
</td></tr>
<tr><td><code id="parametric_boot_distribution_+3A_fn">fn</code></td>
<td>
<p>Function to call on each new model fit to produce a data frame of
estimates. Defaults to <code>broom::tidy()</code>, which produces a tidy data frame of
coefficients, estimates, standard errors, and hypothesis tests.</p>
</td></tr>
<tr><td><code id="parametric_boot_distribution_+3A_nsim">nsim</code></td>
<td>
<p>Number of total simulations to run.</p>
</td></tr>
<tr><td><code id="parametric_boot_distribution_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fn</code> each time it is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default behavior samples from a model and refits the same model to the
sampled data; this is useful when, for example, exploring how model
diagnostics look when the model is well-specified. Another common use of the
parametric bootstrap is hypothesis testing, where we might simulate from a
null model and fit an alternative model to the data, to obtain the null
distribution of a particular estimate or statistic. Provide <code>alternative_fit</code>
to have a specific model fit to each simulated dataset, rather than the model
they are simulated from.
</p>
<p>Only the response variable from the <code>fit</code> (or <code>alternative_fit</code>, if given) is
redrawn; other response variables in the population are left unchanged from
their values in <code>data</code>.
</p>


<h3>Value</h3>

<p>A data frame (tibble) with columns corresponding to the columns
returned by <code>fn</code>. The additional column <code>.sample</code> indicates which fit each
row is from.
</p>


<h3>Model limitations</h3>

<p>Because this function uses S3 generic methods such as <code>model.frame()</code>,
<code>simulate()</code>, and <code>update()</code>, it can be used with any model fit for which
methods are provided. In base R, this includes <code>lm()</code> and <code>glm()</code>.
</p>
<p>The model provided as <code>fit</code> must be fit using the <code>data</code> argument to provide
a data frame. For example:
</p>
<div class="sourceCode"><pre>fit &lt;- lm(dist ~ speed, data = cars)
</pre></div>
<p>When simulating new data, this function provides the simulated data as the
<code>data</code> argument and re-fits the model. If you instead refer directly to local
variables in the model formula, this will not work. For example, if you fit a
model this way:
</p>
<div class="sourceCode"><pre># will not work
fit &lt;- lm(cars$dist ~ cars$speed)
</pre></div>
<p>It will not be possible to refit the model using simulated datasets, as that
would require modifying your environment to edit <code>cars</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_lineup">model_lineup()</a></code> to use resampling to aid in regression diagnostics;
<code><a href="#topic+sampling_distribution">sampling_distribution()</a></code> to simulate draws from the population
distribution, rather than the null
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bootstrap distribution of estimates:
fit &lt;- lm(mpg ~ hp, data = mtcars)
parametric_boot_distribution(fit, nsim = 5)

# Bootstrap distribution of estimates for a quadratic model, when true
# relationship is linear:
quad_fit &lt;- lm(mpg ~ poly(hp, 2), data = mtcars)
parametric_boot_distribution(fit, quad_fit, nsim = 5)

# Bootstrap distribution of estimates for a model with an additional
# predictor, when it's truly zero. data argument must be provided so
# alternative fit has all predictors available, not just hp:
alt_fit &lt;- lm(mpg ~ hp + wt, data = mtcars)
parametric_boot_distribution(fit, alt_fit, data = mtcars, nsim = 5)
</code></pre>

<hr>
<h2 id='partial_residuals'>Augment a model fit with partial residuals for all terms</h2><span id='topic+partial_residuals'></span>

<h3>Description</h3>

<p>Construct a data frame containing the model data, partial residuals for all
quantitative predictors, and predictor effects, for use in residual
diagnostic plots and other analyses. The result is in tidy form (one row per
predictor per observation), allowing it to be easily manipulated for plots
and simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_residuals(fit, predictors = everything())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partial_residuals_+3A_fit">fit</code></td>
<td>
<p>The model to obtain residuals for. This can be a model fit with
<code>lm()</code> or <code>glm()</code>, or any model with a <code>predict()</code> method that accepts a
<code>newdata</code> argument.</p>
</td></tr>
<tr><td><code id="partial_residuals_+3A_predictors">predictors</code></td>
<td>
<p>Predictors to calculate partial residuals for. Defaults to
all predictors, skipping factors. Predictors can be specified using
tidyselect syntax; see <code>help("language", package = "tidyselect")</code> and the
examples below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame (tibble) containing the model data and residuals in tidy
form. There is one row <em>per selected predictor</em> per observation. All
predictors are included as columns, plus the following additional columns:
</p>
<table role = "presentation">
<tr><td><code>.obs</code></td>
<td>
<p>Row number of this observation in the original model data frame.</p>
</td></tr>
<tr><td><code>.predictor_name</code></td>
<td>
<p>Name of the predictor this row gives the partial
residual for.</p>
</td></tr>
<tr><td><code>.predictor_value</code></td>
<td>
<p>Value of the predictor this row gives the partial
residual for.</p>
</td></tr>
<tr><td><code>.partial_resid</code></td>
<td>
<p>Partial residual for this predictor for this
observation.</p>
</td></tr>
<tr><td><code>.predictor_effect</code></td>
<td>
<p>Predictor effect <code class="reqn">\hat \mu(X_{if},
0)</code> for this observation.</p>
</td></tr>
</table>


<h3>Predictors and regressors</h3>

<p>To define partial residuals, we must distinguish between the <em>predictors</em>,
the measured variables we are using to fit our model, and the <em>regressors</em>,
which are calculated from them. In a simple linear model, the regressors are
equal to the predictors. But in a model with polynomials, splines, or other
nonlinear terms, the regressors may be functions of the predictors.
</p>
<p>For example, in a regression with a single predictor <code class="reqn">X</code>, the regression
model <code class="reqn">Y = \beta_0 + \beta_1 X + e</code> has one regressor, <code class="reqn">X</code>. But if we
choose a polynomial of degree 3, the model is <code class="reqn">Y = \beta_0 + \beta_1 X +
\beta_2 X^2 + \beta_3 X^3</code>, and the regressors are <code class="reqn">\{X, X^2, X^3\}</code>.
</p>
<p>Similarly, if we have predictors <code class="reqn">X_1</code> and <code class="reqn">X_2</code> and form a model
with main effects and an interaction, the regressors are <code class="reqn">\{X_1, X_2, X_1
X_2\}</code>.
</p>
<p>Partial residuals are defined in terms of the predictors, not the regressors,
and are intended to allow us to see the shape of the relationship between a
particular predictor and the response, and to compare it to how we have
chosen to model it with regressors. Partial residuals are not useful for
categorical (factor) predictors, and so these are omitted.
</p>


<h3>Linear models</h3>

<p>Consider a linear model where <code class="reqn">\mathbb{E}[Y \mid X = x] = \mu(x)</code>. The mean function <code class="reqn">\mu(x)</code> is a linear combination of
regressors. Let <code class="reqn">\hat \mu</code> be the fitted model and <code class="reqn">\hat
\beta_0</code> be its intercept.
</p>
<p>Choose a predictor <code class="reqn">X_f</code>, the <em>focal</em> predictor, to calculate partial
residuals for. Write the mean function as <code class="reqn">\mu(X_f, X_o)</code>, where
<code class="reqn">X_f</code> is the value of the focal predictor, and <code class="reqn">X_o</code> represents all
other predictors.
</p>
<p>If <code class="reqn">e_i</code> is the residual for observation <code class="reqn">i</code>, the partial residual is
</p>
<p style="text-align: center;"><code class="reqn">r_{if} = e_i + (\hat \mu(x_{if}, 0) - \hat \beta_0).</code>
</p>

<p>Setting <code class="reqn">X_o = 0</code> means setting all other numeric predictors to 0; factor
predictors are set to their first (baseline) level.
</p>


<h3>Generalized linear models</h3>

<p>Consider a generalized linear model where <code class="reqn">g(\mathbb{E}[Y \mid X = x]) =
\mu(x)</code>, where <code class="reqn">g</code> is a link function. Let
<code class="reqn">\hat \mu</code> be the fitted model and <code class="reqn">\hat \beta_0</code> be
its intercept.
</p>
<p>Let <code class="reqn">e_i</code> be the <em>working residual</em> for observation <code class="reqn">i</code>, defined to
be
</p>
<p style="text-align: center;"><code class="reqn">e_i = (y_i - g^{-1}(x_i)) g'(x_i).</code>
</p>

<p>Choose a predictor <code class="reqn">X_f</code>, the <em>focal</em> predictor, to calculate partial
residuals for. Write <code class="reqn">\mu</code> as <code class="reqn">\mu(X_f, X_o)</code>, where <code class="reqn">X_f</code> is the
value of the focal predictor, and <code class="reqn">X_o</code> represents all other predictors.
Hence <code class="reqn">\mu(X_f, X_o)</code> gives the model's prediction on the link scale.
</p>
<p>The partial residual is again
</p>
<p style="text-align: center;"><code class="reqn">r_{if} = e_i + (\hat \mu(x_{if}, 0) - \hat \beta_0).</code>
</p>



<h3>Interpretation</h3>

<p>In linear regression, because the residuals <code class="reqn">e_i</code> should have mean zero
in a well-specified model, plotting the partial residuals against <code class="reqn">x_f</code>
should produce a shape matching the modeled relationship <code class="reqn">\mu</code>. If the
model is wrong, the partial residuals will appear to deviate from the fitted
relationship. Provided the regressors are uncorrelated or approximately
linearly related to each other, the plotted trend should approximate the true
relationship between <code class="reqn">x_f</code> and the response.
</p>
<p>In generalized linear models, this is approximately true if the link function
<code class="reqn">g</code> is approximately linear over the range of observed <code class="reqn">x</code> values.
</p>
<p>Additionally, the function <code class="reqn">\mu(X_f, 0)</code> can be used to show the
relationship between the focal predictor and the response. In a linear model,
the function is linear; with polynomial or spline regressors, it is
nonlinear. This function is the <em>predictor effect function</em>, and the
estimated predictor effects <code class="reqn">\hat \mu(X_{if}, 0)</code> are
included in this function's output.
</p>


<h3>Limitations</h3>

<p>Factor predictors (as factors, logical, or character vectors) are detected
automatically and omitted. However, if a numeric variable is converted to
factor in the model formula, such as with <code>y ~ factor(x)</code>, the function
cannot determine the appropriate type and will raise an error. Create factors
as needed in the source data frame <em>before</em> fitting the model to avoid this
issue.
</p>


<h3>References</h3>

<p>R. Dennis Cook (1993). &quot;Exploring Partial Residual Plots&quot;,
<em>Technometrics</em>, 35:4, 351-362. <a href="https://doi.org/10.1080/00401706.1993.10485350">doi:10.1080/00401706.1993.10485350</a>
</p>
<p>Cook, R. Dennis, and Croos-Dabrera, R. (1998).
&quot;Partial Residual Plots in Generalized Linear Models.&quot; <em>Journal of the
American Statistical Association</em> 93, no. 442: 730â€“39. <a href="https://doi.org/10.2307/2670123">doi:10.2307/2670123</a>
</p>
<p>Fox, J., &amp; Weisberg, S. (2018).
&quot;Visualizing Fit and Lack of Fit in Complex Regression Models with Predictor
Effect Plots and Partial Residuals.&quot; <em>Journal of Statistical Software</em>,
87(9). <a href="https://doi.org/10.18637/jss.v087.i09">doi:10.18637/jss.v087.i09</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binned_residuals">binned_residuals()</a></code> for the related binned residuals;
<code><a href="#topic+augment_longer">augment_longer()</a></code> for a similarly formatted data frame of ordinary
residuals; <code>vignette("linear-regression-diagnostics")</code>,
<code>vignette("logistic-regression-diagnostics")</code>, and
<code>vignette("other-glm-diagnostics")</code> for examples of plotting and
interpreting partial residuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(mpg ~ cyl + disp + hp, data = mtcars)
partial_residuals(fit)

# You can select predictors with tidyselect syntax:
partial_residuals(fit, c(disp, hp))

# Predictors with multiple regressors are supported:
fit2 &lt;- lm(mpg ~ poly(disp, 2), data = mtcars)
partial_residuals(fit2)

# Allowing an interaction by number of cylinders is fine, but partial
# residuals are not generated for the factor. Notice the factor must be
# created first, not in the model formula:
mtcars$cylinders &lt;- factor(mtcars$cyl)
fit3 &lt;- lm(mpg ~ cylinders * disp + hp, data = mtcars)
partial_residuals(fit3)
</code></pre>

<hr>
<h2 id='population'>Define the population generalized regression relationship</h2><span id='topic+population'></span>

<h3>Description</h3>

<p>Specifies a hypothetical infinite population of cases. Each case has some
predictor variables and one or more response variables. The relationship
between the variables and response variables are defined, as well as the
population marginal distribution of each predictor variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="population_+3A_...">...</code></td>
<td>
<p>A sequence of named arguments defining predictor and response
variables. These are evaluated in order, so later response variables may
refer to earlier predictor and response variables. All predictors should be
provided first, before any response variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A population object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictor">predictor()</a></code> and <code><a href="#topic+response">response()</a></code> to define the population;
<code>sample_x()</code> and <code>sample_y()</code> to draw samples from it
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A population with a simple linear relationship
linear_pop &lt;- population(
  x1 = predictor(rnorm, mean = 4, sd = 10),
  x2 = predictor(runif, min = 0, max = 10),
  y = response(0.7 + 2.2 * x1 - 0.2 * x2, error_scale = 1.0)
)

# A population whose response depends on local variables
slope &lt;- 2.2
intercept &lt;- 0.7
sigma &lt;- 2.5
variable_pop &lt;- population(
  x = predictor(rnorm),
  y = response(intercept + slope * x, error_scale = sigma)
)

# Response error scale is heteroskedastic and depends on predictors
heteroskedastic_pop &lt;- population(
  x1 = predictor(rnorm, mean = 4, sd = 10),
  x2 = predictor(runif, min = 0, max = 10),
  y = response(0.7 + 2.2 * x1 - 0.2 * x2,
               error_scale = 1 + x2 / 10)
)

# A binary outcome Y, using a binomial family with logistic link
binary_pop &lt;- population(
  x1 = predictor(rnorm, mean = 4, sd = 10),
  x2 = predictor(runif, min = 0, max = 10),
  y = response(0.7 + 2.2 * x1 - 0.2 * x2,
               family = binomial(link = "logit"))
)

# A binomial outcome Y, with 10 trials per observation, using a logistic link
# to determine the probability of success for each trial
binomial_pop &lt;- population(
  x1 = predictor(rnorm, mean = 4, sd = 10),
  x2 = predictor(runif, min = 0, max = 10),
  y = response(0.7 + 2.2 * x1 - 0.2 * x2,
               family = binomial(link = "logit"),
               size = 10)
)

# Another binomial outcome, but the number of trials depends on another
# predictor
binom_size_pop &lt;- population(
  x1 = predictor(rnorm, mean = 4, sd = 10),
  x2 = predictor(runif, min = 0, max = 10),
  trials = predictor(rpois, lambda = 20),
  y = response(0.7 + 2.2 * x1 - 0.2 * x2,
               family = binomial(link = "logit"),
               size = trials)
)

# A population with a simple linear relationship and collinearity. Because X
# is bivariate, there will be two predictors, named x1 and x2.
library(mvtnorm)
collinear_pop &lt;- population(
  x = predictor(rmvnorm, mean = c(0, 1),
                sigma = matrix(c(1, 0.8, 0.8, 1), nrow = 2)),
  y = response(0.7 + 2.2 * x1 - 0.2 * x2, error_scale = 1.0)
)
</code></pre>

<hr>
<h2 id='population_predictors'>Get the predictors of a population</h2><span id='topic+population_predictors'></span>

<h3>Description</h3>

<p>Get the predictors of a population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population_predictors(population)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="population_predictors_+3A_population">population</code></td>
<td>
<p>Population object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of predictors
</p>

<hr>
<h2 id='population_response'>Get the response variables of a population</h2><span id='topic+population_response'></span>

<h3>Description</h3>

<p>Get the response variables of a population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population_response(population)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="population_response_+3A_population">population</code></td>
<td>
<p>Population object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of response variables
</p>

<hr>
<h2 id='predictor'>Specify the distribution of a predictor variable</h2><span id='topic+predictor'></span>

<h3>Description</h3>

<p>Predictor variables can have any marginal distribution as long as a function
is provided to sample from the distribution. Multivariate distributions are
also supported: if the random generation function returns multiple columns,
multiple random variables will be created. If the columns are named, the
random variables will be named accordingly; otherwise, they will be
successively numbered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictor(dist, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictor_+3A_dist">dist</code></td>
<td>
<p>Function to generate draws from this predictor's distribution,
provided as a function or as a string naming the function.</p>
</td></tr>
<tr><td><code id="predictor_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>dist</code> when generating draws.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random generation function must take an argument named <code>n</code> specifying the
number of draws. For univariate distributions, it should return a vector of
length <code>n</code>; for multivariate distributions, it should return an array or
matrix with <code>n</code> rows and a column per variable.
</p>
<p>Multivariate predictors are successively numbered. For instance, if predictor
<code>X</code> is specified with
</p>
<div class="sourceCode"><pre>library(mvtnorm)
predictor(dist = rmvnorm, mean = c(0, 1),
          sigma = matrix(c(1, 0.5, 0.5, 1), nrow = 2))
</pre></div>
<p>then the population predictors will be named <code>X1</code> and <code>X2</code>, and will have
covariance 0.5.
</p>
<p>If the multivariate predictor has named columns, the names will be used
instead. For instance, if predictor <code>X</code> generates a matrix with columns <code>A</code>
and <code>B</code>, the population predictors will be named <code>XA</code> and <code>XB</code>.
</p>


<h3>Value</h3>

<p>A <code>predictor_dist</code> object, to be used in <code>population()</code> to specify a
population distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate normal distribution
predictor(dist = rnorm, mean = 10, sd = 2.5)

# Multivariate normal distribution
library(mvtnorm)
predictor(dist = rmvnorm, mean = c(0, 1, 7))

# Multivariate with named columns
rmulti &lt;- function(n) {
  cbind(treatment = rbinom(n, size = 1, prob = 0.5),
        confounder = rnorm(n)
  )
}
predictor(dist = rmulti)
</code></pre>

<hr>
<h2 id='prototype_for'>Get a prototype data frame for partial residuals</h2><span id='topic+prototype_for'></span>

<h3>Description</h3>

<p>All predictors, except the one we are calculating partial residuals for, are
set to 0 (or their baseline level, for factors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prototype_for(df, predictor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prototype_for_+3A_df">df</code></td>
<td>
<p>data frame of predictors</p>
</td></tr>
<tr><td><code id="prototype_for_+3A_predictor">predictor</code></td>
<td>
<p>character vector identifying one predictor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prototype data frame
</p>

<hr>
<h2 id='response'>Specify a response variable in terms of predictors</h2><span id='topic+response'></span>

<h3>Description</h3>

<p>Response variables are related to predictors (and other response variables)
through a link function and response distribution. First the expression
provided is evaluated using the predictors, to give this response variable's
value on the link scale; then the inverse link function and response
distribution are used to get the response value. See Details for more
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response(expr, family = gaussian(), error_scale = NULL, size = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="response_+3A_expr">expr</code></td>
<td>
<p>An expression, in terms of other predictor or response variables,
giving this predictor's value on the link scale.</p>
</td></tr>
<tr><td><code id="response_+3A_family">family</code></td>
<td>
<p>The family of this response variable, e.g. <code>gaussian()</code> for an
ordinary Gaussian linear relationship.</p>
</td></tr>
<tr><td><code id="response_+3A_error_scale">error_scale</code></td>
<td>
<p>Scale factor for errors. Used only for linear families,
such as <code>gaussian()</code> and <code>ols_with_error()</code>. Errors drawn while simulating
the response variable will be multiplied by this scale factor. The scale
factor can be a scalar value (such as a fixed standard deviation), or an
expression in terms of the predictors, which will be evaluated when
simulating response data. For generalized linear models, leave as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="response_+3A_size">size</code></td>
<td>
<p>When the <code>family</code> is <code>binomial()</code>, this is the number of trials
for each observation. Defaults to 1, as in logistic regression. May be
specified either as a vector of the same length as the number of
observations or as a scalar. May be written terms of other predictor or
response variables. For other families, <code>size</code> is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Response variables are drawn based on a typical generalized linear model
setup. Let <code class="reqn">Y</code> represent the response variable and <code class="reqn">X</code> represent the
predictor variables. We specify that
</p>
<p style="text-align: center;"><code class="reqn">Y \mid X \sim \text{SomeDistribution},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\mathbb{E}[Y \mid X = x] = g^{-1}(\mu(x)).</code>
</p>

<p>Here <code class="reqn">\mu(X)</code> is the expression <code>expr</code>, and both the distribution and
link function <code class="reqn">g</code> are specified by the <code>family</code> provided. For instance,
if the <code>family</code> is <code>gaussian()</code>, the distribution is Normal and the link is
the identity function; if the <code>family</code> is <code>binomial()</code>, the distribution is
binomial and the link is (by default) the logistic link.
</p>


<h4>Response families</h4>

<p>The following response families are supported.
</p>

<dl>
<dt><code>gaussian()</code></dt><dd>
<p>The default family is <code>gaussian()</code> with the identity link function,
specifying the relationship
</p>
<p style="text-align: center;"><code class="reqn">Y \mid X \sim \text{Normal}(\mu(X), \sigma^2),</code>
</p>

<p>where <code class="reqn">\sigma^2</code> is given by <code>error_scale</code>.
</p>
</dd>
<dt><code>ols_with_error()</code></dt><dd><p>Allows specification of custom non-Normal error
distributions, specifying the relationship
</p>
<p style="text-align: center;"><code class="reqn">Y = \mu(X) + e,</code>
</p>

<p>where <code class="reqn">e</code> is drawn from an arbitrary distribution, specified by the
<code>error</code> argument to <code>ols_with_error()</code>.
</p>
</dd>
<dt><code>binomial()</code></dt><dd><p>Binomial responses include binary responses (as in logistic
regression) and responses giving a total number of successes out of a number
of trials. The response has distribution
</p>
<p style="text-align: center;"><code class="reqn">Y \mid X \sim \text{Binomial}(N, g^{-1}(\mu(X))),</code>
</p>

<p>where <code class="reqn">N</code> is set by the <code>size</code> argument and <code class="reqn">g</code> is the link function.
The default link is the logistic link, and others can be chosen with the
<code>link</code> argument to <code>binomial()</code>. The default <code class="reqn">N</code> is 1, representing a
binary outcome.
</p>
</dd>
<dt><code>poisson()</code></dt><dd><p>Poisson-distributed responses with distribution
</p>
<p style="text-align: center;"><code class="reqn">Y \mid X \sim \text{Poisson}(g^{-1}(\mu(X))),</code>
</p>

<p>where <code class="reqn">g</code> is the link function. The default link is the log link, and
others can be chosen with the <code>link</code> argument to <code>poisson()</code>.
</p>
</dd>
<dt><code>custom_family()</code></dt><dd><p>Responses drawn from an arbitrary distribution with
arbitrary link function, i.e.
</p>
<p style="text-align: center;"><code class="reqn">Y \mid X \sim \text{SomeDistribution}(g^{-1}(\mu(X))),</code>
</p>

<p>where both <code class="reqn">g</code> and SomeDistribution are specified by arguments to
<code>custom_family()</code>.
</p>
</dd>
</dl>




<h4>Evaluation and scoping</h4>

<p>The <code>expr</code>, <code>error_scale</code>, and <code>size</code> arguments are evaluated only when
simulating data for this response variable. They are evaluated in an
environment with access to the predictor variables and the preceding response
variables, which they can refer to by name. Additionally, these arguments can
refer to variables in scope when the enclosing <code>population()</code> was defined.
See the Examples below.
</p>



<h3>Value</h3>

<p>A <code>response_dist</code> object, to be used in <code>population()</code> to specify a
population distribution
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictor">predictor()</a></code> and <code><a href="#topic+population">population()</a></code> to define populations;
<code><a href="#topic+ols_with_error">ols_with_error()</a></code> and <code><a href="#topic+custom_family">custom_family()</a></code> for custom response distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defining a binomial response. The expressions can refer to other predictors
# and to the environment where the `population()` is defined:
slope1 &lt;- 2.5
slope2 &lt;- -3
intercept &lt;- -4.6
size &lt;- 10
population(
  x1 = predictor(rnorm),
  x2 = predictor(rnorm),
  y = response(intercept + slope1 * x1 + slope2 * x2,
               family = binomial(), size = size)
)
</code></pre>

<hr>
<h2 id='rfactor'>Draw random values from a factor variable</h2><span id='topic+rfactor'></span>

<h3>Description</h3>

<p>To specify the population distribution of a factor variable, specify the
probability for each of its factor levels. When drawn from the population,
factor levels are drawn with replacement according to their probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfactor(n, levels, prob = rep_len(1/length(levels), length(levels)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfactor_+3A_n">n</code></td>
<td>
<p>Number of values to draw</p>
</td></tr>
<tr><td><code id="rfactor_+3A_levels">levels</code></td>
<td>
<p>Character vector specifying the levels for the factor</p>
</td></tr>
<tr><td><code id="rfactor_+3A_prob">prob</code></td>
<td>
<p>Vector specifying the probability for each factor level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sample of <code>n</code> values from <code>levels</code>, drawn in proportion to their
probabilities. By default, levels are equally likely.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+by_level">by_level()</a></code> to assign numeric values based on factor levels, such
as to set population regression coefficients by factor level
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rfactor(5, c("foo", "bar", "baz"), c(0.4, 0.3, 0.3))
</code></pre>

<hr>
<h2 id='sample_x'>Draw a data frame from the specified population.</h2><span id='topic+sample_x'></span><span id='topic+sample_y'></span>

<h3>Description</h3>

<p>Sampling is split into two steps, for predictors and for response variables,
to allow users to choose which to simulate. <code>sample_x()</code> will only sample
predictor variables, and <code>sample_y()</code> will augment a data frame of predictors
with columns for response variables, overwriting any already present. Hence
one can use <code>sample_y()</code> as part of a simulation with fixed predictors, for
instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_x(population, n)

sample_y(xs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_x_+3A_population">population</code></td>
<td>
<p>Population, as defined by <code>population()</code>.</p>
</td></tr>
<tr><td><code id="sample_x_+3A_n">n</code></td>
<td>
<p>Number of observations to draw from the population.</p>
</td></tr>
<tr><td><code id="sample_x_+3A_xs">xs</code></td>
<td>
<p>Data frame of predictor values drawn from the population, as
obtained from <code>sample_x()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame (tibble) of <code>n</code> rows, with columns matching the variables
specified in the population.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A population with a simple linear relationship
pop &lt;- population(
  x1 = predictor(rnorm, mean = 4, sd = 10),
  x2 = predictor(runif, min = 0, max = 10),
  y = response(0.7 + 2.2 * x1 - 0.2 * x2, error_scale = 1.0)
)

xs &lt;- pop |&gt;
  sample_x(5)

xs

xs |&gt;
  sample_y()
</code></pre>

<hr>
<h2 id='sampling_distribution'>Simulate the sampling distribution of estimates from a population</h2><span id='topic+sampling_distribution'></span>

<h3>Description</h3>

<p>Repeatedly refits the model to new samples from the population, calculates
estimates for each fit, and compiles a data frame of the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampling_distribution(fit, data, fn = tidy, nsim = 100, fixed_x = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampling_distribution_+3A_fit">fit</code></td>
<td>
<p>A model fit to data, such as by <code>lm()</code> or <code>glm()</code>, to refit to
each sample from the population.</p>
</td></tr>
<tr><td><code id="sampling_distribution_+3A_data">data</code></td>
<td>
<p>Data drawn from a <code>population()</code>, using <code>sample_x()</code> and possibly
<code>sample_y()</code>. The <code>population()</code> specification is used to draw the samples.</p>
</td></tr>
<tr><td><code id="sampling_distribution_+3A_fn">fn</code></td>
<td>
<p>Function to call on each new model fit to produce a data frame of
estimates. Defaults to <code>broom::tidy()</code>, which produces a tidy data frame of
coefficients, estimates, standard errors, and hypothesis tests.</p>
</td></tr>
<tr><td><code id="sampling_distribution_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to run.</p>
</td></tr>
<tr><td><code id="sampling_distribution_+3A_fixed_x">fixed_x</code></td>
<td>
<p>If <code>TRUE</code>, the default, the predictor variables are held fixed
and only the response variables are redrawn from the population. If
<code>FALSE</code>, the predictor and response variables are drawn jointly.</p>
</td></tr>
<tr><td><code id="sampling_distribution_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fn</code> each time it is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To generate sampling distributions of different quantities, the user can
provide a custom <code>fn</code>. The <code>fn</code> should take a model fit as its argument and
return a data frame. For instance, the data frame might contain one row per
estimated coefficient and include the coefficient and its standard error; or
it might contain only one row of model summary statistics.
</p>


<h3>Value</h3>

<p>Data frame (tibble) of <code>nsim + 1</code> simulation results, formed by
concatenating together the data frames returned by <code>fn</code>. The <code>.sample</code>
column identifies which simulated sample each row came from. Rows with
<code>.sample == 0</code> come from the original <code>fit</code>.
</p>


<h3>Model limitations</h3>

<p>Because this function uses S3 generic methods such as <code>model.frame()</code>,
<code>simulate()</code>, and <code>update()</code>, it can be used with any model fit for which
methods are provided. In base R, this includes <code>lm()</code> and <code>glm()</code>.
</p>
<p>The model provided as <code>fit</code> must be fit using the <code>data</code> argument to provide
a data frame. For example:
</p>
<div class="sourceCode"><pre>fit &lt;- lm(dist ~ speed, data = cars)
</pre></div>
<p>When simulating new data, this function provides the simulated data as the
<code>data</code> argument and re-fits the model. If you instead refer directly to local
variables in the model formula, this will not work. For example, if you fit a
model this way:
</p>
<div class="sourceCode"><pre># will not work
fit &lt;- lm(cars$dist ~ cars$speed)
</pre></div>
<p>It will not be possible to refit the model using simulated datasets, as that
would require modifying your environment to edit <code>cars</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parametric_boot_distribution">parametric_boot_distribution()</a></code> to simulate draws from a fitted
model, rather than from the population
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- population(
  x1 = predictor(rnorm, mean = 4, sd = 10),
  x2 = predictor(runif, min = 0, max = 10),
  y = response(0.7 + 2.2 * x1 - 0.2 * x2, error_scale = 4.0)
)

d &lt;- sample_x(pop, n = 20) |&gt;
  sample_y()

fit &lt;- lm(y ~ x1 + x2, data = d)
# using the default fn = broom::tidy(). conf.int argument is passed to
# broom::tidy()
samples &lt;- sampling_distribution(fit, d, conf.int = TRUE)
samples

suppressMessages(library(dplyr))
# the model is correctly specified, so the estimates are unbiased:
samples |&gt;
  group_by(term) |&gt;
  summarize(mean = mean(estimate),
            sd = sd(estimate))

# instead of coefficients, get the sampling distribution of R^2
rsquared &lt;- function(fit) {
  data.frame(r2 = summary(fit)$r.squared)
}
sampling_distribution(fit, d, rsquared, nsim = 10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
