<!DOCTYPE html><html><head><title>Help for package swaRm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {swaRm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#swaRm-package'><p>Analysis tools for collective animal movement data</p></a></li>
<li><a href='#.cartesian_perimeter'><p>Perimeter Of A Polygon In Cartesian Space</p></a></li>
<li><a href='#.cartesianPerimeter'><p>Rotational Order Parameter</p></a></li>
<li><a href='#.ellipse'><p>Bivariate Confidence Ellipse</p></a></li>
<li><a href='#ang_acc'><p>Angular Acceleration</p></a></li>
<li><a href='#ang_speed'><p>Angular Speeds</p></a></li>
<li><a href='#centroid'><p>Centroid</p></a></li>
<li><a href='#chull_area'><p>Surface Area of the Convex Hull</p></a></li>
<li><a href='#chull_perimeter'><p>Perimeter of the Convex Hull</p></a></li>
<li><a href='#dist2centroid'><p>Distances to the Centroid</p></a></li>
<li><a href='#heading'><p>Headings</p></a></li>
<li><a href='#is_chull'><p>Points on Convex Hull</p></a></li>
<li><a href='#linear_acc'><p>Linear Accelerations</p></a></li>
<li><a href='#linear_dist'><p>Linear Distances</p></a></li>
<li><a href='#linear_speed'><p>Linear Speeds</p></a></li>
<li><a href='#nn'><p>Nearest Neighbor</p></a></li>
<li><a href='#nnd'><p>Nearest Neihgbor Distance</p></a></li>
<li><a href='#nsd'><p>Net Squared Displacement</p></a></li>
<li><a href='#pdist'><p>Pairwise Distance Matrix</p></a></li>
<li><a href='#pol_order'><p>Polarization Order Parameter</p></a></li>
<li><a href='#sphericity'><p>Sphericity</p></a></li>
<li><a href='#stretch'><p>Stretching Direction</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Processing Collective Movement Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Garnier &lt;garnier@njit.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Function library for processing collective movement data (e.g. fish
    schools, ungulate herds, baboon troops) collected from GPS trackers or 
    computer vision tracking software. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, splancs, geosphere, lubridate, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://swarm-lab.github.io/swaRm/">https://swarm-lab.github.io/swaRm/</a>,
<a href="https://github.com/swarm-lab/swaRm">https://github.com/swarm-lab/swaRm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/swarm-lab/swaRm/issues">https://github.com/swarm-lab/swaRm/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-10 21:18:45 UTC; simon</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Garnier <a href="https://orcid.org/0000-0002-3886-3974"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-11 10:20:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='swaRm-package'>Analysis tools for collective animal movement data</h2><span id='topic+swaRm'></span><span id='topic+swaRm-package'></span>

<h3>Description</h3>

<p>This package contains functions to facilitate and automate the analysis of 
collective animal movement data.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://swarm-lab.github.io/swaRm/">https://swarm-lab.github.io/swaRm/</a>
</p>
</li>
<li> <p><a href="https://github.com/swarm-lab/swaRm">https://github.com/swarm-lab/swaRm</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/swarm-lab/swaRm/issues">https://github.com/swarm-lab/swaRm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.cartesian_perimeter'>Perimeter Of A Polygon In Cartesian Space</h2><span id='topic+.cartesian_perimeter'></span>

<h3>Description</h3>

<p>Given a set of Cartesian coordinates representing a polygon, 
this function computes the perimeter of the polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cartesian_perimeter(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cartesian_perimeter_+3A_x">x</code></td>
<td>
<p>A vector of x coordinates.</p>
</td></tr>
<tr><td><code id=".cartesian_perimeter_+3A_y">y</code></td>
<td>
<p>A vector of y coordinates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chull_perimeter">chull_perimeter</a></code>
</p>

<hr>
<h2 id='.cartesianPerimeter'>Rotational Order Parameter</h2><span id='topic+.cartesianPerimeter'></span><span id='topic+rot_order'></span><span id='topic+rotOrder'></span>

<h3>Description</h3>

<p>Given a set of headings and locations, this function returns the 
rotational order of the set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cartesianPerimeter(x, y)

rot_order(x, y, h)

rotOrder(h, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cartesianPerimeter_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates.</p>
</td></tr>
<tr><td><code id=".cartesianPerimeter_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates.</p>
</td></tr>
<tr><td><code id=".cartesianPerimeter_+3A_h">h</code></td>
<td>
<p>A vector of headings (in radians).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value between 0 and 1 corresponding to the rotational 
order parameter of the group.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pol_order">pol_order</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
h &lt;- runif(25, 0, 2 * pi)
rot_order(x, y, h)

</code></pre>

<hr>
<h2 id='.ellipse'>Bivariate Confidence Ellipse</h2><span id='topic+.ellipse'></span>

<h3>Description</h3>

<p>This function computes the confidence ellipse of a set of 
bivariate coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ellipse(x, y, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ellipse_+3A_x">x</code></td>
<td>
<p>A vector of x coordinates.</p>
</td></tr>
<tr><td><code id=".ellipse_+3A_y">y</code></td>
<td>
<p>A vector of y coordinates.</p>
</td></tr>
<tr><td><code id=".ellipse_+3A_level">level</code></td>
<td>
<p>The confidence level of the ellipse.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sphericity">sphericity</a></code>, <code><a href="#topic+stretch">stretch</a></code>
</p>

<hr>
<h2 id='ang_acc'>Angular Acceleration</h2><span id='topic+ang_acc'></span><span id='topic+angAcc'></span>

<h3>Description</h3>

<p>Given a set of locations defining a trajectory, this function 
approximates their instantaneous angular accelerations computed as the 
difference between successive angular speeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ang_acc(x, y, t, geo = FALSE)

angAcc(x, y, t, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ang_acc_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="ang_acc_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="ang_acc_+3A_t">t</code></td>
<td>
<p>A vector of timestamps corresponding to a single trajectory.</p>
</td></tr>
<tr><td><code id="ang_acc_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as x, y and t corresponding to the
approximated instantaneous angular accelerations along the trajectory.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heading">heading</a></code>, <code><a href="#topic+ang_speed">ang_speed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
t &lt;- as.POSIXct(1:25, origin = Sys.time())
ang_acc(x, y, t)

</code></pre>

<hr>
<h2 id='ang_speed'>Angular Speeds</h2><span id='topic+ang_speed'></span><span id='topic+angSpeed'></span>

<h3>Description</h3>

<p>Given a set of locations defining a trajectory, this function 
approximates their instantaneous instantaneous angular speeds computed as 
the difference between successive headings divided by the time between these 
successive headings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ang_speed(x, y, t, geo = FALSE)

angSpeed(x, y, t, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ang_speed_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="ang_speed_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="ang_speed_+3A_t">t</code></td>
<td>
<p>A vector of timestamps corresponding to a single trajectory.</p>
</td></tr>
<tr><td><code id="ang_speed_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as x, y and t corresponding to the 
approximated instantaneous angular speeds along the trajectory.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heading">heading</a></code>, <code><a href="#topic+ang_acc">ang_acc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
t &lt;- as.POSIXct(1:25, origin = Sys.time())
ang_speed(x, y, t)

</code></pre>

<hr>
<h2 id='centroid'>Centroid</h2><span id='topic+centroid'></span>

<h3>Description</h3>

<p>This function computes the centroid (or center of mass) of a set 
of x-y (or longitude-latitude) coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid(x, y, robust = FALSE, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroid_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates.</p>
</td></tr>
<tr><td><code id="centroid_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates.</p>
</td></tr>
<tr><td><code id="centroid_+3A_robust">robust</code></td>
<td>
<p>A logical value indicating whether to compute the centroid as a
simple average of the coordinates (FALSE, the default), or as the average of 
the coordinates weighted by the inverse of their mean pairwise distance to 
all other coordinates in the set (TRUE).</p>
</td></tr>
<tr><td><code id="centroid_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-element list corresponding to the location of the centroid.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist2centroid">dist2centroid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
centroid(x, y)

</code></pre>

<hr>
<h2 id='chull_area'>Surface Area of the Convex Hull</h2><span id='topic+chull_area'></span><span id='topic+chullArea'></span>

<h3>Description</h3>

<p>Given a set of locations, this function determines the surface 
area of the convex hull (or envelope) of the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chull_area(x, y, geo = FALSE)

chullArea(x, y, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chull_area_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates.</p>
</td></tr>
<tr><td><code id="chull_area_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates.</p>
</td></tr>
<tr><td><code id="chull_area_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). If <code>TRUE</code>, 
the surface area is returned as square meters. If <code>FALSE</code>, it is 
returned as square units of the <code>[x,y]</code> coordinates. Default: 
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value corresponding to the surface area of the 
convex hull (in square meters if <code>geo</code> is <code>TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_chull">is_chull</a></code>, <code><a href="#topic+chull_perimeter">chull_perimeter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
chull_area(x, y)

</code></pre>

<hr>
<h2 id='chull_perimeter'>Perimeter of the Convex Hull</h2><span id='topic+chull_perimeter'></span><span id='topic+chullPerimeter'></span>

<h3>Description</h3>

<p>Given a set of locations, this function determines the perimeter 
of the convex hull (or envelope) of the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chull_perimeter(x, y, geo = FALSE)

chullPerimeter(x, y, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chull_perimeter_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates.</p>
</td></tr>
<tr><td><code id="chull_perimeter_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates.</p>
</td></tr>
<tr><td><code id="chull_perimeter_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). If <code>TRUE</code>, 
the perimeter is returned as meters. If <code>FALSE</code>, it is returned as 
units of the <code>[x,y]</code> coordinates. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value corresponding to the perimeter of the convex 
hull (in meters if <code>geo</code> is <code>TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_chull">is_chull</a></code>, <code><a href="#topic+chull_area">chull_area</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
chull_perimeter(x, y)

</code></pre>

<hr>
<h2 id='dist2centroid'>Distances to the Centroid</h2><span id='topic+dist2centroid'></span>

<h3>Description</h3>

<p>Given a set of x-y (or longitude-latitude) coordinates, this 
function computes their respective distance to the centroid (or center of 
mass) of the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist2centroid(x, y, robust = FALSE, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist2centroid_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates.</p>
</td></tr>
<tr><td><code id="dist2centroid_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates.</p>
</td></tr>
<tr><td><code id="dist2centroid_+3A_robust">robust</code></td>
<td>
<p>A logical value indicating whether to compute the centroid as a
simple average of the coordinates (FALSE, the default), or as the average of 
the coordinates weighted by the inverse of their mean pairwise distance to 
all other coordinates in the set (TRUE).</p>
</td></tr>
<tr><td><code id="dist2centroid_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as x and y corresponding to the 
individual distance of each point to the centroid of the set.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+centroid">centroid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
dist2centroid(x, y)

</code></pre>

<hr>
<h2 id='heading'>Headings</h2><span id='topic+heading'></span>

<h3>Description</h3>

<p>Given a set of locations defining a trajectory, this function 
approximates their instantaneous headings computed as the direction of the 
vectors between successive locations along the trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heading(x, y, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heading_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="heading_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="heading_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as x and y corresponding to the 
approximated headings along the trajectory.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ang_speed">ang_speed</a></code>, <code><a href="#topic+ang_acc">ang_acc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
heading(x, y)

</code></pre>

<hr>
<h2 id='is_chull'>Points on Convex Hull</h2><span id='topic+is_chull'></span><span id='topic+isChull'></span>

<h3>Description</h3>

<p>Given a set of locations, this function determines which 
locations belongs to the convex hull (or envelope) of the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_chull(x, y)

isChull(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_chull_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates.</p>
</td></tr>
<tr><td><code id="is_chull_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector of the same length as <code>x</code> and <code>y</code>. 
<code>0</code> indicates that the corresponding location is not part of the convex 
hull of the set. Values <code>&gt;0</code> indicates that the corresponding location 
is part of the convex hull, and each value corresponds to the order of the 
locations along the convex hull polygon.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chull_area">chull_area</a></code>, <code><a href="#topic+chull_perimeter">chull_perimeter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
is_chull(x, y)

</code></pre>

<hr>
<h2 id='linear_acc'>Linear Accelerations</h2><span id='topic+linear_acc'></span><span id='topic+linAcc'></span>

<h3>Description</h3>

<p>Given a set of locations defining a trajectory, this function 
computes the linear accelerations between each pair of successive locations 
along the trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_acc(x, y, t, geo = FALSE)

linAcc(x, y, t, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_acc_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="linear_acc_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="linear_acc_+3A_t">t</code></td>
<td>
<p>A vector of timestamps corresponding to a single trajectory.</p>
</td></tr>
<tr><td><code id="linear_acc_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as x and y corresponding to the linear 
accelerations between each pair of successive locations along the trajectory.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linear_speed">linear_speed</a></code>, <code><a href="#topic+linear_dist">linear_dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
t &lt;- as.POSIXct(1:25, origin = Sys.time())
linear_acc(x, y, t)

</code></pre>

<hr>
<h2 id='linear_dist'>Linear Distances</h2><span id='topic+linear_dist'></span><span id='topic+linDist'></span>

<h3>Description</h3>

<p>Given a set of locations defining a trajectory, this function 
computes the linear distances between each pair of successive locations 
along the trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_dist(x, y, geo = FALSE)

linDist(x, y, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_dist_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="linear_dist_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="linear_dist_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as x and y corresponding to the linear 
distances between each pair of successive locations along the trajectory.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linear_speed">linear_speed</a></code>, <code><a href="#topic+linear_acc">linear_acc</a></code>, 
<code><a href="#topic+nsd">nsd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
linear_dist(x, y)

</code></pre>

<hr>
<h2 id='linear_speed'>Linear Speeds</h2><span id='topic+linear_speed'></span><span id='topic+linSpeed'></span>

<h3>Description</h3>

<p>Given a set of locations defining a trajectory, this function 
computes the linear speeds between each pair of successive locations along 
the trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_speed(x, y, t, geo = FALSE)

linSpeed(x, y, t, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_speed_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="linear_speed_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="linear_speed_+3A_t">t</code></td>
<td>
<p>A vector of timestamps corresponding to a single trajectory.</p>
</td></tr>
<tr><td><code id="linear_speed_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as x and y corresponding to the linear 
speeds between each pair of successive locations along the trajectory.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linear_dist">linear_dist</a></code>, <code><a href="#topic+linear_acc">linear_acc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
t &lt;- as.POSIXct(1:25, origin = Sys.time())
linear_speed(x, y, t)

</code></pre>

<hr>
<h2 id='nn'>Nearest Neighbor</h2><span id='topic+nn'></span>

<h3>Description</h3>

<p>Given the locations of different objects, this function 
determines the identity of the nearest neighboring object to each object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nn(x, y, id, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nn_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates.</p>
</td></tr>
<tr><td><code id="nn_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates.</p>
</td></tr>
<tr><td><code id="nn_+3A_id">id</code></td>
<td>
<p>A vector corresponding to the unique identities of each track.</p>
</td></tr>
<tr><td><code id="nn_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as x and y representing the identity of 
the nearest neighboring object to each object.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnd">nnd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
id &lt;- 1:25
nn(x, y, id)

</code></pre>

<hr>
<h2 id='nnd'>Nearest Neihgbor Distance</h2><span id='topic+nnd'></span>

<h3>Description</h3>

<p>Given the locations of different objects, this function 
determines the distance of the nearest neighboring object to each object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnd(x, y, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnd_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates.</p>
</td></tr>
<tr><td><code id="nnd_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates.</p>
</td></tr>
<tr><td><code id="nnd_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as x and y representing the distance to 
the nearest neighboring object for each object.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nn">nn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
id &lt;- 1:25
nnd(x, y)

</code></pre>

<hr>
<h2 id='nsd'>Net Squared Displacement</h2><span id='topic+nsd'></span>

<h3>Description</h3>

<p>Given a set of locations defining a trajectory, this function 
computes the net squared displacement of the trajectory, that is the squared 
distances between each location and the first location of the trajectory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsd(x, y, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsd_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="nsd_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates corresponding to a single 
trajectory.</p>
</td></tr>
<tr><td><code id="nsd_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as x and y corresponding to the net 
squared distances between each location and the first location of the 
trajectory.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linear_dist">linear_dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
nsd(x, y)

</code></pre>

<hr>
<h2 id='pdist'>Pairwise Distance Matrix</h2><span id='topic+pdist'></span>

<h3>Description</h3>

<p>Given a set of locations, this function computes the distances 
between each possible pair of locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdist(x, y, geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdist_+3A_x">x</code></td>
<td>
<p>A vector of x (or longitude) coordinates.</p>
</td></tr>
<tr><td><code id="pdist_+3A_y">y</code></td>
<td>
<p>A vector of y (or latitude) coordinates.</p>
</td></tr>
<tr><td><code id="pdist_+3A_geo">geo</code></td>
<td>
<p>A logical value indicating whether the locations are defined by 
geographic coordinates (pairs of longitude/latitude values). Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix representing pairwise distances between each possible 
pair of locations.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nn">nn</a></code>, <code><a href="#topic+nnd">nnd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
pdist(x, y)

</code></pre>

<hr>
<h2 id='pol_order'>Polarization Order Parameter</h2><span id='topic+pol_order'></span><span id='topic+polOrder'></span>

<h3>Description</h3>

<p>Given a set of headings, this function returns the polarization 
order of the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pol_order(h)

polOrder(h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pol_order_+3A_h">h</code></td>
<td>
<p>A vector of headings (in radians).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value between 0 and 1 corresponding to the polarization 
order parameter of the group.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rot_order">rot_order</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- runif(25, 0, 2 * pi)
pol_order(h)

</code></pre>

<hr>
<h2 id='sphericity'>Sphericity</h2><span id='topic+sphericity'></span>

<h3>Description</h3>

<p>Given a set of locations, this function approximates the 
sphericity of the set by calculating the bivariate 95
the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphericity(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphericity_+3A_x">x</code></td>
<td>
<p>A vector of x coordinates.</p>
</td></tr>
<tr><td><code id="sphericity_+3A_y">y</code></td>
<td>
<p>A vector of y coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value corresponding to the ratio between the minor 
and major axis of the bivariate 95
close to 1 indicates that the set is approximately circular; a value close 
to 0 indicates that the set is strongly elongated.
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stretch">stretch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
sphericity(x, y)

</code></pre>

<hr>
<h2 id='stretch'>Stretching Direction</h2><span id='topic+stretch'></span>

<h3>Description</h3>

<p>Given a set of locations, this function approximates the 
stretching direction of the set by calculating the angle of the main axis of 
the bivariate 95
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stretch(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stretch_+3A_x">x</code></td>
<td>
<p>A vector of x coordinates.</p>
</td></tr>
<tr><td><code id="stretch_+3A_y">y</code></td>
<td>
<p>A vector of y coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value corresponding to the angle (in radians) of the 
main axis of the bivariate 95
</p>


<h3>Author(s)</h3>

<p>Simon Garnier, <a href="mailto:garnier@njit.edu">garnier@njit.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sphericity">sphericity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(25)
y &lt;- rnorm(25, sd = 3)
stretch(x, y)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
