<!DOCTYPE html><html><head><title>Help for package MGDrivE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MGDrivE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregateFemales'><p>Aggregate Female Output by Genotype</p></a></li>
<li><a href='#aggregateOutput'><p>Aggregate Output Over Landscape</p></a></li>
<li><a href='#basicBatchMigration'><p>Make List of Batch Migration Parameters</p></a></li>
<li><a href='#basicRepeatedReleases'><p>Make List of Modified Mosquito Releases</p></a></li>
<li><a href='#calcAquaticStageSurvivalProbability'><p>Calculate Aquatic Stage Survival Probability</p></a></li>
<li><a href='#calcAverageGenerationTime'><p>Calculate Average Generation Time</p></a></li>
<li><a href='#calcCos'><p>Calculate Geodesic Distance - Cosine Method</p></a></li>
<li><a href='#calcDensityDependentDeathRate'><p>Calculate Density-dependent Larval Mortality</p></a></li>
<li><a href='#calcExpKernel'><p>Calculate Exponential Stochastic Matrix</p></a></li>
<li><a href='#calcGammaKernel'><p>Calculate Gamma Stochastic Matrix</p></a></li>
<li><a href='#calcHaversine'><p>Calculate Geodesic Distance - Haversine Method</p></a></li>
<li><a href='#calcHurdleExpKernel'><p>Calculate Zero-inflated Exponential Stochastic Matrix</p></a></li>
<li><a href='#calcLarvalDist'><p>Calculate Distribution of Larval Population</p></a></li>
<li><a href='#calcLarvalPopEquilibrium'><p>Calculate Equilibrium Larval Population</p></a></li>
<li><a href='#calcLarvalStageMortalityRate'><p>Calculate Larval Stage Mortality Rate</p></a></li>
<li><a href='#calcLognormalKernel'><p>Calculate Lognormal Stochastic Matrix</p></a></li>
<li><a href='#calcOmega'><p>Solve for Omega (additional genotype-specific mortality)</p></a></li>
<li><a href='#calcPopulationGrowthRate'><p>Calculate Generational Population Growth Rate</p></a></li>
<li><a href='#calcQuantiles'><p>Summary Statistics for Stochastic MGDrivE</p></a></li>
<li><a href='#calcVinEll'><p>Calculate Geodesic Distance - Vincenty Ellipsoid Method</p></a></li>
<li><a href='#calcVinSph'><p>Calculate Geodesic Distance - Vincenty Sphere Method</p></a></li>
<li><a href='#calcZeroInflation'><p>Calculates the zero-inflation part of a hurdle exponential kernel.</p></a></li>
<li><a href='#cube2csv'><p>Export a Cube to .csv</p></a></li>
<li><a href='#cubeClvR'><p>Inheritance Cube: ClvR (Cleave and Rescue)</p></a></li>
<li><a href='#cubeClvR2'><p>Inheritance Cube: 2-Locus ClvR (Cleave and Rescue)</p></a></li>
<li><a href='#cubeECHACR'><p>Inheritance Cube: ECHACR</p></a></li>
<li><a href='#cubeECHACRX'><p>Inheritance Cube: ECHACRX</p></a></li>
<li><a href='#cubeHoming1RA'><p>Inheritance Cube: Homing Drive with 1 Resistance Allele</p></a></li>
<li><a href='#cubeHomingDrive'><p>Inheritance Cube: CRISPR (Clustered Regularly Interspaced Short Palindromic Repeats) with 2 Resistance Alleles and maternal deposition</p></a></li>
<li><a href='#cubeKillerRescue'><p>Inheritance Cube: Killer-Rescue System</p></a></li>
<li><a href='#cubeMEDEA'><p>Inheritance Cube: MEDEA (Maternal Effect Dominant Embryonic Arrest)</p></a></li>
<li><a href='#cubeMendelian'><p>Inheritance Cube: Mendelian</p></a></li>
<li><a href='#cubeModifiers'><p>Generate and Modify Default Genotype-specific Parameters</p></a></li>
<li><a href='#cubeOneLocusTA'><p>Inheritance Cube: 1 Locus Maternal-Toxin/Zygotic-Antidote System</p></a></li>
<li><a href='#cubeReciprocalTranslocations'><p>Inheritance Cube: Reciprocal Translocation</p></a></li>
<li><a href='#cubeRIDL'><p>Inheritance Cube: RIDL (Release of Insects with Dominant Lethality)</p></a></li>
<li><a href='#cubeSplitDrive'><p>Inheritance Cube: Split CRISPR drive with 2 Resistance Alleles and male/female specific homing</p></a></li>
<li><a href='#cubeTGD'><p>Inheritance Cube: tGD</p></a></li>
<li><a href='#cubeTGDX'><p>Inheritance Cube: tGDX</p></a></li>
<li><a href='#cubeTwoLocusTA'><p>Inheritance Cube: 2 Locus Maternal-Toxin/Zygotic-Antidote System</p></a></li>
<li><a href='#cubeWolbachia'><p>Inheritance Cube: Wolbachia</p></a></li>
<li><a href='#eraseDirectory'><p>Erase all files in a directory</p></a></li>
<li><a href='#generateReleaseVector'><p>Make List of Modified Mosquito Releases</p></a></li>
<li><a href='#get_alpha_Network'><p>Get alpha</p></a></li>
<li><a href='#get_beta_Network'><p>Get beta</p></a></li>
<li><a href='#get_conF_Network'><p>Get conADF</p></a></li>
<li><a href='#get_conM_Network'><p>Get conADM</p></a></li>
<li><a href='#get_drivecubeindex_Network'><p>Get Element(s) of Drive Cube by Index</p></a></li>
<li><a href='#get_eta_Network'><p>Get eta</p></a></li>
<li><a href='#get_femalePop_Patch'><p>Get female Population</p></a></li>
<li><a href='#get_genotypesID_Network'><p>Get genotypesID</p></a></li>
<li><a href='#get_genotypesN_Network'><p>Get genotypesN</p></a></li>
<li><a href='#get_malePop_Patch'><p>Get male Population</p></a></li>
<li><a href='#get_muAd_Network'><p>Get muAd</p></a></li>
<li><a href='#get_muAq_Network'><p>Get muAq</p></a></li>
<li><a href='#get_nPatch_Network'><p>Get nPatch</p></a></li>
<li><a href='#get_omega_Network'><p>Get omega</p></a></li>
<li><a href='#get_patchReleases_Network'><p>Get Patch Release Schedule</p></a></li>
<li><a href='#get_phi_Network'><p>Get phi</p></a></li>
<li><a href='#get_s_Network'><p>Get s</p></a></li>
<li><a href='#get_tau_Network'><p>Get Female Viability Mask (tau)</p></a></li>
<li><a href='#get_timeAq_Network'><p>Get timeAq</p></a></li>
<li><a href='#get_tNow_Network'><p>Get tNow</p></a></li>
<li><a href='#get_xiF_Network'><p>Get xiF</p></a></li>
<li><a href='#get_xiM_Network'><p>Get xiM</p></a></li>
<li><a href='#ggColUtility'><p>Utility to Imitate ggplot2 Colors</p></a></li>
<li><a href='#kernels'><p>Kernels Parameters</p></a></li>
<li><a href='#MGDrivE'><p>MGDrivE: Mosquito Gene Drive Explorer</p></a></li>
<li><a href='#MGDrivE-Cube'><p>MGDrivE: Inheritance Cube</p></a></li>
<li><a href='#MGDrivE-Model'><p>MGDrivE: Model's Mathematical Description</p></a></li>
<li><a href='#moveMatAll2'><p>Movement Matrix: All 2</p></a></li>
<li><a href='#moveMatCascade3'><p>Movement Matrix: Cascade 3</p></a></li>
<li><a href='#moveMatDiag'><p>Movement Matrix: Diagonal</p></a></li>
<li><a href='#moveMatDiagOneCity'><p>Movement Matrix: Diagonal One City</p></a></li>
<li><a href='#moveMatDie'><p>Movement Matrix: Die</p></a></li>
<li><a href='#moveMatIndependent3'><p>Movement Matrix: Independent 3</p></a></li>
<li><a href='#moveMatMixedSpil'><p>Movement Matrix: Mixed Spill</p></a></li>
<li><a href='#moveMatTaleOfTwoCities'><p>Movement Matrix: Tale of Two Cities</p></a></li>
<li><a href='#moveMatTriDiagonal'><p>Movement Matrix: Tri-diagonal</p></a></li>
<li><a href='#moveMatTriple'><p>Movement Matrix: Triple</p></a></li>
<li><a href='#multRun_Network'><p>Run Simulation</p></a></li>
<li><a href='#Network'><p>Network Class Definition</p></a></li>
<li><a href='#normalise'><p>Normalise a Numeric Vector</p></a></li>
<li><a href='#oneDay_adultDeath_deterministic_Patch'><p>Deterministic Adult Survival</p></a></li>
<li><a href='#oneDay_adultDeath_stochastic_Patch'><p>Stochastic Adult Survival</p></a></li>
<li><a href='#oneDay_eggDM_deterministic_Patch'><p>Deterministic Egg Death and Pupation</p></a></li>
<li><a href='#oneDay_eggDM_stochastic_Patch'><p>Stochastic Egg Death and Pupation</p></a></li>
<li><a href='#oneDay_eggReleases_Patch'><p>Release Eggs in a Patch</p></a></li>
<li><a href='#oneDay_initOutput_Patch'><p>Initialize Output from Focal Patch</p></a></li>
<li><a href='#oneDay_larvaDM_deterministic_Patch'><p>Deterministic Larva Death and Pupation</p></a></li>
<li><a href='#oneDay_larvaDM_stochastic_Patch'><p>Stochastic Larva Death and Pupation</p></a></li>
<li><a href='#oneDay_mating_deterministic_Patch'><p>Deterministic Mating</p></a></li>
<li><a href='#oneDay_mating_stochastic_Patch'><p>Stochastic Mating</p></a></li>
<li><a href='#oneDay_Migration_Deterministic_Network'><p>Deterministic Inter-Patch Migration</p></a></li>
<li><a href='#oneDay_Migration_Stochastic_Network'><p>Stochastic Inter-Patch Migration</p></a></li>
<li><a href='#oneDay_migrationIn_Patch'><p>Inbound Migration</p></a></li>
<li><a href='#oneDay_Network'><p>Run a Single Day on a Network</p></a></li>
<li><a href='#oneDay_oviposit_deterministic_Patch'><p>Deterministic Oviposition</p></a></li>
<li><a href='#oneDay_oviposit_stochastic_Patch'><p>Stochastic Oviposition</p></a></li>
<li><a href='#oneDay_PopDynamics_Patch'><p>Daily Population Dynamics for a Patch</p></a></li>
<li><a href='#oneDay_pupaDM_deterministic_Patch'><p>Deterministic Pupa Death and Pupation</p></a></li>
<li><a href='#oneDay_pupaDM_stochastic_Patch'><p>Stochastic Pupa Death and Pupation</p></a></li>
<li><a href='#oneDay_pupation_deterministic_Patch'><p>Deterministic Pupation</p></a></li>
<li><a href='#oneDay_pupation_stochastic_Patch'><p>Stochastic Pupation</p></a></li>
<li><a href='#oneDay_releases_Patch'><p>Release Male/Female/Mated-Female Mosquitoes in a Patch</p></a></li>
<li><a href='#oneDay_writeOutput_Patch'><p>Write Output from Focal Patch</p></a></li>
<li><a href='#oneRun_Network'><p>Run Simulation</p></a></li>
<li><a href='#parameterizeMGDrivE'><p>parameterizeMGDrivE</p></a></li>
<li><a href='#Patch'><p>Patch Class Definition</p></a></li>
<li><a href='#plotMGDrivEMult'><p>Plot</p></a></li>
<li><a href='#plotMGDrivESingle'><p>Plot</p></a></li>
<li><a href='#quantileC'><p>Quantiles Function</p></a></li>
<li><a href='#rDirichlet'><p>Dirichlet Distribution</p></a></li>
<li><a href='#reset_Network'><p>Reset Network</p></a></li>
<li><a href='#reset_Patch'><p>Reset Patch to Initial Conditions</p></a></li>
<li><a href='#retrieveOutput'><p>Retrieve Output</p></a></li>
<li><a href='#set_initialPopulation_Patch'><p>Set Initial Population</p></a></li>
<li><a href='#set_NetworkPointer_Patch'><p>Set Network Pointer</p></a></li>
<li><a href='#set_population_deterministic_Patch'><p>Set Initial Population Deterministic</p></a></li>
<li><a href='#set_population_stochastic_Patch'><p>Set Initial Population Stochastic</p></a></li>
<li><a href='#setupMGDrivE'><p>Setup MGDrivE</p></a></li>
<li><a href='#splitOutput'><p>Split Output by Patch</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mosquito Gene Drive Explorer</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Héctor Manuel Sánchez Castellanos &lt;sanchez.hmsc@berkeley.edu&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://marshalllab.github.io/MGDrivE/">https://marshalllab.github.io/MGDrivE/</a>,
<a href="https://www.marshalllab.com/">https://www.marshalllab.com/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MarshallLab/MGDrivE/issues">https://github.com/MarshallLab/MGDrivE/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a model designed to be a reliable testbed where various gene 
    drive interventions for mosquito-borne diseases control. It is being developed to 
    accommodate the use of various mosquito-specific gene drive systems within a 
    population dynamics framework that allows migration of individuals between patches 
    in landscape. Previous work developing the population dynamics can be found in Deredec et al. 
    (2001) &lt;<a href="https://doi.org/10.1073%2Fpnas.1110717108">doi:10.1073/pnas.1110717108</a>&gt; and Hancock &amp; Godfray (2007) &lt;<a href="https://doi.org/10.1186%2F1475-2875-6-98">doi:10.1186/1475-2875-6-98</a>&gt;, 
    and extensions to accommodate CRISPR homing dynamics in Marshall et al. (2017) 
    &lt;<a href="https://doi.org/10.1038%2Fs41598-017-02744-7">doi:10.1038/s41598-017-02744-7</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, Rcpp, Rdpack (&ge; 0.7), grDevices, graphics, stats, utils</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-05 19:21:06 UTC; gilchrist</td>
</tr>
<tr>
<td>Author:</td>
<td>Héctor Manuel Sánchez Castellanos [aut, cre],
  Jared Bennett [aut],
  Sean Wu [aut],
  John M. Marshall [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-05 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggregateFemales'>Aggregate Female Output by Genotype</h2><span id='topic+aggregateFemales'></span>

<h3>Description</h3>

<p>Aggregate over male mate genotype to convert female matrix output into vector output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateFemales(
  readDir,
  writeDir = NULL,
  genotypes,
  remFile = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateFemales_+3A_readdir">readDir</code></td>
<td>
<p>Directory to read input from</p>
</td></tr>
<tr><td><code id="aggregateFemales_+3A_writedir">writeDir</code></td>
<td>
<p>Directory to write output to. Default is readDir</p>
</td></tr>
<tr><td><code id="aggregateFemales_+3A_genotypes">genotypes</code></td>
<td>
<p>Character vector of possible genotypes; found in <code>driveCube$genotypesID</code></p>
</td></tr>
<tr><td><code id="aggregateFemales_+3A_remfile">remFile</code></td>
<td>
<p>Boolean flag to remove original (unaggregated) file</p>
</td></tr>
<tr><td><code id="aggregateFemales_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This example assumes user has already run MGDrivE and generated output.
#  This also assumes that the user has already split output by patch.
# See vignette for complete example.

# set read/write directory
fPath &lt;- "path/to/data/containing/folder"

# Need genotypes from the cube run in the simulation
#  This is dependent on the simulation run
#  Using Mendelian cube for this example
cube &lt;- cubeMendelian()

# no return value from function
aggregateFemales(readDir= fPath, writeDir = NULL, genotypes = cube$genotypesID,
                 remFile = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='aggregateOutput'>Aggregate Output Over Landscape</h2><span id='topic+aggregateOutput'></span>

<h3>Description</h3>

<p>This function aggregates the output of a run over the entire output, i.e., all
of the patches. It writes the output one level above the folder pointed to by
readDir, if writeDir is NULL. Output consists of 2 csv files, one for males and
one for females, &quot;...M_LandscapeAgg_Run...csv&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateOutput(readDir, writeDir=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateOutput_+3A_readdir">readDir</code></td>
<td>
<p>Directory where output was written to</p>
</td></tr>
<tr><td><code id="aggregateOutput_+3A_writedir">writeDir</code></td>
<td>
<p>Directory to write output to. Default is one level above readDir</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This assumes user has run MGDrivE and output is in fPath.
#  See vignette for examples on how to run MGDrivE

# read/write dirs
fPath &lt;- "folder/containing/output"
oPath &lt;- "folder/to/write/stuff"

# first, split output by patch and aggregate females by mate genotype
# remember, cube is for example and changes with simulation
#  landscape aggregation will work if females are not aggregated, but it's slower
cube &lt;- cubeMendelian()

splitOutput(readDir = fPath, writeDir = NULL, remFile = TRUE)
aggregateFemales(readDir= fPath, writeDi = NULL, genotypes = cube$genotypesID,
                 remFile = TRUE)

# aggregate mosquitoes over entire landscape
#  no return value
aggregateOutput(readDir = fPath, writeDir = NULL)

## End(Not run)

</code></pre>

<hr>
<h2 id='basicBatchMigration'>Make List of Batch Migration Parameters</h2><span id='topic+basicBatchMigration'></span>

<h3>Description</h3>

<p>Sets up a list containing the probability of a batch migration, the fractional
amount of males/females that migrate, and the weighted probabilities for where
to migrate. The default weights for migration are equal for all patches.
These can be changed after running the function. This is only used in
<code><a href="#topic+oneDay_Migration_Stochastic_Network">oneDay_Migration_Stochastic_Network</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicBatchMigration(
  batchProbs = 1e-05,
  sexProbs = c(0.01, 0.01),
  numPatches = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basicBatchMigration_+3A_batchprobs">batchProbs</code></td>
<td>
<p>Probability of a batch migration, either 1 number or a vector
of length equal to the number of patches</p>
</td></tr>
<tr><td><code id="basicBatchMigration_+3A_sexprobs">sexProbs</code></td>
<td>
<p>Population fraction of males and females that migrate. Either
a vector c(M,F) or matrix of 2 columns</p>
</td></tr>
<tr><td><code id="basicBatchMigration_+3A_numpatches">numPatches</code></td>
<td>
<p>Number of patches in the simulation</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># to setup for 3 patches
batchMigration = basicBatchMigration(batchProbs = 1e-5, sexProbs = c(0.1, 0.01), numPatches = 3)

</code></pre>

<hr>
<h2 id='basicRepeatedReleases'>Make List of Modified Mosquito Releases</h2><span id='topic+basicRepeatedReleases'></span>

<h3>Description</h3>

<p>Sets up a release schedule for a single patch, returns a list to be used in
<code><a href="#topic+oneDay_releases_Patch">oneDay_releases_Patch</a></code> or <code><a href="#topic+oneDay_eggReleases_Patch">oneDay_eggReleases_Patch</a></code>.
This function is no longer intended to be used alone, please use the standard
interface, <code><a href="#topic+generateReleaseVector">generateReleaseVector</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicRepeatedReleases(releaseStart, releaseEnd, releaseInterval, releaseMatrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basicRepeatedReleases_+3A_releasestart">releaseStart</code></td>
<td>
<p>Day releases start</p>
</td></tr>
<tr><td><code id="basicRepeatedReleases_+3A_releaseend">releaseEnd</code></td>
<td>
<p>Day releases end</p>
</td></tr>
<tr><td><code id="basicRepeatedReleases_+3A_releaseinterval">releaseInterval</code></td>
<td>
<p>Interval between releases</p>
</td></tr>
<tr><td><code id="basicRepeatedReleases_+3A_releasematrix">releaseMatrix</code></td>
<td>
<p>Numeric matrix specifying the genotype and release amount</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Setup for 3 patches but only release in the first with a defined release
#  schedule, for the cube cubeHomingDrive:

patchReleases = replicate(n = 3, expr = {
  list(maleReleases = NULL, femaleReleases = NULL, eggReleases = NULL, matedFemaleReleases = NULL)
},simplify = FALSE)

patchReleases[[1]]$femaleReleases = MGDrivE::basicRepeatedReleases(releaseStart = 5,
                                                          releaseEnd = 30,
                                                          releaseInterval = 5,
                                                          releaseMatrix = matrix(c(5,100),1,2))

patchReleases[[1]]$maleReleases = MGDrivE::basicRepeatedReleases(releaseStart = 50,
                                                        releaseEnd = 60,
                                                        releaseInterval = 1,
                                                        releaseMatrix = matrix(c(5,100),1,2))

## End(Not run)

</code></pre>

<hr>
<h2 id='calcAquaticStageSurvivalProbability'>Calculate Aquatic Stage Survival Probability</h2><span id='topic+calcAquaticStageSurvivalProbability'></span>

<h3>Description</h3>

<p>Calculate <code class="reqn">\theta_{st}</code>, density-independent survival probability, given
by: </p>
<p style="text-align: center;"><code class="reqn">\theta_{st}=(1-\mu_{st})^{T_{st}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>calcAquaticStageSurvivalProbability(mortalityRate, stageDuration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcAquaticStageSurvivalProbability_+3A_mortalityrate">mortalityRate</code></td>
<td>
<p>Daily mortality probability, <code class="reqn">\mu_{st}</code></p>
</td></tr>
<tr><td><code id="calcAquaticStageSurvivalProbability_+3A_stageduration">stageDuration</code></td>
<td>
<p>Duration of aquatic stage, <code class="reqn">T^{st}</code></p>
</td></tr>
</table>

<hr>
<h2 id='calcAverageGenerationTime'>Calculate Average Generation Time</h2><span id='topic+calcAverageGenerationTime'></span>

<h3>Description</h3>

<p>Calculate <code class="reqn">g</code>, average generation time, given by: </p>
<p style="text-align: center;"><code class="reqn">g=T_e+T_l+T_p+\frac{1}{\mu_{ad}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>calcAverageGenerationTime(stagesDuration, adultMortality)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcAverageGenerationTime_+3A_stagesduration">stagesDuration</code></td>
<td>
<p>Vector of lengths of aquatic stages, <code class="reqn">T_{e}, T_{l}, T_{p}</code></p>
</td></tr>
<tr><td><code id="calcAverageGenerationTime_+3A_adultmortality">adultMortality</code></td>
<td>
<p>Adult mortality rate, <code class="reqn">\mu_{ad}</code></p>
</td></tr>
</table>

<hr>
<h2 id='calcCos'>Calculate Geodesic Distance - Cosine Method</h2><span id='topic+calcCos'></span>

<h3>Description</h3>

<p>This function calculates geodesic distance using the cosine method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcCos(latLongs, r = 6378137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcCos_+3A_latlongs">latLongs</code></td>
<td>
<p>Two column matrix of latitudes/longitudes</p>
</td></tr>
<tr><td><code id="calcCos_+3A_r">r</code></td>
<td>
<p>Earth radius. Default is WGS-84 radius</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># two-column matrix with latitude/longitude, in degrees
latLong = cbind(runif(n = 5, min = 0, max = 90),
                runif(n = 5, min = 0, max = 180))

# cosine distance formula
distMat = calcCos(latLongs = latLong)

</code></pre>

<hr>
<h2 id='calcDensityDependentDeathRate'>Calculate Density-dependent Larval Mortality</h2><span id='topic+calcDensityDependentDeathRate'></span>

<h3>Description</h3>

<p>Calculate <code class="reqn">\alpha</code>, the strength of density-dependent mortality during the
larval stage, given by: </p>
<p style="text-align: center;"><code class="reqn">\alpha=\Bigg( \frac{1/2 * \beta * \theta_e * Ad_{eq}}{R_m-1} \Bigg) * \Bigg( \frac{1-(\theta_l / R_m)}{1-(\theta_l / R_m)^{1/T_l}} \Bigg)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>calcDensityDependentDeathRate(
  fertility,
  thetaAq,
  tAq,
  adultPopSizeEquilibrium,
  populationGrowthRate
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcDensityDependentDeathRate_+3A_fertility">fertility</code></td>
<td>
<p>Number of eggs per oviposition for wild-type females, <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code id="calcDensityDependentDeathRate_+3A_thetaaq">thetaAq</code></td>
<td>
<p>Vector of density-independent survival probabilities of aquatic stages, <code class="reqn">\theta_{e}, \theta_{l}</code></p>
</td></tr>
<tr><td><code id="calcDensityDependentDeathRate_+3A_taq">tAq</code></td>
<td>
<p>Vector of lengths of aquatic stages, <code class="reqn">T_{e}, T_{l}, T_{p}</code></p>
</td></tr>
<tr><td><code id="calcDensityDependentDeathRate_+3A_adultpopsizeequilibrium">adultPopSizeEquilibrium</code></td>
<td>
<p>Adult population size at equilibrium, <code class="reqn">Ad_{eq}</code></p>
</td></tr>
<tr><td><code id="calcDensityDependentDeathRate_+3A_populationgrowthrate">populationGrowthRate</code></td>
<td>
<p>Population growth in absence of density-dependent mortality <code class="reqn">R_{m}</code></p>
</td></tr>
</table>

<hr>
<h2 id='calcExpKernel'>Calculate Exponential Stochastic Matrix</h2><span id='topic+calcExpKernel'></span>

<h3>Description</h3>

<p>Given a distance matrix from <code><a href="#topic+calcVinEll">calcVinEll</a></code>, calculate a
stochastic matrix where one step movement probabilities follow an exponential density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcExpKernel(distMat, rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcExpKernel_+3A_distmat">distMat</code></td>
<td>
<p>Distance matrix from <code><a href="#topic+calcVinEll">calcVinEll</a></code></p>
</td></tr>
<tr><td><code id="calcExpKernel_+3A_rate">rate</code></td>
<td>
<p>Rate parameter of <code><a href="stats.html#topic+Exponential">Exponential</a></code> distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution and density functions for the exponential kernel are given below:
</p>
<p style="text-align: center;"><code class="reqn">
F(x)=1-e^{-\lambda x}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
f(x)=\lambda e^{-\lambda x}
</code>
</p>

<p>where <code class="reqn">\lambda</code> is the rate parameter of the exponential distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setup distance matrix
# two-column matrix with latitude/longitude, in degrees
latLong = cbind(runif(n = 5, min = 0, max = 90),
                runif(n = 5, min = 0, max = 180))

# Vincenty Ellipsoid  distance formula
distMat = calcVinEll(latLongs = latLong)

# calculate exponential distribution over distances
#  rate is just for example
kernMat = calcExpKernel(distMat = distMat, rate = 10)

</code></pre>

<hr>
<h2 id='calcGammaKernel'>Calculate Gamma Stochastic Matrix</h2><span id='topic+calcGammaKernel'></span>

<h3>Description</h3>

<p>Given a distance matrix from <code><a href="#topic+calcVinEll">calcVinEll</a></code>, calculate a
stochastic matrix where one step movement probabilities follow a gamma density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcGammaKernel(distMat, shape, rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcGammaKernel_+3A_distmat">distMat</code></td>
<td>
<p>Distance matrix from <code><a href="#topic+calcVinEll">calcVinEll</a></code></p>
</td></tr>
<tr><td><code id="calcGammaKernel_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of <code><a href="stats.html#topic+GammaDist">GammaDist</a></code> distribution</p>
</td></tr>
<tr><td><code id="calcGammaKernel_+3A_rate">rate</code></td>
<td>
<p>Rate parameter of <code><a href="stats.html#topic+GammaDist">GammaDist</a></code> distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution and density functions for the gamma kernel are given below:
</p>
<p style="text-align: center;"><code class="reqn">
F(x)=\frac{1}{\Gamma(\alpha)}\gamma(\alpha,\beta x)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
f(x)=\frac{\beta^{\alpha}}{\Gamma(\alpha)}x^{\alpha-1}e^{-\beta x}
</code>
</p>

<p>where <code class="reqn">\Gamma(\alpha)</code> is the Gamma function, <code class="reqn">\gamma(\alpha,\beta x)</code> is the lower incomplete
gamma function, and <code class="reqn">\alpha,\beta</code> are the shape and rate parameters, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setup distance matrix
# two-column matrix with latitude/longitude, in degrees
latLong = cbind(runif(n = 5, min = 0, max = 90),
                runif(n = 5, min = 0, max = 180))

# Vincenty Ellipsoid  distance formula
distMat = calcVinEll(latLongs = latLong)

# calculate gamma distribution over distances
#  shape and rate are just for example
kernMat = calcGammaKernel(distMat = distMat, shape = 1, rate = 1)

</code></pre>

<hr>
<h2 id='calcHaversine'>Calculate Geodesic Distance - Haversine Method</h2><span id='topic+calcHaversine'></span>

<h3>Description</h3>

<p>This function calculates geodesic distance using the Haversine method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcHaversine(latLongs, r = 6378137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcHaversine_+3A_latlongs">latLongs</code></td>
<td>
<p>Two column matrix of latitudes/longitudes</p>
</td></tr>
<tr><td><code id="calcHaversine_+3A_r">r</code></td>
<td>
<p>Earth radius. Default is WGS-84 radius</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># two-column matrix with latitude/longitude, in degrees
latLong = cbind(runif(n = 5, min = 0, max = 90),
                runif(n = 5, min = 0, max = 180))

# Haversine distance formula
distMat = calcHaversine(latLongs = latLong)

</code></pre>

<hr>
<h2 id='calcHurdleExpKernel'>Calculate Zero-inflated Exponential Stochastic Matrix</h2><span id='topic+calcHurdleExpKernel'></span>

<h3>Description</h3>

<p>Given a distance matrix from <code><a href="#topic+calcVinEll">calcVinEll</a></code>, calculate a
stochastic matrix where one step movement probabilities follow an zero-inflated
exponential density with a point mass at zero. The point mass at zero represents
the first stage of a two-stage process, where mosquitoes decide to stay at
their current node or leave anywhere. This parameter can be calculated from
lifetime probabilities to stay at the current node with the helper function
<code><a href="#topic+calcZeroInflation">calcZeroInflation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcHurdleExpKernel(distMat, rate, p0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcHurdleExpKernel_+3A_distmat">distMat</code></td>
<td>
<p>Distance matrix from <code><a href="#topic+calcVinEll">calcVinEll</a></code></p>
</td></tr>
<tr><td><code id="calcHurdleExpKernel_+3A_rate">rate</code></td>
<td>
<p>Rate parameter of <code><a href="stats.html#topic+Exponential">Exponential</a></code> distribution</p>
</td></tr>
<tr><td><code id="calcHurdleExpKernel_+3A_p0">p0</code></td>
<td>
<p>Point mass at zero</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a mosquito leaves its current node, with probability <code class="reqn">1-p_{0}</code>, it
then chooses a destination node according to a standard exponential density
with rate parameter <code class="reqn">rate</code>.
</p>
<p>The distribution and density functions for the zero inflated exponential kernel are given below:
</p>
<p style="text-align: center;"><code class="reqn">
F(x)=p_{0}\theta(x) + (1-p_{0})(1-e^{-\lambda x})
</code>
</p>

<p style="text-align: center;"><code class="reqn">
f(x)=p_{0}\delta(x)+(1-p_{0})\lambda e^{-\lambda x}
</code>
</p>

<p>where <code class="reqn">\lambda</code> is the rate parameter of the exponential distribution,
<code class="reqn">\theta(x)</code> is the Heaviside step function and <code class="reqn">\delta(x)</code> is the
Dirac delta function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setup distance matrix
# two-column matrix with latitude/longitude, in degrees
latLong = cbind(runif(n = 5, min = 0, max = 90),
                runif(n = 5, min = 0, max = 180))

# Vincenty Ellipsoid  distance formula
distMat = calcVinEll(latLongs = latLong)

# calculate hurdle exponential distribution over distances
#  rate and point mass are just for example
kernMat = calcHurdleExpKernel(distMat = distMat, rate = 1/1e6, p0 = 0.1)

</code></pre>

<hr>
<h2 id='calcLarvalDist'>Calculate Distribution of Larval Population</h2><span id='topic+calcLarvalDist'></span>

<h3>Description</h3>

<p>This hidden function calculates the distribution of larvae through time by
treating the larval-stage as a discrete-time Markov chain, and solving for the
stationary distribution. As the only aquatic population known for initializing
MGDrivE is the equilibrium larval population, this acts as an anchor from which
to calculate the egg and pupae distributions from (see <code><a href="#topic+set_initialPopulation_Patch">set_initialPopulation_Patch</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcLarvalDist(mu, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcLarvalDist_+3A_mu">mu</code></td>
<td>
<p>Double, death rate</p>
</td></tr>
<tr><td><code id="calcLarvalDist_+3A_t">t</code></td>
<td>
<p>Integer, stage time</p>
</td></tr>
</table>

<hr>
<h2 id='calcLarvalPopEquilibrium'>Calculate Equilibrium Larval Population</h2><span id='topic+calcLarvalPopEquilibrium'></span>

<h3>Description</h3>

<p>Equilibrium larval population size to sustain adult population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcLarvalPopEquilibrium(alpha, Rm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcLarvalPopEquilibrium_+3A_alpha">alpha</code></td>
<td>
<p>See <code><a href="#topic+calcDensityDependentDeathRate">calcDensityDependentDeathRate</a></code></p>
</td></tr>
<tr><td><code id="calcLarvalPopEquilibrium_+3A_rm">Rm</code></td>
<td>
<p>See <code><a href="#topic+calcPopulationGrowthRate">calcPopulationGrowthRate</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='calcLarvalStageMortalityRate'>Calculate Larval Stage Mortality Rate</h2><span id='topic+calcLarvalStageMortalityRate'></span>

<h3>Description</h3>

<p>Calculate <code class="reqn">\mu_{l}</code>, the larval mortality, given by
</p>
<p style="text-align: center;"><code class="reqn">\mu_l=1-\Bigg( \frac{R_m * \mu_{ad}}{1/2 * \beta * (1-\mu_m)} \Bigg)^{\frac{1}{T_e+T_l+T_p}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>calcLarvalStageMortalityRate(
  generationPopGrowthRate,
  adultMortality,
  fertility,
  aquaticStagesDuration
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcLarvalStageMortalityRate_+3A_generationpopgrowthrate">generationPopGrowthRate</code></td>
<td>
<p>See <code><a href="#topic+calcPopulationGrowthRate">calcPopulationGrowthRate</a></code></p>
</td></tr>
<tr><td><code id="calcLarvalStageMortalityRate_+3A_adultmortality">adultMortality</code></td>
<td>
<p>Adult mortality rate, <code class="reqn">\mu_{ad}</code></p>
</td></tr>
<tr><td><code id="calcLarvalStageMortalityRate_+3A_fertility">fertility</code></td>
<td>
<p>Number of eggs per oviposition for wild-type females, <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code id="calcLarvalStageMortalityRate_+3A_aquaticstagesduration">aquaticStagesDuration</code></td>
<td>
<p>Vector of lengths of aquatic stages, <code class="reqn">T_{e}, T_{l}, T_{p}</code></p>
</td></tr>
</table>

<hr>
<h2 id='calcLognormalKernel'>Calculate Lognormal Stochastic Matrix</h2><span id='topic+calcLognormalKernel'></span>

<h3>Description</h3>

<p>Given a distance matrix from <code><a href="#topic+calcVinEll">calcVinEll</a></code>,
calculate a stochastic matrix where one step movement probabilities follow a lognormal density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcLognormalKernel(distMat, meanlog, sdlog)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcLognormalKernel_+3A_distmat">distMat</code></td>
<td>
<p>Distance matrix from <code><a href="#topic+calcVinEll">calcVinEll</a></code></p>
</td></tr>
<tr><td><code id="calcLognormalKernel_+3A_meanlog">meanlog</code></td>
<td>
<p>Log mean of <code><a href="stats.html#topic+Lognormal">Lognormal</a></code> distribution</p>
</td></tr>
<tr><td><code id="calcLognormalKernel_+3A_sdlog">sdlog</code></td>
<td>
<p>Log standard deviation of <code><a href="stats.html#topic+Lognormal">Lognormal</a></code> distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution and density functions for the lognormal kernel are given below:
</p>
<p style="text-align: center;"><code class="reqn">
F(x)=\frac{1}{2} + \frac{1}{2} \mathrm{erf}[\frac{\mathrm{ln}x-\mu}{\sqrt{2}\sigma}]
</code>
</p>

<p style="text-align: center;"><code class="reqn">
f(x)=\frac{1}{x\sigma\sqrt{2\pi}}\mathrm{exp}\left( -\frac{(\mathrm{ln}x-\mu)^{2}}{2\sigma^{2}} \right)
</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean on the log scale, and <code class="reqn">\sigma</code> is the standard deviation on the log scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setup distance matrix
# two-column matrix with latitude/longitude, in degrees
latLong = cbind(runif(n = 5, min = 0, max = 90),
                runif(n = 5, min = 0, max = 180))

# Vincenty Ellipsoid  distance formula
distMat = calcVinEll(latLongs = latLong)

# calculate lognormal distribution over distances
#  mean and standard deviation are just for example
kernMat = calcLognormalKernel(distMat = distMat, meanlog = 100, sdlog = 10)

</code></pre>

<hr>
<h2 id='calcOmega'>Solve for Omega (additional genotype-specific mortality)</h2><span id='topic+calcOmega'></span>

<h3>Description</h3>

<p>Solves for root of equation of geometrically-distributed lifespan for value of omega.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcOmega(mu, lifespanReduction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcOmega_+3A_mu">mu</code></td>
<td>
<p>Daily mortality probability (discrete-time hazard, called <code>muAd</code> in code)</p>
</td></tr>
<tr><td><code id="calcOmega_+3A_lifespanreduction">lifespanReduction</code></td>
<td>
<p>Target reduced lifespan, between 0 and 1
(target average lifespan will be <code class="reqn">\frac{1}{\mu_{Ad}} \times lifespanReduction</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># reduce lifespan by 10%
#  Example mu is an average for Aedes
newOmega &lt;- calcOmega(mu = 0.11, lifespanReduction = 0.90)

</code></pre>

<hr>
<h2 id='calcPopulationGrowthRate'>Calculate Generational Population Growth Rate</h2><span id='topic+calcPopulationGrowthRate'></span>

<h3>Description</h3>

<p>Calculate <code class="reqn">R_{m}</code>, population growth in absence of density-dependent mortality,
given by: </p>
<p style="text-align: center;"><code class="reqn">(r_{m})^{g}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>calcPopulationGrowthRate(dailyPopGrowthRate, averageGenerationTime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcPopulationGrowthRate_+3A_dailypopgrowthrate">dailyPopGrowthRate</code></td>
<td>
<p>Daily population growth rate, <code class="reqn">r_{m}</code></p>
</td></tr>
<tr><td><code id="calcPopulationGrowthRate_+3A_averagegenerationtime">averageGenerationTime</code></td>
<td>
<p>See <code><a href="#topic+calcAverageGenerationTime">calcAverageGenerationTime</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='calcQuantiles'>Summary Statistics for Stochastic MGDrivE</h2><span id='topic+calcQuantiles'></span>

<h3>Description</h3>

<p>This function reads in all repetitions for each patch and calculates either
the mean, quantiles, or both. User chooses the quantiles, up to 4 decimal places,
and enters them as a vector. Quantiles are calculated empirically. (order does not matter)  <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcQuantiles(readDir, writeDir, mean = TRUE, quantiles = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcQuantiles_+3A_readdir">readDir</code></td>
<td>
<p>Directory to find repetition folders in</p>
</td></tr>
<tr><td><code id="calcQuantiles_+3A_writedir">writeDir</code></td>
<td>
<p>Directory to write output</p>
</td></tr>
<tr><td><code id="calcQuantiles_+3A_mean">mean</code></td>
<td>
<p>Boolean, calculate mean or not. Default is TRUE</p>
</td></tr>
<tr><td><code id="calcQuantiles_+3A_quantiles">quantiles</code></td>
<td>
<p>Vector of quantiles to calculate. Default is NULL</p>
</td></tr>
<tr><td><code id="calcQuantiles_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the readDir, this function assumes the follow file structure: <br />
</p>

<ul>
<li><p> readDir
</p>

<ul>
<li><p> repetition 1
</p>

<ul>
<li><p> patch 1
</p>
</li>
<li><p> patch 2
</p>
</li>
<li><p> patch 3
</p>
</li></ul>

</li>
<li><p> repetition 2
</p>

<ul>
<li><p> patch 1
</p>
</li>
<li><p> patch 2
</p>
</li>
<li><p> patch 3
</p>
</li></ul>

</li>
<li><p> repetition 3
</p>
</li>
<li><p> repetition 4
</p>
</li>
<li><p> ... <br />
</p>
</li></ul>

</li></ul>

<p>Output files are *.csv contain the mean or quantile in the file name, i.e.
M/F<em>Mean</em>(patchNum).csv and M/F<em>Quantile</em>(quantNum)_(patchNum).csv.
</p>


<h3>Value</h3>

<p>Writes output to files in writeDir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This function assumes network$multRun() has been performed, or several
#  network$oneRun() have been performed and all of the data has been split
#  and aggregated.

# read/write paths
fPath &lt;- "path/to/folder/ofFolders/with/data"
oPath &lt;- "my/path/output"

# here, only calculate mean, no quantiles
#  no return value
calcQuantiles(readDir = fPath, writeDir = oPath, mean = TRUE,
              quantiles = NULL)

# here, calculate 2.5% and 97.5% quantiles
calcQuantiles(readDir = fPath, writeDir = oPath, mean = FALSE,
              quantiles = c(0.025, 0.975))

## End(Not run)

</code></pre>

<hr>
<h2 id='calcVinEll'>Calculate Geodesic Distance - Vincenty Ellipsoid Method</h2><span id='topic+calcVinEll'></span>

<h3>Description</h3>

<p>This function calculates geodesic distance using the original Vincenty Ellipsoid method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcVinEll(
  latLongs,
  a = 6378137,
  b = 6356752.3142,
  f = 1/298.257223563,
  eps = 1e-12,
  iter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcVinEll_+3A_latlongs">latLongs</code></td>
<td>
<p>Two column matrix of latitudes/longitudes</p>
</td></tr>
<tr><td><code id="calcVinEll_+3A_a">a</code></td>
<td>
<p>Equatorial radius of the earth, default is WGS-84 radius</p>
</td></tr>
<tr><td><code id="calcVinEll_+3A_b">b</code></td>
<td>
<p>Polar radius of the earth, default is WGS-84 radius</p>
</td></tr>
<tr><td><code id="calcVinEll_+3A_f">f</code></td>
<td>
<p>Flattening or inverse eccentricity, default eccentricity is WGS-84</p>
</td></tr>
<tr><td><code id="calcVinEll_+3A_eps">eps</code></td>
<td>
<p>Convergence criteria</p>
</td></tr>
<tr><td><code id="calcVinEll_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations to attempt convergence</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># two-column matrix with latitude/longitude, in degrees
latLong = cbind(runif(n = 5, min = 0, max = 90),
                runif(n = 5, min = 0, max = 180))

# Vincenty Ellipsoid  distance formula
distMat = calcVinEll(latLongs = latLong)

</code></pre>

<hr>
<h2 id='calcVinSph'>Calculate Geodesic Distance - Vincenty Sphere Method</h2><span id='topic+calcVinSph'></span>

<h3>Description</h3>

<p>This function calculates geodesic distance using the Vincenty sphere method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcVinSph(latLongs, r = 6378137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcVinSph_+3A_latlongs">latLongs</code></td>
<td>
<p>Two column matrix of latitudes/longitudes</p>
</td></tr>
<tr><td><code id="calcVinSph_+3A_r">r</code></td>
<td>
<p>Earth radius. Default is WGS-84 radius</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># two-column matrix with latitude/longitude, in degrees
latLong = cbind(runif(n = 5, min = 0, max = 90),
                runif(n = 5, min = 0, max = 180))

# Vincenty Sphere  distance formula
distMat = calcVinSph(latLongs = latLong)

</code></pre>

<hr>
<h2 id='calcZeroInflation'>Calculates the zero-inflation part of a hurdle exponential kernel.</h2><span id='topic+calcZeroInflation'></span>

<h3>Description</h3>

<p>Given the probability of an adult mosquito to stay in the same patch throughout
its whole lifespan, and its mortality, it calculates the height of the pulse-density
part of the hurdle kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcZeroInflation(stayThroughLifespanProbability, adultMortality)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcZeroInflation_+3A_staythroughlifespanprobability">stayThroughLifespanProbability</code></td>
<td>
<p>Probability of a mosquito to spend its
whole lifespan in the same node</p>
</td></tr>
<tr><td><code id="calcZeroInflation_+3A_adultmortality">adultMortality</code></td>
<td>
<p>Adult mortality rate</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># setup distance matrix
# two-column matrix with latitude/longitude, in degrees
latLong = cbind(runif(n = 5, min = 0, max = 90),
                runif(n = 5, min = 0, max = 180))

# Vincenty Ellipsoid  distance formula
distMat = calcVinEll(latLongs = latLong)

# get hurdle height
# Lets assume 80% stay probs and adult mortality of 0.1
hHeight &lt;- calcZeroInflation(stayThroughLifespanProbability = 0.80,
                             adultMortality = 0.1)

# calculate hurdle exponential distribution over distances
kernMat = calcHurdleExpKernel(distMat = distMat, rate = 10, p0 = hHeight)

</code></pre>

<hr>
<h2 id='cube2csv'>Export a Cube to .csv</h2><span id='topic+cube2csv'></span>

<h3>Description</h3>

<p>Export a cube as multiple .csv files (one for each genotype; slices of z-axis).
This function will create the directory if it doesn't exist. Files are stored
as slice_(z-slice)_(genotype).csv
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cube2csv(cube, directory, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cube2csv_+3A_cube">cube</code></td>
<td>
<p>A cube object (see <code><a href="#topic+MGDrivE-Cube">MGDrivE-Cube</a></code> for options)</p>
</td></tr>
<tr><td><code id="cube2csv_+3A_directory">directory</code></td>
<td>
<p>Directory to write .csv files to</p>
</td></tr>
<tr><td><code id="cube2csv_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to retain in .csv output</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# output directory
oPath &lt;- "path/to/write/output"

# setup inheritance cube for export, using Mendelian as the example
cube &lt;- cubeMendelian()

# write out
cube2csv(cube = cube, directory = oPath, digits = 3)

## End(Not run)

</code></pre>

<hr>
<h2 id='cubeClvR'>Inheritance Cube: ClvR (Cleave and Rescue)</h2><span id='topic+cubeClvR'></span>

<h3>Description</h3>

<p>Based on the Cleave-and-Rescue system of <a href="https://doi.org/10.1073/pnas.1921698117">Oberhofer</a>,
this is a 2-locus Cas9-based toxin-antidote system. The first locus carries the
Cas9, gRNAs, and a recoded copy of an essential gene. The second locus is the
targeted essential gene. This gene can be completely haplosufficient (<code>hSuf</code> = 1)
or completely haploinsufficient (<code>hSuf</code> = 0). It is assumed that having
2 copies of the gene (be it wild-type at the second locus or recoded at the first)
confers complete viability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubeClvR(
  cF = 1,
  crF = 0,
  ccF = cF,
  ccrF = crF,
  cM = 1,
  crM = 0,
  ccM = cM,
  ccrM = crM,
  dW = 0,
  drW = 0,
  ddW = dW,
  ddrW = drW,
  hSuf = 1,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeClvR_+3A_cf">cF</code></td>
<td>
<p>Female cutting rate, one ClvR allele</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_crf">crF</code></td>
<td>
<p>Female functional resistance rate, one ClvR allele</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_ccf">ccF</code></td>
<td>
<p>Female cutting rate, two ClvR alleles</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_ccrf">ccrF</code></td>
<td>
<p>Female functional resistance rate, two ClvR alleles</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_cm">cM</code></td>
<td>
<p>Male cutting rate, one ClvR allele</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_crm">crM</code></td>
<td>
<p>Male functional resistance rate, one ClvR allele</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_ccm">ccM</code></td>
<td>
<p>Male cutting rate, two ClvR alleles</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_ccrm">ccrM</code></td>
<td>
<p>Male functional resistance rate, two ClvR alleles</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_dw">dW</code></td>
<td>
<p>Female deposition cutting rate</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_drw">drW</code></td>
<td>
<p>Female deposition functional resistance rate</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_ddw">ddW</code></td>
<td>
<p>Female deposition (HH) cutting rate</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_ddrw">ddrW</code></td>
<td>
<p>Female deposition (HH) functional resistance rate</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_hsuf">hSuf</code></td>
<td>
<p>Haplosufficiency level, default is completely sufficient</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeClvR_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeClvR2'>Inheritance Cube: 2-Locus ClvR (Cleave and Rescue)</h2><span id='topic+cubeClvR2'></span>

<h3>Description</h3>

<p>Based on the Cleave-and-Rescue system of <a href="https://doi.org/10.1101/2020.07.09.196253">Oberhofer</a>,
this is a 3-locus Cas9-based toxin-antidote system. The first locus carries the
Cas9, the second locus carries the gRNAs, and a recoded copy of an essential gene.
The third locus is the targeted essential gene. This gene can be completely
haplosufficient (<code>hSuf</code> = 1) or completely haploinsufficient (<code>hSuf</code> = 0).
It is assumed that having 2 copies of the gene (be it wild-type at the second
locus or recoded at the first) confers complete viability. Additionally, loci
1 and 2 can be linked, given <code>crM</code> and <code>crF</code>, imitating the original
2-locus ClvR system.
For this construct, the first locus will have 2 alleles, the second will have 2
alleles, and the third will have 3 alleles:
</p>

<ul>
<li><p> Locus 1
</p>

<ul>
<li><p> W: Wild-type
</p>
</li>
<li><p> C: Cas9
</p>
</li></ul>

</li>
<li><p> Locus 2
</p>

<ul>
<li><p> W: Wild-type
</p>
</li>
<li><p> G: gRNAs and recoded essential gene
</p>
</li></ul>

</li>
<li><p> Locus 3
</p>

<ul>
<li><p> W: Wild-type
</p>
</li>
<li><p> R: Functional resistant
</p>
</li>
<li><p> B: Non-functional resistant
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeClvR2(
  cF = 1,
  crF = 0,
  ccF = cF,
  ccrF = crF,
  cM = 1,
  crM = 0,
  ccM = cM,
  ccrM = crM,
  dW = 0,
  drW = 0,
  ddW = dW,
  ddrW = drW,
  hSuf = 1,
  crossF = 0.5,
  crossM = 0.5,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeClvR2_+3A_cf">cF</code></td>
<td>
<p>Female cutting rate, one ClvR allele</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_crf">crF</code></td>
<td>
<p>Female functional resistance rate, one ClvR allele</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_ccf">ccF</code></td>
<td>
<p>Female cutting rate, two ClvR alleles</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_ccrf">ccrF</code></td>
<td>
<p>Female functional resistance rate, two ClvR alleles</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_cm">cM</code></td>
<td>
<p>Male cutting rate, one ClvR allele</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_crm">crM</code></td>
<td>
<p>Male functional resistance rate, one ClvR allele</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_ccm">ccM</code></td>
<td>
<p>Male cutting rate, two ClvR alleles</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_ccrm">ccrM</code></td>
<td>
<p>Male functional resistance rate, two ClvR alleles</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_dw">dW</code></td>
<td>
<p>Female deposition cutting rate</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_drw">drW</code></td>
<td>
<p>Female deposition functional resistance rate</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_ddw">ddW</code></td>
<td>
<p>Female deposition (HH) cutting rate</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_ddrw">ddrW</code></td>
<td>
<p>Female deposition (HH) functional resistance rate</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_hsuf">hSuf</code></td>
<td>
<p>Haplosufficiency level, default is completely sufficient</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_crossf">crossF</code></td>
<td>
<p>Crossover rate in females, 0 is completely linked, 0.5 is unlinked, 1.0 is complete divergence</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_crossm">crossM</code></td>
<td>
<p>Crossover rate in males, 0 is completely linked, 0.5 is unlinked, 1.0 is complete divergence</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeClvR2_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Female deposition is implemented incorrectly. Right now, it is performed on
male alleles prior to zygote formation - it should happen post-zygote formation.
Since this construct doesn't have HDR, this should be fine. <br />
Additionally, it is assumed that deposition requries loaded Cas9-RNP complexes
from the mother, having Cas9 and no maternal gRNA, even in the presence of
paternal gRNA, will not result in maternal deposition mediated cleavage.
</p>
<p>Copy-number dependent rates are based on Cas9, not gRNA. The assumption is that
RNA is easier to produce, and therefore won't limit cleavage by Cas9.
</p>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeECHACR'>Inheritance Cube: ECHACR</h2><span id='topic+cubeECHACR'></span>

<h3>Description</h3>

<p>This function creates an ECHACR construct, it has 5 alleles at the first locus
and 4 alleles at the second.
</p>

<ul>
<li><p> W: Wild-type
</p>
</li>
<li><p> H: Homing allele
</p>
</li>
<li><p> E: Eraser allele
</p>
</li>
<li><p> R: No-cost resistance allele
</p>
</li>
<li><p> B: Detrimental resistance allele
</p>
</li>
<li><p> cHW: Rate of homing from H, W -&gt; H transition
</p>
</li>
<li><p> cEH: Rate of homing from E, H -&gt; E transition
</p>
</li>
<li><p> cEW: Rate of homing from E, W -&gt; E transition
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeECHACR(
  cHW = 1,
  cEW = 1,
  cEH = 1,
  chHW = 0,
  crHW = 0,
  ceEW = 0,
  crEW = 0,
  ceEH = 0,
  crEH = 0,
  d1 = 0,
  d2 = 0,
  d3 = 0,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeECHACR_+3A_chw">cHW</code></td>
<td>
<p>Cutting efficiency of drive allele at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_cew">cEW</code></td>
<td>
<p>Cutting efficiency of ECHACR element into W</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_ceh">cEH</code></td>
<td>
<p>Cutting efficiency of ECHACR element into H</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_chhw">chHW</code></td>
<td>
<p>Homing efficiency of drive allele at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_crhw">crHW</code></td>
<td>
<p>Resistance allele efficiency of drive allele at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_ceew">ceEW</code></td>
<td>
<p>Homing efficiency of ECHACR element into W</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_crew">crEW</code></td>
<td>
<p>Resistance allele efficiency of ECHACR element into W</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_ceeh">ceEH</code></td>
<td>
<p>Homing efficiency of ECHACR element into H</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_creh">crEH</code></td>
<td>
<p>Resistance allele efficiency of ECHACR element into H</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_d1">d1</code></td>
<td>
<p>Background mutation rate from W into R allele</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_d2">d2</code></td>
<td>
<p>Background mutation rate from H into R allele</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_d3">d3</code></td>
<td>
<p>Background mutation rate from E into R allele</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeECHACR_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This inheritance pattern corresponds to the <a href="https://doi.org/10.1016/j.molcel.2020.09.003">Active Genetic Neutralizing Elements for Halting or Deleting Gene Drives</a> publication.
</p>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeECHACRX'>Inheritance Cube: ECHACRX</h2><span id='topic+cubeECHACRX'></span>

<h3>Description</h3>

<p>This function creates an X-linked ECHACR construct, it has 5 alleles at the first locus
and 4 alleles at the second.
</p>

<ul>
<li><p> W: Wild-type
</p>
</li>
<li><p> H: Homing allele
</p>
</li>
<li><p> E: Eraser allele
</p>
</li>
<li><p> R: No-cost resistance allele
</p>
</li>
<li><p> B: Detrimental resistance allele
</p>
</li>
<li><p> cHW: Rate of homing from H, W -&gt; H transition
</p>
</li>
<li><p> cEH: Rate of homing from E, H -&gt; E transition
</p>
</li>
<li><p> cEW2: Rate of homing from E, W -&gt; E transition
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeECHACRX(
  cHW = 1,
  cEHW = 1,
  cEW1 = 1,
  cEW2 = 1,
  cEH = 1,
  chHW = 0,
  crHW = 0,
  chEHW = 0,
  crEHW = 0,
  ceEW1 = 0,
  crEW1 = 0,
  ceEW2 = 0,
  crEW2 = 0,
  ceEH = 0,
  crEH = 0,
  d1 = 0,
  d2 = 0,
  d3 = 0,
  dHW = 0,
  dEH = 0,
  dEW = 0,
  drHW = 0,
  drEH = 0,
  drEW = 0,
  crossF = 0,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeECHACRX_+3A_chw">cHW</code></td>
<td>
<p>Cutting efficiency of drive allele at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_cehw">cEHW</code></td>
<td>
<p>Cutting efficiency of drive allele, in the presence of ECHACR element, at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_cew1">cEW1</code></td>
<td>
<p>Cutting efficiency of ECHACR element into W at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_cew2">cEW2</code></td>
<td>
<p>Cutting efficiency of ECHACR element into W at locus 2</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_ceh">cEH</code></td>
<td>
<p>Cutting efficiency of ECHACR element into H</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_chhw">chHW</code></td>
<td>
<p>Homing efficiency of drive allele at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_crhw">crHW</code></td>
<td>
<p>Resistance allele efficiency of drive allele at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_chehw">chEHW</code></td>
<td>
<p>Homing efficiency of drive allele, in the presence of ECHACR element, at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_crehw">crEHW</code></td>
<td>
<p>Resistance allele efficiency of drive allele, in the presence of ECHACR element, at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_ceew1">ceEW1</code></td>
<td>
<p>Homing efficiency of ECHACR element into W at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_crew1">crEW1</code></td>
<td>
<p>Resistance allele efficiency of ECHACR element into W at locus 1</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_ceew2">ceEW2</code></td>
<td>
<p>Homing efficiency of ECHACR element into W at locus 2</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_crew2">crEW2</code></td>
<td>
<p>Resistance allele efficiency of ECHACR element into W at locus 2</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_ceeh">ceEH</code></td>
<td>
<p>Homing efficiency of ECHACR element into H</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_creh">crEH</code></td>
<td>
<p>Resistance allele efficiency of ECHACR element into H</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_d1">d1</code></td>
<td>
<p>Background mutation rate from W into R allele</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_d2">d2</code></td>
<td>
<p>Background mutation rate from H into R allele</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_d3">d3</code></td>
<td>
<p>Background mutation rate from E into R allele</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_dhw">dHW</code></td>
<td>
<p>Female H deposition rate against W</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_deh">dEH</code></td>
<td>
<p>Female E deposition rate against H</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_dew">dEW</code></td>
<td>
<p>Female E deposition rate against W</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_drhw">drHW</code></td>
<td>
<p>Female resistance generation rate, from H allele</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_dreh">drEH</code></td>
<td>
<p>Female resistance generation rate, from E allele</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_drew">drEW</code></td>
<td>
<p>Female resistance generation rate, from E allele</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_crossf">crossF</code></td>
<td>
<p>Female crossover rate. 0 is fully linked, 0.5 is unlinked, 1 is negatively linked</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeECHACRX_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This inheritance pattern corresponds to the <a href="https://doi.org/10.1016/j.molcel.2020.09.003">Active Genetic Neutralizing Elements for Halting or Deleting Gene Drives</a> publication.
</p>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeHoming1RA'>Inheritance Cube: Homing Drive with 1 Resistance Allele</h2><span id='topic+cubeHoming1RA'></span>

<h3>Description</h3>

<p>This function creates an inheritance cube to model a homing gene drive (such as a CRISPR-Cas9 system)
that creates 1 type of resistance allele. It assumes no sex-specific inheritance patterns and the
construct is on an autosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubeHoming1RA(
  c = 1,
  ch = 0,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeHoming1RA_+3A_c">c</code></td>
<td>
<p>Cutting rate</p>
</td></tr>
<tr><td><code id="cubeHoming1RA_+3A_ch">ch</code></td>
<td>
<p>Successful homing rate rate</p>
</td></tr>
<tr><td><code id="cubeHoming1RA_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeHoming1RA_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeHoming1RA_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeHoming1RA_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeHoming1RA_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeHoming1RA_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeHomingDrive'>Inheritance Cube: CRISPR (Clustered Regularly Interspaced Short Palindromic Repeats) with 2 Resistance Alleles and maternal deposition</h2><span id='topic+cubeHomingDrive'></span>

<h3>Description</h3>

<p>This is a sex-specific version of the original cube <code><a href="#topic+cubeHoming1RA">cubeHoming1RA</a></code>. It assumes that the construct
is on an autosome and there can be different male/female homing rates. It also has
maternal deposition, i.e., when the male provides a W allele to a female with a H allele,
some portion are cut during oogenesis.
If the maternal deposition parameters are zero (d* parameters), this is a normal
CRISPR drive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubeHomingDrive(
  cM = 1,
  cF = 1,
  dF = 0,
  chM = 0,
  crM = 0,
  chF = 0,
  crF = 0,
  dhF = 0,
  drF = 0,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeHomingDrive_+3A_cm">cM</code></td>
<td>
<p>Male homing rate</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_cf">cF</code></td>
<td>
<p>Female homing rate</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_df">dF</code></td>
<td>
<p>Female deposition homing rate</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_chm">chM</code></td>
<td>
<p>Male correct homing rate</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_crm">crM</code></td>
<td>
<p>Male resistance generating rate</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_chf">chF</code></td>
<td>
<p>Female correct homing rate</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_crf">crF</code></td>
<td>
<p>Female resistance generating rate</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_dhf">dhF</code></td>
<td>
<p>Female correct deposition rate</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_drf">drF</code></td>
<td>
<p>Female resistance deposition rate</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeHomingDrive_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeKillerRescue'>Inheritance Cube: Killer-Rescue System</h2><span id='topic+cubeKillerRescue'></span>

<h3>Description</h3>

<p>This function creates an inheritance cube to model a Killer-Rescue system.
Killer-Rescue is a 2-locus system: one locus has a toxin and the other locus contains
the antidote. The loci are assumed independent and are non-homing. <br />
This drive has 3 alleles at locus 1 and 2 alleles and locus 2:
</p>

<ul>
<li><p> Locus 1
</p>

<ul>
<li><p> T: Wild-type allele
</p>
</li>
<li><p> K: &quot;Killer&quot; toxin allele
</p>
</li>
<li><p> R: Broken toxin allele
</p>
</li></ul>

</li>
<li><p> Locus 2
</p>

<ul>
<li><p> W: Wild-type allele
</p>
</li>
<li><p> A: Antidote allele
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeKillerRescue(
  eR = 0,
  Keff = 1,
  Aeff = 1,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeKillerRescue_+3A_er">eR</code></td>
<td>
<p>Conversion of K allele to R allele, a basal mutation rate</p>
</td></tr>
<tr><td><code id="cubeKillerRescue_+3A_keff">Keff</code></td>
<td>
<p>Toxin efficacy</p>
</td></tr>
<tr><td><code id="cubeKillerRescue_+3A_aeff">Aeff</code></td>
<td>
<p>Antidote efficacy</p>
</td></tr>
<tr><td><code id="cubeKillerRescue_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeKillerRescue_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeKillerRescue_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeKillerRescue_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeKillerRescue_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeKillerRescue_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeMEDEA'>Inheritance Cube: MEDEA (Maternal Effect Dominant Embryonic Arrest)</h2><span id='topic+cubeMEDEA'></span>

<h3>Description</h3>

<p>This function creates an inheritance cube to model a MEDEA drive system. This
system was first discovered in flour beetles. It biases inheritance by expressing
a maternal toxin such that offspring die unless they express a zygotic antidote. <br />
This drive has 3 alleles at 1 locus:
</p>

<ul>
<li><p> W: Wild-type allele
</p>
</li>
<li><p> M: MEDEA allele
</p>
</li>
<li><p> R: Resistance allele
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeMEDEA(
  rM = 0,
  rW = 0,
  Teff = 1,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeMEDEA_+3A_rm">rM</code></td>
<td>
<p>Breakdown of MEDEA allele, no homing/toxin/antidote, M -&gt; R conversion</p>
</td></tr>
<tr><td><code id="cubeMEDEA_+3A_rw">rW</code></td>
<td>
<p>De novo resistance generation, W -&gt; R conversion</p>
</td></tr>
<tr><td><code id="cubeMEDEA_+3A_teff">Teff</code></td>
<td>
<p>Efficacy of the toxin</p>
</td></tr>
<tr><td><code id="cubeMEDEA_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeMEDEA_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeMEDEA_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeMEDEA_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeMEDEA_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeMEDEA_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeMendelian'>Inheritance Cube: Mendelian</h2><span id='topic+cubeMendelian'></span>

<h3>Description</h3>

<p>This function creates a Mendelian Inheritance Cube. It only handles simple,
alphabetic genotypes. <br />
The default is 3 alleles at 1 locus, this can be extended to however many
alleles one is interested in, but only at 1 locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubeMendelian(
  gtype = c("AA", "Aa", "aa"),
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeMendelian_+3A_gtype">gtype</code></td>
<td>
<p>Vector of genotypes, with the wild-type in the first position</p>
</td></tr>
<tr><td><code id="cubeMendelian_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeMendelian_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeMendelian_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeMendelian_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeMendelian_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeMendelian_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeModifiers'>Generate and Modify Default Genotype-specific Parameters</h2><span id='topic+cubeModifiers'></span>

<h3>Description</h3>

<p>This is an internal function for cubes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubeModifiers(
  gtype,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeModifiers_+3A_gtype">gtype</code></td>
<td>
<p>character vector of genotypes</p>
</td></tr>
<tr><td><code id="cubeModifiers_+3A_eta">eta</code></td>
<td>
<p>genotype-specific mating fitness, handles assortative mating as well</p>
</td></tr>
<tr><td><code id="cubeModifiers_+3A_phi">phi</code></td>
<td>
<p>genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeModifiers_+3A_omega">omega</code></td>
<td>
<p>genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeModifiers_+3A_xif">xiF</code></td>
<td>
<p>genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeModifiers_+3A_xim">xiM</code></td>
<td>
<p>genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeModifiers_+3A_s">s</code></td>
<td>
<p>genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>

<hr>
<h2 id='cubeOneLocusTA'>Inheritance Cube: 1 Locus Maternal-Toxin/Zygotic-Antidote System</h2><span id='topic+cubeOneLocusTA'></span>

<h3>Description</h3>

<p>This function creates a 1 locus maternal-toxin/zygotic-antidote system. This
is similar to the construct called UDmel. There is no resistance generation
in this model. <br />
This drive has 3 alleles at 1 locus:
</p>

<ul>
<li><p> A: Maternal-toxin 1, zygotic-antidote 2
</p>
</li>
<li><p> B: Maternal-toxin 2, zygotic-antidote 1
</p>
</li>
<li><p> W: Wild-type allele
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeOneLocusTA(
  TAEfficacy = 1,
  TBEfficacy = 1,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeOneLocusTA_+3A_taefficacy">TAEfficacy</code></td>
<td>
<p>Maternal toxin A efficacy</p>
</td></tr>
<tr><td><code id="cubeOneLocusTA_+3A_tbefficacy">TBEfficacy</code></td>
<td>
<p>Maternal toxin B efficacy</p>
</td></tr>
<tr><td><code id="cubeOneLocusTA_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeOneLocusTA_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeOneLocusTA_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeOneLocusTA_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeOneLocusTA_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeOneLocusTA_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeReciprocalTranslocations'>Inheritance Cube: Reciprocal Translocation</h2><span id='topic+cubeReciprocalTranslocations'></span>

<h3>Description</h3>

<p>This function creates an inheritance cube to model a reciprocal translocation.
This technology was the original form of underdominant system. It involves 2
chromosomes, each with two alleles. <br />
This drive has 4 alleles at 2 loci:
</p>

<ul>
<li><p> a: Wild-type at locus A
</p>
</li>
<li><p> A: Translocation at locus A
</p>
</li>
<li><p> b: Wile-type at locus B
</p>
</li>
<li><p> B: Translocation at locus B
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeReciprocalTranslocations(
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeReciprocalTranslocations_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeReciprocalTranslocations_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeReciprocalTranslocations_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeReciprocalTranslocations_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeReciprocalTranslocations_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeReciprocalTranslocations_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeRIDL'>Inheritance Cube: RIDL (Release of Insects with Dominant Lethality)</h2><span id='topic+cubeRIDL'></span>

<h3>Description</h3>

<p>This function creates a RIDL system.
RIDL (Release of Insects with Dominant Lethality), is a form of SIT.
Created by Oxitec, this is based on a positive feedback loop using the
toxic tTAV gene, controlled under lab conditions by the TetO promoter.
This has 2 alleles at 1 locus
</p>

<ul>
<li><p> W: Wild-type allele
</p>
</li>
<li><p> R: OX513 RIDL allele
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeRIDL(
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeRIDL_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeRIDL_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeRIDL_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeRIDL_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeRIDL_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeRIDL_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeSplitDrive'>Inheritance Cube: Split CRISPR drive with 2 Resistance Alleles and male/female specific homing</h2><span id='topic+cubeSplitDrive'></span>

<h3>Description</h3>

<p>This is a sex-specific version of a split CRISPR drive. At one locus is the Cas9, inherited
in a Mendelian fashion. At a second, unlinked, locus are the gRNAs. When the two loci occur
together, the gRNAs drive, with potential damaged alleles, but the Cas9 remains
Mendelian. It is assumed that this is an autosomal drive.
This drive corresponds to the <a href="https://elifesciences.org/articles/51701">confinable gene drive system</a>
developed by the Akbari lab.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubeSplitDrive(
  cM = 1,
  chM = 0,
  crM = 0,
  ccM = cM,
  cchM = chM,
  ccrM = crM,
  cF = 1,
  chF = 0,
  crF = 0,
  ccF = cF,
  cchF = chF,
  ccrF = crF,
  dW = 0,
  dhW = 0,
  drW = 0,
  ddW = dW,
  ddhW = dhW,
  ddrW = drW,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeSplitDrive_+3A_cm">cM</code></td>
<td>
<p>Cutting efficiency in males, one Cas9 allele</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_chm">chM</code></td>
<td>
<p>Homing efficiency in males, one Cas9 allele</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_crm">crM</code></td>
<td>
<p>Resistance efficiency in males, one Cas9 allele</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_ccm">ccM</code></td>
<td>
<p>Cutting efficiency in males, two Cas9 alleles</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_cchm">cchM</code></td>
<td>
<p>Homing efficiency in males, two Cas9 alleles</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_ccrm">ccrM</code></td>
<td>
<p>Resistance efficiency in males, two Cas9 alleles</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_cf">cF</code></td>
<td>
<p>Cutting efficiency in females, one Cas9 allele</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_chf">chF</code></td>
<td>
<p>Homing efficiency in females, one Cas9 allele</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_crf">crF</code></td>
<td>
<p>Resistance efficiency in females, one Cas9 allele</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_ccf">ccF</code></td>
<td>
<p>Cutting efficiency in females, two Cas9 alleles</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_cchf">cchF</code></td>
<td>
<p>Homing efficiency in females, two Cas9 alleles</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_ccrf">ccrF</code></td>
<td>
<p>Resistance efficiency in females, two Cas9 alleles</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_dw">dW</code></td>
<td>
<p>Maternal deposition cutting, one Cas9 allele</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_dhw">dhW</code></td>
<td>
<p>Maternal deposition homing, one Cas9 allele</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_drw">drW</code></td>
<td>
<p>Maternal deposition resistance, one Cas9 allele</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_ddw">ddW</code></td>
<td>
<p>Maternal deposition cutting, two Cas9 alleles</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_ddhw">ddhW</code></td>
<td>
<p>Maternal deposition homing, two Cas9 alleles</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_ddrw">ddrW</code></td>
<td>
<p>Maternal deposition resistance, two Cas9 alleles</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeSplitDrive_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeTGD'>Inheritance Cube: tGD</h2><span id='topic+cubeTGD'></span>

<h3>Description</h3>

<p>The trans-complementing Gene Drive (tGD) is a 1-locus, 2 target site drive.
The first target site corresponds to the Cas protein, the second to an effector
gene and the gRNAs. There are two sets of gRNAs, because each target site may have
different cutting/homing/resistance rates, and each sex can have different rates
for all of those things. Additionally, the parent that you receive your Cas from
dictates its efficiency.
Therefor, this construct has 5 alleles at the first locus and 4 alleles at the second.
</p>

<ul>
<li><p> Locus 1
</p>

<ul>
<li><p> W: Wild-type
</p>
</li>
<li><p> P: Paternal Cas9
</p>
</li>
<li><p> M: Maternal Cas9
</p>
</li>
<li><p> R: Resistant allele 1
</p>
</li>
<li><p> B: Resistant allele 2
</p>
</li></ul>

</li>
<li><p> Locus 2
</p>

<ul>
<li><p> W: Wild-type
</p>
</li>
<li><p> G: gRNAs
</p>
</li>
<li><p> R: Resistant 1
</p>
</li>
<li><p> B: Resistant 2
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeTGD(
  cM1 = 0,
  cM2 = 0,
  cP1 = 0,
  cP2 = 0,
  hM1 = 0,
  hM2 = 0,
  hP1 = 0,
  hP2 = 0,
  rM1 = 0,
  rM2 = 0,
  rP1 = 0,
  rP2 = 0,
  crM = 0,
  crP = 0,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeTGD_+3A_cm1">cM1</code></td>
<td>
<p>Maternally inherited Cas9 cutting rate at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_cm2">cM2</code></td>
<td>
<p>Maternally inherited Cas9 cutting rate at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_cp1">cP1</code></td>
<td>
<p>Paternally inherited Cas9 cutting rate at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_cp2">cP2</code></td>
<td>
<p>Paternally inherited Cas9 cutting rate at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_hm1">hM1</code></td>
<td>
<p>Maternally inherited Cas9 homing efficiency at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_hm2">hM2</code></td>
<td>
<p>Maternally inherited Cas9 homing efficiency at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_hp1">hP1</code></td>
<td>
<p>Paternally inherited Cas9 homing efficiency at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_hp2">hP2</code></td>
<td>
<p>Paternally inherited Cas9 homing efficiency at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_rm1">rM1</code></td>
<td>
<p>Maternally inherited Cas9 resistance efficiency at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_rm2">rM2</code></td>
<td>
<p>Maternally inherited Cas9 resistance efficiency at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_rp1">rP1</code></td>
<td>
<p>Paternally inherited Cas9 resistance efficiency at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_rp2">rP2</code></td>
<td>
<p>Paternally inherited Cas9 resistance efficiency at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_crm">crM</code></td>
<td>
<p>Maternal crossover rate, 0 is completely linked, 0.5 is unlinked, 1.0 is complete divergence</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_crp">crP</code></td>
<td>
<p>Paternal crossover rate, 0 is completely linked, 0.5 is unlinked, 1.0 is complete divergence</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeTGD_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This drive corresponds to the <a href="https://www.nature.com/articles/s41467-019-13977-7">transcomplementing gene drive</a>
developed by the Gantz and Bier lab.
</p>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeTGDX'>Inheritance Cube: tGDX</h2><span id='topic+cubeTGDX'></span>

<h3>Description</h3>

<p>The trans-complementing Gene Drive (tGD) is a 1-locus, 2 target site drive.
The first target site corresponds to the Cas protein, the second to an effector
gene and the gRNAs. There are two sets of gRNAs, because each target site may have
different cutting/homing/resistance rates, and each sex can have different rates
for all of those things. Additionally, the parent that you receive your Cas from
dictates its efficiency.
Therefor, this construct has 6 alleles at the first locus and 5 alleles at the second.
</p>

<ul>
<li><p> Locus 1
</p>

<ul>
<li><p> W: Wild-type
</p>
</li>
<li><p> P: Paternal Cas9
</p>
</li>
<li><p> M: Maternal Cas9
</p>
</li>
<li><p> R: Resistant allele 1
</p>
</li>
<li><p> B: Resistant allele 2
</p>
</li>
<li><p> Y: Y allele
</p>
</li></ul>

</li>
<li><p> Locus 2
</p>

<ul>
<li><p> W: Wild-type
</p>
</li>
<li><p> G: gRNAs
</p>
</li>
<li><p> R: Resistant 1
</p>
</li>
<li><p> B: Resistant 2
</p>
</li>
<li><p> Y: Y allele
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeTGDX(
  cM1 = 0,
  cM2 = 0,
  cP1 = 0,
  cP2 = 0,
  hM1 = 0,
  hM2 = 0,
  hP1 = 0,
  hP2 = 0,
  rM1 = 0,
  rM2 = 0,
  rP1 = 0,
  rP2 = 0,
  crM = 0,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeTGDX_+3A_cm1">cM1</code></td>
<td>
<p>Maternally inherited Cas9 cutting rate at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_cm2">cM2</code></td>
<td>
<p>Maternally inherited Cas9 cutting rate at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_cp1">cP1</code></td>
<td>
<p>Paternally inherited Cas9 cutting rate at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_cp2">cP2</code></td>
<td>
<p>Paternally inherited Cas9 cutting rate at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_hm1">hM1</code></td>
<td>
<p>Maternally inherited Cas9 homing efficiency at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_hm2">hM2</code></td>
<td>
<p>Maternally inherited Cas9 homing efficiency at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_hp1">hP1</code></td>
<td>
<p>Paternally inherited Cas9 homing efficiency at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_hp2">hP2</code></td>
<td>
<p>Paternally inherited Cas9 homing efficiency at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_rm1">rM1</code></td>
<td>
<p>Maternally inherited Cas9 resistance efficiency at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_rm2">rM2</code></td>
<td>
<p>Maternally inherited Cas9 resistance efficiency at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_rp1">rP1</code></td>
<td>
<p>Paternally inherited Cas9 resistance efficiency at locus 1</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_rp2">rP2</code></td>
<td>
<p>Paternally inherited Cas9 resistance efficiency at locus 2</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_crm">crM</code></td>
<td>
<p>Maternal crossover rate, 0 is completely linked, 0.5 is unlinked, 1.0 is complete divergence</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeTGDX_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This drive corresponds to the <a href="https://www.nature.com/articles/s41467-019-13977-7">transcomplementing gene drive</a>
developed by the Gantz and Bier lab.
</p>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeTwoLocusTA'>Inheritance Cube: 2 Locus Maternal-Toxin/Zygotic-Antidote System</h2><span id='topic+cubeTwoLocusTA'></span>

<h3>Description</h3>

<p>This function creates a 2 locus maternal-toxin/zygotic-antidote system. This
is similar to the construct called UDmel. There is no resistance generation
in this model. <br />
This drive has 2 unlinked alleles, 1 allele each at 2 loci:
</p>

<ul>
<li><p> A: Maternal-toxin 1, zygotic-antidote 2
</p>
</li>
<li><p> a: Wild-type at locus A
</p>
</li>
<li><p> B: Maternal-toxin 2, zygotic-antidote 1
</p>
</li>
<li><p> b: Wild-type at locus B
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeTwoLocusTA(
  TAEfficacy = 1,
  TBEfficacy = 1,
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeTwoLocusTA_+3A_taefficacy">TAEfficacy</code></td>
<td>
<p>Maternal toxin A efficacy</p>
</td></tr>
<tr><td><code id="cubeTwoLocusTA_+3A_tbefficacy">TBEfficacy</code></td>
<td>
<p>Maternal toxin B efficacy</p>
</td></tr>
<tr><td><code id="cubeTwoLocusTA_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeTwoLocusTA_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeTwoLocusTA_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeTwoLocusTA_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeTwoLocusTA_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeTwoLocusTA_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='cubeWolbachia'>Inheritance Cube: Wolbachia</h2><span id='topic+cubeWolbachia'></span>

<h3>Description</h3>

<p>This function creates an inheritance cube to model a Wolbachia infection. Wolbachia
is a parasite that can infect mosquitoes. It biases its inheritance through
cytoplasmic incompatibility. <br />
This drive has 2 alleles at 1 locus:
</p>

<ul>
<li><p> W: has Wolbachia
</p>
</li>
<li><p> w: does not have Wolbachia
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cubeWolbachia(
  eta = NULL,
  phi = NULL,
  omega = NULL,
  xiF = NULL,
  xiM = NULL,
  s = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubeWolbachia_+3A_eta">eta</code></td>
<td>
<p>Genotype-specific mating fitness</p>
</td></tr>
<tr><td><code id="cubeWolbachia_+3A_phi">phi</code></td>
<td>
<p>Genotype-specific sex ratio at emergence</p>
</td></tr>
<tr><td><code id="cubeWolbachia_+3A_omega">omega</code></td>
<td>
<p>Genotype-specific multiplicative modifier of adult mortality</p>
</td></tr>
<tr><td><code id="cubeWolbachia_+3A_xif">xiF</code></td>
<td>
<p>Genotype-specific female pupatory success</p>
</td></tr>
<tr><td><code id="cubeWolbachia_+3A_xim">xiM</code></td>
<td>
<p>Genotype-specific male pupatory success</p>
</td></tr>
<tr><td><code id="cubeWolbachia_+3A_s">s</code></td>
<td>
<p>Genotype-specific fractional reduction(increase) in fertility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cytoplasmic Incompatibility:
</p>

<ul>
<li><p> male W cross female w -&gt; all offspring die (complete penetrance)
</p>
</li>
<li><p> male w cross female W -&gt; all offspring inherit Wolbachia
</p>
</li></ul>



<h3>Value</h3>

<p>Named list containing the inheritance cube, transition matrix, genotypes, wild-type allele,
and all genotype-specific parameters.
</p>

<hr>
<h2 id='eraseDirectory'>Erase all files in a directory</h2><span id='topic+eraseDirectory'></span>

<h3>Description</h3>

<p>Given a directory path, check that it exists, and if so, delete all its contents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eraseDirectory(directory, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eraseDirectory_+3A_directory">directory</code></td>
<td>
<p>Directory whose contents will be deleted</p>
</td></tr>
<tr><td><code id="eraseDirectory_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Path to directory, can tilde expand
myPath &lt;- "~/path/to/write/output"

# Erase directory
#  No return value
eraseDirectory(directory = myPath)

## End(Not run)

</code></pre>

<hr>
<h2 id='generateReleaseVector'>Make List of Modified Mosquito Releases</h2><span id='topic+generateReleaseVector'></span>

<h3>Description</h3>

<p>Sets up a release schedule for a single patch, calls
<code><a href="#topic+basicRepeatedReleases">basicRepeatedReleases</a></code> internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateReleaseVector(driveCube, releasesParameters, nameGenotypes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateReleaseVector_+3A_drivecube">driveCube</code></td>
<td>
<p>Gene-drive cube</p>
</td></tr>
<tr><td><code id="generateReleaseVector_+3A_releasesparameters">releasesParameters</code></td>
<td>
<p>A list containing the releasesStart, releasesNumber
releasesInterval, and releaseProportion named values.</p>
</td></tr>
<tr><td><code id="generateReleaseVector_+3A_namegenotypes">nameGenotypes</code></td>
<td>
<p>Optional list to specify different genotypes for egg/male/female
releases. This is required for mated female releases. This parameter overrides
the default release type.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># setup a drive cube, using Mendelian as the example
cube &lt;- cubeMendelian()

# setup release parameter list
#  releasesStart is the time of first release
#  releasesNumber is the number of releases
#  releasesInterval is the number of days between releases
#  releaseProportion is the number of mosquitoes released
relParams &lt;- list(releasesStart = 25, releasesNumber = 1,
                  releasesInterval = 0, releaseProportion = 10)

# generate male releases
mRelVec &lt;- generateReleaseVector(driveCube = cube,
                                 releasesParameters = relParams)

# generate mated female releases
fRelVec &lt;- generateReleaseVector(driveCube = cube,
                                 releasesParameters = relParams,
                                 nameGenotypes = list(c("AA","AA", 10),
                                                      c("AA","aa", 10)))

</code></pre>

<hr>
<h2 id='get_alpha_Network'>Get alpha</h2><span id='topic+get_alpha_Network'></span>

<h3>Description</h3>

<p>Return density dependent mortality, see <code><a href="#topic+calcDensityDependentDeathRate">calcDensityDependentDeathRate</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_alpha_Network(ix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_alpha_Network_+3A_ix">ix</code></td>
<td>
<p>Index of patch</p>
</td></tr>
</table>

<hr>
<h2 id='get_beta_Network'>Get beta</h2><span id='topic+get_beta_Network'></span>

<h3>Description</h3>

<p>Return size of wild-type egg batch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_beta_Network()
</code></pre>

<hr>
<h2 id='get_conF_Network'>Get conADF</h2><span id='topic+get_conF_Network'></span>

<h3>Description</h3>

<p>Return <code><a href="base.html#topic+connection">connection</a></code> where adult female dynamics are written to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_conF_Network()
</code></pre>

<hr>
<h2 id='get_conM_Network'>Get conADM</h2><span id='topic+get_conM_Network'></span>

<h3>Description</h3>

<p>Return <code><a href="base.html#topic+connection">connection</a></code> where adult male dynamics are written to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_conM_Network()
</code></pre>

<hr>
<h2 id='get_drivecubeindex_Network'>Get Element(s) of Drive Cube by Index</h2><span id='topic+get_drivecubeindex_Network'></span>

<h3>Description</h3>

<p>Return elements or slices of drive cube. If all <code>NULL</code> return entire cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_drivecubeindex_Network(fG = NULL, mG = NULL, oG = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_drivecubeindex_Network_+3A_fg">fG</code></td>
<td>
<p>Female genotype index</p>
</td></tr>
<tr><td><code id="get_drivecubeindex_Network_+3A_mg">mG</code></td>
<td>
<p>Male genotype index</p>
</td></tr>
<tr><td><code id="get_drivecubeindex_Network_+3A_og">oG</code></td>
<td>
<p>Offspring genotype index</p>
</td></tr>
</table>

<hr>
<h2 id='get_eta_Network'>Get eta</h2><span id='topic+get_eta_Network'></span>

<h3>Description</h3>

<p>Get eta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eta_Network(fIdx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eta_Network_+3A_fidx">fIdx</code></td>
<td>
<p>Index of female genotype to pull
</p>
<p>Return genotype-specific mating fitness</p>
</td></tr>
</table>

<hr>
<h2 id='get_femalePop_Patch'>Get female Population</h2><span id='topic+get_femalePop_Patch'></span>

<h3>Description</h3>

<p>Return  females (nGenotypes X nGenotypes matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_femalePop_Patch()
</code></pre>

<hr>
<h2 id='get_genotypesID_Network'>Get genotypesID</h2><span id='topic+get_genotypesID_Network'></span>

<h3>Description</h3>

<p>Return character vector of possible genotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_genotypesID_Network()
</code></pre>

<hr>
<h2 id='get_genotypesN_Network'>Get genotypesN</h2><span id='topic+get_genotypesN_Network'></span>

<h3>Description</h3>

<p>Return number of possible genotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_genotypesN_Network()
</code></pre>

<hr>
<h2 id='get_malePop_Patch'>Get male Population</h2><span id='topic+get_malePop_Patch'></span>

<h3>Description</h3>

<p>Return males (nGenotypes vector)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_malePop_Patch()
</code></pre>

<hr>
<h2 id='get_muAd_Network'>Get muAd</h2><span id='topic+get_muAd_Network'></span>

<h3>Description</h3>

<p>Return adult mortality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_muAd_Network()
</code></pre>

<hr>
<h2 id='get_muAq_Network'>Get muAq</h2><span id='topic+get_muAq_Network'></span>

<h3>Description</h3>

<p>Return larval mortality, see <code><a href="#topic+calcLarvalStageMortalityRate">calcLarvalStageMortalityRate</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_muAq_Network()
</code></pre>

<hr>
<h2 id='get_nPatch_Network'>Get nPatch</h2><span id='topic+get_nPatch_Network'></span>

<h3>Description</h3>

<p>Return number of patches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nPatch_Network()
</code></pre>

<hr>
<h2 id='get_omega_Network'>Get omega</h2><span id='topic+get_omega_Network'></span>

<h3>Description</h3>

<p>Return genotype-specific multiplicative modifier of adult mortality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_omega_Network()
</code></pre>

<hr>
<h2 id='get_patchReleases_Network'>Get Patch Release Schedule</h2><span id='topic+get_patchReleases_Network'></span>

<h3>Description</h3>

<p>Return the release schedule for a patch for male or female
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_patchReleases_Network(patch, sex = "M")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_patchReleases_Network_+3A_patch">patch</code></td>
<td>
<p>Index of patch</p>
</td></tr>
<tr><td><code id="get_patchReleases_Network_+3A_sex">sex</code></td>
<td>
<p>Character in 'M', 'F', 'Egg', 'mF'</p>
</td></tr>
</table>

<hr>
<h2 id='get_phi_Network'>Get phi</h2><span id='topic+get_phi_Network'></span>

<h3>Description</h3>

<p>Return genotype-specific sex ratio at emergence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_phi_Network()
</code></pre>

<hr>
<h2 id='get_s_Network'>Get s</h2><span id='topic+get_s_Network'></span>

<h3>Description</h3>

<p>Return genotype-specific fractional reduction(increase) in fertility
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_s_Network()
</code></pre>

<hr>
<h2 id='get_tau_Network'>Get Female Viability Mask (tau)</h2><span id='topic+get_tau_Network'></span>

<h3>Description</h3>

<p>Get Female Viability Mask (tau)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tau_Network(fG = NULL, mG = NULL, oG = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tau_Network_+3A_fg">fG</code></td>
<td>
<p>Number for which female genotype to get</p>
</td></tr>
<tr><td><code id="get_tau_Network_+3A_mg">mG</code></td>
<td>
<p>Number for which male genotype to get</p>
</td></tr>
<tr><td><code id="get_tau_Network_+3A_og">oG</code></td>
<td>
<p>Number for which offspring genotype to get
</p>
<p>Return matrix</p>
</td></tr>
</table>

<hr>
<h2 id='get_timeAq_Network'>Get timeAq</h2><span id='topic+get_timeAq_Network'></span>

<h3>Description</h3>

<p>Return duration of aquatic stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_timeAq_Network(stage = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_timeAq_Network_+3A_stage">stage</code></td>
<td>
<p>Character in 'E', 'L', 'P'; if <code>NULL</code> return total duration</p>
</td></tr>
</table>

<hr>
<h2 id='get_tNow_Network'>Get tNow</h2><span id='topic+get_tNow_Network'></span>

<h3>Description</h3>

<p>Return current simulation time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tNow_Network()
</code></pre>

<hr>
<h2 id='get_xiF_Network'>Get xiF</h2><span id='topic+get_xiF_Network'></span>

<h3>Description</h3>

<p>Return genotype-specific female pupatory success
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_xiF_Network()
</code></pre>

<hr>
<h2 id='get_xiM_Network'>Get xiM</h2><span id='topic+get_xiM_Network'></span>

<h3>Description</h3>

<p>Return genotype-specific male pupatory success
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_xiM_Network()
</code></pre>

<hr>
<h2 id='ggColUtility'>Utility to Imitate ggplot2 Colors</h2><span id='topic+ggColUtility'></span>

<h3>Description</h3>

<p>Sample at equally spaced intervals along the color wheel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggColUtility(n, alpha = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggColUtility_+3A_n">n</code></td>
<td>
<p>Number of colors</p>
</td></tr>
<tr><td><code id="ggColUtility_+3A_alpha">alpha</code></td>
<td>
<p>Transparency</p>
</td></tr>
</table>

<hr>
<h2 id='kernels'>Kernels Parameters</h2><span id='topic+kernels'></span>

<h3>Description</h3>

<p>A named list containing maximum likelihood fitted parameter values from
mosquito dispersal estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kernels)
</code></pre>


<h3>Format</h3>

<p>named list with 5 elements:
</p>

<dl>
<dt>lnorm_mean</dt><dd><p>log mean of log-normal density</p>
</dd>
<dt>lnorm_sd</dt><dd><p>log standard deviation of log-normal density</p>
</dd>
<dt>gamma_shape</dt><dd><p>shape parameter of gamma density</p>
</dd>
<dt>gamma_sd</dt><dd><p>rate parameter of gamma density</p>
</dd>
<dt>exp_rate</dt><dd><p>rate parameter of exponential density</p>
</dd>
</dl>


<hr>
<h2 id='MGDrivE'>MGDrivE: Mosquito Gene Drive Explorer</h2><span id='topic+MGDrivE'></span>

<h3>Description</h3>

<p>MGDrivE: Mosquito Gene Drive Explorer
</p>


<h3>Introduction</h3>

<p>Recent developments of CRISPR-Cas9 based homing endonuclease gene drive systems,
for the suppression or replacement of mosquito populations, have generated much
interest in their use for control of mosquito-borne diseases (such as dengue,
malaria, Chikungunya and Zika). This is because genetic control of pathogen
transmission may complement or even substitute traditional vector-control
interventions, which have had limited success in bringing the spread of these
diseases to a halt. Despite excitement for the use of gene drives for mosquito
control, current modeling efforts have analyzed only a handful of these new
approaches (usually studying just one per framework). Moreover, these models
usually consider well-mixed populations with no explicit spatial dynamics. To
this end, we are developing MGDrivE (Mosquito Gene DRIVe Explorer), in
cooperation with the 'UCI Malaria Elimination Initiative', as a flexible
modeling framework to evaluate a variety of drive systems in spatial networks
of mosquito populations. This framework provides a reliable testbed to evaluate
and optimize the efficacy of gene drive mosquito releases. What separates MGDrivE
from other models is the incorporation of mathematical and computational
mechanisms to simulate a wide array of inheritance-based technologies within
the same, coherent set of equations. We do this by treating the population
dynamics, genetic inheritance operations, and migration between habitats as
separate processes coupled together through the use of mathematical tensor
operations. This way we can conveniently swap inheritance patterns whilst
still making use of the same set of population dynamics equations. This is a
crucial advantage of our system, as it allows other research groups to test
their ideas without developing new models and without the need to spend time
adapting other frameworks to suit their needs.
</p>


<h3>Brief Description</h3>

<p>MGDrivE is based on the idea that we can decouple the genotype inheritance
process from the population dynamics equations. This allows the system to be
treated and developed in three semi-independent modules that come together to
form the system. The way this is done will be described later in this document
but a reference diagram is shown here.
</p>


<h3>Previous Work</h3>

<p>The original version of this model was based on work by (Deredec et al. 2011; Hancock and Godfray 2007)
and adapted to accommodate CRISPR homing dynamics in a previous publication
by our team (Marshall et al. 2017).
As it was described, we extended this framework to be able to handle a variable
number of genotypes, and migration across spatial scenarios. We accomplish this
by adapting the equations to work in a tensor-oriented manner, where each
genotype can have different processes affecting their particular strain
(death rates, mating fitness, sex-ratio bias, et cetera).
</p>


<h3>Notation and Conventions</h3>

<p>Before beginning the full description of the model we will define some of the
conventions we followed for the notation of the written description of the system.
</p>

<ul>
<li><p> Overlines are used to denote the dimension of a tensor.
</p>
</li>
<li><p> Subscript brackets are used to indicate an element in time. For example: <code class="reqn">L_{[t-1]}</code> is the larval population at time: <code class="reqn">t-1</code>.
</p>
</li>
<li><p> Parentheses are used to indicate the parameter(s) of a function. For example: <code class="reqn">\overline{O(T_{e}+T_{l})}</code> represents the function <code class="reqn">O</code> evaluated with the parameter: <code class="reqn">T_{e}+T_{l}</code>
</p>
</li>
<li><p> Matrices follow a 'row-first' indexing order (i: row, j: column)
</p>
</li></ul>

<p>In the case of one dimensional tensors, each slot represents a genotype of the
population. For example, the male population is stored in the following way:
</p>
<p style="text-align: center;"><code class="reqn">\overline{Am} = \left(\begin{array}{c} g_1 \\ g_2 \\ g_3 \\ \vdots \\ g_n \end{array}\right) _{i}</code>
</p>

<p>All the processes that affect mosquitoes in a genotype-specific way are defined
and stored in this way within the framework.
</p>
<p>There are two tensors of squared dimensionality in the model: the adult females
matrix, and the genotype-specific male-mating ability (<code class="reqn">\overline{\eta}</code>)
In the case of the former the rows represent the females' genotype, whilst the
columns represent the genotype of the male they mated with:
</p>
<p style="text-align: center;"><code class="reqn">\overline{\overline{Af}} = \left(\begin{array}{ccccc} g_{11} &amp; g_{12} &amp; g_{13} &amp; \cdots &amp; g_{1n}\\ g_{21} &amp; g_{22} &amp; g_{23} &amp; \cdots &amp; g_{2n}\\ g_{31} &amp; g_{32} &amp; g_{33} &amp; \cdots &amp; g_{3n}\\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\ g_{n1} &amp; g_{n2} &amp; g_{n3} &amp; \cdots &amp; g_{nn} \end{array}\right) _{ij}</code>
</p>

<p>The genotype-specific male mating ability, on the other hand, stores the females'
genotype in the rows, and the male genotypes in the columns of the matrix.
</p>


<h3>References</h3>

<p>Deredec A, Godfray HCJ, Burt A (2011).
&ldquo;Requirements for effective malaria control with homing endonuclease genes.&rdquo;
<em>Proceedings of the National Academy of Sciences of the United States of America</em>, <b>108</b>(43), E874&ndash;80.
ISSN 1091-6490, doi: <a href="https://doi.org/10.1073/pnas.1110717108">10.1073/pnas.1110717108</a>, <a href="https://www.pnas.org/content/108/43/E874">https://www.pnas.org/content/108/43/E874</a>.<br /><br /> Hancock PA, Godfray HCJ (2007).
&ldquo;Application of the lumped age-class technique to studying the dynamics of malaria-mosquito-human interactions.&rdquo;
<em>Malaria journal</em>, <b>6</b>, 98.
ISSN 1475-2875, doi: <a href="https://doi.org/10.1186/1475-2875-6-98">10.1186/1475-2875-6-98</a>, <a href="https://malariajournal.biomedcentral.com/articles/10.1186/1475-2875-6-98">https://malariajournal.biomedcentral.com/articles/10.1186/1475-2875-6-98</a>.<br /><br /> Marshall J, Buchman A, C. HMS, Akbari OS (2017).
&ldquo;Overcoming evolved resistance to population-suppressing homing-based gene drives.&rdquo;
<em>Nature Scientific Reports</em>, 1&ndash;46.
ISSN 2045-2322, doi: <a href="https://doi.org/10.1038/s41598-017-02744-7">10.1038/s41598-017-02744-7</a>, <a href="https://www.nature.com/articles/s41598-017-02744-7">https://www.nature.com/articles/s41598-017-02744-7</a>.
</p>

<hr>
<h2 id='MGDrivE-Cube'>MGDrivE: Inheritance Cube</h2><span id='topic+MGDrivE-Cube'></span>

<h3>Description</h3>

<p>To model an arbitrary number of genotypes efficiently in the same mathematical
framework, we use a 3-dimensional array structure (cube) where each axis
represents the following information:
</p>

<ul>
<li><p> x: female adult mate genotype
</p>
</li>
<li><p> y: male adult mate genotype
</p>
</li>
<li><p> z: proportion of the offspring that inherits a given genotype (layer)
</p>
</li></ul>



<h3>Details</h3>

<p>The cube structure gives us the flexibility to apply tensor operations to the
elements within our equations, so that we can calculate the stratified population
dynamics rapidly; and within a readable, flexible computational framework.
This becomes apparent when we define the equation we use for the computation
of eggs laid at any given point in time:
</p>
<p style="text-align: center;"><code class="reqn">\overline{O(T_x)} = \sum_{j=1}^{n} \Bigg( \bigg( (\beta*\overline{s} * \overline{ \overline{Af_{[t-T_x]}}}) * \overline{\overline{\overline{Ih}}} \bigg) * \Lambda  \Bigg)^{\top}_{ij}</code>
</p>

<p>In this equation, the matrix containing the number of mated adult females
(<code class="reqn">\overline{\overline{Af}}</code>) is multiplied element-wise with each one of
the layers containing the eggs genotypes proportions expected from this cross
(<code class="reqn">\overline{\overline{\overline{Ih}}}</code>). The resulting matrix is then
multiplied by a binary 'viability mask' (<code class="reqn">\Lambda</code>) that filters out
female-parent to offspring genetic combinations that are not viable due to
biological impediments (such as cytoplasmic incompatibility). The summation of
the transposed resulting matrix returns us the total fraction of eggs resulting
from all the male to female genotype crosses (<code class="reqn">\overline{O(T_x)}</code>).
</p>
<p>Note: For inheritance operations to be consistent within the framework the
summation of each element in the z-axis (this is, the proportions of each one
of the offspring's genotypes) must be equal to one.
</p>


<h3>Drive-specific Cubes</h3>

<p>An inheritance cube in an array object that specifies inheritance probabilities
(offspring genotype probability) stratified by male and female parent genotypes.
MGDrivE provides the following cubes to model different gene drive systems:
</p>

<ul>
<li> <p><code><a href="#topic+cubeOneLocusTA">cubeOneLocusTA</a></code>: 1 Locus Maternal-Toxin/Zygotic-Antidote System
</p>
</li>
<li> <p><code><a href="#topic+cubeTwoLocusTA">cubeTwoLocusTA</a></code>: 2 Locus Maternal-Toxin/Zygotic-Antidote System
</p>
</li>
<li> <p><code><a href="#topic+cubeClvR">cubeClvR</a></code>: 1 Locus Cleave and Rescue (ClvR)
</p>
</li>
<li> <p><code><a href="#topic+cubeClvR2">cubeClvR2</a></code>: 2 Locus Cleave and Rescue (ClvR)
</p>
</li>
<li> <p><code><a href="#topic+cubeHoming1RA">cubeHoming1RA</a></code>: Homing Drive with 1 Resistance Allele
</p>
</li>
<li> <p><code><a href="#topic+cubeHomingDrive">cubeHomingDrive</a></code>: CRISPR (Clustered Regularly Interspaced Short Palindromic Repeats) with 2 Resistance Allele
</p>
</li>
<li> <p><code><a href="#topic+cubeECHACR">cubeECHACR</a></code>: ECHACR (uh....)
</p>
</li>
<li> <p><code><a href="#topic+cubeECHACRX">cubeECHACRX</a></code>: ECHACR, X-Linked
</p>
</li>
<li> <p><code><a href="#topic+cubeKillerRescue">cubeKillerRescue</a></code>: Killer-Rescue System
</p>
</li>
<li> <p><code><a href="#topic+cubeMEDEA">cubeMEDEA</a></code>: MEDEA (Maternal Effect Dominant Embryonic Arrest)
</p>
</li>
<li> <p><code><a href="#topic+cubeReciprocalTranslocations">cubeReciprocalTranslocations</a></code>: Reciprocal Translocation
</p>
</li>
<li> <p><code><a href="#topic+cubeRIDL">cubeRIDL</a></code>: RIDL (Release of Insects with Dominant Lethality)
</p>
</li>
<li> <p><code><a href="#topic+cubeMendelian">cubeMendelian</a></code>: Mendelian
</p>
</li>
<li> <p><code><a href="#topic+cubeSplitDrive">cubeSplitDrive</a></code>: Split CRISPR drive
</p>
</li>
<li> <p><code><a href="#topic+cubeTGD">cubeTGD</a></code>: trans-complementing Gene Drive
</p>
</li>
<li> <p><code><a href="#topic+cubeTGDX">cubeTGDX</a></code>: trans-complementing Gene Drive, X-Linked
</p>
</li>
<li> <p><code><a href="#topic+cubeWolbachia">cubeWolbachia</a></code>: Wolbachia
</p>
</li></ul>



<h3>Functions for Cubes</h3>

<p>We provide one auxiliary function to operate on cube objects.
</p>

<ul>
<li> <p><code><a href="#topic+cube2csv">cube2csv</a></code>: Export slices of a cube to .csv format
</p>
</li></ul>


<hr>
<h2 id='MGDrivE-Model'>MGDrivE: Model's Mathematical Description</h2><span id='topic+MGDrivE-Model'></span>

<h3>Description</h3>

<p>The original version of this model was based on work by (Deredec et al. 2011; Hancock and Godfray 2007)
and adapted to accommodate CRISPR homing dynamics in a previous publication by
our team (Marshall et al. 2017). As
it was described, we extended this framework to be able to handle a variable
number of genotypes, and migration across spatial scenarios. We did this by
adapting the equations to work in a tensor-oriented manner, where each genotype
can have different processes affecting their particular strain
(death rates, mating fitness, sex-ratio bias, et cetera).
</p>


<h3>Inheritance Cube and Oviposition</h3>

<p>To allow the extension of the framework to an arbitrary number of genotypes,
we transformed traditional inheritance matrices into inheritance cubes, where
each of the axis represents the following information:
</p>

<ul>
<li><p> x: female adult mate genotype
</p>
</li>
<li><p> y: male adult mate genotype
</p>
</li>
<li><p> z: proportion of the offspring that inherits a given genotype (slice)
</p>
</li></ul>

<p>The 'cube' structure gives us the flexibility to apply tensor operations to
the elements within our equations, so that we can calculate the stratified
population dynamics rapidly; and within a readable, flexible computational
framework. This becomes apparent when we define the equation we use for the
computation of eggs laid at any given point in time:
</p>
<p style="text-align: center;"><code class="reqn">\overline{O(T_x)} = \sum_{j=1}^{n} \Bigg( \bigg( (\beta*\overline{s} * \overline{ \overline{Af_{[t-T_x]}}}) * \overline{\overline{\overline{Ih}}} \bigg) * \Lambda  \Bigg)^{\top}_{ij}</code>
</p>

<p>In this equation, the matrix containing the number of mated adult females
(<code class="reqn">\overline{\overline{Af}}</code>) is multiplied element-wise with each one of
the slices containing the eggs genotypes proportions expected from this cross
(<code class="reqn">\overline{\overline{\overline{Ih}}}</code>). The resulting matrix is then
multiplied by a binary 'viability mask' (<code class="reqn">\Lambda</code>) that filters out
female-parent to offspring genetic combinations that are not viable due to
biological impediments (such as cytoplasmic incompatibility). The summation
of the transposed resulting matrix returns us the total fraction of eggs
resulting from all the male to female genotype crosses (<code class="reqn">\overline{O(T_{x})}</code>).
</p>
<p>Note: For inheritance operations to be consistent within the framework, the
summation of each element in the 'z' axis (this is, the proportions of each
one of the offspring's genotypes) must be equal to one.
</p>


<h3>Population Dynamics</h3>

<p>During the three aquatic stages, a density-independent mortality process takes place:
</p>
<p style="text-align: center;"><code class="reqn">\theta_{st}=(1-\mu_{st})^{T_{st}}</code>
</p>

<p>Along with a density dependent process dependent on the number of larvae in the environment:
</p>
<p style="text-align: center;"><code class="reqn">F(L[t])=\Bigg(\frac{\alpha}{\alpha+\sum{\overline{L[t]}}}\Bigg)^{1/T_l}</code>
</p>

<p>where <code class="reqn">\alpha</code> represents the strength of the density-dependent process.
This parameter  is calculated with:
</p>
<p style="text-align: center;"><code class="reqn">\alpha=\Bigg( \frac{1/2 * \beta * \theta_e * Ad_{eq}}{R_m-1} \Bigg) * \Bigg( \frac{1-(\theta_l / R_m)}{1-(\theta_l / R_m)^{1/T_l}} \Bigg)</code>
</p>

<p>in which <code class="reqn">\beta</code> is the species' fertility in the absence of gene-drives,
<code class="reqn">Ad_{eq}</code> is the adult mosquito population equilibrium size, and <code class="reqn">R_{m}</code>
is the population growth in the absence of density-dependent mortality. This
population growth is calculated with the average generation time (<code class="reqn">g</code>),
the adult mortality rate (<code class="reqn">\mu_{ad}</code>), and the daily population growth rate (<code class="reqn">r_{m}</code>):
</p>
<p style="text-align: center;"><code class="reqn">	g=T_{e}+T_{l}+T_{p}+\frac{1}{\mu_{ad}}\\R_{m}=(r_{m})^{g}</code>
</p>



<h4>Larval Stages</h4>

<p>The computation of the larval stage in the population is crucial to the model
because the density dependent processes necessary for equilibrium trajectories
to be calculated occur here. This calculation is performed with the following equation:
</p>
<p style="text-align: center;"><code class="reqn">
D(\theta_l,T_x) =
        \begin{array}{ll}
            \theta_{l[0]}^{'}=\theta_l 								&amp; \quad i = 0 \\
            \theta_{l[i+1]}^{'} = \theta_{l[i]}^{'} *F(\overline{L_{[t-i-T_x]}})	&amp; \quad i \leq T_l
        \end{array}
</code>
</p>

<p>In addition to this, we need the larval mortality (<code class="reqn">\mu_{l}</code>):
</p>
<p style="text-align: center;"><code class="reqn">
	%L_{eq}=&amp;\alpha*\lfloor R_{m} -1\rfloor
	%&amp;
	\mu_{l}=1-\Bigg( \frac{R_{m} * \mu_{ad}}{1/2 * \beta * (1-\mu_{m})} \Bigg)^{\frac{1}{T_{e}+T_{l}+T_{p}}}
</code>
</p>

<p>With these mortality processes, we are now able to calculate the larval population:
</p>
<p style="text-align: center;"><code class="reqn">
	\overline{L_{[t]}}=
		\overline{L_{[t-1]}} * (1-\mu_{l}) * F(\overline{L_{[t-1]})}\\
		+\overline{O(T_{e})}* \theta_{e} \\
		%+\overline{\beta}* \theta_{e} * (\overline{\overline{Af_{(t-T_{e})}}} \circ \overline{\overline{\overline{Ih}}})\\
		- \overline{O(T_{e}+T_{l})} * \theta_{e} * D(\theta_{l},0)
		%\prod_{i=1}^{T_{l}} F(\overline{L_{[t-i]}})
		%\theta_{l}
</code>
</p>

<p>where the first term accounts for larvae surviving one day to the other; the
second term accounts for the eggs that have hatched within the same period of
time; and the last term computes the number of larvae that have transformed into pupae.
</p>



<h4>Adult Stages</h4>

<p>We are ultimately interested in calculating how many adults of each genotype
exist at any given point in time. For this, we first calculate the number of
eggs that are laid and survive to the adult stages with the equation:
</p>
<p style="text-align: center;"><code class="reqn">
	\overline{E^{'}}= \overline{O(T_{e}+T_{l}+T_{p})} \\
	* \bigg(\overline{\xi_{m}} * (\theta_{e} * \theta_{p}) * (1-\mu_{ad}) * D(\theta_{l},T_{p}) \bigg)
</code>
</p>

<p>With this information we can calculate the current number of male adults in
the population by computing the following equation:
</p>
<p style="text-align: center;"><code class="reqn">
	\overline{Am_{[t]}}=
		\overline{Am_{[t-1]}} * (1-\mu_{ad})*\overline{\omega_{m}}\\
		+ (1-\overline{\phi}) *  \overline{E^{'}}\\
 		+ \overline{\nu m_{[t-1]}}
</code>
</p>

<p>in which the first term represents the number of males surviving from one day
to the next; the second one, the fraction of males that survive to adulthood
(<code class="reqn">\overline{E'}</code>) and emerge as males (<code class="reqn">1-\phi</code>); the last one is used
to add males into the population as part of gene-drive release campaigns.
</p>
<p>Female adult populations are calculated in a similar way:
</p>
<p style="text-align: center;"><code class="reqn">
 \overline{\overline{Af_{[t]}}}=
   \overline{\overline{Af_{[t-1]}}} * (1-\mu_{ad}) * \overline{\omega_{f}}\\
   +  \bigg( \overline{\phi} * \overline{E^{'}}+\overline{\nu f_{[t-1]}}\bigg)^{\top} * \bigg( \frac{\overline{\overline{\eta}}*\overline{Am_{[t-1]}}}{\sum{\overline{Am_{[t-1]}}}} \bigg)%\overline{\overline{Mf}}
</code>
</p>

<p>where we first compute the surviving female adults from one day to the next;
and then we calculate the mating composition of the female fraction emerging
from pupa stage. To do this, we obtain the surviving fraction of eggs that
survive to adulthood (<code class="reqn">\overline{E'}</code>) and emerge as females (<code class="reqn">\phi</code>),
we then add the new females added as a result of gene-drive releases (<code class="reqn">\overline{\nu f_{[t-1]}}</code>).
After doing this, we calculate the proportion of males that are allocated to
each female genotype, taking into account their respective mating fitnesses
(<code class="reqn">\overline{\overline{\eta}}</code>) so that we can introduce the new adult
females into the population pool.
</p>



<h3>Gene Drive Releases and Effects</h3>

<p>As it was briefly mentioned before, we are including the option to release
both male and/or female individuals into the populations. Another important t
hing to emphasize is that we allow flexible releases sizes and schedules. Our ]
model handles releases internally as lists of populations compositions so, it
is possible to have releases performed at irregular intervals and with different
numbers of mosquito genetic compositions as long as no new genotypes are
introduced (which have not been previously defined in the inheritance cube).
</p>
<p style="text-align: center;"><code class="reqn">
 \overline{\nu} = \bigg\{
   \left(\begin{array}{c} g_1 \\ g_2 \\ g_3 \\ \vdots \\ g_n \end{array}\right)_{t=1} ,
   \left(\begin{array}{c} g_1 \\ g_2 \\ g_3 \\ \vdots \\ g_n \end{array}\right)_{t=2} ,
   \cdots ,
   \left(\begin{array}{c} g_1 \\ g_2 \\ g_3 \\ \vdots \\ g_n \end{array}\right)_{t=x}
\bigg\}
</code>
</p>

<p>So far, however, we have not described the way in which the effects of these
gene-drives are included into the mosquito populations dynamics. This is done
through the use of various modifiers included in the equations:
</p>

<ul>
<li> <p><code class="reqn">\overline{\omega}</code>: Relative increase in mortality (zero being full mortality effects and one no mortality effect)
</p>
</li>
<li> <p><code class="reqn">\overline{\phi}</code>: Relative shift in the sex of the pupating mosquitoes (zero biases the sex ratio towards males, whilst 1 biases the ratio towards females).
</p>
</li>
<li> <p><code class="reqn">\overline{\overline{\eta}}</code>: Standardized mating fitness (zero being complete fitness ineptitude, and one being regular mating skills).
</p>
</li>
<li> <p><code class="reqn">\overline{\beta}</code>: Fecundity (average number of eggs laid).
</p>
</li>
<li> <p><code class="reqn">\overline{\xi}</code>: Pupation success (zero being full mortality and one full pupation success).
</p>
</li></ul>



<h3>Migration</h3>

<p>To simulate migration within our framework we are considering patches (or nodes)
of fully-mixed populations in a network structure. This allows us to handle
mosquito movement across spatially-distributed populations with a transitions
matrix, which is calculated with the tensor outer product of the genotypes
populations tensors and the transitions matrix of the network as follows:
</p>
<p style="text-align: center;"><code class="reqn">
   \overline{Am_{(t)}^{i}}=
   	\sum{\overline{A_{m}^j} \otimes \overline{\overline{\tau m_{[t-1]}}}} \\
     	\overline{\overline{Af_{(t)}^{i}}}=
     \sum{\overline{\overline{A_{f}^j}} \otimes \overline{\overline{\tau f_{[t-1]}}}}
</code>
</p>

<p>In these equations the new population of the patch <code class="reqn">i</code> is calculated by
summing the migrating mosquitoes of all the <code class="reqn">j</code> patches across the network
defined by the transitions matrix <code class="reqn">\tau</code>, which stores the mosquito migration
probabilities from patch to patch. It is worth noting that the migration
probabilities matrices can be different for males and females; and that there's
no inherent need for them to be static (the migration probabilities may vary
over time to accommodate wind changes due to seasonality).
</p>


<h3>Parameters</h3>

<p>This table compiles all the parameters required to run MGDrivE clustered in six categories:
</p>

<ul>
<li><p> Life Stages: These deal with the structure of mosquito population.
</p>
</li>
<li><p> Bionomics: This set of parameters is related to the behavior of the specific mosquito species being modeled.
</p>
</li>
<li><p> Gene Drive: Genotype-specific vectors of parameters that affect how each gene-drive modifies the responses of populations to them.
</p>
</li>
<li><p> Releases:  List of vectors that control the release of genetically-modified mosquitoes.
</p>
</li>
<li><p> Population:  General mosquito-population parameters that control environmentally-determined variables.
</p>
</li>
<li><p> Network: Related to migration between nodes of population units
</p>
</li></ul>



<h3>Stochasticity</h3>

<p><em>MGDrivE</em> allows stochasticity to be included in the dynamics of various
processes; in an effort to simulate processes that affect various stages of
mosquitoes lives. In the next section, we will describe all the stochastic
processes that can be activated in the program. It should be noted that all
of these can be turned on and off independently from one another as required
by the researcher.
</p>


<h4>Mosquito Biology</h4>

<p><strong>Oviposition</strong>
</p>
<p>Stochastic egg laying by female/male pairs is separated into two steps:
calculating the number of eggs laid by the females and then distributing laid
eggs according to their genotypes. The number of eggs laid follows a Poisson
distribution conditioned on the number of female/male pairs and the fertility
of each female.
</p>
<p style="text-align: center;"><code class="reqn">Poisson( \lambda = numFemales*Fertility)</code>
</p>

<p>Multinomial sampling, conditioned on the number of offspring and the relative
viability of each genotype, determines the genotypes of the offspring.
</p>
<p style="text-align: center;"><code class="reqn">Multinomial \left(numOffspring, p_1, p_2\dots p_b \right)=\frac{numOffspring!}{p_1!\,p_2\,\dots p_n}p_1^{n_1}p_2^{n_2}\dots p_n^{n_n}</code>
</p>

<p><strong>Sex Determination</strong>
</p>
<p>Sex of the offspring is determined by multinomial sampling. This is conditioned
on the number of eggs that live to hatching and a probability of being female,
allowing the user to design systems that skew the sex ratio of the offspring
through reproductive mechanisms.
</p>
<p style="text-align: center;"><code class="reqn">Multinomial(numHatchingEggs, p_{female}, p_{female})</code>
</p>

<p><strong>Mating</strong>
Stochastic mating is determined by multinomial sampling conditioned on the
number of males and their fitness. It is assumed that females mate only once
in their life, therefore each female will sample from the available males and
be done, while the males are free to potentially mate with multiple females.
The males' ability to mate is modulated with a fitness term, thereby allowing
some genotypes to be less fit than others (as seen often with lab releases).
</p>
<p style="text-align: center;"><code class="reqn">Multinomial(numFemales, p_1f_1, p_2f_2, \dots p_nf_n)</code>
</p>

<p><strong>Hatching</strong>
</p>
<p><strong>Other Stochastic Processes</strong>
All remaining stochastic processes (larval survival, hatching , pupating,
surviving to adult hood) are determined by multinomial sampling conditioned
on factors affecting the current life stage. These factors are determined
empirically from mosquito population data.
</p>



<h4>Migration</h4>

<p>Variance of stochastic movement (not used in diffusion model of migration).
</p>



<h3>References</h3>

<p>Deredec A, Godfray HCJ, Burt A (2011).
&ldquo;Requirements for effective malaria control with homing endonuclease genes.&rdquo;
<em>Proceedings of the National Academy of Sciences of the United States of America</em>, <b>108</b>(43), E874&ndash;80.
ISSN 1091-6490, doi: <a href="https://doi.org/10.1073/pnas.1110717108">10.1073/pnas.1110717108</a>, <a href="https://www.pnas.org/content/108/43/E874">https://www.pnas.org/content/108/43/E874</a>.<br /><br /> Hancock PA, Godfray HCJ (2007).
&ldquo;Application of the lumped age-class technique to studying the dynamics of malaria-mosquito-human interactions.&rdquo;
<em>Malaria journal</em>, <b>6</b>, 98.
ISSN 1475-2875, doi: <a href="https://doi.org/10.1186/1475-2875-6-98">10.1186/1475-2875-6-98</a>, <a href="https://malariajournal.biomedcentral.com/articles/10.1186/1475-2875-6-98">https://malariajournal.biomedcentral.com/articles/10.1186/1475-2875-6-98</a>.<br /><br /> Marshall J, Buchman A, C. HMS, Akbari OS (2017).
&ldquo;Overcoming evolved resistance to population-suppressing homing-based gene drives.&rdquo;
<em>Nature Scientific Reports</em>, 1&ndash;46.
ISSN 2045-2322, doi: <a href="https://doi.org/10.1038/s41598-017-02744-7">10.1038/s41598-017-02744-7</a>, <a href="https://www.nature.com/articles/s41598-017-02744-7">https://www.nature.com/articles/s41598-017-02744-7</a>.
</p>

<hr>
<h2 id='moveMatAll2'>Movement Matrix: All 2</h2><span id='topic+moveMatAll2'></span>

<h3>Description</h3>

<p>A movement matrix for simulation with 3 patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moveMatAll2)
</code></pre>


<h3>Format</h3>

<p>A matrix with 3 rows and 3 columns:
</p>

<p>Patches 1 and 3 are sources for patch 2, which is a sink.

</p>

<hr>
<h2 id='moveMatCascade3'>Movement Matrix: Cascade 3</h2><span id='topic+moveMatCascade3'></span>

<h3>Description</h3>

<p>A movement matrix for simulation with 3 patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moveMatCascade3)
</code></pre>


<h3>Format</h3>

<p>A matrix with 3 rows and 3 columns:
</p>

<p>Mosquitoes in patch 1 have equal probability to stay or move to 2; mosquitoes
in patch 2 have equal probability to stay or move to 3; mosquitoes in patch 3 stay there.

</p>

<hr>
<h2 id='moveMatDiag'>Movement Matrix: Diagonal</h2><span id='topic+moveMatDiag'></span>

<h3>Description</h3>

<p>A movement matrix for simulation with 3 patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moveMatDiag)
</code></pre>


<h3>Format</h3>

<p>A matrix with 3 rows and 3 columns:
</p>

<p>3 independent patches.

</p>

<hr>
<h2 id='moveMatDiagOneCity'>Movement Matrix: Diagonal One City</h2><span id='topic+moveMatDiagOneCity'></span>

<h3>Description</h3>

<p>A movement matrix for simulation with 1 patch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moveMatDiagOneCity)
</code></pre>


<h3>Format</h3>

<p>A matrix with 1 rows and 1 columns:
</p>

<p>A 1 by 1 matrix with entry 1.

</p>

<hr>
<h2 id='moveMatDie'>Movement Matrix: Die</h2><span id='topic+moveMatDie'></span>

<h3>Description</h3>

<p>A movement matrix for simulation with 3 patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moveMatDie)
</code></pre>


<h3>Format</h3>

<p>A matrix with 3 rows and 3 columns:
</p>

<p>All entries of matrix are 0 for testing that all mosquitoes will be killed.

</p>

<hr>
<h2 id='moveMatIndependent3'>Movement Matrix: Independent 3</h2><span id='topic+moveMatIndependent3'></span>

<h3>Description</h3>

<p>A movement matrix for simulation with 3 patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moveMatIndependent3)
</code></pre>


<h3>Format</h3>

<p>A matrix with 3 rows and 3 columns:
</p>

<p>Mosquitoes in patch 1 stay with probability 0.975, move to patch 2 with probability 0.025,
mosquitoes in patch 2 and 3 stay in their patches.

</p>

<hr>
<h2 id='moveMatMixedSpil'>Movement Matrix: Mixed Spill</h2><span id='topic+moveMatMixedSpil'></span>

<h3>Description</h3>

<p>A movement matrix for simulation with 3 patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moveMatMixedSpil)
</code></pre>


<h3>Format</h3>

<p>A matrix with 3 rows and 3 columns:
</p>

<p>Mosquitoes in patch 1 stay with probability 0.999, move to patch 2 with probability 0.001,
mosquitoes in patch 2 and 3 stay in their patches.

</p>

<hr>
<h2 id='moveMatTaleOfTwoCities'>Movement Matrix: Tale of Two Cities</h2><span id='topic+moveMatTaleOfTwoCities'></span>

<h3>Description</h3>

<p>A movement matrix for simulation with 2 patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moveMatTaleOfTwoCities)
</code></pre>


<h3>Format</h3>

<p>A matrix with 2 rows and 2 columns:
</p>

<p>Mosquitoes do not move between the two patches.

</p>

<hr>
<h2 id='moveMatTriDiagonal'>Movement Matrix: Tri-diagonal</h2><span id='topic+moveMatTriDiagonal'></span>

<h3>Description</h3>

<p>A movement matrix for simulation with 12 patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moveMatTriDiagonal)
</code></pre>


<h3>Format</h3>

<p>A matrix with 12 rows and 12 columns:
</p>

<p>Tri-diagonal matrix with approximately 0.985 probability on diagonal and
rest of probability mass on k-1 and k+1 off-diagonal elements.

</p>

<hr>
<h2 id='moveMatTriple'>Movement Matrix: Triple</h2><span id='topic+moveMatTriple'></span>

<h3>Description</h3>

<p>A movement matrix for simulation with 3 patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moveMatTriple)
</code></pre>


<h3>Format</h3>

<p>A matrix with 3 rows and 3 columns:
</p>

<p>All entries of matrix are 1 for testing that mosquitoes will be produced.

</p>

<hr>
<h2 id='multRun_Network'>Run Simulation</h2><span id='topic+multRun_Network'></span>

<h3>Description</h3>

<p>Run multiple simulations on this network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multRun_Network(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multRun_Network_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='Network'>Network Class Definition</h2><span id='topic+Network'></span>

<h3>Description</h3>

<p>A <code>Network</code> class object stores all the information for a simulation on
a defined landscape.
</p>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> generator object
</p>


<h3><strong>Constructor</strong></h3>


<ul>
<li><p> params: see <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code>
</p>
</li>
<li><p> driveCube: an inheritance cube
</p>
</li>
<li><p> patchReleases: see <code><a href="#topic+basicRepeatedReleases">basicRepeatedReleases</a></code> for examples on how to set up release schedules
</p>
</li>
<li><p> migrationMale: a stochastic matrix whose dimensions conform to the number of patches
</p>
</li>
<li><p> migrationFemale: a stochastic matrix whose dimensions conform to the number of patches
</p>
</li>
<li><p> migrationBatch: a list of batch migration parameters. See<code><a href="#topic+basicBatchMigration">basicBatchMigration</a></code>
</p>
</li>
<li><p> directory: character string of output directory
</p>
</li>
<li><p> verbose: Chatty? Default is TRUE
</p>
</li></ul>



<h3><strong>Methods</strong></h3>


<ul>
<li><p> get_timeAq: see <code><a href="#topic+get_timeAq_Network">get_timeAq_Network</a></code>
</p>
</li>
<li><p> get_beta: see <code><a href="#topic+get_beta_Network">get_beta_Network</a></code>
</p>
</li>
<li><p> get_muAd: see <code><a href="#topic+get_muAd_Network">get_muAd_Network</a></code>
</p>
</li>
<li><p> get_muAq: see <code><a href="#topic+get_muAq_Network">get_muAq_Network</a></code>
</p>
</li>
<li><p> get_alpha: see <code><a href="#topic+get_alpha_Network">get_alpha_Network</a></code>
</p>
</li>
<li><p> get_drivecubeindex: see <code><a href="#topic+get_drivecubeindex_Network">get_drivecubeindex_Network</a></code>
</p>
</li>
<li><p> get_tau: see <code><a href="#topic+get_tau_Network">get_tau_Network</a></code>
</p>
</li>
<li><p> get_genotypesID: see <code><a href="#topic+get_genotypesID_Network">get_genotypesID_Network</a></code>
</p>
</li>
<li><p> get_genotypesN: see <code><a href="#topic+get_genotypesN_Network">get_genotypesN_Network</a></code>
</p>
</li>
<li><p> get_eta: see <code><a href="#topic+get_eta_Network">get_eta_Network</a></code>
</p>
</li>
<li><p> get_phi: see <code><a href="#topic+get_phi_Network">get_phi_Network</a></code>
</p>
</li>
<li><p> get_omega: see <code><a href="#topic+get_omega_Network">get_omega_Network</a></code>
</p>
</li>
<li><p> get_xiF: see <code><a href="#topic+get_xiF_Network">get_xiF_Network</a></code>
</p>
</li>
<li><p> get_xiM: see <code><a href="#topic+get_xiM_Network">get_xiM_Network</a></code>
</p>
</li>
<li><p> get_s: see <code><a href="#topic+get_s_Network">get_s_Network</a></code>
</p>
</li>
<li><p> get_nPatch: see <code><a href="#topic+get_nPatch_Network">get_nPatch_Network</a></code>
</p>
</li>
<li><p> get_conADM: see <code><a href="#topic+get_conM_Network">get_conM_Network</a></code>
</p>
</li>
<li><p> get_conADF: see <code><a href="#topic+get_conF_Network">get_conF_Network</a></code>
</p>
</li>
<li><p> get_tNow: see <code><a href="#topic+get_tNow_Network">get_tNow_Network</a></code>
</p>
</li>
<li><p> get_patchReleases: see <code><a href="#topic+get_patchReleases_Network">get_patchReleases_Network</a></code>
</p>
</li>
<li><p> oneDay_Migration: see <code><a href="#topic+oneDay_Migration_Deterministic_Network">oneDay_Migration_Deterministic_Network</a></code> or see <code><a href="#topic+oneDay_Migration_Stochastic_Network">oneDay_Migration_Stochastic_Network</a></code>
</p>
</li>
<li><p> reset: see <code><a href="#topic+reset_Network">reset_Network</a></code>
</p>
</li>
<li><p> oneDay: see <code><a href="#topic+oneDay_Network">oneDay_Network</a></code>
</p>
</li>
<li><p> oneRun: see <code><a href="#topic+oneRun_Network">oneRun_Network</a></code>
</p>
</li>
<li><p> multRun: see <code><a href="#topic+multRun_Network">multRun_Network</a></code>
</p>
</li></ul>



<h3><strong>Fields</strong></h3>


<ul>
<li><p> parameters: see <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code>
</p>
</li>
<li><p> patches: a list of <code><a href="#topic+Patch">Patch</a></code> objects
</p>
</li>
<li><p> nPatch: number of patches
</p>
</li>
<li><p> simTime: maximum time of simulation
</p>
</li>
<li><p> sampTime: how often to write output, tNow %% sampTime
</p>
</li>
<li><p> driveCube: an inheritance cube
</p>
</li>
<li><p> tNow: current time of simulation (time starts at 2 because time 1 is the initial equilibrium state)
</p>
</li>
<li><p> runID: an identifier for the current simulation run, useful for Monte Carlo simulation
</p>
</li>
<li><p> directory: a character string of where to store output
</p>
</li>
<li><p> conADM: a <code><a href="base.html#topic+connection">connection</a></code> to write male population dynamics out to
</p>
</li>
<li><p> conADF: a <code><a href="base.html#topic+connection">connection</a></code> to write female population dynamics out to
</p>
</li>
<li><p> migrationMale: a stochastic matrix whose dimensions conform to the number of patches
</p>
</li>
<li><p> migrationFemale: a stochastic matrix whose dimensions conform to the number of patches
</p>
</li>
<li><p> migrationBatch: list of items for batch migration in stochastic sim.
</p>
</li>
<li><p> mMoveMat: holder object for male migration
</p>
</li>
<li><p> fMoveArray: holder object for female migration
</p>
</li>
<li><p> patchReleases: a list of release schedules for each patch
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 # There are no simple examples for this, so looking at the vignettes would be
 #  most useful.

 # Complete manual with examples, but none explored in depth.
 vignette("MGDrivE-Examples", package = "MGDrivE")

 # One example, explored in great detail. This is probably more helpful.
 vignette("MGDrivE-Run", package = "MGDrivE")

 
## End(Not run)

</code></pre>

<hr>
<h2 id='normalise'>Normalise a Numeric Vector</h2><span id='topic+normalise'></span>

<h3>Description</h3>

<p>Normalise a numeric vector to sum to one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise(vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalise_+3A_vector">vector</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
</table>

<hr>
<h2 id='oneDay_adultDeath_deterministic_Patch'>Deterministic Adult Survival</h2><span id='topic+oneDay_adultDeath_deterministic_Patch'></span>

<h3>Description</h3>

<p>Daily adult survival is calculated according to </p>
<p style="text-align: center;"><code class="reqn">\overline{\overline{Af_{[t-1]}}} * (1-\mu_{ad}) * \overline{\omega_{m/f}}</code>
</p>
<p>,
where <code class="reqn">\mu_{ad}</code> corresponds to adult mortality rate and <code class="reqn">\overline{\omega_{m/f}}</code>
corresponds to genotype-specific male/female mortality effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_adultDeath_deterministic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_adultDeath_stochastic_Patch'>Stochastic Adult Survival</h2><span id='topic+oneDay_adultDeath_stochastic_Patch'></span>

<h3>Description</h3>

<p>Daily adult survival is sampled from a binomial distribution where survival
probability is given by </p>
<p style="text-align: center;"><code class="reqn">(1-\mu_{ad}) * \overline{\omega_m/f}</code>
</p>
<p>.
<code class="reqn">\mu_{ad}</code> corresponds to adult mortality rate and <code class="reqn">\overline{\omega_m/f}</code>
corresponds to genotype-specific mortality effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_adultDeath_stochastic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_eggDM_deterministic_Patch'>Deterministic Egg Death and Pupation</h2><span id='topic+oneDay_eggDM_deterministic_Patch'></span>

<h3>Description</h3>

<p>Daily egg survival is calculated according to </p>
<p style="text-align: center;"><code class="reqn">\overline{E_{[t-1]}} * (1-\mu_{aq})</code>
</p>
<p>,
where <code class="reqn">\mu_{aq}</code> corresponds to daily non-density-dependent aquatic mortality.
Eggs transition into larvae at the end of <code class="reqn">T_e</code>. <br />
See <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code> for how these parameters are derived.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_eggDM_deterministic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_eggDM_stochastic_Patch'>Stochastic Egg Death and Pupation</h2><span id='topic+oneDay_eggDM_stochastic_Patch'></span>

<h3>Description</h3>

<p>Daily egg survival is sampled from a binomial distribution, where survival
probability is given by <code class="reqn">1-\mu_{aq}</code>. <code class="reqn">\mu_{aq}</code> corresponds
to daily non-density-dependent aquatic mortality. <br />
Eggs transition into larvae at the end of <code class="reqn">T_e</code>. <br />
See <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code> for how these parameters are derived.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_eggDM_stochastic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_eggReleases_Patch'>Release Eggs in a Patch</h2><span id='topic+oneDay_eggReleases_Patch'></span>

<h3>Description</h3>

<p>Based on this patch's release schedule, <code><a href="#topic+generateReleaseVector">generateReleaseVector</a></code>,
this function handles daily egg releases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_eggReleases_Patch()
</code></pre>

<hr>
<h2 id='oneDay_initOutput_Patch'>Initialize Output from Focal Patch</h2><span id='topic+oneDay_initOutput_Patch'></span>

<h3>Description</h3>

<p>Writes output to the text connections specified in the enclosing <code><a href="#topic+Network">Network</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_initOutput_Patch()
</code></pre>

<hr>
<h2 id='oneDay_larvaDM_deterministic_Patch'>Deterministic Larva Death and Pupation</h2><span id='topic+oneDay_larvaDM_deterministic_Patch'></span>

<h3>Description</h3>

<p>Calculate the number of larvae surviving from day to day, given by:
</p>
<p style="text-align: center;"><code class="reqn">\overline{L_{[t-1]}} * (1-\mu_{aq}) * F(L)</code>
</p>
<p>. F(L), the density dependence
is calculated as </p>
<p style="text-align: center;"><code class="reqn">F(L[t])=\Bigg(\frac{\alpha}{\alpha+\sum{\overline{L[t]}}}\Bigg)^{1/T_l}</code>
</p>
<p>.
See <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code> for how these parameters are derived.
Pupation has no parameters, so the final day of larvae naturally enter the pupal state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_larvaDM_deterministic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_larvaDM_stochastic_Patch'>Stochastic Larva Death and Pupation</h2><span id='topic+oneDay_larvaDM_stochastic_Patch'></span>

<h3>Description</h3>

<p>The daily number of larvae surviving is drawn from a binomial distribution, where
survival probability is given by </p>
<p style="text-align: center;"><code class="reqn">(1-\mu_{aq}) * F(L)</code>
</p>
<p>. F(L), the density dependence
is calculated as </p>
<p style="text-align: center;"><code class="reqn">F(L[t])=\Bigg(\frac{\alpha}{\alpha+\sum{\overline{L[t]}}}\Bigg)^{1/T_l}</code>
</p>
<p>.
See <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code> for how these parameters are derived.
Pupation has no parameters, so the final day of larvae naturally enter the pupal state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_larvaDM_stochastic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_mating_deterministic_Patch'>Deterministic Mating</h2><span id='topic+oneDay_mating_deterministic_Patch'></span>

<h3>Description</h3>

<p>Mating is calculated as the outer product of newly emerging adult females and
all-current adult males, modulated by <code class="reqn">\overline{\overline{\eta}}</code>, the genotype-specific
male mating fitness. <code class="reqn">\overline{\overline{\eta}}</code> corresponds to all female (rows)
and male (columns) genotypes, to perform any type of assortative mating. <br />
If there are no adult males, the unmated females experience one day of death,
calculated as </p>
<p style="text-align: center;"><code class="reqn">\overline{Af_t} * (1-\mu_{ad}) * \overline{\omega_f}</code>
</p>
<p>, and
remain unmated until tomorrow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_mating_deterministic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_mating_stochastic_Patch'>Stochastic Mating</h2><span id='topic+oneDay_mating_stochastic_Patch'></span>

<h3>Description</h3>

<p>Mating for each newly emerging adult female genotype is sampled from a multinomial
distribution with probabilities equal to the adult male population vector
multiplied by <code class="reqn">\overline{\overline{\eta}}</code>, the genotype-specific
male mating fitness. <code class="reqn">\overline{\overline{\eta}}</code> corresponds to all female (rows)
and male (columns) genotypes, to perform any type of assortative mating. <br />
If there are no adult males, the unmated females experience one day of death,
sampled from a binomial distribution parameterized by </p>
<p style="text-align: center;"><code class="reqn">(1-\mu_{ad}) * \overline{\omega_f}</code>
</p>
<p>,
and remain unmated until tomorrow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_mating_stochastic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_Migration_Deterministic_Network'>Deterministic Inter-Patch Migration</h2><span id='topic+oneDay_Migration_Deterministic_Network'></span>

<h3>Description</h3>

<p>Deterministic model of interpatch migration from each patch.
<code>popFemale</code>/<code>popMale</code> is retrieved from each patch using
<code><a href="#topic+get_femalePop_Patch">get_femalePop_Patch</a></code>/<code><a href="#topic+get_malePop_Patch">get_malePop_Patch</a></code>. Migration
location is determined from the supplied matrices, <code>private$migrationFemale</code>
or <code>private$migrationMale</code>. Final migration status is held in
<code>private$fMoveArray</code> or <code>private$mMoveMat</code>. <br />
Batch migration is not used in the deterministic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_Migration_Deterministic_Network()
</code></pre>


<h3>Details</h3>

<p>This function handles outbound and inbound migration. See <code><a href="#topic+MGDrivE-Model">MGDrivE-Model</a></code>,
'Migration' section for more details on how inter-patch migration is handled.
</p>

<hr>
<h2 id='oneDay_Migration_Stochastic_Network'>Stochastic Inter-Patch Migration</h2><span id='topic+oneDay_Migration_Stochastic_Network'></span>

<h3>Description</h3>

<p>Stochastic model of interpatch migration from each patch.
<code>popFemale</code>/<code>popMale</code> is retrieved from each patch using
<code><a href="#topic+get_femalePop_Patch">get_femalePop_Patch</a></code>/<code><a href="#topic+get_malePop_Patch">get_malePop_Patch</a></code>. Migration
location is determined from the supplied matrices, <code>private$migrationFemale</code>
or <code>private$migrationMale</code>. Migration is modeled as a Multinomial
process parameterized by migration location probabilities corresponding to each
patch . Movement is sampled from <code><a href="stats.html#topic+rmultinom">rmultinom</a></code>. <br />
Batch migration begins as a <code><a href="stats.html#topic+rbinom">rbinom</a></code> sampled from
<code>private$migrationBatch$batchProbs</code>.If there is batch migration, the
location of migration is sampled uniformly (see <code><a href="base.html#topic+sample">sample</a></code>),
parameterized by <code>private$migrationBatch$moveProbs</code>. The amount of each sex
that migrations is sampled from <code><a href="stats.html#topic+rbinom">rbinom</a></code>, parameterized by
<code>private$migrationBatch$sexProbs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_Migration_Stochastic_Network()
</code></pre>


<h3>Details</h3>

<p>This function handles outbound and inbound migration. See <code><a href="#topic+MGDrivE-Model">MGDrivE-Model</a></code>,
'Migration' section for more details on how inter-patch migration is handled.
</p>

<hr>
<h2 id='oneDay_migrationIn_Patch'>Inbound Migration</h2><span id='topic+oneDay_migrationIn_Patch'></span>

<h3>Description</h3>

<p>Accumulate all inbound migration to this patch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_migrationIn_Patch(maleIn, femaleIn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneDay_migrationIn_Patch_+3A_malein">maleIn</code></td>
<td>
<p>Vector of inbound migration</p>
</td></tr>
<tr><td><code id="oneDay_migrationIn_Patch_+3A_femalein">femaleIn</code></td>
<td>
<p>Matrix of inbound migration</p>
</td></tr>
</table>

<hr>
<h2 id='oneDay_Network'>Run a Single Day on a Network</h2><span id='topic+oneDay_Network'></span>

<h3>Description</h3>

<p>Runs a single day of simulation on a <code><a href="#topic+Network">Network</a></code> object, handling
population dynamics, migration, population update, and output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_Network()
</code></pre>

<hr>
<h2 id='oneDay_oviposit_deterministic_Patch'>Deterministic Oviposition</h2><span id='topic+oneDay_oviposit_deterministic_Patch'></span>

<h3>Description</h3>

<p>Calculate the number of eggs oviposited by female mosquitoes following:
</p>
<p style="text-align: center;"><code class="reqn">\overline{O(T_x)} = \sum_{j=1}^{n} \Bigg( \bigg( (\beta*\overline{s} * \overline{ \overline{Af_{[t]}}}) * \overline{\overline{\overline{Ih}}} \bigg) * \Lambda \Bigg)^{\top}_{ij}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>oneDay_oviposit_deterministic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_oviposit_stochastic_Patch'>Stochastic Oviposition</h2><span id='topic+oneDay_oviposit_stochastic_Patch'></span>

<h3>Description</h3>

<p>Calculate the number of eggs oviposited by female mosquitoes following:
</p>
<p style="text-align: center;"><code class="reqn">\overline{O(T_x)} = \sum_{j=1}^{n} \Bigg( \bigg( (\beta*\overline{s} * \overline{ \overline{Af_{[t]}}}) * \overline{\overline{\overline{Ih}}} \bigg) * \Lambda  \Bigg)^{\top}_{ij}</code>
</p>

<p>The deterministic result for number of eggs is used as the mean of a Poisson-distributed
number of actual eggs oviposited.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_oviposit_stochastic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_PopDynamics_Patch'>Daily Population Dynamics for a Patch</h2><span id='topic+oneDay_PopDynamics_Patch'></span>

<h3>Description</h3>

<p>Run population dynamics (including migration) for this patch. <br />
Performed in this order, see the following for each function: <br />
Adult Death: <code><a href="#topic+oneDay_adultDeath_deterministic_Patch">oneDay_adultDeath_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_adultDeath_stochastic_Patch">oneDay_adultDeath_stochastic_Patch</a></code> <br />
Pupa Death/Maturation: <code><a href="#topic+oneDay_pupaDM_deterministic_Patch">oneDay_pupaDM_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_pupaDM_stochastic_Patch">oneDay_pupaDM_stochastic_Patch</a></code> <br />
Larva Death/Maturation: <code><a href="#topic+oneDay_larvaDM_deterministic_Patch">oneDay_larvaDM_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_larvaDM_stochastic_Patch">oneDay_larvaDM_stochastic_Patch</a></code> <br />
Egg Death/Maturation: <code><a href="#topic+oneDay_eggDM_deterministic_Patch">oneDay_eggDM_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_eggDM_stochastic_Patch">oneDay_eggDM_stochastic_Patch</a></code> <br />
Pupation: <code><a href="#topic+oneDay_pupation_deterministic_Patch">oneDay_pupation_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_pupation_stochastic_Patch">oneDay_pupation_stochastic_Patch</a></code> <br />
Releases: <code><a href="#topic+oneDay_releases_Patch">oneDay_releases_Patch</a></code> <br />
Mating: <code><a href="#topic+oneDay_mating_deterministic_Patch">oneDay_mating_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_mating_stochastic_Patch">oneDay_mating_stochastic_Patch</a></code> <br />
Lay Eggs: <code><a href="#topic+oneDay_oviposit_deterministic_Patch">oneDay_oviposit_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_oviposit_stochastic_Patch">oneDay_oviposit_stochastic_Patch</a></code> <br />
Release Eggs: <code><a href="#topic+oneDay_eggReleases_Patch">oneDay_eggReleases_Patch</a></code> <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_PopDynamics_Patch()
</code></pre>

<hr>
<h2 id='oneDay_pupaDM_deterministic_Patch'>Deterministic Pupa Death and Pupation</h2><span id='topic+oneDay_pupaDM_deterministic_Patch'></span>

<h3>Description</h3>

<p>Daily pupa survival is calculated according to </p>
<p style="text-align: center;"><code class="reqn">\overline{P_{[t-1]}} * (1-\mu_{aq})</code>
</p>
<p>,
where <code class="reqn">\mu_{aq}</code> corresponds to daily non-density-dependent aquatic mortality. <br />
See <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code> for how these parameters are derived.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_pupaDM_deterministic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_pupaDM_stochastic_Patch'>Stochastic Pupa Death and Pupation</h2><span id='topic+oneDay_pupaDM_stochastic_Patch'></span>

<h3>Description</h3>

<p>Daily pupa survival is sampled from a binomial distribution, where survival
probability is given by </p>
<p style="text-align: center;"><code class="reqn">1-\mu_{aq}</code>
</p>
<p>. <code class="reqn">\mu_{aq}</code> corresponds
to daily non-density-dependent aquatic mortality. <br />
See <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code> for how these parameters are derived.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_pupaDM_stochastic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_pupation_deterministic_Patch'>Deterministic Pupation</h2><span id='topic+oneDay_pupation_deterministic_Patch'></span>

<h3>Description</h3>

<p>Pupa first undergo one extra day of survival, calculated as </p>
<p style="text-align: center;"><code class="reqn">\overline{P_{[t-1]}} * (1-\mu_{ad})</code>
</p>
<p>.
This is an artifact of the conversion from continuous to discrete time (as mentioned
in the original Hancock paper this model is derived from). <br />
Then, pupation into adult males is calculated as </p>
<p style="text-align: center;"><code class="reqn">(1-\overline{\phi}) * \overline{P_{[t]}}</code>
</p>

<p>and into adult females as </p>
<p style="text-align: center;"><code class="reqn">\overline{\phi} * \overline{P_{[t]}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>oneDay_pupation_deterministic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_pupation_stochastic_Patch'>Stochastic Pupation</h2><span id='topic+oneDay_pupation_stochastic_Patch'></span>

<h3>Description</h3>

<p>Pupa first undergo one extra day of survival, calculated as a binomial over
</p>
<p style="text-align: center;"><code class="reqn">\overline{P_{[t-1]}} * (1-\mu_{ad})</code>
</p>
<p>.
This is an artifact of the conversion from continuous to discrete time (as mentioned
in the original Hancock paper this model is derived from). <br />
Then, pupation is sampled from a binomial, where <code class="reqn">(1-\overline{\phi})</code> is
the genotype-specific probability of becoming male, and <code class="reqn">\overline{\phi}</code>
is the genotype-specific of becoming female.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_pupation_stochastic_Patch()
</code></pre>

<hr>
<h2 id='oneDay_releases_Patch'>Release Male/Female/Mated-Female Mosquitoes in a Patch</h2><span id='topic+oneDay_releases_Patch'></span>

<h3>Description</h3>

<p>Based on this patch's release schedule, <code><a href="#topic+generateReleaseVector">generateReleaseVector</a></code>,
this function handles daily releases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_releases_Patch()
</code></pre>

<hr>
<h2 id='oneDay_writeOutput_Patch'>Write Output from Focal Patch</h2><span id='topic+oneDay_writeOutput_Patch'></span>

<h3>Description</h3>

<p>Writes output to the text connections specified in the enclosing <code><a href="#topic+Network">Network</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_writeOutput_Patch()
</code></pre>

<hr>
<h2 id='oneRun_Network'>Run Simulation</h2><span id='topic+oneRun_Network'></span>

<h3>Description</h3>

<p>Run a single simulation on this network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneRun_Network(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneRun_Network_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='parameterizeMGDrivE'>parameterizeMGDrivE</h2><span id='topic+parameterizeMGDrivE'></span>

<h3>Description</h3>

<p>Generate parameters for simulation on a <code><a href="#topic+Network">Network</a></code>.
Parameters include: average generation time <code class="reqn">g</code>, population growth rate <code class="reqn">R_{m}</code>,
aquatic mortality <code class="reqn">\mu_{Aq}</code>, and aquatic survival <code class="reqn">\theta_{Aq}</code>, which
are shared between patches and calculated by <code><a href="#topic+calcAverageGenerationTime">calcAverageGenerationTime</a></code>,
<code><a href="#topic+calcPopulationGrowthRate">calcPopulationGrowthRate</a></code>, and <code><a href="#topic+calcLarvalStageMortalityRate">calcLarvalStageMortalityRate</a></code>. <br />
Patch-specific parameters <code class="reqn">\alpha</code> and <code class="reqn">L_{eq}</code>
are calculated for each patch by <code><a href="#topic+calcDensityDependentDeathRate">calcDensityDependentDeathRate</a></code>
and <code><a href="#topic+calcLarvalPopEquilibrium">calcLarvalPopEquilibrium</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameterizeMGDrivE(
  runID = 1L,
  nPatch,
  simTime,
  sampTime = 1L,
  tEgg = 1L,
  tLarva = 14L,
  tPupa = 1L,
  beta = 32,
  muAd = 0.123,
  popGrowth = 1.096,
  AdPopEQ,
  LarPopRatio,
  AdPopRatio_F,
  AdPopRatio_M,
  inheritanceCube
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameterizeMGDrivE_+3A_runid">runID</code></td>
<td>
<p>Begin counting runs with this set of parameters from this value</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_npatch">nPatch</code></td>
<td>
<p>Number of <code><a href="#topic+Patch">Patch</a></code></p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_simtime">simTime</code></td>
<td>
<p>Maximum time to run simulation</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_samptime">sampTime</code></td>
<td>
<p>Times to sample, used as tNow %% sampTime, default is every day</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_tegg">tEgg</code></td>
<td>
<p>Length of egg stage</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_tlarva">tLarva</code></td>
<td>
<p>Length of larval instar stage</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_tpupa">tPupa</code></td>
<td>
<p>Length of pupal stage</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_beta">beta</code></td>
<td>
<p>Female egg batch size of wild-type</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_muad">muAd</code></td>
<td>
<p>Wild-type daily adult mortality (1/muAd is average wild-type lifespan)</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_popgrowth">popGrowth</code></td>
<td>
<p>Daily population growth rate (used to calculate equilibrium)</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_adpopeq">AdPopEQ</code></td>
<td>
<p>Single number or vector of adult population size at equilibrium
(single number implies all patches have the same population)</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_larpopratio">LarPopRatio</code></td>
<td>
<p>May be empty; if not, a vector gives the wildtype gene frequencies
among larval stages at the beginning of simulation or a matrix provides different
initial frequencies for each patch (every row is a different patch, must have nrow = nPatch)</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_adpopratio_f">AdPopRatio_F</code></td>
<td>
<p>May be empty; if not, a vector gives the wildtype gene frequencies
among adult females at the beginning of simulation or a matrix provides different
initial frequencies for each patch (every row is a different patch, must have nrow = nPatch)</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_adpopratio_m">AdPopRatio_M</code></td>
<td>
<p>May be empty; if not, a vector gives the wildtype gene frequencies
among adult males at the beginning of simulation or a matrix provides different
initial frequencies for each patch (every row is a different patch, must have nrow = nPatch)</p>
</td></tr>
<tr><td><code id="parameterizeMGDrivE_+3A_inheritancecube">inheritanceCube</code></td>
<td>
<p>Inheritance cube to check/set population ratios at the beginning of the simulation</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># using default parameters for 2 patches
#  using different population sizes for patches
simPars &lt;- parameterizeMGDrivE(nPatch = 2, simTime = 365,
                               AdPopEQ = c(100,200), inheritanceCube = cubeMendelian())

</code></pre>

<hr>
<h2 id='Patch'>Patch Class Definition</h2><span id='topic+Patch'></span>

<h3>Description</h3>

<p>A Patch is a single well-mixed population that is the smallest unit of simulation for MGDrivE.
</p>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> generator object
</p>


<h3><strong>Constructor</strong></h3>


<ul>
<li><p> patchID: integer ID of this patch
</p>
</li>
<li><p> genotypesID: character vector of genotypes
</p>
</li>
<li><p> timeAq: integer vector of length 3 specifying the length of each aquatic stage
</p>
</li>
<li><p> numPatches: integer, total number of patches in this simulation
</p>
</li>
<li><p> adultEQ: integer, total adult population in this patch for the duration of the simulation
</p>
</li>
<li><p> larvalEQ: integer, total larval population in this patch for the duration of the simulation
</p>
</li>
<li><p> muAq: double vector, length 3, daily death rate for each aquatic stage
</p>
</li>
<li><p> alpha: double, density-dependent centering parameter, see <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code>
</p>
</li>
<li><p> adultRatioF: named double vector, distribution of adult female genotypes, see <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code>
</p>
</li>
<li><p> adultRatioM: named double vector, distribution of adult male genotypes, see <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code>
</p>
</li>
<li><p> larvalRatio: named double vector, distribution of all aquatic genotypes, see <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code>
</p>
</li>
<li><p> eggReleases: egg release schedule for this patch, see <code><a href="#topic+basicRepeatedReleases">basicRepeatedReleases</a></code>
</p>
</li>
<li><p> maleReleases: male release schedule for this patch, see <code><a href="#topic+basicRepeatedReleases">basicRepeatedReleases</a></code>
</p>
</li>
<li><p> femaleReleases: female release schedule for this patch, see <code><a href="#topic+basicRepeatedReleases">basicRepeatedReleases</a></code>
</p>
</li>
<li><p> matedFemaleReleases: mated females release schedule for this patch, see <code><a href="#topic+basicRepeatedReleases">basicRepeatedReleases</a></code>
</p>
</li></ul>



<h3><strong>Methods</strong></h3>


<ul>
<li><p> set_NetworkPointer: see <code><a href="#topic+set_NetworkPointer_Patch">set_NetworkPointer_Patch</a></code>
</p>
</li>
<li><p> get_femalePopulation: see <code><a href="#topic+get_femalePop_Patch">get_femalePop_Patch</a></code>
</p>
</li>
<li><p> get_malePopulation: see <code><a href="#topic+get_malePop_Patch">get_malePop_Patch</a></code>
</p>
</li>
<li><p> initialPopulation: see <code><a href="#topic+set_initialPopulation_Patch">set_initialPopulation_Patch</a></code>
</p>
</li>
<li><p> setPopulation: see <code><a href="#topic+set_population_deterministic_Patch">set_population_deterministic_Patch</a></code> or <code><a href="#topic+set_population_stochastic_Patch">set_population_stochastic_Patch</a></code>
</p>
</li>
<li><p> reset: see <code><a href="#topic+reset_Patch">reset_Patch</a></code>
</p>
</li>
<li><p> oneDay_initOutput: see <code><a href="#topic+oneDay_initOutput_Patch">oneDay_initOutput_Patch</a></code>
</p>
</li>
<li><p> oneDay_writeOutput: see <code><a href="#topic+oneDay_writeOutput_Patch">oneDay_writeOutput_Patch</a></code>
</p>
</li>
<li><p> oneDay_migrationIn: see <code><a href="#topic+oneDay_migrationIn_Patch">oneDay_migrationIn_Patch</a></code>
</p>
</li>
<li><p> oneDay_PopDynamics: see <code><a href="#topic+oneDay_PopDynamics_Patch">oneDay_PopDynamics_Patch</a></code>
</p>
</li>
<li><p> oneDay_adultD: see <code><a href="#topic+oneDay_adultDeath_deterministic_Patch">oneDay_adultDeath_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_adultDeath_stochastic_Patch">oneDay_adultDeath_stochastic_Patch</a></code>
</p>
</li>
<li><p> oneDay_pupaDM: see <code><a href="#topic+oneDay_pupaDM_deterministic_Patch">oneDay_pupaDM_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_pupaDM_stochastic_Patch">oneDay_pupaDM_stochastic_Patch</a></code>
</p>
</li>
<li><p> oneDay_larvaDM: see <code><a href="#topic+oneDay_larvaDM_deterministic_Patch">oneDay_larvaDM_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_larvaDM_stochastic_Patch">oneDay_larvaDM_stochastic_Patch</a></code>
</p>
</li>
<li><p> oneDay_eggDM: see <code><a href="#topic+oneDay_eggDM_deterministic_Patch">oneDay_eggDM_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_eggDM_stochastic_Patch">oneDay_eggDM_stochastic_Patch</a></code>
</p>
</li>
<li><p> oneDay_pupation: see <code><a href="#topic+oneDay_pupation_deterministic_Patch">oneDay_pupation_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_pupation_stochastic_Patch">oneDay_pupation_stochastic_Patch</a></code>
</p>
</li>
<li><p> oneDay_releases: see <code><a href="#topic+oneDay_releases_Patch">oneDay_releases_Patch</a></code>
</p>
</li>
<li><p> oneDay_releaseEggs: see <code><a href="#topic+oneDay_eggReleases_Patch">oneDay_eggReleases_Patch</a></code>
</p>
</li>
<li><p> oneDay_mating: see <code><a href="#topic+oneDay_mating_deterministic_Patch">oneDay_mating_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_mating_stochastic_Patch">oneDay_mating_stochastic_Patch</a></code>
</p>
</li>
<li><p> oneDay_layEggs: see <code><a href="#topic+oneDay_oviposit_deterministic_Patch">oneDay_oviposit_deterministic_Patch</a></code> or <code><a href="#topic+oneDay_oviposit_stochastic_Patch">oneDay_oviposit_stochastic_Patch</a></code>
</p>
</li></ul>



<h3><strong>Fields</strong></h3>


<ul>
<li><p> patchID: integer ID of this patch
</p>
</li>
<li><p> popAquatic: matrix, nGenotype x sum(timeAquatic), holding all eggs, larva, and pupa
</p>
</li>
<li><p> popMale: vector, nGenotype x 1, holds adult males
</p>
</li>
<li><p> popFemale: matrix, nGenotype x nGenotype, holds mated adult females
</p>
</li>
<li><p> popHolder: vector, nGenotype x 1, temporary population storage
</p>
</li>
<li><p> popPupSex: vector, nGenotype x 1, used in stochastic pupation as another temporary population
</p>
</li>
<li><p> popUnmated: vector, nGenotype x 1, holds unmated females
</p>
</li>
<li><p> popAquatict0: matrix, nGenotype x sum(timeAquatic), holding all eggs, larva, and pupa for reset, see <code><a href="#topic+reset_Patch">reset_Patch</a></code>
</p>
</li>
<li><p> popMalet0: vector, nGenotype x 1, holds adult males for reset see <code><a href="#topic+reset_Patch">reset_Patch</a></code>
</p>
</li>
<li><p> popFemalet0: matrix, nGenotype x nGenotype, holds mated adult females for reset see <code><a href="#topic+reset_Patch">reset_Patch</a></code>
</p>
</li>
<li><p> eggReleases: list of egg releases for this patch. See <code><a href="#topic+oneDay_eggReleases_Patch">oneDay_eggReleases_Patch</a></code>
</p>
</li>
<li><p> maleReleases: list of adult male releases for this patch. See <code><a href="#topic+oneDay_releases_Patch">oneDay_releases_Patch</a></code>
</p>
</li>
<li><p> femaleReleases: list of adult female releases for this patch. See <code><a href="#topic+oneDay_releases_Patch">oneDay_releases_Patch</a></code>
</p>
</li>
<li><p> matedFemaleReleases: list of mated adult female releases for this patch. See <code><a href="#topic+oneDay_releases_Patch">oneDay_releases_Patch</a></code>
</p>
</li>
<li><p> NetworkPointer: a reference to enclosing <code><a href="#topic+Network">Network</a></code>
</p>
</li></ul>


<hr>
<h2 id='plotMGDrivEMult'>Plot</h2><span id='topic+plotMGDrivEMult'></span>

<h3>Description</h3>

<p>Plots several traces from MGDrivE, assuming each set is another repetition
from the same experiment. <br />
Given the readDir, this function assumes the follow file structure: <br />
</p>

<ul>
<li><p> readDir
</p>

<ul>
<li><p> repetition 1
</p>

<ul>
<li><p> patch 1
</p>
</li>
<li><p> patch 2
</p>
</li>
<li><p> patch 3
</p>
</li></ul>

</li>
<li><p> repetition 2
</p>

<ul>
<li><p> patch 1
</p>
</li>
<li><p> patch 2
</p>
</li>
<li><p> patch 3
</p>
</li></ul>

</li>
<li><p> repetition 3
</p>
</li>
<li><p> repetition 4
</p>
</li>
<li><p> ...
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>plotMGDrivEMult(readDir, whichPatches = NULL, totalPop = FALSE,
                       nonZeroGen = FALSE, lwd = 0.75, alpha = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMGDrivEMult_+3A_readdir">readDir</code></td>
<td>
<p>Directory to find repetition folders in</p>
</td></tr>
<tr><td><code id="plotMGDrivEMult_+3A_whichpatches">whichPatches</code></td>
<td>
<p>Vector of patches to plot, must be less than 15. Default is NULL if less than 15 patches</p>
</td></tr>
<tr><td><code id="plotMGDrivEMult_+3A_totalpop">totalPop</code></td>
<td>
<p>Boolean, to plot the total population or not. Default is FALSE</p>
</td></tr>
<tr><td><code id="plotMGDrivEMult_+3A_nonzerogen">nonZeroGen</code></td>
<td>
<p>Boolean, to plot genotypes that are always zero in simulation</p>
</td></tr>
<tr><td><code id="plotMGDrivEMult_+3A_lwd">lwd</code></td>
<td>
<p>Double, specify the line width for plotting</p>
</td></tr>
<tr><td><code id="plotMGDrivEMult_+3A_alpha">alpha</code></td>
<td>
<p>Double, specify the opacity for plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots output from one run or one set of runs after
being analyzed. Setting totalPop to FALSE keeps it from plotting the total
population. NonZeroGen accounts for genotypes that could exist, but are not
created in the simulation. Default is FALSE, as this is easier to read on a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Requires the user to have run MGDrivE, logically stochastic, analyzed
#  the data, and stored it in the directory shown below.
# See vignette for complete example

# Folder where single run is stored
fPath &lt;- "path/to/data/containing/folder"

# plot output to see effect
plotMGDrivEMult(readDir=fPath,totalPop = TRUE,lwd=3.5,alpha=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='plotMGDrivESingle'>Plot</h2><span id='topic+plotMGDrivESingle'></span>

<h3>Description</h3>

<p>Plots one run from MGDrivE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMGDrivESingle(readDir, whichPatches = NULL, totalPop = FALSE,
                         nonZeroGen = FALSE, lwd = 0.75, alpha = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMGDrivESingle_+3A_readdir">readDir</code></td>
<td>
<p>Path to file from single-run of MGDrivE or from analysis function</p>
</td></tr>
<tr><td><code id="plotMGDrivESingle_+3A_whichpatches">whichPatches</code></td>
<td>
<p>Vector of patches to plot, must be less than 15. Default is NULL if less than 15 patches</p>
</td></tr>
<tr><td><code id="plotMGDrivESingle_+3A_totalpop">totalPop</code></td>
<td>
<p>Boolean, to plot the total population or not.</p>
</td></tr>
<tr><td><code id="plotMGDrivESingle_+3A_nonzerogen">nonZeroGen</code></td>
<td>
<p>Boolean, to plot genotypes that are always zero in simulation</p>
</td></tr>
<tr><td><code id="plotMGDrivESingle_+3A_lwd">lwd</code></td>
<td>
<p>Double, specify the line width for plotting</p>
</td></tr>
<tr><td><code id="plotMGDrivESingle_+3A_alpha">alpha</code></td>
<td>
<p>Double, specify the opacity for plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots output from one run or one set of runs after being
analyzed. Setting totalPop to FALSE keeps it from plotting the total population.
NonZeroGen accounts for genotypes that could exist, but are not created in the
simulation. Default is FALSE, as this is easier to read on a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Requires the user to have run MGDrivE, deterministic or stochastic, analyzed
#  the data, and stored it in the directory shown below.
# See vignette for complete example

# Folder where single run is stored
fPath &lt;- "path/to/data/containing/folder"

# plot output to see effect
plotMGDrivESingle(readDir=fPath,totalPop = TRUE,lwd=3.5,alpha=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='quantileC'>Quantiles Function</h2><span id='topic+quantileC'></span>

<h3>Description</h3>

<p>Calculate the given quantiles of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantileC(Trials, Probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantileC_+3A_trials">Trials</code></td>
<td>
<p>Integer matrix to calculate quantiles over</p>
</td></tr>
<tr><td><code id="quantileC_+3A_probs">Probs</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the given quantiles over the rows of an
integer matrix. It uses method 8 of the stat::quantiles() function. It gives
the same result, to numerical accuracy, and is designed to handle matrix input.
It is only designed to work on integer matrices!
</p>


<h3>Value</h3>

<p>Numeric Matrix
</p>

<hr>
<h2 id='rDirichlet'>Dirichlet Distribution</h2><span id='topic+rDirichlet'></span>

<h3>Description</h3>

<p>Make a single draw from a Dirichlet distribution with the shape parameter
one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rDirichlet(migrationPoint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rDirichlet_+3A_migrationpoint">migrationPoint</code></td>
<td>
<p>Vector of weights for draws. Must be positive.</p>
</td></tr>
</table>

<hr>
<h2 id='reset_Network'>Reset Network</h2><span id='topic+reset_Network'></span>

<h3>Description</h3>

<p>Reset a <code><a href="#topic+Network">Network</a></code> between runs, useful for Monte Carlo simulation.
This calls <code><a href="#topic+reset_Patch">reset_Patch</a></code> on each patch
and resets <code>tNow = 2</code> and increments the <code>runID</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_Network(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reset_Network_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='reset_Patch'>Reset Patch to Initial Conditions</h2><span id='topic+reset_Patch'></span>

<h3>Description</h3>

<p>Resets a patch to its initial configuration so that a new one does not have
to be created and allocated in the network (for Monte Carlo simulation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_Patch(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reset_Patch_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='retrieveOutput'>Retrieve Output</h2><span id='topic+retrieveOutput'></span>

<h3>Description</h3>

<p>Read in output from directory. The resulting object will be a nested list;
outermost nesting dimension indexes runID, within runID elements are split by sex
and innermost nesting is over patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieveOutput(readDir, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrieveOutput_+3A_readdir">readDir</code></td>
<td>
<p>Directory where output was written to; must not end in path separator</p>
</td></tr>
<tr><td><code id="retrieveOutput_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nested List
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example assumes user has run and analyzed MGDrivE.
#  See vignette for examples of how to do that.

# set read directory
fPath &lt;- "path/to/split/aggregated/output"

# read in data as nested lists
dataList &lt;- retrieveOutput(readDir = fPath)

## End(Not run)

</code></pre>

<hr>
<h2 id='set_initialPopulation_Patch'>Set Initial Population</h2><span id='topic+set_initialPopulation_Patch'></span>

<h3>Description</h3>

<p>This hidden function distributes the population at time 0 in the steady-state
conformation. This involves finding the number of mosquitoes in each day of the
aquatic stages, and then splitting adults into male and female. Each stage is
appropriately split amongst the initial population genotypes (see <code><a href="#topic+parameterizeMGDrivE">parameterizeMGDrivE</a></code>).
It internally calls <code><a href="#topic+calcLarvalDist">calcLarvalDist</a></code> to determine the distribution
of larvae before setting the eggs and pupa from that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_initialPopulation_Patch(
  adultEQ = adultEQ,
  larvalEQ = larvalEQ,
  adultRatioF = adultRatioF,
  adultRatioM = adultRatioM,
  larvalRatio = larvalRatio,
  timeAq = timeAq,
  muAq = muAq,
  alpha = alpha
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_initialPopulation_Patch_+3A_adulteq">adultEQ</code></td>
<td>
<p>Equilibrium number of adults</p>
</td></tr>
<tr><td><code id="set_initialPopulation_Patch_+3A_larvaleq">larvalEQ</code></td>
<td>
<p>Equilibrium number of larvae</p>
</td></tr>
<tr><td><code id="set_initialPopulation_Patch_+3A_adultratiof">adultRatioF</code></td>
<td>
<p>Genotype specific ratio for adult females</p>
</td></tr>
<tr><td><code id="set_initialPopulation_Patch_+3A_adultratiom">adultRatioM</code></td>
<td>
<p>Genotype specific ratio for adult males</p>
</td></tr>
<tr><td><code id="set_initialPopulation_Patch_+3A_larvalratio">larvalRatio</code></td>
<td>
<p>Genotype specific ratio for larvae</p>
</td></tr>
<tr><td><code id="set_initialPopulation_Patch_+3A_timeaq">timeAq</code></td>
<td>
<p>Time for each aquatic stage</p>
</td></tr>
<tr><td><code id="set_initialPopulation_Patch_+3A_muaq">muAq</code></td>
<td>
<p>Aquatic death rate</p>
</td></tr>
<tr><td><code id="set_initialPopulation_Patch_+3A_alpha">alpha</code></td>
<td>
<p>Density-dependent centering parameter</p>
</td></tr>
</table>

<hr>
<h2 id='set_NetworkPointer_Patch'>Set Network Pointer</h2><span id='topic+set_NetworkPointer_Patch'></span>

<h3>Description</h3>

<p>Set a reference to the enclosing <code><a href="#topic+Network">Network</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_NetworkPointer_Patch(NetworkPointer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_NetworkPointer_Patch_+3A_networkpointer">NetworkPointer</code></td>
<td>
<p>A <code><a href="#topic+Network">Network</a></code> object</p>
</td></tr>
</table>

<hr>
<h2 id='set_population_deterministic_Patch'>Set Initial Population Deterministic</h2><span id='topic+set_population_deterministic_Patch'></span>

<h3>Description</h3>

<p>Calls <code><a href="#topic+set_initialPopulation_Patch">set_initialPopulation_Patch</a></code> to initialize a steady-state
population distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_population_deterministic_Patch(
  adultEQ = adultEQ,
  larvalEQ = larvalEQ,
  adultRatioF = adultRatioF,
  adultRatioM = adultRatioM,
  larvalRatio = larvalRatio,
  timeAq = timeAq,
  muAq = muAq,
  alpha = alpha
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_population_deterministic_Patch_+3A_adulteq">adultEQ</code></td>
<td>
<p>Equilibrium number of adults</p>
</td></tr>
<tr><td><code id="set_population_deterministic_Patch_+3A_larvaleq">larvalEQ</code></td>
<td>
<p>Equilibrium number of larvae</p>
</td></tr>
<tr><td><code id="set_population_deterministic_Patch_+3A_adultratiof">adultRatioF</code></td>
<td>
<p>Genotype specific ratio for adult females</p>
</td></tr>
<tr><td><code id="set_population_deterministic_Patch_+3A_adultratiom">adultRatioM</code></td>
<td>
<p>Genotype specific ratio for adult males</p>
</td></tr>
<tr><td><code id="set_population_deterministic_Patch_+3A_larvalratio">larvalRatio</code></td>
<td>
<p>Genotype specific ratio for larvae</p>
</td></tr>
<tr><td><code id="set_population_deterministic_Patch_+3A_timeaq">timeAq</code></td>
<td>
<p>Time for each aquatic stage</p>
</td></tr>
<tr><td><code id="set_population_deterministic_Patch_+3A_muaq">muAq</code></td>
<td>
<p>Aquatic death rate</p>
</td></tr>
<tr><td><code id="set_population_deterministic_Patch_+3A_alpha">alpha</code></td>
<td>
<p>Density-dependent centering parameter</p>
</td></tr>
</table>

<hr>
<h2 id='set_population_stochastic_Patch'>Set Initial Population Stochastic</h2><span id='topic+set_population_stochastic_Patch'></span>

<h3>Description</h3>

<p>Calls <code><a href="#topic+set_initialPopulation_Patch">set_initialPopulation_Patch</a></code> to initialize a steady-state
population distribution. Populations are then rounded to integer values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_population_stochastic_Patch(
  adultEQ = adultEQ,
  larvalEQ = larvalEQ,
  adultRatioF = adultRatioF,
  adultRatioM = adultRatioM,
  larvalRatio = larvalRatio,
  timeAq = timeAq,
  muAq = muAq,
  alpha = alpha
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_population_stochastic_Patch_+3A_adulteq">adultEQ</code></td>
<td>
<p>Equilibrium number of adults</p>
</td></tr>
<tr><td><code id="set_population_stochastic_Patch_+3A_larvaleq">larvalEQ</code></td>
<td>
<p>Equilibrium number of larvae</p>
</td></tr>
<tr><td><code id="set_population_stochastic_Patch_+3A_adultratiof">adultRatioF</code></td>
<td>
<p>Genotype specific ratio for adult females</p>
</td></tr>
<tr><td><code id="set_population_stochastic_Patch_+3A_adultratiom">adultRatioM</code></td>
<td>
<p>Genotype specific ratio for adult males</p>
</td></tr>
<tr><td><code id="set_population_stochastic_Patch_+3A_larvalratio">larvalRatio</code></td>
<td>
<p>Genotype specific ratio for larvae</p>
</td></tr>
<tr><td><code id="set_population_stochastic_Patch_+3A_timeaq">timeAq</code></td>
<td>
<p>Time for each aquatic stage</p>
</td></tr>
<tr><td><code id="set_population_stochastic_Patch_+3A_muaq">muAq</code></td>
<td>
<p>Aquatic death rate</p>
</td></tr>
<tr><td><code id="set_population_stochastic_Patch_+3A_alpha">alpha</code></td>
<td>
<p>Density-dependent centering parameter</p>
</td></tr>
</table>

<hr>
<h2 id='setupMGDrivE'>Setup MGDrivE</h2><span id='topic+setupMGDrivE'></span>

<h3>Description</h3>

<p>Initialize methods in <code><a href="#topic+Patch">Patch</a></code> to run deterministic or stochastic simulations.
This sets internal function definitions so that <code><a href="#topic+oneRun_Network">oneRun_Network</a></code>
and <code><a href="#topic+multRun_Network">multRun_Network</a></code> run either deterministic or stochastic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupMGDrivE(stochasticityON = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setupMGDrivE_+3A_stochasticityon">stochasticityON</code></td>
<td>
<p>Enable/disable stochastic simulation. Default is FALSE, implying deterministic simulation</p>
</td></tr>
<tr><td><code id="setupMGDrivE_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># run deterministic MGDrivE
setupMGDrivE(stochasticityON = FALSE)

# run stochastic MGDrivE
setupMGDrivE(stochasticityON = TRUE)

</code></pre>

<hr>
<h2 id='splitOutput'>Split Output by Patch</h2><span id='topic+splitOutput'></span>

<h3>Description</h3>

<p>Split output into multiple files by patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitOutput(readDir, writeDir = NULL, remFile = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitOutput_+3A_readdir">readDir</code></td>
<td>
<p>Directory where output was written to</p>
</td></tr>
<tr><td><code id="splitOutput_+3A_writedir">writeDir</code></td>
<td>
<p>Directory to write output to. Default is readDir</p>
</td></tr>
<tr><td><code id="splitOutput_+3A_remfile">remFile</code></td>
<td>
<p>Remove original output? Default is TRUE</p>
</td></tr>
<tr><td><code id="splitOutput_+3A_verbose">verbose</code></td>
<td>
<p>Chatty? Default is TRUE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This example assumes user has already run MGDrivE and generated output.
#  If that's untree, see vignette for complete example
fPath &lt;- "path/to/data/containing/folder"
oPath &lt;- "path/to/write/output"

# split data by patch, keep original files
#  no return value
splitOutput(readDir = fPath, writeDir = oPath, remFile = FALSE)

# Alternatively, remove the original files and write new ones in their place
fPath &lt;- "path/to/data/containing/folder"

splitOutput(readDir = fPath, writeDir = NULL, remFile = TRUE)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
