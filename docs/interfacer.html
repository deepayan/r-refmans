<!DOCTYPE html><html lang="en-GB"><head><title>Help for package interfacer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {interfacer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#as.list.iface'><p>Cast an <code>iface</code> to a plain list.</p></a></li>
<li><a href='#check_character'><p>Checks a set of variables can be coerced to a character and coerces them</p></a></li>
<li><a href='#check_consistent'><p>Check function parameters conform to a set of rules</p></a></li>
<li><a href='#check_date'><p>Checks a set of variables can be coerced to a date and coerces them</p></a></li>
<li><a href='#check_integer'><p>Checks a set of variables can be coerced to integer and coerces them</p></a></li>
<li><a href='#check_logical'><p>Checks a set of variables can be coerced to a logical and coerces them</p></a></li>
<li><a href='#check_numeric'><p>Checks a set of variables can be coerced to numeric and coerces them</p></a></li>
<li><a href='#check_single'><p>Checks a set of variables are all of length one</p></a></li>
<li><a href='#format.iface'><p>Format an <code>iface</code> specification for printing</p></a></li>
<li><a href='#iclip'><p>Create an <code>iface</code> specification from an example dataframe</p></a></li>
<li><a href='#iconvert'><p>Convert a dataframe to a format compatible with an interface specification</p></a></li>
<li><a href='#idispatch'><p>Dispatch to a named function based on the characteristics of a dataframe</p></a></li>
<li><a href='#idocument'><p>Document an interface contract for inserting into <code>roxygen2</code></p></a></li>
<li><a href='#if_col_present'><p>Execute a function or return a value if a column in present in a dataframe</p></a></li>
<li><a href='#iface'><p>Construct an interface specification</p></a></li>
<li><a href='#igroup_process'><p>Handle unexpected additional grouping structure</p></a></li>
<li><a href='#imapper'><p>Specify mappings that can make dataframes compatible with an <code>iface</code> specification</p></a></li>
<li><a href='#iproto'><p>Generate a zero length dataframe conforming to an <code>iface</code> specification</p></a></li>
<li><a href='#ireturn'><p>Check a return parameter from a function</p></a></li>
<li><a href='#is_col_present'><p>Check for existence of a set of columns in a dataframe</p></a></li>
<li><a href='#is.iface'><p>Check if an object is an interface specification</p></a></li>
<li><a href='#itest'><p>Test dataframe conformance to an interface specification.</p></a></li>
<li><a href='#ivalidate'><p>Perform interface checks on dataframe inputs using enclosing function formal</p>
parameter definitions</a></li>
<li><a href='#knit_print.iface'><p>Format an <code>iface</code> specification for printing</p></a></li>
<li><a href='#print.iface'><p>Format an <code>iface</code> specification for printing</p></a></li>
<li><a href='#recycle'><p>Strictly recycle function parameters</p></a></li>
<li><a href='#resolve_missing'><p>Resolve missing values in function parameters and check consistency</p></a></li>
<li><a href='#roxy_tag_parse.roxy_tag_iparam'><p>Parser for <code style="white-space: pre;">&#8288;@iparam&#8288;</code> tags</p></a></li>
<li><a href='#roxy_tag_rd.roxy_tag_iparam'><p>Support for <code style="white-space: pre;">&#8288;@iparam&#8288;</code> tags</p></a></li>
<li><a href='#switch_pipeline'><p>Branch a <code>dplyr</code> pipeline based on a set of conditions</p></a></li>
<li><a href='#type.anything'><p>Coerce to an unspecified type</p></a></li>
<li><a href='#type.character'><p>Coerce to a character.</p></a></li>
<li><a href='#type.complete'><p>Coerce to a complete set of values.</p></a></li>
<li><a href='#type.date'><p>Coerce to a Date.</p></a></li>
<li><a href='#type.default'><p>Set a default value for a column</p></a></li>
<li><a href='#type.double'><p>Coerce to a double.</p></a></li>
<li><a href='#type.enum'><p>Define a conformance rule to match a factor with specific levels.</p></a></li>
<li><a href='#type.factor'><p>Coerce to a factor.</p></a></li>
<li><a href='#type.finite'><p>Check for non-finite values</p></a></li>
<li><a href='#type.group_unique'><p>Coerce to a unique value within the current grouping structure.</p></a></li>
<li><a href='#type.in_range'><p>Define a conformance rule to confirm that a numeric is in a set range</p></a></li>
<li><a href='#type.integer'><p>Coerce to integer</p></a></li>
<li><a href='#type.logical'><p>Coerce to a logical</p></a></li>
<li><a href='#type.not_missing'><p>Check for missing values</p></a></li>
<li><a href='#type.numeric'><p>Coerce to a numeric.</p></a></li>
<li><a href='#type.of_type'><p>Check for a given class</p></a></li>
<li><a href='#type.positive_double'><p>Coerce to a positive double.</p></a></li>
<li><a href='#type.positive_integer'><p>Coerce to a positive integer.</p></a></li>
<li><a href='#type.proportion'><p>Coerce to a number between 0 and 1</p></a></li>
<li><a href='#type.unique_id'><p>A globally unique ids.</p></a></li>
<li><a href='#use_dataframe'><p>Use a dataframe in a package including structure based documentation</p></a></li>
<li><a href='#use_iface'><p>Generate interfacer code for a dataframe</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Define and Enforce Contracts for Dataframes as Function
Parameters</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A dataframe validation framework for package builders who use
  dataframes as function parameters. It performs checks on column names, coerces
  data-types, and checks grouping to make sure user inputs conform to a
  specification provided by the package author. It provides a mechanism for
  package authors to automatically document supported dataframe inputs and
  selectively dispatch to functions depending on the format of a dataframe much
  like S3 does for classes. It also contains some developer tools to make
  working with and documenting dataframe specifications easier. It helps package
  developers to improve their documentation and simplifies parameter validation
  where dataframes are used as function parameters.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2.9003</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, glue, magrittr, purrr, rlang, tibble, tidyselect,
stringr, forcats, knitr, digest, roxygen2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, devtools, ggplot2, testthat (&ge; 3.0.0), fs, readr,
usethis, whisker, clipr, tidyr, binom, spelling</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ai4ci.github.io/interfacer/">https://ai4ci.github.io/interfacer/</a>,
<a href="https://github.com/ai4ci/interfacer">https://github.com/ai4ci/interfacer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ai4ci/interfacer/issues">https://github.com/ai4ci/interfacer/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-03 16:42:54 UTC; vp22681</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert Challen <a href="https://orcid.org/0000-0002-5504-7768"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert Challen &lt;rob.challen@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-03 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='as.list.iface'>Cast an <code>iface</code> to a plain list.</h2><span id='topic+as.list.iface'></span>

<h3>Description</h3>

<p>Cast an <code>iface</code> to a plain list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iface'
as.list(x, ..., flatten = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.list.iface_+3A_x">x</code></td>
<td>
<p>object to be coerced or tested.</p>
</td></tr>
<tr><td><code id="as.list.iface_+3A_...">...</code></td>
<td>
<p>objects, possibly named.</p>
</td></tr>
<tr><td><code id="as.list.iface_+3A_flatten">flatten</code></td>
<td>
<p>get a list of lists representation instead
of the dataframe column by column list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list representation of the <code>iface</code> input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_iface = iface( 
  col1 = integer + group_unique ~ "an integer column"
)

as.list(my_iface, flatten=TRUE)
</code></pre>

<hr>
<h2 id='check_character'>Checks a set of variables can be coerced to a character and coerces them</h2><span id='topic+check_character'></span>

<h3>Description</h3>

<p>Checks a set of variables can be coerced to a character and coerces them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_character(
  ...,
  .message = "`{param}` is not a character: ({err}).",
  .env = rlang::caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_character_+3A_...">...</code></td>
<td>
<p>a list of symbols</p>
</td></tr>
<tr><td><code id="check_character_+3A_.message">.message</code></td>
<td>
<p>a glue specification containing <code>{param}</code> as the name of the
parameter and <code>{err}</code> the cause of the error</p>
</td></tr>
<tr><td><code id="check_character_+3A_.env">.env</code></td>
<td>
<p>the environment to check (defaults to calling environment)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. called for side effects. throws error if not all variables can be coerced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(Sys.Date()+1:10)
b = format(a)
f = iris$Species
g = NA
check_character(a,b,f,g)
</code></pre>

<hr>
<h2 id='check_consistent'>Check function parameters conform to a set of rules</h2><span id='topic+check_consistent'></span>

<h3>Description</h3>

<p>If the parameters of a function are given in some combination but have
an interdependency (e.g. different parametrisations of a probability
distribution) or a constraint (like <code>x&gt;0</code>) this function can simultaneously
check all interrelations are satisfied and report on all the not
conformant features of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_consistent(..., .env = rlang::caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_consistent_+3A_...">...</code></td>
<td>
<p>a set of rules to check either as <code>x=y+z</code>, or <code>x&gt;y</code>. Single <code>=</code>
assignment is checked for equality using <code>identical</code> otherwise the
expressions are evaluated and checked they all are true. This for
consistency with <code><a href="#topic+resolve_missing">resolve_missing()</a></code> which only uses assignment, and ignores
logical expressions.</p>
</td></tr>
<tr><td><code id="check_consistent_+3A_.env">.env</code></td>
<td>
<p>the environment to check in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, throws an informative error if the checks fail.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testfn = function(pos, neg, n) {
  check_consistent(pos=n-neg, neg=n-pos, n=pos+neg, n&gt;pos, n&gt;neg)
}

testfn(pos = 1:4, neg=4:1, n=rep(5,4))
try(testfn(pos = 1:4, neg=5:2, n=rep(5,4)))
</code></pre>

<hr>
<h2 id='check_date'>Checks a set of variables can be coerced to a date and coerces them</h2><span id='topic+check_date'></span>

<h3>Description</h3>

<p>Checks a set of variables can be coerced to a date and coerces them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_date(
  ...,
  .message = "`{param}` is not a date: ({err}).",
  .env = rlang::caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_date_+3A_...">...</code></td>
<td>
<p>a list of symbols</p>
</td></tr>
<tr><td><code id="check_date_+3A_.message">.message</code></td>
<td>
<p>a glue specification containing <code>{param}</code> as the name of the
parameter and <code>{err}</code> the cause of the error</p>
</td></tr>
<tr><td><code id="check_date_+3A_.env">.env</code></td>
<td>
<p>the environment to check (defaults to calling environment)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. called for side effects. throws error if not all variables can be coerced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(Sys.Date()+1:10)
b = format(a)
f = "1970-01-01"
g = NA
check_date(a,b,f,g)

c = c("dfsfs")
try(check_date(c,d, mean))
</code></pre>

<hr>
<h2 id='check_integer'>Checks a set of variables can be coerced to integer and coerces them</h2><span id='topic+check_integer'></span>

<h3>Description</h3>

<p>N.B. This only works for the specific environment (to prevent weird side effects)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_integer(
  ...,
  .message = "`{param}` is not an integer ({err}).",
  .env = rlang::caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_integer_+3A_...">...</code></td>
<td>
<p>a list of symbols</p>
</td></tr>
<tr><td><code id="check_integer_+3A_.message">.message</code></td>
<td>
<p>a glue specification containing <code>{param}</code> as the name of the
parameter and <code>{err}</code> the cause of the error</p>
</td></tr>
<tr><td><code id="check_integer_+3A_.env">.env</code></td>
<td>
<p>the environment to check (defaults to calling environment)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. called for side effects. throws error if not all variables can be coerced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(1:4)
b = c("1",NA,"3")
f = NULL
g = NA
check_integer(a,b,f,g)

c = c("dfsfs")
e = c(1.0,2.3)
try(check_integer(c,d,e, mean))
</code></pre>

<hr>
<h2 id='check_logical'>Checks a set of variables can be coerced to a logical and coerces them</h2><span id='topic+check_logical'></span>

<h3>Description</h3>

<p>Checks a set of variables can be coerced to a logical and coerces them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_logical(
  ...,
  .message = "`{param}` is not a logical: ({err}).",
  .env = rlang::caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_logical_+3A_...">...</code></td>
<td>
<p>a list of symbols</p>
</td></tr>
<tr><td><code id="check_logical_+3A_.message">.message</code></td>
<td>
<p>a glue specification containing <code>{param}</code> as the name of the
parameter and <code>{err}</code> the cause of the error</p>
</td></tr>
<tr><td><code id="check_logical_+3A_.env">.env</code></td>
<td>
<p>the environment to check (defaults to calling environment)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. called for side effects. throws error if not all variables can be coerced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c("T","F")
b = c(1,0,1,0)
f = TRUE
g = NA
check_logical(a,b,f,g)

c = c("dfsfs")
try(check_logical(c,d, mean))
</code></pre>

<hr>
<h2 id='check_numeric'>Checks a set of variables can be coerced to numeric and coerces them</h2><span id='topic+check_numeric'></span>

<h3>Description</h3>

<p>N.B. This only works for the specific environment (to prevent weird side effects)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_numeric(
  ...,
  .message = "`{param}` is non-numeric ({err}).",
  .env = rlang::caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_numeric_+3A_...">...</code></td>
<td>
<p>a list of symbols</p>
</td></tr>
<tr><td><code id="check_numeric_+3A_.message">.message</code></td>
<td>
<p>a glue specification containing <code>{param}</code> as the name of the
parameter and <code>{err}</code> the cause of the error</p>
</td></tr>
<tr><td><code id="check_numeric_+3A_.env">.env</code></td>
<td>
<p>the environment to check (defaults to calling environment)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. called for side effects. throws error if not all variables can be coerced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(1:4L)
b = c("1",NA,"3.3")
f = NULL
g = NA
check_numeric(a,b,f,g)

c = c("dfsfs")
try(check_numeric(c,d, mean))
</code></pre>

<hr>
<h2 id='check_single'>Checks a set of variables are all of length one</h2><span id='topic+check_single'></span>

<h3>Description</h3>

<p>Checks a set of variables are all of length one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_single(
  ...,
  .message = "`{param}` is not length one: ({err}).",
  .env = rlang::caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_single_+3A_...">...</code></td>
<td>
<p>a list of symbols</p>
</td></tr>
<tr><td><code id="check_single_+3A_.message">.message</code></td>
<td>
<p>a glue specification containing <code>{param}</code> as the name of the
parameter and <code>{err}</code> the cause of the error</p>
</td></tr>
<tr><td><code id="check_single_+3A_.env">.env</code></td>
<td>
<p>the environment to check (defaults to calling environment)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. called for side effects. throws error if not all variables can be coerced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = 1
b = "Hello"
g = NA
check_single(a,b,g)

c= c(1,2,3)
d=list(a,b)
try(check_single(c,d,missing))
</code></pre>

<hr>
<h2 id='format.iface'>Format an <code>iface</code> specification for printing</h2><span id='topic+format.iface'></span>

<h3>Description</h3>

<p>Format an <code>iface</code> specification for printing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iface'
format(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format.iface_+3A_x">x</code></td>
<td>
<p>an <code>iface</code> specification</p>
</td></tr>
<tr><td><code id="format.iface_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a formatted string representation of an <code>iface</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_iface = iface( 
  col1 = integer + group_unique ~ "an integer column"
)

print(my_iface)
knitr::knit_print(my_iface)
</code></pre>

<hr>
<h2 id='iclip'>Create an <code>iface</code> specification from an example dataframe</h2><span id='topic+iclip'></span>

<h3>Description</h3>

<p>When developing with <code>interfacer</code> it is useful to be able to base a function
input off a prototype that you are for example using as testing. This
function generates an <code>interfacer::iface</code> specification for the supplied data
frame and copies it  to the clipboard so that it can be pasted into the
package code you are working on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iclip(df, df_name = deparse(substitute(df)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iclip_+3A_df">df</code></td>
<td>
<p>a prototype dataframe</p>
</td></tr>
<tr><td><code id="iclip_+3A_df_name">df_name</code></td>
<td>
<p>an optional name for the parameter (defaults to <code style="white-space: pre;">&#8288;i_&lt;df name&gt;&#8288;</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the dataframe contains one or more list columns with nested dataframes
the nested dataframes are also defined using a second <code>iface</code> specification.
</p>


<h3>Value</h3>

<p>nothing, populates clipboard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) iclip(iris)
</code></pre>

<hr>
<h2 id='iconvert'>Convert a dataframe to a format compatible with an interface specification</h2><span id='topic+iconvert'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+ivalidate">ivalidate()</a></code> and is not generally intended to be
used directly by the end user. It may be helpful in debugging during package
development to interactive test a <code>iface</code> spec. <code>iconvert</code> is an interactive
version of <code><a href="#topic+ivalidate">ivalidate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iconvert(
  df,
  iface,
  .imap = interfacer::imapper(),
  .dname = "&lt;unknown&gt;",
  .fname = "&lt;unknown&gt;",
  .has_dots = TRUE,
  .prune = FALSE,
  .env = rlang::current_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iconvert_+3A_df">df</code></td>
<td>
<p>the dataframe to convert</p>
</td></tr>
<tr><td><code id="iconvert_+3A_iface">iface</code></td>
<td>
<p>the interface spec as an <code>iface</code></p>
</td></tr>
<tr><td><code id="iconvert_+3A_.imap">.imap</code></td>
<td>
<p>an optional <code>imapper</code> mapping</p>
</td></tr>
<tr><td><code id="iconvert_+3A_.dname">.dname</code></td>
<td>
<p>the name of the parameter value (optional).</p>
</td></tr>
<tr><td><code id="iconvert_+3A_.fname">.fname</code></td>
<td>
<p>the name of the function (optional).</p>
</td></tr>
<tr><td><code id="iconvert_+3A_.has_dots">.has_dots</code></td>
<td>
<p>internal library use only. Changes the nature of the error message.</p>
</td></tr>
<tr><td><code id="iconvert_+3A_.prune">.prune</code></td>
<td>
<p>do you want to remove non matching columns?</p>
</td></tr>
<tr><td><code id="iconvert_+3A_.env">.env</code></td>
<td>
<p>internal use only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input dataframe coerced to be conformant to the <code>iface</code>
specification, or an informative error is thrown.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i_diamonds = iface( 
  color = enum(D,E,F,G,H,I,J,extra) ~ "the colour", 
  price = integer ~ "the price"
)

iconvert(ggplot2::diamonds, i_diamonds,.prune = TRUE)


</code></pre>

<hr>
<h2 id='idispatch'>Dispatch to a named function based on the characteristics of a dataframe</h2><span id='topic+idispatch'></span>

<h3>Description</h3>

<p>This provides a dataframe analogy to S3 dispatch. If multiple possible
dataframe formats are possible for a function, each with different processing
requirements, then the choice of function can be made based on matching the
input dataframe to a set of <code>iface</code> specifications. The first matching
<code>iface</code> specification determines which function is used for dispatch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idispatch(x, ..., .default = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idispatch_+3A_x">x</code></td>
<td>
<p>a dataframe</p>
</td></tr>
<tr><td><code id="idispatch_+3A_...">...</code></td>
<td>
<p>a set of <code style="white-space: pre;">&#8288;function name&#8288;</code>=<code>interfacer::iface</code> pairs</p>
</td></tr>
<tr><td><code id="idispatch_+3A_.default">.default</code></td>
<td>
<p>a function to apply in the situation where none of the rules
can be matched. The default results in an error being thrown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the result of dispatching the dataframe to the first function that
matches the rules in <code>...</code>. Matching is permissive in that the test is
passed if a dataframe can be coerced to the <code>iface</code> specified format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 = iface( col1 = integer ~ "An integer column" )
i2 = iface( col2 = integer ~ "A different integer column" )

# this is an example function that would typically be inside a package, and
# is exported from the package.
extract_mean = function(df, ...) {
  idispatch(df,
    extract_mean.i1 = i1,
    extract_mean.i2 = i2
  )
}

# this is expected to be an internal package function
# the naming convention here is based on S3 but it is not required
extract_mean.i1 = function(df = i1, ...) {
  message("using i1")
  # input validation is not required in functions that are being called using
  # `idispatch` as the validation occurs during dispatch. 
  mean(df$col1)
}

extract_mean.i2 = function(df = i2, uplift = 1, ...) {
  message("using i2")
  mean(df$col2)+uplift
}

# this input matches `i1` and the `extract_mean` call is dispatched 
# via `extract_mean.i1`
test = tibble::tibble( col2 = 1:10 )
extract_mean(test, uplift = 50)

# this input matches `i2` and the `extract_mean` call is dispatched 
# via `extract_mean.i2`
test2 = tibble::tibble( col1 = 1:10 )
extract_mean(test2, uplift = 50)

# This input does not match any of the allowable input specifications and 
# generates an error.
test3 = tibble::tibble( wrong_col = 1:10 )
try(extract_mean(test3, uplift = 50))
</code></pre>

<hr>
<h2 id='idocument'>Document an interface contract for inserting into <code>roxygen2</code></h2><span id='topic+idocument'></span>

<h3>Description</h3>

<p>This function is expected to be called within the documentation of a function
as inline code in the parameter documentation of the function. It details the
expected columns that the input dataframe should possess. This has mostly
been superseded by the <code style="white-space: pre;">&#8288;@iparam &lt;name&gt; &lt;description&gt;&#8288;</code> <code>roxygen2</code> tag which does
this automatically, however in some circumstances (particularly multiple
dispatch) you may want to assemble dataframe documentation manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idocument(fn, param = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idocument_+3A_fn">fn</code></td>
<td>
<p>the function that you are documenting</p>
</td></tr>
<tr><td><code id="idocument_+3A_param">param</code></td>
<td>
<p>the parameter you are documenting (optional. if missing defaults
to the first argument of the function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a markdown snippet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' @param df `r idocument(x, df)`
x = function(df = iface( col1 = integer ~ "an integer column" )) {}

cat(idocument(x, df))
</code></pre>

<hr>
<h2 id='if_col_present'>Execute a function or return a value if a column in present in a dataframe</h2><span id='topic+if_col_present'></span>

<h3>Description</h3>

<p>The simple use case. For more complex behaviour see <code>switch_pipeline()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_col_present(df, col, if_present, if_missing = ~.x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="if_col_present_+3A_df">df</code></td>
<td>
<p>a dataframe</p>
</td></tr>
<tr><td><code id="if_col_present_+3A_col">col</code></td>
<td>
<p>a column name</p>
</td></tr>
<tr><td><code id="if_col_present_+3A_if_present">if_present</code></td>
<td>
<p>a <code>purrr</code> style function to execute on the dataframe if the
column is present (or a plain value)</p>
</td></tr>
<tr><td><code id="if_col_present_+3A_if_missing">if_missing</code></td>
<td>
<p>a <code>purrr</code> style function to execute on the dataframe if the
column is missing (or a plain value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either the value of <code>if_present</code>/<code>if_absent</code> or the result of calling
<code>if_present</code>/<code>if_absent</code> as functions on <code>df</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% if_col_present(Species, ~ .x %&gt;% dplyr::rename(new = Species)) %&gt;%
  colnames()

# in contrast to `purrr` absolute values are not interpreted as function names  
iris %&gt;% if_col_present(Species2, "Yes", "No")

</code></pre>

<hr>
<h2 id='iface'>Construct an interface specification</h2><span id='topic+iface'></span>

<h3>Description</h3>

<p>An <code>iface</code> specification defines the expected structure of a dataframe, in
terms of the column names, column types, grouping structure and uniqueness
constraints that the dataframe must conform to. A dataframe can be tested
for conformance to an <code>iface</code> specification using <code><a href="#topic+ivalidate">ivalidate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iface(..., .groups = NULL, .default = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iface_+3A_...">...</code></td>
<td>
<p>The specification of the interface (see details), or an unnamed
<code>iface</code> object to extend, or both.</p>
</td></tr>
<tr><td><code id="iface_+3A_.groups">.groups</code></td>
<td>
<p>either <code>FALSE</code> for no grouping allowed or a formula of the form
<code>~ var1 + var2 + ...</code> which defines what columns must be grouped in the dataframe
(and in which order). If <code>NULL</code> (the default) then any grouping is permitted.
If the formula contains a dot e.g. <code>~ . + var1 + var2</code> then the grouping
must include <code>var1</code> and <code>var2</code> but other groups are also allowed.</p>
</td></tr>
<tr><td><code id="iface_+3A_.default">.default</code></td>
<td>
<p>a default value to supply if there is nothing given in a
function parameter using the <code>iface</code> as a formal. This is either <code>NULL</code> in
which case there is no default, <code>TRUE</code> in which case the default is a zero
row dataframe conforming to the specification, or a provided dataframe,
which is checked to conform, and used as the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>iface</code> specification is designed to be used to define the type of a
parameter in a function. This is done by using the <code>iface</code> specification as
the default value of the parameter in the function definition. The definition
can then be validated at runtime by a call to <code><a href="#topic+ivalidate">ivalidate()</a></code> inside the
function.
</p>
<p>When developing a function output an <code>iface</code> specification may also be used
in <code><a href="#topic+ireturn">ireturn()</a></code> to enforce that the output of a function is correct.
</p>
<p><code>iface</code> definitions can be printed and included in <code>roxygen2</code> documentation
and help us to document input dataframe parameters and dataframe return
values in a standardised way by using the <code style="white-space: pre;">&#8288;@iparam&#8288;</code> <code>roxygen2</code> tag.
</p>
<p><code>iface</code> specifications are defined in the form of a named list of formulae with the
structure <code>column_name = type ~ "documentation"</code>.
</p>
<p><code>type</code> can be one of <code>anything</code>, <code>character</code>, <code>complete</code>, <code>date</code>, <code>default</code>, <code>double</code>, <code>enum</code>, <code>factor</code>, <code>finite</code>, <code>group_unique</code>, <code>in_range</code>, <code>integer</code>, <code>logical</code>, <code>not_missing</code>, <code>numeric</code>, <code>of_type</code>, <code>positive_double</code>, <code>positive_integer</code>, <code>proportion</code>, <code>unique_id</code> (e.g. <code>enum(level1,level2,...)</code>,
<code>in_range(min,max)</code>) or alternatively anything that resolves to a function e.g.
<code>as.ordered</code>.
</p>
<p>If <code>type</code> is a function name, then the function must take a single vector
parameter and return a single vector of the same size. The function must also
return a zero length vector of an appropriate type if passed <code>NULL</code>.
</p>
<p><code>type</code> can also be a concatenation of rules separated by <code>+</code>, e.g.
<code>integer + group_unique</code> for an integer that is unique within a group.
</p>


<h3>Value</h3>

<p>the definition of an interface as a <code>iface</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test_df = tibble::tibble(
  grp = c(rep("a",10),rep("b",10)), 
  col1 = c(1:10,1:10)
) %&gt;% dplyr::group_by(grp)

my_iface = iface( 
  col1 = integer + group_unique ~ "an integer column",
  .default = test_df
)

print(my_iface)

# the function x defines a formal `df` with default value of `my_iface`
# this default value is used to validate the structure of the user supplied
# value when the function is called.
x = function(df = my_iface, ...) {
  df = ivalidate(df,...)
  return(df)
}

# this works
x(tibble::tibble(col1 = c(1,2,3)))

# this fails as x is of the wrong type
try(x(tibble::tibble(col1 = c("a","b","c"))))

# this fails as x has duplicates
try(x(tibble::tibble(col1 = c(1,2,3,3))))

# this gives the default value
x()


my_iface2 = iface(
  first_col = numeric ~ "column order example",
  my_iface, 
  last_col = character ~ "another col", .groups = ~ first_col + col1
)
print(my_iface2)



my_iface_3 = iface( 
  col1 = integer + group_unique ~ "an integer column",
  .default = test_df_2
)
x = function(d = my_iface_3) {ivalidate(d)}

# Doesn't work as test_df_2 hasn't been defined
try(x())

test_df_2 = tibble::tibble(
  grp = c(rep("a",10),rep("b",10)), 
  col1 = c(1:10,1:10)
) %&gt;% dplyr::group_by(grp)

# now it works as has been defined
x()

# it still works as default has been cached.
rm(test_df_2)
x()
</code></pre>

<hr>
<h2 id='igroup_process'>Handle unexpected additional grouping structure</h2><span id='topic+igroup_process'></span>

<h3>Description</h3>

<p>This function is designed to be used by a package author within an enclosing
function. The enclosing function is assumed to take as input a dataframe and
have an <code>iface</code> specified for that dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igroup_process(df = NULL, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="igroup_process_+3A_df">df</code></td>
<td>
<p>a dataframe from an enclosing function in which the grouping may or
may not have been correctly supplied.</p>
</td></tr>
<tr><td><code id="igroup_process_+3A_fn">fn</code></td>
<td>
<p>a function to call with the correctly grouped dataframe as specified
by the <code>iface</code> in the enclosing function.</p>
</td></tr>
<tr><td><code id="igroup_process_+3A_...">...</code></td>
<td>
<p>passed onto <code>iconvert</code> this could be used to supply
<code>.prune</code> parameters. triple dot parameters in the enclosing function will
be separately handled and automatically passed to <code>fn</code> so in general should
not be passed to <code>igroup_process</code> as an intermediary although it probably
won't hurt. This behaviour is similar to <code>NextMethod</code> in S3 method
dispatch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function detects when the grouping of the input has additional groups
over and above those in the specification and intercepts them, regrouping
the dataframe and applying <code>fn</code> group-wise using an equivalent of a
<code>dplyr::group_modify</code>. The parameters provided to the enclosing function will be
passed to <code>fn</code> and they should have compatible method signatures.
</p>


<h3>Value</h3>

<p>the result of calling <code>fn(df, ...)</code> on each unexpected group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This specification requires that the dataframe is grouped only by the color
# column
i_diamond_price = interfacer::iface(
  color = enum(`D`,`E`,`F`,`G`,`H`,`I`,`J`, .ordered=TRUE) ~ "the color column",
  price = integer ~ "the price column",
  .groups = ~ color
)

# An example function which would be exported in a package
ex_mean = function(df = i_diamond_price, extra_param = ".") {
  
  # When called with a dataframe with extra groups `igroup_process` will 
  # regroup the dataframe according to the structure 
  # defined for `i_diamond_price` and apply the inner function to each group
  # after first calling `ivalidate` on each group.
  
  igroup_process(df, 
    
    # the real work of this function is provided as an anonymous inner
    # function (but can be any other function e.g. package private function)
    # or a purrr style lambda.
    
    function(df, extra_param) {
      message(extra_param, appendLF = FALSE)
      return(df %&gt;% dplyr::summarise(mean_price = mean(price)))
    }
    
  )
}

# The correctly grouped dataframe. The `ex_mean` function calculates the mean
# price for each `color` group.
ggplot2::diamonds %&gt;% 
  dplyr::group_by(color) %&gt;% 
  ex_mean(extra_param = "without additional groups...") %&gt;% 
  dplyr::glimpse()
  
# If an additionally grouped dataframe is provided by the user. The `ex_mean` 
# function calculates the mean price for each `cut`,`clarity`, and `color` 
# combination.

ggplot2::diamonds %&gt;% 
  dplyr::group_by(cut, color, clarity) %&gt;% 
  ex_mean() %&gt;% 
  dplyr::glimpse()
  
# The output of this is actually grouped by cut then clarity as
# color is consumed by the igroup_dispatch summarise.

</code></pre>

<hr>
<h2 id='imapper'>Specify mappings that can make dataframes compatible with an <code>iface</code> specification</h2><span id='topic+imapper'></span>

<h3>Description</h3>

<p>When a function uses <code><a href="#topic+ivalidate">ivalidate()</a></code> internally to check a dataframe conforms to
the input it can attempt to rescue an incorrectly formatted dataframe.
This is a pretty advanced idea and is not generally recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imapper(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imapper_+3A_...">...</code></td>
<td>
<p>a set of <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> specifications that when applied to
a dataframe will rename or otherwise fix missing columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is expected to be used only in the context of a <code>.imap = imapper(...)</code>
parameter to an <code><a href="#topic+ivalidate">ivalidate()</a></code> call to make sure that certain columns are present
or are a set value. Anything provided here will overwrite existing
dataframe columns and its use is likely to make function behaviour obtuse.
It may be deprecated in the future. The <code>...</code> input expressions should almost certainly
check for the values already existing before overwriting them.
</p>
<p>If you are considering using this for replacing missing values check using
the <code>default(...)</code> <code>iface</code> type definition instead.
</p>


<h3>Value</h3>

<p>a set of mappings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = function(df = iface(col1 = integer ~ "an integer column" ), ...) {
  df = ivalidate(df,...)
}
input=tibble::tibble(col2 = c(1,2,3)) 
# This fails because col1 is missing
try(x(input))
# This fixes it for this input
x(input, .imap=imapper(col1 = col2))
</code></pre>

<hr>
<h2 id='iproto'>Generate a zero length dataframe conforming to an <code>iface</code> specification</h2><span id='topic+iproto'></span>

<h3>Description</h3>

<p>This function is used internally for default values for a dataframe
parameter. It generates a zero length dataframe that conforms to a <code>iface</code>
specification, in terms of column names, data types and groupings. Such a
dataframe is not guaranteed to be fully conformant to the <code>iface</code>
specification if, for example, completeness constraints are applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iproto(iface)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iproto_+3A_iface">iface</code></td>
<td>
<p>the specification</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe conforming to <code>iface</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i = interfacer::iface(
  col1 = integer ~ "A number",
  col2 = character ~ "A string"
)

iproto(i)
</code></pre>

<hr>
<h2 id='ireturn'>Check a return parameter from a function</h2><span id='topic+ireturn'></span>

<h3>Description</h3>

<p>This is intended to be used within a function to check the validity of a data
frame being returned from a function against an <code>ispec</code> which is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ireturn(df, iface, .prune = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ireturn_+3A_df">df</code></td>
<td>
<p>a dataframe - if missing then the first parameter of the calling
function is assumed to be a dataframe.</p>
</td></tr>
<tr><td><code id="ireturn_+3A_iface">iface</code></td>
<td>
<p>the interface specification that <code>df</code> should conform to.</p>
</td></tr>
<tr><td><code id="ireturn_+3A_.prune">.prune</code></td>
<td>
<p>get rid of excess columns that are not in the spec.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe based on <code>df</code> with validity checks passed,
data-types coerced, and correct grouping applied to conform to <code>iface</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
input = iface(col_in = integer ~ "an integer column" )
output = iface(col_out = integer ~ "an integer column" )

x = function(df = input, ...) {
  df = ivalidate(...)
  tmp = df %&gt;% dplyr::rename(col_out = col_in)
  ireturn(tmp, output)
}
x(tibble::tibble(col_in = c(1,2,3)))
output

</code></pre>

<hr>
<h2 id='is_col_present'>Check for existence of a set of columns in a dataframe</h2><span id='topic+is_col_present'></span>

<h3>Description</h3>

<p>Check for existence of a set of columns in a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_col_present(df, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_col_present_+3A_df">df</code></td>
<td>
<p>a dataframe to test</p>
</td></tr>
<tr><td><code id="is_col_present_+3A_...">...</code></td>
<td>
<p>the column names (unquoted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the columns are all there, false otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_col_present(iris, Species, Petal.Width)
</code></pre>

<hr>
<h2 id='is.iface'>Check if an object is an interface specification</h2><span id='topic+is.iface'></span>

<h3>Description</h3>

<p>Check if an object is an interface specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.iface(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.iface_+3A_x">x</code></td>
<td>
<p>the object to check</p>
</td></tr>
<tr><td><code id="is.iface_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean.
</p>

<hr>
<h2 id='itest'>Test dataframe conformance to an interface specification.</h2><span id='topic+itest'></span>

<h3>Description</h3>

<p><code>ivalidate</code> throws errors deliberately however sometimes dealing with invalid
input may be desirable. <code>itest</code> is generally designed to be used within a function which
specifies the expected input using <code>iface</code>, and allows the function to test if
its given input is conformant to the interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itest(df = NULL, iface = NULL, .imap = imapper())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="itest_+3A_df">df</code></td>
<td>
<p>a dataframe to test. If missing the first parameter of the calling
function is assumed to be the dataframe to test.</p>
</td></tr>
<tr><td><code id="itest_+3A_iface">iface</code></td>
<td>
<p>an interface specification produced by <code>iface()</code>. If missing
this will be inferred from the current function signature.</p>
</td></tr>
<tr><td><code id="itest_+3A_.imap">.imap</code></td>
<td>
<p>an optional mapping specification produced by <code>imapper()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the dataframe is conformant, FALSE otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (rlang::is_installed("ggplot2")) {
  i_diamonds = iface( 
    color = enum(D,E,F,G,H,I,J,extra) ~ "the colour", 
    price = integer ~ "the price"
  )
  
  # Ad hoc testing
  itest(ggplot2::diamonds, i_diamonds)
  
  # Use within function:
  x = function(df = i_diamonds) {
    if(itest()) message("PASS!")
  }
  
  x(ggplot2::diamonds)
}
</code></pre>

<hr>
<h2 id='ivalidate'>Perform interface checks on dataframe inputs using enclosing function formal
parameter definitions</h2><span id='topic+ivalidate'></span>

<h3>Description</h3>

<p><code>ivalidate(...)</code> is intended to be used within a function to check the validity of a data
frame parameter (usually the first parameter) against an <code>ispec</code> which is
given as a default value of a formal parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivalidate(df = NULL, ..., .imap = imapper(), .prune = FALSE, .default = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ivalidate_+3A_df">df</code></td>
<td>
<p>a dataframe - if missing then the first parameter of the calling
function is assumed to be a dataframe.</p>
</td></tr>
<tr><td><code id="ivalidate_+3A_...">...</code></td>
<td>
<p>not used but <code>ivalidate</code> should be included in call to inherit
<code>.imap</code> from the caller function.</p>
</td></tr>
<tr><td><code id="ivalidate_+3A_.imap">.imap</code></td>
<td>
<p>a set of mappings as an <code>imapper</code> object.</p>
</td></tr>
<tr><td><code id="ivalidate_+3A_.prune">.prune</code></td>
<td>
<p>get rid of excess columns that are not in the spec.</p>
</td></tr>
<tr><td><code id="ivalidate_+3A_.default">.default</code></td>
<td>
<p>a default dataframe conforming to the specification. This
overrides any defaults defined in the interface specification</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe based on <code>df</code> with validity checks passed and <code>.imap</code>
mappings applied if present
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = function(df = iface(col1 = integer ~ "an integer column" ), ...) {
  df = ivalidate(...)
  return(df)
}
input=tibble::tibble(col1 = c(1,2,3))
x(input)

# This fails because col1 is not coercable to integer
input2=tibble::tibble(col1 = c(1.5,2,3))
try(x(input2))
</code></pre>

<hr>
<h2 id='knit_print.iface'>Format an <code>iface</code> specification for printing</h2><span id='topic+knit_print.iface'></span>

<h3>Description</h3>

<p>Format an <code>iface</code> specification for printing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_print.iface(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knit_print.iface_+3A_x">x</code></td>
<td>
<p>an <code>iface</code> specification</p>
</td></tr>
<tr><td><code id="knit_print.iface_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a formatted string representation of an <code>iface</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_iface = iface( 
  col1 = integer + group_unique ~ "an integer column"
)

print(my_iface)
knitr::knit_print(my_iface)
</code></pre>

<hr>
<h2 id='print.iface'>Format an <code>iface</code> specification for printing</h2><span id='topic+print.iface'></span>

<h3>Description</h3>

<p>Format an <code>iface</code> specification for printing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iface'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.iface_+3A_x">x</code></td>
<td>
<p>an <code>iface</code> specification</p>
</td></tr>
<tr><td><code id="print.iface_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a formatted string representation of an <code>iface</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_iface = iface( 
  col1 = integer + group_unique ~ "an integer column"
)

print(my_iface)
knitr::knit_print(my_iface)
</code></pre>

<hr>
<h2 id='recycle'>Strictly recycle function parameters</h2><span id='topic+recycle'></span>

<h3>Description</h3>

<p><code>recycle</code> is called within a function and ensures the parameters in the
calling function are all the same length by repeating them using <code>rep</code>. This
function alters the environment from which it is called. It is stricter than
R recycling in that it will not repeat vectors other than length one to match
the longer ones, and it throws more informative errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recycle(..., .min = 1, .env = rlang::caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recycle_+3A_...">...</code></td>
<td>
<p>the variables to recycle</p>
</td></tr>
<tr><td><code id="recycle_+3A_.min">.min</code></td>
<td>
<p>the minimum length of the results (defaults to 1)</p>
</td></tr>
<tr><td><code id="recycle_+3A_.env">.env</code></td>
<td>
<p>the environment to recycle within.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NULL values are not recycled, missing values are ignored.
</p>


<h3>Value</h3>

<p>the length of the longest variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testfn = function(a, b, c) {
  n = recycle(a,b,c)
  print(a)
  print(b)
  print(c)
  print(n)
}

testfn(a=c(1,2,3), b="needs recycling", c=NULL)
try(testfn(a=c(1,2,3), c=NULL))

testfn(a=character(), b=integer(), c=NULL)

# inconsistent to have a zero length and a non zero length
try(testfn(a=c("a","b"), b=integer(), c=NULL))

</code></pre>

<hr>
<h2 id='resolve_missing'>Resolve missing values in function parameters and check consistency</h2><span id='topic+resolve_missing'></span>

<h3>Description</h3>

<p>Uses relationships between parameters to iteratively fill in missing values.
It is possible to specify an inconsistent set of rules or data in which case
the resulting values will be picked up and an error thrown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve_missing(
  ...,
  .env = rlang::caller_env(),
  .eval_null = TRUE,
  .error = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resolve_missing_+3A_...">...</code></td>
<td>
<p>either a set of relationships as a list of <code>x=y+z</code> expressions</p>
</td></tr>
<tr><td><code id="resolve_missing_+3A_.env">.env</code></td>
<td>
<p>the environment to check in (optional - defaults to <code>caller_env()</code>)</p>
</td></tr>
<tr><td><code id="resolve_missing_+3A_.eval_null">.eval_null</code></td>
<td>
<p>The default behaviour (when this option is <code>TRUE</code>)
considers missing values to be are either not given, given explicitly as
<code>NULL</code> or given as a <code>NULL</code> default value. Sometimes we need to consider
<code>NULL</code> values differently to missing values. If this is set to <code>FALSE</code> only
strictly missing values are resolved, and explicit <code>NULL</code> values left as
is.</p>
</td></tr>
<tr><td><code id="resolve_missing_+3A_.error">.error</code></td>
<td>
<p>a glue specification defining the error message. This can use
parameters <code>.missing</code>, <code>.constraints</code>, <code>.present</code> and <code>.call</code> to construct
an error message. If <code>NULL</code> a default message is provided that is generally
sufficient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. Alters the <code>.env</code> environment to fill in missing values or
throws an informative error
</p>


<h3>Examples</h3>

<pre><code class='language-R'># missing variables left with no default value in function definition
testfn = function(pos, neg, n) {
  resolve_missing(pos=n-neg, neg=n-pos, n=pos+neg)
  return(tibble::tibble(pos=pos,neg=neg,n=n))
}

testfn(pos=1:4, neg = 4:1)
testfn(neg=1:4, n = 10:7)

try(testfn())

# not enough info to infer the missing variables
try(testfn(neg=1:4))

# the parameters given are inconsistent with the relationships defined.
try(testfn(pos=2, neg=1, n=4))
</code></pre>

<hr>
<h2 id='roxy_tag_parse.roxy_tag_iparam'>Parser for <code style="white-space: pre;">&#8288;@iparam&#8288;</code> tags</h2><span id='topic+roxy_tag_parse.roxy_tag_iparam'></span>

<h3>Description</h3>

<p>The <code style="white-space: pre;">&#8288;@iparam &lt;name&gt; &lt;description&gt;&#8288;</code> tag can be used in <code>roxygen2</code> documentation
of a function to describe a dataframe parameter. The function must be using
<code>interfacer::iface</code> to define the input dataframe parameter format. The
<code style="white-space: pre;">&#8288;@iparam&#8288;</code> tag will then generate documentation about the type of dataframe
the function is expecting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roxy_tag_iparam'
roxy_tag_parse(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roxy_tag_parse.roxy_tag_iparam_+3A_x">x</code></td>
<td>
<p>A tag</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>roxy_tag</code> object with the <code>val</code> field set to the parsed value
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This provides support to `roxygen2` and only gets executed in the context
# of `devtools::document()`. There is no interactive use of this function.
</code></pre>

<hr>
<h2 id='roxy_tag_rd.roxy_tag_iparam'>Support for <code style="white-space: pre;">&#8288;@iparam&#8288;</code> tags</h2><span id='topic+roxy_tag_rd.roxy_tag_iparam'></span>

<h3>Description</h3>

<p>The <code style="white-space: pre;">&#8288;@iparam &lt;name&gt; &lt;description&gt;&#8288;</code> tag can be used in <code>roxygen2</code> documentation
of a function to describe a dataframe parameter. The function must be using
<code>interfacer::iface</code> to define the input dataframe parameter format. The
<code style="white-space: pre;">&#8288;@iparam&#8288;</code> tag will then generate documentation about the type of dataframe
the function is expecting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roxy_tag_iparam'
roxy_tag_rd(x, base_path, env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roxy_tag_rd.roxy_tag_iparam_+3A_x">x</code></td>
<td>
<p>The tag</p>
</td></tr>
<tr><td><code id="roxy_tag_rd.roxy_tag_iparam_+3A_base_path">base_path</code></td>
<td>
<p>Path to package root directory.</p>
</td></tr>
<tr><td><code id="roxy_tag_rd.roxy_tag_iparam_+3A_env">env</code></td>
<td>
<p>Environment in which to evaluate code (if needed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>roxygen2::rd_section</code> (see <code>roxygen2</code> documentation)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# An example function definition:
fn_definition &lt;- "
#' This is a title
#' 
#' This is the description.
#' 
#' @md
#' @iparam df the input
#' @export
f &lt;- function(df = interfacer::iface(
  id = integer ~ \"an integer `ID`\",
  test = logical ~ \"the test result\"
)) {
  ivalidate(df)
}
"

# For this example we manually parse the function specification in `fn_definition`
# creating a .Rd block - normally this is done by `roxygen2` which then
# writes this to an .Rd file. This function is not intended to be used 
# outside of a call to `devtools::document`.

tmp = roxygen2::parse_text(fn_definition)
print(tmp)

</code></pre>

<hr>
<h2 id='switch_pipeline'>Branch a <code>dplyr</code> pipeline based on a set of conditions</h2><span id='topic+switch_pipeline'></span>

<h3>Description</h3>

<p>Branch a <code>dplyr</code> pipeline based on a set of conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_pipeline(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="switch_pipeline_+3A_.x">.x</code></td>
<td>
<p>a dataframe</p>
</td></tr>
<tr><td><code id="switch_pipeline_+3A_...">...</code></td>
<td>
<p>a list of formulae of the type <code style="white-space: pre;">&#8288;predicate ~ purrr function&#8288;</code> using
<code>.x</code> as the single parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the result of applying <code style="white-space: pre;">&#8288;purrr function&#8288;</code> to <code>.x</code> in the case where
<code>predicate</code> evaluates to true. Both predicate and function can refer to
the pipeline dataframe using <code>.x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;% switch_pipeline(
  is_col_present(.x, Species) ~ .x %&gt;% dplyr::rename(new = Species)
) %&gt;% dplyr::glimpse()
</code></pre>

<hr>
<h2 id='type.anything'>Coerce to an unspecified type</h2><span id='topic+type.anything'></span>

<h3>Description</h3>

<p>Coerce to an unspecified type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.anything(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.anything_+3A_x">x</code></td>
<td>
<p>any vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input (unless x is <code>NULL</code> in which case a <code>character()</code>)
</p>

<hr>
<h2 id='type.character'>Coerce to a character.</h2><span id='topic+type.character'></span>

<h3>Description</h3>

<p>Coerce to a character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.character()
</code></pre>


<h3>Value</h3>

<p>the input as a character.
</p>

<hr>
<h2 id='type.complete'>Coerce to a complete set of values.</h2><span id='topic+type.complete'></span>

<h3>Description</h3>

<p>This test checks either for factors that all factor levels are present in the
input, or for numerics if the sequence from minimum to maximum by the
smallest difference are not all (approximately) present. Empty values are
ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.complete(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.complete_+3A_x">x</code></td>
<td>
<p>any vector, factor or numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input or error if not complete
</p>

<hr>
<h2 id='type.date'>Coerce to a Date.</h2><span id='topic+type.date'></span>

<h3>Description</h3>

<p>Coerce to a Date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.date(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.date_+3A_x">x</code></td>
<td>
<p>an object to be converted.</p>
</td></tr>
<tr><td><code id="type.date_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input as a <code>date</code> vector, error if this would involve data loss.
</p>

<hr>
<h2 id='type.default'>Set a default value for a column</h2><span id='topic+type.default'></span>

<h3>Description</h3>

<p>Any NA values will be replaced by this value. N.b. default values must be
provided before any other rules if the validation is not to fail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.default(value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.default_+3A_value">value</code></td>
<td>
<p>a length one item of the correct type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a validation function that switches NAs for default values
</p>

<hr>
<h2 id='type.double'>Coerce to a double.</h2><span id='topic+type.double'></span>

<h3>Description</h3>

<p>Coerce to a double.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.double(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.double_+3A_x">x</code></td>
<td>
<p>any vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input as a double, error if this would involve data loss.
</p>

<hr>
<h2 id='type.enum'>Define a conformance rule to match a factor with specific levels.</h2><span id='topic+type.enum'></span>

<h3>Description</h3>

<p>Define a conformance rule to match a factor with specific levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.enum(..., .drop = FALSE, .ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.enum_+3A_...">...</code></td>
<td>
<p>the levels (no quotes, backticks if required)</p>
</td></tr>
<tr><td><code id="type.enum_+3A_.drop">.drop</code></td>
<td>
<p>should levels present in the data and not specified cause an error
(FALSE the default) or be silently dropped to NA values (TRUE).</p>
</td></tr>
<tr><td><code id="type.enum_+3A_.ordered">.ordered</code></td>
<td>
<p>must the factor be ordered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that can check and convert input into the factor with specified
levels. This will re-level factors with matching levels but in a different order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = type.enum(one,two,three)
f(c("three","two","one"))
f(factor(rep(1:3,5), labels = c("one","two","three")))
</code></pre>

<hr>
<h2 id='type.factor'>Coerce to a factor.</h2><span id='topic+type.factor'></span>

<h3>Description</h3>

<p>Coerce to a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.factor(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.factor_+3A_x">x</code></td>
<td>
<p>any vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input as a factor, error if this would involve data loss.
</p>

<hr>
<h2 id='type.finite'>Check for non-finite values</h2><span id='topic+type.finite'></span>

<h3>Description</h3>

<p>Any non finite values will cause failure of validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.finite(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.finite_+3A_x">x</code></td>
<td>
<p>any vector that can be coerced to numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input coerced to a numeric value, or an error if any non-finite
values detected
</p>

<hr>
<h2 id='type.group_unique'>Coerce to a unique value within the current grouping structure.</h2><span id='topic+type.group_unique'></span>

<h3>Description</h3>

<p>Coerce to a unique value within the current grouping structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.group_unique(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.group_unique_+3A_x">x</code></td>
<td>
<p>any vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input or error if any of x is not unique.
</p>

<hr>
<h2 id='type.in_range'>Define a conformance rule to confirm that a numeric is in a set range</h2><span id='topic+type.in_range'></span>

<h3>Description</h3>

<p>This is anticipated to be part of a <code>iface</code> rule e.g.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.in_range(min, max, include.min = TRUE, include.max = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.in_range_+3A_min">min</code></td>
<td>
<p>the lower limit</p>
</td></tr>
<tr><td><code id="type.in_range_+3A_max">max</code></td>
<td>
<p>the upper limit</p>
</td></tr>
<tr><td><code id="type.in_range_+3A_include.min">include.min</code></td>
<td>
<p>is lower limit open (default TRUE)</p>
</td></tr>
<tr><td><code id="type.in_range_+3A_include.max">include.max</code></td>
<td>
<p>is upper limit open (default TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>iface(test_col = integer + in_range(-10,10) ~ "An integer from -10 to 10")</code>
</p>


<h3>Value</h3>

<p>a function which checks the values and returns them if OK or throws
an error if not
</p>


<h3>Examples</h3>

<pre><code class='language-R'>type.in_range(0,10,TRUE,TRUE)(0:10)
try(type.in_range(0,10,TRUE,FALSE)(0:10))
try(type.in_range(0,10,FALSE)(0:10))
type.in_range(0,10,FALSE,TRUE)(1:10)
type.in_range(0,10,TRUE,FALSE)(0:9)
type.in_range(0,Inf,FALSE,FALSE)(1:9)
try(type.in_range(0,10)(1:99))
</code></pre>

<hr>
<h2 id='type.integer'>Coerce to integer</h2><span id='topic+type.integer'></span>

<h3>Description</h3>

<p>Coerce to integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.integer(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.integer_+3A_x">x</code></td>
<td>
<p>any vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input as an integer, error if this would involve data loss.
</p>

<hr>
<h2 id='type.logical'>Coerce to a logical</h2><span id='topic+type.logical'></span>

<h3>Description</h3>

<p>Coerce to a logical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.logical(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.logical_+3A_x">x</code></td>
<td>
<p>any vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input as a logical, error if this would involve data loss.
</p>

<hr>
<h2 id='type.not_missing'>Check for missing values</h2><span id='topic+type.not_missing'></span>

<h3>Description</h3>

<p>Any NA values will cause failure of validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.not_missing(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.not_missing_+3A_x">x</code></td>
<td>
<p>any vector, factor or numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input if no missing values detected, otherwise an error
</p>

<hr>
<h2 id='type.numeric'>Coerce to a numeric.</h2><span id='topic+type.numeric'></span>

<h3>Description</h3>

<p>Coerce to a numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.numeric(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.numeric_+3A_x">x</code></td>
<td>
<p>any vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input as a numeric, error if this would involve data loss.
</p>

<hr>
<h2 id='type.of_type'>Check for a given class</h2><span id='topic+type.of_type'></span>

<h3>Description</h3>

<p>Any values of the wrong class will cause failure of validation. This is
particularly useful for custom vectors of for list types (e.g. <code>list(of_type(lm))</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.of_type(type, .not_null = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.of_type_+3A_type">type</code></td>
<td>
<p>the class of the type we are checking as a symbol</p>
</td></tr>
<tr><td><code id="type.of_type_+3A_.not_null">.not_null</code></td>
<td>
<p>are NULL values allowed (for list column entries only)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that can check the input is of the correct type.
</p>

<hr>
<h2 id='type.positive_double'>Coerce to a positive double.</h2><span id='topic+type.positive_double'></span>

<h3>Description</h3>

<p>Coerce to a positive double.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.positive_double(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.positive_double_+3A_x">x</code></td>
<td>
<p>object to be coerced or tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input as a positive double, error if this would involve data loss.
</p>

<hr>
<h2 id='type.positive_integer'>Coerce to a positive integer.</h2><span id='topic+type.positive_integer'></span>

<h3>Description</h3>

<p>Coerce to a positive integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.positive_integer(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.positive_integer_+3A_x">x</code></td>
<td>
<p>any vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input as a positive integer, error if this would involve data loss.
</p>

<hr>
<h2 id='type.proportion'>Coerce to a number between 0 and 1</h2><span id='topic+type.proportion'></span>

<h3>Description</h3>

<p>Coerce to a number between 0 and 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.proportion(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.proportion_+3A_x">x</code></td>
<td>
<p>object to be coerced or tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input as a number from 0 to 1, error if this would involve data loss.
</p>

<hr>
<h2 id='type.unique_id'>A globally unique ids.</h2><span id='topic+type.unique_id'></span>

<h3>Description</h3>

<p>A globally unique ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type.unique_id(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type.unique_id_+3A_x">x</code></td>
<td>
<p>any vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input.
</p>

<hr>
<h2 id='use_dataframe'>Use a dataframe in a package including structure based documentation</h2><span id='topic+use_dataframe'></span>

<h3>Description</h3>

<p>Using the interfacer framework you can document data during development.
This provides the basic documentation framework for a dataset based on a dataframe
in the correct format into the right place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_dataframe(
  df,
  name = deparse(substitute(df)),
  output = "R/data.R",
  pkg = "."
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_dataframe_+3A_df">df</code></td>
<td>
<p>the data frame to use</p>
</td></tr>
<tr><td><code id="use_dataframe_+3A_name">name</code></td>
<td>
<p>the name of the variable you wish to use (defaults to whatever the function is called with)</p>
</td></tr>
<tr><td><code id="use_dataframe_+3A_output">output</code></td>
<td>
<p>where to write data documentation code (defaults to <code>R/data.R</code>)</p>
</td></tr>
<tr><td><code id="use_dataframe_+3A_pkg">pkg</code></td>
<td>
<p>the package (defaults to current)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If this is your only use case for <code>interfacer</code> then you will not need
to import <code>interfacer</code> in your package, as none of the generated code will
depend on it.
</p>


<h3>Value</h3>

<p>nothing, used for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example code
if (interactive()) {
  # This is not run as it is designed for interactive use only and will
  # write to the userspace after checking that is what the user wants.
  use_dataframe(iris) 
}
</code></pre>

<hr>
<h2 id='use_iface'>Generate interfacer code for a dataframe</h2><span id='topic+use_iface'></span>

<h3>Description</h3>

<p>Generating and documenting an <code>iface</code> for a given dataframe would be time
consuming and annoying if you could not do it automatically. In this case as
you interactively develop a package using a test dataframe, the structure of
which can be explicitly documented and made into a specific contract within
the package. This supports development using test dataframes as a prototype
for function ensuring future user input conforms to the same expectations as
the test data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_iface(
  df,
  name = deparse(substitute(df)),
  output = "R/interfaces.R",
  use_as_default = FALSE,
  pkg = "."
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_iface_+3A_df">df</code></td>
<td>
<p>the data frame to use</p>
</td></tr>
<tr><td><code id="use_iface_+3A_name">name</code></td>
<td>
<p>the name of the variable you wish to use (defaults to whatever
the dataframe was called)</p>
</td></tr>
<tr><td><code id="use_iface_+3A_output">output</code></td>
<td>
<p>where within the current package to write data documentation
code (defaults to <code>R/interfaces.R</code>)</p>
</td></tr>
<tr><td><code id="use_iface_+3A_use_as_default">use_as_default</code></td>
<td>
<p>if this is set to true the current dataframe is saved
as package data and the <code>interfacer::iface</code> specification is created
referring to the package copy of the current dataframe as the default
value.</p>
</td></tr>
<tr><td><code id="use_iface_+3A_pkg">pkg</code></td>
<td>
<p>the package (defaults to current)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, used for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example code
if (interactive()) {
  # This is not run as it is designed for interactive use only and will
  # write to the userspace after checking that is what the user wants.
  use_iface(iris) 
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
