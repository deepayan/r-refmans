<!DOCTYPE html><html lang="en"><head><title>Help for package matrixset</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matrixset}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+5B+26lt+3B-.matrixset'><p>Replace Parts of a matrixset</p></a></li>
<li><a href='#add_matrix'><p>Add matrices to the <code>matrixset</code> object</p></a></li>
<li><a href='#annotate'><p>Create/modify/delete annotations of a <code>matrixset</code> object</p></a></li>
<li><a href='#annotate_from_matrix'><p>Apply functions to a single matrix of a matrixset and store results as annotation</p></a></li>
<li><a href='#arrange'><p>Re-order rows or columns of a <code>matrixset</code></p></a></li>
<li><a href='#as_matrixset'><p>Coerce object into <code>matrixset</code></p></a></li>
<li><a href='#column_group_by_drop_default'><p>Default value for .drop argument of function column_group_by()</p></a></li>
<li><a href='#context'><p>Contexts dependent functions</p></a></li>
<li><a href='#filter_column'><p>Subset columns using annotation values</p></a></li>
<li><a href='#filter_row'><p>Subset rows using annotation values</p></a></li>
<li><a href='#group_by'><p>Group rows/columns of a matrixset by one or more variables</p></a></li>
<li><a href='#join'><p>Add meta info from another <code>matrixset</code> or a <code>data.frame</code></p></a></li>
<li><a href='#loop'><p>Apply functions to each matrix of a matrixset</p></a></li>
<li><a href='#matrixset'><p>Matrix Set</p></a></li>
<li><a href='#meta'><p>Matrixset group metadata</p></a></li>
<li><a href='#mrm_plus2015'><p>Table S1 and S2 of MRMPlus Paper in <code>matrixset</code> Format</p></a></li>
<li><a href='#ms_to_df'><p>Convert matrixset to data frame</p></a></li>
<li><a href='#mutate_matrix'><p>Create/modify/delete matrices from a <code>matrixset</code> object</p></a></li>
<li><a href='#print.matrixset'><p>Print a matrixset</p></a></li>
<li><a href='#properties'><p>Matrixset properties</p></a></li>
<li><a href='#remove_anno'><p>Remove meta info of a <code>matrixset</code></p></a></li>
<li><a href='#remove_matrix'><p>Remove one or more matrices of the <code>matrixset</code> object</p></a></li>
<li><a href='#row_group_by_drop_default'><p>Default value for .drop argument of function row_group_by()</p></a></li>
<li><a href='#student_results'><p>Fake Final Exam Results of School Students Before and After Remedial Courses</p></a></li>
<li><a href='#subsetting'><p>Subsetting  matrixsets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Creating, Manipulating and Annotating Matrix Ensemble</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates an object that stores a matrix ensemble, matrices
  that share the same common properties, where rows and columns can be
  annotated. Matrices must have the same dimension and dimnames. Operators to
  manipulate these objects are provided as well as mechanisms to apply
  functions to these objects.</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, crayon, dplyr, lifecycle, Matrix, methods, pillar, purrr,
R6, Rcpp, rlang, stringr, tibble, tidyr, tidyselect, vctrs</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pascalcroteau/matrixset">https://github.com/pascalcroteau/matrixset</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pascalcroteau/matrixset/issues">https://github.com/pascalcroteau/matrixset/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, ggfortify, knitr, lme4, magrittr, patchwork, rmarkdown,
testthat (&ge; 3.0.0), tidyverse, withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-08 01:34:42 UTC; pc</td>
</tr>
<tr>
<td>Author:</td>
<td>Pascal Croteau [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pascal Croteau &lt;croteaupascl@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-08 04:00:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B+26lt+3B-.matrixset'>Replace Parts of a matrixset</h2><span id='topic++5B+3C-.matrixset'></span>

<h3>Description</h3>

<p>Replace whole or parts of some - or all - matrices of a <code>matrixset</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'matrixset'
x[i = NULL, j = NULL, matrix = NULL] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B+2B26lt+2B3B-.matrixset_+3A_x">x</code></td>
<td>
<p><code>matrixset</code> object from which to replace element(s)</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.matrixset_+3A_i">i</code>, <code id="+2B5B+2B26lt+2B3B-.matrixset_+3A_j">j</code></td>
<td>
<p>Indices specifying elements to replace. Indices are numeric or
character vectors or empty (<code>NULL</code>). Note that treating <code>NULL</code> as empty
differs from the usual replacement, where it is treated as <code>integer(0)</code>.
Here a <code>NULL</code> (empty) results in selecting all rows or columns.
</p>
<div class="sourceCode"><pre>Numeric values are coerced to integer as by [as.integer()] (and hence
truncated towards zero).

Character vectors will be matched to the dimnames of the object.

Can also be logical vectors, indicating elements/slices to replace Such
vectors are **NOT** recycled, which is an important difference with usual
matrix replacement. It means that the logical vector must match the
object dimension in length.

Can also be negative integers, indicating elements/slices to leave out of
the replacement.

When indexing, a single argument `i` can be a matrix with two columns.
This is treated as if the first column was the `i` index and the second
column the `j` index.
</pre></div></td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.matrixset_+3A_matrix">matrix</code></td>
<td>
<p>index specifying matrix or matrices to replace. Index is
numeric or character vectors or empty (<code>NULL</code>). Note
that treating <code>NULL</code> as empty differs from the usual
replacement, where it is treated as <code>integer(0)</code>. Here
a <code>NULL</code> (empty) results in replacing all matrices.
</p>
<p>Numeric values are coerced to integer as by <code><a href="base.html#topic+as.integer">as.integer()</a></code> (and hence
truncated towards zero).
</p>
<p>Character vectors will be matched to the matrix names of the object.
</p>
<p>Can also be logical vectors, indicating elements/slices to replace. Such
vectors are <em>NOT</em> recycled, which is an important difference with usual
matrix replacement. It means that the <code>logical</code> vector must match the
number of matrices in length.
</p>
<p>Can also be negative integers, indicating elements/slices to leave out of
the replacement.</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.matrixset_+3A_value">value</code></td>
<td>
<p>object to use as replacement value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>matrix</code> is left unspecified (or given as <code>NULL</code>), all matrices will be
replaced by <code>value</code>. How replacement exactly occurs depends on <code>value</code> itself.
</p>
<p>If <code>value</code> is a single atomic <code>vector</code> (this excludes lists) or <code>matrix</code>,
relevant subscripts of all requested matrices will be replaced by the same
<code>value</code>. This is conditional to the dimensions being compatible.
</p>
<p>Alternatively, <code>value</code> can be a list of atomic vectors/matrices. If <code>value</code>
has a single element, the same rules as above apply. Otherwise, the length
of <code>value</code> must match the number of matrices for which subscripts have to be
replaced.
</p>
<p>If the list elements are named, the names are matched to the names of the
matrices that need replacement - in which case <code>value</code> needs not to be the
same length.
</p>
<p>A final possibility for <code>value</code> is for it to be <code>NULL</code>. In this case, target
matrices are turned to <code>NULL</code>.
</p>


<h3>Value</h3>

<p>A <code>matrixset</code>, with proper elements replaced.
</p>


<h3>vector <code>value</code></h3>

<p>Contrarily to <code>matrix</code> replacement, when submitting an atomic <code>vector</code>
<code>value</code>, dimensions must match exactly.
</p>


<h3>Replacing <code>NULL</code> matrices</h3>

<p>Replacing subscripts of <code>NULL</code> matrices is not possible, unless <code>value</code> is
itself <code>NULL</code>, or a matrix the same dimensions (number of rows and columns)
as <code>x</code>. If <code>x</code> has dimnames, <code>value</code> must have the same dimnames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># an hypothetical example of students that failed 3 courses and their results
# after remedial class

# you can replace a line for all matrices at once. In the example, the "wrong"
# tag refers to the fact that the 'failure' results do not make sense after
# replacement
student_results_wrong &lt;- student_results
student_results_wrong["student 2",,] &lt;- c(0.81, 0.88, 0.71) # obviously, integer index works too
# note how all matrices had the same replacement
student_results_wrong

# this already makes more sense in the context of the example
student_results[2,,] &lt;- list(c(0,0.45,0.1), c(0.81, 0.88, 0.71))
student_results

# or even these two equivalent commands
student_results["student 2",,"remedial"] &lt;- c(0.77, 0.83, 0.75)
student_results[2,,2] &lt;- matrix(c(0.77, 0.83, 0.75), 1, 3)


</code></pre>

<hr>
<h2 id='add_matrix'>Add matrices to the <code>matrixset</code> object</h2><span id='topic+add_matrix'></span>

<h3>Description</h3>

<p>Matrices to add must be of the same dimension and dimnames as <code>.ms</code>.
</p>
<p>Either a named list of matrices can be supplied, or matrices can be specified
separaely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_matrix(.ms, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_matrix_+3A_.ms">.ms</code></td>
<td>
<p>A <code>matrixset</code> object.</p>
</td></tr>
<tr><td><code id="add_matrix_+3A_...">...</code></td>
<td>
<p>A single list of matrices (must be a named list), or
individual matrices, e.g. <code>mat1 = m1</code>, <code>mat2 = m2</code>, etc.
<code>NULL</code> elements are accepted. This allows to create a
placeholder that can be filled later on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrixset</code> with updated matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- matrix(1:60, 20, 3)
dimnames(m1) &lt;- dimnames(student_results)
m2 &lt;- matrix(101:160, 20, 3)
dimnames(m2) &lt;- dimnames(student_results)

ms &lt;- add_matrix(student_results, m1=m1, m2=m2)
ms2 &lt;- add_matrix(student_results, list(m1=m1, m2=m2))

</code></pre>

<hr>
<h2 id='annotate'>Create/modify/delete annotations of a <code>matrixset</code> object</h2><span id='topic+annotate'></span><span id='topic+annotate_row'></span><span id='topic+annotate_column'></span>

<h3>Description</h3>

<p>An annotation is a trait that is stored in the meta (row or column) data frame
of the <code>.ms</code> object.
</p>
<p>Creating an annotation is done as when applying a <code>mutate()</code> on a data frame.
Thus, annotations can be created from already existing annotations.
</p>
<p>The usage is the same as for <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, so see this function for
instructions on how to create/modify or delete traits.
</p>
<p>The only difference is that the tag is a special annotation that can't be
deleted or modify (with one exception in case of modification). The tag is
the column name of the meta data frame that holds the row or column names.
The tag identity of the' object can be obtained via <code><a href="#topic+row_tag">row_tag()</a></code> or
<code><a href="#topic+column_tag">column_tag()</a></code>. To modify a tag, see <code style="white-space: pre;">&#8288;rownames&lt;-()&#8288;</code> or <code style="white-space: pre;">&#8288;colnames&lt;-()&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_row(.ms, ...)

annotate_column(.ms, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="annotate_+3A_.ms">.ms</code></td>
<td>
<p>A <code>matrixset</code> object.</p>
</td></tr>
<tr><td><code id="annotate_+3A_...">...</code></td>
<td>
<p>Name-value pairs, ala <code>dplyr</code>'s <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrixset</code> with updated meta info.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+annotate_row_from_apply">annotate_row_from_apply()</a></code>/<code><a href="#topic+annotate_column_from_apply">annotate_column_from_apply()</a></code>, a version that
allows access to the <code>matrixset</code> matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># You can create annotation from scrath or using already existing annotation
ms &lt;- annotate_row(student_results,
                   dummy = 1,
                   passed = ifelse(previous_year_score &gt;= 0.6, TRUE, FALSE))

# There is a direct access to matrix content with annotate_row_from_apply(),
# but here is an example on how it can be done with annotate_row()
ms &lt;- annotate_row(student_results,
                   mn_fail = apply_matrix_dfl(student_results, mn=~ rowMeans(.m1),
                                              .matrix_wise = FALSE)$mn)

</code></pre>

<hr>
<h2 id='annotate_from_matrix'>Apply functions to a single matrix of a matrixset and store results as annotation</h2><span id='topic+annotate_from_matrix'></span><span id='topic+annotate_row_from_apply'></span><span id='topic+annotate_column_from_apply'></span>

<h3>Description</h3>

<p>This is in essence <code><a href="#topic+apply_row_dfw">apply_row_dfw()</a></code>/<code><a href="#topic+apply_column_dfw">apply_column_dfw()</a></code>, but with the
results saved as new annotations. As such, the usage is almost identical to
these functions, except that only a single matrix can be used, and must be
specified (matrix specification differs also slightly).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_row_from_apply(
  .ms,
  .matrix,
  ...,
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_vary = "fastest",
  names_expand = FALSE
)

annotate_column_from_apply(
  .ms,
  .matrix,
  ...,
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_vary = "fastest",
  names_expand = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="annotate_from_matrix_+3A_.ms">.ms</code></td>
<td>
<p><code>matrixset</code> object</p>
</td></tr>
<tr><td><code id="annotate_from_matrix_+3A_.matrix">.matrix</code></td>
<td>
<p>a tidyselect matrix name: matrix name as a bare name or a
character.</p>
</td></tr>
<tr><td><code id="annotate_from_matrix_+3A_...">...</code></td>
<td>
<p>expressions, separated by commas. They can be specified in one of
the following way:
</p>

<ul>
<li><p> a function name, e.g., <code>mean</code>.
</p>
</li>
<li><p> a function call, where you can use <code>.m</code> to represent the current matrix
(for <code>apply_matrix</code>), <code>.i</code> to represent the current row (for <code>apply_row</code>)
and <code>.j</code> for the current column (<code>apply_column</code>). Bare names of object
traits can be used as well. For instance, <code>lm(.i ~ program)</code>.
</p>
<p>The pronouns are also available for the multivariate version, under
certain circumstances, but they have a different meaning. See the
&quot;Multivariate&quot; section for more details.
</p>
</li>
<li><p> a formula expression. The pronouns <code>.m</code>, <code>.i</code> and <code>.j</code> can be used as
well. See examples to see the usefulness of this.
</p>
</li></ul>

<p>The expressions can be named; these names will be used to provide names to
the results.</p>
</td></tr>
<tr><td><code id="annotate_from_matrix_+3A_names_prefix">names_prefix</code>, <code id="annotate_from_matrix_+3A_names_sep">names_sep</code>, <code id="annotate_from_matrix_+3A_names_glue">names_glue</code>, <code id="annotate_from_matrix_+3A_names_sort">names_sort</code>, <code id="annotate_from_matrix_+3A_names_vary">names_vary</code>, <code id="annotate_from_matrix_+3A_names_expand">names_expand</code></td>
<td>
<p>See
the same arguments of <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A conscious choice was made to provide this functionality only for
<code style="white-space: pre;">&#8288;apply_*_dfw()&#8288;</code>, as this is the only version for which the output dimension
is guaranteed to respect the <code>matrixset</code> paradigm.
</p>
<p>On that note, see the section 'Grouped <code>matrixset</code>'.
</p>


<h3>Value</h3>

<p>A <code>matrixset</code> with updated meta info.
</p>


<h3>Grouped <code>matrixset</code></h3>

<p>In the context of grouping, the <code style="white-space: pre;">&#8288;apply_*_dfw()&#8288;</code> functions stack the results
for each group value.
</p>
<p>In the case of <code style="white-space: pre;">&#8288;annotate_*_from_matrix()&#8288;</code>, a <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code> is
further applied to ensure compatibility of the dimension.
</p>
<p>The <code>pivot_wider()</code> arguments <code>names_prefix</code>, <code>names_sep</code>, <code>names_glue</code>,
<code>names_sort</code>, <code>names_vary </code> and <code>names_expand</code> can help you control the final
annotation trait names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+annotate_row">annotate_row()</a></code>/<code><a href="#topic+annotate_column">annotate_column()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is the same example as in annotate_row(), but with the "proper" way
# of doing it
ms &lt;- annotate_row_from_apply(student_results, "failure", mn = mean)

</code></pre>

<hr>
<h2 id='arrange'>Re-order rows or columns of a <code>matrixset</code></h2><span id='topic+arrange'></span><span id='topic+arrange_row'></span><span id='topic+arrange_column'></span>

<h3>Description</h3>

<p>Orders the rows (<code><a href="#topic+arrange_row">arrange_row()</a></code>) or columns (<code><a href="#topic+arrange_column">arrange_column()</a></code>) by
annotation values.
</p>
<p>The mechanic is based on sorting the annotation data frame via <code>dplyr</code>'s
<code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code>.
</p>
<p>This means, for instance, that grouping is ignored by default. You must
either specify the grouping annotation in the sorting annotation, or use
<code>.by_group = TRUE</code>.
</p>
<p>The handling of locales and handling of missing values is also governed by
dplyr's <code>arrange()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange_row(.ms, ..., .by_group = FALSE)

arrange_column(.ms, ..., .by_group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange_+3A_.ms">.ms</code></td>
<td>
<p>A <code>matrixset</code> object</p>
</td></tr>
<tr><td><code id="arrange_+3A_...">...</code></td>
<td>
<p>Name of traits to base sorting upon. Tidy selection is
supported. Use <code><a href="dplyr.html#topic+desc">dplyr::desc()</a></code> to sort an annotation in
descending order.</p>
</td></tr>
<tr><td><code id="arrange_+3A_.by_group">.by_group</code></td>
<td>
<p><code>logical</code>. Defaults to <code>FALSE</code> and even if <code>TRUE</code>, has no
impact on ungrouped margin. Otherwise, grouping
annotation is used first for sorting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrixset</code> with re-ordered rows or columns, including updated row or
column meta info.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ms1 &lt;- remove_row_annotation(student_results, class, teacher)

# this would not work
# remove_row_annotation(row_group_by(student_results, class), class)
</code></pre>

<hr>
<h2 id='as_matrixset'>Coerce object into <code>matrixset</code></h2><span id='topic+as_matrixset'></span>

<h3>Description</h3>

<p>Turns object into a <code>matrixset</code>. See specific methods for more details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_matrixset(
  x,
  expand = NULL,
  row_info = NULL,
  column_info = NULL,
  row_key = "rowname",
  column_key = "colname",
  row_tag = ".rowname",
  column_tag = ".colname"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_matrixset_+3A_x">x</code></td>
<td>
<p>an object to coerce to <code>matrixset</code>. See methods.</p>
</td></tr>
<tr><td><code id="as_matrixset_+3A_expand">expand</code></td>
<td>
<p>By default (<code>NULL</code>), input matrix expansion is disabled.
Setting this parameter to <code>TRUE</code> will enable the expansion
feature. See the section &lsquo;Matrix Expansion&rsquo; of
<code><a href="#topic+matrixset">matrixset()</a></code> for more details of what it is, as well as
other possible options for <code>expand</code>. Note as well that this
argument is not available for all methods.</p>
</td></tr>
<tr><td><code id="as_matrixset_+3A_row_info">row_info</code></td>
<td>
<p>a data frame, used to annotate matrix rows. The link
between the matrix row names and the data frame is given
in column &quot;rowname&quot;. A different column can be used if one
provides a different <code>row_key</code>.</p>
</td></tr>
<tr><td><code id="as_matrixset_+3A_column_info">column_info</code></td>
<td>
<p>a data frame, used to annotate matrix columns. The link
between the matrix column names and the data frame is given
in column &quot;colname&quot;. A different column can be used if one
provides a different <code>column_key</code>.</p>
</td></tr>
<tr><td><code id="as_matrixset_+3A_row_key">row_key</code></td>
<td>
<p>column name in <code>row_info</code> data frame that will
link the row names with the row information. A string is
expected.</p>
</td></tr>
<tr><td><code id="as_matrixset_+3A_column_key">column_key</code></td>
<td>
<p>column name in <code>col_info</code> data frame that will
link the column names with the row information. A string is
expected.</p>
</td></tr>
<tr><td><code id="as_matrixset_+3A_row_tag">row_tag</code></td>
<td>
<p>A string, giving the row annotation data frame column that
will link the row names to the data frame. While
<code>row_key</code> specifies the column name of the data frame
at input, <code>row_tag</code> specifies the column name that
will be used throughout in the <code>matrixset</code> object.</p>
</td></tr>
<tr><td><code id="as_matrixset_+3A_column_tag">column_tag</code></td>
<td>
<p>A string, giving the column annotation data frame column
that will link the row names to the data frame. While
<code>column_key</code> specifies the column name of the data
frame at input, <code>column_tag</code> specifies the column
name that will be used throughout in the <code>matrixset</code>
object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>matrixset</code> - see <code><a href="#topic+matrixset">matrixset()</a></code>.
</p>


<h3>Methods</h3>


<ul>
<li> <p><code>matrix</code>
</p>
<p>The <code>matrix</code> method is very similar to calling the <code>matrixset</code>
construction function, with some key differences:
</p>

<ul>
<li><p> A matrix name will be provided automatically by <code>as_matrixset</code>. The
name is &quot;..1&quot;.
</p>
</li>
<li><p> Because only matrix is provided, the <code>expand</code> argument is not available
</p>
</li></ul>

</li>
<li> <p><code>list</code>
</p>
<p>The <code>list</code> method is nearly identical to calling the <code>matrixset</code>
construction function. It only differs in that unnamed <code>list</code> element
will be padded with a name. The new padded names are the element index,
prefixed by &quot;..&quot;. Already existing names will be made unique as well. If
name modification needs to be performed, a warning will be issued.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We're showing how 'as_matrixset' can differ. But first, show how they can
# yield the same result. Note that the list is named
lst &lt;- list(a = matrix(1:6, 2, 3), b = matrix(101:106, 2, 3))
identical(matrixset(lst), as_matrixset(lst))

# Now it will differ: the list is unnamed. In fact, 'matrixset' will fail
lst &lt;- list(matrix(1:6, 2, 3), matrix(101:106, 2, 3))
is(try(matrixset(lst), silent = TRUE), "try-error")
as_matrixset(lst)

# You need to name the matrix to use 'matrixset'. A name is provided for you
# with 'as_matrixset'. But you can't control what it is.
as_matrixset(matrix(1:6, 2, 3))

</code></pre>

<hr>
<h2 id='column_group_by_drop_default'>Default value for .drop argument of function column_group_by()</h2><span id='topic+column_group_by_drop_default'></span>

<h3>Description</h3>

<p>Default value for <code>.drop</code> argument of function <code><a href="#topic+column_group_by">column_group_by()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>column_group_by_drop_default(.ms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="column_group_by_drop_default_+3A_.ms">.ms</code></td>
<td>
<p>a <code>matrixset</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> for column-ungrouped <code>matrixset</code>s. For column-grouped objects,
the default is also <code>TRUE</code> unless <code>.ms</code> has been previously grouped with
<code>.drop = FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>student_results |&gt;
    row_group_by(class, .drop = FALSE) |&gt;
    row_group_by_drop_default()

</code></pre>

<hr>
<h2 id='context'>Contexts dependent functions</h2><span id='topic+context'></span><span id='topic+current_row_info'></span><span id='topic+current_column_info'></span><span id='topic+current_n_row'></span><span id='topic+current_n_column'></span><span id='topic+current_row_name'></span><span id='topic+row_pos'></span><span id='topic+row_rel_pos'></span><span id='topic+current_column_name'></span><span id='topic+column_pos'></span><span id='topic+column_rel_pos'></span>

<h3>Description</h3>

<p>These functions are designed to work inside certain <code>matrixset</code> functions, to
have access to current group/matrix/row/column. Because of that, they will
not work in a general context.
</p>
<p>The functions within which the context functions will work are <code><a href="#topic+apply_matrix">apply_matrix()</a></code>,
<code><a href="#topic+apply_row">apply_row()</a></code> and <code><a href="#topic+apply_column">apply_column()</a></code> - as well as their *_dfl/*dfw variant.
</p>
<p>Note that &quot;current&quot; refers to the current matrix/group/row/column, as
applicable, and possibly combined.
</p>
<p>The context functions are:
</p>

<ul>
<li> <p><code>current_n_row()</code> and <code>current_n_column()</code>. They each give the number of rows
and columns, respectively, of the current matrix.
</p>
<p>They are the context equivalent of <code><a href="base.html#topic+nrow">nrow()</a></code> and <code><a href="base.html#topic+ncol">ncol()</a></code>.
</p>
</li>
<li> <p><code>current_row_name()</code> and <code>current_column_name()</code>. They provide the current
row/column name. They are the context equivalent of <code><a href="base.html#topic+rownames">rownames()</a></code> and
<code><a href="base.html#topic+colnames">colnames()</a></code>.
</p>
</li>
<li> <p><code>current_row_info()</code> and <code>current_column_info()</code>. They give access to the
current row/column annotation data frame. The are the context equivalent
of <code><a href="#topic+row_info">row_info()</a></code> and <code><a href="#topic+column_info">column_info()</a></code>.
</p>
</li>
<li> <p><code>row_pos()</code> and <code>column_pos()</code>. They give the current row/column indices.
The indices are the the ones before matrix subsetting.
</p>
</li>
<li> <p><code>row_rel_pos()</code> and <code>column_rel_pos()</code>. They give the row/column indices
relative to the current matrix. They are equivalent to
<code>seq_len(current_n_row())</code>/<code>seq_len(current_n_column())</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>current_row_info()

current_column_info()

current_n_row()

current_n_column()

current_row_name()

row_pos()

row_rel_pos()

current_column_name()

column_pos()

column_rel_pos()
</code></pre>


<h3>Value</h3>

<p>See each individual functions for returned value when used in proper context.
If used out of context, an error condition is issued.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this will fail (as it should), because it is used out of context
is(try(current_n_row(), silent = TRUE), "try-error")

# this is one way to know the number of students per class in 'student_results'
student_results |&gt;
    apply_matrix_dfl(n = ~ current_n_row(), .matrix = 1)

</code></pre>

<hr>
<h2 id='filter_column'>Subset columns using annotation values</h2><span id='topic+filter_column'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+filter_column">filter_column()</a></code> function subsets the columns of all matrices of a
<code>matrixset</code>, retaining all columns that satisfy given condition(s). The
function <code>filter_column</code> works like <code>dplyr</code>'s <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_column(.ms, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_column_+3A_.ms">.ms</code></td>
<td>
<p><code>matrixset</code> object to subset based on the filtering
conditions</p>
</td></tr>
<tr><td><code id="filter_column_+3A_...">...</code></td>
<td>
<p>Condition, or expression, that returns a logical value,
used to determine if columns are kept or discarded. The
expression may refer to column annotations - columns of
the <code>column_info</code> component of <code>.ms</code> More than one
condition can be supplied and if multiple
expressions are included, they are combined with the <code>&amp;</code>
operator. Only columns for which all conditions evaluate
to TRUE are kept.</p>
</td></tr>
<tr><td><code id="filter_column_+3A_.preserve">.preserve</code></td>
<td>
<p><code>logical</code>, relevant only if <code>.ms</code> is column grouped. When
<code>.preserve</code> is <code>FALSE</code> (the default), the column grouping
is updated based on the new <code>matrixset</code> resulting from
the filtering. Otherwise, the column grouping is kept as
is.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditions are given as expressions in <code>...</code>, which are applied to
columns of the annotation data frame (<code>column_info</code>) to determine which
columns should be retained.
</p>
<p>It can be applied to both grouped and ungrouped <code>matrixset</code> (see
<code><a href="#topic+column_group_by">column_group_by()</a></code>), and section &lsquo;Grouped matrixsets&rsquo;.
</p>


<h3>Value</h3>

<p>A <code>matrixset</code>, with possibly a subset of the columns of the original object.
Groups will be updated if <code>.preserve</code> is <code>TRUE</code>.
</p>


<h3>Grouped matrixsets</h3>

<p>Row grouping (<code><a href="#topic+row_group_by">row_group_by()</a></code>) has no impact on column filtering.
</p>
<p>The impact of column grouping (<code><a href="#topic+column_group_by">column_group_by()</a></code>) on column filtering
depends on the conditions. Often, column grouping will not have any impact,
but as soon as an aggregating, lagging or ranking function is involved, then
the results will differ.
</p>
<p>For instance, the two following are not equivalent (except by pure
coincidence).
</p>
<p><code>student_results %&gt;% filter_column(school_average &gt; mean(school_average))</code>
</p>
<p>And it's grouped equivalent:
<code>student_results %&gt;% column_group_by(program) %&gt;% filter_column(school_average &gt; mean(school_average))</code>
</p>
<p>In the ungrouped version, the mean of <code>school_average</code> is taken globally
and <code>filter_column</code> keeps columns with <code>school_average</code> greater than this
global average. In the grouped version, the average is calculated within each
<code>class</code> and the kept columns are the ones with <code>school_average</code> greater
than the within-class average.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filtering using one condition
filter_column(student_results, program == "Applied Science")

# Filetring using multiple conditions. These are equivalent
filter_column(student_results, program == "Applied Science" &amp; school_average &gt; 0.8)
filter_column(student_results, program == "Applied Science", school_average &gt; 0.8)

# The potential difference between grouped and non-grouped.
filter_column(student_results, school_average &gt; mean(school_average))
student_results |&gt;
  column_group_by(program) |&gt;
  filter_column(school_average &gt; mean(school_average))

</code></pre>

<hr>
<h2 id='filter_row'>Subset rows using annotation values</h2><span id='topic+filter_row'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+filter_row">filter_row()</a></code> function subsets the rows of all matrices of a
<code>matrixset</code>, retaining all rows that satisfy given condition(s). The function
<code>filter_row</code> works like <code>dplyr</code>'s <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_row(.ms, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_row_+3A_.ms">.ms</code></td>
<td>
<p><code>matrixset</code> object to subset based on the filtering
conditions</p>
</td></tr>
<tr><td><code id="filter_row_+3A_...">...</code></td>
<td>
<p>Condition, or expression, that returns a logical value,
used to determine if rows are kept or discarded. The
expression may refer to row annotations - columns of
the <code>row_info</code> component of <code>.ms</code> More than one
condition can be supplied and if multiple
expressions are included, they are combined with the <code>&amp;</code>
operator. Only rows for which all conditions evaluate to
TRUE are kept.</p>
</td></tr>
<tr><td><code id="filter_row_+3A_.preserve">.preserve</code></td>
<td>
<p><code>logical</code>, relevant only if <code>.ms</code> is row grouped. When
<code>.preserve</code> is <code>FALSE</code> (the default), the row grouping
is updated based on the new <code>matrixset</code> resulting from
the filtering. Otherwise, the row grouping is kept as is.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditions are given as expressions in <code>...</code>, which are applied to
columns of the annotation data frame (<code>row_info</code>) to determine which rows
should be retained.
</p>
<p>It can be applied to both grouped and ungrouped <code>matrixset</code> (see
<code><a href="#topic+row_group_by">row_group_by()</a></code>), and section &lsquo;Grouped matrixsets&rsquo;.
</p>


<h3>Value</h3>

<p>A <code>matrixset</code>, with possibly a subset of the rows of the original object.
Groups will be updated if <code>.preserve</code> is <code>TRUE</code>.
</p>


<h3>Grouped matrixsets</h3>

<p>Column grouping (<code><a href="#topic+column_group_by">column_group_by()</a></code>) has no impact on row filtering.
</p>
<p>The impact of row grouping (<code><a href="#topic+row_group_by">row_group_by()</a></code>) on row filtering depends on
the conditions. Often, row grouping will not have any impact, but as soon as
an aggregating, lagging or ranking function is involved, then the results
will differ.
</p>
<p>For instance, the two following are not equivalent (except by pure
coincidence).
</p>
<p><code>student_results %&gt;% filter_row(previous_year_score &gt; mean(previous_year_score))</code>
</p>
<p>And it's grouped equivalent:
<code>student_results %&gt;% row_group_by(class) %&gt;% filter_row(previous_year_score &gt; mean(previous_year_score))</code>
</p>
<p>In the ungrouped version, the mean of <code>previous_year_score</code> is taken globally
and <code>filter_row</code> keeps rows with <code>previous_year_score</code> greater than this
global average. In the grouped version, the average is calculated within each
<code>class</code> and the kept rows are the ones with <code>previous_year_score</code> greater
than the within-class average.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filtering using one condition
filter_row(student_results, class == "classA")

# Filetring using multiple conditions. These are equivalent
filter_row(student_results, class == "classA" &amp; previous_year_score &gt; 0.75)
filter_row(student_results, class == "classA", previous_year_score &gt; 0.75)

# The potential difference between grouped and non-grouped.
filter_row(student_results, previous_year_score &gt; mean(previous_year_score))
student_results |&gt;
  row_group_by(teacher) |&gt;
  filter_row(previous_year_score &gt; mean(previous_year_score))

</code></pre>

<hr>
<h2 id='group_by'>Group rows/columns of a matrixset by one or more variables</h2><span id='topic+group_by'></span><span id='topic+row_group_by'></span><span id='topic+column_group_by'></span><span id='topic+row_ungroup'></span><span id='topic+column_ungroup'></span>

<h3>Description</h3>

<p>Applying <code><a href="#topic+row_group_by">row_group_by()</a></code> or <code><a href="#topic+column_group_by">column_group_by()</a></code> to a <code>matrixset</code> object
registers this object as one where certain operations are performed per
(row or column) group.
</p>
<p>To (partly) remove grouping, use <code><a href="#topic+row_ungroup">row_ungroup()</a></code> or <code><a href="#topic+column_ungroup">column_ungroup()</a></code>.
</p>
<p>These functions are the <code>matrixset</code> equivalent of <code>dplyr</code>'s
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> and <code><a href="dplyr.html#topic+group_by">dplyr::ungroup()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_group_by(.ms, ..., .add = FALSE, .drop = row_group_by_drop_default(.ms))

column_group_by(
  .ms,
  ...,
  .add = FALSE,
  .drop = column_group_by_drop_default(.ms)
)

row_ungroup(.ms, ...)

column_ungroup(.ms, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_by_+3A_.ms">.ms</code></td>
<td>
<p>A <code>matrixset</code> object</p>
</td></tr>
<tr><td><code id="group_by_+3A_...">...</code></td>
<td>
<p>In <code><a href="#topic+row_group_by">row_group_by()</a></code> or <code><a href="#topic+column_group_by">column_group_by()</a></code>, annotation
variables to use for grouping. These variables are the ones
returned by <code><a href="#topic+row_traits">row_traits()</a></code> or <code><a href="#topic+column_traits">column_traits()</a></code>. In <code><a href="#topic+row_ungroup">row_ungroup()</a></code>
or <code><a href="#topic+column_ungroup">column_ungroup()</a></code>, variables to remove from grouping. If
not provided, grouping is removed altogether.</p>
</td></tr>
<tr><td><code id="group_by_+3A_.add">.add</code></td>
<td>
<p><code>logical</code>. The default, <code>FALSE</code>, means that previous groups
are overwritten. Setting <code>.add</code> to <code>TRUE</code> will add to the
existing groups.</p>
</td></tr>
<tr><td><code id="group_by_+3A_.drop">.drop</code></td>
<td>
<p><code>logical</code>. When grouping by <code>factor</code> annotations, should
levels that do not appear in the data be dropped? The default
is <code>TRUE</code>, unless <code>.ms</code> has been previously grouped with
<code>.drop = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grouped <code>matrixset</code> with class <code>row_grouped_ms</code>, unless <code>.ms</code> was already
column-grouped via <code><a href="#topic+column_group_by">column_group_by()</a></code>, in which case a <code>dual_grouped_ms</code>
<code>matrixset</code> is returned.
</p>
<p>If the combination of <code>...</code> and <code>.add</code> yields an empty set of grouping
columns, a regular <code>matrixset</code>or a <code>col_grouped_ms</code>, as appropriate, will be
returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>by_class &lt;- row_group_by(student_results, class)

# On it's own, a grouped `matrixset` looks like a regular `matrixset`, except
# that the grouping structure is listed
by_class

# Grouping changes how some functions operates
filter_row(by_class, previous_year_score &gt; mean(previous_year_score))

# You can group by expressions: you end-up grouping by the new annotation:
row_group_by(student_results, sqrt_score = sqrt(previous_year_score))

# By default, grouping overrides existing grouping
row_group_vars(row_group_by(by_class, teacher))

# Use .add = TRUE to instead append
row_group_vars(row_group_by(by_class, teacher, .add = TRUE))
# To removing grouping, use ungroup
row_ungroup(by_class)

</code></pre>

<hr>
<h2 id='join'>Add meta info from another <code>matrixset</code> or a <code>data.frame</code></h2><span id='topic+join'></span><span id='topic+join_row_info'></span><span id='topic+join_column_info'></span>

<h3>Description</h3>

<p>The operation is done through a join operation between the row meta info
data.frame (<code><a href="#topic+join_row_info">join_row_info()</a></code>) of <code>.ms</code> and <code>y</code> (or its row meta info
data.frame if it is a <code>matrixset</code> object). The function <code><a href="#topic+join_column_info">join_column_info()</a></code>
does the equivalent operation for column meta info.
</p>
<p>The default join operation is a left join
(type == 'left'), but most of dplyr's
joins are available ('left', 'inner', 'right', 'full', 'semi' or 'anti').
</p>
<p>The <code>matrixset</code> paradigm of unique row/column names is enforced so if a
<code>.ms</code> data.frame row matches multiple ones in <code>y</code>, the default behavior is
to issue a condition error.
</p>
<p>This can be modified by setting new tag names via the argument <code>names_glue</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_row_info(
  .ms,
  y,
  type = "left",
  by = NULL,
  adjust = FALSE,
  names_glue = NULL,
  suffix = c(".x", ".y"),
  na_matches = c("na", "never")
)

join_column_info(
  .ms,
  y,
  type = "left",
  by = NULL,
  adjust = FALSE,
  names_glue = NULL,
  suffix = c(".x", ".y"),
  na_matches = c("na", "never")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="join_+3A_.ms">.ms</code></td>
<td>
<p>A <code>matrixset</code> object</p>
</td></tr>
<tr><td><code id="join_+3A_y">y</code></td>
<td>
<p>A <code>matrixset</code> object or a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="join_+3A_type">type</code></td>
<td>
<p>Joining type, one of 'left',
'inner', 'right', 'full', 'semi' or 'anti'.</p>
</td></tr>
<tr><td><code id="join_+3A_by">by</code></td>
<td>
<p>The names of the variable to join by.
The default, <code>NULL</code>, results in slightly different
behavior depending if <code>y</code> is a <code>matrixset</code> or a
<code>data.frame</code>.
If a <code>matrixset</code>, the meta info tag of each object (the
tag is the column that holds the row names/column names
in the meta info data frame - typically &quot;.rowname&quot; or
&quot;.colname&quot; unless specified otherwise at <code>matrixset</code>
creation) is used for <code>by</code>.
If a <code>data.frame</code>, a natural join is used. For more
details, see <code>dplyr</code>'s <code><a href="dplyr.html#topic+mutate-joins">dplyr::join()</a></code>.
Note that the cross-join is not available.</p>
</td></tr>
<tr><td><code id="join_+3A_adjust">adjust</code></td>
<td>
<p>A logical. By default (<code>FALSE</code>), the join operation is
not permitted to filter or augment the number of rows of
the meta info data frame.
If <code>TRUE</code>, this will be allowed. In the case where the
data frame is augmented, the matrices of <code>.ms</code>
will be augmented accordingly by padding with <code>NA</code>s (
except for the <code>NULL</code> matrices).
</p>
<p>Alternatively, <code>adjust</code> can be a single string, one of
'pad_x' or 'from_y'. Choosing &quot;pad_x&quot;
is equivalent to <code>TRUE</code>. When choosing &quot;from_y&quot;,
padding is done using values from <code>y</code>, but only
</p>

<ol>
<li><p> if <code>y</code> is a <code>matrixset</code>
</p>
</li>
<li><p> for <code>y</code> matrices that are named the same in <code>x</code>
</p>
</li>
<li><p> If padding rows, only columns common between <code>x</code> and <code>y</code> will use <code>y</code>
values. The same logic is applied when padding columns.
</p>
</li></ol>

<p>Other values are padded with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="join_+3A_names_glue">names_glue</code></td>
<td>
<p>a parameter that may allow multiple matches. By default,
(<code>NULL</code>), no multiple matches are allowed since the
resulting tag names will no longer be unique.
</p>
<p>The value of <code>names_glue</code> can be <code>logical</code>, with the value <code>FALSE</code> being
equivalent to <code>NULL</code>. If <code>TRUE</code>, then the resulting new tag names will be
enforced to be unique by adding a number index, i.e. a number index will
be glued to the tag names (hence the argument name).
</p>
<p>Finally, <code>names_glue</code> can be a string, where you supply a glue
specification that uses the variable names found in <code>y</code> (columns for data
frames, traits for matrixsets) columns to create a custom new tag name. A
special value <code>.tag</code> allows you to access the original tag name. Note that
currently only the curly brackets () can be used in the glue
specification.
</p>
<p>When making the unique tag names, <em>only</em> the non-unique names are modified.
Also, <code>adjust = TRUE</code> must be enforced for <code>names_glue</code> to work.</p>
</td></tr>
<tr><td><code id="join_+3A_suffix">suffix</code></td>
<td>
<p>Suffixes added to disambiguate trait variables. See
<code>dplyr</code>'s <code><a href="dplyr.html#topic+mutate-joins">dplyr::join()</a></code>.</p>
</td></tr>
<tr><td><code id="join_+3A_na_matches">na_matches</code></td>
<td>
<p>How to handle missing values when matching. See
<code>dplyr</code>'s <code><a href="dplyr.html#topic+mutate-joins">dplyr::join()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrixset</code> with updated row or column meta info, with all <code>.ms</code> traits and
<code>y</code> traits. If some traits share the same names - and were not included in
<code>by</code> - <code>suffix</code>es will be appended to these names.
</p>
<p>If adjustment was allowed, the dimensions of the new <code>matrixset</code> may differ
from the original one.
</p>


<h3>Groups</h3>

<p>When <code>y</code> is a <code>matrixset</code>, only groups from <code>.ms</code> are used, if any. Group
update is the same as in <code>dplyr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ms1 &lt;- remove_row_annotation(student_results, class, teacher)
ms &lt;- join_row_info(ms1, student_results)

ms &lt;- join_row_info(ms1, student_results, by = c(".rowname", "previous_year_score"))

# This will throw an error
ms2 &lt;- remove_row_annotation(filter_row(student_results, class %in% c("classA", "classC")),
                             class, teacher, previous_year_score)
ms &lt;- tryCatch(join_row_info(ms2, student_results, type = "full"),
               error = function(e) e)
is(ms, "error") # TRUE
ms$message

# Now it works.
ms &lt;- join_row_info(ms2, student_results, type = "full", adjust = TRUE)
dim(ms2)
dim(ms)
matrix_elm(ms, 1)

# Similarly, this will fail because tag names are no longer unique
meta &lt;- tibble::tibble(sample = c("student 2", "student 2"),
                      msr = c("height", "weight"),
                      value = c(145, 32))
ms &lt;- tryCatch(join_row_info(student_results, meta, by = c(".rowname"="sample")),
               error = function(e) e)
is(ms, "error") # TRUE
ms$message

# This works, by forcing the tag names to be unique. Notice that we suppress
# the warning for now. We'll come back to it.
suppressWarnings(
   join_row_info(student_results, meta, by = c(".rowname"="sample"),
                 adjust = TRUE, names_glue = TRUE)
)
# Here's the warning: we're being told there was a change in tag names
(purrr::quietly(join_row_info)(student_results, meta,
                               by = c(".rowname"="sample"), adjust = TRUE,
                               names_glue = TRUE))$warnings

# You can have better control on how the tag change occurs, for instance by
# appending the msr value to the name
suppressWarnings(
   join_row_info(student_results, meta, by = c(".rowname"="sample"),
                 adjust = TRUE, names_glue = "{.tag}_{msr}")
)
# In this specific example, the {.tag} was superfluous, since the default is
# to append after the tag name
suppressWarnings(
   join_row_info(student_results, meta, by = c(".rowname"="sample"),
                 adjust = TRUE, names_glue = "{msr}")
)
# But the keyword is useful if you want to shuffle order
suppressWarnings(
   join_row_info(student_results, meta, by = c(".rowname"="sample"),
                 adjust = TRUE, names_glue = "{msr}.{.tag}")
)

# You are warned when there is a change in traits
meta &lt;- tibble::tibble(sample = c("student 2", "student 2"),
                       class = c("classA", "classA"),
                       msr = c("height", "weight"),
                       value = c(145, 32))
(purrr::quietly(join_row_info)(student_results, meta,
                               by = c(".rowname"="sample"), adjust = TRUE,
                               names_glue = TRUE))$warnings[2]

# Groups are automatically adjusted
sr_gr &lt;- row_group_by(student_results, class)
gr_orig &lt;- row_group_meta(row_group_by(student_results, class)) |&gt; tidyr::unnest(.rows)
suppressWarnings(
  new_gr &lt;- join_row_info(sr_gr, meta, by = c(".rowname" = "sample", "class"),
                          adjust = TRUE, names_glue = TRUE) |&gt;
   row_group_meta() |&gt; tidyr::unnest(.rows)
)
list(gr_orig, new_gr)

# In the example above, the join operation changed the class of 'class',
# which in turn changed the grouping meta info. You are warned of both.
(purrr::quietly(join_row_info)(sr_gr, meta,
                               by = c(".rowname"="sample", "class"),
                               adjust = TRUE,  names_glue = TRUE))$warnings

# A change in trait name that was used for grouping will result in losing the
# grouping. You are warning of the change in grouping structure.
(purrr::quietly(join_row_info)(sr_gr, meta,
                               by = c(".rowname"="sample"),
                               adjust = TRUE,  names_glue = TRUE))$warnings

</code></pre>

<hr>
<h2 id='loop'>Apply functions to each matrix of a matrixset</h2><span id='topic+loop'></span><span id='topic+apply_row'></span><span id='topic+apply_row_dfl'></span><span id='topic+apply_row_dfw'></span><span id='topic+apply_column'></span><span id='topic+apply_column_dfl'></span><span id='topic+apply_column_dfw'></span><span id='topic+apply_matrix'></span><span id='topic+apply_matrix_dfl'></span><span id='topic+apply_matrix_dfw'></span>

<h3>Description</h3>

<p>The <code>apply_matrix</code> function applies functions to each matrix of a <code>matrixset</code>.
The <code>apply_row</code>/<code>apply_column</code> functions do the same but separately for each
row/column. The functions can be applied to all matrices or only a subset.
</p>
<p>The <code>dfl</code>/<code>dfw</code> versions differ in their output format and when possible,
always return a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>.
</p>
<p>Empty matrices are simply left unevaluated. How that impacts the returned
result depends on which flavor of apply_* has been used. See &lsquo;Value&rsquo;
for more details.
</p>
<p>If <code>.matrix_wise</code> is <code>FALSE</code>, the function (or expression) is multivariate in
the sense that all matrices are accessible at once, as opposed to each of them
in turn.
</p>
<p>See section &quot;Multivariate&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_row(.ms, ..., .matrix = NULL, .matrix_wise = TRUE, .input_list = FALSE)

apply_row_dfl(
  .ms,
  ...,
  .matrix = NULL,
  .matrix_wise = TRUE,
  .input_list = FALSE,
  .force_name = FALSE
)

apply_row_dfw(
  .ms,
  ...,
  .matrix = NULL,
  .matrix_wise = TRUE,
  .input_list = FALSE,
  .force_name = FALSE
)

apply_column(
  .ms,
  ...,
  .matrix = NULL,
  .matrix_wise = TRUE,
  .input_list = FALSE
)

apply_column_dfl(
  .ms,
  ...,
  .matrix = NULL,
  .matrix_wise = TRUE,
  .input_list = FALSE,
  .force_name = FALSE
)

apply_column_dfw(
  .ms,
  ...,
  .matrix = NULL,
  .matrix_wise = TRUE,
  .input_list = FALSE,
  .force_name = FALSE
)

apply_matrix(
  .ms,
  ...,
  .matrix = NULL,
  .matrix_wise = TRUE,
  .input_list = FALSE
)

apply_matrix_dfl(
  .ms,
  ...,
  .matrix = NULL,
  .matrix_wise = TRUE,
  .input_list = FALSE,
  .force_name = FALSE
)

apply_matrix_dfw(
  .ms,
  ...,
  .matrix = NULL,
  .matrix_wise = TRUE,
  .input_list = FALSE,
  .force_name = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loop_+3A_.ms">.ms</code></td>
<td>
<p><code>matrixset</code> object</p>
</td></tr>
<tr><td><code id="loop_+3A_...">...</code></td>
<td>
<p>expressions, separated by commas. They can be specified in one of
the following way:
</p>

<ul>
<li><p> a function name, e.g., <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g., <code>function(x) mean(x)</code> or <code style="white-space: pre;">&#8288;\(x) mean(x)&#8288;</code>
</p>
</li>
<li><p> a formula expression, which may represent a function call, where you can
use.m<code style="white-space: pre;">&#8288;to represent the current matrix (for&#8288;</code>apply_matrix<code style="white-space: pre;">&#8288;), .i&#8288;</code> to represent the current row (for <code>apply_row</code>) and
.j<code style="white-space: pre;">&#8288; for the current column (&#8288;</code>apply_column<code style="white-space: pre;">&#8288;). Bare names of object traits can be used as well. For instance, &#8288;</code>~ lm(.i ~ program)'.
</p>
<p>The pronouns are also available for the multivariate version, under
certain circumstances, but they have a different meaning. See the
&quot;Multivariate&quot; section for more details.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>  an expression. Superseded in favor
of using a formula. The usage is almost identical and the formula is
more clear.
</p>
</li></ul>

<p>The expressions can be named; these names will be used to provide names to
the results.</p>
</td></tr>
<tr><td><code id="loop_+3A_.matrix">.matrix</code></td>
<td>
<p>matrix indices of which matrix to apply functions to. The
default, <code>NULL</code>, means all the matrices are used.
</p>
<p>If not <code>NULL</code>, index is numeric or character vectors.
</p>
<p>Numeric values are coerced to integer as by <code><a href="base.html#topic+as.integer">as.integer()</a></code> (and hence
truncated towards zero).
</p>
<p>Character vectors will be matched to the matrix names of the object.
</p>
<p>Can also be logical vectors, indicating elements/slices to replace. Such
vectors are <em>NOT</em> recycled, which is an important difference with usual
matrix replacement. It means that the <code>logical</code> vector must match the
number of matrices in length.
</p>
<p>Can also be negative integers, indicating elements/slices to leave out of
the replacement.</p>
</td></tr>
<tr><td><code id="loop_+3A_.matrix_wise">.matrix_wise</code></td>
<td>
<p><code>logical</code>. By default (<code>TRUE</code>), matrices are provided
one by one, in turn, to the functions/expressions. But if <code>.matrix_wise</code> is
<code>FALSE</code>, the functions/expressions have access to all matrices. See
&quot;Multivariate&quot; for details, including how to reference the matrices.</p>
</td></tr>
<tr><td><code id="loop_+3A_.input_list">.input_list</code></td>
<td>
<p><code>logical</code>. If multivariate (<code>.matrix_wise ==  FALSE</code>),
the matrices are provided as a single list, where each element is a matrix
(or matrix row or column). The list elements are the matrix names.</p>
</td></tr>
<tr><td><code id="loop_+3A_.force_name">.force_name</code></td>
<td>
<p><code>logical</code>. Used only for the simplified output versions
(dfl/dfw). By default (<code>FALSE</code>), function IDs will be provided only if the
function outcome is a vector of length 2 or more. If <code>.force_name</code> is
<code>TRUE</code> then function IDs are provided in all situations.
</p>
<p>This can be useful in situation of grouping. As the functions are
evaluated independently within each group, there could be situations where
function outcomes are of length 1 for some groups and lenght 2 or more in
other groups.
</p>
<p>See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list for every matrix in the matrixset object. Each list is itself a
list, or <code>NULL</code> for <code>NULL</code> matrices. For <code>apply_matrix</code>, it is a list of
the function values. Otherwise, it is a list with one element for each
row/column. And finally, for <code>apply_row</code>/<code>apply_column</code>, each of these
sub-list is a list, the results of each function.
</p>
<p>When <code>.matrix_wise == FALSE</code>, the output format differs only in that there is
no list for matrices.
</p>
<p>If each function returns a <code>vector</code> of the same dimension, you can use either
the <code style="white-space: pre;">&#8288;_dfl&#8288;</code> or the <code style="white-space: pre;">&#8288;_dfw&#8288;</code> version. What they do is to return a list of
<code>tibble</code>s. The <code>dfl</code> version will stack the function results in a long format
while the <code>dfw</code> version will put them side-by-side, in a wide format. An
empty matrix will be returned for empty input matrices.
</p>
<p>If the functions returned vectors of more than one element, there will be a
column to store the values and one for the function ID (dfl), or one column
per combination of function/result (dfw)
</p>
<p>See the grouping section to learn about the result format in the grouping
context.
</p>


<h3>Pronouns</h3>

<p>The <code>rlang</code> pronouns <code>.data</code> and <code>.env</code> are available. Two scenarios for
which they can be useful are:
</p>

<ul>
<li><p> The annotation names are stored in a character variable. You can make use
of the variable by using <code>.data[[var]]</code>. See the example for an
illustration of this.
</p>
</li>
<li><p> You want to make use of a global variable that has the same name as an
annotation. You can use <code>.env[[var]]</code> or <code>.env$var</code> to make sure to use
the proper variable.
</p>
</li></ul>

<p>The matrixset package defines its own pronouns: .m,
.i and .j, which
are discussed in the function specification argument (<code>...</code>).
</p>
<p>It is not necessary to import any of the pronouns (or load <code>rlang</code> in the
case of <code>.data</code> and <code>.env</code>) in a interactive session.
</p>
<p>It is useful however when writing a package to avoid the <code style="white-space: pre;">&#8288;R CMD check&#8288;</code> notes.
As needed, you can import <code>.data</code> and <code>.env</code> (from <code>rlang</code>) or any of .m,
.i or .j from <code>matrixset</code>.
</p>


<h3>Multivariate</h3>

<p>The default behavior is to apply a function or expression to a single
matrix and each matrices of the <code>matrixset</code> object are provided sequentially
to the function/expression.
</p>
<p>If <code>.matrix_wise</code> is <code>FALSE</code>, all matrices are provided at once to the
functions/expressions. They can be provided in two fashions:
</p>

<ul>
<li><p> separately (default behavior). Each matrix can be referred by <code>.m1</code>, ...,
<code>.mn</code>, where <code>n</code> is the number of matrices. Note that this is the number
as determined by <code>.matrix</code>.
</p>
<p>For <code>apply_row</code> (and dfl/dfw variants), use <code>.i1</code>, <code>.i2</code> and so on
instead. What the functions/expressions have access to in this case is
the first row of the first matrix, the first row of the second matrix
and so on. Then, continuing the loop, the second row of each matrix
will be accessible, and so on
</p>
<p>Similarly, use <code>.j1</code> and so on for the <code>apply_column</code> family.
</p>
<p>Anonymous functions will be understood as a function with multiple
arguments. In the example <code>apply_row(ms, mean, .matrix_wise = FALSE)</code>,
if there are 3 matrices in the <code>ms</code> object, <code>mean</code> is understood as
<code>mean(.i1, .i2, .i3)</code>. Note that this would fail because of the <code>mean</code>
function.
</p>
</li>
<li><p> In a list (<code>.list_input = TRUE</code>). The list will have an element per matrix.
The list can be referred using the same pronouns (<code>.m</code>, <code>.i</code>, <code>.j</code>), and
the matrix, by the matrix names or position.
</p>
</li></ul>

<p>For the multivariate setting, empty matrices are given as is, so it is
important that provided functions can deal with such a scenario. An
alternative is to skip the empty matrices with the <code>.matrix</code> argument.
</p>


<h3>Grouped matrixsets</h3>

<p>If groups have been defined, functions will be evaluated within them. When
both row and column grouping has been registered, functions are evaluated at
each cross-combination of row/column groups.
</p>
<p>The output format is different when the <code>.ms</code> matrixset object is grouped.
A list for every matrix is still returned, but each of these lists now holds
a tibble.
</p>
<p>Each tibble has a column called <code>.vals</code>, where the function results are
stored. This column is a list, one element per group. The group labels are
given by the other columns of the tibble. For a given group, things are like
the ungrouped version: further sub-lists for rows/columns - if applicable -
and function values.
</p>
<p>The dfl/dfw versions are more similar in their output format to their
ungrouped version. The format is almost identical, except that additional
columns are reported to identify the group labels.
</p>
<p>See the examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The firs example takes the whole matrix average, while the second takes
# every row average
(mn_mat &lt;- apply_matrix(student_results, mean))
(mn_row &lt;- apply_row(student_results, mean))

# More than one function can be provided. It's a good idea in this case to
# name them
(mn_col &lt;- apply_column(student_results, avr=mean, med=median))

# the dfl/dfw versions returns nice tibbles - if the functions return values
# of the same length.
(mn_l &lt;- apply_column_dfl(student_results, avr=mean, med=median))
(mn_w &lt;- apply_column_dfw(student_results, avr=mean, med=median))

# There is no difference between the two versions for length-1 vector results.
# hese will differ, however
(rg_l &lt;- apply_column_dfl(student_results, rg=range))
(rg_w &lt;- apply_column_dfw(student_results, rg=range))

# More complex examples can be used, by using pronouns and data annotation
(vals &lt;- apply_column(student_results, avr=mean, avr_trim=~mean(.j, trim=.05),
                                      reg=~lm(.j ~ teacher)))

# You can wrap complex function results, such as for lm, into a list, to use
# the dfl/dfr version
(vals_tidy &lt;- apply_column_dfw(student_results, avr=mean, avr_trim=~mean(.j, trim=.05),
                                               reg=~list(lm(.j ~ teacher))))

# You can provide complex expressions by using formulas
(r &lt;- apply_column(student_results,
                                  res= ~ {
                                    log_score &lt;- log(.j)
                                    p &lt;- predict(lm(log_score ~ teacher + class))
                                    .j - exp(p)
                                  }))

# the .data pronoun can be useful to use names stored in variables
fn &lt;- function(nm) {
  if (!is.character(nm) &amp;&amp; length(nm) != 1) stop("this example won't work")
  apply_column(student_results, ~lm(.j ~ .data[[nm]]))
}
fn("teacher")

# You can use variables that are outside the scope of the matrixset object.
# You don't need to do anything special if that variable is not named as an
# annotation
pass_grade &lt;- 0.5
(passed &lt;- apply_row_dfw(student_results, pass = ~ .i &gt;= pass_grade))

# use .env if shares an annotation name
previous_year_score &lt;- 0.5
(passed &lt;- apply_row_dfw(student_results, pass = ~ .i &gt;= .env$previous_year_score))

# Grouping structure makes looping easy. Look at the output format
cl_prof_gr &lt;- row_group_by(student_results, class, teacher)
(gr_summ &lt;- apply_column(cl_prof_gr, avr=mean, med=median))
(gr_summ_tidy &lt;- apply_column_dfw(cl_prof_gr, avr=mean, med=median))
# to showcase how we can play with format
(gr_summ_tidy_long &lt;- apply_column_dfl(cl_prof_gr, summ = ~ c(avr=mean(.j), med=median(.j))))

# It is even possible to combine groupings
cl_prof_program_gr &lt;- column_group_by(cl_prof_gr, program)
(mat_summ &lt;- apply_matrix(cl_prof_program_gr, avr = mean, med = median, rg = range))
# it doesn' make much sense, but this is to showcase format
(summ_gr &lt;- apply_matrix(cl_prof_program_gr, avr = mean, med = median, rg = range))
(summ_gr_long &lt;- apply_column_dfl(cl_prof_program_gr,
                                 ct = ~ c(avr = mean(.j), med = median(.j)),
                                 rg = range))
(summ_gr_wide &lt;- apply_column_dfw(cl_prof_program_gr,
                                 ct = ~ c(avr = mean(.j), med = median(.j)),
                                 rg = range))


# This is an example where you may want to use the .force_name argument
(apply_matrix_dfl(column_group_by(student_results, program), FC = ~ colMeans(.m)))
(apply_matrix_dfl(column_group_by(student_results, program), FC = ~ colMeans(.m),
                  .force_name = TRUE))

</code></pre>

<hr>
<h2 id='matrixset'>Matrix Set</h2><span id='topic+matrixset'></span>

<h3>Description</h3>

<p>Creates a matrix set, possibly annotated for rows and/or columns. These
annotations are referred as traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixset(
  ...,
  expand = NULL,
  row_info = NULL,
  column_info = NULL,
  row_key = "rowname",
  column_key = "colname",
  row_tag = ".rowname",
  column_tag = ".colname"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrixset_+3A_...">...</code></td>
<td>
<p>A single list of matrices (must be a named list), or
individual matrices, e.g. <code>mat1 = m1</code>, <code>mat2 = m2</code>, etc.
<code>NULL</code> elements are accepted. This allows to create a
placeholder that can be filled later on.</p>
</td></tr>
<tr><td><code id="matrixset_+3A_expand">expand</code></td>
<td>
<p>By default (<code>NULL</code>), input matrix expansion is disabled.
Setting this parameter to <code>TRUE</code> will enable the expansion
feature. See the section &lsquo;Matrix Expansion&rsquo; for more
details of what it is, as well as other possible options
for <code>expand</code>. The section will also detail how the default
expansion value is dependent on the matrix types.</p>
</td></tr>
<tr><td><code id="matrixset_+3A_row_info">row_info</code></td>
<td>
<p>a data frame, used to annotate matrix rows. The link
between the matrix row names and the data frame is given
in column &quot;rowname&quot;. A different column can be used if one
provides a different <code>row_key</code>.</p>
</td></tr>
<tr><td><code id="matrixset_+3A_column_info">column_info</code></td>
<td>
<p>a data frame, used to annotate matrix columns. The link
between the matrix column names and the data frame is given
in column &quot;colname&quot;. A different column can be used if one
provides a different <code>column_key</code>.</p>
</td></tr>
<tr><td><code id="matrixset_+3A_row_key">row_key</code></td>
<td>
<p>column name in 'row_info&ldquo; data frame that will
link the row names with the row information. A string is
expected.</p>
</td></tr>
<tr><td><code id="matrixset_+3A_column_key">column_key</code></td>
<td>
<p>column name in <code>col_info</code> data frame that will
link the column names with the row information. A string is
expected.</p>
</td></tr>
<tr><td><code id="matrixset_+3A_row_tag">row_tag</code></td>
<td>
<p>A string, giving the row annotation data frame column that
will link the row names to the data frame. While
<code>row_key</code> specifies the column name of the data frame
at input, <code>row_tag</code> specifies the column name that
will be used throughout in the <code>matrixset</code> object.</p>
</td></tr>
<tr><td><code id="matrixset_+3A_column_tag">column_tag</code></td>
<td>
<p>A string, giving the column annotation data frame column
that will link the row names to the data frame. While
<code>column_key</code> specifies the column name of the data
frame at input, <code>column_tag</code> specifies the column
name that will be used throughout in the <code>matrixset</code>
object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>matrixset</code> is a collection of matrices that share the same dimensions and,
if applicable, dimnames. It is designed to hold different measures for the
same rows/columns. For example, each matrix could be a different time point
for the same subjects.
</p>
<p>Traits, which are annotations, can be provided in the form of data frames
for rows and/or columns. If traits are provided, the <code>data.frame</code> must
contain only one entry per row/column (see examples).
</p>
<p>Row or column names are not mandatory to create a proper <code>matrixset</code>. The
only way for this to work however is to leave traits (annotations) empty.
If provided, each matrices must have the same dimnames as well.
</p>
<p>If dimnames are missing, note that most of the operations for matrixsets
won't be available. For instance, operations that use traits will not work,
e.g., <code><a href="#topic+filter_row">filter_row()</a></code>.
</p>
<p>It is allowed for matrix elements of a <code>matrixset</code> to be <code>NULL</code> - see
examples.
</p>


<h3>Value</h3>

<p>Returns a <code>matrixset</code>, a collection of matrices (see &lsquo;Details&rsquo;).
</p>


<h3>Matrix Expansion</h3>

<p>The concept of matrix expansion allows to provide input matrices that do not
share the same dimensions.
</p>
<p>This works by taking the union of the dimnames and padding, if necessary,
each matrix with a special value for the missing rows/columns.
</p>
<p>Because the dimnames are used, they must necessarily be non-<code>NULL</code> in the
provided matrices.
</p>
<p>An interesting side-effect is that one can use this option to match the
dimnames and provide a common row/column order among the matrices.
</p>
<p>For base matrices, the padding special value is, by default
(<code>expand = TRUE</code>), <code>NA</code>. For the special matrices (Matrix package), the
default value is <code>0</code>. For these special matrices, padding with 0 forces
conversion to sparse matrix.
</p>
<p>The default value can be changed by providing any value (e.g, <code>-1</code>) to
<code>expand</code>, in which case the same padding value is used for all matrices.
</p>
<p>If different padding values are needed for each matrices, a list can be
provided to <code>expand</code>. If the list is unnamed, it must match the number of
input matrices in length and the padding values are assigned to the matrices
in order.
</p>
<p>A named list can be provided as well. In that case, <code>expand</code> names and
matrix names are matched. All matrices must have a match in the <code>expand</code> list
(more <code>expand</code> values can be provided, though).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_matrixset">as_matrixset()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A single NULL element will create an empty matrixset (it doesn't hold
# any matrices)
lst &lt;- NULL
matrixset(lst)

# This will hold to empty matrices
lst &lt;- list(a = NULL, b = NULL)
matrixset(lst)
# this is equivalent
matrixset(a = NULL, b = NULL)

# A basic example
lst &lt;- list(a = matrix(0, 2, 3))
matrixset(lst)
# equivalent
matrixset(a = matrix(0, 2, 3))

# can mix with NULL too
lst &lt;- list(a = NULL, b = matrix(0, 2, 3), c = matrix(0, 2, 3))
matset &lt;- matrixset(lst)

# dimnames are also considered to be traits
lst &lt;- list(a = NULL, b = matrix(0, 2, 3), c = matrix(0, 2, 3))
rownames(lst$b) &lt;- c("r1", "r2")
rownames(lst$c) &lt;- c("r1", "r2")
matrixset(lst)

# You don't have to annotate both rows and columns. But you need to provide
# the appropriate dimnames when you provide traits
lst &lt;- list(a = matrix(0, 2, 3), b = matrix(0, 2, 3), c = NULL)
rownames(lst$a) &lt;- c("r1", "r2")
rownames(lst$b) &lt;- c("r1", "r2")
colnames(lst$a) &lt;- c("c1", "c2", "c3")
colnames(lst$b) &lt;- c("c1", "c2", "c3")
ri &lt;- data.frame(rowname = c("r1", "r2"), g = 1:2)
matset &lt;- matrixset(lst, row_info = ri)

# You can provide a column name that contains the keys
ri &lt;- data.frame(foo = c("r1", "r2"), g = 1:2)
matset &lt;- matrixset(lst, row_info = ri, row_key = "foo")

lst &lt;- list(a = matrix(0, 2, 3), b = matrix(0, 2, 3), c = NULL)
rownames(lst$a) &lt;- c("r1", "r2")
rownames(lst$b) &lt;- c("r1", "r2")
colnames(lst$a) &lt;- c("c1", "c2", "c3")
colnames(lst$b) &lt;- c("c1", "c2", "c3")
ri &lt;- data.frame(rowname = c("r1", "r2"), g = 1:2)
ci &lt;- data.frame(colname = c("c1", "c2", "c3"), h = 1:3)
matset &lt;- matrixset(lst, row_info = ri, column_info = ci)

# This is not allowed, because the row trait data frame has more than one
# entry for "r1"
lst &lt;- list(a = matrix(0, 2, 3), b = matrix(0, 2, 3), c = NULL)
rownames(lst$a) &lt;- c("r1", "r2")
rownames(lst$b) &lt;- c("r1", "r2")
colnames(lst$a) &lt;- c("c1", "c2", "c3")
colnames(lst$b) &lt;- c("c1", "c2", "c3")
ri &lt;- data.frame(rowname = c("r1", "r2", "r1"), g = 1:3)
ci &lt;- data.frame(colname = c("c1", "c2", "c3"), h = 1:3)
ans &lt;- tryCatch(matrixset(lst, row_info = ri, column_info = ci),
                error = function(e) e)
is(ans, "error")

</code></pre>

<hr>
<h2 id='meta'>Matrixset group metadata</h2><span id='topic+meta'></span><span id='topic+row_group_meta'></span><span id='topic+row_group_vars'></span><span id='topic+row_group_keys'></span><span id='topic+row_group_where'></span><span id='topic+row_group_indices'></span><span id='topic+row_groups'></span><span id='topic+column_group_meta'></span><span id='topic+column_group_vars'></span><span id='topic+column_group_keys'></span><span id='topic+column_group_where'></span><span id='topic+column_group_indices'></span><span id='topic+column_groups'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+row_group_meta">row_group_meta()</a></code> and <code><a href="#topic+column_group_meta">column_group_meta()</a></code> returns the grouping structure,
in a data frame format. See <code>dplyr</code>'s <code><a href="dplyr.html#topic+group_data">dplyr::group_data()</a></code>, from which the
functions are based. Returns <code>NULL</code> for ungrouped <code>matrixset</code>s.
</p>
</li>
<li> <p><code><a href="#topic+row_group_keys">row_group_keys()</a></code> and <code><a href="#topic+column_group_keys">column_group_keys()</a></code> retrieve the grouping data,
while the locations (row or column indices) are retrieved with
<code><a href="#topic+row_group_where">row_group_where()</a></code> and <code><a href="#topic+column_group_where">column_group_where()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+row_group_indices">row_group_indices()</a></code> and <code><a href="#topic+column_group_indices">column_group_indices()</a></code> each return an integer
vector the same length as the number of rows or columns of <code>.ms</code>, and
gives the group that each row or column belongs to.
</p>
</li>
<li> <p><code><a href="#topic+row_group_vars">row_group_vars()</a></code> and <code><a href="#topic+column_group_vars">column_group_vars()</a></code> give names of grouping
variables as character vector; <code><a href="#topic+row_groups">row_groups()</a></code> and <code><a href="#topic+column_groups">column_groups()</a></code> give
the names as a list of symbols.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>row_group_meta(.ms)

row_group_vars(.ms)

row_group_keys(.ms)

row_group_where(.ms)

row_group_indices(.ms)

row_groups(.ms)

column_group_meta(.ms)

column_group_vars(.ms)

column_group_keys(.ms)

column_group_where(.ms)

column_group_indices(.ms)

column_groups(.ms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meta_+3A_.ms">.ms</code></td>
<td>
<p>a <code>matrixset</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='mrm_plus2015'>Table S1 and S2 of MRMPlus Paper in <code>matrixset</code> Format</h2><span id='topic+mrm_plus2015'></span>

<h3>Description</h3>

<p>Table S1 and S2 of MRMPlus Paper in <code>matrixset</code> Format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrm_plus2015
</code></pre>


<h3>Format</h3>

<p>A <code>matrixset</code> of 30 rows and 45 columns
The object contains four matrices:
</p>

<dl>
<dt>light_area</dt><dd><p>Peak area of light peptides.</p>
</dd>
<dt>heavy_area</dt><dd><p>Peak area of heavy peptides.</p>
</dd>
<dt>light_rt</dt><dd><p>Retention time of light peptides.</p>
</dd>
<dt>heavy_rt</dt><dd><p>Retention time of heavy peptides.</p>
</dd>
</dl>

<p>The column names, analytes, are a combination of peptide sequence and
fragment ion. Rownames are the replicate names.
</p>


<h3>Source</h3>

<p>Aiyetan P, Thomas SN, Zhang Z, Zhang H. MRMPlus: an open source quality
control and assessment tool for SRM/MRM assay development. BMC Bioinformatics.
2015 Dec 12;16:411. doi: 10.1186/s12859-015-0838-z. PMID: 26652794; PMCID: PMC4676880.
</p>

<hr>
<h2 id='ms_to_df'>Convert matrixset to data frame</h2><span id='topic+ms_to_df'></span>

<h3>Description</h3>

<p>Converts a <code>matrixset</code> to a <code>data.frame</code> (a <code>tibble</code>, more specifically), in
a long format.
</p>
<p>When <code>as_list</code> is <code>TRUE</code>, each matrix is converted separately. Row/column
annotation is included if requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms_to_df(
  .ms,
  add_row_info = TRUE,
  add_column_info = TRUE,
  as_list = FALSE,
  .matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ms_to_df_+3A_.ms">.ms</code></td>
<td>
<p><code>matrixset</code> object to convert to <code>data.frame</code></p>
</td></tr>
<tr><td><code id="ms_to_df_+3A_add_row_info">add_row_info</code></td>
<td>
<p><code>logical</code>, to include row annotation or not</p>
</td></tr>
<tr><td><code id="ms_to_df_+3A_add_column_info">add_column_info</code></td>
<td>
<p><code>logical</code>, to include column annotation or not</p>
</td></tr>
<tr><td><code id="ms_to_df_+3A_as_list">as_list</code></td>
<td>
<p><code>logical</code>. By default (<code>FALSE</code>), a single tibble
is returned with matrices as columns. When <code>TRUE</code>,
the list structure, an element by converted matrix,
is kept.</p>
</td></tr>
<tr><td><code id="ms_to_df_+3A_.matrix">.matrix</code></td>
<td>
<p>matrix indices of which matrix to include in the
conversion. The default, <code>NULL</code>, means all the
matrices are used.
</p>
<p>If not <code>NULL</code>, index is numeric or character vectors.
</p>
<p>Numeric values are coerced to integer as by <code><a href="base.html#topic+as.integer">as.integer()</a></code> (and hence
truncated towards zero).
</p>
<p>Character vectors will be matched to the matrix names of the object.
</p>
<p>Can also be logical vectors, indicating elements/slices to replace. Such
vectors are <em>NOT</em> recycled, which is an important difference with usual
matrix replacement. It means that the <code>logical</code> vector must match the
number of matrices in length.
</p>
<p>Can also be negative integers, indicating elements/slices to leave out of
the replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, or if <code>as_list</code> is <code>TRUE</code>, A <code>list</code> of data frames, an element per
converted matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># includes both annotation
ms_to_df(student_results)

# includes only row annotation
ms_to_df(student_results, add_column_info = FALSE)

</code></pre>

<hr>
<h2 id='mutate_matrix'>Create/modify/delete matrices from a <code>matrixset</code> object</h2><span id='topic+mutate_matrix'></span>

<h3>Description</h3>

<p>Applies functions that takes matrices as input and return similar matrices.
The definition of similar is that the new matrix has the same dimension and
dimnames as <code>.ms</code>.
</p>
<p>If the returned matrix is assigned to a new matrix, this matrix is added to the
<code>matrixset</code> object. If it is assigned to an already existing matrix, it
overwrites the matrix of the same name.
</p>
<p>Setting a matrix value to <code>NULL</code> will <em><strong>not</strong></em> delete the matrix, but will
create an empty slot (<code>NULL</code>) for the matrix.
</p>
<p>To delete a matrix, use the function <code><a href="#topic+remove_matrix">remove_matrix()</a></code>. See examples below.
</p>
<p>Note that matrices are created sequentially and can be used by other
name-value pairs. There is an example that showcases this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_matrix(.ms, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate_matrix_+3A_.ms">.ms</code></td>
<td>
<p>A <code>matrixset</code> object.</p>
</td></tr>
<tr><td><code id="mutate_matrix_+3A_...">...</code></td>
<td>
<p>Name-value pairs, ala <code>dplyr</code>'s <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>. The value
can be one of:
</p>

<ul>
<li><p> a <code>matrix</code>, with same dimension and dimnames as <code>.ms</code>.
</p>
</li>
<li> <p><code>NULL</code>, which will turn the matrix as an empty placeholder.
</p>
</li>
<li> <p><code><a href="#topic+remove_matrix">remove_matrix()</a></code>, to remove the matrix
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrixset</code> with updated matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Notice how FC can be used as soon as created
ms &lt;- mutate_matrix(student_results,
                    FC = remedial/failure,
                    foo = NULL,
                    logFC = log2(FC),
                    FC = remove_matrix())
# this is NULL
matrix_elm(ms, "foo")

# running this would return an error, since FC was deleted
# matrix_elm(ms, "FC")

</code></pre>

<hr>
<h2 id='print.matrixset'>Print a matrixset</h2><span id='topic+print.matrixset'></span>

<h3>Description</h3>

<p>When printing a <code>matrixset</code>:
</p>

<ul>
<li><p> The number of matrices and their dimension is shown
</p>
</li>
<li><p> Prints each matrix of the object, showing its type and dimension. Full
matrices are shown only for those with 3 rows or less. Otherwise, only
the first and last row is shown. The same also applies for the columns.
</p>
</li>
<li><p> An exception to the point above: if the number of matrices is greater than
<code>n_matrices</code>, the first <code>n_matrices</code> are displayed, while the others will
be named only.
</p>
</li>
<li><p> The row and column annotations (<code>row_info</code>/<code>column_info</code>) are displayed as
<code>tibble</code> objects.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrixset'
print(x, ..., n_matrices = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.matrixset_+3A_x">x</code></td>
<td>
<p><code>matrixset</code> object to print</p>
</td></tr>
<tr><td><code id="print.matrixset_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="print.matrixset_+3A_n_matrices">n_matrices</code></td>
<td>
<p>Number of matrices to display</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the <code>matrixset</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(student_results)
print(mrm_plus2015)

</code></pre>

<hr>
<h2 id='properties'>Matrixset properties</h2><span id='topic+properties'></span><span id='topic+dim.matrixset'></span><span id='topic+dimnames.matrixset'></span><span id='topic+dimnames+3C-.matrixset'></span><span id='topic+matrixnames'></span><span id='topic+matrixnames+3C-'></span><span id='topic+matrix_elm'></span><span id='topic+matrix_elm+3C-'></span><span id='topic+nmatrix'></span><span id='topic+row_traits'></span><span id='topic+column_traits'></span><span id='topic+row_traits+3C-'></span><span id='topic+column_traits+3C-'></span><span id='topic+row_tag'></span><span id='topic+column_tag'></span><span id='topic+row_info'></span><span id='topic+row_info+3C-'></span><span id='topic+column_info'></span><span id='topic+column_info+3C-'></span><span id='topic+is_matrixset'></span>

<h3>Description</h3>

<p>Utility functions to extract relevant information from a <code>matrixset</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrixset'
dim(x)

## S3 method for class 'matrixset'
dimnames(x)

## S3 replacement method for class 'matrixset'
dimnames(x) &lt;- value

matrixnames(x)

matrixnames(x) &lt;- value

matrix_elm(x, matrix)

matrix_elm(x, matrix) &lt;- value

nmatrix(x)

row_traits(x)

column_traits(x)

row_traits(x) &lt;- value

column_traits(x)

column_traits(x) &lt;- value

row_tag(x)

column_tag(x)

row_info(x)

row_info(x) &lt;- value

column_info(x)

column_info(x) &lt;- value

is_matrixset(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="properties_+3A_x">x</code></td>
<td>
<p><code>matrixset</code> object from which to retrieve information, or object
to test for being a <code>matrixset</code>.</p>
</td></tr>
<tr><td><code id="properties_+3A_value">value</code></td>
<td>
<p>valid value for replacement</p>
</td></tr>
<tr><td><code id="properties_+3A_matrix">matrix</code></td>
<td>
<p>index specifying matrix or matrices to extract. Index is
numeric or character vectors or empty (<code>NULL</code>). Note that
treating <code>NULL</code> as empty differs from the usual extraction,
where it is treated as <code>integer(0)</code>. Here a <code>NULL</code> (empty)
results in selecting all matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ìs_matrixset</code> tests if its argument is a proper <code>matrixset</code> object.
</p>
<p><code>dim</code> retrieves the dimension of the <code>matrixset</code> matrices (which are the
same for reach). Similarly,<code>nrow</code>  returns the number of rows for each
matrices, and <code>ncol</code> returns the number of columns.
</p>
<p><code>dimnames</code> retrieves the dimnames of the <code>matrixset</code> matrices (which are the
same for reach). Similarly, <code>rownames</code> (<code>colnames</code>) will retrieve row
(column) names.
</p>
<p><code>matrixnames</code> retrieves the matrix names, or <code>NULL</code> if the matrices are not
named.
</p>
<p><code>nmatrix</code> returns the number of matrices of a <code>matrixset</code>.
</p>
<p><code>row_traits</code> returns the object's row traits; these are the column names of
the row annotation data frame.
</p>
<p><code>column_traits</code> returns the object's column traits; these are the column
names of the column annotation data frame.
</p>
<p><code>row_info</code> extracts the row annotation data frame. <code>column_info</code> does
the same thing for column annotation.
</p>
<p><code>row_tag</code> returns the column name of <code>row_info</code> that stores the <code>matrixset</code>'s
row names. <code>column_tag</code> returns the column name of <code>column_info</code> that stores
the <code>matrixset</code>'s column names.
</p>
<p>The replacement methods for <code>row_traits</code>/<code>row_info</code> and <code>column_traits</code>/<code>column_info</code>
can potentially change meta variables that were used for grouping. There is
always an attempt to keep the original groups, but they will be updated if it
is possible - a message is issued when that happens - and otherwise removed
altogether, with a warning.
</p>
<p><code>matrix_elm</code> extracts a single matrix. It's a wrapper to <code>x[,,matrix]</code>, but
returns the matrix element. The replacement method <code>matrix_elm</code> is also a
wrapper to <code style="white-space: pre;">&#8288;x[,,matrix] &lt;-&#8288;</code>.
</p>


<h3>Value</h3>

<p><code>ìs_matrixset</code> returns a <code>logical</code>.
</p>
<p><code>dim</code> returns a length-2 vector; <code>nrow</code> and <code>ncol</code> return length-1 vector.
</p>
<p><code>dimnames</code> returns a length-2 list; one component for each dimnames (row and
column). <code>rownames</code> and <code>colnames</code> each returns a <code>character</code> vector of
names.
</p>
<p><code>matrixnames</code> a<code>character</code> vector of matrix names, or <code>NULL</code>.
</p>
<p><code>nmatrix</code> returns an <code>ìnteger</code>.
</p>
<p><code>row_traits</code> and <code>column_traits</code> returns a <code>character</code> vector.
</p>
<p><code>row_tag</code> and <code>column_tag</code> returns a <code>character</code> vector.
</p>
<p><code>row_info</code> extracts the row annotation data frame. <code>column_info</code> does
the same thing for column annotation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_matrixset(student_results)
dim(student_results)
c(nrow(student_results), ncol(student_results))
dimnames(student_results)
list(rownames(student_results), colnames(student_results))
matrixnames(student_results)
nmatrix(student_results)
list(row_traits(student_results), column_traits(student_results))
row_info(student_results)
column_info(student_results)

</code></pre>

<hr>
<h2 id='remove_anno'>Remove meta info of a <code>matrixset</code></h2><span id='topic+remove_anno'></span><span id='topic+remove_row_annotation'></span><span id='topic+remove_column_annotation'></span>

<h3>Description</h3>

<p>Deletes row or column annotation (i.e., trait).
</p>
<p>The tag is a special trait that can't be removed. The tag is the column name
of the meta data frame that holds the row or column names. The tag identity
of the' object can be obtained via <code><a href="#topic+row_tag">row_tag()</a></code> or <code><a href="#topic+column_tag">column_tag()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_row_annotation(.ms, ...)

remove_column_annotation(.ms, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_anno_+3A_.ms">.ms</code></td>
<td>
<p>A <code>matrixset</code> object</p>
</td></tr>
<tr><td><code id="remove_anno_+3A_...">...</code></td>
<td>
<p>Name of traits to remove. Tidy selection is supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrixset</code> with updated row or column meta info.
</p>


<h3>Groups</h3>

<p>Removing a trait that is used for grouping is not allowed and will not work.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ms1 &lt;- remove_row_annotation(student_results, class, teacher)

# this doesn't work because "class" is used for grouping
ms2 &lt;- tryCatch(remove_row_annotation(row_group_by(student_results, class), class),
                error = function(e) e)
is(ms2, "error") #TRUE
ms2$message
</code></pre>

<hr>
<h2 id='remove_matrix'>Remove one or more matrices of the <code>matrixset</code> object</h2><span id='topic+remove_matrix'></span>

<h3>Description</h3>

<p>This is a special case of the <code>[</code> method, with the benefit of being explicit
about what action is taken.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_matrix(.ms, matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_matrix_+3A_.ms">.ms</code></td>
<td>
<p>A <code>matrixset</code> object. Leave empty only if <code>remove_matrix()</code>
is used inside <code>mutate_matrix()</code>.</p>
</td></tr>
<tr><td><code id="remove_matrix_+3A_matrix">matrix</code></td>
<td>
<p>index specifying matrix or matrices to remove. Index is
<em>posivie</em> numeric or character vectors. Tidy select is
also supported .Leave empty only if <code>remove_matrix()</code>
is used inside <code>mutate_matrix()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrixset</code> with updated matrices.
</p>


<h3>Usage inside <code><a href="#topic+mutate_matrix">mutate_matrix()</a></code></h3>

<p>In most cases, both arguments of the function are mandatory. However, if you
want to declare that a matrix should be removed via the <code><a href="#topic+mutate_matrix">mutate_matrix()</a></code>
function, the <code>remove_matrix()</code> must be called without arguments. There is
an example that illustrates that.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ms1 &lt;- remove_matrix(student_results, "remedial")
ms2 &lt;- remove_matrix(student_results, 2)
ms3 &lt;- mutate_matrix(student_results, remedial = remove_matrix())

</code></pre>

<hr>
<h2 id='row_group_by_drop_default'>Default value for .drop argument of function row_group_by()</h2><span id='topic+row_group_by_drop_default'></span>

<h3>Description</h3>

<p>Default value for <code>.drop</code> argument of function <code><a href="#topic+row_group_by">row_group_by()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_group_by_drop_default(.ms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="row_group_by_drop_default_+3A_.ms">.ms</code></td>
<td>
<p>a <code>matrixset</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> for row-ungrouped <code>matrixset</code>s. For row-grouped objects, the
default is also <code>TRUE</code> unless <code>.ms</code> has been previously grouped with
<code>.drop = FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>student_results |&gt;
    row_group_by(class, .drop = FALSE) |&gt;
    row_group_by_drop_default()


</code></pre>

<hr>
<h2 id='student_results'>Fake Final Exam Results of School Students Before and After Remedial Courses</h2><span id='topic+student_results'></span>

<h3>Description</h3>

<p>Fake Final Exam Results of School Students Before and After Remedial Courses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>student_results
</code></pre>


<h3>Format</h3>

<p>A <code>matrixset</code> of 20 rows and 3 columns
The object contains two matrices, one for the failure results (matrix named
<code>failure</code>) and one for the results after remedial classes (matrix named
<code>remedial</code>). Each matrix has results for 20 students and 3 classes:
</p>

<ul>
<li><p> Mathematics
</p>
</li>
<li><p> English
</p>
</li>
<li><p> Science
</p>
</li></ul>

<p>The object has been annotated both for rows (students) and columns (courses).
Each students has been annotated for the following information:
</p>

<dl>
<dt>class</dt><dd><p>Group, or class, in which the student was part of</p>
</dd>
<dt>teacher</dt><dd><p>Professor that gave the remedial course</p>
</dd>
<dt>previous_year_score</dt><dd><p>Score the student had in the previous level of
the same class</p>
</dd>
</dl>

<p>Each course has been annotated for the following information:
</p>

<dl>
<dt>national_average</dt><dd><p>National average of all students for the course</p>
</dd>
<dt>school_average</dt><dd><p>Average of the school's students for the course</p>
</dd>
<dt>program</dt><dd><p>Program in which the course is given</p>
</dd>
</dl>


<hr>
<h2 id='subsetting'>Subsetting  matrixsets</h2><span id='topic+subsetting'></span><span id='topic++5B.matrixset'></span><span id='topic++5B.row_grouped_ms'></span><span id='topic++5B.col_grouped_ms'></span><span id='topic++5B.dual_grouped_ms'></span><span id='topic++24.matrixset'></span><span id='topic++5B+5B.matrixset'></span>

<h3>Description</h3>

<p>Extract parts of a matrixset, where indexes refers to rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrixset'

  x[
  i = NULL,
  j = NULL,
  matrix = NULL,
  drop = FALSE,
  keep_annotation = TRUE,
  warn_class_change = getOption("matrixset.warn_class_change")
]

## S3 method for class 'row_grouped_ms'

  x[
  i = NULL,
  j = NULL,
  matrix = NULL,
  drop = FALSE,
  keep_annotation = TRUE,
  warn_class_change = getOption("matrixset.warn_class_change")
]

## S3 method for class 'col_grouped_ms'

  x[
  i = NULL,
  j = NULL,
  matrix = NULL,
  drop = FALSE,
  keep_annotation = TRUE,
  warn_class_change = getOption("matrixset.warn_class_change")
]

## S3 method for class 'dual_grouped_ms'

  x[
  i = NULL,
  j = NULL,
  matrix = NULL,
  drop = FALSE,
  keep_annotation = TRUE,
  warn_class_change = getOption("matrixset.warn_class_change")
]

## S3 method for class 'matrixset'
x$matrix

## S3 method for class 'matrixset'
x[[matrix]]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsetting_+3A_x">x</code></td>
<td>
<p><code>matrixset</code> object from which to extract
element(s)</p>
</td></tr>
<tr><td><code id="subsetting_+3A_i">i</code>, <code id="subsetting_+3A_j">j</code></td>
<td>
<p>rows (<code>i</code>) and columns (<code>j</code>) to extract from
matrices of <code>x</code>, as indices. These are either <code>numeric</code> or <code>character</code>
values.
</p>
<p>To extract every rows or columns, use <code>i = NULL</code> or <code>j = NULL</code>, which is
the default for both. Note that treating <code>NULL</code> as empty differs from the
usual extraction, where it is treated as <code>integer(0)</code>.
</p>
<p>Numeric values are coerced to integer through <code><a href="base.html#topic+as.integer">as.integer()</a></code>, which means
they are truncated towards zero.
</p>
<p>Character vectors will be matched to the dimnames of the object.
</p>
<p>Indices an also be logical vectors, stating for each element if it is
extracted (<code>TRUE</code>) or rejected (<code>FALSE</code>). Logical vectors are <em>NOT</em>
recycled, which is an important difference with usual matrix extraction.
It means that the <code>logical</code> vector must match the object dimension in
length.
</p>
<p>Can also be negative integers, in which case they are indices of elements
to leave out of the selection.
</p>
<p>When indexing, a single argument <code>i</code> can be a matrix with two columns.
This is treated as if the first column was the <code>i</code> index and the second
column the <code>j</code> index.</p>
</td></tr>
<tr><td><code id="subsetting_+3A_matrix">matrix</code></td>
<td>
<p>index specifying matrix or matrices to extract.
Index is numeric or character vectors or empty
(<code>NULL</code>). Note that treating <code>NULL</code> as
empty differs from the usual extraction, where it
is treated as <code>integer(0)</code>. Here a
<code>NULL</code> (empty) results in selecting all
matrices.
</p>
<p>See arguments <code style="white-space: pre;">&#8288;i,j&#8288;</code>, as the same rules are followed.</p>
</td></tr>
<tr><td><code id="subsetting_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, the <code>drop</code> option of matrix extraction
is used. See [<code>[</code>()]. Note that the default for
<code>matrixset</code> objects is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="subsetting_+3A_keep_annotation">keep_annotation</code></td>
<td>
<p><code>logical</code> specifying if the resulting object
should keep the annotations (meta info, or
traits, as per <code>matrixset</code> notation) as part
of the object. The default (<code>TRUE</code>), combined
with the default <code>drop = FALSE</code>, guarantees that
the resulting object is a <code>matrixset</code> object. If
<code>keep_annotation</code> is <code>FALSE</code>, the resulting
object will be a list of matrix, and a warning
will be issued, unless <code>warn_class_change</code> is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="subsetting_+3A_warn_class_change">warn_class_change</code></td>
<td>
<p><code>logical</code> that determines if a warning
should be issued when the extraction result is
not a <code>matrixset</code>. The default is to use
the global option <code>"matrixset.warn_class_change"</code>,
which is <code>FALSE</code> by default. If one wants
to silence permanently this warning, this is the
option to change.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indexes <code>i</code> and <code>j</code> are given as for a regular <code><a href="base.html#topic+matrix">matrix()</a></code>
(note however that factors are currently not allowed for indexing).
Which matrices are extracted (all or a subset) is specified via argument
<code>"matrix"</code>.
</p>
<p>Missing values (<code>NA</code>) are not allowed for indexing, as it results in
unknown selection. Character indexes use exact matching, not partial.
</p>
<p>The default arguments for <code>"drop"</code> and <code>"keep_annotation"</code> are
chosen so that the object resulting from the extraction is still a
<code>matrixset</code>.
</p>
<p>Setting <code>"keep_annotation"</code> to <code>FALSE</code> automatically results in a class
change (a list of matrix) and a warning is issued (see argument
<code>warn_class_change</code>, however).
</p>
<p>Setting <code>drop</code> to <code>TRUE</code> may also result to a change of class,
depending on the provided indices (the same way matrix may result to a vector
when <code>drop</code> is <code>TRUE</code>).
</p>
<p>The subsetting operator <code>[[</code> is a convenient wrapper for <code style="white-space: pre;">&#8288;[(,,matrix)&#8288;</code>.
</p>
<p>There is no <code>$</code> subsetting operator for the <code>matrixset</code> object.
</p>


<h3>Value</h3>

<p>The resulting object type depends on the subsetting options. By default, a
<code>matrixset</code> object will be returned. This object will have the following
properties:
</p>

<ul>
<li><p> Rows and/or columns are a subset of the input (based on what has been
subsetted), but appear in the same order.
</p>
</li>
<li><p> Annotations, or traits, are subsetted appropriately.
</p>
</li>
<li><p> The number of groups may be reduced.
</p>
</li>
<li><p> Currently, attributes are <em>not</em> preserved.
</p>
</li></ul>

<p>If <code>keep_annotation</code> is <code>FALSE</code>, the resulting object will be a list.
Typically, it will be a list of <code>matrix</code>, but if <code>drop</code> is <code>TRUE</code>, some
list elements could be vectors.
</p>


<h3>Grouped matrixset</h3>

<p>When subsetting a grouped <code>matrixset</code> (by rows and/or columns), when the
resulting object is still a <code>matrixset</code>, the grouping structure will be
updated based on the resulting data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lst &lt;- list(a = matrix(1:6, 2, 3), b = matrix(101:106, 2, 3), c = NULL)
rownames(lst$a) &lt;- rownames(lst$b) &lt;- c("r1", "r2")
colnames(lst$a) &lt;- colnames(lst$b) &lt;- c("c1", "c2", "c3")
ri &lt;- data.frame(rowname = c("r1", "r2"), g = 1:2)
ci &lt;- data.frame(colname = c("c1", "c2", "c3"), h = 1:3)
matset &lt;- matrixset(lst, row_info = ri, column_info = ci, row_tag = "foo", column_tag = "bar")

# this doesn't subset anything, just returns matset again
matset[]

# this extracts the first row of every matrix. Note how each matrices is
# still a matrix, so you still end up with a matrixset object. Note also
# that you need placeholder for j and matrix index, even when not provided
matset[1, , ]

# similar idea
matset[,2, ]
matset[1,2,]

# it obviously works with vector indexes
matset[1:2, c(1,3),]

# you can extract the matrices this - even without the 'annoying' warning
matset[, , , keep_annotation = FALSE]
matset[, , , keep_annotation = FALSE, warn_class_change = FALSE]

# extracts subsetted matrices (no annotations)
matset[1, , , keep_annotation = FALSE, warn_class_change = FALSE]

# a bit more in line with how R subsets matrices
matset[1, , , drop = TRUE, warn_class_change = FALSE]

# you can obviously get some of the matrices only
matset[,,1]
matset[c(1,2),,1:2]

# to showcase other kind of indexes. These are all equivalents
matset[1,,]
matset["r1", ,]
matset[c(TRUE, FALSE), ,]
matset[-2, ,] # equivalent because there are only 2 rows

# this is also equivalent
matset[,,1]
matset[[1]]

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
