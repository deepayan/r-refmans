<!DOCTYPE html><html><head><title>Help for package tidyfst</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyfst}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25notin+25'><p>Not in operator</p></a></li>
<li><a href='#arrange_dt'><p>Arrange entries in data.frame</p></a></li>
<li><a href='#as_fst'><p>Save a data.frame as a fst table</p></a></li>
<li><a href='#col_max'><p>Get the column name of the max/min number each row</p></a></li>
<li><a href='#complete_dt'><p>Complete a data frame with missing combinations of data</p></a></li>
<li><a href='#count_dt'><p>Count observations by group</p></a></li>
<li><a href='#cummean'><p>Cumulative mean</p></a></li>
<li><a href='#distinct_dt'><p>Select distinct/unique rows in data.frame</p></a></li>
<li><a href='#drop_na_dt'><p>Dump, replace and fill missing values in data.frame</p></a></li>
<li><a href='#dummy_dt'><p>Fast creation of dummy variables</p></a></li>
<li><a href='#export_fst'><p>Read and write fst files</p></a></li>
<li><a href='#filter_dt'><p>Filter entries in data.frame</p></a></li>
<li><a href='#fst'><p>Parse,inspect and extract data.table from fst file</p></a></li>
<li><a href='#group_by_dt'><p>Group by variable(s) and implement operations</p></a></li>
<li><a href='#group_dt'><p>Data manipulation within groups</p></a></li>
<li><a href='#impute_dt'><p>Impute missing values with mean, median or mode</p></a></li>
<li><a href='#in_dt'><p>Short cut to data.table</p></a></li>
<li><a href='#intersect_dt'><p>Set operations for data frames</p></a></li>
<li><a href='#join'><p>Join tables</p></a></li>
<li><a href='#lead_dt'><p>Fast lead/lag for vectors</p></a></li>
<li><a href='#longer_dt'><p>Pivot data from wide to long</p></a></li>
<li><a href='#mat_df'><p>Conversion between tidy table and named matrix</p></a></li>
<li><a href='#mutate_dt'><p>Mutate columns in data.frame</p></a></li>
<li><a href='#mutate_when'><p>Conditional update of columns in data.table</p></a></li>
<li><a href='#nest_dt'><p>Nest and unnest</p></a></li>
<li><a href='#nth'><p>Extract the nth value from a vector</p></a></li>
<li><a href='#object_size'><p>Nice printing of report the Space Allocated for an Object</p></a></li>
<li><a href='#pairwise_count_dt'><p>Count pairs of items within a group</p></a></li>
<li><a href='#percent'><p>Add percentage to counts in data.frame</p></a></li>
<li><a href='#pkg_load'><p>Load or unload R package(s)</p></a></li>
<li><a href='#print_options'><p>Set global printing method for data.table</p></a></li>
<li><a href='#pull_dt'><p>Pull out a single variable</p></a></li>
<li><a href='#rec'><p>Recode number or strings</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#relocate_dt'><p>Change column order</p></a></li>
<li><a href='#rename_dt'><p>Rename column in data.frame</p></a></li>
<li><a href='#replace_dt'><p>Fast value replacement in data frame</p></a></li>
<li><a href='#rn_col'><p>Tools for working with row names</p></a></li>
<li><a href='#sample_dt'><p>Sample rows randomly from a table</p></a></li>
<li><a href='#select_dt'><p>Select column from data.frame</p></a></li>
<li><a href='#separate_dt'><p>Separate a character column into two columns using</p>
a regular expression separator</a></li>
<li><a href='#slice_dt'><p>Subset rows using their positions</p></a></li>
<li><a href='#sql_join'><p>Case insensitive table joining like SQL</p></a></li>
<li><a href='#summarise_dt'><p>Summarise columns to single values</p></a></li>
<li><a href='#sys_time_print'><p>Convenient print of time taken</p></a></li>
<li><a href='#t_dt'><p>Efficient transpose of data.frame</p></a></li>
<li><a href='#uncount_dt'><p>&quot;Uncount&quot; a data frame</p></a></li>
<li><a href='#unite_dt'><p>Unite multiple columns into one by pasting strings together</p></a></li>
<li><a href='#utf8_encoding'><p>Use UTF-8 for character encoding in a data frame</p></a></li>
<li><a href='#wider_dt'><p>Pivot data from long to wide</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tidy Verbs for Fast Data Manipulation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.7</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit of tidy data manipulation verbs with 'data.table' as the backend.
  Combining the merits of syntax elegance from 'dplyr' and computing performance from 'data.table', 
  'tidyfst' intends to provide users with state-of-the-art data manipulation tools with least pain.
  This package is an extension of 'data.table'. While enjoying a tidy syntax, 
  it also wraps combinations of efficient functions to facilitate frequently-used data operations.  </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hope-data-science/tidyfst">https://github.com/hope-data-science/tidyfst</a>,
<a href="https://hope-data-science.github.io/tidyfst/">https://hope-data-science.github.io/tidyfst/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hope-data-science/tidyfst/issues">https://github.com/hope-data-science/tidyfst/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.13.0), fst (&ge; 0.9.0), stringr (&ge; 1.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, nycflights13, pryr, tidyr, ggplot2, dplyr,
bench, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-18 02:01:33 UTC; DELL</td>
</tr>
<tr>
<td>Author:</td>
<td>Tian-Yuan Huang <a href="https://orcid.org/0000-0002-4151-3764"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tian-Yuan Huang &lt;huang.tian-yuan@qq.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-18 02:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25notin+25'>Not in operator</h2><span id='topic++25notin+25'></span>

<h3>Description</h3>

<p>Inverse operation of match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %notin% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25notin+2B25_+3A_x">x</code></td>
<td>
<p>vector or NULL</p>
</td></tr>
<tr><td><code id="+2B25notin+2B25_+3A_y">y</code></td>
<td>
<p>vector or NULL</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
"a" %in% letters[1:3]
"a" %notin% letters[1:3]

1 %in% 1:3
1 %notin% 1:3
</code></pre>

<hr>
<h2 id='arrange_dt'>Arrange entries in data.frame</h2><span id='topic+arrange_dt'></span>

<h3>Description</h3>

<p>Order the rows of a data frame rows by the values of selected columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange_dt(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange_dt_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="arrange_dt_+3A_...">...</code></td>
<td>
<p>Arrange by what group? Minus symbol means arrange by
descending order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+arrange">arrange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;% arrange_dt(Sepal.Length)

# minus for decreasing order
iris %&gt;% arrange_dt(-Sepal.Length)

# arrange by multiple variables
iris %&gt;% arrange_dt(Sepal.Length,Petal.Length)

</code></pre>

<hr>
<h2 id='as_fst'>Save a data.frame as a fst table</h2><span id='topic+as_fst'></span>

<h3>Description</h3>

<p>This function first export the data.frame to a temporal file,
and then parse it back as a fst table (class name is &quot;fst_table&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_fst(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_fst_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fst_table</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  iris %&gt;%
    as_fst() -&gt; iris_fst
  iris_fst

## End(Not run)
</code></pre>

<hr>
<h2 id='col_max'>Get the column name of the max/min number each row</h2><span id='topic+col_max'></span><span id='topic+col_min'></span>

<h3>Description</h3>

<p>For a data.frame with numeric values, add a new column
specifying the column name of the first max/min value each row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_max(.data, .name = "max_col")

col_min(.data, .name = "min_col")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_max_+3A_.data">.data</code></td>
<td>
<p>A data.frame with numeric column(s)</p>
</td></tr>
<tr><td><code id="col_max_+3A_.name">.name</code></td>
<td>
<p>The column name of the new added column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>References</h3>

<p>https://stackoverflow.com/questions/17735859/for-each-row-return-the-column-name-of-the-largest-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(199057)
DT &lt;- data.table(matrix(sample(10, 100, TRUE), ncol=10))
DT
col_max(DT)
col_max(DT,.name = "max_col_name")
col_min(DT)

col_max(iris)
</code></pre>

<hr>
<h2 id='complete_dt'>Complete a data frame with missing combinations of data</h2><span id='topic+complete_dt'></span>

<h3>Description</h3>

<p>Turns implicit missing values into explicit missing values.
All the combinations of column values (should be unique) will be constructed.
Other columns will be filled with NAs or constant value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_dt(.data, ..., fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_dt_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="complete_dt_+3A_...">...</code></td>
<td>
<p>Specification of columns to expand.The selection of columns is
supported by the flexible <code><a href="#topic+select_dt">select_dt</a></code>.
To find all unique combinations of provided columns, including those not found in the data,
supply each variable as a separate argument. But the two modes (select the
needed columns and fill outside values) could not be mixed,
find more details in examples.</p>
</td></tr>
<tr><td><code id="complete_dt_+3A_fill">fill</code></td>
<td>
<p>Atomic value to fill into the missing cell, default uses <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the provided columns with addtion data are of different length,
all the unique combinations would be returned. This operation should be used
only on unique entries, and it will always returned the unique entries.
</p>
<p>If you supply fill parameter, these values will also replace existing explicit missing values in the data set.
</p>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+complete">complete</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  group = c(1:2, 1),
  item_id = c(1:2, 2),
  item_name = c("a", "b", "b"),
  value1 = 1:3,
  value2 = 4:6
)

df %&gt;% complete_dt(item_id,item_name)
df %&gt;% complete_dt(item_id,item_name,fill = 0)
df %&gt;% complete_dt("item")
df %&gt;% complete_dt(item_id=1:3)
df %&gt;% complete_dt(item_id=1:3,group=1:2)
df %&gt;% complete_dt(item_id=1:3,group=1:3,item_name=c("a","b","c"))

</code></pre>

<hr>
<h2 id='count_dt'>Count observations by group</h2><span id='topic+count_dt'></span><span id='topic+add_count_dt'></span>

<h3>Description</h3>

<p>Count the unique values of one or more variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_dt(.data, ..., sort = TRUE, .name = "n")

add_count_dt(.data, ..., .name = "n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_dt_+3A_.data">.data</code></td>
<td>
<p>data.table/data.frame data.frame will be automatically converted
to data.table.</p>
</td></tr>
<tr><td><code id="count_dt_+3A_...">...</code></td>
<td>
<p>Variables to group by, could receive what 'select_dt' receives.</p>
</td></tr>
<tr><td><code id="count_dt_+3A_sort">sort</code></td>
<td>
<p>logical. If TRUE result will be sorted in desending order by resulting variable.</p>
</td></tr>
<tr><td><code id="count_dt_+3A_.name">.name</code></td>
<td>
<p>character. Name of resulting variable. Default uses &quot;n&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+count">count</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% count_dt(Species)
iris %&gt;% count_dt(Species,.name = "count")
iris %&gt;% add_count_dt(Species)
iris %&gt;% add_count_dt(Species,.name = "N")

mtcars %&gt;% count_dt(cyl,vs)
mtcars %&gt;% count_dt("cyl|vs")
mtcars %&gt;% count_dt(cyl,vs,.name = "N",sort = FALSE)
mtcars %&gt;% add_count_dt(cyl,vs)
mtcars %&gt;% add_count_dt("cyl|vs")

</code></pre>

<hr>
<h2 id='cummean'>Cumulative mean</h2><span id='topic+cummean'></span>

<h3>Description</h3>

<p>Returns a vector whose elements are the cumulative mean of the elements of the argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cummean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cummean_+3A_x">x</code></td>
<td>
<p>a numeric or complex object,
or an object that can be coerced to one of these.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cummean(1:10)

</code></pre>

<hr>
<h2 id='distinct_dt'>Select distinct/unique rows in data.frame</h2><span id='topic+distinct_dt'></span>

<h3>Description</h3>

<p>Select only unique/distinct rows from a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinct_dt(.data, ..., .keep_all = FALSE, fromLast = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinct_dt_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="distinct_dt_+3A_...">...</code></td>
<td>
<p>Optional variables to use when determining uniqueness.
If there are multiple rows for a given combination of inputs,
only the first row will be preserved.
If omitted, will use all variables.</p>
</td></tr>
<tr><td><code id="distinct_dt_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in data.frame. If a combination of ... is not distinct,
this keeps the first row of values.</p>
</td></tr>
<tr><td><code id="distinct_dt_+3A_fromlast">fromLast</code></td>
<td>
<p>Logical indicating if duplication should be
considered from the reverse side. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+distinct">distinct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% distinct_dt()
iris %&gt;% distinct_dt(Species)
iris %&gt;% distinct_dt(Species,.keep_all = TRUE)
mtcars %&gt;% distinct_dt(cyl,vs)
mtcars %&gt;% distinct_dt(cyl,vs,.keep_all = TRUE)
mtcars %&gt;% distinct_dt(cyl,vs,.keep_all = TRUE,fromLast = TRUE)


</code></pre>

<hr>
<h2 id='drop_na_dt'>Dump, replace and fill missing values in data.frame</h2><span id='topic+drop_na_dt'></span><span id='topic+replace_na_dt'></span><span id='topic+delete_na_cols'></span><span id='topic+delete_na_rows'></span><span id='topic+fill_na_dt'></span><span id='topic+shift_fill'></span>

<h3>Description</h3>

<p>A set of tools to deal with missing values in data.frames. 
It can dump, replace, fill (with next or previous observation) or delete entries according to their missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_na_dt(.data, ...)

replace_na_dt(.data, ..., to)

delete_na_cols(.data, prop = NULL, n = NULL)

delete_na_rows(.data, prop = NULL, n = NULL)

fill_na_dt(.data, ..., direction = "down")

shift_fill(x, direction = "down")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_na_dt_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="drop_na_dt_+3A_...">...</code></td>
<td>
<p>Colunms to be replaced or filled. If not specified, use all columns.</p>
</td></tr>
<tr><td><code id="drop_na_dt_+3A_to">to</code></td>
<td>
<p>What value should NA replace by?</p>
</td></tr>
<tr><td><code id="drop_na_dt_+3A_prop">prop</code></td>
<td>
<p>If proportion of NAs is larger than or equal to &quot;prop&quot;, would be deleted.</p>
</td></tr>
<tr><td><code id="drop_na_dt_+3A_n">n</code></td>
<td>
<p>If number of NAs is larger than or equal to &quot;n&quot;, would be deleted.</p>
</td></tr>
<tr><td><code id="drop_na_dt_+3A_direction">direction</code></td>
<td>
<p>Direction in which to fill missing values.
Currently either &quot;down&quot; (the default) or &quot;up&quot;.</p>
</td></tr>
<tr><td><code id="drop_na_dt_+3A_x">x</code></td>
<td>
<p>A vector with missing values to be filled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>drop_na_dt</code> drops the entries with NAs in specific columns.
<code>fill_na_dt</code> fill NAs with observations ahead (&quot;down&quot;) or below (&quot;up&quot;),
which is also known as last observation carried forward (LOCF) and
next observation carried backward(NOCB).
</p>
<p><code>delete_na_cols</code> could drop the columns with NA proportion larger
than or equal to &quot;prop&quot; or NA number larger than or equal to &quot;n&quot;,
<code>delete_na_rows</code> works alike but deals with rows.
</p>
<p><code>shift_fill</code> could fill a vector with missing values.
</p>


<h3>Value</h3>

<p>data.table
</p>


<h3>References</h3>

<p>https://stackoverflow.com/questions/23597140/how-to-find-the-percentage-of-nas-in-a-data-frame
</p>
<p>https://stackoverflow.com/questions/2643939/remove-columns-from-dataframe-where-all-values-are-na
</p>
<p>https://stackoverflow.com/questions/7235657/fastest-way-to-replace-nas-in-a-large-data-table
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+drop_na">drop_na</a></code>,<code><a href="tidyr.html#topic+replace_na">replace_na</a></code>,
<code><a href="tidyr.html#topic+fill">fill</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(x = c(1, 2, NA), y = c("a", NA, "b"))
 df %&gt;% drop_na_dt()
 df %&gt;% drop_na_dt(x)
 df %&gt;% drop_na_dt(y)
 df %&gt;% drop_na_dt(x,y)

 df %&gt;% replace_na_dt(to = 0)
 df %&gt;% replace_na_dt(x,to = 0)
 df %&gt;% replace_na_dt(y,to = 0)
 df %&gt;% replace_na_dt(x,y,to = 0)

 df %&gt;% fill_na_dt(x)
 df %&gt;% fill_na_dt() # not specified, fill all columns
 df %&gt;% fill_na_dt(y,direction = "up")

x = data.frame(x = c(1, 2, NA, 3), y = c(NA, NA, 4, 5),z = rep(NA,4))
x
x %&gt;% delete_na_cols()
x %&gt;% delete_na_cols(prop = 0.75)
x %&gt;% delete_na_cols(prop = 0.5)
x %&gt;% delete_na_cols(prop = 0.24)
x %&gt;% delete_na_cols(n = 2)

x %&gt;% delete_na_rows(prop = 0.6)
x %&gt;% delete_na_rows(n = 2)

# shift_fill
y = c("a",NA,"b",NA,"c")

shift_fill(y) # equals to
shift_fill(y,"down")

shift_fill(y,"up")
</code></pre>

<hr>
<h2 id='dummy_dt'>Fast creation of dummy variables</h2><span id='topic+dummy_dt'></span>

<h3>Description</h3>

<p>Quickly create dummy (binary) columns from character and factor type columns in the inputted data (and numeric columns if specified.)
This function is useful for statistical analysis when you want binary columns rather than character columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy_dt(.data, ..., longname = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy_dt_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="dummy_dt_+3A_...">...</code></td>
<td>
<p>Columns you want to create dummy variables from.
Very flexible, find in the examples.</p>
</td></tr>
<tr><td><code id="dummy_dt_+3A_longname">longname</code></td>
<td>
<p>logical. Should the output column labeled with the
original column name? Default uses <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no columns provided, will return the original data frame.
When NA exist in the input column, they would also be considered. If
the input character column contains both NA and string &quot;NA&quot;, they would be
merged.
</p>
<p>This function is inspired by <span class="pkg">fastDummies</span> package, but provides
simple and precise usage, whereas <code>fastDummies::dummy_cols</code> provides more
features for statistical usage.
</p>


<h3>Value</h3>

<p>data.table
</p>


<h3>References</h3>

<p>https://stackoverflow.com/questions/18881073/creating-dummy-variables-in-r-data-table
</p>


<h3>See Also</h3>

<p><code><a href="fastDummies.html#topic+dummy_cols">dummy_cols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% dummy_dt(Species)
iris %&gt;% dummy_dt(Species,longname = FALSE)

mtcars %&gt;% head() %&gt;% dummy_dt(vs,am)
mtcars %&gt;% head() %&gt;% dummy_dt("cyl|gear")

# when there are NAs in the column
df &lt;- data.table(x = c("a", "b", NA, NA),y = 1:4)
df %&gt;%
  dummy_dt(x)

# when NA  and "NA" both exist, they would be merged
df &lt;- data.table(x = c("a", "b", NA, "NA"),y = 1:4)
df %&gt;%
  dummy_dt(x)

</code></pre>

<hr>
<h2 id='export_fst'>Read and write fst files</h2><span id='topic+export_fst'></span><span id='topic+import_fst'></span>

<h3>Description</h3>

<p>Wrapper for <code><a href="fst.html#topic+read_fst">read_fst</a></code> and <code><a href="fst.html#topic+write_fst">write_fst</a></code>
from <span class="pkg">fst</span>, but use a different default. For data import, always return a data.table.
For data export, always compress the data to the smallest size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_fst(x, path, compress = 100, uniform_encoding = TRUE)

import_fst(
  path,
  columns = NULL,
  from = 1,
  to = NULL,
  as.data.table = TRUE,
  old_format = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_fst_+3A_x">x</code></td>
<td>
<p>a data frame to write to disk</p>
</td></tr>
<tr><td><code id="export_fst_+3A_path">path</code></td>
<td>
<p>path to fst file</p>
</td></tr>
<tr><td><code id="export_fst_+3A_compress">compress</code></td>
<td>
<p>value in the range 0 to 100, indicating the amount of compression to use.
Lower values mean larger file sizes. The default compression is set to 50.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_uniform_encoding">uniform_encoding</code></td>
<td>
<p>If 'TRUE', all character vectors will be assumed to have elements with equal encoding.
The encoding (latin1, UTF8 or native) of the first non-NA element will used as encoding for the whole column.
This will be a correct assumption for most use cases.
If 'uniform.encoding' is set to 'FALSE', no such assumption will be made and all elements will be converted
to the same encoding. The latter is a relatively expensive operation and will reduce write performance for
character columns.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_columns">columns</code></td>
<td>
<p>Column names to read. The default is to read all columns.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_from">from</code></td>
<td>
<p>Read data starting from this row number.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_to">to</code></td>
<td>
<p>Read data up until this row number. The default is to read to the last row of the stored dataset.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_as.data.table">as.data.table</code></td>
<td>
<p>If TRUE, the result will be returned as a <code>data.table</code> object. Any keys set on
dataset <code>x</code> before writing will be retained. This allows for storage of sorted datasets. This option
requires <code>data.table</code> package to be installed.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_old_format">old_format</code></td>
<td>
<p>must be FALSE, the old fst file format is deprecated and can only be read and
converted with fst package versions 0.8.0 to 0.8.10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'import_fst' returns a data.table with the selected columns and rows. 'export_fst'
writes 'x' to a 'fst' file and invisibly returns 'x' (so you can use this function in a pipeline).
</p>


<h3>See Also</h3>

<p><code><a href="fst.html#topic+read_fst">read_fst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
export_fst(iris,"iris_fst_test.fst")
iris_dt = import_fst("iris_fst_test.fst")
iris_dt
unlink("iris_fst_test.fst")

## End(Not run)
</code></pre>

<hr>
<h2 id='filter_dt'>Filter entries in data.frame</h2><span id='topic+filter_dt'></span>

<h3>Description</h3>

<p>Choose rows where conditions are true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_dt(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_dt_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="filter_dt_+3A_...">...</code></td>
<td>
<p>List of variables or name-value pairs of summary/modifications
functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+filter">filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% filter_dt(Sepal.Length &gt; 7)
iris %&gt;% filter_dt(Sepal.Length == max(Sepal.Length))

# comma is not supported in tidyfst after v0.9.8
# which means you can't use:
## Not run: 
 iris %&gt;% filter_dt(Sepal.Length &gt; 7, Sepal.Width &gt; 3)

## End(Not run)
# use following code instead
iris %&gt;% filter_dt(Sepal.Length &gt; 7 &amp; Sepal.Width &gt; 3)

</code></pre>

<hr>
<h2 id='fst'>Parse,inspect and extract data.table from fst file</h2><span id='topic+fst'></span><span id='topic+parse_fst'></span><span id='topic+slice_fst'></span><span id='topic+select_fst'></span><span id='topic+filter_fst'></span><span id='topic+summary_fst'></span>

<h3>Description</h3>

<p>A tookit of APIs for reading fst file as data.table, could select by column, row and conditional filtering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_fst(path)

slice_fst(ft, row_no)

select_fst(ft, ...)

filter_fst(ft, ...)

summary_fst(ft)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fst_+3A_path">path</code></td>
<td>
<p>path to fst file</p>
</td></tr>
<tr><td><code id="fst_+3A_ft">ft</code></td>
<td>
<p>An object of class fst_table, returned by <code>parse_fst</code></p>
</td></tr>
<tr><td><code id="fst_+3A_row_no">row_no</code></td>
<td>
<p>An integer vector (Positive)</p>
</td></tr>
<tr><td><code id="fst_+3A_...">...</code></td>
<td>
<p>The filter conditions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary_fst</code> could provide some basic information about
the fst table.
</p>


<h3>Value</h3>

<p><code>parse_fst</code> returns a fst_table class.
</p>
<p><code>select_fst</code> and <code>filter_fst</code> returns a data.table.
</p>


<h3>See Also</h3>

<p><code><a href="fst.html#topic+fst">fst</a></code>, <code><a href="fst.html#topic+metadata_fst">metadata_fst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  fst::write_fst(iris,"iris_test.fst")
  # parse the file but not reading it
  parse_fst("iris_test.fst") -&gt; ft
  ft

  class(ft)
  lapply(ft,class)
  names(ft)
  dim(ft)
  summary_fst(ft)

  # get the data by query
  ft %&gt;% slice_fst(1:3)
  ft %&gt;% slice_fst(c(1,3))

  ft %&gt;% select_fst(Sepal.Length)
  ft %&gt;% select_fst(Sepal.Length,Sepal.Width)
  ft %&gt;% select_fst("Sepal.Length")
  ft %&gt;% select_fst(1:3)
  ft %&gt;% select_fst(1,3)
  ft %&gt;% select_fst("Se")
  ft %&gt;% select_fst("nothing")
  ft %&gt;% select_fst("Se|Sp")
  ft %&gt;% select_fst(cols = names(iris)[2:3])

  ft %&gt;% filter_fst(Sepal.Width &gt; 3)
  ft %&gt;% filter_fst(Sepal.Length &gt; 6 , Species == "virginica")
  ft %&gt;% filter_fst(Sepal.Length &gt; 6 &amp; Species == "virginica" &amp; Sepal.Width &lt; 3)

  unlink("iris_test.fst")

## End(Not run)
</code></pre>

<hr>
<h2 id='group_by_dt'>Group by variable(s) and implement operations</h2><span id='topic+group_by_dt'></span><span id='topic+group_exe_dt'></span>

<h3>Description</h3>

<p>Carry out data manipulation within specified groups. Different from <code>group_dt</code>,
the implementation is split into two operations, namely grouping and implementation.
</p>
<p>Using <code>setkey</code> and <code>setkeyv</code> in <span class="pkg">data.table</span>
to carry out <code>group_by</code>-like functionalities in <span class="pkg">dplyr</span>. This is
not only convenient but also efficient in computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by_dt(.data, ..., cols = NULL)

group_exe_dt(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by_dt_+3A_.data">.data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="group_by_dt_+3A_...">...</code></td>
<td>
<p>Variables to group by for <code>group_by_dt</code>,
namely the columns to sort by. Do not quote the column names.
Any data manipulation arguments that could be
implemented on a data.frame for <code>group_exe_dt</code>.
It can receive what <code>select_dt</code> receives.</p>
</td></tr>
<tr><td><code id="group_by_dt_+3A_cols">cols</code></td>
<td>
<p>A character vector of column names to group by.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>group_by_dt</code> and <code>group_exe_dt</code> are a pair of functions
to be used in combination. It utilizes the feature of key setting in data.table,
which provides high performance for group operations, especially when you have
to operate by specific groups frequently.
</p>


<h3>Value</h3>

<p>A data.table with keys
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# aggregation after grouping using group_exe_dt
as.data.table(iris) -&gt; a
a %&gt;%
  group_by_dt(Species) %&gt;%
  group_exe_dt(head(1))

a %&gt;%
  group_by_dt(Species) %&gt;%
  group_exe_dt(
    head(3) %&gt;%
      summarise_dt(sum = sum(Sepal.Length))
  )

mtcars %&gt;%
  group_by_dt("cyl|am") %&gt;%
  group_exe_dt(
    summarise_dt(mpg_sum = sum(mpg))
  )
# equals to
mtcars %&gt;%
  group_by_dt(cols = c("cyl","am")) %&gt;%
  group_exe_dt(
    summarise_dt(mpg_sum = sum(mpg))
  )
</code></pre>

<hr>
<h2 id='group_dt'>Data manipulation within groups</h2><span id='topic+group_dt'></span><span id='topic+rowwise_dt'></span>

<h3>Description</h3>

<p>Carry out data manipulation within specified groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_dt(.data, by = NULL, ...)

rowwise_dt(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_dt_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="group_dt_+3A_by">by</code></td>
<td>
<p>Variables to group by,unquoted name of grouping variable of list of unquoted names of grouping variables.</p>
</td></tr>
<tr><td><code id="group_dt_+3A_...">...</code></td>
<td>
<p>Any data manipulation arguments that could be implemented on a data.frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you want to use <code>summarise_dt</code> and <code>mutate_dt</code> in
<code>group_dt</code>, it is better to use the &quot;by&quot; parameter in those functions,
that would be much faster because you don't have to use <code>.SD</code> (which takes
extra time to copy).
</p>


<h3>Value</h3>

<p>data.table
</p>


<h3>References</h3>

<p>https://stackoverflow.com/questions/36802385/use-by-each-row-for-data-table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% group_dt(by = Species,slice_dt(1:2))
iris %&gt;% group_dt(Species,filter_dt(Sepal.Length == max(Sepal.Length)))
iris %&gt;% group_dt(Species,summarise_dt(new = max(Sepal.Length)))

# you can pipe in the `group_dt`
iris %&gt;% group_dt(Species,
                  mutate_dt(max= max(Sepal.Length)) %&gt;%
                    summarise_dt(sum=sum(Sepal.Length)))

# for users familiar with data.table, you can work on .SD directly
# following codes get the first and last row from each group
iris %&gt;%
  group_dt(
    by = Species,
    rbind(.SD[1],.SD[.N])
  )

#' # for summarise_dt, you can use "by" to calculate within the group
mtcars %&gt;%
  summarise_dt(
   disp = mean(disp),
   hp = mean(hp),
   by = cyl
)

  # but you could also, of course, use group_dt
 mtcars %&gt;%
   group_dt(by =.(vs,am),
     summarise_dt(avg = mean(mpg)))

  # and list of variables could also be used
 mtcars %&gt;%
   group_dt(by =list(vs,am),
            summarise_dt(avg = mean(mpg)))

# examples for `rowwise_dt`
df &lt;- data.table(x = 1:2, y = 3:4, z = 4:5)

df %&gt;% mutate_dt(m = mean(c(x, y, z)))

df %&gt;% rowwise_dt(
  mutate_dt(m = mean(c(x, y, z)))
)
</code></pre>

<hr>
<h2 id='impute_dt'>Impute missing values with mean, median or mode</h2><span id='topic+impute_dt'></span>

<h3>Description</h3>

<p>Impute the columns of data.frame with its mean, median or mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_dt(.data, ..., .func = "mode")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_dt_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="impute_dt_+3A_...">...</code></td>
<td>
<p>Columns to select</p>
</td></tr>
<tr><td><code id="impute_dt_+3A_.func">.func</code></td>
<td>
<p>Character, &quot;mode&quot; (default), &quot;mean&quot; or &quot;median&quot;.
Could also define it by oneself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Pclass &lt;- c(3, 1, 3, 1, 3, 2, 2, 3, NA, NA)
Sex &lt;- c('male', 'male', 'female', 'female', 'female',
         'female', NA, 'male', 'female', NA)
Age &lt;- c(22, 38, 26, 35, NA,
         45, 25, 39, 28, 40)
SibSp &lt;- c(0, 1, 3, 1, 2, 3, 2, 2, NA, 0)
Fare &lt;- c(7.25, 71.3, 7.92, NA, 8.05, 8.46, 51.9, 60, 32, 15)
Embarked &lt;- c('S', NA, 'S', 'Q', 'Q', 'S', 'C', 'S', 'C', 'S')
data &lt;- data.frame('Pclass' = Pclass,
 'Sex' = Sex, 'Age' = Age, 'SibSp' = SibSp,
 'Fare' = Fare, 'Embarked' = Embarked)

data
data %&gt;% impute_dt() # defalut uses "mode" as `.func`
data %&gt;% impute_dt(is.numeric,.func = "mean")
data %&gt;% impute_dt(is.numeric,.func = "median")

my_fun = function(x){
  x[is.na(x)] = (max(x,na.rm = TRUE) - min(x,na.rm = TRUE))/2
  x
}
data %&gt;% impute_dt(is.numeric,.func = my_fun)

</code></pre>

<hr>
<h2 id='in_dt'>Short cut to data.table</h2><span id='topic+in_dt'></span><span id='topic+as_dt'></span>

<h3>Description</h3>

<p>To use facilities provided by <span class="pkg">data.table</span>, but do not have to
load <span class="pkg">data.table</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_dt(.data, ...)

as_dt(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_dt_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="in_dt_+3A_...">...</code></td>
<td>
<p>Recieve <code>B</code> in data.table's <code>A[B]</code> syntax.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>as_dt</code> could turn any data frame to data.table class. If the data is
not a data frame, return error.
</p>
<p>The <code>in_dt</code> function creates a virtual environment in data.table, it could be
piped well because it still follows the principals of <span class="pkg">tidyfst</span>, which are: (1) Never
use in place replacement and (2) Always recieves a data frame (data.frame/tibble/data.table)
and returns a data.table. Therefore, the in place functions like <code>:=</code> will still
return the results.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+data.table">data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% as_dt()
iris %&gt;% in_dt(order(-Sepal.Length),.SD[.N],by=Species)
</code></pre>

<hr>
<h2 id='intersect_dt'>Set operations for data frames</h2><span id='topic+intersect_dt'></span><span id='topic+union_dt'></span><span id='topic+setdiff_dt'></span><span id='topic+setequal_dt'></span>

<h3>Description</h3>

<p>Wrappers of set operations in <span class="pkg">data.table</span>.
Only difference is it could be applied to non-data.table data frames by
recognizing and coercing them to data.table automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect_dt(x, y, all = FALSE)

union_dt(x, y, all = FALSE)

setdiff_dt(x, y, all = FALSE)

setequal_dt(x, y, all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect_dt_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="intersect_dt_+3A_y">y</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="intersect_dt_+3A_all">all</code></td>
<td>
<p>Logical. When <code>FALSE</code> (default),
removes duplicate rows on the result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+setops">setops</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = iris[c(2,3,3,4),]
x2 = iris[2:4,]
y = iris[c(3:5),]

intersect_dt(x, y)            # intersect
intersect_dt(x, y, all=TRUE)  # intersect all
setdiff_dt(x, y)              # except
setdiff_dt(x, y, all=TRUE)    # except all
union_dt(x, y)                # union
union_dt(x, y, all=TRUE)      # union all
setequal_dt(x, x2, all=FALSE) # setequal
setequal_dt(x, x2)            # setequal all

</code></pre>

<hr>
<h2 id='join'>Join tables</h2><span id='topic+join'></span><span id='topic+inner_join_dt'></span><span id='topic+left_join_dt'></span><span id='topic+right_join_dt'></span><span id='topic+full_join_dt'></span><span id='topic+anti_join_dt'></span><span id='topic+semi_join_dt'></span>

<h3>Description</h3>

<p>The mutating joins add columns from 'y' to 'x',
matching rows based on the keys:
</p>
<p>* 'inner_join_dt()': includes all rows in 'x' and 'y'.
* 'left_join_dt()': includes all rows in 'x'.
* 'right_join_dt()': includes all rows in 'y'.
* 'full_join_dt()': includes all rows in 'x' or 'y'.
</p>
<p>Filtering joins filter rows from 'x' based on the presence or absence
of matches in 'y':
</p>
<p>* 'semi_join_dt()' return all rows from 'x' with a match in 'y'.
* 'anti_join_dt()' return all rows from 'x' without a match in 'y'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_join_dt(x, y, by = NULL, on = NULL, suffix = c(".x", ".y"))

left_join_dt(x, y, by = NULL, on = NULL, suffix = c(".x", ".y"))

right_join_dt(x, y, by = NULL, on = NULL, suffix = c(".x", ".y"))

full_join_dt(x, y, by = NULL, on = NULL, suffix = c(".x", ".y"))

anti_join_dt(x, y, by = NULL, on = NULL)

semi_join_dt(x, y, by = NULL, on = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_+3A_x">x</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="join_+3A_y">y</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="join_+3A_by">by</code></td>
<td>
<p>(Optional) A character vector of variables to join by.
</p>
<p>If 'NULL', the default, '*_join_dt()' will perform a natural join, using all
variables in common across 'x' and 'y'. A message lists the variables so that you
can check they're correct; suppress the message by supplying 'by' explicitly.
</p>
<p>To join by different variables on 'x' and 'y', use a named vector.
For example, 'by = c(&quot;a&quot; = &quot;b&quot;)' will match 'x$a' to 'y$b'.
</p>
<p>To join by multiple variables, use a vector with length &gt; 1.
For example, 'by = c(&quot;a&quot;, &quot;b&quot;)' will match 'x$a' to 'y$a' and 'x$b' to
'y$b'. Use a named vector to match different variables in 'x' and 'y'.
For example, 'by = c(&quot;a&quot; = &quot;b&quot;, &quot;c&quot; = &quot;d&quot;)' will match 'x$a' to 'y$b' and
'x$c' to 'y$d'.</p>
</td></tr>
<tr><td><code id="join_+3A_on">on</code></td>
<td>
<p>(Optional)
Indicate which columns in x should be joined with which columns in y.
Examples included:
1.<code>.by = c("a","b")</code> (this is a must for <code>set_full_join_dt</code>);
2.<code>.by = c(x1="y1", x2="y2")</code>;
3.<code>.by = c("x1==y1", "x2==y2")</code>;
4.<code>.by = c("a", V2="b")</code>;
5.<code>.by = .(a, b)</code>;
6.<code>.by = c("x&gt;=a", "y&lt;=b")</code> or <code>.by = .(x&gt;=a, y&lt;=b)</code>.</p>
</td></tr>
<tr><td><code id="join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in x and y, these
suffixes will be added to the output to disambiguate them. Should be a
character vector of length 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
workers = fread("
    name company
    Nick Acme
    John Ajax
    Daniela Ajax
")

positions = fread("
    name position
    John designer
    Daniela engineer
    Cathie manager
")

workers %&gt;% inner_join_dt(positions)
workers %&gt;% left_join_dt(positions)
workers %&gt;% right_join_dt(positions)
workers %&gt;% full_join_dt(positions)

# filtering joins
workers %&gt;% anti_join_dt(positions)
workers %&gt;% semi_join_dt(positions)

# To suppress the message, supply 'by' argument
workers %&gt;% left_join_dt(positions, by = "name")

# Use a named 'by' if the join variables have different names
positions2 = setNames(positions, c("worker", "position")) # rename first column in 'positions'
workers %&gt;% inner_join_dt(positions2, by = c("name" = "worker"))

# the syntax of 'on' could be a bit different
workers %&gt;% inner_join_dt(positions2,on = "name==worker")


</code></pre>

<hr>
<h2 id='lead_dt'>Fast lead/lag for vectors</h2><span id='topic+lead_dt'></span><span id='topic+lag_dt'></span>

<h3>Description</h3>

<p>Find the &quot;next&quot; or &quot;previous&quot; values in a vector.
It has wrapped <span class="pkg">data.table</span>'s <code>shift</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lead_dt(x, n = 1L, fill = NA)

lag_dt(x, n = 1L, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lead_dt_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="lead_dt_+3A_n">n</code></td>
<td>
<p>a positive integer of length 1,
giving the number of positions to lead or lag by. Default uses 1</p>
</td></tr>
<tr><td><code id="lead_dt_+3A_fill">fill</code></td>
<td>
<p>Value to use for padding when the window goes beyond the input length.
Default uses <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+lead">lead</a></code>,<code><a href="data.table.html#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lead_dt(1:5)
lag_dt(1:5)
lead_dt(1:5,2)
lead_dt(1:5,n = 2,fill = 0)
</code></pre>

<hr>
<h2 id='longer_dt'>Pivot data from wide to long</h2><span id='topic+longer_dt'></span>

<h3>Description</h3>

<p>Turning a wide table to its longer form. It takes multiple columns and collapses into key-value pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longer_dt(.data, ..., name = "name", value = "value", na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longer_dt_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="longer_dt_+3A_...">...</code></td>
<td>
<p>Pattern for unchanged group or unquoted names. Pattern can accept
regular expression to match column names. It can recieve what <code>select_dt</code>
recieves.</p>
</td></tr>
<tr><td><code id="longer_dt_+3A_name">name</code></td>
<td>
<p>Name for the measured variable names column.
The default name is 'name'.</p>
</td></tr>
<tr><td><code id="longer_dt_+3A_value">value</code></td>
<td>
<p>Name for the molten data values column(s).
The default name is 'value'.</p>
</td></tr>
<tr><td><code id="longer_dt_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, <code>NA</code> values will be removed from the molten data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wider_dt">wider_dt</a></code>,
<code><a href="data.table.html#topic+melt">melt</a></code>,
<code><a href="tidyr.html#topic+pivot_longer">pivot_longer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1:
stocks = data.frame(
  time = as.Date('2009-01-01') + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
)

stocks

stocks %&gt;%
  longer_dt(time)

stocks %&gt;%
  longer_dt("ti")

# Example 2:


  library(tidyr)

  billboard %&gt;%
    longer_dt(
      -"wk",
      name = "week",
      value = "rank",
      na.rm = TRUE
    )

  # or use:
  billboard %&gt;%
    longer_dt(
      artist,track,date.entered,
      name = "week",
      value = "rank",
      na.rm = TRUE
    )

  # or use:
  billboard %&gt;%
    longer_dt(
      1:3,
      name = "week",
      value = "rank",
      na.rm = TRUE
    )

</code></pre>

<hr>
<h2 id='mat_df'>Conversion between tidy table and named matrix</h2><span id='topic+mat_df'></span><span id='topic+df_mat'></span>

<h3>Description</h3>

<p>Convenient fucntions to implement conversion between
tidy table and named matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_df(m)

df_mat(df, row, col, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat_df_+3A_m">m</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="mat_df_+3A_df">df</code></td>
<td>
<p>A data.frame with at least 3 columns, one for row name,
one for column name, and one for values. The names for column and
row should be unique.</p>
</td></tr>
<tr><td><code id="mat_df_+3A_row">row</code></td>
<td>
<p>Unquoted expression of column name for row</p>
</td></tr>
<tr><td><code id="mat_df_+3A_col">col</code></td>
<td>
<p>Unquoted expression of column name for column</p>
</td></tr>
<tr><td><code id="mat_df_+3A_value">value</code></td>
<td>
<p>Unquoted expression of column name for values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>mat_df</code>, a data.frame.
For <code>df_mat</code>, a named matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mm = matrix(c(1:8,NA),ncol = 3,dimnames = list(letters[1:3],LETTERS[1:3]))
mm
tdf = mat_df(mm)
tdf
mat = df_mat(tdf,row,col,value)
setequal(mm,mat)

tdf %&gt;%
  setNames(c("A","B","C")) %&gt;%
  df_mat(A,B,C)

</code></pre>

<hr>
<h2 id='mutate_dt'>Mutate columns in data.frame</h2><span id='topic+mutate_dt'></span><span id='topic+transmute_dt'></span>

<h3>Description</h3>

<p>Adds or updates columns in data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_dt(.data, ..., by)

transmute_dt(.data, ..., by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_dt_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="mutate_dt_+3A_...">...</code></td>
<td>
<p>List of variables or name-value pairs of summary/modifications
functions.</p>
</td></tr>
<tr><td><code id="mutate_dt_+3A_by">by</code></td>
<td>
<p>(Optional) Mutate by what group?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate">mutate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;% mutate_dt(one = 1,Sepal.Length = Sepal.Length + 1)
iris %&gt;% transmute_dt(one = 1,Sepal.Length = Sepal.Length + 1)
# add group number with symbol `.GRP`
iris %&gt;% mutate_dt(id = 1:.N,grp = .GRP,by = Species)

</code></pre>

<hr>
<h2 id='mutate_when'>Conditional update of columns in data.table</h2><span id='topic+mutate_when'></span><span id='topic+mutate_vars'></span>

<h3>Description</h3>

<p>Update or add columns when the given condition is met.
</p>
<p><code>mutate_when</code> integrates <code>mutate</code> and <code>case_when</code>
in <span class="pkg">dplyr</span> and make a new tidy verb for data.table. <code>mutate_vars</code> is
a super function to do updates in specific columns according to conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_when(.data, when, ..., by)

mutate_vars(.data, .cols = NULL, .func, ..., by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_when_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="mutate_when_+3A_when">when</code></td>
<td>
<p>An object which can be coerced to logical mode</p>
</td></tr>
<tr><td><code id="mutate_when_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions for <code>mutate_when</code>.
Additional parameters to be passed to parameter '.func' in <code>mutate_vars</code>.</p>
</td></tr>
<tr><td><code id="mutate_when_+3A_by">by</code></td>
<td>
<p>(Optional) Mutate by what group?</p>
</td></tr>
<tr><td><code id="mutate_when_+3A_.cols">.cols</code></td>
<td>
<p>Any types that can be accepted by <code><a href="#topic+select_dt">select_dt</a></code>.</p>
</td></tr>
<tr><td><code id="mutate_when_+3A_.func">.func</code></td>
<td>
<p>Function to be run within each column, should return a value or
vectors with same length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select_dt">select_dt</a></code>, <code><a href="dplyr.html#topic+case_when">case_when</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris[3:8,]
iris[3:8,] %&gt;%
  mutate_when(Petal.Width == .2,
              one = 1,Sepal.Length=2)

iris %&gt;% mutate_vars("Pe",scale)
iris %&gt;% mutate_vars(is.numeric,scale)
iris %&gt;% mutate_vars(-is.factor,scale)
iris %&gt;% mutate_vars(1:2,scale)
iris %&gt;% mutate_vars(.func = as.character)
</code></pre>

<hr>
<h2 id='nest_dt'>Nest and unnest</h2><span id='topic+nest_dt'></span><span id='topic+unnest_dt'></span><span id='topic+squeeze_dt'></span><span id='topic+chop_dt'></span><span id='topic+unchop_dt'></span>

<h3>Description</h3>

<p>Create or melt list columns in data.frame.
</p>
<p>Analogous function for <code>nest</code> and <code>unnest</code> in <span class="pkg">tidyr</span>.
<code>unnest_dt</code> will automatically remove other list-columns except for the
target list-columns (which would be unnested later). Also, <code>squeeze_dt</code> is
designed to merge multiple columns into list column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_dt(.data, ..., mcols = NULL, .name = "ndt")

unnest_dt(.data, ...)

squeeze_dt(.data, ..., .name = "ndt")

chop_dt(.data, ...)

unchop_dt(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_dt_+3A_.data">.data</code></td>
<td>
<p>data.table, nested or unnested</p>
</td></tr>
<tr><td><code id="nest_dt_+3A_...">...</code></td>
<td>
<p>The variables for nest group(for <code>nest_dt</code>),
columns to be nested(for <code>squeeze_dt</code> and <code>chop_dt</code>),
or column(s) to be unnested(for <code>unnest_dt</code>).
Could recieve anything that <code><a href="#topic+select_dt">select_dt</a></code> could receive.</p>
</td></tr>
<tr><td><code id="nest_dt_+3A_mcols">mcols</code></td>
<td>
<p>Name-variable pairs in the list, form like</p>
</td></tr>
<tr><td><code id="nest_dt_+3A_.name">.name</code></td>
<td>
<p>Character. The nested column name. Defaults to &quot;ndt&quot;.
<code>list(petal="^Pe",sepal="^Se")</code>, see example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the <code>nest_dt</code>, the data would be nested to a column named 'ndt',
which is short for nested data.table.
</p>
<p>The <code>squeeze_dt</code> would not remove the originial columns.
</p>
<p>The <code>unchop_dt</code> is the reverse operation of <code>chop_dt</code>.
</p>
<p>These functions are experiencing the experimental stage, especially
the <code>unnest_dt</code>. If they don't work on some circumtances, try <span class="pkg">tidyr</span>
package.
</p>


<h3>Value</h3>

<p>data.table, nested or unnested
</p>


<h3>References</h3>

<p>https://www.r-bloggers.com/much-faster-unnesting-with-data-table/
</p>
<p>https://stackoverflow.com/questions/25430986/create-nested-data-tables-by-collapsing-rows-into-new-data-tables
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+nest">nest</a></code>, <code><a href="tidyr.html#topic+chop">chop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# examples for nest_dt
# nest by which columns?
 mtcars %&gt;% nest_dt(cyl)
 mtcars %&gt;% nest_dt("cyl")
 mtcars %&gt;% nest_dt(cyl,vs)
 mtcars %&gt;% nest_dt(vs:am)
 mtcars %&gt;% nest_dt("cyl|vs")
 mtcars %&gt;% nest_dt(c("cyl","vs"))

 # change the nested column name
 mtcars %&gt;% nest_dt(cyl,.name = "data")

# nest two columns directly
iris %&gt;% nest_dt(mcols = list(petal="^Pe",sepal="^Se"))

# nest more flexibly
iris %&gt;% nest_dt(mcols = list(ndt1 = 1:3,
  ndt2 = "Pe",
  ndt3 = Sepal.Length:Sepal.Width))

# examples for unnest_dt
# unnest which column?
 mtcars %&gt;% nest_dt("cyl|vs") %&gt;%
   unnest_dt(ndt)
 mtcars %&gt;% nest_dt("cyl|vs") %&gt;%
   unnest_dt("ndt")

df &lt;- data.table(
  a = list(c("a", "b"), "c"),
  b = list(c(TRUE,TRUE),FALSE),
  c = list(3,c(1,2)),
  d = c(11, 22)
)

df
df %&gt;% unnest_dt(a)
df %&gt;% unnest_dt(2)
df %&gt;% unnest_dt("c")
df %&gt;% unnest_dt(cols = names(df)[3])

# You can unnest multiple columns simultaneously
df %&gt;% unnest_dt(1:3)
df %&gt;% unnest_dt(a,b,c)
df %&gt;% unnest_dt("a|b|c")

# examples for squeeze_dt
# nest which columns?
iris %&gt;% squeeze_dt(1:2)
iris %&gt;% squeeze_dt("Se")
iris %&gt;% squeeze_dt(Sepal.Length:Petal.Width)
iris %&gt;% squeeze_dt(1:2,.name = "data")

# examples for chop_dt
df &lt;- data.table(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
df %&gt;% chop_dt(y,z)
df %&gt;% chop_dt(y,z) %&gt;% unchop_dt(y,z)
</code></pre>

<hr>
<h2 id='nth'>Extract the nth value from a vector</h2><span id='topic+nth'></span><span id='topic+maxth'></span><span id='topic+minth'></span>

<h3>Description</h3>

<p><code>nth</code> get the value from a vector with its position,
while <code>maxth</code> and <code>minth</code> get the nth highest or lowest value
from the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nth(v, n = 1)

maxth(v, n = 1)

minth(v, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nth_+3A_v">v</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="nth_+3A_n">n</code></td>
<td>
<p>For<code>nth</code>, a single integer specifying the position. Default uses <code>1</code>.
Negative integers index from the end
(i.e. -1L will return the last value in the vector).
If a double is supplied, it will be silently truncated.
For <code>maxth</code> and <code>minth</code>, a single integer indicating the nth
highest or lowest value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value.
</p>


<h3>References</h3>

<p>https://stackoverflow.com/questions/2453326/fastest-way-to-find-second-third-highest-lowest-value-in-vector-or-column/66367996#66367996
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = 1:10
nth(x, 1)
nth(x, 5)
nth(x, -2)

y = c(10,3,4,5,2,1,6,9,7,8)
maxth(y,3)
minth(y,3)

</code></pre>

<hr>
<h2 id='object_size'>Nice printing of report the Space Allocated for an Object</h2><span id='topic+object_size'></span>

<h3>Description</h3>

<p>Provides an estimate of the memory that is being used to store an R object.
A wrapper of 'object.size', but use a nicer printing unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_size(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_size_+3A_object">object</code></td>
<td>
<p>an R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;object_size&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;% object_size()

</code></pre>

<hr>
<h2 id='pairwise_count_dt'>Count pairs of items within a group</h2><span id='topic+pairwise_count_dt'></span>

<h3>Description</h3>

<p>Count the number of times each pair
of items appear together within a group.
For example, this could count the number of times two words appear within documents.
This function has referred to <code>pairwise_count</code> in <strong>widyr</strong> package,
but with very different defaults on several parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_count_dt(
  .data,
  .group,
  .value,
  upper = FALSE,
  diag = FALSE,
  sort = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise_count_dt_+3A_.data">.data</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="pairwise_count_dt_+3A_.group">.group</code></td>
<td>
<p>Column name of counting group.</p>
</td></tr>
<tr><td><code id="pairwise_count_dt_+3A_.value">.value</code></td>
<td>
<p>Item to count pairs, will end up in <code>V1</code> and <code>V2</code> columns.</p>
</td></tr>
<tr><td><code id="pairwise_count_dt_+3A_upper">upper</code></td>
<td>
<p>When <code>FALSE</code>(Default), duplicated combinations would be removed.</p>
</td></tr>
<tr><td><code id="pairwise_count_dt_+3A_diag">diag</code></td>
<td>
<p>Whether to include diagonal (V1==V2) in output. Default uses <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pairwise_count_dt_+3A_sort">sort</code></td>
<td>
<p>Whether to sort rows by counts. Default uses <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with 3 columns (named as &quot;V1&quot;,&quot;V2&quot; and &quot;n&quot;), containing combinations
in &quot;V1&quot; and &quot;V2&quot;, and counts in &quot;n&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="widyr.html#topic+pairwise_count">pairwise_count</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.table(group = rep(1:5, each = 2),
              letter = c("a", "b",
                         "a", "c",
                         "a", "c",
                         "b", "e",
                         "b", "f"))
pairwise_count_dt(dat,group,letter)
pairwise_count_dt(dat,group,letter,sort = FALSE)
pairwise_count_dt(dat,group,letter,upper = TRUE)
pairwise_count_dt(dat,group,letter,diag = TRUE)
pairwise_count_dt(dat,group,letter,diag = TRUE,upper = TRUE)

# The column name could be specified using character.
pairwise_count_dt(dat,"group","letter")
</code></pre>

<hr>
<h2 id='percent'>Add percentage to counts in data.frame</h2><span id='topic+percent'></span><span id='topic+add_prop'></span>

<h3>Description</h3>

<p>Add percentage for counts in the data.frame, both numeric and
character with '
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percent(x, digits = 1)

add_prop(.data, count_name = last(names(.data)), digits = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percent_+3A_x">x</code></td>
<td>
<p>A number (numeric).</p>
</td></tr>
<tr><td><code id="percent_+3A_digits">digits</code></td>
<td>
<p>How many digits to keep in the percentage. Default uses 1.</p>
</td></tr>
<tr><td><code id="percent_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="percent_+3A_count_name">count_name</code></td>
<td>
<p>Column name of counts (Character).
Default uses the last column of data.frame.</p>
</td></tr>
</table>


<h3>References</h3>

<p>https://stackoverflow.com/questions/7145826/how-to-format-a-number-as-percentage-in-r
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 percent(0.9057)
 percent(0.9057,3)

 iris %&gt;%
   count_dt(Species) %&gt;%
   add_prop()

 iris %&gt;%
   count_dt(Species) %&gt;%
   add_prop(count_name = "n",digits = 2)

</code></pre>

<hr>
<h2 id='pkg_load'>Load or unload R package(s)</h2><span id='topic+pkg_load'></span><span id='topic+pkg_unload'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code><a href="base.html#topic+require">require</a></code> and
<code><a href="base.html#topic+detach">detach</a></code>.  <code>pkg_load</code> checks to see if a
package is installed, if not it attempts to install the package
from CRAN. <code>pkg_unload</code> can detach one or more loaded packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkg_load(..., pkg_names = NULL)

pkg_unload(..., pkg_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkg_load_+3A_...">...</code></td>
<td>
<p>Name(s) of package(s).</p>
</td></tr>
<tr><td><code id="pkg_load_+3A_pkg_names">pkg_names</code></td>
<td>
<p>(Optional)Character vector containing packages to load
or unload. Default uses <code>NULL</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+require">require</a></code>,
<code><a href="base.html#topic+detach">detach</a></code>,
<code><a href="pacman.html#topic+p_load">p_load</a></code>,
<code><a href="pacman.html#topic+p_unload">p_unload</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pkg_load(data.table)
pkg_unload(data.table)

pkg_load(stringr,fst)
pkg_unload(stringr,fst)

pkg_load(pkg_names = c("data.table","fst"))
p_unload(pkg_names = c("data.table","fst"))

pkg_load(data.table,stringr,fst)
pkg_unload("all") # shortcut to unload all loaded packages

## End(Not run)
</code></pre>

<hr>
<h2 id='print_options'>Set global printing method for data.table</h2><span id='topic+print_options'></span>

<h3>Description</h3>

<p>This function allow user to define how data.table is printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_options(
  topn = 5,
  nrows = 100,
  class = TRUE,
  row.names = TRUE,
  col.names = "auto",
  print.keys = TRUE,
  trunc.cols = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_options_+3A_topn">topn</code></td>
<td>
<p>The number of rows to be printed from the beginning and
end of tables with more than <code>nrow</code> rows.</p>
</td></tr>
<tr><td><code id="print_options_+3A_nrows">nrows</code></td>
<td>
<p>The number of rows which will be printed before truncation is enforced.</p>
</td></tr>
<tr><td><code id="print_options_+3A_class">class</code></td>
<td>
<p>If <code>TRUE</code>, the resulting output will include above each column its storage class (or a self-evident abbreviation thereof).</p>
</td></tr>
<tr><td><code id="print_options_+3A_row.names">row.names</code></td>
<td>
<p>If <code>TRUE</code>, row indices will be printed.</p>
</td></tr>
<tr><td><code id="print_options_+3A_col.names">col.names</code></td>
<td>
<p>One of three flavours for controlling the display of column names in output. <code>"auto"</code> includes column names above the data, as well as below the table if <code>nrow(x) &gt; 20</code>. <code>"top"</code> excludes this lower register when applicable, and <code>"none"</code> suppresses column names altogether (as well as column classes if <code>class = TRUE</code>.</p>
</td></tr>
<tr><td><code id="print_options_+3A_print.keys">print.keys</code></td>
<td>
<p>If <code>TRUE</code>, any <code><a href="#topic+key">key</a></code> and/or <code><a href="data.table.html#topic+indices">index</a></code> currently assigned to <code>x</code> will be printed prior to the preview of the data.</p>
</td></tr>
<tr><td><code id="print_options_+3A_trunc.cols">trunc.cols</code></td>
<td>
<p>If <code>TRUE</code>, only the columns that can be printed in the console without wrapping the columns to new lines will be printed (similar to <code>tibbles</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notice that <span class="pkg">tidyfst</span> has a slightly different printing default for data.table,
which is it always prints the keys and variable class (not like <span class="pkg">data.table</span>).
</p>


<h3>Value</h3>

<p>None. This function is used for its side effect of changing options.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+print.data.table">print.data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;% as.data.table()
print_options(topn = 3,trunc.cols = TRUE)
iris %&gt;% as.data.table()

# set all settings to default in tidyfst
print_options()
iris %&gt;% as.data.table()

</code></pre>

<hr>
<h2 id='pull_dt'>Pull out a single variable</h2><span id='topic+pull_dt'></span>

<h3>Description</h3>

<p>Extract vector from data.frame, works likt '[['. Analogous function for <code>pull</code> in <span class="pkg">dplyr</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_dt(.data, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_dt_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="pull_dt_+3A_col">col</code></td>
<td>
<p>A name of column or index (should be positive).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+pull">pull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% pull_dt(2)
mtcars %&gt;% pull_dt(cyl)
mtcars %&gt;% pull_dt("cyl")
</code></pre>

<hr>
<h2 id='rec'>Recode number or strings</h2><span id='topic+rec'></span><span id='topic+rec_num'></span><span id='topic+rec_char'></span>

<h3>Description</h3>

<p>Recode discrete variables, including numerice and character
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rec_num(x, rec, keep = TRUE)

rec_char(x, rec, keep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rec_+3A_x">x</code></td>
<td>
<p>A numeric or character vector.</p>
</td></tr>
<tr><td><code id="rec_+3A_rec">rec</code></td>
<td>
<p>String with recode pairs of old and new values.
Find the usage in examples.</p>
</td></tr>
<tr><td><code id="rec_+3A_keep">keep</code></td>
<td>
<p>Logical. Decide whether to keep the original values if not recoded.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector.
</p>


<h3>See Also</h3>

<p><code><a href="sjmisc.html#topic+rec">rec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = 1:10
x
rec_num(x, rec = "1=10; 4=2")
rec_num(x, rec = "1:3=1; 4:6=2")
rec_num(x, rec = "1:3=1; 4:6=2",keep = FALSE)

y = letters[1:5]
y
rec_char(y,rec = "a=A;b=B")
rec_char(y,rec = "a,b=A;c,d=B")
rec_char(y,rec = "a,b=A;c,d=B",keep = FALSE)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic++25like+25'></span><span id='topic++25chin+25'></span><span id='topic+data.table'></span><span id='topic+as.data.table'></span><span id='topic+fread'></span><span id='topic+fwrite'></span><span id='topic+fintersect'></span><span id='topic+fsetdiff'></span><span id='topic+funion'></span><span id='topic+fsetequal'></span><span id='topic+frollapply'></span><span id='topic+fcoalesce'></span><span id='topic+uniqueN'></span><span id='topic+rbindlist'></span><span id='topic+tables'></span><span id='topic+like'></span><span id='topic+copy'></span><span id='topic+key'></span><span id='topic+CJ'></span><span id='topic+rleid'></span><span id='topic+rleidv'></span><span id='topic+fcase'></span><span id='topic+between'></span><span id='topic+set'></span><span id='topic+setDT'></span><span id='topic+setDF'></span><span id='topic+setnames'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>data.table</dt><dd><p><code><a href="data.table.html#topic+chmatch">%chin%</a></code>, <code><a href="data.table.html#topic+like">%like%</a></code>, <code><a href="data.table.html#topic+as.data.table">as.data.table</a></code>, <code><a href="data.table.html#topic+between">between</a></code>, <code><a href="data.table.html#topic+J">CJ</a></code>, <code><a href="data.table.html#topic+copy">copy</a></code>, <code><a href="data.table.html#topic+data.table">data.table</a></code>, <code><a href="data.table.html#topic+fcase">fcase</a></code>, <code><a href="data.table.html#topic+coalesce">fcoalesce</a></code>, <code><a href="data.table.html#topic+setops">fintersect</a></code>, <code><a href="data.table.html#topic+fread">fread</a></code>, <code><a href="data.table.html#topic+froll">frollapply</a></code>, <code><a href="data.table.html#topic+setops">fsetdiff</a></code>, <code><a href="data.table.html#topic+setops">fsetequal</a></code>, <code><a href="data.table.html#topic+setops">funion</a></code>, <code><a href="data.table.html#topic+fwrite">fwrite</a></code>, <code><a href="data.table.html#topic+setkey">key</a></code>, <code><a href="data.table.html#topic+like">like</a></code>, <code><a href="data.table.html#topic+rbindlist">rbindlist</a></code>, <code><a href="data.table.html#topic+rleid">rleid</a></code>, <code><a href="data.table.html#topic+rleid">rleidv</a></code>, <code><a href="data.table.html#topic+assign">set</a></code>, <code><a href="data.table.html#topic+setDF">setDF</a></code>, <code><a href="data.table.html#topic+setDT">setDT</a></code>, <code><a href="data.table.html#topic+setattr">setnames</a></code>, <code><a href="data.table.html#topic+tables">tables</a></code>, <code><a href="data.table.html#topic+duplicated">uniqueN</a></code></p>
</dd>
<dt>stringr</dt><dd><p><code><a href="stringr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='relocate_dt'>Change column order</h2><span id='topic+relocate_dt'></span>

<h3>Description</h3>

<p>Change the position of columns,
using the same syntax as 'select_dt()'. Check similar function
as 'relocate' in <span class="pkg">dplyr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relocate_dt(.data, ..., how = "first", where = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relocate_dt_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="relocate_dt_+3A_...">...</code></td>
<td>
<p>Columns to move</p>
</td></tr>
<tr><td><code id="relocate_dt_+3A_how">how</code></td>
<td>
<p>The mode of movement, including &quot;first&quot;,&quot;last&quot;,&quot;after&quot;,&quot;before&quot;.
Default uses &quot;first&quot;.</p>
</td></tr>
<tr><td><code id="relocate_dt_+3A_where">where</code></td>
<td>
<p>Destination of columns selected by <code>...</code>.
Applicable for &quot;after&quot; and &quot;before&quot; mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with rearranged columns.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+relocate">relocate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(a = 1, b = 1, c = 1, d = "a", e = "a", f = "a")
df
df %&gt;% relocate_dt(f)
df %&gt;% relocate_dt(a,how = "last")

df %&gt;% relocate_dt(is.character)
df %&gt;% relocate_dt(is.numeric, how = "last")
df %&gt;% relocate_dt("[aeiou]")

df %&gt;% relocate_dt(a, how = "after",where = f)
df %&gt;% relocate_dt(f, how = "before",where = a)
df %&gt;% relocate_dt(f, how = "before",where = c)
df %&gt;% relocate_dt(f, how = "after",where = c)

df2 &lt;- data.table(a = 1, b = "a", c = 1, d = "a")
df2 %&gt;% relocate_dt(is.numeric,
                    how = "after",
                    where = is.character)
df2 %&gt;% relocate_dt(is.numeric,
                    how="before",
                    where = is.character)
</code></pre>

<hr>
<h2 id='rename_dt'>Rename column in data.frame</h2><span id='topic+rename_dt'></span><span id='topic+rename_with_dt'></span>

<h3>Description</h3>

<p>Rename one or more columns in the data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_dt(.data, ...)

rename_with_dt(.data, .fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_dt_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="rename_dt_+3A_...">...</code></td>
<td>
<p>statements of rename, e.g. 'sl = Sepal.Length' means the column named
as &quot;Sepal.Length&quot; would be renamed to &quot;sl&quot;</p>
</td></tr>
<tr><td><code id="rename_dt_+3A_.fn">.fn</code></td>
<td>
<p>A function used to transform the selected columns.
Should return a character vector the same length as the input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+rename">rename</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;%
  rename_dt(sl = Sepal.Length,sw = Sepal.Width) %&gt;%
  head()
iris %&gt;% rename_with_dt(toupper)
iris %&gt;% rename_with_dt(toupper,"^Pe")

</code></pre>

<hr>
<h2 id='replace_dt'>Fast value replacement in data frame</h2><span id='topic+replace_dt'></span>

<h3>Description</h3>

<p>While <code>replace_na_dt</code> could replace all NAs to another
value, <code>replace_dt</code> could replace any value(s) to another specific
value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_dt(.data, ..., from = is.nan, to = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_dt_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="replace_dt_+3A_...">...</code></td>
<td>
<p>Colunms to be replaced. If not specified, use all columns.</p>
</td></tr>
<tr><td><code id="replace_dt_+3A_from">from</code></td>
<td>
<p>A value, a vector of values or a function returns a logical value.
Defaults to <code>is.nan</code>.</p>
</td></tr>
<tr><td><code id="replace_dt_+3A_to">to</code></td>
<td>
<p>A value. Defaults to <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+replace_na_dt">replace_na_dt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% mutate_vars(is.factor,as.character) -&gt; new_iris

new_iris %&gt;%
  replace_dt(Species, from = "setosa",to = "SS")
new_iris %&gt;%
  replace_dt(Species,from = c("setosa","virginica"),to = "sv")
new_iris %&gt;%
  replace_dt(Petal.Width, from = .2,to = 2)
new_iris %&gt;%
  replace_dt(from = .2,to = NA)
new_iris %&gt;%
  replace_dt(is.numeric, from = function(x) x &gt; 3, to = 9999 )
</code></pre>

<hr>
<h2 id='rn_col'>Tools for working with row names</h2><span id='topic+rn_col'></span><span id='topic+col_rn'></span>

<h3>Description</h3>

<p>The enhanced data.frame, including tibble and data.table, do not
support row names. To link to some base r facilities, there should be functions
to save information in row names. These functions are analogous to
<code>rownames_to_column</code> and <code>column_to_rownames</code> in <span class="pkg">tibble</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rn_col(.data, var = "rowname")

col_rn(.data, var = "rowname")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rn_col_+3A_.data">.data</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="rn_col_+3A_var">var</code></td>
<td>
<p>Name of column to use for rownames.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rn_col</code> returns a data.table,
<code>col_rn</code> returns a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 mtcars %&gt;% rn_col()
 mtcars %&gt;% rn_col("rn")

 mtcars %&gt;% rn_col() -&gt; new_mtcars

 new_mtcars %&gt;% col_rn() -&gt; old_mtcars
 old_mtcars
 setequal(mtcars,old_mtcars)
</code></pre>

<hr>
<h2 id='sample_dt'>Sample rows randomly from a table</h2><span id='topic+sample_dt'></span><span id='topic+sample_n_dt'></span><span id='topic+sample_frac_dt'></span>

<h3>Description</h3>

<p>Select a number or proportion of rows randomly from the data frame
</p>
<p><code>sample_dt</code> is a merged version of <code>sample_n_dt</code> and
<code>sample_frac_dt</code>, this could be convenient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_dt(.data, n = NULL, prop = NULL, replace = FALSE, by = NULL)

sample_n_dt(.data, size, replace = FALSE, by = NULL)

sample_frac_dt(.data, size, replace = FALSE, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_dt_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="sample_dt_+3A_n">n</code></td>
<td>
<p>Number of rows to select</p>
</td></tr>
<tr><td><code id="sample_dt_+3A_prop">prop</code></td>
<td>
<p>Fraction of rows to select</p>
</td></tr>
<tr><td><code id="sample_dt_+3A_replace">replace</code></td>
<td>
<p>Sample with or without replacement? Default uses <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sample_dt_+3A_by">by</code></td>
<td>
<p>(Optional) Character. Specify if you want to sample by group.</p>
</td></tr>
<tr><td><code id="sample_dt_+3A_size">size</code></td>
<td>
<p>For <code>sample_n_dt</code>, the number of rows to select.
For <code>sample_frac_dt</code>, the fraction of rows to select.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+sample_n">sample_n</a></code>,<code><a href="dplyr.html#topic+sample_frac">sample_frac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_n_dt(mtcars, 10)
sample_n_dt(mtcars, 50, replace = TRUE)
sample_frac_dt(mtcars, 0.1)
sample_frac_dt(mtcars, 1.5, replace = TRUE)


sample_dt(mtcars,n=10)
sample_dt(mtcars,prop = 0.1)


# sample by group(s)
iris %&gt;% sample_n_dt(2,by = "Species")
iris %&gt;% sample_frac_dt(.1,by = "Species")

mtcars %&gt;% sample_n_dt(1,by = "cyl,vs")
# equals to
mtcars %&gt;% sample_n_dt(1,by = c("cyl","vs"))
</code></pre>

<hr>
<h2 id='select_dt'>Select column from data.frame</h2><span id='topic+select_dt'></span><span id='topic+select_mix'></span>

<h3>Description</h3>

<p>Select specific column(s) via various ways. One can select columns by their column names, indexes or regular expression recognizing the column name(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_dt(.data, ..., cols = NULL, negate = FALSE)

select_mix(.data, ..., rm.dup = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_dt_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="select_dt_+3A_...">...</code></td>
<td>
<p>List of variables or name-value pairs of summary/modifications
functions. It can also recieve conditional function to select columns.
When starts with '-'(minus symbol) or '!', return the negative columns.</p>
</td></tr>
<tr><td><code id="select_dt_+3A_cols">cols</code></td>
<td>
<p>(Optional)A numeric or character vector.</p>
</td></tr>
<tr><td><code id="select_dt_+3A_negate">negate</code></td>
<td>
<p>Applicable when regular expression and &quot;cols&quot; is used.
If <code>TRUE</code>, return the non-matched pattern. Default uses <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="select_dt_+3A_rm.dup">rm.dup</code></td>
<td>
<p>Should duplicated columns be removed? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+select_if">select_if</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% select_dt(Species)
iris %&gt;% select_dt(Sepal.Length,Sepal.Width)
iris %&gt;% select_dt(Sepal.Length:Petal.Length)
iris %&gt;% select_dt(-Sepal.Length)
iris %&gt;% select_dt(-Sepal.Length,-Petal.Length)
iris %&gt;% select_dt(-(Sepal.Length:Petal.Length))
iris %&gt;% select_dt(c("Sepal.Length","Sepal.Width"))
iris %&gt;% select_dt(-c("Sepal.Length","Sepal.Width"))
iris %&gt;% select_dt(1)
iris %&gt;% select_dt(-1)
iris %&gt;% select_dt(1:3)
iris %&gt;% select_dt(-(1:3))
iris %&gt;% select_dt(1,3)
iris %&gt;% select_dt("Pe")
iris %&gt;% select_dt(-"Se")
iris %&gt;% select_dt(!"Se")
iris %&gt;% select_dt("Pe",negate = TRUE)
iris %&gt;% select_dt("Pe|Sp")
iris %&gt;% select_dt(cols = 2:3)
iris %&gt;% select_dt(cols = 2:3,negate = TRUE)
iris %&gt;% select_dt(cols = c("Sepal.Length","Sepal.Width"))
iris %&gt;% select_dt(cols = names(iris)[2:3])

iris %&gt;% select_dt(is.factor)
iris %&gt;% select_dt(-is.factor)
iris %&gt;% select_dt(!is.factor)

# select_mix could provide flexible mix selection
select_mix(iris, Species,"Sepal.Length")
select_mix(iris,1:2,is.factor)

select_mix(iris,Sepal.Length,is.numeric)
# set rm.dup to FALSE could save the duplicated column names
select_mix(iris,Sepal.Length,is.numeric,rm.dup = FALSE)

</code></pre>

<hr>
<h2 id='separate_dt'>Separate a character column into two columns using
a regular expression separator</h2><span id='topic+separate_dt'></span>

<h3>Description</h3>

<p>Given either regular expression,
<code>separate_dt()</code> turns a single character column into two columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_dt(
  .data,
  separated_colname,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_dt_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="separate_dt_+3A_separated_colname">separated_colname</code></td>
<td>
<p>Column to be separated, can be a character or alias.</p>
</td></tr>
<tr><td><code id="separate_dt_+3A_into">into</code></td>
<td>
<p>Character vector of length 2.</p>
</td></tr>
<tr><td><code id="separate_dt_+3A_sep">sep</code></td>
<td>
<p>Separator between columns.</p>
</td></tr>
<tr><td><code id="separate_dt_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input column from output data frame.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+separate">separate</a></code>, <code><a href="#topic+unite_dt">unite_dt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = c(NA, "a.b", "a.d", "b.c"))
df %&gt;% separate_dt(x, c("A", "B"))
# equals to
df %&gt;% separate_dt("x", c("A", "B"))

# If you just want the second variable:
df %&gt;% separate_dt(x,into = c(NA,"B"))
</code></pre>

<hr>
<h2 id='slice_dt'>Subset rows using their positions</h2><span id='topic+slice_dt'></span><span id='topic+slice_head_dt'></span><span id='topic+slice_tail_dt'></span><span id='topic+slice_max_dt'></span><span id='topic+slice_min_dt'></span><span id='topic+slice_sample_dt'></span>

<h3>Description</h3>

<p>'slice_dt()' lets you index rows by their (integer) locations. It allows you
to select, remove, and duplicate rows. It is accompanied by a number of
helpers for common use cases:
</p>
<p>* 'slice_head_dt()' and 'slice_tail_dt()' select the first or last rows.
* 'slice_sample_dt()' randomly selects rows.
* 'slice_min_dt()' and 'slice_max_dt()' select rows with highest or lowest values
of a variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_dt(.data, ..., by = NULL)

slice_head_dt(.data, n, by = NULL)

slice_tail_dt(.data, n, by = NULL)

slice_max_dt(.data, order_by, n, by = NULL, with_ties = TRUE)

slice_min_dt(.data, order_by, n, by = NULL, with_ties = TRUE)

slice_sample_dt(.data, n, replace = FALSE, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_dt_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="slice_dt_+3A_...">...</code></td>
<td>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.</p>
</td></tr>
<tr><td><code id="slice_dt_+3A_by">by</code></td>
<td>
<p>Slice by which group(s)?</p>
</td></tr>
<tr><td><code id="slice_dt_+3A_n">n</code></td>
<td>
<p>When larger than or equal to 1, the number of rows.
When between 0 and 1, the proportion of rows to select.</p>
</td></tr>
<tr><td><code id="slice_dt_+3A_order_by">order_by</code></td>
<td>
<p>Variable or function of variables to order by.</p>
</td></tr>
<tr><td><code id="slice_dt_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together? The default, 'TRUE',
may return more rows than you request. Use 'FALSE' to ignore ties,
and return the first 'n' rows.</p>
</td></tr>
<tr><td><code id="slice_dt_+3A_replace">replace</code></td>
<td>
<p>Should sampling be performed with ('TRUE') or without
('FALSE', the default) replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+slice">slice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a = iris
slice_dt(a,1,2)
slice_dt(a,2:3)
slice_dt(a,141:.N)
slice_dt(a,1,.N)
slice_head_dt(a,5)
slice_head_dt(a,0.1)
slice_tail_dt(a,5)
slice_tail_dt(a,0.1)
slice_max_dt(a,Sepal.Length,10)
slice_max_dt(a,Sepal.Length,10,with_ties = FALSE)
slice_min_dt(a,Sepal.Length,10)
slice_min_dt(a,Sepal.Length,10,with_ties = FALSE)
slice_sample_dt(a,10)
slice_sample_dt(a,0.1)


# use by to slice by group

## following codes get the same results
slice_dt(a,1:3,by = "Species")
slice_dt(a,1:3,by = Species)
slice_dt(a,1:3,by = .(Species))

slice_head_dt(a,2,by = Species)
slice_tail_dt(a,2,by = Species)

slice_max_dt(a,Sepal.Length,3,by = Species)
slice_max_dt(a,Sepal.Length,3,by = Species,with_ties = FALSE)
slice_min_dt(a,Sepal.Length,3,by = Species)
slice_min_dt(a,Sepal.Length,3,by = Species,with_ties = FALSE)

# in `slice_sample_dt`, "by" could only take character class
slice_sample_dt(a,.1,by = "Species")
slice_sample_dt(a,3,by = "Species")
slice_sample_dt(a,51,replace = TRUE,by = "Species")

</code></pre>

<hr>
<h2 id='sql_join'>Case insensitive table joining like SQL</h2><span id='topic+sql_join'></span><span id='topic+sql_join_dt'></span>

<h3>Description</h3>

<p>Work like the '*_join_dt' series functions, joining
tables with common or customized keys  in various ways. The only
difference is the joining is case insensitive like SQL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_join_dt(x, y, by = NULL, type = "inner", suffix = c(".x", ".y"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_join_+3A_x">x</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="sql_join_+3A_y">y</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="sql_join_+3A_by">by</code></td>
<td>
<p>(Optional) A character vector of variables to join by.
</p>
<p>If 'NULL', the default, '*_join_dt()' will perform a natural join, using all
variables in common across 'x' and 'y'. A message lists the variables so that you
can check they're correct; suppress the message by supplying 'by' explicitly.
</p>
<p>To join by different variables on 'x' and 'y', use a named vector.
For example, 'by = c(&quot;a&quot; = &quot;b&quot;)' will match 'x$a' to 'y$b'.
</p>
<p>To join by multiple variables, use a vector with length &gt; 1.
For example, 'by = c(&quot;a&quot;, &quot;b&quot;)' will match 'x$a' to 'y$a' and 'x$b' to
'y$b'. Use a named vector to match different variables in 'x' and 'y'.
For example, 'by = c(&quot;a&quot; = &quot;b&quot;, &quot;c&quot; = &quot;d&quot;)' will match 'x$a' to 'y$b' and
'x$c' to 'y$d'.
</p>
<p>Notice that in 'sql_join', the joining variables would turn to upper case
in the output table.</p>
</td></tr>
<tr><td><code id="sql_join_+3A_type">type</code></td>
<td>
<p>Which type of join would you like to use?
Default uses &quot;inner&quot;, other options include
&quot;left&quot;, &quot;right&quot;, &quot;full&quot;, &quot;anti&quot;, &quot;semi&quot;.</p>
</td></tr>
<tr><td><code id="sql_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in x and y, these
suffixes will be added to the output to disambiguate them. Should be a
character vector of length 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+join">join</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt1 = data.table(x = c("A","b"),y = 1:2)
dt2 = data.table(x = c("a","B"),z = 4:5)
sql_join_dt(dt1,dt2)
</code></pre>

<hr>
<h2 id='summarise_dt'>Summarise columns to single values</h2><span id='topic+summarise_dt'></span><span id='topic+summarize_dt'></span><span id='topic+summarise_when'></span><span id='topic+summarize_when'></span><span id='topic+summarise_vars'></span><span id='topic+summarize_vars'></span>

<h3>Description</h3>

<p>Summarise group of values into one value for each group. If there is only one group, then only one value would be returned.
The summarise function should always return a single value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_dt(.data, ..., by = NULL)

summarize_dt(.data, ..., by = NULL)

summarise_when(.data, when, ..., by = NULL)

summarize_when(.data, when, ..., by = NULL)

summarise_vars(.data, .cols = NULL, .func, ..., by)

summarize_vars(.data, .cols = NULL, .func, ..., by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_dt_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="summarise_dt_+3A_...">...</code></td>
<td>
<p>List of variables or name-value pairs of summary/modifications
functions for <code>summarise_dt</code>.Additional parameters to be passed to
parameter '.func' in <code>summarise_vars</code>.</p>
</td></tr>
<tr><td><code id="summarise_dt_+3A_by">by</code></td>
<td>
<p>unquoted name of grouping variable of list of unquoted names of
grouping variables. For details see <a href="data.table.html#topic+data.table">data.table</a></p>
</td></tr>
<tr><td><code id="summarise_dt_+3A_when">when</code></td>
<td>
<p>An object which can be coerced to logical mode</p>
</td></tr>
<tr><td><code id="summarise_dt_+3A_.cols">.cols</code></td>
<td>
<p>Columns to be summarised.</p>
</td></tr>
<tr><td><code id="summarise_dt_+3A_.func">.func</code></td>
<td>
<p>Function to be run within each column, should return a value or vectors with same length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summarise_vars</code> could complete summarise on specific columns.
</p>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+summarise">summarise</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% summarise_dt(avg = mean(Sepal.Length))
iris %&gt;% summarise_dt(avg = mean(Sepal.Length),by = Species)
mtcars %&gt;% summarise_dt(avg = mean(hp),by = .(cyl,vs))

# the data.table way
mtcars %&gt;% summarise_dt(cyl_n = .N, by = .(cyl, vs)) # `.` is short for list

iris %&gt;% summarise_vars(is.numeric,min)
iris %&gt;% summarise_vars(-is.factor,min)
iris %&gt;% summarise_vars(1:4,min)

iris %&gt;% summarise_vars(is.numeric,min,by ="Species")
mtcars %&gt;% summarise_vars(is.numeric,mean,by = "vs,am")

# use multiple functions on multiple columns
iris %&gt;%
  summarise_vars(is.numeric,.func = list(mean,sd,median))
iris %&gt;%
  summarise_vars(is.numeric,.func = list(mean,sd,median),by = Species)

</code></pre>

<hr>
<h2 id='sys_time_print'>Convenient print of time taken</h2><span id='topic+sys_time_print'></span><span id='topic+pst'></span>

<h3>Description</h3>

<p>Convenient printing of time elapsed. A wrapper of
<code>data.table::timetaken</code>, but showing the results more directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sys_time_print(expr)

pst(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sys_time_print_+3A_expr">expr</code></td>
<td>
<p>Valid R expression to be timed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the form HH:MM:SS,
or SS.MMMsec if under 60 seconds (invisibly for <code>show_time</code>). See examples.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+timetaken">timetaken</a></code>, <code><a href="base.html#topic+system.time">system.time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sys_time_print(Sys.sleep(1))

a = iris
sys_time_print({
  res = iris %&gt;%
    mutate_dt(one = 1)
})
res
</code></pre>

<hr>
<h2 id='t_dt'>Efficient transpose of data.frame</h2><span id='topic+t_dt'></span>

<h3>Description</h3>

<p>An efficient way to transpose data frames(data.frame/data.table/tibble).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_dt(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_dt_+3A_.data">.data</code></td>
<td>
<p>A data.frame/data.table/tibble</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function would return the original data.frame structure,
keeping all the row names and column names. If the row names are not
available or, &quot;V1,V2...&quot; will be provided.
</p>


<h3>Value</h3>

<p>A transposed data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t_dt(iris)
t_dt(mtcars)
</code></pre>

<hr>
<h2 id='uncount_dt'>&quot;Uncount&quot; a data frame</h2><span id='topic+uncount_dt'></span>

<h3>Description</h3>

<p>Duplicating rows according to a weighting variable.
This is the opposite operation of 'count_dt'.
Analogous to 'tidyr::uncount'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncount_dt(.data, wt, .remove = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncount_dt_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="uncount_dt_+3A_wt">wt</code></td>
<td>
<p>A vector of weights.</p>
</td></tr>
<tr><td><code id="uncount_dt_+3A_.remove">.remove</code></td>
<td>
<p>Should the column for <code>weights</code> be removed?
Default uses <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+count">count</a></code>, <code><a href="tidyr.html#topic+uncount">uncount</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.table(x = c("a", "b"), n = c(1, 2))
uncount_dt(df, n)
uncount_dt(df,n,FALSE)
</code></pre>

<hr>
<h2 id='unite_dt'>Unite multiple columns into one by pasting strings together</h2><span id='topic+unite_dt'></span>

<h3>Description</h3>

<p>Convenience function to paste together multiple columns into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unite_dt(
  .data,
  united_colname,
  ...,
  sep = "_",
  remove = FALSE,
  na2char = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unite_dt_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unite_dt_+3A_united_colname">united_colname</code></td>
<td>
<p>The name of the new column, string only.</p>
</td></tr>
<tr><td><code id="unite_dt_+3A_...">...</code></td>
<td>
<p>A selection of columns. If want to select all columns,
pass &quot;&quot; to the parameter. See example.</p>
</td></tr>
<tr><td><code id="unite_dt_+3A_sep">sep</code></td>
<td>
<p>Separator to use between values.</p>
</td></tr>
<tr><td><code id="unite_dt_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input columns from output data frame.</p>
</td></tr>
<tr><td><code id="unite_dt_+3A_na2char">na2char</code></td>
<td>
<p>If <code>FALSE</code>, missing values would be merged into <code>NA</code>,
otherwise <code>NA</code> is treated as character &quot;NA&quot;. This is different from
<span class="pkg">tidyr</span>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+unite">unite</a></code>,<code><a href="#topic+separate_dt">separate_dt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- expand.grid(x = c("a", NA), y = c("b", NA))
df

# Treat missing value as NA, default
df %&gt;% unite_dt("z", x:y, remove = FALSE)
# Treat missing value as character "NA"
df %&gt;% unite_dt("z", x:y, na2char = TRUE, remove = FALSE)
df %&gt;%
  unite_dt("xy", x:y)

# Select all columns
iris %&gt;% unite_dt("merged_name",".")
</code></pre>

<hr>
<h2 id='utf8_encoding'>Use UTF-8 for character encoding in a data frame</h2><span id='topic+utf8_encoding'></span>

<h3>Description</h3>

<p><code>fread</code> from <span class="pkg">data.table</span> could not recognize the encoding
and return the correct form, this could be unconvenient for text mining tasks. The
<code>utf8-encoding</code> could use &quot;UTF-8&quot; as the encoding to override the current
encoding of characters in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utf8_encoding(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utf8_encoding_+3A_.data">.data</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with characters in UTF-8 encoding
</p>

<hr>
<h2 id='wider_dt'>Pivot data from long to wide</h2><span id='topic+wider_dt'></span>

<h3>Description</h3>

<p>Transform a data frame from long format to wide by increasing the number of columns and decreasing the number of rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wider_dt(.data, ..., name, value = NULL, fun = NULL, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wider_dt_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="wider_dt_+3A_...">...</code></td>
<td>
<p>Optional. The unchanged group in the transformation.
Could use integer vector, could receive what <code>select_dt</code> receives.</p>
</td></tr>
<tr><td><code id="wider_dt_+3A_name">name</code></td>
<td>
<p>Chracter.One column name of class to spread</p>
</td></tr>
<tr><td><code id="wider_dt_+3A_value">value</code></td>
<td>
<p>Chracter.One column name of value to spread.
If <code>NULL</code>, use all other variables.</p>
</td></tr>
<tr><td><code id="wider_dt_+3A_fun">fun</code></td>
<td>
<p>Should the data be aggregated before casting?
Defaults to <code>NULL</code>, which uses <code>length</code> for aggregation.
If a function is provided, with aggregated by this function.</p>
</td></tr>
<tr><td><code id="wider_dt_+3A_fill">fill</code></td>
<td>
<p>Value with which to fill missing cells. Default uses <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter of 'name' and 'value' should always
be provided and should be explicit called (with the parameter names attached).
</p>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+longer_dt">longer_dt</a></code>,
<code><a href="data.table.html#topic+dcast">dcast</a></code>,
<code><a href="tidyr.html#topic+pivot_wider">pivot_wider</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> stocks = data.frame(
   time = as.Date('2009-01-01') + 0:9,
   X = rnorm(10, 0, 1),
   Y = rnorm(10, 0, 2),
   Z = rnorm(10, 0, 4)
 ) %&gt;%
   longer_dt(time) -&gt; longer_stocks

 longer_stocks

 longer_stocks %&gt;%
   wider_dt("time",
            name = "name",
            value = "value")

 longer_stocks %&gt;%
   mutate_dt(one = 1) %&gt;%
   wider_dt("time",
            name = "name",
            value = "one")

## using "fun" parameter for aggregation
DT &lt;- data.table(v1 = rep(1:2, each = 6),
                 v2 = rep(rep(1:3, 2), each = 2),
                 v3 = rep(1:2, 6),
                 v4 = rnorm(6))
## for each combination of (v1, v2), add up all values of v4
DT %&gt;%
  wider_dt(v1,v2,
           value = "v4",
           name = ".",
           fun = sum)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
