<!DOCTYPE html><html><head><title>Help for package jmatrix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jmatrix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CsvToJMat'><p>CsvToJMat</p></a></li>
<li><a href='#FilterJMatByName'><p>FilterJMatByName</p></a></li>
<li><a href='#GetJCol'><p>GetJCol</p></a></li>
<li><a href='#GetJColByName'><p>GetJColByName</p></a></li>
<li><a href='#GetJColNames'><p>GetJColNames</p></a></li>
<li><a href='#GetJManyCols'><p>GetJManyCols</p></a></li>
<li><a href='#GetJManyColsByNames'><p>GetJManyColsByNames</p></a></li>
<li><a href='#GetJManyRows'><p>GetJManyRows</p></a></li>
<li><a href='#GetJManyRowsByNames'><p>GetJManyRowsByNames</p></a></li>
<li><a href='#GetJNames'><p>GetJNames</p></a></li>
<li><a href='#GetJRow'><p>GetJRow</p></a></li>
<li><a href='#GetJRowByName'><p>GetJRowByName</p></a></li>
<li><a href='#GetJRowNames'><p>GetJRowNames</p></a></li>
<li><a href='#JMatInfo'><p>JMatInfo</p></a></li>
<li><a href='#JMatrixSetDebug'><p>JMatrixSetDebug</p></a></li>
<li><a href='#JMatToCsv'><p>JMatToCsv</p></a></li>
<li><a href='#JWriteBin'><p>JWriteBin</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read from/Write to Disk Matrices with any Data Type in a Binary
Format</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Juan Domingo <a href="https://orcid.org/0000-0003-4728-6256"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Guillermo Ayala <a href="https://orcid.org/0000-0002-6231-2865"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Spanish Ministry of Science and Innovation, MCIN/AEI
    &lt;doi:10.13039/501100011033&gt; [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juan Domingo &lt;Juan.Domingo@uv.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A mainly instrumental package meant to allow other packages whose core is written in 'C++' to read, write
        and manipulate matrices in a binary format so that the memory used for them is no more than strictly needed. Its functionality
        is already inside 'parallelpam' and 'scellpam', so if you have installed any of these, you do not need to install 'jmatrix'.
        Using just the needed memory is not always true with 'R' matrices or vectors, since by default they are of double type. Trials
        like the 'float' package have been done, but to use them you have to coerce a matrix already loaded in 'R' memory to a float matrix,
        and then you can delete it. The problem comes when your computer has not memory enough to hold the matrix in the first place, so
        you are forced to load it by chunks. This is the problem this package tries to address (with partial success, but this is a
        difficult problem since 'R' is not a strictly typed language, which is anyway quite hard to get in an interpreted language).
	This package allows the creation and manipulation of full, sparse and symmetric matrices of any standard data type.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8), memuse (&ge; 4.2.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-07 16:17:20 UTC; jdomingo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-08 18:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='CsvToJMat'>CsvToJMat</h2><span id='topic+CsvToJMat'></span>

<h3>Description</h3>

<p>Gets a csv/tsv file and writes to a disk file the binary matrix of counts contained in it in the jmatrix binary format.<br />
First line of the .csv is supposed to have the field names.<br />
First column of each line is supposed to have the row name.<br />
The fields are supposed to be separated by one occurrence of a character-field sepparator (usually, comma or tab)
.tsv files can be read with this function, too, setting the csep argument to '\t'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CsvToJMat(
  ifname,
  ofname,
  mtype = "sparse",
  csep = ",",
  ctype = "raw",
  valuetype = "float",
  transpose = FALSE,
  comment = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CsvToJMat_+3A_ifname">ifname</code></td>
<td>
<p>A string with the name of the .csv/.tsv text file.</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_ofname">ofname</code></td>
<td>
<p>A string with the name of the binary output file.</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_mtype">mtype</code></td>
<td>
<p>A string to indicate the matrix type: 'full', 'sparse' or 'symmetric'. Default: 'sparse'</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_csep">csep</code></td>
<td>
<p>The character used as separator in the .csv file. Default: ',' (comma) (Set to '\t' for .tsv)</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_ctype">ctype</code></td>
<td>
<p>The string 'raw' or 'log1' to write raw counts or log(counts+1), or the normalized versions, 'rawn' and 'log1n', which normalize ALWAYS BY COLUMNS (before transposition, if requested to transpose). The logarithm is taken base 2. Default: raw</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_valuetype">valuetype</code></td>
<td>
<p>The data type to store the matrix. It must be one of the strings 'uint32', 'float' or 'double'. Default: float</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_transpose">transpose</code></td>
<td>
<p>Boolean to indicate if the matrix should be transposed before writing. See Details for a comment about this. Default: FALSE</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_comment">comment</code></td>
<td>
<p>A comment to be stored with the matrix. Default: &quot;&quot; (no comment)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter transpose has the default value of FALSE. But don't forget to set it to TRUE if you want the cells
(which in single cell common practice are by columns) to be written by rows. This will be needed later to calculate
the dissimilarity matrix, if this is the next step of your workflow. See help of CalcAndWriteDissimilarityMatrix
</p>
<p>Special note for loading symmetric matrices:<br />
If you use this function to load what you expect to be a symmetric matrix from a .csv file, remember that the input table
MUST be square, but only the lower-diagonal matrix will be stored, including the main diagonal. The rest of the input table is
completely ignored, except to check that there are values in it. It is not checked if the table really represents a
symmetric matrix or not.<br />
Furthermore, symmetric matrices can only be loaded in raw mode, i.e.: no normalization is allowed, and they cannot be transposed.
</p>


<h3>Value</h3>

<p>No return value, called for side effects (creates a file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Since we have no a .csv file to test, we will generate one with another funcion of this package
Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
tmpfile2=paste0(tempdir(),"/Rfullfloat2.bin")
tmpcsvfile1=paste0(tempdir(),"/Rfullfloat.csv")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
JMatToCsv(tmpfile1,tmpcsvfile1)
CsvToJMat(tmpcsvfile1,tmpfile2)
# It can be checked that files Rfullfloat.bin and Rfullfloat2.bin contain the same data
# (even they differ in the comment, which has been eliminated when converting to csv)
</code></pre>

<hr>
<h2 id='FilterJMatByName'>FilterJMatByName</h2><span id='topic+FilterJMatByName'></span>

<h3>Description</h3>

<p>Takes a jmatrix binary file containing a table with rows and columns and filters it by name, eliminating the rows or columns whose whose names are not in certain list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterJMatByName(fname, Gn, filname, namesat = "rows")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterJMatByName_+3A_fname">fname</code></td>
<td>
<p>A string with the file name of the original table</p>
</td></tr>
<tr><td><code id="FilterJMatByName_+3A_gn">Gn</code></td>
<td>
<p>A list of R strings with the names of the rows or columns that must remain. All others will be filtered out</p>
</td></tr>
<tr><td><code id="FilterJMatByName_+3A_filname">filname</code></td>
<td>
<p>A string with the file name of the filtered table</p>
</td></tr>
<tr><td><code id="FilterJMatByName_+3A_namesat">namesat</code></td>
<td>
<p>The string &quot;rows&quot; or &quot;cols&quot; indicating if the searched names are in the rows or in the columns of the original table. Default: &quot;rows&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the table has no list of names in the requested dimension (rows or colums), an error is rised.<br />
The row or column names whose names are not found obviosuly cannot remain, and the program rises a warning indicating for which row/column names this happens.<br />
The matrix contained in the filtered file will have the same nature (full or sparse) and the same data type as the original.<br />
This function can be used to filter either by row or by column name, with appropriate usage of parameter namesat
</p>


<h3>Value</h3>

<p>No return value, called for side effects (creates a file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
tmpfile2=paste0(tempdir(),"/Rfullfloatrowfilt.bin")
tmpfile3=paste0(tempdir(),"/Rfullfloatrowcolfilt.bin")
tmpcsvfile1=paste0(tempdir(),"/Rfullfloat.csv")
tmpcsvfile3=paste0(tempdir(),"/Rfullfloatrowcolfilt.csv")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
# Let's keep only rows A, C and E
FilterJMatByName(tmpfile1,c("A","C","E"),tmpfile2,namesat="rows")
# and from the result, let's keep only columns b, d and g
FilterJMatByName(tmpfile2,c("b","d","g"),tmpfile3,namesat="cols")
JMatToCsv(tmpfile1,tmpcsvfile1)
JMatToCsv(tmpfile3,tmpcsvfile3)
# You can now compare both ASCII/csv files
</code></pre>

<hr>
<h2 id='GetJCol'>GetJCol</h2><span id='topic+GetJCol'></span>

<h3>Description</h3>

<p>Returns (as a R numeric vector) the requested column number from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJCol(fname, ncol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJCol_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJCol_+3A_ncol">ncol</code></td>
<td>
<p>The number of the column to be returned, in R-numbering (from 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the values of elements in the requested column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[,3]
vf&lt;-GetJCol(tmpfile1,3)
vf
</code></pre>

<hr>
<h2 id='GetJColByName'>GetJColByName</h2><span id='topic+GetJColByName'></span>

<h3>Description</h3>

<p>Returns (as a R numeric vector) the requested named column from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJColByName(fname, colname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJColByName_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJColByName_+3A_colname">colname</code></td>
<td>
<p>The name of the column to be returned. If the matrix has no column names, or the name is not found, an empty vector is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the values of elements in the requested column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[,"c"]
vf&lt;-GetJColByName(tmpfile1,"c")
vf
</code></pre>

<hr>
<h2 id='GetJColNames'>GetJColNames</h2><span id='topic+GetJColNames'></span>

<h3>Description</h3>

<p>Returns a R StringVector with the column names of a matrix stored in the binary format of package jmatrix, if it has them stored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJColNames(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJColNames_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A R StringVector with the column names, or the empty vector if the binaryfile has no column names as metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
cn&lt;-GetJColNames(tmpfile1)
cn
</code></pre>

<hr>
<h2 id='GetJManyCols'>GetJManyCols</h2><span id='topic+GetJManyCols'></span>

<h3>Description</h3>

<p>Returns (as a R numeric matrix) the columns with the requested column numbers from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJManyCols(fname, extcols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJManyCols_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJManyCols_+3A_extcols">extcols</code></td>
<td>
<p>A numeric vector with the indexes of the columns to be extracted, in R-numbering (from 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the values of elements in the requested columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
vc&lt;-GetJManyCols(tmpfile1,c(1,4))
vc
</code></pre>

<hr>
<h2 id='GetJManyColsByNames'>GetJManyColsByNames</h2><span id='topic+GetJManyColsByNames'></span>

<h3>Description</h3>

<p>Returns (as a R numeric matrix) the columns with the requested column names from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJManyColsByNames(fname, extcolnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJManyColsByNames_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJManyColsByNames_+3A_extcolnames">extcolnames</code></td>
<td>
<p>A vector of RStrings with the names of the columns to be extracted. If the binary file has no column names, or _any_ of the column names is not present, an empty matrix is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the values of elements in the requested columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[,c(1,4)]
vf&lt;-GetJManyColsByNames(tmpfile1,c("a","d"))
vf
</code></pre>

<hr>
<h2 id='GetJManyRows'>GetJManyRows</h2><span id='topic+GetJManyRows'></span>

<h3>Description</h3>

<p>Returns (as a R numeric matrix) the rows with the requested row numbers from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJManyRows(fname, extrows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJManyRows_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJManyRows_+3A_extrows">extrows</code></td>
<td>
<p>A numeric vector with the indexes of the rows to be extracted, in R-numbering (from 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the values of elements in the requested rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[c(1,4),]
vc&lt;-GetJManyRows(tmpfile1,c(1,4))
vc
</code></pre>

<hr>
<h2 id='GetJManyRowsByNames'>GetJManyRowsByNames</h2><span id='topic+GetJManyRowsByNames'></span>

<h3>Description</h3>

<p>Returns (as a R numeric matrix) the rows with the requested row names from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJManyRowsByNames(fname, extrownames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJManyRowsByNames_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJManyRowsByNames_+3A_extrownames">extrownames</code></td>
<td>
<p>A vector of RStrings with the names of the rows to be extracted. If the binary file has no row names, or _any_ of the row names is not present, an empty matrix is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the values of elements in the requested rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[c("A","C"),]
vf&lt;-GetJManyRowsByNames(tmpfile1,c("A","C"))
vf
</code></pre>

<hr>
<h2 id='GetJNames'>GetJNames</h2><span id='topic+GetJNames'></span>

<h3>Description</h3>

<p>Returns a R list of two elements, rownames and colnames, each of them being a R StringVector with the corresponding names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJNames(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJNames_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N[&quot;rownames&quot;,&quot;colnames&quot;]: A list with two elements named rownames and colnames which are R StringVectors.
If the binary file has no row or column names as metadata BOTH will be returned as empty vectors, even if one of them exists.
If you want to extract only one, use either GetJRowNames or GetJColNames, as appropriate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
N&lt;-GetJNames(tmpfile1)
N["rownames"]
N["colnames"]
</code></pre>

<hr>
<h2 id='GetJRow'>GetJRow</h2><span id='topic+GetJRow'></span>

<h3>Description</h3>

<p>Returns (as a R numeric vector) the requested row number from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJRow(fname, nrow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJRow_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJRow_+3A_nrow">nrow</code></td>
<td>
<p>The number of the row to be returned, in R-numbering (from 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the values of elements in the requested row
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[3,]
vf&lt;-GetJRow(tmpfile1,3)
vf
</code></pre>

<hr>
<h2 id='GetJRowByName'>GetJRowByName</h2><span id='topic+GetJRowByName'></span>

<h3>Description</h3>

<p>Returns (as a R numeric vector) the requested named row from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJRowByName(fname, rowname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJRowByName_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJRowByName_+3A_rowname">rowname</code></td>
<td>
<p>The name of the row to be returned. If the matrix has no row names, or the name is not found, an empty vector is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the values of elements in the requested row
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf["C",]
vf&lt;-GetJRowByName(tmpfile1,"C")
vf
</code></pre>

<hr>
<h2 id='GetJRowNames'>GetJRowNames</h2><span id='topic+GetJRowNames'></span>

<h3>Description</h3>

<p>Returns a R StringVector with the row names of a matrix stored in the binary format of package jmatrix, if it has them stored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJRowNames(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJRowNames_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A R StringVector with the row names, or the empty vector if the binary file has no row names as metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
rn&lt;-GetJRowNames(tmpfile1)
rn
</code></pre>

<hr>
<h2 id='JMatInfo'>JMatInfo</h2><span id='topic+JMatInfo'></span>

<h3>Description</h3>

<p>Shows in the screen or writes to a file information about a matrix stored in the binary format of package jmatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JMatInfo(fname, fres = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JMatInfo_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="JMatInfo_+3A_fres">fres</code></td>
<td>
<p>String with the name of the file to write the information. Default: &quot;&quot; (information is written to the console)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects (writes on screen or creates a file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
JMatInfo(tmpfile1)
</code></pre>

<hr>
<h2 id='JMatrixSetDebug'>JMatrixSetDebug</h2><span id='topic+JMatrixSetDebug'></span>

<h3>Description</h3>

<p>Sets debugging in jmatrix package to ON (with TRUE) or OFF (with FALSE).<br />
On package load the default status is OFF.<br />
Setting debugging to ON shows a message. Setting to OFF does not show anything (since debugging is OFF...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JMatrixSetDebug(deb = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JMatrixSetDebug_+3A_deb">deb</code></td>
<td>
<p>boolean, TRUE to generate debug messages and FALSE to turn them off. Default: true</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects (internal boolean flag changed)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>JMatrixSetDebug(TRUE)
JMatrixSetDebug(FALSE)
</code></pre>

<hr>
<h2 id='JMatToCsv'>JMatToCsv</h2><span id='topic+JMatToCsv'></span>

<h3>Description</h3>

<p>Writes a binary matrix in the jmatrix package format as a .csv file. This is mainly for checking/inspection and
to load the data from R as read.csv, if the memory of having all data as doubles allows doing such thing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JMatToCsv(ifile, csvfile, csep = ",", withquotes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JMatToCsv_+3A_ifile">ifile</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="JMatToCsv_+3A_csvfile">csvfile</code></td>
<td>
<p>String with the file name that will contain the data as csv.</p>
</td></tr>
<tr><td><code id="JMatToCsv_+3A_csep">csep</code></td>
<td>
<p>Character used as separator. Default: , (comma)</p>
</td></tr>
<tr><td><code id="JMatToCsv_+3A_withquotes">withquotes</code></td>
<td>
<p>boolean to mark if row and column names in the .csv file must be written surrounded by doble quotes. Default: FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numbers are written to text with as many decimal places as allowed by its data type (internally obtained
with std::numeric_limits&lt;type&gt;::max_digits10)<br />
NOTE ON READING FROM R: to read the .csv files exported by this function you MUST use the R function read.csv
(not read.table) AND set its argument row.names to 1, since we always write a first column with the row names,
even if the binary matrix does not store them; in this case they are simply &quot;1&quot;,&quot;2&quot;,...
</p>


<h3>Value</h3>

<p>No return value, called for side effects (creates a file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
tmpcsvfile1=paste0(tempdir(),"/Rfullfloat.csv")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
JMatToCsv(tmpfile1,tmpcsvfile1)
</code></pre>

<hr>
<h2 id='JWriteBin'>JWriteBin</h2><span id='topic+JWriteBin'></span>

<h3>Description</h3>

<p>Writes a R matrix to a disk file as a binary matrix in the jmatrix format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JWriteBin(M, fname, dtype = "float", dmtype = "full", comment = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JWriteBin_+3A_m">M</code></td>
<td>
<p>The R matrix to be written</p>
</td></tr>
<tr><td><code id="JWriteBin_+3A_fname">fname</code></td>
<td>
<p>The name of the file to write</p>
</td></tr>
<tr><td><code id="JWriteBin_+3A_dtype">dtype</code></td>
<td>
<p>The data type of the matrix to be written: one of the strings 'short', 'int', 'long', 'float' or 'double'. Default: 'float'</p>
</td></tr>
<tr><td><code id="JWriteBin_+3A_dmtype">dmtype</code></td>
<td>
<p>The matrix type: one of the strings 'full', 'sparse' or 'symmetric'. Default: 'full'</p>
</td></tr>
<tr><td><code id="JWriteBin_+3A_comment">comment</code></td>
<td>
<p>A optional string with the comment to be added as metadata. Default: &quot;&quot; (empty string, no added comment)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function cautiously. Differently to the functions to get one or more rows or columns from the binary file,
which book only the memory strictly needed for the vector/matrix and do not load all the binary file in memory,
this function books the full matrix in the requested data type and writes it later so with very big matrices
you might run out of memory.<br />
Type 'int' is really long int (8-bytes in most modern machines) so using 'int' or 'long' is equivalent.<br />
Type is coerced from double (the internal type of R matrices) to the requested type, which may provoke a loose of precision.<br />
If M is a named-R matrix, row and column names are written as metadata, too.<br />
Also, if you write as symmetric a matrix which is not such, only the lower-diagonal part will be written.
The rest of the data will be lost. In this case, if the matrix has row and column names, only row names are written.
</p>


<h3>Value</h3>

<p>No return value, called for side effects (creates a file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
