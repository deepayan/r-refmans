<!DOCTYPE html><html><head><title>Help for package degross</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {degross}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ddegross'><p>Density function based on an object resulting from the estimation procedure in degross.</p></a></li>
<li><a href='#degross'><p>Density estimation from tabulated data with given frequencies and group central moments.</p></a></li>
<li><a href='#degross_lpost'><p>Log-posterior (with gradient and Fisher information) for given spline parameters, small bin frequencies, tabulated sample moments and roughness penalty parameter.</p>
This function is maximized during the M-step of the EM algorithm to estimate the B-spline parameters entering the density specification.</a></li>
<li><a href='#degross_lpostBasic'><p>Log-posterior for given spline parameters, big bin (and optional: small bin) frequencies, tabulated sample moments and roughness penalty parameter.</p>
Compared to degross_lpost, no Fisher information matrix is computed and the gradient evaluation is optional, with a resulting computational gain.</a></li>
<li><a href='#degross.object'><p>Object resulting from the estimation of a density from grouped (tabulated) summary statistics</p></a></li>
<li><a href='#degrossData'><p>Creates a degrossData.object from the observed tabulated frequencies and central moments.</p></a></li>
<li><a href='#degrossData.object'><p>Object generated from grouped summary statistics, including tabulated frequencies and central moments of order 1 up to 4, to estimate the underlying density using <code>degross</code>.</p></a></li>
<li><a href='#pdegross'><p>Cumulative distribution function (cdf) based on an object resulting from the estimation procedure in degross.</p></a></li>
<li><a href='#plot.degross'><p>Plot the density estimate obtained from grouped summary statistics using degross and superpose it to the observed histogram.</p></a></li>
<li><a href='#print.degross'><p>Print a 'degross' object.</p></a></li>
<li><a href='#print.degrossData'><p>Print a 'degrossData' object.</p></a></li>
<li><a href='#qdegross'><p>Quantile function based on an object resulting from the estimation procedure in degross.</p></a></li>
<li><a href='#Sigma_fun'><p>Variance-covariance of sample central moments (root-n approximation)</p>
given the vector mu with the theoretical moments of order 1 to 8.
CAREFUL: the result must be divided by n (= sample size)!</a></li>
<li><a href='#simDegrossData'><p>Simulation of grouped data and their sample moments to illustrate the degross density estimation procedure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Density Estimation from GROuped Summary Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of a density from grouped (tabulated) summary statistics evaluated in each of the big bins (or classes) partitioning the support of the variable. These statistics include class frequencies and central moments of order one up to four. The log-density is modelled using a linear combination of penalised B-splines. The multinomial log-likelihood involving the frequencies adds up to a roughness penalty based on the differences in the coefficients of neighbouring B-splines and the log of a root-n approximation of the sampling density of the observed vector of central moments in each class. The so-obtained penalized log-likelihood is maximized using the EM algorithm to get an estimate of the spline parameters and, consequently, of the variable density and related quantities such as quantiles, see Lambert, P. (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2107.03883">doi:10.48550/arXiv.2107.03883</a>&gt; for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>cubicBsplines, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-03 10:30:10 UTC; plambert</td>
</tr>
<tr>
<td>Author:</td>
<td>Philippe Lambert [aut, cre] (Université de Liège / Université
    catholique de Louvain (Belgium))</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philippe Lambert &lt;p.lambert@uliege.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-04 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ddegross'>Density function based on an object resulting from the estimation procedure in <a href="#topic+degross">degross</a>.</h2><span id='topic+ddegross'></span>

<h3>Description</h3>

<p>Density function based on an object resulting from the estimation procedure in <a href="#topic+degross">degross</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddegross(x, degross.fit, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddegross_+3A_x">x</code></td>
<td>
<p>Scalar or vector where the fitted density must be evaluated.</p>
</td></tr>
<tr><td><code id="ddegross_+3A_degross.fit">degross.fit</code></td>
<td>
<p>A <a href="#topic+degross.object">degross.object</a> generated using <a href="#topic+degross">degross</a> and containing the density estimation results.</p>
</td></tr>
<tr><td><code id="ddegross_+3A_phi">phi</code></td>
<td>
<p>(Optional) vector of spline parameters for the log density (default: <code>degross.fit$phi</code> if missing).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or vector of the same length as <code>x</code> containing the value of the fitted density at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degross.object">degross.object</a></code>, <code><a href="#topic+pdegross">pdegross</a></code>, <code><a href="#topic+qdegross">qdegross</a></code>, <code><a href="#topic+degross">degross</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate grouped data
sim = simDegrossData(n=1500, plotting=TRUE, choice=2)

## Create a degrossData object
obj.data = degrossData(Big.bins=sim$Big.bins, freq.j=sim$freq.j, m.j=sim$m.j)
print(obj.data)

## Estimate the density
obj.fit = degross(obj.data)

## Superpose the fitted density using the &lt;ddegross&gt; function
curve(ddegross(x,obj.fit),add=TRUE,lty="dashed")
legend("topright",lty="dashed",lwd=2,legend="Estimated",box.lty=0, inset=.04)

</code></pre>

<hr>
<h2 id='degross'>Density estimation from tabulated data with given frequencies and group central moments.</h2><span id='topic+degross'></span>

<h3>Description</h3>

<p>Estimation of a density from tabulated summary statistics evaluated within each of the big bins (or classes) partitioning the variable support. These statistics include class frequencies and central moments of orders one up to four. The log-density is modelled using a linear combination of penalized B-splines. The multinomial log-likelihood involving the frequencies adds up to a roughness penalty based on differences of neighboring B-spline coefficients and to the log of a root-n approximation of the sampling density of the observed vector of central moments within each class. The so-obtained penalized log-likelihood is maximized using the EM algorithm to get an estimation of the spline parameters and, hence, of the variable density and related quantities such as quantiles, see Lambert (2021) for details.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>degross(degross.data,
       phi0 = NULL, tau0 = 1000,
       use.moments = rep(TRUE,4), freq.min = 20, diag.only=FALSE,
       penalize = TRUE,
       aa = 2, bb = 1e-06, pen.order = 3, fixed.tau = FALSE,
       plotting = FALSE, verbose = FALSE, iterlim=20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degross_+3A_degross.data">degross.data</code></td>
<td>
<p>A <a href="#topic+degrossData.object">degrossData.object</a> generated by <a href="#topic+degrossData">degrossData</a>.</p>
</td></tr>
<tr><td><code id="degross_+3A_phi0">phi0</code></td>
<td>
<p>Starting value for the <code>K</code>-vector <code class="reqn">\phi</code> of B-spline parameters specifying the log-density. Default: NULL.</p>
</td></tr>
<tr><td><code id="degross_+3A_tau0">tau0</code></td>
<td>
<p>Starting value for the roughness penalty parameter. Default: 1000.</p>
</td></tr>
<tr><td><code id="degross_+3A_use.moments">use.moments</code></td>
<td>
<p>Vector with 4 logicals indicating which tabulated sample moments to use as soft constraints. Defaults: <code>rep(TRUE,4)</code>.</p>
</td></tr>
<tr><td><code id="degross_+3A_freq.min">freq.min</code></td>
<td>
<p>Minimal big bin frequency required to use the corresponding observed moments as soft constraints. Default: <code>20</code>.</p>
</td></tr>
<tr><td><code id="degross_+3A_diag.only">diag.only</code></td>
<td>
<p>Logical indicating whether to ignore the off-diagonal elements of the variance-covariance matrix of the sample central moments. Default: FALSE.</p>
</td></tr>
<tr><td><code id="degross_+3A_penalize">penalize</code></td>
<td>
<p>Logical indicating whether a roughness penalty of order <code>pen.order</code> is required (with <code class="reqn">\tau \sim G(aa,bb)</code>). Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="degross_+3A_aa">aa</code></td>
<td>
<p>Positive real giving the first parameter in the Gamma prior for <code>tau</code>. Default: <code>2</code>.</p>
</td></tr>
<tr><td><code id="degross_+3A_bb">bb</code></td>
<td>
<p>Positive real giving the second parameter in the Gamma prior for <code>tau</code>. Default: <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="degross_+3A_pen.order">pen.order</code></td>
<td>
<p>Integer giving the order of the roughness penalty. Default: <code>3</code>.</p>
</td></tr>
<tr><td><code id="degross_+3A_fixed.tau">fixed.tau</code></td>
<td>
<p>Logical indicating whether the roughness penalty parameter <code>tau</code> is fixed. Default: FALSE, implying its estimation.</p>
</td></tr>
<tr><td><code id="degross_+3A_plotting">plotting</code></td>
<td>
<p>Logical indicating whether an histogram of the data with the estimated density should be plotted. Default: FALSE.</p>
</td></tr>
<tr><td><code id="degross_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether details on the estimation progress should be displayed. Default: FALSE.</p>
</td></tr>
<tr><td><code id="degross_+3A_iterlim">iterlim</code></td>
<td>
<p>Maximum number of iterations during the M-step. Default: 20.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>degross</code> containing several components from the density estimation procedure. Details can be found in <code><a href="#topic+degross.object">degross.object</a></code>. A summary of its content can be printed using <code><a href="#topic+print.degross">print.degross</a></code> or plotted using <code><a href="#topic+plot.degross">plot.degross</a></code>.
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degross.object">degross.object</a></code>, <code><a href="#topic+ddegross">ddegross</a></code>, <code><a href="#topic+pdegross">pdegross</a></code>, <code><a href="#topic+qdegross">qdegross</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate grouped data
sim = simDegrossData(n=3500, plotting=TRUE,choice=2,J=3)
print(sim$true.density) ## Display density of the data generating mechanism

## Create a degrossData object
obj.data = with(sim, degrossData(Big.bins=Big.bins, freq.j=freq.j, m.j=m.j))
print(obj.data)

## Estimate the density underlying the grouped data
obj.fit = degross(obj.data)

## Plot the estimated density...
plot(obj.fit)
## ... and compare it with the ('target') density used to simulate the data
curve(sim$true.density(x),add=TRUE,col="red",lwd=2)
legend("topleft",
       legend=c("Observed freq.","Target density","Estimated density"),
       col=c("grey85","red","black"), lwd=c(10,2,2),
       lty=c("solid","solid","dashed"), box.lty=0, inset=.02)

</code></pre>

<hr>
<h2 id='degross_lpost'>Log-posterior (with gradient and Fisher information) for given spline parameters, small bin frequencies, tabulated sample moments and roughness penalty parameter.
This function is maximized during the M-step of the EM algorithm to estimate the B-spline parameters entering the density specification.</h2><span id='topic+degross_lpost'></span>

<h3>Description</h3>

<p>Log-posterior (with gradient and Fisher information) for given spline parameters, small bin frequencies, tabulated sample moments and roughness penalty parameter.
This function is maximized during the M-step of the EM algorithm to estimate the B-spline parameters entering the density specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degross_lpost(phi, tau, n.i, degross.data,
                     use.moments = rep(TRUE,4), freq.min = 20, diag.only=FALSE,
                     penalize = TRUE, aa = 2, bb = 1e-6, pen.order = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degross_lpost_+3A_phi">phi</code></td>
<td>
<p>Vector of K B-spline parameters <code class="reqn">\phi</code> to specify the log-density.</p>
</td></tr>
<tr><td><code id="degross_lpost_+3A_tau">tau</code></td>
<td>
<p>Roughness penalty parameter.</p>
</td></tr>
<tr><td><code id="degross_lpost_+3A_n.i">n.i</code></td>
<td>
<p>Small bin frequencies.</p>
</td></tr>
<tr><td><code id="degross_lpost_+3A_degross.data">degross.data</code></td>
<td>
<p>A <a href="#topic+degrossData.object">degrossData.object</a> created using the <a href="#topic+degrossData">degrossData</a> function.</p>
</td></tr>
<tr><td><code id="degross_lpost_+3A_use.moments">use.moments</code></td>
<td>
<p>Vector with 4 logicals indicating which tabulated sample moments to use as soft constraints. Defaults: <code>rep(TRUE,4)</code>.</p>
</td></tr>
<tr><td><code id="degross_lpost_+3A_freq.min">freq.min</code></td>
<td>
<p>Minimal big bin frequency required to use the corresponding observed moments as soft constraints. Default: <code>20</code>.</p>
</td></tr>
<tr><td><code id="degross_lpost_+3A_diag.only">diag.only</code></td>
<td>
<p>Logical indicating whether to ignore the off-diagonal elements of the variance-covariance matrix of the sample central moments. Default: FALSE.</p>
</td></tr>
<tr><td><code id="degross_lpost_+3A_penalize">penalize</code></td>
<td>
<p>Logical indicating whether a roughness penalty of order <code>pen.order</code> is required (with <code class="reqn">\tau \sim G(aa,bb)</code>). Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="degross_lpost_+3A_aa">aa</code></td>
<td>
<p>Positive real giving the first parameter in the Gamma prior for <code>tau</code>. Default: <code>2</code>.</p>
</td></tr>
<tr><td><code id="degross_lpost_+3A_bb">bb</code></td>
<td>
<p>Positive real giving the second parameter in the Gamma prior for <code>tau</code>. Default: <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="degross_lpost_+3A_pen.order">pen.order</code></td>
<td>
<p>Integer giving the order of the roughness penalty. Default: <code>3</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing :
</p>

<ul>
<li><p><code>lpost</code>, <code>lpost.ni</code> : <code style="white-space: pre;">&#8288; &#8288;</code>value of the log-posterior based on the given small bin frequencies <code>n.i</code> and the tabulated sample moments.
</p>
</li>
<li><p><code>lpost.mj</code> : <code style="white-space: pre;">&#8288; &#8288;</code>value of the log-posterior based on the big bin frequencies <code>degross.data$freq.j</code> and the tabulated sample moments.
</p>
</li>
<li><p><code>llik.ni</code> : <code style="white-space: pre;">&#8288; &#8288;</code>multinomial log-likelihood based on the given small bin frequencies <code>n.i</code>.
</p>
</li>
<li><p><code>llik.mj</code> : <code style="white-space: pre;">&#8288; &#8288;</code>multinomial log-likelihood based on the big bin frequencies <code>degross.data$freq.j</code>.
</p>
</li>
<li><p><code>moments.penalty</code> : <code style="white-space: pre;">&#8288; &#8288;</code>log of the joint (asymptotic) density for the observed sample moments.
</p>
</li>
<li><p><code>penalty</code> : <code style="white-space: pre;">&#8288; &#8288;</code><code class="reqn">\log p(\phi|\tau) + \log p(\tau)</code>.
</p>
</li>
<li><p><code>Score</code>, <code>Score.ni</code> : <code style="white-space: pre;">&#8288; &#8288;</code>score (w.r.t. <code class="reqn">\phi</code>) of <code>lpost.ni</code>.
</p>
</li>
<li><p><code>Score.mj</code> : <code style="white-space: pre;">&#8288; &#8288;</code>score (w.r.t. <code class="reqn">\phi</code>) of <code>lpost.mj</code>.
</p>
</li>
<li><p><code>Fisher</code> &amp; <code>Fisher.ni</code>: <code style="white-space: pre;">&#8288; &#8288;</code>information matrix (w.r.t. <code class="reqn">\phi</code>) of <code>lpost.ni</code>.
</p>
</li>
<li><p><code>Fisher.mj</code> : <code style="white-space: pre;">&#8288; &#8288;</code>information matrix (w.r.t. <code class="reqn">\phi</code>) of <code>lpost.mj</code>.
</p>
</li>
<li><p><code>M.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>theoretical moments of the density (resulting from <code class="reqn">\phi</code>) within a big bin.
</p>
</li>
<li><p><code>pi.i</code> : <code style="white-space: pre;">&#8288; &#8288;</code>small bin probabilities.
</p>
</li>
<li><p><code>ui</code> : <code style="white-space: pre;">&#8288; &#8288;</code>small bin midpoints.
</p>
</li>
<li><p><code>delta</code> : <code style="white-space: pre;">&#8288; &#8288;</code>width of the small bins.
</p>
</li>
<li><p><code>gamma.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>Big bin probabilities.
</p>
</li>
<li><p><code>tau</code> : <code style="white-space: pre;">&#8288; &#8288;</code>reminder of the value of the roughness penalty parameter <code class="reqn">\tau</code>.
</p>
</li>
<li><p><code>phi</code> : <code style="white-space: pre;">&#8288; &#8288;</code>reminder of the vector of spline parameters (defining the density).
</p>
</li>
<li><p><code>n.i</code> : <code style="white-space: pre;">&#8288; &#8288;</code>reminder of the small bin frequencies given as input.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degross_lpostBasic">degross_lpostBasic</a></code>, <code><a href="#topic+degross">degross</a></code>, <code><a href="#topic+degross.object">degross.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim = simDegrossData(n=3500, plotting=TRUE,choice=2) ## Generate grouped data
obj.data = degrossData(Big.bins=sim$Big.bins, freq.j=sim$freq.j, m.j=sim$m.j)
print(obj.data)
obj.fit = degross(obj.data) ## Estimate the underlying density
## Evaluate the log-posterior at convergence
res = with(obj.fit, degross_lpost(phi, tau, n.i, obj.data, diag.only=diag.only))
print(res$Score) ## Score of the log posterior at convergence

</code></pre>

<hr>
<h2 id='degross_lpostBasic'>Log-posterior for given spline parameters, big bin (and optional: small bin) frequencies, tabulated sample moments and roughness penalty parameter.
Compared to <a href="#topic+degross_lpost">degross_lpost</a>, no Fisher information matrix is computed and the gradient evaluation is optional, with a resulting computational gain.</h2><span id='topic+degross_lpostBasic'></span>

<h3>Description</h3>

<p>Log-posterior for given spline parameters, big bin (and optional: small bin) frequencies, tabulated sample moments and roughness penalty parameter.
Compared to <a href="#topic+degross_lpost">degross_lpost</a>, no Fisher information matrix is computed and the gradient evaluation is optional, with a resulting computational gain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degross_lpostBasic(phi, tau, n.i, degross.data,
                          use.moments = rep(TRUE,4), freq.min = 20, diag.only=FALSE,
                          gradient=FALSE,
                          penalize = TRUE, aa = 2, bb = 1e-6, pen.order = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degross_lpostBasic_+3A_phi">phi</code></td>
<td>
<p>Vector of K B-spline parameters <code class="reqn">\phi</code> to specify the log-density.</p>
</td></tr>
<tr><td><code id="degross_lpostBasic_+3A_tau">tau</code></td>
<td>
<p>Roughness penalty parameter.</p>
</td></tr>
<tr><td><code id="degross_lpostBasic_+3A_n.i">n.i</code></td>
<td>
<p>Small bin frequencies.</p>
</td></tr>
<tr><td><code id="degross_lpostBasic_+3A_degross.data">degross.data</code></td>
<td>
<p>A <a href="#topic+degrossData.object">degrossData.object</a> created using the <a href="#topic+degrossData">degrossData</a> function.</p>
</td></tr>
<tr><td><code id="degross_lpostBasic_+3A_use.moments">use.moments</code></td>
<td>
<p>Vector with 4 logicals indicating which tabulated sample moments to use as soft constraints. Defaults: <code>rep(TRUE,4)</code>.</p>
</td></tr>
<tr><td><code id="degross_lpostBasic_+3A_freq.min">freq.min</code></td>
<td>
<p>Minimal big bin frequency required to use the corresponding observed moments as soft constraints. Default: <code>20</code>.</p>
</td></tr>
<tr><td><code id="degross_lpostBasic_+3A_diag.only">diag.only</code></td>
<td>
<p>Logical indicating whether to ignore the off-diagonal elements of the variance-covariance matrix of the sample central moments. Default: FALSE.</p>
</td></tr>
<tr><td><code id="degross_lpostBasic_+3A_gradient">gradient</code></td>
<td>
<p>Logical indicating if the gradient (Score) of the <code class="reqn">\log p(\phi|\tau,data)</code> should be computed (default: FALSE).</p>
</td></tr>
<tr><td><code id="degross_lpostBasic_+3A_penalize">penalize</code></td>
<td>
<p>Logical indicating whether a roughness penalty of order <code>pen.order</code> is required (with <code class="reqn">tau \sim G(aa,bb)</code>). Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="degross_lpostBasic_+3A_aa">aa</code></td>
<td>
<p>Real giving the first parameter in the Gamma prior for <code>tau</code>. Default: <code>2</code>.</p>
</td></tr>
<tr><td><code id="degross_lpostBasic_+3A_bb">bb</code></td>
<td>
<p>Real giving the second parameter in the Gamma prior for <code>tau</code>. Default: <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="degross_lpostBasic_+3A_pen.order">pen.order</code></td>
<td>
<p>Integer giving the order of the roughness penalty. Default: <code>3</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing :
</p>

<ul>
<li><p><code>lpost.ni</code> : <code style="white-space: pre;">&#8288; &#8288;</code>value of the log-posterior based on the given small bin frequencies <code>n.i</code> and the tabulated sample moments.
</p>
</li>
<li><p><code>lpost.mj</code> : <code style="white-space: pre;">&#8288; &#8288;</code>value of the log-posterior based on the big bin frequencies <code>degross.data$freq.j</code> and the tabulated sample moments.
</p>
</li>
<li><p><code>llik.ni</code> : <code style="white-space: pre;">&#8288; &#8288;</code>multinomial log-likelihood based on the given small bin frequencies <code>n.i</code>.
</p>
</li>
<li><p><code>llik.mj</code> : <code style="white-space: pre;">&#8288; &#8288;</code>multinomial log-likelihood based on the big bin frequencies <code>degross.data$freq.j</code> resulting from <code>n.i</code>.
</p>
</li>
<li><p><code>moments.penalty</code> : <code style="white-space: pre;">&#8288; &#8288;</code>log of the joint (asymptotic) density for the observed sample moments.
</p>
</li>
<li><p><code>penalty</code> : <code style="white-space: pre;">&#8288; &#8288;</code><code class="reqn">\log p(\phi|\tau) + \log p(\tau)</code>.
</p>
</li>
<li><p><code>M.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>theoretical moments of the density (resulting from <code class="reqn">\phi</code>) within a big bin.
</p>
</li>
<li><p><code>pi.i</code> : <code style="white-space: pre;">&#8288; &#8288;</code>small bin probabilities.
</p>
</li>
<li><p><code>ui</code> : <code style="white-space: pre;">&#8288; &#8288;</code>small bin midpoints.
</p>
</li>
<li><p><code>delta</code> : <code style="white-space: pre;">&#8288; &#8288;</code>width of the small bins.
</p>
</li>
<li><p><code>gamma.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>big bin probabilities.
</p>
</li>
<li><p><code>tau</code> : <code style="white-space: pre;">&#8288; &#8288;</code>reminder of the value of the roughness penalty parameter <code class="reqn">\tau</code>.
</p>
</li>
<li><p><code>phi</code> : <code style="white-space: pre;">&#8288; &#8288;</code>reminder of the vector of spline parameters (defining the density).
</p>
</li>
<li><p><code>n.i</code> : <code style="white-space: pre;">&#8288; &#8288;</code>reminder of the small bin frequencies given as input.
</p>
</li>
<li><p><code>freq.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>reminder of the big bin frequencies in <code>degross.data$freq.j</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degross_lpost">degross_lpost</a></code>, <code><a href="#topic+degross">degross</a></code>, <code><a href="#topic+degross.object">degross.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim = simDegrossData(n=3500, plotting=TRUE,choice=2) ## Generate grouped data
obj.data = degrossData(Big.bins=sim$Big.bins, freq.j=sim$freq.j, m.j=sim$m.j)
print(obj.data)
obj.fit = degross(obj.data) ## Estimate the underlying density
phi.hat = obj.fit$phi ; tau.hat = obj.fit$tau
## Evaluate the log-posterior at convergence
res = degross_lpostBasic(phi=phi.hat, tau=tau.hat, degross.data=obj.data,
                         gradient=TRUE)
print(res)

</code></pre>

<hr>
<h2 id='degross.object'>Object resulting from the estimation of a density from grouped (tabulated) summary statistics</h2><span id='topic+degross.object'></span>

<h3>Description</h3>

<p>An object returned by the <code><a href="#topic+degross">degross</a></code> function is a list containing several components resulting from the density estimation procedure.
</p>


<h3>Value</h3>

<p>A <code>degross</code> object is a list containing, after convergence of the EM algorithm :
</p>

<ul>
<li><p><code>lpost</code> &amp; <code>lpost.ni</code>: <code style="white-space: pre;">&#8288; &#8288;</code>value of the log-posterior for the complete data based on the expected small bin frequencies <code>n.i</code> at convergence of the EM algorithm.
</p>
</li>
<li><p><code>lpost.mj</code> : <code style="white-space: pre;">&#8288; &#8288;</code>value of the log-posterior for the observed data based on the big bin frequencies <code>freq.j</code>.
</p>
</li>
<li><p><code>llik.ni</code>:  <code style="white-space: pre;">&#8288; &#8288;</code>log-likelihood for the complete data based on the estimated small bin frequencies <code>n.i</code>.
</p>
</li>
<li><p><code>llik.mj</code> : <code style="white-space: pre;">&#8288; &#8288;</code>log-likelihood for the observed data based on the big bin frequencies <code>freq.j</code>.
</p>
</li>
<li><p><code>moments.penalty</code> : <code style="white-space: pre;">&#8288; &#8288;</code>log of the joint (asymptotic) density for the observed sample moments.
</p>
</li>
<li><p><code>penalty</code> : <code style="white-space: pre;">&#8288; &#8288;</code><code class="reqn">\log p(\phi|\tau) + \log p(\tau)</code>.
</p>
</li>
<li><p><code>Score</code> &amp; <code>Score.mj</code>: <code style="white-space: pre;">&#8288; &#8288;</code>score (w.r.t. <code class="reqn">\phi</code>) of the log of the observed joint posterior function.
</p>
</li>
<li><p><code>Score.ni</code>: <code style="white-space: pre;">&#8288; &#8288;</code>score (w.r.t. <code class="reqn">\phi</code>) of the log-posterior for the complete data based on the expected small bin frequencies <code>n.i</code> at convergence of the EM algorithm.
</p>
</li>
<li><p><code>Fisher</code> &amp; <code>Fisher.ni</code>: <code style="white-space: pre;">&#8288; &#8288;</code>information matrix (w.r.t. <code class="reqn">\phi</code>) based on the log-posterior for the complete data based on the expected small bin frequencies <code>n.i</code> at convergence of the EM algorithm.
</p>
</li>
<li><p><code>Fisher.mj</code> : <code style="white-space: pre;">&#8288; &#8288;</code>information matrix (w.r.t. <code class="reqn">\phi</code>) based on the log of the observed joint posterior function.
</p>
</li>
<li><p><code>M.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>theoretical moments of the fitted density within a big bin.
</p>
</li>
<li><p><code>pi.i</code> : <code style="white-space: pre;">&#8288; &#8288;</code>small bin probabilities (at convergence).
</p>
</li>
<li><p><code>ui</code> : <code style="white-space: pre;">&#8288; &#8288;</code>small bin midpoints.
</p>
</li>
<li><p><code>delta</code> : <code style="white-space: pre;">&#8288; &#8288;</code>width of the small bins.
</p>
</li>
<li><p><code>gamma.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>big bin probabilities (at convergence).
</p>
</li>
<li><p><code>tau</code> : <code style="white-space: pre;">&#8288; &#8288;</code>value of the roughness penalty parameter <code class="reqn">\tau</code> (<code>tau0</code> if <code>fixed.tau</code>=TRUE, estimated otherwise).
</p>
</li>
<li><p><code>phi</code> : <code style="white-space: pre;">&#8288; &#8288;</code>vector with the spline parameters (at convergence).
</p>
</li>
<li><p><code>n.i</code> : <code style="white-space: pre;">&#8288; &#8288;</code>small bin frequencies under the estimated density (at convergence).
</p>
</li>
<li><p><code>edf</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the effective degrees of freedom (or effective number of spline parameters) (at convergence).
</p>
</li>
<li><p><code>aic</code> : <code style="white-space: pre;">&#8288; &#8288;</code>-2*(<code>llik.mj</code> + <code>moments.penalty</code>) + 2<em><code>edf</code>.</em>
</p>
<p><code>bic</code> : <code style="white-space: pre;">&#8288; &#8288;</code>-2(<code>llik.mj</code> + <code>moments.penalty</code>) + <code class="reqn">\log(n)</code>*<code>edf</code>.
</p>
</li>
<li><p><code>log.evidence</code> : <code style="white-space: pre;">&#8288; &#8288;</code>approximation to the log of <code class="reqn">p(\hat{\phi}_\tau,\hat{\tau} | D)</code> <code class="reqn">|\Sigma_\phi|^{(1/2)}</code>.
</p>
</li>
<li><p><code>degross.data</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the <a href="#topic+degrossData">degrossData</a> object from which density estimation proceeded.
</p>
</li>
<li><p><code>use.moments</code> : <code style="white-space: pre;">&#8288; &#8288;</code>vector of 4 logicals indicating which tabulated sample moments were used as soft constraints during estimation.
</p>
</li>
<li><p><code>diag.only</code> : <code style="white-space: pre;">&#8288; &#8288;</code>logical indicating whether the off-diagonal elements of the variance-covariance matrix of the sample central moments were ignored. Default: FALSE.
</p>
</li>
<li><p><code>logNormCst</code> : <code style="white-space: pre;">&#8288; &#8288;</code>log of the normalizing constant when evaluating the density.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degross">degross</a></code>, <code><a href="#topic+print.degross">print.degross</a></code>, <code><a href="#topic+plot.degross">plot.degross</a></code>.
</p>

<hr>
<h2 id='degrossData'>Creates a <a href="#topic+degrossData.object">degrossData.object</a> from the observed tabulated frequencies and central moments.</h2><span id='topic+degrossData'></span>

<h3>Description</h3>

<p>Creates a <a href="#topic+degrossData.object">degrossData.object</a> from the observed tabulated frequencies and central moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degrossData(Big.bins, freq.j, m.j, I=300, K=25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degrossData_+3A_big.bins">Big.bins</code></td>
<td>
<p>Vector of length <code>J+1</code> with the limits of the <code>J</code> big bins containing the data used to produce the tabulated statistics.</p>
</td></tr>
<tr><td><code id="degrossData_+3A_freq.j">freq.j</code></td>
<td>
<p>The number of data observed within each big bin.</p>
</td></tr>
<tr><td><code id="degrossData_+3A_m.j">m.j</code></td>
<td>
<p>A matrix of dim <code>J</code> by 4 giving the first 4 sample central moments within each of the <code>J</code> big bins.</p>
</td></tr>
<tr><td><code id="degrossData_+3A_i">I</code></td>
<td>
<p>The number of small bins used for quadrature during the normalization of the density during its estimation. Default: <code>300</code>.</p>
</td></tr>
<tr><td><code id="degrossData_+3A_k">K</code></td>
<td>
<p>The desired number of B-splines in the basis used for density estimation. Default= <code>25</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+degrossData.object">degrossData.object</a>, i.e. a list containing:
</p>

<ul>
<li><p><code>small.bins</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a vector of length <code>I+1</code> with the small bin limits.
</p>
</li>
<li><p><code>ui</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the <code>I</code> midpoints of the small bins.
</p>
</li>
<li><p><code>delta</code> : <code style="white-space: pre;">&#8288; &#8288;</code>width of the small bins.
</p>
</li>
<li><p><code>I</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the number of small bins.
</p>
</li>
<li><p><code>B.i</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a matrix of dim <code>I</code> by <code>K</code> with the B-spline basis evaluated at the small bin midpoints.
</p>
</li>
<li><p><code>K</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of B-splines in the basis.
</p>
</li>
<li><p><code>knots</code> : <code style="white-space: pre;">&#8288; &#8288;</code>equidistant knots supporting the B-splines basis.
</p>
</li>
<li><p><code>Big.bins</code> : <code style="white-space: pre;">&#8288; &#8288;</code>vector of length <code>J+1</code> with the limits of the <code>J</code> big bins containing the data used to produce the tabulated statistics.
</p>
</li>
<li><p><code>freq.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the number of data observed within each big bin.
</p>
</li>
<li><p><code>m.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a matrix of dim <code>J</code> by 4 giving the first 4 sample central moments within each big bin.
</p>
</li>
<li><p><code>J</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the number of big bins.
</p>
</li>
<li><p><code>small.to.big</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a vector of length <code>I</code> indicating to what big bin each element of <code>ui</code> belongs.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.degrossData">print.degrossData</a></code>, <code><a href="#topic+degross">degross</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim = simDegrossData(n=3500, plotting=TRUE)
obj.data = degrossData(Big.bins=sim$Big.bins, freq.j=sim$freq.j, m.j=sim$m.j)
print(obj.data)

</code></pre>

<hr>
<h2 id='degrossData.object'>Object generated from grouped summary statistics, including tabulated frequencies and central moments of order 1 up to 4, to estimate the underlying density using <code><a href="#topic+degross">degross</a></code>.</h2><span id='topic+degrossData.object'></span>

<h3>Description</h3>

<p>An object returned by the <code><a href="#topic+degrossData">degrossData</a></code> function from tabulated frequencies and central moments of order 1 up to 4. It is used in a second step by <code><a href="#topic+degross">degross</a></code> to estimate the underlying density.
</p>


<h3>Value</h3>

<p>A list containing :
</p>

<ul>
<li><p><code>small.bins</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a vector of length <code>I+1</code> with the small bin limits.
</p>
</li>
<li><p><code>ui</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the <code>I</code> midpoints of the small bins.
</p>
</li>
<li><p><code>delta</code> : <code style="white-space: pre;">&#8288; &#8288;</code>width of the small bins.
</p>
</li>
<li><p><code>I</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the number of small bins.
</p>
</li>
<li><p><code>B.i</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a matrix of dim <code>I</code> by <code>K</code> with the B-spline basis evaluated at the small bin midpoints.
</p>
</li>
<li><p><code>K</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of B-splines in the basis.
</p>
</li>
<li><p><code>knots</code> : <code style="white-space: pre;">&#8288; &#8288;</code>equidistant knots supporting the B-splines basis.
</p>
</li>
<li><p><code>Big.bins</code> : <code style="white-space: pre;">&#8288; &#8288;</code>vector of length <code>J+1</code> with the limits of the <code>J</code> big bins containing the data used to produce the tabulated statistics.
</p>
</li>
<li><p><code>freq.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the number of data observed within each big bin.
</p>
</li>
<li><p><code>m.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a matrix of dim <code>J</code> by 4 giving the first 4 sample central moments within each big bin.
</p>
</li>
<li><p><code>J</code> : <code style="white-space: pre;">&#8288; &#8288;</code>the number of big bins.
</p>
</li>
<li><p><code>small.to.big</code> : <code style="white-space: pre;">&#8288; &#8288;</code>a vector of length <code>I</code> indicating to what big bin each element of <code>ui</code> belongs.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degrossData">degrossData</a></code>, <code><a href="#topic+print.degrossData">print.degrossData</a></code>
</p>

<hr>
<h2 id='pdegross'>Cumulative distribution function (cdf) based on an object resulting from the estimation procedure in <a href="#topic+degross">degross</a>.</h2><span id='topic+pdegross'></span>

<h3>Description</h3>

<p>Cumulative distribution function (cdf) based on an object resulting from the estimation procedure in <a href="#topic+degross">degross</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdegross(x, degross.fit, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdegross_+3A_x">x</code></td>
<td>
<p>Scalar or vector where the fitted cdf must be evaluated.</p>
</td></tr>
<tr><td><code id="pdegross_+3A_degross.fit">degross.fit</code></td>
<td>
<p>A <code><a href="#topic+degross.object">degross.object</a></code> generated using <a href="#topic+degross">degross</a> and containing the density estimation results.</p>
</td></tr>
<tr><td><code id="pdegross_+3A_phi">phi</code></td>
<td>
<p>(Optional) vector of spline parameters for the log density (default: <code>degross.fit$phi</code> if missing).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar or vector of the same length as <code>x</code> containing the value of the fitted cdf at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degross.object">degross.object</a></code>, <code><a href="#topic+ddegross">ddegross</a></code>, <code><a href="#topic+qdegross">qdegross</a></code>, <code><a href="#topic+degross">degross</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate grouped data
sim = simDegrossData(n=3500, plotting=TRUE, choice=2)

## Create a degrossData object
obj.data = degrossData(Big.bins=sim$Big.bins, freq.j=sim$freq.j, m.j=sim$m.j)
print(obj.data)

## Estimate the density
obj.fit = degross(obj.data)

## Superpose the fitted cdf using the &lt;pdegross&gt; function
with(sim, curve(true.cdf(x),min(Big.bins),max(Big.bins),
     col="red",lwd=2, ylab="F(x)"))
curve(pdegross(x,obj.fit),add=TRUE,lty="dashed")
legend("topleft", legend=c("Target cdf","Estimated cdf"), lwd=2,
       lty=c("solid","dashed"), col=c("red","black"), box.lty=0, inset=.04)

</code></pre>

<hr>
<h2 id='plot.degross'>Plot the density estimate obtained from grouped summary statistics using <a href="#topic+degross">degross</a> and superpose it to the observed histogram.</h2><span id='topic+plot.degross'></span>

<h3>Description</h3>

<p>Plot the density estimate corresponding to a <code>degross</code> object and superpose it to the observed histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'degross'
plot(x, col="black", lwd=2, lty="dashed", xlab="", ylab="Density", main="",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.degross_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+degross.object">degross.object</a> generated by <a href="#topic+degross">degross</a>.</p>
</td></tr>
<tr><td><code id="plot.degross_+3A_col">col</code></td>
<td>
<p>Color used for plotting the fitted density.</p>
</td></tr>
<tr><td><code id="plot.degross_+3A_lwd">lwd</code></td>
<td>
<p>Line width for the fitted density curve.</p>
</td></tr>
<tr><td><code id="plot.degross_+3A_lty">lty</code></td>
<td>
<p>Line type for the the fitted density curve.</p>
</td></tr>
<tr><td><code id="plot.degross_+3A_xlab">xlab</code></td>
<td>
<p>Label on the x-axis.</p>
</td></tr>
<tr><td><code id="plot.degross_+3A_ylab">ylab</code></td>
<td>
<p>Label on the y-axis.</p>
</td></tr>
<tr><td><code id="plot.degross_+3A_main">main</code></td>
<td>
<p>Title for the generated graph.</p>
</td></tr>
<tr><td><code id="plot.degross_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>hist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A histogram based on the observed big bin frequencies with the fitted density superposed.
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degross">degross</a></code>, <code><a href="#topic+degross.object">degross.object</a></code>, <code><a href="#topic+print.degross">print.degross</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim = simDegrossData(n=3500, plotting=TRUE,choice=2) ## Generate grouped data
obj.data = degrossData(Big.bins=sim$Big.bins, freq.j=sim$freq.j, m.j=sim$m.j)
print(obj.data)
obj.fit = degross(obj.data) ## Estimate the underlying density
plot(obj.fit) ## Plot the fitted density with the data histogram

</code></pre>

<hr>
<h2 id='print.degross'>Print a 'degross' object.</h2><span id='topic+print.degross'></span>

<h3>Description</h3>

<p>Print a summary of the information contained in a <a href="#topic+degross.object">degross.object</a> generated by <code><a href="#topic+degross">degross</a></code> for density estimation from tabulated frequency and central moment data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'degross'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.degross_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+degross.object">degross.object</a> generated by <a href="#topic+degross">degross</a>.</p>
</td></tr>
<tr><td><code id="print.degross_+3A_...">...</code></td>
<td>
<p>Possible additional printing options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print information on the fitted density corresponding to the <a href="#topic+degross.object">degross.object</a> <code>x</code>: the estimated central moments within each class (or big bin) are printed with global fit statistics. A summary of the observed data is also provided: it includes the total sample size, the numbers of small and big bins with their limits in addition to the number of B-splines used for density estimation with <code><a href="#topic+degross">degross</a></code>.
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degross">degross</a></code>, <code><a href="#topic+plot.degross">plot.degross</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim = simDegrossData(n=3500, plotting=TRUE)
obj.data = degrossData(Big.bins=sim$Big.bins, freq.j=sim$freq.j, m.j=sim$m.j)

## Estimate the density underlying the grouped data
obj.fit = degross(obj.data)
print(obj.fit)

</code></pre>

<hr>
<h2 id='print.degrossData'>Print a 'degrossData' object.</h2><span id='topic+print.degrossData'></span>

<h3>Description</h3>

<p>Print a summary of the information contained in a <code><a href="#topic+degrossData.object">degrossData.object</a></code> used by <code><a href="#topic+degross">degross</a></code> for density estimation from tabulated frequency and moment data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'degrossData'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.degrossData_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+degrossData.object">degrossData.object</a> generated by <a href="#topic+degrossData">degrossData</a>.</p>
</td></tr>
<tr><td><code id="print.degrossData_+3A_...">...</code></td>
<td>
<p>Possible additional printing options for a matrix object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print the tabulated summary statistics contained in the <a href="#topic+degrossData.object">degrossData.object</a> <code>x</code>, with additional information on the total sample size, numbers of small and big bins with their limits, the number of B-splines planned for density estimation using <code><a href="#topic+degross">degross</a></code>.
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degross">degross</a></code>, <code><a href="#topic+degrossData">degrossData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim = simDegrossData(n=3500, plotting=TRUE)
obj.data = degrossData(Big.bins=sim$Big.bins, freq.j=sim$freq.j, m.j=sim$m.j)
print(obj.data)

</code></pre>

<hr>
<h2 id='qdegross'>Quantile function based on an object resulting from the estimation procedure in <a href="#topic+degross">degross</a>.</h2><span id='topic+qdegross'></span>

<h3>Description</h3>

<p>Quantile function based on an object resulting from the estimation procedure in <a href="#topic+degross">degross</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdegross(p, degross.fit, phi, get.se=FALSE, cred.level=.95, eps=1e-4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdegross_+3A_p">p</code></td>
<td>
<p>Scalar or vector of probabilities in (0,1) indicating the requested fitted quantiles Q(p) based on the density estimation results in <code>degross.fit</code>.</p>
</td></tr>
<tr><td><code id="qdegross_+3A_degross.fit">degross.fit</code></td>
<td>
<p>A <code><a href="#topic+degross.object">degross.object</a></code> generated using <a href="#topic+degross">degross</a> and containing the density estimation results.</p>
</td></tr>
<tr><td><code id="qdegross_+3A_phi">phi</code></td>
<td>
<p>(Optional) vector of spline parameters for the log density (default: <code>degross.fit$phi</code> if missing).</p>
</td></tr>
<tr><td><code id="qdegross_+3A_get.se">get.se</code></td>
<td>
<p>Logical indicating if standard errors for Q(p) are requested (default: FALSE).</p>
</td></tr>
<tr><td><code id="qdegross_+3A_cred.level">cred.level</code></td>
<td>
<p>Level of credible intervals for Q(p).</p>
</td></tr>
<tr><td><code id="qdegross_+3A_eps">eps</code></td>
<td>
<p>Precision with which each quantile should be computed (default: 1e-4).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or vector <code>x</code> of the same length as <code>p</code> containing the values Q(p) at which the cdf <code>pdegross(x,degross.fit)</code> is equal to <code>p</code>.
When <code>get.se</code> is TRUE, a vector or a matrix containing the quantile estimate(s), standard errors and credible interval limits for Q(p) is provided.
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degross.object">degross.object</a></code>, <code><a href="#topic+ddegross">ddegross</a></code>, <code><a href="#topic+pdegross">pdegross</a></code>, <code><a href="#topic+degross">degross</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate grouped data
sim = simDegrossData(n=3500, plotting=TRUE, choice=2)

## Create a degrossData object
obj.data = degrossData(Big.bins=sim$Big.bins, freq.j=sim$freq.j, m.j=sim$m.j)
print(obj.data)

## Estimate the density
obj.fit = degross(obj.data)

## Corresponding fitted quantiles
p = c(.01,.05,seq(.1,.9,by=.1),.95,.99) ## Desired probabilities
Q.p = qdegross(p,obj.fit) ## Compute the desired quantiles
print(Q.p) ## Estimated quantiles

## Compute the standard error and a 90% credible interval for the 60% quantile
Q.60 = qdegross(.60,obj.fit,get.se=TRUE,cred.level=.90) ## Compute the desired quantile
print(Q.60) ## Estimated quantile, standard error and credible interval

</code></pre>

<hr>
<h2 id='Sigma_fun'>Variance-covariance of sample central moments (root-n approximation)
given the vector mu with the theoretical moments of order 1 to 8.
CAREFUL: the result must be divided by n (= sample size)!</h2><span id='topic+Sigma_fun'></span>

<h3>Description</h3>

<p>Variance-covariance of sample central moments (root-n approximation)
given the vector mu with the theoretical moments of order 1 to 8.
CAREFUL: the result must be divided by n (= sample size)!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sigma_fun(mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sigma_fun_+3A_mu">mu</code></td>
<td>
<p>Vector of length 8 with the first 8 theoretical central moments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance-covariance matrix of the first four sample central moments (CAREFUL: a division by the sample size is further required !)
</p>


<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu = numeric(8)
dfun = function(x) dgamma(x,10,5)
mu[1] = integrate(function(x) x*dfun(x),0,Inf)$val
for (j in 2:8) mu[j] = integrate(function(x) (x-mu[1])^j*dfun(x),0,Inf)$val
Sigma_fun(mu)

</code></pre>

<hr>
<h2 id='simDegrossData'>Simulation of grouped data and their sample moments to illustrate the <a href="#topic+degross">degross</a> density estimation procedure</h2><span id='topic+simDegrossData'></span>

<h3>Description</h3>

<p>Simulation of grouped data and their sample moments to illustrate the <a href="#topic+degross">degross</a> density estimation procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simDegrossData(n, plotting=TRUE, choice=2, J=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simDegrossData_+3A_n">n</code></td>
<td>
<p>Desired sample size</p>
</td></tr>
<tr><td><code id="simDegrossData_+3A_plotting">plotting</code></td>
<td>
<p>Logical indicating whether the histogram of the simulated data should be plotted. Default: FALSE</p>
</td></tr>
<tr><td><code id="simDegrossData_+3A_choice">choice</code></td>
<td>
<p>Integer in 1:3 indicating from which mixture of distributions to generate the data</p>
</td></tr>
<tr><td><code id="simDegrossData_+3A_j">J</code></td>
<td>
<p>Number of big bins</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing tabulated frequencies and central moments of degrees 1 to 4 for data generated using a mixture density. This list contains :
</p>

<ul>
<li><p><code>n</code> : <code style="white-space: pre;">&#8288; &#8288;</code>total sample size.
</p>
</li>
<li><p><code>J</code> : <code style="white-space: pre;">&#8288; &#8288;</code>number of big bins.
</p>
</li>
<li><p><code>Big.bins</code> : <code style="white-space: pre;">&#8288; &#8288;</code>vector of length <code>J+1</code> with the big bin limits.
</p>
</li>
<li><p><code>freq.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code>vector of length <code>J</code> with the observed big bin frequencies.
</p>
</li>
<li><p><code>m.j</code> : <code style="white-space: pre;">&#8288; &#8288;</code><code>J</code> by <code>4</code> matrix with on each row the observed first four sample central moments within a given big bin.
</p>
</li>
<li><p><code>true.density</code> : <code style="white-space: pre;">&#8288; &#8288;</code>density of the raw data generating mechanism (to be estimated from the observed grouped data).
</p>
</li>
<li><p><code>true.cdf</code> : <code style="white-space: pre;">&#8288; &#8288;</code>cdf of the raw data generating mechanism (to be estimated from the observed grouped data).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Philippe Lambert <a href="mailto:p.lambert@uliege.be">p.lambert@uliege.be</a>
</p>


<h3>References</h3>

<p>Lambert, P. (2021) Moment-based density and risk estimation from grouped summary statistics. arXiv:2107.03883.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degrossData">degrossData</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate data
sim = simDegrossData(n=3500, plotting=TRUE, choice=2, J=3)
print(sim$true.density) ## Display density of the data generating mechanism

# Create a degrossData object
obj.data = with(sim, degrossData(Big.bins=Big.bins, freq.j=freq.j, m.j=m.j))
print(obj.data)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
