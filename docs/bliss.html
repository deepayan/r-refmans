<!DOCTYPE html><html><head><title>Help for package bliss</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bliss}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+between+'><p>between</p></a></li>
<li><a href='#BIC_model_choice'><p>BIC_model_choice</p></a></li>
<li><a href='#bliss'><p>bliss: Bayesian functional Linear regression with Sparse Step functions</p></a></li>
<li><a href='#Bliss_Gibbs_Sampler'><p>Bliss_Gibbs_Sampler</p></a></li>
<li><a href='#Bliss_Simulated_Annealing'><p>Bliss_Simulated_Annealing</p></a></li>
<li><a href='#build_Fourier_basis'><p>build_Fourier_basis</p></a></li>
<li><a href='#change_grid'><p>change_grid</p></a></li>
<li><a href='#choose_beta'><p>choose_beta</p></a></li>
<li><a href='#compute_beta_posterior_density'><p>compute_beta_posterior_density</p></a></li>
<li><a href='#compute_beta_sample'><p>compute_beta_sample</p></a></li>
<li><a href='#compute_chains_info'><p>compute_chains_info</p></a></li>
<li><a href='#compute_random_walk'><p>compute_random_walk</p></a></li>
<li><a href='#compute_starting_point_sann'><p>compute_starting_point_sann</p></a></li>
<li><a href='#corr_matrix'><p>corr_matrix</p></a></li>
<li><a href='#data1'><p>a list of data</p></a></li>
<li><a href='#determine_intervals'><p>determine_intervals</p></a></li>
<li><a href='#dposterior'><p>dposterior</p></a></li>
<li><a href='#fit_Bliss'><p>fit_Bliss</p></a></li>
<li><a href='#image_Bliss'><p>image_Bliss</p></a></li>
<li><a href='#integrate_trapeze'><p>integrate_trapeze</p></a></li>
<li><a href='#interpretation_plot'><p>interpretation_plot</p></a></li>
<li><a href='#lines_bliss'><p>lines_bliss</p></a></li>
<li><a href='#param1'><p>A list of param for bliss model</p></a></li>
<li><a href='#pdexp'><p>pdexp</p></a></li>
<li><a href='#plot_bliss'><p>plot_bliss</p></a></li>
<li><a href='#printbliss'><p>Print a bliss Object</p></a></li>
<li><a href='#res_bliss1'><p>A result of the BliSS method</p></a></li>
<li><a href='#sigmoid'><p>sigmoid</p></a></li>
<li><a href='#sigmoid_sharp'><p>sigmoid_sharp</p></a></li>
<li><a href='#sim'><p>sim</p></a></li>
<li><a href='#sim_x'><p>sim_x</p></a></li>
<li><a href='#support_estimation'><p>support_estimation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Functional Linear Regression with Sparse Step Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul-Marie Grollemund [aut, cre],
  Isabelle Sanchez [ctr],
  Meili Baragatti [ctr]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul-Marie Grollemund &lt;paul.marie.grollemund@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A method for the Bayesian functional linear regression model (scalar-on-function),
  including two estimators of the coefficient function and an estimator of its support.
  A representation of the posterior distribution is also available. Grollemund P-M., Abraham C., 
  Baragatti M., Pudlo P. (2019) &lt;<a href="https://doi.org/10.1214%2F18-BA1095">doi:10.1214/18-BA1095</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pmgrollemund/bliss">https://github.com/pmgrollemund/bliss</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pmgrollemund/bliss/issues">https://github.com/pmgrollemund/bliss/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, RcppArmadillo, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, RColorBrewer</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-15 13:05:27 UTC; sanchez</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-16 13:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='+between+'>between</h2><span id='topic++between+'></span>

<h3>Description</h3>

<p>Check if a number belong to a given interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value %between% interval
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2Bbetween+2B_+3A_value">value</code></td>
<td>
<p>a numerical value.</p>
</td></tr>
<tr><td><code id="+2Bbetween+2B_+3A_interval">interval</code></td>
<td>
<p>a numerical vector: (lower,upper).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>1 %between% c(0,2)
2 %between% c(0,2)
3 %between% c(0,2)
</code></pre>

<hr>
<h2 id='BIC_model_choice'>BIC_model_choice</h2><span id='topic+BIC_model_choice'></span>

<h3>Description</h3>

<p>Model selection with BIC criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BIC_model_choice(Ks, iter, data, verbose = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC_model_choice_+3A_ks">Ks</code></td>
<td>
<p>a numerical vector containing the K values.</p>
</td></tr>
<tr><td><code id="BIC_model_choice_+3A_iter">iter</code></td>
<td>
<p>an integer, the number of iteration for each run of <code>fit_Bliss</code>.</p>
</td></tr>
<tr><td><code id="BIC_model_choice_+3A_data">data</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>Q</dt><dd><p>an integer, the number of functional covariates.</p>
</dd>
<dt>y</dt><dd><p>a numerical vector, the outcomes.</p>
</dd>
<dt>x</dt><dd><p>a list of matrices, the qth matrix contains the observations of the
qth functional covariate at time points given by <code>grids</code>.</p>
</dd>
<dt>grids</dt><dd><p>a list of numerical vectors, the qth vector is the grid of
time points for the qth functional covariate.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="BIC_model_choice_+3A_verbose">verbose</code></td>
<td>
<p>write stuff if TRUE (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector, the BIC values for the Bliss model for different
K value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
param_sim &lt;- list(Q=1,n=100,p=c(50),grids_lim=list(c(0,1)))
data      &lt;- sim(param_sim,verbose=TRUE)
iter = 1e2
Ks &lt;- 1:5

res_BIC &lt;- BIC_model_choice(Ks,iter,data)
plot(res_BIC,xlab="K",ylab="BIC")

</code></pre>

<hr>
<h2 id='bliss'>bliss: Bayesian functional Linear regression with Sparse Step functions</h2><span id='topic+bliss'></span>

<h3>Description</h3>

<p>A method for the Bayesian Functional Linear Regression model (functions-on-scalar),
including two estimators of the coefficient function and an estimator of its support.
A representation of the posterior distribution is also available.
</p>

<hr>
<h2 id='Bliss_Gibbs_Sampler'>Bliss_Gibbs_Sampler</h2><span id='topic+Bliss_Gibbs_Sampler'></span>

<h3>Description</h3>

<p>A Gibbs Sampler algorithm to sample the posterior distribution of
the Bliss model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bliss_Gibbs_Sampler(data, param, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bliss_Gibbs_Sampler_+3A_data">data</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>Q</dt><dd><p>an integer, the number of functional covariates.</p>
</dd>
<dt>y</dt><dd><p>a numerical vector, the outcome values <code>y_i</code>.</p>
</dd>
<dt>x</dt><dd><p>a list of matrices, the qth matrix contains the observations of the
qth functional covariate at time points given by <code>grids</code>.</p>
</dd>
<dt>grids</dt><dd><p>a list of numerical vectors, the qth vector is the grid of
time points for the qth functional covariate.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Bliss_Gibbs_Sampler_+3A_param">param</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>iter</dt><dd><p>an integer, the number of iterations of the Gibbs sampler algorithm.</p>
</dd>
<dt>K</dt><dd><p>a vector of integers, corresponding to the numbers of intervals for
each covariate.</p>
</dd>
<dt>p</dt><dd><p>an integer, the number of time points.</p>
</dd>
<dt>basis</dt><dd><p>a character vector (optional). The possible values are &quot;uniform&quot; (default),
&quot;epanechnikov&quot;, &quot;gauss&quot; and &quot;triangular&quot; which correspond to
different basis functions to expand the coefficient function and the
functional covariates</p>
</dd>
<dt>phi_l</dt><dd><p>a numerical (optional). An hyperparameters related to the exponential prior
on the length of the intervals. Lower values promotes wider intervals.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Bliss_Gibbs_Sampler_+3A_verbose">verbose</code></td>
<td>
<p>write stuff if TRUE (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing :
</p>

<dl>
<dt>trace</dt><dd><p>a matrix, the trace of the Gibbs Sampler.</p>
</dd>
<dt>param</dt><dd><p>a list containing parameters used to run the function. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# May take a while
param_sim &lt;- list(Q=1,n=25,p=50,grids_lim=list(c(0,1)),iter=1e4,K=2)
data_sim &lt;- sim(param_sim,verbose=FALSE)
res_Bliss_Gibbs_Sampler &lt;- Bliss_Gibbs_Sampler(data_sim,param_sim)
theta_1 &lt;- res_Bliss_Gibbs_Sampler$trace[1,]
theta_1
# Resultat for few iterations
param_sim &lt;- list(Q=1,n=25,p=50,grids_lim=list(c(0,1)),iter=5e2,K=2)
data_sim &lt;- sim(param_sim,verbose=FALSE)
res_Bliss_Gibbs_Sampler &lt;- Bliss_Gibbs_Sampler(data_sim,param_sim)
theta_1 &lt;- res_Bliss_Gibbs_Sampler$trace[1,]
theta_1

</code></pre>

<hr>
<h2 id='Bliss_Simulated_Annealing'>Bliss_Simulated_Annealing</h2><span id='topic+Bliss_Simulated_Annealing'></span>

<h3>Description</h3>

<p>A Simulated Annealing algorithm to compute the Bliss estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bliss_Simulated_Annealing(
  beta_sample,
  normalization_values,
  param,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bliss_Simulated_Annealing_+3A_beta_sample">beta_sample</code></td>
<td>
<p>a matrix. Each row is a coefficient function computed from the
posterior sample.</p>
</td></tr>
<tr><td><code id="Bliss_Simulated_Annealing_+3A_normalization_values">normalization_values</code></td>
<td>
<p>a matrix given by the function <code>Bliss_Gibbs_Sampler</code>.</p>
</td></tr>
<tr><td><code id="Bliss_Simulated_Annealing_+3A_param">param</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>grid</dt><dd><p>a numerical vector, the time points.</p>
</dd>
<dt>K</dt><dd><p>an integer, the number of intervals.</p>
</dd>
<dt>basis</dt><dd><p>a character vector (optional). The possible values are &quot;uniform&quot;
(default), &quot;epanechnikov&quot;, &quot;gauss&quot; and &quot;triangular&quot; which correspond to
different basis functions to expand the coefficient function and the
functional covariates</p>
</dd>
<dt>burnin</dt><dd><p>an integer (optional), the number of iteration to drop from the
posterior sample.</p>
</dd>
<dt>iter_sann</dt><dd><p>an integer (optional), the number of iteration of the Simulated
Annealing algorithm.</p>
</dd>
<dt>k_max</dt><dd><p>an integer (optional), the maximal number of intervals for the
Simulated Annealing algorithm.</p>
</dd>
<dt>l_max</dt><dd><p>an integer (optional), the maximal interval length for the
Simulated Annealing algorithm.</p>
</dd>
<dt>Temp_init</dt><dd><p>a nonnegative value (optional), the initial temperature for
the cooling function of the Simulated Annealing algorithm.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Bliss_Simulated_Annealing_+3A_verbose">verbose</code></td>
<td>
<p>write stuff if TRUE (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>

<dl>
<dt>Bliss_estimate</dt><dd><p>a numerical vector, corresponding to the Bliss estimate
of the coefficient function.</p>
</dd>
<dt>Smooth_estimate</dt><dd><p>a numerical vector, which is the posterior expectation
of the coefficient function for each time points.</p>
</dd>
<dt>trace</dt><dd><p>a matrix, the trace of the algorithm.</p>
</dd>
<dt>argmin</dt><dd><p>an integer, the index of the iteration minimizing the Bliss loss.</p>
</dd>
<dt>difference</dt><dd><p>a numerical vector, the difference between the Bliss
estimate and the smooth estimate.</p>
</dd>
<dt>sdifference</dt><dd><p>a numerical vector, a smooth version of <code>difference</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(data1)
data(param1)
param1$grids&lt;-data1$grids
# result of res_bliss1&lt;-fit_Bliss(data=data1,param=param1)
data(res_bliss1)
beta_sample &lt;- compute_beta_sample(posterior_sample=res_bliss1$posterior_sample,
                                   param=param1,Q=1)
param_test&lt;-list(grid=param1$grids[[1]],iter=1e3,K=2)
test&lt;-Bliss_Simulated_Annealing(beta_sample[[1]],
                 res_bliss1$posterior_sample$param$normalization_values[[1]],
                 param=param_test)
ylim &lt;- range(range(test$Bliss_estimate),range(test$Smooth_estimate))
plot(param_test$grid,test$Bliss_estimate,type="l",ylim=ylim)
lines(param_test$grid,test$Smooth_estimate,lty=2)

</code></pre>

<hr>
<h2 id='build_Fourier_basis'>build_Fourier_basis</h2><span id='topic+build_Fourier_basis'></span>

<h3>Description</h3>

<p>Define a Fourier basis to simulate functional covariate observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_Fourier_basis(grid, dim, per = 2 * pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_Fourier_basis_+3A_grid">grid</code></td>
<td>
<p>a numerical vector.</p>
</td></tr>
<tr><td><code id="build_Fourier_basis_+3A_dim">dim</code></td>
<td>
<p>a numerical value. It corresponds to <code>dim(basis)/2</code>.</p>
</td></tr>
<tr><td><code id="build_Fourier_basis_+3A_per">per</code></td>
<td>
<p>a numerical value which corresponds to the period of the sine and
cosine functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="#topic+sim_x">sim_x</a></code> function.
</p>


<h3>Value</h3>

<p>a matrix. Each row is an functional observation evaluated on the
<code>grid</code> time points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the function \code{sim_x}.
</code></pre>

<hr>
<h2 id='change_grid'>change_grid</h2><span id='topic+change_grid'></span>

<h3>Description</h3>

<p>Compute a function (evaluated on a grid) on a given (finer) grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_grid(fct, grid, new_grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_grid_+3A_fct">fct</code></td>
<td>
<p>a numerical vector, the function to evaluate on the new grid.</p>
</td></tr>
<tr><td><code id="change_grid_+3A_grid">grid</code></td>
<td>
<p>a numerical vector, the initial grid.</p>
</td></tr>
<tr><td><code id="change_grid_+3A_new_grid">new_grid</code></td>
<td>
<p>a numerical vector, the new grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector, the approximation of the function on the new grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- seq(0,1,l=1e1)
new_grid &lt;- seq(0,1,l=1e2)
fct &lt;- 3*grid^2 + sin(grid*2*pi)
plot(grid,fct,type="o",lwd=2,cex=1.5)
lines(new_grid,change_grid(fct,grid,new_grid),type="o",col="red",cex=0.8)
</code></pre>

<hr>
<h2 id='choose_beta'>choose_beta</h2><span id='topic+choose_beta'></span>

<h3>Description</h3>

<p>Compute a coefficient function for the Function Linear Regression
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose_beta(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choose_beta_+3A_param">param</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>grid</dt><dd><p>a numerical vector, the time points.</p>
</dd>
<dt>p</dt><dd><p>a numerical value, the length of the vector <code>grid</code>.</p>
</dd>
<dt>shape</dt><dd><p>a character vector: &quot;smooth&quot;, &quot;random_smooth&quot;,
&quot;simple&quot;, &quot;simple_bis&quot;, &quot;random_simple&quot;, &quot;sinusoid&quot;,
&quot;flat_sinusoid&quot; and &quot;sharp&quot;</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Several shapes are available.
</p>


<h3>Value</h3>

<p>A numerical vector which corresponds to the coefficient function
at given times points (<code>grid</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### smooth
param &lt;- list(p=100,grid=seq(0,1,length=100),shape="smooth")
beta_function &lt;- choose_beta(param)
plot(param$grid,beta_function,type="l")
### random_smooth
param &lt;- list(p=100,grid=seq(0,1,length=100),shape="random_smooth")
beta_function &lt;- choose_beta(param)
plot(param$grid,beta_function,type="l")
### simple
param &lt;- list(p=100,grid=seq(0,1,length=100),shape="simple")
beta_function &lt;- choose_beta(param)
plot(param$grid,beta_function,type="s")
### simple_bis
param &lt;- list(p=100,grid=seq(0,1,length=100),shape="simple_bis")
beta_function &lt;- choose_beta(param)
plot(param$grid,beta_function,type="s")
### random_simple
param &lt;- list(p=100,grid=seq(0,1,length=100),shape="random_simple")
beta_function &lt;- choose_beta(param)
plot(param$grid,beta_function,type="s")
### sinusoid
param &lt;- list(p=100,grid=seq(0,1,length=100),shape="sinusoid")
beta_function &lt;- choose_beta(param)
plot(param$grid,beta_function,type="l")
### flat_sinusoid
param &lt;- list(p=100,grid=seq(0,1,length=100),shape="flat_sinusoid")
beta_function &lt;- choose_beta(param)
plot(param$grid,beta_function,type="l")
### sharp
param &lt;- list(p=100,grid=seq(0,1,length=100),shape="sharp")
beta_function &lt;- choose_beta(param)
plot(param$grid,beta_function,type="l")
</code></pre>

<hr>
<h2 id='compute_beta_posterior_density'>compute_beta_posterior_density</h2><span id='topic+compute_beta_posterior_density'></span>

<h3>Description</h3>

<p>Compute the posterior density of the coefficient function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_beta_posterior_density(beta_sample, param, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_beta_posterior_density_+3A_beta_sample">beta_sample</code></td>
<td>
<p>a matrix. Each row is a coefficient function computed from the
posterior sample.</p>
</td></tr>
<tr><td><code id="compute_beta_posterior_density_+3A_param">param</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>grid</dt><dd><p>a numerical vector, the time points.</p>
</dd>
<dt>lims_estimate</dt><dd><p>a numerical vector, the time points.</p>
</dd>
<dt>burnin</dt><dd><p>an integer (optional), the number of iteration to drop from the Gibbs
sample.</p>
</dd>
<dt>lims_kde</dt><dd><p>an integer (optional), correspond to the <code>lims</code> option
of the <code>kde2d</code> funtion.</p>
</dd>
<dt>new_grid</dt><dd><p>a numerical vector (optional) to compute beta sample on a
different grid.</p>
</dd>
<dt>thin</dt><dd><p>an integer (optional) to thin the posterior sample.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="compute_beta_posterior_density_+3A_verbose">verbose</code></td>
<td>
<p>write stuff if TRUE (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The posterior densities correponds to approximations of the marginal
posterior distribitions (of beta(t) for each t).
The sample is thinned in order to reduce the correlation and the
computational time of the function <code><a href="MASS.html#topic+kde2d">kde2d</a></code>.
</p>


<h3>Value</h3>

<p>An approximation of the posterior density on a two-dimensional grid
(corresponds to the result of the <code><a href="MASS.html#topic+kde2d">kde2d</a></code> function).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(RColorBrewer)
data(data1)
data(param1)
# result of res_bliss1&lt;-fit_Bliss(data=data1,param=param1)
data(res_bliss1)
q &lt;- 1
param_beta_density &lt;- list(grid= data1[["grids"]][[q]],
                           iter= param1[["iter"]],
                           p   = param1[["p"]][q],
                           n        = length(data1[["y"]]),
                           thin     = param1[["thin"]],
                           burnin   = param1[["burnin"]],
                           lims_kde = param1[["lims_kde"]][[q]],
                           new_grid = param1[["new_grids"]][[q]],
                           lims_estimate = range(res_bliss1$Smooth_estimate[[q]]))
density_estimate &lt;- compute_beta_posterior_density(res_bliss1$beta_sample[[q]],param_beta_density)
image(density_estimate$grid_t,
      density_estimate$grid_beta_t,
      density_estimate$density,col=rev(heat.colors(100)))

</code></pre>

<hr>
<h2 id='compute_beta_sample'>compute_beta_sample</h2><span id='topic+compute_beta_sample'></span>

<h3>Description</h3>

<p>Compute the posterior coefficient function from the posterior
sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_beta_sample(posterior_sample, param, Q, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_beta_sample_+3A_posterior_sample">posterior_sample</code></td>
<td>
<p>a list provided by the function <code>Bliss_Gibbs_Sampler</code>.</p>
</td></tr>
<tr><td><code id="compute_beta_sample_+3A_param">param</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>K</dt><dd><p>a vector of integers, corresponding to the numbers of intervals for
each covariate.</p>
</dd>
<dt>grids</dt><dd><p>a numerical vector, the observation time points.</p>
</dd>
<dt>basis</dt><dd><p>a vector of characters (optional) among : &quot;uniform&quot; (default),
&quot;epanechnikov&quot;, &quot;gauss&quot; and &quot;triangular&quot; which correspond to
different basis functions to expand the coefficient function and the
functional covariates.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="compute_beta_sample_+3A_q">Q</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="compute_beta_sample_+3A_verbose">verbose</code></td>
<td>
<p>write stuff if TRUE (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a matrix containing the coefficient function posterior sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RColorBrewer)
data(data1)
data(param1)
param1$grids&lt;-data1$grids
# result of res_bliss1&lt;-fit_Bliss(data=data1,param=param1)
data(res_bliss1)
beta_sample &lt;- compute_beta_sample(posterior_sample=res_bliss1$posterior_sample,
                                   param=param1,Q=1)
indexes &lt;- sample(nrow(beta_sample[[1]]),1e2,replace=FALSE)
cols &lt;- colorRampPalette(brewer.pal(9,"YlOrRd"))(1e2)
matplot(param1$grids[[1]],t(beta_sample[[1]][indexes,]),type="l",lty=1,col=cols,
xlab="grid",ylab="")
</code></pre>

<hr>
<h2 id='compute_chains_info'>compute_chains_info</h2><span id='topic+compute_chains_info'></span>

<h3>Description</h3>

<p>Compute summaries of Gibbs Sampler chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_chains_info(chain, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_chains_info_+3A_chain">chain</code></td>
<td>
<p>a list given by the <code>Bliss_Gibbs_Sampler</code> function.</p>
</td></tr>
<tr><td><code id="compute_chains_info_+3A_param">param</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>K</dt><dd><p>a vector of integers, corresponding to the numbers of intervals for
each covariate.</p>
</dd>
<dt>grids</dt><dd><p>a numerical vector, the observation time points.</p>
</dd>
<dt>basis</dt><dd><p>a vector of characters (optional) among : &quot;uniform&quot; (default),
&quot;epanechnikov&quot;, &quot;gauss&quot; and &quot;triangular&quot; which correspond to
different basis functions to expand the coefficient function and the
functional covariates.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list containing the estimates of <code>mu</code> and <code>sigma_sq</code>, the
Smooth estimate and the chain autocorrelation for <code>mu</code>, <code>sigma_sq</code> and <code>beta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
param_sim &lt;- list(Q=1,
                  n=100,
                  p=c(50),
                  grids_lim=list(c(0,1)))
data &lt;- sim(param_sim,verbose=TRUE)

param &lt;- list(iter=5e2,
              K=c(3),
              n_chains = 3)
res_bliss &lt;- fit_Bliss(data,param,verbose=TRUE,compute_density=FALSE,sann=FALSE)

param$grids &lt;- data$grids
chains_info1 &lt;- compute_chains_info(res_bliss$chains[[1]],param)
chains_info2 &lt;- compute_chains_info(res_bliss$chains[[2]],param)
chains_info3 &lt;- compute_chains_info(res_bliss$chains[[3]],param)

# Smooth estimates
ylim &lt;- range(range(chains_info1$estimates$Smooth_estimate),
range(chains_info2$estimates$Smooth_estimate),
range(chains_info3$estimates$Smooth_estimate))
plot(data$grids[[1]],chains_info1$estimates$Smooth_estimate,type="l",ylim=ylim,
xlab="grid",ylab="")
lines(data$grids[[1]],chains_info2$estimates$Smooth_estimate,col=2)
lines(data$grids[[1]],chains_info3$estimates$Smooth_estimate,col=3)

# Autocorrelation
plot(chains_info1$autocorr_lag[,1],type="h")

</code></pre>

<hr>
<h2 id='compute_random_walk'>compute_random_walk</h2><span id='topic+compute_random_walk'></span>

<h3>Description</h3>

<p>Compute a (Gaussian) random walk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_random_walk(n, p, mu, sigma, start = rep(0, n))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_random_walk_+3A_n">n</code></td>
<td>
<p>an integer, the number of random walks.</p>
</td></tr>
<tr><td><code id="compute_random_walk_+3A_p">p</code></td>
<td>
<p>an integer, the length of the random walks.</p>
</td></tr>
<tr><td><code id="compute_random_walk_+3A_mu">mu</code></td>
<td>
<p>a numerical vector, the mean of the random walks.</p>
</td></tr>
<tr><td><code id="compute_random_walk_+3A_sigma">sigma</code></td>
<td>
<p>a numerical value which is the standard deviation of the
gaussian distribution used to compute the random walks.</p>
</td></tr>
<tr><td><code id="compute_random_walk_+3A_start">start</code></td>
<td>
<p>a numerical vector (optional) which is the initial value of
the random walks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="#topic+sim_x">sim_x</a></code> function.
</p>


<h3>Value</h3>

<p>a matrix where each row is a random walk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see the sim_x() function.
</code></pre>

<hr>
<h2 id='compute_starting_point_sann'>compute_starting_point_sann</h2><span id='topic+compute_starting_point_sann'></span>

<h3>Description</h3>

<p>Compute a starting point for the Simulated Annealing algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_starting_point_sann(beta_expe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_starting_point_sann_+3A_beta_expe">beta_expe</code></td>
<td>
<p>a numerical vector, the expectation of the coefficient
function posterior sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with 3 columns : &quot;m&quot;, &quot;l&quot; and &quot;b&quot;. The two first
columns define the begin and the end of the intervals and the third
gives the mean values of each interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(res_bliss1)
mystart&lt;-compute_starting_point_sann(apply(res_bliss1$beta_sample[[1]],2,mean))
</code></pre>

<hr>
<h2 id='corr_matrix'>corr_matrix</h2><span id='topic+corr_matrix'></span>

<h3>Description</h3>

<p>Compute an autocorrelation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_matrix(diagonal, ksi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_matrix_+3A_diagonal">diagonal</code></td>
<td>
<p>a numerical vector corresponding to the diagonal.</p>
</td></tr>
<tr><td><code id="corr_matrix_+3A_ksi">ksi</code></td>
<td>
<p>a numerical value, related to the correlation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a symmetric matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Test 1 : weak autocorrelation
ksi     &lt;- 1
diagVar &lt;- abs(rnorm(100,50,5))
Sigma   &lt;- corr_matrix(diagVar,ksi^2)
persp(Sigma)
### Test 2 : strong autocorrelation
ksi     &lt;- 0.2
diagVar &lt;- abs(rnorm(100,50,5))
Sigma   &lt;- corr_matrix(diagVar,ksi^2)
persp(Sigma)
</code></pre>

<hr>
<h2 id='data1'>a list of data</h2><span id='topic+data1'></span>

<h3>Description</h3>

<p>A data object for bliss model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data1
</code></pre>


<h3>Format</h3>

<p>a list of data
</p>

<dl>
<dt>Q</dt><dd><p>the number of functional covariates</p>
</dd>
<dt>y</dt><dd><p>y coordinate</p>
</dd>
<dt>x</dt><dd><p>x coordinate</p>
</dd>
<dt>betas</dt><dd><p>the coefficient function used to generate the data</p>
</dd>
<dt>grids</dt><dd><p>the grid of the observation times</p>
</dd>
</dl>


<hr>
<h2 id='determine_intervals'>determine_intervals</h2><span id='topic+determine_intervals'></span>

<h3>Description</h3>

<p>Determine for which intervals a function is nonnull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine_intervals(beta_fct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determine_intervals_+3A_beta_fct">beta_fct</code></td>
<td>
<p>a numerical vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with 3 columns : &quot;begin&quot;, &quot;end&quot; and &quot;value&quot;. The two first
columns define the begin and the end of the intervals and the third
gives the mean values of each interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data1)
data(param1)
# result of res_bliss1&lt;-fit_Bliss(data=data1,param=param1)
data(res_bliss1)
intervals &lt;- determine_intervals(res_bliss1$Bliss_estimate[[1]])
plot(data1$grids[[1]],res_bliss1$Bliss_estimate[[1]],type="s")
for(k in 1:nrow(intervals)){
   segments(data1$grids[[1]][intervals[k,1]],intervals[k,3],
           data1$grids[[1]][intervals[k,2]],intervals[k,3],col=2,lwd=4)
}
</code></pre>

<hr>
<h2 id='dposterior'>dposterior</h2><span id='topic+dposterior'></span>

<h3>Description</h3>

<p>Compute (non-normalized) posterior densities for a given parameter set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dposterior(posterior_sample, data, theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dposterior_+3A_posterior_sample">posterior_sample</code></td>
<td>
<p>a list given by the <code>Bliss_Gibbs_Sampler</code> function.</p>
</td></tr>
<tr><td><code id="dposterior_+3A_data">data</code></td>
<td>
<p>a list containing
</p>

<dl>
<dt>y</dt><dd><p>a numerical vector, the outcomes.</p>
</dd>
<dt>x</dt><dd><p>a list of matrices, the qth matrix contains the observations of the
qth functional covariate at time points given by <code>grids</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dposterior_+3A_theta">theta</code></td>
<td>
<p>a matrix or a vector which contains the parameter set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>theta</code> is NULL, the posterior density is computed from
the MCMC sample given in the <code>posterior_sample</code>.
</p>


<h3>Value</h3>

<p>Return the (log) posterior density, the (log) likelihood and the
(log) prior density for the given parameter set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data1)
data(param1)
# result of res_bliss1&lt;-fit_Bliss(data=data1,param=param1)
data(res_bliss1)
# Compute the posterior density of the MCMC sample :
res_poste &lt;- dposterior(res_bliss1$posterior_sample,data1)
</code></pre>

<hr>
<h2 id='fit_Bliss'>fit_Bliss</h2><span id='topic+fit_Bliss'></span>

<h3>Description</h3>

<p>Fit the Bayesian Functional
Linear Regression model (with Q functional covariates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_Bliss(
  data,
  param,
  compute_density = TRUE,
  sann = TRUE,
  support_estimate = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_Bliss_+3A_data">data</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>Q</dt><dd><p>an integer, the number of functional covariates.</p>
</dd>
<dt>y</dt><dd><p>a numerical vector, the outcomes.</p>
</dd>
<dt>x</dt><dd><p>a list of matrices, the qth matrix contains the observations of the
qth functional covariate at time points given by <code>grids</code>.</p>
</dd>
<dt>grids</dt><dd><p>a list of numerical vectors, the qth vector is the grid of
time points for the qth functional covariate.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fit_Bliss_+3A_param">param</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>iter</dt><dd><p>an integer, the number of iterations of the Gibbs sampler algorithm.</p>
</dd>
<dt>K</dt><dd><p>a vector of integers, corresponding to the numbers of intervals for
each covariate.</p>
</dd>
<dt>basis</dt><dd><p>a character vector (optional). The possible values are &quot;uniform&quot; (default),
&quot;epanechnikov&quot;, &quot;gauss&quot; and &quot;triangular&quot; which correspond to
different basis functions to expand the coefficient function and the
functional covariates</p>
</dd>
<dt>burnin</dt><dd><p>an integer (optional), the number of iteration to drop from the
posterior sample.</p>
</dd>
<dt>iter_sann</dt><dd><p>an integer (optional), the number of iteration of the Simulated
Annealing algorithm.</p>
</dd>
<dt>k_max</dt><dd><p>an integer (optional), the maximal number of intervals for the
Simulated Annealing algorithm.</p>
</dd>
<dt>l_max</dt><dd><p>an integer (optional), the maximal interval length for the
Simulated Annealing algorithm.</p>
</dd>
<dt>lims_kde</dt><dd><p>an integer (optional), correspond to the <code>lims</code> option
of the <code>kde2d</code> funtion.</p>
</dd>
<dt>n_chains</dt><dd><p>an integer (optional) which corresponds to the number of
Gibbs sampler runs.</p>
</dd>
<dt>new_grids</dt><dd><p>a list of Q vectors (optional) to compute beta samples on
different grids.</p>
</dd>
<dt>Temp_init</dt><dd><p>a nonnegative value (optional), the initial temperature for
the cooling function of the Simulated Annealing algorithm.</p>
</dd>
<dt>thin</dt><dd><p>an integer (optional) to thin the posterior sample.</p>
</dd>
<dt>times_sann</dt><dd><p>an integer (optional), the number of times the algorithm
will be executed</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fit_Bliss_+3A_compute_density">compute_density</code></td>
<td>
<p>a logical value. If TRUE, the posterior density
of the coefficient function is computed. (optional)</p>
</td></tr>
<tr><td><code id="fit_Bliss_+3A_sann">sann</code></td>
<td>
<p>a logical value. If TRUE, the Bliss estimate is
computed with a Simulated Annealing Algorithm. (optional)</p>
</td></tr>
<tr><td><code id="fit_Bliss_+3A_support_estimate">support_estimate</code></td>
<td>
<p>a logical value. If TRUE, the estimate of the
coefficient function support is computed. (optional)</p>
</td></tr>
<tr><td><code id="fit_Bliss_+3A_verbose">verbose</code></td>
<td>
<p>write stuff if TRUE (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list containing:
</p>

<dl>
<dt>alpha</dt><dd><p>a list of Q numerical vector. Each vector is the function
alpha(t) associated to a functional covariate. For each t, alpha(t)
is the posterior probabilities of the event &quot;the support covers t&quot;.</p>
</dd>
<dt>beta_posterior_density</dt><dd><p>a list of Q items. Each item contains a list
containing information to plot the posterior density of the
coefficient function with the <code>image</code> function.
</p>

<dl>
<dt><code>grid_t</code></dt><dd><p>a numerical vector: the x-axis.</p>
</dd>
<dt><code>grid_beta_t</code></dt><dd><p>a numerical vector: the y-axis.</p>
</dd>
<dt><code>density</code></dt><dd><p>a matrix: the z values.</p>
</dd>
<dt><code>new_beta_sample</code></dt><dd><p>a matrix: beta sample used to compute
the posterior densities.</p>
</dd>
</dl>

</dd>
<dt>beta_sample</dt><dd><p>a list of Q matrices. The qth matrix is a posterior
sample of the qth functional covariates.</p>
</dd>
<dt>Bliss_estimate</dt><dd><p>a list of numerical vectors corresponding to the
Bliss estimates of each functional covariates.</p>
</dd>
<dt>chains</dt><dd><p>a list of <code>posterior_sample</code>. <code>chains</code> is <code>NULL</code> if
<code>n_chains</code>=1.</p>
</dd>
<dt>chains_info</dt><dd><p>a list for each chain providing: a mu estimate, a sigma_sq estimate,
the Smooth estimate of the coefficient function and the autocorrelation of the
Markov Chain.</p>
</dd>
<dt>data</dt><dd><p>a list containing the data.</p>
</dd>
<dt>posterior_sample</dt><dd><p>a list of information about the posterior sample:
the trace matrix of the Gibbs sampler, a list of Gibbs sampler parameters
and the posterior densities.</p>
</dd>
<dt>support_estimate</dt><dd><p>a list of support estimates of each functional covariate.</p>
</dd>
<dt>support_estimate_fct</dt><dd><p>another version of the support estimates.</p>
</dd>
<dt>trace_sann</dt><dd><p>a list of Q matrices which are the trace of the
Simulated Annealing algorithm.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># see the vignette BlissIntro.
</code></pre>

<hr>
<h2 id='image_Bliss'>image_Bliss</h2><span id='topic+image_Bliss'></span>

<h3>Description</h3>

<p>Plot an approximation of the posterior density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_Bliss(beta_posterior_density, param = list(), q = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_Bliss_+3A_beta_posterior_density">beta_posterior_density</code></td>
<td>
<p>a list. The result of the function
<code>compute_beta_posterior_density</code>.</p>
</td></tr>
<tr><td><code id="image_Bliss_+3A_param">param</code></td>
<td>
<p>a list containing: (optional)
</p>

<dl>
<dt>cols</dt><dd><p>a vector of colors for the function image.</p>
</dd>
<dt>main</dt><dd><p>an overall title for the plot.</p>
</dd>
<dt>xlab</dt><dd><p>a title for the x axis.</p>
</dd>
<dt>ylab</dt><dd><p>a title for the y axis.</p>
</dd>
<dt>ylim</dt><dd><p>a numeric vectors of length 2, giving the y coordinate range.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="image_Bliss_+3A_q">q</code></td>
<td>
<p>an integer (optional), the index of the functional covariate to plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(RColorBrewer)
data(data1)
data(param1)
data(res_bliss1)
param1$cols &lt;- colorRampPalette(brewer.pal(9,"Reds"))(1e2)
image_Bliss(res_bliss1$beta_posterior_density,param1,q=1)
lines(res_bliss1$data$grids[[1]],res_bliss1$Bliss_estimate[[1]],type="s",lwd=2)
lines(res_bliss1$data$grids[[1]],res_bliss1$data$betas[[1]],col=3,lwd=2,type="s")

# ---- not run
param1$cols &lt;- colorRampPalette(brewer.pal(9,"YlOrRd"))(1e2)
image_Bliss(res_bliss1$beta_posterior_density,param1,q=1)
lines(res_bliss1$data$grids[[1]],res_bliss1$Bliss_estimate[[1]],type="s",lwd=2)
lines(res_bliss1$data$grids[[1]],res_bliss1$data$betas[[1]],col=3,lwd=2,type="s")

param1$cols &lt;- rev(heat.colors(12))
param1$col_scale &lt;- "quantile"
image_Bliss(res_bliss1$beta_posterior_density,param1,q=1)
lines(res_bliss1$data$grids[[1]],res_bliss1$Bliss_estimate[[1]],type="s",lwd=2)
lines(res_bliss1$data$grids[[1]],res_bliss1$data$betas[[1]],col=3,lwd=2,type="s")

param1$cols &lt;- rev(terrain.colors(12))
image_Bliss(res_bliss1$beta_posterior_density,param1,q=1)
lines(res_bliss1$data$grids[[1]],res_bliss1$Bliss_estimate[[1]],type="s",lwd=2)
lines(res_bliss1$data$grids[[1]],res_bliss1$data$betas[[1]],col=2,lwd=2,type="s")

param1$cols &lt;- rev(topo.colors(12))
image_Bliss(res_bliss1$beta_posterior_density,param1,q=1)
lines(res_bliss1$data$grids[[1]],res_bliss1$Bliss_estimate[[1]],type="s",lwd=2)
lines(res_bliss1$data$grids[[1]],res_bliss1$data$betas[[1]],col=2,lwd=2,type="s")
</code></pre>

<hr>
<h2 id='integrate_trapeze'>integrate_trapeze</h2><span id='topic+integrate_trapeze'></span>

<h3>Description</h3>

<p>Trapezoidal rule to approximate an integral.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate_trapeze(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrate_trapeze_+3A_x">x</code></td>
<td>
<p>a numerical vector, the discretization of the domain.</p>
</td></tr>
<tr><td><code id="integrate_trapeze_+3A_y">y</code></td>
<td>
<p>a numerical value, the discretization of the function to integrate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical value, the approximation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0,1,le=1e2)
integrate_trapeze(x,x^2)

integrate_trapeze(data1$grids[[1]],t(data1$x[[1]]))
</code></pre>

<hr>
<h2 id='interpretation_plot'>interpretation_plot</h2><span id='topic+interpretation_plot'></span>

<h3>Description</h3>

<p>Provide a graphical representation of the functional data
with a focus on the detected periods with the Bliss method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpretation_plot(data, Bliss_estimate, q = 1, centered = FALSE, cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpretation_plot_+3A_data">data</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>y</dt><dd><p>a numerical vector, the outcomes.</p>
</dd>
<dt>x</dt><dd><p>a list of matrices, the qth matrix contains the observations of the
qth functional covariate at time points given by <code>grids</code>.</p>
</dd>
<dt>grids</dt><dd><p>a list of numerical vectors, the qth vector is the grid of
time points for the qth functional covariate.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="interpretation_plot_+3A_bliss_estimate">Bliss_estimate</code></td>
<td>
<p>a numerical vector, the Bliss estimate.</p>
</td></tr>
<tr><td><code id="interpretation_plot_+3A_q">q</code></td>
<td>
<p>an integer (optional), the index of the functional covariate to plot.</p>
</td></tr>
<tr><td><code id="interpretation_plot_+3A_centered">centered</code></td>
<td>
<p>a logical value (optional), If TRUE, the functional data are centered.</p>
</td></tr>
<tr><td><code id="interpretation_plot_+3A_cols">cols</code></td>
<td>
<p>a numerical vector of colours (optional).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(data1)
data(param1)
# result of res_bliss1 &lt;- fit_Bliss(data=data1,param=param1,verbose=TRUE)
data(res_bliss1)
interpretation_plot(data=data1,Bliss_estimate=res_bliss1$Bliss_estimate,q=1)
interpretation_plot(data=data1,Bliss_estimate=res_bliss1$Bliss_estimate,q=1,centered=TRUE)
</code></pre>

<hr>
<h2 id='lines_bliss'>lines_bliss</h2><span id='topic+lines_bliss'></span>

<h3>Description</h3>

<p>A suitable representation of the Bliss estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lines_bliss(x, y, connect = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines_bliss_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot.</p>
</td></tr>
<tr><td><code id="lines_bliss_+3A_y">y</code></td>
<td>
<p>the y coordinates of points in the plot.</p>
</td></tr>
<tr><td><code id="lines_bliss_+3A_connect">connect</code></td>
<td>
<p>a logical value (optional), to handle discontinuous function.
If <code>connect</code> is TRUE, the plot is one line. Otherwise, several
lines are used.</p>
</td></tr>
<tr><td><code id="lines_bliss_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters
(see <code>par</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>### Plot the BLiss estimate on a suitable grid

data(data1)
data(param1)
# res_bliss1 &lt;- fit_Bliss(data=data1,param=param1,verbose=TRUE)

data(res_bliss1)
### Plot the BLiss estimate on a suitable grid
plot_bliss(res_bliss1$data$grids[[1]],
           res_bliss1$Bliss_estimate[[1]],lwd=2,bound=FALSE)
lines_bliss(res_bliss1$data$grids[[1]],
            res_bliss1$Smooth_estimate[[1]],lty=2)
</code></pre>

<hr>
<h2 id='param1'>A list of param for bliss model</h2><span id='topic+param1'></span>

<h3>Description</h3>

<p>A list of param for bliss model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param1
</code></pre>


<h3>Format</h3>

<p>a list of param for bliss model
</p>

<dl>
<dt>Q</dt><dd><p>the number of functional covariates</p>
</dd>
<dt>n</dt><dd><p>the sample size</p>
</dd>
<dt>p</dt><dd><p>the number of observation times</p>
</dd>
<dt>beta_shapes</dt><dd><p>the shapes of the coefficient functions</p>
</dd>
<dt>grids_lim</dt><dd><p>the range of the observation times</p>
</dd>
<dt>grids</dt><dd><p>the grids of the observation times</p>
</dd>
<dt>K</dt><dd><p>the number of intervals for the coefficient function</p>
</dd>
</dl>


<hr>
<h2 id='pdexp'>pdexp</h2><span id='topic+pdexp'></span>

<h3>Description</h3>

<p>Probability function of a discretized Exponentiel distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdexp(a, l_values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdexp_+3A_a">a</code></td>
<td>
<p>a positive value, the mean of the Exponential prior.</p>
</td></tr>
<tr><td><code id="pdexp_+3A_l_values">l_values</code></td>
<td>
<p>a numerical value, the discrete support of the parameter l.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector, which is the prability function on <code>l_values</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pdexp(10,seq(0,1,1))

x &lt;- seq(0,10,le=1e3)
plot(x,dexp(x,0.5),lty=2,type="l")
lines(pdexp(0.5,1:10),type="p")
</code></pre>

<hr>
<h2 id='plot_bliss'>plot_bliss</h2><span id='topic+plot_bliss'></span>

<h3>Description</h3>

<p>A suitable representation of the Bliss estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_bliss(x, y, connect = FALSE, xlab = "", ylab = "", ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_bliss_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot.</p>
</td></tr>
<tr><td><code id="plot_bliss_+3A_y">y</code></td>
<td>
<p>the y coordinates of points in the plot.</p>
</td></tr>
<tr><td><code id="plot_bliss_+3A_connect">connect</code></td>
<td>
<p>a logical value (optional), to handle discontinuous function.
If <code>connect</code> is TRUE, the plot is one line. Otherwise, several
lines are used.</p>
</td></tr>
<tr><td><code id="plot_bliss_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis.</p>
</td></tr>
<tr><td><code id="plot_bliss_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot_bliss_+3A_ylim">ylim</code></td>
<td>
<p>a numeric vectors of length 2, giving the y coordinate range.</p>
</td></tr>
<tr><td><code id="plot_bliss_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters
(see <code>par</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data1)
data(param1)
# res_bliss1 &lt;- fit_Bliss(data=data1,param=param1,verbose=TRUE)

data(res_bliss1)
### Plot the BLiss estimate on a suitable grid
plot_bliss(res_bliss1$data$grids[[1]],
           res_bliss1$Bliss_estimate[[1]],lwd=2,bound=FALSE)
</code></pre>

<hr>
<h2 id='printbliss'>Print a bliss Object</h2><span id='topic+printbliss'></span>

<h3>Description</h3>

<p>Print a bliss Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printbliss(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printbliss_+3A_x">x</code></td>
<td>
<p>input bliss Object</p>
</td></tr>
<tr><td><code id="printbliss_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># See fit_Bliss() function
</code></pre>

<hr>
<h2 id='res_bliss1'>A result of the BliSS method</h2><span id='topic+res_bliss1'></span>

<h3>Description</h3>

<p>A result of the BliSS method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res_bliss1
</code></pre>


<h3>Format</h3>

<p>a Bliss object (list)
</p>

<dl>
<dt>alpha</dt><dd><p>a list of Q numerical vector. Each vector is the function
alpha(t) associated to a functional covariate. For each t, alpha(t)
is the posterior probabilities of the event &quot;the support covers t&quot;.</p>
</dd>
<dt>beta_posterior_density</dt><dd><p>a list of Q items. Each item contains a list
containing information to plot the posterior density of the
coefficient function with the <code>image</code> function.
</p>

<dl>
<dt><code>grid_t</code></dt><dd><p>a numerical vector: the x-axis.</p>
</dd>
<dt><code>grid_beta_t</code></dt><dd><p>a numerical vector: the y-axis.</p>
</dd>
<dt><code>density</code></dt><dd><p>a matrix: the z values.</p>
</dd>
<dt><code>new_beta_sample</code></dt><dd><p>a matrix: beta sample used to compute
the posterior densities.</p>
</dd>
</dl>
</dd>
<dt>beta_sample</dt><dd><p>a list of Q matrices. The qth matrix is a posterior
sample of the qth functional covariates.</p>
</dd>
<dt>Bliss_estimate</dt><dd><p>a list of numerical vectors corresponding to the
Bliss estimates of each functional covariates.</p>
</dd>
<dt>chains_info</dt><dd><p>a list containing (for each chain): a mu estimate, a sigma_sq estimate,
the Smooth estimate of the coefficient function and the autocorrelation of the
Markov Chain.</p>
</dd>
<dt>data</dt><dd><p>see the description of the object <code>data1</code>.</p>
</dd>
<dt>posterior_sample</dt><dd><p>a list containing (for each chain) the result of the
<code>Bliss_Gibbs_Sampler</code> function.</p>
</dd>
<dt>Smooth_estimate</dt><dd><p>a list containing the Smooth estimates of the
coefficient functions.</p>
</dd>
<dt>support_estimate</dt><dd><p>a list containing the estimations of the support.</p>
</dd>
<dt>support_estimate_fct</dt><dd><p>a list containing the estimation of the support.</p>
</dd>
<dt>trace_sann</dt><dd><p>a list containing (for each chain) the trace of the
Simulated Annealing algorithm.</p>
</dd>
</dl>


<hr>
<h2 id='sigmoid'>sigmoid</h2><span id='topic+sigmoid'></span>

<h3>Description</h3>

<p>Compute a sigmoid function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmoid(x, asym = 1, v = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmoid_+3A_x">x</code></td>
<td>
<p>a numerical vector, time points.</p>
</td></tr>
<tr><td><code id="sigmoid_+3A_asym">asym</code></td>
<td>
<p>a numerical value (optional), the asymptote of the sigmoid function.</p>
</td></tr>
<tr><td><code id="sigmoid_+3A_v">v</code></td>
<td>
<p>a numerical value (optional), related to the slope at the origin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see the function <code><a href="#topic+sim_x">sim_x</a></code>.
</p>


<h3>Value</h3>

<p>a numerical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Test 1 :
x &lt;- seq(-7,7,0.1)
y &lt;- sigmoid(x)
plot(x,y,type="l",main="Sigmoid function")
## Test 2 :
x  &lt;- seq(-7,7,0.1)
y  &lt;- sigmoid(x)
y2 &lt;- sigmoid(x,asym=0.5)
y3 &lt;- sigmoid(x,v   =  5)
plot(x,y,type="l",main="Other sigmoid functions")
lines(x,y2,col=2)
lines(x,y3,col=3)
</code></pre>

<hr>
<h2 id='sigmoid_sharp'>sigmoid_sharp</h2><span id='topic+sigmoid_sharp'></span>

<h3>Description</h3>

<p>Compute a sharp sigmoid function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmoid_sharp(x, loc = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmoid_sharp_+3A_x">x</code></td>
<td>
<p>a numerical vector, time points.</p>
</td></tr>
<tr><td><code id="sigmoid_sharp_+3A_loc">loc</code></td>
<td>
<p>a numerical value (optional), the time of the sharp.</p>
</td></tr>
<tr><td><code id="sigmoid_sharp_+3A_...">...</code></td>
<td>
<p>Arguments (optional) for the function sigmoid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see the function <code><a href="#topic+sim_x">sim_x</a></code>.
</p>


<h3>Value</h3>

<p>a numerical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Test 1 :
x &lt;- seq(-7,7,0.1)
y &lt;- sigmoid_sharp(x)
plot(x,y,type="l",main="Sharp sigmoid")
## Test 2 :
x  &lt;- seq(-7,7,0.1)
y  &lt;- sigmoid_sharp(x,loc=3)
y2 &lt;- sigmoid_sharp(x,loc=3,asym=0.5)
y3 &lt;- sigmoid_sharp(x,loc=3,v   =  5)
plot(x,y,type="l",main="Other sharp sigmoids")
lines(x,y2,col=2)
lines(x,y3,col=3)
</code></pre>

<hr>
<h2 id='sim'>sim</h2><span id='topic+sim'></span>

<h3>Description</h3>

<p>Simulate a dataset for the Function Linear Regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(param, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_+3A_param">param</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>beta_shapes</dt><dd><p>a character vector. The qth item indicates the shape of
the coefficient function associated to the qth functional covariate.</p>
</dd>
<dt>n</dt><dd><p>an integer, the sample size.</p>
</dd>
<dt>p</dt><dd><p>a vector of integers, the qth component is the number of
times for the qth covariate.</p>
</dd>
<dt>Q</dt><dd><p>an integer, the number of functional covariates.</p>
</dd>
<dt>autocorr_diag</dt><dd><p>a list of numerical vectors (optional), the qth vector is the
diagonal of the autocorrelation matrix of the qth functional
covariate.</p>
</dd>
<dt>autocorr_spread</dt><dd><p>a vector of numerical values (optional) which are related to the
autocorrelation of the functional covariates.</p>
</dd>
<dt>grids</dt><dd><p>a list of numerical vectors (optional), the qth vector is the grid
of time points for the qth functional covariate.</p>
</dd>
<dt>grids_lim</dt><dd><p>a list of numerical vectors  (optional), the qth item is the lower
and upper boundaries of the domain for the qth functional covariate.</p>
</dd>
<dt>link</dt><dd><p>a function (optional) to simulate data from the Generalized Functional
Linear Regression model.</p>
</dd>
<dt>mu</dt><dd><p>a numerical value (optional), the 'true' intercept of the model.</p>
</dd>
<dt>r</dt><dd><p>a nonnegative value (optional), the signal to noise ratio.</p>
</dd>
<dt>x_shapes</dt><dd><p>a character vector (optional). The qth item indicates the shape of the
functional covariate observations.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sim_+3A_verbose">verbose</code></td>
<td>
<p>write stuff if TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>

<dl>
<dt>Q</dt><dd><p>an integer, the number of functional covariates.</p>
</dd>
<dt>y</dt><dd><p>a numerical vector, the outcome observations.</p>
</dd>
<dt>x</dt><dd><p>a list of matrices, the qth matrix contains the observations of the
qth functional covariate at time points given by <code>grids</code>.</p>
</dd>
<dt>grids</dt><dd><p>a list of numerical vectors, the qth vector is the grid of
time points for the qth functional covariate.</p>
</dd>
<dt>betas</dt><dd><p>a list of numerical vectors, the qth vector is the 'true' coefficient
function associated to the qth covariate on a grid of time points
given with <code>grids</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(RColorBrewer)
param &lt;- list(Q=2,n=25,p=c(50,50),grids_lim=list(c(0,1),c(-1,2)))
data &lt;- sim(param)
data$y
cols &lt;- colorRampPalette(brewer.pal(9,"YlOrRd"))(10)
q=2
matplot(data$grids[[q]],t(data$x[[q]]),type="l",lty=1,col=cols)
plot(data$grids[[q]],data$betas[[q]],type="l")
abline(h=0,lty=2,col="gray")
</code></pre>

<hr>
<h2 id='sim_x'>sim_x</h2><span id='topic+sim_x'></span>

<h3>Description</h3>

<p>Simulate functional covariate observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_x(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_x_+3A_param">param</code></td>
<td>
<p>a list containing :
</p>

<dl>
<dt>grid</dt><dd><p>a numerical vector, the observation times.</p>
</dd>
<dt>n</dt><dd><p>an integer, the sample size.</p>
</dd>
<dt>p</dt><dd><p>an integer, the number of observation times.</p>
</dd>
<dt>diagVar</dt><dd><p>a numerical vector (optional), the diagonal of the autocorrelation matrix.</p>
</dd>
<dt>dim</dt><dd><p>a numerical value (optional), the dimension of the Fourier basis,
if &quot;shape&quot; is &quot;Fourier&quot; or &quot;Fourier2&quot;. </p>
</dd>
<dt>ksi</dt><dd><p>a numerical value (optional) related to the observations correlation.</p>
</dd>
<dt>x_shape</dt><dd><p>a character vector (optional), the shape of the observations. </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Several shape are available for the observations: &quot;Fourier&quot;,
&quot;Fourier2&quot;, &quot;random_walk&quot;, &quot;random_sharp&quot;, &quot;uniform&quot;, &quot;gaussian&quot;,
&quot;mvgauss&quot;, &quot;mvgauss_different_scale&quot;, &quot;mvgauss_different_scale2&quot;,
&quot;mvgauss_different_scale3&quot; and &quot;mvgauss_different_scale4&quot;.
</p>


<h3>Value</h3>

<p>a matrix which contains the functional covariate observations at time
points given by <code>grid</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RColorBrewer)
### Fourier
param &lt;- list(n=15,p=100,grid=seq(0,1,length=100),x_shape="Fourier")
x &lt;- sim_x(param)
cols &lt;- colorRampPalette(brewer.pal(9,"YlOrRd"))(15)
matplot(param$grid,t(x),type="l",lty=1,col=cols)
### Fourier2
param &lt;- list(n=15,p=100,grid=seq(0,1,length=100),x_type="Fourier2")
x &lt;- sim_x(param)
cols &lt;- colorRampPalette(brewer.pal(9,"YlOrRd"))(15)
matplot(param$grid,t(x),type="l",lty=1,col=cols)
### random_walk
param &lt;- list(n=15,p=100,grid=seq(0,1,length=100),x_type="random_walk")
x &lt;- sim_x(param)
cols &lt;- colorRampPalette(brewer.pal(9,"YlOrRd"))(15)
matplot(param$grid,t(x),type="l",lty=1,col=cols)
### random_sharp
param &lt;- list(n=15,p=100,grid=seq(0,1,length=100),x_type="random_sharp")
x &lt;- sim_x(param)
cols &lt;- colorRampPalette(brewer.pal(9,"YlOrRd"))(15)
matplot(param$grid,t(x),type="l",lty=1,col=cols)
### uniform
param &lt;- list(n=15,p=100,grid=seq(0,1,length=100),x_type="uniform")
x &lt;- sim_x(param)
cols &lt;- colorRampPalette(brewer.pal(9,"YlOrRd"))(15)
matplot(param$grid,t(x),type="l",lty=1,col=cols)
### gaussian
param &lt;- list(n=15,p=100,grid=seq(0,1,length=100),x_type="gaussian")
x &lt;- sim_x(param)
cols &lt;- colorRampPalette(brewer.pal(9,"YlOrRd"))(15)
matplot(param$grid,t(x),type="l",lty=1,col=cols)
### mvgauss
param &lt;- list(n=15,p=100,grid=seq(0,1,length=100),x_type="mvgauss")
x &lt;- sim_x(param)
cols &lt;- colorRampPalette(brewer.pal(9,"YlOrRd"))(15)
matplot(param$grid,t(x),type="l",lty=1,col=cols)
</code></pre>

<hr>
<h2 id='support_estimation'>support_estimation</h2><span id='topic+support_estimation'></span>

<h3>Description</h3>

<p>Compute the support estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>support_estimation(beta_sample_q, gamma = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support_estimation_+3A_beta_sample_q">beta_sample_q</code></td>
<td>
<p>a matrix. Each row is a coefficient function computed from the
posterior sample.</p>
</td></tr>
<tr><td><code id="support_estimation_+3A_gamma">gamma</code></td>
<td>
<p>a numeric value, the default value is <code>0.5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>

<dl>
<dt>alpha</dt><dd><p>a numerical vector. The approximated posterior probabilities
that the coefficient function support covers <code>t</code> for each time
points <code>t</code>.</p>
</dd>
<dt>estimate</dt><dd><p>a numerical vector, the support estimate.</p>
</dd>
<dt>estimate_fct</dt><dd><p>a numerical vector, another version of the support
estimate.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data1)
data(param1)
# result of res_bliss1&lt;-fit_Bliss(data=data1,param=param1)
data(res_bliss1)
res_support &lt;- support_estimation(res_bliss1$beta_sample[[1]])

### The estimate
res_support$estimate
### Plot the result
grid &lt;- res_bliss1$data$grids[[1]]
plot(grid,res_support$alpha,ylim=c(0,1),type="l",xlab="",ylab="")
for(k in 1:nrow(res_support$estimate)){
    segments(grid[res_support$estimate[k,1]],0.5,
             grid[res_support$estimate[k,2]],0.5,lwd=2,col=2)
    points(grid[res_support$estimate[k,1]],0.5,pch="|",lwd=2,col=2)
    points(grid[res_support$estimate[k,2]],0.5,pch="|",lwd=2,col=2)
}
abline(h=0.5,col=2,lty=2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
