<!DOCTYPE html><html><head><title>Help for package profoc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {profoc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#profoc-package'>
<p>Package Info</p></a></li>
<li><a href='#autoplot.batch'><p>Autoplot method for batch models</p></a></li>
<li><a href='#autoplot.online'><p>Autoplot method for online models</p></a></li>
<li><a href='#batch'><p>Probabilistic Forecast Combination - Batch</p></a></li>
<li><a href='#conline'><p>Create an conline Object from the conline C++ Class</p></a></li>
<li><a href='#init_experts_list'><p>Create experts list to be used in conline class</p></a></li>
<li><a href='#make_basis_mats'><p>Create a List of Basis Matrices</p></a></li>
<li><a href='#make_hat_mats'><p>Create a List of Hat Matrices</p></a></li>
<li><a href='#make_knots'><p>Create a vector of knots for splines</p></a></li>
<li><a href='#online'><p>Probabilistic Forecast Combination - Online</p></a></li>
<li><a href='#oracle'><p>Probabilistic Forecast Combination - Oracle</p></a></li>
<li><a href='#penalty'><p>B-Spline penalty</p></a></li>
<li><a href='#plot.batch'><p>Plot method for batch models</p></a></li>
<li><a href='#plot.online'><p>Plot method for online models</p></a></li>
<li><a href='#post_process_model'><p>Post Process Data from conline Class</p></a></li>
<li><a href='#predict.online'><p>Predict method for online models</p></a></li>
<li><a href='#print.batch'><p>Print method for batch models</p></a></li>
<li><a href='#print.online'><p>Print method for online models</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#splines2_basis'><p>Create B-Spline basis</p></a></li>
<li><a href='#summary.online'><p>Summary method for online models</p></a></li>
<li><a href='#tidy.online.experts_loss'><p>Tidy the Experts' losses of an Online object</p></a></li>
<li><a href='#tidy.online.forecaster_loss'><p>Tidy the Experts' losses of an Online object</p></a></li>
<li><a href='#tidy.online.predictions'><p>Tidy the Predictions of an Online object</p></a></li>
<li><a href='#tidy.online.weights'><p>Tidy the Weights of an Online object</p></a></li>
<li><a href='#update.online'><p>Update method for online models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Probabilistic Forecast Combination Using CRPS Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-25</td>
</tr>
<tr>
<td>Description:</td>
<td>Combine probabilistic forecasts using CRPS learning algorithms proposed in Berrisch, Ziel (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2102.00968">doi:10.48550/arXiv.2102.00968</a>&gt; &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2021.11.008">doi:10.1016/j.jeconom.2021.11.008</a>&gt;. The package implements multiple online learning algorithms like Bernstein online aggregation; see Wintenberger (2014) &lt;<a href="https://doi.org/10.48550/arXiv.1404.1356">doi:10.48550/arXiv.1404.1356</a>&gt;. Quantile regression is also implemented for comparison purposes. Model parameters can be tuned automatically with respect to the loss of the forecast combination. Methods like predict(), update(), plot() and print() are available for convenience. This package utilizes the optim C++ library for numeric optimization <a href="https://github.com/kthohr/optim">https://github.com/kthohr/optim</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5), Matrix, abind, methods, lifecycle, generics,
tibble, ggplot2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.10.7.5.0), RcppProgress, splines2
(&ge; 0.4.4), rcpptimer (&ge; 1.1.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://profoc.berrisch.biz">https://profoc.berrisch.biz</a>, <a href="https://github.com/BerriJ/profoc">https://github.com/BerriJ/profoc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/BerriJ/profoc/issues">https://github.com/BerriJ/profoc/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), gamlss.dist, knitr, rmarkdown, dplyr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-25 11:08:56 UTC; vscode</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan Berrisch <a href="https://orcid.org/0000-0002-4944-9074"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Florian Ziel <a href="https://orcid.org/0000-0002-2974-2660"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan Berrisch &lt;Jonathan@Berrisch.biz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-25 11:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='profoc-package'>
Package Info
</h2><span id='topic+profoc-package'></span>

<h3>Description</h3>

<p>Use multiple online-aggregation algorithms to combine probabilistic forecasts using CRPS Learning as described in Berrisch, Ziel: &quot;CRPS Learning&quot;, 2021. The primary function of this package is called <code>online</code>.
</p>
<p><a href="https://doi.org/10.1016/j.jeconom.2021.11.008">doi:10.1016/j.jeconom.2021.11.008</a>
</p>


<h3>Details</h3>


<p>Index of help topics:
</p>
<pre>
autoplot.batch          Autoplot method for batch models
autoplot.online         Autoplot method for online models
batch                   Probabilistic Forecast Combination - Batch
conline                 Create an conline Object from the conline C++
                        Class
init_experts_list       Create experts list to be used in conline class
make_basis_mats         Create a List of Basis Matrices
make_hat_mats           Create a List of Hat Matrices
make_knots              Create a vector of knots for splines
online                  Probabilistic Forecast Combination - Online
oracle                  Probabilistic Forecast Combination - Oracle
penalty                 B-Spline penalty
plot.batch              Plot method for batch models
plot.online             Plot method for online models
post_process_model      Post Process Data from conline Class
predict.online          Predict method for online models
print.batch             Print method for batch models
print.online            Print method for online models
profoc-package          Package Info
splines2_basis          Create B-Spline basis
summary.online          Summary method for online models
tidy.online.experts_loss
                        Tidy the Experts' losses of an Online object
tidy.online.forecaster_loss
                        Tidy the Experts' losses of an Online object
tidy.online.predictions
                        Tidy the Predictions of an Online object
tidy.online.weights     Tidy the Weights of an Online object
update.online           Update method for online models
</pre>


<h3>Author(s)</h3>

<p>Maintainer: Jonathan Berrisch <a href="mailto:Jonathan@Berrisch.biz">mailto:Jonathan@Berrisch.biz</a>
</p>
<p>Co-Author: Florian Ziel
</p>


<h3>References</h3>

<p>Berrisch, Ziel: &quot;CRPS Learning&quot;, 2021
</p>
<p><a href="https://doi.org/10.1016/j.jeconom.2021.11.008">doi:10.1016/j.jeconom.2021.11.008</a>
</p>
<p><a href="https://doi.org/10.48550/arXiv.2102.00968">doi:10.48550/arXiv.2102.00968</a>
</p>


<h3>See Also</h3>

<p>Source Code: <a href="https://github.com/BerriJ/profoc">https://github.com/BerriJ/profoc</a>
</p>
<p>BugReports: <a href="https://github.com/BerriJ/profoc/issues">https://github.com/BerriJ/profoc/issues</a>
</p>

<hr>
<h2 id='autoplot.batch'>Autoplot method for batch models</h2><span id='topic+autoplot.batch'></span>

<h3>Description</h3>

<p>Plots the most recent weights in each quantile using ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'batch'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.batch_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from 'batch'</p>
</td></tr>
<tr><td><code id="autoplot.batch_+3A_...">...</code></td>
<td>
<p>further arguments are ignored</p>
</td></tr>
</table>

<hr>
<h2 id='autoplot.online'>Autoplot method for online models</h2><span id='topic+autoplot.online'></span>

<h3>Description</h3>

<p>Plots the most recent weights in each quantile using ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'online'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.online_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from 'online'</p>
</td></tr>
<tr><td><code id="autoplot.online_+3A_...">...</code></td>
<td>
<p>further arguments are ignored</p>
</td></tr>
</table>

<hr>
<h2 id='batch'>Probabilistic Forecast Combination - Batch</h2><span id='topic+batch'></span>

<h3>Description</h3>

<p>Returns predictions and weights calculated by sequential numeric
optimization. The optimization is done stepwise, always
calculating a one-step-ahead forecast.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch(
  y,
  experts,
  tau = 1:dim(experts)[2]/(dim(experts)[2] + 1),
  affine = FALSE,
  positive = FALSE,
  intercept = FALSE,
  debias = TRUE,
  lead_time = 0,
  initial_window = 30,
  rolling_window = initial_window,
  loss_function = "quantile",
  loss_parameter = 1,
  qw_crps = FALSE,
  b_smooth = list(knots = length(tau), mu = 0.5, sigma = 1, nonc = 0, tailweight = 1, deg
    = 1, periodic = FALSE),
  p_smooth = list(knots = length(tau), mu = 0.5, sigma = 1, nonc = 0, tailweight = 1, deg
    = 1, ndiff = 1.5, lambda = -Inf, periodic = FALSE),
  forget = 0,
  soft_threshold = -Inf,
  hard_threshold = -Inf,
  fixed_share = 0,
  parametergrid_max_combinations = 100,
  parametergrid = NULL,
  forget_past_performance = 0,
  allow_quantile_crossing = FALSE,
  trace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batch_+3A_y">y</code></td>
<td>
<p>A numeric matrix of realizations. In probabilistic
settings a matrix of dimension Tx1, in multivariate settings
a TxD matrix. In the latter case, each slice of
the expert's array gets evaluated using the corresponding
column of the y matrix.</p>
</td></tr>
<tr><td><code id="batch_+3A_experts">experts</code></td>
<td>
<p>An array of predictions with dimension
(Observations, Quantiles, Experts).</p>
</td></tr>
<tr><td><code id="batch_+3A_tau">tau</code></td>
<td>
<p>A numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="batch_+3A_affine">affine</code></td>
<td>
<p>Defines whether weights are summing to 1 or not. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="batch_+3A_positive">positive</code></td>
<td>
<p>Defines if a positivity constraint is applied to the weights.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="batch_+3A_intercept">intercept</code></td>
<td>
<p>Determines if an intercept is added, defaults to FALSE. If true, a new first expert is added, always predicting 1.</p>
</td></tr>
<tr><td><code id="batch_+3A_debias">debias</code></td>
<td>
<p>Defines whether the intercepts weight is constrained or not.
If TRUE (the default), the intercept weight is unconstrained.
Only affects the results if affine and or positive is set to TRUE.
If FALSE, the intercept is treated as an expert.</p>
</td></tr>
<tr><td><code id="batch_+3A_lead_time">lead_time</code></td>
<td>
<p>offset for expert forecasts. Defaults to 0, which means that
experts forecast t+1 at t. Setting this to h means experts predictions refer
to t+1+h at time t. The weight updates delay accordingly.</p>
</td></tr>
<tr><td><code id="batch_+3A_initial_window">initial_window</code></td>
<td>
<p>Defines the size of the initial estimation window.</p>
</td></tr>
<tr><td><code id="batch_+3A_rolling_window">rolling_window</code></td>
<td>
<p>Defines the size of the rolling window. Defaults to
the value of initial_window. Set it to the number of observations to receive
an expanding window.</p>
</td></tr>
<tr><td><code id="batch_+3A_loss_function">loss_function</code></td>
<td>
<p>Either &quot;quantile&quot;, &quot;expectile&quot; or &quot;percentage&quot;.</p>
</td></tr>
<tr><td><code id="batch_+3A_loss_parameter">loss_parameter</code></td>
<td>
<p>Optional parameter scaling the power of the loss function.</p>
</td></tr>
<tr><td><code id="batch_+3A_qw_crps">qw_crps</code></td>
<td>
<p>Decides whether the sum of quantile scores (FALSE) or
the quantile weighted CRPS (TRUE) should be minimized.
Defaults to FALSE. Which corresponds to Berrisch &amp; Ziel (2021)</p>
</td></tr>
<tr><td><code id="batch_+3A_b_smooth">b_smooth</code></td>
<td>
<p>A named list determining how the B-Spline matrices for
probabilistic smoothing are created. Default corresponds to no probabilistic
smoothing. See details.</p>
</td></tr>
<tr><td><code id="batch_+3A_p_smooth">p_smooth</code></td>
<td>
<p>A named list determining how the hat matrices  for
probabilistic P-Spline smoothing are created. Default corresponds to
no smoothing. See details.</p>
</td></tr>
<tr><td><code id="batch_+3A_forget">forget</code></td>
<td>
<p>Adds an exponential forgetting to the optimization.
Past observations will get less influence on the optimization.
Defaults to 0, which corresponds to no forgetting.</p>
</td></tr>
<tr><td><code id="batch_+3A_soft_threshold">soft_threshold</code></td>
<td>
<p>If specified, the following soft threshold will be applied
to the weights: w = sgn(w)*max(abs(w)-t,0) where t is the soft_threshold parameter.
Defaults to -inf, which means that no threshold will be applied.
If all expert weights are thresholded to 0, a weight of 1 will be assigned
to the expert with the highest weights prior to thresholding. Thus soft_threshold = 1
leads to the 'follow the leader' strategy if method is set to &quot;ewa&quot;.</p>
</td></tr>
<tr><td><code id="batch_+3A_hard_threshold">hard_threshold</code></td>
<td>
<p>If specified, the following hard thresholding will be applied
to the weights: w = w*(abs(w)&gt;t) where t is the threshold_hard parameter.
Defaults to -inf, which means that no threshold will be applied.
If all expert weights are thresholded to 0, a weight of 1 will be assigned
to the expert with the highest weight prior to thresholding. Thus hard_threshold = 1
leads to the 'follow the leader' strategy if method is set to &quot;ewa&quot;.</p>
</td></tr>
<tr><td><code id="batch_+3A_fixed_share">fixed_share</code></td>
<td>
<p>Amount of fixed share to be added to the weights.
Defaults to 0. 1 leads to uniform weights.</p>
</td></tr>
<tr><td><code id="batch_+3A_parametergrid_max_combinations">parametergrid_max_combinations</code></td>
<td>
<p>Integer specifying the maximum
number of parameter combinations that should be considered. If
the number of possible combinations exceeds this threshold,
the maximum allowed number is randomly sampled. Defaults to 100.</p>
</td></tr>
<tr><td><code id="batch_+3A_parametergrid">parametergrid</code></td>
<td>
<p>User supplied grid of parameters. Can be used if not
all combinations of the input vectors should be considered. Must be a matrix
with 13 columns (online) or 12 columns batch with the following order:
basis_knot_distance, basis_knot_distance_power, basis_deg, forget_regret,
soft_threshold, hard_threshold, fixed_share, p_smooth_lambda,
p_smooth_knot_distance, p_smooth_knot_distance_power, p_smooth_deg,
p_smooth_ndiff, gamma.</p>
</td></tr>
<tr><td><code id="batch_+3A_forget_past_performance">forget_past_performance</code></td>
<td>
<p>Share of past performance not to be considered, resp. to be
forgotten in every iteration of the algorithm when selecting the best parameter
combination. Defaults to 0.</p>
</td></tr>
<tr><td><code id="batch_+3A_allow_quantile_crossing">allow_quantile_crossing</code></td>
<td>
<p>Shall quantile crossing be allowed? Defaults to false, which means that predictions are sorted in ascending order.</p>
</td></tr>
<tr><td><code id="batch_+3A_trace">trace</code></td>
<td>
<p>Print a progress bar to the console? Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>batch selects various parameters automatically based on
the past loss. For this, the parameters smoothing parameters (see below)
can be specified as numeric vectors containing values to consider.
</p>
<p>This package offers two options for smoothing (Basis Smoothing
and P-Splines).
Parameters <code>b_smooth</code> and <code>p_smooth</code> take named lists to
create the corresponding basis and hat matrices. The arguments are:
<code>knots</code> which determines the number of knots to be created, <code>mu</code>,
<code>sigma</code>, <code>sigma</code>, <code>nonc</code>, <code>tailweight</code> correspond to
to parameters of the beta distribution, which defines how the knots are
#distributed (see <code>?make_knots</code> for details) the defaults will create
an equidistant knot sequence, <code>deg</code> sets the degree of the spline
function and also influences how many outer knots will be used and
<code>periodic</code> which determines whether the spline basis will be periodic.
It's possible to provide vectors of values for each of these parameters.
In that case, all parameter combinations will be used to create the
respective matrices and all candidates will be considered during
online-learning. In addition to the inputs mentioned
before  <code>p_smooth</code> requires <code>ndiff</code> which determines the degree
of differentiation applied to the basis-matrix (can take any value
between and including 1 and 2), <code>lambda</code> which determines the degree
of penalization applied to the smoothing, higher values will give
smoother weight functions. As for the other parameters, it is possible
to provide multiple values.
</p>


<h3>Value</h3>

<p>Returns weights and corresponding predictions.
It is possible to impose a convexity constraint to the
weights by setting affine and positive to TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
T &lt;- 50 # Observations
N &lt;- 2 # Experts
P &lt;- 9 # Quantiles
prob_grid &lt;- 1:P / (P + 1)

y &lt;- rnorm(n = T) # Realized
experts &lt;- array(dim = c(T, P, N)) # Predictions
for (t in 1:T) {
    experts[t, , 1] &lt;- qnorm(prob_grid, mean = -1, sd = 1)
    experts[t, , 2] &lt;- qnorm(prob_grid, mean = 3, sd = sqrt(4))
}

model &lt;- batch(
    y = matrix(y),
    experts = experts,
    p_smooth = list(lambda = 10)
)

print(model)
plot(model)
autoplot(model)

## End(Not run)
</code></pre>

<hr>
<h2 id='conline'>Create an conline Object from the conline C++ Class</h2><span id='topic+conline'></span>

<h3>Description</h3>

<p>Allows for the creation of a Online Object in <em>C++</em> from <em>R</em>
using the <em>C++</em> conline class.
</p>


<h3>Value</h3>

<p>A <code>conline</code> object from the <em>C++</em> conline Class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conline_obj &lt;- new(conline)
</code></pre>

<hr>
<h2 id='init_experts_list'>Create experts list to be used in conline class</h2><span id='topic+init_experts_list'></span>

<h3>Description</h3>

<p>This function works in conjunction with the conline class.
It takes a matrix of experts and a matrix of outcomes and
returns a list of experts which fulfills all properties
that are needed for passing it to the an instance of conline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_experts_list(experts, y, output_with_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_experts_list_+3A_experts">experts</code></td>
<td>
<p>array of predictions with dimension T x D x P x K
(Observations x Variables x Quantiles x Experts) or T x D x K or T x P x K.</p>
</td></tr>
<tr><td><code id="init_experts_list_+3A_y">y</code></td>
<td>
<p>A matrix of outcomes with dimension T x D.</p>
</td></tr>
<tr><td><code id="init_experts_list_+3A_output_with_names">output_with_names</code></td>
<td>
<p>Defaults to FALSE. If TRUE, the function
returns a list with
the experts list, the names of the variables (dnames) and the
names of the experts (enames).</p>
</td></tr>
</table>

<hr>
<h2 id='make_basis_mats'>Create a List of Basis Matrices</h2><span id='topic+make_basis_mats'></span>

<h3>Description</h3>

<p>This function creates a list of basis matrices and the corresponding
parameters. It is used in <code>online()</code> to create the basis matrices
for basis smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_basis_mats(
  x,
  n = length(x),
  mu = 0.5,
  sigma = 1,
  nonc = 0,
  tailw = 1,
  deg = 1,
  periodic = FALSE,
  idx = NULL,
  params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_basis_mats_+3A_x">x</code></td>
<td>
<p>The predictor variable</p>
</td></tr>
<tr><td><code id="make_basis_mats_+3A_n">n</code></td>
<td>
<p>Number of knots</p>
</td></tr>
<tr><td><code id="make_basis_mats_+3A_mu">mu</code></td>
<td>
<p>Beta distribution location parameter</p>
</td></tr>
<tr><td><code id="make_basis_mats_+3A_sigma">sigma</code></td>
<td>
<p>Beta distribution scale parameter</p>
</td></tr>
<tr><td><code id="make_basis_mats_+3A_nonc">nonc</code></td>
<td>
<p>Beta distribution noncentrality parameter</p>
</td></tr>
<tr><td><code id="make_basis_mats_+3A_tailw">tailw</code></td>
<td>
<p>Tailweight</p>
</td></tr>
<tr><td><code id="make_basis_mats_+3A_deg">deg</code></td>
<td>
<p>Degree of splines</p>
</td></tr>
<tr><td><code id="make_basis_mats_+3A_periodic">periodic</code></td>
<td>
<p>Create periodic basis</p>
</td></tr>
<tr><td><code id="make_basis_mats_+3A_idx">idx</code></td>
<td>
<p><code>make_basis_mats()</code> will create a grid containing all
combinations of the parameters. If idx is set, this grid will
be subsetted to the rows specified by idx.</p>
</td></tr>
<tr><td><code id="make_basis_mats_+3A_params">params</code></td>
<td>
<p>Instead of the arguments above, a grid (data.frame
or named matrix) of parameters can be passed directly.</p>
</td></tr>
</table>

<hr>
<h2 id='make_hat_mats'>Create a List of Hat Matrices</h2><span id='topic+make_hat_mats'></span>

<h3>Description</h3>

<p>This function creates a list of hat matrices and the corresponding
parameters. It is used in <code>online()</code> to create the hat matrices
for penalized smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_hat_mats(
  x,
  n = length(x),
  mu = 0.5,
  sigma = 1,
  nonc = 0,
  tailw = 1,
  deg = 1,
  ndiff = 1.5,
  lambda = -Inf,
  periodic = FALSE,
  idx = NULL,
  params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_hat_mats_+3A_x">x</code></td>
<td>
<p>The predictor variable</p>
</td></tr>
<tr><td><code id="make_hat_mats_+3A_n">n</code></td>
<td>
<p>Number of knots</p>
</td></tr>
<tr><td><code id="make_hat_mats_+3A_mu">mu</code></td>
<td>
<p>Beta distribution location parameter</p>
</td></tr>
<tr><td><code id="make_hat_mats_+3A_sigma">sigma</code></td>
<td>
<p>Beta distribution scale parameter</p>
</td></tr>
<tr><td><code id="make_hat_mats_+3A_nonc">nonc</code></td>
<td>
<p>Beta distribution noncentrality parameter</p>
</td></tr>
<tr><td><code id="make_hat_mats_+3A_tailw">tailw</code></td>
<td>
<p>Tailweight</p>
</td></tr>
<tr><td><code id="make_hat_mats_+3A_deg">deg</code></td>
<td>
<p>Degree of splines</p>
</td></tr>
<tr><td><code id="make_hat_mats_+3A_ndiff">ndiff</code></td>
<td>
<p>Sets the degree of the differencing matrix for creating
the penalty</p>
</td></tr>
<tr><td><code id="make_hat_mats_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter (higher values lead to higher penalty)</p>
</td></tr>
<tr><td><code id="make_hat_mats_+3A_periodic">periodic</code></td>
<td>
<p>Create periodic penalty</p>
</td></tr>
<tr><td><code id="make_hat_mats_+3A_idx">idx</code></td>
<td>
<p><code>make_hat_mats()</code> will create a grid containing all
combinations of the parameters. If idx is set, this grid will
be subsetted to the rows specified by idx.</p>
</td></tr>
<tr><td><code id="make_hat_mats_+3A_params">params</code></td>
<td>
<p>Instead of the arguments above, a grid (data.frame
or named matrix) of parameters can be passed directly.</p>
</td></tr>
</table>

<hr>
<h2 id='make_knots'>Create a vector of knots for splines</h2><span id='topic+make_knots'></span>

<h3>Description</h3>

<p>This function creates a knot vector for splines. The knots are distributed
according to a beta distribution. The first input defines the number of inner
knots. The total number of knots is <code>n + 2 * order</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_knots(n, mu = 0.5, sig = 1, nonc = 0, tailw = 1, deg = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_knots_+3A_n">n</code></td>
<td>
<p>Number of knots</p>
</td></tr>
<tr><td><code id="make_knots_+3A_mu">mu</code></td>
<td>
<p>Beta distribution location parameter</p>
</td></tr>
<tr><td><code id="make_knots_+3A_sig">sig</code></td>
<td>
<p>Beta distribution scale parameter</p>
</td></tr>
<tr><td><code id="make_knots_+3A_nonc">nonc</code></td>
<td>
<p>Beta distribution noncentrality parameter</p>
</td></tr>
<tr><td><code id="make_knots_+3A_tailw">tailw</code></td>
<td>
<p>Tailweight</p>
</td></tr>
<tr><td><code id="make_knots_+3A_deg">deg</code></td>
<td>
<p>Degree of splines</p>
</td></tr>
</table>

<hr>
<h2 id='online'>Probabilistic Forecast Combination - Online</h2><span id='topic+online'></span>

<h3>Description</h3>

<p>Returns predictions and weights calculated by online-learning algorithms
using CRPS Learning.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>online(
  y,
  experts,
  tau,
  lead_time = 0,
  loss_function = "quantile",
  loss_parameter = 1,
  loss_gradient = TRUE,
  method = "bewa",
  b_smooth_pr = list(knots = P, mu = 0.5, sigma = 1, nonc = 0, tailweight = 1, deg = 1,
    periodic = FALSE),
  p_smooth_pr = list(knots = P, mu = 0.5, sigma = 1, nonc = 0, tailweight = 1, deg = 1,
    ndiff = 1.5, lambda = -Inf, periodic = FALSE),
  b_smooth_mv = list(knots = D, mu = 0.5, sigma = 1, nonc = 0, tailweight = 1, deg = 1,
    periodic = FALSE),
  p_smooth_mv = list(knots = D, mu = 0.5, sigma = 1, nonc = 0, tailweight = 1, deg = 1,
    ndiff = 1.5, lambda = -Inf, periodic = FALSE),
  forget_regret = 0,
  soft_threshold = -Inf,
  hard_threshold = -Inf,
  fixed_share = 0,
  gamma = 1,
  parametergrid_max_combinations = 100,
  parametergrids = list(general = NULL, b_smooth_pr = NULL, p_smooth_pr = NULL,
    b_smooth_mv = NULL, p_smooth_mv = NULL),
  forget_past_performance = 0,
  save_past_performance = FALSE,
  save_predictions_grid = FALSE,
  allow_quantile_crossing = FALSE,
  init = NULL,
  loss = NULL,
  regret = NULL,
  trace = TRUE,
  get_timings = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="online_+3A_y">y</code></td>
<td>
<p>A numeric matrix of realizations. In probabilistic
settings a matrix of dimension Tx1, in multivariate settings
a TxD matrix. In the latter case, each slice of
the expert's array gets evaluated using the corresponding
column of the y matrix.</p>
</td></tr>
<tr><td><code id="online_+3A_experts">experts</code></td>
<td>
<p>An array of predictions with dimension T x D x P x K
(Observations x Variables x Quantiles x Experts) or T x D x K or T x P x K.</p>
</td></tr>
<tr><td><code id="online_+3A_tau">tau</code></td>
<td>
<p>A numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="online_+3A_lead_time">lead_time</code></td>
<td>
<p>offset for expert forecasts. Defaults to 0, which means that
experts forecast t+1 at t. Setting this to h means experts predictions refer
to t+1+h at time t. The weight updates delay accordingly.</p>
</td></tr>
<tr><td><code id="online_+3A_loss_function">loss_function</code></td>
<td>
<p>Either &quot;quantile&quot;, &quot;expectile&quot; or &quot;percentage&quot;.</p>
</td></tr>
<tr><td><code id="online_+3A_loss_parameter">loss_parameter</code></td>
<td>
<p>Optional parameter scaling the power of the loss function.</p>
</td></tr>
<tr><td><code id="online_+3A_loss_gradient">loss_gradient</code></td>
<td>
<p>Determines if a linearized version of the loss is used.</p>
</td></tr>
<tr><td><code id="online_+3A_method">method</code></td>
<td>
<p>One of &quot;boa&quot;, &quot;bewa&quot;, &quot;ml_poly&quot; or &quot;ewa&quot;. Where &quot;bewa&quot; refers to a mixture of boa and ewa, including the second
order refinement of boa, but updating weights with the simple
exponential weighting.</p>
</td></tr>
<tr><td><code id="online_+3A_b_smooth_pr">b_smooth_pr</code></td>
<td>
<p>A named list determining how the B-Spline matrices for
probabilistic smoothing are created. Default corresponds to no probabilistic
smoothing. See details.</p>
</td></tr>
<tr><td><code id="online_+3A_p_smooth_pr">p_smooth_pr</code></td>
<td>
<p>A named list determining how the hat matrices  for
probabilistic P-Spline smoothing are created. Default corresponds to
no smoothing. See details.</p>
</td></tr>
<tr><td><code id="online_+3A_b_smooth_mv">b_smooth_mv</code></td>
<td>
<p>A named list determining how the B-Spline matrices  for
multivariate smoothing are created. Default corresponds to no probabilistic
smoothing. See details.</p>
</td></tr>
<tr><td><code id="online_+3A_p_smooth_mv">p_smooth_mv</code></td>
<td>
<p>A named list determining how the hat matrices  for
probabilistic P-Spline smoothing are created. Default corresponds to
no smoothing. See details.</p>
</td></tr>
<tr><td><code id="online_+3A_forget_regret">forget_regret</code></td>
<td>
<p>Share of past regret not to be considered, resp. to be
forgotten in every iteration of the algorithm. Defaults to 0.</p>
</td></tr>
<tr><td><code id="online_+3A_soft_threshold">soft_threshold</code></td>
<td>
<p>If specified, the following soft threshold will be applied
to the weights: w = sgn(w)*max(abs(w)-t,0) where t is the soft_threshold parameter.
Defaults to -inf, which means that no threshold will be applied.
If all expert weights are thresholded to 0, a weight of 1 will be assigned
to the expert with the highest weights prior to thresholding. Thus soft_threshold = 1
leads to the 'follow the leader' strategy if method is set to &quot;ewa&quot;.</p>
</td></tr>
<tr><td><code id="online_+3A_hard_threshold">hard_threshold</code></td>
<td>
<p>If specified, the following hard thresholding will be applied
to the weights: w = w*(abs(w)&gt;t) where t is the threshold_hard parameter.
Defaults to -inf, which means that no threshold will be applied.
If all expert weights are thresholded to 0, a weight of 1 will be assigned
to the expert with the highest weight prior to thresholding. Thus hard_threshold = 1
leads to the 'follow the leader' strategy if method is set to &quot;ewa&quot;.</p>
</td></tr>
<tr><td><code id="online_+3A_fixed_share">fixed_share</code></td>
<td>
<p>Amount of fixed share to be added to the weights.
Defaults to 0. 1 leads to uniform weights.</p>
</td></tr>
<tr><td><code id="online_+3A_gamma">gamma</code></td>
<td>
<p>Scaling parameter for the learning rate.</p>
</td></tr>
<tr><td><code id="online_+3A_parametergrid_max_combinations">parametergrid_max_combinations</code></td>
<td>
<p>Integer specifying the maximum
number of parameter combinations that should be considered. If
the number of possible combinations exceeds this threshold,
the maximum allowed number is randomly sampled. Defaults to 100.</p>
</td></tr>
<tr><td><code id="online_+3A_parametergrids">parametergrids</code></td>
<td>
<p>User supplied grids of parameters. Can be used if not
all combinations of the input vectors should be considered. Must be a named
list of five matrices. The matrices in list must be named as: &quot;general&quot;,
&quot;b_smooth_pr&quot;, &quot;b_smooth_mv&quot;, &quot;p_smooth_pr&quot;, &quot;p_smooth_mv&quot;.
The &quot;general&quot; matrix must contain 11 named columns:
&quot;forget_regret&quot;, &quot;soft_threshold&quot;, &quot;hard_threshold&quot;, &quot;fixed_share&quot;,
&quot;basis_pr_idx&quot;, &quot;basis_mv_idx&quot;, &quot;hat_pr_idx&quot;, &quot;hat_mv_idx&quot;,
&quot;gamma&quot;, &quot;loss_share&quot;, &quot;regret_share&quot;.
The matrices determining the basis smoothing (b_smooth_pr, b_smooth_mv) must
contain the following named columns:
n, mu, sigma, nonc, tailw, deg, periodic.
In addition to the columns of the basis smoothing matrices, the matrices
determining the penalized smoothing (p_smooth_pr, p_smooth_mv) must contain
the following columns:
diff, lambda.
The *_idx columns in the general matrix determine which row of the
corresponding smoothing matrix is used.</p>
</td></tr>
<tr><td><code id="online_+3A_forget_past_performance">forget_past_performance</code></td>
<td>
<p>Share of past performance not to be considered, resp. to be
forgotten in every iteration of the algorithm when selecting the best parameter
combination. Defaults to 0.</p>
</td></tr>
<tr><td><code id="online_+3A_save_past_performance">save_past_performance</code></td>
<td>
<p>Whether or not the past performance w.r.t to the
considered parameter grid should be reported or not. Defaults to <code>FALSE</code> to
save memory. Setting it to <code>TRUE</code> can be memory intensive depending on the
data and the considered grid.</p>
</td></tr>
<tr><td><code id="online_+3A_save_predictions_grid">save_predictions_grid</code></td>
<td>
<p>Whether or not all predictions w.r.t to the
considered parameter grid should be reported or not. Defaults to <code>FALSE</code>.
Setting it to <code>TRUE</code> can be memory intensive depending on the data
and the considered grid.</p>
</td></tr>
<tr><td><code id="online_+3A_allow_quantile_crossing">allow_quantile_crossing</code></td>
<td>
<p>Shall quantile crossing be allowed? Defaults to false, which means that predictions are sorted in ascending order.</p>
</td></tr>
<tr><td><code id="online_+3A_init">init</code></td>
<td>
<p>A named list containing &quot;init_weights&quot;: Array of dimension
DxPxK used as starting weights. &quot;R0&quot; a matrix of dimension PxK or 1xK
used as starting regret.</p>
</td></tr>
<tr><td><code id="online_+3A_loss">loss</code></td>
<td>
<p>User specified loss array. Can also be a list with elements
&quot;loss_array&quot;
and &quot;share&quot;, share mixes the provided loss with the loss calculated by
profoc. 1 means, only the provided loss will be used. share can also be
vector of shares to consider.</p>
</td></tr>
<tr><td><code id="online_+3A_regret">regret</code></td>
<td>
<p>User specified regret array. If specific, the regret will
not be calculated by profoc. Can also be a list with elements &quot;regret_array&quot;
and &quot;share&quot;, share mixes the provided regret with the regret calculated by
profoc. 1 means, only the provided regret will be used. share can also be
vector of shares to consider.</p>
</td></tr>
<tr><td><code id="online_+3A_trace">trace</code></td>
<td>
<p>Print a progress bar to the console? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="online_+3A_get_timings">get_timings</code></td>
<td>
<p>Whether or not to return timings. Defaults to <code>FALSE</code>. If
set to true a dataframe <code>times</code> will be written to your global environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>online selects various parameters automatically based on
the past loss. For this, lambda, forget, fixed_share, gamma, and the
smoothing parameters (see below) can be specified as numeric vectors
containing values to consider.
</p>
<p>This package offers two options for smoothing (Basis Smoothing
and P-Splines). Both options can be used to smooth the weights
over dimension D (covariates) or P (quantiles) or both.
Parameters <code>b_smooth_pr</code> and <code>b_smooth_mv</code> take named lists to
create the corresponding basis matrices. The arguments are:
<code>knots</code> which determines the number of knots to be created, <code>mu</code>,
<code>sigma</code>, <code>sigma</code>, <code>nonc</code>, <code>tailweight</code> correspond to
to parameters of the beta distribution, which defines how the knots are
#distributed (see <code>?make_knots</code> for details) the defaults will create
an equidistant knot sequence, <code>deg</code> sets the degree of the spline
function and also influences how many outer knots will be used and
<code>periodic</code> which determines whether the spline basis will be periodic.
It's possible to provide vectors of values for each of these parameters.
In that case, all parameter combinations will be used to create the
respective matrices and all candidates will be considered during
online-learning.
Parameters <code>p_smooth_pr</code> and <code>p_smooth_mv</code> determine the hat-matrix
creation for P-Spline smoothing. In addition to the inputs mentioned
before, they require to provide <code>ndiff</code> which determines the degree
of differentiation applied to the basis-matrix (can take any value
between and including 1 and 2), <code>lambda</code> which determines the degree
of penalization applied to the smoothing, higher values will give
smoother weight functions. As for the other parameters, it is possible
to provide multiple values.
</p>


<h3>Value</h3>

<p>Returns weights and corresponding predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
T &lt;- 50 # Observations
N &lt;- 2 # Experts
P &lt;- 9 # Quantiles
prob_grid &lt;- 1:P / (P + 1)

y &lt;- rnorm(n = T) # Realized
experts &lt;- array(dim = c(T, P, N)) # Predictions
for (t in 1:T) {
    experts[t, , 1] &lt;- qnorm(prob_grid, mean = -1, sd = 1)
    experts[t, , 2] &lt;- qnorm(prob_grid, mean = 3, sd = sqrt(4))
}

model &lt;- online(
    y = matrix(y),
    experts = experts,
    tau = prob_grid,
    p_smooth_pr = list(lambda = 10)
)

print(model)
plot(model)

new_y &lt;- matrix(rnorm(1)) # Realized
new_experts &lt;- experts[T, , , drop = FALSE]

# Update will update the models weights etc if you provide new realizations
model &lt;- update(model, new_y = new_y, new_experts = new_experts)

# Predict will expand `model$predictions` by default
model &lt;- predict(model, new_experts = new_experts, update_model = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='oracle'>Probabilistic Forecast Combination - Oracle</h2><span id='topic+oracle'></span>

<h3>Description</h3>

<p>Returns predictions and weights calculated by numeric
optimization. The optimization is done in hindsight.
This means all observations are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oracle(y, experts, tau, affine = FALSE,
positive = FALSE, intercept = FALSE, debias = TRUE,
loss_function = "quantile", loss_parameter = 1, forget = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oracle_+3A_y">y</code></td>
<td>
<p>A numeric matrix of realizations. In probabilistic
settings a matrix of dimension Tx1, in multivariate settings
a TxD matrix. In the latter case, each slice of
the expert's array gets evaluated using the corresponding
column of the y matrix.</p>
</td></tr>
<tr><td><code id="oracle_+3A_experts">experts</code></td>
<td>
<p>An array of predictions with dimension
(Observations, Quantiles, Experts).</p>
</td></tr>
<tr><td><code id="oracle_+3A_tau">tau</code></td>
<td>
<p>A numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="oracle_+3A_affine">affine</code></td>
<td>
<p>Defines whether weights are summing to 1 or not. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="oracle_+3A_positive">positive</code></td>
<td>
<p>Defines if a positivity constraint is applied to the weights.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="oracle_+3A_intercept">intercept</code></td>
<td>
<p>Determines if an intercept is added, defaults to FALSE. If true, a new first expert is added, always predicting 1.</p>
</td></tr>
<tr><td><code id="oracle_+3A_debias">debias</code></td>
<td>
<p>Defines whether the intercepts weight is constrained or not.
If TRUE (the default), the intercept weight is unconstrained.
Only affects the results if affine and or positive is set to TRUE.
If FALSE, the intercept is treated as an expert.</p>
</td></tr>
<tr><td><code id="oracle_+3A_loss_function">loss_function</code></td>
<td>
<p>Either &quot;quantile&quot;, &quot;expectile&quot; or &quot;percentage&quot;.</p>
</td></tr>
<tr><td><code id="oracle_+3A_loss_parameter">loss_parameter</code></td>
<td>
<p>Optional parameter scaling the power of the loss function.</p>
</td></tr>
<tr><td><code id="oracle_+3A_forget">forget</code></td>
<td>
<p>Adds an exponential forgetting to the optimization.
Past observations will get less influence on the optimization.
Defaults to 0, which corresponds to no forgetting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns weights and corresponding predictions.
It is possible to calculate the best convex combination
of weights by setting affine and positive to TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
T &lt;- 50 # Observations
N &lt;- 2 # Experts
P &lt;- 9 # Quantiles
prob_grid &lt;- 1:P / (P + 1)

y &lt;- rnorm(n = T) # Realized
experts &lt;- array(dim = c(T, P, N)) # Predictions
for (t in 1:T) {
    experts[t, , 1] &lt;- qnorm(prob_grid, mean = -1, sd = 1)
    experts[t, , 2] &lt;- qnorm(prob_grid, mean = 3, sd = sqrt(4))
}

model &lt;- oracle(
    y = matrix(y),
    experts = experts
)

## End(Not run)

</code></pre>

<hr>
<h2 id='penalty'>B-Spline penalty</h2><span id='topic+penalty'></span>

<h3>Description</h3>

<p>This function calculates the B-Spline basis penalty.
It follows the procedure outlined in the paper by Zheyuan Li, Jiguo
Cao, 2022 &quot;General P-Splines for Non-Uniform B-Splines&quot;
<a href="https://doi.org/10.48550/arXiv.2201.06808">doi:10.48550/arXiv.2201.06808</a>.
For equidistant knots it coincides with the usual penalty based
on the identitiy. For non-equidistant knots it is a weighted penalty
with respect to the knot distances.
In addition to the above, we added the possibility to calculate
periodic penalties which are based on the periodic differencing matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalty(knots, order, periodic = FALSE, max_diff = 999L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalty_+3A_knots">knots</code></td>
<td>
<p>Vector of knots.</p>
</td></tr>
<tr><td><code id="penalty_+3A_order">order</code></td>
<td>
<p>Order of the Basis (degree + 1).</p>
</td></tr>
<tr><td><code id="penalty_+3A_periodic">periodic</code></td>
<td>
<p>Whether the penalties should be periodic or not.</p>
</td></tr>
<tr><td><code id="penalty_+3A_max_diff">max_diff</code></td>
<td>
<p>Maximum difference order to calculate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of (order - 1) penalty matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Equidistant knots with order 2
knots &lt;- 1:10

P &lt;- penalty(knots, order = 2)

print(P[[1]]) # First differences

# Non equidistant knots
knots &lt;- c(0, 0, 0, 0, 1, 3, 4, 4, 4, 4)

P &lt;- penalty(knots, order = 4)

print(P[[1]]) # First differences
print(P[[2]]) # Second differences
print(P[[3]]) # Third differences

# Periodic penalty for equidistant knots
oder &lt;- 4
deg &lt;- order - 1
knots &lt;- 1:15

penalty(knots, order = order, periodic = TRUE)[[1]]
penalty(knots, order = order, periodic = TRUE)[[2]]
penalty(knots, order = order, periodic = TRUE)[[3]]

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.batch'>Plot method for batch models</h2><span id='topic+plot.batch'></span>

<h3>Description</h3>

<p>Plots the most recent weights in each quantile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'batch'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.batch_+3A_x">x</code></td>
<td>
<p>Object of class inheriting from 'batch'</p>
</td></tr>
<tr><td><code id="plot.batch_+3A_...">...</code></td>
<td>
<p>further arguments are ignored</p>
</td></tr>
</table>

<hr>
<h2 id='plot.online'>Plot method for online models</h2><span id='topic+plot.online'></span>

<h3>Description</h3>

<p>Plots the most recent weights in each quantile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'online'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.online_+3A_x">x</code></td>
<td>
<p>Object of class inheriting from 'online'</p>
</td></tr>
<tr><td><code id="plot.online_+3A_...">...</code></td>
<td>
<p>further arguments are ignored</p>
</td></tr>
</table>

<hr>
<h2 id='post_process_model'>Post Process Data from conline Class</h2><span id='topic+post_process_model'></span>

<h3>Description</h3>

<p>This function works in conjunction with the conline class.
After the main learning task, it takes the output of the
conline class and returns an object suitable for, visualization,
further, and deployment.
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_process_model(model_instance, names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_process_model_+3A_model_instance">model_instance</code></td>
<td>
<p>An instance of conline.</p>
</td></tr>
<tr><td><code id="post_process_model_+3A_names">names</code></td>
<td>
<p>A named list with dimnames of <code>y</code> and <code>experts</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='predict.online'>Predict method for online models</h2><span id='topic+predict.online'></span>

<h3>Description</h3>

<p>Calculates predictions based on new expert advice.
This does not update weights. If new observations are available
use update instead. The latter updates and weights and computes predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'online'
predict(object, new_experts, update_model = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.online_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from 'online'</p>
</td></tr>
<tr><td><code id="predict.online_+3A_new_experts">new_experts</code></td>
<td>
<p>new expert predictions</p>
</td></tr>
<tr><td><code id="predict.online_+3A_update_model">update_model</code></td>
<td>
<p>Defines whether the model object should be updated or not.
If TRUE, new forecaster and expert predictions are appended onto
the respective object items. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="predict.online_+3A_...">...</code></td>
<td>
<p>further arguments are ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>predict.online</code> produces an updated model object.
</p>

<hr>
<h2 id='print.batch'>Print method for batch models</h2><span id='topic+print.batch'></span>

<h3>Description</h3>

<p>Prints the average loss of all and the forecast combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'batch'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.batch_+3A_x">x</code></td>
<td>
<p>Object of class inheriting from 'batch'</p>
</td></tr>
<tr><td><code id="print.batch_+3A_...">...</code></td>
<td>
<p>further arguments are ignored</p>
</td></tr>
</table>

<hr>
<h2 id='print.online'>Print method for online models</h2><span id='topic+print.online'></span>

<h3>Description</h3>

<p>Prints the average loss of all experts and the forecast combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'online'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.online_+3A_x">x</code></td>
<td>
<p>Object of class inheriting from 'online'</p>
</td></tr>
<tr><td><code id="print.online_+3A_...">...</code></td>
<td>
<p>further arguments are ignored</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+autoplot'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+autoplot">autoplot</a></code></p>
</dd>
</dl>

<hr>
<h2 id='splines2_basis'>Create B-Spline basis</h2><span id='topic+splines2_basis'></span>

<h3>Description</h3>

<p>This function creates a B-Spline matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splines2_basis(x, knots, deg, periodic = FALSE, intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splines2_basis_+3A_x">x</code></td>
<td>
<p>Vector of values.</p>
</td></tr>
<tr><td><code id="splines2_basis_+3A_knots">knots</code></td>
<td>
<p>Vector of knots.</p>
</td></tr>
<tr><td><code id="splines2_basis_+3A_deg">deg</code></td>
<td>
<p>Degree of the Spline functions.</p>
</td></tr>
<tr><td><code id="splines2_basis_+3A_periodic">periodic</code></td>
<td>
<p>Whether the basis should be periodic or not.</p>
</td></tr>
<tr><td><code id="splines2_basis_+3A_intercept">intercept</code></td>
<td>
<p>Whether the firs column should be kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of B-Spline basis functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 9
deg &lt;- 3
mu &lt;- 0.35
x &lt;- 0:1000 / 1000

knots &lt;- make_knots(n, mu = mu, deg = deg)

B &lt;- splines2_basis(x, knots, deg)
ts.plot(B, col = 1:dim(B)[2])

# Periodic Case
B &lt;- splines2_basis(x, knots, deg, periodic = TRUE)
ts.plot(B, col = 1:dim(B)[2])

</code></pre>

<hr>
<h2 id='summary.online'>Summary method for online models</h2><span id='topic+summary.online'></span>

<h3>Description</h3>

<p>Calculates parameters chosen during optimization and aggregates losses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'online'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.online_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from 'online'</p>
</td></tr>
<tr><td><code id="summary.online_+3A_...">...</code></td>
<td>
<p>further arguments are ignored</p>
</td></tr>
</table>

<hr>
<h2 id='tidy.online.experts_loss'>Tidy the Experts' losses of an Online object</h2><span id='topic+tidy.online.experts_loss'></span>

<h3>Description</h3>

<p><code>tidy</code> will transform the <code>experts_loss</code> array of an online object
into a tibble that is better suited for plotting and analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'online.experts_loss'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.online.experts_loss_+3A_x">x</code></td>
<td>
<p>The experts_loss of an <code>online</code> object.</p>
</td></tr>
<tr><td><code id="tidy.online.experts_loss_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns <code>t</code> <code>d</code> <code>p</code> <code>k</code> and <code>w</code> corresponding
to the time, marginals, probabilities, and experts_loss
of the online-learning computation.
</p>

<hr>
<h2 id='tidy.online.forecaster_loss'>Tidy the Experts' losses of an Online object</h2><span id='topic+tidy.online.forecaster_loss'></span>

<h3>Description</h3>

<p><code>tidy</code> will transform the 'forecaster_loss&ldquo; array of an online object
into a tibble that is better suited for plotting and analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'online.forecaster_loss'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.online.forecaster_loss_+3A_x">x</code></td>
<td>
<p>The forecaster_loss of an <code>online</code> object.</p>
</td></tr>
<tr><td><code id="tidy.online.forecaster_loss_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns <code>t</code> <code>d</code> <code>p</code> <code>k</code> and <code>w</code> corresponding
to the time, marginals, probabilities, and forecaster_loss
of the online-learning computation.
</p>

<hr>
<h2 id='tidy.online.predictions'>Tidy the Predictions of an Online object</h2><span id='topic+tidy.online.predictions'></span>

<h3>Description</h3>

<p><code>tidy</code> will transform the <code>predictions</code> array of an online object
into a tibble that is better suited for plotting and analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'online.predictions'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.online.predictions_+3A_x">x</code></td>
<td>
<p>The predictions of an <code>online</code> object.</p>
</td></tr>
<tr><td><code id="tidy.online.predictions_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns <code>t</code> <code>d</code> <code>p</code> <code>k</code> and <code>w</code> corresponding
to the time, marginals, probabilities, and predictions
of the online-learning computation.
</p>

<hr>
<h2 id='tidy.online.weights'>Tidy the Weights of an Online object</h2><span id='topic+tidy.online.weights'></span>

<h3>Description</h3>

<p><code>tidy</code> will transform the weights array of an online object
into a tibble that is better suited for plotting and analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'online.weights'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.online.weights_+3A_x">x</code></td>
<td>
<p>The weights of an <code>online</code> object.</p>
</td></tr>
<tr><td><code id="tidy.online.weights_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns <code>t</code> <code>d</code> <code>p</code> <code>k</code> and <code>w</code> corresponding
to the time, marginals, probabilities, experts, and weights
of the online-learning computation.
</p>

<hr>
<h2 id='update.online'>Update method for online models</h2><span id='topic+update.online'></span>

<h3>Description</h3>

<p>Continues learning using new observations and new expert advice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'online'
update(object, new_y, new_experts = NULL, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.online_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from 'online'</p>
</td></tr>
<tr><td><code id="update.online_+3A_new_y">new_y</code></td>
<td>
<p>new observations</p>
</td></tr>
<tr><td><code id="update.online_+3A_new_experts">new_experts</code></td>
<td>
<p>new expert predictions. This must be left unspecified</p>
</td></tr>
<tr><td><code id="update.online_+3A_trace">trace</code></td>
<td>
<p>If a progress bar shall be shown. Defaults to FALSE
if the model already contains the expert predictions corresponding to new_y.</p>
</td></tr>
<tr><td><code id="update.online_+3A_...">...</code></td>
<td>
<p>further arguments are ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>update.online</code> produces an updated model object.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
