<!DOCTYPE html><html lang="en"><head><title>Help for package Rsurrogate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rsurrogate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Aug.R.s.surv.estimate'>
<p>Calculates the augmented estimator of the proportion of treatment effect explained by the surrogate marker information measured at a specified time and primary outcome information up to that specified time</p>
</p></a></li>
<li><a href='#augment.est.vector'>
<p>Augmentation function</p></a></li>
<li><a href='#calculate.var.np'>
<p>calculates closed form variance estimate for R</p></a></li>
<li><a href='#censor.weight'>
<p>Calculates censoring probability for weighting</p></a></li>
<li><a href='#cumsum2'>
<p>Helper function</p></a></li>
<li><a href='#d_example'>
<p>Hypothetical data</p></a></li>
<li><a href='#d_example_me'>
<p>Hypothetical data with replicate measurements</p></a></li>
<li><a href='#d_example_multiple'>
<p>Hypothetical survival data with multiple surrogate markers</p></a></li>
<li><a href='#d_example_surv'>
<p>Hypothetical survival data</p></a></li>
<li><a href='#delper.si'>
<p>Helper function</p></a></li>
<li><a href='#delta.estimate'>
<p>Calculates treatment effect</p></a></li>
<li><a href='#delta.multiple.surv'>
<p>Calculates robust residual treatment effect accounting for multiple surrogate markers at a specified time and primary outcome information up to that specified time</p></a></li>
<li><a href='#delta.s.estimate'>
<p>Calculates model-based or robust residual treatment effect</p>
</p></a></li>
<li><a href='#delta.s.surv.estimate'>
<p>Calculates robust residual treatment effect accounting for surrogate marker information measured at a specified time and primary outcome information up to that specified time</p></a></li>
<li><a href='#delta.surv.estimate'>
<p>Calculates treatment effect in a survival setting</p></a></li>
<li><a href='#delta.t.surv.estimate'>
<p>Calculates robust residual treatment effect accounting only for primary outcome information up to a specified time</p>
</p></a></li>
<li><a href='#fieller.calculate.me'>
<p>Constructs Fieller's confidence interval.</p></a></li>
<li><a href='#fieller.ci'>
<p>Constructs Fieller's confidence interval.</p></a></li>
<li><a href='#Kern.FUN'>
<p>Calculates kernel matrix</p></a></li>
<li><a href='#me.variance.estimate'>
<p>Estimates measurement error variance given replicate data.</p></a></li>
<li><a href='#perturb.nu.vector'>
<p>Helper for augmentation function</p></a></li>
<li><a href='#pred.smooth'>
<p>Calculates expected outcome for control group surrogate values</p></a></li>
<li><a href='#pred.smooth.surv'>
<p>Calculates the conditional probability of survival for control group values</p></a></li>
<li><a href='#R.multiple.surv'>
<p>Calculates the proportion of treatment effect explained by multiple surrogate markers measured at a specified time and primary outcome information up to that specified time</p></a></li>
<li><a href='#R.s.estimate'>
<p>Calculates the proportion of treatment effect explained</p></a></li>
<li><a href='#R.s.estimate.me'>
<p>Calculates the proportion of treatment effect explained correcting for measurement error in the surrogate marker</p>
</p></a></li>
<li><a href='#R.s.surv.estimate'>
<p>Calculates the proportion of treatment effect explained by the surrogate marker information measured at a specified time and primary outcome information up to that specified time</p></a></li>
<li><a href='#R.t.surv.estimate'>
<p>Calculates the proportion of treatment effect explained by the primary outcome information up to a specified time</p>
</p></a></li>
<li><a href='#VTM'>
<p>Repeats a row.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Estimation of the Proportion of Treatment Effect
Explained by Surrogate Marker Information</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Layla Parast</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Layla Parast &lt;parast@austin.utexas.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to estimate the proportion of treatment effect on the primary outcome that is explained by the treatment effect on the surrogate marker. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, survival, Matrix</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 18:30:29 UTC; parastlm</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 19:52:49 UTC</td>
</tr>
</table>
<hr>
<h2 id='Aug.R.s.surv.estimate'>
Calculates the augmented estimator of the proportion of treatment effect explained by the surrogate marker information measured at a specified time and primary outcome information up to that specified time
</h2><span id='topic+Aug.R.s.surv.estimate'></span>

<h3>Description</h3>

<p>This function calculates the augmented version of the proportion of treatment effect on the primary outcome explained by the surrogate marker information measured at <code class="reqn">t_0</code> and primary outcome information up to <code class="reqn">t_0</code>.  Variance estimates and 95 % confidence intervals for the augmented estimates are provided automatically;  three versions of the confidence interval are provided: a normal approximation based interval, a quantile based interval and Fieller's confidence interval, all using perturbation-resampling. The user can also request an estimate of the incremental value of surrogate marker information. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Aug.R.s.surv.estimate(xone, xzero, deltaone, deltazero, sone, szero, t, 
weight.perturb = NULL, landmark, extrapolate = FALSE, transform = FALSE, 
basis.delta.one, basis.delta.zero, basis.delta.s.one = NULL, 
basis.delta.s.zero = NULL, incremental.value = FALSE, approx = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Aug.R.s.surv.estimate_+3A_xone">xone</code></td>
<td>

<p>numeric vector, the observed event times in the treatment group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_xzero">xzero</code></td>
<td>

<p>numeric vector, the observed event times in the control group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_deltaone">deltaone</code></td>
<td>

<p>numeric vector, the event indicators for the treatment group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_deltazero">deltazero</code></td>
<td>

<p>numeric vector, the event indicators for the control group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_sone">sone</code></td>
<td>

<p>numeric vector; surrogate marker measurement at <code class="reqn">t_0</code> for treated observations, assumed to be continuous. If <code class="reqn">X_{1i}&lt;t_0</code>, then the surrogate marker measurement should be NA. 
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_szero">szero</code></td>
<td>

<p>numeric vector; surrogate marker measurement at <code class="reqn">t_0</code> for control observations, assumed to be continuous. If <code class="reqn">X_{1i}&lt;t_0</code>, then the surrogate marker measurement should be NA.
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_t">t</code></td>
<td>

<p>the time of interest.
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>weights used for perturbation resampling.
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time <code class="reqn">t_0</code> or time of surrogate marker measurement.
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_extrapolate">extrapolate</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use extrapolation.
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_transform">transform</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use a transformation for the surrogate marker. 
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_basis.delta.one">basis.delta.one</code></td>
<td>

<p>either a vector of length <code class="reqn">n_1</code> or a matrix with <code class="reqn">n_1</code> rows; this is the basis transformation used for augmentation of <code class="reqn">\hat{\Delta}(t)</code> for treated observations only, all values must be numeric
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_basis.delta.zero">basis.delta.zero</code></td>
<td>

<p>either a vector of length <code class="reqn">n_0</code> or a matrix with <code class="reqn">n_0</code> rows; this is the basis transformation used for augmentation of <code class="reqn">\hat{\Delta}(t)</code> for control observations only, all values must be numeric
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_basis.delta.s.one">basis.delta.s.one</code></td>
<td>

<p>either a vector of length <code class="reqn">n_1</code> or a matrix with <code class="reqn">n_1</code> rows; this is the basis transformation used for augmentation of <code class="reqn">\hat{\Delta}_S(t,t_0)</code> for treated observations only, all values must be numeric; default is to assume this is the same as basis.delta.one i.e. that the same basis transformation is used for both quantities
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_basis.delta.s.zero">basis.delta.s.zero</code></td>
<td>

<p>either a vector of length <code class="reqn">n_0</code> or a matrix with <code class="reqn">n_0</code> rows; this is the basis transformation used for augmentation of <code class="reqn">\hat{\Delta}_S(t,t_0)</code> for control observations only, all values must be numeric; default is to assume this is the same as basis.delta.zero i.e. that the same basis transformation is used for both quantities
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_incremental.value">incremental.value</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user would like to see the incremental value of the surrogate marker information, default is FALSE.
</p>
</td></tr>
<tr><td><code id="Aug.R.s.surv.estimate_+3A_approx">approx</code></td>
<td>

<p>TRUE or FALSE indicating whether an approximation should be used when calculating the probability of censoring; most relevant in settings where the survival time of interest for the primary outcome is greater than the last observed event but before the last censored case, default is TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see R.s.surv.estimate documention for details about the estimates before augmentation is performed. Recent work has shown that augmentation can lead to improvements in efficiency by taking advantage of the association between baseline information, denoted here as <code class="reqn">Z</code>, and the primary outcome. This function calculates the augmented estimates of the quantities of interest. For example, the augmented version of <code class="reqn"> \hat{\Delta}(t)</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Delta}(t)^{AUG} =   \hat{\Delta}(t) + \gamma \{n_1^{-1}\sum_{i=1}^{n_1}h(Z_{1i})-n_0^{-1}\sum_{i=1}^{n_0}h(Z_{0i}) \} </code>
</p>
 
<p>where <code class="reqn">Z_{gi}, i=1, 2, \cdots, n_g</code> are i.i.d. random vectors of baseline covariates from treatment group <code class="reqn">g</code> and <code class="reqn">h(\cdot)</code> is a basis transformation given a priori.  Due to treatment randomization, <code class="reqn"> \{n_1^{-1}\sum_{i=1}^{n_1}h(Z_{1i})-n_0^{-1}\sum_{i=1}^{n_0}h(Z_{0i}) \}</code> converges to zero in probability as the sample size goes to infinity and thus the augmented estimator converges to the same limit as the original counterparts.  The quantity <code class="reqn">\gamma</code> is selected such that the variance of <code class="reqn"> \hat{\Delta}(t)^{AUG}</code> is minimized.  That is,  <code class="reqn">\gamma = (\Xi_{12}) ( \Xi_{22} ) ^{-1}</code> where
</p>
<p style="text-align: center;"><code class="reqn"> \Xi_{12} = \mbox{cov}  \{ \hat{\Delta}(t), n_1^{-1}\sum_{i=1}^{n_1}h(Z_{1i})-n_0^{-1}\sum_{i=1}^{n_0}h(Z_{0i}) \},</code>
</p>

<p style="text-align: center;"><code class="reqn">  \Xi_{22} = \mbox{var}  \{n_1^{-1}\sum_{i=1}^{n_1}h(Z_{1i})-n_0^{-1}\sum_{i=1}^{n_0}h(Z_{0i})\}</code>
</p>

<p>and thus we can obtain <code class="reqn">\hat{\Delta}(t)^{AUG}</code> by replacing <code class="reqn">\gamma</code> with a consistent estimator, <code class="reqn">\hat{\gamma}</code> obtained using perturbation-resampling. A similar approach is used to obtain  <code class="reqn">\hat{\Delta}_S(t)^{AUG}</code> and thus construct
</p>
<p style="text-align: center;"><code class="reqn">\hat{R}_S(t,t_0)^{AUG}=1-\frac{\hat{\Delta}_S(t,t_0)^{AUG}}{\hat{\Delta}(t)^{AUG}}.</code>
</p>
<p> When only a single <code class="reqn">Z_{gi}</code> is provided in the basis argument, the following basis is used in this function: <code class="reqn">h(Z_{gi}) = (1, Z_{gi}, Z_{gi}^2)'.</code>
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table role = "presentation">
<tr><td><code>aug.delta</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}(t)^{AUG}</code>.</p>
</td></tr>
<tr><td><code>aug.delta.s</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}_S(t,t_0)^{AUG}</code>.</p>
</td></tr>
<tr><td><code>aug.R.s</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{R}_S(t,t_0)^{AUG}</code>.</p>
</td></tr>
<tr><td><code>aug.delta.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}(t)^{AUG}</code>.</p>
</td></tr>
<tr><td><code>aug.delta.s.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}_S(t,t_0)^{AUG}</code>.</p>
</td></tr>
<tr><td><code>aug.R.s.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{R}_S(t,t_0)^{AUG}</code>.</p>
</td></tr>
<tr><td><code>conf.int.normal.aug.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)^{AUG}</code> based on a normal approximation.</p>
</td></tr>
<tr><td><code>conf.int.quantile.aug.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)^{AUG}</code> based on sample quantiles of the perturbed values.</p>
</td></tr> 
<tr><td><code>conf.int.normal.aug.delta.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_S(t,t_0)^{AUG}</code> based on a normal approximation.</p>
</td></tr>
<tr><td><code>conf.int.quantile.aug.delta.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_S(t,t_0)^{AUG}</code> based on sample quantiles of the perturbed values.</p>
</td></tr> 
<tr><td><code>conf.int.normal.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)^{AUG}</code> based on a normal approximation.</p>
</td></tr>
<tr><td><code>conf.int.quantile.aug.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)^{AUG}</code> based on sample quantiles of the perturbed values..</p>
</td></tr> 
<tr><td><code>conf.int.fieller.aug.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)^{AUG}</code> based on Fieller's approach.</p>
</td></tr> 
<tr><td><code>aug.delta.t</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}_T(t,t_0)^{AUG}</code>; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>aug.R.t</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{R}_T(t,t_0)^{AUG}</code>; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>aug.incremental.value</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{IV}_S(t,t_0)^{AUG}</code>; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>aug.delta.t.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}_T(t,t_0)^{AUG}</code>; if  incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>aug.R.t.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{R}_T(t,t_0)^{AUG}</code>; if  incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>aug.incremental.value.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{IV}_S(t,t_0)^{AUG}</code>; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>aug.conf.int.normal.delta.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_T(t,t_0)^{AUG}</code> based on a normal approximation; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>aug.conf.int.quantile.delta.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_T(t,t_0)^{AUG}</code> based on sample quantiles of the perturbed values; if  incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>aug.conf.int.normal.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)^{AUG}</code> based on a normal approximation; if  incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>aug.conf.int.quantile.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)^{AUG}</code> based on sample quantiles of the perturbed values; if  incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>aug.conf.int.fieller.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)^{AUG}</code> based on Fieller's approach, described above; if incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>aug.conf.int.normal.iv</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{IV}_S(t,t_0)^{AUG}</code> based on a normal approximation; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>aug.conf.int.quantile.iv</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{IV}_S(t,t_0)^{AUG}</code> based on sample quantiles of the perturbed values; if  incremental.vaue = TRUE.</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>If the treatment effect is not significant, the user will receive the following message: &quot;Warning: it looks like the treatment effect is not significant; may be difficult to interpret the residual treatment effect in this setting&quot;. If the observed support of the surrogate marker for the control group is outside the observed support of the surrogate marker for the treatment group, the user will receive the following message: &quot;Warning: observed supports do not appear equal, may need to consider a transformation or extrapolation&quot;.
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Tian L, Cai T, Zhao L,Wei L. On the covariate-adjusted estimation for an overall treatment difference with data from a randomized comparative clinical trial. Biostatistics 2012; 13(2): 256-273.
</p>
<p>Garcia TP, Ma Y, Yin G. Efficiency improvement in a class of survival models through model-free covariate incorporation. Lifetime Data Analysis 2011; 17(4): 552-565. 
</p>
<p>Zhang M, Tsiatis AA, Davidian M. Improving efficiency of inferences in randomized clinical trials using auxiliary covariates. Biometrics 2008; 64(3): 707-715.
</p>
<p>Parast, L., Cai, T., &amp; Tian, L. (2017). Evaluating surrogate marker information using censored data. Statistics in Medicine, 36(11), 1767-1782.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#computationally intensive
#Aug.R.s.surv.estimate(xone = d_example_surv$x1, xzero = d_example_surv$x0,  
#deltaone = d_example_surv$delta1, deltazero = d_example_surv$delta0, 
#sone = d_example_surv$s1, szero = d_example_surv$s0, t=3, landmark = 1, 
#basis.delta.one = d_example_surv$z1 , basis.delta.zero = d_example_surv$z0)

</code></pre>

<hr>
<h2 id='augment.est.vector'>
Augmentation function
</h2><span id='topic+augment.est.vector'></span>

<h3>Description</h3>

<p>Augmentation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augment.est.vector(point.delta, perturb.delta, treat.ind, basis, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augment.est.vector_+3A_point.delta">point.delta</code></td>
<td>

</td></tr>
<tr><td><code id="augment.est.vector_+3A_perturb.delta">perturb.delta</code></td>
<td>

</td></tr>
<tr><td><code id="augment.est.vector_+3A_treat.ind">treat.ind</code></td>
<td>

</td></tr>
<tr><td><code id="augment.est.vector_+3A_basis">basis</code></td>
<td>

</td></tr>
<tr><td><code id="augment.est.vector_+3A_weights">weights</code></td>
<td>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>

<hr>
<h2 id='calculate.var.np'>
calculates closed form variance estimate for R
</h2><span id='topic+calculate.var.np'></span>

<h3>Description</h3>

<p>calculates closed form variance estimate for R; used in R function that corrects for measurement error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.var.np(s1, s0, y1, y0, extrapolate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate.var.np_+3A_s1">s1</code></td>
<td>

<p>numeric vector or matrix; surrogate marker for treated observations, assumed to be continuous. If there are multiple surrogates then this should be a matrix with <code class="reqn">n_1</code> (number of treated observations) rows and n.s (number of surrogate markers) columns.
</p>
</td></tr>
<tr><td><code id="calculate.var.np_+3A_s0">s0</code></td>
<td>

<p>numeric vector; surrogate marker for control observations, assumed to be continuous.If there are multiple surrogates then this should be a matrix with <code class="reqn">n_0</code> (number of control observations) rows and n.s (number of surrogate markers) columns. 
</p>
</td></tr>
<tr><td><code id="calculate.var.np_+3A_y1">y1</code></td>
<td>

<p>numeric vector; primary outcome for treated observations, assumed to be continuous.
</p>
</td></tr>
<tr><td><code id="calculate.var.np_+3A_y0">y0</code></td>
<td>

<p>numeric vector; primary outcome for control observations, assumed to be continuous.
</p>
</td></tr>
<tr><td><code id="calculate.var.np_+3A_extrapolate">extrapolate</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use extrapolation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>total</code></td>
<td>
<p>matrix needed for variance calculation</p>
</td></tr>
<tr><td><code>psionly</code></td>
<td>
<p>matrix needed for variance calculation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., McDermott, M., Tian, L. (2016). Robust estimation of the proportion of treatment effect explained by surrogate marker information. Statistics in Medicine, 35(10):1637-1653.
</p>
<p>Parast, L., Garcia, T. P., Prentice, R. L., &amp; Carroll, R. J. (2022). Robust methods to correct for measurement error when evaluating a surrogate marker. Biometrics, 78(1), 9-23.
</p>

<hr>
<h2 id='censor.weight'>
Calculates censoring probability for weighting
</h2><span id='topic+censor.weight'></span>

<h3>Description</h3>

<p>Helper function; calculates censoring probability needed for inverse probability of censoring weighting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>censor.weight(data.x, data.delta, t, weight = NULL, approx = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="censor.weight_+3A_data.x">data.x</code></td>
<td>

<p>numeric vector, the observed event time: X = min(T, C) where T is the time of the primary outcome, C is the censoring time
</p>
</td></tr>
<tr><td><code id="censor.weight_+3A_data.delta">data.delta</code></td>
<td>

<p>numeric vector of 0/1, the censoring indicator: D = I(T&lt;C) where T is the time of the primary outcome, C is the censoring time
</p>
</td></tr>
<tr><td><code id="censor.weight_+3A_t">t</code></td>
<td>

<p>number, the time of interest
</p>
</td></tr>
<tr><td><code id="censor.weight_+3A_weight">weight</code></td>
<td>

<p>a numeric vector or matrix of weights used for perturbation-resampling, default is null.
</p>
</td></tr>
<tr><td><code id="censor.weight_+3A_approx">approx</code></td>
<td>

<p>TRUE or FALSE indicating whether an approximation should be used when calculating the probability of censoring; most relevant in settings where the survival time of interest for the primary outcome is greater than the last observed event but before the last censored case, default is TRUE.
</p>
</td></tr></table>


<h3>Details</h3>

<p>Computes the Kaplan Meier estimate of survival for the censoring random variable at the specified time
</p>


<h3>Value</h3>

<p>Kaplan Meier estimate of survival for censoring at time t
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>

<hr>
<h2 id='cumsum2'>
Helper function
</h2><span id='topic+cumsum2'></span>

<h3>Description</h3>

<p>Helper function; should not be called directly by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumsum2(mydat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumsum2_+3A_mydat">mydat</code></td>
<td>

<p>mydat</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>out</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>

<hr>
<h2 id='d_example'>
Hypothetical data
</h2><span id='topic+d_example'></span>

<h3>Description</h3>

<p>Hypothetical data to be used in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(d_example)</code></pre>


<h3>Format</h3>

<p>A list with 8 elements representing 500 observations from a control group and 500 observations from a treatment group:
</p>

<dl>
<dt><code>s1.a</code></dt><dd><p>First surrogate marker measurement for treated observations.</p>
</dd>
<dt><code>s1.b</code></dt><dd><p>Second surrogate marker measurement for treated observations.</p>
</dd>
<dt><code>s1.c</code></dt><dd><p>Third surrogate marker measurement for treated observations.</p>
</dd>
<dt><code>y1</code></dt><dd><p>Primary outcome for treated observations.</p>
</dd>
<dt><code>s0.a</code></dt><dd><p>First surrogate marker measurement for control observations.</p>
</dd>
<dt><code>s0.b</code></dt><dd><p>Second surrogate marker measurement for control observations.</p>
</dd>
<dt><code>s0.c</code></dt><dd><p>Third surrogate marker measurement for control observations.</p>
</dd>
<dt><code>y0</code></dt><dd><p>Primary outcome for control observations.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(d_example)
names(d_example)
</code></pre>

<hr>
<h2 id='d_example_me'>
Hypothetical data with replicate measurements
</h2><span id='topic+d_example_me'></span>

<h3>Description</h3>

<p>Hypothetical data to be used in measurement error example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(d_example_me)</code></pre>


<h3>Format</h3>

<p>A list with 10 elements representing 500 observations from a control group and 500 observations from a treatment group:
</p>

<dl>
<dt><code>y1</code></dt><dd><p>Primary outcome for treated observations.</p>
</dd>
<dt><code>s1</code></dt><dd><p>Surrogate marker for treated observations.</p>
</dd>
<dt><code>s1_rep1</code></dt><dd><p>Replicate measurement of the surrogate marker for treated observations.</p>
</dd>
<dt><code>s1_rep2</code></dt><dd><p>Replicate measurement of the surrogate marker for treated observations.</p>
</dd>
<dt><code>s1_rep3</code></dt><dd><p>Replicate measurement of the surrogate marker for treated observations.</p>
</dd>
<dt><code>y0</code></dt><dd><p>Primary outcome for control observations.</p>
</dd>
<dt><code>s0</code></dt><dd><p>Surrogate marker for control observations.</p>
</dd>
<dt><code>s0_rep1</code></dt><dd><p>Replicate measurement of the surrogate marker for control observations.</p>
</dd>
<dt><code>s0_rep2</code></dt><dd><p>Replicate measurement of the surrogate marker for control observations.</p>
</dd>
<dt><code>s0_rep3</code></dt><dd><p>Replicate measurement of the surrogate marker for control observations.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(d_example_me)
names(d_example_me)
</code></pre>

<hr>
<h2 id='d_example_multiple'>
Hypothetical survival data with multiple surrogate markers
</h2><span id='topic+d_example_multiple'></span>

<h3>Description</h3>

<p>Hypothetical survival data with multiple surrogate markers to be used in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(d_example_multiple)</code></pre>


<h3>Format</h3>

<p>A list with 6 elements representing 1000 observations from a control group and 1000 observations from a treatment group:
</p>

<dl>
<dt><code>s1</code></dt><dd><p>Surrogate marker measurements for treated observations; these markers are measured at time = 0.5. For observations that experience the primary outcome or are censored before 0.5, the surrogate values are NA.</p>
</dd>
<dt><code>x1</code></dt><dd><p>The observed event or censoring time for treated observations; X  = min(T, C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>delta1</code></dt><dd><p>The indicator identifying whether the treated observation was observed to have the event or was censored; D =1*(T&lt;C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>s0</code></dt><dd><p>Surrogate marker measurements for control observations; these markers are measured at time = 0.5. For observations that experience the primary outcome or are censored before 0.5, the surrogate values are NA.</p>
</dd>
<dt><code>x0</code></dt><dd><p>The observed event or censoring time for control observations; X  = min(T, C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>delta0</code></dt><dd><p>The indicator identifying whether the control observation was observed to have the event or was censored; D =1*(T&lt;C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example_multiple)
names(d_example_multiple)
</code></pre>

<hr>
<h2 id='d_example_surv'>
Hypothetical survival data
</h2><span id='topic+d_example_surv'></span>

<h3>Description</h3>

<p>Hypothetical survival data to be used in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(d_example_surv)</code></pre>


<h3>Format</h3>

<p>A list with 8 elements representing 500 observations from a control group and 500 observations from a treatment group:
</p>

<dl>
<dt><code>s1</code></dt><dd><p>Surrogate marker measurement for treated observations; this marker is measured at time = 0.5. For observations that experience the primary outcome or are censored before 0.5, this value is NA.</p>
</dd>
<dt><code>x1</code></dt><dd><p>The observed event or censoring time for treated observations; X  = min(T, C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>delta1</code></dt><dd><p>The indicator identifying whether the treated observation was observed to have the event or was censored; D =1*(T&lt;C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>s0</code></dt><dd><p>Surrogate marker measurement for control observations; this marker is measured at time = 0.5. For observations that experience the primary outcome or are censored before 0.5, this value is NA.</p>
</dd>
<dt><code>x0</code></dt><dd><p>The observed event or censoring time for control observations; X  = min(T, C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>delta0</code></dt><dd><p>The indicator identifying whether the control observation was observed to have the event or was censored; D =1*(T&lt;C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>z1</code></dt><dd><p>A baseline covariate value for treated observations.</p>
</dd>
<dt><code>z0</code></dt><dd><p>A baseline covariate value for control observations.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example_surv)
names(d_example_surv)
</code></pre>

<hr>
<h2 id='delper.si'>
Helper function
</h2><span id='topic+helper.si'></span>

<h3>Description</h3>

<p>Helper function; should not be called directly by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper.si(yy,FUN,Yi,Vi=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delper.si_+3A_yy">yy</code></td>
<td>

<p>yy
</p>
</td></tr>
<tr><td><code id="delper.si_+3A_fun">FUN</code></td>
<td>

<p>FUN</p>
</td></tr>
<tr><td><code id="delper.si_+3A_yi">Yi</code></td>
<td>

<p>Yi</p>
</td></tr>
<tr><td><code id="delper.si_+3A_vi">Vi</code></td>
<td>

<p>Vi</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>out</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>

<hr>
<h2 id='delta.estimate'>
Calculates treatment effect
</h2><span id='topic+delta.estimate'></span>

<h3>Description</h3>

<p>This function calculates the treatment effect estimate, the difference in the average outcome in the treatment group minus the control group. This function is intended to be used for a fully observed continuous outcome. The user can also request a variance estimate, estimated using perturbating-resampling, and a 95% confidence interval. If a confidence interval is requested two versions are provided: a normal approximation based interval and a quantile based interval, both use perturbation-resampling. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.estimate(yone,yzero, var = FALSE, conf.int = FALSE, weight = NULL, 
weight.perturb = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta.estimate_+3A_yone">yone</code></td>
<td>

<p>numeric vector; primary outcome for treated observations.
</p>
</td></tr>
<tr><td><code id="delta.estimate_+3A_yzero">yzero</code></td>
<td>

<p>numeric vector; primary outcome for control observations.
</p>
</td></tr>
<tr><td><code id="delta.estimate_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether a variance estimate for delta is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.estimate_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether a 95% confidence interval for delta is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.estimate_+3A_weight">weight</code></td>
<td>

<p>a n1+n0 by x matrix of weights where n1 = length of yone and n0 = length of yzero, default is null; generally not supplied by use but only used by other functions.
</p>
</td></tr>
<tr><td><code id="delta.estimate_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a n1+n0 by x matrix of weights where n1 = length of yone and n0 = length of yzero, default is null; generally used for confidence interval construction and may be supplied by user.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Y^{(1)}</code> and <code class="reqn">Y^{(0)}</code> denote the primary outcome under the treatment and primary outcome under the control,respectively. The treatment effect, <code class="reqn">\Delta</code>, is the expected difference in <code class="reqn">Y^{(1)}</code> compared to <code class="reqn">Y^{(0)}</code>, <code class="reqn"> \Delta=E(Y^{(1)}-Y^{(0)}).</code> We estimate <code class="reqn">\Delta</code> as </p>
<p style="text-align: center;"><code class="reqn">\hat{\Delta}
= n_1^{-1} \sum_{i=1}^{n_1} Y_{1i}  - n_0^{-1} \sum_{i=1}^{n_0}  Y_{0i}</code>
</p>
<p> where <code class="reqn">Y_{1i}</code> is the observed primary outcome for person <code class="reqn">i</code> in the treated group, <code class="reqn">Y_{0i}</code> is the observed primary outcome for person <code class="reqn">i</code> in the control group, and <code class="reqn">n_1</code> and <code class="reqn">n_0</code> are the number of individuals in the treatment and control group, respectively. Randomized treatment assignment is assumed throughout this package.
</p>
<p>Variance estimation and confidence interval construction are performed using perturbation-resampling. Specifically, let <code class="reqn">\left \{ V^{(b)} = (V_{11}^{(b)}, ...V_{1n_1}^{(b)}, V_{01}^{(b)}, ...V_{0n_0}^{(b)})^T, b=1,....,D \right \}</code> be <code class="reqn">n \times D</code> independent copies of a positive random variables <code class="reqn">V</code> from a known distribution with unit mean and unit variance. Let
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Delta}^{(b)}  = \frac{  \sum_{i=1}^{n_1} V_{1i}^{(b)} Y_{1i}}{ \sum_{i=1}^{n_1} V_{1i}^{(b)}}  - \frac{  \sum_{i=1}^{n_0} V_{0i}^{(b)} Y_{0i}}{ \sum_{i=1}^{n_0} V_{0i}^{(b)}}.</code>
</p>
<p>The variance of <code class="reqn">\hat{\Delta}</code> is obtained as the empirical variance of <code class="reqn">\{\hat{\Delta}^{(b)}, b = 1,...,D\}.</code> In this package, we use weights generated from an Exponential(1) distribution and use <code class="reqn">D=500</code>.  We construct two versions of the <code class="reqn">95\%</code> confidence interval for <code class="reqn">\hat{\Delta}</code>: one based on a normal approximation confidence interval using the estimated variance and another taking the 2.5th and 97.5th empirical percentiles of <code class="reqn">\hat{\Delta}^{(b)}</code>.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}</code>, described above. </p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.normal</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example)
names(d_example)
delta.estimate(yone=d_example$y1, yzero=d_example$y0)
</code></pre>

<hr>
<h2 id='delta.multiple.surv'>
Calculates robust residual treatment effect accounting for multiple surrogate markers at a specified time and primary outcome information up to that specified time
</h2><span id='topic+delta.multiple.surv'></span>

<h3>Description</h3>

<p>This function calculates the robust estimate of the residual treatment effect accounting for multiple surrogate markers measured at <code class="reqn">t_0</code> and primary outcome information up to <code class="reqn">t_0</code> i.e. the hypothetical treatment effect if both the surrogate marker distributions at <code class="reqn">t_0</code> and survival up to <code class="reqn">t_0</code> in the treatment group look like the surrogate marker distributions and survival up to <code class="reqn">t_0</code> in the control group. Ideally this function is only used as a helper function and is not directly called. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.multiple.surv(xone, xzero, deltaone, deltazero, sone, szero, type =1, t, 
weight.perturb = NULL, landmark, extrapolate = FALSE, transform = FALSE,
approx = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta.multiple.surv_+3A_xone">xone</code></td>
<td>

<p>numeric vector, the observed event times in the treatment group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_xzero">xzero</code></td>
<td>

<p>numeric vector, the observed event times in the control group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_deltaone">deltaone</code></td>
<td>

<p>numeric vector, the event indicators for the treatment group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_deltazero">deltazero</code></td>
<td>

<p>numeric vector, the event indicators for the control group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_sone">sone</code></td>
<td>

<p>matrix of numeric values; surrogate marker measurements at <code class="reqn">t_0</code> for treated observations. If <code class="reqn">X_{1i}&lt;t_0</code>, then the surrogate marker measurements should be NA. 
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_szero">szero</code></td>
<td>

<p>matrix of numeric values; surrogate marker measurements at <code class="reqn">t_0</code> for control observations. If <code class="reqn">X_{0i}&lt;t_0</code>, then the surrogate marker measurements should be NA.
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_type">type</code></td>
<td>

<p>type of estimate; options are 1 = two-stage robust estimator, 2 = weighted two-stage robust estimator, 3 = double-robust estimator, 4 = two-stage model-based estimator, 5 = weighted estimator, 6 = double-robust model-bsed estimator; default is 1.
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_t">t</code></td>
<td>

<p>the time of interest.
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>weights used for perturbation resampling.
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time <code class="reqn">t_0</code> or time of surrogate marker measurement.
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_extrapolate">extrapolate</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use extrapolation.
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_transform">transform</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use a transformation for the surrogate marker psuedo-score. 
</p>
</td></tr>
<tr><td><code id="delta.multiple.surv_+3A_approx">approx</code></td>
<td>

<p>TRUE or FALSE indicating whether an approximation should be used when calculating the probability of censoring; most relevant in settings where the survival time of interest for the primary outcome is greater than the last observed event but before the last censored case, default is TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details are included in the documentation for R.multiple.surv.
</p>


<h3>Value</h3>

<p><code class="reqn">\hat{\Delta}_S(t,t_0)</code>, the residual treatment effect estimate accounting for multiple surrogarte markers measured at <code class="reqn">t_0</code> and primary outcome information up to <code class="reqn">t_0</code>.
</p>


<h3>Note</h3>

<p>If the treatment effect is not significant, the user will receive the following message: &quot;Warning: it looks like the treatment effect is not significant; may be difficult to interpret the residual treatment effect in this setting&quot;.</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., Cai, T., &amp; Tian, L. (2021). Evaluating multiple surrogate markers with censored data. Biometrics, 77(4), 1315-1327.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example_multiple)
names(d_example_multiple)
## Not run: 
delta.multiple.surv(xone = d_example_multiple$x1, xzero = d_example_multiple$x0, deltaone =
 d_example_multiple$delta1, deltazero = d_example_multiple$delta0, sone = 
 as.matrix(d_example_multiple$s1), szero = as.matrix(d_example_multiple$s0), 
 type =1, t = 1, landmark=0.5)

## End(Not run)

</code></pre>

<hr>
<h2 id='delta.s.estimate'>
Calculates model-based or robust residual treatment effect
</h2><span id='topic+delta.s.estimate'></span>

<h3>Description</h3>

<p>This function calculates the model-based or robust estimate of the residual treatment effect i.e. the hypothetical treatment effect if the distribution of the surrogate in the treatment group looks like the distribution of the surrogate in the control group. Ideally, this function is only used as a helper function and is not directly called. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.s.estimate(sone, szero, yone, yzero, weight.perturb = NULL, number="single",
type="robust", warn.te = FALSE, warn.support = FALSE, extrapolate = FALSE, 
transform = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta.s.estimate_+3A_sone">sone</code></td>
<td>

<p>numeric vector or matrix; surrogate marker for treated observations, assumed to be continuous. If there are multiple surrogates then this should be a matrix with <code class="reqn">n_1</code> (number of treated observations) rows and n.s (number of surrogate markers) columns.
</p>
</td></tr>
<tr><td><code id="delta.s.estimate_+3A_szero">szero</code></td>
<td>

<p>numeric vector or matrix; surrogate marker for control observations, assumed to be continuous. If there are multiple surrogates then this should be a matrix with <code class="reqn">n_0</code> (number of control observations) rows and n.s (number of surrogate markers) columns. 
</p>
</td></tr>
<tr><td><code id="delta.s.estimate_+3A_yone">yone</code></td>
<td>

<p>numeric vector; primary outcome for treated observations.
</p>
</td></tr>
<tr><td><code id="delta.s.estimate_+3A_yzero">yzero</code></td>
<td>

<p>numeric vector; primary outcome for control observations.
</p>
</td></tr>
<tr><td><code id="delta.s.estimate_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a <code class="reqn">n_1+n_0</code> by x matrix of weights where <code class="reqn">n_1 = </code> length of yone and <code class="reqn">n_0 = </code> length of yzero; generally used for variance estimation and confidence interval construction, default is null.
</p>
</td></tr>
<tr><td><code id="delta.s.estimate_+3A_number">number</code></td>
<td>

<p>specifies the number of surrogate markers; choices are &quot;multiple&quot; or &quot;single&quot;, default is &quot;single&quot;. 
</p>
</td></tr>
<tr><td><code id="delta.s.estimate_+3A_type">type</code></td>
<td>

<p>specifies the type of estimation; choices are &quot;robust&quot; or &quot;model&quot;, default is &quot;robust&quot;.
</p>
</td></tr>
<tr><td><code id="delta.s.estimate_+3A_warn.te">warn.te</code></td>
<td>

<p>value passed from R.s.estimate function to control warnings; user does not need to specify.
</p>
</td></tr>
<tr><td><code id="delta.s.estimate_+3A_warn.support">warn.support</code></td>
<td>

<p>value passed from R.s.estimate function to control warnings; user does not need to specify.
</p>
</td></tr>
<tr><td><code id="delta.s.estimate_+3A_extrapolate">extrapolate</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use extrapolation.
</p>
</td></tr>
<tr><td><code id="delta.s.estimate_+3A_transform">transform</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use a transformation for the surrogate marker. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details are included in the documentation for R.s.estimate.
</p>


<h3>Value</h3>

<p><code class="reqn">\hat{\Delta}_S</code>, the model-based or robust residual treatment effect estimate.
</p>


<h3>Note</h3>

<p>If the treatment effect is not significant, the user will receive the following message: &quot;Warning: it looks like the treatment effect is not significant; may be difficult to interpret the residual treatment effect in this setting&quot;. In the single marker case with the robust estimation approach, if the observed support of the surrogate marker for the control group is outside the observed support of the surrogate marker for the treatment group, the user will receive the following message: &quot;Warning: observed supports do not appear equal, may need to consider a transformation or extrapolation&quot;.</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., McDermott, M., Tian, L. (2015). Robust estimation of the proportion of treatment effect explained by surrogate marker information. Statistics in Medicine, 35(10):1637-1653.
</p>
<p>Wang, Y., &amp; Taylor, J. M. (2002). A measure of the proportion of treatment effect explained by a surrogate marker. Biometrics, 58(4), 803-812.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example)
names(d_example)
delta.s.estimate(yone=d_example$y1, yzero=d_example$y0, sone=d_example$s1.a, szero=
d_example$s0.a, number = "single", type = "robust")
delta.s.estimate(yone=d_example$y1, yzero=d_example$y0, sone=d_example$s1.a, szero=
d_example$s0.a, number = "single", type = "model")
delta.s.estimate(yone=d_example$y1, yzero=d_example$y0, sone=cbind(d_example$s1.a, 
d_example$s1.b, d_example$s1.c), szero=cbind(d_example$s0.a, d_example$s0.b, d_example$s0.c), 
number = "multiple", type = "robust")
delta.s.estimate(yone=d_example$y1, yzero=d_example$y0, sone=cbind(d_example$s1.a, 
d_example$s1.b, d_example$s1.c), szero=cbind(d_example$s0.a, d_example$s0.b, d_example$s0.c),
number = "multiple", type = "model")
</code></pre>

<hr>
<h2 id='delta.s.surv.estimate'>
Calculates robust residual treatment effect accounting for surrogate marker information measured at a specified time and primary outcome information up to that specified time
</h2><span id='topic+delta.s.surv.estimate'></span>

<h3>Description</h3>

<p>This function calculates the robust estimate of the residual treatment effect accounting for surrogate marker information measured at <code class="reqn">t_0</code> and primary outcome information up to <code class="reqn">t_0</code> i.e. the hypothetical treatment effect if both the surrogate marker distribution at <code class="reqn">t_0</code> and survival up to <code class="reqn">t_0</code> in the treatment group look like the surrogate marker distribution and survival up to <code class="reqn">t_0</code> in the control group. Ideally this function is only used as a helper function and is not directly called. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.s.surv.estimate(xone, xzero, deltaone, deltazero, sone, szero, t, 
weight.perturb = NULL, landmark, extrapolate = FALSE, transform = FALSE,
approx = T, warn.te = FALSE, warn.support = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta.s.surv.estimate_+3A_xone">xone</code></td>
<td>

<p>numeric vector, the observed event times in the treatment group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_xzero">xzero</code></td>
<td>

<p>numeric vector, the observed event times in the control group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_deltaone">deltaone</code></td>
<td>

<p>numeric vector, the event indicators for the treatment group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_deltazero">deltazero</code></td>
<td>

<p>numeric vector, the event indicators for the control group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_sone">sone</code></td>
<td>

<p>numeric vector; surrogate marker measurement at <code class="reqn">t_0</code> for treated observations, assumed to be continuous. If <code class="reqn">X_{1i}&lt;t_0</code>, then the surrogate marker measurement should be NA. 
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_szero">szero</code></td>
<td>

<p>numeric vector; surrogate marker measurement at <code class="reqn">t_0</code> for control observations, assumed to be continuous. If <code class="reqn">X_{1i}&lt;t_0</code>, then the surrogate marker measurement should be NA.
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_t">t</code></td>
<td>

<p>the time of interest.
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>weights used for perturbation resampling.
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time <code class="reqn">t_0</code> or time of surrogate marker measurement.
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_extrapolate">extrapolate</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use extrapolation.
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_transform">transform</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use a transformation for the surrogate marker. 
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_approx">approx</code></td>
<td>

<p>TRUE or FALSE indicating whether an approximation should be used when calculating the probability of censoring; most relevant in settings where the survival time of interest for the primary outcome is greater than the last observed event but before the last censored case, default is TRUE.
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_warn.te">warn.te</code></td>
<td>

<p>value passed from R.s.estimate function to control warnings; user does not need to specify.
</p>
</td></tr>
<tr><td><code id="delta.s.surv.estimate_+3A_warn.support">warn.support</code></td>
<td>

<p>value passed from R.s.estimate function to control warnings; user does not need to specify.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details are included in the documentation for R.s.surv.estimate.
</p>


<h3>Value</h3>

<p><code class="reqn">\hat{\Delta}_S(t,t_0)</code>, the robust residual treatment effect estimate accounting for surrogate marker information measured at <code class="reqn">t_0</code> and primary outcome information up to <code class="reqn">t_0</code>.
</p>


<h3>Note</h3>

<p>If the treatment effect is not significant, the user will receive the following message: &quot;Warning: it looks like the treatment effect is not significant; may be difficult to interpret the residual treatment effect in this setting&quot;. If the observed support of the surrogate marker for the control group is outside the observed support of the surrogate marker for the treatment group, the user will receive the following message: &quot;Warning: observed supports do not appear equal, may need to consider a transformation or extrapolation&quot;.</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., Cai, T., &amp; Tian, L. (2017). Evaluating surrogate marker information using censored data. Statistics in Medicine, 36(11), 1767-1782.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example_surv)
names(d_example_surv)

</code></pre>

<hr>
<h2 id='delta.surv.estimate'>
Calculates treatment effect in a survival setting
</h2><span id='topic+delta.surv.estimate'></span>

<h3>Description</h3>

<p>This function calculates the treatment effect in the survival setting i.e. the difference in survival at time t between the treatment group and the control group. The user can also request a variance estimate, estimated using perturbating-resampling, and a 95% confidence interval. If a confidence interval is requested two versions are provided: a normal approximation based interval and a quantile based interval, both use perturbation-resampling. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.surv.estimate(xone, xzero, deltaone, deltazero, t, var = FALSE, conf.int 
= FALSE, weight = NULL, weight.perturb = NULL, approx = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta.surv.estimate_+3A_xone">xone</code></td>
<td>

<p>numeric vector, the observed event times in the treatment group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.surv.estimate_+3A_xzero">xzero</code></td>
<td>

<p>numeric vector, the observed event times in the control group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.surv.estimate_+3A_deltaone">deltaone</code></td>
<td>

<p>numeric vector, the event indicators for the treatment group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.surv.estimate_+3A_deltazero">deltazero</code></td>
<td>

<p>numeric vector, the event indicators for the control group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.surv.estimate_+3A_t">t</code></td>
<td>

<p>the time of interest.
</p>
</td></tr>
<tr><td><code id="delta.surv.estimate_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether a variance estimate for delta is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.surv.estimate_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether a 95% confidence interval for delta is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.surv.estimate_+3A_weight">weight</code></td>
<td>

<p>a <code class="reqn">n_1+n_0</code> by <code class="reqn">x</code> matrix of weights where <code class="reqn">n_1 =</code> sample size in treatment group and <code class="reqn">n_0 =</code> sample size in the control group, default is null; generally not supplied by use but only used by other functions.
</p>
</td></tr>
<tr><td><code id="delta.surv.estimate_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a <code class="reqn">n_1+n_0</code> by <code class="reqn">x</code> matrix of weights where <code class="reqn">n_1 =</code>sample size in treatment group and <code class="reqn">n_0 =</code> sample size in the control group, default is null; generally used for confidence interval construction and may be supplied by user.
</p>
</td></tr>
<tr><td><code id="delta.surv.estimate_+3A_approx">approx</code></td>
<td>

<p>TRUE or FALSE indicating whether an approximation should be used when calculating the probability of censoring; most relevant in settings where the survival time of interest for the primary outcome is greater than the last observed event but before the last censored case, default is TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">G</code> be the binary treatment indicator with <code class="reqn">G=1</code> for treatment and <code class="reqn">G=0</code> for control and we assume throughout that subjects are randomly assigned to a treatment group at baseline. Let <code class="reqn">T</code> denote the time of the primary outcome of interest, death for example. We use potential outcomes notation such that <code class="reqn">T^{(g)}</code> denotes the time of the primary outcome under treatment <code class="reqn">G = g</code>. We define the treatment effect, <code class="reqn">\Delta(t)</code>, as the difference in survival rates by time <code class="reqn">t</code> under treatment versus control,
</p>
<p style="text-align: center;"><code class="reqn"> \Delta(t)=E\{ I(T^{(1)}&gt;t)\} - E\{I(T^{(0)}&gt;t)\} = P(T^{(1)}&gt;t) - P(T^{(0)}&gt;t)</code>
</p>

<p>where <code class="reqn">t&gt;t_0</code>
</p>
<p>Due to censoring, our data consist of <code class="reqn">n_1</code> observations <code class="reqn">\{(X_{1i}, \delta_{1i}), i=1,...,n_1\}</code> from the treatment group <code class="reqn">G=1</code> and <code class="reqn">n_0</code> observations <code class="reqn">\{(X_{0i}, \delta_{0i}), i=1,...,n_0\}</code> from the control group <code class="reqn">G=0</code> where <code class="reqn">X_{gi} = \min(T_{gi}, C_{ gi})</code>,  <code class="reqn">\delta_{gi} = I(T_{gi} &lt; C_{gi})</code>, and <code class="reqn">C_{gi}</code> denotes the censoring time for <code class="reqn">g= 1,0</code>, for individual <code class="reqn">i</code>. Throughout, we estimate the treatment effect <code class="reqn">\Delta(t)</code> as
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Delta}(t)  = n_1^{-1} \sum_{i=1}^{n_1} \frac{I(X_{1i}&gt;t)}{\hat{W}^C_1(t)} - n_0^{-1} \sum_{i=1}^{n_0} \frac{I(X_{0i}&gt;t)}{\hat{W}^C_0(t)}</code>
</p>

<p>where  <code class="reqn">\hat{W}^C_g(\cdot)</code> is the Kaplan-Meier estimator of survival for censoring for <code class="reqn">g=1,0.</code> 
</p>
<p>Variance estimation and confidence interval construction are performed using perturbation-resampling. Specifically, let <code class="reqn">\left \{ V^{(b)} = (V_{11}^{(b)}, ...V_{1n_1}^{(b)}, V_{01}^{(b)}, ...V_{0n_0}^{(b)})^T, b=1,....,D \right \}</code> be <code class="reqn">n \times D</code> independent copies of a positive random variables <code class="reqn">V</code> from a known distribution with unit mean and unit variance. Let
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Delta}^{(b)} (t) = \frac{  \sum_{i=1}^{n_1} V_{1i}^{(b)} I(X_{1i}&gt;t)}{ \sum_{i=1}^{n_1} V_{1i}^{(b)} \hat{W}_1^{C(b)}(t)}  -\frac{  \sum_{i=1}^{n_0} V_{0i}^{(b)} I(X_{0i}&gt;t)}{ \sum_{i=1}^{n_0} V_{0i}^{(b)} \hat{W}_0^{C(b)}(t)}.</code>
</p>
<p> In this package, we use weights generated from an Exponential(1) distribution and use <code class="reqn">D=500</code>. The variance of <code class="reqn">\hat{\Delta}(t)</code> is obtained as the empirical variance of <code class="reqn">\{\hat{\Delta}(t)^{(b)}, b = 1,...,D\}.</code> We construct two versions of the <code class="reqn">95\%</code>confidence interval for <code class="reqn">\hat{\Delta}(t)</code>: one based on a normal approximation confidence interval using the estimated variance and another taking the 2.5th and 97.5th empirical percentiles of <code class="reqn">\hat{\Delta}(t)^{(b)}</code>.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}(t)</code>, described above. </p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}(t)</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.normal</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example_surv)
names(d_example_surv)
delta.surv.estimate(xone = d_example_surv$x1, xzero = d_example_surv$x0,  
deltaone = d_example_surv$delta1, deltazero = d_example_surv$delta0, t = 3)
</code></pre>

<hr>
<h2 id='delta.t.surv.estimate'>
Calculates robust residual treatment effect accounting only for primary outcome information up to a specified time
</h2><span id='topic+delta.t.surv.estimate'></span>

<h3>Description</h3>

<p>This function calculates the robust estimate of the residual treatment effect accounting only for primary outcome information up to <code class="reqn">t_0</code> i.e. the hypothetical treatment effect if survival up to <code class="reqn">t_0</code> in the treatment group looks like survival up to <code class="reqn">t_0</code> in the control group. Ideally this function is only used as a helper function and is not directly called. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.t.surv.estimate(xone, xzero, deltaone, deltazero, t, weight.perturb = NULL,
landmark, approx = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta.t.surv.estimate_+3A_xone">xone</code></td>
<td>

<p>numeric vector, the observed event times in the treatment group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.t.surv.estimate_+3A_xzero">xzero</code></td>
<td>

<p>numeric vector, the observed event times in the control group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.t.surv.estimate_+3A_deltaone">deltaone</code></td>
<td>

<p>numeric vector, the event indicators for the treatment group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.t.surv.estimate_+3A_deltazero">deltazero</code></td>
<td>

<p>numeric vector, the event indicators for the control group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.t.surv.estimate_+3A_t">t</code></td>
<td>

<p>the time of interest.
</p>
</td></tr>
<tr><td><code id="delta.t.surv.estimate_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>weights used for perturbation resampling.
</p>
</td></tr>
<tr><td><code id="delta.t.surv.estimate_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time <code class="reqn">t_0</code> or time of surrogate marker measurement.
</p>
</td></tr>
<tr><td><code id="delta.t.surv.estimate_+3A_approx">approx</code></td>
<td>

<p>TRUE or FALSE indicating whether an approximation should be used when calculating the probability of censoring; most relevant in settings where the survival time of interest for the primary outcome is greater than the last observed event but before the last censored case, default is TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details are included in the documentation for R.t.surv.estimate.
</p>


<h3>Value</h3>

<p><code class="reqn">\hat{\Delta}_T(t,t_0)</code>, the robust residual treatment effect estimate accounting only for survival up to <code class="reqn">t_0</code>.
</p>


<h3>Note</h3>

<p>If the treatment effect is not significant, the user will receive the following message: &quot;Warning: it looks like the treatment effect is not significant; may be difficult to interpret the residual treatment effect in this setting&quot;.</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., Cai, T., &amp; Tian, L. (2017). Evaluating surrogate marker information using censored data. Statistics in Medicine, 36(11), 1767-1782.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example_surv)
names(d_example_surv)

</code></pre>

<hr>
<h2 id='fieller.calculate.me'>
Constructs Fieller's confidence interval.
</h2><span id='topic+fieller.calculate.me'></span>

<h3>Description</h3>

<p>Constructs Fieller's confidence interval - closed form, not using perturbation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fieller.calculate.me(a, B, var.mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fieller.calculate.me_+3A_a">a</code></td>
<td>

<p>value of numerator
</p>
</td></tr>
<tr><td><code id="fieller.calculate.me_+3A_b">B</code></td>
<td>

<p>value of denominator
</p>
</td></tr>
<tr><td><code id="fieller.calculate.me_+3A_var.mat">var.mat</code></td>
<td>

<p>variance-covariance matrix for a and B
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a confidence interval for 1-a/B when closed form variance and covariance estimates are available. See documention for R.s.estimate.me for more detail.
</p>


<h3>Value</h3>

<p>Returns a vector of length 2, lower bound of the 95% confidence interval and upper bound of the 95% confidence interval.
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., Garcia, T. P., Prentice, R. L., &amp; Carroll, R. J. (2022). Robust methods to correct for measurement error when evaluating a surrogate marker. Biometrics, 78(1), 9-23.
</p>
<p>Fieller, Edgar C. (1954). Some problems in interval estimation. Journal of the Royal Statistical Society. Series B (Methodological), 175-185.
</p>
<p>Fieller, E. C. (1940). The biological standardization of insulin. Supplement to the Journal of the Royal Statistical Society, 1-64.
</p>

<hr>
<h2 id='fieller.ci'>
Constructs Fieller's confidence interval.
</h2><span id='topic+fieller.ci'></span>

<h3>Description</h3>

<p>Constructs Fieller's confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fieller.ci(perturb.delta.s, perturb.delta, delta.s, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fieller.ci_+3A_perturb.delta.s">perturb.delta.s</code></td>
<td>

<p>numeric vector; the perturbed values for <code class="reqn">\hat{\Delta}_S</code>, the residual treatment effect estimate, used in variance estimation and confidence interval construction.
</p>
</td></tr>
<tr><td><code id="fieller.ci_+3A_perturb.delta">perturb.delta</code></td>
<td>

<p>numeric vector; the perturbed values for <code class="reqn">\hat{\Delta}</code>, the treatment effect estimate, used in variance estimation and confidence interval construction.
</p>
</td></tr>
<tr><td><code id="fieller.ci_+3A_delta.s">delta.s</code></td>
<td>

<p>the residual treatment effect, <code class="reqn">\Delta_S</code>, estimate, <code class="reqn">\hat{\Delta}_S</code>.
</p>
</td></tr>
<tr><td><code id="fieller.ci_+3A_delta">delta</code></td>
<td>

<p>the treatment effect, <code class="reqn">\Delta</code>, estimate, <code class="reqn">\hat{\Delta}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See documention for R.s.estimate for more detail.
</p>


<h3>Value</h3>

<p>Returns a vector of length 2, lower bound of the 95% confidence interval and upper bound of the 95% confidence interval.
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Fieller, Edgar C. (1954). Some problems in interval estimation. Journal of the Royal Statistical Society. Series B (Methodological), 175-185.
</p>
<p>Fieller, E. C. (1940). The biological standardization of insulin. Supplement to the Journal of the Royal Statistical Society, 1-64.
</p>
<p>Parast, L., McDermott, M., Tian, L. (2016). Robust estimation of the proportion of treatment effect explained by surrogate marker information. Statistics in Medicine, 35(10):1637-1653.
</p>

<hr>
<h2 id='Kern.FUN'>
Calculates kernel matrix
</h2><span id='topic+Kern.FUN'></span>

<h3>Description</h3>

<p>Helper function; this calculates the kernel matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kern.FUN(zz, zi, bw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kern.FUN_+3A_zz">zz</code></td>
<td>

<p>zz
</p>
</td></tr>
<tr><td><code id="Kern.FUN_+3A_zi">zi</code></td>
<td>

<p>zi
</p>
</td></tr>
<tr><td><code id="Kern.FUN_+3A_bw">bw</code></td>
<td>

<p>bandwidth
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the kernel matrix
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>

<hr>
<h2 id='me.variance.estimate'>
Estimates measurement error variance given replicate data. 
</h2><span id='topic+me.variance.estimate'></span>

<h3>Description</h3>

<p>Estimates measurement error variance given replicate data using a simple components of variance analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>me.variance.estimate(replicates)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="me.variance.estimate_+3A_replicates">replicates</code></td>
<td>

<p>matrix of data where each row indicates a subject and each column is a replicated measurement; columns can have NAs when subjects have different numbers of measurements. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates measurement error variance given replicate data using a simple components of variance analysis. 
</p>


<h3>Value</h3>

<p>estimate of measurement error variance
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Carroll, R. J., Ruppert, D., Crainiceanu, C. M., and Stefanski, L. A. (2006). Measurement
error in nonlinear models: a modern perspective. Chapman and Hall/CRC.
</p>
<p>Parast, L., Garcia, T. P., Prentice, R. L., &amp; Carroll, R. J. (2022). Robust methods to correct for measurement error when evaluating a surrogate marker. Biometrics, 78(1), 9-23.
</p>

<hr>
<h2 id='perturb.nu.vector'>
Helper for augmentation function
</h2><span id='topic+perturb.nu.vector'></span>

<h3>Description</h3>

<p>Helper for augmentation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturb.nu.vector(mat, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perturb.nu.vector_+3A_mat">mat</code></td>
<td>

</td></tr>
<tr><td><code id="perturb.nu.vector_+3A_weights">weights</code></td>
<td>

</td></tr>
</table>

<hr>
<h2 id='pred.smooth'>
Calculates expected outcome for control group surrogate values
</h2><span id='topic+pred.smooth'></span>

<h3>Description</h3>

<p>Helper function; calculates the expected outcome for control group surrogate values using treatment group surrogate and outcome information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.smooth(zz, zi.one, bw = NULL, y1, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred.smooth_+3A_zz">zz</code></td>
<td>

<p>surrogate values in the treatment group; used to estimate conditional mean function
</p>
</td></tr>
<tr><td><code id="pred.smooth_+3A_zi.one">zi.one</code></td>
<td>

<p>surrogate values in the control group
</p>
</td></tr>
<tr><td><code id="pred.smooth_+3A_bw">bw</code></td>
<td>

<p>bandwidth
</p>
</td></tr>
<tr><td><code id="pred.smooth_+3A_y1">y1</code></td>
<td>

<p>outcome in the treatment group
</p>
</td></tr>
<tr><td><code id="pred.smooth_+3A_weight">weight</code></td>
<td>

<p>weight
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details are included in the documentation for R.s.estimate
</p>


<h3>Value</h3>

<p>expected outcome for each surrogate value in the control group
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., McDermott, M., Tian, L. (2016). Robust estimation of the proportion of treatment effect explained by surrogate marker information. Statistics in medicine, 35(10):1637-1653.
</p>

<hr>
<h2 id='pred.smooth.surv'>
Calculates the conditional probability of survival for control group values
</h2><span id='topic+pred.smooth.surv'></span>

<h3>Description</h3>

<p>Helper function; calculates the estimated probability of survival for control 
group for control group surrogate values using treatment group surrogate and 
outcome information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.smooth.surv(xone.f, deltaone.f, sone.f, szero.one, myt, weight.pred, 
extrapolate, transform, ps.weight = NULL, warn.support = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred.smooth.surv_+3A_xone.f">xone.f</code></td>
<td>

<p>observed event times in the treatment group
</p>
</td></tr>
<tr><td><code id="pred.smooth.surv_+3A_deltaone.f">deltaone.f</code></td>
<td>

<p>censoring indicators in the treatment group
</p>
</td></tr>
<tr><td><code id="pred.smooth.surv_+3A_sone.f">sone.f</code></td>
<td>

<p>surrogate marker values in the treatment group
</p>
</td></tr>
<tr><td><code id="pred.smooth.surv_+3A_szero.one">szero.one</code></td>
<td>

<p>surrogate marker values in the control group
</p>
</td></tr>
<tr><td><code id="pred.smooth.surv_+3A_myt">myt</code></td>
<td>

<p>time of interest
</p>
</td></tr>
<tr><td><code id="pred.smooth.surv_+3A_weight.pred">weight.pred</code></td>
<td>

<p>weight used for perturbation resampling
</p>
</td></tr>
<tr><td><code id="pred.smooth.surv_+3A_extrapolate">extrapolate</code></td>
<td>

<p>TRUE or FALSE; indicates whether local constant extrapolation should be used, default is FALSE
</p>
</td></tr>
<tr><td><code id="pred.smooth.surv_+3A_transform">transform</code></td>
<td>

<p>TRUE or FALSE; indicates whether a transformation should be used, default is FALSE
</p>
</td></tr>
<tr><td><code id="pred.smooth.surv_+3A_ps.weight">ps.weight</code></td>
<td>

<p>vector of propensity score weights to be used in the multiple marker setting, default is NULL
</p>
</td></tr>
<tr><td><code id="pred.smooth.surv_+3A_warn.support">warn.support</code></td>
<td>

<p>value passed from R.s.estimate function to control warnings; user does not need to specify.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details are included in the documentation for R.s.surv.estimate and R.multiple.surv
</p>


<h3>Value</h3>

<p>conditional probability of survival past t for control group
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>

<hr>
<h2 id='R.multiple.surv'>
Calculates the proportion of treatment effect explained by multiple surrogate markers measured at a specified time and primary outcome information up to that specified time
</h2><span id='topic+R.multiple.surv'></span>

<h3>Description</h3>

<p>This function calculates the proportion of treatment effect on the primary outcome explained by multiple surrogate markers measured at <code class="reqn">t_0</code> and primary outcome information up to <code class="reqn">t_0</code>.  The user can also request a variance estimate, estimated using perturbating-resampling, and a 95% confidence interval. If a confidence interval is requested three versions are provided: a normal approximation based interval, a quantile based interval and Fieller's confidence interval, all using perturbation-resampling. The user can also request an estimate of the incremental value of the surrogate marker information. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.multiple.surv(xone, xzero, deltaone, deltazero, sone, szero, type =1, t, 
weight.perturb = NULL, landmark, extrapolate = FALSE, transform = FALSE, 
conf.int = FALSE, var = FALSE, incremental.value = FALSE, approx = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R.multiple.surv_+3A_xone">xone</code></td>
<td>

<p>numeric vector, the observed event times in the treatment group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_xzero">xzero</code></td>
<td>

<p>numeric vector, the observed event times in the control group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_deltaone">deltaone</code></td>
<td>

<p>numeric vector, the event indicators for the treatment group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_deltazero">deltazero</code></td>
<td>

<p>numeric vector, the event indicators for the control group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_sone">sone</code></td>
<td>

<p>matrix of numeric values; surrogate marker measurements at <code class="reqn">t_0</code> for treated observations. If <code class="reqn">X_{1i}&lt;t_0</code>, then the surrogate marker measurements should be NA. 
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_szero">szero</code></td>
<td>

<p>matrix of numeric values; surrogate marker measurements at <code class="reqn">t_0</code> for control observations. If <code class="reqn">X_{0i}&lt;t_0</code>, then the surrogate marker measurements should be NA.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_type">type</code></td>
<td>

<p>type of estimate; options are 1 = two-stage robust estimator, 2 = weighted two-stage robust estimator, 3 = double-robust estimator, 4 = two-stage model-based estimator, 5 = weighted estimator, 6 = double-robust model-based estimator; default is 1.
</p>
</td></tr>  
<tr><td><code id="R.multiple.surv_+3A_t">t</code></td>
<td>

<p>the time of interest.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>weights used for perturbation resampling.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time <code class="reqn">t_0</code> or time of surrogate marker measurement.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_extrapolate">extrapolate</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use extrapolation.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_transform">transform</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use a transformation for the surrogate marker pseudo-score. 
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether a 95% confidence interval for delta is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether a variance estimate is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_incremental.value">incremental.value</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user would like to see the incremental value of the surrogate marker information, default is FALSE.
</p>
</td></tr>
<tr><td><code id="R.multiple.surv_+3A_approx">approx</code></td>
<td>

<p>TRUE or FALSE indicating whether an approximation should be used when calculating the probability of censoring; most relevant in settings where the survival time of interest for the primary outcome is greater than the last observed event but before the last censored case, default is TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">G \in \{A, B\}</code> be the binary treatment indicator and we assume that subjects are randomly assigned to either treatment group <code class="reqn">A</code> or <code class="reqn">B</code> at baseline. Let <code class="reqn">T</code> denote the time to the occurrence of the primary outcome, death for example, and <code class="reqn">S = (S_1,S_2,...,S_k)^{T}</code> denote the vector of <code class="reqn">k</code> surrogate markers measured at a given time <code class="reqn">t_0</code>. Let <code class="reqn">T^{(g)}</code> and <code class="reqn">S^{(g)}</code> denote the counterfactual  event time and surrogate marker measurements under treatment <code class="reqn">G = g</code> for <code class="reqn">g \in \{A, B\}</code>.  In practice, we only observe <code class="reqn">(T, S)=(T^{(A)}, S^{(A)})</code> or <code class="reqn">(T^{(B)}, S^{(B)})</code> depending on whether <code class="reqn">G=A</code> or <code class="reqn">B.</code> The treatment effect, <code class="reqn">\Delta(t)</code>, is the treatment difference in survival rates at time <code class="reqn">t &gt; t_0</code>,
<code class="reqn">\Delta(t)=E\{ I(T^{(A)}&gt;t)\} - E\{I(T^{(B)}&gt;t)\} = P(T^{(A)}&gt;t) - P(T^{(B)}&gt;t)</code>
where <code class="reqn">I(\cdot)</code> is the indicator function. For individuals who are censored or experience the primary outcome before <code class="reqn">t_0</code>, we assume that their <code class="reqn">S</code> information is not available.
</p>
<p>The surrogate marker information at time <code class="reqn">t_0</code> is defined as a combination of the observed information on <code class="reqn">I(T &gt;t_0)</code> and the observed <code class="reqn">S</code> at <code class="reqn">t_0</code>, denoted by <code class="reqn">Q_{t_0}  = \{Q_{t_0}^{(g)}, g = A, B\}</code>, where 
<code class="reqn">Q_{t_0} ^{(g)} = \{ T ^{(g)} \wedge  t_0, S ^{(g)} I(T ^{(g)} &gt; t_0)\}</code>. With information on <code class="reqn">Q_{t_0}</code>, the residual treatment effect is defined as:
<code class="reqn">\Delta_{S}(t,t_0) = E\{ I(T ^{(A)} &gt; t) - I(T ^{(B)}&gt;t)  \mid Q_{t_0}^{(A)} = Q_{t_0}^{(B)} \}
 =P(T^{(B)} &gt; t_0) \int_{S}  \psi_A(t \mid S, t_0) dF_{B}(S \mid t_0) -P(T^{(B)}&gt; t)</code>
where <code class="reqn">S = (s_1, ..., s_k)^{T}</code>, 
<code class="reqn">F_{g}(S \mid t_0)  = P(S^{(g)}\le S \mid T^{(g)}&gt;t_0),</code>  
<code class="reqn">\psi_g(t\mid S,t_0) = P(T^{(g)}&gt; t\mid S^{(g)}=S, T^{(g)}&gt; t_0).</code> The proportion of the treatment effect on the primary outcome that is explained by the treatment effect on <code class="reqn">Q_{t_0}</code>  is <code class="reqn">R_{S}(t,t_0)=1-\Delta_{S}(t,t_0)/\Delta</code>. This function provides 6 different estimators for <code class="reqn">R_{S}(t,t_0)</code> using censored data. 
</p>
<p>Due to censoring, the observed data consist of <code class="reqn">n</code> observations <code class="reqn">\{(G_i, X_{i}, \delta_{i}, S_{i}I(X_{i} &gt; t_0)), i=1,...,n\}</code> from the two treatment groups, where <code class="reqn">X_{i} = \min(T_{i}, C_{i})</code>, <code class="reqn">\delta_{i} = I(T_{i} &lt; C_{i})</code>,  and <code class="reqn">C_{i}</code> denotes the censoring time for the <code class="reqn">i</code>th subject. We assume independent censoring i.e., <code class="reqn">(T_i, S_i) \perp C_i \mid G_i</code>. For ease of notation, we also let <code class="reqn">\{(X_{gi}, \delta_{gi}, S_{gi}I(X_{gi} &gt; t_0)), i=1,...,n_g\}</code> denote <code class="reqn">n_g = \sum_{i=1}^n I(G_i = g)</code> observations from treatment group <code class="reqn">g \in \{A,B\},</code> where <code class="reqn">X_{gi}=\min(T_{gi}, C_{gi})</code> and <code class="reqn">\delta_{gi}=I(T_{gi}&lt;C_{gi}).</code> Without loss of generality, we assume that <code class="reqn">\bar{\pi}_g = n_g/n \to \pi_g \in (0,1)</code> as <code class="reqn">n\to \infty</code>. Throughout, we estimate the treatment effect <code class="reqn">\Delta(t) =P(T^{(A)}&gt;t) - P(T^{(B)}&gt;t)</code> as
<code class="reqn"> \hat{\Delta}(t)  = n_A^{-1} \sum_{i=1}^{n_A} \frac{I(X_{Ai}&gt;t)}{\hat{W}^C_A(t)} - n_B^{-1} \sum_{i=1}^{n_B} \frac{I(X_{Bi}&gt;t)}{\hat{W}^C_B(t)}</code>
where  <code class="reqn">\hat{W}^C_g(t)</code> is the Kaplan-Meier estimator of <code class="reqn">W^C_g(t) = P(C_{g} &gt; t)</code>. 
</p>
<p>We first describe the two-stage robust estimator which involves a two-stage procedure combining the use of a working model and a nonparametric estimation procedure for <code class="reqn">\Delta_{S}(t,t_0)</code>. The idea is simply to summarize <code class="reqn">S</code> into a univariate score <code class="reqn">U</code> and then construct a nonparametric estimator for <code class="reqn">R_S(t,t_0)</code> treating <code class="reqn">U</code> as <code class="reqn">S</code>. To construct <code class="reqn">U</code>, we approximate the conditional distribution of <code class="reqn">T^{(A)} \mid S^{(A)}, T^{(A)} &gt; t_0</code> by using a working semiparametric  model such as the landmark proportional hazards model <code class="reqn">q_A(S) = P(T^{(A)} &gt;t \mid T^{(A)} &gt;t_0, S^{(A)}) = \exp\{-\Lambda_0(t|t_0) \exp(\beta ^{T} S^{(A)}) \},  t&gt;t_0, </code>
where <code class="reqn"> \Lambda_0(t|t_0)</code> is the unspecified baseline cumulative hazard function for <code class="reqn">T^{(A)}</code> conditional on <code class="reqn">\{T^{(A)} &gt; t_0\}</code> and <code class="reqn">\beta</code> is an unknown vector of coefficients. Let <code class="reqn">\hat{\beta}</code> be the maximizer of the corresponding log partial likelihood function and <code class="reqn">\hat{\Lambda}_0(t|t_0)</code> be the Breslow-type estimate of baseline hazard. If one were to assume that this working model is correctly specified, then a consistent estimate of <code class="reqn">\Delta_{S}(t,t_0)</code> would simply be: <code class="reqn">\hat{\Delta}_{S}^M=n_B^{-1} \sum_{i=1}^{n_B} [ \exp \{ -\hat{\Lambda}_0(t|t_0)\exp(\hat{\beta} ^{T} S_{Bi}) \} \frac{I(X_{Bi} &gt; t_0)}{\hat{W}^C_B(t_0)}  -   \frac{I(X_{Bi} &gt; t)}{\hat{W}^C_B(t)}].</code> We refer to this estimate as the two-stage model-based estimator (option 4 for type).
Instead of relying on correct specification of this model, we use the resulting  score <code class="reqn">U = \beta_0^{T}S</code> as a univariate &ldquo;pseudo-marker&quot; to summarize the <code class="reqn">k</code> surrogates. In the second stage, to estimate <code class="reqn">\Delta_{S}(t,t_0)</code>, we apply a nonparametric approach with <code class="reqn">S</code> represented by the univariate marker <code class="reqn">U</code>.  Specifically, we use a  kernel Nelson-Aalen estimator to nonparametrically estimate  <code class="reqn">\phi_A(t|u, t_0)=P(T^{(A)}&gt; t\mid U^{(A)}=u, T^{(A)}&gt; t_0) = \exp\{-\Lambda_A(t|u, t_0 )\}</code> as <code class="reqn">\hat \phi_A(t|u, t_0)  = \exp\{-\hat{\Lambda}_A(t|u, t_0) \}</code>, where
<code class="reqn">\hat{\Lambda}_A(t|u, t_0) = \int_{t_0}^t \frac{\sum_{i=1}^{n_A} I(X_{Ai}&gt;t_0) K_h\{\gamma(\hat{U}_{Ai}) - \gamma(u)\}dN_{Ai}(z)}{\sum_{i=1}^{n_A}  I(X_{Ai}&gt;t_0) K_h\{\gamma(\hat{U}_{Ai}) - \gamma(u)\} Y_{Ai}(z)},</code>
<code class="reqn">\hat{U}_{Ai} = \hat{\beta} ^{T} S_{Ai}</code>, <code class="reqn">\hat{U}_{Bi} = \hat{\beta} ^{T} S_{Bi}</code>, <code class="reqn">Y_{Ai} = I(X_{Ai} \geq t)</code>, <code class="reqn">N_{Ai}(t) = I(X_{Ai} \leq t) \delta_{Ai},  K(\cdot)</code> is a smooth symmetric density function, <code class="reqn">K_h(x) = K(x/h)/h,</code> and <code class="reqn">\gamma(\cdot)</code> is a given monotone transformation function. We then estimate <code class="reqn">\Delta_{S}(t,t_0)</code> as
<code class="reqn">\hat{\Delta}_{S}(t,t_0) = n_B^{-1} \sum_{i=1}^{n_B} [\hat{\phi}_A(t|\hat{U}_{Bi},t_0) \frac{I(X_{Bi} &gt; t_0)}{\hat{W}^C_B(t_0)}  -   \frac{I(X_{Bi} &gt; t)}{\hat{W}^C_B(t)}]</code> and <code class="reqn">\hat{R}_{S}(t,t_0) =1- \hat{\Delta}_{S}(t,t_0)/\hat{\Delta}(t).</code> We refer to this estimate as the two-stage robust estimator (option 1 for type).
</p>
<p>The next estimator borrows ideas from the extensive causal inference literature focusing on double robust estimators  two-stage weighted estimator with a propensity score weight explicitly balancing the two treatment groups with respect to the distribution of <code class="reqn">S</code>. The weighting enables us to &ldquo;adjust&quot; the distribution of <code class="reqn">S^{(A)}</code> before constructing the conditional survival estimate <code class="reqn">\hat \phi_A(t|u, t_0).</code> This approach results in a double-robust estimator of <code class="reqn">\Delta_{S}(t, t_0)</code>, which is consistent when either <code class="reqn">U^{(A)}</code> captures all the information about the relationship between <code class="reqn">I(T^{(A)}\ge t)</code> and <code class="reqn">S^{(A)}</code> or the propensity score model for <code class="reqn">\pi(S,t_0)=P(G_i=B|S_i=S, T_{i} &gt; t_0)</code> is correctly specified. While <code class="reqn">\pi(S,t_0)</code> depends on <code class="reqn">t_0</code>, for simplicity, we drop <code class="reqn">t_0</code> from our notation and simply use <code class="reqn">\pi(S)</code>.
</p>
<p>Regression models can be imposed to obtain estimates for <code class="reqn">\pi(S)</code>. For example, a simple logistic regression model can be imposed for 
<code class="reqn">\tilde{\pi}(S)=P(G_i=B|S_i=S, X_{i}&gt;t_0)</code> with
<code class="reqn">logit\{\tilde{\pi}(S)\} = \alpha_0 + \alpha_1 ^{T} S,</code>
where <code class="reqn">\alpha_0</code> and <code class="reqn">\alpha_1</code> are estimated only among those with   <code class="reqn">X_{gi} &gt; t_0</code> to account for censoring. The propensity score of interest, <code class="reqn">\pi(S),</code> can be derived from <code class="reqn">\tilde{\pi}(S)</code> directly since 
<code class="reqn">logit\{\pi(S)\}=logit\{\tilde{\pi}(S)\} + \log\{W_A^C(t_0)/W_B^C(t_0)\},</code>
which follows from the assumption that <code class="reqn">(T_{gi}, S_{gi}) \perp C_{gi}.</code> We then modify  the above expression by weighting observations with the estimated <code class="reqn">L(S_{Ai})=\pi(S_{Ai})/\{1-\pi(S_{Ai})\}</code>  and obtain
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Lambda}^w_A(t|u, t_0)  = \int_{t_0}^t \frac{\sum_{i=1}^{n_A} \hat{L}(S_{Ai}) I(X_{Ai}&gt;t_0) K_h\{\gamma(\hat{U}_{Ai}) - \gamma(u)\}dN_{Ai}(z)}{\sum_{i=1}^{n_A}  \hat{L}(S_{Ai}) I(X_{Ai}&gt;t_0) K_h\{\gamma(\hat{U}_{Ai}) - \gamma(u)\} Y_{Ai}(z)},</code>
</p>
<p>,
where <code class="reqn">\hat{L}(S_{gi}) = \exp(\hat{\alpha}_0+\hat{\alpha}_1^{T} S_{gi})\hat{W}^C_B(t_0)/\hat{W}^C_A(t_0).</code>
</p>
<p>Subsequently, we define
<code class="reqn">\hat{\Delta}^w_{S}(t,t_0) = n_B^{-1} \sum_{i=1}^{n_B} [\hat{\phi}^w_A(t|\hat{U}_{Bi},t_0) \frac{I(X_{Bi} &gt; t_0)}{\hat{W}^C_B(t_0)}  -   \frac{I(X_{Bi} &gt; t)}{\hat{W}^C_B(t)}]</code> and <code class="reqn">\hat{R}^w_{S}(t,t_0) =1- \hat{\Delta}^w_{S}(t,t_0)/\hat{\Delta}(t)</code>
where <code class="reqn">\hat \phi^w_A(t|t_0,u)  = \exp\{-\hat{\Lambda}^w_A(t|t_0,u) \}.</code> We refer to this estimate as the weighted two-stage robust estimator (option 2 for type).
</p>
<p>While the two-stage weighted estimator reflects one way to enhance the robustness of an initial estimator, the idea of combining a propensity-score type model and a regression-type model has certainly been extensively studied in the causal inference literature and a more familiar double-robust estimator can be constructed as: <code class="reqn">\hat{\Delta}_{S}^{DR}(t,t_0)  = n^{-1} [\sum_{i=1}^{n_A}\frac{I(X_{Ai}&gt;t)}{\hat{W}_{A}^C(t)\bar{\pi}_B} \hat{L}(S_{Ai}) - \sum_{i=1}^{n_B} \frac{I(X_{Bi}&gt;t)}{\hat{W}_{B}^C(t)\bar{\pi}_B}  ]  - n^{-1} [ \sum_{i=1}^{n_A} \frac{ \hat{\phi}_A(t\mid\hat{U}_{Ai},t_0) I(X_{Ai} &gt; t_0) }{\hat{W}_{A}^C(t_0)\bar{\pi}_B}  \hat{L}(S_{Ai}) - \sum_{i=1}^{n_B}\frac{ \hat{\phi}_A(t\mid \hat{U}_{Bi},t_0) I(X_{Bi} &gt; t_0) }{\hat{W}_{B}^C(t_0)\bar{\pi}_B} ] </code>
and <code class="reqn">\hat{R}_{S}^{DR}(t,t_0) =1- \hat{\Delta}_{S}^{DR}(t,t_0)/\hat{\Delta}(t)</code>, where  <code class="reqn">\hat{\phi}_A(t|\hat{U}_{gi},t_0)</code> is the (unweighted) estimate of <code class="reqn">\phi_A(t\mid u,t_0)</code> used in <code class="reqn">\hat{\Delta}_{S}(t,t_0)</code>. We refer to this estimate as the double robust estimator (option 3 for type).
</p>
<p>The weighted estimator (option type 5) is defined as: 
<code class="reqn"> \hat{\Delta}^{PS}_{S}(t,t_0) =  n^{-1} \sum_{i=1}^n  \{\frac{I(X_{i}&gt;t)}{\hat{W}_{G_i}^C(t)\bar{\pi}_B}  [ I(G_i = A)\hat{L}(S_{Ai})   - I(G_i = B )  ]  \} </code>
and <code class="reqn">\hat{R}^{PS}_{S}(t,t_0) =1- \hat{\Delta}^{PS}_{S}(t,t_0)/\hat{\Delta}(t).</code> This estimator  completely relies on the correct specification of <code class="reqn">\pi(S)</code>. The double-robust model-based estimator (option 6 for type) is defined as <code class="reqn">\hat{\Delta}_{S}^{DR2}(t,t_0)</code>  and <code class="reqn">\hat{R}_{S}^{DR2}(t,t_0) =1- \hat{\Delta}_{S}^{DR2}(t,t_0)/\hat{\Delta}(t)</code> which are constructed parallel to the construction of  <code class="reqn">\hat{\Delta}_{S}^{DR}(t,t_0)</code> i.e., a combination of  <code class="reqn">\hat{\Delta}_{S}^M(t,t_0)</code> and <code class="reqn">\hat{R}^{PS}_{S}(t,t_0)</code>.
</p>
<p>Variance estimates are obtained using perturbation resampling. If a confidence interval is requested three versions are provided: a normal approximation based interval, a quantile based interval and Fieller's confidence interval, all using perturbation-resampling. An estimate of the incremental value of the surrogate marker information can also be requested; this essentially compared the proportion explained by the surrogate information vs. the proportion explained by <code class="reqn">T</code> alone up to <code class="reqn">t_0</code>. Details can be found in Parast, L., Cai, T., &amp; Tian, L. (2021). Evaluating multiple surrogate markers with censored data. Biometrics, 77(4), 1315-1327.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}(t)</code>, described in delta.estimate documentation.</p>
</td></tr>
<tr><td><code>delta.s</code></td>
<td>
<p>the residual treatment effect estimate, <code class="reqn">\hat{\Delta}_S(t,t_0)</code>.</p>
</td></tr>
<tr><td><code>R.s</code></td>
<td>
<p>the estimated proportion of treatment effect explained by the set of markers, <code class="reqn">\hat{R}_S(t,t_0)</code>.</p>
</td></tr>
<tr><td><code>delta.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}(t)</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>delta.s.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}_S(t,t_0)</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>R.s.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{R}_S(t,t_0)</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.normal.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.normal.delta.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_S(t,t_0)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.delta.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_S(t,t_0)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.normal.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.fieller.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)</code> based on Fieller's approach; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>delta.t</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}_T(t,t_0)</code>; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>R.t</code></td>
<td>
<p>the estimated proportion of treatment effect explained by survival only, <code class="reqn">\hat{R}_T(t,t_0)</code>; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>incremental.value</code></td>
<td>
<p>the estimate of the incremental value of the surrogate markers, <code class="reqn">\hat{IV}_S(t,t_0)</code>; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>delta.t.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}_T(t,t_0)</code>; if var = TRUE or conf.int = TRUE and  incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>R.t.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{R}_T(t,t_0)</code>; if var = TRUE or conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>incremental.value.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{IV}_S(t,t_0)</code>; if var = TRUE or conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.normal.delta.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_T(t,t_0)</code> based on a normal approximation; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.delta.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_T(t,t_0)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.normal.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on a normal approximation; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.fieller.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on Fieller's approach; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.normal.iv</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{IV}_S(t,t_0)</code> based on a normal approximation; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.iv</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{IV}_S(t,t_0)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>If the treatment effect is not significant, the user will receive the following message: &quot;Warning: it looks like the treatment effect is not significant; may be difficult to interpret the residual treatment effect in this setting&quot;.</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., Cai, T., &amp; Tian, L. (2017). Evaluating surrogate marker information using censored data. Statistics in Medicine, 36(11), 1767-1782.
</p>
<p>Parast, L., Cai, T., &amp; Tian, L. (2021). Evaluating multiple surrogate markers with censored data. Biometrics, 77(4), 1315-1327.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example_multiple)
names(d_example_multiple)
## Not run: 
R.multiple.surv(xone = d_example_multiple$x1, xzero = d_example_multiple$x0, deltaone = 
d_example_multiple$delta1, deltazero = d_example_multiple$delta0, sone = 
as.matrix(d_example_multiple$s1), szero = as.matrix(d_example_multiple$s0), 
type =1, t = 1, landmark=0.5)
R.multiple.surv(xone = d_example_multiple$x1, xzero = d_example_multiple$x0, deltaone = 
d_example_multiple$delta1, deltazero = d_example_multiple$delta0, sone = 
as.matrix(d_example_multiple$s1), szero = as.matrix(d_example_multiple$s0), 
type =1, t = 1, landmark=0.5, conf.int = T)	
R.multiple.surv(xone = d_example_multiple$x1, xzero = d_example_multiple$x0, deltaone = 
d_example_multiple$delta1, deltazero = d_example_multiple$delta0, sone = 
as.matrix(d_example_multiple$s1), szero = as.matrix(d_example_multiple$s0), 
type =3, t = 1, landmark=0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='R.s.estimate'>
Calculates the proportion of treatment effect explained
</h2><span id='topic+R.s.estimate'></span>

<h3>Description</h3>

<p>This function calculates the proportion of treatment effect on the primary outcome explained by the treatment effect on the surrogate marker(s). This function is intended to be used for a fully observed continuous outcome. The user can also request a variance estimate and a 95% confidence interval, both estimated using perturbating-resampling. If a confidence interval is requested three versions are provided: a normal approximation based interval, a quantile based interval, and Fieller's confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.s.estimate(sone, szero, yone, yzero, var = FALSE, conf.int = FALSE, 
weight.perturb = NULL, number = "single", type = "robust",extrapolate = FALSE, 
transform = FALSE,warn.te = FALSE, warn.support = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R.s.estimate_+3A_sone">sone</code></td>
<td>

<p>numeric vector or matrix; surrogate marker for treated observations, assumed to be continuous. If there are multiple surrogates then this should be a matrix with <code class="reqn">n_1</code> (number of treated observations) rows and n.s (number of surrogate markers) columns.
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_szero">szero</code></td>
<td>

<p>numeric vector; surrogate marker for control observations, assumed to be continuous.If there are multiple surrogates then this should be a matrix with <code class="reqn">n_0</code> (number of control observations) rows and n.s (number of surrogate markers) columns. 
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_yone">yone</code></td>
<td>

<p>numeric vector; primary outcome for treated observations, assumed to be continuous.
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_yzero">yzero</code></td>
<td>

<p>numeric vector; primary outcome for control observations, assumed to be continuous.
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether a variance estimate is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether a 95% confidence interval is requested, default is FALSE
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a <code class="reqn">n_1+n_0</code> by <code class="reqn">x</code> matrix of weights where <code class="reqn">n_1 = </code> length of yone and <code class="reqn">n_0 = </code>  length of yzero; used for perturbation-resampling, default is null.
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_number">number</code></td>
<td>

<p>specifies the number of surrogate markers; choices are &quot;multiple&quot; or &quot;single&quot;, default is &quot;single&quot; 
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_type">type</code></td>
<td>

<p>specifies the type of estimation; choices are &quot;robust&quot; or &quot;model&quot; or &quot;freedman&quot;, default is &quot;robust&quot;
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_extrapolate">extrapolate</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use extrapolation.
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_transform">transform</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use a transformation for the surrogate marker. 
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_warn.te">warn.te</code></td>
<td>

<p>value to control warnings; user does not need to specify.
</p>
</td></tr>
<tr><td><code id="R.s.estimate_+3A_warn.support">warn.support</code></td>
<td>

<p>value to control warnings; user does not need to specify.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Y^{(1)}</code> and <code class="reqn">Y^{(0)}</code> denote the primary outcome under the treatment and primary outcome under the control,respectively. Let <code class="reqn">S^{(1)}</code> and <code class="reqn">S^{(0)}</code> denote the surrogate marker under the treatment and the surrogate marker under the control,respectively. The residual treatment effect is defined as
</p>
<p style="text-align: center;"><code class="reqn"> \Delta_S=\int_{-\infty}^{\infty}  E(Y^{(1)}|S^{(1)}=s) dF_0(s)  - \int_{-\infty}^{\infty} E(Y^{(0)}|S^{(0)}=s) dF_0(s),</code>
</p>

<p>where <code class="reqn">\Delta_S(s)= E(Y^{(1)}|S^{(1)}=s)-E(Y^{(0)}|S^{(0)}=s)</code>  and <code class="reqn">F_0(\cdot)</code> is the marginal cumulative distribution function of <code class="reqn">S^{(0)}</code>, the surrogate marker measure under the control. The proportion of treatment effect explained by the surrogate marker, which we denote by <code class="reqn">R_S</code>, can be expressed using a contrast between <code class="reqn">\Delta_S</code> and <code class="reqn">\Delta</code>:
</p>
<p style="text-align: center;"><code class="reqn">R_S=\{\Delta-\Delta_S\}/\Delta=1-\Delta_S/\Delta.</code>
</p>
<p>   The definition and estimation of <code class="reqn">\Delta</code> is described in the delta.estimate documentation.
</p>
<p>A flexible model-based approach to estimate <code class="reqn">\Delta_S</code> in the single marker setting is to specify:
</p>
<p style="text-align: center;"><code class="reqn">E(S^{(0)})=\alpha_0 \quad\mbox{and}\quad E(S^{(1)})-E(S^{(0)}) = \alpha_1,</code>
</p>

<p style="text-align: center;"><code class="reqn"> E(Y^{(0)} | S^{(0)}) = \beta_0 + \beta_1 S^{(0)}  \quad \mbox{and} \quad  E(Y^{(1)} | S^{(1)}) = (\beta_0 +\beta_2)+ (\beta_1+\beta_3) S^{(1)}. </code>
</p>

<p>It can be shown that when these models hold, <code class="reqn">\Delta_S = \beta_2 + \beta_3 \alpha_0</code>. Thus, reasonable estimates for <code class="reqn">\Delta_S</code> and <code class="reqn">R_S</code> using this approach would be <code class="reqn">\hat{\Delta}_S =  \hat{\beta}_2 + \hat{\beta}_3 \hat{\alpha}_0</code> and <code class="reqn">\hat{R}_S = 1-\hat{\Delta}_S / \hat{\Delta}.</code> 
</p>
<p>For robust estimation of <code class="reqn">\Delta_S</code> in the single marker setting, we estimate <code class="reqn">\mu_1(s) = E(Y^{(1)}|S^{(1)}=s)</code> nonparametrically using kernel smoothing: 
</p>
<p style="text-align: center;"><code class="reqn">\hat{\mu}_1(s) = \frac{\sum_{i=1}^{n_1} K_h\left (S_{1i}-s \right ) Y_{1i} }{\sum_{i=1}^{n_1} K_h\left (S_{1i}-s \right )}</code>
</p>

<p>where <code class="reqn">S_{1i}</code> is the observed <code class="reqn">S^{(1)}</code> for person <code class="reqn">i</code>, <code class="reqn">Y_{1i}</code> is the observed <code class="reqn">Y^{(1)}</code> for person <code class="reqn">i</code>, <code class="reqn">K(\cdot)</code> is a smooth symmetric density function with finite support, <code class="reqn">K_h(\cdot)=K(\cdot/h)/h</code> and <code class="reqn">h</code> is a specified bandwidth. As in most nonparametric functional estimation procedures, the choice of the smoothing parameter <code class="reqn">h</code>  is critical. To eliminate the impact of the bias of the conditional mean function on the resulting estimator, we require the standard undersmoothing assumption of <code class="reqn">h=O(n_1^{-\delta})</code> with <code class="reqn">\delta \in (1/4,1/3).</code>  To obtain an appropriate <code class="reqn">h</code> we first use bw.nrd to obtain <code class="reqn">h_{opt}</code>; and then we let <code class="reqn">h = h_{opt}n_1^{-c_0}</code>  with <code class="reqn">c_0 = 0.25</code>. We then estimate <code class="reqn">\Delta_S</code> as
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Delta}_S= \sum_{i=1}^{n_0} \frac{\hat{\mu}_1(S_{0i})- Y_{0i}}{n_0}</code>
</p>
<p> where <code class="reqn">S_{0i}</code> is the observed <code class="reqn">S^{(0)}</code> for person <code class="reqn">i</code> and <code class="reqn">Y_{0i}</code> is the observed <code class="reqn">Y^{(0)}</code> for person <code class="reqn">i</code>. Lastly, we estimate <code class="reqn">R_S</code> as <code class="reqn">\hat{R}_S = 1-\hat{\Delta}_S/\hat{\Delta}</code>.
</p>
<p>This function also allows for estimation of <code class="reqn">R_S</code> using Freedman's approach.  Let <code class="reqn">Y</code> denote the primary outcome, <code class="reqn">S</code> denote the surrogate marker, and <code class="reqn">G</code> denote the treatment group (0 for control, 1 for treatment). Freedman's approach to calculating the proportion of treatment effect explained by the surrogate marker is to fit the following two regression models:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|G) = \gamma_0 + \gamma_1 I(G=1) \quad \mbox{and} \quad E(Y|G, S) = \gamma_{0S} + \gamma_{1S}I(G=1) + \gamma_{2S} S </code>
</p>

<p>and estimating the proportion of treatment effect explained, denoted by <code class="reqn">R_S</code>, as <code class="reqn"> 1-\hat{\gamma}_{1S}/\hat{\gamma}_1</code>.
</p>
<p>This function also estimates <code class="reqn">R_S</code> in a multiple marking setting. A flexible model-based approach to estimate <code class="reqn">\Delta_S</code> in the multiple marker setting is to specify models for <code class="reqn">E(Y|G, S)</code> and <code class="reqn">E(S_j | G)</code> for each <code class="reqn">S_j</code> in <code class="reqn">S = \{S_1,...S_p\}</code> (where p is the number of surrogate markers). Without loss of generality, consider the case where there are three surrogate markers, <code class="reqn">S = \{S_1, S_2, S_3\}</code> and one specifies the following linear models:
</p>
<p style="text-align: center;"><code class="reqn">E(Y^{(0)} | S^{(0)}) = \beta_0 + \beta_1 S_1^{(0)} + \beta_2 S_2^{(0)} +  \beta_3 S_3^{(0)}</code>
</p>

<p style="text-align: center;"><code class="reqn">E(Y^{(1)} | S^{(1)}) = (\beta_0+\beta_4) + (\beta_1+\beta_5) S_1^{(1)} + (\beta_2+\beta_6) S_2^{(1)} +  (\beta_3+\beta_7) S_3^{(1)}</code>
</p>

<p style="text-align: center;"><code class="reqn"> E(S_j^{(0)}) = \alpha_j, ~~~~j=1,2,3.</code>
</p>
 
<p>It can be shown that when these models hold 
</p>
<p style="text-align: center;"><code class="reqn">\Delta_{S} = \beta_4 + \beta_5\alpha_1 + \beta_6 \alpha_2 + \beta_7 \alpha_3.</code>
</p>
<p> Thus, reasonable estimates for <code class="reqn">\Delta_{S}</code> and <code class="reqn">R_{S}</code> here would be easily obtained by replacing the unknown regression coefficients in the models above by their consistent estimators. 
</p>
<p>For robust estimation of S <code class="reqn">\Delta_S</code> in the multiple marker setting, we use a two-stage procedure combining the model-based approach and the nonparametric estimation procedure from the single marker setting. Specifically, we use a working semiparametric  model: </p>
<p style="text-align: center;"><code class="reqn">E(Y^{(1)}|S^{(1)}=S)=\beta_0 + \beta_1 S_1^{(1)} + \beta_2 S_2^{(1)} +  \beta_3 S_3^{(1)}</code>
</p>
 
<p>and define <code class="reqn">Q^{(1)} = \hat{\beta}_0 + \hat{\beta}_1 S_1^{(1)} + \hat{\beta}_2 S_2^{(1)} +  \hat{\beta}_3 S_3^{(1)}</code> and <code class="reqn">Q^{(0)} = \hat{\beta}_0 + \hat{\beta}_1 S_1^{(0)} + \hat{\beta}_2 S_2^{(0)} +  \hat{\beta}_3 S_3^{(0)}</code> to reduce the dimension of <code class="reqn">S</code> in the first stage  and in the second stage, we apply the robust approach used in the single marker setting to  estimate its surrogacy. 
</p>
<p>To use Freedman's approach in the presence of multiple markers, the markers are simply additively entered into the second regression model.
</p>
<p>Variance estimation and confidence interval construction are performed using perturbation-resampling. Specifically, let <code class="reqn">\left \{ V^{(b)} = (V_{11}^{(b)}, ...V_{1n_1}^{(b)}, V_{01}^{(b)}, ...V_{0n_0}^{(b)})^T, b=1,....,D \right \}</code> be <code class="reqn">n \times D</code> independent copies of a positive random variables <code class="reqn">V</code> from a known distribution with unit mean and unit variance. Let
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Delta}^{(b)}  = \frac{  \sum_{i=1}^{n_1} V_{1i}^{(b)} Y_{1i}}{ \sum_{i=1}^{n_1} V_{1i}^{(b)}}  - \frac{  \sum_{i=1}^{n_0} V_{0i}^{(b)} Y_{0i}}{ \sum_{i=1}^{n_0} V_{0i}^{(b)}}.</code>
</p>
<p> The variance of <code class="reqn">\hat{\Delta}</code> is obtained as the empirical variance of <code class="reqn">\{\hat{\Delta}^{(b)}, b = 1,...,D\}.</code> In this package, we use weights generated from an Exponential(1) distribution and use <code class="reqn">D=500</code>. Variance estimates for <code class="reqn">\hat{\Delta}_S</code> and <code class="reqn">\hat{R}_S</code> are calculated similarly. We construct two versions of the <code class="reqn">95\%</code> confidence interval for each estimate: one based on a normal approximation confidence interval using the estimated variance and another taking the 2.5th and 97.5th empirical percentile of the perturbed quantities.  In addition, we use Fieller's method to obtain a third confidence interval for <code class="reqn">R_S</code> as
</p>
<p style="text-align: center;"><code class="reqn">\left\{1-r:  \frac{(\hat{\Delta}_S-r\hat{\Delta})^2}{\hat{\sigma}_{11}-2r\hat\sigma_{12}+r^2\hat\sigma_{22}} \le c_{\alpha}\right\},</code>
</p>

<p>where <code class="reqn">\hat{\Sigma}=(\hat\sigma_{ij})_{1\le i,j\le 2}</code> and <code class="reqn">c_\alpha</code> is the <code class="reqn">(1-\alpha)</code>th percentile of
</p>
<p style="text-align: center;"><code class="reqn">\left\{\frac{\{\hat{\Delta}^{(b)}_S-(1-\hat R_S)\hat{\Delta}^{(b)}\}^2}{\hat{\sigma}_{11}-2(1-\hat R_S)\hat\sigma_{12}+(1-\hat R_S)^2\hat\sigma_{22}}, b=1, \cdots, C\right\}</code>
</p>

<p>where <code class="reqn">\alpha=0.05</code>.
</p>
<p>Note that if the observed supports for S are not the same, then <code class="reqn">\hat{\mu}_1(s)</code> for <code class="reqn">S_{0i} = s</code> outside the support of <code class="reqn">S_{1i}</code> may return NA (depending on the bandwidth). If extrapolation = TRUE, then the   <code class="reqn">\hat{\mu}_1(s)</code> values for these surrogate values are set to the closest non-NA value. If transform = TRUE, then <code class="reqn">S_{1i}</code> and <code class="reqn">S_{0i}</code> are transformed such that the new transformed values, <code class="reqn">S^{tr}_{1i}</code> and <code class="reqn">S^{tr}_{0i}</code> are defined as: <code class="reqn">S^{tr}_{gi} = F([S_{gi} - \mu]/\sigma)</code> for <code class="reqn">g=0,1</code> where <code class="reqn">F(\cdot)</code> is the cumulative distribution function for a standard normal random variable, and <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> are the sample mean and standard deviation, respectively, of <code class="reqn">(S_{1i}, S_{0i})^T</code>.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table role = "presentation">
<tr><td><code>R.s</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{R}_S</code>, described above.</p>
</td></tr>
<tr><td><code>R.s.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{R}_S</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.normal.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.fieller.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S</code> based on Fieller's approach, described above; if conf.int = TRUE.</p>
</td></tr> 
</table>
<p>For all options other then &quot;freedman&quot;, the following are also returned:
</p>
<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}</code>, described in delta.estimate documentation.</p>
</td></tr>
<tr><td><code>delta.s</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}_S</code>, described above.</p>
</td></tr>
<tr><td><code>delta.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>delta.s.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}_S</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.normal.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.normal.delta.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_S</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.delta.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_S</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE.</p>
</td></tr> 
</table>


<h3>Note</h3>

<p> If the treatment effect is not significant, the user will receive the following message: &quot;Warning: it looks like the treatment effect is not significant; may be difficult to interpret the proportion of treatment effect explained in this setting&quot;. In the single marker case with the robust estimation approach, if the observed support of the surrogate marker for the control group is outside the observed support of the surrogate marker for the treatment group, the user will receive the following message: &quot;Warning: observed supports do not appear equal, may need to consider a transformation or extrapolation&quot;</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Freedman, L. S., Graubard, B. I., &amp; Schatzkin, A. (1992). Statistical validation of intermediate endpoints for chronic diseases. Statistics in medicine, 11(2), 167-178.
</p>
<p>Parast, L., McDermott, M., Tian, L. (2016). Robust estimation of the proportion of treatment effect explained by surrogate marker information. Statistics in Medicine, 35(10):1637-1653.
</p>
<p>Wang, Y., &amp; Taylor, J. M. (2002). A measure of the proportion of treatment effect explained by a surrogate marker. Biometrics, 58(4), 803-812.
</p>
<p>Fieller, Edgar C. (1954). Some problems in interval estimation. Journal of the Royal Statistical Society. Series B (Methodological), 175-185.
</p>
<p>Fieller, E. C. (1940). The biological standardization of insulin. Supplement to the Journal of the Royal Statistical Society, 1-64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example)
names(d_example)
R.s.estimate(yone=d_example$y1, yzero=d_example$y0, sone=d_example$s1.a, szero=d_example$s0.a, 
number = "single", type = "robust")
R.s.estimate(yone=d_example$y1, yzero=d_example$y0, sone=cbind(d_example$s1.a,d_example$s1.b, 
d_example$s1.c), szero=cbind(d_example$s0.a, d_example$s0.b, d_example$s0.c), 
number = "multiple", type = "model")
</code></pre>

<hr>
<h2 id='R.s.estimate.me'>
Calculates the proportion of treatment effect explained correcting for measurement error in the surrogate marker
</h2><span id='topic+R.s.estimate.me'></span>

<h3>Description</h3>

<p>This function calculates the proportion of treatment effect on the primary outcome explained by the treatment effect on a surrogate marker, correcting for measurement error in the surrogate marker. This function is intended to be used for a fully observed continuous outcome. The user must specify what type of estimation they would like (parametric or nonparametric estimation of the proportion explained, denoted by R) and what estimator they would like (see below for details). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.s.estimate.me(sone, szero, yone, yzero, parametric = FALSE, estimator = "n", 
me.variance, extrapolate = TRUE, transform = FALSE, naive = FALSE, Ronly = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R.s.estimate.me_+3A_sone">sone</code></td>
<td>

<p>numeric vector or matrix; surrogate marker for treated observations, assumed to be continuous. If there are multiple surrogates then this should be a matrix with <code class="reqn">n_1</code> (number of treated observations) rows and n.s (number of surrogate markers) columns.
</p>
</td></tr>
<tr><td><code id="R.s.estimate.me_+3A_szero">szero</code></td>
<td>

<p>numeric vector; surrogate marker for control observations, assumed to be continuous.If there are multiple surrogates then this should be a matrix with <code class="reqn">n_0</code> (number of control observations) rows and n.s (number of surrogate markers) columns. 
</p>
</td></tr>
<tr><td><code id="R.s.estimate.me_+3A_yone">yone</code></td>
<td>

<p>numeric vector; primary outcome for treated observations, assumed to be continuous.
</p>
</td></tr>
<tr><td><code id="R.s.estimate.me_+3A_yzero">yzero</code></td>
<td>

<p>numeric vector; primary outcome for control observations, assumed to be continuous.
</p>
</td></tr>
<tr><td><code id="R.s.estimate.me_+3A_parametric">parametric</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants the parametric approach to be used (TRUE) or nonparametric (FALSE).
</p>
</td></tr>
<tr><td><code id="R.s.estimate.me_+3A_estimator">estimator</code></td>
<td>

<p>options are &quot;d&quot;,&quot;q&quot;,&quot;n&quot; for parametric and &quot;q&quot;,&quot;n&quot; for nonparametric; &quot;d&quot; stands for the disattenuated estimator, &quot;q&quot; stands for the SIMEX estimator with quadratic extrapolation, &quot;n&quot; stands for the SIMEX estimator with a nonlinear extrapolation. Note that the nonlinear extrapolation may have convergence issues with a small sample size; if this occurs, please consider using quadratic extrapolation instead.
</p>
</td></tr>
<tr><td><code id="R.s.estimate.me_+3A_me.variance">me.variance</code></td>
<td>

<p>the variance of the measurement error; must be provided.
</p>
</td></tr>
<tr><td><code id="R.s.estimate.me_+3A_extrapolate">extrapolate</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use extrapolation.
</p>
</td></tr>
<tr><td><code id="R.s.estimate.me_+3A_transform">transform</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use a transformation for the surrogate marker. 
</p>
</td></tr>
<tr><td><code id="R.s.estimate.me_+3A_naive">naive</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants the naive estimate (not correcting for measurement error) to also be calculated
</p>
</td></tr>
<tr><td><code id="R.s.estimate.me_+3A_ronly">Ronly</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants only R (and corresponding variance and confidence intervals) to be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While there are many methods available to quantify the value of a surrogate marker, most assume that the marker is measured without error. This function calculates the proportion of treatment effect on the primary outcome explained by the treatment effect on a surrogate marker, correcting for measurement error in the surrogate marker. The user can choose either the parametric framework or nonparametric framework for estmation. Within the parametric framework there are three options for measurement error correction: the disattenuated estimator, the SIMEX estimator with quadratic extrapolation, and the SIMEX estimator with nonlinear extrapolation. Within the nonparametric framework there are two options for measurement error correction: the SIMEX estimator with quadratic extrapolation and the SIMEX estimator with nonlinear extrapolation. We describe each below. 
</p>
<p>Let <code class="reqn">G</code> be the binary treatment indicator with <code class="reqn">G=1</code> indicating treatment and <code class="reqn">G=0</code> indicating control (or placebo).  We assume throughout that subjects are randomly assigned to treatment or control at baseline. Let <code class="reqn">Y</code> and <code class="reqn">S</code> denote the continuous primary outcome and continuous surrogate marker, respectively, where <code class="reqn">S</code> is measured post-baseline and is assumed to be a biomarker, clinical measurement, psychological test score, or other  physiological measurement. In the absence of measurement error, the observed data consists of <code class="reqn">\{Y_i, S_i, G_i\}</code> for <code class="reqn">i \in \{1,...,n\}</code>. With measurement error, instead of observing <code class="reqn">S</code> we observe <code class="reqn">W = S + U</code>, where <code class="reqn">E(U|S) = 0</code> and the variance of <code class="reqn">U</code> is <code class="reqn">\sigma_u^2</code>. Such measurement error may be attributable to, for example, laboratory error. Thus, our observed data will consist of <code class="reqn">\{Y_i, W_i, G_i\}</code> for <code class="reqn">i \in \{1,...,n\}</code>. Throughout, we assume that  <code class="reqn">\sigma_u^2</code> is known. Here, we are interested in estimating the proprtion of the treatment effect on the primary outcome that is explained by the treatment effect on the surrogate marker, denoted as <code class="reqn">R_S</code>. 
</p>
<p>To estimate <code class="reqn">R_S</code> parametrically, we assume the following models <code class="reqn">E(Y|G) = \beta_0 + \beta_1 G</code> and <code class="reqn">E(Y|G,S) = \beta_0^* + \beta_1^*G + \beta_2^* S</code>. It can be shown that if these models hold,  <code class="reqn">R_S=1-\beta_1^*/\beta_1</code>. When <code class="reqn">W = S+U</code> is available instead of <code class="reqn">S</code>, this measurement error does not affect estimation of <code class="reqn">\beta_1</code>, but it does affect estimation of <code class="reqn">\beta_1^*</code>, and <code class="reqn">\beta_2^*</code>. Since estimation of <code class="reqn">R_S</code> relies on estimation of <code class="reqn">\beta_1</code> and <code class="reqn">\beta_1^*</code>, we focus on the effect of measurement error on <code class="reqn">\beta_1^*</code> estimation. The attenuation bias for <code class="reqn">\hat \beta_1^*</code> and <code class="reqn">\hat R</code> can be written out in closed form when the proportion of treatment effect is parametrically estimated as described above, when these specified models hold, and when the surrogate marker <code class="reqn">S</code> is measured with error. There exist two methods to eliminate this bias when estimating <code class="reqn">R_S</code>. Taking advantage of the fact that we can express the attenuation bias in closed form, the first is a straightforward disattenuated estimator: <code class="reqn">\hat \beta _{1A} = \hat{\beta}_1^* -  \frac{  \hat{\beta}_2^* \{\Omega^2_{W} \Omega_{GW}-\Omega_{GW}(\Omega^2_{W} - \sigma_u^2)\}}{\Omega^2_{G}(\Omega^2_{W} - \sigma_u^2)-\Omega_{GW}\Omega_{GW}}</code> and <code class="reqn">\hat{R}_{A} = 1- \left [ \hat{\beta}_1^* -  \frac{  \hat{\beta}_2^* \{\Omega^2_{W} \Omega_{GW}-\Omega_{GW}(\Omega^2_{W} - \sigma_u^2)\}}{\Omega^2_{G}(\Omega^2_{W} - \sigma_u^2)-\Omega_{GW}\Omega_{GW}}  \right] / \hat{\beta}_1</code> where <code class="reqn">\Omega^2</code> denotes the sample variance or covariance.
</p>
<p>The second method to eliminate this bias uses Simulation Extrapolation (SIMEX) estimation, which is a simulation-based method that involves first generating additional measurement error and observing how it affects the bias of the parameter estimate of interest, and then extrapolating this information to a setting with no measurement error. To incorporate SIMEX estimation within our surrogate marker framework, we define <code class="reqn">W_{b,i}(\lambda) = W_i + \lambda^{1/2} \sigma_u \epsilon_{i,b}</code>
for <code class="reqn">b=1,...,B</code> where <code class="reqn">B=50</code>, <code class="reqn">\epsilon_{i,b} \sim N(0,1)</code>, <code class="reqn">\sigma_u</code> is assumed known, and <code class="reqn">\lambda \in (0,0.25,0.5,0.75,1.0,</code> <code class="reqn">1.25,1.5,1.75,2.0)</code> and for each iteration <code class="reqn">b</code> and <code class="reqn">\lambda</code> value, obtaining  <code class="reqn">\hat \beta_{1b}^*(\lambda)</code> by fitting the regression model: <code class="reqn">E(Y \mid W_b(\lambda),S) = \beta_{0b}^* + \beta_{1b}^* W_{b}(\lambda) + \beta_{2b}^* S.</code> We then calculate the average estimate for each quantity over the iterations <code class="reqn">b=1,...,B</code> for each <code class="reqn">\lambda</code> value, denoted as <code class="reqn">\hat \beta^*_{1,S,\sigma^2_u(1+\lambda)} = \sum_{b=1}^B \hat \beta_{1b}^*(\lambda)</code>. The second step, extrapolation, takes these average estimates for each <code class="reqn">\lambda</code> value and extrapolates using a function <code class="reqn">G(\Gamma, \lambda)</code> to obtain the estimated quantity if <code class="reqn">\lambda=-1</code>. For the extrapolation step, we use both a quadratic extrapolation and nonlinear extrapolation i.e., we solve for <code class="reqn">\Gamma = (\alpha_0, \alpha_1, \alpha_2)^T</code> in  <code class="reqn">\hat \beta^*_{1,S,\sigma^2_u(1+\lambda)} = \alpha_0 + \alpha_1 \lambda + \alpha_2 \lambda^2</code> and <code class="reqn">\hat \beta^*_{1,S,\sigma^2_u(1+\lambda)}= \alpha_0 + \alpha_1 /( \alpha_2 + \lambda)</code>, respectively. Using the estimates of <code class="reqn">\alpha_0, \alpha_1, \alpha_2</code>, we calculate the predicted <code class="reqn">\hat \beta^*_{1,S,\sigma^2_u(1+\lambda)}</code> when <code class="reqn">\lambda = -1</code>. In essence, the simulations add successively larger measurement errors of size <code class="reqn">(1+\lambda)\sigma^2_u</code> and then extrapolate to the case when <code class="reqn">\lambda = -1</code> such that the measurement error is 0. We denote the resulting estimator of <code class="reqn">\beta_1^*</code> as <code class="reqn">\hat{\beta}^*_{1,SIMEX} = G(\hat \Gamma, -1)</code> and define <code class="reqn">\hat{R}_{SIMEX} = 1- \hat{\beta}^*_{1,SIMEX}/ \hat \beta_1.</code> 
</p>
<p>While the parametric approach to estimate the proportion of treatment effect explained by <code class="reqn">S</code> is most commonly used in clinical practice, previous work has demonstrated biased results when the assumed models are not correctly specified. An alternative approach involves estimating the treatment effect, <code class="reqn">\Delta</code>, and residual treatment effect, <code class="reqn">\Delta_S</code>, as <code class="reqn">R_S</code> is defined as <code class="reqn">1-\Delta/\Delta_S</code>. The quantity <code class="reqn">\Delta</code> can be estimated simply by <code class="reqn">\hat{\Delta} = n_1^{-1}\sum_{i=1}^{n} Y_i I(G_i = 1) - n_0^{-1}\sum_{i=1}^{n} Y_i I(G_i = 0)</code>, where <code class="reqn">n_1</code> and <code class="reqn">n_0</code> denote the number of individuals in the treatment and control groups, respectively. The quantity <code class="reqn">\Delta_S</code> can be estimated nonparametrically using kernel smoothing as <code class="reqn">\hat{\Delta}_S = n_0^{-1} \sum_{i: G_i = 0}\hat{\mu}_1(S_i) - n_0^{-1}\sum_{i=1}^{n} Y_i I(G_i = 0)</code>
where <code class="reqn">\hat{\mu}_1(s) = \{ \sum_{j: G_j = 1} K_h(S_j - s)Y_j \}/ \{\sum_{j:G_j = 1} K_h(S_j - s)\}</code>, <code class="reqn">K(\cdot)</code> is a smooth symmetric density function with finite support, <code class="reqn">K_h(\cdot)=K(\cdot/h)/h</code> and <code class="reqn">h</code> is a specified bandwidth such that <code class="reqn">h=O(n_1^{-\nu})</code> with <code class="reqn">\nu \in (1/4,1/2).</code> 
</p>
<p>When <code class="reqn">W = S + U</code> is available instead of <code class="reqn">S</code>, estimation of <code class="reqn">\Delta</code> is not affected whereas estimation of <code class="reqn">\Delta_S</code> is affected and thus, the nonparametric estimation procedure described above results in a biased estimate of <code class="reqn">R_S</code>. Unlike the parametric approach, the attenuation bias cannot be expressed in closed form. Within this nonparametric framework, SIMEX estimation can be used to correct for measurement error. We implement the estimation procedure as described above where we first generate additional measurement error to obtain <code class="reqn">W_{b,i}(\lambda)</code> and for each iteration <code class="reqn">b</code> and <code class="reqn">\lambda</code> values obtain <code class="reqn">\hat{\Delta}_{S,b}(\lambda) = n_0^{-1} \sum_{i: G_i = 0} \left \{ \frac{\sum_{j: G_j = 1} K_h(W_{b,j}(\lambda) - W_{b,i}(\lambda))Y_j}{\sum_{j:G_j = 1} K_h(W_{b,j}(\lambda)- W_{b,i}(\lambda))} \right \} - n_0^{-1}\sum_{i=1}^{n} Y_i I(G_i = 0).</code> We then calculate the average estimate for each quantity over the iterations <code class="reqn">b=1,...,B</code> for each <code class="reqn">\lambda</code> value, denoted as <code class="reqn">\hat{\Delta}_{S,\sigma_u^2(1+\lambda)} = \sum_{b=1}^B \hat{\Delta}_{S,b}(\lambda)</code> and extrapolate using a function <code class="reqn">G(\Gamma, \lambda)</code>; we specifically use the quadratic and nonlinear functions as in the parametric setting. We denote the resulting estimator of <code class="reqn">\Delta_S</code> as <code class="reqn">\hat{\Delta}_{S,SIMEX} = G(\hat \Gamma, -1)</code> and define <code class="reqn">\hat{R}_{S,SIMEX} = 1- \hat{\Delta}_{S,SIMEX} / \hat \Delta.</code> 
</p>
<p>In this function, parametric estimation is equivalent to Freedman's approach in the R.s.estimate documentation; nonparametric estimation is equivalent to the robust approach in the R.s.estimate documentation. Variance estimates for all estimators are calculated in this function based on derived closed form variance expressions. For all approaches, confidence intervals for <code class="reqn">\Delta_S</code> can be constructed using a normal approximation; confidence intervals for <code class="reqn">R_S</code> can be constructed using either a normal approximation or using Fieller's method, all of which are provided in this function. Details regarding the asymptotic properties of these estimators and closed form variance calculation can be found in: Parast, L., Garcia, T. P., Prentice, R. L., &amp; Carroll, R. J. (2022). Robust methods to correct for measurement error when evaluating a surrogate marker. Biometrics, 78(1), 9-23.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table role = "presentation">
<tr><td><code>R.naive</code></td>
<td>
<p>the naive estimate of the proportion of treatment effect explained by the surrogate marker; only if naive = TRUE</p>
</td></tr>
<tr><td><code>R.naive.var</code></td>
<td>
<p>the estimated variance of the naive estimate of the proportion of treatment effect explained by the surrogate marker; only if naive = TRUE</p>
</td></tr>
<tr><td><code>R.naive.CI.normal</code></td>
<td>
<p>the 95% confidence interval using the normal approximation for the naive estimate of the proportion of treatment effect explained by the surrogate marker; only if naive = TRUE</p>
</td></tr>
<tr><td><code>R.naive.CI.fieller</code></td>
<td>
<p>the 95% confidence interval using Fieller's approach for the naive estimate of the proportion of treatment effect explained by the surrogate marker; only if naive = TRUE</p>
</td></tr>
<tr><td><code>B1star.naive</code></td>
<td>
<p>the naive estimate of the adjusted regression coefficient for treatment; only if naive = TRUE and Ronly = FALSE and parametric = TRUE</p>
</td></tr>
<tr><td><code>B1star.naive.var</code></td>
<td>
<p>the estimated variance of the naive estimate of the adjusted regression coefficient for treatment; only if naive = TRUE and Ronly = FALSE and parametric = TRUE</p>
</td></tr>
<tr><td><code>B1star.naive.CI.normal</code></td>
<td>
<p>the 95% confidence interval using the normal approximation for the naive estimate of the adjusted regression coefficient for treatment; only if naive = TRUE and Ronly = FALSE and parametric = TRUE</p>
</td></tr>
<tr><td><code>deltas.naive</code></td>
<td>
<p>the naive estimate of the residual treatment effect; only if naive = TRUE and Ronly = FALSE and parametric = FALSE</p>
</td></tr>
<tr><td><code>deltas.naive.var</code></td>
<td>
<p>the estimated variance of the naive estimate of the residual treatment effect; only if naive = TRUE and Ronly = FALSE and parametric = FALSE</p>
</td></tr>
<tr><td><code>deltas.naive.CI.normal</code></td>
<td>
<p>the 95% confidence interval using the normal approximation for the naive estimate of the residual treatment effect; only if naive = TRUE and Ronly = FALSE and parametric = FALSE</p>
</td></tr>
<tr><td><code>R.corrected.dis</code></td>
<td>
<p>the corrected disattenuated estimate of the proportion of treatment effect explained by the surrogate marker; only if parametric = TRUE and estimator =&quot;d&quot;</p>
</td></tr>
<tr><td><code>R.corrected.var.dis</code></td>
<td>
<p>the estimated variance of the corrected disattenuated estimate of the proportion of treatment effect explained by the surrogate marker; only if naive = TRUE</p>
</td></tr>
<tr><td><code>R.corrected.CI.normal.dis</code></td>
<td>
<p>the 95% confidence interval using the normal approximation for the corrected disattenuated estimate of the proportion of treatment effect explained by the surrogate marker; only if parametric = TRUE and estimator =&quot;d&quot;</p>
</td></tr>
<tr><td><code>R.corrected.CI.fieller.dis</code></td>
<td>
<p>the 95% confidence interval using Fieller's approach for the corrected disattenuated estimate of the proportion of treatment effect explained by the surrogate marker; only if parametric = TRUE and estimator =&quot;d&quot;</p>
</td></tr>
<tr><td><code>B1star.corrected.dis</code></td>
<td>
<p>the corrected disattenuated estimate of the adjusted regression coefficient for treatment; only if parametric = TRUE and estimator = &quot;d&quot; and Ronly = FALSE</p>
</td></tr>
<tr><td><code>B1star.corrected.var.dis</code></td>
<td>
<p>the estimated variance of the corrected disattenuated estimate of the adjusted regression coefficient for treatment; only if parametric = TRUE and estimator = &quot;d&quot; and Ronly = FALSE</p>
</td></tr>
<tr><td><code>B1star.corrected.CI.normal.dis</code></td>
<td>
<p>the 95% confidence interval using the normal approximation for the corrected disattenuated estimate of the adjusted regression coefficient for treatment; only if parametric = TRUE and estimator = &quot;d&quot; and Ronly = FALSE</p>
</td></tr>
<tr><td><code>R.corrected.q</code></td>
<td>
<p>the corrected SIMEX (quadratic) estimate of the proportion of treatment effect explained by the surrogate marker; only if estimator = &quot;q&quot;</p>
</td></tr>
<tr><td><code>R.corrected.var.q</code></td>
<td>
<p>the estimated variance of the corrected SIMEX (quadratic) estimate of the proportion of treatment effect explained by the surrogate marker; only if estimator = &quot;q&quot;</p>
</td></tr>
<tr><td><code>R.corrected.CI.normal.q</code></td>
<td>
<p>the 95% confidence interval using the normal approximation for the corrected SIMEX (quadratic) estimate of the proportion of treatment effect explained by the surrogate marker; only if estimator = &quot;q&quot;</p>
</td></tr>
<tr><td><code>R.corrected.CI.fieller.q</code></td>
<td>
<p>the 95% confidence interval using Fieller's approach for the corrected SIMEX (quadratic) estimate of the proportion of treatment effect explained by the surrogate marker; only if estimator = &quot;q&quot;</p>
</td></tr>
<tr><td><code>B1star.corrected.q</code></td>
<td>
<p>the corrected SIMEX (quadratic) estimate of the adjusted regression coefficient for treatment; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = TRUE</p>
</td></tr>
<tr><td><code>B1star.corrected.var.q</code></td>
<td>
<p>the estimated variance of the corrected SIMEX (quadratic) estimate of the adjusted regression coefficient for treatment; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = TRUE</p>
</td></tr>
<tr><td><code>B1star.corrected.CI.normal.q</code></td>
<td>
<p>the 95% confidence interval using the normal approximation for the corrected SIMEX (quadratic) estimate of the adjusted regression coefficient for treatment; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = TRUE</p>
</td></tr>
<tr><td><code>deltas.corrected.q</code></td>
<td>
<p>the corrected SIMEX (quadratic) estimate of the residual treatment effect; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = FALSE</p>
</td></tr>
<tr><td><code>deltas.corrected.var.q</code></td>
<td>
<p>the estimated variance of the corrected SIMEX (quadratic) estimate of the residual treatment effect; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = FALSE</p>
</td></tr>
<tr><td><code>deltas.corrected.CI.normal.q</code></td>
<td>
<p>the 95% confidence interval using the normal approximation for the corrected SIMEX (quadratic) estimate of the residual treatment effect; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = FALSE</p>
</td></tr>
<tr><td><code>R.corrected.nl</code></td>
<td>
<p>the corrected SIMEX (nonlinear) estimate of the proportion of treatment effect explained by the surrogate marker; only if estimator = &quot;q&quot;</p>
</td></tr>
<tr><td><code>R.corrected.var.nl</code></td>
<td>
<p>the estimated variance of the corrected SIMEX (nonlinear) estimate of the proportion of treatment effect explained by the surrogate marker; only if estimator = &quot;q&quot;</p>
</td></tr>
<tr><td><code>R.corrected.CI.normal.nl</code></td>
<td>
<p>the 95% confidence interval using the normal approximation for the corrected SIMEX (nonlinear) estimate of the proportion of treatment effect explained by the surrogate marker; only if estimator = &quot;q&quot;</p>
</td></tr>
<tr><td><code>R.corrected.CI.fieller.nl</code></td>
<td>
<p>the 95% confidence interval using Fieller's approach for the corrected SIMEX (nonlinear) estimate of the proportion of treatment effect explained by the surrogate marker; only if estimator = &quot;q&quot;</p>
</td></tr>
<tr><td><code>B1star.corrected.nl</code></td>
<td>
<p>the corrected SIMEX (nonlinear) estimate of the adjusted regression coefficient for treatment; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = TRUE</p>
</td></tr>
<tr><td><code>B1star.corrected.var.nl</code></td>
<td>
<p>the estimated variance of the corrected SIMEX (nonlinear) estimate of the adjusted regression coefficient for treatment; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = TRUE</p>
</td></tr>
<tr><td><code>B1star.corrected.CI.normal.nl</code></td>
<td>
<p>the 95% confidence interval using the normal approximation for the corrected SIMEX (nonlinear) estimate of the adjusted regression coefficient for treatment; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = TRUE</p>
</td></tr>
<tr><td><code>deltas.corrected.nl</code></td>
<td>
<p>the corrected SIMEX (nonlinear) estimate of the residual treatment effect; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = FALSE</p>
</td></tr>
<tr><td><code>deltas.corrected.var.nl</code></td>
<td>
<p>the estimated variance of the corrected SIMEX (nonlinear) estimate of the residual treatment effect; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = FALSE</p>
</td></tr>
<tr><td><code>deltas.corrected.CI.normal.nl</code></td>
<td>
<p>the 95% confidence interval using the normal approximation for the corrected SIMEX (nonlinear) estimate of the residual treatment effect; only if estimator = &quot;q&quot; and Ronly = FALSE and parametric = FALSE</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., Garcia, T. P., Prentice, R. L., &amp; Carroll, R. J. (2022). Robust methods to correct for measurement error when evaluating a surrogate marker. Biometrics, 78(1), 9-23.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example_me)
names(d_example_me)
R.s.estimate.me(yone=d_example_me$y1, yzero=d_example_me$y0, sone=d_example_me$s1, 
szero=d_example_me$s0, parametric = TRUE, estimator = "d", me.variance = 0.5, 
naive= TRUE, Ronly = FALSE)
R.s.estimate.me(yone=d_example_me$y1, yzero=d_example_me$y0, sone=d_example_me$s1, 
szero=d_example_me$s0, parametric = TRUE, estimator = "q", me.variance = 0.5, 
naive= FALSE, Ronly = TRUE)

#estimating measurement error variance with replicates
replicates = rbind(cbind(d_example_me$s1_rep1, d_example_me$s1_rep2, 
d_example_me$s1_rep3), cbind(d_example_me$s0_rep1, d_example_me$s0_rep2, 
d_example_me$s0_rep3))
mean.i = apply(replicates,1,mean, na.rm = TRUE)
num.i = apply(replicates,1,function(x) sum(!is.na(x)))
var.u = sum((replicates-mean.i)^2, na.rm = TRUE)/sum(num.i)
var.u
R.s.estimate.me(yone=d_example_me$y1, yzero=d_example_me$y0, sone=d_example_me$s1, 
szero=d_example_me$s0, parametric = TRUE, estimator = "d", me.variance = var.u, 
naive= TRUE, Ronly = FALSE)

R.s.estimate.me(yone=d_example_me$y1, yzero=d_example_me$y0, 
sone=d_example_me$s1, szero=d_example_me$s0, parametric = FALSE, estimator = "q", 
me.variance = 0.5, naive= FALSE, Ronly = TRUE)

</code></pre>

<hr>
<h2 id='R.s.surv.estimate'>
Calculates the proportion of treatment effect explained by the surrogate marker information measured at a specified time and primary outcome information up to that specified time
</h2><span id='topic+R.s.surv.estimate'></span>

<h3>Description</h3>

<p>This function calculates the proportion of treatment effect on the primary outcome explained by the surrogate marker information measured at <code class="reqn">t_0</code> and primary outcome information up to <code class="reqn">t_0</code>.  The user can also request a variance estimate, estimated using perturbating-resampling, and a 95% confidence interval. If a confidence interval is requested three versions are provided: a normal approximation based interval, a quantile based interval and Fieller's confidence interval, all using perturbation-resampling. The user can also request an estimate of the incremental value of surrogate marker information. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.s.surv.estimate(xone, xzero, deltaone, deltazero, sone, szero, t, 
weight.perturb = NULL, landmark, extrapolate = FALSE, transform = FALSE, 
conf.int = FALSE, var = FALSE, incremental.value = FALSE, approx = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R.s.surv.estimate_+3A_xone">xone</code></td>
<td>

<p>numeric vector, the observed event times in the treatment group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_xzero">xzero</code></td>
<td>

<p>numeric vector, the observed event times in the control group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_deltaone">deltaone</code></td>
<td>

<p>numeric vector, the event indicators for the treatment group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_deltazero">deltazero</code></td>
<td>

<p>numeric vector, the event indicators for the control group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_sone">sone</code></td>
<td>

<p>numeric vector; surrogate marker measurement at <code class="reqn">t_0</code> for treated observations, assumed to be continuous. If <code class="reqn">X_{1i}&lt;t_0</code>, then the surrogate marker measurement should be NA. 
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_szero">szero</code></td>
<td>

<p>numeric vector; surrogate marker measurement at <code class="reqn">t_0</code> for control observations, assumed to be continuous. If <code class="reqn">X_{1i}&lt;t_0</code>, then the surrogate marker measurement should be NA.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_t">t</code></td>
<td>

<p>the time of interest.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>weights used for perturbation resampling.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time <code class="reqn">t_0</code> or time of surrogate marker measurement.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_extrapolate">extrapolate</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use extrapolation.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_transform">transform</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user wants to use a transformation for the surrogate marker. 
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether a 95% confidence interval for delta is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether a variance estimate is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_incremental.value">incremental.value</code></td>
<td>

<p>TRUE or FALSE; indicates whether the user would like to see the incremental value of the surrogate marker information, default is FALSE.
</p>
</td></tr>
<tr><td><code id="R.s.surv.estimate_+3A_approx">approx</code></td>
<td>

<p>TRUE or FALSE indicating whether an approximation should be used when calculating the probability of censoring; most relevant in settings where the survival time of interest for the primary outcome is greater than the last observed event but before the last censored case, default is TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">G</code> be the binary treatment indicator with <code class="reqn">G=1</code> for treatment and <code class="reqn">G=0</code> for control and we assume throughout that subjects are randomly assigned to a treatment group at baseline. Let <code class="reqn">T^{(1)}</code> and <code class="reqn">T^{(0)}</code> denote the time of the primary outcome of interest, death for example, under the treatment and under the control, respectively. Let <code class="reqn">S^{(1)}</code> and <code class="reqn">S^{(0)}</code> denote the surrogate marker measured at time <code class="reqn">t_0</code> under the treatment and the control, respectively.
</p>
<p>The residual treatment effect is defined as
</p>
<p style="text-align: center;"><code class="reqn"> \Delta_S(t,t_0) = P(T^{(0)} &gt; t_0) \left \{\int \psi_1(t | s, t_0) dF_0(s | t_0)-P(T^{(0)}&gt; t| T^{(0)}&gt; t_0) \right \}</code>
</p>
<p> where <code class="reqn">F_0(\cdot |  t_0)</code> is the cumulative distribution function of <code class="reqn">S^{(0)}</code> conditional on <code class="reqn">T^{(0)}&gt; t_0</code> and <code class="reqn">\psi_1(t |  s,t_0) = P(T^{(1)}&gt; t |  S^{(1)}=s, T ^{(1)} &gt; t_0)</code>. The proportion of treatment effect explained by the surrogate marker information measured at <code class="reqn">t_0</code> and primary outcome information up to <code class="reqn">t_0</code>, which we denote by <code class="reqn">R_S(t,t_0)</code>, can be expressed using a contrast between <code class="reqn">\Delta_S(t,t_0)</code> and <code class="reqn">\Delta(t)</code>:
</p>
<p style="text-align: center;"><code class="reqn">R_S(t,t_0)=\{\Delta(t)-\Delta_S(t,t_0)\}/\Delta(t)=1-\Delta_S(t,t_0)/\Delta(t).</code>
</p>
<p>   The definition and estimation of <code class="reqn">\Delta(t)</code> is described in the delta.surv.estimate documentation.
</p>
<p>Due to censoring, our data consist of <code class="reqn">n_1</code> observations <code class="reqn">\{(X_{1i}, \delta_{1i}, S_{1i}), i=1,...,n_1\}</code> from the treatment group <code class="reqn">G=1</code> and <code class="reqn">n_0</code> observations <code class="reqn">\{(X_{0i}, \delta_{0i}, S_{0i}), i=1,...,n_0\}</code> from the control group <code class="reqn">G=0</code> where <code class="reqn">X_{gi} = \min(T_{gi}, C_{ gi})</code>,  <code class="reqn">\delta_{gi} = I(T_{gi} &lt; C_{gi})</code>, <code class="reqn">C_{gi}</code> denotes the censoring time, and <code class="reqn">S_{gi}</code> denotes the surrogate marker information measured at time <code class="reqn">t_0</code>, for <code class="reqn">g= 1,0</code>, for individual <code class="reqn">i</code>. Note that if <code class="reqn">X_{gi} &lt; t_0</code>, then <code class="reqn">S_{gi}</code> should be NA (not available).
</p>
<p>To estimate <code class="reqn">\Delta_S(t,t_0)</code>, we use a nonparametric kernel Nelson-Aalen estimator to estimate <code class="reqn">\psi_1(t | s,t_0)</code> as <code class="reqn">\hat{\psi}_1(t| s,t_0)  = \exp\{-\hat{\Lambda}_1(t| s,t_0) \}</code>, where
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Lambda}_1(t| s,t_0) = \int_{t_0}^t \frac{\sum_{i=1}^{n_1} I(X_{1i}&gt;t_0) K_h\{\gamma(S_{1i}) - \gamma(s)\}dN_{1i}(z)}{\sum_{i=1}^{n_1}  I(X_{1i}&gt;t_0) K_h\{\gamma(S_{1i}) - \gamma(s)\} Y_{1i}(z)},</code>
</p>

<p>is a consistent estimate of <code class="reqn">\Lambda_1(t| s,t_0 ) =  -\log [\psi_1(t| s,t_0)], Y_{1i}(t) = I(X_{1i} \geq t),  N_{1i}(t) = I(X_{1i} \leq t) \delta_i,  K(\cdot)</code> is a smooth symmetric density function, <code class="reqn">K_h(x) = K(x/h)/h, \gamma(\cdot)</code> is a given monotone transformation function, and <code class="reqn">h</code> is a specified bandwidth. To obtain an appropriate <code class="reqn">h</code> we first use bw.nrd to obtain <code class="reqn">h_{opt}</code>; and then we let <code class="reqn">h = h_{opt}n_1^{-c_0}</code>  with <code class="reqn">c_0 = 0.11</code>.
</p>
<p>Since <code class="reqn">F_0(s | t_0) = P(S_{0i} \le s | X_{0i} &gt; t_0)</code>, we empirically estimate <code class="reqn">F_0(s | t_0)</code> using all subjects with <code class="reqn">X_{0i} &gt; t_0</code> as </p>
<p style="text-align: center;"><code class="reqn">
\hat{F}_0(s | t_0) = \frac{\sum_{i=1}^{n_0} I(S_{0i} \le s, X_{0i} &gt; t_0)}{\sum_{i=1}^{n_0} I(X_{0i} &gt; t_0)}.</code>
</p>

<p>Subsequently, we construct an estimator for <code class="reqn">\Delta_{S}(t,t_0)</code> as
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Delta}_S(t,t_0) = n_0^{-1} \sum_{i=1}^{n_0} \left[\hat{\psi}_1(t| S_{0i},t_0) \frac{I(X_{0i} &gt; t_0)}{\hat{W}^C_0(t_0)}  -   \frac{I(X_{0i} &gt; t)}{\hat{W}^C_0(t)}\right]</code>
</p>

<p>where <code class="reqn">\hat{W}^C_g(\cdot)</code> is the Kaplan-Meier estimator of survival for censoring for <code class="reqn">g=1,0.</code> Finally, we estimate <code class="reqn">R_S(t,t_0)</code> as <code class="reqn">\hat{R}_S(t,t_0) =1- \hat{\Delta}_S(t,t_0)/\hat{\Delta}(t).</code> 
</p>
<p>Variance estimation and confidence interval construction are performed using perturbation-resampling. Specifically, let <code class="reqn">\left \{ V^{(b)} = (V_{11}^{(b)}, ...V_{1n_1}^{(b)}, V_{01}^{(b)}, ...V_{0n_0}^{(b)})^T, b=1,....,D \right \}</code> be <code class="reqn">n \times D</code> independent copies of a positive random variables <code class="reqn">V</code> from a known distribution with unit mean and unit variance. Let
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Delta}^{(b)}(t) = \frac{  \sum_{i=1}^{n_1} V_{1i}^{(b)} I(X_{1i}&gt;t)}{ \sum_{i=1}^{n_1} V_{1i}^{(b)} \hat{W}_1^{C(b)}(t)}  -\frac{  \sum_{i=1}^{n_0} V_{0i}^{(b)} I(X_{0i}&gt;t)}{ \sum_{i=1}^{n_0} V_{0i}^{(b)} \hat{W}_0^{C(b)}(t)}.</code>
</p>
<p> In this package, we use weights generated from an Exponential(1) distribution and use <code class="reqn">D=500</code>. The variance of <code class="reqn">\hat{\Delta}(t)</code> is obtained as the empirical variance of <code class="reqn">\{\hat{\Delta}(t)^{(b)}, b = 1,...,D\}</code>. Variance estimates for <code class="reqn">\hat{\Delta}_S(t,t_0)</code> and <code class="reqn">\hat{R}_S(t,t_0)</code> are calculated similarly. We construct two versions of the <code class="reqn">95\%</code> confidence interval for each estimate: one based on a normal approximation confidence interval using the estimated variance and another taking the 2.5th and 97.5th empirical percentile of the perturbed quantities.  In addition, we use Fieller's method to obtain a third confidence interval for <code class="reqn">R_S(t,t_0)</code> as
</p>
<p style="text-align: center;"><code class="reqn">\left\{1-r:  \frac{(\hat{\Delta}_S(t,t_0)-r\hat{\Delta}(t))^2}{\hat{\sigma}_{11}-2r\hat\sigma_{12}+r^2\hat\sigma_{22}} \le c_{\alpha}\right\},</code>
</p>

<p>where <code class="reqn">\hat{\Sigma}=(\hat\sigma_{ij})_{1\le i,j\le 2}</code> and <code class="reqn">c_\alpha</code> is the <code class="reqn">(1-\alpha)</code>th percentile of
</p>
<p style="text-align: center;"><code class="reqn">\left\{\frac{\{\hat{\Delta}^{(b)}_S(t)-(1-\hat R_S(t,t_0))\hat{\Delta}(t)^{(b)}\}^2}{\hat{\sigma}_{11}-2(1-\hat R_S(t,t_0))\hat\sigma_{12}+(1-\hat R_S(t,t_0))^2\hat\sigma_{22}}, b=1, \cdots, C\right\}</code>
</p>

<p>where <code class="reqn">\alpha=0.05</code>.
</p>
<p>Since the definition of <code class="reqn">R_S(t,t_0)</code> considers the surrogate information as a combination of both <code class="reqn">S</code> information and <code class="reqn">T</code> information up to <code class="reqn">t_0</code>, a logical inquiry would be how to assess the incremental value of the <code class="reqn">S</code> information in terms of the proportion of treatment effect explained, when added to <code class="reqn">T</code> information up to <code class="reqn">t_0</code>. The proportion of treatment effect explained by <code class="reqn">T</code> information up to <code class="reqn">t_0</code> only is denoted as <code class="reqn">R_T(t,t_0)</code> and is described in the documentation for R.t.surv.estimate. The incremental value of <code class="reqn">S</code> information is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
IV_S(t,t_0) = R_S(t,t_0) - R_T(t,t_0) = \frac{\Delta_T(t,t_0) - \Delta_S(t,t_0)}{\Delta (t)}.</code>
</p>

<p>For estimation of <code class="reqn">R_T(t_0)</code>, see documentation for R.t.surv.estimate. The quantity <code class="reqn">IV_S(t,t_0)</code>  is then estimated by <code class="reqn">\hat{IV}_S(t,t_0) = \hat{R}_S(t,t_0) - \hat{R}_T(t,t_0)</code>. Perturbation-resampling is used for variance estimation and confidence interval construction for this quantity, similar to the other quantities in this package.
</p>
<p>Note that if the observed supports for S are not the same, then <code class="reqn">\hat{\Lambda}_1(t| s,t_0)</code> for <code class="reqn">S_{0i} = s</code> outside the support of <code class="reqn">S_{1i}</code> may return NA (depending on the bandwidth). If extrapolation = TRUE, then the   <code class="reqn">\hat{\Lambda}_1(t| s,t_0)</code> values for these surrogate values are set to the closest non-NA value. If transform = TRUE, then <code class="reqn">S_{1i}</code> and <code class="reqn">S_{0i}</code> are transformed such that the new transformed values, <code class="reqn">S^{tr}_{1i}</code> and <code class="reqn">S^{tr}_{0i}</code> are defined as: <code class="reqn">S^{tr}_{gi} = F([S_{gi} - \mu]/\sigma)</code> for <code class="reqn">g=0,1</code> where <code class="reqn">F(\cdot)</code> is the cumulative distribution function for a standard normal random variable, and <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> are the sample mean and standard deviation, respectively, of <code class="reqn">\{(S_{1i}, S_{0i})^T, i \quad s.t. X_{gi} &gt; t_0\}</code>.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}(t)</code>, described in delta.estimate documentation.</p>
</td></tr>
<tr><td><code>delta.s</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}_S(t,t_0)</code>, described above.</p>
</td></tr>
<tr><td><code>R.s</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{R}_S(t,t_0)</code>, described above.</p>
</td></tr>
<tr><td><code>delta.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}(t)</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>delta.s.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}_S(t,t_0)</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>R.s.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{R}_S(t,t_0)</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.normal.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.normal.delta.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_S(t,t_0)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.delta.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_S(t,t_0)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.normal.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.fieller.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)</code> based on Fieller's approach, described above; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>delta.t</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}_T(t,t_0)</code>, described above; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>R.t</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{R}_T(t,t_0)</code>, described above; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>incremental.value</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{IV}_S(t,t_0)</code>, described above; if incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>delta.t.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}_T(t,t_0)</code>; if var = TRUE or conf.int = TRUE and  incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>R.t.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{R}_T(t,t_0)</code>; if var = TRUE or conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>incremental.value.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{IV}_S(t,t_0)</code>; if var = TRUE or conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.normal.delta.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_T(t,t_0)</code> based on a normal approximation; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.delta.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_T(t,t_0)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.normal.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on a normal approximation; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.fieller.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on Fieller's approach, described above; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.normal.iv</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{IV}_S(t,t_0)</code> based on a normal approximation; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.iv</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{IV}_S(t,t_0)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>If the treatment effect is not significant, the user will receive the following message: &quot;Warning: it looks like the treatment effect is not significant; may be difficult to interpret the residual treatment effect in this setting&quot;. If the observed support of the surrogate marker for the control group is outside the observed support of the surrogate marker for the treatment group, the user will receive the following message: &quot;Warning: observed supports do not appear equal, may need to consider a transformation or extrapolation&quot;.</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., Cai, T., &amp; Tian, L. (2017). Evaluating surrogate marker information using censored data. Statistics in Medicine, 36(11), 1767-1782.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example_surv)
names(d_example_surv)
</code></pre>

<hr>
<h2 id='R.t.surv.estimate'>
Calculates the proportion of treatment effect explained by the primary outcome information up to a specified time
</h2><span id='topic+R.t.surv.estimate'></span>

<h3>Description</h3>

<p>This function calculates the proportion of treatment effect on the primary outcome explained by the treatment effect on the primary outcome up to <code class="reqn">t_0</code>.  The user can also request a variance estimate, estimated using perturbating-resampling, and a 95% confidence interval. If a confidence interval is requested three versions are provided: a normal approximation based interval, a quantile based interval and Fieller's confidence interval, all using perturbation-resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.t.surv.estimate(xone, xzero, deltaone, deltazero, t, weight.perturb = NULL, 
landmark, var = FALSE, conf.int = FALSE, approx = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R.t.surv.estimate_+3A_xone">xone</code></td>
<td>

<p>numeric vector, the observed event times in the treatment group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.t.surv.estimate_+3A_xzero">xzero</code></td>
<td>

<p>numeric vector, the observed event times in the control group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.t.surv.estimate_+3A_deltaone">deltaone</code></td>
<td>

<p>numeric vector, the event indicators for the treatment group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.t.surv.estimate_+3A_deltazero">deltazero</code></td>
<td>

<p>numeric vector, the event indicators for the control group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="R.t.surv.estimate_+3A_t">t</code></td>
<td>

<p>the time of interest.
</p>
</td></tr>
<tr><td><code id="R.t.surv.estimate_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>weights used for perturbation resampling.
</p>
</td></tr>
<tr><td><code id="R.t.surv.estimate_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time <code class="reqn">t_0</code> or time of surrogate marker measurement.
</p>
</td></tr>
<tr><td><code id="R.t.surv.estimate_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether a variance estimate for delta is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="R.t.surv.estimate_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether a 95% confidence interval for delta is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="R.t.surv.estimate_+3A_approx">approx</code></td>
<td>

<p>TRUE or FALSE indicating whether an approximation should be used when calculating the probability of censoring; most relevant in settings where the survival time of interest for the primary outcome is greater than the last observed event but before the last censored case, default is TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">G</code> be the binary treatment indicator with <code class="reqn">G=1</code> for treatment and <code class="reqn">G=0</code> for control and we assume throughout that subjects are randomly assigned to a treatment group at baseline. Let <code class="reqn">T</code> denote the time of the primary outcome of interest, death for example. We use potential outcomes notation such that <code class="reqn">T^{(g)}</code> denotes the time of the primary outcome under treatment <code class="reqn">G = g</code>. The proportion of treatment effect explained by T observed up to <code class="reqn">t_0</code> only is <code class="reqn">R_T(t,t_0) = 1-\Delta_T(t,t_0)/\Delta(t)</code> where
</p>
<p style="text-align: center;"><code class="reqn">\Delta_T(t, t_0) = P(T^{(0)}&gt;t_0)P(T^{(1)}&gt;t\mid T^{(1)}&gt;t_0)-P(T^{(0)}&gt;t).</code>
</p>
<p>  To estimate <code class="reqn">R_T(t,t_0)</code>, we use the estimator <code class="reqn">\hat{R}_T(t,t_0) = 1-\hat{\Delta}_T(t,t_0)/\hat{\Delta}(t)</code> where <code class="reqn">\hat{\Delta}_T(t,t_0) =  \hat{\phi}_0(t_0)\hat{\phi}_1(t)/\hat{\phi}_1(t_0) - \hat{\phi}_0(t)</code> and <code class="reqn">\hat{\phi}_g(u) = n_g^{-1} \sum_{i=1}^{n_g} \frac{I(X_{gi}&gt;u)}{\hat{W}^C_g(u)}</code> for <code class="reqn">g=1,0</code> where  <code class="reqn">\widehat{W}^C_g(\cdot)</code> is the Kaplan-Meier estimator of survival for censoring for <code class="reqn">g=1,0.</code> 
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}(t)</code>, described in delta.estimate documentation.</p>
</td></tr>
<tr><td><code>delta.t</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}_T(t,t_0)</code>, described above.</p>
</td></tr>
<tr><td><code>R.t</code></td>
<td>
<p>the estimate, <code class="reqn">\hat{R}_T(t,t_0)</code>, described above.</p>
</td></tr>
<tr><td><code>delta.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}(t)</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>delta.t.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}_T(t,t_0)</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>R.t.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{R}_T(t,t_0)</code>; if var = TRUE or conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.normal.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.normal.delta.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_T(t,t_0)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.delta.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_T(t,t_0)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.normal.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td></tr>
<tr><td><code>conf.int.quantile.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE.</p>
</td></tr> 
<tr><td><code>conf.int.fieller.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on Fieller's approach, described above; if conf.int = TRUE.</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>If the treatment effect is not significant, the user will receive the following message: &quot;Warning: it looks like the treatment effect is not significant; may be difficult to interpret the residual treatment effect in this setting&quot;.</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., Cai, T., &amp; Tian, L. (2017). Evaluating surrogate marker information using censored data. Statistics in Medicine, 36(11), 1767-1782.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d_example_surv)
names(d_example_surv)
</code></pre>

<hr>
<h2 id='VTM'>
Repeats a row.
</h2><span id='topic+VTM'></span>

<h3>Description</h3>

<p>Helper function; this function creates a matrix that repeats vc, dm times where each row is equal to the vc vector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VTM(vc, dm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VTM_+3A_vc">vc</code></td>
<td>

<p>the vector to repeat.
</p>
</td></tr>
<tr><td><code id="VTM_+3A_dm">dm</code></td>
<td>

<p>number of rows.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix that repeats vc, dm times where each row is equal to the vc vector
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
