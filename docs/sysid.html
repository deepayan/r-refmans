<!DOCTYPE html><html><head><title>Help for package sysid</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sysid}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+3D+25'><p>Multiple assignment operator</p></a></li>
<li><a href='#armax'><p>Estimate ARMAX Models</p></a></li>
<li><a href='#armaxsim'><p>Data simulated from an ARMAX model</p></a></li>
<li><a href='#arx'><p>Estimate ARX Models</p></a></li>
<li><a href='#arxsim'><p>Data simulated from an ARX model</p></a></li>
<li><a href='#bj'><p>Estimate Box-Jenkins Models</p></a></li>
<li><a href='#bjsim'><p>Data simulated from an BJ model</p></a></li>
<li><a href='#compare'><p>Compare the measured output and the predicted output(s)</p></a></li>
<li><a href='#cstr'><p>Continuous stirred tank reactor data (idframe)</p></a></li>
<li><a href='#cstr_mis'><p>Continuous stirred tank reactor data with missing values</p></a></li>
<li><a href='#cstrData'><p>Continuous stirred tank reactor data (data.frame)</p></a></li>
<li><a href='#dataSlice'><p>Subset or Resample idframe data</p></a></li>
<li><a href='#detrend'><p>Remove offsets and linear trends</p></a></li>
<li><a href='#estpoly'><p>Estimated polynomial object</p></a></li>
<li><a href='#etfe'><p>Estimate empirical transfer function</p></a></li>
<li><a href='#fitch'><p>Fit Characteristics</p></a></li>
<li><a href='#frd'><p>Frequency response data</p></a></li>
<li><a href='#getcov'><p>Parameter covariance of the identified model</p></a></li>
<li><a href='#idframe'><p>S3 class for storing input-output data.</p></a></li>
<li><a href='#idfrd'><p>S3 class constructor for storing frequency response data</p></a></li>
<li><a href='#idinput'><p>function to generate input singals (rgs/rbs/prbs/sine)</p></a></li>
<li><a href='#idpoly'><p>Polynomial model with identifiable parameters</p></a></li>
<li><a href='#impulseest'><p>Estimate Impulse Response Coefficients</p></a></li>
<li><a href='#impulseplot'><p>Impulse Response Plots</p></a></li>
<li><a href='#inputData'><p>Output or Input-data</p></a></li>
<li><a href='#inputNames+26lt+3B-'><p>Extract or set series' names</p></a></li>
<li><a href='#iv'><p>ARX model estimation using instrumental variable method</p></a></li>
<li><a href='#iv4'><p>ARX model estimation using four-stage instrumental variable method</p></a></li>
<li><a href='#misdata'><p>Replace Missing Data by Interpolation</p></a></li>
<li><a href='#nInputSeries'><p>Number of series in input or output</p></a></li>
<li><a href='#oe'><p>Estimate Output-Error Models</p></a></li>
<li><a href='#oesim'><p>Data simulated from an OE model</p></a></li>
<li><a href='#optimOptions'><p>Create optimization options</p></a></li>
<li><a href='#plot.idframe'><p>Plotting idframe objects</p></a></li>
<li><a href='#plot.idfrd'><p>Plotting idfrd objects</p></a></li>
<li><a href='#predict.estpoly'><p>Predictions of identified model</p></a></li>
<li><a href='#rarx'><p>Estimate parameters of ARX recursively</p></a></li>
<li><a href='#read.idframe'><p>Data input into a idframe object</p></a></li>
<li><a href='#read.table.idframe'><p>Read the contents of a table-formatted file</p></a></li>
<li><a href='#residplot'><p>Plot residual characteristics</p></a></li>
<li><a href='#sim'><p>Simulate response of dynamic system</p></a></li>
<li><a href='#spa'><p>Estimate frequency response</p></a></li>
<li><a href='#step'><p>Step Response Plots</p></a></li>
<li><a href='#time'><p>Sampling times of IO data</p>
</p>
<p><code>time</code> creates the vector of times at which data was sampled. <code>frequency</code> returns the number of damples per unit time and <code>deltat</code> the time-interval</p>
between observations</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>System Identification in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-01-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Suraj Yerramilli, Arun Tangirala</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Suraj Yerramilli &lt;surajyerramilli@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for constructing mathematical models of dynamical systems from measured input-output data. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>signal,tframe, ggplot2 (&ge; 2.1.0), reshape2, polynom, bitops,
zoo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-07 18:42:13 UTC; suraj</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-07 20:00:56</td>
</tr>
</table>
<hr>
<h2 id='+25+3D+25'>Multiple assignment operator</h2><span id='topic++25+3D+25'></span><span id='topic+g'></span>

<h3>Description</h3>

<p>Assign multiple variables from a list or function return object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l %=% r
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B3D+2B25_+3A_l">l</code></td>
<td>
<p>the variables to be assigned</p>
</td></tr>
<tr><td><code id="+2B25+2B3D+2B25_+3A_r">r</code></td>
<td>
<p>the list or function-return object</p>
</td></tr>
</table>

<hr>
<h2 id='armax'>Estimate ARMAX Models</h2><span id='topic+armax'></span>

<h3>Description</h3>

<p>Fit an ARMAX model of the specified order given the input-output data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>armax(x, order = c(0, 1, 1, 0), init_sys = NULL, intNoise = FALSE,
  options = optimOptions())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="armax_+3A_x">x</code></td>
<td>
<p>an object of class <code>idframe</code></p>
</td></tr>
<tr><td><code id="armax_+3A_order">order</code></td>
<td>
<p>Specification of the orders: the four integer components 
(na,nb,nc,nk) are the order of polynolnomial A, order of polynomial B 
+ 1, order of the polynomial C,and the input-output delay respectively</p>
</td></tr>
<tr><td><code id="armax_+3A_init_sys">init_sys</code></td>
<td>
<p>Linear polynomial model that configures the initial parameterization.
Must be an ARMAX model. Overrules the <code>order</code> argument</p>
</td></tr>
<tr><td><code id="armax_+3A_intnoise">intNoise</code></td>
<td>
<p>Logical variable indicating whether to add integrators in
the noise channel (Default=<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="armax_+3A_options">options</code></td>
<td>
<p>Estimation Options, setup using <code><a href="#topic+optimOptions">optimOptions</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>SISO ARMAX models are of the form 
</p>
<p style="text-align: center;"><code class="reqn">
   y[k] + a_1 y[k-1] + \ldots + a_{na} y[k-na] = b_{nk} u[k-nk] + 
   \ldots + b_{nk+nb} u[k-nk-nb] + c_{1} e[k-1] + \ldots c_{nc} e[k-nc]
   + e[k] 
</code>
</p>

<p>The function estimates the coefficients using non-linear least squares 
(Levenberg-Marquardt Algorithm)
<br />
The data is expected to have no offsets or trends. They can be removed 
using the <code><a href="#topic+detrend">detrend</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class <code>estpoly</code> containing the following elements:
</p>
<table>
<tr><td><code>sys</code></td>
<td>
<p>an <code>idpoly</code> object containing the 
fitted ARMAX coefficients</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the predicted response</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>the input data used</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>A list containing the following fields: <br />
<code>vcov</code> - the covariance matrix of the fitted coefficients <br />
<code>sigma</code> - the standard deviation of the innovations</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>Option set used for estimation. If no 
custom options were configured, this is a set of default options</p>
</td></tr>
<tr><td><code>termination</code></td>
<td>
<p>Termination conditions for the iterative
search used for prediction error minimization:
<code>WhyStop</code> - Reason for termination <br />
<code>iter</code> - Number of Iterations <br />
<code>iter</code> - Number of Function Evaluations </p>
</td></tr>
</table>


<h3>References</h3>

<p>Arun K. Tangirala (2015), <em>Principles of System Identification: 
Theory and Practice</em>, CRC Press, Boca Raton. Sections 14.4.1, 21.6.2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(armaxsim)
z &lt;- dataSlice(armaxsim,end=1533) # training set
mod_armax &lt;- armax(z,c(1,2,1,2))
mod_armax

</code></pre>

<hr>
<h2 id='armaxsim'>Data simulated from an ARMAX model</h2><span id='topic+armaxsim'></span>

<h3>Description</h3>

<p>This dataset contains 2555 samples simulated from the following ARMAX model:
</p>
<p style="text-align: center;"><code class="reqn">
 y[k] = \frac{0.6q^{-2} - 0.2q^{-3}}{1 - 0.5q^{-1}} u[k] + 
 \frac{1-0.3q^{-1}}{1 - 0.5q^{-1}} e[k]
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>armaxsim
</code></pre>


<h3>Format</h3>

<p>an <code>idframe</code> object with 2555 samples, one input and one
output</p>


<h3>Details</h3>

<p>The model is simulated with a 2555 samples long full-band PRBS input.
The noise variance is set to 0.1
</p>

<hr>
<h2 id='arx'>Estimate ARX Models</h2><span id='topic+arx'></span>

<h3>Description</h3>

<p>Fit an ARX model of the specified order given the input-output data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arx(x, order = c(1, 1, 1), lambda = 0.1, intNoise = FALSE, fixed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arx_+3A_x">x</code></td>
<td>
<p>an object of class <code>idframe</code></p>
</td></tr>
<tr><td><code id="arx_+3A_order">order</code></td>
<td>
<p>Specification of the orders: the three integer components 
(na,nb,nk) are the order of polynolnomial A, (order of polynomial B + 1) and 
the input-output delay</p>
</td></tr>
<tr><td><code id="arx_+3A_lambda">lambda</code></td>
<td>
<p>Regularization parameter(Default=<code>0.1</code>)</p>
</td></tr>
<tr><td><code id="arx_+3A_intnoise">intNoise</code></td>
<td>
<p>Logical variable indicating whether to add integrators in
the noise channel (Default=<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="arx_+3A_fixed">fixed</code></td>
<td>
<p>list containing fixed parameters. If supplied, only <code>NA</code> entries 
will be varied. Specified as a list of two vectors, each containing the parameters
of polynomials A and B respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SISO ARX models are of the form 
</p>
<p style="text-align: center;"><code class="reqn">
   y[k] + a_1 y[k-1] + \ldots + a_{na} y[k-na] = b_{nk} u[k-nk] + 
   \ldots + b_{nk+nb} u[k-nk-nb] + e[k] 
</code>
</p>

<p>The function estimates the coefficients using linear least squares (with
regularization).
<br />
The data is expected to have no offsets or trends. They can be removed 
using the <code><a href="#topic+detrend">detrend</a></code> function. 
<br />
To estimate finite impulse response(<code>FIR</code>) models, specify the first
order to be zero.
</p>


<h3>Value</h3>

<p>An object of class <code>estpoly</code> containing the following elements:
</p>
<table>
<tr><td><code>sys</code></td>
<td>
<p>an <code>idpoly</code> object containing the 
fitted ARX coefficients</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the predicted response</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>the input data used</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>A list containing the following fields: <br />
<code>vcov</code> - the covariance matrix of the fitted coefficients <br />
<code>sigma</code> - the standard deviation of the innovations<br />
<code>df</code> - the residual degrees of freedom</p>
</td></tr>
</table>


<h3>References</h3>

<p>Arun K. Tangirala (2015), <em>Principles of System Identification: 
Theory and Practice</em>, CRC Press, Boca Raton. Section 21.6.1
</p>
<p>Lennart Ljung (1999), <em>System Identification: Theory for the User</em>, 
2nd Edition, Prentice Hall, New York. Section 10.1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arxsim)
mod_arx &lt;- arx(arxsim,c(1,2,2))
mod_arx
plot(mod_arx) # plot the predicted and actual responses

</code></pre>

<hr>
<h2 id='arxsim'>Data simulated from an ARX model</h2><span id='topic+arxsim'></span>

<h3>Description</h3>

<p>This dataset contains 2555 samples simulated from the following ARX model:
</p>
<p style="text-align: center;"><code class="reqn">
 y[k] = \frac{0.6q^{-2} - 0.2q^{-3}}{1 - 0.5q^{-1}} u[k] + 
 \frac{1}{1 - 0.5q^{-1}} e[k]
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>arxsim
</code></pre>


<h3>Format</h3>

<p>an <code>idframe</code> object with 2555 samples, one input and one
output</p>


<h3>Details</h3>

<p>The model is simulated with a 2555 samples long full-band PRBS input.
The noise variance is set to 0.1
</p>

<hr>
<h2 id='bj'>Estimate Box-Jenkins Models</h2><span id='topic+bj'></span>

<h3>Description</h3>

<p>Fit a box-jenkins model of the specified order from input-output data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bj(z, order = c(1, 1, 1, 1, 0), init_sys = NULL, options = optimOptions())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bj_+3A_z">z</code></td>
<td>
<p>an <code>idframe</code> object containing the data</p>
</td></tr>
<tr><td><code id="bj_+3A_order">order</code></td>
<td>
<p>Specification of the orders: the five integer components 
(nb,nc,nd,nf,nk) are order of polynomial B + 1, order of the polynomial C,
order of the polynomial D, order of the polynomial F, and the 
input-output delay respectively</p>
</td></tr>
<tr><td><code id="bj_+3A_init_sys">init_sys</code></td>
<td>
<p>Linear polynomial model that configures the initial parameterization.
Must be a BJ model. Overrules the <code>order</code> argument</p>
</td></tr>
<tr><td><code id="bj_+3A_options">options</code></td>
<td>
<p>Estimation Options, setup using 
<code><a href="#topic+optimOptions">optimOptions</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>SISO BJ models are of the form 
</p>
<p style="text-align: center;"><code class="reqn">
   y[k] = \frac{B(q^{-1})}{F(q^{-1})}u[k-nk] + 
   \frac{C(q^{-1})}{D(q^{-1})} e[k]
</code>
</p>

<p>The orders of Box-Jenkins model are defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">
   B(q^{-1}) = b_1 + b_2q^{-1} + \ldots + b_{nb} q^{-nb+1}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
   C(q^{-1}) = 1 + c_1q^{-1} + \ldots + c_{nc} q^{-nc}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
   D(q^{-1}) = 1 + d_1q^{-1} + \ldots + d_{nd} q^{-nd}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
   F(q^{-1}) = 1 + f_1q^{-1} + \ldots + f_{nf} q^{-nf}
</code>
</p>

<p>The function estimates the coefficients using non-linear least squares 
(Levenberg-Marquardt Algorithm)
<br />
The data is expected to have no offsets or trends. They can be removed 
using the <code><a href="#topic+detrend">detrend</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class <code>estpoly</code> containing the following elements:
</p>
<table>
<tr><td><code>sys</code></td>
<td>
<p>an <code>idpoly</code> object containing the 
fitted BJ coefficients</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the predicted response</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>the input data used</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>A list containing the following fields: <br />
<code>vcov</code> - the covariance matrix of the fitted coefficients <br />
<code>sigma</code> - the standard deviation of the innovations</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>Option set used for estimation. If no 
custom options were configured, this is a set of default options</p>
</td></tr>
<tr><td><code>termination</code></td>
<td>
<p>Termination conditions for the iterative
search used for prediction error minimization:
<code>WhyStop</code> - Reason for termination <br />
<code>iter</code> - Number of Iterations <br />
<code>iter</code> - Number of Function Evaluations </p>
</td></tr>
</table>


<h3>References</h3>

<p>Arun K. Tangirala (2015), <em>Principles of System Identification: 
Theory and Practice</em>, CRC Press, Boca Raton. Sections 14.4.1, 17.5.2, 
21.6.3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bjsim)
z &lt;- dataSlice(bjsim,end=1500) # training set
mod_bj &lt;- bj(z,c(2,1,1,1,2))
mod_bj 
residplot(mod_bj) # residual plots

</code></pre>

<hr>
<h2 id='bjsim'>Data simulated from an BJ model</h2><span id='topic+bjsim'></span>

<h3>Description</h3>

<p>This dataset contains 2046 samples simulated from the following BJ model:
</p>
<p style="text-align: center;"><code class="reqn">
 y[k] = \frac{0.6q^{-2} - 0.2q^{-3}}{1 - 0.5q^{-1}} u[k] + 
 \frac{1+0.2q^{-1}}{1 - 0.3q^{-1}} e[k]
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>bjsim
</code></pre>


<h3>Format</h3>

<p>an <code>idframe</code> object with 2046 samples, one input and one
output</p>


<h3>Details</h3>

<p>The model is simulated with a 2046 samples long full-band PRBS input.
The noise variance is set to 0.1
</p>

<hr>
<h2 id='compare'>Compare the measured output and the predicted output(s)</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>Plots the output predictions of model(s) superimposed over validation data, 
data, for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(data, nahead = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_data">data</code></td>
<td>
<p>validation data in the form of an <code>idframe</code> object</p>
</td></tr>
<tr><td><code id="compare_+3A_nahead">nahead</code></td>
<td>
<p>number of steps ahead at which to predict (Default:1). For infinite-
step ahead predictions, supply <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="compare_+3A_...">...</code></td>
<td>
<p>models whose predictions are to be compared</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+predict.estpoly">predict.estpoly</a></code> for obtaining model predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arxsim)
mod1 &lt;- arx(arxsim,c(1,2,2))
mod2 &lt;- oe(arxsim,c(2,1,1))
compare(arxsim,nahead=Inf,mod1,mod2)

</code></pre>

<hr>
<h2 id='cstr'>Continuous stirred tank reactor data (idframe)</h2><span id='topic+cstr'></span>

<h3>Description</h3>

<p>The Process is a model of a Continuous Stirring Tank Reactor, 
where the reaction is exothermic and the concentration is 
controlled by regulating the coolant flow.
<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cstr
</code></pre>


<h3>Format</h3>

<p>an <code>idframe</code> object with 7500 samples, one input and two
outputs</p>


<h3>Details</h3>

<p>Inputs: q, Coolant Flow l/min
Outputs:
</p>

<dl>
<dt>Ca</dt><dd><p>Concentration mol/l</p>
</dd>
<dt>T</dt><dd><p>Temperature Kelvin</p>
</dd></dl>


<hr>
<h2 id='cstr_mis'>Continuous stirred tank reactor data with missing values</h2><span id='topic+cstr_mis'></span>

<h3>Description</h3>

<p>This dataset is derived from the <code>cstr</code> dataset with few samples
containing missing values, in one or all variables. It is used to 
demonstrate the capabilities of the <code>misdata</code> routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cstr_mis
</code></pre>


<h3>Format</h3>

<p>an <code>idframe</code> object with 7500 samples, one input and two
outputs</p>


<h3>See Also</h3>

<p><code><a href="#topic+cstr">cstr</a></code>, <code><a href="#topic+misdata">misdata</a></code>
</p>

<hr>
<h2 id='cstrData'>Continuous stirred tank reactor data (data.frame)</h2><span id='topic+cstrData'></span>

<h3>Description</h3>

<p>The Process is a model of a Continuous Stirring Tank Reactor, 
where the reaction is exothermic and the concentration is 
controlled by regulating the coolant flow.
<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cstrData
</code></pre>


<h3>Format</h3>

<p>an <code>data.frame</code> object with 7500 rows and three columns:
q, Ca and T</p>


<h3>Details</h3>

<p>Inputs: q, Coolant Flow l/min
Outputs:
</p>

<dl>
<dt>Ca</dt><dd><p>Concentration mol/l</p>
</dd>
<dt>T</dt><dd><p>Temperature Kelvin</p>
</dd></dl>



<h3>Source</h3>

<p><a href="ftp://ftp.esat.kuleuven.be/pub/SISTA/data/process_industry/cstr.dat.gz">ftp://ftp.esat.kuleuven.be/pub/SISTA/data/process_industry/cstr.dat.gz</a>
</p>

<hr>
<h2 id='dataSlice'>Subset or Resample idframe data</h2><span id='topic+dataSlice'></span>

<h3>Description</h3>

<p><code>dataSlice</code> is a subsetting method for objects of class <code>idframe</code>. It 
extracts the subset of the object <code>data</code> observed between indices <code>start</code>
and <code>end</code>.  If a frequency is specified, the series is then re-sampled at the 
new frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataSlice(data, start = NULL, end = NULL, freq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataSlice_+3A_data">data</code></td>
<td>
<p>an object of class <code>idframe</code></p>
</td></tr>
<tr><td><code id="dataSlice_+3A_start">start</code></td>
<td>
<p>the start index</p>
</td></tr>
<tr><td><code id="dataSlice_+3A_end">end</code></td>
<td>
<p>the end index</p>
</td></tr>
<tr><td><code id="dataSlice_+3A_freq">freq</code></td>
<td>
<p>fraction of the original frequency at which the series
to be sampled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dataSlice function extends the <code><a href="stats.html#topic+window">window</a></code> 
function for idframe objects
</p>


<h3>Value</h3>

<p>an idframe object
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+window">window</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cstr)
cstrsub &lt;- dataSlice(cstr,start=200,end=400) # extract between indices 200 and 400
cstrTrain &lt;- dataSlice(cstr,end=4500) # extract upto index 4500
cstrTest &lt;- dataSlice(cstr,start=6501) # extract from index 6501 till the end
cstr_new &lt;- dataSlice(cstr,freq=0.5) # resample data at half the original frequency  

</code></pre>

<hr>
<h2 id='detrend'>Remove offsets and linear trends</h2><span id='topic+detrend'></span><span id='topic+trInfo'></span>

<h3>Description</h3>

<p>Removes offsets or trends from data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrend(x, type = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detrend_+3A_x">x</code></td>
<td>
<p>an object of class <code>idframe</code></p>
</td></tr>
<tr><td><code id="detrend_+3A_type">type</code></td>
<td>
<p>argument indicating the type of trend to be removed (Default=<code>0</code>)
</p>

<ul>
<li><p> type=<code>0</code>: Subtracts mean value from each signal
</p>
</li>
<li><p> type=<code>1</code>: Subtracts a linear trend (least-squres fit)
</p>
</li>
<li><p> type=<code>trInfo</code> object: Subtracts a trend specified by the object
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>R</code> by default doesn't allow return of multiple objects. The <code>%=%</code>
operator and <code>g</code> function in this package facillitate this behaviour. See 
the examples section for more information.
</p>


<h3>Value</h3>

<p>A list containing two objects: the detrended data and the trend information
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cstr)
datatrain &lt;- dataSlice(cstr,end=4500)
datatest &lt;- dataSlice(cstr,4501)
g(Ztrain,tr) %=% detrend(datatrain) # Remove means
g(Ztest) %=% detrend(datatest,tr)

</code></pre>

<hr>
<h2 id='estpoly'>Estimated polynomial object</h2><span id='topic+estpoly'></span>

<h3>Description</h3>

<p>Estimated discrete-time polynomial model returned from an estimation
routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estpoly(sys, fitted.values, residuals, options = NULL, call, stats,
  termination = NULL, input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estpoly_+3A_sys">sys</code></td>
<td>
<p>an <code>idpoly</code> object containing the estimated polynomial
coefficients</p>
</td></tr>
<tr><td><code id="estpoly_+3A_fitted.values">fitted.values</code></td>
<td>
<p>1-step ahead predictions on the training dataset</p>
</td></tr>
<tr><td><code id="estpoly_+3A_residuals">residuals</code></td>
<td>
<p>1-step ahead prediction errors</p>
</td></tr>
<tr><td><code id="estpoly_+3A_options">options</code></td>
<td>
<p>optimization specification ser used (applicable for non-linear least
squares)</p>
</td></tr>
<tr><td><code id="estpoly_+3A_call">call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code id="estpoly_+3A_stats">stats</code></td>
<td>
<p>a list containing estimation statistics</p>
</td></tr>
<tr><td><code id="estpoly_+3A_termination">termination</code></td>
<td>
<p>termination criteria for optimization</p>
</td></tr>
<tr><td><code id="estpoly_+3A_input">input</code></td>
<td>
<p>input signal of the training data-set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Do not use <code>estpoly</code> for directly specifing an input-output polynomial model.
<code><a href="#topic+idpoly">idpoly</a></code> is to be used instead
</p>

<hr>
<h2 id='etfe'>Estimate empirical transfer function</h2><span id='topic+etfe'></span>

<h3>Description</h3>

<p>Estimates the emperical transfer function from the data by taking the 
ratio of the fourier transforms of the output and the input variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etfe(data, n = 128)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etfe_+3A_data">data</code></td>
<td>
<p>an object of class <code>idframe</code></p>
</td></tr>
<tr><td><code id="etfe_+3A_n">n</code></td>
<td>
<p>frequency spacing (Default: <code>128</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>idfrd</code> object containing the estimated frequency response
</p>


<h3>References</h3>

<p>Arun K. Tangirala (2015), <em>Principles of System Identification: 
Theory and Practice</em>, CRC Press, Boca Raton. Sections 5.3 and 20.4.2
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fft">fft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arxsim)
frf &lt;- etfe(arxsim)

</code></pre>

<hr>
<h2 id='fitch'>Fit Characteristics</h2><span id='topic+fitch'></span>

<h3>Description</h3>

<p>Returns quantitative assessment of the estimated model as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitch(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitch_+3A_x">x</code></td>
<td>
<p>the estimated model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements
</p>
<table>
<tr><td><code>MSE</code></td>
<td>
<p>Mean Square Error measure of how well the response of the model fits
the estimation data</p>
</td></tr>
<tr><td><code>FPE</code></td>
<td>
<p>Final Prediction Error</p>
</td></tr>
<tr><td><code>FitPer</code></td>
<td>
<p>Normalized root mean squared error (NRMSE) measure of how well the 
response of the model fits the estimation data, expressed as a percentage.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Raw Akaike Information Citeria (AIC) measure of model quality</p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>Small sample-size corrected AIC</p>
</td></tr>
<tr><td><code>nAIC</code></td>
<td>
<p>Normalized AIC</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criteria (BIC)</p>
</td></tr>
</table>

<hr>
<h2 id='frd'>Frequency response data</h2><span id='topic+frd'></span>

<h3>Description</h3>

<p>This dataset contains frequency response data of an unknown SISO system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frd
</code></pre>


<h3>Format</h3>

<p>an <code>idfrd</code> object with response at 128 frequency points</p>

<hr>
<h2 id='getcov'>Parameter covariance of the identified model</h2><span id='topic+getcov'></span>

<h3>Description</h3>

<p>Obtain the parameter covariance matrix of the linear, identified 
parametric model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getcov(sys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getcov_+3A_sys">sys</code></td>
<td>
<p>a linear, identified parametric model</p>
</td></tr>
</table>

<hr>
<h2 id='idframe'>S3 class for storing input-output data.</h2><span id='topic+idframe'></span>

<h3>Description</h3>

<p><code>idframe</code> is an S3 class for storing and manipulating input-ouput data. It supports discrete time and frequency domain data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idframe(output, input = NULL, Ts = 1, start = 0, end = NULL,
  unit = c("seconds", "minutes", "hours", "days")[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idframe_+3A_output">output</code></td>
<td>
<p>dataframe/matrix/vector containing the outputs</p>
</td></tr>
<tr><td><code id="idframe_+3A_input">input</code></td>
<td>
<p>dataframe/matrix/vector containing the inputs</p>
</td></tr>
<tr><td><code id="idframe_+3A_ts">Ts</code></td>
<td>
<p>sampling interval (Default: 1)</p>
</td></tr>
<tr><td><code id="idframe_+3A_start">start</code></td>
<td>
<p>Time of the first observation</p>
</td></tr>
<tr><td><code id="idframe_+3A_end">end</code></td>
<td>
<p>Time of the last observation Optional Argument</p>
</td></tr>
<tr><td><code id="idframe_+3A_unit">unit</code></td>
<td>
<p>Time unit (Default: &quot;seconds&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an idframe object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.idframe">plot.idframe</a></code>, the plot method for idframe objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dataMatrix &lt;- matrix(rnorm(1000),ncol=5) 
data &lt;- idframe(output=dataMatrix[,3:5],input=dataMatrix[,1:2],Ts=1)

</code></pre>

<hr>
<h2 id='idfrd'>S3 class constructor for storing frequency response data</h2><span id='topic+idfrd'></span>

<h3>Description</h3>

<p>S3 class constructor for storing frequency response data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idfrd(respData, freq, Ts, spec = NULL, covData = NULL, noiseCov = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idfrd_+3A_respdata">respData</code></td>
<td>
<p>frequency response data. For SISO systems, supply a 
vector of frequency response values. For MIMO systems with Ny 
outputs and Nu inputs, supply an array of size c(Ny,Nu,Nw).</p>
</td></tr>
<tr><td><code id="idfrd_+3A_freq">freq</code></td>
<td>
<p>frequency points of the response</p>
</td></tr>
<tr><td><code id="idfrd_+3A_ts">Ts</code></td>
<td>
<p>sampling time of data</p>
</td></tr>
<tr><td><code id="idfrd_+3A_spec">spec</code></td>
<td>
<p>power spectra and cross spectra of the system 
output disturbances (noise). Supply an array of size (Ny,Ny,Nw)</p>
</td></tr>
<tr><td><code id="idfrd_+3A_covdata">covData</code></td>
<td>
<p>response data covariance matrices. Supply an array
of size (Ny,Nu,Nw,2,2). covData[ky,ku,kw,,] is the covariance matrix
of respData[ky,ku,kw]</p>
</td></tr>
<tr><td><code id="idfrd_+3A_noisecov">noiseCov</code></td>
<td>
<p>power spectra variance. Supply an array of 
size (Ny,Ny,Nw)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an idfrd object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.idfrd">plot.idfrd</a></code> for generating bode plots, 
<code><a href="#topic+spa">spa</a></code> and <code><a href="#topic+etfe">etfe</a></code> for estimating the 
frequency response given input/output data
</p>

<hr>
<h2 id='idinput'>function to generate input singals (rgs/rbs/prbs/sine)</h2><span id='topic+idinput'></span>

<h3>Description</h3>

<p><code>idinput</code> is a function for generating input signals (rgs/rbs/prbs/sine) for identification purposes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idinput(n, type = "rgs", band = c(0, 1), levels = c(-1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idinput_+3A_n">n</code></td>
<td>
<p>integer length of the input singal to be generated</p>
</td></tr>
<tr><td><code id="idinput_+3A_type">type</code></td>
<td>
<p>the type of input signal to be generated. 
'rgs' - generates random gaussian signal
'rbs' - generates random binary signal
'prbs' - generates pseudorandom binary signal
'sine' - generates a signal that is a sum of sinusoids
</p>
<p>Default value is type='rgs'</p>
</td></tr>
<tr><td><code id="idinput_+3A_band">band</code></td>
<td>
<p>determines the frequency content of the signal. 
For type='rbs'/'sine'/,  band = [wlow,whigh]
which specifies the lower and the upper bound of the passband frequencies(expressed as fractions of Nyquist frequency). Default is c(0,1)
For type='prbs', band=[0,B]
where B is such that the singal is constant over 1/B (clock period). Default is c(0,1)</p>
</td></tr>
<tr><td><code id="idinput_+3A_levels">levels</code></td>
<td>
<p>row vector defining the input level. It is of the form 
levels=c(minu, maxu)
For 'rbs','prbs', 'sine', the generated signal always between minu and maxu.
For 'rgs', minu=mean value of signal minus one standard deviation and maxu=mean value of signal plus one standard deviation
</p>
<p>Default value is levels=c(-1,1)</p>
</td></tr>
</table>

<hr>
<h2 id='idpoly'>Polynomial model with identifiable parameters</h2><span id='topic+idpoly'></span>

<h3>Description</h3>

<p>Creates a polynomial model with identifiable coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idpoly(A = 1, B = 1, C = 1, D = 1, F1 = 1, ioDelay = 0, Ts = 1,
  noiseVar = 1, intNoise = F, unit = c("seconds", "minutes", "hours",
  "days")[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idpoly_+3A_a">A</code></td>
<td>
<p>autoregressive coefficients</p>
</td></tr>
<tr><td><code id="idpoly_+3A_b">B</code>, <code id="idpoly_+3A_f1">F1</code></td>
<td>
<p>coefficients of the numerator and denominator respectively
of the deterministic model between the input and output</p>
</td></tr>
<tr><td><code id="idpoly_+3A_c">C</code>, <code id="idpoly_+3A_d">D</code></td>
<td>
<p>coefficients of the numerator and denominator respectively
of the stochastic model</p>
</td></tr>
<tr><td><code id="idpoly_+3A_iodelay">ioDelay</code></td>
<td>
<p>the delay in the input-output channel</p>
</td></tr>
<tr><td><code id="idpoly_+3A_ts">Ts</code></td>
<td>
<p>sampling interval</p>
</td></tr>
<tr><td><code id="idpoly_+3A_noisevar">noiseVar</code></td>
<td>
<p>variance of the white noise source (Default=<code>1</code>)</p>
</td></tr>
<tr><td><code id="idpoly_+3A_intnoise">intNoise</code></td>
<td>
<p>Logical variable indicating presence or absence of integrator
in the noise channel (Default=<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="idpoly_+3A_unit">unit</code></td>
<td>
<p>time unit (Default=<code>"seconds"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Discrete-time polynomials are of the form
</p>
<p style="text-align: center;"><code class="reqn">
 A(q^{-1}) y[k] = \frac{B(q^{-1})}{F1(q^{-1})} u[k] + 
 \frac{C(q^{-1})}{D(q^{-1})} e[k] 
</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'># define output-error model
mod_oe &lt;- idpoly(B=c(0.6,-0.2),F1=c(1,-0.5),ioDelay = 2,Ts=0.1,
noiseVar = 0.1)

# define box-jenkins model with unit variance
B &lt;- c(0.6,-0.2)
C &lt;- c(1,-0.3)
D &lt;- c(1,1.5,0.7)
F1 &lt;- c(1,-0.5)
mod_bj &lt;- idpoly(1,B,C,D,F1,ioDelay=1)

</code></pre>

<hr>
<h2 id='impulseest'>Estimate Impulse Response Coefficients</h2><span id='topic+impulseest'></span>

<h3>Description</h3>

<p><code>impulseest</code> is used to estimate impulse response coefficients from 
the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impulseest(x, M = 30, K = NULL, regul = F, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impulseest_+3A_x">x</code></td>
<td>
<p>an object of class <code>idframe</code></p>
</td></tr>
<tr><td><code id="impulseest_+3A_m">M</code></td>
<td>
<p>Order of the FIR Model (Default:<code>30</code>)</p>
</td></tr>
<tr><td><code id="impulseest_+3A_k">K</code></td>
<td>
<p>Transport delay in the estimated impulse response 
(Default:NULL)</p>
</td></tr>
<tr><td><code id="impulseest_+3A_regul">regul</code></td>
<td>
<p>Parameter indicating whether regularization should be 
used. (Default:<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="impulseest_+3A_lambda">lambda</code></td>
<td>
<p>The value of the regularization parameter. Valid only if
<code>regul=TRUE</code>. (Default:<code>1</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The IR Coefficients are estimated using linear least squares. Future 
Versions will provide support for multivariate data.
</p>


<h3>References</h3>

<p>Arun K. Tangirala (2015), <em>Principles of System Identification: 
Theory and Practice</em>, CRC Press, Boca Raton. Sections 17.4.11 and 20.2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+step">step</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uk &lt;- rnorm(1000,1)
yk &lt;- filter (uk,c(0.9,-0.4),method="recursive") + rnorm(1000,1)
data &lt;- idframe(output=data.frame(yk),input=data.frame(uk))
fit &lt;- impulseest(data)
impulseplot(fit)

</code></pre>

<hr>
<h2 id='impulseplot'>Impulse Response Plots</h2><span id='topic+impulseplot'></span>

<h3>Description</h3>

<p>Plots the estimated IR coefficients along with the significance limits
at each lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impulseplot(model, sd = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impulseplot_+3A_model">model</code></td>
<td>
<p>an object of class <code>impulseest</code></p>
</td></tr>
<tr><td><code id="impulseplot_+3A_sd">sd</code></td>
<td>
<p>standard deviation of the confidence region (Default: <code>2</code>)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+impulseest">impulseest</a></code>,<code><a href="#topic+step">step</a></code>
</p>

<hr>
<h2 id='inputData'>Output or Input-data</h2><span id='topic+inputData'></span><span id='topic+inputData.idframe'></span><span id='topic+outputData'></span><span id='topic+outputData.idframe'></span>

<h3>Description</h3>

<p>Extract output-data or input-data in idframe objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inputData(x, series)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inputData_+3A_x">x</code></td>
<td>
<p><code>idframe</code> object</p>
</td></tr>
<tr><td><code id="inputData_+3A_series">series</code></td>
<td>
<p>the indices to extract</p>
</td></tr>
</table>

<hr>
<h2 id='inputNames+26lt+3B-'>Extract or set series' names</h2><span id='topic+inputNames'></span><span id='topic+inputNames+3C-'></span><span id='topic+inputNames+3C-.idframe'></span><span id='topic+outputNames'></span><span id='topic+outputNames+3C-'></span><span id='topic+outputNames+3C-.idframe'></span>

<h3>Description</h3>

<p>Extract or set names of series in input or output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inputNames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inputNames+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p><code>idframe</code> object</p>
</td></tr>
<tr><td><code id="inputNames+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>vector of strings</p>
</td></tr>
</table>

<hr>
<h2 id='iv'>ARX model estimation using instrumental variable method</h2><span id='topic+iv'></span>

<h3>Description</h3>

<p>Estimates an ARX model of the specified order from input-output data using
the instrument variable method. If arbitrary instruments are not supplied 
by the user, the instruments are generated using the arx routine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv(z, order = c(0, 1, 0), x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iv_+3A_z">z</code></td>
<td>
<p>an idframe object containing the data</p>
</td></tr>
<tr><td><code id="iv_+3A_order">order</code></td>
<td>
<p>Specification of the orders: the three integer components 
(na,nb,nk) are the order of polynolnomial A, (order of polynomial B + 1) 
and the input-output delay</p>
</td></tr>
<tr><td><code id="iv_+3A_x">x</code></td>
<td>
<p>instrument variable matrix. x must be of the same size as the output 
data. (Default: <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>estpoly</code> containing the following elements:
</p>
<table>
<tr><td><code>sys</code></td>
<td>
<p>an <code>idpoly</code> object containing the 
fitted ARX coefficients</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the predicted response</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>the input data used</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>A list containing the following fields: <br />
<code>vcov</code> - the covariance matrix of the fitted coefficients <br />
<code>sigma</code> - the standard deviation of the innovations<br />
<code>df</code> - the residual degrees of freedom</p>
</td></tr>
</table>


<h3>References</h3>

<p>Arun K. Tangirala (2015), <em>Principles of System Identification: 
Theory and Practice</em>, CRC Press, Boca Raton. Sections 21.7.1, 21.7.2
</p>
<p>Lennart Ljung (1999), <em>System Identification: Theory for the User</em>, 
2nd Edition, Prentice Hall, New York. Section 7.6
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+iv4">iv4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arxsim)
mod_iv &lt;- iv(arxsim,c(2,1,1))

</code></pre>

<hr>
<h2 id='iv4'>ARX model estimation using four-stage instrumental variable method</h2><span id='topic+iv4'></span>

<h3>Description</h3>

<p>Estimates an ARX model of the specified order from input-output data using
the instrument variable method. The estimation algorithm is insensitive to 
the color of the noise term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iv4(z, order = c(0, 1, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iv4_+3A_z">z</code></td>
<td>
<p>an idframe object containing the data</p>
</td></tr>
<tr><td><code id="iv4_+3A_order">order</code></td>
<td>
<p>Specification of the orders: the three integer components 
(na,nb,nk) are the order of polynolnomial A, (order of polynomial B + 1) 
and the input-output delay</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation is performed in 4 stages. The first stage uses the arx function. The resulting model generates the 
instruments for a second-stage IV estimate. The residuals obtained from this model are modeled using a sufficently
high-order AR model. At the fourth stage, the input-output data is filtered through this AR model and then subjected 
to the IV function with the same instrument filters as in the second stage.
</p>


<h3>Value</h3>

<p>An object of class <code>estpoly</code> containing the following elements:
</p>
<table>
<tr><td><code>sys</code></td>
<td>
<p>an <code>idpoly</code> object containing the 
fitted ARX coefficients</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the predicted response</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>the input data used</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>A list containing the following fields: <br />
<code>vcov</code> - the covariance matrix of the fitted coefficients <br />
<code>sigma</code> - the standard deviation of the innovations<br />
<code>df</code> - the residual degrees of freedom</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lennart Ljung (1999), <em>System Identification: Theory for the User</em>, 
2nd Edition, Prentice Hall, New York. Section 15.3
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arx">arx</a></code>, <code><a href="#topic+iv4">iv4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod_dgp &lt;- idpoly(A=c(1,-0.5),B=c(0.6,-.2),C=c(1,0.6),ioDelay = 2,noiseVar = 0.1)
u &lt;- idinput(400,"prbs")
y &lt;- sim(mod_dgp,u,addNoise=TRUE)
z &lt;- idframe(y,u)
mod_iv4 &lt;- iv4(z,c(1,2,2))

</code></pre>

<hr>
<h2 id='misdata'>Replace Missing Data by Interpolation</h2><span id='topic+misdata'></span>

<h3>Description</h3>

<p>Function for replacing missing values with interpolated ones. This is an
extension of the <code>na.approx</code> function from the <code>zoo</code> package.
The missing data is indicated using the value <em>NA</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>misdata(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="misdata_+3A_data">data</code></td>
<td>
<p>an object of class <code>idframe</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>data (an idframe object) with missing data replaced.
</p>


<h3>See Also</h3>

<p><code><a href="zoo.html#topic+na.approx">na.approx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cstr_mis)
summary(cstr_mis) # finding out the number of NAs
cstr &lt;- misdata(cstr_mis)

</code></pre>

<hr>
<h2 id='nInputSeries'>Number of series in input or output</h2><span id='topic+nInputSeries'></span><span id='topic+nOutputSeries'></span>

<h3>Description</h3>

<p>Number of series in input or output in a idframe object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nInputSeries(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nInputSeries_+3A_data">data</code></td>
<td>
<p><code>idframe</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='oe'>Estimate Output-Error Models</h2><span id='topic+oe'></span>

<h3>Description</h3>

<p>Fit an output-error model of the specified order given the input-output data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe(x, order = c(1, 1, 0), init_sys = NULL, options = optimOptions())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oe_+3A_x">x</code></td>
<td>
<p>an object of class <code>idframe</code></p>
</td></tr>
<tr><td><code id="oe_+3A_order">order</code></td>
<td>
<p>Specification of the orders: the four integer components 
(nb,nf,nk) are order of polynomial B + 1, order of the polynomial F,
and the input-output delay respectively</p>
</td></tr>
<tr><td><code id="oe_+3A_init_sys">init_sys</code></td>
<td>
<p>Linear polynomial model that configures the initial parameterization.
Must be an OE model. Overrules the <code>order</code> argument</p>
</td></tr>
<tr><td><code id="oe_+3A_options">options</code></td>
<td>
<p>Estimation Options, setup using 
<code><a href="#topic+optimOptions">optimOptions</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>SISO OE models are of the form 
</p>
<p style="text-align: center;"><code class="reqn">
   y[k] + f_1 y[k-1] + \ldots + f_{nf} y[k-nf] = b_{nk} u[k-nk] + 
   \ldots + b_{nk+nb} u[k-nk-nb] + f_{1} e[k-1] + \ldots f_{nf} e[k-nf]
   + e[k] 
</code>
</p>

<p>The function estimates the coefficients using non-linear least squares 
(Levenberg-Marquardt Algorithm)
<br />
The data is expected to have no offsets or trends. They can be removed 
using the <code><a href="#topic+detrend">detrend</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class <code>estpoly</code> containing the following elements:
</p>
<table>
<tr><td><code>sys</code></td>
<td>
<p>an <code>idpoly</code> object containing the 
fitted OE coefficients</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the predicted response</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>the input data used</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>A list containing the following fields: <br />
<code>vcov</code> - the covariance matrix of the fitted coefficients <br />
<code>sigma</code> - the standard deviation of the innovations</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>Option set used for estimation. If no 
custom options were configured, this is a set of default options</p>
</td></tr>
<tr><td><code>termination</code></td>
<td>
<p>Termination conditions for the iterative
search used for prediction error minimization:
<code>WhyStop</code> - Reason for termination <br />
<code>iter</code> - Number of Iterations <br />
<code>iter</code> - Number of Function Evaluations </p>
</td></tr>
</table>


<h3>References</h3>

<p>Arun K. Tangirala (2015), <em>Principles of System Identification: 
Theory and Practice</em>, CRC Press, Boca Raton. Sections 14.4.1, 17.5.2, 
21.6.3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oesim)
z &lt;- dataSlice(oesim,end=1533) # training set
mod_oe &lt;- oe(z,c(2,1,2))
mod_oe 
plot(mod_oe) # plot the predicted and actual responses

</code></pre>

<hr>
<h2 id='oesim'>Data simulated from an OE model</h2><span id='topic+oesim'></span>

<h3>Description</h3>

<p>This dataset contains 2555 samples simulated from the following OE model:
</p>
<p style="text-align: center;"><code class="reqn">
 y[k] = \frac{0.6q^{-2} - 0.2q^{-3}}{1 - 0.5q^{-1}} u[k] + e[k]
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>oesim
</code></pre>


<h3>Format</h3>

<p>an <code>idframe</code> object with 2555 samples, one input and one
output</p>


<h3>Details</h3>

<p>The model is simulated with a 2555 samples long full-band PRBS input.
The noise variance is set to 0.1
</p>

<hr>
<h2 id='optimOptions'>Create optimization options</h2><span id='topic+optimOptions'></span>

<h3>Description</h3>

<p>Specify optimization options that are to be passed to the 
numerical estimation routines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimOptions(tol = 0.01, maxIter = 20, LMinit = 0.01, LMstep = 2,
  display = c("off", "on")[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimOptions_+3A_tol">tol</code></td>
<td>
<p>Minimum 2-norm of the gradient (Default: <code>1e-2</code>)</p>
</td></tr>
<tr><td><code id="optimOptions_+3A_maxiter">maxIter</code></td>
<td>
<p>Maximum number of iterations to be performed</p>
</td></tr>
<tr><td><code id="optimOptions_+3A_lminit">LMinit</code></td>
<td>
<p>Starting value of search-direction length 
in the Levenberg-Marquardt method (Default: <code>0.01</code>)</p>
</td></tr>
<tr><td><code id="optimOptions_+3A_lmstep">LMstep</code></td>
<td>
<p>Size of the Levenberg-Marquardt step (Default: <code>2</code>)</p>
</td></tr>
<tr><td><code id="optimOptions_+3A_display">display</code></td>
<td>
<p>Argument whether to display iteration details or not
(Default: <code>"off"</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='plot.idframe'>Plotting idframe objects</h2><span id='topic+plot.idframe'></span>

<h3>Description</h3>

<p>Plotting method for objects inherting from class <code>idframe</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'idframe'
plot(x, col = "steelblue", lwd = 1, main = NULL,
  size = 12, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.idframe_+3A_x">x</code></td>
<td>
<p>an <code>idframe</code> object</p>
</td></tr>
<tr><td><code id="plot.idframe_+3A_col">col</code></td>
<td>
<p>line color, to be passed to plot.(Default=<code>"steelblue"</code>)</p>
</td></tr>
<tr><td><code id="plot.idframe_+3A_lwd">lwd</code></td>
<td>
<p>line width, in millimeters(Default=<code>1</code>)</p>
</td></tr>
<tr><td><code id="plot.idframe_+3A_main">main</code></td>
<td>
<p>the plot title. (Default = <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="plot.idframe_+3A_size">size</code></td>
<td>
<p>text size (Default = <code>12</code>)</p>
</td></tr>
<tr><td><code id="plot.idframe_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(cstr)
plot(cstr,col="blue")

</code></pre>

<hr>
<h2 id='plot.idfrd'>Plotting idfrd objects</h2><span id='topic+plot.idfrd'></span>

<h3>Description</h3>

<p>Generates the bode plot of the given frequency response data. It uses the
ggplot2 plotting engine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'idfrd'
plot(x, col = "steelblue", lwd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.idfrd_+3A_x">x</code></td>
<td>
<p>An object of class <code>idframe</code></p>
</td></tr>
<tr><td><code id="plot.idfrd_+3A_col">col</code></td>
<td>
<p>a specification for the line colour (Default : <code>"
steelblue"</code>)</p>
</td></tr>
<tr><td><code id="plot.idfrd_+3A_lwd">lwd</code></td>
<td>
<p>the line width, a positive number, defaulting to 1</p>
</td></tr>
<tr><td><code id="plot.idfrd_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(frd)
plot(frd)

</code></pre>

<hr>
<h2 id='predict.estpoly'>Predictions of identified model</h2><span id='topic+predict.estpoly'></span>

<h3>Description</h3>

<p>Predicts the output of an identified model (<code>estpoly</code>) object K steps ahead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estpoly'
predict(object, newdata = NULL, nahead = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.estpoly_+3A_object">object</code></td>
<td>
<p><code>estpoly</code> object containing the identified model</p>
</td></tr>
<tr><td><code id="predict.estpoly_+3A_newdata">newdata</code></td>
<td>
<p>optional dataset to be used for predictions. If not supplied, 
predictions are made on the training set.</p>
</td></tr>
<tr><td><code id="predict.estpoly_+3A_nahead">nahead</code></td>
<td>
<p>number of steps ahead at which to predict (Default:1). For infinite-
step ahead predictions or pure simulation, supply <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="predict.estpoly_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time-series containing the predictions
</p>


<h3>References</h3>

<p>Arun K. Tangirala (2015), <em>Principles of System Identification: Theory 
and Practice</em>, CRC Press, Boca Raton. Chapter 18
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arxsim)
mod1 &lt;- oe(arxsim,c(2,1,1))
Yhat &lt;- predict(mod1,arxsim) #  1-step ahead predictions 
Yhat_2 &lt;- predict(mod1,arxsim,nahead=2) # 2-step ahead predictions
Yhat_inf &lt;- predict(mod1,arxsim,nahead=Inf) # Infinite-step ahead predictions

</code></pre>

<hr>
<h2 id='rarx'>Estimate parameters of ARX recursively</h2><span id='topic+rarx'></span>

<h3>Description</h3>

<p>Estimates the parameters of a single-output ARX model of the 
specified order from data using the recursive weighted least-squares
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rarx(x, order = c(1, 1, 1), lambda = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rarx_+3A_x">x</code></td>
<td>
<p>an object of class <code>idframe</code></p>
</td></tr>
<tr><td><code id="rarx_+3A_order">order</code></td>
<td>
<p>Specification of the orders: the three integer components 
(na,nb,nk) are the order of polynolnomial A, (order of polynomial B + 1) and 
the input-output delay</p>
</td></tr>
<tr><td><code id="rarx_+3A_lambda">lambda</code></td>
<td>
<p>Forgetting factor(Default=<code>0.95</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects
</p>

<dl>
<dt>theta</dt><dd><p>Estimated parameters of the model. The <code class="reqn">k^{th}</code> 
row contains the parameters associated with the <code class="reqn">k^{th}</code> 
sample. Each row in <code>theta</code> has the following format: <br />
theta[i,:]=[a1,a2,...,ana,b1,...bnb]
</p>
</dd>
<dt>yhat</dt><dd><p>Predicted value of the output, according to the 
current model - parameters based on all past data</p>
</dd>
</dl>



<h3>References</h3>

<p>Arun K. Tangirala (2015), <em>Principles of System Identification: 
Theory and Practice</em>, CRC Press, Boca Raton. Section 25.1.3
</p>
<p>Lennart Ljung (1999), <em>System Identification: Theory for the User</em>, 
2nd Edition, Prentice Hall, New York. Section 11.2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Gp1 &lt;- idpoly(c(1,-0.9,0.2),2,ioDelay=2,noiseVar = 0.1)
Gp2 &lt;- idpoly(c(1,-1.2,0.35),2.5,ioDelay=2,noiseVar = 0.1)
uk = idinput(2044,'prbs',c(0,1/4)); N = length(uk);
N1 = round(0.35*N); N2 = round(0.4*N); N3 = N-N1-N2;
yk1 &lt;- sim(Gp1,uk[1:N1],addNoise = TRUE)
yk2 &lt;- sim(Gp2,uk[N1+1:N2],addNoise = TRUE)
yk3 &lt;- sim(Gp1,uk[N1+N2+1:N3],addNoise = TRUE)
yk &lt;- c(yk1,yk2,yk3)
z &lt;- idframe(yk,uk,1)
g(theta,yhat) %=% rarx(z,c(2,1,2))

</code></pre>

<hr>
<h2 id='read.idframe'>Data input into a idframe object</h2><span id='topic+read.idframe'></span>

<h3>Description</h3>

<p>Read the contents of a data.frame/matrix into a <code>idframe</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.idframe(data, ninputs = NULL, Ts = 1, unit = c("seconds", "minutes",
  "hours", "days")[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.idframe_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> object</p>
</td></tr>
<tr><td><code id="read.idframe_+3A_ninputs">ninputs</code></td>
<td>
<p>the number of input columns. (Default: 0)</p>
</td></tr>
<tr><td><code id="read.idframe_+3A_ts">Ts</code></td>
<td>
<p>sampling interval (Default: 1)</p>
</td></tr>
<tr><td><code id="read.idframe_+3A_unit">unit</code></td>
<td>
<p>Time Unit (Default: &quot;seconds&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an idframe object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cstrData)
data &lt;- read.idframe(cstrData,ninputs=1,Ts= 1,unit="minutes")

</code></pre>

<hr>
<h2 id='read.table.idframe'>Read the contents of a table-formatted file</h2><span id='topic+read.table.idframe'></span>

<h3>Description</h3>

<p>Read the contents of an file in table format into a <code>idframe</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.table.idframe(file, header = TRUE, sep = ",", ninputs = 0, Ts = 1,
  unit = c("seconds", "minutes", "hours", "days")[1], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.table.idframe_+3A_file">file</code></td>
<td>
<p>the path to the file to read</p>
</td></tr>
<tr><td><code id="read.table.idframe_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the first row corresponding to 
the first element of the rowIndex vector contains the names of the variables. 
(Default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="read.table.idframe_+3A_sep">sep</code></td>
<td>
<p>the field separator character. Values on each line of the file are 
separated by this character. (Default: <code>","</code>)</p>
</td></tr>
<tr><td><code id="read.table.idframe_+3A_ninputs">ninputs</code></td>
<td>
<p>the number of input columns. (Default: 0)</p>
</td></tr>
<tr><td><code id="read.table.idframe_+3A_ts">Ts</code></td>
<td>
<p>sampling interval (Default: 1)</p>
</td></tr>
<tr><td><code id="read.table.idframe_+3A_unit">unit</code></td>
<td>
<p>Time Unit (Default: &quot;seconds&quot;)</p>
</td></tr>
<tr><td><code id="read.table.idframe_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the <code><a href="utils.html#topic+read.table">read.table</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>read.table.idframe</code> function uses the <code><a href="utils.html#topic+read.table">read.table</a></code> function, 
provided by the <span class="pkg">utils</span> package, to read data from a table-formatted file and then calls the 
<code><a href="#topic+read.idframe">read.idframe</a></code> function to read the data into a idframe object
</p>


<h3>Value</h3>

<p>an idframe object
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataMatrix &lt;- data.frame(matrix(rnorm(1000),ncol=5))
colnames(dataMatrix) &lt;- c("u1","u2","y1","y2","y3")
write.csv(dataMatrix,file="test.csv",row.names=FALSE)
 
data &lt;- read.table.idframe("test.csv",ninputs=2,unit="minutes")

</code></pre>

<hr>
<h2 id='residplot'>Plot residual characteristics</h2><span id='topic+residplot'></span>

<h3>Description</h3>

<p>Computes the 1-step ahead prediction errors (residuals) for an estimated polynomial
model, and plots auto-correlation of the residuals and the 
cross-correlation of the residuals with the input signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residplot(model, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residplot_+3A_model">model</code></td>
<td>
<p>estimated polynomial model</p>
</td></tr>
<tr><td><code id="residplot_+3A_newdata">newdata</code></td>
<td>
<p>an optional dataset on which predictions are to be computed. If
not supplied, predictions are computed on the training dataset.</p>
</td></tr>
</table>

<hr>
<h2 id='sim'>Simulate response of dynamic system</h2><span id='topic+sim'></span>

<h3>Description</h3>

<p>Simulate the response of a system to a given input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(model, input, addNoise = F, innov = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_+3A_model">model</code></td>
<td>
<p>the linear system to simulate</p>
</td></tr>
<tr><td><code id="sim_+3A_input">input</code></td>
<td>
<p>a vector/matrix containing the input</p>
</td></tr>
<tr><td><code id="sim_+3A_addnoise">addNoise</code></td>
<td>
<p>logical variable indicating whether to add noise to the 
response model. (Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="sim_+3A_innov">innov</code></td>
<td>
<p>an optional times series of innovations. If not supplied (specified
as <code>NULL</code>), gaussian white noise is generated, with the variance specified in 
the model (Property: <code>noiseVar</code>)</p>
</td></tr>
<tr><td><code id="sim_+3A_seed">seed</code></td>
<td>
<p>integer indicating the seed value of the random number generator.
Useful for reproducibility purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine is currently built only for SISO systems. Future versions will
include support for MIMO systems.
</p>


<h3>Value</h3>

<p>a vector containing the simulated output
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ARX Model
u &lt;- idinput(300,"rgs")
model &lt;- idpoly(A=c(1,-1.5,0.7),B=c(0.8,-0.25),ioDelay=1,
noiseVar=0.1)
y &lt;- sim(model,u,addNoise=TRUE)

</code></pre>

<hr>
<h2 id='spa'>Estimate frequency response</h2><span id='topic+spa'></span>

<h3>Description</h3>

<p>Estimates frequency response and noise spectrum from data with 
fixed resolution using spectral analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa(x, winsize = NULL, freq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_+3A_x">x</code></td>
<td>
<p>an <code>idframe</code> object</p>
</td></tr>
<tr><td><code id="spa_+3A_winsize">winsize</code></td>
<td>
<p>lag size of the Hanning window (Default: <code>min
(length(x)/10,30)</code>)</p>
</td></tr>
<tr><td><code id="spa_+3A_freq">freq</code></td>
<td>
<p>frequency points at which the response is evaluated
(Default: <code>seq(1,128)/128*pi/Ts</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>idfrd</code> object containing the estimated frequency response 
and the noise spectrum
</p>


<h3>References</h3>

<p>Arun K. Tangirala (2015), <em>Principles of System Identification: 
Theory and Practice</em>, CRC Press, Boca Raton. Sections 16.5 and 20.4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arxsim)
frf &lt;- spa(arxsim)

</code></pre>

<hr>
<h2 id='step'>Step Response Plots</h2><span id='topic+step'></span>

<h3>Description</h3>

<p>Plots the step response of a system, given the IR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_+3A_model">model</code></td>
<td>
<p>an object of class <code>impulseest</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+impulseest">impulseest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uk &lt;- rnorm(1000,1)
yk &lt;- filter (uk,c(0.9,-0.4),method="recursive") + rnorm(1000,1)
data &lt;- idframe(output=data.frame(yk),input=data.frame(uk))
fit &lt;- impulseest(data)
step(fit) 

</code></pre>

<hr>
<h2 id='time'>Sampling times of IO data
<code>time</code> creates the vector of times at which data was sampled. <code>frequency</code> returns the number of damples per unit time and <code>deltat</code> the time-interval 
between observations</h2><span id='topic+deltat'></span><span id='topic+frequency'></span><span id='topic+time'></span>

<h3>Description</h3>

<p>Sampling times of IO data
</p>
<p><code>time</code> creates the vector of times at which data was sampled. <code>frequency</code> returns the number of damples per unit time and <code>deltat</code> the time-interval 
between observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_+3A_x">x</code></td>
<td>
<p>a idframe object, or a univariate or multivariate time-series, or a vector or matrix</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
