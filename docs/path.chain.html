<!DOCTYPE html><html><head><title>Help for package path.chain</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {path.chain}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#path.chain-package'><p>path.chain: Concise Structure for Chainable Paths</p></a></li>
<li><a href='#+24.path_chain'><p>Access path_chain object</p></a></li>
<li><a href='#as_config'><p>Prepare list to be saved as config .yaml file</p></a></li>
<li><a href='#as_path_chain'><p>Create chainable path</p></a></li>
<li><a href='#as.list'><p>Convert object of type 'path_chain' to list</p></a></li>
<li><a href='#create_sample_dir'><p>Create sample directory</p></a></li>
<li><a href='#create_temp_dir'><p>Create temporary diectory and return its name</p></a></li>
<li><a href='#file_path'><p>Construct path to file without doubled separators</p></a></li>
<li><a href='#full_path_chain'><p>Full path chain</p></a></li>
<li><a href='#naming_k'><p>Naming convention, which adds k prefix for each key, capitalizes and removes file extension</p></a></li>
<li><a href='#on_path_not_exists'><p>Function called if path does not exists</p></a></li>
<li><a href='#on_validate_path'><p>Function called to validate path correctness</p></a></li>
<li><a href='#path_chain'><p>Get directory structure and create path_chain object</p></a></li>
<li><a href='#path_children'><p>Get children nodes, i.e. all the suddiectories in the given directory</p></a></li>
<li><a href='#path_link'><p>Creates a link of path chain - a directory or a file</p></a></li>
<li><a href='#print'><p>Print path_chain object</p></a></li>
<li><a href='#temp_path'><p>Construct path to file in a temporary directory</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Concise Structure for Chainable Paths</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides path_chain class and functions, which facilitates loading and saving 
             directory structure in YAML configuration files via 'config' package. 
             The file structure you created during exploration can be transformed 
             into legible section in the config file, and then easily loaded for further usage.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/krzjoa/path.chain/issues">https://github.com/krzjoa/path.chain/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/krzjoa/path.chain">https://github.com/krzjoa/path.chain</a>,
<a href="https://krzjoa.github.io/path.chain/">https://krzjoa.github.io/path.chain/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown, config, yaml, fs,
magrittr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, stringi, logger</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-16 21:03:38 UTC; krzysztof</td>
</tr>
<tr>
<td>Author:</td>
<td>Krzysztof Joachimiak
    <a href="https://orcid.org/0000-0003-4780-7947"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Krzysztof Joachimiak &lt;joachimiak.krzysztof@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-23 09:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='path.chain-package'>path.chain: Concise Structure for Chainable Paths</h2><span id='topic+path.chain-package'></span><span id='topic+path.chain'></span>

<h3>Description</h3>

<p>The aim of this package is to provide tools,
which allow us to represent directory structure as
nested R objects. It can be easily saved as .yaml
files so that we can later load it and use in our project.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Joachimiak
</p>

<hr>
<h2 id='+24.path_chain'>Access path_chain object</h2><span id='topic++24.path_chain'></span>

<h3>Description</h3>

<p>Access path_chain object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'path_chain'
node$child
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24.path_chain_+3A_node">node</code></td>
<td>
<p>path_chain</p>
</td></tr>
<tr><td><code id="+2B24.path_chain_+3A_child">child</code></td>
<td>
<p>nested path_chain name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>path_chain or character, if path indicates leaf of structure tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' If we want to create our chain manually, we have start from the leaves
level2.b &lt;- path_link("fileA.RData")
level2.a &lt;- path_link("fileB.RData")
level1   &lt;- path_link("data", list(level2.a = level2.a , level2.b = level2.b))
root     &lt;- path_link("files", list(level1))
# Print root path
root$.
# Print file path using chaining
root$data$level2.a
</code></pre>

<hr>
<h2 id='as_config'>Prepare list to be saved as config .yaml file</h2><span id='topic+as_config'></span><span id='topic+as_config.path_chain'></span><span id='topic+as_config.list'></span>

<h3>Description</h3>

<p>This function is provided to keep compatibility
with 'config' package, which requires existence of default key.
Additionally, we can at once wrap our structure with some other keys,
in order to not to mix directory structur with different keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_config(x, config = "default", wrap = "dirs", ...)

## S3 method for class 'path_chain'
as_config(x, config = "default", wrap = "dirs",
  ..., root.name = "root.dir")

## S3 method for class 'list'
as_config(x, config = "default", wrap = "dirs", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_config_+3A_x">x</code></td>
<td>
<p>list with directory structure</p>
</td></tr>
<tr><td><code id="as_config_+3A_config">config</code></td>
<td>
<p>configuration name</p>
</td></tr>
<tr><td><code id="as_config_+3A_wrap">wrap</code></td>
<td>
<p>key name to wrap directory structure</p>
</td></tr>
<tr><td><code id="as_config_+3A_...">...</code></td>
<td>
<p>additional arguments (not used at the moment)</p>
</td></tr>
<tr><td><code id="as_config_+3A_root.name">root.name</code></td>
<td>
<p>key for root directory (for path_chain only)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list compatible with 'config' package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
# Initalizaing sample directory
tmp &lt;- create_temp_dir("files")
create_sample_dir(tmp, override = TRUE)
full_path_chain(tmp, "kRoot", naming_k) %&gt;%
   list(kDirs = .) %&gt;%
   list(default = .) %&gt;%
   yaml::write_yaml(temp_path("config.yaml"))
# We can simply use such function
full_path_chain(tmp, "kRoot", naming_k) %&gt;%
   as_config("default", "kDirs") %&gt;%
   yaml::write_yaml(temp_path("config.yaml"))
</code></pre>

<hr>
<h2 id='as_path_chain'>Create chainable path</h2><span id='topic+as_path_chain'></span>

<h3>Description</h3>

<p>This function always treats first object in the nested list
as a subdirectory root path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_path_chain(nested.list, root.name = "kRoot")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_path_chain_+3A_nested.list">nested.list</code></td>
<td>
<p>'list' object with nested lists/strings inside</p>
</td></tr>
<tr><td><code id="as_path_chain_+3A_root.name">root.name</code></td>
<td>
<p>key for root directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>path_chain object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
# Manually created nested list
nested.list &lt;- list(kRoot = "root", "file1.txt", list("subdir", "file2.csv"))
chainable.path &lt;- as_path_chain(nested.list)
class(chainable.path)
chainable.path$.
chainable.path$subdir$files2.csv
# Nested list from config file
tmp &lt;- create_temp_dir("files")
create_sample_dir(tmp, override = TRUE)
fs::dir_tree(tmp)
path_chain(tmp, naming = naming_k) %&gt;%
  as.list(root.name = "kRoot") %&gt;%
  as_config("default", "kDirs") %&gt;%
  yaml::write_yaml(temp_path("config.yaml"))
chainable.path &lt;- config::get("kDirs", "defaul", temp_path("config.yaml")) %&gt;%
 as_path_chain()
class(chainable.path)
chainable.path$.
chainable.path$kData$kExample1
</code></pre>

<hr>
<h2 id='as.list'>Convert object of type 'path_chain' to list</h2><span id='topic+as.list'></span><span id='topic+as.list.path_chain'></span>

<h3>Description</h3>

<p>Convert object of type 'path_chain' to list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'path_chain'
as.list(x, ..., root.name = "root.dir")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list_+3A_x">x</code></td>
<td>
<p>a path_chain object</p>
</td></tr>
<tr><td><code id="as.list_+3A_...">...</code></td>
<td>
<p>elipsis for API consistency, does nothing</p>
</td></tr>
<tr><td><code id="as.list_+3A_root.name">root.name</code></td>
<td>
<p>key for root directory; default: 'root.dir'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- create_temp_dir("files")
create_sample_dir(tmp)
path.chain &lt;- path_chain(tmp)
as.list(path.chain)
</code></pre>

<hr>
<h2 id='create_sample_dir'>Create sample directory</h2><span id='topic+create_sample_dir'></span>

<h3>Description</h3>

<p>Creates sample nested directory to test and learn path.chain package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_sample_dir(path = "files", override = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_sample_dir_+3A_path">path</code></td>
<td>
<p>path for the new sample folder</p>
</td></tr>
<tr><td><code id="create_sample_dir_+3A_override">override</code></td>
<td>
<p>boolean: override folder if it already exists</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- create_temp_dir("files")
create_sample_dir(tmp, override = TRUE)
list.files(tmp, all.files = TRUE, recursive = TRUE, include.dirs = TRUE)
fs::dir_tree(tmp)
</code></pre>

<hr>
<h2 id='create_temp_dir'>Create temporary diectory and return its name</h2><span id='topic+create_temp_dir'></span>

<h3>Description</h3>

<p>Create temporary diectory and return its name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_temp_dir(..., warn = FALSE, recursive = FALSE,
  fsep = .Platform$file.sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_temp_dir_+3A_...">...</code></td>
<td>
<p>arbitrary character objects</p>
</td></tr>
<tr><td><code id="create_temp_dir_+3A_warn">warn</code></td>
<td>
<p>warn, if folder already exists</p>
</td></tr>
<tr><td><code id="create_temp_dir_+3A_recursive">recursive</code></td>
<td>
<p>ogical. Should elements of the path other than the last be created?
If true, like the Unix command mkdir -p</p>
</td></tr>
<tr><td><code id="create_temp_dir_+3A_fsep">fsep</code></td>
<td>
<p>the path separator to use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Simply create and return temporal directory
create_temp_dir()
# Create temp dir and return concatenated path
# Keep in mind, that 'files' and 'report_2020.xls' will not be created.
create_temp_dir("files", "report_2020.xls")
</code></pre>

<hr>
<h2 id='file_path'>Construct path to file without doubled separators</h2><span id='topic+file_path'></span>

<h3>Description</h3>

<p>Construct path to file without doubled separators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_path(..., fsep = .Platform$file.sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_path_+3A_...">...</code></td>
<td>
<p>character vectors</p>
</td></tr>
<tr><td><code id="file_path_+3A_fsep">fsep</code></td>
<td>
<p>the path separator to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character file path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file.path("files/", "data/", "cars.RData")
file_path("files/", "data/", "cars.RData")
</code></pre>

<hr>
<h2 id='full_path_chain'>Full path chain</h2><span id='topic+full_path_chain'></span>

<h3>Description</h3>

<p>'full_path_chain' represents another approach to creating chainable paths
In contrast to 'path_chain', this functon creates just a list with nested list with full paths as a leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full_path_chain(path = ".", root.name = ".", naming = basename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full_path_chain_+3A_path">path</code></td>
<td>
<p>root path</p>
</td></tr>
<tr><td><code id="full_path_chain_+3A_root.name">root.name</code></td>
<td>
<p>naming convention for root directory</p>
</td></tr>
<tr><td><code id="full_path_chain_+3A_naming">naming</code></td>
<td>
<p>naming function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of lists and character objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- create_temp_dir("files")
create_sample_dir(tmp, override = TRUE)
fs::dir_tree(tmp)
chainable.path &lt;- full_path_chain(tmp)
chainable.path
</code></pre>

<hr>
<h2 id='naming_k'>Naming convention, which adds k prefix for each key, capitalizes and removes file extension</h2><span id='topic+naming_k'></span>

<h3>Description</h3>

<p>Naming convention, which adds k prefix for each key, capitalizes and removes file extension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naming_k(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="naming_k_+3A_path">path</code></td>
<td>
<p>full path or its element</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
naming_k("path/to/myfile.txt")
# Using with full_path_chain
tmp &lt;- create_temp_dir("files")
create_sample_dir(tmp, override = TRUE)
full.path.chain &lt;- full_path_chain(tmp, naming = naming_k)
full.path.chain
tmp &lt;- create_temp_dir("files")
create_sample_dir(tmp)
# Using with path_chain / create_path_chain
path.chain &lt;- path_chain(tmp, naming = naming_k)
path.chain %&gt;%
  as.list()
</code></pre>

<hr>
<h2 id='on_path_not_exists'>Function called if path does not exists</h2><span id='topic+on_path_not_exists'></span>

<h3>Description</h3>

<p>Function called if path does not exists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>on_path_not_exists(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="on_path_not_exists_+3A_fun">fun</code></td>
<td>
<p>a function, one-side formula or NULL; if missing,
returns value of the path.chain.on.path.not.exists option</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># We'll create an options backup for this example
old.options &lt;- options()
on_path_not_exists(print)
on_path_not_exists()
options(old.options)
</code></pre>

<hr>
<h2 id='on_validate_path'>Function called to validate path correctness</h2><span id='topic+on_validate_path'></span>

<h3>Description</h3>

<p>Function called to validate path correctness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>on_validate_path(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="on_validate_path_+3A_fun">fun</code></td>
<td>
<p>a function; if missing, returns value of the path.chain.on.path.not.exists option</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># We'll create an options backup for this example
old.options &lt;- options()
is_path_valid &lt;- function(x) grepl("\\.fst", x)
on_validate_path(is_path_valid)
on_validate_path()
options(old.options)
</code></pre>

<hr>
<h2 id='path_chain'>Get directory structure and create path_chain object</h2><span id='topic+path_chain'></span>

<h3>Description</h3>

<p>Returns 'path_chain' object, which reflects
structure of the folder passed with 'path' param
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_chain(path, naming = basename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_chain_+3A_path">path</code></td>
<td>
<p>root of the directory structure</p>
</td></tr>
<tr><td><code id="path_chain_+3A_naming">naming</code></td>
<td>
<p>function, which defines naming convention</p>
</td></tr>
</table>


<h3>Value</h3>

<p>path_chain object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- create_temp_dir("files")
create_sample_dir(tmp, override = TRUE)
fs::dir_tree(tmp)
chainable.path &lt;- path_chain(tmp)
chainable.path$data$persons.csv
# With customized naming convention
chainable.path &lt;- path_chain(tmp, naming = naming_k)
chainable.path$kData$kPersons
</code></pre>

<hr>
<h2 id='path_children'>Get children nodes, i.e. all the suddiectories in the given directory</h2><span id='topic+path_children'></span>

<h3>Description</h3>

<p>Get children nodes, i.e. all the suddiectories in the given directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_children(path.chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_children_+3A_path.chain">path.chain</code></td>
<td>
<p>object of 'path_chain' class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 'path_chain' objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- create_temp_dir("files")
create_sample_dir(tmp, override = TRUE)
path.chain &lt;- path_chain(tmp)
path_children(path.chain)
</code></pre>

<hr>
<h2 id='path_link'>Creates a link of path chain - a directory or a file</h2><span id='topic+path_link'></span>

<h3>Description</h3>

<p>It returns basic package's object: an object representing a link in the chain.
Each link has the path_chain class - it can represents a one-element path chain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_link(node = NULL, children = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_link_+3A_node">node</code></td>
<td>
<p>Current node name; character</p>
</td></tr>
<tr><td><code id="path_link_+3A_children">children</code></td>
<td>
<p>list of children - path_chains</p>
</td></tr>
</table>


<h3>Value</h3>

<p>path_chain object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If we want to create our chain manually, we have start from the leaves
level2.b &lt;- path_link("fileA.RData")
level2.a &lt;- path_link("fileB.RData")
level1   &lt;- path_link("data", list(level2.a = level2.a , level2.b = level2.b))
root     &lt;- path_link("files", list(level1))
# Print root path
root$.
# Print file path using chaining
root$data$level2.a
</code></pre>

<hr>
<h2 id='print'>Print path_chain object</h2><span id='topic+print'></span><span id='topic+print.path_chain'></span>

<h3>Description</h3>

<p>Print path_chain object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'path_chain'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>'path_chain' object</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>elipsis for API consistency, does nothing</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>level2.b &lt;- path_link("fileA.RData")
level2.a &lt;- path_link("fileB.RData")
level1   &lt;- path_link("data", list(level2.a = level2.a , level2.b = level2.b))
root     &lt;- path_link("files", list(level1))
print(root)

tmp &lt;- create_temp_dir("files")
create_sample_dir(tmp, override = TRUE)
chainable.path &lt;- path_chain(tmp)
print(chainable.path)
</code></pre>

<hr>
<h2 id='temp_path'>Construct path to file in a temporary directory</h2><span id='topic+temp_path'></span>

<h3>Description</h3>

<p>Construct path to file in a temporary directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temp_path(..., fsep = .Platform$file.sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temp_path_+3A_...">...</code></td>
<td>
<p>arbitrary character objects</p>
</td></tr>
<tr><td><code id="temp_path_+3A_fsep">fsep</code></td>
<td>
<p>the path separator to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful: if you call this function, it only creates a path for temporary file/dir.
All the rest has to be created on your own, e.g. calling <a href="base.html#topic+dir.create">dir.create</a> function.
</p>


<h3>Value</h3>

<p>a path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>temp_path("files", "report.csv")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
