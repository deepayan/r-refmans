<!DOCTYPE html><html lang="en"><head><title>Help for package streamR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {streamR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#streamR-package'><p>Access to Twitter Streaming APIs via R</p></a></li>
<li><a href='#createOAuthToken'><p>Create OAuth token without handshake.</p></a></li>
<li><a href='#example_tweets'><p>Ten sample tweets published by @twitterapi</p></a></li>
<li><a href='#filterStream'><p>Connect to Twitter Streaming API and return public statuses that</p>
match one or more filter predicates.</a></li>
<li><a href='#parseTweets'><p>Converts tweets in JSON format to data frame.</p></a></li>
<li><a href='#readTweets'><p>Converts tweets in JSON format to R list.</p></a></li>
<li><a href='#sampleStream'><p>Connect to Twitter Streaming API and return a small random sample of</p>
all public statuses.</a></li>
<li><a href='#userStream'><p>Connect to Twitter Streaming API and return messages for a single user.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Access to Twitter Streaming API via R</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to access Twitter's filter, sample, and user streams, and to
    parse the output into data frames.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Pablo Barbera &lt;pablo.barbera@nyu.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pablo Barbera &lt;pablo.barbera@nyu.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.12.0), RCurl, rjson, ndjson</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ROAuth (&ge; 0.9.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'filterStream.R' 'parseTweets.R' 'sampleStream.R'
'userStream.R' 'streamR-package.R' 'readTweets.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-12-09 18:15:55 UTC; pablobarbera</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-12-09 20:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='streamR-package'>Access to Twitter Streaming APIs via R</h2><span id='topic+streamR-package'></span><span id='topic+streamR'></span>

<h3>Description</h3>

<p>This package provides a series of functions that allow R users
to access Twitter's filter, sample, and user streams, and to
parse the output into data frames.
</p>


<h3>Author(s)</h3>

<p>Pablo Barbera <a href="mailto:pablo.barbera@nyu.edu">pablo.barbera@nyu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterStream">filterStream</a></code>, <code><a href="#topic+sampleStream">sampleStream</a></code>, 
<code><a href="#topic+userStream">userStream</a></code>, <code><a href="#topic+readTweets">readTweets</a></code>, <code><a href="#topic+parseTweets">parseTweets</a></code>
</p>

<hr>
<h2 id='createOAuthToken'>Create OAuth token without handshake.</h2><span id='topic+createOAuthToken'></span>

<h3>Description</h3>

<p>This function generates a OAuth token using the consumer key, consumer secret,
access token and access token secret available in the &quot;Keys and Access Token&quot;
tab of the &quot;Application Management&quot; website on Twitter's developers website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createOAuthToken(consumerKey, consumerSecret, accessToken, accessTokenSecret)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createOAuthToken_+3A_consumerkey">consumerKey</code></td>
<td>
<p>Consumer key for OAuth token</p>
</td></tr>
<tr><td><code id="createOAuthToken_+3A_consumersecret">consumerSecret</code></td>
<td>
<p>Consumer secret for OAuth token</p>
</td></tr>
<tr><td><code id="createOAuthToken_+3A_accesstoken">accessToken</code></td>
<td>
<p>Access token for OAuth token</p>
</td></tr>
<tr><td><code id="createOAuthToken_+3A_accesstokensecret">accessTokenSecret</code></td>
<td>
<p>Access token secret for OAuth token</p>
</td></tr>
</table>

<hr>
<h2 id='example_tweets'>Ten sample tweets published by @twitterapi</h2><span id='topic+example_tweets'></span>

<h3>Description</h3>

<p>A vector of string characters that contains ten sample tweets
in plain text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example_tweets)
</code></pre>


<h3>Source</h3>

<p><a href="http://www.twitter.com/twitterapi">http://www.twitter.com/twitterapi</a>
</p>

<hr>
<h2 id='filterStream'>Connect to Twitter Streaming API and return public statuses that 
match one or more filter predicates.</h2><span id='topic+filterStream'></span>

<h3>Description</h3>

<p><code>filterStream</code> opens a connection to Twitter's Streaming API
that will return public statuses that match one or more filter predicates.
Tweets can be filtered by keywords, users, language, and location. The output
can be saved as an object in memory or written to a text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterStream(file.name = NULL, track = NULL, follow = NULL,
  locations = NULL, language = NULL, timeout = 0, tweets = NULL,
  oauth = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterStream_+3A_file.name">file.name</code></td>
<td>
<p>string, name of the file where tweets will be written. 
&quot;&quot; indicates output to the console, which can be redirected to an R object (see examples).
If the file already exists, tweets will be appended (not overwritten).</p>
</td></tr>
<tr><td><code id="filterStream_+3A_track">track</code></td>
<td>
<p>string or string vector containing keywords to track.
See the <code>track</code> parameter information in the Streaming API documentation for details.</p>
</td></tr>
<tr><td><code id="filterStream_+3A_follow">follow</code></td>
<td>
<p>string or numeric, vector of Twitter user IDs, indicating the users whose public
statuses should be delivered on the stream. See the <code>follow</code> parameter information
in the Streaming API documentation for details.</p>
</td></tr>
<tr><td><code id="filterStream_+3A_locations">locations</code></td>
<td>
<p>numeric, a vector of longitude, latitude pairs (with the southwest corner
coming first) specifying sets of bounding boxes to filter public statuses by. 
See the <code>locations</code> parameter information in the Streaming API documentation for details.</p>
</td></tr>
<tr><td><code id="filterStream_+3A_language">language</code></td>
<td>
<p>string or string vector containing a list of BCP 47 language identifiers.
If not <code>NULL</code> (default), function will only return tweets that have been detected
as being written in the specified languages. Note that this parameter can only be used
in combination with any of the other filter parameters. See documentation for details.</p>
</td></tr>
<tr><td><code id="filterStream_+3A_timeout">timeout</code></td>
<td>
<p>numeric, maximum length of time (in seconds) of connection to stream.
The connection will be automatically closed after this period. For example, setting
<code>timeout</code> to 10800 will keep the connection open for 3 hours. The default is 0,
which will keep the connection open permanently.</p>
</td></tr>
<tr><td><code id="filterStream_+3A_tweets">tweets</code></td>
<td>
<p>numeric, maximum number of tweets to be collected when function is called.
After that number of tweets have been captured, function will stop. If set to <code>NULL</code>
(default), the connection will be open for the number of seconds specified in <code>timeout</code>
parameter.</p>
</td></tr>
<tr><td><code id="filterStream_+3A_oauth">oauth</code></td>
<td>
<p>an object of class <code>oauth</code> that contains the access token
to the user's twitter session OR a list with details to create a new access token.
See examples for more details.</p>
</td></tr>
<tr><td><code id="filterStream_+3A_verbose">verbose</code></td>
<td>
<p>logical, default is <code>TRUE</code>, which generates some output to the
R console with information about the capturing process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>filterStream</code> provides access to the statuses/filter Twitter stream.
</p>
<p>It will return public statuses that
match the keywords given in the <code>track</code> argument, published by the users
specified in the <code>follow</code> argument, written in the language specified
in the <code>language</code> argument, and sent within the location bounding
boxes declared in the <code>locations</code> argument.
</p>
<p>Note that location bounding boxes do not act as filters for other filter
parameters. In the fourth example below, we capture all tweets containing the term
rstats (even non-geolocated tweets) OR coming from the New York City area. For more
information on how the Streaming API request parameters work, check the
documentation at: <a href="https://developer.twitter.com/en/docs/tweets/filter-realtime/guides/basic-stream-parameters">https://developer.twitter.com/en/docs/tweets/filter-realtime/guides/basic-stream-parameters</a>.
</p>
<p>Also note that the <code>language</code> parameter needs to be used in combination
with another filter option (either keywords or location).
</p>
<p>If any of these arguments is left empty (e.g. no user filter is specified),
the function will return all public statuses that match the other filters.
At least one predicate parameter must be specified.
</p>
<p>Note that when no file name is provided, tweets are written to a temporary file, 
which is loaded in memory as a string vector when the connection to the stream
is closed.
</p>
<p>The total number of actual tweets that are captured might be lower than the number 
of tweets requested because blank lines, deletion notices, and incomplete
tweets are included in the count of tweets downloaded.
</p>


<h3>Author(s)</h3>

<p>Pablo Barbera <a href="mailto:pablo.barbera@nyu.edu">pablo.barbera@nyu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleStream">sampleStream</a></code>, <code><a href="#topic+userStream">userStream</a></code>, <code><a href="#topic+parseTweets">parseTweets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 
## An example of an authenticated request using the ROAuth package, 
## where consumerkey and consumer secret are fictitious. 
## You can obtain your own at dev.twitter.com
  library(ROAuth)
  requestURL &lt;- "https://api.twitter.com/oauth/request_token"
  accessURL &lt;- "https://api.twitter.com/oauth/access_token"
  authURL &lt;- "https://api.twitter.com/oauth/authorize"
  consumerKey &lt;- "xxxxxyyyyyzzzzzz"
  consumerSecret &lt;- "xxxxxxyyyyyzzzzzzz111111222222"
  my_oauth &lt;- OAuthFactory$new(consumerKey=consumerKey,
    consumerSecret=consumerSecret, requestURL=requestURL,
    accessURL=accessURL, authURL=authURL)
  my_oauth$handshake(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl"))

## Alternatively, it is also possible to create a token without the handshake:
 my_oauth &lt;- list(consumer_key = "CONSUMER_KEY",
   consumer_secret = "CONSUMER_SECRET",
   access_token="ACCESS_TOKEN",
   access_token_secret = "ACCESS_TOKEN_SECRET")

## capture 10 tweets mentioning the "Rstats" hashtag
  filterStream( file.name="tweets_rstats.json", 
     track="rstats", tweets=10, oauth=my_oauth )

## capture tweets published by Twitter's official account      
  filterStream( file.name="tweets_twitter.json", 
     follow="783214", timeout=600, oauth=my_oauth )

## capture tweets sent from New York City in Spanish only, and saving as an object in memory
  tweets &lt;- filterStream( file.name="", language="es",
      locations=c(-74,40,-73,41), timeout=600, oauth=my_oauth )  

## capture tweets mentioning the "rstats" hashtag or sent from New York City
  filterStream( file="tweets_rstats.json", track="rstats",
      locations=c(-74,40,-73,41), timeout=600, oauth=my_oauth )


## End(Not run)

</code></pre>

<hr>
<h2 id='parseTweets'>Converts tweets in JSON format to data frame.</h2><span id='topic+parseTweets'></span>

<h3>Description</h3>

<p>This function parses tweets downloaded using <code>filterStream</code>, 
<code>sampleStream</code> or <code>userStream</code> and returns a data frame. If tweet contains
280-character text it will return the complete text and not only 140 characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseTweets(tweets, simplify = FALSE, verbose = TRUE, legacy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parseTweets_+3A_tweets">tweets</code></td>
<td>
<p>A character string naming the file where tweets are stored or the
name of the object in memory where the tweets were saved as strings.</p>
</td></tr>
<tr><td><code id="parseTweets_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code> it will return a data frame with only tweet and user
fields (i.e., no geographic information or url entities).</p>
</td></tr>
<tr><td><code id="parseTweets_+3A_verbose">verbose</code></td>
<td>
<p>logical, default is <code>TRUE</code>, which will print in the console
the number of tweets that have been parsed.</p>
</td></tr>
<tr><td><code id="parseTweets_+3A_legacy">legacy</code></td>
<td>
<p>logical, default is <code>FALSE</code>. Read tweets using old method (reading lines into memory and parsing
line by line). Try using <code>legacy=TRUE</code> if getting errors with default options. Note that legacy mode will
only return up to 140 characters per tweet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parseTweets</code> parses tweets downloaded using the <code><a href="#topic+filterStream">filterStream</a></code>,
<code><a href="#topic+sampleStream">sampleStream</a></code> or <code><a href="#topic+userStream">userStream</a></code> functions
and returns a data frame where each row corresponds to one tweet and each column
represents a different field for each tweet (id, text, created_at, etc.).
</p>
<p>The total number of tweets that are parsed might be lower than the number of lines
in the file or object that contains the tweets because blank lines, deletion notices,
and incomplete tweets are ignored.
</p>
<p>To parse json to a twitter list, see <code><a href="#topic+readTweets">readTweets</a></code>. That function can be significantly
faster for large files, when only a few fields are required.
</p>
<p>Note also that the <code>retweet_count</code> field contains the number of times a given tweet
was retweeted at the time it was captured from the API, or for automatic retweets the number
of times the original tweet was retweeted.
</p>


<h3>Author(s)</h3>

<p>Pablo Barbera <a href="mailto:pablo.barbera@nyu.edu">pablo.barbera@nyu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterStream">filterStream</a></code>, <code><a href="#topic+sampleStream">sampleStream</a></code>, <code><a href="#topic+userStream">userStream</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The dataset example_tweets contains 10 public statuses published
## by @twitterapi in plain text format. The code below converts the object
## into a data frame that can be manipulated by other functions.

data(example_tweets)
tweets.df &lt;- parseTweets(example_tweets, simplify=TRUE, legacy=TRUE)

## Not run: 
## A more complete example, that shows how to capture a user's home timeline
## for one hour using authentication via OAuth, and then parsing the tweets
## into a data frame.

 library(ROAuth)
 reqURL &lt;- "https://api.twitter.com/oauth/request_token"
 accessURL &lt;- "https://api.twitter.com/oauth/access_token"
 authURL &lt;- "https://api.twitter.com/oauth/authorize"
 consumerKey &lt;- "xxxxxyyyyyzzzzzz"
 consumerSecret &lt;- "xxxxxxyyyyyzzzzzzz111111222222"
 my_oauth &lt;- OAuthFactory$new(consumerKey=consumerKey,
                              consumerSecret=consumerSecret,
                              requestURL=reqURL,
                              accessURL=accessURL,
                              authURL=authURL)
 my_oauth$handshake()
 userStream( file="my_timeline.json", with="followings",
         timeout=3600, oauth=my_oauth )
 tweets.df &lt;- parseTweets("my_timeline.json")

## End(Not run) 


</code></pre>

<hr>
<h2 id='readTweets'>Converts tweets in JSON format to R list.</h2><span id='topic+readTweets'></span>

<h3>Description</h3>

<p>This function parses tweets downloaded using <code>filterStream</code>,
<code>sampleStream</code> or <code>userStream</code> and returns a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readTweets(tweets, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readTweets_+3A_tweets">tweets</code></td>
<td>
<p>A character string naming the file where tweets are stored or the
name of the object in memory where the tweets were saved as strings.</p>
</td></tr>
<tr><td><code id="readTweets_+3A_verbose">verbose</code></td>
<td>
<p>logical, default is <code>TRUE</code>, which will print in the console
the number of tweets that have been parsed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the first step in the <code><a href="#topic+parseTweets">parseTweets</a></code> function and
is provided now as an independent function for convenience purposes. In cases
where only one field is needed, it can be faster to extract it directly from
the JSON data read in R as a list. It can also be useful to extract fields
that are not parsed by <code><a href="#topic+parseTweets">parseTweets</a></code>, such as hashtags or mentions.
</p>
<p>The total number of tweets that are parsed might be lower than the number of lines
in the file or object that contains the tweets because blank lines, deletion notices,
and incomplete tweets are ignored.
</p>


<h3>Author(s)</h3>

<p>Pablo Barbera <a href="mailto:pablo.barbera@nyu.edu">pablo.barbera@nyu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parseTweets">parseTweets</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The dataset example_tweets contains 10 public statuses published
## by @twitterapi in plain text format. The code below converts the object
## into a list and extracts only the text.

data(example_tweets)
tweets.list &lt;- readTweets(example_tweets)
only.text &lt;- unlist(lapply(tweets.list, '[[', 'text'))
## it can be done with an explicit loop:
only.text &lt;- c()
for (i in 1:length(tweets.list)){
   only.text[i] &lt;- tweets.list[[i]]['text']
}
print(unlist(only.text))



</code></pre>

<hr>
<h2 id='sampleStream'>Connect to Twitter Streaming API and return a small random sample of
all public statuses.</h2><span id='topic+sampleStream'></span>

<h3>Description</h3>

<p><code>sampleStream</code> opens a connection to Twitter's Streaming API
that will return a small random sample of public statuses, around 1%
at any given time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleStream(file.name, timeout = 0, tweets = NULL, oauth = NULL,
  verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleStream_+3A_file.name">file.name</code></td>
<td>
<p>string, name of the file where tweets will be written. 
&quot;&quot; indicates output to the console, which can be redirected to an R object.
If the file already exists, tweets will be appended (not overwritten).</p>
</td></tr>
<tr><td><code id="sampleStream_+3A_timeout">timeout</code></td>
<td>
<p>numeric, maximum length of time (in seconds) of connection to stream.
The connection will be automatically closed after this period. For example, setting
<code>timeout</code> to 10800 will keep the connection open for 3 hours. The default is 0,
which will keep the connection open permanently.</p>
</td></tr>
<tr><td><code id="sampleStream_+3A_tweets">tweets</code></td>
<td>
<p>numeric, maximum number of tweets to be collected when function is called.
After that number of tweets have been captured, function will stop. If set to <code>NULL</code>
(default), the connection will be open for the number of seconds specified in <code>timeout</code>
parameter.</p>
</td></tr>
<tr><td><code id="sampleStream_+3A_oauth">oauth</code></td>
<td>
<p>an object of class <code>oauth</code> that contains the access token
to the user's twitter session OR a list with details to create a new access token.
See examples for more details.</p>
</td></tr>
<tr><td><code id="sampleStream_+3A_verbose">verbose</code></td>
<td>
<p>logical, default is <code>TRUE</code>, which generates some output to the
R console with information about the capturing process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information, check the documentation at:
<a href="https://developer.twitter.com/en/docs/tweets/sample-realtime/overview/GET_statuse_sample">https://developer.twitter.com/en/docs/tweets/sample-realtime/overview/GET_statuse_sample</a>
</p>
<p>Note that when no file name is provided, tweets are written to a temporary file, 
which is loaded in memory as a string vector when the connection to the stream
is closed.
</p>
<p>The total number of actual tweets that are captured might be lower than the number 
of tweets requested because blank lines, deletion notices, and incomplete
tweets are included in the count of tweets downloaded.
</p>


<h3>Author(s)</h3>

<p>Pablo Barbera <a href="mailto:pablo.barbera@nyu.edu">pablo.barbera@nyu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterStream">filterStream</a></code>, <code><a href="#topic+userStream">userStream</a></code>, <code><a href="#topic+parseTweets">parseTweets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## capture a random sample of tweets
sampleStream( file.name="tweets_sample.json", user=FOO, password=BAR )

## An example of an authenticated request using the ROAuth package, 
## where consumerkey and consumer secret are fictitious. 
## You can obtain your own at dev.twitter.com
 library(ROAuth)
 reqURL &lt;- "https://api.twitter.com/oauth/request_token"
 accessURL &lt;- "https://api.twitter.com/oauth/access_token"
 authURL &lt;- "https://api.twitter.com/oauth/authorize"
 consumerKey &lt;- "xxxxxyyyyyzzzzzz"
 consumerSecret &lt;- "xxxxxxyyyyyzzzzzzz111111222222"
  my_oauth &lt;- OAuthFactory$new(consumerKey=consumerKey,
    consumerSecret=consumerSecret, requestURL=requestURL,
    accessURL=accessURL, authURL=authURL)
 my_oauth$handshake(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl"))

## Alternatively, it is also possible to create a token without the handshake:
 my_oauth &lt;- list(consumer_key = "CONSUMER_KEY",
   consumer_secret = "CONSUMER_SECRET",
   access_token="ACCESS_TOKEN",
   access_token_secret = "ACCESS_TOKEN_SECRET")

 sampleStream( file.name="tweets_sample.json", oauth=my_oauth )


## End(Not run)

</code></pre>

<hr>
<h2 id='userStream'>Connect to Twitter Streaming API and return messages for a single user.</h2><span id='topic+userStream'></span>

<h3>Description</h3>

<p><code>userStream</code> opens a connection to Twitter's Streaming API
that will return statuses specific to the authenticated user. The output
can be saved as an object in memory or written to a text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>userStream(file.name = NULL, with = "followings", replies = NULL,
  track = NULL, locations = NULL, timeout = 0, tweets = NULL,
  oauth = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="userStream_+3A_file.name">file.name</code></td>
<td>
<p>string, name of the file where tweets will be written. 
&quot;&quot; indicates output to the console, which can be redirected to an R object.
If the file already exists, tweets will be appended (not overwritten).</p>
</td></tr>
<tr><td><code id="userStream_+3A_with">with</code></td>
<td>
<p>string, detault is &quot;followings&quot;, which will stream messages from accounts the
authenticated user follow. If set to &quot;user&quot;, will only stream messages from authenticated
user.
</p>
<p>See the <code>with</code> parameter information in the Streaming API documentation for details:
<a href="https://developer.twitter.com/en/docs/tweets/filter-realtime/guides/basic-stream-parameters">https://developer.twitter.com/en/docs/tweets/filter-realtime/guides/basic-stream-parameters</a></p>
</td></tr>
<tr><td><code id="userStream_+3A_replies">replies</code></td>
<td>
<p>string, default is <code>NULL</code>, which will only stream replies sent by
a different user if the authenticated user follows the receiver of the reply. All replies
to users that the authenticated user follows will be included if this argument is set to &quot;all&quot;.
</p>
<p>See the <code>replies</code> parameter information in the Streaming API documentation for details:
<a href="https://developer.twitter.com/en/docs/tweets/filter-realtime/guides/basic-stream-parameters">https://developer.twitter.com/en/docs/tweets/filter-realtime/guides/basic-stream-parameters</a></p>
</td></tr>
<tr><td><code id="userStream_+3A_track">track</code></td>
<td>
<p>string or string vector containing keywords to track.
See the track parameter information in the Streaming API documentation for details:
<a href="https://developer.twitter.com/en/docs/tweets/filter-realtime/guides/basic-stream-parameters">https://developer.twitter.com/en/docs/tweets/filter-realtime/guides/basic-stream-parameters</a>.</p>
</td></tr>
<tr><td><code id="userStream_+3A_locations">locations</code></td>
<td>
<p>numeric, a vector of longitude, latitude pairs (with the southwest corner
coming first) specifying sets of bounding boxes to filter statuses by. 
See the locations parameter information in the Streaming API documentation for details:
<a href="https://developer.twitter.com/en/docs/tweets/filter-realtime/guides/basic-stream-parameters">https://developer.twitter.com/en/docs/tweets/filter-realtime/guides/basic-stream-parameters</a></p>
</td></tr>
<tr><td><code id="userStream_+3A_timeout">timeout</code></td>
<td>
<p>numeric, maximum length of time (in seconds) of connection to stream.
The connection will be automatically closed after this period. For example, setting
<code>timeout</code> to 10800 will keep the connection open for 3 hours. The default is 0,
which will keep the connection open permanently.</p>
</td></tr>
<tr><td><code id="userStream_+3A_tweets">tweets</code></td>
<td>
<p>numeric, maximum number of tweets to be collected when function is called.
After that number of tweets have been captured, function will stop. If set to <code>NULL</code>
(default), the connection will be open for the number of seconds specified in <code>timeout</code>
parameter.</p>
</td></tr>
<tr><td><code id="userStream_+3A_oauth">oauth</code></td>
<td>
<p>an object of class <code>oauth</code> that contains the access token
to the user's twitter session OR a list with details to create a new access token.
See examples for more details.</p>
</td></tr>
<tr><td><code id="userStream_+3A_verbose">verbose</code></td>
<td>
<p>logical, default is <code>TRUE</code>, which generates some output to the
R console with information about the capturing process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides access to messages for a single user.
</p>
<p>The set of messages to be returned can include the user's tweets and/or replies, 
and public statuses published by the accounts the user follows, as well to replies
to those accounts. 
</p>
<p>Tweets can also be filtered by keywords and location, using the <code>track</code>
and <code>locations</code> arguments.
</p>
<p>The total number of actual tweets that are captured might be lower than the number 
of tweets requested because blank lines, deletion notices, and incomplete
tweets are included in the count of tweets downloaded.
</p>
<p>Note that when no file name is provided, tweets are written to a temporary file, 
which is loaded in memory as a string vector when the connection to the stream
is closed.
</p>


<h3>Author(s)</h3>

<p>Pablo Barbera <a href="mailto:pablo.barbera@nyu.edu">pablo.barbera@nyu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterStream">filterStream</a></code>, <code><a href="#topic+sampleStream">sampleStream</a></code>, <code><a href="#topic+parseTweets">parseTweets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## The following example shows how to capture a user's home timeline
## with the Streaming API and using authentication via the ROAuth
## package, with fictitious consumerkey and consumer secret.
## You can obtain your own at dev.twitter.com
 library(ROAuth)
 requestURL &lt;- "https://api.twitter.com/oauth/request_token"
 accessURL &lt;- "https://api.twitter.com/oauth/access_token"
 authURL &lt;- "https://api.twitter.com/oauth/authorize"
 consumerKey &lt;- "xxxxxyyyyyzzzzzz"
 consumerSecret &lt;- "xxxxxxyyyyyzzzzzzz111111222222"
 my_oauth &lt;- OAuthFactory$new(consumerKey=consumerKey,
    consumerSecret=consumerSecret, requestURL=requestURL,
    accessURL=accessURL, authURL=authURL)
 my_oauth$handshake(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl"))

## Alternatively, it is also possible to create a token without the handshake:
 my_oauth &lt;- list(consumer_key = "CONSUMER_KEY",
   consumer_secret = "CONSUMER_SECRET",
   access_token="ACCESS_TOKEN",
   access_token_secret = "ACCESS_TOKEN_SECRET")

## Capturing 10 tweets from a user's timeline
 userStream( file.name="my_timeline.json", with="followings",
     tweets=10, oauth=my_oauth )

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
