<!DOCTYPE html><html><head><title>Help for package dodgr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dodgr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_nodes_to_graph'><p>Insert new nodes into a graph, breaking edges at point of nearest</p>
intersection.</a></li>
<li><a href='#clear_dodgr_cache'><p>Remove cached versions of <code>dodgr</code> graphs.</p></a></li>
<li><a href='#compare_heaps'><p>Compare timings of different sort heaps for a given input graph.</p></a></li>
<li><a href='#dodgr'><p>Distances On Directed GRaphs (&quot;dodgr&quot;)</p></a></li>
<li><a href='#dodgr_cache_off'><p>Turn off all dodgr caching in current session.</p></a></li>
<li><a href='#dodgr_cache_on'><p>Turn on all dodgr caching in current session.</p></a></li>
<li><a href='#dodgr_centrality'><p>Calculate betweenness centrality for a 'dodgr' network.</p></a></li>
<li><a href='#dodgr_components'><p>Identify connected components of graph.</p></a></li>
<li><a href='#dodgr_contract_graph'><p>Contract graph to junction vertices only.</p></a></li>
<li><a href='#dodgr_deduplicate_graph'><p>Deduplicate edges in a graph</p></a></li>
<li><a href='#dodgr_distances'><p>Calculate matrix of pair-wise distances between points.</p></a></li>
<li><a href='#dodgr_dists'><p>Calculate matrix of pair-wise distances between points.</p></a></li>
<li><a href='#dodgr_dists_categorical'><p>Cumulative distances along different edge categories</p></a></li>
<li><a href='#dodgr_dists_nearest'><p>Calculate vector of shortest distances from a series of 'from' points to</p>
nearest one of series of 'to' points.</a></li>
<li><a href='#dodgr_flowmap'><p>Create a map of <code>dodgr</code> flows.</p></a></li>
<li><a href='#dodgr_flows_aggregate'><p>Aggregate flows throughout a network.</p></a></li>
<li><a href='#dodgr_flows_disperse'><p>Aggregate flows dispersed from each point in a network.</p></a></li>
<li><a href='#dodgr_flows_si'><p>Aggregate flows throughout a network using a spatial interaction model.</p></a></li>
<li><a href='#dodgr_full_cycles'><p>Calculate fundamental cycles on a FULL (that is, non-contracted) graph.</p></a></li>
<li><a href='#dodgr_fundamental_cycles'><p>Calculate fundamental cycles in a graph.</p></a></li>
<li><a href='#dodgr_insert_vertex'><p>Insert a new node or vertex into a network</p></a></li>
<li><a href='#dodgr_isochrones'><p>Calculate isochrone contours from specified points.</p></a></li>
<li><a href='#dodgr_isodists'><p>Calculate isodistance contours from specified points.</p></a></li>
<li><a href='#dodgr_isoverts'><p>Calculate isodistance or isochrone contours from specified points.</p></a></li>
<li><a href='#dodgr_load_streetnet'><p>Load a street network previously saved with dodgr_save_streetnet.</p></a></li>
<li><a href='#dodgr_paths'><p>Calculate lists of pair-wise shortest paths between points.</p></a></li>
<li><a href='#dodgr_sample'><p>Sample a random but connected sub-component of a graph</p></a></li>
<li><a href='#dodgr_save_streetnet'><p>Save a weighted streetnet to a local file</p></a></li>
<li><a href='#dodgr_sflines_to_poly'><p>Convert <span class="pkg">sf</span> <code>LINESTRING</code> objects to <code>POLYGON</code> objects representing all</p>
fundamental cycles within the <code>LINESTRING</code> objects.</a></li>
<li><a href='#dodgr_streetnet'><p>Extract a street network in <span class="pkg">sf</span>-format for a given location.</p></a></li>
<li><a href='#dodgr_streetnet_sc'><p>Extract a street network in <span class="pkg">silicate</span>-format for a given location.</p></a></li>
<li><a href='#dodgr_times'><p>Calculate matrix of pair-wise travel times between points.</p></a></li>
<li><a href='#dodgr_to_igraph'><p>Convert a <code>dodgr</code> graph to an <span class="pkg">igraph</span>.</p></a></li>
<li><a href='#dodgr_to_sf'><p>Convert a <code>dodgr</code> graph into an equivalent <span class="pkg">sf</span> object.</p></a></li>
<li><a href='#dodgr_to_sfc'><p>Convert a <code>dodgr</code> graph into an equivalent <code>sf::sfc</code> object.</p></a></li>
<li><a href='#dodgr_to_tidygraph'><p>Convert a <code>dodgr</code> graph to an <span class="pkg">tidygraph</span>.</p></a></li>
<li><a href='#dodgr_uncontract_graph'><p>Re-expand a contracted graph.</p></a></li>
<li><a href='#dodgr_vertices'><p>Extract vertices of graph, including spatial coordinates if included.</p></a></li>
<li><a href='#estimate_centrality_threshold'><p>Estimate a value for the 'dist_threshold' parameter of the</p>
dodgr_centrality function.</a></li>
<li><a href='#estimate_centrality_time'><p>Estimate time required for a planned centrality calculation.</p></a></li>
<li><a href='#hampi'><p>Sample street network from Hampi, India.</p></a></li>
<li><a href='#igraph_to_dodgr'><p>Convert a <span class="pkg">igraph</span> network to an equivalent <code>dodgr</code> representation.</p></a></li>
<li><a href='#match_points_to_graph'><p>Alias for match_pts_to_graph</p></a></li>
<li><a href='#match_points_to_verts'><p>Alias for match_pts_to_verts</p></a></li>
<li><a href='#match_pts_to_graph'><p>Match spatial points to the edges of a spatial graph.</p></a></li>
<li><a href='#match_pts_to_verts'><p>Match spatial points to the vertices of a spatial graph.</p></a></li>
<li><a href='#merge_directed_graph'><p>Merge directed edges into equivalent undirected edges.</p></a></li>
<li><a href='#os_roads_bristol'><p>Sample street network from Bristol, U.K.</p></a></li>
<li><a href='#summary.dodgr_dists_categorical'><p>Transform a result from dodgr_dists_categorical to summary statistics</p></a></li>
<li><a href='#weight_railway'><p>Weight a network for routing along railways.</p></a></li>
<li><a href='#weight_streetnet'><p>Weight a street network according to a specified weighting profile.</p></a></li>
<li><a href='#weighting_profiles'><p>Weighting profiles used to route different modes of transport.</p></a></li>
<li><a href='#write_dodgr_wt_profile'><p>Write <code>dodgr</code> weighting profiles to local file.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Distances on Directed Graphs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.21</td>
</tr>
<tr>
<td>Description:</td>
<td>Distances on dual-weighted directed graphs using
    priority-queue shortest paths (Padgham (2019) &lt;<a href="https://doi.org/10.32866%2F6945">doi:10.32866/6945</a>&gt;).
    Weighted directed graphs have weights from A to B which may differ
    from those from B to A.  Dual-weighted directed graphs have two sets
    of such weights. A canonical example is a street network to be used
    for routing in which routes are calculated by weighting distances
    according to the type of way and mode of transport, yet lengths of
    routes must be calculated from direct distances.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ATFutures/dodgr">https://github.com/ATFutures/dodgr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ATFutures/dodgr/issues">https://github.com/ATFutures/dodgr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>callr, digest, fs, magrittr, methods, osmdata, Rcpp (&ge;
0.12.6), RcppParallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, dplyr, geodist, ggplot2, igraph, igraphdata, jsonlite,
knitr, markdown, rmarkdown, roxygen2, sf, testthat (&ge; 3.1.6),
tidygraph</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel, RcppThread</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-02 10:29:24 UTC; smexus</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark Padgham [aut, cre],
  Andreas Petutschnig [aut],
  David Cooley [aut],
  Robin Lovelace [ctb],
  Andrew Smith [ctb],
  Malcolm Morgan [ctb],
  Shane Saunders [cph] (Original author of included code for priority
    heaps)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark Padgham &lt;mark.padgham@email.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-02 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_nodes_to_graph'>Insert new nodes into a graph, breaking edges at point of nearest
intersection.</h2><span id='topic+add_nodes_to_graph'></span>

<h3>Description</h3>

<p>Note that this routine presumes graphs to be <code>dodgr_streetnet</code> object, with
geographical coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_nodes_to_graph(graph, xy, dist_tol = 1e-06, intersections_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_nodes_to_graph_+3A_graph">graph</code></td>
<td>
<p>A <code>dodgr</code> graph with spatial coordinates, such as a
<code>dodgr_streetnet</code> object.</p>
</td></tr>
<tr><td><code id="add_nodes_to_graph_+3A_xy">xy</code></td>
<td>
<p>coordinates of points to be matched to the vertices, either as
matrix or <span class="pkg">sf</span>-formatted <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="add_nodes_to_graph_+3A_dist_tol">dist_tol</code></td>
<td>
<p>Only insert new nodes if they are further from existing nodes
than this distance, expressed in units of the distance column of <code>graph</code>.</p>
</td></tr>
<tr><td><code id="add_nodes_to_graph_+3A_intersections_only">intersections_only</code></td>
<td>
<p>If <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This inserts new nodes by extending lines from each input point to the edge
with the closest point of perpendicular intersection. That edge is then split
at that point of intersection, creating two new edges (or four for directed
edges). If <code>intersections_only = FALSE</code> (default), then additional edges are
inserted from those intersection points to the input points. If
<code>intersections_only = TRUE</code>, then nodes are added by splitting graph edges at
points of nearest perpendicular intersection, without adding additional edges
out to the actual input points.
</p>
<p>In the former case, the properties of those new edges, such as distance and
time weightings, are inherited from the edges which are intersected, and may
need to be manually modified after calling this function.
</p>


<h3>Value</h3>

<p>A modified version of <code>graph</code>, with additional edges formed by
breaking previous edges at nearest perpendicular intersections with the
points, <code>xy</code>.
</p>


<h3>See Also</h3>

<p>Other match: 
<code><a href="#topic+match_points_to_graph">match_points_to_graph</a>()</code>,
<code><a href="#topic+match_points_to_verts">match_points_to_verts</a>()</code>,
<code><a href="#topic+match_pts_to_graph">match_pts_to_graph</a>()</code>,
<code><a href="#topic+match_pts_to_verts">match_pts_to_verts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi, wt_profile = "foot")
dim (graph)

verts &lt;- dodgr_vertices (graph)
set.seed (2)
npts &lt;- 10
xy &lt;- data.frame (
    x = min (verts$x) + runif (npts) * diff (range (verts$x)),
    y = min (verts$y) + runif (npts) * diff (range (verts$y))
)

graph &lt;- add_nodes_to_graph (graph, xy)
dim (graph) # more edges than original
</code></pre>

<hr>
<h2 id='clear_dodgr_cache'>Remove cached versions of <code>dodgr</code> graphs.</h2><span id='topic+clear_dodgr_cache'></span>

<h3>Description</h3>

<p>This function should generally <em>not</em> be needed, except if graph
structure has been directly modified other than through <code>dodgr</code> functions;
for example by modifying edge weights or distances. Graphs are cached based
on the vector of edge IDs, so manual changes to any other attributes will not
necessarily be translated into changes in <code>dodgr</code> output unless the cached
versions are cleared using this function. See
<a href="https://github.com/ATFutures/dodgr/wiki/Caching-of-streetnets-and-contracted-graphs">https://github.com/ATFutures/dodgr/wiki/Caching-of-streetnets-and-contracted-graphs</a>
for details of caching process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_dodgr_cache()
</code></pre>


<h3>Value</h3>

<p>Nothing; the function silently clears any cached objects
</p>


<h3>See Also</h3>

<p>Other cache: 
<code><a href="#topic+dodgr_cache_off">dodgr_cache_off</a>()</code>,
<code><a href="#topic+dodgr_cache_on">dodgr_cache_on</a>()</code>,
<code><a href="#topic+dodgr_load_streetnet">dodgr_load_streetnet</a>()</code>,
<code><a href="#topic+dodgr_save_streetnet">dodgr_save_streetnet</a>()</code>
</p>

<hr>
<h2 id='compare_heaps'>Compare timings of different sort heaps for a given input graph.</h2><span id='topic+compare_heaps'></span>

<h3>Description</h3>

<p>Perform timing comparison between different kinds of heaps as well as with
equivalent routines from the <span class="pkg">igraph</span> package. To do this, a random
sub-graph containing a defined number of vertices is first selected.
Alternatively, this random sub-graph can be pre-generated with the
<code>dodgr_sample</code> function and passed directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_heaps(graph, nverts = 100, replications = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_heaps_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> object representing the network graph (or a
sub-sample selected with codedodgr_sample)</p>
</td></tr>
<tr><td><code id="compare_heaps_+3A_nverts">nverts</code></td>
<td>
<p>Number of vertices used to generate random sub-graph. If a
non-numeric value is given, the whole graph will be used.</p>
</td></tr>
<tr><td><code id="compare_heaps_+3A_replications">replications</code></td>
<td>
<p>Number of replications to be used in comparison</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of <code>bench::mark</code> comparison.
</p>


<h3>Note</h3>

<p><span class="pkg">igraph</span> caches intermediate results of graph processing, so
the <span class="pkg">igraph</span> comparisons will be faster on subsequent runs. To obtain
fair comparisons, run only once or re-start the current R session.
</p>


<h3>See Also</h3>

<p>Other misc: 
<code><a href="#topic+dodgr_flowmap">dodgr_flowmap</a>()</code>,
<code><a href="#topic+dodgr_full_cycles">dodgr_full_cycles</a>()</code>,
<code><a href="#topic+dodgr_fundamental_cycles">dodgr_fundamental_cycles</a>()</code>,
<code><a href="#topic+dodgr_insert_vertex">dodgr_insert_vertex</a>()</code>,
<code><a href="#topic+dodgr_sample">dodgr_sample</a>()</code>,
<code><a href="#topic+dodgr_sflines_to_poly">dodgr_sflines_to_poly</a>()</code>,
<code><a href="#topic+dodgr_vertices">dodgr_vertices</a>()</code>,
<code><a href="#topic+merge_directed_graph">merge_directed_graph</a>()</code>,
<code><a href="#topic+summary.dodgr_dists_categorical">summary.dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
## Not run: 
compare_heaps (graph, nverts = 1000, replications = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='dodgr'>Distances On Directed GRaphs (&quot;dodgr&quot;)</h2><span id='topic+dodgr'></span>

<h3>Description</h3>

<p>Distances on dual-weighted directed graphs using priority-queue shortest
paths. Weighted directed graphs have weights from A to B which may differ
from those from B to A. Dual-weighted directed graphs have two sets of such
weights. A canonical example is a street network to be used for routing in
which routes are calculated by weighting distances according to the type of
way and mode of transport, yet lengths of routes must be calculated from
direct distances.
</p>


<h3>The Main Function</h3>


<ul>
<li> <p><code><a href="#topic+dodgr_dists">dodgr_dists()</a></code>: Calculate pair-wise distances between
specified pairs of points in a graph.
</p>
</li></ul>



<h3>Functions to Obtain Graphs</h3>


<ul>
<li> <p><code><a href="#topic+dodgr_streetnet">dodgr_streetnet()</a></code>: Extract a street network in Simple
Features (<code>sf</code>) form.
</p>
</li>
<li> <p><code><a href="#topic+weight_streetnet">weight_streetnet()</a></code>: Convert an <code>sf</code>-formatted street
network to a <code>dodgr</code> graph through applying specified weights to all
edges.
</p>
</li></ul>



<h3>Functions to Modify Graphs</h3>


<ul>
<li> <p><code><a href="#topic+dodgr_components">dodgr_components()</a></code>: Number all graph edges according to
their presence in distinct connected components.
</p>
</li>
<li> <p><code><a href="#topic+dodgr_contract_graph">dodgr_contract_graph()</a></code>: Contract a graph by removing
redundant edges.
</p>
</li></ul>



<h3>Miscellaneous Functions</h3>


<ul>
<li> <p><code><a href="#topic+dodgr_sample">dodgr_sample()</a></code>: Randomly sample a graph, returning a single
connected component of a defined number of vertices.
</p>
</li>
<li> <p><code><a href="#topic+dodgr_vertices">dodgr_vertices()</a></code>: Extract all vertices of a graph.
</p>
</li>
<li> <p><code><a href="#topic+compare_heaps">compare_heaps()</a></code>: Compare the performance of different
priority queue heap structures for a given type of graph.
</p>
</li></ul>


<hr>
<h2 id='dodgr_cache_off'>Turn off all dodgr caching in current session.</h2><span id='topic+dodgr_cache_off'></span>

<h3>Description</h3>

<p>This function is useful is speed is paramount, and if graph contraction is
not needed. Caching can be switched back on with <a href="#topic+dodgr_cache_on">dodgr_cache_on</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_cache_off()
</code></pre>


<h3>Value</h3>

<p>Nothing; the function invisibly returns <code>TRUE</code> if successful.
</p>


<h3>See Also</h3>

<p>Other cache: 
<code><a href="#topic+clear_dodgr_cache">clear_dodgr_cache</a>()</code>,
<code><a href="#topic+dodgr_cache_on">dodgr_cache_on</a>()</code>,
<code><a href="#topic+dodgr_load_streetnet">dodgr_load_streetnet</a>()</code>,
<code><a href="#topic+dodgr_save_streetnet">dodgr_save_streetnet</a>()</code>
</p>

<hr>
<h2 id='dodgr_cache_on'>Turn on all dodgr caching in current session.</h2><span id='topic+dodgr_cache_on'></span>

<h3>Description</h3>

<p>This will only have an effect after caching has been turned off with
<a href="#topic+dodgr_cache_off">dodgr_cache_off</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_cache_on()
</code></pre>


<h3>Value</h3>

<p>Nothing; the function invisibly returns <code>TRUE</code> if successful.
</p>


<h3>See Also</h3>

<p>Other cache: 
<code><a href="#topic+clear_dodgr_cache">clear_dodgr_cache</a>()</code>,
<code><a href="#topic+dodgr_cache_off">dodgr_cache_off</a>()</code>,
<code><a href="#topic+dodgr_load_streetnet">dodgr_load_streetnet</a>()</code>,
<code><a href="#topic+dodgr_save_streetnet">dodgr_save_streetnet</a>()</code>
</p>

<hr>
<h2 id='dodgr_centrality'>Calculate betweenness centrality for a 'dodgr' network.</h2><span id='topic+dodgr_centrality'></span>

<h3>Description</h3>

<p>Centrality can be calculated in either vertex- or edge-based form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_centrality(
  graph,
  contract = TRUE,
  edges = TRUE,
  column = "d_weighted",
  vert_wts = NULL,
  dist_threshold = NULL,
  heap = "BHeap",
  check_graph = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_centrality_+3A_graph">graph</code></td>
<td>
<p>'data.frame' or equivalent object representing the network
graph (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_centrality_+3A_contract">contract</code></td>
<td>
<p>If 'TRUE', centrality is calculated on contracted graph
before mapping back on to the original full graph. Note that for street
networks, in particular those obtained from the <span class="pkg">osmdata</span> package, vertex
placement is effectively arbitrary except at junctions; centrality for such
graphs should only be calculated between the latter points, and thus
'contract' should always be 'TRUE'.</p>
</td></tr>
<tr><td><code id="dodgr_centrality_+3A_edges">edges</code></td>
<td>
<p>If 'TRUE', centrality is calculated for graph edges, returning
the input 'graph' with an additional 'centrality' column; otherwise
centrality is calculated for vertices, returning the equivalent of
'dodgr_vertices(graph)', with an additional vertex-based 'centrality' column.</p>
</td></tr>
<tr><td><code id="dodgr_centrality_+3A_column">column</code></td>
<td>
<p>Column of graph defining the edge properties used to calculate
centrality (see Note).</p>
</td></tr>
<tr><td><code id="dodgr_centrality_+3A_vert_wts">vert_wts</code></td>
<td>
<p>Optional vector of length equal to number of vertices
(<code>nrow(dodgr_vertices(graph))</code>), to enable centrality to be calculated in
weighted form, such that centrality measured from each vertex will be
weighted by the specified amount.</p>
</td></tr>
<tr><td><code id="dodgr_centrality_+3A_dist_threshold">dist_threshold</code></td>
<td>
<p>If not 'NULL', only calculate centrality for each point
out to specified threshold. Setting values for this will result in
approximate estimates for centrality, yet with considerable gains in
computational efficiency. For sufficiently large values, approximations will
be accurate to within some constant multiplier. Appropriate values can be
established via the <a href="#topic+estimate_centrality_threshold">estimate_centrality_threshold</a> function.</p>
</td></tr>
<tr><td><code id="dodgr_centrality_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; 'FHeap'), Binary Heap ('BHeap'),
Trinomial Heap ('TriHeap'), Extended Trinomial Heap
('TriHeapExt', and 2-3 Heap ('Heap23').</p>
</td></tr>
<tr><td><code id="dodgr_centrality_+3A_check_graph">check_graph</code></td>
<td>
<p>If <code>TRUE</code>, graph is first checked for duplicate edges,
which can cause incorrect centrality calculations. If duplicate edges are
detected in an interactive session, a prompt will ask whether you want to
proceed or rectify edges first. This value may be set to <code>FALSE</code> to skip this
check and the interactive prompt.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified version of graph with additional 'centrality' column added.
</p>


<h3>Note</h3>

<p>The <code>column</code> parameter is by default <code>d_weighted</code>, meaning centrality
is calculated by routing according to weighted distances. Other possible
values for this parameter are
</p>

<ul>
<li> <p><code>d</code> for unweighted distances
</p>
</li>
<li> <p><code>time</code> for unweighted time-based routing
</p>
</li>
<li> <p><code>time_weighted</code> for weighted time-based routing
</p>
</li></ul>

<p>Centrality is calculated by default using parallel computation with the
maximal number of available cores or threads. This number can be reduced by
specifying a value via
<code style="white-space: pre;">&#8288;RcppParallel::setThreadOptions (numThreads = &lt;desired_number&gt;)&#8288;</code>.
</p>


<h3>See Also</h3>

<p>Other centrality: 
<code><a href="#topic+estimate_centrality_threshold">estimate_centrality_threshold</a>()</code>,
<code><a href="#topic+estimate_centrality_time">estimate_centrality_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph_full &lt;- weight_streetnet (hampi)
graph &lt;- dodgr_contract_graph (graph_full)
graph &lt;- dodgr_centrality (graph)
# 'graph' is then the contracted graph with an additional 'centrality' column
# Same calculation via 'igraph':
igr &lt;- dodgr_to_igraph (graph)
library (igraph)
cent &lt;- edge_betweenness (igr)
identical (cent, graph$centrality) # TRUE
# Values of centrality between all junctions in the contracted graph can then
# be mapped back onto the original full network by "uncontracting":
graph_full &lt;- dodgr_uncontract_graph (graph)
# For visualisation, it is generally necessary to merge the directed edges to
# form an equivalent undirected graph. Conversion to 'sf' format via
# 'dodgr_to_sf()' is also useful for many visualisation routines.
graph_sf &lt;- merge_directed_graph (graph_full) %&gt;%
    dodgr_to_sf ()

## Not run: 
library (mapview)
centrality &lt;- graph_sf$centrality / max (graph_sf$centrality)
ncols &lt;- 30
cols &lt;- c ("lawngreen", "red")
cols &lt;- colorRampPalette (cols) (ncols) [ceiling (ncols * centrality)]
mapview (graph_sf, color = cols, lwd = 10 * centrality)

## End(Not run)

# An example of flow aggregation across a generic (non-OSM) highway,
# represented as the 'routes_fast' object of the \pkg{stplanr} package,
# which is a SpatialLinesDataFrame containing commuter densities along
# components of a street network.
## Not run: 
library (stplanr)
# merge all of the 'routes_fast' lines into a single network
r &lt;- overline (routes_fast, attrib = "length", buff_dist = 1)
r &lt;- sf::st_as_sf (r)
# Convert to a 'dodgr' network, for which we need to specify both a 'type'
# and 'id' column.
r$type &lt;- 1
r$id &lt;- seq (nrow (r))
graph_full &lt;- weight_streetnet (
    r,
    type_col = "type",
    id_col = "id",
    wt_profile = 1
)
# convert to contracted form, retaining junction vertices only, and append
# 'centrality' column
graph &lt;- dodgr_contract_graph (graph_full) %&gt;%
    dodgr_centrality ()
#' expand back to full graph; merge directed flows; and convert result to
# 'sf'-format for plotting
graph_sf &lt;- dodgr_uncontract_graph (graph) %&gt;%
    merge_directed_graph () %&gt;%
    dodgr_to_sf ()
plot (graph_sf ["centrality"])

## End(Not run)

</code></pre>

<hr>
<h2 id='dodgr_components'>Identify connected components of graph.</h2><span id='topic+dodgr_components'></span>

<h3>Description</h3>

<p>Identify connected components of graph and add corresponding <code>component</code>
column to <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_components(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_components_+3A_graph">graph</code></td>
<td>
<p>A <code>data.frame</code> of edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent graph with additional <code>component</code> column,
sequentially numbered from 1 = largest component.
</p>


<h3>See Also</h3>

<p>Other modification: 
<code><a href="#topic+dodgr_contract_graph">dodgr_contract_graph</a>()</code>,
<code><a href="#topic+dodgr_uncontract_graph">dodgr_uncontract_graph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
graph &lt;- dodgr_components (graph)
</code></pre>

<hr>
<h2 id='dodgr_contract_graph'>Contract graph to junction vertices only.</h2><span id='topic+dodgr_contract_graph'></span>

<h3>Description</h3>

<p>Removes redundant (straight-line) vertices from graph, leaving only junction
vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_contract_graph(graph, verts = NULL, nocache = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_contract_graph_+3A_graph">graph</code></td>
<td>
<p>A flat table of graph edges. Must contain columns labelled
<code>from</code> and <code>to</code>, or <code>start</code> and <code>stop</code>. May also contain
similarly labelled columns of spatial coordinates (for example
<code>from_x</code>) or <code>stop_lon</code>).</p>
</td></tr>
<tr><td><code id="dodgr_contract_graph_+3A_verts">verts</code></td>
<td>
<p>Optional list of vertices to be retained as routing points.
These must match the <code>from</code> and <code>to</code> columns of <code>graph</code>.</p>
</td></tr>
<tr><td><code id="dodgr_contract_graph_+3A_nocache">nocache</code></td>
<td>
<p>If <code>FALSE</code> (default), load cached version of contracted graph
if previously calculated and cached. If <code>TRUE</code>, then re-contract graph even
if previously calculated version has been stored in cache.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contracted version of the original <code>graph</code>, containing the same
number of columns, but with each row representing an edge between two
junction vertices (or between the submitted <code>verts</code>, which may or may not be
junctions).
</p>


<h3>See Also</h3>

<p>Other modification: 
<code><a href="#topic+dodgr_components">dodgr_components</a>()</code>,
<code><a href="#topic+dodgr_uncontract_graph">dodgr_uncontract_graph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
nrow (graph) # 5,973
graph &lt;- dodgr_contract_graph (graph)
nrow (graph) # 662
</code></pre>

<hr>
<h2 id='dodgr_deduplicate_graph'>Deduplicate edges in a graph</h2><span id='topic+dodgr_deduplicate_graph'></span>

<h3>Description</h3>

<p>Graph may have duplicated edges, particularly when extracted as
<a href="#topic+dodgr_streetnet">dodgr_streetnet</a> objects. This function de-duplicates any repeated
edges, reducing weighted distances and times to the minimal values from all
duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_deduplicate_graph(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_deduplicate_graph_+3A_graph">graph</code></td>
<td>
<p>Any 'dodgr' graph or network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A potentially modified version of graph, with any formerly duplicated
edges reduces to single rows containing minimal weighted distances and times.
</p>


<h3>See Also</h3>

<p>Other conversion: 
<code><a href="#topic+dodgr_to_igraph">dodgr_to_igraph</a>()</code>,
<code><a href="#topic+dodgr_to_sfc">dodgr_to_sfc</a>()</code>,
<code><a href="#topic+dodgr_to_sf">dodgr_to_sf</a>()</code>,
<code><a href="#topic+dodgr_to_tidygraph">dodgr_to_tidygraph</a>()</code>,
<code><a href="#topic+igraph_to_dodgr">igraph_to_dodgr</a>()</code>
</p>

<hr>
<h2 id='dodgr_distances'>Calculate matrix of pair-wise distances between points.</h2><span id='topic+dodgr_distances'></span>

<h3>Description</h3>

<p>Alias for <a href="#topic+dodgr_dists">dodgr_dists</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_distances(
  graph,
  from = NULL,
  to = NULL,
  shortest = TRUE,
  pairwise = FALSE,
  heap = "BHeap",
  parallel = TRUE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_distances_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the network
graph (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_distances_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which route distances are to
be calculated (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_distances_+3A_to">to</code></td>
<td>
<p>Vector or matrix of points <strong>to</strong> which route distances are to be
calculated (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_distances_+3A_shortest">shortest</code></td>
<td>
<p>If <code>FALSE</code>, calculate distances along the <em>fastest</em>
rather than shortest routes (see Notes).</p>
</td></tr>
<tr><td><code id="dodgr_distances_+3A_pairwise">pairwise</code></td>
<td>
<p>If <code>TRUE</code>, calculate distances only between the ordered
pairs of <code>from</code> and <code>to</code>.</p>
</td></tr>
<tr><td><code id="dodgr_distances_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
<code style="white-space: pre;">&#8288;Trinomial Heap (&#8288;</code>TriHeap<code style="white-space: pre;">&#8288;), Extended Trinomial Heap (&#8288;</code>TriHeapExt<code style="white-space: pre;">&#8288;, and 2-3 Heap (&#8288;</code>Heap23').</p>
</td></tr>
<tr><td><code id="dodgr_distances_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, perform routing calculation in parallel (see
details)</p>
</td></tr>
<tr><td><code id="dodgr_distances_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, display progress messages on screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>square matrix of distances between nodes
</p>


<h3>Note</h3>

<p><code>graph</code> must minimally contain three columns of <code>from</code>,
<code>to</code>, <code>dist</code>. If an additional column named <code>weight</code> or
<code>wt</code> is present, shortest paths are calculated according to values
specified in that column; otherwise according to <code>dist</code> values. Either
way, final distances between <code>from</code> and <code>to</code> points are calculated
by default according to values of <code>dist</code>. That is, paths between any pair of
points will be calculated according to the minimal total sum of <code>weight</code>
values (if present), while reported distances will be total sums of <code>dist</code>
values.
</p>
<p>For street networks produced with <a href="#topic+weight_streetnet">weight_streetnet</a>, distances may also
be calculated along the <em>fastest</em> routes with the <code>shortest = FALSE</code>
option. Graphs must in this case have columns of <code>time</code> and <code>time_weighted</code>.
Note that the fastest routes will only be approximate when derived from
<span class="pkg">sf</span>-format data generated with the <span class="pkg">osmdata</span> function
<code>osmdata_sf()</code>, and will be much more accurate when derived from <code>sc</code>-format
data generated with <code>osmdata_sc()</code>. See <a href="#topic+weight_streetnet">weight_streetnet</a> for details.
</p>
<p>The <code>from</code> and <code>to</code> columns of <code>graph</code> may be either single
columns of numeric or character values specifying the numbers or names of
graph vertices, or combinations to two columns specifying geographical
(longitude and latitude) coordinates. In the latter case, almost any sensible
combination of names will be accepted (for example, <code style="white-space: pre;">&#8288;fromx, fromy&#8288;</code>,
<code style="white-space: pre;">&#8288;from_x, from_y&#8288;</code>, or <code style="white-space: pre;">&#8288;fr_lat, fr_lon&#8288;</code>.)
</p>
<p><code>from</code> and <code>to</code> values can be either two-column matrices or
equivalent of longitude and latitude coordinates, or else single columns
precisely matching node numbers or names given in <code>graph$from</code> or
<code>graph$to</code>. If <code>to</code> is <code>NULL</code>, pairwise distances are calculated from all
<code>from</code> points to all other nodes in <code>graph</code>. If both <code>from</code> and <code>to</code> are
<code>NULL</code>, pairwise distances are calculated between all nodes in <code>graph</code>.
</p>
<p>Calculations in parallel (<code>parallel = TRUE</code>) ought very generally be
advantageous. For small graphs, calculating distances in parallel is likely
to offer relatively little gain in speed, but increases from parallel
computation will generally markedly increase with increasing graph sizes.
By default, parallel computation uses the maximal number of available cores
or threads. This number can be reduced by specifying a value via
<code style="white-space: pre;">&#8288;RcppParallel::setThreadOptions (numThreads = &lt;desired_number&gt;)&#8288;</code>. Parallel
calculations are, however, not able to be interrupted (for example, by
<code>Ctrl-C</code>), and can only be stopped by killing the R process.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+dodgr_dists_nearest">dodgr_dists_nearest</a>()</code>,
<code><a href="#topic+dodgr_dists">dodgr_dists</a>()</code>,
<code><a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>()</code>,
<code><a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>()</code>,
<code><a href="#topic+dodgr_flows_si">dodgr_flows_si</a>()</code>,
<code><a href="#topic+dodgr_isochrones">dodgr_isochrones</a>()</code>,
<code><a href="#topic+dodgr_isodists">dodgr_isodists</a>()</code>,
<code><a href="#topic+dodgr_isoverts">dodgr_isoverts</a>()</code>,
<code><a href="#topic+dodgr_paths">dodgr_paths</a>()</code>,
<code><a href="#topic+dodgr_times">dodgr_times</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple graph
graph &lt;- data.frame (
    from = c ("A", "B", "B", "B", "C", "C", "D", "D"),
    to = c ("B", "A", "C", "D", "B", "D", "C", "A"),
    d = c (1, 2, 1, 3, 2, 1, 2, 1)
)
dodgr_dists (graph)

# A larger example from the included [hampi()] data.
graph &lt;- weight_streetnet (hampi)
from &lt;- sample (graph$from_id, size = 100)
to &lt;- sample (graph$to_id, size = 50)
d &lt;- dodgr_dists (graph, from = from, to = to)
# d is a 100-by-50 matrix of distances between `from` and `to`

## Not run: 
# a more complex street network example, thanks to @chrijo; see
# https://github.com/ATFutures/dodgr/issues/47

xy &lt;- rbind (
    c (7.005994, 51.45774), # limbeckerplatz 1 essen germany
    c (7.012874, 51.45041)
) # hauptbahnhof essen germany
xy &lt;- data.frame (lon = xy [, 1], lat = xy [, 2])
essen &lt;- dodgr_streetnet (pts = xy, expand = 0.2, quiet = FALSE)
graph &lt;- weight_streetnet (essen, wt_profile = "foot")
d &lt;- dodgr_dists (graph, from = xy, to = xy)
# First reason why this does not work is because the graph has multiple,
# disconnected components.
table (graph$component)
# reduce to largest connected component, which is always number 1
graph &lt;- graph [which (graph$component == 1), ]
d &lt;- dodgr_dists (graph, from = xy, to = xy)
# should work, but even then note that
table (essen$level)
# There are parts of the network on different building levels (because of
# shopping malls and the like). These may or may not be connected, so it may
# be necessary to filter out particular levels
index &lt;- which (!(essen$level == "-1" | essen$level == "1")) # for example
library (sf) # needed for following sub-select operation
essen &lt;- essen [index, ]
graph &lt;- weight_streetnet (essen, wt_profile = "foot")
graph &lt;- graph [which (graph$component == 1), ]
d &lt;- dodgr_dists (graph, from = xy, to = xy)

## End(Not run)
</code></pre>

<hr>
<h2 id='dodgr_dists'>Calculate matrix of pair-wise distances between points.</h2><span id='topic+dodgr_dists'></span>

<h3>Description</h3>

<p>Calculate matrix of pair-wise distances between points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_dists(
  graph,
  from = NULL,
  to = NULL,
  shortest = TRUE,
  pairwise = FALSE,
  heap = "BHeap",
  parallel = TRUE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_dists_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the network
graph (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_dists_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which route distances are to
be calculated (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_dists_+3A_to">to</code></td>
<td>
<p>Vector or matrix of points <strong>to</strong> which route distances are to be
calculated (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_dists_+3A_shortest">shortest</code></td>
<td>
<p>If <code>FALSE</code>, calculate distances along the <em>fastest</em>
rather than shortest routes (see Notes).</p>
</td></tr>
<tr><td><code id="dodgr_dists_+3A_pairwise">pairwise</code></td>
<td>
<p>If <code>TRUE</code>, calculate distances only between the ordered
pairs of <code>from</code> and <code>to</code>.</p>
</td></tr>
<tr><td><code id="dodgr_dists_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
<code style="white-space: pre;">&#8288;Trinomial Heap (&#8288;</code>TriHeap<code style="white-space: pre;">&#8288;), Extended Trinomial Heap (&#8288;</code>TriHeapExt<code style="white-space: pre;">&#8288;, and 2-3 Heap (&#8288;</code>Heap23').</p>
</td></tr>
<tr><td><code id="dodgr_dists_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, perform routing calculation in parallel (see
details)</p>
</td></tr>
<tr><td><code id="dodgr_dists_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, display progress messages on screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>square matrix of distances between nodes
</p>


<h3>Note</h3>

<p><code>graph</code> must minimally contain three columns of <code>from</code>,
<code>to</code>, <code>dist</code>. If an additional column named <code>weight</code> or
<code>wt</code> is present, shortest paths are calculated according to values
specified in that column; otherwise according to <code>dist</code> values. Either
way, final distances between <code>from</code> and <code>to</code> points are calculated
by default according to values of <code>dist</code>. That is, paths between any pair of
points will be calculated according to the minimal total sum of <code>weight</code>
values (if present), while reported distances will be total sums of <code>dist</code>
values.
</p>
<p>For street networks produced with <a href="#topic+weight_streetnet">weight_streetnet</a>, distances may also
be calculated along the <em>fastest</em> routes with the <code>shortest = FALSE</code>
option. Graphs must in this case have columns of <code>time</code> and <code>time_weighted</code>.
Note that the fastest routes will only be approximate when derived from
<span class="pkg">sf</span>-format data generated with the <span class="pkg">osmdata</span> function
<code>osmdata_sf()</code>, and will be much more accurate when derived from <code>sc</code>-format
data generated with <code>osmdata_sc()</code>. See <a href="#topic+weight_streetnet">weight_streetnet</a> for details.
</p>
<p>The <code>from</code> and <code>to</code> columns of <code>graph</code> may be either single
columns of numeric or character values specifying the numbers or names of
graph vertices, or combinations to two columns specifying geographical
(longitude and latitude) coordinates. In the latter case, almost any sensible
combination of names will be accepted (for example, <code style="white-space: pre;">&#8288;fromx, fromy&#8288;</code>,
<code style="white-space: pre;">&#8288;from_x, from_y&#8288;</code>, or <code style="white-space: pre;">&#8288;fr_lat, fr_lon&#8288;</code>.)
</p>
<p><code>from</code> and <code>to</code> values can be either two-column matrices or
equivalent of longitude and latitude coordinates, or else single columns
precisely matching node numbers or names given in <code>graph$from</code> or
<code>graph$to</code>. If <code>to</code> is <code>NULL</code>, pairwise distances are calculated from all
<code>from</code> points to all other nodes in <code>graph</code>. If both <code>from</code> and <code>to</code> are
<code>NULL</code>, pairwise distances are calculated between all nodes in <code>graph</code>.
</p>
<p>Calculations in parallel (<code>parallel = TRUE</code>) ought very generally be
advantageous. For small graphs, calculating distances in parallel is likely
to offer relatively little gain in speed, but increases from parallel
computation will generally markedly increase with increasing graph sizes.
By default, parallel computation uses the maximal number of available cores
or threads. This number can be reduced by specifying a value via
<code style="white-space: pre;">&#8288;RcppParallel::setThreadOptions (numThreads = &lt;desired_number&gt;)&#8288;</code>. Parallel
calculations are, however, not able to be interrupted (for example, by
<code>Ctrl-C</code>), and can only be stopped by killing the R process.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_distances">dodgr_distances</a>()</code>,
<code><a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+dodgr_dists_nearest">dodgr_dists_nearest</a>()</code>,
<code><a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>()</code>,
<code><a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>()</code>,
<code><a href="#topic+dodgr_flows_si">dodgr_flows_si</a>()</code>,
<code><a href="#topic+dodgr_isochrones">dodgr_isochrones</a>()</code>,
<code><a href="#topic+dodgr_isodists">dodgr_isodists</a>()</code>,
<code><a href="#topic+dodgr_isoverts">dodgr_isoverts</a>()</code>,
<code><a href="#topic+dodgr_paths">dodgr_paths</a>()</code>,
<code><a href="#topic+dodgr_times">dodgr_times</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple graph
graph &lt;- data.frame (
    from = c ("A", "B", "B", "B", "C", "C", "D", "D"),
    to = c ("B", "A", "C", "D", "B", "D", "C", "A"),
    d = c (1, 2, 1, 3, 2, 1, 2, 1)
)
dodgr_dists (graph)

# A larger example from the included [hampi()] data.
graph &lt;- weight_streetnet (hampi)
from &lt;- sample (graph$from_id, size = 100)
to &lt;- sample (graph$to_id, size = 50)
d &lt;- dodgr_dists (graph, from = from, to = to)
# d is a 100-by-50 matrix of distances between `from` and `to`

## Not run: 
# a more complex street network example, thanks to @chrijo; see
# https://github.com/ATFutures/dodgr/issues/47

xy &lt;- rbind (
    c (7.005994, 51.45774), # limbeckerplatz 1 essen germany
    c (7.012874, 51.45041)
) # hauptbahnhof essen germany
xy &lt;- data.frame (lon = xy [, 1], lat = xy [, 2])
essen &lt;- dodgr_streetnet (pts = xy, expand = 0.2, quiet = FALSE)
graph &lt;- weight_streetnet (essen, wt_profile = "foot")
d &lt;- dodgr_dists (graph, from = xy, to = xy)
# First reason why this does not work is because the graph has multiple,
# disconnected components.
table (graph$component)
# reduce to largest connected component, which is always number 1
graph &lt;- graph [which (graph$component == 1), ]
d &lt;- dodgr_dists (graph, from = xy, to = xy)
# should work, but even then note that
table (essen$level)
# There are parts of the network on different building levels (because of
# shopping malls and the like). These may or may not be connected, so it may
# be necessary to filter out particular levels
index &lt;- which (!(essen$level == "-1" | essen$level == "1")) # for example
library (sf) # needed for following sub-select operation
essen &lt;- essen [index, ]
graph &lt;- weight_streetnet (essen, wt_profile = "foot")
graph &lt;- graph [which (graph$component == 1), ]
d &lt;- dodgr_dists (graph, from = xy, to = xy)

## End(Not run)
</code></pre>

<hr>
<h2 id='dodgr_dists_categorical'>Cumulative distances along different edge categories</h2><span id='topic+dodgr_dists_categorical'></span>

<h3>Description</h3>

<p>Cumulative distances along different edge categories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_dists_categorical(
  graph,
  from = NULL,
  to = NULL,
  proportions_only = FALSE,
  pairwise = FALSE,
  dlimit = NULL,
  heap = "BHeap",
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_dists_categorical_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the network
graph which must have a column named &quot;edge_type&quot; which labels categories of
edge types along which categorical distances are to be aggregated (see
Note).</p>
</td></tr>
<tr><td><code id="dodgr_dists_categorical_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which route distances are to
be calculated (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_dists_categorical_+3A_to">to</code></td>
<td>
<p>Vector or matrix of points <strong>to</strong> which route distances are to be
calculated (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_dists_categorical_+3A_proportions_only">proportions_only</code></td>
<td>
<p>If <code>FALSE</code>, return distance matrices for full
distances and for each edge category; if <code>TRUE</code>, return single vector of
proportional distances, like the <code>summary</code> function applied to full
results. See Note.</p>
</td></tr>
<tr><td><code id="dodgr_dists_categorical_+3A_pairwise">pairwise</code></td>
<td>
<p>If <code>TRUE</code>, calculate distances only between the ordered
pairs of <code>from</code> and <code>to</code>. In this case, neither the <code>proportions_only</code> nor
<code>dlimit</code> parameters have any effect, and the result is a single matrix with
one row for each pair of <code>from</code>-<code>to</code> points, and one column for each
category.</p>
</td></tr>
<tr><td><code id="dodgr_dists_categorical_+3A_dlimit">dlimit</code></td>
<td>
<p>If no value to <code>to</code> is given, distances are aggregated from
each <code>from</code> point out to the specified distance limit (in the same units as
the edge distances of the input graph). <code>dlimit</code> only has any effect if <code>to</code>
is not specified, in which case the <code>proportions_only</code> argument has no
effect.</p>
</td></tr>
<tr><td><code id="dodgr_dists_categorical_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
<code style="white-space: pre;">&#8288;Trinomial Heap (&#8288;</code>TriHeap<code style="white-space: pre;">&#8288;), Extended Trinomial Heap (&#8288;</code>TriHeapExt<code style="white-space: pre;">&#8288;, and 2-3 Heap (&#8288;</code>Heap23').</p>
</td></tr>
<tr><td><code id="dodgr_dists_categorical_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, display progress messages on screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>to</code> is specified, a list of distance matrices of equal dimensions
(length(from), length(to)), the first of which (&quot;distance&quot;) holds the final
distances, while the rest are one matrix for each unique value of
&quot;edge_type&quot;, holding the distances traversed along those types of edges only.
Otherwise, a single matrix of total distances along all ways from each point
out to the specified value of <code>dlimit</code>, along with distances along each of
the different kinds of ways specified in the &quot;edge_type&quot; column of the input
graph.
</p>


<h3>Note</h3>

<p>The &quot;edge_type&quot; column in the graph can contain any kind of discrete or
categorical values, although integer values of 0 are not permissible. <code>NA</code>
values are ignored. The function requires one full distance
matrix to be stored for each category of &quot;edge_type&quot; (unless
<code>proportions_only = TRUE</code>). It is wise to keep numbers of discrete types as
low as possible, especially for large distance matrices.
</p>
<p>Setting the <code>proportions_only</code> flag to <code>TRUE</code> may be advantageous for
large jobs, because this avoids construction of the full matrices. This may
speed up calculations, but perhaps more importantly it may make possible
calculations which would otherwise require distance matrices too large to be
directly stored.
</p>
<p>Calculations are not able to be interrupted (for example, by <code>Ctrl-C</code>),
and can only be stopped by killing the R process.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_distances">dodgr_distances</a>()</code>,
<code><a href="#topic+dodgr_dists_nearest">dodgr_dists_nearest</a>()</code>,
<code><a href="#topic+dodgr_dists">dodgr_dists</a>()</code>,
<code><a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>()</code>,
<code><a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>()</code>,
<code><a href="#topic+dodgr_flows_si">dodgr_flows_si</a>()</code>,
<code><a href="#topic+dodgr_isochrones">dodgr_isochrones</a>()</code>,
<code><a href="#topic+dodgr_isodists">dodgr_isodists</a>()</code>,
<code><a href="#topic+dodgr_isoverts">dodgr_isoverts</a>()</code>,
<code><a href="#topic+dodgr_paths">dodgr_paths</a>()</code>,
<code><a href="#topic+dodgr_times">dodgr_times</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prepare a graph for categorical routing by including an "edge_type" column
graph &lt;- weight_streetnet (hampi, wt_profile = "foot")
graph &lt;- graph [graph$component == 1, ]
graph$edge_type &lt;- graph$highway
# Define start and end points for categorical distances; using all vertices
# here.
length (unique (graph$edge_type)) # Number of categories
v &lt;- dodgr_vertices (graph)
from &lt;- to &lt;- v$id [1:100]
d &lt;- dodgr_dists_categorical (graph, from, to)
class (d)
length (d)
sapply (d, dim)
# 9 distance matrices, all of same dimensions, first of which is standard
# distance matrix
s &lt;- summary (d) # print summary as proportions along each "edge_type"
# or directly calculate proportions only
dodgr_dists_categorical (graph, from, to,
    proportions_only = TRUE
)

# Pairwise distances return single matrix with number of rows equal to 'from'
# / 'to', and number of columns equal to number of edge types plus one for
# total distances.
d &lt;- dodgr_dists_categorical (graph, from, to, pairwise = TRUE)
class (d)
dim (d)

# The 'dlimit' parameter can be used to calculate total distances along each
# category of edges from a set of points out to specified threshold:
dlimit &lt;- 2000 # in metres
d &lt;- dodgr_dists_categorical (graph, from, dlimit = dlimit)
dim (d) # length(from), length(unique(edge_type)) + 1
</code></pre>

<hr>
<h2 id='dodgr_dists_nearest'>Calculate vector of shortest distances from a series of 'from' points to
nearest one of series of 'to' points.</h2><span id='topic+dodgr_dists_nearest'></span>

<h3>Description</h3>

<p>Calculate vector of shortest distances from a series of 'from' points to
nearest one of series of 'to' points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_dists_nearest(
  graph,
  from = NULL,
  to = NULL,
  shortest = TRUE,
  heap = "BHeap",
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_dists_nearest_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the network
graph (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_dists_nearest_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which route distances are to
be calculated (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_dists_nearest_+3A_to">to</code></td>
<td>
<p>Vector or matrix of points <strong>to</strong> which shortest route distances
are to be calculated to nearest 'to' point only.</p>
</td></tr>
<tr><td><code id="dodgr_dists_nearest_+3A_shortest">shortest</code></td>
<td>
<p>If <code>FALSE</code>, calculate distances along the <em>fastest</em>
rather than shortest routes (see Notes).</p>
</td></tr>
<tr><td><code id="dodgr_dists_nearest_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
<code style="white-space: pre;">&#8288;Trinomial Heap (&#8288;</code>TriHeap<code style="white-space: pre;">&#8288;), Extended Trinomial Heap (&#8288;</code>TriHeapExt<code style="white-space: pre;">&#8288;, and 2-3 Heap (&#8288;</code>Heap23').</p>
</td></tr>
<tr><td><code id="dodgr_dists_nearest_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, display progress messages on screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of distances, one element for each 'from' point giving the
distance to the nearest 'to' point.
</p>


<h3>Note</h3>

<p><code>graph</code> must minimally contain three columns of <code>from</code>,
<code>to</code>, <code>dist</code>. If an additional column named <code>weight</code> or
<code>wt</code> is present, shortest paths are calculated according to values
specified in that column; otherwise according to <code>dist</code> values. Either
way, final distances between <code>from</code> and <code>to</code> points are calculated
by default according to values of <code>dist</code>. That is, paths between any pair of
points will be calculated according to the minimal total sum of <code>weight</code>
values (if present), while reported distances will be total sums of <code>dist</code>
values.
</p>
<p>For street networks produced with <a href="#topic+weight_streetnet">weight_streetnet</a>, distances may also
be calculated along the <em>fastest</em> routes with the <code>shortest = FALSE</code>
option. Graphs must in this case have columns of <code>time</code> and <code>time_weighted</code>.
Note that the fastest routes will only be approximate when derived from
<span class="pkg">sf</span>-format data generated with the <span class="pkg">osmdata</span> function
<code>osmdata_sf()</code>, and will be much more accurate when derived from <code>sc</code>-format
data generated with <code>osmdata_sc()</code>. See <a href="#topic+weight_streetnet">weight_streetnet</a> for details.
</p>
<p>The <code>from</code> and <code>to</code> columns of <code>graph</code> may be either single
columns of numeric or character values specifying the numbers or names of
graph vertices, or combinations to two columns specifying geographical
(longitude and latitude) coordinates. In the latter case, almost any sensible
combination of names will be accepted (for example, <code style="white-space: pre;">&#8288;fromx, fromy&#8288;</code>,
<code style="white-space: pre;">&#8288;from_x, from_y&#8288;</code>, or <code style="white-space: pre;">&#8288;fr_lat, fr_lon&#8288;</code>.)
</p>
<p><code>from</code> and <code>to</code> values can be either two-column matrices or
equivalent of longitude and latitude coordinates, or else single columns
precisely matching node numbers or names given in <code>graph$from</code> or
<code>graph$to</code>. If <code>to</code> is <code>NULL</code>, pairwise distances are calculated from all
<code>from</code> points to all other nodes in <code>graph</code>. If both <code>from</code> and <code>to</code> are
<code>NULL</code>, pairwise distances are calculated between all nodes in <code>graph</code>.
</p>
<p>Calculations are always calculated in parallel, using multiple threads.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_distances">dodgr_distances</a>()</code>,
<code><a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+dodgr_dists">dodgr_dists</a>()</code>,
<code><a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>()</code>,
<code><a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>()</code>,
<code><a href="#topic+dodgr_flows_si">dodgr_flows_si</a>()</code>,
<code><a href="#topic+dodgr_isochrones">dodgr_isochrones</a>()</code>,
<code><a href="#topic+dodgr_isodists">dodgr_isodists</a>()</code>,
<code><a href="#topic+dodgr_isoverts">dodgr_isoverts</a>()</code>,
<code><a href="#topic+dodgr_paths">dodgr_paths</a>()</code>,
<code><a href="#topic+dodgr_times">dodgr_times</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple graph
graph &lt;- data.frame (
    from = c ("A", "B", "B", "B", "C", "C", "D", "D"),
    to = c ("B", "A", "C", "D", "B", "D", "C", "A"),
    d = c (1, 2, 1, 3, 2, 1, 2, 1)
)
dodgr_dists (graph)

# A larger example from the included [hampi()] data.
graph &lt;- weight_streetnet (hampi)
from &lt;- sample (graph$from_id, size = 100)
to &lt;- sample (graph$to_id, size = 50)
d &lt;- dodgr_dists (graph, from = from, to = to)
# d is a 100-by-50 matrix of distances between `from` and `to`

## Not run: 
# a more complex street network example, thanks to @chrijo; see
# https://github.com/ATFutures/dodgr/issues/47

xy &lt;- rbind (
    c (7.005994, 51.45774), # limbeckerplatz 1 essen germany
    c (7.012874, 51.45041)
) # hauptbahnhof essen germany
xy &lt;- data.frame (lon = xy [, 1], lat = xy [, 2])
essen &lt;- dodgr_streetnet (pts = xy, expand = 0.2, quiet = FALSE)
graph &lt;- weight_streetnet (essen, wt_profile = "foot")
d &lt;- dodgr_dists (graph, from = xy, to = xy)
# First reason why this does not work is because the graph has multiple,
# disconnected components.
table (graph$component)
# reduce to largest connected component, which is always number 1
graph &lt;- graph [which (graph$component == 1), ]
d &lt;- dodgr_dists (graph, from = xy, to = xy)
# should work, but even then note that
table (essen$level)
# There are parts of the network on different building levels (because of
# shopping malls and the like). These may or may not be connected, so it may
# be necessary to filter out particular levels
index &lt;- which (!(essen$level == "-1" | essen$level == "1")) # for example
library (sf) # needed for following sub-select operation
essen &lt;- essen [index, ]
graph &lt;- weight_streetnet (essen, wt_profile = "foot")
graph &lt;- graph [which (graph$component == 1), ]
d &lt;- dodgr_dists (graph, from = xy, to = xy)

## End(Not run)
</code></pre>

<hr>
<h2 id='dodgr_flowmap'>Create a map of <code>dodgr</code> flows.</h2><span id='topic+dodgr_flowmap'></span>

<h3>Description</h3>

<p>Create a map of the output of <a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a> or
<a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_flowmap(net, bbox = NULL, linescale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_flowmap_+3A_net">net</code></td>
<td>
<p>A street network with a <code>flow</code> column obtained from
<a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a> or <a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a></p>
</td></tr>
<tr><td><code id="dodgr_flowmap_+3A_bbox">bbox</code></td>
<td>
<p>If given, scale the map to this bbox, otherwise use entire extend
of <code>net</code></p>
</td></tr>
<tr><td><code id="dodgr_flowmap_+3A_linescale">linescale</code></td>
<td>
<p>Maximal thickness of plotted lines</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>net</code> should be first passed through <code>merge_directed_graph</code>
prior to plotting, otherwise lines for different directions will be overlaid.
</p>


<h3>See Also</h3>

<p>Other misc: 
<code><a href="#topic+compare_heaps">compare_heaps</a>()</code>,
<code><a href="#topic+dodgr_full_cycles">dodgr_full_cycles</a>()</code>,
<code><a href="#topic+dodgr_fundamental_cycles">dodgr_fundamental_cycles</a>()</code>,
<code><a href="#topic+dodgr_insert_vertex">dodgr_insert_vertex</a>()</code>,
<code><a href="#topic+dodgr_sample">dodgr_sample</a>()</code>,
<code><a href="#topic+dodgr_sflines_to_poly">dodgr_sflines_to_poly</a>()</code>,
<code><a href="#topic+dodgr_vertices">dodgr_vertices</a>()</code>,
<code><a href="#topic+merge_directed_graph">merge_directed_graph</a>()</code>,
<code><a href="#topic+summary.dodgr_dists_categorical">summary.dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
from &lt;- sample (graph$from_id, size = 10)
to &lt;- sample (graph$to_id, size = 5)
to &lt;- to [!to %in% from]
flows &lt;- matrix (
    10 * runif (length (from) * length (to)),
    nrow = length (from)
)
graph &lt;- dodgr_flows_aggregate (graph, from = from, to = to, flows = flows)
# graph then has an additonal 'flows` column of aggregate flows along all
# edges. These flows are directed, and can be aggregated to equivalent
# undirected flows on an equivalent undirected graph with:
graph_undir &lt;- merge_directed_graph (graph)
## Not run: 
dodgr_flowmap (graph_undir)

## End(Not run)
</code></pre>

<hr>
<h2 id='dodgr_flows_aggregate'>Aggregate flows throughout a network.</h2><span id='topic+dodgr_flows_aggregate'></span>

<h3>Description</h3>

<p>Aggregate flows throughout a network based on an input matrix of flows
between all pairs of <code>from</code> and <code>to</code> points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_flows_aggregate(
  graph,
  from,
  to,
  flows,
  contract = TRUE,
  heap = "BHeap",
  tol = 1e-12,
  norm_sums = TRUE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_flows_aggregate_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the network
graph (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_flows_aggregate_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which aggregate flows are to
be calculated (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_flows_aggregate_+3A_to">to</code></td>
<td>
<p>Vector or matrix of points <strong>to</strong> which aggregate flows are to be
calculated (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_flows_aggregate_+3A_flows">flows</code></td>
<td>
<p>Matrix of flows with <code>nrow(flows)==length(from)</code> and
<code>ncol(flows)==length(to)</code>.</p>
</td></tr>
<tr><td><code id="dodgr_flows_aggregate_+3A_contract">contract</code></td>
<td>
<p>If <code>TRUE</code> (default), calculate flows on contracted graph
before mapping them back on to the original full graph (recommended as this
will generally be much faster). <code>FALSE</code> should only be used if the <code>graph</code>
has already been contracted.</p>
</td></tr>
<tr><td><code id="dodgr_flows_aggregate_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
Trinomial Heap (<code>TriHeap</code>), Extended Trinomial Heap
(<code>TriHeapExt</code>, and 2-3 Heap (<code>Heap23</code>).</p>
</td></tr>
<tr><td><code id="dodgr_flows_aggregate_+3A_tol">tol</code></td>
<td>
<p>Relative tolerance below which flows towards <code>to</code> vertices are not
considered. This will generally have no effect, but can provide speed gains
when flow matrices represent spatial interaction models, in which case this
parameter effectively reduces the radius from each <code>from</code> point over which
flows are aggregated. To remove any such effect, set <code>tol = 0</code>.</p>
</td></tr>
<tr><td><code id="dodgr_flows_aggregate_+3A_norm_sums">norm_sums</code></td>
<td>
<p>Standardise sums from all origin points, so sum of flows
throughout entire network equals sum of densities from all origins (see
Note).</p>
</td></tr>
<tr><td><code id="dodgr_flows_aggregate_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, display progress messages on screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified version of graph with additional <code>flow</code> column added.
</p>


<h3>Note</h3>

<p>Spatial Interaction models are often fitted through trialling a range
of values of 'k'. The specification above allows fitting multiple values of
'k' to be done with a single call, in a way that is far more efficient than
making multiple calls. A matrix of 'k' values may be entered, with each
column holding a different vector of values, one for each 'from' point. For a
matrix of 'k' values having 'n' columns, the return object will be a modified
version in the input 'graph', with an additional 'n' columns, named 'flow1',
'flow2', ... up to 'n'. These columns must be subsequently matched by the
user back on to the corresponding columns of the matrix of 'k' values.
</p>
<p>The <code>norm_sums</code> parameter should be used whenever densities at origins
and destinations are absolute values, and ensures that the sum of resultant
flow values throughout the entire network equals the sum of densities at all
origins. For example, with <code>norm_sums = TRUE</code> (the default), a flow from a
single origin with density one to a single destination along two edges will
allocate flows of one half to each of those edges, such that the sum of flows
across the network will equal one, or the sum of densities from all origins.
The <code>norm_sums = TRUE</code> option is appropriate where densities are relative
values, and ensures that each edge maintains relative proportions. In the
above example, flows along each of two edges would equal one, for a network
sum of two, or greater than the sum of densities.
</p>
<p>Flows are calculated by default using parallel computation with the maximal
number of available cores or threads. This number can be reduced by
specifying a value via
<code style="white-space: pre;">&#8288;RcppParallel::setThreadOptions (numThreads = &lt;desired_number&gt;)&#8288;</code>.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_distances">dodgr_distances</a>()</code>,
<code><a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+dodgr_dists_nearest">dodgr_dists_nearest</a>()</code>,
<code><a href="#topic+dodgr_dists">dodgr_dists</a>()</code>,
<code><a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>()</code>,
<code><a href="#topic+dodgr_flows_si">dodgr_flows_si</a>()</code>,
<code><a href="#topic+dodgr_isochrones">dodgr_isochrones</a>()</code>,
<code><a href="#topic+dodgr_isodists">dodgr_isodists</a>()</code>,
<code><a href="#topic+dodgr_isoverts">dodgr_isoverts</a>()</code>,
<code><a href="#topic+dodgr_paths">dodgr_paths</a>()</code>,
<code><a href="#topic+dodgr_times">dodgr_times</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
from &lt;- sample (graph$from_id, size = 10)
to &lt;- sample (graph$to_id, size = 5)
to &lt;- to [!to %in% from]
flows &lt;- matrix (10 * runif (length (from) * length (to)),
    nrow = length (from)
)
graph &lt;- dodgr_flows_aggregate (graph, from = from, to = to, flows = flows)
# graph then has an additonal 'flows' column of aggregate flows along all
# edges. These flows are directed, and can be aggregated to equivalent
# undirected flows on an equivalent undirected graph with:
graph_undir &lt;- merge_directed_graph (graph)
# This graph will only include those edges having non-zero flows, and so:
nrow (graph)
nrow (graph_undir) # the latter is much smaller

# The following code can be used to convert the resultant graph to an `sf`
# object suitable for plotting
## Not run: 
gsf &lt;- dodgr_to_sf (graph_undir)

# example of plotting with the 'mapview' package
library (mapview)
flow &lt;- gsf$flow / max (gsf$flow)
ncols &lt;- 30
cols &lt;- c ("lawngreen", "red")
colranmp &lt;- colorRampPalette (cols) (ncols) [ceiling (ncols * flow)]
mapview (gsf, color = colranmp, lwd = 10 * flow)

## End(Not run)

# An example of flow aggregation across a generic (non-OSM) highway,
# represented as the `routes_fast` object of the \pkg{stplanr} package,
# which is a SpatialLinesDataFrame containing commuter densities along
# components of a street network.
## Not run: 
library (stplanr)
# merge all of the 'routes_fast' lines into a single network
r &lt;- overline (routes_fast, attrib = "length", buff_dist = 1)
r &lt;- sf::st_as_sf (r)
# then extract the start and end points of each of the original 'routes_fast'
# lines and use these for routing with `dodgr`
l &lt;- lapply (routes_fast@lines, function (i) {
    c (
        sp::coordinates (i) [[1]] [1, ],
        tail (sp::coordinates (i) [[1]], 1)
    )
})
l &lt;- do.call (rbind, l)
xy_start &lt;- l [, 1:2]
xy_end &lt;- l [, 3:4]
# Then just specify a generic OD matrix with uniform values of 1:
flows &lt;- matrix (1, nrow = nrow (l), ncol = nrow (l))
# We need to specify both a `type` and `id` column for the
# \link{weight_streetnet} function.
r$type &lt;- 1
r$id &lt;- seq (nrow (r))
graph &lt;- weight_streetnet (
    r,
    type_col = "type",
    id_col = "id",
    wt_profile = 1
)
f &lt;- dodgr_flows_aggregate (
    graph,
    from = xy_start,
    to = xy_end,
    flows = flows
)
# Then merge directed flows and convert to \pkg{sf} for plotting as before:
f &lt;- merge_directed_graph (f)
geoms &lt;- dodgr_to_sfc (f)
gc &lt;- dodgr_contract_graph (f)
gsf &lt;- sf::st_sf (geoms)
gsf$flow &lt;- gc$flow
# sf plot:
plot (gsf ["flow"])

## End(Not run)
</code></pre>

<hr>
<h2 id='dodgr_flows_disperse'>Aggregate flows dispersed from each point in a network.</h2><span id='topic+dodgr_flows_disperse'></span>

<h3>Description</h3>

<p>Disperse flows throughout a network based on a input vectors of origin points
and associated densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_flows_disperse(
  graph,
  from,
  dens,
  k = 500,
  contract = TRUE,
  heap = "BHeap",
  tol = 1e-12,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_flows_disperse_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the network
graph (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_flows_disperse_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which aggregate dispersed
flows are to be calculated (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_flows_disperse_+3A_dens">dens</code></td>
<td>
<p>Vectors of densities corresponding to the <code>from</code> points</p>
</td></tr>
<tr><td><code id="dodgr_flows_disperse_+3A_k">k</code></td>
<td>
<p>Width coefficient of exponential diffusion function defined as
<code>exp(-d/k)</code>, in units of distance column of <code>graph</code> (metres by default). Can
also be a vector with same length as <code>from</code>, giving dispersal coefficients
from each point. If value of <code>k&lt;0</code> is given, a standard logistic polynomial
will be used.</p>
</td></tr>
<tr><td><code id="dodgr_flows_disperse_+3A_contract">contract</code></td>
<td>
<p>If <code>TRUE</code> (default), calculate flows on contracted graph
before mapping them back on to the original full graph (recommended as this
will generally be much faster). <code>FALSE</code> should only be used if the <code>graph</code>
has already been contracted.</p>
</td></tr>
<tr><td><code id="dodgr_flows_disperse_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
Trinomial Heap (<code>TriHeap</code>), Extended Trinomial Heap
(<code>TriHeapExt</code>, and 2-3 Heap (<code>Heap23</code>).</p>
</td></tr>
<tr><td><code id="dodgr_flows_disperse_+3A_tol">tol</code></td>
<td>
<p>Relative tolerance below which dispersal is considered to have
finished. This parameter can generally be ignored; if in doubt, its effect
can be removed by setting <code>tol = 0</code>.</p>
</td></tr>
<tr><td><code id="dodgr_flows_disperse_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, display progress messages on screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified version of graph with additional <code>flow</code> column added.
</p>


<h3>Note</h3>

<p>Spatial Interaction models are often fitted through trialling a range
of values of 'k'. The specification above allows fitting multiple values of
'k' to be done with a single call, in a way that is far more efficient than
making multiple calls. A matrix of 'k' values may be entered, with each
column holding a different vector of values, one for each 'from' point. For a
matrix of 'k' values having 'n' columns, the return object will be a modified
version in the input 'graph', with an additional 'n' columns, named 'flow1',
'flow2', ... up to 'n'. These columns must be subsequently matched by the
user back on to the corresponding columns of the matrix of 'k' values.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_distances">dodgr_distances</a>()</code>,
<code><a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+dodgr_dists_nearest">dodgr_dists_nearest</a>()</code>,
<code><a href="#topic+dodgr_dists">dodgr_dists</a>()</code>,
<code><a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>()</code>,
<code><a href="#topic+dodgr_flows_si">dodgr_flows_si</a>()</code>,
<code><a href="#topic+dodgr_isochrones">dodgr_isochrones</a>()</code>,
<code><a href="#topic+dodgr_isodists">dodgr_isodists</a>()</code>,
<code><a href="#topic+dodgr_isoverts">dodgr_isoverts</a>()</code>,
<code><a href="#topic+dodgr_paths">dodgr_paths</a>()</code>,
<code><a href="#topic+dodgr_times">dodgr_times</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
from &lt;- sample (graph$from_id, size = 10)
dens &lt;- rep (1, length (from)) # Uniform densities
graph &lt;- dodgr_flows_disperse (graph, from = from, dens = dens)
# graph then has an additonal 'flows` column of aggregate flows along all
# edges. These flows are directed, and can be aggregated to equivalent
# undirected flows on an equivalent undirected graph with:
graph_undir &lt;- merge_directed_graph (graph)
</code></pre>

<hr>
<h2 id='dodgr_flows_si'>Aggregate flows throughout a network using a spatial interaction model.</h2><span id='topic+dodgr_flows_si'></span>

<h3>Description</h3>

<p>Aggregate flows throughout a network using an exponential Spatial Interaction
(SI) model between a specified set of origin and destination points, and
associated vectors of densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_flows_si(
  graph,
  from,
  to,
  k = 500,
  dens_from = NULL,
  dens_to = NULL,
  contract = TRUE,
  norm_sums = TRUE,
  heap = "BHeap",
  tol = 1e-12,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_flows_si_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the network
graph (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_flows_si_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which aggregate flows are to
be calculated (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_flows_si_+3A_to">to</code></td>
<td>
<p>Vector or matrix of points <strong>to</strong> which aggregate flows are to be
calculated (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_flows_si_+3A_k">k</code></td>
<td>
<p>Width of exponential spatial interaction function (exp (-d / k)),
in units of 'd', specified in one of 3 forms: (i) a single value; (ii) a
vector of independent values for each origin point (with same length as
'from' points); or (iii) an equivalent matrix with each column holding values
for each 'from' point, so 'nrow(k)==length(from)'. See Note.</p>
</td></tr>
<tr><td><code id="dodgr_flows_si_+3A_dens_from">dens_from</code></td>
<td>
<p>Vector of densities at origin ('from') points</p>
</td></tr>
<tr><td><code id="dodgr_flows_si_+3A_dens_to">dens_to</code></td>
<td>
<p>Vector of densities at destination ('to') points</p>
</td></tr>
<tr><td><code id="dodgr_flows_si_+3A_contract">contract</code></td>
<td>
<p>If <code>TRUE</code> (default), calculate flows on contracted graph
before mapping them back on to the original full graph (recommended as this
will generally be much faster). <code>FALSE</code> should only be used if the <code>graph</code>
has already been contracted.</p>
</td></tr>
<tr><td><code id="dodgr_flows_si_+3A_norm_sums">norm_sums</code></td>
<td>
<p>Standardise sums from all origin points, so sum of flows
throughout entire network equals sum of densities from all origins (see
Note).</p>
</td></tr>
<tr><td><code id="dodgr_flows_si_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
Trinomial Heap (<code>TriHeap</code>), Extended Trinomial Heap
(<code>TriHeapExt</code>, and 2-3 Heap (<code>Heap23</code>).</p>
</td></tr>
<tr><td><code id="dodgr_flows_si_+3A_tol">tol</code></td>
<td>
<p>Relative tolerance below which flows towards <code>to</code> vertices are not
considered. This will generally have no effect, but can provide speed gains
when flow matrices represent spatial interaction models, in which case this
parameter effectively reduces the radius from each <code>from</code> point over which
flows are aggregated. To remove any such effect, set <code>tol = 0</code>.</p>
</td></tr>
<tr><td><code id="dodgr_flows_si_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, display progress messages on screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified version of graph with additional <code>flow</code> column added.
</p>


<h3>Note</h3>

<p>Spatial Interaction models are often fitted through trialling a range
of values of 'k'. The specification above allows fitting multiple values of
'k' to be done with a single call, in a way that is far more efficient than
making multiple calls. A matrix of 'k' values may be entered, with each
column holding a different vector of values, one for each 'from' point. For a
matrix of 'k' values having 'n' columns, the return object will be a modified
version in the input 'graph', with an additional 'n' columns, named 'flow1',
'flow2', ... up to 'n'. These columns must be subsequently matched by the
user back on to the corresponding columns of the matrix of 'k' values.
</p>
<p>The <code>norm_sums</code> parameter should be used whenever densities at origins
and destinations are absolute values, and ensures that the sum of resultant
flow values throughout the entire network equals the sum of densities at all
origins. For example, with <code>norm_sums = TRUE</code> (the default), a flow from a
single origin with density one to a single destination along two edges will
allocate flows of one half to each of those edges, such that the sum of flows
across the network will equal one, or the sum of densities from all origins.
The <code>norm_sums = TRUE</code> option is appropriate where densities are relative
values, and ensures that each edge maintains relative proportions. In the
above example, flows along each of two edges would equal one, for a network
sum of two, or greater than the sum of densities.
</p>
<p>With <code>norm_sums = TRUE</code>, the sum of network flows (<code>sum(output$flow)</code>) should
equal the sum of origin densities (<code>sum(dens_from)</code>). This may nevertheless
not always be the case, because origin points may simply be too far from any
destination (<code>to</code>) points for an exponential model to yield non-zero values
anywhere in a network within machine tolerance. Such cases may result in sums
of output flows being less than sums of input densities.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_distances">dodgr_distances</a>()</code>,
<code><a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+dodgr_dists_nearest">dodgr_dists_nearest</a>()</code>,
<code><a href="#topic+dodgr_dists">dodgr_dists</a>()</code>,
<code><a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>()</code>,
<code><a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>()</code>,
<code><a href="#topic+dodgr_isochrones">dodgr_isochrones</a>()</code>,
<code><a href="#topic+dodgr_isodists">dodgr_isodists</a>()</code>,
<code><a href="#topic+dodgr_isoverts">dodgr_isoverts</a>()</code>,
<code><a href="#topic+dodgr_paths">dodgr_paths</a>()</code>,
<code><a href="#topic+dodgr_times">dodgr_times</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
from &lt;- sample (graph$from_id, size = 10)
to &lt;- sample (graph$to_id, size = 5)
to &lt;- to [!to %in% from]
flows &lt;- matrix (10 * runif (length (from) * length (to)),
    nrow = length (from)
)
graph &lt;- dodgr_flows_aggregate (graph, from = from, to = to, flows = flows)
# graph then has an additonal 'flows' column of aggregate flows along all
# edges. These flows are directed, and can be aggregated to equivalent
# undirected flows on an equivalent undirected graph with:
graph_undir &lt;- merge_directed_graph (graph)
# This graph will only include those edges having non-zero flows, and so:
nrow (graph)
nrow (graph_undir) # the latter is much smaller
</code></pre>

<hr>
<h2 id='dodgr_full_cycles'>Calculate fundamental cycles on a FULL (that is, non-contracted) graph.</h2><span id='topic+dodgr_full_cycles'></span>

<h3>Description</h3>

<p>Calculate fundamental cycles on a FULL (that is, non-contracted) graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_full_cycles(graph, graph_max_size = 10000, expand = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_full_cycles_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the contracted
network graph (see Details).</p>
</td></tr>
<tr><td><code id="dodgr_full_cycles_+3A_graph_max_size">graph_max_size</code></td>
<td>
<p>Maximum size submitted to the internal C++ routines as
a single chunk. Warning: Increasing this may lead to computer meltdown!</p>
</td></tr>
<tr><td><code id="dodgr_full_cycles_+3A_expand">expand</code></td>
<td>
<p>For large graphs which must be broken into chunks, this factor
determines the relative overlap between chunks to ensure all cycles are
captured. (This value should only need to be modified in special cases.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function converts the <code>graph</code> to its contracted form, calculates
the fundamental cycles on that version, and then expands these cycles back
onto the original graph. This is far more computationally efficient than
calculating fundamental cycles on a full (non-contracted) graph.
</p>


<h3>See Also</h3>

<p>Other misc: 
<code><a href="#topic+compare_heaps">compare_heaps</a>()</code>,
<code><a href="#topic+dodgr_flowmap">dodgr_flowmap</a>()</code>,
<code><a href="#topic+dodgr_fundamental_cycles">dodgr_fundamental_cycles</a>()</code>,
<code><a href="#topic+dodgr_insert_vertex">dodgr_insert_vertex</a>()</code>,
<code><a href="#topic+dodgr_sample">dodgr_sample</a>()</code>,
<code><a href="#topic+dodgr_sflines_to_poly">dodgr_sflines_to_poly</a>()</code>,
<code><a href="#topic+dodgr_vertices">dodgr_vertices</a>()</code>,
<code><a href="#topic+merge_directed_graph">merge_directed_graph</a>()</code>,
<code><a href="#topic+summary.dodgr_dists_categorical">summary.dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
net &lt;- weight_streetnet (hampi)
graph &lt;- dodgr_contract_graph (net)
cyc1 &lt;- dodgr_fundamental_cycles (graph)
cyc2 &lt;- dodgr_full_cycles (net)

## End(Not run)
# cyc2 has same number of cycles, but each one is generally longer, through
# including all points intermediate to junctions; cyc1 has cycles composed of
# junction points only.
</code></pre>

<hr>
<h2 id='dodgr_fundamental_cycles'>Calculate fundamental cycles in a graph.</h2><span id='topic+dodgr_fundamental_cycles'></span>

<h3>Description</h3>

<p>Calculate fundamental cycles in a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_fundamental_cycles(
  graph,
  vertices = NULL,
  graph_max_size = 10000,
  expand = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_fundamental_cycles_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the contracted
network graph (see Details).</p>
</td></tr>
<tr><td><code id="dodgr_fundamental_cycles_+3A_vertices">vertices</code></td>
<td>
<p><code>data.frame</code> returned from <a href="#topic+dodgr_vertices">dodgr_vertices</a><code>(graph)</code>.
Will be calculated if not provided, but it's quicker to pass this if it has
already been calculated.</p>
</td></tr>
<tr><td><code id="dodgr_fundamental_cycles_+3A_graph_max_size">graph_max_size</code></td>
<td>
<p>Maximum size submitted to the internal C++ routines as
a single chunk. Warning: Increasing this may lead to computer meltdown!</p>
</td></tr>
<tr><td><code id="dodgr_fundamental_cycles_+3A_expand">expand</code></td>
<td>
<p>For large graphs which must be broken into chunks, this factor
determines the relative overlap between chunks to ensure all cycles are
captured. (This value should only need to be modified in special cases.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of cycle paths, in terms of vertex IDs in <code>graph</code> and, for
spatial graphs, the corresponding coordinates.
</p>


<h3>Note</h3>

<p>Calculation of fundamental cycles is VERY computationally demanding,
and this function should only be executed on CONTRACTED graphs (that is,
graphs returned from <a href="#topic+dodgr_contract_graph">dodgr_contract_graph</a>), and even than may take a
long time to execute. Results for full graphs can be obtained with the
function <a href="#topic+dodgr_full_cycles">dodgr_full_cycles</a>. The computational complexity can also not
be calculated in advance, and so the parameter <code>graph_max_size</code> will lead to
graphs larger than that (measured in numbers of edges) being cut into smaller
parts. (Note that that is only possible for spatial graphs, meaning that it
is not at all possible to apply this function to large, non-spatial graphs.)
Each of these smaller parts will be expanded by the specified amount
(<code>expand</code>), and cycles found within. The final result is obtained by
aggregating all of these cycles and removing any repeated ones arising due to
overlap in the expanded portions. Finally, note that this procedure of
cutting graphs into smaller, computationally manageable sub-graphs provides
only an approximation and may not yield all fundamental cycles.
</p>


<h3>See Also</h3>

<p>Other misc: 
<code><a href="#topic+compare_heaps">compare_heaps</a>()</code>,
<code><a href="#topic+dodgr_flowmap">dodgr_flowmap</a>()</code>,
<code><a href="#topic+dodgr_full_cycles">dodgr_full_cycles</a>()</code>,
<code><a href="#topic+dodgr_insert_vertex">dodgr_insert_vertex</a>()</code>,
<code><a href="#topic+dodgr_sample">dodgr_sample</a>()</code>,
<code><a href="#topic+dodgr_sflines_to_poly">dodgr_sflines_to_poly</a>()</code>,
<code><a href="#topic+dodgr_vertices">dodgr_vertices</a>()</code>,
<code><a href="#topic+merge_directed_graph">merge_directed_graph</a>()</code>,
<code><a href="#topic+summary.dodgr_dists_categorical">summary.dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- weight_streetnet (hampi)
graph &lt;- dodgr_contract_graph (net)
verts &lt;- dodgr_vertices (graph)
cyc &lt;- dodgr_fundamental_cycles (graph, verts)
</code></pre>

<hr>
<h2 id='dodgr_insert_vertex'>Insert a new node or vertex into a network</h2><span id='topic+dodgr_insert_vertex'></span>

<h3>Description</h3>

<p>Insert a new node or vertex into a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_insert_vertex(graph, v1, v2, x = NULL, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_insert_vertex_+3A_graph">graph</code></td>
<td>
<p>A flat table of graph edges. Must contain columns labelled
<code>from</code> and <code>to</code>, or <code>start</code> and <code>stop</code>. May also contain
similarly labelled columns of spatial coordinates (for example
<code>from_x</code>) or <code>stop_lon</code>).</p>
</td></tr>
<tr><td><code id="dodgr_insert_vertex_+3A_v1">v1</code></td>
<td>
<p>Vertex defining start of graph edge along which new vertex is to be
inserted</p>
</td></tr>
<tr><td><code id="dodgr_insert_vertex_+3A_v2">v2</code></td>
<td>
<p>Vertex defining end of graph edge along which new vertex is to be
inserted (order of <code>v1</code> and <code>v2</code> is not important).</p>
</td></tr>
<tr><td><code id="dodgr_insert_vertex_+3A_x">x</code></td>
<td>
<p>The <code>x</code>-coordinate of new vertex. If not specified, vertex is
created half-way between <code>v1</code> and <code>v2</code>.</p>
</td></tr>
<tr><td><code id="dodgr_insert_vertex_+3A_y">y</code></td>
<td>
<p>The <code>y</code>-coordinate of new vertex. If not specified, vertex is
created half-way between <code>v1</code> and <code>v2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified graph with specified edge between defined start and end
vertices split into two edges either side of new vertex.
</p>


<h3>See Also</h3>

<p>Other misc: 
<code><a href="#topic+compare_heaps">compare_heaps</a>()</code>,
<code><a href="#topic+dodgr_flowmap">dodgr_flowmap</a>()</code>,
<code><a href="#topic+dodgr_full_cycles">dodgr_full_cycles</a>()</code>,
<code><a href="#topic+dodgr_fundamental_cycles">dodgr_fundamental_cycles</a>()</code>,
<code><a href="#topic+dodgr_sample">dodgr_sample</a>()</code>,
<code><a href="#topic+dodgr_sflines_to_poly">dodgr_sflines_to_poly</a>()</code>,
<code><a href="#topic+dodgr_vertices">dodgr_vertices</a>()</code>,
<code><a href="#topic+merge_directed_graph">merge_directed_graph</a>()</code>,
<code><a href="#topic+summary.dodgr_dists_categorical">summary.dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
e1 &lt;- sample (nrow (graph), 1)
v1 &lt;- graph$from_id [e1]
v2 &lt;- graph$to_id [e1]
# insert new vertex in the middle of that randomly-selected edge:
graph2 &lt;- dodgr_insert_vertex (graph, v1, v2)
nrow (graph)
nrow (graph2) # new edges added to graph2
</code></pre>

<hr>
<h2 id='dodgr_isochrones'>Calculate isochrone contours from specified points.</h2><span id='topic+dodgr_isochrones'></span>

<h3>Description</h3>

<p>Function is fully vectorized to calculate accept vectors of central points
and vectors defining multiple isochrone thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_isochrones(graph, from = NULL, tlim = NULL, heap = "BHeap")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_isochrones_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the network
graph (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_isochrones_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which isochrones are to
be calculated.</p>
</td></tr>
<tr><td><code id="dodgr_isochrones_+3A_tlim">tlim</code></td>
<td>
<p>Vector of desired limits of isochrones in seconds</p>
</td></tr>
<tr><td><code id="dodgr_isochrones_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
Trinomial Heap (<code>TriHeap</code>), Extended Trinomial Heap
(<code>TriHeapExt</code>, and 2-3 Heap (<code>Heap23</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>data.frame</code> of isochrones as points sorted anticlockwise
around each origin (<code>from</code>) point, with columns denoting the <code>from</code> points
and <code>tlim</code> value(s). The isochrones are given as <code>id</code> values and associated
coordinates of the series of points from each <code>from</code> point at the specified
isochrone times.
</p>
<p>Isochrones are calculated by default using parallel computation with the
maximal number of available cores or threads. This number can be reduced by
specifying a value via <code style="white-space: pre;">&#8288;RcppParallel::setThreadOptions (numThreads = &lt;desired_number&gt;)&#8288;</code>.
</p>


<h3>Note</h3>

<p>Isodists are calculated by default using parallel computation with the
maximal number of available cores or threads. This number can be reduced by
specifying a value via
<code style="white-space: pre;">&#8288;RcppParallel::setThreadOptions (numThreads = &lt;desired_number&gt;)&#8288;</code>.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_distances">dodgr_distances</a>()</code>,
<code><a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+dodgr_dists_nearest">dodgr_dists_nearest</a>()</code>,
<code><a href="#topic+dodgr_dists">dodgr_dists</a>()</code>,
<code><a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>()</code>,
<code><a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>()</code>,
<code><a href="#topic+dodgr_flows_si">dodgr_flows_si</a>()</code>,
<code><a href="#topic+dodgr_isodists">dodgr_isodists</a>()</code>,
<code><a href="#topic+dodgr_isoverts">dodgr_isoverts</a>()</code>,
<code><a href="#topic+dodgr_paths">dodgr_paths</a>()</code>,
<code><a href="#topic+dodgr_times">dodgr_times</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use osmdata package to extract 'SC'-format data:
library (osmdata)
dat &lt;- opq ("hampi india") %&gt;%
    add_osm_feature (key = "highway") %&gt;%
    osmdata_sc ()
graph &lt;- weight_streetnet (dat)
from &lt;- sample (graph$.vx0, size = 100)
tlim &lt;- c (5, 10, 20, 30, 60) * 60 # times in seconds
x &lt;- dodgr_isochrones (graph, from = from, tlim)

## End(Not run)
</code></pre>

<hr>
<h2 id='dodgr_isodists'>Calculate isodistance contours from specified points.</h2><span id='topic+dodgr_isodists'></span>

<h3>Description</h3>

<p>Function is fully vectorized to calculate accept vectors of central points
and vectors defining multiple isodistances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_isodists(
  graph,
  from = NULL,
  dlim = NULL,
  contract = TRUE,
  heap = "BHeap"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_isodists_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the network
graph (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_isodists_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which isodistances are to
be calculated.</p>
</td></tr>
<tr><td><code id="dodgr_isodists_+3A_dlim">dlim</code></td>
<td>
<p>Vector of desired limits of isodistances in metres.</p>
</td></tr>
<tr><td><code id="dodgr_isodists_+3A_contract">contract</code></td>
<td>
<p>If <code>TRUE</code>, calculate isodists only to vertices in the
contract graph, in other words, only to junction vertices.</p>
</td></tr>
<tr><td><code id="dodgr_isodists_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
Trinomial Heap (<code>TriHeap</code>), Extended Trinomial Heap
(<code>TriHeapExt</code>, and 2-3 Heap (<code>Heap23</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>data.frame</code> of isodistances as points sorted anticlockwise
around each origin (<code>from</code>) point, with columns denoting the <code>from</code> points
and <code>dlim</code> value(s). The isodistance contours are given as <code>id</code> values and
associated coordinates of the series of points from each <code>from</code> point at the
specified isodistances.
</p>


<h3>Note</h3>

<p>Isodists are calculated by default using parallel computation with the
maximal number of available cores or threads. This number can be reduced by
specifying a value via
<code style="white-space: pre;">&#8288;RcppParallel::setThreadOptions (numThreads = &lt;desired_number&gt;)&#8288;</code>.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_distances">dodgr_distances</a>()</code>,
<code><a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+dodgr_dists_nearest">dodgr_dists_nearest</a>()</code>,
<code><a href="#topic+dodgr_dists">dodgr_dists</a>()</code>,
<code><a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>()</code>,
<code><a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>()</code>,
<code><a href="#topic+dodgr_flows_si">dodgr_flows_si</a>()</code>,
<code><a href="#topic+dodgr_isochrones">dodgr_isochrones</a>()</code>,
<code><a href="#topic+dodgr_isoverts">dodgr_isoverts</a>()</code>,
<code><a href="#topic+dodgr_paths">dodgr_paths</a>()</code>,
<code><a href="#topic+dodgr_times">dodgr_times</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
from &lt;- sample (graph$from_id, size = 100)
dlim &lt;- c (1, 2, 5, 10, 20) * 100
d &lt;- dodgr_isodists (graph, from = from, dlim)
</code></pre>

<hr>
<h2 id='dodgr_isoverts'>Calculate isodistance or isochrone contours from specified points.</h2><span id='topic+dodgr_isoverts'></span>

<h3>Description</h3>

<p>Returns lists of all network vertices contained within the contours. Function
is fully vectorized to calculate accept vectors of central points and vectors
defining multiple isochrone thresholds. Provide one or more <code>dlim</code> values for
isodistances, or one or more <code>tlim</code> values for isochrones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_isoverts(graph, from = NULL, dlim = NULL, tlim = NULL, heap = "BHeap")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_isoverts_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the network
graph (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_isoverts_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which isodistances or
isochrones are to be calculated.</p>
</td></tr>
<tr><td><code id="dodgr_isoverts_+3A_dlim">dlim</code></td>
<td>
<p>Vector of desired limits of isodistances in metres.</p>
</td></tr>
<tr><td><code id="dodgr_isoverts_+3A_tlim">tlim</code></td>
<td>
<p>Vector of desired limits of isochrones in seconds</p>
</td></tr>
<tr><td><code id="dodgr_isoverts_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
Trinomial Heap (<code>TriHeap</code>), Extended Trinomial Heap
(<code>TriHeapExt</code>, and 2-3 Heap (<code>Heap23</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>data.frame</code> of vertex IDs, with columns denoting the <code>from</code>
points and <code>tlim</code> value(s). The isochrones are given as <code>id</code> values and
associated coordinates of the series of points from each <code>from</code> point at the
specified isochrone times.
</p>
<p>Isoverts are calculated by default using parallel computation with the
maximal number of available cores or threads. This number can be reduced by
specifying a value via <code style="white-space: pre;">&#8288;RcppParallel::setThreadOptions (numThreads = &lt;desired_number&gt;)&#8288;</code>.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_distances">dodgr_distances</a>()</code>,
<code><a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+dodgr_dists_nearest">dodgr_dists_nearest</a>()</code>,
<code><a href="#topic+dodgr_dists">dodgr_dists</a>()</code>,
<code><a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>()</code>,
<code><a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>()</code>,
<code><a href="#topic+dodgr_flows_si">dodgr_flows_si</a>()</code>,
<code><a href="#topic+dodgr_isochrones">dodgr_isochrones</a>()</code>,
<code><a href="#topic+dodgr_isodists">dodgr_isodists</a>()</code>,
<code><a href="#topic+dodgr_paths">dodgr_paths</a>()</code>,
<code><a href="#topic+dodgr_times">dodgr_times</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use osmdata package to extract 'SC'-format data:
library (osmdata)
dat &lt;- opq ("hampi india") %&gt;%
    add_osm_feature (key = "highway") %&gt;%
    osmdata_sc ()
graph &lt;- weight_streetnet (dat)
from &lt;- sample (graph$.vx0, size = 100)
tlim &lt;- c (5, 10, 20, 30, 60) * 60 # times in seconds
x &lt;- dodgr_isoverts (graph, from = from, tlim)

## End(Not run)
</code></pre>

<hr>
<h2 id='dodgr_load_streetnet'>Load a street network previously saved with <a href="#topic+dodgr_save_streetnet">dodgr_save_streetnet</a>.</h2><span id='topic+dodgr_load_streetnet'></span>

<h3>Description</h3>

<p>This always returns the full, non-contracted graph. The contracted graph can
be generated by passing the result to <a href="#topic+dodgr_contract_graph">dodgr_contract_graph</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_load_streetnet(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_load_streetnet_+3A_filename">filename</code></td>
<td>
<p>Name (with optional full path) of file to be loaded.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cache: 
<code><a href="#topic+clear_dodgr_cache">clear_dodgr_cache</a>()</code>,
<code><a href="#topic+dodgr_cache_off">dodgr_cache_off</a>()</code>,
<code><a href="#topic+dodgr_cache_on">dodgr_cache_on</a>()</code>,
<code><a href="#topic+dodgr_save_streetnet">dodgr_save_streetnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- weight_streetnet (hampi)
f &lt;- file.path (tempdir (), "streetnet.Rds")
dodgr_save_streetnet (net, f)
clear_dodgr_cache () # rm cached objects from tempdir
# at some later time, or in a new R session:
net &lt;- dodgr_load_streetnet (f)
</code></pre>

<hr>
<h2 id='dodgr_paths'>Calculate lists of pair-wise shortest paths between points.</h2><span id='topic+dodgr_paths'></span>

<h3>Description</h3>

<p>Calculate lists of pair-wise shortest paths between points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_paths(
  graph,
  from,
  to,
  vertices = TRUE,
  pairwise = FALSE,
  heap = "BHeap",
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_paths_+3A_graph">graph</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the network
graph (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_paths_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which route paths are to
be calculated (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_paths_+3A_to">to</code></td>
<td>
<p>Vector or matrix of points <strong>to</strong> which route paths are to be
calculated (see Details)</p>
</td></tr>
<tr><td><code id="dodgr_paths_+3A_vertices">vertices</code></td>
<td>
<p>If <code>TRUE</code>, return lists of lists of vertices for each
path, otherwise return corresponding lists of edge numbers from <code>graph</code>.</p>
</td></tr>
<tr><td><code id="dodgr_paths_+3A_pairwise">pairwise</code></td>
<td>
<p>If <code>TRUE</code>, calculate paths only between the ordered
pairs of <code>from</code> and <code>to</code>. In this case, each of these must be the
same length, and the output will contain paths the i-th members of each, and
thus also be of that length.</p>
</td></tr>
<tr><td><code id="dodgr_paths_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
<code>Radix</code>, Trinomial Heap (<code>TriHeap</code>), Extended Trinomial Heap
(<code>TriHeapExt</code>, and 2-3 Heap (<code>Heap23</code>).</p>
</td></tr>
<tr><td><code id="dodgr_paths_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, display progress messages on screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of list of paths tracing all connections between nodes such that
if <code>x &lt;- dodgr_paths (graph, from, to)</code>, then the path between
<code>from[i]</code> and <code>to[j]</code> is <code>x [[i]] [[j]]</code>.
</p>


<h3>Note</h3>

<p><code>graph</code> must minimally contain four columns of <code>from</code>,
<code>to</code>, <code>dist</code>. If an additional column named <code>weight</code> or
<code>wt</code> is present, shortest paths are calculated according to values
specified in that column; otherwise according to <code>dist</code> values. Either
way, final distances between <code>from</code> and <code>to</code> points are calculated
according to values of <code>dist</code>. That is, paths between any pair of points
will be calculated according to the minimal total sum of <code>weight</code>
values (if present), while reported distances will be total sums of
<code>dist</code> values.
</p>
<p>The <code>from</code> and <code>to</code> columns of <code>graph</code> may be either single
columns of numeric or character values specifying the numbers or names of
graph vertices, or combinations to two columns specifying geographical
(longitude and latitude) coordinates. In the latter case, almost any sensible
combination of names will be accepted (for example, <code style="white-space: pre;">&#8288;fromx, fromy&#8288;</code>,
<code style="white-space: pre;">&#8288;from_x, from_y&#8288;</code>, or <code style="white-space: pre;">&#8288;fr_lat, fr_lon&#8288;</code>.)
</p>
<p><code>from</code> and <code>to</code> values can be either two-column matrices of
equivalent of longitude and latitude coordinates, or else single columns
precisely matching node numbers or names given in <code>graph$from</code> or
<code>graph$to</code>. If <code>to</code> is missing, pairwise distances are calculated
between all points specified in <code>from</code>. If neither <code>from</code> nor
<code>to</code> are specified, pairwise distances are calculated between all nodes
in <code>graph</code>.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_distances">dodgr_distances</a>()</code>,
<code><a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+dodgr_dists_nearest">dodgr_dists_nearest</a>()</code>,
<code><a href="#topic+dodgr_dists">dodgr_dists</a>()</code>,
<code><a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>()</code>,
<code><a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>()</code>,
<code><a href="#topic+dodgr_flows_si">dodgr_flows_si</a>()</code>,
<code><a href="#topic+dodgr_isochrones">dodgr_isochrones</a>()</code>,
<code><a href="#topic+dodgr_isodists">dodgr_isodists</a>()</code>,
<code><a href="#topic+dodgr_isoverts">dodgr_isoverts</a>()</code>,
<code><a href="#topic+dodgr_times">dodgr_times</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
from &lt;- sample (graph$from_id, size = 100)
to &lt;- sample (graph$to_id, size = 50)
dp &lt;- dodgr_paths (graph, from = from, to = to)
# dp is a list with 100 items, and each of those 100 items has 30 items, each
# of which is a single path listing all vertiex IDs as taken from `graph`.

# it is also possible to calculate paths between pairwise start and end
# points
from &lt;- sample (graph$from_id, size = 5)
to &lt;- sample (graph$to_id, size = 5)
dp &lt;- dodgr_paths (graph, from = from, to = to, pairwise = TRUE)
# dp is a list of 5 items, each of which just has a single path between each
# pairwise from and to point.
</code></pre>

<hr>
<h2 id='dodgr_sample'>Sample a random but connected sub-component of a graph</h2><span id='topic+dodgr_sample'></span>

<h3>Description</h3>

<p>Sample a random but connected sub-component of a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_sample(graph, nverts = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_sample_+3A_graph">graph</code></td>
<td>
<p>A flat table of graph edges. Must contain columns labelled
<code>from</code> and <code>to</code>, or <code>start</code> and <code>stop</code>. May also contain
similarly labelled columns of spatial coordinates (for example
<code>from_x</code>) or <code>stop_lon</code>).</p>
</td></tr>
<tr><td><code id="dodgr_sample_+3A_nverts">nverts</code></td>
<td>
<p>Number of vertices to sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A connected sub-component of <code>graph</code>
</p>


<h3>Note</h3>

<p>Graphs may occasionally have <code>nverts + 1</code> vertices, rather than
the requested <code>nverts</code>.
</p>


<h3>See Also</h3>

<p>Other misc: 
<code><a href="#topic+compare_heaps">compare_heaps</a>()</code>,
<code><a href="#topic+dodgr_flowmap">dodgr_flowmap</a>()</code>,
<code><a href="#topic+dodgr_full_cycles">dodgr_full_cycles</a>()</code>,
<code><a href="#topic+dodgr_fundamental_cycles">dodgr_fundamental_cycles</a>()</code>,
<code><a href="#topic+dodgr_insert_vertex">dodgr_insert_vertex</a>()</code>,
<code><a href="#topic+dodgr_sflines_to_poly">dodgr_sflines_to_poly</a>()</code>,
<code><a href="#topic+dodgr_vertices">dodgr_vertices</a>()</code>,
<code><a href="#topic+merge_directed_graph">merge_directed_graph</a>()</code>,
<code><a href="#topic+summary.dodgr_dists_categorical">summary.dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
nrow (graph) # 5,742
graph &lt;- dodgr_sample (graph, nverts = 200)
nrow (graph) # generally around 400 edges
nrow (dodgr_vertices (graph)) # 200
</code></pre>

<hr>
<h2 id='dodgr_save_streetnet'>Save a weighted streetnet to a local file</h2><span id='topic+dodgr_save_streetnet'></span>

<h3>Description</h3>

<p>The <a href="#topic+weight_streetnet">weight_streetnet</a> function returns a single <code>data.frame</code> object,
the processing of which also relies on a couple of cached lookup-tables to
match edges in the <code>data.frame</code> to objects in the original input data. It
automatically calculates and caches a contracted version of the same graph,
to enable rapid conversion between contracted and uncontracted forms. This
function saves all of these items in a single <code>.Rds</code> file, so that a the
result of a linkweight_streetnet call can be rapidly loaded into a
workspace in subsequent sessions, rather than re-calculating the entire
weighted network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_save_streetnet(net, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_save_streetnet_+3A_net">net</code></td>
<td>
<p><code>data.frame</code> or equivalent object representing the weighted
network graph.</p>
</td></tr>
<tr><td><code id="dodgr_save_streetnet_+3A_filename">filename</code></td>
<td>
<p>Name with optional full path of file in which to save the
input <code>net</code>. The extension <code>.Rds</code> will be automatically appended, unless
specified otherwise.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This may take some time if <a href="#topic+dodgr_cache_off">dodgr_cache_off</a> has been called.
The contracted version of the graph is also saved, and so must be calculated
if it has not previously been automatically cached.
</p>


<h3>See Also</h3>

<p>Other cache: 
<code><a href="#topic+clear_dodgr_cache">clear_dodgr_cache</a>()</code>,
<code><a href="#topic+dodgr_cache_off">dodgr_cache_off</a>()</code>,
<code><a href="#topic+dodgr_cache_on">dodgr_cache_on</a>()</code>,
<code><a href="#topic+dodgr_load_streetnet">dodgr_load_streetnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- weight_streetnet (hampi)
f &lt;- file.path (tempdir (), "streetnet.Rds")
dodgr_save_streetnet (net, f)
clear_dodgr_cache () # rm cached objects from tempdir
# at some later time, or in a new R session:
net &lt;- dodgr_load_streetnet (f)
</code></pre>

<hr>
<h2 id='dodgr_sflines_to_poly'>Convert <span class="pkg">sf</span> <code>LINESTRING</code> objects to <code>POLYGON</code> objects representing all
fundamental cycles within the <code>LINESTRING</code> objects.</h2><span id='topic+dodgr_sflines_to_poly'></span>

<h3>Description</h3>

<p>Convert <span class="pkg">sf</span> <code>LINESTRING</code> objects to <code>POLYGON</code> objects representing all
fundamental cycles within the <code>LINESTRING</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_sflines_to_poly(sflines, graph_max_size = 10000, expand = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_sflines_to_poly_+3A_sflines">sflines</code></td>
<td>
<p>An <span class="pkg">sf</span> <code>LINESTRING</code> object representing a network.</p>
</td></tr>
<tr><td><code id="dodgr_sflines_to_poly_+3A_graph_max_size">graph_max_size</code></td>
<td>
<p>Maximum size submitted to the internal C++ routines as
a single chunk. Warning: Increasing this may lead to computer meltdown!</p>
</td></tr>
<tr><td><code id="dodgr_sflines_to_poly_+3A_expand">expand</code></td>
<td>
<p>For large graphs which must be broken into chunks, this factor
determines the relative overlap between chunks to ensure all cycles are
captured. (This value should only need to be modified in special cases.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf::sfc</code> collection of <code>POLYGON</code> objects.
</p>


<h3>See Also</h3>

<p>Other misc: 
<code><a href="#topic+compare_heaps">compare_heaps</a>()</code>,
<code><a href="#topic+dodgr_flowmap">dodgr_flowmap</a>()</code>,
<code><a href="#topic+dodgr_full_cycles">dodgr_full_cycles</a>()</code>,
<code><a href="#topic+dodgr_fundamental_cycles">dodgr_fundamental_cycles</a>()</code>,
<code><a href="#topic+dodgr_insert_vertex">dodgr_insert_vertex</a>()</code>,
<code><a href="#topic+dodgr_sample">dodgr_sample</a>()</code>,
<code><a href="#topic+dodgr_vertices">dodgr_vertices</a>()</code>,
<code><a href="#topic+merge_directed_graph">merge_directed_graph</a>()</code>,
<code><a href="#topic+summary.dodgr_dists_categorical">summary.dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>()</code>
</p>

<hr>
<h2 id='dodgr_streetnet'>Extract a street network in <span class="pkg">sf</span>-format for a given location.</h2><span id='topic+dodgr_streetnet'></span>

<h3>Description</h3>

<p>Use the <code>osmdata</code> package to extract the street network for a given
location. For routing between a given set of points (passed as <code>pts</code>),
the <code>bbox</code> argument may be omitted, in which case a bounding box will
be constructed by expanding the range of <code>pts</code> by the relative amount of
<code>expand</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_streetnet(bbox, pts = NULL, expand = 0.05, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_streetnet_+3A_bbox">bbox</code></td>
<td>
<p>Bounding box as vector or matrix of coordinates, or location
name. Passed to <code>osmdata::getbb</code>.</p>
</td></tr>
<tr><td><code id="dodgr_streetnet_+3A_pts">pts</code></td>
<td>
<p>List of points presumably containing spatial coordinates</p>
</td></tr>
<tr><td><code id="dodgr_streetnet_+3A_expand">expand</code></td>
<td>
<p>Relative factor by which street network should extend beyond
limits defined by pts (only if <code>bbox</code> not given).</p>
</td></tr>
<tr><td><code id="dodgr_streetnet_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, display progress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Simple Features (<code>sf</code>) object with coordinates of all lines in
the street network.
</p>


<h3>Note</h3>

<p>Calls to this function may return &quot;General overpass server error&quot; with
a note that &quot;Query timed out.&quot; The overpass served used to access the data
has a sophisticated queueing system which prioritises requests that are
likely to require little time. These timeout errors can thus generally <em>not</em>
be circumvented by changing &quot;timeout&quot; options on the HTTP requests, and
should rather be interpreted to indicate that a request is too large, and may
need to be refined, or somehow broken up into smaller queries.
</p>


<h3>See Also</h3>

<p>Other extraction: 
<code><a href="#topic+dodgr_streetnet_sc">dodgr_streetnet_sc</a>()</code>,
<code><a href="#topic+weight_railway">weight_railway</a>()</code>,
<code><a href="#topic+weight_streetnet">weight_streetnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
streetnet &lt;- dodgr_streetnet ("hampi india", expand = 0)
# convert to form needed for `dodgr` functions:
graph &lt;- weight_streetnet (streetnet)
nrow (graph) # around 5,900 edges
# Alternative ways of extracting street networks by using a small selection
# of graph vertices to define bounding box:
verts &lt;- dodgr_vertices (graph)
verts &lt;- verts [sample (nrow (verts), size = 200), ]
streetnet &lt;- dodgr_streetnet (pts = verts, expand = 0)
graph &lt;- weight_streetnet (streetnet)
nrow (graph)
# This will generally have many more rows because most street networks
# include streets that extend considerably beyond the specified bounding box.

# bbox can also be a polygon:
bb &lt;- osmdata::getbb ("gent belgium") # rectangular bbox
nrow (dodgr_streetnet (bbox = bb)) # around 30,000
bb &lt;- osmdata::getbb ("gent belgium", format_out = "polygon")
nrow (dodgr_streetnet (bbox = bb)) # around 17,000
# The latter has fewer rows because only edges within polygon are returned

# Example with access restrictions
bbox &lt;- c (-122.2935, 47.62663, -122.28, 47.63289)
x &lt;- dodgr_streetnet_sc (bbox)
net &lt;- weight_streetnet (x, keep_cols = "access", turn_penalty = TRUE)
# has many streets with "access" = "private"; these can be removed like this:
net2 &lt;- net [which (!net$access != "private"), ]
# or modified in some other way such as strongly penalizing use of those
# streets:
index &lt;- which (net$access == "private")
net$time_weighted [index] &lt;- net$time_weighted [index] * 100

## End(Not run)
</code></pre>

<hr>
<h2 id='dodgr_streetnet_sc'>Extract a street network in <span class="pkg">silicate</span>-format for a given location.</h2><span id='topic+dodgr_streetnet_sc'></span>

<h3>Description</h3>

<p>Use the <code>osmdata</code> package to extract the street network for a given
location and return it in <code>SC</code>-format. For routing between a given set of
points (passed as <code>pts</code>), the <code>bbox</code> argument may be omitted, in which case a
bounding box will be constructed by expanding the range of <code>pts</code> by the
relative amount of <code>expand</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_streetnet_sc(bbox, pts = NULL, expand = 0.05, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_streetnet_sc_+3A_bbox">bbox</code></td>
<td>
<p>Bounding box as vector or matrix of coordinates, or location
name. Passed to <code>osmdata::getbb</code>.</p>
</td></tr>
<tr><td><code id="dodgr_streetnet_sc_+3A_pts">pts</code></td>
<td>
<p>List of points presumably containing spatial coordinates</p>
</td></tr>
<tr><td><code id="dodgr_streetnet_sc_+3A_expand">expand</code></td>
<td>
<p>Relative factor by which street network should extend beyond
limits defined by pts (only if <code>bbox</code> not given).</p>
</td></tr>
<tr><td><code id="dodgr_streetnet_sc_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, display progress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Simple Features (<code>sf</code>) object with coordinates of all lines in
the street network.
</p>


<h3>Note</h3>

<p>Calls to this function may return &quot;General overpass server error&quot; with
a note that &quot;Query timed out.&quot; The overpass served used to access the data
has a sophisticated queueing system which prioritises requests that are
likely to require little time. These timeout errors can thus generally <em>not</em>
be circumvented by changing &quot;timeout&quot; options on the HTTP requests, and
should rather be interpreted to indicate that a request is too large, and may
need to be refined, or somehow broken up into smaller queries.
</p>


<h3>See Also</h3>

<p>Other extraction: 
<code><a href="#topic+dodgr_streetnet">dodgr_streetnet</a>()</code>,
<code><a href="#topic+weight_railway">weight_railway</a>()</code>,
<code><a href="#topic+weight_streetnet">weight_streetnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
streetnet &lt;- dodgr_streetnet ("hampi india", expand = 0)
# convert to form needed for `dodgr` functions:
graph &lt;- weight_streetnet (streetnet)
nrow (graph) # around 5,900 edges
# Alternative ways of extracting street networks by using a small selection
# of graph vertices to define bounding box:
verts &lt;- dodgr_vertices (graph)
verts &lt;- verts [sample (nrow (verts), size = 200), ]
streetnet &lt;- dodgr_streetnet (pts = verts, expand = 0)
graph &lt;- weight_streetnet (streetnet)
nrow (graph)
# This will generally have many more rows because most street networks
# include streets that extend considerably beyond the specified bounding box.

# bbox can also be a polygon:
bb &lt;- osmdata::getbb ("gent belgium") # rectangular bbox
nrow (dodgr_streetnet (bbox = bb)) # around 30,000
bb &lt;- osmdata::getbb ("gent belgium", format_out = "polygon")
nrow (dodgr_streetnet (bbox = bb)) # around 17,000
# The latter has fewer rows because only edges within polygon are returned

# Example with access restrictions
bbox &lt;- c (-122.2935, 47.62663, -122.28, 47.63289)
x &lt;- dodgr_streetnet_sc (bbox)
net &lt;- weight_streetnet (x, keep_cols = "access", turn_penalty = TRUE)
# has many streets with "access" = "private"; these can be removed like this:
net2 &lt;- net [which (!net$access != "private"), ]
# or modified in some other way such as strongly penalizing use of those
# streets:
index &lt;- which (net$access == "private")
net$time_weighted [index] &lt;- net$time_weighted [index] * 100

## End(Not run)
</code></pre>

<hr>
<h2 id='dodgr_times'>Calculate matrix of pair-wise travel times between points.</h2><span id='topic+dodgr_times'></span>

<h3>Description</h3>

<p>Calculate matrix of pair-wise travel times between points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_times(graph, from = NULL, to = NULL, shortest = FALSE, heap = "BHeap")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_times_+3A_graph">graph</code></td>
<td>
<p>A <code>dodgr</code> network returned from the <a href="#topic+weight_streetnet">weight_streetnet</a>
function using a network obtained with the <span class="pkg">osmdata</span> <code>osmdata_sc</code>
function, possibly contracted with <a href="#topic+dodgr_contract_graph">dodgr_contract_graph</a>.</p>
</td></tr>
<tr><td><code id="dodgr_times_+3A_from">from</code></td>
<td>
<p>Vector or matrix of points <strong>from</strong> which route distances are to
be calculated (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_times_+3A_to">to</code></td>
<td>
<p>Vector or matrix of points <strong>to</strong> which route distances are to be
calculated (see Notes)</p>
</td></tr>
<tr><td><code id="dodgr_times_+3A_shortest">shortest</code></td>
<td>
<p>If <code>TRUE</code>, calculate times along the <em>shortest</em> rather
than fastest paths.</p>
</td></tr>
<tr><td><code id="dodgr_times_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; <code>FHeap</code>), Binary Heap (<code>BHeap</code>),
<code style="white-space: pre;">&#8288;Trinomial Heap (&#8288;</code>TriHeap<code style="white-space: pre;">&#8288;), Extended Trinomial Heap (&#8288;</code>TriHeapExt<code style="white-space: pre;">&#8288;, and 2-3 Heap (&#8288;</code>Heap23').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>square matrix of distances between nodes
</p>


<h3>Note</h3>

<p><code>graph</code> must minimally contain three columns of <code>from</code>,
<code>to</code>, <code>dist</code>. If an additional column named <code>weight</code> or
<code>wt</code> is present, shortest paths are calculated according to values
specified in that column; otherwise according to <code>dist</code> values. Either
way, final distances between <code>from</code> and <code>to</code> points are calculated
by default according to values of <code>dist</code>. That is, paths between any pair of
points will be calculated according to the minimal total sum of <code>weight</code>
values (if present), while reported distances will be total sums of <code>dist</code>
values.
</p>
<p>For street networks produced with <a href="#topic+weight_streetnet">weight_streetnet</a>, distances may also
be calculated along the <em>fastest</em> routes with the <code>shortest = FALSE</code>
option. Graphs must in this case have columns of <code>time</code> and <code>time_weighted</code>.
Note that the fastest routes will only be approximate when derived from
<span class="pkg">sf</span>-format data generated with the <span class="pkg">osmdata</span> function
<code>osmdata_sf()</code>, and will be much more accurate when derived from <code>sc</code>-format
data generated with <code>osmdata_sc()</code>. See <a href="#topic+weight_streetnet">weight_streetnet</a> for details.
</p>
<p>The <code>from</code> and <code>to</code> columns of <code>graph</code> may be either single
columns of numeric or character values specifying the numbers or names of
graph vertices, or combinations to two columns specifying geographical
(longitude and latitude) coordinates. In the latter case, almost any sensible
combination of names will be accepted (for example, <code style="white-space: pre;">&#8288;fromx, fromy&#8288;</code>,
<code style="white-space: pre;">&#8288;from_x, from_y&#8288;</code>, or <code style="white-space: pre;">&#8288;fr_lat, fr_lon&#8288;</code>.)
</p>
<p><code>from</code> and <code>to</code> values can be either two-column matrices or
equivalent of longitude and latitude coordinates, or else single columns
precisely matching node numbers or names given in <code>graph$from</code> or
<code>graph$to</code>. If <code>to</code> is <code>NULL</code>, pairwise distances are calculated from all
<code>from</code> points to all other nodes in <code>graph</code>. If both <code>from</code> and <code>to</code> are
<code>NULL</code>, pairwise distances are calculated between all nodes in <code>graph</code>.
</p>
<p>Calculations in parallel (<code>parallel = TRUE</code>) ought very generally be
advantageous. For small graphs, calculating distances in parallel is likely
to offer relatively little gain in speed, but increases from parallel
computation will generally markedly increase with increasing graph sizes.
By default, parallel computation uses the maximal number of available cores
or threads. This number can be reduced by specifying a value via
<code style="white-space: pre;">&#8288;RcppParallel::setThreadOptions (numThreads = &lt;desired_number&gt;)&#8288;</code>. Parallel
calculations are, however, not able to be interrupted (for example, by
<code>Ctrl-C</code>), and can only be stopped by killing the R process.
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+dodgr_distances">dodgr_distances</a>()</code>,
<code><a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+dodgr_dists_nearest">dodgr_dists_nearest</a>()</code>,
<code><a href="#topic+dodgr_dists">dodgr_dists</a>()</code>,
<code><a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>()</code>,
<code><a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a>()</code>,
<code><a href="#topic+dodgr_flows_si">dodgr_flows_si</a>()</code>,
<code><a href="#topic+dodgr_isochrones">dodgr_isochrones</a>()</code>,
<code><a href="#topic+dodgr_isodists">dodgr_isodists</a>()</code>,
<code><a href="#topic+dodgr_isoverts">dodgr_isoverts</a>()</code>,
<code><a href="#topic+dodgr_paths">dodgr_paths</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple graph
graph &lt;- data.frame (
    from = c ("A", "B", "B", "B", "C", "C", "D", "D"),
    to = c ("B", "A", "C", "D", "B", "D", "C", "A"),
    d = c (1, 2, 1, 3, 2, 1, 2, 1)
)
dodgr_dists (graph)

# A larger example from the included [hampi()] data.
graph &lt;- weight_streetnet (hampi)
from &lt;- sample (graph$from_id, size = 100)
to &lt;- sample (graph$to_id, size = 50)
d &lt;- dodgr_dists (graph, from = from, to = to)
# d is a 100-by-50 matrix of distances between `from` and `to`

## Not run: 
# a more complex street network example, thanks to @chrijo; see
# https://github.com/ATFutures/dodgr/issues/47

xy &lt;- rbind (
    c (7.005994, 51.45774), # limbeckerplatz 1 essen germany
    c (7.012874, 51.45041)
) # hauptbahnhof essen germany
xy &lt;- data.frame (lon = xy [, 1], lat = xy [, 2])
essen &lt;- dodgr_streetnet (pts = xy, expand = 0.2, quiet = FALSE)
graph &lt;- weight_streetnet (essen, wt_profile = "foot")
d &lt;- dodgr_dists (graph, from = xy, to = xy)
# First reason why this does not work is because the graph has multiple,
# disconnected components.
table (graph$component)
# reduce to largest connected component, which is always number 1
graph &lt;- graph [which (graph$component == 1), ]
d &lt;- dodgr_dists (graph, from = xy, to = xy)
# should work, but even then note that
table (essen$level)
# There are parts of the network on different building levels (because of
# shopping malls and the like). These may or may not be connected, so it may
# be necessary to filter out particular levels
index &lt;- which (!(essen$level == "-1" | essen$level == "1")) # for example
library (sf) # needed for following sub-select operation
essen &lt;- essen [index, ]
graph &lt;- weight_streetnet (essen, wt_profile = "foot")
graph &lt;- graph [which (graph$component == 1), ]
d &lt;- dodgr_dists (graph, from = xy, to = xy)

## End(Not run)
</code></pre>

<hr>
<h2 id='dodgr_to_igraph'>Convert a <code>dodgr</code> graph to an <span class="pkg">igraph</span>.</h2><span id='topic+dodgr_to_igraph'></span>

<h3>Description</h3>

<p>Convert a <code>dodgr</code> graph to an <span class="pkg">igraph</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_to_igraph(graph, weight_column = "d")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_to_igraph_+3A_graph">graph</code></td>
<td>
<p>A <code>dodgr</code> graph</p>
</td></tr>
<tr><td><code id="dodgr_to_igraph_+3A_weight_column">weight_column</code></td>
<td>
<p>The column of the <code>dodgr</code> network to use as the edge
weights in the <code>igraph</code> representation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>igraph</code> equivalent of the input. Note that this will <em>not</em>
be a dual-weighted graph.
</p>


<h3>See Also</h3>

<p><a href="#topic+igraph_to_dodgr">igraph_to_dodgr</a>
</p>
<p>Other conversion: 
<code><a href="#topic+dodgr_deduplicate_graph">dodgr_deduplicate_graph</a>()</code>,
<code><a href="#topic+dodgr_to_sfc">dodgr_to_sfc</a>()</code>,
<code><a href="#topic+dodgr_to_sf">dodgr_to_sf</a>()</code>,
<code><a href="#topic+dodgr_to_tidygraph">dodgr_to_tidygraph</a>()</code>,
<code><a href="#topic+igraph_to_dodgr">igraph_to_dodgr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
graphi &lt;- dodgr_to_igraph (graph)
</code></pre>

<hr>
<h2 id='dodgr_to_sf'>Convert a <code>dodgr</code> graph into an equivalent <span class="pkg">sf</span> object.</h2><span id='topic+dodgr_to_sf'></span>

<h3>Description</h3>

<p>Works by aggregating edges into <code>LINESTRING</code> objects representing longest
sequences between all junction nodes. The resultant objects will generally
contain more <code>LINESTRING</code> objects than the original <span class="pkg">sf</span> object, because
the former will be bisected at every junction point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_to_sf(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_to_sf_+3A_graph">graph</code></td>
<td>
<p>A <code>dodgr</code> graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent object of class <span class="pkg">sf</span>.
</p>


<h3>Note</h3>

<p>Requires the <span class="pkg">sf</span> package to be installed.
</p>


<h3>See Also</h3>

<p>Other conversion: 
<code><a href="#topic+dodgr_deduplicate_graph">dodgr_deduplicate_graph</a>()</code>,
<code><a href="#topic+dodgr_to_igraph">dodgr_to_igraph</a>()</code>,
<code><a href="#topic+dodgr_to_sfc">dodgr_to_sfc</a>()</code>,
<code><a href="#topic+dodgr_to_tidygraph">dodgr_to_tidygraph</a>()</code>,
<code><a href="#topic+igraph_to_dodgr">igraph_to_dodgr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hw &lt;- weight_streetnet (hampi)
nrow (hw) # 5,729 edges
xy &lt;- dodgr_to_sf (hw)
dim (xy) # 764 edges; 14 attributes
</code></pre>

<hr>
<h2 id='dodgr_to_sfc'>Convert a <code>dodgr</code> graph into an equivalent <code>sf::sfc</code> object.</h2><span id='topic+dodgr_to_sfc'></span>

<h3>Description</h3>

<p>Convert a <code>dodgr</code> graph into a <code>list</code> composed of
two objects: <code>dat</code>, a <code>data.frame</code>; and
<code>geometry</code>, an <code>sfc</code> object from the (<span class="pkg">sf</span>) package.
Works by aggregating edges into <code>LINESTRING</code>
objects representing longest sequences between all junction nodes. The
resultant objects will generally contain more <code>LINESTRING</code> objects than
the original <span class="pkg">sf</span> object, because the former will be bisected at every
junction point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_to_sfc(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_to_sfc_+3A_graph">graph</code></td>
<td>
<p>A <code>dodgr</code> graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing (1) A <code>data.frame</code> of data associated with the
<code>sf</code> geometries; and (ii) A Simple Features Collection (<code>sfc</code>) list of
<code>LINESTRING</code> objects.
</p>


<h3>Note</h3>

<p>The output of this function corresponds to the edges obtained from
<code>dodgr_contract_graph</code>. This function does not require the <span class="pkg">sf</span> package
to be installed; the corresponding function that creates a full <span class="pkg">sf</span>
object - <a href="#topic+dodgr_to_sf">dodgr_to_sf</a> does requires <span class="pkg">sf</span> to be installed.
</p>


<h3>See Also</h3>

<p>Other conversion: 
<code><a href="#topic+dodgr_deduplicate_graph">dodgr_deduplicate_graph</a>()</code>,
<code><a href="#topic+dodgr_to_igraph">dodgr_to_igraph</a>()</code>,
<code><a href="#topic+dodgr_to_sf">dodgr_to_sf</a>()</code>,
<code><a href="#topic+dodgr_to_tidygraph">dodgr_to_tidygraph</a>()</code>,
<code><a href="#topic+igraph_to_dodgr">igraph_to_dodgr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hw &lt;- weight_streetnet (hampi)
nrow (hw)
xy &lt;- dodgr_to_sfc (hw)
dim (hw) # 5.845 edges
length (xy$geometry) # more linestrings aggregated from those edges
nrow (hampi) # than the 191 linestrings in original sf object
dim (xy$dat) # same number of rows as there are geometries
# The dodgr_to_sf function then just implements this final conversion:
# sf::st_sf (xy$dat, geometry = xy$geometry, crs = 4326)
</code></pre>

<hr>
<h2 id='dodgr_to_tidygraph'>Convert a <code>dodgr</code> graph to an <span class="pkg">tidygraph</span>.</h2><span id='topic+dodgr_to_tidygraph'></span>

<h3>Description</h3>

<p>Convert a <code>dodgr</code> graph to an <span class="pkg">tidygraph</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_to_tidygraph(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_to_tidygraph_+3A_graph">graph</code></td>
<td>
<p>A <code>dodgr</code> graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>tidygraph</code> equivalent of the input
</p>


<h3>See Also</h3>

<p>Other conversion: 
<code><a href="#topic+dodgr_deduplicate_graph">dodgr_deduplicate_graph</a>()</code>,
<code><a href="#topic+dodgr_to_igraph">dodgr_to_igraph</a>()</code>,
<code><a href="#topic+dodgr_to_sfc">dodgr_to_sfc</a>()</code>,
<code><a href="#topic+dodgr_to_sf">dodgr_to_sf</a>()</code>,
<code><a href="#topic+igraph_to_dodgr">igraph_to_dodgr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
grapht &lt;- dodgr_to_tidygraph (graph)
</code></pre>

<hr>
<h2 id='dodgr_uncontract_graph'>Re-expand a contracted graph.</h2><span id='topic+dodgr_uncontract_graph'></span>

<h3>Description</h3>

<p>Revert a contracted graph created with <a href="#topic+dodgr_contract_graph">dodgr_contract_graph</a> back to
the full, uncontracted version. This function is mostly used for the side
effect of mapping any new columns inserted on to the contracted graph back
on to the original graph, as demonstrated in the example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_uncontract_graph(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_uncontract_graph_+3A_graph">graph</code></td>
<td>
<p>A contracted graph created from <a href="#topic+dodgr_contract_graph">dodgr_contract_graph</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>data.frame</code> representing the equivalent original,
uncontracted graph.
</p>


<h3>See Also</h3>

<p>Other modification: 
<code><a href="#topic+dodgr_components">dodgr_components</a>()</code>,
<code><a href="#topic+dodgr_contract_graph">dodgr_contract_graph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph0 &lt;- weight_streetnet (hampi)
nrow (graph0) # 6,813
graph1 &lt;- dodgr_contract_graph (graph0)
nrow (graph1) # 760
graph2 &lt;- dodgr_uncontract_graph (graph1)
nrow (graph2) # 6,813

# Insert new data on to the contracted graph and uncontract it:
graph1$new_col &lt;- runif (nrow (graph1))
graph3 &lt;- dodgr_uncontract_graph (graph1)
# graph3 is then the uncontracted graph which includes "new_col" as well
dim (graph0)
dim (graph3)
</code></pre>

<hr>
<h2 id='dodgr_vertices'>Extract vertices of graph, including spatial coordinates if included.</h2><span id='topic+dodgr_vertices'></span>

<h3>Description</h3>

<p>Extract vertices of graph, including spatial coordinates if included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodgr_vertices(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodgr_vertices_+3A_graph">graph</code></td>
<td>
<p>A flat table of graph edges. Must contain columns labelled
<code>from</code> and <code>to</code>, or <code>start</code> and <code>stop</code>. May also contain
similarly labelled columns of spatial coordinates (for example
<code>from_x</code>) or <code>stop_lon</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of vertices with unique numbers (<code>n</code>).
</p>


<h3>Note</h3>

<p>Values of <code>n</code> are 0-indexed
</p>


<h3>See Also</h3>

<p>Other misc: 
<code><a href="#topic+compare_heaps">compare_heaps</a>()</code>,
<code><a href="#topic+dodgr_flowmap">dodgr_flowmap</a>()</code>,
<code><a href="#topic+dodgr_full_cycles">dodgr_full_cycles</a>()</code>,
<code><a href="#topic+dodgr_fundamental_cycles">dodgr_fundamental_cycles</a>()</code>,
<code><a href="#topic+dodgr_insert_vertex">dodgr_insert_vertex</a>()</code>,
<code><a href="#topic+dodgr_sample">dodgr_sample</a>()</code>,
<code><a href="#topic+dodgr_sflines_to_poly">dodgr_sflines_to_poly</a>()</code>,
<code><a href="#topic+merge_directed_graph">merge_directed_graph</a>()</code>,
<code><a href="#topic+summary.dodgr_dists_categorical">summary.dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
v &lt;- dodgr_vertices (graph)
</code></pre>

<hr>
<h2 id='estimate_centrality_threshold'>Estimate a value for the 'dist_threshold' parameter of the
<a href="#topic+dodgr_centrality">dodgr_centrality</a> function.</h2><span id='topic+estimate_centrality_threshold'></span>

<h3>Description</h3>

<p>Providing distance thresholds to this
function generally provides considerably speed gains, and results in
approximations of centrality. This function enables the determination of
values of 'dist_threshold' corresponding to specific degrees of accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_centrality_threshold(graph, tolerance = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_centrality_threshold_+3A_graph">graph</code></td>
<td>
<p>'data.frame' or equivalent object representing the network
graph (see Details)</p>
</td></tr>
<tr><td><code id="estimate_centrality_threshold_+3A_tolerance">tolerance</code></td>
<td>
<p>Desired maximal degree of inaccuracy in centrality estimates
</p>

<ul>
<li><p> values will be accurate to within this amount, subject to a constant
scaling factor. Note that threshold values increase non-linearly with
decreasing values of 'tolerance'
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value for 'dist_threshold' giving the required tolerance.
</p>


<h3>Note</h3>

<p>This function may take some time to execute. While running, it displays
ongoing information on screen of estimated values of 'dist_threshold' and
associated errors. Thresholds are progressively increased until the error is
reduced below the specified tolerance.
</p>


<h3>See Also</h3>

<p>Other centrality: 
<code><a href="#topic+dodgr_centrality">dodgr_centrality</a>()</code>,
<code><a href="#topic+estimate_centrality_time">estimate_centrality_time</a>()</code>
</p>

<hr>
<h2 id='estimate_centrality_time'>Estimate time required for a planned centrality calculation.</h2><span id='topic+estimate_centrality_time'></span>

<h3>Description</h3>

<p>The 'dodgr' centrality functions are designed to be applied to potentially
very large graphs, and may take considerable time to execute. This helper
function estimates how long a centrality function may take for a given graph
and given value of 'dist_threshold' estimated via the
<a href="#topic+estimate_centrality_threshold">estimate_centrality_threshold</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_centrality_time(
  graph,
  contract = TRUE,
  edges = TRUE,
  dist_threshold = NULL,
  heap = "BHeap"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_centrality_time_+3A_graph">graph</code></td>
<td>
<p>'data.frame' or equivalent object representing the network
graph (see Details)</p>
</td></tr>
<tr><td><code id="estimate_centrality_time_+3A_contract">contract</code></td>
<td>
<p>If 'TRUE', centrality is calculated on contracted graph
before mapping back on to the original full graph. Note that for street
networks, in particular those obtained from the <span class="pkg">osmdata</span> package, vertex
placement is effectively arbitrary except at junctions; centrality for such
graphs should only be calculated between the latter points, and thus
'contract' should always be 'TRUE'.</p>
</td></tr>
<tr><td><code id="estimate_centrality_time_+3A_edges">edges</code></td>
<td>
<p>If 'TRUE', centrality is calculated for graph edges, returning
the input 'graph' with an additional 'centrality' column; otherwise
centrality is calculated for vertices, returning the equivalent of
'dodgr_vertices(graph)', with an additional vertex-based 'centrality' column.</p>
</td></tr>
<tr><td><code id="estimate_centrality_time_+3A_dist_threshold">dist_threshold</code></td>
<td>
<p>If not 'NULL', only calculate centrality for each point
out to specified threshold. Setting values for this will result in
approximate estimates for centrality, yet with considerable gains in
computational efficiency. For sufficiently large values, approximations will
be accurate to within some constant multiplier. Appropriate values can be
established via the <a href="#topic+estimate_centrality_threshold">estimate_centrality_threshold</a> function.</p>
</td></tr>
<tr><td><code id="estimate_centrality_time_+3A_heap">heap</code></td>
<td>
<p>Type of heap to use in priority queue. Options include
Fibonacci Heap (default; 'FHeap'), Binary Heap ('BHeap'),
Trinomial Heap ('TriHeap'), Extended Trinomial Heap
('TriHeapExt', and 2-3 Heap ('Heap23').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimated calculation time for calculating centrality for the
given value of 'dist_threshold'
</p>


<h3>Note</h3>

<p>This function may take some time to execute. While running, it displays
ongoing information on screen of estimated values of 'dist_threshold' and
associated errors. Thresholds are progressively increased until the error is
reduced below the specified tolerance.
</p>


<h3>See Also</h3>

<p>Other centrality: 
<code><a href="#topic+dodgr_centrality">dodgr_centrality</a>()</code>,
<code><a href="#topic+estimate_centrality_threshold">estimate_centrality_threshold</a>()</code>
</p>

<hr>
<h2 id='hampi'>Sample street network from Hampi, India.</h2><span id='topic+hampi'></span>

<h3>Description</h3>

<p>A sample street network from the township of Hampi, Karnataka, India.
</p>


<h3>Format</h3>

<p>A Simple Features <code>sf</code> <code>data.frame</code> containing the street
network of Hampi.
</p>


<h3>Note</h3>

<p>Can be re-created with the following command, which also removes
extraneous columns to reduce size:
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+os_roads_bristol">os_roads_bristol</a></code>,
<code><a href="#topic+weighting_profiles">weighting_profiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
hampi &lt;- dodgr_streetnet ("hampi india")
cols &lt;- c ("osm_id", "highway", "oneway", "geometry")
hampi &lt;- hampi [, which (names (hampi) %in% cols)]

## End(Not run)
# this 'sf data.frame' can be converted to a 'dodgr' network with
net &lt;- weight_streetnet (hampi, wt_profile = "foot")
</code></pre>

<hr>
<h2 id='igraph_to_dodgr'>Convert a <span class="pkg">igraph</span> network to an equivalent <code>dodgr</code> representation.</h2><span id='topic+igraph_to_dodgr'></span>

<h3>Description</h3>

<p>Convert a <span class="pkg">igraph</span> network to an equivalent <code>dodgr</code> representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph_to_dodgr(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph_to_dodgr_+3A_graph">graph</code></td>
<td>
<p>An <span class="pkg">igraph</span> network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>dodgr</code> equivalent of the input.
</p>


<h3>See Also</h3>

<p><a href="#topic+dodgr_to_igraph">dodgr_to_igraph</a>
</p>
<p>Other conversion: 
<code><a href="#topic+dodgr_deduplicate_graph">dodgr_deduplicate_graph</a>()</code>,
<code><a href="#topic+dodgr_to_igraph">dodgr_to_igraph</a>()</code>,
<code><a href="#topic+dodgr_to_sfc">dodgr_to_sfc</a>()</code>,
<code><a href="#topic+dodgr_to_sf">dodgr_to_sf</a>()</code>,
<code><a href="#topic+dodgr_to_tidygraph">dodgr_to_tidygraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
graphi &lt;- dodgr_to_igraph (graph)
graph2 &lt;- igraph_to_dodgr (graphi)
identical (graph2, graph) # FALSE
</code></pre>

<hr>
<h2 id='match_points_to_graph'>Alias for <a href="#topic+match_pts_to_graph">match_pts_to_graph</a></h2><span id='topic+match_points_to_graph'></span>

<h3>Description</h3>

<p>Match spatial points to the edges of a spatial graph, through finding the
edge with the closest perpendicular intersection. NOTE: Intersections are
calculated geometrically, and presume planar geometry. It is up to users of
projected geometrical data, such as those within a <code>dodgr_streetnet</code> object,
to ensure that either: (i) Data span an sufficiently small area that errors
from presuming planar geometry may be ignored; or (ii) Data are re-projected
to an equivalent planar geometry prior to calling this routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_points_to_graph(graph, xy, connected = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_points_to_graph_+3A_graph">graph</code></td>
<td>
<p>A <code>dodgr</code> graph with spatial coordinates, such as a
<code>dodgr_streetnet</code> object.</p>
</td></tr>
<tr><td><code id="match_points_to_graph_+3A_xy">xy</code></td>
<td>
<p>coordinates of points to be matched to the vertices, either as
matrix or <span class="pkg">sf</span>-formatted <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="match_points_to_graph_+3A_connected">connected</code></td>
<td>
<p>Should points be matched to the same (largest) connected
component of graph? If <code>FALSE</code> and these points are to be used for a
<code>dodgr</code> routing routine (<a href="#topic+dodgr_dists">dodgr_dists</a>, <a href="#topic+dodgr_paths">dodgr_paths</a>, or
<a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>), then results may not be returned if points are
not part of the same connected component. On the other hand, forcing them to
be part of the same connected component may decrease the spatial accuracy of
matching.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>distances = FALSE</code> (default), a vector index matching the <code>xy</code>
coordinates to nearest edges. For bi-directional edges, only one match is
returned, and it is up to the user to identify and suitably process matching
edge pairs. For 'distances = TRUE', a 'data.frame' of four columns:
</p>

<ul>
<li><p> &quot;index&quot; The index of closest edges in &quot;graph&quot;, as described above.
</p>
</li>
<li><p> &quot;d_signed&quot; The perpendicular distance from ech point to the nearest
edge, with negative distances denoting points to the left of edges, and
positive distances denoting points to the right. Distances of zero denote
points lying precisely on the line of an edge (potentially including cases
where nearest point of bisection lies beyond the actual edge).
</p>
</li>
<li><p> &quot;x&quot; The x-coordinate of the point of intersection.
</p>
</li>
<li><p> &quot;y&quot; The y-coordinate of the point of intersection.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other match: 
<code><a href="#topic+add_nodes_to_graph">add_nodes_to_graph</a>()</code>,
<code><a href="#topic+match_points_to_verts">match_points_to_verts</a>()</code>,
<code><a href="#topic+match_pts_to_graph">match_pts_to_graph</a>()</code>,
<code><a href="#topic+match_pts_to_verts">match_pts_to_verts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi, wt_profile = "foot")
# Then generate some random points to match to graph
verts &lt;- dodgr_vertices (graph)
npts &lt;- 10
xy &lt;- data.frame (
    x = min (verts$x) + runif (npts) * diff (range (verts$x)),
    y = min (verts$y) + runif (npts) * diff (range (verts$y))
)
edges &lt;- match_pts_to_graph (graph, xy)
graph [edges, ] # The edges of the graph closest to `xy`
</code></pre>

<hr>
<h2 id='match_points_to_verts'>Alias for <a href="#topic+match_pts_to_verts">match_pts_to_verts</a></h2><span id='topic+match_points_to_verts'></span>

<h3>Description</h3>

<p>The <a href="#topic+match_pts_to_graph">match_pts_to_graph</a> function matches points to the nearest edge
based on geometric intersections; this function only matches to the nearest
vertex based on point-to-point distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_points_to_verts(verts, xy, connected = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_points_to_verts_+3A_verts">verts</code></td>
<td>
<p>A <code>data.frame</code> of vertices obtained from
<code>dodgr_vertices(graph)</code>.</p>
</td></tr>
<tr><td><code id="match_points_to_verts_+3A_xy">xy</code></td>
<td>
<p>coordinates of points to be matched to the vertices, either as
matrix or <span class="pkg">sf</span>-formatted <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="match_points_to_verts_+3A_connected">connected</code></td>
<td>
<p>Should points be matched to the same (largest) connected
component of graph? If <code>FALSE</code> and these points are to be used for a
<code>dodgr</code> routing routine (<a href="#topic+dodgr_dists">dodgr_dists</a>, <a href="#topic+dodgr_paths">dodgr_paths</a>, or
<a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>), then results may not be returned if points are
not part of the same connected component. On the other hand, forcing them to
be part of the same connected component may decrease the spatial accuracy of
matching.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector index into verts
</p>


<h3>See Also</h3>

<p>Other match: 
<code><a href="#topic+add_nodes_to_graph">add_nodes_to_graph</a>()</code>,
<code><a href="#topic+match_points_to_graph">match_points_to_graph</a>()</code>,
<code><a href="#topic+match_pts_to_graph">match_pts_to_graph</a>()</code>,
<code><a href="#topic+match_pts_to_verts">match_pts_to_verts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- weight_streetnet (hampi, wt_profile = "foot")
verts &lt;- dodgr_vertices (net)
# Then generate some random points to match to graph
npts &lt;- 10
xy &lt;- data.frame (
    x = min (verts$x) + runif (npts) * diff (range (verts$x)),
    y = min (verts$y) + runif (npts) * diff (range (verts$y))
)
pts &lt;- match_pts_to_verts (verts, xy)
pts # an index into verts
pts &lt;- verts$id [pts]
pts # names of those vertices
</code></pre>

<hr>
<h2 id='match_pts_to_graph'>Match spatial points to the edges of a spatial graph.</h2><span id='topic+match_pts_to_graph'></span>

<h3>Description</h3>

<p>Match spatial points to the edges of a spatial graph, through finding the
edge with the closest perpendicular intersection. NOTE: Intersections are
calculated geometrically, and presume planar geometry. It is up to users of
projected geometrical data, such as those within a <code>dodgr_streetnet</code> object,
to ensure that either: (i) Data span an sufficiently small area that errors
from presuming planar geometry may be ignored; or (ii) Data are re-projected
to an equivalent planar geometry prior to calling this routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_pts_to_graph(graph, xy, connected = FALSE, distances = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_pts_to_graph_+3A_graph">graph</code></td>
<td>
<p>A <code>dodgr</code> graph with spatial coordinates, such as a
<code>dodgr_streetnet</code> object.</p>
</td></tr>
<tr><td><code id="match_pts_to_graph_+3A_xy">xy</code></td>
<td>
<p>coordinates of points to be matched to the vertices, either as
matrix or <span class="pkg">sf</span>-formatted <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="match_pts_to_graph_+3A_connected">connected</code></td>
<td>
<p>Should points be matched to the same (largest) connected
component of graph? If <code>FALSE</code> and these points are to be used for a
<code>dodgr</code> routing routine (<a href="#topic+dodgr_dists">dodgr_dists</a>, <a href="#topic+dodgr_paths">dodgr_paths</a>, or
<a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>), then results may not be returned if points are
not part of the same connected component. On the other hand, forcing them to
be part of the same connected component may decrease the spatial accuracy of
matching.</p>
</td></tr>
<tr><td><code id="match_pts_to_graph_+3A_distances">distances</code></td>
<td>
<p>If <code>TRUE</code>, return a 'data.frame' object with 'index' column
as described in return value; and additional columns with perpendicular
distance to nearest edge in graph, and coordinates of points of intersection.
See description of return value for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>distances = FALSE</code> (default), a vector index matching the <code>xy</code>
coordinates to nearest edges. For bi-directional edges, only one match is
returned, and it is up to the user to identify and suitably process matching
edge pairs. For 'distances = TRUE', a 'data.frame' of four columns:
</p>

<ul>
<li><p> &quot;index&quot; The index of closest edges in &quot;graph&quot;, as described above.
</p>
</li>
<li><p> &quot;d_signed&quot; The perpendicular distance from ech point to the nearest
edge, with negative distances denoting points to the left of edges, and
positive distances denoting points to the right. Distances of zero denote
points lying precisely on the line of an edge (potentially including cases
where nearest point of bisection lies beyond the actual edge).
</p>
</li>
<li><p> &quot;x&quot; The x-coordinate of the point of intersection.
</p>
</li>
<li><p> &quot;y&quot; The y-coordinate of the point of intersection.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other match: 
<code><a href="#topic+add_nodes_to_graph">add_nodes_to_graph</a>()</code>,
<code><a href="#topic+match_points_to_graph">match_points_to_graph</a>()</code>,
<code><a href="#topic+match_points_to_verts">match_points_to_verts</a>()</code>,
<code><a href="#topic+match_pts_to_verts">match_pts_to_verts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi, wt_profile = "foot")
# Then generate some random points to match to graph
verts &lt;- dodgr_vertices (graph)
npts &lt;- 10
xy &lt;- data.frame (
    x = min (verts$x) + runif (npts) * diff (range (verts$x)),
    y = min (verts$y) + runif (npts) * diff (range (verts$y))
)
edges &lt;- match_pts_to_graph (graph, xy)
graph [edges, ] # The edges of the graph closest to `xy`
</code></pre>

<hr>
<h2 id='match_pts_to_verts'>Match spatial points to the vertices of a spatial graph.</h2><span id='topic+match_pts_to_verts'></span>

<h3>Description</h3>

<p>The <a href="#topic+match_pts_to_graph">match_pts_to_graph</a> function matches points to the nearest edge
based on geometric intersections; this function only matches to the nearest
vertex based on point-to-point distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_pts_to_verts(verts, xy, connected = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_pts_to_verts_+3A_verts">verts</code></td>
<td>
<p>A <code>data.frame</code> of vertices obtained from
<code>dodgr_vertices(graph)</code>.</p>
</td></tr>
<tr><td><code id="match_pts_to_verts_+3A_xy">xy</code></td>
<td>
<p>coordinates of points to be matched to the vertices, either as
matrix or <span class="pkg">sf</span>-formatted <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="match_pts_to_verts_+3A_connected">connected</code></td>
<td>
<p>Should points be matched to the same (largest) connected
component of graph? If <code>FALSE</code> and these points are to be used for a
<code>dodgr</code> routing routine (<a href="#topic+dodgr_dists">dodgr_dists</a>, <a href="#topic+dodgr_paths">dodgr_paths</a>, or
<a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a>), then results may not be returned if points are
not part of the same connected component. On the other hand, forcing them to
be part of the same connected component may decrease the spatial accuracy of
matching.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector index into verts
</p>


<h3>See Also</h3>

<p>Other match: 
<code><a href="#topic+add_nodes_to_graph">add_nodes_to_graph</a>()</code>,
<code><a href="#topic+match_points_to_graph">match_points_to_graph</a>()</code>,
<code><a href="#topic+match_points_to_verts">match_points_to_verts</a>()</code>,
<code><a href="#topic+match_pts_to_graph">match_pts_to_graph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- weight_streetnet (hampi, wt_profile = "foot")
verts &lt;- dodgr_vertices (net)
# Then generate some random points to match to graph
npts &lt;- 10
xy &lt;- data.frame (
    x = min (verts$x) + runif (npts) * diff (range (verts$x)),
    y = min (verts$y) + runif (npts) * diff (range (verts$y))
)
pts &lt;- match_pts_to_verts (verts, xy)
pts # an index into verts
pts &lt;- verts$id [pts]
pts # names of those vertices
</code></pre>

<hr>
<h2 id='merge_directed_graph'>Merge directed edges into equivalent undirected edges.</h2><span id='topic+merge_directed_graph'></span>

<h3>Description</h3>

<p>Merge directed edges into equivalent undirected values by aggregating across
directions. This function is primarily intended to aid visualisation of
directed graphs, particularly visualising the results of the
<a href="#topic+dodgr_flows_aggregate">dodgr_flows_aggregate</a> and <a href="#topic+dodgr_flows_disperse">dodgr_flows_disperse</a> functions, which
return columns of aggregated flows directed along each edge of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_directed_graph(graph, col_names = c("flow"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_directed_graph_+3A_graph">graph</code></td>
<td>
<p>A undirected graph in which directed edges of the input graph
have been merged through aggregation to yield a single, undirected edge
between each pair of vertices.</p>
</td></tr>
<tr><td><code id="merge_directed_graph_+3A_col_names">col_names</code></td>
<td>
<p>Names of columns to be merged through aggregation. Values
for these columns in resultant undirected graph will be aggregated from
directed values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An equivalent graph in which all directed edges have been reduced to
single, undirected edges, and all values of the specified column(s) have been
aggregated across directions to undirected values.
</p>


<h3>See Also</h3>

<p>Other misc: 
<code><a href="#topic+compare_heaps">compare_heaps</a>()</code>,
<code><a href="#topic+dodgr_flowmap">dodgr_flowmap</a>()</code>,
<code><a href="#topic+dodgr_full_cycles">dodgr_full_cycles</a>()</code>,
<code><a href="#topic+dodgr_fundamental_cycles">dodgr_fundamental_cycles</a>()</code>,
<code><a href="#topic+dodgr_insert_vertex">dodgr_insert_vertex</a>()</code>,
<code><a href="#topic+dodgr_sample">dodgr_sample</a>()</code>,
<code><a href="#topic+dodgr_sflines_to_poly">dodgr_sflines_to_poly</a>()</code>,
<code><a href="#topic+dodgr_vertices">dodgr_vertices</a>()</code>,
<code><a href="#topic+summary.dodgr_dists_categorical">summary.dodgr_dists_categorical</a>()</code>,
<code><a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- weight_streetnet (hampi)
from &lt;- sample (graph$from_id, size = 10)
to &lt;- sample (graph$to_id, size = 5)
to &lt;- to [!to %in% from]
flows &lt;- matrix (10 * runif (length (from) * length (to)),
    nrow = length (from)
)
graph &lt;- dodgr_flows_aggregate (graph, from = from, to = to, flows = flows)
# graph then has an additonal 'flows` column of aggregate flows along all
# edges. These flows are directed, and can be aggregated to equivalent
# undirected flows on an equivalent undirected graph with:
graph_undir &lt;- merge_directed_graph (graph)
# This graph will only include those edges having non-zero flows, and so:
nrow (graph)
nrow (graph_undir) # the latter is much smaller
</code></pre>

<hr>
<h2 id='os_roads_bristol'>Sample street network from Bristol, U.K.</h2><span id='topic+os_roads_bristol'></span>

<h3>Description</h3>

<p>A sample street network for Bristol, U.K., from the Ordnance Survey.
</p>


<h3>Format</h3>

<p>A Simple Features <code>sf</code> <code>data.frame</code> representing
motorways in Bristol, UK.
</p>


<h3>Note</h3>

<p>Input data downloaded from
<a href="https://osdatahub.os.uk/downloads/open">https://osdatahub.os.uk/downloads/open</a>,
To download the data from that page click on the tick box next to
'OS Open Roads', scroll to the bottom, click 'Continue' and complete
the form on the subsequent page.
This dataset is open access and can be used under the
<a href="https://www.ordnancesurvey.co.uk/business-and-government/licensing/using-creating-data-with-os-products/os-opendata.html">Open Government License</a>
and must be cited as follows:
Contains OS data © Crown copyright and database right (2017)
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+hampi">hampi</a></code>,
<code><a href="#topic+weighting_profiles">weighting_profiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library (sf)
library (dplyr)
# data must be unzipped here
# os_roads &lt;- sf::read_sf("~/data/ST_RoadLink.shp")
# u &lt;- paste0 (
#     "https://opendata.arcgis.com/datasets/",
#     "686603e943f948acaa13fb5d2b0f1275_4.kml"
# )
# lads &lt;- sf::read_sf(u)
# mapview::mapview(lads)
# bristol_pol &lt;- dplyr::filter(lads, grepl("Bristol", lad16nm))
# os_roads &lt;- st_transform(os_roads, st_crs(lads)
# os_roads_bristol &lt;- os_roads[bristol_pol, ] %&gt;%
#   dplyr::filter(class == "Motorway" &amp;
#                 roadNumber != "M32") %&gt;%
#   st_zm(drop = TRUE)
# mapview::mapview(os_roads_bristol)

## End(Not run)
# Converting this 'sf data.frame' to a 'dodgr' network requires manual
# specification of weighting profile:
colnm &lt;- "formOfWay" # name of column used to determine weights
wts &lt;- data.frame (
    name = "custom",
    way = unique (os_roads_bristol [[colnm]]),
    value = c (0.1, 0.2, 0.8, 1)
)
net &lt;- weight_streetnet (
    os_roads_bristol,
    wt_profile = wts,
    type_col = colnm, id_col = "identifier"
)
# 'id_col' tells the function which column to use to attribute IDs of ways
</code></pre>

<hr>
<h2 id='summary.dodgr_dists_categorical'>Transform a result from <a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a> to summary statistics</h2><span id='topic+summary.dodgr_dists_categorical'></span>

<h3>Description</h3>

<p>Transform a result from <a href="#topic+dodgr_dists_categorical">dodgr_dists_categorical</a> to summary statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dodgr_dists_categorical'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dodgr_dists_categorical_+3A_object">object</code></td>
<td>
<p>A 'dodgr_dists_categorical' object</p>
</td></tr>
<tr><td><code id="summary.dodgr_dists_categorical_+3A_...">...</code></td>
<td>
<p>Extra parameters currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summary statistics (invisibly)
</p>


<h3>See Also</h3>

<p>Other misc: 
<code><a href="#topic+compare_heaps">compare_heaps</a>()</code>,
<code><a href="#topic+dodgr_flowmap">dodgr_flowmap</a>()</code>,
<code><a href="#topic+dodgr_full_cycles">dodgr_full_cycles</a>()</code>,
<code><a href="#topic+dodgr_fundamental_cycles">dodgr_fundamental_cycles</a>()</code>,
<code><a href="#topic+dodgr_insert_vertex">dodgr_insert_vertex</a>()</code>,
<code><a href="#topic+dodgr_sample">dodgr_sample</a>()</code>,
<code><a href="#topic+dodgr_sflines_to_poly">dodgr_sflines_to_poly</a>()</code>,
<code><a href="#topic+dodgr_vertices">dodgr_vertices</a>()</code>,
<code><a href="#topic+merge_directed_graph">merge_directed_graph</a>()</code>,
<code><a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>()</code>
</p>

<hr>
<h2 id='weight_railway'>Weight a network for routing along railways.</h2><span id='topic+weight_railway'></span>

<h3>Description</h3>

<p>Weight (or re-weight) an <code>sf</code>-formatted OSM street network for routing
along railways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_railway(
  x,
  type_col = "railway",
  id_col = "osm_id",
  keep_cols = c("maxspeed"),
  excluded = c("abandoned", "disused", "proposed", "razed")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_railway_+3A_x">x</code></td>
<td>
<p>A street network represented either as <code>sf</code> <code>LINESTRING</code>
objects, typically extracted with <a href="#topic+dodgr_streetnet">dodgr_streetnet</a>.</p>
</td></tr>
<tr><td><code id="weight_railway_+3A_type_col">type_col</code></td>
<td>
<p>Specify column of the <code>sf</code> <code>data.frame</code> object
which designates different types of railways to be used for weighting
(default works with <code>osmdata</code> objects).</p>
</td></tr>
<tr><td><code id="weight_railway_+3A_id_col">id_col</code></td>
<td>
<p>Specify column of the codesf <code>data.frame</code> object which
provides unique identifiers for each railway (default works with
<code>osmdata</code> objects).</p>
</td></tr>
<tr><td><code id="weight_railway_+3A_keep_cols">keep_cols</code></td>
<td>
<p>Vectors of columns from <code>sf_lines</code> to be kept in the
resultant <code>dodgr</code> network; vector can be either names or indices of
desired columns.</p>
</td></tr>
<tr><td><code id="weight_railway_+3A_excluded">excluded</code></td>
<td>
<p>Types of railways to exclude from routing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of edges representing the rail network, along
with a column of graph component numbers.
</p>


<h3>Note</h3>

<p>Default railway weighting is by distance. Other weighting schemes, such
as by maximum speed, can be implemented simply by modifying the
<code>d_weighted</code> column returned by this function accordingly.
</p>


<h3>See Also</h3>

<p>Other extraction: 
<code><a href="#topic+dodgr_streetnet_sc">dodgr_streetnet_sc</a>()</code>,
<code><a href="#topic+dodgr_streetnet">dodgr_streetnet</a>()</code>,
<code><a href="#topic+weight_streetnet">weight_streetnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# sample railway extraction with the 'osmdata' package
library (osmdata)
dat &lt;- opq ("shinjuku") %&gt;%
    add_osm_feature (key = "railway") %&gt;%
    osmdata_sf (quiet = FALSE)
graph &lt;- weight_railway (dat$osm_lines)

## End(Not run)
</code></pre>

<hr>
<h2 id='weight_streetnet'>Weight a street network according to a specified weighting profile.</h2><span id='topic+weight_streetnet'></span><span id='topic+weight_streetnet.default'></span><span id='topic+weight_streetnet.sf'></span><span id='topic+weight_streetnet.sc'></span><span id='topic+weight_streetnet.SC'></span>

<h3>Description</h3>

<p>Weight (or re-weight) an <span class="pkg">sf</span> or <code>SC</code> (<code>silicate</code>)-formatted OSM street
network according to a named profile, selected from (foot, horse, wheelchair,
bicycle, moped, motorcycle, motorcar, goods, hgv, psv), or a cusstomized
version dervied from those.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_streetnet(
  x,
  wt_profile = "bicycle",
  wt_profile_file = NULL,
  turn_penalty = FALSE,
  type_col = "highway",
  id_col = "osm_id",
  keep_cols = NULL,
  left_side = FALSE
)

## Default S3 method:
weight_streetnet(
  x,
  wt_profile = "bicycle",
  wt_profile_file = NULL,
  turn_penalty = FALSE,
  type_col = "highway",
  id_col = "osm_id",
  keep_cols = NULL,
  left_side = FALSE
)

## S3 method for class 'sf'
weight_streetnet(
  x,
  wt_profile = "bicycle",
  wt_profile_file = NULL,
  turn_penalty = FALSE,
  type_col = "highway",
  id_col = "osm_id",
  keep_cols = NULL,
  left_side = FALSE
)

## S3 method for class 'sc'
weight_streetnet(
  x,
  wt_profile = "bicycle",
  wt_profile_file = NULL,
  turn_penalty = FALSE,
  type_col = "highway",
  id_col = "osm_id",
  keep_cols = NULL,
  left_side = FALSE
)

## S3 method for class 'SC'
weight_streetnet(
  x,
  wt_profile = "bicycle",
  wt_profile_file = NULL,
  turn_penalty = FALSE,
  type_col = "highway",
  id_col = "osm_id",
  keep_cols = NULL,
  left_side = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_streetnet_+3A_x">x</code></td>
<td>
<p>A street network represented either as <code>sf</code> <code>LINESTRING</code>
objects, typically extracted with <a href="#topic+dodgr_streetnet">dodgr_streetnet</a>, or as an <code>SC</code>
(<code>silicate</code>) object typically extracted with the <a href="#topic+dodgr_streetnet_sc">dodgr_streetnet_sc</a>.</p>
</td></tr>
<tr><td><code id="weight_streetnet_+3A_wt_profile">wt_profile</code></td>
<td>
<p>Name of weighting profile, or <code>data.frame</code> specifying
custom values (see Details)</p>
</td></tr>
<tr><td><code id="weight_streetnet_+3A_wt_profile_file">wt_profile_file</code></td>
<td>
<p>Name of locally-stored, <code>.json</code>-formatted version of
<code>dodgr::weighting_profiles</code>, created with <a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>, and
modified as desired.</p>
</td></tr>
<tr><td><code id="weight_streetnet_+3A_turn_penalty">turn_penalty</code></td>
<td>
<p>Including time penalty on edges for turning across
oncoming traffic at intersections (see Note).</p>
</td></tr>
<tr><td><code id="weight_streetnet_+3A_type_col">type_col</code></td>
<td>
<p>Specify column of the <code>sf</code> <code>data.frame</code> object
which designates different types of highways to be used for weighting
(default works with <code>osmdata</code> objects).</p>
</td></tr>
<tr><td><code id="weight_streetnet_+3A_id_col">id_col</code></td>
<td>
<p>For <code>sf</code>-formatted data only: Specify column of the codesf
<code>data.frame</code> object which provides unique identifiers for each highway
(default works with <code>osmdata</code> objects).</p>
</td></tr>
<tr><td><code id="weight_streetnet_+3A_keep_cols">keep_cols</code></td>
<td>
<p>Vectors of columns from <code>x</code> to be kept in the resultant
<code>dodgr</code> network; vector can be either names, regex-patterns,  or indices of
desired columns (see notes).</p>
</td></tr>
<tr><td><code id="weight_streetnet_+3A_left_side">left_side</code></td>
<td>
<p>Does traffic travel on the left side of the road (<code>TRUE</code>) or
the right side (<code>FALSE</code>)? - only has effect on turn angle calculations for
edge times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of edges representing the street network, with
distances in metres and times in seconds, along with a column of graph
component numbers. Times for <span class="pkg">sf</span>-formatted street networks are only
approximate, and do not take into account traffic lights, turn angles, or
elevation changes. Times for <span class="pkg">sc</span>-formatted street networks take into
account all of these factors, with elevation changes automatically taken into
account for networks generated with the <span class="pkg">osmdata</span> function
<code>osm_elevation()</code>.
</p>


<h3>Note</h3>

<p>Names for the <code>wt_profile</code> parameter are taken from
<a href="#topic+weighting_profiles">weighting_profiles</a>, which is a list including a <code>data.frame</code> also
called <code>weighting_profiles</code> of weights for different modes of transport.
Values for <code>wt_profile</code> are taken from current modes included there, which
are &quot;bicycle&quot;, &quot;foot&quot;, &quot;goods&quot;, &quot;hgv&quot;, &quot;horse&quot;, &quot;moped&quot;, &quot;motorcar&quot;,
&quot;motorcycle&quot;, &quot;psv&quot;, and &quot;wheelchair&quot;. Railway routing can be implemented
with the separate function <a href="#topic+weight_railway">weight_railway</a>. Alternatively, the entire
<code>weighting_profile</code> structures can be written to a local <code>.json</code>-formatted
file with <a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>, the values edited as desired, and
the name of this file passed as the <code>wt_profile_file</code> parameter.
</p>
<p>Realistic routing include factors such as access restrictions, turn
penalties, and effects of incline, can only be implemented when the objects
passed to <code>weight_streetnet</code> are of <span class="pkg">sc</span> (&quot;silicate&quot;) format, generated
with <a href="#topic+dodgr_streetnet_sc">dodgr_streetnet_sc</a>. Restrictions applied to ways (in Open
Streetmap Terminology) may be controlled by ensuring specific columns are
retained in the <code>dodgr</code> network with the <code>keep_cols</code> argument. For example,
restrictions on access are generally specified by specifying a value for the
key of &quot;access&quot;. Include &quot;access&quot; in <code>keep_cols</code> will ensure these values are
retained in the <code>dodgr</code> version, from which ways with specified values can
easily be removed or modified, as demonstrated in the examples.
</p>
<p>The additional Open Street Map (OSM) keys which can be used to specify
restrictions are which are automatically extracted with
<a href="#topic+dodgr_streetnet_sc">dodgr_streetnet_sc</a>, and so may be added to the <code>keep_cols</code> argument,
include:
</p>

<ul>
<li><p> &quot;access&quot;
</p>
</li>
<li><p> &quot;bicycle&quot;
</p>
</li>
<li><p> &quot;foot&quot;
</p>
</li>
<li><p> &quot;highway&quot;
</p>
</li>
<li><p> &quot;motorcar&quot;
</p>
</li>
<li><p> &quot;motor_vehicle&quot;
</p>
</li>
<li><p> &quot;restriction&quot;
</p>
</li>
<li><p> &quot;toll&quot;
</p>
</li>
<li><p> &quot;vehicle&quot;
</p>
</li></ul>

<p>Restrictions and time-penalties on turns can be implemented from such
objects by setting <code>turn_penalty = TRUE</code>. Setting <code>turn_penalty = TRUE</code> will
honour turn restrictions specified in Open Street Map (unless the &quot;penalties&quot;
table of <a href="#topic+weighting_profiles">weighting_profiles</a> has <code>restrictions = FALSE</code> for a specified
<code>wt_profile</code>). Resultant graphs are fundamentally different from the default
for distance-based routing. These graphs may be used directly in the
<a href="#topic+dodgr_dists">dodgr_dists</a> function. Use in any other functions requires additional
information obtained in a file in the temporary directory of the current R
session with a name starting with &quot;dodgr_junctions_&quot;, and including the
value of <code>attr(graph, "hash")</code>. If graphs with turn penalties are to be used
in subsequent R sessions, this &quot;dodgr_junctions_&quot; file will need to be moved
to a more permanent storage location, and then replaced in the temporary
directory of any subsequent R sessions.
</p>
<p>The resultant graph includes only those edges for which the given
weighting profile specifies finite edge weights. Any edges of types not
present in a given weighting profile are automatically removed from the
weighted streetnet.
</p>
<p>If the resultant graph is to be contracted via
<a href="#topic+dodgr_contract_graph">dodgr_contract_graph</a>, <strong>and</strong> if the columns of the graph have been,
or will be, modified, then automatic caching must be switched off with
<a href="#topic+dodgr_cache_off">dodgr_cache_off</a>. If not, the <a href="#topic+dodgr_contract_graph">dodgr_contract_graph</a> function will
return the automatically cached version, which is the contracted version of
the full graph prior to any modification of columns.
</p>


<h3>See Also</h3>

<p><a href="#topic+write_dodgr_wt_profile">write_dodgr_wt_profile</a>, <a href="#topic+dodgr_times">dodgr_times</a>
</p>
<p>Other extraction: 
<code><a href="#topic+dodgr_streetnet_sc">dodgr_streetnet_sc</a>()</code>,
<code><a href="#topic+dodgr_streetnet">dodgr_streetnet</a>()</code>,
<code><a href="#topic+weight_railway">weight_railway</a>()</code>
</p>
<p>Other extraction: 
<code><a href="#topic+dodgr_streetnet_sc">dodgr_streetnet_sc</a>()</code>,
<code><a href="#topic+dodgr_streetnet">dodgr_streetnet</a>()</code>,
<code><a href="#topic+weight_railway">weight_railway</a>()</code>
</p>
<p>Other extraction: 
<code><a href="#topic+dodgr_streetnet_sc">dodgr_streetnet_sc</a>()</code>,
<code><a href="#topic+dodgr_streetnet">dodgr_streetnet</a>()</code>,
<code><a href="#topic+weight_railway">weight_railway</a>()</code>
</p>
<p>Other extraction: 
<code><a href="#topic+dodgr_streetnet_sc">dodgr_streetnet_sc</a>()</code>,
<code><a href="#topic+dodgr_streetnet">dodgr_streetnet</a>()</code>,
<code><a href="#topic+weight_railway">weight_railway</a>()</code>
</p>
<p>Other extraction: 
<code><a href="#topic+dodgr_streetnet_sc">dodgr_streetnet_sc</a>()</code>,
<code><a href="#topic+dodgr_streetnet">dodgr_streetnet</a>()</code>,
<code><a href="#topic+weight_railway">weight_railway</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># hampi is included with package as an 'osmdata' sf-formatted street network
net &lt;- weight_streetnet (hampi)
class (net) # data.frame
dim (net) # 6096  11; 6096 streets
# os_roads_bristol is also included as an sf data.frame, but in a different
# format requiring identification of columns and specification of custom
# weighting scheme.
colnm &lt;- "formOfWay"
wts &lt;- data.frame (
    name = "custom",
    way = unique (os_roads_bristol [[colnm]]),
    value = c (0.1, 0.2, 0.8, 1)
)
net &lt;- weight_streetnet (
    os_roads_bristol,
    wt_profile = wts,
    type_col = colnm, id_col = "identifier"
)
dim (net) # 406 11; 406 streets

# An example for a generic (non-OSM) highway, represented as the
# `routes_fast` object of the \pkg{stplanr} package, which is a
# SpatialLinesDataFrame.
## Not run: 
library (stplanr)
# merge all of the 'routes_fast' lines into a single network
r &lt;- overline (routes_fast, attrib = "length", buff_dist = 1)
r &lt;- sf::st_as_sf (r, crs = 4326)
# We need to specify both a `type` and `id` column for the
# \link{weight_streetnet} function.
r$type &lt;- 1
r$id &lt;- seq (nrow (r))
graph &lt;- weight_streetnet (
    r,
    type_col = "type",
    id_col = "id",
    wt_profile = 1
)

## End(Not run)
</code></pre>

<hr>
<h2 id='weighting_profiles'>Weighting profiles used to route different modes of transport.</h2><span id='topic+weighting_profiles'></span>

<h3>Description</h3>

<p>Collection of weighting profiles used to adjust the routing process to
different means of transport. Modified from data taken from the Routino
project, with additional tables for average speeds, dependence of speed on
type of surface, and waiting times in seconds at traffic lights. The latter
table (called &quot;penalties&quot;) includes waiting times at traffic lights (in
seconds), additional time penalties for turning across oncoming traffic
(&quot;turn&quot;), and a binary flag indicating whether turn restrictions should be
obeyed or not.
</p>


<h3>Format</h3>

<p>List of <code>data.frame</code> objects with profile names, means of transport
and weights.
</p>


<h3>References</h3>

<p><a href="https://www.routino.org/xml/routino-profiles.xml">https://www.routino.org/xml/routino-profiles.xml</a>
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+hampi">hampi</a></code>,
<code><a href="#topic+os_roads_bristol">os_roads_bristol</a></code>
</p>

<hr>
<h2 id='write_dodgr_wt_profile'>Write <code>dodgr</code> weighting profiles to local file.</h2><span id='topic+write_dodgr_wt_profile'></span>

<h3>Description</h3>

<p>Write the <code>dodgr</code> street network weighting profiles to a local
<code>.json</code>-formatted file for manual editing and subsequent re-reading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_dodgr_wt_profile(file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_dodgr_wt_profile_+3A_file">file</code></td>
<td>
<p>Full name (including path) of file to which to write. The <code>.json</code>
suffix will be automatically appended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if writing successful.
</p>


<h3>See Also</h3>

<p><a href="#topic+weight_streetnet">weight_streetnet</a>
</p>
<p>Other misc: 
<code><a href="#topic+compare_heaps">compare_heaps</a>()</code>,
<code><a href="#topic+dodgr_flowmap">dodgr_flowmap</a>()</code>,
<code><a href="#topic+dodgr_full_cycles">dodgr_full_cycles</a>()</code>,
<code><a href="#topic+dodgr_fundamental_cycles">dodgr_fundamental_cycles</a>()</code>,
<code><a href="#topic+dodgr_insert_vertex">dodgr_insert_vertex</a>()</code>,
<code><a href="#topic+dodgr_sample">dodgr_sample</a>()</code>,
<code><a href="#topic+dodgr_sflines_to_poly">dodgr_sflines_to_poly</a>()</code>,
<code><a href="#topic+dodgr_vertices">dodgr_vertices</a>()</code>,
<code><a href="#topic+merge_directed_graph">merge_directed_graph</a>()</code>,
<code><a href="#topic+summary.dodgr_dists_categorical">summary.dodgr_dists_categorical</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
