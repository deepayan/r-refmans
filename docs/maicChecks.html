<!DOCTYPE html><html lang="en"><head><title>Help for package maicChecks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {maicChecks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#maicChecks-package'><p>maicChecks: Exact Matching and Matching-Adjusted Indirect Comparison (MAIC)</p></a></li>
<li><a href='#eAD'><p>three AD scenarios</p></a></li>
<li><a href='#eIPD'><p>an IPD set</p></a></li>
<li><a href='#exmLP.2ipd'><p>Checks whether two IPD datasets can be matched with lpSolve::lp</p></a></li>
<li><a href='#exmWt.2ipd'><p>Exact matching for two IPD's</p></a></li>
<li><a href='#maicLP'><p>Checks if AD is within the convex hull of IPD using lp-solve</p></a></li>
<li><a href='#maicMD'><p>Checks if AD is within the convex hull of IPD using Mahalanobis distance</p></a></li>
<li><a href='#maicPCA'><p>Checks whether AD is outside IPD in PC coordinates</p></a></li>
<li><a href='#maicT2Test'><p>Hotelling's T-square test to check whether maic is needed</p></a></li>
<li><a href='#maicWt'><p>Estimates the MAIC weights</p></a></li>
<li><a href='#maxessWt'><p>Maximum ESS Weights</p></a></li>
<li><a href='#sim110'><p>Simulated data used for exact matching</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Exact Matching and Matching-Adjusted Indirect Comparison (MAIC)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lillian Yau &lt;maicChecks@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The second version (0.2.0) contains implementation for exact matching which is an alternative to propensity score matching (see Glimm &amp; Yau (2025)). The initial version (0.1.2) contains a collection of easy-to-implement tools for checking whether a MAIC can be conducted, as well as an alternative way of calculating weights (see Glimm &amp; Yau (2021) &lt;<a href="https://doi.org/10.1002%2Fpst.2210">doi:10.1002/pst.2210</a>&gt;.)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, tidyr, ggplot2, lpSolve, quadprog</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-03 15:24:22 UTC; stardust</td>
</tr>
<tr>
<td>Author:</td>
<td>Lillian Yau [aut, cre],
  Ekkehard Glimm [aut],
  Xinlei Deng <a href="https://orcid.org/0000-0001-8129-6007"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-03 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='maicChecks-package'>maicChecks: Exact Matching and Matching-Adjusted Indirect Comparison (MAIC)</h2><span id='topic+maicChecks'></span><span id='topic+maicChecks-package'></span>

<h3>Description</h3>

<p>The second version (0.2.0) contains implementation for exact matching which is an alternative to propensity score matching (see Glimm &amp; Yau (2025)). The initial version (0.1.2) contains a collection of easy-to-implement tools for checking whether a MAIC can be conducted, as well as an alternative way of calculating weights (see Glimm &amp; Yau (2021) <a href="https://doi.org/10.1002/pst.2210">doi:10.1002/pst.2210</a>.)
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lillian Yau <a href="mailto:maicChecks@gmail.com">maicChecks@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Ekkehard Glimm
</p>
</li>
<li><p> Xinlei Deng <a href="mailto:xinlei.deng.apha@gmail.com">xinlei.deng.apha@gmail.com</a> (<a href="https://orcid.org/0000-0001-8129-6007">ORCID</a>)
</p>
</li></ul>


<hr>
<h2 id='eAD'>three AD scenarios</h2><span id='topic+eAD'></span>

<h3>Description</h3>

<p>Three artificial scenarios serves as the ad cases.
This is used in Glimm &amp; Yau (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eAD)
</code></pre>


<h3>Format</h3>


<dl>
<dt>scen</dt><dd><p>corresponds to scenarios A, B, and C in the reference manuscript (Glimm &amp; Yau (2021)). Scenario A is very close to IPD center (see data(ipd)) and is within the IPD convex hull; scenario B is further away from IPD center but otherwise still inside the IPD convex hull; scenario C is outside IPD convex hull.</p>
</dd>
<dt>y1</dt><dd><p>a numeric vector</p>
</dd>
<dt>y2</dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>References</h3>

<p>Glimm &amp; Yau (2021)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eAD)
</code></pre>

<hr>
<h2 id='eIPD'>an IPD set</h2><span id='topic+eIPD'></span>

<h3>Description</h3>

<p>an articial data set serves as the IPD set.
this is used in Glimm &amp; Yau (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eIPD)
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>y1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y2</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>References</h3>

<p>Glimm &amp; Yau (2021)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eIPD)
</code></pre>

<hr>
<h2 id='exmLP.2ipd'>Checks whether two IPD datasets can be matched with lpSolve::lp</h2><span id='topic+exmLP.2ipd'></span>

<h3>Description</h3>

<p>Checks whether two IPD datasets can be matched with lpSolve::lp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exmLP.2ipd(
  ipd1,
  ipd2,
  vars_to_match = NULL,
  cat_vars_to_01 = NULL,
  mean.constrained = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exmLP.2ipd_+3A_ipd1">ipd1</code></td>
<td>
<p>a dataframe with n1 row and p column, where n1 is number of subjects of the first IPD, and p is the number of variables used in standardization.</p>
</td></tr>
<tr><td><code id="exmLP.2ipd_+3A_ipd2">ipd2</code></td>
<td>
<p>a dataframe with n2 row and p column, where n2 is number of subjects of the second IPD, and p is the number of variables used in standardization.</p>
</td></tr>
<tr><td><code id="exmLP.2ipd_+3A_vars_to_match">vars_to_match</code></td>
<td>
<p>variables used for matching. if NULL, use all variables.</p>
</td></tr>
<tr><td><code id="exmLP.2ipd_+3A_cat_vars_to_01">cat_vars_to_01</code></td>
<td>
<p>variable names for the categorical variables that need to be converted to indicator variables.</p>
</td></tr>
<tr><td><code id="exmLP.2ipd_+3A_mean.constrained">mean.constrained</code></td>
<td>
<p>whether to restrict the weighted means to be within the ranges of observed means. Default is FALSE. When it is TRUE, there is a higher chance of not having a solution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If dummy variables are already created for the categorical variables in the data set, and are present in <code>ipd1</code> and <code>ipd2</code>, then <code>cat_vars_to_01</code> should be left as NULL.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>lp.check</code></td>
<td>
<p>0 = OS can be conducted; 2 = OS cannot be conducted</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lillian Yau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ipd1 &lt;- sim110[sim110$study == 'IPD A',]
ipd2 &lt;- sim110[sim110$study == 'IPD B',]
x &lt;- exmLP.2ipd(ipd1, ipd2, vars_to_match = paste0('X', 1:5), 
cat_vars_to_01 = paste0('X', 1:3), mean.constrained = FALSE) 

## End(Not run)
</code></pre>

<hr>
<h2 id='exmWt.2ipd'>Exact matching for two IPD's</h2><span id='topic+exmWt.2ipd'></span>

<h3>Description</h3>

<p>Exact matching for two IPD's
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exmWt.2ipd(
  ipd1,
  ipd2,
  vars_to_match = NULL,
  cat_vars_to_01 = NULL,
  mean.constrained = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exmWt.2ipd_+3A_ipd1">ipd1</code></td>
<td>
<p>a dataframe with n row and p column, where n is number of subjects and p is the number of variables used in matching.</p>
</td></tr>
<tr><td><code id="exmWt.2ipd_+3A_ipd2">ipd2</code></td>
<td>
<p>the other IPD with the same number of columns</p>
</td></tr>
<tr><td><code id="exmWt.2ipd_+3A_vars_to_match">vars_to_match</code></td>
<td>
<p>variables used for matching. if NULL, use all variables.</p>
</td></tr>
<tr><td><code id="exmWt.2ipd_+3A_cat_vars_to_01">cat_vars_to_01</code></td>
<td>
<p>a list of variable names for the categorical variables that need to be converted to indicator variables.</p>
</td></tr>
<tr><td><code id="exmWt.2ipd_+3A_mean.constrained">mean.constrained</code></td>
<td>
<p>whether to restrict the weighted means to be within the ranges of observed means. Default is FALSE. When it is TRUE, there is a higher chance of not having a solution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If dummy variables are already created for the categorical variables in the data set, and are present in <code>ipd1</code> and <code>ipd2</code>, then <code>cat_vars_to_01</code> should be left as NULL.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ipd1</code></td>
<td>
<p>re-scaled weights of the exact matching by maximizing ESS for IPD 1, and the input IPD 1 data with categorical variables converted to 0-1 indicators</p>
</td></tr>
<tr><td><code>ipd2</code></td>
<td>
<p>re-scaled weights of the exact matching by maximizing ESS for IPD 2, and the input IPD 2 data with categorical variables converted to 0-1 indicators</p>
</td></tr>
<tr><td><code>wtd.summ</code></td>
<td>
<p>ESS for IPD 1, ESS for IPD 2, and weighted means of the matching variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lillian Yau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ipd1 &lt;- sim110[sim110$study == 'IPD A',]
ipd2 &lt;- sim110[sim110$study == 'IPD B',]
x &lt;- exmWt.2ipd(ipd1, ipd2, vars_to_match = paste0('X', 1:5), 
cat_vars_to_01 = paste0('X', 1:3), mean.constrained = FALSE) 

## End(Not run)
</code></pre>

<hr>
<h2 id='maicLP'>Checks if AD is within the convex hull of IPD using lp-solve</h2><span id='topic+maicLP'></span>

<h3>Description</h3>

<p>Checks if AD is within the convex hull of IPD using lp-solve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maicLP(ipd, ad)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maicLP_+3A_ipd">ipd</code></td>
<td>
<p>a dataframe with n row and p column, where n is number of subjects and p is the number of variables used in matching.</p>
</td></tr>
<tr><td><code id="maicLP_+3A_ad">ad</code></td>
<td>
<p>a dataframe with 1 row and p column. The matching variables should be in the same order as that in <code>ipd</code>. The function does not check this.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>lp.check</code></td>
<td>
<p>0 = AD is inside IPD, and MAIC can be conducted; 2 = otherwise</p>
</td></tr>
</table>


<h3>References</h3>

<p>Glimm &amp; Yau (2021). &quot;Geometric approaches to assessing the numerical feasibility for conducting matching-adjusted indirect comparisons&quot;, Pharmaceutical Statistics, 21(5):974-987. doi:10.1002/pst.2210.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## eAD[1,] is the scenario A in the reference paper,
## i.e. when AD is within IPD convex hull
maicLP(eIPD, eAD[1,2:3])

## eAD[3,] is the scenario C in the reference paper,
## i.e. when AD is outside IPD convex hull
maicLP(eIPD, eAD[3,2:3])
</code></pre>

<hr>
<h2 id='maicMD'>Checks if AD is within the convex hull of IPD using Mahalanobis distance</h2><span id='topic+maicMD'></span>

<h3>Description</h3>

<p>Should only be used when all matching variables are normally distributed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maicMD(ipd, ad, n.ad = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maicMD_+3A_ipd">ipd</code></td>
<td>
<p>a dataframe with n row and p column, where n is number of subjects and p is the number of variables used in matching.</p>
</td></tr>
<tr><td><code id="maicMD_+3A_ad">ad</code></td>
<td>
<p>a dataframe with 1 row and p column. The matching variables should be in the same order as that in <code>ipd</code>. The function does not check this.</p>
</td></tr>
<tr><td><code id="maicMD_+3A_n.ad">n.ad</code></td>
<td>
<p>default is Inf assuming <code>ad</code> is a fixed (known) quantity with infinit accuracy. In most MAIC applications <code>ad</code> is only the sample statistics and n.ad is known.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When AD does not have the largest Mahalanobis distance, in the original scale AD can still be outside of the IPD convex hull. On the other hand, when AD does have the largest Mahalanobis distance, in the original scale, AD is for sure outside the IPD convex hull.
</p>


<h3>Value</h3>

<p>Prints a message whether AD is furthest away from 0, i.e. IPD center in terms of Mahalanobis distance. Also returns ggplot object for plotting.
</p>
<table role = "presentation">
<tr><td><code>md.dplot</code></td>
<td>
<p>dot-plot of AD and IPD in Mahalanobis distance</p>
</td></tr>
<tr><td><code>md.check</code></td>
<td>
<p>0 = AD has the largest Mahalanobis distance to the IPD center; 2 = otherwise</p>
</td></tr>
</table>


<h3>References</h3>

<p>Glimm &amp; Yau (2021). &quot;Geometric approaches to assessing the numerical feasibility for conducting matching-adjusted indirect comparisons&quot;, Pharmaceutical Statistics, 21(5):974-987. doi:10.1002/pst.2210.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## eAD[1,] is the scenario A in the reference paper,
## i.e. when AD is perfectly within IPD
md &lt;- maicMD(eIPD, eAD[1,2:3])
md ## a dot-plot of IPD Mahalanobis distances along with AD in the same metric.

## End(Not run)
</code></pre>

<hr>
<h2 id='maicPCA'>Checks whether AD is outside IPD in PC coordinates</h2><span id='topic+maicPCA'></span>

<h3>Description</h3>

<p>Checks whether AD is outside IPD in principal component (PC) coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maicPCA(ipd, ad)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maicPCA_+3A_ipd">ipd</code></td>
<td>
<p>a dataframe with n row and p column, where n is number of subjects in IPD set and p is the number of variables used in matching.</p>
</td></tr>
<tr><td><code id="maicPCA_+3A_ad">ad</code></td>
<td>
<p>a dataframe with 1 row and p column. The matching variables should be in the same order as that in <code>ipd</code>. The function does not check this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When AD is within the IPD PC ranges, AD can still be outside the IPD convex hull in the original scale. On the other hand, if AD is outside the IPD PC ranges, in the original scale AD is for sure outside the IPD convex hull.
</p>


<h3>Value</h3>

<p>Prints a message whether AD is inside or outside IPD PC coordinates. Also returns a ggplot object to be plotted.
</p>
<table role = "presentation">
<tr><td><code>pc.dplot</code></td>
<td>
<p>dot-plot of AD and IPD both in IPD's PC coordinates</p>
</td></tr>
<tr><td><code>pca.check</code></td>
<td>
<p>0 = AD within the ranges of IPD's PC coordinates; 2 = otherwise</p>
</td></tr>
</table>


<h3>References</h3>

<p>Glimm &amp; Yau (2021). &quot;Geometric approaches to assessing the numerical feasibility for conducting matching-adjusted indirect comparisons&quot;, Pharmaceutical Statistics, 21(5):974-987. doi:10.1002/pst.2210.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## eAD[1,] is the scenario A in the reference paper,
## i.e. when AD is perfectly within IPD
a1 &lt;- maicPCA(eIPD, eAD[1,2:3])
a1 ## the dot plots of PC's for IPD and AD

## eAD[3,] is the scenario C in the reference paper,
## i.e. when AD is outside IPD
a3 &lt;- maicPCA(eIPD, eAD[3,2:3])
a3 ## the dot plots of PC's for IPD and AD

## End(Not run)
</code></pre>

<hr>
<h2 id='maicT2Test'>Hotelling's T-square test to check whether maic is needed</h2><span id='topic+maicT2Test'></span>

<h3>Description</h3>

<p>Hotelling's T-square test to check whether maic is needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maicT2Test(ipd, ad, n.ad = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maicT2Test_+3A_ipd">ipd</code></td>
<td>
<p>a dataframe with n row and p column, where n is number of subjects and p is the number of variables used in matching.</p>
</td></tr>
<tr><td><code id="maicT2Test_+3A_ad">ad</code></td>
<td>
<p>a dataframe with 1 row and p column. The matching variables should be in the same order as that in <code>ipd</code>. The function does not check this.</p>
</td></tr>
<tr><td><code id="maicT2Test_+3A_n.ad">n.ad</code></td>
<td>
<p>default is Inf assuming <code>ad</code> is a fixed (known) quantity with infinit accuracy. In most MAIC applications <code>ad</code> is the sample statistics and <code>n.ad</code> is known.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>n.ad</code> is not Inf, the covariance matrix is adjusted by the factor n.ad/(n.ipd + n.ad)), where n.ipd is nrow(ipd), the sample size of <code>ipd</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>T.sq.f</code></td>
<td>
<p>the value of the T^2 test statistic</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>the p-value corresponding to the test statistic. When the p-value is small, matching is necessary.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Glimm &amp; Yau (2021). &quot;Geometric approaches to assessing the numerical feasibility for conducting matching-adjusted indirect comparisons&quot;, Pharmaceutical Statistics, 21(5):974-987. doi:10.1002/pst.2210.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## eAD[1,] is the scenario A in the reference paper,
## i.e. when AD is perfectly within IPD
maicT2Test(eIPD, eAD[1,2:3])
</code></pre>

<hr>
<h2 id='maicWt'>Estimates the MAIC weights</h2><span id='topic+maicWt'></span>

<h3>Description</h3>

<p>Estimates the MAIC weights for each individual in the IPD. Should only be used after it is ascertained that AD is indeed within the convex hull of IPD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maicWt(ipd, ad, max.it = 25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maicWt_+3A_ipd">ipd</code></td>
<td>
<p>a dataframe with n row and p column, where n is number of subjects and p is the number of variables used in matching.</p>
</td></tr>
<tr><td><code id="maicWt_+3A_ad">ad</code></td>
<td>
<p>a dataframe with 1 row and p coln. The matching variables should be in the same order as that in <code>ipd</code>. The function does not check this.</p>
</td></tr>
<tr><td><code id="maicWt_+3A_max.it">max.it</code></td>
<td>
<p>maximum iteration passed to optim(). if <code>ad</code> is within <code>ipd</code> convex hull, then the default 25 iterations of optim() should be enough.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The main code are taken from Philippo (2016). It returns the following:
</p>
<table role = "presentation">
<tr><td><code>optim.out</code></td>
<td>
<p>results of optim()</p>
</td></tr>
<tr><td><code>maic.wt</code></td>
<td>
<p>MAIC un-scaled weights for each subject in the IPD set</p>
</td></tr>
<tr><td><code>maic.wt.rs</code></td>
<td>
<p>re-scaled weights which add up to the original total sample size, i.e. nrow(ipd)</p>
</td></tr>
<tr><td><code>ipd.ess</code></td>
<td>
<p>effective sample size</p>
</td></tr>
<tr><td><code>ipd.wtsumm</code></td>
<td>
<p>weighted summary statistics of the matching variables after matching. they should be identical to the input AD when AD is within the IPD convex hull.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Phillippo DM, Ades AE, Dias S, et al. (2016). Methods for population-adjusted indirect comparisons in submissions to NICE. NICE Decision Support Unit Technical Support Document 18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## eAD[1,] is scenario A in the reference manuscript
m1 &lt;- maicWt(eIPD, eAD[1,2:3])
</code></pre>

<hr>
<h2 id='maxessWt'>Maximum ESS Weights</h2><span id='topic+maxessWt'></span>

<h3>Description</h3>

<p>Estimates an alternative set of weights which maximizes effective sample size (ESS) for a given set of variates used in the matching. Should only be used after it is ascertained that AD is indeed within the convex hull of IPD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxessWt(ipd, ad)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxessWt_+3A_ipd">ipd</code></td>
<td>
<p>a dataframe with n row and p column, where n is number of subjects and p is the number of variables used in matching.</p>
</td></tr>
<tr><td><code id="maxessWt_+3A_ad">ad</code></td>
<td>
<p>a dataframe with 1 row and p column. The matching variables should be in the same order as that in <code>ipd</code>. The function does not check this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weights maximize the ESS subject to the set of baseline covariates used in the matching.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>maxess.wt</code></td>
<td>
<p>maximum ESS weights. Scaled to sum up to the total IPD sample size, i.e. nrow(ipd)</p>
</td></tr>
<tr><td><code>ipd.ess</code></td>
<td>
<p>effective sample size. It is no smaller than the ESS given by the MAIC weights.</p>
</td></tr>
<tr><td><code>ipd.wtsumm</code></td>
<td>
<p>weighted summary statistics of the matching variables after matching. they should be identical to the input AD when AD is within the IPD convex hull.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Glimm &amp; Yau (2021). &quot;Geometric approaches to assessing the numerical feasibility for conducting matching-adjusted indirect comparisons&quot;, Pharmaceutical Statistics, 21(5):974-987. doi:10.1002/pst.2210.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## eAD[1,] is scenario A in the reference manuscript
m0 &lt;- maxessWt(eIPD, eAD[1,2:3])
</code></pre>

<hr>
<h2 id='sim110'>Simulated data used for exact matching</h2><span id='topic+sim110'></span>

<h3>Description</h3>

<p>sim110 is one of the simulated data presented in the simulation study in Glimm &amp; Yau (2025).The covariates used in matching are X1 to X15. A response variable Y is simulated to depend on 6 of the 15 covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sim110)
</code></pre>


<h3>Format</h3>


<dl>
<dt>X1 to X15</dt><dd><p>Covariates used in matching</p>
</dd>
<dt>Y</dt><dd><p>Response variable</p>
</dd>
<dt>study</dt><dd><p>IPD A and IPD B</p>
</dd>
</dl>



<h3>References</h3>

<p>Glimm &amp; Yau (2025)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim110)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
