<!DOCTYPE html><html><head><title>Help for package taxonbridge</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {taxonbridge}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#annotate'><p>Annotate a custom taxonomy</p></a></li>
<li><a href='#dedupe'><p>Remove duplicate scientific names in a taxonomy</p></a></li>
<li><a href='#download_gbif'><p>Download the GBIF backbone taxonomy</p></a></li>
<li><a href='#download_ncbi'><p>Download the NCBI taxonomy</p></a></li>
<li><a href='#fuzzy_search'><p>Match misspelled or partial scientific names</p></a></li>
<li><a href='#get_inconsistencies'><p>Detect candidate inconsistencies and ambiguity between NCBI and GBIF data</p></a></li>
<li><a href='#get_lineages'><p>Get entries that have lineage information for both the GBIF and NCBI data</p></a></li>
<li><a href='#get_status'><p>Filter a custom taxonomy by GBIF taxonomic status/synonym</p></a></li>
<li><a href='#get_taxa'><p>A helper function to filter on GBIF and NCBI taxa names</p></a></li>
<li><a href='#get_validity'><p>Validate entries of a merged taxonomy</p></a></li>
<li><a href='#load_population'><p>Load previously merged GBIF and NCBI taxonomies</p></a></li>
<li><a href='#load_sample'><p>Load an example of previously merged GBIF and NCBI taxonomies</p></a></li>
<li><a href='#load_taxonomies'><p>Load and merge GBIF and NCBI taxonomic data</p></a></li>
<li><a href='#plot_mdb'><p>Generic for plot_mdb methods</p></a></li>
<li><a href='#prepare_comparable_rank_dist'><p>Get comparable NCBI and GBIF taxonomic ranks</p></a></li>
<li><a href='#prepare_rank_dist'><p>Get all NCBI and GBIF taxonomic ranks</p></a></li>
<li><a href='#term_conversion'><p>Convert GBIF terms to NCBI terms</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Create Custom Taxonomies Based on the NCBI Taxonomy and GBIF
Backbone Taxonomy</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The NCBI taxonomy is a popular resource for taxonomic studies but it only contains
    data on species with sequence data whereas the GBIF has a more extensive coverage of
    extinct species. Taxonbridge is useful for the creation and analysis of custom taxonomies
    based on the NCBI taxonomy and GBIF backbone taxonomy.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MoultDB/taxonbridge">https://github.com/MoultDB/taxonbridge</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MoultDB/taxonbridge/issues">https://github.com/MoultDB/taxonbridge/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>purrr, dplyr, vroom, ggplot2, rje, withr, utils, stringr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-04 11:45:33 UTC; wernerveldsman</td>
</tr>
<tr>
<td>Author:</td>
<td>Werner Veldsman <a href="https://orcid.org/0000-0001-9837-8332"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Giulia Campli [aut],
  Sagane Dind [aut],
  Valentine Rech de Laval
    <a href="https://orcid.org/0000-0002-3020-1490"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Harriet Drage <a href="https://orcid.org/0000-0002-0759-5970"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Robert Waterhouse <a href="https://orcid.org/0000-0003-4199-9052"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Marc Robinson-Rechavi
    <a href="https://orcid.org/0000-0001-9837-8332"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Werner Veldsman &lt;wernerpieter.veldsman@unil.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-04 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='annotate'>Annotate a custom taxonomy</h2><span id='topic+annotate'></span>

<h3>Description</h3>

<p>Annotate a custom taxonomy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate(x, names, new_column, present = "1", absent = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_+3A_x">x</code></td>
<td>
<p>A tibble with taxonomic data to be annotated.</p>
</td></tr>
<tr><td><code id="annotate_+3A_names">names</code></td>
<td>
<p>A character vector containing scientific names that will be matched to scientific names in <code>x</code>.</p>
</td></tr>
<tr><td><code id="annotate_+3A_new_column">new_column</code></td>
<td>
<p>A string to be the name of a new column that will contain annotations.</p>
</td></tr>
<tr><td><code id="annotate_+3A_present">present</code></td>
<td>
<p>A string with the annotation in the case of a match (Defaults to &quot;1&quot;).</p>
</td></tr>
<tr><td><code id="annotate_+3A_absent">absent</code></td>
<td>
<p>A string with the annotation in case of no match (Defaults to NA).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method takes as input a character vector with scientific names. If the
scientific name(s) in the vector match with scientific names in the tibble, a new
column will be created and an annotation of choice will be added to the relevant row
in the new column. This method is useful for annotating scientific names with identified
ambiguity, duplication or any other characteristic. The character vector could, for example,
even contain scientific names that have not been derived with a Taxonbridge method.
</p>


<h3>Value</h3>

<p>A tibble that contains an additional column with annotations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample &lt;- load_sample()
lineages &lt;- get_lineages(sample)
kingdom &lt;- get_validity(lineages, rank = "kingdom", valid = FALSE)
family &lt;- get_validity(lineages, rank = "family", valid = FALSE)
candidates &lt;- list(kingdom, family)
binomials &lt;- get_inconsistencies(candidates, uninomials = FALSE, set = "intersect")
x &lt;- annotate(sample, binomials, new_column = "inconsistencies", "Accepted but ambigious")
x[!is.na(x$inconsistencies),c("inconsistencies")]
</code></pre>

<hr>
<h2 id='dedupe'>Remove duplicate scientific names in a taxonomy</h2><span id='topic+dedupe'></span>

<h3>Description</h3>

<p>Remove duplicate scientific names in a taxonomy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dedupe(x, ranked = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dedupe_+3A_x">x</code></td>
<td>
<p>A tibble created with <code>load_taxonomies()</code> or <code>load_population()</code> or <code>load_sample()</code>.</p>
</td></tr>
<tr><td><code id="dedupe_+3A_ranked">ranked</code></td>
<td>
<p>A logical indicating whether duplicates should be removed by certainty
of taxonomic status. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method can be used in one of two ways. By simply passing a tibble as input,
duplicates will be stringently removed based on the following order: &quot;accepted&quot;, &quot;synonym&quot;,&quot;homotypic synonym&quot;,
&quot;heterotypic synonym&quot;, &quot;proparte synonym&quot;,&quot;doubtful&quot;, NA. If however the ranked parameter is set to <code>FALSE</code>,
duplicates will only be removed based on the scientific names, but not on taxonomic status, which results
in less duplicates being removed.
</p>


<h3>Value</h3>

<p>A de-duplicated tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dedupe(load_sample())
</code></pre>

<hr>
<h2 id='download_gbif'>Download the GBIF backbone taxonomy</h2><span id='topic+download_gbif'></span>

<h3>Description</h3>

<p>Download the GBIF backbone taxonomy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_gbif()
</code></pre>


<h3>Details</h3>

<p>This method downloads the GBIF backbone taxonomy archive file to a temporary directory,
extracts <code>Taxon.tsv</code> from the downloaded archive file, and then removes the archive file.
</p>


<h3>Value</h3>

<p>A string containing the path to <code>Taxon.tsv</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: download_gbif()
</code></pre>

<hr>
<h2 id='download_ncbi'>Download the NCBI taxonomy</h2><span id='topic+download_ncbi'></span>

<h3>Description</h3>

<p>Download the NCBI taxonomy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_ncbi(taxonkitpath = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_ncbi_+3A_taxonkitpath">taxonkitpath</code></td>
<td>
<p>A string containing the full path to where <code>Taxonkit</code> is installed (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method downloads a NCBI taxonomy archive file to a temporary directory,
extracts four files (<code>nodes.dmp</code>, <code>names.dmp</code>, <code>merged.dmp</code> and <code>delnodes.dmp</code>)
from the downloaded archive file, and then removes the archive file. Further parsing of
these four files must be carried out with Taxonkit (<a href="https://bioinf.shenwei.me/taxonkit/download/">https://bioinf.shenwei.me/taxonkit/download/</a>),
either automatically or manually. If the path to a Taxonkit installation is supplied, Taxonkit is
called and the location of the four files is passed to Taxonkit as an argument for automatic parsing.
Taxonkit output is saved in the same temporary folder in a file called <code>All.lineages.tsv.gz</code>.
If the path to Taxonkit is not supplied, parsing should be carried out manually using the command:
<code style="white-space: pre;">&#8288;taxonkit list --data-dir=path/to/downloaded/files --ids 1 | taxonkit lineage --show-lineage-taxids --show-lineage-ranks --show-rank --show-name --data-dir=path/to/downloaded/files | taxonkit reformat --taxid-field 1 --data-dir=path/to/downloaded/files -o All.lineages.tsv.gz&#8288;</code>
</p>


<h3>Value</h3>

<p>A character vector containing paths to the relevant downloaded and unzipped NCBI data dump files, or
if the <code>taxonkitpath</code> parameter was set, the path to <code>All.lineages.tsv.gz</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: download_ncbi()
## Not run: download_ncbi(taxonkitpath = "/home/usr/bin/taxonkit")
</code></pre>

<hr>
<h2 id='fuzzy_search'>Match misspelled or partial scientific names</h2><span id='topic+fuzzy_search'></span>

<h3>Description</h3>

<p>Match misspelled or partial scientific names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzy_search(
  x,
  term,
  sensitivity = 0,
  allow_term_removal = FALSE,
  force_binomial = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuzzy_search_+3A_x">x</code></td>
<td>
<p>A tibble created with <code>load_taxonomies()</code> or <code>load_population()</code> or <code>load_sample()</code>.</p>
</td></tr>
<tr><td><code id="fuzzy_search_+3A_term">term</code></td>
<td>
<p>A string consisting of a scientific name.</p>
</td></tr>
<tr><td><code id="fuzzy_search_+3A_sensitivity">sensitivity</code></td>
<td>
<p>An integer representing character mismatch tolerance. Defaults to intolerant i.e. sensitivity=0.</p>
</td></tr>
<tr><td><code id="fuzzy_search_+3A_allow_term_removal">allow_term_removal</code></td>
<td>
<p>A logical indicating whether searches against only the first word of <code>term</code>
should be carried out if no matches are found. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="fuzzy_search_+3A_force_binomial">force_binomial</code></td>
<td>
<p>A logical indicating whether <code>term</code> should be stripped
to a maximum of two words. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sensitivity</code> parameter sets the number of character mismatches that are tolerated for
a match to be reported. The higher the sensitivity, the more matches will be found, but the
less relevant they may be. The <code>allow_term_removal</code> parameter allows stripping the search query
to only retain the characters before the first occurrence of a white space i.e. only the first
word of a search query is used during the search. This is useful when &quot;Genus sp.&quot; or &quot;Genus indet.&quot; is
the search query. However, <code>fuzzy_search()</code> will always search using the entire search query first and
then only proceed to strip terms if no hits are found. On the other hand, if <code>force_binomial</code> is set to TRUE,
the search query will first be limited to the first two words before searching commences. This in turn is useful
if the search query includes credit to the publisher e.g. &quot;Birgus latro (Linnaeus, 1767)&quot; or to
prevent subspecies names (so-called trinomials) from leading to a match not being made.
</p>


<h3>Value</h3>

<p>A list of candidate match(es), if applicable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fuzzy_search(load_sample(), "Miacis deutschi")
fuzzy_search(load_sample(), "Miacis sp.", allow_term_removal = TRUE)
fuzzy_search(load_sample(), "Miacus deutschi", sensitivity = 1)
fuzzy_search(load_sample(), "Miacis deutschi (Smith, 2022)", force_binomial = TRUE)
</code></pre>

<hr>
<h2 id='get_inconsistencies'>Detect candidate inconsistencies and ambiguity between NCBI and GBIF data</h2><span id='topic+get_inconsistencies'></span>

<h3>Description</h3>

<p>Detect candidate inconsistencies and ambiguity between NCBI and GBIF data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_inconsistencies(x, uninomials = TRUE, set = "intersect")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_inconsistencies_+3A_x">x</code></td>
<td>
<p>A <strong>list</strong> consisting of two tibbles of different ranks that have been passed to <code>get_validated(..., rank = ...)</code>.</p>
</td></tr>
<tr><td><code id="get_inconsistencies_+3A_uninomials">uninomials</code></td>
<td>
<p>A logical indicating whether uninomials should be included in the detection. Defaults to TRUE.
Note: uninomials are single names (e.g., &quot;Coenobitidae&quot;).</p>
</td></tr>
<tr><td><code id="get_inconsistencies_+3A_set">set</code></td>
<td>
<p>The type of set operation to be performed on <code>x</code> (&quot;intersect&quot;, &quot;union&quot;, or &quot;setdiff&quot;).
Defaults to intersect. Note: the set difference (&quot;setdiff&quot;) argument is order dependent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method will return the intersect, union, or set difference of a list of two
tibbles, and is meant to be used on lists of tibbles that have already been
processed with <code>get_validity()</code>. A list consisting of a single tibble may be passed to this method for the
purpose of retrieving a character vector containing scientific names, however, set operations do not apply
to lists consisting of single tibbles.
</p>


<h3>Value</h3>

<p>A character vector containing scientific names that exhibit inconsistency or ambiguity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample &lt;- load_sample()
lineages &lt;- get_lineages(sample)
kingdom &lt;- get_validity(lineages, rank = "kingdom", valid = FALSE)
family &lt;- get_validity(lineages, rank = "family", valid = FALSE)
candidates &lt;- list(kingdom, family)
get_inconsistencies(candidates, uninomials = FALSE, set = "intersect")
</code></pre>

<hr>
<h2 id='get_lineages'>Get entries that have lineage information for both the GBIF and NCBI data</h2><span id='topic+get_lineages'></span>

<h3>Description</h3>

<p>Get entries that have lineage information for both the GBIF and NCBI data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lineages(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_lineages_+3A_x">x</code></td>
<td>
<p>A tibble created with <code>load_taxonomies()</code> or <code>load_population()</code> or <code>load_sample()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with complete lineage data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_lineages(load_sample())
</code></pre>

<hr>
<h2 id='get_status'>Filter a custom taxonomy by GBIF taxonomic status/synonym</h2><span id='topic+get_status'></span>

<h3>Description</h3>

<p>Filter a custom taxonomy by GBIF taxonomic status/synonym
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_status(x, status = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_status_+3A_x">x</code></td>
<td>
<p>A tibble created with <code>load_taxonomies()</code> or <code>load_population()</code> or <code>load_sample()</code>.</p>
</td></tr>
<tr><td><code id="get_status_+3A_status">status</code></td>
<td>
<p>Filter on GBIF assigned status (i.e. NA, &quot;doubtful&quot;, &quot;accepted&quot;, &quot;proparte synonym&quot;, &quot;synonym&quot;, &quot;homotypic synonym&quot;,
&quot;heterotypic synonym&quot;). Can be a string or a vector of strings. Defaults to no filtering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered tibble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_status(load_sample(), "synonym")
get_status(load_sample(), c("accepted", "doubtful"))
</code></pre>

<hr>
<h2 id='get_taxa'>A helper function to filter on GBIF and NCBI taxa names</h2><span id='topic+get_taxa'></span>

<h3>Description</h3>

<p>A helper function to filter on GBIF and NCBI taxa names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxa(
  x,
  kingdom = NA,
  phylum = NA,
  class = NA,
  order = NA,
  family = NA,
  genus = NA,
  species = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_taxa_+3A_x">x</code></td>
<td>
<p>A tibble created with <code>load_taxonomies()</code> or <code>load_population()</code> or <code>load_sample()</code>.</p>
</td></tr>
<tr><td><code id="get_taxa_+3A_kingdom">kingdom</code></td>
<td>
<p>A string consisting of a scientific name.</p>
</td></tr>
<tr><td><code id="get_taxa_+3A_phylum">phylum</code></td>
<td>
<p>A string consisting of a scientific name.</p>
</td></tr>
<tr><td><code id="get_taxa_+3A_class">class</code></td>
<td>
<p>A string consisting of a scientific name.</p>
</td></tr>
<tr><td><code id="get_taxa_+3A_order">order</code></td>
<td>
<p>A string consisting of a scientific name.</p>
</td></tr>
<tr><td><code id="get_taxa_+3A_family">family</code></td>
<td>
<p>A string consisting of a scientific name.</p>
</td></tr>
<tr><td><code id="get_taxa_+3A_genus">genus</code></td>
<td>
<p>A string consisting of a scientific name.</p>
</td></tr>
<tr><td><code id="get_taxa_+3A_species">species</code></td>
<td>
<p>A string consisting of a scientific name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method will return results if the scientific name of interest is
found in either the GBIF or the NCBI. The scientific name does not have to be
case sensitive.
</p>


<h3>Value</h3>

<p>A filtered tibble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_taxa(load_sample(), species = "hyalina")
get_taxa(load_sample(), phylum = "ArthroPODA", genus = "BirGus")
</code></pre>

<hr>
<h2 id='get_validity'>Validate entries of a merged taxonomy</h2><span id='topic+get_validity'></span>

<h3>Description</h3>

<p>Validate entries of a merged taxonomy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_validity(x, rank = "family", valid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_validity_+3A_x">x</code></td>
<td>
<p>A tibble created with <code>load_taxonomies()</code> or <code>load_population()</code> or <code>load_sample()</code>.</p>
</td></tr>
<tr><td><code id="get_validity_+3A_rank">rank</code></td>
<td>
<p>A string with GBIF rank that will be used to examine a NCBI lineage for validation purposes. Must
be kingdom, phylum, class, order or family. Defaults to family. Note: If kingdom is used, the
term_conversion() method should first be applied.</p>
</td></tr>
<tr><td><code id="get_validity_+3A_valid">valid</code></td>
<td>
<p>A logical indicating whether the returned data should include valid or invalid
entries (defaults to TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taxonbridge matches NCBI and GBIF data by scientific name. This method will use the GBIF rank
(kingdom, phylum, class, order or family) and search for this rank name in the matched NCBI
lineage. The purpose is to detect scientific names that have different lineage
data in the GBIF and NCBI. If the <code>valid</code> parameter is set to TRUE, this method will
not only check the rank names, but also ensure that the GBIF <code>taxonRank</code> column and
NCBI <code>ncbi_rank</code> column matches.
</p>


<h3>Value</h3>

<p>A validated tibble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_validity(load_sample(), valid = TRUE)
</code></pre>

<hr>
<h2 id='load_population'>Load previously merged GBIF and NCBI taxonomies</h2><span id='topic+load_population'></span>

<h3>Description</h3>

<p>Load previously merged GBIF and NCBI taxonomies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_population(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_population_+3A_x">x</code></td>
<td>
<p>Path to a text file containing previously merged NCBI and GBIF taxonomies (compressed or uncompressed).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method imports a previously merged taxonomy from your file system. An
example of a previously merged taxonomy can be downloaded
from <a href="https://drive.google.com/file/d/1gpvm9QKdOcuGo_cIXPkAgGlB-qfKZZU6/view?usp=sharing">https://drive.google.com/file/d/1gpvm9QKdOcuGo_cIXPkAgGlB-qfKZZU6/view?usp=sharing</a>.
</p>


<h3>Value</h3>

<p>A tibble containing merged GBIF and NCBI taxonomic data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: load_population("path/to/merged_taxonomies")
</code></pre>

<hr>
<h2 id='load_sample'>Load an example of previously merged GBIF and NCBI taxonomies</h2><span id='topic+load_sample'></span>

<h3>Description</h3>

<p>Load an example of previously merged GBIF and NCBI taxonomies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_sample()
</code></pre>


<h3>Details</h3>

<p>This method returns a small subset of previously merged GBIF and NCBI taxonomies. The
subset is an example dataset that is only meant to be used to familiarize yourself
with <code>taxonbridge</code> methods.
</p>


<h3>Value</h3>

<p>A tibble containing a sample of merged GBIF and NCBI taxonomic data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_sample()
</code></pre>

<hr>
<h2 id='load_taxonomies'>Load and merge GBIF and NCBI taxonomic data</h2><span id='topic+load_taxonomies'></span>

<h3>Description</h3>

<p>Load and merge GBIF and NCBI taxonomic data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_taxonomies(GBIF_path, NCBI_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_taxonomies_+3A_gbif_path">GBIF_path</code></td>
<td>
<p>Path to the GBIF backbone taxonomy (compressed or uncompressed).</p>
</td></tr>
<tr><td><code id="load_taxonomies_+3A_ncbi_path">NCBI_path</code></td>
<td>
<p>Path to the NCBI taxonomy (compressed or uncompressed).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method merges a GBIF <code>Taxon.tsv</code> file (see <code>download_gbif()</code>) and
a Taxonkit (<a href="https://bioinf.shenwei.me/taxonkit/download/">https://bioinf.shenwei.me/taxonkit/download/</a>) output file (see <code>download_ncbi()</code>).
</p>


<h3>Value</h3>

<p>A tibble containing merged GBIF and NCBI taxonomic data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: load_taxonomies("path/to/GBIF/Taxon.tsv","path/to/NCBI-Taxonkit/All.lineages.tsv.gz")
## Not run: load_taxonomies(download_gbif(), download_ncbi(taxonkitpath = "/path/to/taxonkit"))
</code></pre>

<hr>
<h2 id='plot_mdb'>Generic for plot_mdb methods</h2><span id='topic+plot_mdb'></span>

<h3>Description</h3>

<p>Generic for plot_mdb methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mdb(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mdb_+3A_x">x</code></td>
<td>
<p>An object of the class one_rank or the class all_ranks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A generic with methods that plot <code>taxonbridge</code> data types (<code>one_rank</code> and <code>all_ranks</code>). These
data types are created by using the methods <code>prepare_rank_dist()</code> or <code>prepare_comparable_rank_dist()</code>.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> derived plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_mdb(prepare_rank_dist(load_sample(), NCBI = TRUE, GBIF = TRUE))
plot_mdb(prepare_comparable_rank_dist(load_sample()))
plot_mdb(prepare_rank_dist(get_status(load_sample(),status = "synonym"), NCBI = TRUE))
plot_mdb(prepare_comparable_rank_dist(get_validity(get_status(load_sample()), valid = TRUE)))
</code></pre>

<hr>
<h2 id='prepare_comparable_rank_dist'>Get comparable NCBI and GBIF taxonomic ranks</h2><span id='topic+prepare_comparable_rank_dist'></span>

<h3>Description</h3>

<p>Get comparable NCBI and GBIF taxonomic ranks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_comparable_rank_dist(x, GBIF = TRUE, NCBI = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_comparable_rank_dist_+3A_x">x</code></td>
<td>
<p>A tibble created with <code>load_taxonomies()</code> or <code>load_population()</code> or <code>load_sample()</code>.</p>
</td></tr>
<tr><td><code id="prepare_comparable_rank_dist_+3A_gbif">GBIF</code></td>
<td>
<p>A logical indicating whether GBIF taxonomic ranks are to be retrieved.</p>
</td></tr>
<tr><td><code id="prepare_comparable_rank_dist_+3A_ncbi">NCBI</code></td>
<td>
<p>A logical indicating whether NCBI taxonomic ranks are to be retrieved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method, like <code>prepare_rank_dist()</code>, returns taxonomic ranks aggregated by frequency for
data derived from the NCBI, the GBIF, or both. However, this method only retains
taxonomic ranks that have at least one NCBI and one GBIF representative.
</p>


<h3>Value</h3>

<p>A list of tibble(s) assigned to the S3 class <code>one_rank</code> or to the S3 class <code>all_ranks</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prepare_comparable_rank_dist(load_sample())
prepare_comparable_rank_dist(get_status(load_sample(), "accepted"), NCBI = FALSE)
</code></pre>

<hr>
<h2 id='prepare_rank_dist'>Get all NCBI and GBIF taxonomic ranks</h2><span id='topic+prepare_rank_dist'></span>

<h3>Description</h3>

<p>Get all NCBI and GBIF taxonomic ranks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_rank_dist(x, GBIF = FALSE, NCBI = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_rank_dist_+3A_x">x</code></td>
<td>
<p>A tibble created with <code>load_taxonomies()</code> or <code>load_population()</code> or <code>load_sample()</code>.</p>
</td></tr>
<tr><td><code id="prepare_rank_dist_+3A_gbif">GBIF</code></td>
<td>
<p>A logical indicating whether GBIF taxonomic ranks are to be retrieved.</p>
</td></tr>
<tr><td><code id="prepare_rank_dist_+3A_ncbi">NCBI</code></td>
<td>
<p>A logical indicating whether NCBI taxonomic ranks are to be retrieved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method returns taxonomic ranks aggregated by frequency for
data derived from the NCBI, the GBIF, or both.
</p>


<h3>Value</h3>

<p>A list of tibble(s) assigned to the S3 class <code>one_rank</code> or to the S3 class <code>all_ranks</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prepare_rank_dist(load_sample(), NCBI=TRUE, GBIF=TRUE)
prepare_rank_dist(load_sample(), NCBI=TRUE)
</code></pre>

<hr>
<h2 id='term_conversion'>Convert GBIF terms to NCBI terms</h2><span id='topic+term_conversion'></span>

<h3>Description</h3>

<p>Convert GBIF terms to NCBI terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_conversion(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="term_conversion_+3A_x">x</code></td>
<td>
<p>A tibble created with <code>load_taxonomies()</code> or <code>load_population()</code> or <code>load_sample()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method converts GBIF terminology to NCBI terminology where there is
no biological provenance for the difference. Specifically, &quot;Animalia&quot; is converted
to &quot;Metazoa&quot;, and &quot;Plantae&quot; is converted to &quot;Viridiplantae&quot;.
</p>


<h3>Value</h3>

<p>A tibble with converted terms. The tibble is furthermore annotated with the
attribute <code>converted=TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>term_conversion(load_sample())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
