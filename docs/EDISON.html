<!DOCTYPE html><html lang="en"><head><title>Help for package EDISON</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EDISON}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EDISON-package'><p>Allows for network reconstruction and changepoint detection.</p></a></li>
<li><a href='#AcceptableMove'><p>Check if move is acceptable.</p></a></li>
<li><a href='#addProposalNetworkInfo'><p>Add the proposed new network to the new.nets list.</p></a></li>
<li><a href='#BinoHyperMove'><p>Makes a binomial hyperparameter move.</p></a></li>
<li><a href='#BinoHyperRatio'><p>Calculates the MH ratio of the binomial prior.</p></a></li>
<li><a href='#bp.computeAlpha'><p>Computes the acceptance ratio of two changepoint configurations.</p></a></li>
<li><a href='#buildXY'><p>Builds response Y and predictor X.</p></a></li>
<li><a href='#CalculateChanges'><p>Function to calculate the number of differences between adjaccent network</p>
segments.</a></li>
<li><a href='#calculateCPPGlobal'><p>Calculated the global changepoint probabilities.</p></a></li>
<li><a href='#calculateCPProbabilities'><p>Calculate the changepoint probabilities.</p></a></li>
<li><a href='#calculateEdgeProbabilities'><p>Calculate the edge probabilities.</p></a></li>
<li><a href='#calculateEdgeProbabilitiesSegs'><p>Calculate edge probabilities for fixed segments.</p></a></li>
<li><a href='#calculateEdgeProbabilitiesTimePoints'><p>Calculate the edge posterior probabilities for each timepoint.</p></a></li>
<li><a href='#CalculateLikelihoodRatio'><p>Calculates the ratio of two likelihoods in a structure move.</p></a></li>
<li><a href='#CalculatePriorRatio'><p>Calculates the network prior ratio.</p></a></li>
<li><a href='#CollectNetworkInfo'><p>Collects all the network information in one list.</p></a></li>
<li><a href='#computePx'><p>Compute projection matrix.</p></a></li>
<li><a href='#computeRho4'><p>Calculate proposal frequencies for changepoint moves.</p></a></li>
<li><a href='#convert_nets'><p>Convert internal representation of networks.</p></a></li>
<li><a href='#cp.birth'><p>Make changepoint birth move.</p></a></li>
<li><a href='#cp.death'><p>Make changepoint death move.</p></a></li>
<li><a href='#cp.shift'><p>Makes a changepoint shift move.</p></a></li>
<li><a href='#defaultOptions'><p>Set the default options for the MCMC simulation.</p></a></li>
<li><a href='#dinvgamma'><p>Calculate inverse gamma distribution.</p></a></li>
<li><a href='#EDISON.run'><p>Wrapper function for starting an MCMC simulation</p></a></li>
<li><a href='#ExpHyperMove'><p>Makes an exponential hyperparameter move.</p></a></li>
<li><a href='#ExpHyperRatioTarget'><p>Calculates the ratio of an exponential hyperparameter move.</p></a></li>
<li><a href='#fix_eigenvalues'><p>Modify network to ensure stationarity.</p></a></li>
<li><a href='#generateNetwork'><p>Generate a random network.</p></a></li>
<li><a href='#HyperparameterMove'><p>Make a hyperparameter move.</p></a></li>
<li><a href='#HyperParms'><p>Sets up initial values of hyperparameters.</p></a></li>
<li><a href='#init'><p>Initialise the MCMC simulation.</p></a></li>
<li><a href='#main'><p>Main function of the MCMC simulation.</p></a></li>
<li><a href='#make_structure_move'><p>Makes a structure move.</p></a></li>
<li><a href='#NetworkProbBino'><p>Calculates the prior probability of the network segments under the binomial</p>
prior.</a></li>
<li><a href='#NetworkProbExp'><p>Calculates the prior probability of the network using the exponential prior.</p></a></li>
<li><a href='#NetworkRatioBino'><p>Calculates the ratio of binomial prior probabilites.</p></a></li>
<li><a href='#NetworkRatioExp'><p>Calculates the ratio of exponential network prior probabilities.</p></a></li>
<li><a href='#output'><p>Collects and saves output.</p></a></li>
<li><a href='#phase.update'><p>Make a network structure or hyperparameter move.</p></a></li>
<li><a href='#PriorRatioPoisson'><p>Calculate network prior ratio with Poisson prior.</p></a></li>
<li><a href='#proposalTuning'><p>Tune the proposal width for betas.</p></a></li>
<li><a href='#proposeContinuous'><p>Propose a new real hyperparameter value.</p></a></li>
<li><a href='#ProposeDiscrete'><p>Propose a new discrete value.</p></a></li>
<li><a href='#psrf'><p>Calculates the potential scale reduction factor.</p></a></li>
<li><a href='#psrf_check'><p>Check the potential scale reduction factors for all parameters (edges).</p></a></li>
<li><a href='#psrf_check_hyper'><p>Checks the potential scale reduction factor for the hyperparameters.</p></a></li>
<li><a href='#readDataTS'><p>Read target data.</p></a></li>
<li><a href='#rinvgamma'><p>Samples from the inverse gamma distribution.</p></a></li>
<li><a href='#runDBN'><p>Setup and run the MCMC simulation.</p></a></li>
<li><a href='#sampleBinit'><p>Sample initial regression coefficients.</p></a></li>
<li><a href='#sampleBxy'><p>Sample regression coefficients.</p></a></li>
<li><a href='#sampleDelta2'><p>Sample delta squared.</p></a></li>
<li><a href='#sampleK'><p>Sample initial number of changepoints.</p></a></li>
<li><a href='#sampleParms'><p>Sample initial parameters for the MCMC simulation.</p></a></li>
<li><a href='#sampleSig2'><p>Sample initial sigma squared.</p></a></li>
<li><a href='#simulateNetwork'><p>Generate network and simulate data.</p></a></li>
<li><a href='#updateSigMulti'><p>Update sigma squared variances.</p></a></li>
<li><a href='#updateSigSolo'><p>Sample new values for sigma squared.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Network Reconstruction and Changepoint Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-03-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Frank Dondelinger, Sophie Lebre</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frank Dondelinger &lt;fdondelinger.work@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Package EDISON (Estimation of Directed Interactions from
    Sequences Of Non-homogeneous gene expression) runs an MCMC
    simulation to reconstruct networks from time series data, using
    a non-homogeneous, time-varying dynamic Bayesian network.
    Networks segments and changepoints are inferred concurrently,
    and information sharing priors provide a reduction of the
    inference uncertainty.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Depends:</td>
<td>corpcor, MASS</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-03-30 18:25:37 UTC; levendis</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-03-30 21:04:12</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='EDISON-package'>Allows for network reconstruction and changepoint detection.</h2><span id='topic+EDISON'></span><span id='topic+EDISON-package'></span>

<h3>Description</h3>

<p>This package runs an MCMC simulation to reconstruct networks from time
series data, using a non-homogeneous, time-varying dynamic Bayesian network.
Networks segments and changepoints are inferred concurrently, and
information sharing priors provide a reduction of the inference uncertainty.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> EDISON</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.1.1</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2016-03-30</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;"> LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Frank Dondelinger, Sophie Lebre
</p>
<p>Maintainer: Frank Dondelinger &lt;fdondelinger.work@gmail.com&gt;
</p>


<h3>References</h3>

<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian
networks with Bayesian regularization for inferring gene regulatory networks
with gradually time-varying structure&quot;, Machine Learning.
</p>
<p>Husmeier et al. (2010), &quot;Inter-time segment information sharing for
non-homogeneous dynamic Bayesian networks&quot;, NIPS.
</p>


<h3>See Also</h3>

<p><code><a href="corpcor.html#topic+corpcor-package">corpcor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random gene network and simulate data from it
dataset = simulateNetwork(l=25)

# Run MCMC simulation to infer networks and changepoint locations
result = EDISON.run(dataset$sim_data, num.iter=500)

# Calculate posterior probabilities of changepoints
cps = calculateCPProbabilities(result)

# Calculate marginal posterior probabilities of edges in the network
network = calculateEdgeProbabilities(result)


</code></pre>

<hr>
<h2 id='AcceptableMove'>Check if move is acceptable.</h2><span id='topic+AcceptableMove'></span>

<h3>Description</h3>

<p>This function takes as input a new network proposal and checks that the
proposal does not exceed the maximum number of parents for a node, and that
there are no self loops (if self loops have been disallowed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AcceptableMove(proposal, qmax, self.loops, target, fixed.edges)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AcceptableMove_+3A_proposal">proposal</code></td>
<td>
<p>The proposed network (K-by-q matrix with K segments and q
parent sets).</p>
</td></tr>
<tr><td><code id="AcceptableMove_+3A_qmax">qmax</code></td>
<td>
<p>Maximum number of parents allowed.</p>
</td></tr>
<tr><td><code id="AcceptableMove_+3A_self.loops">self.loops</code></td>
<td>
<p>Flag indicating whether self loops are allowed.</p>
</td></tr>
<tr><td><code id="AcceptableMove_+3A_target">target</code></td>
<td>
<p>The current target node (only needed to find out which parent
would be the self loop).</p>
</td></tr>
<tr><td><code id="AcceptableMove_+3A_fixed.edges">fixed.edges</code></td>
<td>
<p>Which edges in the network should be fixed for all 
segments (q-by-q matrix with entries 0 for fixed non-edge, 1 for fixed edge,
-1 for non-fixed edge).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the proposed move is acceptable, <code>FALSE</code>
otherwise.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_structure_move">make_structure_move</a></code>
</p>

<hr>
<h2 id='addProposalNetworkInfo'>Add the proposed new network to the new.nets list.</h2><span id='topic+addProposalNetworkInfo'></span>

<h3>Description</h3>

<p>Updates the network.info data structure so that it stays consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addProposalNetworkInfo(network.info, newS, E)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addProposalNetworkInfo_+3A_network.info">network.info</code></td>
<td>
<p>Data structure containing the current network.</p>
</td></tr>
<tr><td><code id="addProposalNetworkInfo_+3A_news">newS</code></td>
<td>
<p>Proposed new network for this target, a num.local.segs by 
num.parents matrix.</p>
</td></tr>
<tr><td><code id="addProposalNetworkInfo_+3A_e">E</code></td>
<td>
<p>The current vector of local segments for this target (only used to 
check for consistency with the network.info change points).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated network.info data structure, with new network added to 
new.nets.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>

<hr>
<h2 id='BinoHyperMove'>Makes a binomial hyperparameter move.</h2><span id='topic+BinoHyperMove'></span>

<h3>Description</h3>

<p>This function proposes a move for one of the hyperparameters of the binomial
prior, calculates the acceptance probability and accepts the move
accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinoHyperMove(network.info, node.sharing, GLOBvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BinoHyperMove_+3A_network.info">network.info</code></td>
<td>
<p>The collected network information obtained using
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code>.</p>
</td></tr>
<tr><td><code id="BinoHyperMove_+3A_node.sharing">node.sharing</code></td>
<td>
<p>Which type of node sharing is used, either <code>'soft'</code>
or <code>'hard'</code> sharing.</p>
</td></tr>
<tr><td><code id="BinoHyperMove_+3A_globvar">GLOBvar</code></td>
<td>
<p>Global variables of the MCMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with elements: </p>
<table role = "presentation">
<tr><td><code>move</code></td>
<td>
<p>The move type (in this
case, 2).</p>
</td></tr> <tr><td><code>move.made</code></td>
<td>
<p>1 if the move was proposed, 0 otherwise.</p>
</td></tr>
<tr><td><code>network.info</code></td>
<td>
<p>The network information, including the new
hyperparameters if the move was accepted.</p>
</td></tr> <tr><td><code>accept</code></td>
<td>
<p>Whether the move
was accepted or not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For information about the binomial information sharing prior,
see:
</p>
<p>Husmeier et al. (2010), &quot;Inter-time segment information sharing for
non-homogeneous dynamic Bayesian networks&quot;, NIPS.
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BinoHyperMove">BinoHyperMove</a></code>
</p>

<hr>
<h2 id='BinoHyperRatio'>Calculates the MH ratio of the binomial prior.</h2><span id='topic+BinoHyperRatio'></span>

<h3>Description</h3>

<p>This function calculates the ratio of the binomial information sharing prior
with the proposed new hyperparameter values, and the binomial prior with the
current hyperparameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinoHyperRatio(params.proposed, changed, node.sharing, network.info)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BinoHyperRatio_+3A_params.proposed">params.proposed</code></td>
<td>
<p>The new proposed hyperparameter values for the
binomial prior.</p>
</td></tr>
<tr><td><code id="BinoHyperRatio_+3A_changed">changed</code></td>
<td>
<p>Gives the index of the parameter that has changed.</p>
</td></tr>
<tr><td><code id="BinoHyperRatio_+3A_node.sharing">node.sharing</code></td>
<td>
<p>Type of information sharing among nodes: <code>'soft'</code>
or <code>'hard'</code>.</p>
</td></tr>
<tr><td><code id="BinoHyperRatio_+3A_network.info">network.info</code></td>
<td>
<p>The network information as collected by
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a number greater than zero which represents
the ratio of binomial priors.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For information about the binomial information sharing prior,
see:
</p>
<p>Husmeier et al. (2010), &quot;Inter-time segment information sharing for
non-homogeneous dynamic Bayesian networks&quot;, NIPS.
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BinoHyperMove">BinoHyperMove</a></code>
</p>

<hr>
<h2 id='bp.computeAlpha'>Computes the acceptance ratio of two changepoint configurations.</h2><span id='topic+bp.computeAlpha'></span>

<h3>Description</h3>

<p>This function computes the acceptance ratio of two changepoint
configurations with networks in a changepoint birth or death move.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bp.computeAlpha(birth, lNew, kminus, Ekl, Estar, Ekr, yL, PxL, yR, PxR, y2, Px2,
  D, delta2, q, smax, v0, gamma0, prior_ratio = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bp.computeAlpha_+3A_birth">birth</code></td>
<td>
<p><code>1</code> for a changepoint birth move, <code>-1</code> for a
changepoint death move.</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_lnew">lNew</code></td>
<td>
<p>Number of edges in the new segment.</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_kminus">kminus</code></td>
<td>
<p>Minimal number of changepoints between the two compared models
(equal to <code>s</code> for a birth move, <code>s-1</code> for a death move.</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_ekl">Ekl</code></td>
<td>
<p>Changepoint on the left of proposed changepoint.</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_estar">Estar</code></td>
<td>
<p>Changepoint being inserted or deleted.</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_ekr">Ekr</code></td>
<td>
<p>Changepoint on the right of proposed changepoint.</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_yl">yL</code></td>
<td>
<p>Response data (left).</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_pxl">PxL</code></td>
<td>
<p>Projection matrix (left).</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_yr">yR</code></td>
<td>
<p>Response data (right).</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_pxr">PxR</code></td>
<td>
<p>Projection matrix (right).</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_y2">y2</code></td>
<td>
<p>Response data (both).</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_px2">Px2</code></td>
<td>
<p>Projection matrix (both).</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_d">D</code></td>
<td>
<p>Hyperparameters for the number of edges in each segment.</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_delta2">delta2</code></td>
<td>
<p>Hyperparameters for the empirical covariance (signal-to-noise
ratio).</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_q">q</code></td>
<td>
<p>Total number of nodes in the network.</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_smax">smax</code></td>
<td>
<p>Maximum number of changepoints.</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_v0">v0</code></td>
<td>
<p>Hyperparameter.</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_gamma0">gamma0</code></td>
<td>
<p>Hyperparameter.</p>
</td></tr>
<tr><td><code id="bp.computeAlpha_+3A_prior_ratio">prior_ratio</code></td>
<td>
<p>Ratio of network structure priors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>References</h3>

<p>For more information about the model, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cp.birth">cp.birth</a></code>, <code><a href="#topic+cp.death">cp.death</a></code>
</p>

<hr>
<h2 id='buildXY'>Builds response Y and predictor X.</h2><span id='topic+buildXY'></span>

<h3>Description</h3>

<p>This function builds the response variables Y and predictor variables X from
the input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildXY(targetData, predData, GLOBvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildXY_+3A_targetdata">targetData</code></td>
<td>
<p>Target input data.</p>
</td></tr>
<tr><td><code id="buildXY_+3A_preddata">predData</code></td>
<td>
<p>Predictor input data.</p>
</td></tr>
<tr><td><code id="buildXY_+3A_globvar">GLOBvar</code></td>
<td>
<p>Global variables of the MCMC simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements: </p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>Predictor variables.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>Response variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>

<hr>
<h2 id='CalculateChanges'>Function to calculate the number of differences between adjaccent network
segments.</h2><span id='topic+CalculateChanges'></span>

<h3>Description</h3>

<p>This function takes the current network structure, compares each segment to
the next one, and calculates the number of changes. If soft information
sharing among nodes is active, then this procedure is only done for the
current target node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateChanges(network.info, node.sharing)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalculateChanges_+3A_network.info">network.info</code></td>
<td>
<p>The network information collected by function
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code>.</p>
</td></tr>
<tr><td><code id="CalculateChanges_+3A_node.sharing">node.sharing</code></td>
<td>
<p>Specifies the type of information sharing among nodes:
<code>'soft'</code> or <code>'hard'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector with 4 elements: the number of coinciding edges,
the number of edges in the previous segment that are absent in the next one,
the number of edges in the next segment that are absent in the previous one
and the number of coinciding non-edges.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>

<hr>
<h2 id='calculateCPPGlobal'>Calculated the global changepoint probabilities.</h2><span id='topic+calculateCPPGlobal'></span>

<h3>Description</h3>

<p>This function calculates the global probability of a changepoint at each
measured timepoint, using the node-specific probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateCPPGlobal(prob.cps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateCPPGlobal_+3A_prob.cps">prob.cps</code></td>
<td>
<p>Node-specific changepoint probabilities, a NumNodes by
NumTimepoints matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of length 1 by NumTimepoints, containing the global
changepoint probabilities.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateCPProbabilities">calculateCPProbabilities</a></code>
</p>

<hr>
<h2 id='calculateCPProbabilities'>Calculate the changepoint probabilities.</h2><span id='topic+calculateCPProbabilities'></span>

<h3>Description</h3>

<p>This function calculates the marginal changepoint probabilities from the
changepoint samples taken during the MCMC simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateCPProbabilities(network.samples)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateCPProbabilities_+3A_network.samples">network.samples</code></td>
<td>
<p>List of network and changepoint samples collected
during the MCMC simulation by <code><a href="#topic+EDISON.run">EDISON.run</a></code> and
<code><a href="#topic+runDBN">runDBN</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of dimension NumNodes by NumTimePoints, where each
entry contains the marginal posterior probability of a changepoint for that
node at that timepoint.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random gene network and simulate data from it
dataset = simulateNetwork()

# Run MCMC simulation to infer networks and changepoint locations
result = EDISON.run(dataset$sim_data, num.iter=500)

# Calculate posterior probabilities of changepoints
cps = calculateCPProbabilities(result)

</code></pre>

<hr>
<h2 id='calculateEdgeProbabilities'>Calculate the edge probabilities.</h2><span id='topic+calculateEdgeProbabilities'></span>

<h3>Description</h3>

<p>This function calculates the marginal posterior probabilities of the edges
in the network segments, for each timepoint, and optionally calculates the
same for specified changepoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateEdgeProbabilities(network.samples, cps = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateEdgeProbabilities_+3A_network.samples">network.samples</code></td>
<td>
<p>Network samples obtained from the MCMC simulation
using <code><a href="#topic+EDISON.run">EDISON.run</a></code> and <code><a href="#topic+runDBN">runDBN</a></code>.</p>
</td></tr>
<tr><td><code id="calculateEdgeProbabilities_+3A_cps">cps</code></td>
<td>
<p>Optionally specifies changepoints to allow for calculating the
marginal posterior edge probabilities for specific segments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements: </p>
<table role = "presentation">
<tr><td><code>probs.all</code></td>
<td>
<p>A list containing marginal
edge posterior probabilities for each timepoint.</p>
</td></tr> <tr><td><code>probs.segs</code></td>
<td>
<p>A list
containing marginal edge posterior probabilities for each specified
segment.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateEdgeProbabilitiesTimePoints">calculateEdgeProbabilitiesTimePoints</a></code>,
</p>
<p><code><a href="#topic+calculateEdgeProbabilitiesSegs">calculateEdgeProbabilitiesSegs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random gene network and simulate data from it
dataset = simulateNetwork(l=25)

# Run MCMC simulation to infer networks and changepoint locations
result = EDISON.run(dataset$sim_data, num.iter=500)

# Calculate marginal posterior probabilities of edges in the network
network = calculateEdgeProbabilities(result)

# Calculate marginal posterior probabilities of edges in the network, 
# using the true changepoints
true.cps = c(2,dataset$epsilon)
network = calculateEdgeProbabilities(result, cps=true.cps)

</code></pre>

<hr>
<h2 id='calculateEdgeProbabilitiesSegs'>Calculate edge probabilities for fixed segments.</h2><span id='topic+calculateEdgeProbabilitiesSegs'></span>

<h3>Description</h3>

<p>This function calculates the marginal posterior probabilities for the edges
in each network for the specified segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateEdgeProbabilitiesSegs(prob.networks, cps, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateEdgeProbabilitiesSegs_+3A_prob.networks">prob.networks</code></td>
<td>
<p>List containing the marginal posterior probabilities
for the edges of each network at each timepoint, from
<code><a href="#topic+calculateEdgeProbabilitiesTimePoints">calculateEdgeProbabilitiesTimePoints</a></code>.</p>
</td></tr>
<tr><td><code id="calculateEdgeProbabilitiesSegs_+3A_cps">cps</code></td>
<td>
<p>Changepoints defining the segments for which the edge
probabilities should be calculated. Note that these are global changepoints
that apply to the whole network.</p>
</td></tr>
<tr><td><code id="calculateEdgeProbabilitiesSegs_+3A_numnodes">numNodes</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of length equal to the number of segments, with each
entry containing a matrix of size NumNodes by NumNodes which contains the
marginal edge probabilities for that segment.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateEdgeProbabilities">calculateEdgeProbabilities</a></code>,
</p>
<p><code><a href="#topic+calculateEdgeProbabilitiesTimePoints">calculateEdgeProbabilitiesTimePoints</a></code>
</p>

<hr>
<h2 id='calculateEdgeProbabilitiesTimePoints'>Calculate the edge posterior probabilities for each timepoint.</h2><span id='topic+calculateEdgeProbabilitiesTimePoints'></span>

<h3>Description</h3>

<p>This function calculates the marginal posterior edge probabilities of the
network at each timepoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateEdgeProbabilitiesTimePoints(network.samples, cps, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateEdgeProbabilitiesTimePoints_+3A_network.samples">network.samples</code></td>
<td>
<p>Collection of network and changepoint samples of the
MCMC simulation, as obtained by <code><a href="#topic+EDISON.run">EDISON.run</a></code>,
<code><a href="#topic+runDBN">runDBN</a></code>.</p>
</td></tr>
<tr><td><code id="calculateEdgeProbabilitiesTimePoints_+3A_cps">cps</code></td>
<td>
<p>Changepoint vector.</p>
</td></tr>
<tr><td><code id="calculateEdgeProbabilitiesTimePoints_+3A_numnodes">numNodes</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length equal to the number of timepoints, where each entry
contains a matrix of size NumNodes by NumNodes with the marginal posterior
edge probabilities of the network at this timepoint.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateEdgeProbabilities">calculateEdgeProbabilities</a></code>,
</p>
<p><code><a href="#topic+calculateEdgeProbabilitiesSegs">calculateEdgeProbabilitiesSegs</a></code>
</p>

<hr>
<h2 id='CalculateLikelihoodRatio'>Calculates the ratio of two likelihoods in a structure move.</h2><span id='topic+CalculateLikelihoodRatio'></span>

<h3>Description</h3>

<p>This function calculates the ratio of the liklihoods in a network structure
move. The returned value is the ratio for the modification of one edge in
one segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateLikelihoodRatio(gamma0, y, Pxlm, Pxl, v0, delta2, dir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalculateLikelihoodRatio_+3A_gamma0">gamma0</code></td>
<td>
<p>Hyperparameter.</p>
</td></tr>
<tr><td><code id="CalculateLikelihoodRatio_+3A_y">y</code></td>
<td>
<p>Target data.</p>
</td></tr>
<tr><td><code id="CalculateLikelihoodRatio_+3A_pxlm">Pxlm</code></td>
<td>
<p>Projection matrix with modified edge.</p>
</td></tr>
<tr><td><code id="CalculateLikelihoodRatio_+3A_pxl">Pxl</code></td>
<td>
<p>Original projection matrix.</p>
</td></tr>
<tr><td><code id="CalculateLikelihoodRatio_+3A_v0">v0</code></td>
<td>
<p>Hyperparameter.</p>
</td></tr>
<tr><td><code id="CalculateLikelihoodRatio_+3A_delta2">delta2</code></td>
<td>
<p>Delta squared parameter (signal-to-noise).</p>
</td></tr>
<tr><td><code id="CalculateLikelihoodRatio_+3A_dir">dir</code></td>
<td>
<p>Direction of the change: 1 = Added an edge. 2 = Removed an edge.
0 = No change.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the likelihood ratio.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For more information about the hyperparameters and the
functional form of the likelihood, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculatePriorRatio">CalculatePriorRatio</a></code>
</p>

<hr>
<h2 id='CalculatePriorRatio'>Calculates the network prior ratio.</h2><span id='topic+CalculatePriorRatio'></span>

<h3>Description</h3>

<p>This function calculates the ratio of the network structure priors for a
structure move.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculatePriorRatio(method, q, lambda, network.info)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalculatePriorRatio_+3A_method">method</code></td>
<td>
<p>Indicates which prior to use: <code>'poisson'</code> for the
standard Poisson prior (no information sharing), <code>'exp_soft'</code> or
<code>'exp_hard'</code> for the exponential information sharing prior with soft or
hard sharing among nodes and <code>'bino_soft'</code> or <code>'bino_hard'</code> for
the binomial information sharing prior with soft or hard sharing among
nodes.</p>
</td></tr>
<tr><td><code id="CalculatePriorRatio_+3A_q">q</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="CalculatePriorRatio_+3A_lambda">lambda</code></td>
<td>
<p>Vector of lambda hyperparameter values for each network
(needed for the Poisson prior).</p>
</td></tr>
<tr><td><code id="CalculatePriorRatio_+3A_network.info">network.info</code></td>
<td>
<p>The network information collected using
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ratio of the network structure priors for the proposed
structure move.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For more information on the network structure priors, see:
</p>
<p>Husmeier et al. (2010), &quot;Inter-time segment information sharing for
non-homogeneous dynamic Bayesian networks&quot;, NIPS.
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateLikelihoodRatio">CalculateLikelihoodRatio</a></code>
</p>

<hr>
<h2 id='CollectNetworkInfo'>Collects all the network information in one list.</h2><span id='topic+CollectNetworkInfo'></span>

<h3>Description</h3>

<p>This function collects information about the current network segments and
hyperparameters for the information sharing priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CollectNetworkInfo(Sall, Eall, prior.params, posPhase, target, q, self.loops, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CollectNetworkInfo_+3A_sall">Sall</code></td>
<td>
<p>Structure of all segments. A list of length <code>q</code>, where each
element is a <code>K_i</code> by <code>q</code> matrix containing the parents for the
current node in each of the <code>K_i</code> segments.</p>
</td></tr>
<tr><td><code id="CollectNetworkInfo_+3A_eall">Eall</code></td>
<td>
<p>Positions of segment boundaries. A list of length <code>q</code>,
where each element is a vector containing the segment boundaries for the
current parent node.</p>
</td></tr>
<tr><td><code id="CollectNetworkInfo_+3A_prior.params">prior.params</code></td>
<td>
<p>The hyperparameters of the information sharing prior (if
applicable).</p>
</td></tr>
<tr><td><code id="CollectNetworkInfo_+3A_posphase">posPhase</code></td>
<td>
<p>The segment being changed.</p>
</td></tr>
<tr><td><code id="CollectNetworkInfo_+3A_target">target</code></td>
<td>
<p>The target parent node whose edge is being changed.</p>
</td></tr>
<tr><td><code id="CollectNetworkInfo_+3A_q">q</code></td>
<td>
<p>The total number of nodes in the network.</p>
</td></tr>
<tr><td><code id="CollectNetworkInfo_+3A_self.loops">self.loops</code></td>
<td>
<p>Whether self-loops are allowed in the network.</p>
</td></tr>
<tr><td><code id="CollectNetworkInfo_+3A_k">k</code></td>
<td>
<p>The level-2 hyperparameter for the exponential prior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>nets</code></td>
<td>
<p>The structure of all segments, a list of length <code>K</code> where K
is the total number of segments over all nodes.</p>
</td></tr> <tr><td><code>segment</code></td>
<td>
<p>Identical to
<code>posPhase</code>.</p>
</td></tr> <tr><td><code>target.nets</code></td>
<td>
<p>Identical to <code>Sall</code>.</p>
</td></tr>
<tr><td><code>prior.params</code></td>
<td>
<p>Identical to <code>prior.params</code>.</p>
</td></tr>
<tr><td><code>self.loops</code></td>
<td>
<p>Identical to <code>self.loops</code>.</p>
</td></tr> <tr><td><code>k</code></td>
<td>
<p>Identical to
<code>k</code>.</p>
</td></tr> <tr><td><code>new.nets</code></td>
<td>
<p>Dummy variable for holding the proposed network
in a network structure move. Originally identical to variable <code>nets</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>

<hr>
<h2 id='computePx'>Compute projection matrix.</h2><span id='topic+computePx'></span>

<h3>Description</h3>

<p>This function computes the projection matrix that is needed for calculation
of the likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePx(len, x, delta2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computePx_+3A_len">len</code></td>
<td>
<p>Delimiting breakpoints.</p>
</td></tr>
<tr><td><code id="computePx_+3A_x">x</code></td>
<td>
<p>The observations of x in the corresponding state.</p>
</td></tr>
<tr><td><code id="computePx_+3A_delta2">delta2</code></td>
<td>
<p>Signal-to-noise ratio hyperparameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The projection matrix.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>References</h3>

<p>For more information about the hyperparameters and the
functional form of the likelihood, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateLikelihoodRatio">CalculateLikelihoodRatio</a></code>
</p>

<hr>
<h2 id='computeRho4'>Calculate proposal frequencies for changepoint moves.</h2><span id='topic+computeRho4'></span>

<h3>Description</h3>

<p>This function calculates the frequency at which each of the different
changepoint moves is proposed. For the poisson network structure prior, this
ensures that the proposal frequency is equal to the prior probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeRho4(k, kmin, kmax, c, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeRho4_+3A_k">k</code></td>
<td>
<p>The number of hidden states.</p>
</td></tr>
<tr><td><code id="computeRho4_+3A_kmin">kmin</code></td>
<td>
<p>Minimum number of hidden states.</p>
</td></tr>
<tr><td><code id="computeRho4_+3A_kmax">kmax</code></td>
<td>
<p>Maximum number of hidden states</p>
</td></tr>
<tr><td><code id="computeRho4_+3A_c">c</code></td>
<td>
<p>Parameter.</p>
</td></tr>
<tr><td><code id="computeRho4_+3A_lambda">lambda</code></td>
<td>
<p>Hyperparameter controlling the number of hidden states.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing the proposal frequencies for the different
changepoint moves.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>References</h3>

<p>For more information about the hyperparameters and the
functional form of the likelihood, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>

<hr>
<h2 id='convert_nets'>Convert internal representation of networks.</h2><span id='topic+convert_nets'></span>

<h3>Description</h3>

<p>Converts from representing the network as a list of target nodes to
representing it as a list of segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_nets(Ball, Eall)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_nets_+3A_ball">Ball</code></td>
<td>
<p>Input network: List of target nodes, where each element is a
NumSegs by NumNodes matrix giving the parents for the target node in each
segment.</p>
</td></tr>
<tr><td><code id="convert_nets_+3A_eall">Eall</code></td>
<td>
<p>Changepoints: List of target nodes, where each element contains
a vector of changepoints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements: </p>
<table role = "presentation">
<tr><td><code>B_nets</code></td>
<td>
<p>List of segments, where each
element contains a matrix of size NumNodes by NumNodes, representing the
network for that segment.</p>
</td></tr> <tr><td><code>segs</code></td>
<td>
<p>Vector containing the global segment
boundaries.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>

<hr>
<h2 id='cp.birth'>Make changepoint birth move.</h2><span id='topic+cp.birth'></span>

<h3>Description</h3>

<p>This function makes a changepoint birth move, possibly adding a changepoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp.birth(Eall, Sall, Ball, Sig2all, X, Y, D, GLOBvar, HYPERvar, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cp.birth_+3A_eall">Eall</code></td>
<td>
<p>Changepoints: List of target nodes, where each element contains
a vector of changepoints.</p>
</td></tr>
<tr><td><code id="cp.birth_+3A_sall">Sall</code></td>
<td>
<p>Network structure: List of target nodes, where each element is a
NumSegs by NumNodes matrix giving the parents for the target node in each
segment. A binary matrix.</p>
</td></tr>
<tr><td><code id="cp.birth_+3A_ball">Ball</code></td>
<td>
<p>Network parameters: Similar to network structure, but with
regression parameters included.</p>
</td></tr>
<tr><td><code id="cp.birth_+3A_sig2all">Sig2all</code></td>
<td>
<p>Sigma squared parameters.</p>
</td></tr>
<tr><td><code id="cp.birth_+3A_x">X</code></td>
<td>
<p>Response data.</p>
</td></tr>
<tr><td><code id="cp.birth_+3A_y">Y</code></td>
<td>
<p>Target data.</p>
</td></tr>
<tr><td><code id="cp.birth_+3A_d">D</code></td>
<td>
<p>Hyperparameter.</p>
</td></tr>
<tr><td><code id="cp.birth_+3A_globvar">GLOBvar</code></td>
<td>
<p>Global variables of the MCMC simulation.</p>
</td></tr>
<tr><td><code id="cp.birth_+3A_hypervar">HYPERvar</code></td>
<td>
<p>Hyperparameter variables.</p>
</td></tr>
<tr><td><code id="cp.birth_+3A_target">target</code></td>
<td>
<p>Which target node the move is being proposed for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements: </p>
<table role = "presentation">
<tr><td><code>E</code></td>
<td>
<p>New changepoint vector for target
node.</p>
</td></tr> <tr><td><code>Sall</code></td>
<td>
<p>Updated network structure.</p>
</td></tr> <tr><td><code>Ball</code></td>
<td>
<p>Updated network
structure with regression parameters.</p>
</td></tr> <tr><td><code>Sig2all</code></td>
<td>
<p>Udated sigma squared.</p>
</td></tr>
<tr><td><code>prior.params</code></td>
<td>
<p>Updated vector of structure prior hyperparameters.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>Whether the move was accepted or not.</p>
</td></tr> <tr><td><code>move</code></td>
<td>
<p>What type
of move was made. In this case <code>move=1</code> for a changepoint birth move.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The acceptance ratio of the move.</p>
</td></tr> <tr><td><code>estar</code></td>
<td>
<p>The location of
the new changepoint.</p>
</td></tr> <tr><td><code>k</code></td>
<td>
<p>Hyperparameter.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>
<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For more information about the different changepoint moves, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cp.death">cp.death</a></code>, <code><a href="#topic+cp.shift">cp.shift</a></code>
</p>

<hr>
<h2 id='cp.death'>Make changepoint death move.</h2><span id='topic+cp.death'></span>

<h3>Description</h3>

<p>This function makes a changepoint death move, possibly removing a
changepoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp.death(Eall, Sall, Ball, Sig2all, X, Y, D, GLOBvar, HYPERvar, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cp.death_+3A_eall">Eall</code></td>
<td>
<p>Changepoints: List of target nodes, where each element contains
a vector of changepoints.</p>
</td></tr>
<tr><td><code id="cp.death_+3A_sall">Sall</code></td>
<td>
<p>Network structure: List of target nodes, where each element is a
NumSegs by NumNodes matrix giving the parents for the target node in each
segment. A binary matrix.</p>
</td></tr>
<tr><td><code id="cp.death_+3A_ball">Ball</code></td>
<td>
<p>Network parameters: Similar to network structure, but with
regression parameters included.</p>
</td></tr>
<tr><td><code id="cp.death_+3A_sig2all">Sig2all</code></td>
<td>
<p>Sigma squared parameters.</p>
</td></tr>
<tr><td><code id="cp.death_+3A_x">X</code></td>
<td>
<p>Response data.</p>
</td></tr>
<tr><td><code id="cp.death_+3A_y">Y</code></td>
<td>
<p>Target data.</p>
</td></tr>
<tr><td><code id="cp.death_+3A_d">D</code></td>
<td>
<p>Hyperparameter.</p>
</td></tr>
<tr><td><code id="cp.death_+3A_globvar">GLOBvar</code></td>
<td>
<p>Global variables of the MCMC simulation.</p>
</td></tr>
<tr><td><code id="cp.death_+3A_hypervar">HYPERvar</code></td>
<td>
<p>Hyperparameter variables.</p>
</td></tr>
<tr><td><code id="cp.death_+3A_target">target</code></td>
<td>
<p>Which target node the move is being proposed for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements: </p>
<table role = "presentation">
<tr><td><code>E</code></td>
<td>
<p>New changepoint vector for target
node.</p>
</td></tr> <tr><td><code>Sall</code></td>
<td>
<p>Updated network structure.</p>
</td></tr> <tr><td><code>Ball</code></td>
<td>
<p>Updated network
structure with regression parameters.</p>
</td></tr> <tr><td><code>Sig2all</code></td>
<td>
<p>Updated sigma
squared.</p>
</td></tr> <tr><td><code>prior.params</code></td>
<td>
<p>Updated vector of structure prior
hyperparameters.</p>
</td></tr> <tr><td><code>accept</code></td>
<td>
<p>Whether the move was accepted or not.</p>
</td></tr>
<tr><td><code>move</code></td>
<td>
<p>What type of move was made. In this case <code>move=2</code> for a
changepoint death move.</p>
</td></tr> <tr><td><code>alpha</code></td>
<td>
<p>The acceptance ratio of the move.</p>
</td></tr>
<tr><td><code>estar</code></td>
<td>
<p>The location of the removed changepoint.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Hyperparameter.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>
<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For more information about the different changepoint moves, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cp.birth">cp.birth</a></code>, <code><a href="#topic+cp.shift">cp.shift</a></code>
</p>

<hr>
<h2 id='cp.shift'>Makes a changepoint shift move.</h2><span id='topic+cp.shift'></span>

<h3>Description</h3>

<p>This function makes a changepoint shift move, possibly moving one of the
changepoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp.shift(Eall, Sall, Ball, Sig2all, X, Y, GLOBvar, HYPERvar, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cp.shift_+3A_eall">Eall</code></td>
<td>
<p>Changepoints: List of target nodes, where each element contains
a vector of changepoints.</p>
</td></tr>
<tr><td><code id="cp.shift_+3A_sall">Sall</code></td>
<td>
<p>Network structure: List of target nodes, where each element is a
NumSegs by NumNodes matrix giving the parents for the target node in each
segment. A binary matrix.</p>
</td></tr>
<tr><td><code id="cp.shift_+3A_ball">Ball</code></td>
<td>
<p>Network parameters: Similar to network structure, but with
regression parameters included.</p>
</td></tr>
<tr><td><code id="cp.shift_+3A_sig2all">Sig2all</code></td>
<td>
<p>Sigma squared parameters.</p>
</td></tr>
<tr><td><code id="cp.shift_+3A_x">X</code></td>
<td>
<p>Response data.</p>
</td></tr>
<tr><td><code id="cp.shift_+3A_y">Y</code></td>
<td>
<p>Target data.</p>
</td></tr>
<tr><td><code id="cp.shift_+3A_globvar">GLOBvar</code></td>
<td>
<p>Global variables of the MCMC simulation.</p>
</td></tr>
<tr><td><code id="cp.shift_+3A_hypervar">HYPERvar</code></td>
<td>
<p>Hyperparameter variables.</p>
</td></tr>
<tr><td><code id="cp.shift_+3A_target">target</code></td>
<td>
<p>Which target node the move is being proposed for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements: </p>
<table role = "presentation">
<tr><td><code>E</code></td>
<td>
<p>New changepoint vector for target
node.</p>
</td></tr> <tr><td><code>Sall</code></td>
<td>
<p>Updated network structure.</p>
</td></tr> <tr><td><code>Ball</code></td>
<td>
<p>Updated network
structure with regression parameters.</p>
</td></tr> <tr><td><code>Sig2all</code></td>
<td>
<p>Updated sigma
squared.</p>
</td></tr> <tr><td><code>prior.params</code></td>
<td>
<p>Updated vector of structure prior
hyperparameters.</p>
</td></tr> <tr><td><code>accept</code></td>
<td>
<p>Whether the move was accepted or not.</p>
</td></tr>
<tr><td><code>move</code></td>
<td>
<p>What type of move was made. In this case <code>move=2</code> for a
changepoint death move.</p>
</td></tr> <tr><td><code>alpha</code></td>
<td>
<p>The acceptance ratio of the move.</p>
</td></tr>
<tr><td><code>estar</code></td>
<td>
<p>The location of the removed changepoint.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Hyperparameter.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>References</h3>

<p>For more information about the different changepoint moves, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cp.birth">cp.birth</a></code>, <code><a href="#topic+cp.death">cp.death</a></code>
</p>

<hr>
<h2 id='defaultOptions'>Set the default options for the MCMC simulation.</h2><span id='topic+defaultOptions'></span>

<h3>Description</h3>

<p>This function creates a list with the default options of the MCMC
simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultOptions()
</code></pre>


<h3>Value</h3>

<p>A list of default options with elements: </p>
<table role = "presentation">
<tr><td><code>lmax</code></td>
<td>
<p>Maximum number
of parent nodes. Default=5.</p>
</td></tr> <tr><td><code>m</code></td>
<td>
<p>Number of repeated measurements.
Default=1 (no repeats).</p>
</td></tr> <tr><td><code>dyn</code></td>
<td>
<p>Lag for the DBN model. Default = 1 when
X(t) depends on the previous measurement X(t-1), but dyn can be chosen equal
to 2, 3, ...</p>
</td></tr> <tr><td><code>minPhase</code></td>
<td>
<p>Minimal length of a segment. Default=2.</p>
</td></tr>
<tr><td><code>maxCP</code></td>
<td>
<p>Maximal number of changepoints. Default=10.</p>
</td></tr>
<tr><td><code>maxTF</code></td>
<td>
<p>Maximal number of incoming edges for each node. Default=5.</p>
</td></tr>
<tr><td><code>alphaCP</code></td>
<td>
<p>Hyperparameter for the number of changepoints. Default=1.</p>
</td></tr>
<tr><td><code>betaCP</code></td>
<td>
<p>Hyperparameter for the number of changepoints. Default=0.5.</p>
</td></tr>
<tr><td><code>alphaTF</code></td>
<td>
<p>Hyperparameter for the number of incoming edges. Default=1.</p>
</td></tr>
<tr><td><code>betaTF</code></td>
<td>
<p>Hyperparameter for the number of incoming edges. Default=0.5.</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>
<p>Whether to include a burnin period. Default=F.</p>
</td></tr>
<tr><td><code>psrf.check</code></td>
<td>
<p>Whether to calculate the potential scale reduction factor
(PSRF). Default=F.</p>
</td></tr> <tr><td><code>pp.l1</code></td>
<td>
<p>Proposal frequency for level-1
hyperparameter moves. Default=0.2.</p>
</td></tr> <tr><td><code>pp.l2</code></td>
<td>
<p>Proposal frequency for
level-2 hyperparameter moves. Default=0.01.</p>
</td></tr> <tr><td><code>save.by.node</code></td>
<td>
<p>Whether to
save results separately for each target node. Default=F.</p>
</td></tr>
<tr><td><code>save.file</code></td>
<td>
<p>Whether to save the results to a file. Default=F.</p>
</td></tr>
<tr><td><code>hyper.fixed</code></td>
<td>
<p>Whether to keep the network structure prior
hyperparameters fixed. Default=F.</p>
</td></tr> <tr><td><code>cp.fixed</code></td>
<td>
<p>Whether to keep the
changepoints fixed. Default=F.</p>
</td></tr> <tr><td><code>hyper.init</code></td>
<td>
<p>Initial values for the
network structure prior hyperparameters. Default=NULL.</p>
</td></tr>
<tr><td><code>cp.init</code></td>
<td>
<p>Initial values for the changepoint locations. Default=NULL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set options to allow saving network and changepoint samples to file
options = defaultOptions()
options$save.file = TRUE

# NOT EXECUTED
# result.bino2 = EDISON.run(dataset$sim_data, 
#                  information.sharing='bino_hard',
#                  num.iter=5000, output.file='bino2.results',
#                  options=options)

</code></pre>

<hr>
<h2 id='dinvgamma'>Calculate inverse gamma distribution.</h2><span id='topic+dinvgamma'></span>

<h3>Description</h3>

<p>This function calculates the density of the inverse gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvgamma(x, shape, scale = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dinvgamma_+3A_x">x</code></td>
<td>
<p>Input.</p>
</td></tr>
<tr><td><code id="dinvgamma_+3A_shape">shape</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="dinvgamma_+3A_scale">scale</code></td>
<td>
<p>Scale parameter (1/rate).</p>
</td></tr>
<tr><td><code id="dinvgamma_+3A_log">log</code></td>
<td>
<p>Whether to return the log density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the density (or log density).
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Draw samples from inverse gamma distribution with shape parameter 1 
# and scale parameter 1
samples = rinvgamma(100, shape=1, scale=1)

# Calculate density of samples
densities = dinvgamma(samples, shape=1, scale=1)

</code></pre>

<hr>
<h2 id='EDISON.run'>Wrapper function for starting an MCMC simulation</h2><span id='topic+EDISON.run'></span>

<h3>Description</h3>

<p>This function provides a wrapper for starting an MCMC simulation, using only
the data and some basic options as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EDISON.run(input, output.file = "EDISON.output",
  information.sharing = "poisson", num.iter = 10000, prior.params = NULL,
  options = NULL, fixed.edges = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EDISON.run_+3A_input">input</code></td>
<td>
<p>Input data. Either a filename pointing to an R data file
containing the results of <code><a href="#topic+simulateNetwork">simulateNetwork</a></code>, or a NumTimePoints
by NumNodes matrix.</p>
</td></tr>
<tr><td><code id="EDISON.run_+3A_output.file">output.file</code></td>
<td>
<p>Where to save the output of the MCMC simulation.</p>
</td></tr>
<tr><td><code id="EDISON.run_+3A_information.sharing">information.sharing</code></td>
<td>
<p>Which information sharing prior to use:
<code>'poisson'</code> for the Poisson prior (no information sharing),
<code>'exp_hard'</code> or <code>'exp_soft'</code> for the exponential prior with hard
or soft coupling among nodes, respectively, and <code>'bino_hard'</code> or
<code>'bino_soft'</code> for the binomial prior with hard or soft coupling among
nodes.</p>
</td></tr>
<tr><td><code id="EDISON.run_+3A_num.iter">num.iter</code></td>
<td>
<p>Number of iterations of the MCMC simulation.</p>
</td></tr>
<tr><td><code id="EDISON.run_+3A_prior.params">prior.params</code></td>
<td>
<p>Initial values of the hyperparameters of the information
sharing priors.</p>
</td></tr>
<tr><td><code id="EDISON.run_+3A_options">options</code></td>
<td>
<p>Settings for the MCMC simulation, as generated by
<code><a href="#topic+defaultOptions">defaultOptions</a></code>.</p>
</td></tr>
<tr><td><code id="EDISON.run_+3A_fixed.edges">fixed.edges</code></td>
<td>
<p>Matrix of size NumNodes by NumNodes, with 
<code>fixed.edges[i,j]==1|0</code> if the edge between nodes i and j is fixed, and 
-1 otherwise. Defaults to <code>NULL</code> (no edges fixed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the results of the MCMC simulation, similar to
<code><a href="#topic+runDBN">runDBN</a></code>.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre Frank Dondelinger
</p>


<h3>References</h3>

<p>For details on the model and MCMC simulation, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runDBN">runDBN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random gene network and simulate data from it
dataset = simulateNetwork(l=25)

# Run MCMC simulation to infer networks and changepoint locations
# Uses default settings: Poisson prior and 1500 iterations
result.poisson = EDISON.run(dataset$sim_data, num.iter=500)

# Use the binomial information sharing prior with hard node coupling, and
# run for 5000 iterations

# NOT EXECUTED
#result.bino = EDISON.run(dataset$sim_data, 
#                information.sharing='bino_hard', num.iter=5000)
                        
# Set options to allow saving network and changepoint samples to file
options = defaultOptions()
options$save.file = TRUE

# NOT EXECUTED
# result.bino2 = EDISON.run(dataset$sim_data, 
#                  information.sharing='bino_hard',
#                  num.iter=5000, output.file='bino2.results',
#                  options=options)

</code></pre>

<hr>
<h2 id='ExpHyperMove'>Makes an exponential hyperparameter move.</h2><span id='topic+ExpHyperMove'></span>

<h3>Description</h3>

<p>This function tries to make a level-1 or level-2 hyperparameter move for the
exponential prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpHyperMove(network.info, node.sharing, GLOBvar, hyper.proposals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpHyperMove_+3A_network.info">network.info</code></td>
<td>
<p>The network information collected by
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code>.</p>
</td></tr>
<tr><td><code id="ExpHyperMove_+3A_node.sharing">node.sharing</code></td>
<td>
<p>The type of information sharing among nodes:
<code>'soft'</code> or <code>'hard'</code>.</p>
</td></tr>
<tr><td><code id="ExpHyperMove_+3A_globvar">GLOBvar</code></td>
<td>
<p>Collection of global variables of the MCMC.</p>
</td></tr>
<tr><td><code id="ExpHyperMove_+3A_hyper.proposals">hyper.proposals</code></td>
<td>
<p>Proposal width of the hyperparameter move.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with elements: </p>
<table role = "presentation">
<tr><td><code>move.made</code></td>
<td>
<p>1 if a level-1
hyperparameter move has been made, 0 otherwise.</p>
</td></tr> <tr><td><code>network.info</code></td>
<td>
<p>Network
information with updated hyperparameters if the move was accepted.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>Whether a level-1 hyperparameter move has been accepted or
not.</p>
</td></tr> <tr><td><code>move.made.k</code></td>
<td>
<p>1 if a level-2 hyperparameter move has been made, 0
otherwise.</p>
</td></tr> <tr><td><code>accept.k</code></td>
<td>
<p>Whether a level-2 hyperparameter move has been
accepted or not.</p>
</td></tr> <tr><td><code>move</code></td>
<td>
<p>Type of move: 2 for a level-1 hyperparameter
move, 3 for a level-2 hyperparameter move.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For information about the exponential information sharing prior,
see:
</p>
<p>Husmeier et al. (2010), &quot;Inter-time segment information sharing for
non-homogeneous dynamic Bayesian networks&quot;, NIPS.
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ExpHyperRatioTarget">ExpHyperRatioTarget</a></code>
</p>

<hr>
<h2 id='ExpHyperRatioTarget'>Calculates the ratio of an exponential hyperparameter move.</h2><span id='topic+ExpHyperRatioTarget'></span>

<h3>Description</h3>

<p>This function calculates the acceptance ratio of a level-1 hyperparameter
move for a given target node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpHyperRatioTarget(beta.proposed, beta.old, target.net, self.loops)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpHyperRatioTarget_+3A_beta.proposed">beta.proposed</code></td>
<td>
<p>Proposed new hyperparameter value.</p>
</td></tr>
<tr><td><code id="ExpHyperRatioTarget_+3A_beta.old">beta.old</code></td>
<td>
<p>Previous value of hyperparameter beta.</p>
</td></tr>
<tr><td><code id="ExpHyperRatioTarget_+3A_target.net">target.net</code></td>
<td>
<p>Network segments for the target node associated with this
hyperparameter value.</p>
</td></tr>
<tr><td><code id="ExpHyperRatioTarget_+3A_self.loops">self.loops</code></td>
<td>
<p><code>'TRUE'</code> if self-loops are acceptable, <code>'FALSE'</code>
otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ratio of the exponential prior with the previous
hyperparameter value and the proposed new hyperparameter value.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For information about the exponential information sharing prior,
see:
</p>
<p>Husmeier et al. (2010), &quot;Inter-time segment information sharing for
non-homogeneous dynamic Bayesian networks&quot;, NIPS.
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ExpHyperMove">ExpHyperMove</a></code>
</p>

<hr>
<h2 id='fix_eigenvalues'>Modify network to ensure stationarity.</h2><span id='topic+fix_eigenvalues'></span>

<h3>Description</h3>

<p>This function ensures that the eigenvalues of the network structure matrix
are smaller or equal to 1, thereby ensuring stationarity of the regression.
This is done by removing edges at random until the condition is satisfied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_eigenvalues(network, q, gauss_weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_eigenvalues_+3A_network">network</code></td>
<td>
<p>Original network structure, a matrix of size NumNodes by
NumNodes.</p>
</td></tr>
<tr><td><code id="fix_eigenvalues_+3A_q">q</code></td>
<td>
<p>Number of nodes.</p>
</td></tr>
<tr><td><code id="fix_eigenvalues_+3A_gauss_weights">gauss_weights</code></td>
<td>
<p>If <code>TRUE</code>, use Gaussian regression weight, if
<code>FALSE</code> conserve original weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a network with fewer eigenvalues than the original network,
but satisfying the stationarity condition.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateNetwork">generateNetwork</a></code>
</p>

<hr>
<h2 id='generateNetwork'>Generate a random network.</h2><span id='topic+generateNetwork'></span>

<h3>Description</h3>

<p>This function generates a random network with changepoints for structure
changes, for simulating synthetic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateNetwork(lambda_2 = 0.45, q = 10, min_phase_length = 1,
  k_bar = 5, l = 10, lambda_3 = 2, spacing = 1, gauss_weights = TRUE,
  same = FALSE, change_method = "sequential", fixed = FALSE, cps = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateNetwork_+3A_lambda_2">lambda_2</code></td>
<td>
<p>Average number of parents for each node in the network
(parameter for a Poisson distribution).</p>
</td></tr>
<tr><td><code id="generateNetwork_+3A_q">q</code></td>
<td>
<p>Number of nodes.</p>
</td></tr>
<tr><td><code id="generateNetwork_+3A_min_phase_length">min_phase_length</code></td>
<td>
<p>Minimum segment length.</p>
</td></tr>
<tr><td><code id="generateNetwork_+3A_k_bar">k_bar</code></td>
<td>
<p>Maximum number of changepoints. If <code>fixed=TRUE</code>, this is
equal to the number of changepoints.</p>
</td></tr>
<tr><td><code id="generateNetwork_+3A_l">l</code></td>
<td>
<p>Length of the time series.</p>
</td></tr>
<tr><td><code id="generateNetwork_+3A_lambda_3">lambda_3</code></td>
<td>
<p>Average number of structure changes between two segments
(parameter for a Poisson distribution).</p>
</td></tr>
<tr><td><code id="generateNetwork_+3A_spacing">spacing</code></td>
<td>
<p><code>1</code> if segments are equally spaced, <code>0</code> if they are
spaced randomly (subject to the constraints of min_phase_length).</p>
</td></tr>
<tr><td><code id="generateNetwork_+3A_gauss_weights">gauss_weights</code></td>
<td>
<p><code>1</code> if edge weights in the network are drawn from
N(0, 1), <code>0</code> if they are fixed to be 1.</p>
</td></tr>
<tr><td><code id="generateNetwork_+3A_same">same</code></td>
<td>
<p><code>1</code> if all segments have the same network structure (no
changes), <code>0</code> otherwise.</p>
</td></tr>
<tr><td><code id="generateNetwork_+3A_change_method">change_method</code></td>
<td>
<p><code>'sequential'</code> if the changes happen sequentially
(i.e. changes at segment i are applied to segment i-1),
<code>'hierarchical'</code> if the changes happen with respect to a hypernetwork
(i.e. changes at segment i are applied to segment 0).</p>
</td></tr>
<tr><td><code id="generateNetwork_+3A_fixed">fixed</code></td>
<td>
<p><code>T</code> if the changepoint locations are fixed, <code>F</code> if
they should be sampled.</p>
</td></tr>
<tr><td><code id="generateNetwork_+3A_cps">cps</code></td>
<td>
<p>Changepoint locations (if they are fixed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements: </p>
<table role = "presentation">
<tr><td><code>network</code></td>
<td>
<p>The network, a
list of length NumSegs, where each element is a NumNodes by NumNodes
matrix.</p>
</td></tr> <tr><td><code>epsilon</code></td>
<td>
<p>The vector of changepoint locations.</p>
</td></tr> <tr><td><code>k</code></td>
<td>
<p>The
number of changepoint.</p>
</td></tr> <tr><td><code>changes</code></td>
<td>
<p>The number of changes among
segments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateNetwork">simulateNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random network with default parameters
network = generateNetwork()

# Simulate data using generated network
dataset = simulateNetwork(net=network)

# Generate random network with 4 changepoints and 15 nodes, 
# with changepoints distributed over a timeseries of length 50
network = generateNetwork(l=50, q=15, fixed=TRUE, k_bar=4)

# Simulate data of length 50 using generated network
dataset = simulateNetwork(net=network)

</code></pre>

<hr>
<h2 id='HyperparameterMove'>Make a hyperparameter move.</h2><span id='topic+HyperparameterMove'></span>

<h3>Description</h3>

<p>This function makes a hyperparameter move for the information sharing prior
selected (or no move if no information sharing prior is selected).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HyperparameterMove(method, network.info, GLOBvar, hyper.proposals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HyperparameterMove_+3A_method">method</code></td>
<td>
<p>The information sharing method used: <code>'poisson'</code> for the
Poisson prior (no information sharing), <code>'exp_soft'</code> and
<code>'exp_hard'</code> for the exponential information sharing prior with soft or
hard information sharing among nodes, respectively, <code>'bino_soft'</code> and
<code>'bino_hard'</code> for the binomial information sharing prior with soft or
hard information sharing among nodes, respectively.</p>
</td></tr>
<tr><td><code id="HyperparameterMove_+3A_network.info">network.info</code></td>
<td>
<p>Network information collected using
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code>.</p>
</td></tr>
<tr><td><code id="HyperparameterMove_+3A_globvar">GLOBvar</code></td>
<td>
<p>Global variables used during the MCMC.</p>
</td></tr>
<tr><td><code id="HyperparameterMove_+3A_hyper.proposals">hyper.proposals</code></td>
<td>
<p>Proposal width for hyperparameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List summing up the result of the hypermove. Contains at least:
</p>
<table role = "presentation">
<tr><td><code>move.made</code></td>
<td>
<p>Whether a hyperparameter move has been made.</p>
</td></tr>
<tr><td><code>network.info</code></td>
<td>
<p>The network information, possibly updated if the
hyperparameter move was made and accepted.</p>
</td></tr></table>
<p> May contain further elements
depending on the type of information sharing prior used. See the
prior-specific functions <code><a href="#topic+ExpHyperMove">ExpHyperMove</a></code> and
<code><a href="#topic+BinoHyperMove">BinoHyperMove</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For information about the information sharing priors, see:
</p>
<p>Husmeier et al. (2010), &quot;Inter-time segment information sharing for
non-homogeneous dynamic Bayesian networks&quot;, NIPS.
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>

<hr>
<h2 id='HyperParms'>Sets up initial values of hyperparameters.</h2><span id='topic+HyperParms'></span>

<h3>Description</h3>

<p>This function initialises the variable HYPERvar with values for the various
hyperparameters in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HyperParms(options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HyperParms_+3A_options">options</code></td>
<td>
<p>MCMC settings, possibly from <code><a href="#topic+defaultOptions">defaultOptions</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Settings for the HYPERvar variable: </p>
<table role = "presentation">
<tr><td><code>cD</code></td>
<td>
<p>Proportion of
changepoint moves proposed.</p>
</td></tr> <tr><td><code>alphaD</code></td>
<td>
<p>Prior settings for the number of
changepoints.</p>
</td></tr> <tr><td><code>betaD</code></td>
<td>
<p>Prior settings for the number of changepoints.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Ratio of changepoint birth/death moves proposed.</p>
</td></tr> <tr><td><code>v0</code></td>
<td>
<p>Prior
settings for the sigma squared parameters.</p>
</td></tr> <tr><td><code>gamma0</code></td>
<td>
<p>Prior settings for
the sigma squared parameters.</p>
</td></tr> <tr><td><code>alphad2</code></td>
<td>
<p>Prior settings for the
signal-to-noise ratio delta squared.</p>
</td></tr> <tr><td><code>betad2</code></td>
<td>
<p>Prior settings for the
signal-to-noise ratio delta squared.</p>
</td></tr> <tr><td><code>alphalbd</code></td>
<td>
<p>Prior settings for the
number of transcription factors.</p>
</td></tr> <tr><td><code>betalbd</code></td>
<td>
<p>Prior settings for the
number of transcription factors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>
<p>Frank Dondelinger
</p>

<hr>
<h2 id='init'>Initialise the MCMC simulation.</h2><span id='topic+init'></span>

<h3>Description</h3>

<p>This function intialises the parameters and variables needed for the MCMC
simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init(X, Y, sinit, GLOBvar, HYPERvar, options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_+3A_x">X</code></td>
<td>
<p>Input response data.</p>
</td></tr>
<tr><td><code id="init_+3A_y">Y</code></td>
<td>
<p>Input target data.</p>
</td></tr>
<tr><td><code id="init_+3A_sinit">sinit</code></td>
<td>
<p>Initial changepoints.</p>
</td></tr>
<tr><td><code id="init_+3A_globvar">GLOBvar</code></td>
<td>
<p>Global variables used during the MCMC simulation.</p>
</td></tr>
<tr><td><code id="init_+3A_hypervar">HYPERvar</code></td>
<td>
<p>Hyperparameter variables.</p>
</td></tr>
<tr><td><code id="init_+3A_options">options</code></td>
<td>
<p>MCMC simulation options as obtained e.g. by
<code><a href="#topic+defaultOptions">defaultOptions</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements: </p>
<table role = "presentation">
<tr><td><code>counters</code></td>
<td>
<p>Matrices for counting the number
of moves made and accepted.</p>
</td></tr> <tr><td><code>initState</code></td>
<td>
<p>Initial state of the variables
of the MCMC simulation.</p>
</td></tr> <tr><td><code>listStock</code></td>
<td>
<p>Variables for recording the
network, changepoint and hyperparameter samples.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>
<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleParms">sampleParms</a></code>
</p>

<hr>
<h2 id='main'>Main function of the MCMC simulation.</h2><span id='topic+main'></span>

<h3>Description</h3>

<p>This function executes the main loop of the MCMC simulation, making the
different moves and recording samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>main(X, Y, initiation, GLOBvar, HYPERvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="main_+3A_x">X</code></td>
<td>
<p>Input response data.</p>
</td></tr>
<tr><td><code id="main_+3A_y">Y</code></td>
<td>
<p>Input target data.</p>
</td></tr>
<tr><td><code id="main_+3A_initiation">initiation</code></td>
<td>
<p>Initialisation of the MCMC simulation, as obtained by
function <code><a href="#topic+init">init</a></code>.</p>
</td></tr>
<tr><td><code id="main_+3A_globvar">GLOBvar</code></td>
<td>
<p>Global variables of the MCMC simulation.</p>
</td></tr>
<tr><td><code id="main_+3A_hypervar">HYPERvar</code></td>
<td>
<p>Hyperparameter variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements: </p>
<table role = "presentation">
<tr><td><code>counters</code></td>
<td>
<p>List
containing the different move counters for the number of times moves have
been proposed and accepted.</p>
</td></tr> <tr><td><code>listStock</code></td>
<td>
<p>List containing the recorded
samples for the networks, changepoints and hyperparameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>
<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For more information about the MCMC simulations, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runDBN">runDBN</a></code>
</p>

<hr>
<h2 id='make_structure_move'>Makes a structure move.</h2><span id='topic+make_structure_move'></span>

<h3>Description</h3>

<p>This function makes a network structure move.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_structure_move(x, y, S, B, Sig2, q, qmax, network.info, method, Mphase, E,
  fixed.edges, HYPERvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_structure_move_+3A_x">x</code></td>
<td>
<p>Response data.</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_y">y</code></td>
<td>
<p>Target data.</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_s">S</code></td>
<td>
<p>Network structure for the current target node, a NumSegs by
NumNodes matrix.</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_b">B</code></td>
<td>
<p>Same as <code>S</code>, but including the regression parameters.</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_sig2">Sig2</code></td>
<td>
<p>Sigma squared parameters.</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_q">q</code></td>
<td>
<p>Number of nodes.</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_qmax">qmax</code></td>
<td>
<p>Maximum number of parents.</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_network.info">network.info</code></td>
<td>
<p>Network information, as collected by
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code>.</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_method">method</code></td>
<td>
<p>Information sharing method: Either <code>'poisson'</code>,
<code>'exp_hard'</code>,
</p>
<p><code>'exp_soft'</code>, <code>'bino_hard'</code>, <code>'bino_soft'</code>.</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_mphase">Mphase</code></td>
<td>
<p>Segment boundary positions.</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_e">E</code></td>
<td>
<p>Changepoint vector.</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_fixed.edges">fixed.edges</code></td>
<td>
<p>Matrix of size NumNodes by NumNodes, with 
<code>fixed.edges[i,j]==1|0</code> if the edge between nodes i and j is fixed, and 
-1 otherwise. Defaults to <code>NULL</code> (no edges fixed).</p>
</td></tr>
<tr><td><code id="make_structure_move_+3A_hypervar">HYPERvar</code></td>
<td>
<p>Hyperparameter variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>newS</code></td>
<td>
<p>Updated network structure.</p>
</td></tr> <tr><td><code>newB</code></td>
<td>
<p>Updated network
structure with regression parameters.</p>
</td></tr> <tr><td><code>move</code></td>
<td>
<p>Type of move being made:
1 for network structure moves.</p>
</td></tr> <tr><td><code>accept</code></td>
<td>
<p><code>1</code> if the move has been
accepted, <code>0</code> otherwise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For more information about the MCMC moves, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>

<hr>
<h2 id='NetworkProbBino'>Calculates the prior probability of the network segments under the binomial
prior.</h2><span id='topic+NetworkProbBino'></span>

<h3>Description</h3>

<p>This function calculates the (log) probability of the network segments using
the binomial information sharing prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkProbBino(network.info, node.sharing = "soft")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NetworkProbBino_+3A_network.info">network.info</code></td>
<td>
<p>Network information collected by function
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code>.</p>
</td></tr>
<tr><td><code id="NetworkProbBino_+3A_node.sharing">node.sharing</code></td>
<td>
<p>Coupling of hyperparameters among nodes: <code>'hard'</code>
or <code>'soft'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the log prior probability of the network segments under the
binomial prior.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For information about the binomial information sharing prior,
see:
</p>
<p>Husmeier et al. (2010), &quot;Inter-time segment information sharing for
non-homogeneous dynamic Bayesian networks&quot;, NIPS.
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NetworkRatioBino">NetworkRatioBino</a></code>, <code><a href="#topic+CalculatePriorRatio">CalculatePriorRatio</a></code>
</p>

<hr>
<h2 id='NetworkProbExp'>Calculates the prior probability of the network using the exponential prior.</h2><span id='topic+NetworkProbExp'></span>

<h3>Description</h3>

<p>This function calculates the log prior probability of the network structure.
It uses the exponential information sharing prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkProbExp(network.info)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NetworkProbExp_+3A_network.info">network.info</code></td>
<td>
<p>Network information collected using the function
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the log prior probability of the network segments.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For information about the exponential information sharing prior,
see:
</p>
<p>Husmeier et al. (2010), &quot;Inter-time segment information sharing for
non-homogeneous dynamic Bayesian networks&quot;, NIPS.
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NetworkRatioExp">NetworkRatioExp</a></code>, <code><a href="#topic+CalculatePriorRatio">CalculatePriorRatio</a></code>
</p>

<hr>
<h2 id='NetworkRatioBino'>Calculates the ratio of binomial prior probabilites.</h2><span id='topic+NetworkRatioBino'></span>

<h3>Description</h3>

<p>This function calculates the ratio of binomial prior probabilities of two
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkRatioBino(network.info, node.sharing)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NetworkRatioBino_+3A_network.info">network.info</code></td>
<td>
<p>Network information collected by function
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code>.  Note that network.info$new.nets has to be
set.</p>
</td></tr>
<tr><td><code id="NetworkRatioBino_+3A_node.sharing">node.sharing</code></td>
<td>
<p>Type of coupling of hyperparameters among nodes:
<code>'hard'</code> or <code>'soft'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ratio of [prior of new network]/[prior of old network].
</p>


<h3>Author(s)</h3>

<p>For information about the binomial information sharing prior, see:
</p>
<p>Husmeier et al. (2010), &quot;Inter-time segment information sharing for
non-homogeneous dynamic Bayesian networks&quot;, NIPS.
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NetworkProbBino">NetworkProbBino</a></code>, <code><a href="#topic+CalculatePriorRatio">CalculatePriorRatio</a></code>
</p>

<hr>
<h2 id='NetworkRatioExp'>Calculates the ratio of exponential network prior probabilities.</h2><span id='topic+NetworkRatioExp'></span>

<h3>Description</h3>

<p>This function calculates the ratio of exponential network information
sharing prior probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkRatioExp(network.info)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NetworkRatioExp_+3A_network.info">network.info</code></td>
<td>
<p>Network information collected using the function
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code>. Note that <code>network.info$new.nets</code> has
to be set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ratio [prior of new network]/[prior of old network].
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For information about the exponential information sharing prior,
see:
</p>
<p>Husmeier et al. (2010), &quot;Inter-time segment information sharing for
non-homogeneous dynamic Bayesian networks&quot;, NIPS.
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NetworkProbExp">NetworkProbExp</a></code>, <code><a href="#topic+CalculatePriorRatio">CalculatePriorRatio</a></code>
</p>

<hr>
<h2 id='output'>Collects and saves output.</h2><span id='topic+output'></span>

<h3>Description</h3>

<p>This function collects the network, changepoint and hyperparameter samples
taken from the MCMC simulation, and saves them to a file if appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output(counters, listStock, GLOBvar, HYPERvar, OUTvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="output_+3A_counters">counters</code></td>
<td>
<p>List of counters for the number of moves that have been
proposed and accepted.</p>
</td></tr>
<tr><td><code id="output_+3A_liststock">listStock</code></td>
<td>
<p>Network, changepoint and hyperparameter samples.</p>
</td></tr>
<tr><td><code id="output_+3A_globvar">GLOBvar</code></td>
<td>
<p>Global variables of the MCMC simulation.</p>
</td></tr>
<tr><td><code id="output_+3A_hypervar">HYPERvar</code></td>
<td>
<p>Hyperparameter variables.</p>
</td></tr>
<tr><td><code id="output_+3A_outvar">OUTvar</code></td>
<td>
<p>Output variables, including the output file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with an element for each target node which is also a
list. Each sublist containts the elements: </p>
<table role = "presentation">
<tr><td><code>cp_samples</code></td>
<td>
<p>Changepoint
samples, a NumSamples by MaxNumChangePoints matrix.</p>
</td></tr>
<tr><td><code>edge_samples</code></td>
<td>
<p>Network samples (with regression parameters), a
NumSamples by (NumSegs * NumNodes) matrix.</p>
</td></tr> <tr><td><code>target</code></td>
<td>
<p>The target node
for this subnetwork.</p>
</td></tr> <tr><td><code>hyper_samples</code></td>
<td>
<p>Information sharing prior
hyperparameter samples, a NumSamples by NumHyperParams matrix.</p>
</td></tr>
<tr><td><code>sampled</code></td>
<td>
<p>Sampled iterations.</p>
</td></tr> <tr><td><code>counters</code></td>
<td>
<p>Counters for the number
of proposed and accepted moves.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>

<hr>
<h2 id='phase.update'>Make a network structure or hyperparameter move.</h2><span id='topic+phase.update'></span>

<h3>Description</h3>

<p>This function makes a network structure or information sharing
hyperparameter move.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase.update(Eall, Sall, Ball, Sig2all, X, Y, GLOBvar, HYPERvar, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phase.update_+3A_eall">Eall</code></td>
<td>
<p>List of changepoints with one entry for each target node. Each
entry has length equal to the number of changepoints for that target node.</p>
</td></tr>
<tr><td><code id="phase.update_+3A_sall">Sall</code></td>
<td>
<p>Network structure: List of length equal to the number of target
nodes, where each list entry is a NumSegs by NumNodes matrix.</p>
</td></tr>
<tr><td><code id="phase.update_+3A_ball">Ball</code></td>
<td>
<p>Network structure with regression coefficients: Same as Sall,
but with regression coefficients as matrix entries.</p>
</td></tr>
<tr><td><code id="phase.update_+3A_sig2all">Sig2all</code></td>
<td>
<p>Sigma squared.</p>
</td></tr>
<tr><td><code id="phase.update_+3A_x">X</code></td>
<td>
<p>Input response data.</p>
</td></tr>
<tr><td><code id="phase.update_+3A_y">Y</code></td>
<td>
<p>Input target data.</p>
</td></tr>
<tr><td><code id="phase.update_+3A_globvar">GLOBvar</code></td>
<td>
<p>Global variables used during the MCMC simulation.</p>
</td></tr>
<tr><td><code id="phase.update_+3A_hypervar">HYPERvar</code></td>
<td>
<p>Hyperparameter variables.</p>
</td></tr>
<tr><td><code id="phase.update_+3A_target">target</code></td>
<td>
<p>Current target node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements: </p>
<table role = "presentation">
<tr><td><code>E</code></td>
<td>
<p>Changepoints
for the current target node.</p>
</td></tr> <tr><td><code>Sall</code></td>
<td>
<p>Network structure (possibly
updated).</p>
</td></tr> <tr><td><code>Ball</code></td>
<td>
<p>Network structure regression coefficients (possibly
updated).</p>
</td></tr> <tr><td><code>Sig2all</code></td>
<td>
<p>Sigma squared.</p>
</td></tr> <tr><td><code>prior.params</code></td>
<td>
<p>Information
sharing prior hyperparameters (possibly updated).</p>
</td></tr> <tr><td><code>k</code></td>
<td>
<p>Level-2
exponential prior hyperparameter (possibly updated).</p>
</td></tr> <tr><td><code>move</code></td>
<td>
<p>Move type:
4 for a network structure move, 5 hyperparameter move.</p>
</td></tr>
<tr><td><code>move</code></td>
<td>
<p>Structure Move type: 1 for a network structure move, 2 for a
level-1 hyperparameter move, 3 for a level-2 hyperparameter move.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>1 if the move has been accepted, 0 otherwise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>
<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For more information on network structure moves and information
sharing priors, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_structure_move">make_structure_move</a></code>
</p>

<hr>
<h2 id='PriorRatioPoisson'>Calculate network prior ratio with Poisson prior.</h2><span id='topic+PriorRatioPoisson'></span>

<h3>Description</h3>

<p>This function calculates the ratio of the Poisson prior for two networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PriorRatioPoisson(network.info, q, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PriorRatioPoisson_+3A_network.info">network.info</code></td>
<td>
<p>Network information collected using
<code><a href="#topic+CollectNetworkInfo">CollectNetworkInfo</a></code>. Note that one needs to set
<code>network.info$new.nets</code>.</p>
</td></tr>
<tr><td><code id="PriorRatioPoisson_+3A_q">q</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="PriorRatioPoisson_+3A_lambda">lambda</code></td>
<td>
<p>Vector of lambda hyperparameters for each network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ratio [prior of new network]/[prior of old network].
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For more information on the network structure priors, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculatePriorRatio">CalculatePriorRatio</a></code>
</p>

<hr>
<h2 id='proposalTuning'>Tune the proposal width for betas.</h2><span id='topic+proposalTuning'></span>

<h3>Description</h3>

<p>This function adjusts the proposal width for the beta hyperparameter(s) of
the exponential information sharing prior, so that the acceptance rate is
close to 0.25.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proposalTuning(acceptRate, hyper.proposals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proposalTuning_+3A_acceptrate">acceptRate</code></td>
<td>
<p>Current acceptance rate.</p>
</td></tr>
<tr><td><code id="proposalTuning_+3A_hyper.proposals">hyper.proposals</code></td>
<td>
<p>Current proposal width.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the new proposal width.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>

<hr>
<h2 id='proposeContinuous'>Propose a new real hyperparameter value.</h2><span id='topic+proposeContinuous'></span>

<h3>Description</h3>

<p>This function proposes a new real values hyperparameter for the information
sharing prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proposeContinuous(orig_beta, proposal_range, limit = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proposeContinuous_+3A_orig_beta">orig_beta</code></td>
<td>
<p>Current value of the hyperparameter.</p>
</td></tr>
<tr><td><code id="proposeContinuous_+3A_proposal_range">proposal_range</code></td>
<td>
<p>Range for the new value.</p>
</td></tr>
<tr><td><code id="proposeContinuous_+3A_limit">limit</code></td>
<td>
<p>Hard limit on the range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new uniformly random value within <code>proposal_range</code> of
<code>orig_beta</code> and limited by <code>limit</code>.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ProposeDiscrete">ProposeDiscrete</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Previous parameter value
param = runif(1, 0, 1)

# Propose new value within range [0, 1], with proposal width 0.1
new.param = proposeContinuous(param, 0.1, 1)

</code></pre>

<hr>
<h2 id='ProposeDiscrete'>Propose a new discrete value.</h2><span id='topic+ProposeDiscrete'></span>

<h3>Description</h3>

<p>This function proposes a new discrete parameter, based on the previous
value, within the given proposal range, making sure that the maximum range
is not exceeded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProposeDiscrete(params.old, proposal.range, max.range)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ProposeDiscrete_+3A_params.old">params.old</code></td>
<td>
<p>Old parameter value (an integer).</p>
</td></tr>
<tr><td><code id="ProposeDiscrete_+3A_proposal.range">proposal.range</code></td>
<td>
<p>Range for new proposal (an integer).</p>
</td></tr>
<tr><td><code id="ProposeDiscrete_+3A_max.range">max.range</code></td>
<td>
<p>Maximum value for new proposal (an integer).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the new proposed parameter, which will be an integer in the
range [0, <code>max.range</code>], and within at most <code>proposal.range</code> of
<code>params.old</code>.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+proposeContinuous">proposeContinuous</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Previous parameter value
param = rpois(1, 5)

# Propose new value within range [0, 10], with proposal width 2
new.param = ProposeDiscrete(param, 2, 10)

</code></pre>

<hr>
<h2 id='psrf'>Calculates the potential scale reduction factor.</h2><span id='topic+psrf'></span>

<h3>Description</h3>

<p>This function calculates the potential scale reduction factor of parameters
or hyperparameters over several MCMC simulations (or one simulation split
up). This can serve as a convergence diagnostic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psrf(parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psrf_+3A_parameters">parameters</code></td>
<td>
<p>A list of MCMC trajectories, where each trajectory is a
matrix with NumParams rows and NumIterations columns, where NumParams is the
number of parameters and NumIterations is the number of samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vectors of length NumParams, containing the PSRF values for each
parameter.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>
<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>Gelman and Rubin (1992) Inference from iterative simulation
using multiple sequences, Statistical Science.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psrf_check">psrf_check</a></code>, <code><a href="#topic+psrf_check_hyper">psrf_check_hyper</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate 5 'runs' of random samples from Gaussian N(0,1)
samples = list()

for(run in 1:5) {
  samples[[run]] = matrix(rnorm(1000), 1, 1000)
}

# Check potential scale reduction factor
# (Will be very close to 1 due to the samples being from 
# the same distribution)
psrf.val = psrf(samples)


# Now use slightly different Gaussian distributions for each 'run'.
for(run in 1:5) {
  mean = runif(1, 0, 2)
  samples[[run]] = matrix(rnorm(1000, mean, 1), 1, 1000)
}

# Check potential scale reduction factor
# (Should be &gt; 1.1)
psrf.val = psrf(samples)


</code></pre>

<hr>
<h2 id='psrf_check'>Check the potential scale reduction factors for all parameters (edges).</h2><span id='topic+psrf_check'></span>

<h3>Description</h3>

<p>This function treats the edges of the network as parameters, calculates
their potential scale reduction factors and returns the highest value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psrf_check(params, q, k_max, num_it)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psrf_check_+3A_params">params</code></td>
<td>
<p>Matrix of parameters.</p>
</td></tr>
<tr><td><code id="psrf_check_+3A_q">q</code></td>
<td>
<p>Number of nodes.</p>
</td></tr>
<tr><td><code id="psrf_check_+3A_k_max">k_max</code></td>
<td>
<p>Number of segments.</p>
</td></tr>
<tr><td><code id="psrf_check_+3A_num_it">num_it</code></td>
<td>
<p>Number of iterations/samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the highest PSRF value.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>Gelman and Rubin (1992) Inference from iterative simulation
using multiple sequences, Statistical Science.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psrf">psrf</a></code>, <code><a href="#topic+psrf_check_hyper">psrf_check_hyper</a></code>
</p>

<hr>
<h2 id='psrf_check_hyper'>Checks the potential scale reduction factor for the hyperparameters.</h2><span id='topic+psrf_check_hyper'></span>

<h3>Description</h3>

<p>This function checks the potential scale reduction factors for the
hyperparameters of the information sharing priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psrf_check_hyper(params, num_it)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psrf_check_hyper_+3A_params">params</code></td>
<td>
<p>Matrix of hyperparameters.</p>
</td></tr>
<tr><td><code id="psrf_check_hyper_+3A_num_it">num_it</code></td>
<td>
<p>Number of iterations/samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the maximum PSRF value.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>Gelman and Rubin (1992) Inference from iterative simulation
using multiple sequences, Statistical Science.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psrf">psrf</a></code>, <code><a href="#topic+psrf_check">psrf_check</a></code>
</p>

<hr>
<h2 id='readDataTS'>Read target data.</h2><span id='topic+readDataTS'></span>

<h3>Description</h3>

<p>This function reads in the target data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDataTS(data, posI, t0, tf, m, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readDataTS_+3A_data">data</code></td>
<td>
<p>Input data matrix to read.</p>
</td></tr>
<tr><td><code id="readDataTS_+3A_posi">posI</code></td>
<td>
<p>Position of interest.</p>
</td></tr>
<tr><td><code id="readDataTS_+3A_t0">t0</code></td>
<td>
<p>First timepoint.</p>
</td></tr>
<tr><td><code id="readDataTS_+3A_tf">tf</code></td>
<td>
<p>Last timepoint.</p>
</td></tr>
<tr><td><code id="readDataTS_+3A_m">m</code></td>
<td>
<p>Number of repetitions.</p>
</td></tr>
<tr><td><code id="readDataTS_+3A_n">n</code></td>
<td>
<p>Number of timepoints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the target data.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildXY">buildXY</a></code>
</p>

<hr>
<h2 id='rinvgamma'>Samples from the inverse gamma distribution.</h2><span id='topic+rinvgamma'></span>

<h3>Description</h3>

<p>This function samples from the inverse gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rinvgamma(n, shape, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rinvgamma_+3A_n">n</code></td>
<td>
<p>Number of values to sample.</p>
</td></tr>
<tr><td><code id="rinvgamma_+3A_shape">shape</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="rinvgamma_+3A_scale">scale</code></td>
<td>
<p>Scale parameter (1/rate).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Random sample from the inverse gamma distribution.
</p>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dinvgamma">dinvgamma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Draw samples from inverse gamma distribution with shape parameter 1 
# and scale parameter 1
samples = rinvgamma(100, shape=1, scale=1)

# Calculate density of samples
densities = dinvgamma(samples, shape=1, scale=1)

</code></pre>

<hr>
<h2 id='runDBN'>Setup and run the MCMC simulation.</h2><span id='topic+runDBN'></span>

<h3>Description</h3>

<p>This function initialises the variabes for the MCMC simulation, runs the
simulation and returns the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runDBN(targetdata, preddata = NULL, q, n, multipleVar = TRUE,
  minPhase = 2, niter = 20000, scaling = TRUE, method = "poisson",
  prior.params = NULL, self.loops = TRUE, k = 15, options = NULL,
  outputFile = ".", fixed.edges = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runDBN_+3A_targetdata">targetdata</code></td>
<td>
<p>Target input data: A matrix of dimensions NumNodes by
NumTimePoints.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_preddata">preddata</code></td>
<td>
<p>Optional: Input response data, if different from the target
data.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_q">q</code></td>
<td>
<p>Number of nodes.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_n">n</code></td>
<td>
<p>Number of timepoints.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_multiplevar">multipleVar</code></td>
<td>
<p><code>TRUE</code> when a specific variance is estimated for
each segment, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_minphase">minPhase</code></td>
<td>
<p>Minimal segment length.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_niter">niter</code></td>
<td>
<p>Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_scaling">scaling</code></td>
<td>
<p>If <code>TRUE</code>, scale the input data to mean 0 and standard
deviation 1, else leave it unchanged.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_method">method</code></td>
<td>
<p>Network structure prior to use: <code>'poisson'</code> for a sparse
Poisson prior (no information sharing), <code>'exp_hard'</code> or
<code>'exp_soft'</code> for the exponential information sharing prior with hard or
soft node coupling, <code>'bino_hard'</code> or <code>'bino_soft'</code> with hard or
soft node coupling.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_prior.params">prior.params</code></td>
<td>
<p>Initial hyperparameters for the information sharing
prior.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_self.loops">self.loops</code></td>
<td>
<p>If <code>TRUE</code>, allow self-loops in the network, if
<code>FALSE</code>, disallow self-loops.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_k">k</code></td>
<td>
<p>Initial value for the level-2 hyperparameter of the exponential
information sharing prior.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_options">options</code></td>
<td>
<p>MCMC options as obtained e.g. by the function
<code><a href="#topic+defaultOptions">defaultOptions</a></code>.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_outputfile">outputFile</code></td>
<td>
<p>File where the output of the MCMC simulation should be
saved.</p>
</td></tr>
<tr><td><code id="runDBN_+3A_fixed.edges">fixed.edges</code></td>
<td>
<p>Matrix of size NumNodes by NumNodes, with 
<code>fixed.edges[i,j]==1|0</code> if the edge between nodes i and j is fixed, and 
-1 otherwise. Defaults to <code>NULL</code> (no edges fixed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of the MCMC simulation: network
samples, changepoint samples and hyperparameter samples. For details, see
<code><a href="#topic+output">output</a></code>.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>
<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For more information about the MCMC simulations, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+output">output</a></code>
</p>

<hr>
<h2 id='sampleBinit'>Sample initial regression coefficients.</h2><span id='topic+sampleBinit'></span>

<h3>Description</h3>

<p>This function samples the initial regression coefficients for the networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleBinit(Si, sig2, delta2, X, q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleBinit_+3A_si">Si</code></td>
<td>
<p>Network structure.</p>
</td></tr>
<tr><td><code id="sampleBinit_+3A_sig2">sig2</code></td>
<td>
<p>Sigma squared.</p>
</td></tr>
<tr><td><code id="sampleBinit_+3A_delta2">delta2</code></td>
<td>
<p>Signal-to-noise ratio hyperparameter.</p>
</td></tr>
<tr><td><code id="sampleBinit_+3A_x">X</code></td>
<td>
<p>Input data.</p>
</td></tr>
<tr><td><code id="sampleBinit_+3A_q">q</code></td>
<td>
<p>Number of nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of regression coefficients.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>References</h3>

<p>For details of the regression model, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>

<hr>
<h2 id='sampleBxy'>Sample regression coefficients.</h2><span id='topic+sampleBxy'></span>

<h3>Description</h3>

<p>This function samples the regression coefficients given the current state of
the MCMC simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleBxy(xi, y, Sig2, delta2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleBxy_+3A_xi">xi</code></td>
<td>
<p>Response data.</p>
</td></tr>
<tr><td><code id="sampleBxy_+3A_y">y</code></td>
<td>
<p>Target data.</p>
</td></tr>
<tr><td><code id="sampleBxy_+3A_sig2">Sig2</code></td>
<td>
<p>Sigma squared.</p>
</td></tr>
<tr><td><code id="sampleBxy_+3A_delta2">delta2</code></td>
<td>
<p>Signal-to-noise hyperparameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The regression parameters.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>References</h3>

<p>For details of the regression model, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>

<hr>
<h2 id='sampleDelta2'>Sample delta squared.</h2><span id='topic+sampleDelta2'></span>

<h3>Description</h3>

<p>This function samples the signal-to-noise hyperparameter delta squared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleDelta2(pos, x, q, B, S, sig2, alphad2, betad2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleDelta2_+3A_pos">pos</code></td>
<td>
<p>The current segment.</p>
</td></tr>
<tr><td><code id="sampleDelta2_+3A_x">x</code></td>
<td>
<p>Data,</p>
</td></tr>
<tr><td><code id="sampleDelta2_+3A_q">q</code></td>
<td>
<p>Number of nodes.</p>
</td></tr>
<tr><td><code id="sampleDelta2_+3A_b">B</code></td>
<td>
<p>Regression coefficients.</p>
</td></tr>
<tr><td><code id="sampleDelta2_+3A_s">S</code></td>
<td>
<p>Network structure.</p>
</td></tr>
<tr><td><code id="sampleDelta2_+3A_sig2">sig2</code></td>
<td>
<p>Sigma squared.</p>
</td></tr>
<tr><td><code id="sampleDelta2_+3A_alphad2">alphad2</code></td>
<td>
<p>Gamma prior hyperparameter.</p>
</td></tr>
<tr><td><code id="sampleDelta2_+3A_betad2">betad2</code></td>
<td>
<p>Gamma prior hyperparameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New sample of delta squared.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>References</h3>

<p>For details of the sampling, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>

<hr>
<h2 id='sampleK'>Sample initial number of changepoints.</h2><span id='topic+sampleK'></span>

<h3>Description</h3>

<p>This function samples the initial number of changepoints from a sparse
Poisson prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleK(mini, maxi, lambda, nb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleK_+3A_mini">mini</code></td>
<td>
<p>Minimum value.</p>
</td></tr>
<tr><td><code id="sampleK_+3A_maxi">maxi</code></td>
<td>
<p>Maximum value.</p>
</td></tr>
<tr><td><code id="sampleK_+3A_lambda">lambda</code></td>
<td>
<p>Parameter of the Poisson distribution.</p>
</td></tr>
<tr><td><code id="sampleK_+3A_nb">nb</code></td>
<td>
<p>Number of values to sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sampled number of changepoints.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>References</h3>

<p>For more information on the prior choice and sampling, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>

<hr>
<h2 id='sampleParms'>Sample initial parameters for the MCMC simulation.</h2><span id='topic+sampleParms'></span>

<h3>Description</h3>

<p>This function samples the initial hyperparameters and parameters that are
needed for the MCMC simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleParms(X, GLOBvar, HYPERvar, s_init = NULL, options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleParms_+3A_x">X</code></td>
<td>
<p>Input data.</p>
</td></tr>
<tr><td><code id="sampleParms_+3A_globvar">GLOBvar</code></td>
<td>
<p>Global variables of the MCMC simulation.</p>
</td></tr>
<tr><td><code id="sampleParms_+3A_hypervar">HYPERvar</code></td>
<td>
<p>Hyperparameter variables.</p>
</td></tr>
<tr><td><code id="sampleParms_+3A_s_init">s_init</code></td>
<td>
<p>Initial number of changepoints.</p>
</td></tr>
<tr><td><code id="sampleParms_+3A_options">options</code></td>
<td>
<p>MCMC options, as given by e.g. <code><a href="#topic+defaultOptions">defaultOptions</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with elements: </p>
<table role = "presentation">
<tr><td><code>E</code></td>
<td>
<p>The initial changepoint
vector.</p>
</td></tr> <tr><td><code>S</code></td>
<td>
<p>The intial networks structure.</p>
</td></tr> <tr><td><code>B</code></td>
<td>
<p>The initial
regression parameters.</p>
</td></tr> <tr><td><code>Sig2</code></td>
<td>
<p>The inital sigma squared variances.</p>
</td></tr>
<tr><td><code>betas</code></td>
<td>
<p>The intial hyperparameters for the exponential information
sharing prior.</p>
</td></tr> <tr><td><code>hyper_params</code></td>
<td>
<p>The initial hyperparameters for the
binomial information sharing prior.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>
<p>Frank Dondelinger
</p>


<h3>References</h3>

<p>For more information about the parameters and hyperparameters,
see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init">init</a></code>
</p>

<hr>
<h2 id='sampleSig2'>Sample initial sigma squared.</h2><span id='topic+sampleSig2'></span>

<h3>Description</h3>

<p>This function samples the initial values for the sigma squared variance from
the inverse gamma prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleSig2(y, Px, v0, gamma0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleSig2_+3A_y">y</code></td>
<td>
<p>Input data.</p>
</td></tr>
<tr><td><code id="sampleSig2_+3A_px">Px</code></td>
<td>
<p>Projection matrix.</p>
</td></tr>
<tr><td><code id="sampleSig2_+3A_v0">v0</code></td>
<td>
<p>Inverse gamma prior hyperparameter.</p>
</td></tr>
<tr><td><code id="sampleSig2_+3A_gamma0">gamma0</code></td>
<td>
<p>Inverse gamma prior hyperparameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sampled sigma squared values.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>References</h3>

<p>For more information about the model, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>

<hr>
<h2 id='simulateNetwork'>Generate network and simulate data.</h2><span id='topic+simulateNetwork'></span>

<h3>Description</h3>

<p>This function generates a random network with structure changepoints (or
takes one as input) and simulated data from it using a regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateNetwork(l = 100, min_phase_length = 10, k_bar = 10, q = 10,
  lambda_2 = 0.45, noise = 0.25, net = NULL, lambda_3 = 2,
  spacing = 0, gauss_weights = FALSE, same = FALSE,
  changes = "sequential", fixed = FALSE, cps = NULL, saveFile = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateNetwork_+3A_l">l</code></td>
<td>
<p>Length of the time series.</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_min_phase_length">min_phase_length</code></td>
<td>
<p>Minimum segment length.</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_k_bar">k_bar</code></td>
<td>
<p>Maximum number of changepoints.</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_q">q</code></td>
<td>
<p>Number of nodes.</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_lambda_2">lambda_2</code></td>
<td>
<p>Average number of parents for each node in the network
(parameter for a Poisson distribution).</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_noise">noise</code></td>
<td>
<p>Standard deviation of the Gaussian observation noise. Can be
constant, or segment specific (in which case the number of changepoints
needs to be fixed and the noise needs to be a vector of the same length).</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_net">net</code></td>
<td>
<p>Input network, can be <code>NULL</code> if a new network should be
generated.</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_lambda_3">lambda_3</code></td>
<td>
<p>Average number of structure changes between two segments
(parameter for a Poisson distribution).</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_spacing">spacing</code></td>
<td>
<p><code>1</code> if segments are equally spaced, <code>0</code> if they are
spaced randomly (subject to the constraints of min_phase_length).</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_gauss_weights">gauss_weights</code></td>
<td>
<p><code>1</code> if edge weights in the network are drawn from
N(0, 1), <code>0</code> if they are fixed to be 1.</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_same">same</code></td>
<td>
<p><code>1</code> if the networks should all be the same (no changes),
<code>0</code> otherwise.</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_changes">changes</code></td>
<td>
<p><code>'sequential'</code> if the changes happen sequentially (i.e.
changes at segment i are applied to segment i-1), <code>'hierarchical'</code> if
the changes happen with respect to a hypernetwork (i.e. changes at segment i
are applied to segment 0).</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_fixed">fixed</code></td>
<td>
<p><code>T</code> if the changepoint locations are fixed, <code>F</code> if
they should be sampled.</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_cps">cps</code></td>
<td>
<p>Changepoint locations (if they are fixed).</p>
</td></tr>
<tr><td><code id="simulateNetwork_+3A_savefile">saveFile</code></td>
<td>
<p>If not <code>NULL</code>, indicates the filename for saving the
output in R data format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements: </p>
<table role = "presentation">
<tr><td><code>sim_data</code></td>
<td>
<p>A matrix of length NumNodes by
NumTimepoints containing the simulated data from the regression model.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>Changepoint vector.</p>
</td></tr> <tr><td><code>k</code></td>
<td>
<p>Number of changepoints.</p>
</td></tr>
<tr><td><code>network</code></td>
<td>
<p>The network, a list of length NumSegs, where each element is
a NumNodes by NumNodes matrix.</p>
</td></tr> <tr><td><code>noise</code></td>
<td>
<p>The standard deviation of the
applied Gaussian noise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Dondelinger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateNetwork">generateNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random network and simulate data with default parameters
dataset = simulateNetwork()

# Generate random network and simulate data with an average of 
# 1 change per node among network segments
dataset = simulateNetwork(lambda_3=1)

# Generate random network and simulate data with an average of 
# 1 change per node among network segments and standard deviation 
# of the Gaussian observation noise 0.5
dataset = simulateNetwork(lambda_3=1, noise=0.5)

# Generate random network with default parameters
network = generateNetwork()

# Simulate data using generated network
dataset = simulateNetwork(net=network)

# Generate random network with 4 changepoints and 15 nodes, 
# with changepoints distributed over a timeseries of length 50
network = generateNetwork(l=50, q=15, fixed=TRUE, k_bar=4)

# Simulate data of length 50 using generated network
dataset = simulateNetwork(net=network)

</code></pre>

<hr>
<h2 id='updateSigMulti'>Update sigma squared variances.</h2><span id='topic+updateSigMulti'></span>

<h3>Description</h3>

<p>This function samples new values for the sigma squared variances, given the
current network structure. A multivariate distribution is assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateSigMulti(phase, X, Y, E, Sall, Ball, Sig2, Mphase, alphad2, betad2, v0,
  gamma0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateSigMulti_+3A_phase">phase</code></td>
<td>
<p>Current segment.</p>
</td></tr>
<tr><td><code id="updateSigMulti_+3A_x">X</code></td>
<td>
<p>Input response data.</p>
</td></tr>
<tr><td><code id="updateSigMulti_+3A_y">Y</code></td>
<td>
<p>Input target data.</p>
</td></tr>
<tr><td><code id="updateSigMulti_+3A_e">E</code></td>
<td>
<p>Changepoints.</p>
</td></tr>
<tr><td><code id="updateSigMulti_+3A_sall">Sall</code></td>
<td>
<p>Network structure.</p>
</td></tr>
<tr><td><code id="updateSigMulti_+3A_ball">Ball</code></td>
<td>
<p>Regression coefficients.</p>
</td></tr>
<tr><td><code id="updateSigMulti_+3A_sig2">Sig2</code></td>
<td>
<p>Current sigma squared values.</p>
</td></tr>
<tr><td><code id="updateSigMulti_+3A_mphase">Mphase</code></td>
<td>
<p>Segment positions.</p>
</td></tr>
<tr><td><code id="updateSigMulti_+3A_alphad2">alphad2</code></td>
<td>
<p>Hyperparameter for gamma prior.</p>
</td></tr>
<tr><td><code id="updateSigMulti_+3A_betad2">betad2</code></td>
<td>
<p>Hyperparameter for gamma prior.</p>
</td></tr>
<tr><td><code id="updateSigMulti_+3A_v0">v0</code></td>
<td>
<p>Hyperparameter for inverse gamma prior.</p>
</td></tr>
<tr><td><code id="updateSigMulti_+3A_gamma0">gamma0</code></td>
<td>
<p>Hyperparameter for inverse gamma prior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new samples sigma squared values.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>References</h3>

<p>For more information about the model, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+updateSigSolo">updateSigSolo</a></code>
</p>

<hr>
<h2 id='updateSigSolo'>Sample new values for sigma squared.</h2><span id='topic+updateSigSolo'></span>

<h3>Description</h3>

<p>This function samples new values for the sigma squared variances, given the
current network structure. A univariate distribution is assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateSigSolo(X, Y, E, Sall, Ball, Sig2, Mphase, alphad2, betad2, v0, gamma0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateSigSolo_+3A_x">X</code></td>
<td>
<p>Input response data.</p>
</td></tr>
<tr><td><code id="updateSigSolo_+3A_y">Y</code></td>
<td>
<p>Input target data.</p>
</td></tr>
<tr><td><code id="updateSigSolo_+3A_e">E</code></td>
<td>
<p>Changepoints.</p>
</td></tr>
<tr><td><code id="updateSigSolo_+3A_sall">Sall</code></td>
<td>
<p>Network structure.</p>
</td></tr>
<tr><td><code id="updateSigSolo_+3A_ball">Ball</code></td>
<td>
<p>Regression coefficients.</p>
</td></tr>
<tr><td><code id="updateSigSolo_+3A_sig2">Sig2</code></td>
<td>
<p>Current sigma squared.</p>
</td></tr>
<tr><td><code id="updateSigSolo_+3A_mphase">Mphase</code></td>
<td>
<p>Segment position.</p>
</td></tr>
<tr><td><code id="updateSigSolo_+3A_alphad2">alphad2</code></td>
<td>
<p>Gamma prior hyperparameter.</p>
</td></tr>
<tr><td><code id="updateSigSolo_+3A_betad2">betad2</code></td>
<td>
<p>Gamma prior hyperparameter.</p>
</td></tr>
<tr><td><code id="updateSigSolo_+3A_v0">v0</code></td>
<td>
<p>Inverse gamma prior hyperparameter.</p>
</td></tr>
<tr><td><code id="updateSigSolo_+3A_gamma0">gamma0</code></td>
<td>
<p>Inverse gamma prior hyperparameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the new samples sigma squared values.
</p>


<h3>Author(s)</h3>

<p>Sophie Lebre
</p>


<h3>References</h3>

<p>For more information about the model, see:
</p>
<p>Dondelinger et al. (2012), &quot;Non-homogeneous dynamic Bayesian networks with
Bayesian regularization for inferring gene regulatory networks with
gradually time-varying structure&quot;, Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+updateSigMulti">updateSigMulti</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
