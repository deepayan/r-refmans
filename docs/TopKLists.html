<!DOCTYPE html><html><head><title>Help for package TopKLists</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TopKLists}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggmap'>
<p>Aggregation map for the integration of truncated lists</p></a></li>
<li><a href='#Borda'>
<p>Borda based rank aggregation</p></a></li>
<li><a href='#Borda.plot'>
<p>Plot Borda's scores against ranks</p></a></li>
<li><a href='#breast'><p>Sample data from breast cancer expression</p></a></li>
<li><a href='#calculate.maxK'>
<p>The main function for TopKInference</p></a></li>
<li><a href='#CEMC'>
<p>CEMC based rank aggregation</p></a></li>
<li><a href='#compute.stream'>
<p>Calculates point of degeneration j0 into noise of the Idata, applying moderate deviation-based inference</p></a></li>
<li><a href='#deltaplot'>
<p>An exploratory plot of discordance for delta selection.</p></a></li>
<li><a href='#geo.mean'>
<p>Calculate the geometric mean</p></a></li>
<li><a href='#init.p'>
<p>Initialization method for probabilities</p></a></li>
<li><a href='#j0.multi'>
<p>Function returning an overall point j0 of degeneration into noise for multiple ranked lists</p></a></li>
<li><a href='#Kendall.plot'>
<p>Plot of the Kendall Criterion values</p></a></li>
<li><a href='#Kendall2Lists'>
<p>Calculate modified Kendall's tau distance</p></a></li>
<li><a href='#KendallMLists'>
<p>KendallMLists</p></a></li>
<li><a href='#l2norm'>
<p>Calculate the L2 norm</p></a></li>
<li><a href='#MC'>
<p>Markov chain based rank aggregation</p></a></li>
<li><a href='#MC.plot'>
<p>Plot of the ordered stationary probabilities</p></a></li>
<li><a href='#MC.ranks'>
<p>MC based rank aggregation</p></a></li>
<li><a href='#prepare.idata'>
<p>Prepare Idata vector of 0's and 1's</p></a></li>
<li><a href='#Spearman'>
<p>Modified Spearman's footrule distance</p></a></li>
<li><a href='#TopKLists-package'>
<p>Inference, aggregation and visualization for top-<em>k</em> ranked lists</p></a></li>
<li><a href='#TopKListsGUI'>
<p>TopKListsGUI for inference and visualization</p></a></li>
<li><a href='#TopKSample'>
<p>Sampler to generate N top-k lists according to p</p></a></li>
<li><a href='#TopKSpaceSampleInput'>
<p>Sample input for TopKSpace functions</p></a></li>
<li><a href='#trans.matrix'>
<p>Compute transition matrices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inference, Aggregation and Visualization for Top-K Ranked Lists</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-29</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.8</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael G. Schimek, Eva Budinska, Jie Ding, Karl G. Kugler, Vendula Svendova, Shili Lin, Bastian Pfeifer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bastian Pfeifer &lt;bastian.pfeifer@medunigraz.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>For multiple ranked input lists (full or partial) representing the same set of N objects, the package 'TopKLists' &lt;<a href="https://doi.org/10.1515%2Fsagmb-2014-0093">doi:10.1515/sagmb-2014-0093</a>&gt; offers (1) statistical inference on the lengths of informative top-k lists, (2) stochastic aggregation of full or partial lists, and (3) graphical tools for the statistical exploration of input lists, and for the visualization of aggregation results. Note that RGtk2 and gWidgets2RGtk2 have been archived on CRAN. See <a href="https://github.com/pievos101/TopKLists">https://github.com/pievos101/TopKLists</a> for installation instructions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Hmisc,grid,gplots</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,RGtk2,gWidgets2,gWidgets2RGtk2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://topklists.r-forge.r-project.org">http://topklists.r-forge.r-project.org</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-01 07:35:55 UTC; bastian</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-01 12:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggmap'>
Aggregation map for the integration of truncated lists
</h2><span id='topic+aggmap'></span>

<h3>Description</h3>

<p>The function <code>aggmap</code> applies Paul Murrell's <code>grid</code> package. It is plotting the ranked items (objects) of <em>L</em> truncated (top) lists of individual length <code class="reqn">\hat{k}_i</code>, based on pairwise comparison of all <em>L</em> lists. The resulting <code>aggmap</code> is defined as follows: For an index, <code class="reqn">p=1,2,\ldots,L-1</code>, aggregation levels (groupings of top lists) are combined in one display. For each group of <em>L-p</em> truncated lists down to the smallest group consisting of just one pair of lists, (1) an arbitrary reference list (&quot;ground truth&quot;) is selected under the condition that it comprises <code class="reqn">\max_i(\hat{k}_i)</code> items among all pairwise comparisons in the group of rankings, (2) symbols of its <code class="reqn">\max_i(\hat{k}_i)</code> items are printed vertically from the highest to the lowest rank position, and (3) the aggregation information for all remaining <em>L-p</em> rankings in the group is added, ordered according to descending list length.
</p>
<p>The aggregation information per item and group consists of three measures represented by colored triangles and rectangles, respectively, outlined in array format: (a) The <b>membership</b> of an individual item in the top-<em>k</em> lists, <em>yes</em> is denoted by the color 'grey' and <em>no</em> by the color 'white'. (b) The <b>distance</b> <em>d</em> of the rank of an individual item in the reference list from its position in the other list, is denoted by a triangle color scaled from 'red' <em>identical</em> to 'yellow' <em>far distant</em>. An additional integer value gives the numerical distance between the item's rank positions, a negative sign means ranked lower, and a positive sign means ranked higher in the current list, with respect to the reference list. (c) The rectangular of a symbol takes on the color 'grey' when the <b>percentage</b> of <code class="reqn">d \leq \delta</code> across the columns of a group is above some prespecified threshold, and 'white' otherwise. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggmap(truncated.lists)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggmap_+3A_truncated.lists">truncated.lists</code></td>
<td>

<p>Object resulting from the <code><a href="#topic+calculate.maxK">calculate.maxK</a></code> function
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eva Budinska &lt;budinska@iba.muni.cz&gt;, Michael G. Schimek &lt;michael.schimek@medunigraz.at&gt;
</p>


<h3>References</h3>

<p>Murrell, R. (2005) R Graphics. Chapman &amp; Hall/CRC, Boca Raton, Florida.
</p>
<p>Schimek, M. G. and Budinska, E. (2010). Visualization techniques for the integration of rank data. In Lechevallier, Y. and Saporta, G. (eds). COMPSTAT 2010. Proceedings in Computational Statistics. Heidelberg: Physica (e-book ISBN 978-3-7908-2603-6), 1637-1644.
</p>
<p>Schimek, M. G. and Bloice, M. (2012). Modelling the rank order of Web search engine results. In Komarek, A. and Nagy, S. (eds). Proceedings of the 27th International Workshop on Statistical Modelling. (e-book ISBN 978-80-263-0250-6), Vol. 1, 303-308. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate.maxK">calculate.maxK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
data(breast)
truncated.lists = calculate.maxK(breast, d=10, v=10, L=3, threshold=50)
## Not run: 
aggmap(truncated.lists)

## End(Not run)
</code></pre>

<hr>
<h2 id='Borda'>
Borda based rank aggregation
</h2><span id='topic+Borda'></span>

<h3>Description</h3>

<p>Computes Borda scores and ranks based on four different aggregation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Borda(input, space = NULL, k = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Borda_+3A_input">input</code></td>
<td>

<p>A list containing individual ranked lists.
</p>
</td></tr>
<tr><td><code id="Borda_+3A_space">space</code></td>
<td>

<p>A list containing the underlying spaces. If not explicitly specified, all lists are treated as coming from a common space defined by the union of all input lists.
</p>
</td></tr>
<tr><td><code id="Borda_+3A_k">k</code></td>
<td>

<p>An integer specifying the number of items in the output top-k list.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes Borda scores and ranks based on four different aggregation functions, in which the underlying spaces, where the individual ranked lists come from, are taken into account. The four aggregation functions are mean, median, geometric mean, and L2 norm.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>TopK</code></td>
<td>
<p>A matrix with 4 columns each corresponding to the rankings
by each of the 4 aggregation functions.</p>
</td></tr>
<tr><td><code>Scores</code></td>
<td>
<p>A matrix with 4 columns each corresponding to the Borda
scores from each of the 4 aggregation functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shili Lin &lt;shili@stat.osu.edu&gt;
</p>


<h3>References</h3>

<p>Lin, S. (2010). Space oriented rank-based data integration.
Statistical Applications in Genetics and Molecular Biology 9, Article 20.
</p>


<h3>See Also</h3>

<p><a href="#topic+geo.mean">geo.mean</a>, <a href="#topic+l2norm">l2norm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#get sample data
data(TopKSpaceSampleInput)

outBorda=Borda(input,space) #underlying space-dependent
outBorda1=Borda(input,space=input) #top-k spaces

</code></pre>

<hr>
<h2 id='Borda.plot'>
Plot Borda's scores against ranks
</h2><span id='topic+Borda.plot'></span>

<h3>Description</h3>

<p>Plotting Borda's scores against ranking can frequently reveal when information for
ranking starts to diminish. This function plots scores versus ranks after aggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Borda.plot(outBorda, k, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Borda.plot_+3A_outborda">outBorda</code></td>
<td>

<p>A list containing the output from running the Borda function.
</p>
</td></tr>
<tr><td><code id="Borda.plot_+3A_k">k</code></td>
<td>

<p>The number of scores to be plotted. If not supplied, all the scores in the output from Borda will be plotted.
</p>
</td></tr>
<tr><td><code id="Borda.plot_+3A_...">...</code></td>
<td>

<p>other parameters passed on to the plot function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of Borda's scores versus ranks.
</p>


<h3>Author(s)</h3>

<p>Shili Lin &lt;shili@stat.osu.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Borda">Borda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#get sample data
data(TopKSpaceSampleInput)
outBorda=Borda(input,space,k=40)
Borda.plot(outBorda, k=40)
</code></pre>

<hr>
<h2 id='breast'>Sample data from breast cancer expression</h2><span id='topic+breast'></span>

<h3>Description</h3>

<p>The example dataset comprises three lists of microarray results (differential gene
expression) from three breast cancer studies:
</p>

<ol>
<li><p> Strong Time Dependence of the 76-Gene Prognostic Signature (2007) labeled TransBig
</p>
</li>
<li><p> MicroArray Quality Control Phase II Project (2010) labeled MDCC
</p>
</li>
<li><p> A Clinically Relevant Gene Signature in Triple-Negative and Basal-Like Breast Cancer (2011) labeled Pusztai
</p>
</li></ol>

<p>Only genes (unique gene symbols) common to all studies are considered, therefore
each of the three lists has the length of N = 917.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(breast)</code></pre>


<h3>Format</h3>

<p>data.frame</p>


<h3>Source</h3>


<ol>
<li><p> TransBig: <a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=gse7390">GEO GSE7390</a>
</p>
</li>
<li><p> MDCC: <a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE20194">GEO GSE20194</a>
</p>
</li>
<li><p> Pusztai: <a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE20271">GEP GSE20271</a>
</p>
</li></ol>



<h3>References</h3>

<p>TransBig: Desmedt C, Piette F, Loi S, Wang Y et al. (2007).  Strong time dependence of the 76-gene prognostic signature for node-negative breast cancer patients in the TRANSBIG multicenter independent validation series. Clin Cancer Res, 1;13(11):3207-14. PMID: 17545524
</p>
<p>MDACC: Shi L, Campbell G, Jones WD, Campagne F et al. (2010). The MicroArray Quality Control (MAQC)-II study of common practices for the development and validation of microarray-based predictive models. Nat Biotechnol;28(8):827-38. PMID: 20676074
</p>
<p>Pusztai: Tabchy A., Valero V., Vidaurre T., Lluch A. et al. (2010). Evaluation of a 30-gene paclitaxel, fluorouracil, doxorubicin, and cyclophosphamide chemotherapy response predictor in a multicenter randomized trial in breast cancer. Clin Cancer Res 1;16(21):5351-61. PMID: 20829329
</p>

<hr>
<h2 id='calculate.maxK'>
The main function for TopKInference
</h2><span id='topic+calculate.maxK'></span>

<h3>Description</h3>

<p>Returns a complex object named truncated.lists containing the <code>Idata</code> vector (see <code>prepare.idata</code>), the estimated truncation index <code class="reqn">j_0=k+1</code> (see <code>compute.stream</code>) for each pair of input lists, the overall top-<em>k</em> estimate (see <code>j0.multi</code>), and other objects with necessary plotting information for the <code>aggmap</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.maxK(lists, L, d, v, threshold) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate.maxK_+3A_lists">lists</code></td>
<td>

<p>Data frame containing two or more columns that represent input lists of ordered objects subject to comparison
</p>
</td></tr>
<tr><td><code id="calculate.maxK_+3A_l">L</code></td>
<td>

<p>Number of input lists that are compared
</p>
</td></tr>
<tr><td><code id="calculate.maxK_+3A_d">d</code></td>
<td>

<p>The maximal distance delta between object ranks required for the estimation of <code class="reqn">j_0</code>
</p>
</td></tr>
<tr><td><code id="calculate.maxK_+3A_v">v</code></td>
<td>

<p>The pilot sample size (tuning parameter) <code class="reqn">\nu</code> required for the estimation of <code class="reqn">j_0</code>
</p>
</td></tr>
<tr><td><code id="calculate.maxK_+3A_threshold">threshold</code></td>
<td>

<p>The percentage of occurencies of an object in the top-<em>k</em> selection among all comparisons in order to be gray-shaded in the <code>aggmap</code> as a consolidated object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of the following content:
</p>
<table>
<tr><td><code>comparedLists</code></td>
<td>
<p>Contains information about the overlap of all pairwise compared lists (structure for the <code>aggmap</code>)</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>Contains information about the list names</p>
</td></tr>
<tr><td><code>grayshadedLists</code></td>
<td>
<p>Contains information which objects in a list are consolidated (gray-shaded in the <code>aggmap</code>)</p>
</td></tr>
<tr><td><code>summarytable</code></td>
<td>
<p>Table of top-<em>k</em> list overlaps containing rank information, the rank sum, the order of objects as a function of the rank sum, the frequency of an object in the input lists and the frequency of an object in the truncated lists (for plotting in the <code>aggmap</code>)</p>
</td></tr>
<tr><td><code>vennlists</code></td>
<td>
<p>Contains the top-<em>k</em> objects for each of the input lists (for display in the Venn-diagram)</p>
</td></tr>
<tr><td><code>venntable</code></td>
<td>
<p>Contains the overlap information (for display in the Venn-table)</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Selected pilot sample size (tuning parameter) <code class="reqn">\nu</code></p>
</td></tr>
<tr><td><code>Ntoplot</code></td>
<td>
<p>Number of columns to be plotted in the <code>aggmap</code></p>
</td></tr>
<tr><td><code>Idata</code></td>
<td>
<p>Data frame of Idata vectors (see <code>compute.stream</code>) for each pair of input lists and the associated delta's</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>selected delta</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>selected threshold</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>number of lists</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>number of items in data frame (lists)</p>
</td></tr>
<tr><td><code>lists</code></td>
<td>
<p>data frame of lists that entered the analysis</p>
</td></tr>
<tr><td><code>maxK</code></td>
<td>
<p>maximal estimate of the top-<em>k</em>'s (for all pairwise comparisons)</p>
</td></tr>
<tr><td><code>topkspace</code></td>
<td>
<p>the final integrated list of objects as result of the CEMC algorithm applied to the maxK truncated lists</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eva Budinska &lt;budinska@iba.muni.cz&gt;, Michael G. Schimek &lt;michael.schimek@medunigraz.at&gt;
</p>


<h3>References</h3>

<p>Hall, P. and Schimek, M. G. (2012). Moderate deviation-based inference for random degeneration in paired rank lists. J. Amer. Statist. Assoc., 107, 661-672.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CEMC">CEMC</a>, <a href="#topic+prepare.idata">prepare.idata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
data(breast)
truncated.lists = calculate.maxK(breast, d=6, v=10, L=3, threshold=50)
## Not run: 
aggmap(truncated.lists)

## End(Not run)
</code></pre>

<hr>
<h2 id='CEMC'>
CEMC based rank aggregation
</h2><span id='topic+CEMC'></span>

<h3>Description</h3>

<p>Performs Cross Entropy Monte Carlo simulations for generating combined ranked list using CEMC, taking into account the different spaces of ranked input lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEMC(input, space = NULL, k=NULL, dm = "k", kp = 0.5, N = NULL, N1 = NULL,
rho = 0.1, e1 = 0.1, e2 = 1, w = 0.5, b = 0, init.m = "p", init.w = 0,
d.w = NULL, input.par = NULL, extra=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CEMC_+3A_input">input</code></td>
<td>

<p>A list of several <code>TopKLists</code>, may have different length
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_space">space</code></td>
<td>

<p>A list of the same structure as the input list. Contains underlying spaces for the top-<em>k</em> lists. NULL means all lists share a common space, which is taken to be the union of all input lists
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_k">k</code></td>
<td>

<p>Desired length of combined list
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_dm">dm</code></td>
<td>

<p>Distance measure, &quot;s&quot; for Spearman, &quot;k&quot; for Kendall (p=0)
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_kp">kp</code></td>
<td>

<p>Partial distance used in Kendall's tau distance measure
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_n">N</code></td>
<td>

<p>Number of samples generated in each iterate
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_n1">N1</code></td>
<td>

<p>Number of samples retained after each iterate 
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_rho">rho</code></td>
<td>

<p>Proportion of samples used to estimate a new probability matrix
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_e1">e1</code></td>
<td>

<p>Stopping criterion with respect to the l1-norm of the difference of the two probability matrices between the current and previous iterations  
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_e2">e2</code></td>
<td>

<p>Stopping criterion with respect to the difference in the obtimizing criterion (e.g. the generalized Kemeny guideline) between the current and the previous iterations  
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_w">w</code></td>
<td>

<p>Weight of the new probability vector for the next iterate
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_b">b</code></td>
<td>

<p>Parameter used in blur function - this is for finding starting values for the algorithem
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_init.m">init.m</code></td>
<td>

<p>Initialization method, see the function <code>init.p</code> for details
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_init.w">init.w</code></td>
<td>

<p>Probability matrix initialization. (See Details)
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_d.w">d.w</code></td>
<td>

<p>Weights for distances from different input lists
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_input.par">input.par</code></td>
<td>

<p>Input parameters in a data.frame
</p>
</td></tr>
<tr><td><code id="CEMC_+3A_extra">extra</code></td>
<td>

<p>Number of additional items to be included in the combined ranked list during the 
calculation
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm implemented is the Order Explicit Algorithm, which is an iterative procedure to maximize an objective function (either based on Kendall's distance (dm=&quot;k&quot;) or Spearman's distance (dm=&quot;s&quot;)). 
</p>
<p>init.w: probability matrix initialization:
(1-init.w) * uniform +  init.w * estimated from input lists
</p>


<h3>Value</h3>

<p>A list containing three components:
</p>
<table>
<tr><td><code>TopK</code></td>
<td>
<p>A vector giving the aggregate ranked list.</p>
</td></tr>
<tr><td><code>ProbMatrix</code></td>
<td>
<p>A matrix, with each column represent the probability vector of a multinomial distribution and thus sum to 1.</p>
</td></tr>
<tr><td><code>input.par</code></td>
<td>
<p>A vector containing tuning parameters used in the current run. User may edit this vector and use it as input for a more refined analysis.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jie Ding &lt;jding@jimmy.harvard.edu&gt;, Shili Lin &lt;shili@stat.osu.edu&gt;
</p>


<h3>References</h3>

<p>Lin, S. and Ding, J. (2009). Integration of ranked lists via Cross Entropy Monte Carlo with applications to mRNA and microRNA studies. Biometrics, 65, 9-18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#small data set; a larger data example is available in the vignettes
L1=c("chicken","dog","cat")
L2=c(1,"chicken","cat", 2:5)
L3=c("dog","chicken",1:10)
input=list(L1,L2,L3)
space1=c("chicken","dog","cat",1:10)
space=list(space1,space1,space1)
outCEMC=CEMC(input, space) #underlying space-dependent
</code></pre>

<hr>
<h2 id='compute.stream'>
Calculates point of degeneration j0 into noise of the Idata, applying moderate deviation-based inference
</h2><span id='topic+compute.stream'></span>

<h3>Description</h3>

<p>The estimation of <code class="reqn">\hat{j}_0</code> is achieved via a moderate deviation-based approach. The probability that an estimator, computed from a pilot sample size <code class="reqn">\nu</code>, exceeds a value <em>z</em>, the deviation above <em>z</em> is said to be a moderate deviation if its associated probability is polynomially small as a function of <code class="reqn">\nu</code>, and to be a large deviation if the probability is exponentially small in <code class="reqn">\nu</code>.  The values of <code class="reqn">z=z_\nu</code> that are associated with moderate deviations are
<code class="reqn">z_\nu\equiv\bigl(C\,\nu^{-1}\,\log\nu\bigr)^{1/2}</code>, where <code class="reqn">C&gt;\frac{1}{4}</code>. The null hypothesis that <code class="reqn">p_k=\frac{1}{2}</code> for <code class="reqn">\nu</code> consecutive values of <em>k</em>, versus the alternative hypothesis that <code class="reqn">p_k&gt;\frac{1}{2}</code> for at least one of the values of <em>k</em>, is rejected when <code class="reqn">\hat{p}_j^\pm-\frac{1}{2}&gt;z_\nu</code>.  The probabilities <code class="reqn">\hat{p}_j^+</code> and <code class="reqn">\hat{p}_j^-</code> are estimates of <code class="reqn">p_j</code> computed from the <code class="reqn">\nu</code> data pairs <code class="reqn">I_\ell</code> for which <code class="reqn">\ell</code> lies immediately to the right of <em>j</em>, or immediately to the left of <em>j</em>, respectively. 
</p>
<p>The iterative algorithm consists of an ordered sequence of &quot;test stages&quot; <code class="reqn">s_1, s_2,\ldots</code>  In stage <code class="reqn">s_k</code> an integer <code class="reqn">J_{s_k}</code> is estimated, which is a potential lower bound to <code class="reqn">j_0</code> (when <code class="reqn">k</code> is odd), or a potential upper bound to <code class="reqn">j_0</code> (when <code class="reqn">k</code> is even).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.stream(Idata, const=0.251, v, r=1.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.stream_+3A_idata">Idata</code></td>
<td>

<p>Input data is a vector of 0s and 1s (see <code>prepare.idata</code>)
</p>
</td></tr>
<tr><td><code id="compute.stream_+3A_const">const</code></td>
<td>

<p>Denotes the constant C of the moderate deviation bound, needs to be larger than 0.25 (default is 0.251)
</p>
</td></tr>
<tr><td><code id="compute.stream_+3A_v">v</code></td>
<td>

<p>Denotes the pilot sample size <code class="reqn">\nu</code> related to the degree of randomness in the assignments. In each step the noise is estimated from the Idata as probability of 1 within the interval of size <code class="reqn">\nu</code>, moving from <code class="reqn">J_{s_{k-1}} -r \nu</code> if <code class="reqn">k</code> is odd or <code class="reqn">J_{s_{k-1}} +r \nu</code> if <code class="reqn">k</code> is even, until convergence or break (see <code>r</code>)
</p>
</td></tr>
<tr><td><code id="compute.stream_+3A_r">r</code></td>
<td>

<p>Denotes a technical constant determining the starting point from which the probability for <code class="reqn">I=1</code> is estimated in a window of size <code>v</code> (see <code>v</code>, default is 1.2)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing:
</p>
<table>
<tr><td><code>j0_est</code></td>
<td>
<p>Is the estimated index for which the <code>Idata</code> degenerate into noise</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p><code class="reqn">k=j0_est-1</code></p>
</td></tr>
<tr><td><code>reason.break</code></td>
<td>
<p>The reason why the computation has ended - convergence or break condition</p>
</td></tr>
<tr><td><code>js</code></td>
<td>
<p>Is the sequence of estimated <code class="reqn">j_0</code> in each iteration run, also showing the convergence behaviour</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Is the preselected value of the parameter <code class="reqn">\nu</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eva Budinska &lt;budinska@iba.muni.cz&gt;, Michael G. Schimek &lt;michael.schimek@medunigraz.at&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare.idata">prepare.idata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(465)
myhead &lt;- rbinom(20, 1, 0.8)
mytail &lt;- rbinom(20, 1, 0.5)
mydata &lt;- c(myhead, mytail)
compute.stream(mydata, v=10)	
</code></pre>

<hr>
<h2 id='deltaplot'>
An exploratory plot of discordance for delta selection.
</h2><span id='topic+deltaplot'></span>

<h3>Description</h3>

<p>Returns a graph of non-overlap (discordance) of rankings represented by the sum of zeros across all objects in the <code class="reqn">\delta</code>-dependent <code>Idata</code> vector (see <code>compute.stream</code>) for a suitable range of <code class="reqn">\delta</code> values starting at <code class="reqn">\delta=0</code>. Graphs are plotted for all pairwise list combinations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltaplot(lists, deltas=NULL, subset.lists=NULL, subplot = FALSE,
perc.subplot=50, directory=NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deltaplot_+3A_lists">lists</code></td>
<td>

<p>A data frame cotaining two or more columns that represent lists of ordered objects to be compared
</p>
</td></tr>
<tr><td><code id="deltaplot_+3A_deltas">deltas</code></td>
<td>

<p>The range of <code class="reqn">\delta</code> values to be examined, defaults to NULL. If not specified then <code>delta=c(1:nrow(lists)*0.25)</code>. If <code>max(deltas)</code> is larger than <code>nrow(lists)</code>, then <code>deltas=deltas[which(deltas&lt;nrow(lists)*0.25)]</code>, 
</p>
</td></tr>
<tr><td><code id="deltaplot_+3A_subset.lists">subset.lists</code></td>
<td>

<p>Specifies the subset of the input lists, which is used for calculating zero counts for the deltaplot. The value contained in <code>subset.lists</code> specifies which objects are taken for the calculation from each input list, e.g. a value of 100 would use the first 100 objects of each input list. Default is NULL, in which case all objects of each list are used. 
If specified and <code>max(deltas)</code> is larger than <code>subset.lists</code>, then <code>deltas=deltas[which(deltas&lt;subset.lists*0.25)]</code>, 
</p>
</td></tr>
<tr><td><code id="deltaplot_+3A_subplot">subplot</code></td>
<td>

<p>Logical: if TRUE an additional deltaplot is generated containing a detailed subplot positioned in the top right corner of the plot. This subplot encloses a configurable subset of the values of the original deltaplot. This subset can be specified via a percentage value using the <code>perc.subplot</code> parameter (default is FALSE for <code>subplot</code>).
</p>
</td></tr>
<tr><td><code id="deltaplot_+3A_perc.subplot">perc.subplot</code></td>
<td>

<p>Percentage of the range of the main plot used for creating a subplot in the top right corner, default is 50(%). Subplot provides a detailed view of the main plot.
</p>
</td></tr>
<tr><td><code id="deltaplot_+3A_directory">directory</code></td>
<td>

<p>Specifies the directory for saving the generated deltaplots in PDF
format. In case <code>directory</code> is <code>NULL</code> (default), no pdf is created, but a
new device will be opened.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Mdelta</code></td>
<td>
<p>A list of <code class="reqn">\delta</code>-matrices for each comparison of ordered lists</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eva Budinska &lt;budinska@iba.muni.cz&gt;, Vendula Svendova &lt;vendula.svendova@medunigraz.at&gt;, Michael G. Schimek &lt;michael.schimek@medunigraz.at&gt;
</p>


<h3>References</h3>

<p>Schimek, M. G. and Budinska, E. (2010). Visualization techniques for the integration of rank data. In Lechevallier, Y. and Saporta, G. (eds). COMPSTAT 2010. Proceedings in Computational Statistics. Heidelberg: Physica (e-book ISBN 978-3-7908-2603-6), 1637-1644.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
data(breast)
##plot subplot
a = deltaplot(breast, deltas = 1:50, subplot=TRUE)

##don't plot subplot (default)
a = deltaplot(breast, deltas=1:50, subplot = FALSE)
</code></pre>

<hr>
<h2 id='geo.mean'>
Calculate the geometric mean
</h2><span id='topic+geo.mean'></span>

<h3>Description</h3>

<p>Calculate the geometric mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo.mean(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo.mean_+3A_x">x</code></td>
<td>

<p>A vector of values
</p>
</td></tr>
<tr><td><code id="geo.mean_+3A_na.rm">na.rm</code></td>
<td>

<p>Whether missing values should be automatically removed from calculation
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The geometric mean
</p>


<h3>Author(s)</h3>

<p>Shili Lin &lt;shili@stat.osu.edu&gt;
</p>


<h3>References</h3>

<p>Lin, S. (2010)
Space oriented rank-based data integration.
Statistical Applications in Genetics and Molecular Biology 9, Article 20.
</p>


<h3>See Also</h3>

<p><a href="#topic+Borda">Borda</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(122)
vals &lt;- sample(1:100, 10)
geo.mean(vals)
</code></pre>

<hr>
<h2 id='init.p'>
Initialization method for probabilities
</h2><span id='topic+init.p'></span>

<h3>Description</h3>

<p>Initialization method for probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.p(topK, n, k, init.m = "p", init.w = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.p_+3A_topk">topK</code></td>
<td>

<p>A list of input lists, with items coded from 1 to <code>n</code>
</p>
</td></tr>
<tr><td><code id="init.p_+3A_n">n</code></td>
<td>

<p>Total number of items
</p>
</td></tr>
<tr><td><code id="init.p_+3A_k">k</code></td>
<td>

<p>Length of target list
</p>
</td></tr>
<tr><td><code id="init.p_+3A_init.m">init.m</code></td>
<td>

<p>Initialization method, &quot;p&quot; point mass, &quot;s&quot; smooth, &quot;cp&quot; point mass using composite ranks, &quot;cs&quot; smooth using composite ranks
</p>
</td></tr>
<tr><td><code id="init.p_+3A_init.w">init.w</code></td>
<td>

<p>initialization weight
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A probability matrix
</p>


<h3>Author(s)</h3>

<p>Jie Ding &lt;jding@jimmy.harvard.edu&gt;
</p>


<h3>References</h3>

<p>Lin, S., Ding, J. (2009)
Integration of Ranked Lists  via
Cross Entropy Monte Carlo with Applications to mRNA and microRNA
Studies. Biometrics 65, 9-18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

rank.pool &lt;- 1:10
a &lt;- sample(rank.pool, 10)
b &lt;- sample(rank.pool, 10)
c &lt;- sample(rank.pool, 10)
rlist &lt;- list(a, b, c)


init.p(rlist, length(unique(unlist(rlist))), 5, "cp")
</code></pre>

<hr>
<h2 id='j0.multi'>
Function returning an overall point j0 of degeneration into noise for multiple ranked lists
</h2><span id='topic+j0.multi'></span>

<h3>Description</h3>

<p>Moderate deviation-based calculation of an overall point <code class="reqn">j_0</code> of degeneration into noise for multiple ranked lists. The function takes a matrix of ordered lists and estimates a <code class="reqn">j_0</code> for each pair of the input lists (columns), with repect to the preselected distance parameter <code class="reqn">\delta</code>. This function combines the functions <code>compute.stream</code> and <code>prepare.Idata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j0.multi(lists, d, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j0.multi_+3A_lists">lists</code></td>
<td>

<p>Input data frame, where each column represents one list of ordered items
</p>
</td></tr>
<tr><td><code id="j0.multi_+3A_d">d</code></td>
<td>

<p>The maximal distance of an object's rank positions when two lists are compared. When the distance between the respective rank positions of the object is smaller or equal <code>d</code>, then the object is assigned the value 1, otherwise 0
</p>
</td></tr>
<tr><td><code id="j0.multi_+3A_v">v</code></td>
<td>

<p>Parameter for estimating <code class="reqn">j_0</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The smaller <code>d</code>, the stronger the assumption about the concordance of any two lists (<code>d=0</code> is assuming identical rankings of an object)
</p>


<h3>Value</h3>

<p>A list containing the maximal estimated indices of information degradation <code class="reqn">j_0</code> through all combinations of <em>L</em> lists:
</p>
<table>
<tr><td><code>maxK</code></td>
<td>
<p>Maximal estimated k through all combinations of two lists</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>Data frame of estimated <code class="reqn">j_0</code> for each pairwise comparison</p>
</td></tr>
<tr><td><code>Idata</code></td>
<td>
<p>Data stream vector of zeros and ones</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eva Budinska &lt;budinska@iba.muni.cz&gt;, Michael G. Schimek &lt;michael.schimek@medunigraz.at&gt;
</p>


<h3>References</h3>

<p>Hall, P. and Schimek, M. G. (2012). Moderate deviation-based inference for random degeneration in paired rank lists. J. Amer. Statist. Assoc., 107, 661-672.
</p>


<h3>See Also</h3>

<p><a href="#topic+compute.stream">compute.stream</a>, <a href="#topic+prepare.idata">prepare.idata</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4657)

lists &lt;- data.frame(L1=c("A","B","C","D","E","F","G","H","J","I","K","L","M","N"))
lists$L2 &lt;- c("B","C","A","E","G","F","G","J","K","L","M","N","I","H")
lists$L3 &lt;- sample(LETTERS[1:14])
res.j0.temp = j0.multi(lists, d=5, v=3)


</code></pre>

<hr>
<h2 id='Kendall.plot'>
Plot of the Kendall Criterion values
</h2><span id='topic+Kendall.plot'></span>

<h3>Description</h3>

<p>Plot of the Kendall Criterion values of aggregate ranked lists; useful for comparing performances of several algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kendall.plot(input, all.aggregates, space = NULL, algorithm = NULL, p =
0.5, w = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kendall.plot_+3A_input">input</code></td>
<td>

<p>A list object containing individual ranked lists.
</p>
</td></tr>
<tr><td><code id="Kendall.plot_+3A_all.aggregates">all.aggregates</code></td>
<td>

<p>A list comprising of aggregate top-<em>k</em> lists from different algorithms to be compared.
</p>
</td></tr>
<tr><td><code id="Kendall.plot_+3A_space">space</code></td>
<td>

<p>A list containing the underlying spaces. If not explicitly specified, all lists are treated as coming from a common space defined by the union of all input lists.
</p>
</td></tr>
<tr><td><code id="Kendall.plot_+3A_algorithm">algorithm</code></td>
<td>

<p>A vector listing the names corresponding to the algorithms used to construct the aggregate ranked lists all.aggregates.
</p>
</td></tr>
<tr><td><code id="Kendall.plot_+3A_p">p</code></td>
<td>

<p>A parameter between 0 and 1 for setting the distance of a pair of elements between two lists, if at least one of the elements is not in the underlying space of one of the list or if both elements belong to one list but neither belong
to the other list. (We recommend using <code>p=0.5</code> for a &quot;neutral approach&quot;.)
</p>
</td></tr>
<tr><td><code id="Kendall.plot_+3A_w">w</code></td>
<td>

<p>Weight vector assigned to the input list. Prior information on the reliability of each input list can be incorporated. The default is set to equal weight for each input list.
</p>
</td></tr>
<tr><td><code id="Kendall.plot_+3A_...">...</code></td>
<td>

<p>Other parameters passed on to the plot function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the weighted Kendall's distance between each of the aggregate ranked list with the input ranked lists and plot the computed distances.
</p>


<h3>Value</h3>

<p>A plot of Kendall's distance for each of the aggregate list.
</p>


<h3>Author(s)</h3>

<p>Shili Lin &lt;shili@stat.osu.edu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KendallMLists">KendallMLists</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#get sample data
data(TopKSpaceSampleInput)
outMC=MC(input,space)
all.aggregate=list(outMC$MC1.TopK,outMC$MC2.TopK,outMC$MC3.TopK)
Kendall.plot(input, all.aggregate,space, algorithm=c("MC1","MC2","MC3"))
</code></pre>

<hr>
<h2 id='Kendall2Lists'>
Calculate modified Kendall's tau distance
</h2><span id='topic+Kendall2Lists'></span><span id='topic+Kendall2Lists.c'></span>

<h3>Description</h3>

<p>Kendall's tau is equal to the number of adjunct pairwise exchanges required to convert one ranking into another. This modified version allows for partial lists to be compared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kendall2Lists(rank.a, rank.b, k.a, k.b, n, p = 0)
Kendall2Lists.c(rank.a, rank.b, k.a, k.b, n, p = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kendall2Lists_+3A_rank.a">rank.a</code></td>
<td>

<p>A single top-<em>k</em> list
</p>
</td></tr>
<tr><td><code id="Kendall2Lists_+3A_rank.b">rank.b</code></td>
<td>

<p>A vector of matrix form of top-<em>k</em> list(s) to be compared to the list <code>a</code>
</p>
</td></tr>
<tr><td><code id="Kendall2Lists_+3A_k.a">k.a</code></td>
<td>

<p>Value of <code>k</code> for <code>rank.a</code>
</p>
</td></tr>
<tr><td><code id="Kendall2Lists_+3A_k.b">k.b</code></td>
<td>

<p>Value of <code>k</code> for <code>rank.b</code>
</p>
</td></tr>
<tr><td><code id="Kendall2Lists_+3A_n">n</code></td>
<td>

<p>Total number of objects, numbered from 1 to n
</p>
</td></tr>
<tr><td><code id="Kendall2Lists_+3A_p">p</code></td>
<td>

<p>Distance added for tied pair (potential problem when <code>p != 0</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two implementations available. Pure R code in <code>kendall</code> and a faster implementation using native C code <code>kendall.c</code>.
</p>


<h3>Value</h3>

<p>Returns modified Kendall's tau distance against <code>a</code> for each list within <code>b</code> 
</p>


<h3>Author(s)</h3>

<p>Jie Ding &lt;jding@jimmy.harvard.edu&gt;
</p>


<h3>References</h3>

<p>Lin, S., Ding, J. (2009)
Integration of ranked lists via Cross Entropy Monte Carlo with applications to mRNA and microRNA studies. Biometrics 65, 9-18.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Spearman">Spearman</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
a &lt;- sample(1:10, 10)
b &lt;- sample(1:10, 10)
Kendall2Lists(a, b, 6, 6, 10)
Kendall2Lists.c(a, b, 6, 6, 10)
</code></pre>

<hr>
<h2 id='KendallMLists'>
KendallMLists
</h2><span id='topic+KendallMLists'></span>

<h3>Description</h3>

<p>Compute Kendall's tau criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KendallMLists(input, space = NULL, aggregate, p = 0.5, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KendallMLists_+3A_input">input</code></td>
<td>

<p>A list with each element being a top-<em>k</em> list to be aggregated; the top-<em>k</em> lists can be of variable lengths
</p>
</td></tr>
<tr><td><code id="KendallMLists_+3A_space">space</code></td>
<td>

<p>A list with each element being the underlying space from which the corresponding top-<em>k</em> list is derived
</p>
</td></tr>
<tr><td><code id="KendallMLists_+3A_aggregate">aggregate</code></td>
<td>

<p>The aggregate list (result) from any of the three classes of algorithms
</p>
</td></tr>
<tr><td><code id="KendallMLists_+3A_p">p</code></td>
<td>

<p>A parameter between 0 and 1 for setting the distance of a pair of elements between two lists,  
if at least one of the elements is not in the underlying space of one
of the list or if both elements belong to one list but neither belongs 
to the other list. (We recommend using <code>p=0.5</code> for a &quot;neutral approach&quot;.)
</p>
</td></tr>
<tr><td><code id="KendallMLists_+3A_w">w</code></td>
<td>

<p>Weight vector assigning a weight to each list 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Kendall's distance
</p>


<h3>Author(s)</h3>

<p>Shili Lin &lt;shili@stat.osu.edu&gt; 
</p>


<h3>References</h3>

<p>Lin, S., Ding, J. (2009)
Integration of ranked lists via Cross Entropy Monte Carlo with applications to mRNA and microRNA studies. Biometrics 65, 9-18.
</p>
<p>Lin, S. (2010)
Space oriented rank-based data integration. Statistical Applications in Genetics and Molecular Biology 9, Article 20.
</p>


<h3>See Also</h3>

<p><a href="#topic+Borda">Borda</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TopKSpaceSampleInput)
bb1=Borda(input,space)
w= c(2/(30 * (30 - 1)), 2/(25 * (25 - 1)), 2/(20 * (20 -+ 1)))
kc.ARM=KendallMLists(input, space, bb1[[1]][, 1], p = 0.5, w = w)
</code></pre>

<hr>
<h2 id='l2norm'>
Calculate the L2 norm
</h2><span id='topic+l2norm'></span>

<h3>Description</h3>

<p>Calculated the L2 norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l2norm(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l2norm_+3A_x">x</code></td>
<td>

<p>Objects for which the L2 norm is to be calculated
</p>
</td></tr>
<tr><td><code id="l2norm_+3A_na.rm">na.rm</code></td>
<td>

<p>Whether or not to remove NA values from the calculation
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The L2 norm of <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Shili Lin &lt;shili@stat.ohio-state.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(122)
vals &lt;- sample(1:100, 10)
l2norm(vals)
</code></pre>

<hr>
<h2 id='MC'>
Markov chain based rank aggregation
</h2><span id='topic+MC'></span>

<h3>Description</h3>

<p>Aggregating ranked lists using three  Markov chain algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC(input, space = NULL, k = NULL, a = 0.15, delta = 10^-15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC_+3A_input">input</code></td>
<td>

<p>A list containing individual ranked lists.
</p>
</td></tr>
<tr><td><code id="MC_+3A_space">space</code></td>
<td>

<p>A list containing the underlying spaces. If not explicitly specified, all lists are treated as coming from a common space defined by the union of all input lists.
</p>
</td></tr>
<tr><td><code id="MC_+3A_k">k</code></td>
<td>

<p>An integer specifying the number of items in the output top-k list.
</p>
</td></tr>
<tr><td><code id="MC_+3A_a">a</code></td>
<td>

<p>Tuning parameter to make sure Markov Chain with the transition matrix is ergodic;
default set to 0.15.
</p>
</td></tr>
<tr><td><code id="MC_+3A_delta">delta</code></td>
<td>

<p>Convergence criterion for stationary distribution; default set to 10^-15.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructs ergodic Markov Chain based on ranking data from individual lists. A larger probability in the stationary distribution corresponds to a higher rank of the corresponding element. The algorithm are considered: MC1 (spam sensitive), MC2 (majority rule), and MC3 (proportional).
</p>


<h3>Value</h3>

<p>A list of elements, two for each of the MC algorithms: 
</p>
<table>
<tr><td><code>MC1.TopK</code></td>
<td>
<p>A vector of aggregate ranked elements based on <code>MC1</code> algorithm.</p>
</td></tr>
<tr><td><code>MC1.Prob</code></td>
<td>
<p>Stationary probability distribution: a vector of probabilities corresponding to the ranked elements in <code>MC1.TopK</code></p>
</td></tr>
<tr><td><code>MC2.TopK</code></td>
<td>
<p>A vector of aggregate ranked elements based on MC2 algorithm.</p>
</td></tr>
<tr><td><code>MC2.Prob</code></td>
<td>
<p>Stationary probability distribution: a vector of probabilities corresponding to the ranked elements in <code>MC2.TopK</code></p>
</td></tr>
<tr><td><code>MC3.TopK</code></td>
<td>
<p>A vector of aggregate ranked elements based on MC3 algorithm.</p>
</td></tr>
<tr><td><code>MC3.Prob</code></td>
<td>
<p>Stationary probability distribution: a vector of probabilities corresponding to the ranked elements in <code>MC3.TopK</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shili Lin &lt;shili@stat.osu.edu&gt;
</p>


<h3>References</h3>

<p>Lin, S. (2010). Space oriented rank-based data integration.
Statistical Applications in Genetics and Molecular Biology 9, Article 20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Borda">Borda</a></code>, <code><a href="#topic+CEMC">CEMC</a></code>, <code><a href="#topic+MC.plot">MC.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#get sample data
data(TopKSpaceSampleInput)
outMC=MC(input,space) #underlying space-dependent
outMCa=MC(input,space=input) #top-k spaces
MC.plot(outMC)
</code></pre>

<hr>
<h2 id='MC.plot'>
Plot of the ordered stationary probabilities
</h2><span id='topic+MC.plot'></span>

<h3>Description</h3>

<p>Plot of the ordered stationary probabilities versus ranking contains useful information
regarding the relative rankings of elements. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
MC.plot(outMC, k, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC.plot_+3A_outmc">outMC</code></td>
<td>

<p>Output (a list) from running the MC algorithm 
</p>
</td></tr>
<tr><td><code id="MC.plot_+3A_k">k</code></td>
<td>

<p>Number of stationary probabilities to be plotted. If missing, all stationary probabilities contained in the <code>MC</code> output will be plotted
</p>
</td></tr>
<tr><td><code id="MC.plot_+3A_...">...</code></td>
<td>

<p>Other parameters passed on the the plot function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of ordered stationary probabilities versus ranking.
</p>


<h3>Author(s)</h3>

<p>Shili Lin &lt;shili@stat.osu.edu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MC">MC</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#get sample data
data(TopKSpaceSampleInput)
outMC=MC(input,space)
MC.plot(outMC)
</code></pre>

<hr>
<h2 id='MC.ranks'>
MC based rank aggregation
</h2><span id='topic+MC.ranks'></span>

<h3>Description</h3>

<p>Compute aggregate ranks based on the transition matrix from the three Markov Chain algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC.ranks(elements, trans, a, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC.ranks_+3A_elements">elements</code></td>
<td>

<p>Unique elements of the union of all input lists - second element of the output list from function <code>trans.matrix</code>
</p>
</td></tr>
<tr><td><code id="MC.ranks_+3A_trans">trans</code></td>
<td>

<p>One of the three transition matrices build by function <code>trans.matrix</code> - 4 (5 or 6)
elements of the output list from function <code>trans.matrix</code>
</p>
</td></tr>
<tr><td><code id="MC.ranks_+3A_a">a</code></td>
<td>

<p>Tuning parameter to make sure Markov Chain with the transition matrix is ergodic; parameter value passed from <code>MC</code>.
</p>
</td></tr>
<tr><td><code id="MC.ranks_+3A_delta">delta</code></td>
<td>

<p>Convergence criterion for stationary distribution; parameter value passed from <code>MC</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute stationary distribution based on a Markov Chain transition matrix built with function <code>trans.matrix</code>.
</p>


<h3>Value</h3>

<p>A list with 3 components:
</p>
<table>
<tr><td><code>comp1</code></td>
<td>
<p>Number of iterations to reach the stationary distribution</p>
</td></tr>
<tr><td><code>comp2</code></td>
<td>
<p>The stationary distribution</p>
</td></tr>
<tr><td><code>comp3</code></td>
<td>
<p>The rankings based on the stationary distribution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shili Lin &lt;shili@stat.osu.edu&gt;
</p>


<h3>References</h3>

<p>Lin, S. (2010)
Space oriented rank-based data integration. Statistical Applications in Genetics and Molecular Biology 9, Article 20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MC">MC</a>, <a href="#topic+trans.matrix">trans.matrix</a></code>
</p>

<hr>
<h2 id='prepare.idata'>
Prepare Idata vector of 0's and 1's
</h2><span id='topic+prepare.idata'></span>

<h3>Description</h3>

<p>Function creates a data stream vector of zeros and ones (<code>Idata</code>) based on the preselected distance delta of the paired ordered lists. The obtained vector is further used as an input for <code>compute.stream</code>, a function that estimates the index position of information degradation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare.idata(x, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.idata_+3A_x">x</code></td>
<td>

<p>Data matrix or data frame, where the columns represent the lists of objects ordered according those rankings obtained from two different assessments. 
</p>
</td></tr>
<tr><td><code id="prepare.idata_+3A_d">d</code></td>
<td>

<p>The maximal distance between two lists for a ranked object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data stream vector is created as follows: if diff(rank1, rank2) of an individual object is less or equal <code>delta</code>, then 1 is assigned; otherwise 0. The smaller the <code>delta</code> value, the stronger the assumption of concordance for the paired ranked lists. When <code>delta=0</code>, the condition returns 1 for an object if and only if its rankings in the two lists are identical (the two objects share the same row).
</p>


<h3>Value</h3>

<p>The result is an object of type <code>Idata</code>, which is a list containing the data stream vector of zeros and ones, and the information about the applied distance <code>delta</code>
</p>
<table>
<tr><td><code>Idata</code></td>
<td>
<p>Data stream vector of zeros and ones</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>The applied <code>delta</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eva Budinska &lt;budinska@iba.muni.cz&gt;, Michael G. Schimek &lt;michael.schimek@medunigraz.at&gt;
</p>


<h3>See Also</h3>

<p><a href="#topic+compute.stream">compute.stream</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4568)
A &lt;- sample(1:20, 20)
B &lt;- sample(1:20, 20)
C &lt;- sample(1:20, 20)
mm &lt;- data.frame(A, B, C, row.names=LETTERS[1:20])
prepare.idata(mm, d=10)

# The breast cancer example
data(breast)
Idata1 = prepare.idata(breast[,c(1,3)], d=10)
# or 
Idata2 = prepare.idata(breast[,c(1,2)], d=10)
# compare to
Idata2 = prepare.idata(breast, d=10)
</code></pre>

<hr>
<h2 id='Spearman'>
Modified Spearman's footrule distance
</h2><span id='topic+Spearman'></span>

<h3>Description</h3>

<p>Spearman's footrule is a measure for distance between ranked lists. It is given as the sum of absolute differences between ranks of two lists. Here a modified version is implemented that allows for comparing partial lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spearman(rank.a, rank.b, k.a, k.b, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spearman_+3A_rank.a">rank.a</code></td>
<td>

<p>A single top-<em>k</em> list
</p>
</td></tr>
<tr><td><code id="Spearman_+3A_rank.b">rank.b</code></td>
<td>

<p>A vector of matrix form of top-<em>k</em> list(s) to be compared to the list <code>a</code>
</p>
</td></tr>
<tr><td><code id="Spearman_+3A_k.a">k.a</code></td>
<td>

<p>Value of <code>k</code> for <code>rank.a</code>
</p>
</td></tr>
<tr><td><code id="Spearman_+3A_k.b">k.b</code></td>
<td>

<p>Value of <code>k</code> for <code>rank.b</code>
</p>
</td></tr>
<tr><td><code id="Spearman_+3A_n">n</code></td>
<td>

<p>Total number of objects, numbered from 1 to n
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns modified Spearman distance against <code>a</code> for each lists within <code>b</code> 
</p>


<h3>Author(s)</h3>

<p>Jie Ding &lt;jding@jimmy.harvard.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kendall2Lists">Kendall2Lists</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
a &lt;- sample(1:10, 10)
b &lt;- sample(1:10, 10)
Spearman(a, b, 6, 6, 10)

</code></pre>

<hr>
<h2 id='TopKLists-package'>
Inference, aggregation and visualization for top-<em>k</em> ranked lists
</h2><span id='topic+TopKLists'></span>

<h3>Description</h3>

<p>Web search engines or microarray laboratory devices, among other new technologies, produce very long lists of distinct items or objects in rank order. The statistical task is to identify common top-ranking objects from two or more lists and to form sublists of consolidated items. In each list, the rank position might be due to a measure of strength of evidence, to a preference, or to an assessment either based on expert knowledge or a technical device. For each object, it is assumed that its rank assignment in one list is independent of its rank assignments in the other lists. The ranking is from 1 to <em>N</em> throughout without ties. For a general definition of ranked lists see Schimek (2011).
</p>
<p>Starting with the work of Mallows (1957), there is a substantial model-based literature on problems in combining rankings where the number of items <em>N</em> is relatively small, and significantly less than the number <em>L</em> of assessors (rankings). These well-known parametric approaches cannot handle data of the type described above with <em>N&gt;&gt;L</em> and <em>N</em> huge. Dwork et al. (2001) and DeConde et al. (2006) were the first to address such large-scale rank aggregation problems in the context of Web search engine technology and high-throughput biotechnology, repectively. Here our task is not limited to the aggregation of rankings, we also consider the problem of ranked lists where the reliability of rankings breaks down after the first (top) <em>k</em> objects due to error or lack of discriminatory information. In response to the above requirements, we have implemented various distribution-free, and at the same time computationally highly efficient, stochastic approaches because list consolidation by means of brute force (e.g. combinatorial approaches) is limited to the situation where both <em>N</em> and <em>L</em> are impractically small.
</p>
<p>For multiple full ranked (input) lists representing the same set of <em>N</em> objects, the package <code style="white-space: pre;">&#8288;TopKLists&#8288;</code> offers (1) statistical inference on the lengths of informative (top-<em>k</em>) partial lists, (2) stochastic aggregation of full or partial lists, and (3) graphical tools for the statistical exploration of input lists, and for aggregation visualization. Our implementations are based on recently developed methods as outlined in Hall and Schimek (2012), Lin (2010a), Lin and Ding (2009), and Schimek, Mysickova and Budinska (2012). Whenever you use the package, please refer to Hall and Schimek (2012) and Lin and Ding (2009) and Schimek et al. (2015) (for full citation please see below).</p>


<h3>Details</h3>

<p>The package consists of three modules and a graphical user interface
(GUI):
</p>

<ul>
<li><p> (1) <code style="white-space: pre;">&#8288;TopKInference&#8288;</code> provides exploratory nonparametric inference for the estimation of the top-<em>k</em> list length of paired rankings;
</p>
</li>
<li><p> (2) <code style="white-space: pre;">&#8288;TopKSpace&#8288;</code> provides several rank aggregation techniques (Borda, Markov chain, and Cross Entropy Monte Carlo) which allow the combination of input lists even when the rank positions of some objects are not present in all the lists (so-called <em>partial input lists</em>);
</p>
</li>
<li><p> (3) <code style="white-space: pre;">&#8288;TopKGraphics&#8288;</code> provides a collection of graphical tools for visualization of the inputs to and the outputs from the other modules.
</p>
</li></ul>

<p>Highly convenient is a new aggregation mapping tool called <code>aggmap</code> in <code style="white-space: pre;">&#8288;TopKGraphics&#8288;</code>. The GUI allows the non-statistician an easy access to the practically most relevant techniques provided in <code style="white-space: pre;">&#8288;TopKInference&#8288;</code>, <code style="white-space: pre;">&#8288;TopKSpace&#8288;</code>, and <code style="white-space: pre;">&#8288;TopKGraphics&#8288;</code>. Due to the exploratory nature of the implemented methods, tuning parameters are required. All those having a strong impact on the results can be controlled via the GUI. For additional program details and a bioscience application see Schimek et al. (2011). For aspects of modelling the rank order of Web search engine results see Schimek and Bloice (2012). A Springer monograph by Schimek, Lin and Wang of the title &ldquo;Statistical Integration of Omics Data&rdquo; is in preparation.</p>


<h3>Author(s)</h3>

<p>Michael G. Schimek, Eva Budinska, Jie Ding, Karl G. Kugler, Vendula Svendova, Shili Lin. 
</p>


<h3>References</h3>

<p>DeConde R. et al. (2006). Combining results of microarray experiments: a rank aggregation approach. Statist. Appl. Genet. Mol. Biol., 5, Article 15.
</p>
<p>Dwork, C. et al. (2001). Rank aggregation methods for the Web. <a href="http://www10.org/cdrom/papers/577/">http://www10.org/cdrom/papers/577/</a>
</p>
<p>Hall, P. and Schimek, M. G. (2012). Moderate deviation-based inference for random degeneration in paired rank lists. J. Amer. Statist. Assoc., 107, 661-672.
</p>
<p>Lin, S. (2010a). Space oriented rank-based data integration. Statist. Appl. Genet. Mol. Biol., 9, Article 20.
</p>
<p>Lin, S. (2010b). Rank aggregation methods. Wiley Interdisciplinary Reviews: Computational Statistics, 2, 555-570.
</p>
<p>Lin, S. and Ding, J. (2009). Integration of ranked lists via Cross Entropy Monte Carlo with applications to mRNA and microRNA studies. Biometrics, 65, 9-18. 
</p>
<p>Mallows, C. L. (1957). Non null ranking models I. Biometrika, 44, 114-130.
</p>
<p>Schimek, M. G. (2011). Statistics on Ranked Lists. In Lovric, M. (ed). International Encyclopedia of Statistical Science. Berlin: Springer, Part 19, 1487-1491, DOI: 10.1007/978-3-642-04898-2_563.
</p>
<p>Schimek, M. G. and Bloice, M. (2012). Modelling the rank order of Web search engine results. In Komarek, A. and Nagy, S. (eds). Proceedings of the 27th International Workshop on Statistical Modelling. (e-book ISBN 978-80-263-0250-6), Vol. 1, 303-308. 
</p>
<p>Schimek, M. G. and Budinska, E. (2010). Visualization Techniques for the Integration of Rank Data. In Lechevallier, Y. and Saporta, G. (eds). COMPSTAT 2010. Proceedings in Computational Statistics. Heidelberg: Physica (e-book ISBN 978-3-7908-2603-6), 1637-1644.
</p>
<p>Schimek, M. G., Budinska, E., Kugler, K. and Lin, S. (2011). Package &ldquo;TopKLists&rdquo; for rank-based genomic data integration. Proceedings of CompBio 2011, 434-440, DOI: 10.2316/P.2011.742-032.
</p>
<p>Schimek, M. G., Budinska, E., Kugler, K. G., Svendova, V., Ding, J., Lin, S. (2015). TopKLists: a comprehensive R package for statistical inference, stochastic aggregation, and visualization of multiple omics ranked lists. Statistical Applications in Genetics and Molecular Biology, 14(3): 311-316.
</p>
<p>Schimek, M. G., Mysickova, A. and Budinska, E. (2012). An inference and integration approach for the consolidation of ranked lists. Communications in Statistics - Simulation and Computation, 41:7, 1152-1166. 
</p>
<p>Schimek, M. G., Lin, S. and Wang, N. (2015). Statistical Integration of Omics Data. In preparation. New York: Springer.
</p>


<h3>See Also</h3>

<p>Project homepage: <a href="http://topklists.r-forge.r-project.org">http://topklists.r-forge.r-project.org</a>
</p>

<hr>
<h2 id='TopKListsGUI'>
TopKListsGUI for inference and visualization
</h2><span id='topic+TopKListsGUI'></span>

<h3>Description</h3>

<p>This function opens a RGUI window and allows the user to select the parameters for the distance <code class="reqn">\delta</code>, for the pilot sample size <code class="reqn">\nu</code>, and the threshold for the <code>aggmap</code> presentation. Based on the selected parameters, a pairwise estimation of the top-<em>k</em> lists overlap is performed with switching reference lists (e.g. L1 with L2 and L2 with L1). Based on these estimates, all involved lists are truncated and the maximum of the <code class="reqn">\hat{k}_i</code> estimates is selected by default. The individual results of each combination of ranked lists are displayed automatically in the RGUI window and saved to a prespecified folder. After the maximal truncation point is estimated, <code>CEMC</code> algorithm is applied to generate the final list of top-<em>k</em> objects.
</p>
<p>The consolidated top-<em>k</em> list results can be displayed in three different formats controlled by tabs: 
</p>
<p>(1)'Aggregation map': It is a special type of heatmap, where the truncated lists are ordered from left to right, from the one with the largest overlap with all the others to the one with the lowest overlap. For details see the description of the <code>aggmap</code>.
(2) 'Summary table': An interactive table that displays the set of overlapping objects in dependence of the selected parameters. 
(3) 'Venn-diagram &amp; Venn-table': A Venn-diagram and a Venn-table of the overlapping objects based on all truncated input lists. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TopKListsGUI(lists, autorange.delta = FALSE, override.errors = TRUE,
venndiag.pdf.size = c(7, 7), venndiag.size = c(380, 420),
gui.size = c(900, 810), directory = NULL, venndiag.res = 70, aggmap.res = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TopKListsGUI_+3A_lists">lists</code></td>
<td>
<p>A data frame of ordered lists of objects - rows represent the objects, columns represent the individual input lists
</p>
</td></tr>
<tr><td><code id="TopKListsGUI_+3A_autorange.delta">autorange.delta</code></td>
<td>
<p>If TRUE, results for all <code class="reqn">\delta</code> values leading to the  <code class="reqn">\hat{k}_i</code> estimates (as function of the parameters specified by the user) will be displayed (note, for a large list length <em>N</em> this can take quite some time, because the <code class="reqn">\delta</code> range examined is from 0 to <code>nrow(lists)</code> by steps of 1). If FALSE, then the user defines the <code class="reqn">\delta</code> range (min and max) in the RGUI window 
</p>
</td></tr>
<tr><td><code id="TopKListsGUI_+3A_override.errors">override.errors</code></td>
<td>
<p>If TRUE, errors due to an inappropriate value selection are overridden and the calculation continues for all other <code class="reqn">\delta</code> values, but there is no output for viewing in the GUI corresponding to that combination of values which has caused the error; defaults to TRUE 
</p>
</td></tr>
<tr><td><code id="TopKListsGUI_+3A_venndiag.pdf.size">venndiag.pdf.size</code></td>
<td>
<p>A numeric vector defining the width and height of the Venn-diagram plot - it is passed to the <code>pdf()</code> function that saves the plot; defaults to c(7, 7)
</p>
</td></tr>
<tr><td><code id="TopKListsGUI_+3A_venndiag.size">venndiag.size</code></td>
<td>
<p>A numeric vector defining the width and height of the Venn-diagram plot - it is passed to the <code>png()</code> function that saves the plot; defaults to c(380, 420)
</p>
</td></tr>
<tr><td><code id="TopKListsGUI_+3A_gui.size">gui.size</code></td>
<td>
<p>A numeric vector defining the width and height of the RGUI to be displayed; defaults to c(900, 810)
</p>
</td></tr>
<tr><td><code id="TopKListsGUI_+3A_directory">directory</code></td>
<td>
<p>Specification of the name of the directory where the results and plots should be saved (including some temporary files required for the calculations). If kept <code>NULL</code> a directory called &quot;TopKLists-temp&quot; will be created in <code>getwd()</code>. In that case a write permission is needed for <code>getwd()</code>.
</p>
</td></tr>
<tr><td><code id="TopKListsGUI_+3A_venndiag.res">venndiag.res</code></td>
<td>
<p>A number defining the resolution of the Venn-diagram plot - this argument is passed to the <code>res = argument</code> of the <code>png()</code> function saving the diagram, but affects also the RGUI display; defaults to 70
</p>
</td></tr>
<tr><td><code id="TopKListsGUI_+3A_aggmap.res">aggmap.res</code></td>
<td>
<p>A number defining the resolution of the <code>aggmap</code> plot - this argument is passed to the <code>res = argument</code> of the <code>png()</code> function saving the plot, but affects also the RGUI display; defaults to 100
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RGUI window with three tabs:
</p>
<p>'Aggregation map':  For an index <code class="reqn">p=1,2,\ldots,L-1</code> aggregation levels (groupings of top lists) are combined in one display. For each group of <em>L-p</em> truncated lists down to the smallest group consisting of just one pair of lists, (1) an arbitrary reference list (&quot;ground truth&quot;) is selected under the condition that it comprises <code class="reqn">\max_i(\hat{k}_i)</code> items among all pairwise comparisons in the group of rankings, (2) symbols of its <code class="reqn">\max_i(\hat{k}_i)</code> items are printed vertically from the highest to the lowest rank position, and (3) the aggregation information for all remaining <em>L-p</em> rankings in the group is added, ordered according to descending list length. 
</p>
<p>'Summary table': An interactive table that displays all overlapping (grey) objects based on the truncated list comparison. Rank sum per object and frequency of each object in the input lists or truncated lists are calculated over all compared lists. The first column denotes if an object was selected by the CEMC algorithm for the final set of common objects. The table can be ordered according to any of the displayed columns. 
</p>
<p>'Venn-diagram &amp; Venn-table': The Venn-diagram and the Venn-table display the rank intersection of the identified top-<em>k</em> objects in two different formats. 
</p>
<p>These tabs automatically save all plots and tables into the specified directory.
</p>
<p>The following additional exploratory features are implemented:
</p>
<p>'Deltaplot' (see <code>deltaplot</code>): For a preselected range of <code class="reqn">\delta</code>'s and all list pairs, an exploratory plot of rank discordance is created and saved (function not part of the RGUI window).
</p>
<p>'Mdelta' (see <code>deltaplot</code>): For a preselected range of <code class="reqn">\delta</code>'s and all list pairs, Delta-matrices are created and saved (function not part of the RGUI window) in one <code>rdata</code> object (<code>Mdelta.rdata</code>). Each delta-matrix is saved individually in a tab delimited <code>.txt</code>-file.
</p>


<h3>Author(s)</h3>

<p>Eva Budinska &lt;budinska@iba.muni.cz&gt;, Karl G. Kugler &lt;kg.kugler@gmail.com&gt;, Michael G. Schimek &lt;michael.schimek@medunigraz.at&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CEMC">CEMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(breast)
TopKListsGUI(breast)

## End(Not run)

</code></pre>

<hr>
<h2 id='TopKSample'>
Sampler to generate N top-k lists according to p
</h2><span id='topic+TopKSample'></span><span id='topic+TopKSample.c'></span>

<h3>Description</h3>

<p>Sampler to generate <em>N</em> top-<em>k</em> lists according to <em>p</em>. A function wrapping to a native C implementation is available as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TopKSample(p, N)
TopKSample.c(p, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TopKSample_+3A_p">p</code></td>
<td>

<p>Matrix of dimension n*(k+1), n is the number of items (to be ranked) and k is the top elements in the joint ranking. Each column is a multinomial probability vector.
</p>
</td></tr>
<tr><td><code id="TopKSample_+3A_n">N</code></td>
<td>

<p>The number of samples
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pure R implementation <code>TopKSample</code> and a native C method <code>TopKSample.c</code> are available.
</p>


<h3>Value</h3>

<p>N TopKlists
</p>


<h3>Note</h3>

<p>By default the C implementation is used due to its better performance.
</p>


<h3>Author(s)</h3>

<p>Jie Ding &lt;jding@jimmy.harvard.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
rank.pool &lt;- 1:10
a &lt;- sample(rank.pool, 10)
b &lt;- sample(rank.pool, 10)
c &lt;- sample(rank.pool, 10)
M &lt;- cbind(a, b, c)

TopKSample.c(M, 4)

</code></pre>

<hr>
<h2 id='TopKSpaceSampleInput'>
Sample input for TopKSpace functions
</h2><span id='topic+TopKSpaceSampleInput'></span><span id='topic+input'></span><span id='topic+space'></span>

<h3>Description</h3>

<p>Sample input for <code style="white-space: pre;">&#8288;TopKSpace&#8288;</code> functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TopKSpaceSampleInput)</code></pre>


<h3>Format</h3>

<p>Two sets of lists for the demonstration of the usage of <code style="white-space: pre;">&#8288;TopKSpace&#8288;</code>-related functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TopKSpaceSampleInput)
str(input)
str(space)
</code></pre>

<hr>
<h2 id='trans.matrix'>
Compute transition matrices
</h2><span id='topic+trans.matrix'></span>

<h3>Description</h3>

<p>Builds transition matrices for all three Markov Chain algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans.matrix(input, space)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans.matrix_+3A_input">input</code></td>
<td>

<p>A list containing individual ranked lists
</p>
</td></tr>
<tr><td><code id="trans.matrix_+3A_space">space</code></td>
<td>

<p>A list containing the underlying spaces
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both input and space are lists of the same <code>length = nList</code>
</p>


<h3>Value</h3>

<p>The output is a list: 
</p>
<table>
<tr><td><code>L</code></td>
<td>
<p>Unique elements of the union of all input ranked lists</p>
</td></tr>
<tr><td><code>MC1</code></td>
<td>
<p>The transition matrix constructed from the MC1 algorithm</p>
</td></tr>
<tr><td><code>MC2</code></td>
<td>
<p>The transition matrix constructed from the MC2 algorithm</p>
</td></tr>
<tr><td><code>MC3</code></td>
<td>
<p>The transition matrix constructed from the MC3 algorithm</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shili Lin &lt;shili@stat.osu.edu&gt;
</p>


<h3>References</h3>

<p>Lin, S. (2010)
Space oriented rank-based data integration.
Statistical Applications in Genetics and Molecular Biology 9, Article 20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MC">MC</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
