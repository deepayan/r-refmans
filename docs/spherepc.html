<!DOCTYPE html><html><head><title>Help for package spherepc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spherepc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Cal.recon'><p>Calculating reconstruction error</p></a></li>
<li><a href='#Crossprod'><p>Crossproduct of vectors</p></a></li>
<li><a href='#Dist.pt'><p>The number of distinct points.</p></a></li>
<li><a href='#Earthquake'><p>Earthquake</p></a></li>
<li><a href='#Expmap'><p>Exponential map</p></a></li>
<li><a href='#ExtrinsicMean'><p>Finding Extrinsic Mean</p></a></li>
<li><a href='#GenerateCircle'><p>Generating circle on sphere</p></a></li>
<li><a href='#IntrinsicMean'><p>Finding Intrinsic Mean</p></a></li>
<li><a href='#Kernel.Gaussian'><p>Gaussian kernel function</p></a></li>
<li><a href='#Kernel.indicator'><p>Indicator kernel function</p></a></li>
<li><a href='#Kernel.quartic'><p>Quartic kernel function</p></a></li>
<li><a href='#Logmap'><p>Logarithm map</p></a></li>
<li><a href='#LPG'><p>Local principal geodesics</p></a></li>
<li><a href='#PGA'><p>Principal geodesic analysis</p></a></li>
<li><a href='#PrincipalCircle'><p>Principal circle on a sphere</p></a></li>
<li><a href='#Proj.Hauberg'><p>Projecting the nearest point</p></a></li>
<li><a href='#Rotate'><p>Rotating point on a sphere</p></a></li>
<li><a href='#Rotate.inv'><p>Rotating point on a sphere</p></a></li>
<li><a href='#SPC'><p>Spherical principal curves</p></a></li>
<li><a href='#SPC.Hauberg'><p>principal curves by Hauberg on a sphere</p></a></li>
<li><a href='#Trans.Euclid'><p>Transforming into Euclidean coordinate</p></a></li>
<li><a href='#Trans.sph'><p>Transforming into spherical coordinate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spherical Principal Curves</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Author:</td>
<td>Jongmin Lee [aut, cre],
  Jang-Hyun Kim [ctb],
  Hee-Seok Oh [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jongmin Lee &lt;jongminlee9218@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fitting dimension reduction methods to data lying on two-dimensional sphere.
    This package provides principal geodesic analysis, principal circle, principal curves 
    proposed by Hauberg, and spherical principal curves. Moreover, it offers the method of locally   
    defined principal geodesics which is underway. The detailed procedures 
    are described in Lee, J., Kim, J.-H. and Oh, H.-S. (2021) &lt;<a href="https://doi.org/10.1109%2FTPAMI.2020.3025327">doi:10.1109/TPAMI.2020.3025327</a>&gt;. 
    Also see Kim, J.-H., Lee, J. and Oh, H.-S. (2020) &lt;<a href="https://arxiv.org/abs/2003.02578">arXiv:2003.02578</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>geosphere, rgl, sphereplot, stats</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>XQuartz (on MacOS)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-07 00:54:46 UTC; jongminlee</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-07 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Cal.recon'>Calculating reconstruction error</h2><span id='topic+Cal.recon'></span>

<h3>Description</h3>

<p>This function calculates reconstruction error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cal.recon(data, line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cal.recon_+3A_data">data</code></td>
<td>
<p>matrix or data frame consisting of spatial locations with two columns.
Each row represents longitude and latitude.</p>
</td></tr>
<tr><td><code id="Cal.recon_+3A_line">line</code></td>
<td>
<p>longitude and latitude of a line as a matrix or data frame with two columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates reconstruction error from the data to the line. Longitude should range from -180 to 180 and latitude from -90 to 90. This function requires to load 'geosphere' R package.
</p>


<h3>Value</h3>

<p>summation of squared distance from the data to the line on the unit sphere.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(geosphere)           # This function needs to load 'geosphere' R packages.
data &lt;- rbind(c(0, 0), c(50, -10), c(100, -70))
line &lt;- rbind(c(30, 30), c(-20, 50), c(50, 80))
Cal.recon(data, line)
</code></pre>

<hr>
<h2 id='Crossprod'>Crossproduct of vectors</h2><span id='topic+Crossprod'></span>

<h3>Description</h3>

<p>This function performs the cross product of two three-dimensional vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Crossprod(vec1, vec2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Crossprod_+3A_vec1">vec1</code></td>
<td>
<p>three-dimensional vector.</p>
</td></tr>
<tr><td><code id="Crossprod_+3A_vec2">vec2</code></td>
<td>
<p>three-dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the cross product of two three-dimensional vectors.
</p>


<h3>Value</h3>

<p>three-dimensional vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Crossprod(c(1, 1, 1), c(5,6,10))
</code></pre>

<hr>
<h2 id='Dist.pt'>The number of distinct points.</h2><span id='topic+Dist.pt'></span>

<h3>Description</h3>

<p>This function calculates the number of distinct point in the given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dist.pt(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dist.pt_+3A_data">data</code></td>
<td>
<p>matrix or dataframe consisting of spatial locations with two columns.
Each row represents longitude and latitude.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the number of distinct points in the given data.
</p>


<h3>Value</h3>

<p>a numeric.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Dist.pt(rbind(c(0, 0), c(0, 1), c(1, 0), c(1, 1), c(0, 0)))
</code></pre>

<hr>
<h2 id='Earthquake'>Earthquake</h2><span id='topic+Earthquake'></span>

<h3>Description</h3>

<p>It is an earthquake data from the U.S Geological Survey that collect significant earthquakes (8+ Mb magnitude) around the Pacific Ocean since the year 1900. The data are available from (<a href="https://www.usgs.gov">https://www.usgs.gov</a>).
Additionally, note that distribution of the data has the following features: 1) scattered, 2) curvilinear one-dimensional structure on the sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Earthquake)
</code></pre>


<h3>Format</h3>

<p>A data frame consisting of time, latitude, longitude, depth, magnitude, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Earthquake)
names(Earthquake)
# collect spatial locations (longitude/latitude) of data.
earthquake &lt;- cbind(Earthquake$longitude, Earthquake$latitude)  
library(rgl)
library(sphereplot)
library(geosphere)
#### example 1: principal geodesic analysis (PGA)
PGA(earthquake)

#### example 2: principal circle
circle &lt;- PrincipalCircle(earthquake)          # get center and radius of principal circle
PC &lt;- GenerateCircle(circle[1:2], circle[3])   # generate Principal circle
# plot
sphereplot::rgl.sphgrid()                      
sphereplot::rgl.sphpoints(earthquake, radius = 1, col = "blue", size = 12)
sphereplot::rgl.sphpoints(PC, radius = 1, col = "red", size = 9)

#### example 3: spherical principal curves (SPC, SPC.Hauberg)
SPC(earthquake)         # spherical principal curves.
SPC.Hauberg(earthquake) # principal curves by Hauberg on sphere.

#### example 4: local principal geodesics (LPG)
LPG(earthquake, scale = 0.5, nu = 0.2, maxpt = 20)
LPG(earthquake, scale = 0.4, nu = 0.3)  

</code></pre>

<hr>
<h2 id='Expmap'>Exponential map</h2><span id='topic+Expmap'></span>

<h3>Description</h3>

<p>This function performs the exponential map at (0, 0, 1) on the unit 2-sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Expmap(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Expmap_+3A_vec">vec</code></td>
<td>
<p>element of two-dimensional Euclidean vector space.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs exponential map at (0, 0, 1) on the unit sphere.
<code>vec</code> is an element of the tangent plane of the unit sphere at (0, 0, 1), and the result is an element of the unit sphere in three-dimensional Euclidean space.
</p>


<h3>Value</h3>

<p>three-dimensional vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>References</h3>

<p>Fletcher, P. T., Lu, C., Pizer, S. M. and Joshi, S. (2004). Principal geodesic analysis for the study of nonlinear statistics of shape. IEEE Transactions on Medical Imaging, 23, 995-1005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Logmap">Logmap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Expmap(c(1, 2))
</code></pre>

<hr>
<h2 id='ExtrinsicMean'>Finding Extrinsic Mean</h2><span id='topic+ExtrinsicMean'></span>

<h3>Description</h3>

<p>This function identifies the extrinsic mean of data on the unit 2-sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtrinsicMean(data, weights = rep(1, nrow(data)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtrinsicMean_+3A_data">data</code></td>
<td>
<p>matrix or data frame consisting of spatial locations with two columns.
Each row represents longitude and latitude (denoted by degrees).</p>
</td></tr>
<tr><td><code id="ExtrinsicMean_+3A_weights">weights</code></td>
<td>
<p>vector of weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies the extrinsic mean of data.
</p>


<h3>Value</h3>

<p>two-dimensional vector.
</p>


<h3>Note</h3>

<p>In the case of spheres, if data set is not contained in a hemisphere, then 
it is possible that the extrinsic mean of the data set does not exists; for example,
a great circle.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>References</h3>

<p>Jongmin Lee, Jang-Hyun Kim and Hee-Seok Oh. (2021). Spherical Principal Curves. IEEE Transactions on Pattern Analysis and Machine Intelligence, 43, 2165-2171. &lt;doi.org/10.1109/TPAMI.2020.3025327&gt;.
Jang-Hyun Kim, Jongmin Lee and Hee-Seok Oh. (2020). Spherical Principal Curves &lt;arXiv:2003.02578&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IntrinsicMean">IntrinsicMean</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### comparison of Intrinsic mean and extrinsic mean.
#### example: noisy circular data set.
library(rgl)
library(sphereplot)
library(geosphere)
n &lt;- 500                  # the number of samples.
x &lt;- 360 * runif(n) - 180
sigma &lt;- 5
y &lt;- 60 + sigma * rnorm(n)
simul.circle &lt;- cbind(x, y)
data &lt;- simul.circle
In.mean &lt;- IntrinsicMean(data)
Ex.mean &lt;- ExtrinsicMean(data)
## plot (color of data is "blue"; that of intrinsic mean is "red" and 
## that of extrinsic mean is "green".)
sphereplot::rgl.sphgrid()    
sphereplot::rgl.sphpoints(data, radius = 1, col = "blue", size = 12)
sphereplot::rgl.sphpoints(In.mean[1], In.mean[2], radius = 1, col = "red", size = 12)
sphereplot::rgl.sphpoints(Ex.mean[1], Ex.mean[2], radius = 1, col = "green", size = 12)
</code></pre>

<hr>
<h2 id='GenerateCircle'>Generating circle on sphere</h2><span id='topic+GenerateCircle'></span>

<h3>Description</h3>

<p>This function makes a circle on the unit 2-sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateCircle(center, radius, T = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateCircle_+3A_center">center</code></td>
<td>
<p>center of circle with spatial locations (longitude and latitude denoted by degrees).</p>
</td></tr>
<tr><td><code id="GenerateCircle_+3A_radius">radius</code></td>
<td>
<p>radius of circle. It should be in [0, pi].</p>
</td></tr>
<tr><td><code id="GenerateCircle_+3A_t">T</code></td>
<td>
<p>the number of points that make up circle. The points in circle are equally spaced. The default is 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes a circle on the unit 2-sphere.
</p>


<h3>Value</h3>

<p>matrix consisting of spatial locations with two columns.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PrincipalCircle">PrincipalCircle</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rgl)
library(sphereplot)
library(geosphere)
circle &lt;- GenerateCircle(c(0, 0), 1)
# plot (It requires to load 'rgl', 'sphereplot', and 'geosphere' R package.)
sphereplot::rgl.sphgrid()
sphereplot::rgl.sphpoints(circle[, 1], circle[, 2], radius = 1, col = "blue", size = 12)
</code></pre>

<hr>
<h2 id='IntrinsicMean'>Finding Intrinsic Mean</h2><span id='topic+IntrinsicMean'></span>

<h3>Description</h3>

<p>This function calculates the intrinsic mean of data on sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntrinsicMean(data, weights = rep(1, nrow(data)), thres = 1e-5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntrinsicMean_+3A_data">data</code></td>
<td>
<p>matrix or data frame consisting of spatial locations with two columns.
Each row represents longitude and latitude (denoted by degrees).</p>
</td></tr>
<tr><td><code id="IntrinsicMean_+3A_weights">weights</code></td>
<td>
<p>vector of weights.</p>
</td></tr>
<tr><td><code id="IntrinsicMean_+3A_thres">thres</code></td>
<td>
<p>threshold of the stopping conditions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the intrinsic mean of data. The intrinsic mean is found by the gradient descent algorithm, which works well if the data is well-localized. In the case of spheres, if data is contained in a hemisphere, then the algorithm converges. 
</p>


<h3>Value</h3>

<p>two-dimensional vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>References</h3>

<p>Fletcher, P. T., Lu, C., Pizer, S. M. and Joshi, S. (2004). Principal geodesic analysis for the study of nonlinear statistics of shape. IEEE Transactions on Medical Imaging, 23, 995-1005.
Jongmin Lee, Jang-Hyun Kim and Hee-Seok Oh. (2021). Spherical Principal Curves. IEEE Transactions on Pattern Analysis and Machine Intelligence, 43. 2165-2171. &lt;doi.org/10.1109/TPAMI.2020.3025327&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ExtrinsicMean">ExtrinsicMean</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### comparison of Intrinsic mean and extrinsic mean.
#### example: circular data set.
library(rgl)
library(sphereplot)
library(geosphere)
n &lt;- 500
x &lt;- 360 * runif(n) - 180
sigma &lt;- 5
y &lt;- 60 + sigma * rnorm(n)
simul.circle &lt;- cbind(x, y)
data &lt;- simul.circle
In.mean &lt;- IntrinsicMean(data)
Ex.mean &lt;- ExtrinsicMean(data)
## plot (color of data is "blue"; that of intrinsic mean is "red" and 
## that of extrinsic mean is "green".)
sphereplot::rgl.sphgrid()    
sphereplot::rgl.sphpoints(data, radius = 1, col = "blue", size = 12)
sphereplot::rgl.sphpoints(In.mean[1], In.mean[2], radius = 1, col = "red", size = 12)
sphereplot::rgl.sphpoints(Ex.mean[1], Ex.mean[2], radius = 1, col = "green", size = 12)
</code></pre>

<hr>
<h2 id='Kernel.Gaussian'>Gaussian kernel function</h2><span id='topic+Kernel.Gaussian'></span>

<h3>Description</h3>

<p>This function returns the value of a Gaussian kernel function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kernel.Gaussian(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kernel.Gaussian_+3A_vec">vec</code></td>
<td>
<p>any length of vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of a Gaussian kernel function. The value of kernel represents the similarity from origin. The function returns a vector whose length is same as <code>vec</code>.
</p>


<h3>Value</h3>

<p>vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kernel.indicator">Kernel.indicator</a></code>, <code><a href="#topic+Kernel.quartic">Kernel.quartic</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Kernel.Gaussian(c(0, 1/2, 1, 2))
</code></pre>

<hr>
<h2 id='Kernel.indicator'>Indicator kernel function</h2><span id='topic+Kernel.indicator'></span>

<h3>Description</h3>

<p>This function returns the value of an indicator kernel function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kernel.indicator(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kernel.indicator_+3A_vec">vec</code></td>
<td>
<p>any length of vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of an indicator kernel function. The value of kernel represents similarity from origin. The function returns a vector whose length is same as <code>vec</code>.
</p>


<h3>Value</h3>

<p>vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kernel.Gaussian">Kernel.Gaussian</a></code>, <code><a href="#topic+Kernel.quartic">Kernel.quartic</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Kernel.indicator(c(0, 1/2, 1, 2))
</code></pre>

<hr>
<h2 id='Kernel.quartic'>Quartic kernel function</h2><span id='topic+Kernel.quartic'></span>

<h3>Description</h3>

<p>This function returns the value of a quartic kernel function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kernel.quartic(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kernel.quartic_+3A_vec">vec</code></td>
<td>
<p>any length of vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of quartic kernel function. The value of kernel represents similarity from origin. The function returns a vector whose length is same as <code>vec</code>.
</p>


<h3>Value</h3>

<p>vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kernel.Gaussian">Kernel.Gaussian</a></code>, <code><a href="#topic+Kernel.indicator">Kernel.indicator</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Kernel.quartic(c(0, 1/2, 1, 2))
</code></pre>

<hr>
<h2 id='Logmap'>Logarithm map</h2><span id='topic+Logmap'></span>

<h3>Description</h3>

<p>This function performs the logarithm map at (0, 0, 1) on the unit sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Logmap(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Logmap_+3A_vec">vec</code></td>
<td>
<p>element of the unit sphere in three-dimensional Euclidean vector space.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the logarithm map at (0, 0, 1) on the unit sphere. Note that, <code>vec</code> is normalized to be contained in the unit sphere.
</p>


<h3>Value</h3>

<p>two-dimensional vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>References</h3>

<p>Fletcher, P. T., Lu, C., Pizer, S. M. and Joshi, S. (2004). Principal geodesic analysis for the study of nonlinear statistics of shape. IEEE Transactions on Medical Imaging, 23, 995-1005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Expmap">Expmap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Logmap(c(1/sqrt(2), 1/sqrt(2), 0))
</code></pre>

<hr>
<h2 id='LPG'>Local principal geodesics</h2><span id='topic+LPG'></span>

<h3>Description</h3>

<p>Locally definded principal geodesic analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LPG(data, scale = 0.04, tau = scale/3, nu = 0, maxpt = 500,
seed = NULL, kernel = "indicator", thres = 1e-4, 
col1 = "blue", col2 = "green", col3 = "red")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LPG_+3A_data">data</code></td>
<td>
<p>matrix or data frame consisting of spatial locations with two columns.
Each row represents longitude and latitude (denoted by degrees).</p>
</td></tr>
<tr><td><code id="LPG_+3A_scale">scale</code></td>
<td>
<p>scale parameter for this function. The argument is the degree to which <code>LPG</code> expresses data locally; thus, as <code>scale</code> grows as the result of <code>LPG</code> become similar to that of the <code><a href="#topic+PGA">PGA</a></code> function. The default is 0.4.</p>
</td></tr>
<tr><td><code id="LPG_+3A_tau">tau</code></td>
<td>
<p>forwarding or backwarding distance of each step. It is empirically recommended to choose a third of <code>scale</code>, which is the default of this argument.</p>
</td></tr>
<tr><td><code id="LPG_+3A_nu">nu</code></td>
<td>
<p>parameter to alleviate the bias of resulting curves. <code>nu</code> represents the viscosity of the given data and it should be selected in [0, 1). The default is zero. When the <code>nu</code> is close to 1, the curves usually swirl around, similar to the motion of a large viscous fluid. The swirling can be controlled by the argument <code>maxpt</code>.</p>
</td></tr>
<tr><td><code id="LPG_+3A_maxpt">maxpt</code></td>
<td>
<p>maximum number of points that each curve has. The default is 500.</p>
</td></tr>
<tr><td><code id="LPG_+3A_seed">seed</code></td>
<td>
<p>random seed number.</p>
</td></tr>
<tr><td><code id="LPG_+3A_kernel">kernel</code></td>
<td>
<p>kind of kernel function. The default is the indicator kernel and alternatives are quartic or Gaussian.</p>
</td></tr>
<tr><td><code id="LPG_+3A_thres">thres</code></td>
<td>
<p>threshold of the stopping condition for the <code>IntrinsicMean</code> contained in the <code>LPG</code> function. The default is 1e-4.</p>
</td></tr>
<tr><td><code id="LPG_+3A_col1">col1</code></td>
<td>
<p>color of data. The default is blue.</p>
</td></tr>
<tr><td><code id="LPG_+3A_col2">col2</code></td>
<td>
<p>color of points in the resulting principal curves. The default is green.</p>
</td></tr>
<tr><td><code id="LPG_+3A_col3">col3</code></td>
<td>
<p>color of the resulting curves. The default is red.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locally definded principal geodesic analysis. The result is sensitive to <code>scale</code> and <code>nu</code>, especially <code>scale</code> should be carefully chosen according to the structure of the given data.
</p>


<h3>Value</h3>

<p>plot and a list consisting of
</p>
<table>
<tr><td><code>prin.curves</code></td>
<td>
<p>spatial locations (represented by degrees) of points in the resulting curves.</p>
</td></tr>
<tr><td><code>line</code></td>
<td>
<p>connecting lines between points in <code>prin.curves</code>.</p>
</td></tr>
<tr><td><code>num.curves</code></td>
<td>
<p>the number of the resulting curves.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PGA">PGA</a></code>, <code><a href="#topic+SPC">SPC</a></code>, <code><a href="#topic+SPC.Hauberg">SPC.Hauberg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rgl)
library(sphereplot)
library(geosphere)

#### example 1: spiral data
## longitude and latitude are expressed in degrees
set.seed(40)
n &lt;- 900                                    # the number of samples
sigma1 &lt;- 1; sigma2 &lt;- 2.5;                 # noise levels
radius &lt;- 73; slope &lt;- pi/16                # radius and slope of spiral
## polar coordinate of (longitude, latitude)
r &lt;- runif(n)^(2/3) * radius; theta &lt;- -slope * r + 3 
## transform to (longitude, latitude)
correction &lt;- (0.5 * r/radius + 0.3)        # correction of noise level
lon1 &lt;- r * cos(theta) + correction * sigma1 * rnorm(n)
lat1 &lt;- r * sin(theta) + correction * sigma1 * rnorm(n)
lon2 &lt;- r * cos(theta) + correction * sigma2 * rnorm(n)
lat2 &lt;- r * sin(theta) + correction * sigma2 * rnorm(n)
spiral1 &lt;- cbind(lon1, lat1); spiral2 &lt;- cbind(lon2, lat2)
## plot spiral data
rgl.sphgrid(col.lat = 'black', col.long = 'black')
rgl.sphpoints(spiral1, radius = 1, col = 'blue', size = 12)
## implement the LPG to (noisy) spiral data
LPG(spiral1, scale = 0.06, nu = 0.1, seed = 100)
LPG(spiral2, scale = 0.12, nu = 0.1, seed = 100)
#### example 2: zigzag data set
set.seed(10)
n &lt;- 50                                # the number of samples is 6 * n = 300
sigma1 &lt;- 2; sigma2 &lt;- 5               # noise levels                   
x1 &lt;- x2 &lt;- x3 &lt;- x4 &lt;- x5 &lt;- x6 &lt;- runif(n) * 20 - 20
y1 &lt;- x1 + 20 + sigma1 * rnorm(n); y2 &lt;- -x2 + 20 + sigma1 * rnorm(n)
y3 &lt;- x3 + 60 + sigma1 * rnorm(n); y4 &lt;- -x4 - 20 + sigma1 * rnorm(n)
y5 &lt;- x5 - 20 + sigma1 * rnorm(n); y6 &lt;- -x6 - 60 + sigma1 * rnorm(n)
x &lt;- c(x1, x2, x3, x4, x5, x6); y &lt;- c(y1, y2, y3, y4, y5, y6)
simul.zigzag1 &lt;- cbind(x, y)
## plot zigzag data
sphereplot::rgl.sphgrid(col.lat = 'black', col.long = 'black')
sphereplot::rgl.sphpoints(simul.zigzag1, radius = 1, col = 'blue', size = 12)
## implement the LPG to zigzag data
LPG(simul.zigzag1, scale = 0.1, nu = 0.1, maxpt = 45, seed = 50)

## noisy zigzag data
set.seed(10)
z1 &lt;- z2 &lt;- z3 &lt;- z4 &lt;- z5 &lt;- z6 &lt;- runif(n) * 20 - 20
w1 &lt;- z1 + 20 + sigma2 * rnorm(n); w2 &lt;- -z2 + 20 + sigma2 * rnorm(n)
w3 &lt;- z3 + 60 + sigma2 * rnorm(n); w4 &lt;- -z4 - 20 + sigma2 * rnorm(n)
w5 &lt;- z5 - 20 + sigma2 * rnorm(n); w6 &lt;- -z6 - 60 + sigma2 * rnorm(n)
z &lt;- c(z1, z2, z3, z4, z5, z6); w &lt;- c(w1, w2, w3, w4, w5, w6)
simul.zigzag2 &lt;- cbind(z, w)
## implement the LPG to noisy zigzag data
LPG(simul.zigzag2, scale = 0.2, nu = 0.1, maxpt = 18, seed = 20)


#### example 3: Doubly circular data set
set.seed(30)
n &lt;- 200
sigma &lt;- 1
x1 &lt;- 40 * runif(n) - 20
y1 &lt;- (-x1^2 + 400)^(1/2) + 30 + sigma * rnorm(n)
x2 &lt;- 40 * runif(n) - 20
y2 &lt;- -(-x2^2 + 400)^(1/2) + 30 + sigma * rnorm(n)
y3 &lt;- 40 * runif(n) + 10
x3 &lt;- -(-y3^2 + 60 * y3 - 500)^(1/2) + sigma * rnorm(n)
y4 &lt;- 40 * runif(n) + 10
x4 &lt;- (-y4^2 + 60 * y4 - 500)^(1/2) + sigma * rnorm(n)
Dc1 &lt;- cbind(c(x1, x2, x3, x4), c(y1, y2, y3, y4))
z1 &lt;- 40 * runif(n) - 20
w1 &lt;- (400 - z1^2)^(1/2) - 20 + sigma * rnorm(n)
z2 &lt;- 40 * runif(n) - 20
w2 &lt;- -(400 - z2^2)^(1/2) - 20 + sigma * rnorm(n)
w3 &lt;- -40 * runif(n)
z3 &lt;- (-w3^2 - 40 * w3)^(1/2) + sigma * rnorm(n)
w4 &lt;- -40 * runif(n)
z4 &lt;- -(-w4^2 - 40 * w4)^(1/2) + sigma * rnorm(n)
Dc2 &lt;- cbind(c(z1, z2, z3, z4), c(w1, w2, w3, w4))
Dc &lt;- rbind(Dc1, Dc2)
LPG(Dc, scale = 0.15, nu = 0.1, maxpt = 22,)


#### example 4: real earthquake data
data(Earthquake)
names(Earthquake)
earthquake &lt;- cbind(Earthquake$longitude, Earthquake$latitude)  
LPG(earthquake, scale = 0.5, nu = 0.2, maxpt = 20)
LPG(earthquake, scale = 0.4, nu = 0.3)


#### example 5: tree data
## tree consists of stem, branches and subbranches

## generate stem
set.seed(10)
n1 &lt;- 200; n2 &lt;- 100; n3 &lt;- 15 # the number of samples in stem, a branch, and a subbranch
sigma1 &lt;- 0.1; sigma2 &lt;- 0.05; sigma3 &lt;- 0.01 # noise levels
noise1 &lt;- sigma1 * rnorm(n1); noise2 &lt;- sigma2 * rnorm(n2); noise3 &lt;- sigma3 * rnorm(n3)
l1 &lt;- 70; l2 &lt;- 20; l3 &lt;- 1            # length of stem, branches, and subbranches
rep1 &lt;- l1 * runif(n1)                 # repeated part of stem
stem &lt;- cbind(0 + noise1, rep1 - 10)

## generate branch
rep2 &lt;- l2 * runif(n2)                 # repeated part of branch
branch1 &lt;- cbind(-rep2, rep2 + 10 + noise2); branch2 &lt;- cbind(rep2, rep2 + noise2)
branch3 &lt;- cbind(rep2, rep2 + 20 + noise2); branch4 &lt;- cbind(rep2, rep2 + 40 + noise2)
branch5 &lt;- cbind(-rep2, rep2 + 30 + noise2)
branch &lt;- rbind(branch1, branch2, branch3, branch4, branch5)

## generate subbranches
rep3 &lt;- l3 * runif(n3)                 # repeated part in subbranches
branches1 &lt;- cbind(rep3 - 10, rep3 + 20 + noise3)
branches2 &lt;- cbind(-rep3 + 10, rep3 + 10 + noise3)
branches3 &lt;- cbind(rep3 - 14, rep3 + 24 + noise3)
branches4 &lt;- cbind(-rep3 + 14, rep3 + 14 + noise3)
branches5 &lt;- cbind(-rep3 - 12, -rep3 + 22 + noise3)
branches6 &lt;- cbind(rep3 + 12, -rep3 + 12 + noise3)
branches7 &lt;- cbind(-rep3 - 16, -rep3 + 26 + noise3)
branches8 &lt;- cbind(rep3 + 16, -rep3 + 16 + noise3)
branches9 &lt;- cbind(rep3 + 10, -rep3 + 50 + noise3)
branches10 &lt;- cbind(-rep3 - 10, -rep3 + 40 + noise3)
branches11 &lt;- cbind(-rep3 + 12, rep3 + 52 + noise3)
branches12 &lt;- cbind(rep3 - 12, rep3 + 42 + noise3)
branches13 &lt;- cbind(rep3 + 14, -rep3 + 54 + noise3)
branches14 &lt;- cbind(-rep3 - 14, -rep3 + 44 + noise3)
branches15 &lt;- cbind(-rep3 + 16, rep3 + 56 + noise3)
branches16 &lt;- cbind(rep3 - 16, rep3 + 46 + noise3)
branches17 &lt;- cbind(-rep3 + 10, rep3 + 30 + noise3)
branches18 &lt;- cbind(-rep3 + 14, rep3 + 34 + noise3)
branches19 &lt;- cbind(rep3 + 16, -rep3 + 36 + noise3)
branches20 &lt;- cbind(rep3 + 12, -rep3 + 32 + noise3)
sub.branches &lt;- rbind(branches1, branches2, branches3, branches4, branches5, branches6,
+    branches7, branches8, branches9, branches10, branches11, branches12, branches13,
+    branches14, branches15, branches16, branches17, branches18, branches19, branches20)

## tree consists of stem, branch and subbranches
tree &lt;- rbind(stem, branch, sub.branches)

## plot tree data
sphereplot::rgl.sphgrid(col.lat = 'black', col.long = 'black')
sphereplot::rgl.sphpoints(tree, radius = 1, col = 'blue', size = 12)

## implement the LPG function to tree data
LPG(tree, scale = 0.03, nu = 0.2, seed = 10)
</code></pre>

<hr>
<h2 id='PGA'>Principal geodesic analysis</h2><span id='topic+PGA'></span>

<h3>Description</h3>

<p>This function performs principal geodesic analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PGA(data, col1 = "blue", col2 = "red")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PGA_+3A_data">data</code></td>
<td>
<p>matrix or data frame consisting of spatial locations with two columns.
Each row represents longitude and latitude (denoted by degrees.</p>
</td></tr>
<tr><td><code id="PGA_+3A_col1">col1</code></td>
<td>
<p>color of data. The default is blue.</p>
</td></tr>
<tr><td><code id="PGA_+3A_col2">col2</code></td>
<td>
<p>color of the principal geodesic line. The default is red</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs principal geodesic analysis.
</p>


<h3>Value</h3>

<p>plot and a list consisting of
</p>
<table>
<tr><td><code>line</code></td>
<td>
<p>spatial locations (longitude and latitude by degrees) of points in the principal geodesic line.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires to load 'sphereplot', 'geosphere' and 'rgl' R package.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>References</h3>

<p>Fletcher, P. T., Lu, C., Pizer, S. M. and Joshi, S. (2004). Principal geodesic analysis for the study of nonlinear statistics of shape. IEEE Transactions on Medical Imaging, 23, 995-1005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LPG">LPG</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rgl)
library(sphereplot)
library(geosphere)
#### example 1: noisy half-great circle data
circle &lt;- GenerateCircle(c(150, 60), radius = pi/2)
half.circle &lt;- circle[circle[, 1] &lt; 0, , drop = FALSE]
sigma &lt;- 2
half.circle &lt;- half.circle + sigma * rnorm(nrow(half.circle))
PGA(half.circle)

#### example 2: noisy S-shaped data 
#### The data consists of two parts: x ~ Uniform[0, 20], y = sqrt(20 * x - x^2) + N(0, sigma^2), 
#### x ~ Uniform[-20, 0], y = -sqrt(-20 * x - x^2) + N(0, sigma^2).
n &lt;- 500                                           
x &lt;- 60 * runif(n)
sigma &lt;- 2                                         
y &lt;- (60 * x - x^2)^(1/2) + sigma * rnorm(n)
simul.S1 &lt;- cbind(x, y)
z &lt;- -60 * runif(n)
w &lt;- -(-60 * z - z^2)^(1/2)+ sigma * rnorm(n)
simul.S2 &lt;- cbind(z, w)
simul.S &lt;- rbind(simul.S1, simul.S2)
PGA(simul.S)
</code></pre>

<hr>
<h2 id='PrincipalCircle'>Principal circle on a sphere</h2><span id='topic+PrincipalCircle'></span>

<h3>Description</h3>

<p>This function fits a principal circle on sphere via gradient descent algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrincipalCircle(data, step.size = 1e-3, thres = 1e-5, maxit = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrincipalCircle_+3A_data">data</code></td>
<td>
<p>matrix or data frame consisting of spatial locations (longitude and latitude denoted by degrees) with two columns.</p>
</td></tr>
<tr><td><code id="PrincipalCircle_+3A_step.size">step.size</code></td>
<td>
<p>step size of gradient descent algorithm. For convergence of the algorithm, <code>step.size</code> is recommended to be below 0.01. The default is 1e-3.</p>
</td></tr>
<tr><td><code id="PrincipalCircle_+3A_thres">thres</code></td>
<td>
<p>threshold of the stopping condition. The default is 1e-5.</p>
</td></tr>
<tr><td><code id="PrincipalCircle_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations. The default is 10000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a principal circle on sphere via gradient descent algorithm. The function returns three-dimensional vectors whose components represent longitude and latitude of the center and the radius of the circle in regular order.
</p>


<h3>Value</h3>

<p>three-dimensional vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>References</h3>

<p>Jongmin Lee, Jang-Hyun Kim and Hee-Seok Oh. (2021). Spherical principal curves. IEEE Transactions on Pattern Analysis and Machine Intelligence, 43, 2165-2171. &lt;doi.org/10.1109/TPAMI.2020.3025327&gt;.
</p>
<p>Jang-Hyun Kim, Jongmin Lee and Hee-Seok Oh (2020), Spherical principal curves &lt;arXiv:2003.02578&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GenerateCircle">GenerateCircle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rgl)
library(sphereplot)
library(geosphere)
#### example 1: half-great circle data
circle &lt;- GenerateCircle(c(150, 60), radius = pi/2)
half.great.circle &lt;- circle[circle[, 1] &lt; 0, , drop = FALSE]
sigma &lt;- 2
half.great.circle &lt;- half.great.circle + sigma * rnorm(nrow(half.great.circle))
## find a principal circle

PC &lt;- PrincipalCircle(half.great.circle)
result &lt;- GenerateCircle(PC[1:2], PC[3])
## plot
rgl.sphgrid()
rgl.sphpoints(half.great.circle, radius = 1, col = "blue", size = 12)
rgl.sphpoints(result, radius = 1, col = "red", size = 6)

#### example 2: circular data
n &lt;- 700                            
x &lt;- seq(-180, 180, length.out = n)
sigma &lt;- 5                          
y &lt;- 45 + sigma * rnorm(n)
simul.circle &lt;- cbind(x, y)
## find a principal circle
PC &lt;- PrincipalCircle(simul.circle)
result &lt;- GenerateCircle(PC[1:2], PC[3])
## plot
sphereplot::rgl.sphgrid()
sphereplot::rgl.sphpoints(simul.circle, radius = 1, col = "blue", size = 12)
sphereplot::rgl.sphpoints(result, radius = 1, col = "red", size = 6)

#### example 3: earthquake data
data(Earthquake)
names(Earthquake)
earthquake &lt;- cbind(Earthquake$longitude, Earthquake$latitude) 
PC &lt;- PrincipalCircle(earthquake)
result &lt;- GenerateCircle(PC[1:2], PC[3])
## plot
sphereplot::rgl.sphgrid(col.long = "black", col.lat = "black")
sphereplot::rgl.sphpoints(earthquake, radius = 1, col = "blue", size = 12)
sphereplot::rgl.sphpoints(result, radius = 1, col = "red", size = 6)

</code></pre>

<hr>
<h2 id='Proj.Hauberg'>Projecting the nearest point</h2><span id='topic+Proj.Hauberg'></span>

<h3>Description</h3>

<p>This function performs the approximated projection for each data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Proj.Hauberg(data, line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Proj.Hauberg_+3A_data">data</code></td>
<td>
<p>matrix or data frame consisting of spatial locations with two columns.
Each row represents longitude and latitude.</p>
</td></tr>
<tr><td><code id="Proj.Hauberg_+3A_line">line</code></td>
<td>
<p>longitude and latitude of line as a matrix or data frame with two columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the nearest points in <code>line</code> for each point in the data.
The function requires to load the 'geosphere' R package.
</p>


<h3>Value</h3>

<p>matrix consisting of spatial locations with two columns.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>References</h3>

<p>Hauberg, S. (2016). Principal curves on Riemannian manifolds. IEEE Transactions on Pattern Analysis and Machine Intelligence, 38, 1915-1921.
</p>
<p>Jang-Hyun Kim, Jongmin Lee and Hee-Seok Oh. (2020). Spherical Principal Curves &lt;arXiv:2003.02578&gt;.
</p>
<p>Jongmin Lee, Jang-Hyun Kim and Hee-Seok Oh. (2021). Spherical principal curves. IEEE Transactions on Pattern Analysis and Machine Intelligence, 43, 2165-2171. &lt;doi.org/10.1109/TPAMI.2020.3025327&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SPC.Hauberg">SPC.Hauberg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(geosphere)
Proj.Hauberg(rbind(c(0, 0), c(10, -20)), rbind(c(50, 10), c(40, 20), c(30, 30)))
</code></pre>

<hr>
<h2 id='Rotate'>Rotating point on a sphere</h2><span id='topic+Rotate'></span>

<h3>Description</h3>

<p>Rotate a point on the unit 2-sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rotate(pt1, pt2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rotate_+3A_pt1">pt1</code></td>
<td>
<p>spatial location.</p>
</td></tr>
<tr><td><code id="Rotate_+3A_pt2">pt2</code></td>
<td>
<p>spatial location.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function rotates <code>pt2</code> to the extent that <code>pt1</code> to spherical coordinate (0, 90).
The function returns a point as a form of three-dimensional Euclidean coordinate.
</p>


<h3>Value</h3>

<p>three-dimensional vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/Rodrigues_rotation_formula
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rotate.inv">Rotate.inv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## If "pt1" is north pole (= (0, 90)), Rotate() function returns Euclidean coordinate of "pt2".
Rotate(c(0, 90), c(10, 10))   # It returns Euclidean coordinate of spatial location (10, 10).
# The Trans.Euclid() function converts spatial coordinate (10, 10) to Euclidean coordinate.
Trans.Euclid(c(10, 10))       
</code></pre>

<hr>
<h2 id='Rotate.inv'>Rotating point on a sphere</h2><span id='topic+Rotate.inv'></span>

<h3>Description</h3>

<p>Rotate a point on the unit 2-sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> Rotate.inv(pt1, pt2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rotate.inv_+3A_pt1">pt1</code></td>
<td>
<p>spatial location.</p>
</td></tr>
<tr><td><code id="Rotate.inv_+3A_pt2">pt2</code></td>
<td>
<p>spatial location.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function rotates <code>pt2</code> to the extent that the spherical coordinate (0, 90) is rotated to <code>pt1</code>.
The function is the inverse of the <code>Rotate</code> function, and returns a point as a form of three-dimensional Euclidean coordinate.
</p>


<h3>Value</h3>

<p>three-dimensional vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/Rodrigues_rotation_formula
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rotate">Rotate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## If "pt1" is north pole (= (0, 90)), Rotate.inv() returns Euclidean coordinate of "pt2".
# It returns Euclidean coordinate of spatial location (-100, 80).
Rotate.inv(c(0, 90), c(-100, 80)) 
# It converts spatial coordinate (-100, 80) to Euclidean coordinate.
Trans.Euclid(c(-100, 80))                                                   
</code></pre>

<hr>
<h2 id='SPC'>Spherical principal curves</h2><span id='topic+SPC'></span>

<h3>Description</h3>

<p>This function fits a spherical principal curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPC(data, q = 0.1, T = nrow(data), step.size = 1e-3, maxit = 10, 
type = "Intrinsic", thres = 0.1, deletePoints = FALSE, plot.proj = FALSE, 
kernel = "quartic", col1 = "blue", col2 = "green", col3 = "red")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SPC_+3A_data">data</code></td>
<td>
<p>matrix or data frame consisting of spatial locations with two columns.
Each row represents a longitude and latitude (denoted by degrees).</p>
</td></tr>
<tr><td><code id="SPC_+3A_q">q</code></td>
<td>
<p>numeric value of the smoothing parameter. The parameter plays the same role, as the bandwidth does in kernel regression, in the <code>SPC</code> function. The value should be a numeric value between 0.01 and 0.5. The default is 0.1.</p>
</td></tr>
<tr><td><code id="SPC_+3A_t">T</code></td>
<td>
<p>the number of points making up the resulting curve. The default is 1000.</p>
</td></tr>
<tr><td><code id="SPC_+3A_step.size">step.size</code></td>
<td>
<p>step size of the <code>PrincipalCircle</code> function. The default is 0.001. The resulting principal circle is used by an initial estimate of the <code>SPC</code>.</p>
</td></tr>
<tr><td><code id="SPC_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations. The default is 30.</p>
</td></tr>
<tr><td><code id="SPC_+3A_type">type</code></td>
<td>
<p>type of mean on the sphere. The default is &quot;Intrinsic&quot; and the other choice is &quot;Extrinsic&quot;.</p>
</td></tr>
<tr><td><code id="SPC_+3A_thres">thres</code></td>
<td>
<p>threshold of the stopping condition. The default is 0.1</p>
</td></tr>
<tr><td><code id="SPC_+3A_deletepoints">deletePoints</code></td>
<td>
<p>logical value. The argument is an option of whether to delete points or not. If <code>deletePoints</code> is FALSE, this function leaves the points in curves which do not have adjacent data for each expectation step. As a result, the function usually returns a closed curve, i.e. a curve without endpoints. If <code>deletePoints</code> is TRUE, this function deletes the points in curves which do not have adjacent data for each expectation step. As a result, The <code>SPC</code> function usually returns an open curve, i.e. a curve with endpoints. The default is FALSE.</p>
</td></tr>
<tr><td><code id="SPC_+3A_plot.proj">plot.proj</code></td>
<td>
<p>logical value. If the argument is TRUE, the projection line for each data is plotted. The default is FALSE.</p>
</td></tr>
<tr><td><code id="SPC_+3A_kernel">kernel</code></td>
<td>
<p>kind of kernel function. The default is quartic kernel and alternatives are indicator or Gaussian.</p>
</td></tr>
<tr><td><code id="SPC_+3A_col1">col1</code></td>
<td>
<p>color of data. The default is blue.</p>
</td></tr>
<tr><td><code id="SPC_+3A_col2">col2</code></td>
<td>
<p>color of points in the principal curves. The default is green.</p>
</td></tr>
<tr><td><code id="SPC_+3A_col3">col3</code></td>
<td>
<p>color of resulting principal curves. The default is red.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a spherical principal curves, and requires to load the 'rgl', 'sphereplot', and 'geosphere' R packages.
</p>


<h3>Value</h3>

<p>plot and a list consisting of
</p>
<table>
<tr><td><code>prin.curves</code></td>
<td>
<p>spatial locations (denoted by degrees) of points in the resulting principal curves.</p>
</td></tr>
<tr><td><code>line</code></td>
<td>
<p>connecting line bewteen points of <code>prin.curves</code>.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>whether or not the algorithm converged.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>the number of iterations of the algorithm.</p>
</td></tr>
<tr><td><code>recon.error</code></td>
<td>
<p>sum of squared distances from the data to their projections.</p>
</td></tr>
<tr><td><code>num.dist.pt</code></td>
<td>
<p>the number of distinct projections.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires to load 'rgl', 'sphereplot', and 'geosphere' R packages.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>References</h3>

<p>Jang-Hyun Kim, Jongmin Lee and Hee-Seok Oh. (2020). Spherical Principal Curves &lt;arXiv:2003.02578&gt;.
</p>
<p>Jongmin Lee, Jang-Hyun Kim and Hee-Seok Oh. (2021). Spherical principal curves. IEEE Transactions on Pattern Analysis and Machine Intelligence, 43, 2165-2171. &lt;doi.org/10.1109/TPAMI.2020.3025327&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SPC.Hauberg">SPC.Hauberg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rgl)
library(sphereplot)
library(geosphere)

#### example 2: waveform data
n &lt;- 200
alpha &lt;- 1/3; freq &lt;- 4                           # amplitude and frequency of wave
sigma1 &lt;- 2; sigma2 &lt;- 10                         # noise levels  
lon &lt;- seq(-180, 180, length.out = n)             # uniformly sampled longitude
lat &lt;- alpha * 180/pi * sin(freq * lon * pi/180) + 10.        # latitude vector
## add Gaussian noises on latitude vector
lat1 &lt;- lat + sigma1 * rnorm(length(lon)); lat2 &lt;- lat + sigma2 * rnorm(length(lon))
wave1 &lt;- cbind(lon, lat1); wave2 &lt;- cbind(lon, lat2)
## implement SPC to the (noisy) waveform data
SPC(wave1, q = 0.05)
SPC(wave2, q = 0.05)

#### example 1: earthquake data
data(Earthquake)
names(Earthquake)
earthquake &lt;- cbind(Earthquake$longitude, Earthquake$latitude)   
SPC(earthquake, q = 0.1)
## options 1: plot the projection lines (use option of plot.proj = TRUE)
SPC(earthquake, q = 0.1, plot.proj = TRUE)
## option 2: open principal curves (use option of deletePoints = TRUE)
SPC(earthquake, q = 0.04, deletePoints = TRUE)

</code></pre>

<hr>
<h2 id='SPC.Hauberg'>principal curves by Hauberg on a sphere</h2><span id='topic+SPC.Hauberg'></span>

<h3>Description</h3>

<p>This function fits a principal curve by Hauberg on the unit 2-sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPC.Hauberg(data, q = 0.1, T = nrow(data), step.size = 1e-3, maxit = 10, 
type = "Intrinsic", thres = 1e-2, deletePoints = FALSE, plot.proj = FALSE, 
kernel = "quartic", col1 = "blue", col2 = "green", col3 = "red")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SPC.Hauberg_+3A_data">data</code></td>
<td>
<p>matrix or data frame consisting of spatial locations with two columns. Each row represents longitude and latitude (denoted by degrees).</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_q">q</code></td>
<td>
<p>numeric value of the smoothing parameter. The parameter plays the same role, as the bandwidth does in kernel regression, in the <code>SPC</code> function. The value should be a numeric value between 0.01 and 0.5. The default is 0.1.</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_t">T</code></td>
<td>
<p>the number of points making up the resulting curve. The default is 1000.</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_step.size">step.size</code></td>
<td>
<p>step size of the <code>PrincipalCircle</code> function. The default is 0.001. The resulting principal circle is used by an initialization of the <code>SPC</code>.</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations. The default is 30.</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_type">type</code></td>
<td>
<p>type of mean on sphere. The default is &quot;Intrinsic&quot; and the alternative is &quot;extrinsic&quot;.</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_thres">thres</code></td>
<td>
<p>threshold of the stopping condition. The default is 0.01.</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_deletepoints">deletePoints</code></td>
<td>
<p>logical value. The argument is an option of whether to delete points or not. If <code>deletePoints</code> is FALSE, this function leaves the points in curves which do not have adjacent data for each expectation step. As a result, the function usually returns a closed curve, i.e. a curve without endpoints. If <code>deletePoints</code> is TRUE, this function deletes the points in curves which do not have adjacent data for each expectation step. As a result, The <code>SPC</code> function usually returns an open curve, i.e. a curve with endpoints. The default is FALSE.</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_plot.proj">plot.proj</code></td>
<td>
<p>logical value. If the argument is TRUE, the projection line for each data is plotted. The default is FALSE.</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_kernel">kernel</code></td>
<td>
<p>kind of kernel function. The default is quartic kernel and alternatives are indicator or Gaussian.</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_col1">col1</code></td>
<td>
<p>color of data. The default is blue.</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_col2">col2</code></td>
<td>
<p>color of points in the principal curves. The default is green.</p>
</td></tr>
<tr><td><code id="SPC.Hauberg_+3A_col3">col3</code></td>
<td>
<p>color of resulting principal curves. The default is red.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a principal curve proposed by Hauberg on the sphere, and requires to load the 'rgl', 'sphereplot', and 'geosphere' R packages.
</p>


<h3>Value</h3>

<p>plot and a list consisting of
</p>
<table>
<tr><td><code>prin.curves</code></td>
<td>
<p>spatial locations (denoted by degrees) of points in the resulting principal curves.</p>
</td></tr>
<tr><td><code>line</code></td>
<td>
<p>connecting line bewteen points of <code>prin.curves</code>.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>whether or not the algorithm converged.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>the number of iterations of the algorithm.</p>
</td></tr>
<tr><td><code>recon.error</code></td>
<td>
<p>sum of squared distances from the data to their projections.</p>
</td></tr>
<tr><td><code>num.dist.pt</code></td>
<td>
<p>the number of distinct projections.</p>
</td></tr>
<tr><td><code>plot</code></td>
<td>
<p>plotting of the data and principal curves.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires to load 'rgl', 'sphereplot', and 'geosphere' R packages.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>References</h3>

<p>Hauberg, S. (2016). Principal curves on Riemannian manifolds. IEEE Transactions on Pattern Analysis and Machine Intelligence, 38, 1915-1921.
</p>
<p>Jang-Hyun Kim, Jongmin Lee and Hee-Seok Oh. (2020). Spherical Principal Curves &lt;arXiv:2003.02578&gt;.
</p>
<p>Jongmin Lee, Jang-Hyun Kim and Hee-Seok Oh. (2021). Spherical Principal Curves. IEEE Transactions on Pattern Analysis and Machine Intelligence, 43, 2165-2171. &lt;doi.org/10.1109/TPAMI.2020.3025327&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SPC">SPC</a></code>, <code><a href="#topic+Proj.Hauberg">Proj.Hauberg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rgl)
library(sphereplot)
library(geosphere)

#### example 1: earthquake data
data(Earthquake)
names(Earthquake)
earthquake &lt;- cbind(Earthquake$longitude, Earthquake$latitude)
SPC.Hauberg(earthquake, q = 0.1)

#### example 2: waveform data
## longitude and latitude are expressed in degrees
n &lt;- 200
alpha &lt;- 1/3; freq &lt;- 4                           # amplitude and frequency of wave
sigma &lt;- 2                                        # noise level
lon &lt;- seq(-180, 180, length.out = n)             # uniformly sampled longitude
lat &lt;- alpha * 180/pi * sin(freq * lon * pi/180) + 10.        # latitude vector
## add Gaussian noises on latitude vector
lat1 &lt;- lat + sigma * rnorm(length(lon))
wave &lt;- cbind(lon, lat1)
## implement principal curves by Hauberg to the waveform data
SPC.Hauberg(wave, q = 0.05)

</code></pre>

<hr>
<h2 id='Trans.Euclid'>Transforming into Euclidean coordinate</h2><span id='topic+Trans.Euclid'></span>

<h3>Description</h3>

<p>This function converts a spherical coordinate to a Euclidean coordinate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Trans.Euclid(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Trans.Euclid_+3A_vec">vec</code></td>
<td>
<p>two-dimensional spherical coordinate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a two-dimensional spherical coordinate to a three-dimensional Euclidean coordinate.
Longitude should be range from -180 to 180 and latitude from -90 to 90.
</p>


<h3>Value</h3>

<p>three-dimensional vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Trans.sph">Trans.sph</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Trans.Euclid(c(0, 0))
Trans.Euclid(c(0, 90))
Trans.Euclid(c(90, 0))
Trans.Euclid(c(180, 0))
Trans.Euclid(c(-90, 0))
</code></pre>

<hr>
<h2 id='Trans.sph'>Transforming into spherical coordinate</h2><span id='topic+Trans.sph'></span>

<h3>Description</h3>

<p>This function converts a Euclidean coordinate to a spherical coordinate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Trans.sph(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Trans.sph_+3A_vec">vec</code></td>
<td>
<p>three-dimensional Euclidean coordinate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a three-dimensional Euclidean coordinate to a two-dimensional spherical coordinate.
If <code>vec</code> is not in the unit sphere, it is divided by its magnitude so that the result lies on the unit sphere.
</p>


<h3>Value</h3>

<p>two-dimensional vector.
</p>


<h3>Author(s)</h3>

<p>Jongmin Lee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Trans.Euclid">Trans.Euclid</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Trans.sph(c(1, 0, 0))
Trans.sph(c(0, 1, 0))
Trans.sph(c(0, 0, 1))
Trans.sph(c(-1, 0 , 0))
Trans.sph(c(0, -1, 0))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
