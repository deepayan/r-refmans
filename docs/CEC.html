<!DOCTYPE html><html lang="en"><head><title>Help for package CEC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CEC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CEC-package'><p>Cross-Entropy Clustering</p></a></li>
<li><a href='#cec'><p>Cross-Entropy Clustering</p></a></li>
<li><a href='#fourGaussians'><p>Four Gaussian Clusters</p></a></li>
<li><a href='#init.centers'><p>Cluster Center Initialization</p></a></li>
<li><a href='#mixShapes'><p>Mixed Shapes Clusters</p></a></li>
<li><a href='#mouseset'><p>Mouse</p></a></li>
<li><a href='#plot.cec'><p>Plot CEC Objects</p></a></li>
<li><a href='#print.cec'><p>Printing Cross Entropy Clusters</p></a></li>
<li><a href='#threeGaussians'><p>Three Gaussian Clusters</p></a></li>
<li><a href='#Tset'><p>T-Shaped Clusters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cross-Entropy Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Garnier &lt;garnier@njit.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Splits data into Gaussian type clusters using the Cross-Entropy 
    Clustering ('CEC') method. This method allows for the simultaneous use of 
    various types of Gaussian mixture models, for performing the reduction of 
    unnecessary clusters, and for discovering new clusters by splitting them. 
    'CEC' is based on the work of Spurek, P. and Tabor, J. (2014) 
    &lt;<a href="https://doi.org/10.1016%2Fj.patcog.2014.03.006">doi:10.1016/j.patcog.2014.03.006</a>&gt;.</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/swarm-lab/cec">https://github.com/swarm-lab/cec</a>, <a href="https://swarm-lab.github.io/cec/">https://swarm-lab.github.io/cec/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, methods, stats, utils</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-10 20:57:21 UTC; simon</td>
</tr>
<tr>
<td>Author:</td>
<td>Kamieniecki Konrad [aut],
  Spurek Przemyslaw [ctb],
  Simon Garnier <a href="https://orcid.org/0000-0002-3886-3974"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-10 22:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='CEC-package'>Cross-Entropy Clustering</h2><span id='topic+CEC'></span><span id='topic+CEC-package'></span>

<h3>Description</h3>

<p>CEC divides data into Gaussian type clusters. The implementation
allows the simultaneous use of various type Gaussian mixture models,
performs the reduction of unnecessary clusters and it's able to discover new
groups. Based on Spurek, P. and Tabor, J. (2014) &lt;doi:10.1016/j.patcog.2014.03.006&gt;
<code>cec</code>.
</p>


<h3>Author(s)</h3>

<p>Konrad Kamieniecki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cec">cec</a></code>
</p>

<hr>
<h2 id='cec'>Cross-Entropy Clustering</h2><span id='topic+cec'></span><span id='topic+cec-class'></span>

<h3>Description</h3>

<p><code>cec</code> performs Cross-Entropy Clustering on a data matrix. 
See <code>Details</code> for an explanation of Cross-Entropy Clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cec(
  x,
  centers,
  type = c("covariance", "fixedr", "spherical", "diagonal", "eigenvalues", "mean", "all"),
  iter.max = 25,
  nstart = 1,
  param,
  centers.init = c("kmeans++", "random"),
  card.min = "5%",
  keep.removed = FALSE,
  interactive = FALSE,
  threads = 1,
  split = FALSE,
  split.depth = 8,
  split.tries = 5,
  split.limit = 100,
  split.initial.starts = 1,
  readline = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cec_+3A_x">x</code></td>
<td>
<p>A numeric matrix of data. Each row corresponds to a distinct
observation; each column corresponds to a distinct variable/dimension. It
must not contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="cec_+3A_centers">centers</code></td>
<td>
<p>Either a matrix of initial centers or the number of initial
centers (<code>k</code>, single number <code>cec(data, 4, ...)</code>) or a vector for
variable number of centers (<code>cec(data, 3:10, ...)</code>). It must not
contain <code>NA</code> values.
</p>
<p>If <code>centers</code> is a vector, <code>length(centers)</code> clusterings will be
performed for each start (<code>nstart</code> argument) and the total number of
clusterings will be <code>length(centers) * nstart</code>.
</p>
<p>If <code>centers</code> is a number or a vector, initial centers will be generated
using a method depending on the <code>centers.init</code> argument.</p>
</td></tr>
<tr><td><code id="cec_+3A_type">type</code></td>
<td>
<p>The type (or types) of clustering (density family). This can be
either a single value or a vector of length equal to the number of centers.
Possible values are: &quot;covariance&quot;, &quot;fixedr&quot;, &quot;spherical&quot;, &quot;diagonal&quot;,
&quot;eigenvalues&quot;, &quot;all&quot; (default).
</p>
<p>Currently, if the <code>centers</code> argument is a vector, only a single type 
can be used.</p>
</td></tr>
<tr><td><code id="cec_+3A_iter.max">iter.max</code></td>
<td>
<p>The maximum number of iterations of the clustering algorithm.</p>
</td></tr>
<tr><td><code id="cec_+3A_nstart">nstart</code></td>
<td>
<p>The number of clusterings to perform (with different initial
centers). Only the best clustering (with the lowest cost) will be returned.
A value grater than 1 is valid only if the <code>centers</code> argument is a
number or a vector.
</p>
<p>If the <code>centers</code> argument is a vector, <code>length(centers)</code>
clusterings will be performed for each start and the total number of
clusterings will be <code>length(centers) * nstart</code>.
</p>
<p>If the split mode is on (<code>split = TRUE</code>), the whole procedure (initial
clustering + split) will be performed <code>nstart</code> times, which may take
some time.</p>
</td></tr>
<tr><td><code id="cec_+3A_param">param</code></td>
<td>
<p>The parameter (or parameters) specific to a particular type of
clustering. Not all types of clustering require parameters. The types that
require parameter are: &quot;covariance&quot; (matrix parameter), &quot;fixedr&quot; (numeric
parameter), &quot;eigenvalues&quot; (vector parameter). This can be a vector or a list
(when one of the parameters is a matrix or a vector).</p>
</td></tr>
<tr><td><code id="cec_+3A_centers.init">centers.init</code></td>
<td>
<p>The method used to automatically initialize the centers.
Possible values are: &quot;kmeans++&quot; (default) and &quot;random&quot;.</p>
</td></tr>
<tr><td><code id="cec_+3A_card.min">card.min</code></td>
<td>
<p>The minimal cluster cardinality. If the number of
observations in a cluster becomes lower than card.min, the cluster is
removed. This argument can be either an integer number or a string ending
with a percent sign (e.g. &quot;5%&quot;).</p>
</td></tr>
<tr><td><code id="cec_+3A_keep.removed">keep.removed</code></td>
<td>
<p>If this parameter is TRUE, the removed clusters will be
visible in the results as NA in the &quot;centers&quot; matrix (as well as the
corresponding values in the list of covariances).</p>
</td></tr>
<tr><td><code id="cec_+3A_interactive">interactive</code></td>
<td>
<p>If <code>TRUE</code>, the result of clustering will be plotted 
after every iteration.</p>
</td></tr>
<tr><td><code id="cec_+3A_threads">threads</code></td>
<td>
<p>The number of threads to use or &quot;auto&quot; to use the default
number of threads (usually the number of available processing units/cores)
when performing multiple starts (<code>nstart</code> parameter).
</p>
<p>The execution of a single start is always performed by a single thread, thus
for <code>nstart = 1</code> only one thread will be used regardless of the value
of this parameter.</p>
</td></tr>
<tr><td><code id="cec_+3A_split">split</code></td>
<td>
<p>If <code>TRUE</code>, the function will attempt to discover new
clusters after the initial clustering, by trying to split single clusters
into two and check whether it lowers the cost function.
</p>
<p>For each start (<code>nstart</code>), the initial clustering will be performed and
then splitting will be applied to the results. The number of starts in the
initial clustering before splitting is driven by the
<code>split.initial.starts</code> parameter.</p>
</td></tr>
<tr><td><code id="cec_+3A_split.depth">split.depth</code></td>
<td>
<p>The cluster subdivision depth used in split mode. Usually,
a value lower than 10 is sufficient (when after each splitting, new clusters
have similar sizes). For some data, splitting may often produce clusters
that will not be split further, in that case a higher value of
<code>split.depth</code> is required.</p>
</td></tr>
<tr><td><code id="cec_+3A_split.tries">split.tries</code></td>
<td>
<p>The number of attempts that are made when trying to split
a cluster in split mode.</p>
</td></tr>
<tr><td><code id="cec_+3A_split.limit">split.limit</code></td>
<td>
<p>The maximum number of centers to be discovered in split
mode.</p>
</td></tr>
<tr><td><code id="cec_+3A_split.initial.starts">split.initial.starts</code></td>
<td>
<p>The number of 'standard' starts performed before
starting the splitting process.</p>
</td></tr>
<tr><td><code id="cec_+3A_readline">readline</code></td>
<td>
<p>Used only in the interactive mode. If <code>readline</code> is
TRUE, at each iteration, before plotting it will wait for the user to press
&lt;Return&gt; instead of the standard 'before plotting' waiting
(<code>graphics::par(ask = TRUE)</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cross-Entropy Clustering (CEC) aims to partition <em>m</em> points
into <em>k</em> clusters so as to minimize the cost function (energy
<em><strong>E</strong></em> of the clustering) by switching the points between
clusters. The presented method is based on the Hartigan approach, where we
remove clusters which cardinalities decreased below some small prefixed
level.
</p>
<p>The energy function <em><strong>E</strong></em> is given by:
</p>
<p style="text-align: center;"><code class="reqn">E(Y_1,\mathcal{F}_1;...;Y_k,\mathcal{F}_k) = \sum\limits_{i=1}^{k}
 p(Y_i) \cdot (-ln(p(Y_i)) + H^{\times}(Y_i\|\mathcal{F}_i))</code>
</p>

<p>where <em>Yi</em> denotes the <em>i</em>-th cluster, <em>p(Yi)</em> is the ratio
of the number of points in <em>i</em>-th cluster to the total number points,
<em><strong>H</strong>(Yi|Fi)</em> is the value of cross-entropy, which represents the
internal cluster energy function of data <em>Yi</em> defined with respect to a
certain Gaussian density family <em>Fi</em>, which encodes the type of
clustering we consider.
</p>
<p>The value of the internal energy function <em><strong>H</strong></em> depends on the
covariance matrix (computed using maximum-likelihood) and the mean (in case
of the <em>mean</em> model) of the points in the cluster. Seven
implementations of <em><strong>H</strong></em> have been proposed (expressed as a type
- model - of the clustering):
</p>

<dl>
<dt>&quot;all&quot;: </dt><dd><p>All Gaussian densities. Data will form ellipsoids with
arbitrary radiuses.</p>
</dd>
<dt>&quot;covariance&quot;: </dt><dd><p>Gaussian densities with a fixed given covariance. The
shapes of clusters depend on the given covariance matrix (additional
parameter).</p>
</dd>
<dt>&quot;fixedr&quot;: </dt><dd><p>Special case of 'covariance', where the covariance matrix
equals <em>rI</em> for the given <em>r</em> (additional parameter). The
clustering will have a tendency to divide data into balls with approximate
radius proportional to the square root of <em>r</em>.</p>
</dd>
<dt>&quot;spherical&quot;: </dt><dd><p>Spherical (radial) Gaussian densities (covariance
proportional to the identity). Clusters will have a tendency to form balls
of arbitrary sizes.</p>
</dd>
<dt>&quot;diagonal&quot;: </dt><dd><p>Gaussian densities with diagonal covariane. Data will
form ellipsoids with radiuses parallel to the coordinate axes.</p>
</dd>
<dt>&quot;eigenvalues&quot;: </dt><dd><p>Gaussian densities with covariance matrix having
fixed eigenvalues (additional parameter). The clustering will try to divide
the data into fixed-shaped ellipsoids rotated by an arbitrary angle.</p>
</dd>
<dt>&quot;mean&quot;: </dt><dd><p>Gaussian densities with a fixed mean. Data will be covered
with ellipsoids with fixed centers.</p>
</dd>
</dl>

<p>The implementation of <code>cec</code> function allows mixing of clustering types.
</p>


<h3>Value</h3>

<p>An object of class <code>cec</code> with the following attributes:
<code>data</code>, <code>cluster</code>, <code>probability</code>, <code>centers</code>,
<code>cost.function</code>, <code>nclusters</code>, <code>iterations</code>, <code>cost</code>,
<code>covariances</code>, <code>covariances.model</code>, <code>time</code>.
</p>


<h3>References</h3>

<p>Spurek, P. and Tabor, J. (2014) Cross-Entropy Clustering
<em>Pattern Recognition</em> <b>47, 9</b> 3046&ndash;3059
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CEC-package">CEC-package</a></code>, <code><a href="#topic+plot.cec">plot.cec</a></code>, 
<code><a href="#topic+print.cec">print.cec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example of clustering a random data set of 3 Gaussians, with 10 random
## initial centers and a minimal cluster size of 7% of the total data set.

m1 &lt;- matrix(rnorm(2000, sd = 1), ncol = 2)
m2 &lt;- matrix(rnorm(2000, mean = 3, sd = 1.5), ncol = 2)
m3 &lt;- matrix(rnorm(2000, mean = 3, sd = 1), ncol = 2)
m3[,2] &lt;- m3[, 2] - 5
m &lt;- rbind(m1, m2, m3)

plot(m, cex = 0.5, pch = 19)

## Clustering result:
Z &lt;- cec(m, 10, iter.max = 100, card.min = "7%")
plot(Z)

# Result:
Z

## Example of clustering mouse-like set using spherical Gaussian densities.
m &lt;- mouseset(n = 7000, r.head = 2, r.left.ear = 1.1, r.right.ear = 1.1,
left.ear.dist = 2.5, right.ear.dist = 2.5, dim = 2)
plot(m, cex = 0.5, pch = 19)
## Clustering result:
Z &lt;- cec(m, 3, type = 'sp', iter.max = 100, nstart = 4, card.min = '5%')
plot(Z)
# Result:
Z

## Example of clustering data set 'Tset' using 'eigenvalues' clustering type.
data(Tset)
plot(Tset, cex = 0.5, pch = 19)
centers &lt;- init.centers(Tset, 2)
## Clustering result:
Z &lt;- cec(Tset, 5, 'eigenvalues', param = c(0.02, 0.002), nstart = 4)
plot(Z)
# Result:
Z

## Example of using cec split method starting with a single cluster.
data(mixShapes)
plot(mixShapes, cex = 0.5, pch = 19)
## Clustering result:
Z &lt;- cec(mixShapes, 1, split = TRUE)
plot(Z)
# Result:
Z

</code></pre>

<hr>
<h2 id='fourGaussians'>Four Gaussian Clusters</h2><span id='topic+fourGaussians'></span>

<h3>Description</h3>

<p>Matrix of 2-dimensional points forming four Gaussian clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fourGaussians)
plot(fourGaussians, cex = 0.5, pch = 19);

</code></pre>

<hr>
<h2 id='init.centers'>Cluster Center Initialization</h2><span id='topic+init.centers'></span>

<h3>Description</h3>

<p><code>init.centers</code> automatically initializes the centers of the
clusters before running the Cross-Entropy Clustering algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.centers(x, k, method = c("kmeans++", "random"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init.centers_+3A_x">x</code></td>
<td>
<p>A numeric matrix of data. Each row corresponds to a distinct
observation; each column corresponds to a distinct variable/dimension. It
must not contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="init.centers_+3A_k">k</code></td>
<td>
<p>An integer indicating the number of cluster centers to initialize.</p>
</td></tr>
<tr><td><code id="init.centers_+3A_method">method</code></td>
<td>
<p>A character string indicating the initialization method to use. 
It can take the following values:
</p>

<dl>
<dt>&quot;kmeans++&quot;: </dt><dd><p>the centers are selected using the k-means++ algorithm.</p>
</dd>
<dt>&quot;random&quot;: </dt><dd><p>the centers are randomly selected among the values in
<code>x</code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>k</code> rows and <code>ncol(x)</code> columns.
</p>


<h3>References</h3>

<p>Arthur, D., &amp; Vassilvitskii, S. (2007). k-means++: the advantages 
of careful seeding. Proceedings of the Eighteenth Annual ACM-SIAM Symposium 
on Discrete Algorithms, 1027–1035.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the examples provided with the cec() function.

</code></pre>

<hr>
<h2 id='mixShapes'>Mixed Shapes Clusters</h2><span id='topic+mixShapes'></span>

<h3>Description</h3>

<p>Matrix of 2-dimensional points that form circular and elliptical 
patterns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mixShapes)
plot(mixShapes, cex = 0.5, pch = 19);

</code></pre>

<hr>
<h2 id='mouseset'>Mouse</h2><span id='topic+mouseset'></span>

<h3>Description</h3>

<p><code>mouseset</code> generates a cluster of points uniformly 
distributed inside a &quot;mouse head&quot; shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mouseset(
  n = 4000,
  r.head = 2,
  r.left.ear = 1.1,
  r.right.ear = 1.1,
  left.ear.dist = 2.5,
  right.ear.dist = 2.5,
  dim = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mouseset_+3A_n">n</code></td>
<td>
<p>The number of points (default: 4000).</p>
</td></tr>
<tr><td><code id="mouseset_+3A_r.head">r.head</code></td>
<td>
<p>The radius of the mouse's head (default: 2).</p>
</td></tr>
<tr><td><code id="mouseset_+3A_r.left.ear">r.left.ear</code>, <code id="mouseset_+3A_r.right.ear">r.right.ear</code></td>
<td>
<p>The radii of the left and right ear of the 
mouse's head (default: 1.1).</p>
</td></tr>
<tr><td><code id="mouseset_+3A_left.ear.dist">left.ear.dist</code>, <code id="mouseset_+3A_right.ear.dist">right.ear.dist</code></td>
<td>
<p>The distance between the center of the 
mouse's head and the center of the left and right ear (default: 2.5).</p>
</td></tr>
<tr><td><code id="mouseset_+3A_dim">dim</code></td>
<td>
<p>The dimensionality of the mouse's head (default: 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>dim</code> columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(mouseset())

</code></pre>

<hr>
<h2 id='plot.cec'>Plot CEC Objects</h2><span id='topic+plot.cec'></span>

<h3>Description</h3>

<p><code>plot.cec</code> presents the results from the <code><a href="#topic+cec">cec</a></code>
function in the form of a plot. The colors of the data points represent the
cluster they belong to. Ellipses are drawn to represent the covariance
(of either the model or the sample) of each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cec'
plot(
  x,
  col,
  cex = 0.5,
  pch = 19,
  cex.centers = 1,
  pch.centers = 8,
  ellipses = TRUE,
  ellipses.lwd = 4,
  ellipses.lty = 2,
  model = TRUE,
  xlab,
  ylab,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cec_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+cec">cec</a></code> object resulting from the <code><a href="#topic+cec">cec</a></code>
function.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_col">col</code></td>
<td>
<p>A specification for the default plotting color of the points in 
the clusters. See <code><a href="graphics.html#topic+par">par</a></code> for more details.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_cex">cex</code></td>
<td>
<p>A numerical value giving the amount by which plotting text and 
symbols should be magnified relative to the default. See <code><a href="graphics.html#topic+par">par</a></code> 
for more details.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_pch">pch</code></td>
<td>
<p>Either an integer specifying a symbol or a single character to be 
used as the default in plotting points. See <code><a href="graphics.html#topic+par">par</a></code> for more 
details.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_cex.centers">cex.centers</code></td>
<td>
<p>The same as <code>cex</code>, except that it applies only to the 
centers' means.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_pch.centers">pch.centers</code></td>
<td>
<p>The same as <code>pch</code>, except that it applies only to the 
centers' means.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_ellipses">ellipses</code></td>
<td>
<p>If this parameter is TRUE, covariance ellipses will be drawn.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_ellipses.lwd">ellipses.lwd</code></td>
<td>
<p>The line width of the covariance ellipses. See <code>lwd</code>
in <code><a href="graphics.html#topic+par">par</a></code> for more details.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_ellipses.lty">ellipses.lty</code></td>
<td>
<p>The line type of the covariance ellipses. See <code>lty</code>
in <code><a href="graphics.html#topic+par">par</a></code> for more details.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_model">model</code></td>
<td>
<p>If this parameter is TRUE, the model (expected) covariance will
be used for each cluster instead of the sample covariance (MLE) of the 
points in the cluster, when drawing the covariance ellipses.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x axis. See <a href="base.html#topic+plot">plot</a> for more details.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_ylab">ylab</code></td>
<td>
<p>A label for the y axis. See <a href="base.html#topic+plot">plot</a> for more details.</p>
</td></tr>
<tr><td><code id="plot.cec_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>plot</code> when drawing data 
points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns nothing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cec">cec</a></code>, <code><a href="#topic+print.cec">print.cec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the examples provided with the cec() function.

</code></pre>

<hr>
<h2 id='print.cec'>Printing Cross Entropy Clusters</h2><span id='topic+print.cec'></span>

<h3>Description</h3>

<p>Print objects of class <code><a href="#topic+cec">cec</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cec'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cec_+3A_x">x</code></td>
<td>
<p>An object produced by <code><a href="#topic+cec">cec</a></code>.</p>
</td></tr>
<tr><td><code id="print.cec_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns nothing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cec">cec</a></code>, <code><a href="#topic+plot.cec">plot.cec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the examples provided with the cec() function.

</code></pre>

<hr>
<h2 id='threeGaussians'>Three Gaussian Clusters</h2><span id='topic+threeGaussians'></span>

<h3>Description</h3>

<p>Matrix of 2-dimensional points forming three Gaussian clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(threeGaussians)
plot(threeGaussians, cex = 0.5, pch = 19);

</code></pre>

<hr>
<h2 id='Tset'>T-Shaped Clusters</h2><span id='topic+Tset'></span>

<h3>Description</h3>

<p>Matrix of 2-dimensional points that form the letter T.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Tset)
plot(Tset, cex = 0.5, pch = 19);

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
