<!DOCTYPE html><html><head><title>Help for package SPLICE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SPLICE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SPLICE-package'><p>SPLICE: Synthetic Paid Loss and Incurred Cost Experience (SPLICE) Simulator</p></a></li>
<li><a href='#claim_history'><p>Development of Case Estimates</p></a></li>
<li><a href='#claim_majRev'><p>Major Revisions of Incurred Loss</p></a></li>
<li><a href='#claim_minRev'><p>Minor Revisions of Outstanding Claim Payments</p></a></li>
<li><a href='#generate_data'><p>Generate Data of Varying Complexity</p></a></li>
<li><a href='#generate_incurred_dataset'><p>Generate Incurred Dataset</p></a></li>
<li><a href='#output_incurred'><p>Incurred Triangles</p></a></li>
<li><a href='#test_incurred_dataset'><p>Incurred Case Estimates Dataset</p></a></li>
<li><a href='#triangular'><p>The Triangular Distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Synthetic Paid Loss and Incurred Cost Experience (SPLICE)
Simulator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Avanzi [aut],
  Greg Taylor [aut],
  Melantha Wang [aut, cre],
  William Ho [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Melantha Wang &lt;wang.melantha@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, zoo, lifecycle</td>
</tr>
<tr>
<td>Description:</td>
<td>An extension to the individual claim simulator called 'SynthETIC'
    (on CRAN), to simulate the evolution of case estimates of incurred losses
    through the lifetime of an insurance claim. The transactional simulation
    output now comprises key dates, and both claim payments and revisions of
    estimated incurred losses. An initial set of test parameters, designed to
    mirror the experience of a real insurance portfolio, were set up and applied
    by default to generate a realistic test data set of incurred histories (see
    vignette). However, the distributional assumptions used to generate this
    data set can be easily modified by users to match their experiences.
    Reference: Avanzi B, Taylor G, Wang M (2021) "SPLICE: A Synthetic Paid Loss
    and Incurred Cost Experience Simulator" &lt;<a href="https://doi.org/10.48550/arXiv.2109.04058">doi:10.48550/arXiv.2109.04058</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/agi-lab/SPLICE">https://github.com/agi-lab/SPLICE</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/agi-lab/SPLICE/issues">https://github.com/agi-lab/SPLICE/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, dplyr, RColorBrewer, actuar</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), SynthETIC (&ge; 1.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-27 13:30:05 UTC; melantha</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-04 00:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SPLICE-package'>SPLICE: Synthetic Paid Loss and Incurred Cost Experience (SPLICE) Simulator</h2><span id='topic+SPLICE'></span><span id='topic+SPLICE-package'></span>

<h3>Description</h3>

<p>An extension to the individual claim simulator called 'SynthETIC' (on CRAN), to simulate the evolution of case estimates of incurred losses through the lifetime of an insurance claim. The transactional simulation output now comprises key dates, and both claim payments and revisions of estimated incurred losses. An initial set of test parameters, designed to mirror the experience of a real insurance portfolio, were set up and applied by default to generate a realistic test data set of incurred histories (see vignette). However, the distributional assumptions used to generate this data set can be easily modified by users to match their experiences. Reference: Avanzi B, Taylor G, Wang M (2021) &quot;SPLICE: A Synthetic Paid Loss and Incurred Cost Experience Simulator&quot; <a href="https://arxiv.org/abs/2109.04058">arXiv:2109.04058</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Melantha Wang <a href="mailto:wang.melantha@gmail.com">wang.melantha@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Benjamin Avanzi <a href="mailto:b.avanzi@unimelb.edu.au">b.avanzi@unimelb.edu.au</a>
</p>
</li>
<li><p> Greg Taylor <a href="mailto:greg_taylor60@hotmail.com">greg_taylor60@hotmail.com</a>
</p>
</li>
<li><p> William Ho <a href="mailto:ho.w@unimelb.edu.au">ho.w@unimelb.edu.au</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/agi-lab/SPLICE">https://github.com/agi-lab/SPLICE</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/agi-lab/SPLICE/issues">https://github.com/agi-lab/SPLICE/issues</a>
</p>
</li></ul>


<hr>
<h2 id='claim_history'>Development of Case Estimates</h2><span id='topic+claim_history'></span>

<h3>Description</h3>

<p>Consolidates payments and incurred revisions and returns a full transactional
history of all the individual claims (transaction being either a payment or
a case estimate revision).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_history(
  claims,
  majRev_list,
  minRev_list,
  k1 = 0.95,
  k2 = 0.95,
  base_inflation_vector = NULL,
  keep_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_history_+3A_claims">claims</code></td>
<td>
<p>an <code>claims</code> object containing all the simulated quantities
(other than those related to incurred loss), see
<code><a href="SynthETIC.html#topic+claims">claims</a></code>.</p>
</td></tr>
<tr><td><code id="claim_history_+3A_majrev_list">majRev_list</code></td>
<td>
<p>nested list of major revision histories, see
<code><a href="#topic+claim_majRev">claim_majRev</a></code>.</p>
</td></tr>
<tr><td><code id="claim_history_+3A_minrev_list">minRev_list</code></td>
<td>
<p>nested list of minor revision histories, see
<code><a href="#topic+claim_minRev">claim_minRev</a></code>.</p>
</td></tr>
<tr><td><code id="claim_history_+3A_k1">k1</code></td>
<td>
<p>maximum amount of cumulative claims paid as a proportion of
total incurred estimate for major revisions; between 0 and 1.</p>
</td></tr>
<tr><td><code id="claim_history_+3A_k2">k2</code></td>
<td>
<p>maximum amount of cumulative claims paid as a proportion of
total incurred estimate for minor revisions; between 0 and 1.</p>
</td></tr>
<tr><td><code id="claim_history_+3A_base_inflation_vector">base_inflation_vector</code></td>
<td>
<p>vector showing <strong>quarterly</strong> base inflation
rates (quarterly effective) for all the periods under consideration (default
is nil base inflation), should be consistent with the input inflation vector
in <code><a href="SynthETIC.html#topic+claim_payment_inflation">claim_payment_inflation</a></code>. If a single number is
provided, the function will assume constant quarterly inflation.</p>
</td></tr>
<tr><td><code id="claim_history_+3A_keep_all">keep_all</code></td>
<td>
<p><code>TRUE</code> to keep the paid, outstanding payments, total
incurred estimates just before the revision, <code>FALSE</code> to keep only the
estimates right after the revision (<code style="white-space: pre;">&#8288;_right&#8288;</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works to generate the full history of claims paid and
incurred estimates by consolidating all the simulated revision quantities.
It should be noted that in this consolidation step, we make the following
adjustments:
</p>

<ul>
<li><p> Major and minor revisions should not occur simultaneously. In the event
that they do (which is only possible at the second last partial payment),
the major revision takes precedence, and the minor revision be discarded.
This will be reflected in the <code>majRev</code> and <code>minRev</code> components of the output
list.
</p>
</li>
<li><p> Estimates of incurred loss are specified to be computed in reverse order,
and it is necessary that the total incurred estimate is always strictly
greater than the cumulative claims paid (except at the final paymen where
equality holds). Hence we introduce <code>k1</code> and <code>k2</code> to make sure that
the revised incurred estimates satisfy </p>
<p style="text-align: center;"><code class="reqn">ky(t) \ge c(t)</code>
</p>
<p> where <code class="reqn">y(t)</code>
represents the total incurred estimate at delay <code class="reqn">t</code>, <code class="reqn">k</code> is a
constant between 0 and 1, and <code class="reqn">c(t)</code> is the cumulative claims paid up to
time <code class="reqn">t</code>. When the raw simulated revision multipliers violate this
requirement, the case estimates of the total incurred or the outstanding
claim payments will be increased to make sure this condition always holds,
i.e. this adjustment takes precedence over the raw simulated revision
multipliers.
</p>
</li>
<li> <p><strong>Inflation adjustment</strong>: One can choose to ignore inflation in the
incurred estimates (default), or to make allowance for
it.
</p>

<ul>
<li><p> If <code>base_inflation_vector == NULL</code> (default), then all case estimates
will be computed in values corresponding to time <code class="reqn">t = 0</code>, i.e. the
commencement of the first occurrence period.
</p>
</li>
<li><p> If <code>base_inflation_vector</code> is provided, then the case estimators will
include full superimposed inflation and base inflation only up to the date
of the revision, i.e. there is an adjustment for the time elapsed since the
immediately preceding revision and <strong>no future base inflation</strong> beyond the
date of valuation.
</p>
</li>
<li><p> If inflation is involved, it should be noted that the case estimator
reviews the base inflation situation only in the process of making a
revision. When <em>only</em> a payment is made, the insurer's system automatically
writes down the outstanding liability on the assumption of no change in
ultimate incurred amount.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>A nested list structure such that the <em>j</em>th component of the <em>i</em>th
sub-list provides a full transactional history of the <em>j</em>th claim of
occurrence period <em>i</em>. The &quot;unit list&quot; (i.e. the smallest, innermost
sub-list) contains the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>txn_delay</code> </td><td style="text-align: left;"> Delays from notification to the transactions (payment or
incurred revision). </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>txn_time</code> </td><td style="text-align: left;"> Times of the transactions (from the commencement of the
first occurrence period). </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>txn_type</code> </td><td style="text-align: left;"> Types of the transactions, "Ma" for major revision, "Mi" for
minor revision, "P" for payment, "PMa" for major revision coincident with a
payment, "PMi" for minor revision coincident with a payment. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cumpaid_right</code> </td><td style="text-align: left;"> Cumulative claim payments immediately after each of the
transactions (in the "right" continuous sense). </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OCL_right</code> </td><td style="text-align: left;"> Case estimate of outstanding claim payments immediately
after each of the transactions (in the "right" continuous sense). </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>incurred_right</code> </td><td style="text-align: left;"> Case estimate of incurred loss immediately after each
of the transactions (in the "right" continuous sense). </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>minRev</code> </td><td style="text-align: left;"> A list containing full history of minor revisions (frequency,
time and revision size); <code><a href="#topic+claim_minRev">claim_minRev</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>majRev</code> </td><td style="text-align: left;"> A list containing full history of major revisions (frequency,
time and revision size); see <code><a href="#topic+claim_majRev">claim_majRev</a></code>.
</td>
</tr>

</table>

<p>and optionally (by setting <code>keep_all = TRUE</code>),
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>cumpaid_left</code> </td><td style="text-align: left;"> Cumulative claim payments just before each of the
transactions. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OCL_left</code> </td><td style="text-align: left;"> Case estimate of outstanding claim payments just before each
of the transactions. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>incurred_left</code> </td><td style="text-align: left;"> Case estimate of incurred loss just before each of the
transactions. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<hr>
<h2 id='claim_majRev'>Major Revisions of Incurred Loss</h2><span id='topic+claim_majRev'></span><span id='topic+claim_majRev_freq'></span><span id='topic+claim_majRev_time'></span><span id='topic+claim_majRev_size'></span>

<h3>Description</h3>

<p>A suite of functions that works together to simulate, in order, the (1)
frequency, (2) time, and (3) size of major revisions of incurred loss, for
each of the claims occurring in each of the periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_majRev_freq(
  claims,
  rfun,
  paramfun,
  frequency_vector = claims$frequency_vector,
  claim_size_list = claims$claim_size_list,
  ...
)

claim_majRev_time(
  claims,
  majRev_list,
  rfun,
  paramfun,
  claim_size_list = claims$claim_size_list,
  settlement_list = claims$settlement_list,
  payment_delay_list = claims$payment_delay_list,
  ...
)

claim_majRev_size(majRev_list, rfun, paramfun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_majRev_+3A_claims">claims</code></td>
<td>
<p>an <code><a href="SynthETIC.html#topic+claims">claims</a></code> object containing all the
simulated quantities (other than those related to incurred loss), see
<code><a href="SynthETIC.html#topic+claims">claims</a></code>.</p>
</td></tr>
<tr><td><code id="claim_majRev_+3A_rfun">rfun</code></td>
<td>
<p>optional alternative random sampling function for:
</p>

<ul>
<li> <p><code>claim_majRev_freq</code>: the number of major revisions;
</p>
</li>
<li> <p><code>claim_majRev_time</code>: the epochs of major revisions measured from claim
notification;
</p>
</li>
<li> <p><code>claim_majRev_size</code>: the sizes of the major revision multipliers.
</p>
</li></ul>

<p>See Details for default.</p>
</td></tr>
<tr><td><code id="claim_majRev_+3A_paramfun">paramfun</code></td>
<td>
<p>parameters for the random sampling function, as a function of
other claim characteristics such as <code>claim_size</code>; see Details.</p>
</td></tr>
<tr><td><code id="claim_majRev_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods
(not required if the <code>claims</code> argument is provided); see
<code><a href="SynthETIC.html#topic+claim_frequency">claim_frequency</a></code>.</p>
</td></tr>
<tr><td><code id="claim_majRev_+3A_claim_size_list">claim_size_list</code></td>
<td>
<p>list of claim sizes (not required if the <code>claims</code>
argument is provided); see <code><a href="SynthETIC.html#topic+claim_size">claim_size</a></code>.</p>
</td></tr>
<tr><td><code id="claim_majRev_+3A_...">...</code></td>
<td>
<p>other arguments/parameters to be passed onto <code>paramfun</code>.</p>
</td></tr>
<tr><td><code id="claim_majRev_+3A_majrev_list">majRev_list</code></td>
<td>
<p>nested list of major revision histories (with non-empty
revision frequencies).</p>
</td></tr>
<tr><td><code id="claim_majRev_+3A_settlement_list">settlement_list</code></td>
<td>
<p>list of settlement delays (not required if the
<code>claims</code> argument is provided); see <code><a href="SynthETIC.html#topic+claim_closure">claim_closure</a></code>.</p>
</td></tr>
<tr><td><code id="claim_majRev_+3A_payment_delay_list">payment_delay_list</code></td>
<td>
<p>(compound) list of inter partial delays (not
required if the <code>claims</code> argument is provided); see
<code><a href="SynthETIC.html#topic+claim_payment_delay">claim_payment_delay</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list structure such that the <em>j</em>th component of the <em>i</em>th
sub-list is a list of information on major revisions of the <em>j</em>th claim of
occurrence period <em>i</em>. The &quot;unit list&quot; (i.e. the smallest, innermost
sub-list) contains the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>majRev_freq</code> </td><td style="text-align: left;"> Number of major revisions of incurred loss
[<code>claim_majRev_freq()</code>]. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>majRev_time</code> </td><td style="text-align: left;"> Time of major revisions (from claim notification)
[<code>claim_majRev_time()</code>]. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>majRev_factor</code> </td><td style="text-align: left;"> Major revision multiplier of <strong>incurred loss</strong>
[<code>claim_majRev_size()</code>]. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>majRev_atP</code> </td><td style="text-align: left;"> An indicator, <code>1</code> if the last major revision occurs at the
time of the last major payment (i.e. second last payment), <code>0</code> otherwise
[<code>claim_majRev_time()</code>].
</td>
</tr>

</table>



<h3>Details - <code>claim_majRev_freq</code> (Frequency)</h3>

<p>Let <em>K</em> represent the number
of major revisions associated with a particular claim. The notification of a
claim is considered as a major revision, so all claims have at least 1 major
revision (<code class="reqn">K \ge 1</code>).
</p>
<p>The default <code>majRev_freq_function</code> specifies that no additional major revisions
will occur for claims of size smaller than or equal to <code>claim_size_benchmark</code>
(0.075 * <code>ref_claim</code> by default). For claims above this threshold,
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">Pr(K = 2)</code> </td><td style="text-align: left;"> <code class="reqn">= 0.1 + 0.3min(1, (claim_size - 0.075 * ref_claim) / 0.925 * ref_claim)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">Pr(K = 3)</code> </td><td style="text-align: left;"> <code class="reqn">= 0.5min(1, max(0, claim_size - 0.25 * ref_claim)/ (0.75 * ref_claim))</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">Pr(K = 1)</code> </td><td style="text-align: left;"> <code class="reqn">= 1 - Pr(K = 2) - Pr(K = 3)</code>
</td>
</tr>

</table>

<p>where <code>ref_claim</code> is a package-wise global variable that user should define
by <code><a href="SynthETIC.html#topic+set_parameters">set_parameters</a></code> (if moving away from the default).
</p>
<p>The idea is that	major revisions are more likely for larger claims, and do
not occur at all for the smallest claims. Note also that by default a claim
may experience <strong>up to a maximum of 2 major revisions</strong> in addition to the
one at claim notification. This is taken as an assumption in the default
setting of <code>claim_majRev_size()</code>. If user decides to modify this assumption,
they will need to take care of the part on the major revision size as well.
</p>


<h3>Details - <code>claim_majRev_time</code> (Time)</h3>

<p>Let <code class="reqn">\tau_k</code> represent the
epoch of the <em>k</em>th major revision (time measured from claim notification),
<code class="reqn">k = 1, ..., K</code>. As the notification of a claim is considered a major
revision itself, we have <code class="reqn">\tau_1 = 0</code> for all claims.
</p>
<p>The last major revision for a claim may occur at the time of the second last
partial payment (which is usually the major settlement payment) with
probability
</p>
<p style="text-align: center;"><code class="reqn">0.2 min(1, max(0, (claim_size - ref_claim) / (14 * ref_claim)))</code>
</p>

<p>where <code>ref_claim</code> is a package-wise global variable that user should define
by <code><a href="SynthETIC.html#topic+set_parameters">set_parameters</a></code> (if moving away from the default).
</p>
<p>Now, if there is a major revision at the time of the second last partial
payment, then <code class="reqn">\tau_k, k = 2, ..., K - 1</code> are sampled from a triangular
distribution with parameters (see also <code><a href="#topic+ptri">ptri</a></code>)
</p>

<ul>
<li> <p><code>min = time_to_second_last_payment / 3</code>
</p>
</li>
<li> <p><code>max = time_to_second_last_payment</code>
</p>
</li>
<li><p> maximum density at <code>mode = time_to_second_last_payment / 3</code>.
</p>
</li></ul>

<p>Otherwise (i.e. no major revision at the time of the second last partial
payment), <code class="reqn">\tau_k, k = 2, ..., K</code> are sampled from a triangular
distribution with parameters
</p>

<ul>
<li> <p><code>min = settlement_delay / 3</code>
</p>
</li>
<li> <p><code>max = settlement_delay</code>
</p>
</li>
<li><p> maximum density at <code>mode = settlement_delay / 3</code>.
</p>
</li></ul>

<p>Note that when there is a major revision at the time of the second last
partial payment, <code>majRev_atP</code> (one of the output list components) will be set
to be 1.
</p>


<h3>Details - <code>claim_majRev_size</code> (Revision Multiplier)</h3>

<p>As mentioned in
the frequency section (&quot;Details - <code>claim_majRev_freq</code>&quot;), the default function
for the major revision multipliers assumes that there are only up to 2 major
revisions (in addition to the one at claim notification) for all claims.
</p>
<p>By default,
</p>

<ul>
<li><p> the first major revision multiplier <code class="reqn">g_1</code> is simply 1 (no meaning);
</p>
</li>
<li><p> the second major revision multiplier <code class="reqn">g_2</code> is sampled from a lognormal
distribution with parameters <code>meanlog</code> <code class="reqn"> = 1.8</code> and <code>sdlog</code> <code class="reqn">= 0.2</code>;
</p>
</li>
<li><p> the third major revision multiplier <code class="reqn">g_3</code> is sampled from a lognormal
distribution with parameters <code>meanlog</code> <code class="reqn">= 1 + 0.07(6 - g_2)</code> and <code>sdlog</code>
<code class="reqn">= 0.1</code>. Note that the third major revision is likely to be smaller than
the second.
</p>
</li></ul>

<p>The revision multipliers are subject to further constraints to ensure that
the revised incurred estimate never falls below what has already been paid.
This is dicussed in <code><a href="#topic+claim_history">claim_history</a></code>.
</p>
<p><strong>The major revision multipliers apply to the incurred loss estimates</strong>, that
is, a revision multiplier of 2.54 means that at the time of the major
revision the incurred loss increases by a factor of 2.54. We highlight this
as <strong>in the case of minor revisions, the multipliers will instead apply to
outstanding claim amounts</strong>, see <code><a href="#topic+claim_minRev">claim_minRev</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="SynthETIC.html#topic+claims">claims</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
test_claims &lt;- SynthETIC::test_claims_object
major &lt;- claim_majRev_freq(test_claims)
major[[1]][[1]] # the "unit list" for the first claim

# update the timing information
major &lt;- claim_majRev_time(test_claims, major)
# observe how this has changed
major[[1]][[1]]

# update the revision multipliers
major &lt;- claim_majRev_size(major)
# again observe how this has changed
major[[1]][[1]]
</code></pre>

<hr>
<h2 id='claim_minRev'>Minor Revisions of Outstanding Claim Payments</h2><span id='topic+claim_minRev'></span><span id='topic+claim_minRev_freq'></span><span id='topic+claim_minRev_time'></span><span id='topic+claim_minRev_size'></span>

<h3>Description</h3>

<p>A suite of functions that works together to simulate, in order,
the (1) frequency, (2) time, and (3) size of minor revisions of outstanding
claim payments, for each of the claims occurring in each of the periods.
</p>
<p>We separate the case of minor revisions that occur simultaneously with a
partial payment (denoted <code style="white-space: pre;">&#8288;_atP&#8288;</code>), and the ones that do not coincide with a
payment (denoted <code style="white-space: pre;">&#8288;_notatP&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_minRev_freq(
  claims,
  prob_atP = 0.5,
  rfun_notatP,
  paramfun_notatP,
  frequency_vector = claims$frequency_vector,
  settlement_list = claims$settlement_list,
  no_payments_list = claims$no_payments_list,
  ...
)

claim_minRev_time(
  claims,
  minRev_list,
  rfun_notatP,
  paramfun_notatP,
  settlement_list = claims$settlement_list,
  payment_delay_list = claims$payment_delay_list,
  ...
)

claim_minRev_size(
  claims,
  majRev_list,
  minRev_list,
  rfun,
  paramfun_atP,
  paramfun_notatP,
  settlement_list = claims$settlement_list,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_minRev_+3A_claims">claims</code></td>
<td>
<p>an <code>claims</code> object containing all the simulated quantities
(other than those related to incurred loss), see
<code><a href="SynthETIC.html#topic+claims">claims</a></code>.</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_prob_atp">prob_atP</code></td>
<td>
<p>(optional) probability that a minor revision will occur at
the time of a partial payment; default value 0.5.</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_rfun_notatp">rfun_notatP</code></td>
<td>
<p>optional alternative random sampling function for:
</p>

<ul>
<li> <p><code>claim_minRev_freq</code>: the number of minor revisions that occur at an epoch
other than those of partial payments;
</p>
</li>
<li> <p><code>claim_minRev_time</code>: the epochs of such minor revisions measured from claim
notification;
</p>
</li>
<li> <p><code>claim_minRev_size</code>: the sizes of the minor revision multipliers (common for
<code style="white-space: pre;">&#8288;_atP&#8288;</code> and <code style="white-space: pre;">&#8288;_notatP&#8288;</code>, hence simply termed <code>rfun</code> in this case).
</p>
</li></ul>

<p>See Details for default.</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_paramfun_notatp">paramfun_notatP</code></td>
<td>
<p>parameters for the above random sampling function,
as a function of other claim characteristics (e.g. <code>lambda</code> as a function of
<code>claim_size</code> for an <code>rpois</code> simulation); see Examples.</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods
(not required if the <code>claims</code> argument is provided); see
<code><a href="SynthETIC.html#topic+claim_frequency">claim_frequency</a></code>.</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_settlement_list">settlement_list</code></td>
<td>
<p>list of settlement delays (not required if the
<code>claims</code> argument is provided); see <code><a href="SynthETIC.html#topic+claim_closure">claim_closure</a></code>.</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_no_payments_list">no_payments_list</code></td>
<td>
<p>list of number of partial payments (not required if
the <code>claims</code> argument is provided); see
<code><a href="SynthETIC.html#topic+claim_payment_no">claim_payment_no</a></code>.</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_...">...</code></td>
<td>
<p>other arguments/parameters to be passed onto <code>paramfun</code>.</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_minrev_list">minRev_list</code></td>
<td>
<p>nested list of minor revision histories (with non-empty
revision frequencies).</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_payment_delay_list">payment_delay_list</code></td>
<td>
<p>(compound) list of inter partial delays (not
required if the <code>claims</code> argument is provided); see
<code><a href="SynthETIC.html#topic+claim_payment_delay">claim_payment_delay</a></code>.</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_majrev_list">majRev_list</code></td>
<td>
<p>nested list of major revision histories (with non-empty
revision frequencies).</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_rfun">rfun</code></td>
<td>
<p>optional alternative random sampling function for the sizes of
the minor revision multipliers (common for <code style="white-space: pre;">&#8288;_atP&#8288;</code> and <code style="white-space: pre;">&#8288;_notatP&#8288;</code>, hence simply
termed <code>rfun</code> in this case).</p>
</td></tr>
<tr><td><code id="claim_minRev_+3A_paramfun_atp">paramfun_atP</code></td>
<td>
<p>parameters for <code>rfun</code> in <code>claim_minRev_size()</code> for minor
revisions that occur at the time of a partial payment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list structure such that the <em>j</em>th component of the <em>i</em>th
sub-list is a list of information on minor revisions of the <em>j</em>th claim of
occurrence period <em>i</em>. The &quot;unit list&quot; (i.e. the smallest, innermost
sub-list) contains the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>minRev_atP</code> </td><td style="text-align: left;"> A vector of indicators showing whether there is a minor
revision at each partial payment [<code>claim_minRev_freq()</code>]. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>minRev_freq_atP</code> </td><td style="text-align: left;"> Number of minor revisions that occur simultaneously with
a partial payment, numerically equals to the sum of <code>minRev_atP</code>
[<code>claim_minRev_freq()</code>]. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>minRev_freq_notatP</code> </td><td style="text-align: left;"> Number of minor revisions that do not occur with a
partial payment [<code>claim_minRev_freq()</code>]. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>minRev_time_atP</code> </td><td style="text-align: left;"> Time of minor revisions that occur simultaneously with
a partial payment (time measured from claim notification)
[<code>claim_minRev_time()</code>]. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>minRev_time_notatP</code> </td><td style="text-align: left;"> Time of minor revisions that do <em>not</em> occur
simultaneously with a partial payment (time measured from claim notification)
[<code>claim_minRev_time()</code>]. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>minRev_factor_atP</code> </td><td style="text-align: left;"> Minor revision multipliers of <strong>outstanding claim
payments</strong> for revisions at partial payments [<code>claim_minRev_size()</code>]. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>minRev_factor_notatP</code> </td><td style="text-align: left;"> Minor revision multipliers of <strong>outstanding claim
payments</strong> for revisions at any other times [<code>claim_minRev_size()</code>]. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details - <code>claim_minRev_freq</code> (Frequency)</h3>

<p>Minor revisions may occur
simultaneously with a partial payment, or at any other time.
</p>
<p>For the former case, we sample the occurrence of minor revisions as Bernoulli
random variables with default probability parameter <code>prob_atP</code> <code class="reqn">= 1/2</code>.
</p>
<p>For the latter case, by default we sample the number of (non payment
simultaneous) minor revisions from a geometric distribution with mean =
<code class="reqn">min(3, setldel / 4)</code>.
</p>
<p>One can modify the above sampling distributions by plugging in their own
<code>prob_atP</code> parameter and <code>rfun_notatP</code> function, where the former dictates
the probability of incurring a minor revision at the time of a payment, and
the latter simulates and returns the number of minor revisions at any other
points in time, with possible dependence on the settlement delay of the claim
and/or other claim characteristics.
</p>


<h3>Details - <code>claim_minRev_time</code> (Time)</h3>

<p>For minor revisions that occur
simultaneously with a partial payment, the revision times simply coincide
with the epochs of the relevant partial payments.
</p>
<p>For minor revisions that occur at a different time, by default the revision
times are sampled from a uniform distribution with parameters <code>min</code> <code class="reqn">=
settlement_delay / 6</code> and <code>max</code> <code class="reqn">= settlement_delay</code>.
</p>
<p>One can modify the above sampling distribution by plugging in their own
<code>rfun_notatP</code> and <code>paramfun_notatP</code> in <code>claim_minRev_time()</code>, which together
simulate the epochs of minor revisions that do not coincide with a payment,
with possible dependence on the settlement delay of the claim and/or other
claim characteristics (see Examples).
</p>


<h3>Details - <code>claim_minRev_size</code> (Revision Multiplier)</h3>

<p>The sampling
distribution for minor revision multipliers is the same for both revisions
that occur with and without a partial payment. In the default setting, we
incorporate sampling dependence on the delay from notification to settlement
(<code>setldel</code>), the delay from notification to the subject minor revisions
(<code>minRev_time</code>), and the history of major revisions (in particular, the time
of the second major revision).
</p>
<p>Let <code class="reqn">\tau</code> denote the delay from notification to the epoch of the minor
revision, and <code class="reqn">w</code> the settlement delay. Then
</p>

<ul>
<li><p> For <code class="reqn">\tau \le w / 3</code>, the revision multiplier is sampled from a
lognormal distribution with parameters <code>meanlog</code> <code class="reqn">= 0.15</code> and <code>sdlog</code>
<code class="reqn">= 0.05</code> if preceded by a 2nd major revision, <code>sdlog</code> <code class="reqn">= 0.1</code>
otherwise;
</p>
</li>
<li><p> For <code class="reqn">w / 3 &lt; \tau \le 2w / 3</code>, the revision multiplier is sampled
from a lognormal distribution with parameters <code>meanlog</code> <code class="reqn">= 0</code> and <code>sdlog</code>
<code class="reqn">= 0.05</code> if preceded by a 2nd major revision, <code>sdlog</code> <code class="reqn">= 0.1</code>
otherwise;
</p>
</li>
<li><p> For <code class="reqn">\tau &gt; 2w / 3</code>, the revision multiplier is sampled from a
lognormal distribution with parameters <code>meanlog</code> <code class="reqn">= -0.1</code> and <code>sdlog</code>
<code class="reqn">= 0.05</code> if preceded by a 2nd major revision, <code>sdlog</code> <code class="reqn">= 0.1</code>
otherwise.
</p>
</li></ul>

<p>Note that minor revisions tend to be upward in the early part of a claim’s
life, and downward in the latter part.
</p>
<p>The revision multipliers are subject to further constraints to ensure that
the revised incurred estimate never falls below what has already been paid.
This is dicussed in <code><a href="#topic+claim_history">claim_history</a></code>.
</p>
<p><strong>Important note:</strong> Unlike the major revision multipliers which apply to the
<strong>incurred loss estimates</strong>, the minor revision multipliers apply to the case
estimate of <strong>outstanding claim payments</strong> i.e. a revision multiplier of 2.54
means that at the time of the minor revision the outstanding claims payment
increases by a factor of 2.54.
</p>


<h3>See Also</h3>

<p><code><a href="SynthETIC.html#topic+claims">claims</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
test_claims &lt;- SynthETIC::test_claims_object

# generate major revisions (required for the simulation of minor revisions)
major &lt;- claim_majRev_freq(test_claims)
major &lt;- claim_majRev_time(test_claims, major)
major &lt;- claim_majRev_size(major)

# generate frequency of minor revisions
minor &lt;- claim_minRev_freq(test_claims)
minor[[1]][[1]] # the "unit list" for the first claim

# update the timing information
minor &lt;- claim_minRev_time(test_claims, minor)
# observe how this has changed
minor[[1]][[1]]
# with an alternative sampling distribution e.g. triangular
minRev_time_notatP &lt;- function(n, setldel) {
  sort(rtri(n, min = setldel/6, max = setldel, mode = setldel))
}
minor_2 &lt;- claim_minRev_time(test_claims, minor, minRev_time_notatP)

# update the revision multipliers (need to generate "major" first)
minor &lt;- claim_minRev_size(test_claims, major, minor)
</code></pre>

<hr>
<h2 id='generate_data'>Generate Data of Varying Complexity</h2><span id='topic+generate_data'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> <br /> <br />
Generates datasets under 5 scenarios of different levels of complexity (here
&quot;complexity&quot; means the level of difficulty of analysis).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data(
  n_claims_per_period,
  n_periods = 40,
  complexity = c(1:5),
  data_type = c("claims", "payments", "incurred"),
  random_seed = NULL,
  verbose = TRUE,
  covariates_obj = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_data_+3A_n_claims_per_period">n_claims_per_period</code></td>
<td>
<p><strong>expected</strong> number of claims per period (equals
the total expected number of claims divided by <code>n_periods</code>).</p>
</td></tr>
<tr><td><code id="generate_data_+3A_n_periods">n_periods</code></td>
<td>
<p>number of accident periods considered (equals number of
claims development periods considered); default 40.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_complexity">complexity</code></td>
<td>
<p>integer from 1 (simplest) to 5 (most complex); see Details.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_data_type">data_type</code></td>
<td>
<p>a character vector specifying output data types. By default
the function will output all 3 datasets (claims, payments, incurred), but the
user may choose to output only a subset.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_random_seed">random_seed</code></td>
<td>
<p>optional seed for random number generation for
reproducibility.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code> print a message about the data generated.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_covariates_obj">covariates_obj</code></td>
<td>
<p>a SynthETIC <code><a href="SynthETIC.html#topic+covariates">covariates</a></code> object (requires <code style="white-space: pre;">&#8288;SynthETIC &gt;= 1.1.0&#8288;</code>). Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>generate_data()</code> produces datasets of varying levels of complexity,
where 1 represents the simplest, and 5 represents the most complex:
</p>

<ul>
<li><p> 1 – simple, homogeneous claims experience, with zero inflation.
</p>
</li>
<li><p> 2 – slightly more complex than 1, with dependence of notification delay and
settlement delay on claim size, and 2% p.a. base inflation.
</p>
</li>
<li><p> 3 – steady increase in claim processing speed over occurrence periods (i.e.
steady decline in settlement delays).
</p>
</li>
<li><p> 4 – inflation shock at time 30 (from 0% to 10% p.a.).
</p>
</li>
<li><p> 5 – default distributional models, with complex dependence structures (e.g.
dependence of settlement delay on claim occurrence period).
</p>
</li></ul>

<p>We remark that this by no means defines the limits of the complexity that can
be generated with <code>SPLICE</code>. This function is provided for the convenience of
users who wish to generate (a collection of) datasets under some
representative scenarios. If more complex features are required, the user is
free to modify the distributional assumptions (which, of course, requires
more thoughts and coding) to achieve their purposes.
</p>


<h3>Value</h3>

<p>A named list of dataframes:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>claim_dataset</code> </td><td style="text-align: left;"> A dataset of claim records that takes the same structure
as <code><a href="SynthETIC.html#topic+test_claim_dataset">test_claim_dataset</a></code>, with each row representing a
unique claim. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>payment_dataset</code> </td><td style="text-align: left;"> A dataset of partial payment records that takes the
same structure as <code><a href="SynthETIC.html#topic+test_transaction_dataset">test_transaction_dataset</a></code>, with
each row representing a unique payment. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>incurred_dataset</code> </td><td style="text-align: left;"> A dataset of transaction records that tracks how the
case estimates change over time. Takes the same structure as
<code><a href="#topic+test_incurred_dataset">test_incurred_dataset</a></code>, with each row representing a transaction
(any of claim notification, settlement, a payment, or a case estimate
revision). </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>covariates_data</code> </td><td style="text-align: left;"> Only if <code>covariates_obj</code> is not NULL, in which case
it will return a SynthETIC <code><a href="SynthETIC.html#topic+covariates_data">covariates_data</a></code> object.
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="SynthETIC.html#topic+generate_claim_dataset">generate_claim_dataset</a></code>,
<code><a href="SynthETIC.html#topic+generate_transaction_dataset">generate_transaction_dataset</a></code>,
<code><a href="#topic+generate_incurred_dataset">generate_incurred_dataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate datasets of full complexity
result &lt;- generate_data(
  n_claims_per_period = 50, data_type = c('claims', 'payments'),
  complexity = 5, random_seed = 42)

# Save individual datasets
claims &lt;- result$claim_dataset
payments &lt;- result$payment_dataset

# Generate chain-ladder compatible dataset
CL_simple &lt;- generate_data(
  n_claims_per_period = 50, data_type = 'claims', complexity = 1, random_seed = 42)

# To mute message output
CL_simple_2 &lt;- generate_data(
  n_claims_per_period = 50, data_type = 'claims', verbose = FALSE, random_seed = 42)

# Ouput is reproducible with the same random_seed value
all.equal(CL_simple$claim_dataset, CL_simple_2$claim_dataset)

</code></pre>

<hr>
<h2 id='generate_incurred_dataset'>Generate Incurred Dataset</h2><span id='topic+generate_incurred_dataset'></span>

<h3>Description</h3>

<p>Generates a dataset of transaction records that tracks how the case estimates
of the total incurred, the outstanding claim payments, and the cumulative
claims paid change over time. A sample dataset is included as part of the
package, see <code><a href="#topic+test_incurred_dataset">test_incurred_dataset</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_incurred_dataset(claims, incurred_history)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_incurred_dataset_+3A_claims">claims</code></td>
<td>
<p>an <code>claims</code> object containing all the simulated quantities,
(other than those related to incurred loss), see
<code><a href="SynthETIC.html#topic+claims">claims</a></code>.</p>
</td></tr>
<tr><td><code id="generate_incurred_dataset_+3A_incurred_history">incurred_history</code></td>
<td>
<p>the full history of incurred case estimates, see
<code><a href="#topic+claim_history">claim_history</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe that takes the same structure as
<code><a href="#topic+test_incurred_dataset">test_incurred_dataset</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test_incurred_dataset">test_incurred_dataset</a></code>
</p>

<hr>
<h2 id='output_incurred'>Incurred Triangles</h2><span id='topic+output_incurred'></span>

<h3>Description</h3>

<p>Outputs the full square of claims incurred by occurrence period and
development period. The upper left triangle represents the past, and the
lower right triangle the unseen future. <br /> <br />
Users can modify the aggregate level by providing an <code>aggregate_level</code>
argument to the function. For example, setting <code>aggregate_level = 4</code> when
working with calendar <em>quarters</em> produces an incurred square by occurrence
and development <em>year</em>. <br /> <br />
We refer to the package vignette for examples on changing the aggregation
granularity:
<code>vignette("SPLICE-demo", package = "SPLICE")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_incurred(
  incurred_history,
  aggregate_level = 1,
  incremental = TRUE,
  future = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output_incurred_+3A_incurred_history">incurred_history</code></td>
<td>
<p>the full history of incurred case estimates, see
<code><a href="#topic+claim_history">claim_history</a></code>.</p>
</td></tr>
<tr><td><code id="output_incurred_+3A_aggregate_level">aggregate_level</code></td>
<td>
<p>number of periods to be aggregated together; must be
a divisor of the total number of periods under consideration (default 1).</p>
</td></tr>
<tr><td><code id="output_incurred_+3A_incremental">incremental</code></td>
<td>
<p>logical; if true returns the incremental incurred square,
else returns the cumulative incurred square.</p>
</td></tr>
<tr><td><code id="output_incurred_+3A_future">future</code></td>
<td>
<p>logical; if true (default) shows the full claim triangle (i.e.
including claim payments in future periods), else shows only the past
triangle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Remark on out-of-bound transaction times</strong>: This function includes
adjustment for out-of-bound transaction dates, by forcing any transactions
that were projected to fall out of the maximum development period to be
counted as if they were made at the end of the limiting development period.
For example, if we consider 40 periods of development and a claim of the 21st
occurrence period was projected to have a major revision at time 62.498210,
then we would treat such a revision as if it occurred at time 60 for the
purpose of tabulation.
</p>


<h3>Value</h3>

<p>An array of claims incurred to date.
</p>

<hr>
<h2 id='test_incurred_dataset'>Incurred Case Estimates Dataset</h2><span id='topic+test_incurred_dataset'></span><span id='topic+test_incurred_dataset_noInf'></span><span id='topic+test_incurred_dataset_inflated'></span>

<h3>Description</h3>

<p>A dataset of 31,250 records of transactions (partial payments and incurred
revisions) associated with the 3,624 claims described in <code>SynthETIC</code>'s
<code><a href="SynthETIC.html#topic+test_claim_dataset">test_claim_dataset</a></code>. The <code style="white-space: pre;">&#8288;_inflated&#8288;</code> version includes
inflation adjustment in the case estimates, while the <code style="white-space: pre;">&#8288;_noInf&#8288;</code> version
excludes any inflation effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_incurred_dataset_noInf

test_incurred_dataset_inflated
</code></pre>


<h3>Format</h3>

<p>A data frame with 31,250 rows and 9 variables:
</p>

<dl>
<dt>claim_no</dt><dd><p>claim number, which uniquely characterises each claim.</p>
</dd>
<dt>claim_size</dt><dd><p>size of the claim (in constant dollar values).</p>
</dd>
<dt>txn_time</dt><dd><p>double; the &quot;absolute&quot; time of transaction (on a continuous
time scale).</p>
</dd>
<dt>txn_delay</dt><dd><p>delay from notification to the subject transaction.</p>
</dd>
<dt>txn_type</dt><dd><p>character; nature of the transactions, &quot;Ma&quot; for major
revision, &quot;Mi&quot; for minor revision, &quot;P&quot; for payment,
&quot;PMa&quot; for major revision coincident with a payment,
&quot;PMi&quot; for minor revision coincident with a payment.</p>
</dd>
<dt>incurred</dt><dd><p>double; case estimate of total incurred loss immediately
<strong>after</strong> the transaction.</p>
</dd>
<dt>OCL</dt><dd><p>double; case estimate of outstanding claim payments immediately
<strong>after</strong> the transaction.</p>
</dd>
<dt>cumpaid</dt><dd><p>double; cumulative claim paid <strong>after</strong> the transaction.</p>
</dd>
<dt>multiplier</dt><dd><p>revision multipliers (subject to further constraints
documented in <code><a href="#topic+claim_history">claim_history</a></code>), <code>NA</code> for
transactions that do not involve a revision. Note that
major revision multipliers apply to the incurred losses,
while minor revision multipliers apply to the outstanding
claim payments.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+generate_incurred_dataset">generate_incurred_dataset</a></code>
</p>

<hr>
<h2 id='triangular'>The Triangular Distribution</h2><span id='topic+triangular'></span><span id='topic+ptri'></span><span id='topic+dtri'></span><span id='topic+qtri'></span><span id='topic+rtri'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for
the triangular distribution with parameters <code>min</code>, <code>max</code> and <code>mode</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptri(q, min, max, mode)

dtri(x, min, max, mode)

qtri(p, min, max, mode)

rtri(n, min, max, mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangular_+3A_min">min</code></td>
<td>
<p>vector of minimum values.</p>
</td></tr>
<tr><td><code id="triangular_+3A_max">max</code></td>
<td>
<p>vector of maximum values.</p>
</td></tr>
<tr><td><code id="triangular_+3A_mode">mode</code></td>
<td>
<p>vector of modes.</p>
</td></tr>
<tr><td><code id="triangular_+3A_x">x</code>, <code id="triangular_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="triangular_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="triangular_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to
be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The triangular distribution with parameters <code>min</code><code class="reqn">= a</code>, <code>max</code>
<code class="reqn">= b</code>, <code>mode</code><code class="reqn">= c</code> has density:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">f(x) =</code>
</td><td style="text-align: left;"> <code class="reqn">\frac{2(x-a)}{(b-a)(c-a)}</code> </td><td style="text-align: left;"> for <code class="reqn">a &lt; x \le c</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code class="reqn">\frac{2(b-x)}{(b-a)(b-c)}</code> </td><td style="text-align: left;"> for <code class="reqn">c &lt; x \le b</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code class="reqn">0</code> </td><td style="text-align: left;"> otherwise
</td>
</tr>

</table>
<p> and distribution function:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">F(x) =</code>
</td><td style="text-align: left;"> <code class="reqn">0</code> </td><td style="text-align: left;"> for <code class="reqn">x \le a</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code class="reqn">\frac{(x-a)^2}{(b-a)(c-a)}</code> </td><td style="text-align: left;"> for <code class="reqn">a &lt; x \le c</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code class="reqn">1 - \frac{(b-x)^2}{(b-a)(b-c)}</code> </td><td style="text-align: left;"> for <code class="reqn">c &lt; x \le b</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code class="reqn">1</code> </td><td style="text-align: left;"> for <code class="reqn">x &gt; b</code>
</td>
</tr>

</table>

<p>for <code class="reqn">a \le c \le b</code>.
</p>


<h3>Value</h3>

<p><code>dtri</code> gives the density, <code>ptri</code> gives the distribution function,
<code>qtri</code> gives the quantile function, and <code>rtri</code> generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ptri(c(0, 1/2, 1), min = 0, max = 1, mode = 1/2)
dtri(c(0, 1/2, 1), min = 0, max = 1, mode = 1/2)
plot(function(x) dtri(x, min = 0, max = 1, mode = 1/2), 0, 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
