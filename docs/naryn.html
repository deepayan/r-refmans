<!DOCTYPE html><html><head><title>Help for package naryn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {naryn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#naryn-package'><p>Toolkit for medical records data analysis</p></a></li>
<li><a href='#.create_logical_track_filter'><p>Create a filter for logical track</p></a></li>
<li><a href='#.emr_expr_vars'><p>Get a vector of variables inside an expression</p></a></li>
<li><a href='#.emr_filter'><p>Parse an R filter string</p></a></li>
<li><a href='#.emr_vtrack.get'><p>Get virtual track parameters given a string</p></a></li>
<li><a href='#.naryn'><p>An environment for storing the package global variables</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#emr_annotate'><p>Annotates id-time points table</p></a></li>
<li><a href='#emr_cor'><p>Calculates correlation statistics for pairs of track expressions</p></a></li>
<li><a href='#emr_date2time'><p>Converts date and hour to internal time format</p></a></li>
<li><a href='#emr_db.connect'><p>Initializes connection with Naryn Database</p></a></li>
<li><a href='#emr_db.reload'><p>Reloads database</p></a></li>
<li><a href='#emr_db.subset'><p>Defines an ids subset</p></a></li>
<li><a href='#emr_db.subset.ids'><p>Returns the ids that constitute the current ids subset</p></a></li>
<li><a href='#emr_db.subset.info'><p>Returns information about the current subset</p></a></li>
<li><a href='#emr_db.unload'><p>Unload all tracks from naryn database</p></a></li>
<li><a href='#emr_dist'><p>Calculates distribution of track expressions</p></a></li>
<li><a href='#emr_download_example_data'><p>Download example database</p></a></li>
<li><a href='#emr_entries.get'><p>Get an entry</p></a></li>
<li><a href='#emr_entries.get_all'><p>Get all entries</p></a></li>
<li><a href='#emr_entries.ls'><p>List entries</p></a></li>
<li><a href='#emr_entries.reload'><p>Reload entries from disk</p></a></li>
<li><a href='#emr_entries.rm'><p>Remove an entry</p></a></li>
<li><a href='#emr_entries.rm_all'><p>Remove all entries</p></a></li>
<li><a href='#emr_entries.set'><p>Set an entry</p></a></li>
<li><a href='#emr_extract'><p>Returns evaluated track expression</p></a></li>
<li><a href='#emr_filter.attr.src'><p>Get or set attributes of a named filter</p></a></li>
<li><a href='#emr_filter.clear'><p>Clear all filters from the current environment</p></a></li>
<li><a href='#emr_filter.create'><p>Creates a new named filter</p></a></li>
<li><a href='#emr_filter.create_from_name'><p>Create a filter from an automatically generated name</p></a></li>
<li><a href='#emr_filter.exists'><p>Checks whether the named filter exists</p></a></li>
<li><a href='#emr_filter.info'><p>Returns the definition of a named filter</p></a></li>
<li><a href='#emr_filter.ls'><p>Returns a list of named filters</p></a></li>
<li><a href='#emr_filter.name'><p>Generate a default name for a naryn filter</p></a></li>
<li><a href='#emr_filter.rm'><p>Deletes a named filter</p></a></li>
<li><a href='#emr_filters.info'><p>Returns the filter definition of named filters given a filter expression</p></a></li>
<li><a href='#emr_ids_coverage'><p>Returns ids coverage per track</p></a></li>
<li><a href='#emr_ids_vals_coverage'><p>Returns ids coverage per value track</p></a></li>
<li><a href='#emr_monthly_iterator'><p>Create an iterator that goes every year/month</p></a></li>
<li><a href='#emr_quantiles'><p>Calculates quantiles of a track expression</p></a></li>
<li><a href='#emr_screen'><p>Finds Id-Time points that match track expression</p></a></li>
<li><a href='#emr_summary'><p>Calculates summary statistics of track expression</p></a></li>
<li><a href='#emr_time'><p>Convert time periods to internal time format</p></a></li>
<li><a href='#emr_time2date'><p>Convert from internal time to year, month, day, hour</p></a></li>
<li><a href='#emr_time2dayofmonth'><p>Converts time from internal format to a day of month</p></a></li>
<li><a href='#emr_time2hour'><p>Converts time from internal format to an hour</p></a></li>
<li><a href='#emr_time2month'><p>Converts time from internal format to a month</p></a></li>
<li><a href='#emr_time2year'><p>Converts time from internal format to a year</p></a></li>
<li><a href='#emr_track.addto'><p>Adds new records to a track</p></a></li>
<li><a href='#emr_track.attr.export'><p>Returns attributes values of tracks</p></a></li>
<li><a href='#emr_track.attr.get'><p>Returns the value of the track attribute</p></a></li>
<li><a href='#emr_track.attr.rm'><p>Deletes a track attribute</p></a></li>
<li><a href='#emr_track.attr.set'><p>Assigns a value to the track attribute</p></a></li>
<li><a href='#emr_track.create'><p>Creates a track from a track expression</p></a></li>
<li><a href='#emr_track.dbs'><p>Returns a vector of db ids which have a</p>
version of the track</a></li>
<li><a href='#emr_track.exists'><p>Checks whether the track exists</p></a></li>
<li><a href='#emr_track.ids'><p>Returns track ids</p></a></li>
<li><a href='#emr_track.import'><p>Imports a track from a file or data-frame</p></a></li>
<li><a href='#emr_track.info'><p>Returns information about the track.</p></a></li>
<li><a href='#emr_track.logical.create'><p>Creates a logical track</p></a></li>
<li><a href='#emr_track.logical.exists'><p>Is a track logical</p></a></li>
<li><a href='#emr_track.logical.info'><p>Returns information about a logical track</p></a></li>
<li><a href='#emr_track.logical.rm'><p>Deletes a logical track</p></a></li>
<li><a href='#emr_track.ls'><p>Returns a list of track names</p></a></li>
<li><a href='#emr_track.mv'><p>Moves (renames) a track</p></a></li>
<li><a href='#emr_track.percentile'><p>Returns track percentile of the values</p></a></li>
<li><a href='#emr_track.readonly'><p>Gets or sets &quot;read-only&quot; property of a track</p></a></li>
<li><a href='#emr_track.rm'><p>Deletes a track</p></a></li>
<li><a href='#emr_track.unique'><p>Returns track values</p></a></li>
<li><a href='#emr_track.var.get'><p>Returns value of a track variable</p></a></li>
<li><a href='#emr_track.var.ls'><p>Returns a list of track variables for a track</p></a></li>
<li><a href='#emr_track.var.rm'><p>Deletes a track variable</p></a></li>
<li><a href='#emr_track.var.set'><p>Assigns value to a track variable</p></a></li>
<li><a href='#emr_vtrack.attr.src'><p>Get or set attributes of a virtual track</p></a></li>
<li><a href='#emr_vtrack.clear'><p>Clear all virtual tracks from the current environment</p></a></li>
<li><a href='#emr_vtrack.create'><p>Creates a new virtual track</p></a></li>
<li><a href='#emr_vtrack.create_from_name'><p>Create a virtual track from an automatically generated name</p></a></li>
<li><a href='#emr_vtrack.exists'><p>Checks whether the virtual track exists</p></a></li>
<li><a href='#emr_vtrack.info'><p>Returns the definition of a virtual track</p></a></li>
<li><a href='#emr_vtrack.ls'><p>Returns a list of virtual track names</p></a></li>
<li><a href='#emr_vtrack.name'><p>Generate a default name for a virtual track</p></a></li>
<li><a href='#emr_vtrack.rm'><p>Deletes a virtual track</p></a></li>
<li><a href='#string_to_var'><p>Create a syntactically valid variable name from a string</p></a></li>
<li><a href='#var_to_string'><p>Decode a variable created by string_to_var</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Native Access Medical Record Retriever for High Yield Analytics</td>
</tr>
<tr>
<td>Version:</td>
<td>2.6.26</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit for medical records data analysis. The 'naryn'
    package implements an efficient data structure for storing medical
    records, and provides a set of functions for data extraction,
    manipulation and analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tanaylab.github.io/naryn/">https://tanaylab.github.io/naryn/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tanaylab/naryn/issues">https://github.com/tanaylab/naryn/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), utils</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, glue, lifecycle, magrittr, parallel, purrr, stringr,
tidyr, yaml</td>
</tr>
<tr>
<td>Suggests:</td>
<td>brio, callr, devtools, forcats, knitr, readr, rlang,
rmarkdown, spelling, testthat (&ge; 3.0.4), tibble, tools, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>logical_tracks, w_test-options,
x_multiple_db</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>OS_type:</td>
<td>unix</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-14 19:09:26 UTC; aviezerl</td>
</tr>
<tr>
<td>Author:</td>
<td>Misha Hoichman [aut],
  Aviezer Lifshitz [aut, cre],
  Ben Gilat [aut],
  Netta Mendelson-Cohen [ctb],
  Rami Jaschek [ctb],
  Weizmann Institute of Science [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aviezer Lifshitz &lt;aviezer.lifshitz@weizmann.ac.il&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-15 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='naryn-package'>Toolkit for medical records data analysis</h2><span id='topic+naryn-package'></span><span id='topic+naryn'></span>

<h3>Description</h3>

<p>'naryn' package is intended to help users to efficiently analyze data in
time-patient space.
</p>


<h3>Details</h3>

<p>For a complete list of help resources, use <code>library(help = "naryn")</code>.
</p>
<p>More information about the options can be found in 'User manual' of the
package.
</p>

<hr>
<h2 id='.create_logical_track_filter'>Create a filter for logical track</h2><span id='topic+.create_logical_track_filter'></span>

<h3>Description</h3>

<p>This function is mostly for internal use. Please create a filter using <code><a href="#topic+emr_filter.create">emr_filter.create</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.create_logical_track_filter(
  ltrack,
  filter = NULL,
  filter_name = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".create_logical_track_filter_+3A_ltrack">ltrack</code></td>
<td>
<p>name of logical track</p>
</td></tr>
<tr><td><code id=".create_logical_track_filter_+3A_filter">filter</code></td>
<td>
<p>existing filter (the new filter would be added)</p>
</td></tr>
<tr><td><code id=".create_logical_track_filter_+3A_filter_name">filter_name</code></td>
<td>
<p>name for the new filter (optional)</p>
</td></tr>
<tr><td><code id=".create_logical_track_filter_+3A_env">env</code></td>
<td>
<p>environment for the new filter (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string with the logical track filter (i.e. filter for the values of the original track), added (with '&amp;' operator) to the original filter (if exists).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.create_logical_track_filter("logical_track")

</code></pre>

<hr>
<h2 id='.emr_expr_vars'>Get a vector of variables inside an expression</h2><span id='topic+.emr_expr_vars'></span>

<h3>Description</h3>

<p>Get a vector of variables inside an expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.emr_expr_vars(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".emr_expr_vars_+3A_expr">expr</code></td>
<td>
<p>string with a naryn expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of the variables inside an expression
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.emr_expr_vars("a + b")

</code></pre>

<hr>
<h2 id='.emr_filter'>Parse an R filter string</h2><span id='topic+.emr_filter'></span>

<h3>Description</h3>

<p>This is used internally in the CPP code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.emr_filter(filter)
</code></pre>


<h3>Value</h3>

<p>the parsed R filter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.emr_filter("f &gt; 1")

</code></pre>

<hr>
<h2 id='.emr_vtrack.get'>Get virtual track parameters given a string</h2><span id='topic+.emr_vtrack.get'></span>

<h3>Description</h3>

<p>Get virtual track parameters given a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.emr_vtrack.get(vtrackstr, adjust_logical = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".emr_vtrack.get_+3A_vtrackstr">vtrackstr</code></td>
<td>
<p>name of the virtual track</p>
</td></tr>
<tr><td><code id=".emr_vtrack.get_+3A_adjust_logical">adjust_logical</code></td>
<td>
<p>when the source is logical track - adjust the parameters to imitate a physical track</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the parameters of the virtual track
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()

emr_vtrack.create("vtrack1", "dense_track",
    time.shift = 1,
    func = "max"
)
.emr_vtrack.get("vtrack1")

</code></pre>

<hr>
<h2 id='.naryn'>An environment for storing the package global variables</h2><span id='topic+.naryn'></span>

<h3>Description</h3>

<p>An environment for storing the package global variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.naryn
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 6.
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='emr_annotate'>Annotates id-time points table</h2><span id='topic+emr_annotate'></span>

<h3>Description</h3>

<p>Annotates id-time points table by the values given in the second table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_annotate(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_annotate_+3A_x">x</code></td>
<td>
<p>sorted id-time points table that is expanded</p>
</td></tr>
<tr><td><code id="emr_annotate_+3A_y">y</code></td>
<td>
<p>sorted id-time points table that is used for annotations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function merges two sorted id-time points tables 'x' and 'y' by
matching 'id', 'time' and 'ref' columns. The result is a new id-time points
table that has all the additional columns of 'x' and 'y'.
</p>
<p>Two rows match if 'id' AND 'time' match AND either 'ref' matches OR one of
the 'ref' is '-1'.
</p>
<p>If a row RX from 'x' matches N rows RY1, ..., RYn from 'y', N rows are added
to the result: [RX RY1], ..., [RX RYn].
</p>
<p>If a row RX from 'x' does not match any rows from 'y', a row of [RX NA] form
is added to the result (i.e. all the values of columns borrowed from 'y' are
set to 'NA').
</p>
<p>A missing 'ref' column is interpreted as if reference equals '-1'.
</p>
<p>Both of 'x' and 'y' must be sorted by 'id', 'time' and 'ref' (in this
order!). Note however that all the package functions (such as 'emr_extract',
...) return id-time point tables always properly sorted.
</p>


<h3>Value</h3>

<p>A data frame with all the columns from 'x' and additional columns
from 'y'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_extract">emr_extract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()

r1 &lt;- emr_extract("sparse_track", keepref = TRUE)
r2 &lt;- emr_extract("dense_track", keepref = TRUE)
r2$dense_track &lt;- r2$dense_track + 1000
emr_annotate(r1, r2)
</code></pre>

<hr>
<h2 id='emr_cor'>Calculates correlation statistics for pairs of track expressions</h2><span id='topic+emr_cor'></span>

<h3>Description</h3>

<p>Calculates correlation statistics for pairs of track expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_cor(
  ...,
  cor.exprs = NULL,
  include.lowest = FALSE,
  right = TRUE,
  stime = NULL,
  etime = NULL,
  iterator = NULL,
  keepref = FALSE,
  filter = NULL,
  dataframe = FALSE,
  names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_cor_+3A_...">...</code></td>
<td>
<p>pairs of [factor.expr, breaks], where <code>factor.expr</code> is the  track expression and breaks are the breaks that determine the bin or 'NULL'.</p>
</td></tr>
<tr><td><code id="emr_cor_+3A_cor.exprs">cor.exprs</code></td>
<td>
<p>vector of track expressions for which correlation
statistics is calculated.</p>
</td></tr>
<tr><td><code id="emr_cor_+3A_include.lowest">include.lowest</code></td>
<td>
<p>if 'TRUE', the lowest (or highest, for 'right = FALSE') value of the range determined by breaks is included.</p>
</td></tr>
<tr><td><code id="emr_cor_+3A_right">right</code></td>
<td>
<p>if 'TRUE' the intervals are closed on the right (and open on
the left), otherwise vice versa.</p>
</td></tr>
<tr><td><code id="emr_cor_+3A_stime">stime</code></td>
<td>
<p>start time scope.</p>
</td></tr>
<tr><td><code id="emr_cor_+3A_etime">etime</code></td>
<td>
<p>end time scope.</p>
</td></tr>
<tr><td><code id="emr_cor_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions. See also 'iterator' section.</p>
</td></tr>
<tr><td><code id="emr_cor_+3A_keepref">keepref</code></td>
<td>
<p>If 'TRUE' references are preserved in the iterator.</p>
</td></tr>
<tr><td><code id="emr_cor_+3A_filter">filter</code></td>
<td>
<p>Iterator filter.</p>
</td></tr>
<tr><td><code id="emr_cor_+3A_dataframe">dataframe</code></td>
<td>
<p>return a data frame instead of an N-dimensional vector.</p>
</td></tr>
<tr><td><code id="emr_cor_+3A_names">names</code></td>
<td>
<p>names for track expressions in the returned dataframe (only relevant when <code>dataframe == TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works in a similar manner to 'emr_dist'. However instead of
returning a single counter for each bin 'emr_cor' returns 5 matrices of
'length(cor.exprs) X length(cor.exprs)' size. Each matrix represents the
correlation statistics for each pair of track expressions from 'cor.exprs'.
Given a 'bin' and a pair of track expressions 'cor.exprs[i]' and
'cor.exprs[j]' the corresponding matrix contains the following information:
</p>
<p>$n[bin,i,j] - number of times when both 'cor.exprs[i]' and 'cor.exprs[j]'
exist $e[bin,i,j] - expectation (average) of values from 'cor.exprs[i]' when
'cor.exprs[j]' exists $var[bin,i,j] - variance of values from 'cor.exprs[i]'
when 'cor.exprs[j]' exists $cov[bin,i,j] - covariance of 'cor.exprs[i]' and
'cor.exprs[j]' $cor[bin,i,j] - correlation of 'cor.exprs[i]' and
'cor.exprs[j]'
</p>
<p>Similarly to 'emr_dist' 'emr_cor' can do multi-dimensional binning. Given N
dimensional binning the individual data in the matrices can be accessed as:
$cor[bin1, ..., binN, i, j].
</p>
<p>If <code>dataframe = TRUE</code> the return value is a data frame with a column for each track expression, additional columns i,j with pairs of <code>cor_exprs</code>
and another 5 columns: 'n', 'e', 'var', 'cov', 'cor' with the same values
as the matrices described above.
</p>


<h3>Value</h3>

<p>A list of 5 elements each containing a N-dimensional vector (N is
the number of 'expr'-'breaks' pairs). The member of each vector is a
specific statistics matrix. If <code>dataframe == TRUE</code> - a data frame with a column for each track expression, additional columns i,j with pairs of <code>cor_exprs</code> and another 5 columns: 'n', 'e', 'var', 'cov', 'cor', see description.
</p>


<h3>iterator</h3>

<p>There are a few types of iterators:
</p>

<dl>
<dt>Track iterator: </dt><dd><p>Track iterator returns the points (including the reference) from the specified track. Track name is specified as a string. If 'keepref=FALSE' the reference of each point is set to '-1' <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func=&quot;avg&quot;, time.shift=1) <br />
emr_extract(&quot;glucose&quot;, iterator=&quot;insulin_shot_track&quot;) <br />
</p>
</dd>
<dt>Id-Time Points Iterator: </dt><dd><p>Id-Time points iterator generates points from an *id-time points table*. If 'keepref=FALSE' the reference of each point is set to '-1'. <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func = &quot;avg&quot;, time.shift = 1) <br />
r &lt;- emr_extract(&quot;insulin_shot_track&quot;) # &lt;&ndash; implicit iterator is used here <br />
emr_extract(&quot;glucose&quot;, iterator = r) <br />
</p>
</dd>
<dt>Ids Iterator: </dt><dd><p>Ids iterator generates points with ids taken from an *ids table* and times that run from 'stime' to 'etime' with a step of 1. If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.<br />
Example: <br /> <br />
stime &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime &lt;- emr_date2time(31, 12, 2016, 23) <br />
emr_extract(&quot;glucose&quot;, iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime)<br />
</p>
</dd>
<dt>Time Intervals Iterator: </dt><dd><p>*Time intervals iterator* generates points for all the ids that appear in 'patients.dob' track with times taken from a *time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'. <br />
Example: <br />
# Returns the level of hangover for all patients the next day after New Year Eve for the years 2015 and 2016 <br />
stime1 &lt;- emr_date2time(1, 1, 2015, 0) <br />
etime1 &lt;- emr_date2time(1, 1, 2015, 23) <br />
stime2 &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime2 &lt;- emr_date2time(1, 1, 2016, 23) <br />
emr_extract(&quot;alcohol_level_track&quot;, iterator = data.frame( <br />
stime = c(stime1, stime2), <br />
etime = c(etime1, etime2) <br />
)) <br />
</p>
</dd>
<dt>Id-Time Intervals Iterator: </dt><dd><p>*Id-Time intervals iterator* generates for each id points that cover &lsquo;[&rsquo;stime', 'etime']' time range as specified in *id-time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'</p>
</dd>
<dt>Beat Iterator: </dt><dd><p>*Beat Iterator* generates a &quot;time beat&quot; at the given period for each id that appear in 'patients.dob' track. The period is given always in hours. <br />
Example: <br />
emr_extract(&quot;glucose_track&quot;, iterator=10, stime=1000, etime=2000) <br />
This will create a beat iterator with a period of 10 hours starting at 'stime' up until 'etime' is reached. If, for example, 'stime' equals '1000' then the beat iterator will create for each id iterator points at times: 1000, 1010, 1020, ... <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.
</p>
</dd>
<dt>Extended Beat Iterator: </dt><dd><p>*Extended beat iterator* is as its name suggests a variation on the beat iterator. It works by the same principle of creating time points with the given period however instead of basing the times count on 'stime' it accepts an additional parameter - a track or a *Id-Time Points table* - that instructs what should be the initial time point for each of the ids. The two parameters (period and mapping) should come in a list. Each id is required to appear only once and if a certain id does not appear at all, it is skipped by the iterator. <br />
Anyhow points that lie outside of '[stime, etime]' range are not generated. <br />
Example: <br />
# Returns the maximal weight of patients at one year span starting from their birthdays <br />
emr_vtrack.create(&quot;weight&quot;, &quot;weight_track&quot;, func = &quot;max&quot;, time.shift = c(0, year())) <br />
emr_extract(&quot;weight&quot;, iterator = list(year(), &quot;birthday_track&quot;), stime = 1000, etime = 2000) <br />
</p>
</dd>
<dt>Periodic Iterator: </dt><dd><p>periodic iterator goes over every year/month. You can use it by running  <code>emr_monthly_iterator</code> or <code>emr_yearly_iterator</code>. <br />
Example: <br />
iter &lt;- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017)) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
iter &lt;- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
</p>
</dd>
<dt>Implicit Iterator: </dt><dd><p>The iterator is set implicitly if its value remains 'NULL' (which is the default). In that case the track expression is analyzed and searched for track names. If all the track variables or virtual track variables point to the same track, this track is used as a source for a track iterator. If more then one track appears in the track expression, an error message is printed out notifying ambiguity.</p>
</dd>
</dl>

<p>Revealing Current Iterator Time:
During the evaluation of a track expression one can access a specially defined variable named 'EMR_TIME' (Python: 'TIME'). This variable contains a vector ('numpy.ndarray' in Python) of current iterator times. The length of the vector matches the length of the track variable (which is a vector too). <br />
Note that some values in 'EMR_TIME' might be set 0. Skip those intervals and the values of the track variables at the corresponding indices. <br />
# Returns times of the current iterator as a day of month <br />
emr_extract(&quot;emr_time2dayofmonth(EMR_TIME)&quot;, iterator = &quot;sparse_track&quot;) <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_dist">emr_dist</a></code>, <code><a href="base.html#topic+cut">cut</a></code>,
<code><a href="#topic+emr_track.unique">emr_track.unique</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_cor("categorical_track", c(0, 2, 5),
    cor.exprs = c("sparse_track", "1/dense_track"),
    include.lowest = TRUE, iterator = "categorical_track",
    keepref = TRUE
)
emr_cor("categorical_track", c(0, 2, 5),
    cor.exprs = c("sparse_track", "1/dense_track"),
    include.lowest = TRUE, iterator = "categorical_track",
    keepref = TRUE,
    dataframe = TRUE
)
</code></pre>

<hr>
<h2 id='emr_date2time'>Converts date and hour to internal time format</h2><span id='topic+emr_date2time'></span>

<h3>Description</h3>

<p>Converts date and hour to internal time format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_date2time(day, month, year, hour = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_date2time_+3A_day">day</code></td>
<td>
<p>vector of days of month in [1, 31] range</p>
</td></tr>
<tr><td><code id="emr_date2time_+3A_month">month</code></td>
<td>
<p>vector of months in [1, 12] range</p>
</td></tr>
<tr><td><code id="emr_date2time_+3A_year">year</code></td>
<td>
<p>vector of years</p>
</td></tr>
<tr><td><code id="emr_date2time_+3A_hour">hour</code></td>
<td>
<p>vector of hours in [0, 23] range</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts date and hour to internal time format. Note: the
earliest valid time is 1 March 1867.
</p>
<p>Note: if one of the arguments ('day', ...) is a vector, then the other
arguments must be vectors two of identical size or scalars. Internally a
data frame is built out of all the vectors or scalars before the conversion
is applied. Hence rules for data frame creation apply to this function.
</p>


<h3>Value</h3>

<p>Vector of converted times.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_time2hour">emr_time2hour</a></code>, <code><a href="#topic+emr_time2dayofmonth">emr_time2dayofmonth</a></code>,
<code><a href="#topic+emr_time2month">emr_time2month</a></code>, <code><a href="#topic+emr_time2year">emr_time2year</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()

# 30 January, 1938, 6:00 - birthday of Islam Karimov
t &lt;- emr_date2time(30, 1, 1938, 6)
emr_time2hour(t)
emr_time2dayofmonth(t)
emr_time2month(t)
emr_time2year(t)

# cover all times when Islam Karimov could have been born
# (if we don't know the exact hour!)
t &lt;- emr_date2time(30, 1, 1938, 0:23)
</code></pre>

<hr>
<h2 id='emr_db.connect'>Initializes connection with Naryn Database</h2><span id='topic+emr_db.connect'></span><span id='topic+emr_db.init_examples'></span><span id='topic+emr_db.init'></span><span id='topic+emr_db.ls'></span>

<h3>Description</h3>

<p>Initializes connection with Naryn Database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_db.connect(db_dirs = NULL, load_on_demand = NULL, do_reload = FALSE)

emr_db.init(
  global.dir = NULL,
  user.dir = NULL,
  global.load.on.demand = TRUE,
  user.load.on.demand = TRUE,
  do.reload = FALSE
)

emr_db.ls()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_db.connect_+3A_db_dirs">db_dirs</code></td>
<td>
<p>vector of db directories</p>
</td></tr>
<tr><td><code id="emr_db.connect_+3A_load_on_demand">load_on_demand</code></td>
<td>
<p>vector of booleans, same length as db_dirs, if load_on_demand[i] is FALSE, tracks from db_dirs[i] will be pre-loaded, or a single 'TRUE' or 'FALSE' to set <code>load_on_demand</code> for all the databases. If NULL is passed, <code>load_on_demand</code> is set to TRUE on all the databases</p>
</td></tr>
<tr><td><code id="emr_db.connect_+3A_do_reload">do_reload</code></td>
<td>
<p>If <code>TRUE</code>, rebuilds DB index files.</p>
</td></tr>
<tr><td><code id="emr_db.connect_+3A_global.dir">global.dir</code>, <code id="emr_db.connect_+3A_user.dir">user.dir</code>, <code id="emr_db.connect_+3A_global.load.on.demand">global.load.on.demand</code>, <code id="emr_db.connect_+3A_user.load.on.demand">user.load.on.demand</code>, <code id="emr_db.connect_+3A_do.reload">do.reload</code></td>
<td>
<p>old parameters of the deprecated function <code>emr_db.init</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Call 'emr_db.connect' function to establish the access to the tracks in the db_dirs.
To establish a connection using 'emr_db.connect', Naryn requires to specify at-least
one db dir. Optionally, 'emr_db.connect' accepts additional db dirs which can also
contain additional tracks.
</p>
<p>In a case where 2 or more db dirs contain the same track name (namespace collision),
the  track will  be taken from the db dir which was passed *last* in  the order of
connections.
</p>
<p>For example, if we have 2 db dirs <code>/db1</code> and <code>/db2</code> which both contain
a track named <code>track1</code>, the call  <code>emr_db.connect(c('/db1', '/db2'))</code> will result with
Naryn  using <code>track1</code> from <code>/db2</code>. As you might expect the overriding is consistent not
only for the track's data, but also for any other Naryn entity using or pointing
to the track.
</p>
<p>Even though all the db dirs may contain track files, their designation is different.
All the db dirs except the last dir in the order of connections are mainly read-only.
The directory which was connected last in the order, also known as *user dir*, is
intended to store volatile data like the results of intermediate calculations.
</p>
<p>New tracks can be created only in  the db dir which was last in  the order of
connections, using <code>emr_track.import</code> or <code>emr_track.create</code>. In order to write tracks
to a db dir which is not last in the connection order, the user must explicitly
reconnect and set the required db dir as the last in order, this should be done for a
well justified reason.
</p>
<p>When the package is attached it internally calls 'emr_db.init_examples'
which sets a single example db dir - 'PKGDIR/naryndb/test'.
('PKGDIR' is the directory where the package is installed).
</p>
<p>Physical files in the database are supposed to be managed exclusively by
Naryn itself. Manual modification, addition or deletion of track files may
be done, yet it must be ratified via running 'emr_db.reload'. Some of these
manual changes however (like moving a track from global space to user or
vice versa) might cause 'emr_db.connect' to fail. 'emr_db.reload' cannot be
invoked then as it requires first the connection to the DB be established.
To break the deadlock use 'do_reload=True' parameter within 'emr_db.connect'.
This will connect to the DB and rebuild the DB index files in one step.
</p>
<p>If 'load_on_demand' is 'TRUE' a track is loaded into memory only when it is
accessed and it is unloaded from memory as R sessions ends or the package is
unloaded.
</p>
<p>If 'load_on_demand' parameter is 'FALSE', all the tracks from the specified
space (global / user) are pre-loaded into memory making subsequent track
access significantly faster. As loaded tracks reside in shared memory, other
R sessions running on the same machine, may also enjoy significant run-time
boost. On the flip side, pre-loading all the tracks prolongs the execution
of 'emr_db.connect' and requires enough memory to accommodate all the data.
</p>
<p>Choosing between the two modes depends on the specific needs. While
'load_on_demand=TRUE' seems to be a solid default choice, in an environment
where there are frequent short-living R sessions, each accessing a track one
might opt for running a &quot;daemon&quot; - an additional permanent R session. The
daemon would pre-load all the tracks in advance and stay alive thus boosting
the run-time of the later emerging sessions.
</p>
<p>Upon completion the connection is established with the database and a few
variables are added to the .naryn environment. These variables should not be
modified by the user!
</p>

<table>
<tr>
 <td style="text-align: left;">
.naryn$EMR_GROOT </td><td style="text-align: left;"> First db dir of tracks in the order of connections </td>
</tr>
<tr>
 <td style="text-align: left;">
.naryn$EMR_UROOT </td><td style="text-align: left;"> Last db dir of tracks in the order of connection (user dir) </td>
</tr>
<tr>
 <td style="text-align: left;">
.naryn$EMR_ROOTS </td><td style="text-align: left;"> Vector of directories (db_dirs) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>emr_db.init</code> is the old version of this function which
is now deprecated.
</p>
<p><code>emr_db.ls</code> lists all the currently connected databases.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_db.reload">emr_db.reload</a></code>, <code><a href="#topic+emr_track.import">emr_track.import</a></code>,
<code><a href="#topic+emr_track.create">emr_track.create</a></code>, <code><a href="#topic+emr_track.rm">emr_track.rm</a></code>,
<code><a href="#topic+emr_track.ls">emr_track.ls</a></code>, <code><a href="#topic+emr_vtrack.ls">emr_vtrack.ls</a></code>,
<code><a href="#topic+emr_filter.ls">emr_filter.ls</a></code>
</p>

<hr>
<h2 id='emr_db.reload'>Reloads database</h2><span id='topic+emr_db.reload'></span>

<h3>Description</h3>

<p>Reloads database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_db.reload()
</code></pre>


<h3>Details</h3>

<p>Rebuilds Naryn database index files. Use this function if you manually
add/delete/move/modify track files or if you suspect that the database is
corrupted: existing tracks cannot be found, deleted ones continue to appear
or a warning message is issued by Naryn itself recommending to run
'emr_db.reload'.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_db.connect">emr_db.connect</a></code>, <code><a href="#topic+emr_track.ls">emr_track.ls</a></code>,
<code><a href="#topic+emr_vtrack.ls">emr_vtrack.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.reload()

</code></pre>

<hr>
<h2 id='emr_db.subset'>Defines an ids subset</h2><span id='topic+emr_db.subset'></span>

<h3>Description</h3>

<p>Defines an ids subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_db.subset(src = "", fraction = NULL, complementary = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_db.subset_+3A_src">src</code></td>
<td>
<p>track name or ids table or 'NULL'</p>
</td></tr>
<tr><td><code id="emr_db.subset_+3A_fraction">fraction</code></td>
<td>
<p>fraction of data to be sampled from 'src' in [0,1] range</p>
</td></tr>
<tr><td><code id="emr_db.subset_+3A_complementary">complementary</code></td>
<td>
<p>'TRUE' for a complementary subset, otherwise 'FALSE'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'emr_db.subset' creates an ids subset&quot; (&quot;viewport&quot;) of data of &quot;fraction *
sizeof('src')&quot; size by sampling the ids from 'src'. Once the subset is
defined only the ids that are in the subset are used by various functions
and iterators. Other ids are ignored.
</p>
<p>'src' can be a track name or an ids table. If 'complementary' is 'TRUE' the
complementary set of sampled ids is used as a subset.
</p>
<p>If 'src' is 'NULL' the current subset is annihilated.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_db.connect">emr_db.connect</a></code>, <code><a href="#topic+emr_db.subset.ids">emr_db.subset.ids</a></code>,
<code><a href="#topic+emr_db.subset.info">emr_db.subset.info</a></code>
</p>

<hr>
<h2 id='emr_db.subset.ids'>Returns the ids that constitute the current ids subset</h2><span id='topic+emr_db.subset.ids'></span>

<h3>Description</h3>

<p>Returns the ids that constitute the current ids subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_db.subset.ids()
</code></pre>


<h3>Details</h3>

<p>'emr_db.subset.ids' returns the ids that constitute the current ids subset.
The ids are returned in &quot;ids table&quot; format.
</p>
<p>If no ids subset is defined, 'emr_db.subset.ids' returns 'NULL'.
</p>


<h3>Value</h3>

<p>Ids table or 'NULL'
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_db.subset">emr_db.subset</a></code>
</p>

<hr>
<h2 id='emr_db.subset.info'>Returns information about the current subset</h2><span id='topic+emr_db.subset.info'></span>

<h3>Description</h3>

<p>Returns information about the current subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_db.subset.info()
</code></pre>


<h3>Details</h3>

<p>'emr_db.subset.info' returns the parameters that were used to define the
current subset or 'NULL' if no subset has been defined.
</p>


<h3>Value</h3>

<p>Information about the current subset or 'NULL'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_db.subset">emr_db.subset</a></code>, <code><a href="#topic+emr_db.subset.ids">emr_db.subset.ids</a></code>
</p>

<hr>
<h2 id='emr_db.unload'>Unload all tracks from naryn database</h2><span id='topic+emr_db.unload'></span>

<h3>Description</h3>

<p>Unload all tracks from naryn database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_db.unload()
</code></pre>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.unload()


</code></pre>

<hr>
<h2 id='emr_dist'>Calculates distribution of track expressions</h2><span id='topic+emr_dist'></span>

<h3>Description</h3>

<p>Calculates distribution of track expressions' values over the given set of
bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_dist(
  ...,
  include.lowest = FALSE,
  right = TRUE,
  stime = NULL,
  etime = NULL,
  iterator = NULL,
  keepref = FALSE,
  filter = NULL,
  dataframe = FALSE,
  names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_dist_+3A_...">...</code></td>
<td>
<p>pairs of [expr, breaks], where <code>expr</code> is the  track expression and breaks are the breaks that determine the bin or 'NULL'.</p>
</td></tr>
<tr><td><code id="emr_dist_+3A_include.lowest">include.lowest</code></td>
<td>
<p>if 'TRUE', the lowest (or highest, for 'right = FALSE') value of the range determined by breaks is included</p>
</td></tr>
<tr><td><code id="emr_dist_+3A_right">right</code></td>
<td>
<p>if 'TRUE' the intervals are closed on the right (and open on
the left), otherwise vice versa.</p>
</td></tr>
<tr><td><code id="emr_dist_+3A_stime">stime</code></td>
<td>
<p>start time scope</p>
</td></tr>
<tr><td><code id="emr_dist_+3A_etime">etime</code></td>
<td>
<p>end time scope</p>
</td></tr>
<tr><td><code id="emr_dist_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions. See also 'iterator' section.</p>
</td></tr>
<tr><td><code id="emr_dist_+3A_keepref">keepref</code></td>
<td>
<p>If 'TRUE' references are preserved in the iterator.</p>
</td></tr>
<tr><td><code id="emr_dist_+3A_filter">filter</code></td>
<td>
<p>Iterator filter.</p>
</td></tr>
<tr><td><code id="emr_dist_+3A_dataframe">dataframe</code></td>
<td>
<p>return a data frame instead of an N-dimensional vector.</p>
</td></tr>
<tr><td><code id="emr_dist_+3A_names">names</code></td>
<td>
<p>names for track expressions in the returned dataframe (only relevant when <code>dataframe == TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the distribution of values of the numeric track
expressions over the given set of bins.
</p>
<p>The range of bins is determined by 'breaks' argument. For example:
'breaks=c(x1, x2, x3, x4)' represents three different intervals (bins): (x1,
x2], (x2, x3], (x3, x4].
</p>
<p>If the track expression constitutes of a categorical track or a virtual
track which source is a categorical track, the 'breaks' is allowed to be
'NULL' meaning that the breaks are derived implicitly from the unique values
of the underlying track.
</p>
<p>'emr_dist' can work with any number of dimensions. If more than one
'expr'-'breaks' pair is passed, the result is a multidimensional vector, and
an individual value can be accessed by [i1,i2,...,iN] notation, where 'i1'
is the first track and 'iN' is the last track expression.
</p>


<h3>Value</h3>

<p>N-dimensional vector where N is the number of 'expr'-'breaks' pairs. If <code>dataframe == TRUE</code> - a data frame with a column for each track expression and an additional column 'n' with counts.
</p>


<h3>iterator</h3>

<p>There are a few types of iterators:
</p>

<dl>
<dt>Track iterator: </dt><dd><p>Track iterator returns the points (including the reference) from the specified track. Track name is specified as a string. If 'keepref=FALSE' the reference of each point is set to '-1' <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func=&quot;avg&quot;, time.shift=1) <br />
emr_extract(&quot;glucose&quot;, iterator=&quot;insulin_shot_track&quot;) <br />
</p>
</dd>
<dt>Id-Time Points Iterator: </dt><dd><p>Id-Time points iterator generates points from an *id-time points table*. If 'keepref=FALSE' the reference of each point is set to '-1'. <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func = &quot;avg&quot;, time.shift = 1) <br />
r &lt;- emr_extract(&quot;insulin_shot_track&quot;) # &lt;&ndash; implicit iterator is used here <br />
emr_extract(&quot;glucose&quot;, iterator = r) <br />
</p>
</dd>
<dt>Ids Iterator: </dt><dd><p>Ids iterator generates points with ids taken from an *ids table* and times that run from 'stime' to 'etime' with a step of 1. If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.<br />
Example: <br /> <br />
stime &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime &lt;- emr_date2time(31, 12, 2016, 23) <br />
emr_extract(&quot;glucose&quot;, iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime)<br />
</p>
</dd>
<dt>Time Intervals Iterator: </dt><dd><p>*Time intervals iterator* generates points for all the ids that appear in 'patients.dob' track with times taken from a *time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'. <br />
Example: <br />
# Returns the level of hangover for all patients the next day after New Year Eve for the years 2015 and 2016 <br />
stime1 &lt;- emr_date2time(1, 1, 2015, 0) <br />
etime1 &lt;- emr_date2time(1, 1, 2015, 23) <br />
stime2 &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime2 &lt;- emr_date2time(1, 1, 2016, 23) <br />
emr_extract(&quot;alcohol_level_track&quot;, iterator = data.frame( <br />
stime = c(stime1, stime2), <br />
etime = c(etime1, etime2) <br />
)) <br />
</p>
</dd>
<dt>Id-Time Intervals Iterator: </dt><dd><p>*Id-Time intervals iterator* generates for each id points that cover &lsquo;[&rsquo;stime', 'etime']' time range as specified in *id-time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'</p>
</dd>
<dt>Beat Iterator: </dt><dd><p>*Beat Iterator* generates a &quot;time beat&quot; at the given period for each id that appear in 'patients.dob' track. The period is given always in hours. <br />
Example: <br />
emr_extract(&quot;glucose_track&quot;, iterator=10, stime=1000, etime=2000) <br />
This will create a beat iterator with a period of 10 hours starting at 'stime' up until 'etime' is reached. If, for example, 'stime' equals '1000' then the beat iterator will create for each id iterator points at times: 1000, 1010, 1020, ... <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.
</p>
</dd>
<dt>Extended Beat Iterator: </dt><dd><p>*Extended beat iterator* is as its name suggests a variation on the beat iterator. It works by the same principle of creating time points with the given period however instead of basing the times count on 'stime' it accepts an additional parameter - a track or a *Id-Time Points table* - that instructs what should be the initial time point for each of the ids. The two parameters (period and mapping) should come in a list. Each id is required to appear only once and if a certain id does not appear at all, it is skipped by the iterator. <br />
Anyhow points that lie outside of '[stime, etime]' range are not generated. <br />
Example: <br />
# Returns the maximal weight of patients at one year span starting from their birthdays <br />
emr_vtrack.create(&quot;weight&quot;, &quot;weight_track&quot;, func = &quot;max&quot;, time.shift = c(0, year())) <br />
emr_extract(&quot;weight&quot;, iterator = list(year(), &quot;birthday_track&quot;), stime = 1000, etime = 2000) <br />
</p>
</dd>
<dt>Periodic Iterator: </dt><dd><p>periodic iterator goes over every year/month. You can use it by running  <code>emr_monthly_iterator</code> or <code>emr_yearly_iterator</code>. <br />
Example: <br />
iter &lt;- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017)) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
iter &lt;- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
</p>
</dd>
<dt>Implicit Iterator: </dt><dd><p>The iterator is set implicitly if its value remains 'NULL' (which is the default). In that case the track expression is analyzed and searched for track names. If all the track variables or virtual track variables point to the same track, this track is used as a source for a track iterator. If more then one track appears in the track expression, an error message is printed out notifying ambiguity.</p>
</dd>
</dl>

<p>Revealing Current Iterator Time:
During the evaluation of a track expression one can access a specially defined variable named 'EMR_TIME' (Python: 'TIME'). This variable contains a vector ('numpy.ndarray' in Python) of current iterator times. The length of the vector matches the length of the track variable (which is a vector too). <br />
Note that some values in 'EMR_TIME' might be set 0. Skip those intervals and the values of the track variables at the corresponding indices. <br />
# Returns times of the current iterator as a day of month <br />
emr_extract(&quot;emr_time2dayofmonth(EMR_TIME)&quot;, iterator = &quot;sparse_track&quot;) <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_cor">emr_cor</a></code>, <code><a href="base.html#topic+cut">cut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_dist("sparse_track", c(0, 15, 20, 30, 40, 50), keepref = TRUE)
emr_dist("sparse_track", c(0, 15, 20, 30, 40, 50), keepref = TRUE, dataframe = TRUE)
</code></pre>

<hr>
<h2 id='emr_download_example_data'>Download example database</h2><span id='topic+emr_download_example_data'></span>

<h3>Description</h3>

<p>Download an example database which was simulated to include an example of a typical EMR database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_download_example_data(dir = getwd(), temp_dir = tempdir())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_download_example_data_+3A_dir">dir</code></td>
<td>
<p>Directory to save the database to. Default: current working directory.</p>
</td></tr>
<tr><td><code id="emr_download_example_data_+3A_temp_dir">temp_dir</code></td>
<td>
<p>Directory to save the temporary downloaded file to.
Change if your system has a small '/tmp&ldquo; directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. The database is saved under the name 'sample_db' in the specified directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_download_example_data()




</code></pre>

<hr>
<h2 id='emr_entries.get'>Get an entry</h2><span id='topic+emr_entries.get'></span>

<h3>Description</h3>

<p>Get an entry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_entries.get(key, db_dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_entries.get_+3A_key">key</code></td>
<td>
<p>The key of the entry to get</p>
</td></tr>
<tr><td><code id="emr_entries.get_+3A_db_dir">db_dir</code></td>
<td>
<p>One or more database directories to reload entries from. If NULL - the first database is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The entry value. If the key does not exist, NULL is returned. For multiple databases, a named list of database entries is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()
emr_entries.get("entry1")

</code></pre>

<hr>
<h2 id='emr_entries.get_all'>Get all entries</h2><span id='topic+emr_entries.get_all'></span>

<h3>Description</h3>

<p>Get all entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_entries.get_all(db_dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_entries.get_all_+3A_db_dir">db_dir</code></td>
<td>
<p>One or more database directories to reload entries from. If NULL - the first database is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of entries. For multiple databases, a named list of database entries is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()
emr_entries.get_all()

</code></pre>

<hr>
<h2 id='emr_entries.ls'>List entries</h2><span id='topic+emr_entries.ls'></span>

<h3>Description</h3>

<p>List entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_entries.ls(db_dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_entries.ls_+3A_db_dir">db_dir</code></td>
<td>
<p>One or more database directories to reload entries from. If NULL - the first database is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of entry names. For multiple databases, a named list of database entries is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()
emr_entries.ls()

</code></pre>

<hr>
<h2 id='emr_entries.reload'>Reload entries from disk</h2><span id='topic+emr_entries.reload'></span>

<h3>Description</h3>

<p>Reload entries from disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_entries.reload(db_dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_entries.reload_+3A_db_dir">db_dir</code></td>
<td>
<p>One or more database directories to reload entries from. If NULL - the first database is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. If the entries were reloaded - the file timestamp is returned invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()
emr_entries.reload()

</code></pre>

<hr>
<h2 id='emr_entries.rm'>Remove an entry</h2><span id='topic+emr_entries.rm'></span>

<h3>Description</h3>

<p>Remove an entry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_entries.rm(key, db_dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_entries.rm_+3A_key">key</code></td>
<td>
<p>The key of the entry to remove. If the key does not exist, nothing happens.</p>
</td></tr>
<tr><td><code id="emr_entries.rm_+3A_db_dir">db_dir</code></td>
<td>
<p>One or more database directories to reload entries from. If NULL - the first database is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()
emr_entries.rm("entry1")
emr_entries.ls()

</code></pre>

<hr>
<h2 id='emr_entries.rm_all'>Remove all entries</h2><span id='topic+emr_entries.rm_all'></span>

<h3>Description</h3>

<p>Remove all entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_entries.rm_all(db_dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_entries.rm_all_+3A_db_dir">db_dir</code></td>
<td>
<p>One or more database directories to reload entries from. If NULL - the first database is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()
emr_entries.rm_all()

</code></pre>

<hr>
<h2 id='emr_entries.set'>Set an entry</h2><span id='topic+emr_entries.set'></span>

<h3>Description</h3>

<p>Set an entry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_entries.set(key, value, db_dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_entries.set_+3A_key">key</code></td>
<td>
<p>The key of the entry to set</p>
</td></tr>
<tr><td><code id="emr_entries.set_+3A_value">value</code></td>
<td>
<p>The value of the entry to set. This can be anything that can be serialized to YAML</p>
</td></tr>
<tr><td><code id="emr_entries.set_+3A_db_dir">db_dir</code></td>
<td>
<p>One or more database directories to reload entries from. If NULL - the first database is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()
emr_entries.set("entry1", "new value")
emr_entries.get("entry1")

</code></pre>

<hr>
<h2 id='emr_extract'>Returns evaluated track expression</h2><span id='topic+emr_extract'></span>

<h3>Description</h3>

<p>Returns the result of track expressions evaluation for each of the iterator
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_extract(
  expr,
  tidy = FALSE,
  sort = FALSE,
  names = NULL,
  stime = NULL,
  etime = NULL,
  iterator = NULL,
  keepref = FALSE,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_extract_+3A_expr">expr</code></td>
<td>
<p>vector of track expressions</p>
</td></tr>
<tr><td><code id="emr_extract_+3A_tidy">tidy</code></td>
<td>
<p>if 'TRUE' result is returned in &quot;tidy&quot;&quot; format</p>
</td></tr>
<tr><td><code id="emr_extract_+3A_sort">sort</code></td>
<td>
<p>if 'TRUE' result is sorted by id, time and reference</p>
</td></tr>
<tr><td><code id="emr_extract_+3A_names">names</code></td>
<td>
<p>names for the track expressions in the returned value. If
'NULL' names are set to the track expression themselves.</p>
</td></tr>
<tr><td><code id="emr_extract_+3A_stime">stime</code></td>
<td>
<p>start time scope</p>
</td></tr>
<tr><td><code id="emr_extract_+3A_etime">etime</code></td>
<td>
<p>end time scope</p>
</td></tr>
<tr><td><code id="emr_extract_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions. See also 'iterator' section.</p>
</td></tr>
<tr><td><code id="emr_extract_+3A_keepref">keepref</code></td>
<td>
<p>If 'TRUE' references are preserved in the iterator.</p>
</td></tr>
<tr><td><code id="emr_extract_+3A_filter">filter</code></td>
<td>
<p>Iterator filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the result of track expressions evaluation for each of
the iterator stops.
</p>
<p>If 'tidy' is 'TRUE' the returned value is a set of ID-Time points with two
additional columns named 'expr' and 'value'. 'expr' marks the track
expression that produced the value. Rows with NaN values are omitted from
the tidy format.
</p>
<p>If 'tidy' is 'FALSE' the returned value is a set of ID-Time points with an
additional column for the values of each of the track expressions.
</p>
<p>If 'sort' is 'TRUE' the returned value is sorted by id, time and reference,
otherwise the order is not guaranteed especially for longer runs, when
multitasking might be launched. Sorting requires additional time, so it is
switched off by default.
</p>
<p>'names' parameter sets the labels for the track expressions in the return
value. If 'names' is 'NULL' the labels are set to the track expression
themselves.
</p>


<h3>Value</h3>

<p>A set of ID-Time points with additional columns depending on the
value of 'tidy' (see above).
</p>


<h3>iterator</h3>

<p>There are a few types of iterators:
</p>

<dl>
<dt>Track iterator: </dt><dd><p>Track iterator returns the points (including the reference) from the specified track. Track name is specified as a string. If 'keepref=FALSE' the reference of each point is set to '-1' <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func=&quot;avg&quot;, time.shift=1) <br />
emr_extract(&quot;glucose&quot;, iterator=&quot;insulin_shot_track&quot;) <br />
</p>
</dd>
<dt>Id-Time Points Iterator: </dt><dd><p>Id-Time points iterator generates points from an *id-time points table*. If 'keepref=FALSE' the reference of each point is set to '-1'. <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func = &quot;avg&quot;, time.shift = 1) <br />
r &lt;- emr_extract(&quot;insulin_shot_track&quot;) # &lt;&ndash; implicit iterator is used here <br />
emr_extract(&quot;glucose&quot;, iterator = r) <br />
</p>
</dd>
<dt>Ids Iterator: </dt><dd><p>Ids iterator generates points with ids taken from an *ids table* and times that run from 'stime' to 'etime' with a step of 1. If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.<br />
Example: <br /> <br />
stime &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime &lt;- emr_date2time(31, 12, 2016, 23) <br />
emr_extract(&quot;glucose&quot;, iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime)<br />
</p>
</dd>
<dt>Time Intervals Iterator: </dt><dd><p>*Time intervals iterator* generates points for all the ids that appear in 'patients.dob' track with times taken from a *time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'. <br />
Example: <br />
# Returns the level of hangover for all patients the next day after New Year Eve for the years 2015 and 2016 <br />
stime1 &lt;- emr_date2time(1, 1, 2015, 0) <br />
etime1 &lt;- emr_date2time(1, 1, 2015, 23) <br />
stime2 &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime2 &lt;- emr_date2time(1, 1, 2016, 23) <br />
emr_extract(&quot;alcohol_level_track&quot;, iterator = data.frame( <br />
stime = c(stime1, stime2), <br />
etime = c(etime1, etime2) <br />
)) <br />
</p>
</dd>
<dt>Id-Time Intervals Iterator: </dt><dd><p>*Id-Time intervals iterator* generates for each id points that cover &lsquo;[&rsquo;stime', 'etime']' time range as specified in *id-time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'</p>
</dd>
<dt>Beat Iterator: </dt><dd><p>*Beat Iterator* generates a &quot;time beat&quot; at the given period for each id that appear in 'patients.dob' track. The period is given always in hours. <br />
Example: <br />
emr_extract(&quot;glucose_track&quot;, iterator=10, stime=1000, etime=2000) <br />
This will create a beat iterator with a period of 10 hours starting at 'stime' up until 'etime' is reached. If, for example, 'stime' equals '1000' then the beat iterator will create for each id iterator points at times: 1000, 1010, 1020, ... <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.
</p>
</dd>
<dt>Extended Beat Iterator: </dt><dd><p>*Extended beat iterator* is as its name suggests a variation on the beat iterator. It works by the same principle of creating time points with the given period however instead of basing the times count on 'stime' it accepts an additional parameter - a track or a *Id-Time Points table* - that instructs what should be the initial time point for each of the ids. The two parameters (period and mapping) should come in a list. Each id is required to appear only once and if a certain id does not appear at all, it is skipped by the iterator. <br />
Anyhow points that lie outside of '[stime, etime]' range are not generated. <br />
Example: <br />
# Returns the maximal weight of patients at one year span starting from their birthdays <br />
emr_vtrack.create(&quot;weight&quot;, &quot;weight_track&quot;, func = &quot;max&quot;, time.shift = c(0, year())) <br />
emr_extract(&quot;weight&quot;, iterator = list(year(), &quot;birthday_track&quot;), stime = 1000, etime = 2000) <br />
</p>
</dd>
<dt>Periodic Iterator: </dt><dd><p>periodic iterator goes over every year/month. You can use it by running  <code>emr_monthly_iterator</code> or <code>emr_yearly_iterator</code>. <br />
Example: <br />
iter &lt;- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017)) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
iter &lt;- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
</p>
</dd>
<dt>Implicit Iterator: </dt><dd><p>The iterator is set implicitly if its value remains 'NULL' (which is the default). In that case the track expression is analyzed and searched for track names. If all the track variables or virtual track variables point to the same track, this track is used as a source for a track iterator. If more then one track appears in the track expression, an error message is printed out notifying ambiguity.</p>
</dd>
</dl>

<p>Revealing Current Iterator Time:
During the evaluation of a track expression one can access a specially defined variable named 'EMR_TIME' (Python: 'TIME'). This variable contains a vector ('numpy.ndarray' in Python) of current iterator times. The length of the vector matches the length of the track variable (which is a vector too). <br />
Note that some values in 'EMR_TIME' might be set 0. Skip those intervals and the values of the track variables at the corresponding indices. <br />
# Returns times of the current iterator as a day of month <br />
emr_extract(&quot;emr_time2dayofmonth(EMR_TIME)&quot;, iterator = &quot;sparse_track&quot;) <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_screen">emr_screen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_extract("dense_track", stime = 1, etime = 3)
</code></pre>

<hr>
<h2 id='emr_filter.attr.src'>Get or set attributes of a named filter</h2><span id='topic+emr_filter.attr.src'></span><span id='topic+emr_filter.attr.keepref'></span><span id='topic+emr_filter.attr.time.shift'></span><span id='topic+emr_filter.attr.val'></span><span id='topic+emr_filter.attr.expiration'></span>

<h3>Description</h3>

<p>Get or set attributes of a named filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_filter.attr.src(filter, src)

emr_filter.attr.keepref(filter, keepref)

emr_filter.attr.time.shift(filter, time.shift)

emr_filter.attr.val(filter, val)

emr_filter.attr.expiration(filter, expiration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_filter.attr.src_+3A_filter">filter</code></td>
<td>
<p>filter name.</p>
</td></tr>
<tr><td><code id="emr_filter.attr.src_+3A_src">src</code>, <code id="emr_filter.attr.src_+3A_keepref">keepref</code>, <code id="emr_filter.attr.src_+3A_time.shift">time.shift</code>, <code id="emr_filter.attr.src_+3A_val">val</code>, <code id="emr_filter.attr.src_+3A_expiration">expiration</code></td>
<td>
<p>filter attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When only 'filter' argument is used in the call, the functions return the
corresponding attribute of the named filter. Otherwise a new attribute value
is set.
</p>
<p>Note: since inter-dependency exists between certain attributes, the
correctness of the attributes as a whole can only be verified when the named
filter is applied to a track expression.
</p>
<p>For more information about the valid attribute values please refer to the
documentation of 'emr_filter.create'.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_filter.create">emr_filter.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_filter.create("f1", "dense_track", time.shift = c(2, 4))
emr_filter.attr.src("f1")
emr_filter.attr.src("f1", "sparse_track")
emr_filter.attr.src("f1")
</code></pre>

<hr>
<h2 id='emr_filter.clear'>Clear all filters from the current environment</h2><span id='topic+emr_filter.clear'></span>

<h3>Description</h3>

<p>Clear all filters from the current environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_filter.clear()
</code></pre>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_filter.create("f1", "dense_track", time.shift = c(2, 4))
emr_filter.ls()
emr_filter.clear()
emr_filter.ls()
</code></pre>

<hr>
<h2 id='emr_filter.create'>Creates a new named filter</h2><span id='topic+emr_filter.create'></span>

<h3>Description</h3>

<p>Creates a new named filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_filter.create(
  filter,
  src,
  keepref = FALSE,
  time.shift = NULL,
  val = NULL,
  expiration = NULL,
  operator = "="
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_filter.create_+3A_filter">filter</code></td>
<td>
<p>filter name. If NULL - a name would be generated automatically using <code>emr_filter.name</code>.</p>
</td></tr>
<tr><td><code id="emr_filter.create_+3A_src">src</code></td>
<td>
<p>source (track name, virtual track name or id-time table). Can be a vector of track names.</p>
</td></tr>
<tr><td><code id="emr_filter.create_+3A_keepref">keepref</code></td>
<td>
<p>'TRUE' or 'FALSE'</p>
</td></tr>
<tr><td><code id="emr_filter.create_+3A_time.shift">time.shift</code></td>
<td>
<p>time shift and expansion for iterator time</p>
</td></tr>
<tr><td><code id="emr_filter.create_+3A_val">val</code></td>
<td>
<p>selected values</p>
</td></tr>
<tr><td><code id="emr_filter.create_+3A_expiration">expiration</code></td>
<td>
<p>expiration period</p>
</td></tr>
<tr><td><code id="emr_filter.create_+3A_operator">operator</code></td>
<td>
<p>operator for filtering. Accepts one of: &quot;=&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new named filter.
</p>
<p>'src' can be either a track name, a virtual track name, or an id-time table - data frame with the
first columns named &quot;id&quot;, &quot;time&quot; and an optional &quot;ref&quot;.
</p>
<p>If 'val' is not 'NULL', the time window of the filter is required to contain
at least one value from the vector of 'val' which passes the 'operator' (see below).
</p>
<p>'val' is allowed to be used only when 'src' is a name of a track. When val is specified,
the filter will filter the i.d, time points by applying the 'operator' argument on the
value of the point.
</p>
<p>If 'expiration' is not 'NULL' and the filter window contains a value at time
't', the existence of previous values in the time window of [t-expiration,
t-1] (aka: &quot;expiration window&quot;) is checked. If no such values are found in
the expiration window, the filter returns 'TRUE', otherwise 'FALSE'.
</p>
<p>'expiration' is allowed to be used only when 'src' is a name of a
categorical track and 'keepref' is 'FALSE'.
</p>
<p>'operator' corresponds to the 'val' argument. The point passes the filter
if the point's value passes the operator. For example if the point's value is 4,
the operator is &quot;&lt;&quot; and val is 5, the expression evaluated is 4 &lt; 5 (pass).
When 'operator' is not &quot;=&quot;, 'vals' must exist, and be of length 1.
</p>
<p>If both 'val' and 'expiration' are not 'NULL' then only values from 'val'
vector are checked both in time window and expiration window.
</p>
<p>Note: 'time.shift' can be used only when 'keepref' is 'FALSE'.
Note:  A zero length vector is interpreted by R as NULL, so <code>val=c()</code> would create
a filter which returns all the values of <code>src</code>
</p>


<h3>Value</h3>

<p>Name of the filter (invisibly, if filter name wasn't generated automatically, otherwise - explicitly)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_filter.attr.src">emr_filter.attr.src</a></code>, <code><a href="#topic+emr_filter.ls">emr_filter.ls</a></code>,
<code><a href="#topic+emr_filter.exists">emr_filter.exists</a></code>, <code><a href="#topic+emr_filter.rm">emr_filter.rm</a></code>, <code><a href="#topic+emr_filter.create_from_name">emr_filter.create_from_name</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_filter.create("f1", "dense_track", time.shift = c(2, 4))
emr_filter.create("f2", "dense_track", keepref = TRUE)
emr_extract("sparse_track", filter = "!f1 &amp; f2")
</code></pre>

<hr>
<h2 id='emr_filter.create_from_name'>Create a filter from an automatically generated name</h2><span id='topic+emr_filter.create_from_name'></span>

<h3>Description</h3>

<p>Create a filter from an automatically generated name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_filter.create_from_name(filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_filter.create_from_name_+3A_filter">filter</code></td>
<td>
<p>name of a filter automatically generated by <code>emr_filter.name</code>. Can be a vector of filter names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>name of the filter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_filter.create">emr_filter.create</a></code>, <code><a href="#topic+emr_filter.create_from_name">emr_filter.create_from_name</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()
name &lt;- emr_filter.name("dense_track", time.shift = c(2, 4))
emr_filter.create_from_name(name)
</code></pre>

<hr>
<h2 id='emr_filter.exists'>Checks whether the named filter exists</h2><span id='topic+emr_filter.exists'></span>

<h3>Description</h3>

<p>Checks whether the named filter exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_filter.exists(filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_filter.exists_+3A_filter">filter</code></td>
<td>
<p>filter name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks whether the named filter exists.
</p>


<h3>Value</h3>

<p>'TRUE', if the named filter exists, otherwise 'FALSE'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_filter.create">emr_filter.create</a></code>, <code><a href="#topic+emr_filter.ls">emr_filter.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_filter.create("f1", "dense_track", time.shift = c(2, 4))
emr_filter.exists("f1")
</code></pre>

<hr>
<h2 id='emr_filter.info'>Returns the definition of a named filter</h2><span id='topic+emr_filter.info'></span>

<h3>Description</h3>

<p>Returns the definition of a named filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_filter.info(filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_filter.info_+3A_filter">filter</code></td>
<td>
<p>filter name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the internal representation of a named filter.
</p>


<h3>Value</h3>

<p>Internal representation of a named filter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_filter.create">emr_filter.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_filter.create("f1", "dense_track", time.shift = c(2, 4))
emr_filter.info("f1")
</code></pre>

<hr>
<h2 id='emr_filter.ls'>Returns a list of named filters</h2><span id='topic+emr_filter.ls'></span>

<h3>Description</h3>

<p>Returns a list of named filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_filter.ls(
  pattern = "",
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_filter.ls_+3A_pattern">pattern</code>, <code id="emr_filter.ls_+3A_ignore.case">ignore.case</code>, <code id="emr_filter.ls_+3A_perl">perl</code>, <code id="emr_filter.ls_+3A_fixed">fixed</code>, <code id="emr_filter.ls_+3A_usebytes">useBytes</code></td>
<td>
<p>see 'grep'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list of named filters that exist in current R
environment that match the pattern (see 'grep'). If called without any
arguments all named filters are returned.
</p>


<h3>Value</h3>

<p>An array that contains the names of filters.
If no filter was found, <code>character(0)</code> would be returned.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+emr_filter.exists">emr_filter.exists</a></code>,
<code><a href="#topic+emr_filter.create">emr_filter.create</a></code>, <code><a href="#topic+emr_filter.rm">emr_filter.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_filter.create("f1", "dense_track", time.shift = c(2, 4))
emr_filter.create("f2", "dense_track", keepref = TRUE)
emr_filter.ls()
emr_filter.ls("*2")
</code></pre>

<hr>
<h2 id='emr_filter.name'>Generate a default name for a naryn filter</h2><span id='topic+emr_filter.name'></span>

<h3>Description</h3>

<p>Generate a default name for a naryn filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_filter.name(
  src,
  keepref = FALSE,
  time.shift = NULL,
  val = NULL,
  expiration = NULL,
  operator = "="
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_filter.name_+3A_src">src</code></td>
<td>
<p>source (track name, virtual track name or id-time table). Can be a vector of track names.</p>
</td></tr>
<tr><td><code id="emr_filter.name_+3A_keepref">keepref</code></td>
<td>
<p>'TRUE' or 'FALSE'</p>
</td></tr>
<tr><td><code id="emr_filter.name_+3A_time.shift">time.shift</code></td>
<td>
<p>time shift and expansion for iterator time</p>
</td></tr>
<tr><td><code id="emr_filter.name_+3A_val">val</code></td>
<td>
<p>selected values</p>
</td></tr>
<tr><td><code id="emr_filter.name_+3A_expiration">expiration</code></td>
<td>
<p>expiration period</p>
</td></tr>
<tr><td><code id="emr_filter.name_+3A_operator">operator</code></td>
<td>
<p>operator for filtering. Accepts one of: &quot;=&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given filter parameters, generate a name with the following format:
&quot;f_(src).kr(keepref).vals_(val).ts_(time.shift).exp_(expiration).op_(operator)&quot;
Where for 'val' and 'time.shift' the values are separated by an
underscore.
</p>
<p>If <code>time.shift</code>, <code>val</code> or <code>expiration</code> are
<code>NULL</code> - their section would not appear in the generated name.
</p>


<h3>Value</h3>

<p>a default name for the filter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_filter.create">emr_filter.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_filter.name("dense_track", time.shift = c(2, 4))
</code></pre>

<hr>
<h2 id='emr_filter.rm'>Deletes a named filter</h2><span id='topic+emr_filter.rm'></span>

<h3>Description</h3>

<p>Deletes a named filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_filter.rm(filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_filter.rm_+3A_filter">filter</code></td>
<td>
<p>filter name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes a named filter from current R environment.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_filter.create">emr_filter.create</a></code>, <code><a href="#topic+emr_filter.ls">emr_filter.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_filter.create("f1", "dense_track", time.shift = c(2, 4))
emr_filter.create("f2", "dense_track", keepref = TRUE)
emr_filter.ls()
emr_filter.rm("f1")
emr_filter.ls()
</code></pre>

<hr>
<h2 id='emr_filters.info'>Returns the filter definition of named filters given a filter expression</h2><span id='topic+emr_filters.info'></span>

<h3>Description</h3>

<p>Returns the filter definition of named filters given a filter expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_filters.info(filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_filters.info_+3A_filter">filter</code></td>
<td>
<p>a filter expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of named filters
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_filter.info">emr_filter.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()
emr_filter.create("f1", "dense_track", time.shift = c(2, 4))
emr_filter.create("f2", "dense_track", time.shift = c(2, 4))
emr_filter.create("f3", "dense_track", time.shift = c(2, 4))
emr_filters.info("f1 | (f2 &amp; f3)")

</code></pre>

<hr>
<h2 id='emr_ids_coverage'>Returns ids coverage per track</h2><span id='topic+emr_ids_coverage'></span>

<h3>Description</h3>

<p>Returns ids coverage per track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_ids_coverage(ids, tracks, stime = NULL, etime = NULL, filter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_ids_coverage_+3A_ids">ids</code></td>
<td>
<p>track name or Ids Table</p>
</td></tr>
<tr><td><code id="emr_ids_coverage_+3A_tracks">tracks</code></td>
<td>
<p>a vector of track names</p>
</td></tr>
<tr><td><code id="emr_ids_coverage_+3A_stime">stime</code></td>
<td>
<p>start time scope</p>
</td></tr>
<tr><td><code id="emr_ids_coverage_+3A_etime">etime</code></td>
<td>
<p>end time scope</p>
</td></tr>
<tr><td><code id="emr_ids_coverage_+3A_filter">filter</code></td>
<td>
<p>iterator filter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a set of ids and a vector of categorical tracks. For
each track it calculates how many ids appear in the track. Each id is
counted only once.
</p>
<p>Ids can originate from a track or be provided within Ids Table.
</p>
<p>Note: The internal iterator that runs over each track is defined with
'keepref=TRUE'.
</p>


<h3>Value</h3>

<p>A vector containing the ids count for each track.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_ids_vals_coverage">emr_ids_vals_coverage</a></code>, <code><a href="#topic+emr_track.ids">emr_track.ids</a></code>,
<code><a href="#topic+emr_dist">emr_dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_ids_coverage(data.frame(id = c(15, 24, 27)), "categorical_track")
</code></pre>

<hr>
<h2 id='emr_ids_vals_coverage'>Returns ids coverage per value track</h2><span id='topic+emr_ids_vals_coverage'></span>

<h3>Description</h3>

<p>Returns ids coverage per value track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_ids_vals_coverage(ids, tracks, stime = NULL, etime = NULL, filter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_ids_vals_coverage_+3A_ids">ids</code></td>
<td>
<p>track name or Ids Table</p>
</td></tr>
<tr><td><code id="emr_ids_vals_coverage_+3A_tracks">tracks</code></td>
<td>
<p>a vector of track names</p>
</td></tr>
<tr><td><code id="emr_ids_vals_coverage_+3A_stime">stime</code></td>
<td>
<p>start time scope</p>
</td></tr>
<tr><td><code id="emr_ids_vals_coverage_+3A_etime">etime</code></td>
<td>
<p>end time scope</p>
</td></tr>
<tr><td><code id="emr_ids_vals_coverage_+3A_filter">filter</code></td>
<td>
<p>iterator filter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a set of ids and a vector of categorical tracks. For
each track value it calculates how many ids share this value. Each id is
counted only once. A data frame with 3 columns 'track', 'val' and 'count' is
returned.
</p>
<p>Ids can originate from a track or be provided within Ids Table.
</p>
<p>Note: The internal iterator that runs over each track is defined with
'keepref=TRUE'.
</p>


<h3>Value</h3>

<p>A data frame containing the number of ids for each track value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_ids_coverage">emr_ids_coverage</a></code>, <code><a href="#topic+emr_track.ids">emr_track.ids</a></code>,
<code><a href="#topic+emr_dist">emr_dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_ids_vals_coverage(data.frame(id = c(15, 24, 27)), "categorical_track")
</code></pre>

<hr>
<h2 id='emr_monthly_iterator'>Create an iterator that goes every year/month</h2><span id='topic+emr_monthly_iterator'></span><span id='topic+emr_yearly_iterator'></span>

<h3>Description</h3>

<p>Create an iterator that goes every year/month, from <code>stime</code>.
If <code>etime</code> is set, the iterator would go every year/month until the last point which is &lt;= <code>etime</code>.
If <code>month</code> or <code>years</code> is set, the iterator would be set for every year/month
<code>n</code>times.
If both parameters are set, the iterator would go from <code>etime</code> until the early between <code>n</code>
times and <code>etime</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_monthly_iterator(stime, etime = NULL, n = NULL)

emr_yearly_iterator(stime, etime = NULL, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_monthly_iterator_+3A_stime">stime</code></td>
<td>
<p>the date of the first point in machine format (use <code>emr_date2time</code>)</p>
</td></tr>
<tr><td><code id="emr_monthly_iterator_+3A_etime">etime</code></td>
<td>
<p>end of time scope (can be <code>NULL</code> if <code>months</code> parameter is set)</p>
</td></tr>
<tr><td><code id="emr_monthly_iterator_+3A_n">n</code></td>
<td>
<p>number of months / years</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an id time data frame that can be used as an iterator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iter &lt;- emr_monthly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017))
# note that the examples database doesn't include actual dates, so the results are empty
emr_extract("dense_track", iterator = iter, stime = 1, etime = 3)

iter &lt;- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15)
emr_extract("dense_track", iterator = iter, stime = 1, etime = 3)

</code></pre>

<hr>
<h2 id='emr_quantiles'>Calculates quantiles of a track expression</h2><span id='topic+emr_quantiles'></span>

<h3>Description</h3>

<p>Calculates quantiles of a track expression for the given percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_quantiles(
  expr,
  percentiles = 0.5,
  stime = NULL,
  etime = NULL,
  iterator = NULL,
  keepref = FALSE,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_quantiles_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="emr_quantiles_+3A_percentiles">percentiles</code></td>
<td>
<p>an array of percentiles of quantiles in [0, 1] range</p>
</td></tr>
<tr><td><code id="emr_quantiles_+3A_stime">stime</code></td>
<td>
<p>start time scope</p>
</td></tr>
<tr><td><code id="emr_quantiles_+3A_etime">etime</code></td>
<td>
<p>end time scope</p>
</td></tr>
<tr><td><code id="emr_quantiles_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expression. See also 'iterator' section.</p>
</td></tr>
<tr><td><code id="emr_quantiles_+3A_keepref">keepref</code></td>
<td>
<p>If 'TRUE' references are preserved in the iterator.</p>
</td></tr>
<tr><td><code id="emr_quantiles_+3A_filter">filter</code></td>
<td>
<p>Iterator filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates quantiles for the given percentiles.
</p>
<p>If data size exceeds the limit (see: 'getOption(emr_max.data.size)'), the
data is randomly sampled to fit the limit. A warning message is generated
then.
</p>


<h3>Value</h3>

<p>An array that represent quantiles.
</p>


<h3>iterator</h3>

<p>There are a few types of iterators:
</p>

<dl>
<dt>Track iterator: </dt><dd><p>Track iterator returns the points (including the reference) from the specified track. Track name is specified as a string. If 'keepref=FALSE' the reference of each point is set to '-1' <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func=&quot;avg&quot;, time.shift=1) <br />
emr_extract(&quot;glucose&quot;, iterator=&quot;insulin_shot_track&quot;) <br />
</p>
</dd>
<dt>Id-Time Points Iterator: </dt><dd><p>Id-Time points iterator generates points from an *id-time points table*. If 'keepref=FALSE' the reference of each point is set to '-1'. <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func = &quot;avg&quot;, time.shift = 1) <br />
r &lt;- emr_extract(&quot;insulin_shot_track&quot;) # &lt;&ndash; implicit iterator is used here <br />
emr_extract(&quot;glucose&quot;, iterator = r) <br />
</p>
</dd>
<dt>Ids Iterator: </dt><dd><p>Ids iterator generates points with ids taken from an *ids table* and times that run from 'stime' to 'etime' with a step of 1. If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.<br />
Example: <br /> <br />
stime &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime &lt;- emr_date2time(31, 12, 2016, 23) <br />
emr_extract(&quot;glucose&quot;, iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime)<br />
</p>
</dd>
<dt>Time Intervals Iterator: </dt><dd><p>*Time intervals iterator* generates points for all the ids that appear in 'patients.dob' track with times taken from a *time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'. <br />
Example: <br />
# Returns the level of hangover for all patients the next day after New Year Eve for the years 2015 and 2016 <br />
stime1 &lt;- emr_date2time(1, 1, 2015, 0) <br />
etime1 &lt;- emr_date2time(1, 1, 2015, 23) <br />
stime2 &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime2 &lt;- emr_date2time(1, 1, 2016, 23) <br />
emr_extract(&quot;alcohol_level_track&quot;, iterator = data.frame( <br />
stime = c(stime1, stime2), <br />
etime = c(etime1, etime2) <br />
)) <br />
</p>
</dd>
<dt>Id-Time Intervals Iterator: </dt><dd><p>*Id-Time intervals iterator* generates for each id points that cover &lsquo;[&rsquo;stime', 'etime']' time range as specified in *id-time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'</p>
</dd>
<dt>Beat Iterator: </dt><dd><p>*Beat Iterator* generates a &quot;time beat&quot; at the given period for each id that appear in 'patients.dob' track. The period is given always in hours. <br />
Example: <br />
emr_extract(&quot;glucose_track&quot;, iterator=10, stime=1000, etime=2000) <br />
This will create a beat iterator with a period of 10 hours starting at 'stime' up until 'etime' is reached. If, for example, 'stime' equals '1000' then the beat iterator will create for each id iterator points at times: 1000, 1010, 1020, ... <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.
</p>
</dd>
<dt>Extended Beat Iterator: </dt><dd><p>*Extended beat iterator* is as its name suggests a variation on the beat iterator. It works by the same principle of creating time points with the given period however instead of basing the times count on 'stime' it accepts an additional parameter - a track or a *Id-Time Points table* - that instructs what should be the initial time point for each of the ids. The two parameters (period and mapping) should come in a list. Each id is required to appear only once and if a certain id does not appear at all, it is skipped by the iterator. <br />
Anyhow points that lie outside of '[stime, etime]' range are not generated. <br />
Example: <br />
# Returns the maximal weight of patients at one year span starting from their birthdays <br />
emr_vtrack.create(&quot;weight&quot;, &quot;weight_track&quot;, func = &quot;max&quot;, time.shift = c(0, year())) <br />
emr_extract(&quot;weight&quot;, iterator = list(year(), &quot;birthday_track&quot;), stime = 1000, etime = 2000) <br />
</p>
</dd>
<dt>Periodic Iterator: </dt><dd><p>periodic iterator goes over every year/month. You can use it by running  <code>emr_monthly_iterator</code> or <code>emr_yearly_iterator</code>. <br />
Example: <br />
iter &lt;- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017)) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
iter &lt;- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
</p>
</dd>
<dt>Implicit Iterator: </dt><dd><p>The iterator is set implicitly if its value remains 'NULL' (which is the default). In that case the track expression is analyzed and searched for track names. If all the track variables or virtual track variables point to the same track, this track is used as a source for a track iterator. If more then one track appears in the track expression, an error message is printed out notifying ambiguity.</p>
</dd>
</dl>

<p>Revealing Current Iterator Time:
During the evaluation of a track expression one can access a specially defined variable named 'EMR_TIME' (Python: 'TIME'). This variable contains a vector ('numpy.ndarray' in Python) of current iterator times. The length of the vector matches the length of the track variable (which is a vector too). <br />
Note that some values in 'EMR_TIME' might be set 0. Skip those intervals and the values of the track variables at the corresponding indices. <br />
# Returns times of the current iterator as a day of month <br />
emr_extract(&quot;emr_time2dayofmonth(EMR_TIME)&quot;, iterator = &quot;sparse_track&quot;) <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_extract">emr_extract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_quantiles("sparse_track", c(0.1, 0.6, 0.8))
</code></pre>

<hr>
<h2 id='emr_screen'>Finds Id-Time points that match track expression</h2><span id='topic+emr_screen'></span>

<h3>Description</h3>

<p>Finds all patient-time pairs where track expression is 'TRUE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_screen(
  expr,
  sort = FALSE,
  stime = NULL,
  etime = NULL,
  iterator = NULL,
  keepref = FALSE,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_screen_+3A_expr">expr</code></td>
<td>
<p>logical track expression</p>
</td></tr>
<tr><td><code id="emr_screen_+3A_sort">sort</code></td>
<td>
<p>if 'TRUE' result is sorted by id, time and reference</p>
</td></tr>
<tr><td><code id="emr_screen_+3A_stime">stime</code></td>
<td>
<p>start time scope</p>
</td></tr>
<tr><td><code id="emr_screen_+3A_etime">etime</code></td>
<td>
<p>end time scope</p>
</td></tr>
<tr><td><code id="emr_screen_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expression. See also 'iterator' section.</p>
</td></tr>
<tr><td><code id="emr_screen_+3A_keepref">keepref</code></td>
<td>
<p>If 'TRUE' references are preserved in the iterator.</p>
</td></tr>
<tr><td><code id="emr_screen_+3A_filter">filter</code></td>
<td>
<p>Iterator filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds all Id-Time points where track expression's value is
'TRUE'.
</p>
<p>If 'sort' is 'TRUE' the returned value is sorted by id, time and reference,
otherwise the order is not guaranteed especially for longer runs, when
multitasking might be launched. Sorting requires additional time, so it is
switched off by default.
</p>


<h3>Value</h3>

<p>A set of Id-Time points that match track expression.
</p>


<h3>iterator</h3>

<p>There are a few types of iterators:
</p>

<dl>
<dt>Track iterator: </dt><dd><p>Track iterator returns the points (including the reference) from the specified track. Track name is specified as a string. If 'keepref=FALSE' the reference of each point is set to '-1' <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func=&quot;avg&quot;, time.shift=1) <br />
emr_extract(&quot;glucose&quot;, iterator=&quot;insulin_shot_track&quot;) <br />
</p>
</dd>
<dt>Id-Time Points Iterator: </dt><dd><p>Id-Time points iterator generates points from an *id-time points table*. If 'keepref=FALSE' the reference of each point is set to '-1'. <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func = &quot;avg&quot;, time.shift = 1) <br />
r &lt;- emr_extract(&quot;insulin_shot_track&quot;) # &lt;&ndash; implicit iterator is used here <br />
emr_extract(&quot;glucose&quot;, iterator = r) <br />
</p>
</dd>
<dt>Ids Iterator: </dt><dd><p>Ids iterator generates points with ids taken from an *ids table* and times that run from 'stime' to 'etime' with a step of 1. If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.<br />
Example: <br /> <br />
stime &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime &lt;- emr_date2time(31, 12, 2016, 23) <br />
emr_extract(&quot;glucose&quot;, iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime)<br />
</p>
</dd>
<dt>Time Intervals Iterator: </dt><dd><p>*Time intervals iterator* generates points for all the ids that appear in 'patients.dob' track with times taken from a *time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'. <br />
Example: <br />
# Returns the level of hangover for all patients the next day after New Year Eve for the years 2015 and 2016 <br />
stime1 &lt;- emr_date2time(1, 1, 2015, 0) <br />
etime1 &lt;- emr_date2time(1, 1, 2015, 23) <br />
stime2 &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime2 &lt;- emr_date2time(1, 1, 2016, 23) <br />
emr_extract(&quot;alcohol_level_track&quot;, iterator = data.frame( <br />
stime = c(stime1, stime2), <br />
etime = c(etime1, etime2) <br />
)) <br />
</p>
</dd>
<dt>Id-Time Intervals Iterator: </dt><dd><p>*Id-Time intervals iterator* generates for each id points that cover &lsquo;[&rsquo;stime', 'etime']' time range as specified in *id-time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'</p>
</dd>
<dt>Beat Iterator: </dt><dd><p>*Beat Iterator* generates a &quot;time beat&quot; at the given period for each id that appear in 'patients.dob' track. The period is given always in hours. <br />
Example: <br />
emr_extract(&quot;glucose_track&quot;, iterator=10, stime=1000, etime=2000) <br />
This will create a beat iterator with a period of 10 hours starting at 'stime' up until 'etime' is reached. If, for example, 'stime' equals '1000' then the beat iterator will create for each id iterator points at times: 1000, 1010, 1020, ... <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.
</p>
</dd>
<dt>Extended Beat Iterator: </dt><dd><p>*Extended beat iterator* is as its name suggests a variation on the beat iterator. It works by the same principle of creating time points with the given period however instead of basing the times count on 'stime' it accepts an additional parameter - a track or a *Id-Time Points table* - that instructs what should be the initial time point for each of the ids. The two parameters (period and mapping) should come in a list. Each id is required to appear only once and if a certain id does not appear at all, it is skipped by the iterator. <br />
Anyhow points that lie outside of '[stime, etime]' range are not generated. <br />
Example: <br />
# Returns the maximal weight of patients at one year span starting from their birthdays <br />
emr_vtrack.create(&quot;weight&quot;, &quot;weight_track&quot;, func = &quot;max&quot;, time.shift = c(0, year())) <br />
emr_extract(&quot;weight&quot;, iterator = list(year(), &quot;birthday_track&quot;), stime = 1000, etime = 2000) <br />
</p>
</dd>
<dt>Periodic Iterator: </dt><dd><p>periodic iterator goes over every year/month. You can use it by running  <code>emr_monthly_iterator</code> or <code>emr_yearly_iterator</code>. <br />
Example: <br />
iter &lt;- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017)) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
iter &lt;- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
</p>
</dd>
<dt>Implicit Iterator: </dt><dd><p>The iterator is set implicitly if its value remains 'NULL' (which is the default). In that case the track expression is analyzed and searched for track names. If all the track variables or virtual track variables point to the same track, this track is used as a source for a track iterator. If more then one track appears in the track expression, an error message is printed out notifying ambiguity.</p>
</dd>
</dl>

<p>Revealing Current Iterator Time:
During the evaluation of a track expression one can access a specially defined variable named 'EMR_TIME' (Python: 'TIME'). This variable contains a vector ('numpy.ndarray' in Python) of current iterator times. The length of the vector matches the length of the track variable (which is a vector too). <br />
Note that some values in 'EMR_TIME' might be set 0. Skip those intervals and the values of the track variables at the corresponding indices. <br />
# Returns times of the current iterator as a day of month <br />
emr_extract(&quot;emr_time2dayofmonth(EMR_TIME)&quot;, iterator = &quot;sparse_track&quot;) <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_extract">emr_extract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_screen("sparse_track == 13 | dense_track &lt; 80",
    iterator = "sparse_track", keepref = TRUE
)
</code></pre>

<hr>
<h2 id='emr_summary'>Calculates summary statistics of track expression</h2><span id='topic+emr_summary'></span>

<h3>Description</h3>

<p>Calculates summary statistics of track expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_summary(
  expr,
  stime = NULL,
  etime = NULL,
  iterator = NULL,
  keepref = FALSE,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_summary_+3A_expr">expr</code></td>
<td>
<p>track expression.</p>
</td></tr>
<tr><td><code id="emr_summary_+3A_stime">stime</code></td>
<td>
<p>start time scope.</p>
</td></tr>
<tr><td><code id="emr_summary_+3A_etime">etime</code></td>
<td>
<p>end time scope.</p>
</td></tr>
<tr><td><code id="emr_summary_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions. See also 'iterator' section.</p>
</td></tr>
<tr><td><code id="emr_summary_+3A_keepref">keepref</code></td>
<td>
<p>If 'TRUE' references are preserved in the iterator.</p>
</td></tr>
<tr><td><code id="emr_summary_+3A_filter">filter</code></td>
<td>
<p>Iterator filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns summary statistics of a track expression: total number
of values, number of NaN values, min, max, sum, mean and standard deviation
of the values.
</p>


<h3>Value</h3>

<p>An array that represents summary statistics.
</p>


<h3>iterator</h3>

<p>There are a few types of iterators:
</p>

<dl>
<dt>Track iterator: </dt><dd><p>Track iterator returns the points (including the reference) from the specified track. Track name is specified as a string. If 'keepref=FALSE' the reference of each point is set to '-1' <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func=&quot;avg&quot;, time.shift=1) <br />
emr_extract(&quot;glucose&quot;, iterator=&quot;insulin_shot_track&quot;) <br />
</p>
</dd>
<dt>Id-Time Points Iterator: </dt><dd><p>Id-Time points iterator generates points from an *id-time points table*. If 'keepref=FALSE' the reference of each point is set to '-1'. <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func = &quot;avg&quot;, time.shift = 1) <br />
r &lt;- emr_extract(&quot;insulin_shot_track&quot;) # &lt;&ndash; implicit iterator is used here <br />
emr_extract(&quot;glucose&quot;, iterator = r) <br />
</p>
</dd>
<dt>Ids Iterator: </dt><dd><p>Ids iterator generates points with ids taken from an *ids table* and times that run from 'stime' to 'etime' with a step of 1. If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.<br />
Example: <br /> <br />
stime &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime &lt;- emr_date2time(31, 12, 2016, 23) <br />
emr_extract(&quot;glucose&quot;, iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime)<br />
</p>
</dd>
<dt>Time Intervals Iterator: </dt><dd><p>*Time intervals iterator* generates points for all the ids that appear in 'patients.dob' track with times taken from a *time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'. <br />
Example: <br />
# Returns the level of hangover for all patients the next day after New Year Eve for the years 2015 and 2016 <br />
stime1 &lt;- emr_date2time(1, 1, 2015, 0) <br />
etime1 &lt;- emr_date2time(1, 1, 2015, 23) <br />
stime2 &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime2 &lt;- emr_date2time(1, 1, 2016, 23) <br />
emr_extract(&quot;alcohol_level_track&quot;, iterator = data.frame( <br />
stime = c(stime1, stime2), <br />
etime = c(etime1, etime2) <br />
)) <br />
</p>
</dd>
<dt>Id-Time Intervals Iterator: </dt><dd><p>*Id-Time intervals iterator* generates for each id points that cover &lsquo;[&rsquo;stime', 'etime']' time range as specified in *id-time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'</p>
</dd>
<dt>Beat Iterator: </dt><dd><p>*Beat Iterator* generates a &quot;time beat&quot; at the given period for each id that appear in 'patients.dob' track. The period is given always in hours. <br />
Example: <br />
emr_extract(&quot;glucose_track&quot;, iterator=10, stime=1000, etime=2000) <br />
This will create a beat iterator with a period of 10 hours starting at 'stime' up until 'etime' is reached. If, for example, 'stime' equals '1000' then the beat iterator will create for each id iterator points at times: 1000, 1010, 1020, ... <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.
</p>
</dd>
<dt>Extended Beat Iterator: </dt><dd><p>*Extended beat iterator* is as its name suggests a variation on the beat iterator. It works by the same principle of creating time points with the given period however instead of basing the times count on 'stime' it accepts an additional parameter - a track or a *Id-Time Points table* - that instructs what should be the initial time point for each of the ids. The two parameters (period and mapping) should come in a list. Each id is required to appear only once and if a certain id does not appear at all, it is skipped by the iterator. <br />
Anyhow points that lie outside of '[stime, etime]' range are not generated. <br />
Example: <br />
# Returns the maximal weight of patients at one year span starting from their birthdays <br />
emr_vtrack.create(&quot;weight&quot;, &quot;weight_track&quot;, func = &quot;max&quot;, time.shift = c(0, year())) <br />
emr_extract(&quot;weight&quot;, iterator = list(year(), &quot;birthday_track&quot;), stime = 1000, etime = 2000) <br />
</p>
</dd>
<dt>Periodic Iterator: </dt><dd><p>periodic iterator goes over every year/month. You can use it by running  <code>emr_monthly_iterator</code> or <code>emr_yearly_iterator</code>. <br />
Example: <br />
iter &lt;- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017)) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
iter &lt;- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
</p>
</dd>
<dt>Implicit Iterator: </dt><dd><p>The iterator is set implicitly if its value remains 'NULL' (which is the default). In that case the track expression is analyzed and searched for track names. If all the track variables or virtual track variables point to the same track, this track is used as a source for a track iterator. If more then one track appears in the track expression, an error message is printed out notifying ambiguity.</p>
</dd>
</dl>

<p>Revealing Current Iterator Time:
During the evaluation of a track expression one can access a specially defined variable named 'EMR_TIME' (Python: 'TIME'). This variable contains a vector ('numpy.ndarray' in Python) of current iterator times. The length of the vector matches the length of the track variable (which is a vector too). <br />
Note that some values in 'EMR_TIME' might be set 0. Skip those intervals and the values of the track variables at the corresponding indices. <br />
# Returns times of the current iterator as a day of month <br />
emr_extract(&quot;emr_time2dayofmonth(EMR_TIME)&quot;, iterator = &quot;sparse_track&quot;) <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.info">emr_track.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_summary("sparse_track")
</code></pre>

<hr>
<h2 id='emr_time'>Convert time periods to internal time format</h2><span id='topic+emr_time'></span><span id='topic+hours'></span><span id='topic+hour'></span><span id='topic+days'></span><span id='topic+day'></span><span id='topic+weeks'></span><span id='topic+week'></span><span id='topic+months'></span><span id='topic+month'></span><span id='topic+years'></span><span id='topic+year'></span>

<h3>Description</h3>

<p>Convert time periods to internal time format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_time(days = 0, months = 0, years = 0, hours = 0)

hours(n)

hour()

days(n)

day()

weeks(n)

week()

day()

months(n)

month()

years(n)

year()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_time_+3A_days">days</code></td>
<td>
<p>number of days</p>
</td></tr>
<tr><td><code id="emr_time_+3A_months">months</code></td>
<td>
<p>number of months</p>
</td></tr>
<tr><td><code id="emr_time_+3A_years">years</code></td>
<td>
<p>number of years</p>
</td></tr>
<tr><td><code id="emr_time_+3A_hours">hours</code></td>
<td>
<p>number of hours</p>
</td></tr>
<tr><td><code id="emr_time_+3A_n">n</code></td>
<td>
<p>number of days/weeks/months/years/hours</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>emr_time</code> converts a generic number of years, months day and hours to the internal
naryn machine format (which is hours).
</p>
<p><code>year</code>, <code>years</code>, <code>month</code>, <code>months</code>, <code>week</code>, <code>weeks</code>,
<code>day</code>, <code>days</code>, <code>hour</code>, <code>hours</code>
are other convenience functions to get a time period explicitly.
</p>


<h3>Value</h3>

<p>Machine time format (number of hours)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_time(5) # 5 days
emr_time(months = 4) # 4 months
emr_time(2, 4, 1) # 1 year, 4 months and 2 days

year() # 1 year
years(5) # 5 years
month() # 1 month
months(5) # 5 months
day() # 1 day
days(9) # 9 days
week() # 1 week
weeks(2) # 2 weeks
hour() # 1 hour
hours(5) # 5 hours
</code></pre>

<hr>
<h2 id='emr_time2date'>Convert from internal time to year, month, day, hour</h2><span id='topic+emr_time2date'></span>

<h3>Description</h3>

<p>Convert from internal time to year, month, day, hour
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_time2date(time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_time2date_+3A_time">time</code></td>
<td>
<p>vector of times in internal format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with columns named 'year', 'month', 'day' and 'hour'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()

# 30 January, 1938, 6:00 - birthday of Islam Karimov
t1 &lt;- emr_date2time(30, 1, 1938, 6)
# September 2, 2016, 7:00 - death of Islam Karimov
t2 &lt;- emr_date2time(2, 9, 2016, 7)
emr_time2date(c(t1, t2))
</code></pre>

<hr>
<h2 id='emr_time2dayofmonth'>Converts time from internal format to a day of month</h2><span id='topic+emr_time2dayofmonth'></span>

<h3>Description</h3>

<p>Converts time from internal format to a day of month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_time2dayofmonth(time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_time2dayofmonth_+3A_time">time</code></td>
<td>
<p>vector of times in internal format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts time from internal format to a day of month in [1,
31] range.
</p>


<h3>Value</h3>

<p>Vector of converted times. NA values in the vector would be returned as NA's.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_time2hour">emr_time2hour</a></code>, <code><a href="#topic+emr_time2month">emr_time2month</a></code>,
<code><a href="#topic+emr_time2year">emr_time2year</a></code>, <code><a href="#topic+emr_date2time">emr_date2time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()

# 30 January, 1938, 6:00 - birthday of Islam Karimov
t &lt;- emr_date2time(30, 1, 1938, 6)
emr_time2hour(t)
emr_time2dayofmonth(t)
emr_time2month(t)
emr_time2year(t)
</code></pre>

<hr>
<h2 id='emr_time2hour'>Converts time from internal format to an hour</h2><span id='topic+emr_time2hour'></span>

<h3>Description</h3>

<p>Converts time from internal format to an hour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_time2hour(time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_time2hour_+3A_time">time</code></td>
<td>
<p>vector of times in internal format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts time from internal format to an hour in [0, 23]
range.
</p>


<h3>Value</h3>

<p>Vector of converted times. NA values in the vector would be returned as NA's.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_time2dayofmonth">emr_time2dayofmonth</a></code>, <code><a href="#topic+emr_time2month">emr_time2month</a></code>,
<code><a href="#topic+emr_time2year">emr_time2year</a></code>, <code><a href="#topic+emr_date2time">emr_date2time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()

# 30 January, 1938, 6:00 - birthday of Islam Karimov
t &lt;- emr_date2time(30, 1, 1938, 6)
emr_time2hour(t)
emr_time2dayofmonth(t)
emr_time2month(t)
emr_time2year(t)
</code></pre>

<hr>
<h2 id='emr_time2month'>Converts time from internal format to a month</h2><span id='topic+emr_time2month'></span>

<h3>Description</h3>

<p>Converts time from internal format to a month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_time2month(time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_time2month_+3A_time">time</code></td>
<td>
<p>vector of times in internal format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts time from internal format to a month in [1, 12]
range.
</p>


<h3>Value</h3>

<p>Vector of converted times. NA values in the vector would be returned as NA's.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_time2hour">emr_time2hour</a></code>, <code><a href="#topic+emr_time2dayofmonth">emr_time2dayofmonth</a></code>,
<code><a href="#topic+emr_time2year">emr_time2year</a></code>, <code><a href="#topic+emr_date2time">emr_date2time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()

# 30 January, 1938, 6:00 - birthday of Islam Karimov
t &lt;- emr_date2time(30, 1, 1938, 6)
emr_time2hour(t)
emr_time2dayofmonth(t)
emr_time2month(t)
emr_time2year(t)
</code></pre>

<hr>
<h2 id='emr_time2year'>Converts time from internal format to a year</h2><span id='topic+emr_time2year'></span>

<h3>Description</h3>

<p>Converts time from internal format to a year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_time2year(time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_time2year_+3A_time">time</code></td>
<td>
<p>vector of times in internal format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts time from internal format to a year.
</p>


<h3>Value</h3>

<p>Vector of converted times. NA values in the vector would be returned as NA's.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_time2hour">emr_time2hour</a></code>, <code><a href="#topic+emr_time2dayofmonth">emr_time2dayofmonth</a></code>,
<code><a href="#topic+emr_time2month">emr_time2month</a></code>, <code><a href="#topic+emr_date2time">emr_date2time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()

# 30 January, 1938, 6:00 - birthday of Islam Karimov
t &lt;- emr_date2time(30, 1, 1938, 6)
emr_time2hour(t)
emr_time2dayofmonth(t)
emr_time2month(t)
emr_time2year(t)
</code></pre>

<hr>
<h2 id='emr_track.addto'>Adds new records to a track</h2><span id='topic+emr_track.addto'></span>

<h3>Description</h3>

<p>Adds new records to a track from a TAB-delimited file or a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.addto(track, src, force = FALSE, remove_unknown = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.addto_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="emr_track.addto_+3A_src">src</code></td>
<td>
<p>file name or data-frame containing the track records</p>
</td></tr>
<tr><td><code id="emr_track.addto_+3A_force">force</code></td>
<td>
<p>if 'TRUE', suppresses user confirmation for addition to
logical tracks</p>
</td></tr>
<tr><td><code id="emr_track.addto_+3A_remove_unknown">remove_unknown</code></td>
<td>
<p>if 'TRUE', removes unknown ids (ids that are not present at 'patients.dob' track) from the data. Otherwise, an error is thrown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds new records to a track. The records are contained either
in a file or a data frame.
</p>
<p>If 'src' is a file name, the latter must be constituted of four columns
separated by spaces or 'TAB' characters: ID, time, reference and value. The
file might contain lines of comments which should start with a '#'
character. Note that the file should not contain a header line.
</p>
<p>Alternatively 'src' can be a data frame consisting of the columns named
&quot;id&quot;, &quot;time&quot;, &quot;ref&quot; and &quot;value&quot;. Note: &quot;ref&quot; column in the data frame is
optional.
</p>
<p>Adding to a logical track adds the values to the underlying physical
track, and is allowed only if all the values are within the logical
track allowed values and only from a data frame <code>src</code>. Note that
this might affect other logical tracks pointing to the same physical
track and therefore requires confirmation from the user unless
<code>force=TRUE</code>.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.import">emr_track.import</a></code>, <code><a href="#topic+emr_track.create">emr_track.create</a></code>,
<code><a href="#topic+emr_db.init">emr_db.init</a></code>, <code><a href="#topic+emr_track.ls">emr_track.ls</a></code>
</p>

<hr>
<h2 id='emr_track.attr.export'>Returns attributes values of tracks</h2><span id='topic+emr_track.attr.export'></span>

<h3>Description</h3>

<p>Returns attributes values of tracks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.attr.export(track = NULL, attr = NULL, include_missing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.attr.export_+3A_track">track</code></td>
<td>
<p>a vector of track names or 'NULL'</p>
</td></tr>
<tr><td><code id="emr_track.attr.export_+3A_attr">attr</code></td>
<td>
<p>a vector of attribute names or 'NULL'</p>
</td></tr>
<tr><td><code id="emr_track.attr.export_+3A_include_missing">include_missing</code></td>
<td>
<p>when TRUE - adds a row for tracks which do not have the 'attr' with NA,
or tracks which do not exist. Otherwise tracks without an attribute would be omitted from the data
frame, and an error would be thrown for tracks which do not exist.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a data frame that contains attributes values of one or
more tracks. The data frame is constituted of 3 columns named 'track',
'attr' and 'value'.
</p>
<p>'track' parameter is optionally used to retrieve only the attributes of the
specific track(s). If 'NULL', attributes of all the tracks are returned.
</p>
<p>Likewise 'attr' allows to retrieve only specifically named attributes.
</p>
<p>If both 'track' and 'attr' are used, the attributes that fulfill both of the
conditions are returned
</p>
<p>Overriding a track also overrides it's track attributes, the
attributes will persist when the track is no longer overridden.
</p>


<h3>Value</h3>

<p>A data frame containing attributes values of tracks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.attr.get">emr_track.attr.get</a></code>, <code><a href="#topic+emr_track.attr.set">emr_track.attr.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.attr.export()
emr_track.attr.set("sparse_track", "gender", "female")
emr_track.attr.set("sparse_track", "tag", "")
emr_track.attr.set("dense_track", "gender", "male")
emr_track.attr.export()
emr_track.attr.export(track = "sparse_track")
emr_track.attr.export(attr = "gender")
emr_track.attr.export(track = "sparse_track", attr = "gender")
</code></pre>

<hr>
<h2 id='emr_track.attr.get'>Returns the value of the track attribute</h2><span id='topic+emr_track.attr.get'></span>

<h3>Description</h3>

<p>Returns the value of the track attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.attr.get(track = NULL, attr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.attr.get_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="emr_track.attr.get_+3A_attr">attr</code></td>
<td>
<p>attribute name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of a track attribute or 'NULL' if the
attribute does not exist.
</p>


<h3>Value</h3>

<p>Track attribute value or 'NULL'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.attr.export">emr_track.attr.export</a></code>,
<code><a href="#topic+emr_track.attr.set">emr_track.attr.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.attr.set("sparse_track", "test_attr", "value")
emr_track.attr.get("sparse_track", "test_attr")
</code></pre>

<hr>
<h2 id='emr_track.attr.rm'>Deletes a track attribute</h2><span id='topic+emr_track.attr.rm'></span>

<h3>Description</h3>

<p>Deletes a track attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.attr.rm(track, attr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.attr.rm_+3A_track">track</code></td>
<td>
<p>one or more track names</p>
</td></tr>
<tr><td><code id="emr_track.attr.rm_+3A_attr">attr</code></td>
<td>
<p>attribute name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes a track attribute.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.attr.set">emr_track.attr.set</a></code>, <code><a href="#topic+emr_track.attr.get">emr_track.attr.get</a></code>,
<code><a href="#topic+emr_track.attr.export">emr_track.attr.export</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.attr.set("sparse_track", "test_attr", "value")
emr_track.attr.export()
emr_track.attr.rm("sparse_track", "test_attr")
emr_track.attr.export()
</code></pre>

<hr>
<h2 id='emr_track.attr.set'>Assigns a value to the track attribute</h2><span id='topic+emr_track.attr.set'></span>

<h3>Description</h3>

<p>Assigns a value to the track attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.attr.set(track, attr, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.attr.set_+3A_track">track</code></td>
<td>
<p>one or more track names</p>
</td></tr>
<tr><td><code id="emr_track.attr.set_+3A_attr">attr</code></td>
<td>
<p>one or more attribute names</p>
</td></tr>
<tr><td><code id="emr_track.attr.set_+3A_value">value</code></td>
<td>
<p>on or more values (strings). Can be an empty string (&rdquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a track attribute and assigns 'value' to it. If the
attribute already exists its value is overwritten.
</p>
<p>Note that both attributes and values should be in ASCII encoding.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.attr.get">emr_track.attr.get</a></code>, <code><a href="#topic+emr_track.attr.rm">emr_track.attr.rm</a></code>,
<code><a href="#topic+emr_track.attr.export">emr_track.attr.export</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.attr.set("sparse_track", "test_attr", "value")
emr_track.attr.get("sparse_track", "test_attr")
</code></pre>

<hr>
<h2 id='emr_track.create'>Creates a track from a track expression</h2><span id='topic+emr_track.create'></span>

<h3>Description</h3>

<p>Creates a track from a track expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.create(
  track,
  space,
  categorical,
  expr,
  stime = NULL,
  etime = NULL,
  iterator = NULL,
  keepref = FALSE,
  filter = NULL,
  override = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.create_+3A_track">track</code></td>
<td>
<p>the name of the newly created track</p>
</td></tr>
<tr><td><code id="emr_track.create_+3A_space">space</code></td>
<td>
<p>db path, one of the paths supplied in emr_db.connect</p>
</td></tr>
<tr><td><code id="emr_track.create_+3A_categorical">categorical</code></td>
<td>
<p>if 'TRUE' track is marked as categorical</p>
</td></tr>
<tr><td><code id="emr_track.create_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="emr_track.create_+3A_stime">stime</code></td>
<td>
<p>start time scope</p>
</td></tr>
<tr><td><code id="emr_track.create_+3A_etime">etime</code></td>
<td>
<p>end time scope</p>
</td></tr>
<tr><td><code id="emr_track.create_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions. See also 'iterator' section.</p>
</td></tr>
<tr><td><code id="emr_track.create_+3A_keepref">keepref</code></td>
<td>
<p>If 'TRUE' references are preserved in the iterator</p>
</td></tr>
<tr><td><code id="emr_track.create_+3A_filter">filter</code></td>
<td>
<p>Iterator filter</p>
</td></tr>
<tr><td><code id="emr_track.create_+3A_override">override</code></td>
<td>
<p>Boolean indicating whether the creation intends to override an existing track (default FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new track based on the values from
the track expression. The location of the track is controlled via 'space'
parameter which can be any of the db_dirs supplied in emr_db.connect
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>iterator</h3>

<p>There are a few types of iterators:
</p>

<dl>
<dt>Track iterator: </dt><dd><p>Track iterator returns the points (including the reference) from the specified track. Track name is specified as a string. If 'keepref=FALSE' the reference of each point is set to '-1' <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func=&quot;avg&quot;, time.shift=1) <br />
emr_extract(&quot;glucose&quot;, iterator=&quot;insulin_shot_track&quot;) <br />
</p>
</dd>
<dt>Id-Time Points Iterator: </dt><dd><p>Id-Time points iterator generates points from an *id-time points table*. If 'keepref=FALSE' the reference of each point is set to '-1'. <br />
Example: <br /> <br />
# Returns the level of glucose one hour after the insulin shot was made <br />
emr_vtrack.create(&quot;glucose&quot;, &quot;glucose_track&quot;, func = &quot;avg&quot;, time.shift = 1) <br />
r &lt;- emr_extract(&quot;insulin_shot_track&quot;) # &lt;&ndash; implicit iterator is used here <br />
emr_extract(&quot;glucose&quot;, iterator = r) <br />
</p>
</dd>
<dt>Ids Iterator: </dt><dd><p>Ids iterator generates points with ids taken from an *ids table* and times that run from 'stime' to 'etime' with a step of 1. If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.<br />
Example: <br /> <br />
stime &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime &lt;- emr_date2time(31, 12, 2016, 23) <br />
emr_extract(&quot;glucose&quot;, iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime)<br />
</p>
</dd>
<dt>Time Intervals Iterator: </dt><dd><p>*Time intervals iterator* generates points for all the ids that appear in 'patients.dob' track with times taken from a *time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'. <br />
Example: <br />
# Returns the level of hangover for all patients the next day after New Year Eve for the years 2015 and 2016 <br />
stime1 &lt;- emr_date2time(1, 1, 2015, 0) <br />
etime1 &lt;- emr_date2time(1, 1, 2015, 23) <br />
stime2 &lt;- emr_date2time(1, 1, 2016, 0) <br />
etime2 &lt;- emr_date2time(1, 1, 2016, 23) <br />
emr_extract(&quot;alcohol_level_track&quot;, iterator = data.frame( <br />
stime = c(stime1, stime2), <br />
etime = c(etime1, etime2) <br />
)) <br />
</p>
</dd>
<dt>Id-Time Intervals Iterator: </dt><dd><p>*Id-Time intervals iterator* generates for each id points that cover &lsquo;[&rsquo;stime', 'etime']' time range as specified in *id-time intervals table* (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of '[stime, etime]' range are skipped. <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'</p>
</dd>
<dt>Beat Iterator: </dt><dd><p>*Beat Iterator* generates a &quot;time beat&quot; at the given period for each id that appear in 'patients.dob' track. The period is given always in hours. <br />
Example: <br />
emr_extract(&quot;glucose_track&quot;, iterator=10, stime=1000, etime=2000) <br />
This will create a beat iterator with a period of 10 hours starting at 'stime' up until 'etime' is reached. If, for example, 'stime' equals '1000' then the beat iterator will create for each id iterator points at times: 1000, 1010, 1020, ... <br />
If 'keepref=TRUE' for each id-time pair the iterator generates 255 points with references running from '0' to '254'. If 'keepref=FALSE' only one point is generated for the given id and time, and its reference is set to '-1'.
</p>
</dd>
<dt>Extended Beat Iterator: </dt><dd><p>*Extended beat iterator* is as its name suggests a variation on the beat iterator. It works by the same principle of creating time points with the given period however instead of basing the times count on 'stime' it accepts an additional parameter - a track or a *Id-Time Points table* - that instructs what should be the initial time point for each of the ids. The two parameters (period and mapping) should come in a list. Each id is required to appear only once and if a certain id does not appear at all, it is skipped by the iterator. <br />
Anyhow points that lie outside of '[stime, etime]' range are not generated. <br />
Example: <br />
# Returns the maximal weight of patients at one year span starting from their birthdays <br />
emr_vtrack.create(&quot;weight&quot;, &quot;weight_track&quot;, func = &quot;max&quot;, time.shift = c(0, year())) <br />
emr_extract(&quot;weight&quot;, iterator = list(year(), &quot;birthday_track&quot;), stime = 1000, etime = 2000) <br />
</p>
</dd>
<dt>Periodic Iterator: </dt><dd><p>periodic iterator goes over every year/month. You can use it by running  <code>emr_monthly_iterator</code> or <code>emr_yearly_iterator</code>. <br />
Example: <br />
iter &lt;- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017)) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
iter &lt;- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15) <br />
emr_extract(&quot;dense_track&quot;, iterator = iter, stime = 1, etime = 3) <br />
</p>
</dd>
<dt>Implicit Iterator: </dt><dd><p>The iterator is set implicitly if its value remains 'NULL' (which is the default). In that case the track expression is analyzed and searched for track names. If all the track variables or virtual track variables point to the same track, this track is used as a source for a track iterator. If more then one track appears in the track expression, an error message is printed out notifying ambiguity.</p>
</dd>
</dl>

<p>Revealing Current Iterator Time:
During the evaluation of a track expression one can access a specially defined variable named 'EMR_TIME' (Python: 'TIME'). This variable contains a vector ('numpy.ndarray' in Python) of current iterator times. The length of the vector matches the length of the track variable (which is a vector too). <br />
Note that some values in 'EMR_TIME' might be set 0. Skip those intervals and the values of the track variables at the corresponding indices. <br />
# Returns times of the current iterator as a day of month <br />
emr_extract(&quot;emr_time2dayofmonth(EMR_TIME)&quot;, iterator = &quot;sparse_track&quot;) <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.import">emr_track.import</a></code>, <code><a href="#topic+emr_track.addto">emr_track.addto</a></code>,
<code><a href="#topic+emr_track.rm">emr_track.rm</a></code>, <code><a href="#topic+emr_track.readonly">emr_track.readonly</a></code>,
<code><a href="#topic+emr_track.ls">emr_track.ls</a></code>, <code><a href="#topic+emr_track.exists">emr_track.exists</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()

emr_track.create("new_dense_track", expr = "dense_track * 2", categorical = FALSE)
emr_extract("new_dense_track")

</code></pre>

<hr>
<h2 id='emr_track.dbs'>Returns a vector of db ids which have a
version of the track</h2><span id='topic+emr_track.dbs'></span><span id='topic+emr_track.current_db'></span>

<h3>Description</h3>

<p><code>emr_track.dbs</code> returns all the databases which have a version of the track,
while <code>emr_track.current_db</code> returns the database from which 'naryn' currently takes
the track according to the override rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.dbs(track, dataframe = FALSE)

emr_track.current_db(track, dataframe = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.dbs_+3A_track">track</code></td>
<td>
<p>one or more track names</p>
</td></tr>
<tr><td><code id="emr_track.dbs_+3A_dataframe">dataframe</code></td>
<td>
<p>return a data frame with with columns
called 'track' and 'db' instead of a vector of database ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of db ids for each track. If <code>dataframe</code> is TRUE - returns a data frame with columns
called 'track' and 'db' with the track and database ids (multiple rows per track in the case of
<code>emr_track.dbs</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.info">emr_track.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# both db1 and db2 have a track named 'categorical_track'
emr_db.init_examples(2)
emr_track.dbs("categorical_track")
emr_track.dbs(emr_track.ls())

emr_track.current_db("categorical_track")
emr_track.current_db(emr_track.ls())

</code></pre>

<hr>
<h2 id='emr_track.exists'>Checks whether the track exists</h2><span id='topic+emr_track.exists'></span>

<h3>Description</h3>

<p>Checks whether the track exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.exists(track, db_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.exists_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="emr_track.exists_+3A_db_id">db_id</code></td>
<td>
<p>string of a db dir passed to <code>emr_db.connect</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks whether the track exists.
If <code>db_id</code> is passed, the function checks
whether the track exists in the specific db.
</p>


<h3>Value</h3>

<p>'TRUE' if the tracks exists, otherwise 'FALSE'
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.ls">emr_track.ls</a></code>, <code><a href="#topic+emr_track.info">emr_track.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.exists("sparse_track")
</code></pre>

<hr>
<h2 id='emr_track.ids'>Returns track ids</h2><span id='topic+emr_track.ids'></span>

<h3>Description</h3>

<p>Returns the ids contained by the track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.ids(track)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.ids_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the ids contained by the track.
</p>
<p>Note: this function ignores the current subset, i.e. ids of the whole track
are returned.
</p>


<h3>Value</h3>

<p>An Ids Table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.unique">emr_track.unique</a></code>, <code><a href="#topic+emr_track.info">emr_track.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.ids("categorical_track")
</code></pre>

<hr>
<h2 id='emr_track.import'>Imports a track from a file or data-frame</h2><span id='topic+emr_track.import'></span>

<h3>Description</h3>

<p>Imports a track from a file or data-frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.import(
  track,
  space,
  categorical,
  src,
  override = FALSE,
  remove_unknown = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.import_+3A_track">track</code></td>
<td>
<p>the name of the newly created track</p>
</td></tr>
<tr><td><code id="emr_track.import_+3A_space">space</code></td>
<td>
<p>db dir string (path), one of the paths supplied in emr_db.connect</p>
</td></tr>
<tr><td><code id="emr_track.import_+3A_categorical">categorical</code></td>
<td>
<p>if 'TRUE' track is marked as categorical</p>
</td></tr>
<tr><td><code id="emr_track.import_+3A_src">src</code></td>
<td>
<p>file name or data-frame containing the track records</p>
</td></tr>
<tr><td><code id="emr_track.import_+3A_override">override</code></td>
<td>
<p>Boolean indicating whether the creation intends to override an existing track (default FALSE)</p>
</td></tr>
<tr><td><code id="emr_track.import_+3A_remove_unknown">remove_unknown</code></td>
<td>
<p>if 'TRUE', removes unknown ids (ids that are not present at 'patients.dob' track) from the data. Otherwise, an error is thrown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new track from a text file or a data-frame.
The location of the track is controlled via 'space' parameter which
can be any of the db_dirs supplied in emr_db.connect.
</p>
<p>If 'src' is a file name, the latter must be constituted of four columns
separated by spaces or 'TAB' characters: ID, time, reference and value. The
file might contain lines of comments which should start with a '#'
character.
</p>
<p>Alternatively 'src' can be an ID-Time Values table, which is a data frame with
the following columns: &quot;id&quot; &quot;time&quot; &quot;ref&quot; and &quot;value&quot;. Note that the
file should not contain a header.
</p>
<p>(see &quot;User Manual&quot; for more info).
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.addto">emr_track.addto</a></code>, <code><a href="#topic+emr_track.create">emr_track.create</a></code>,
<code><a href="#topic+emr_track.readonly">emr_track.readonly</a></code>, <code><a href="#topic+emr_db.init">emr_db.init</a></code>,
<code><a href="#topic+emr_track.ls">emr_track.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()

# import from data frame
emr_track.import(
    "new_track",
    categorical = TRUE,
    src = data.frame(id = c(5, 10), time = c(1, 2), value = c(10, 20))
)

# import from file
fn &lt;- tempfile()
write.table(
    data.frame(id = c(5, 10), time = c(1, 2), reference = c(1, 1), value = c(10, 20)),
    file = fn, sep = "\t", row.names = FALSE, col.names = FALSE
)
emr_track.import("new_track1", categorical = TRUE, src = fn)

# create an empty track
emr_track.import(
    "empty_track",
    categorical = TRUE,
    src = data.frame(id = numeric(), time = numeric(), value = numeric())
)

</code></pre>

<hr>
<h2 id='emr_track.info'>Returns information about the track.</h2><span id='topic+emr_track.info'></span>

<h3>Description</h3>

<p>This function returns information about the track: type, data type, number
of vales, number of unique values, minimal / maximal value, minimal /
maximal id, minimal / maximal time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.info(track)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.info_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: this function ignores the current subset, i.e. it is applied to the
whole track.
</p>


<h3>Value</h3>

<p>A list that contains track properties
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.ls">emr_track.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.info("sparse_track")
</code></pre>

<hr>
<h2 id='emr_track.logical.create'>Creates a logical track</h2><span id='topic+emr_track.logical.create'></span>

<h3>Description</h3>

<p>Creates a logical track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.logical.create(track, src, values = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.logical.create_+3A_track">track</code></td>
<td>
<p>one or more names of the newly created logical tracks.</p>
</td></tr>
<tr><td><code id="emr_track.logical.create_+3A_src">src</code></td>
<td>
<p>name of the physical tracks for each logical <code>track</code></p>
</td></tr>
<tr><td><code id="emr_track.logical.create_+3A_values">values</code></td>
<td>
<p>vector of selected values. When creating multiple logical tracks at once
- <code>values</code> should be a list of vectors (with one vector of values for each logical track).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a logical track based on an existing categorical track
in the global space.
</p>
<p>Note: Both the logical track and source should be on the global db. If the logical track
would be created and afterwards the db would be loaded as non-global db the logical tracks
would **not** be visible.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_track.logical.create("logical_track_example", "categorical_track", values = c(2, 3))

# multiple tracks
emr_track.logical.create(
    c("logical_track1", "logical_track2", "logical_track3"),
    rep("categorical_track", 3),
    values = list(c(2, 3), NULL, c(1, 4))
)


</code></pre>

<hr>
<h2 id='emr_track.logical.exists'>Is a track logical</h2><span id='topic+emr_track.logical.exists'></span>

<h3>Description</h3>

<p>Is a track logical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.logical.exists(track)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.logical.exists_+3A_track">track</code></td>
<td>
<p>of the track</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if <code>track</code> is a logical track and FALSE otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_track.logical.exists("logical_track")

</code></pre>

<hr>
<h2 id='emr_track.logical.info'>Returns information about a logical track</h2><span id='topic+emr_track.logical.info'></span>

<h3>Description</h3>

<p>Returns information about a logical track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.logical.info(track)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.logical.info_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the source and values of a logical track
</p>


<h3>Value</h3>

<p>A list that contains <code>source</code> - the source of the logical track, and <code>values</code>: the values of the logical track.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.ls">emr_track.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emr_db.init_examples()
emr_track.logical.info("logical_track")

</code></pre>

<hr>
<h2 id='emr_track.logical.rm'>Deletes a logical track</h2><span id='topic+emr_track.logical.rm'></span>

<h3>Description</h3>

<p>Deletes a logical track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.logical.rm(track, force = FALSE, rm_vars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.logical.rm_+3A_track">track</code></td>
<td>
<p>the name of one or more tracks to delete</p>
</td></tr>
<tr><td><code id="emr_track.logical.rm_+3A_force">force</code></td>
<td>
<p>if 'TRUE', suppresses user confirmation of a named track removal</p>
</td></tr>
<tr><td><code id="emr_track.logical.rm_+3A_rm_vars">rm_vars</code></td>
<td>
<p>remove track variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='emr_track.ls'>Returns a list of track names</h2><span id='topic+emr_track.ls'></span><span id='topic+emr_track.global.ls'></span><span id='topic+emr_track.user.ls'></span><span id='topic+emr_track.logical.ls'></span>

<h3>Description</h3>

<p>Returns a list of track names in the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.ls(
  ...,
  db_id = NULL,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)

emr_track.global.ls(
  ...,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)

emr_track.user.ls(
  ...,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)

emr_track.logical.ls(
  ...,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.ls_+3A_...">...</code></td>
<td>
<p>these arguments are of either form 'pattern' or 'attribute =
pattern'</p>
</td></tr>
<tr><td><code id="emr_track.ls_+3A_db_id">db_id</code></td>
<td>
<p>db dir string (path), one of the paths supplied in emr_db.connect. If NULL - all track names would be
returned.</p>
</td></tr>
<tr><td><code id="emr_track.ls_+3A_ignore.case">ignore.case</code>, <code id="emr_track.ls_+3A_perl">perl</code>, <code id="emr_track.ls_+3A_fixed">fixed</code>, <code id="emr_track.ls_+3A_usebytes">useBytes</code></td>
<td>
<p>see 'grep'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'emr_track.ls' returns a list of all tracks (global and user) in the
database that match the pattern (see 'grep'). If called without any
arguments all tracks are returned.
</p>
<p>If pattern is specified without a track attribute (i.e. in the form of
'pattern') then filtering is applied to the track names. If pattern is
supplied with a track attribute (i.e. in the form of 'name = pattern') then
track attribute is matched against the pattern.
</p>
<p>Multiple patterns are applied one after another. The resulted list of tracks
should match all the patterns.
</p>
<p>If <code>db_id</code> parameter is set, only tracks within the specific db would be shown.
Note that tracks which were overridden by other databases would not be shown, even if
their files exist within the database. See <code>emr_db.connect</code> for more details.
</p>
<p>'emr_track.global.ls', 'emr_track.user.ls', 'emr_track.logical.ls' work similarly to
'emr_track.ls' but instead of returning all track names, each of them
returns either global, local or logical tracks accordingly.
</p>


<h3>Value</h3>

<p>An array that contains the names of tracks that match the supplied
patterns.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+emr_db.init">emr_db.init</a></code>,
<code><a href="#topic+emr_track.exists">emr_track.exists</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()

# get all track names
emr_track.ls()

# get track names that match the pattern "den*"
emr_track.ls("den*")

emr_track.attr.set("sparse_track", "gender", "female")
emr_track.attr.set("dense_track", "gender", "male")
emr_track.ls(gender = "")
emr_track.ls(gender = "female")
emr_track.ls(gender = "^male")
</code></pre>

<hr>
<h2 id='emr_track.mv'>Moves (renames) a track</h2><span id='topic+emr_track.mv'></span>

<h3>Description</h3>

<p>Moves (renames) a track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.mv(src, tgt, space = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.mv_+3A_src">src</code></td>
<td>
<p>source track name</p>
</td></tr>
<tr><td><code id="emr_track.mv_+3A_tgt">tgt</code></td>
<td>
<p>target track name</p>
</td></tr>
<tr><td><code id="emr_track.mv_+3A_space">space</code></td>
<td>
<p>db path (string), one of the paths supplied in emr_db.connect or NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function moves (renames) 'src' track into 'tgt'. If 'space' equals
'NULL', the track remains in the same space. Otherwise it is moved
to the specified space.
</p>
<p>Note that logical tracks cannot be moved to the user space.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.create">emr_track.create</a></code>, <code><a href="#topic+emr_track.rm">emr_track.rm</a></code>,
<code><a href="#topic+emr_track.ls">emr_track.ls</a></code>
</p>

<hr>
<h2 id='emr_track.percentile'>Returns track percentile of the values</h2><span id='topic+emr_track.percentile'></span>

<h3>Description</h3>

<p>Returns track percentile of the values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.percentile(track, val, lower = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.percentile_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="emr_track.percentile_+3A_val">val</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="emr_track.percentile_+3A_lower">lower</code></td>
<td>
<p>how to calculate percentiles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the percentiles of the values given in 'val' based on
track data.
</p>
<p>If 'lower' is 'TRUE' percentile indicates the relative number of track
values lower than 'val'. If 'lower' is 'FALSE' percentile reflects the
relative number of track values lower or equal than 'val'.
</p>


<h3>Value</h3>

<p>A vector of percentile values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.unique">emr_track.unique</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()

# percentiles of 30, 50
emr_track.percentile("dense_track", c(30, 50))

# calculate percentiles of track's earliest values in time window
emr_vtrack.create("v1",
    src = "dense_track", func = "earliest",
    time.shift = c(-5, 5)
)
emr_extract(
    c(
        "dense_track",
        "emr_track.percentile(\"dense_track\", v1, FALSE)"
    ),
    keepref = TRUE, names = c("col1", "col2")
)
</code></pre>

<hr>
<h2 id='emr_track.readonly'>Gets or sets &quot;read-only&quot; property of a track</h2><span id='topic+emr_track.readonly'></span>

<h3>Description</h3>

<p>Gets or sets &quot;readonly&quot; property of a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.readonly(track, readonly = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.readonly_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="emr_track.readonly_+3A_readonly">readonly</code></td>
<td>
<p>if 'NULL', return &quot;readonlyness&quot; of the track, otherwise
sets it</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gets or sets &quot;readonly-ness&quot; of the track. If 'readonly' is
'NULL' the functions returns whether the track is R/O. Otherwise it sets
&quot;readonly-ness&quot; to the value indicated by 'readonly'.
</p>
<p>Logical tracks inherit their &quot;readonly-ness&quot; from the source
physical tracks.
</p>
<p>Overriding a track also overrides it's &quot;readonly-ness&quot;, it's
&quot;readonly-ness&quot; will persist when the track is no longer overridden
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.create">emr_track.create</a></code>, <code><a href="#topic+emr_track.mv">emr_track.mv</a></code>,
<code><a href="#topic+emr_track.ls">emr_track.ls</a></code>, <code><a href="#topic+emr_track.rm">emr_track.rm</a></code>
</p>

<hr>
<h2 id='emr_track.rm'>Deletes a track</h2><span id='topic+emr_track.rm'></span>

<h3>Description</h3>

<p>Deletes a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.rm(track, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.rm_+3A_track">track</code></td>
<td>
<p>one or more track names to delete</p>
</td></tr>
<tr><td><code id="emr_track.rm_+3A_force">force</code></td>
<td>
<p>if 'TRUE', suppresses user confirmation of a named track removal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes a user track from the database. By default
'emr_track.rm' requires the user to interactively confirm the deletion. Set
'force' to 'TRUE' to suppress the user prompt.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.create">emr_track.create</a></code>, <code><a href="#topic+emr_track.mv">emr_track.mv</a></code>,
<code><a href="#topic+emr_track.ls">emr_track.ls</a></code>, <code><a href="#topic+emr_track.readonly">emr_track.readonly</a></code>
</p>

<hr>
<h2 id='emr_track.unique'>Returns track values</h2><span id='topic+emr_track.unique'></span>

<h3>Description</h3>

<p>Returns unique and sorted track values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.unique(track)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.unique_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns unique and sorted track values. NaN values (if exist in the track)
are not returned.
</p>
<p>Note: this function ignores the current subset, i.e. the unique values of
the whole track are returned.
</p>


<h3>Value</h3>

<p>A vector of values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.ids">emr_track.ids</a></code>, <code><a href="#topic+emr_track.info">emr_track.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.unique("categorical_track")
</code></pre>

<hr>
<h2 id='emr_track.var.get'>Returns value of a track variable</h2><span id='topic+emr_track.var.get'></span>

<h3>Description</h3>

<p>Returns value of a track variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.var.get(track, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.var.get_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="emr_track.var.get_+3A_var">var</code></td>
<td>
<p>track variable name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of a track variable. If the variable does
not exist NULL is returned.
</p>


<h3>Value</h3>

<p>Track variable value. If the variable does not exists, NULL is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.var.set">emr_track.var.set</a></code>, <code><a href="#topic+emr_track.var.ls">emr_track.var.ls</a></code>,
<code><a href="#topic+emr_track.var.rm">emr_track.var.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.var.set("sparse_track", "test_var", 1:10)
emr_track.var.get("sparse_track", "test_var")
emr_track.var.rm("sparse_track", "test_var")
</code></pre>

<hr>
<h2 id='emr_track.var.ls'>Returns a list of track variables for a track</h2><span id='topic+emr_track.var.ls'></span>

<h3>Description</h3>

<p>Returns a list of track variables for a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.var.ls(
  track,
  pattern = "",
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.var.ls_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="emr_track.var.ls_+3A_pattern">pattern</code>, <code id="emr_track.var.ls_+3A_ignore.case">ignore.case</code>, <code id="emr_track.var.ls_+3A_perl">perl</code>, <code id="emr_track.var.ls_+3A_fixed">fixed</code>, <code id="emr_track.var.ls_+3A_usebytes">useBytes</code></td>
<td>
<p>see 'grep'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list of track variables of a track that match the
pattern (see 'grep'). If called without any arguments all track variables of
a track are returned.
</p>
<p>Overriding a track also overrides it's track variables, the
variables will persist when the track is no longer overridden
</p>


<h3>Value</h3>

<p>An array that contains the names of track variables.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+emr_track.var.get">emr_track.var.get</a></code>,
<code><a href="#topic+emr_track.var.set">emr_track.var.set</a></code>, <code><a href="#topic+emr_track.var.rm">emr_track.var.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.var.ls("sparse_track")
emr_track.var.set("sparse_track", "test_var1", 1:10)
emr_track.var.set("sparse_track", "test_var2", "v")
emr_track.var.ls("sparse_track")
emr_track.var.ls("sparse_track", pattern = "2")
emr_track.var.rm("sparse_track", "test_var1")
emr_track.var.rm("sparse_track", "test_var2")
</code></pre>

<hr>
<h2 id='emr_track.var.rm'>Deletes a track variable</h2><span id='topic+emr_track.var.rm'></span>

<h3>Description</h3>

<p>Deletes a track variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.var.rm(track, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.var.rm_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="emr_track.var.rm_+3A_var">var</code></td>
<td>
<p>track variable name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes a track variable.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.var.get">emr_track.var.get</a></code>, <code><a href="#topic+emr_track.var.set">emr_track.var.set</a></code>,
<code><a href="#topic+emr_track.var.ls">emr_track.var.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.var.set("sparse_track", "test_var1", 1:10)
emr_track.var.set("sparse_track", "test_var2", "v")
emr_track.var.ls("sparse_track")
emr_track.var.rm("sparse_track", "test_var1")
emr_track.var.rm("sparse_track", "test_var2")
emr_track.var.ls("sparse_track")
</code></pre>

<hr>
<h2 id='emr_track.var.set'>Assigns value to a track variable</h2><span id='topic+emr_track.var.set'></span>

<h3>Description</h3>

<p>Assigns value to a track variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_track.var.set(track, var, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_track.var.set_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="emr_track.var.set_+3A_var">var</code></td>
<td>
<p>track variable name</p>
</td></tr>
<tr><td><code id="emr_track.var.set_+3A_value">value</code></td>
<td>
<p>value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a track variable and assigns 'value' to it. If the
track variable already exists its value is overwritten.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_track.var.get">emr_track.var.get</a></code>, <code><a href="#topic+emr_track.var.ls">emr_track.var.ls</a></code>,
<code><a href="#topic+emr_track.var.rm">emr_track.var.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_track.var.set("sparse_track", "test_var", 1:10)
emr_track.var.get("sparse_track", "test_var")
emr_track.var.rm("sparse_track", "test_var")
</code></pre>

<hr>
<h2 id='emr_vtrack.attr.src'>Get or set attributes of a virtual track</h2><span id='topic+emr_vtrack.attr.src'></span><span id='topic+emr_vtrack.attr.func'></span><span id='topic+emr_vtrack.attr.params'></span><span id='topic+emr_vtrack.attr.keepref'></span><span id='topic+emr_vtrack.attr.time.shift'></span><span id='topic+emr_vtrack.attr.id.map'></span><span id='topic+emr_vtrack.attr.filter'></span>

<h3>Description</h3>

<p>Get or set attributes of a virtual track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_vtrack.attr.src(vtrack, src)

emr_vtrack.attr.func(vtrack, func)

emr_vtrack.attr.params(vtrack, params)

emr_vtrack.attr.keepref(vtrack, keepref)

emr_vtrack.attr.time.shift(vtrack, time.shift)

emr_vtrack.attr.id.map(vtrack, id.map)

emr_vtrack.attr.filter(vtrack, filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_vtrack.attr.src_+3A_vtrack">vtrack</code></td>
<td>
<p>virtual track name.</p>
</td></tr>
<tr><td><code id="emr_vtrack.attr.src_+3A_src">src</code>, <code id="emr_vtrack.attr.src_+3A_func">func</code>, <code id="emr_vtrack.attr.src_+3A_params">params</code>, <code id="emr_vtrack.attr.src_+3A_keepref">keepref</code>, <code id="emr_vtrack.attr.src_+3A_time.shift">time.shift</code>, <code id="emr_vtrack.attr.src_+3A_id.map">id.map</code>, <code id="emr_vtrack.attr.src_+3A_filter">filter</code></td>
<td>
<p>virtual track
attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When only 'vtrack' argument is used in the call, the functions return the
corresponding attribute of the virtual track. Otherwise a new attribute
value is set.
</p>
<p>Note: since inter-dependency exists between certain attributes, the
correctness of the attributes as a whole can only be verified when the
virtual track is used in a track expression.
</p>
<p>For more information about the valid attribute values please refer to the
documentation of 'emr_vtrack.create'.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_vtrack.create">emr_vtrack.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_vtrack.create("vtrack1", "dense_track")
emr_vtrack.attr.src("vtrack1")
emr_vtrack.attr.src("vtrack1", "sparse_track")
emr_vtrack.attr.src("vtrack1")
</code></pre>

<hr>
<h2 id='emr_vtrack.clear'>Clear all virtual tracks from the current environment</h2><span id='topic+emr_vtrack.clear'></span>

<h3>Description</h3>

<p>Clear all virtual tracks from the current environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_vtrack.clear()
</code></pre>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_vtrack.create("vtrack1", "dense_track")
emr_vtrack.ls()
emr_vtrack.clear()
emr_vtrack.ls()
</code></pre>

<hr>
<h2 id='emr_vtrack.create'>Creates a new virtual track</h2><span id='topic+emr_vtrack.create'></span>

<h3>Description</h3>

<p>Creates a new virtual track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_vtrack.create(
  vtrack,
  src,
  func = NULL,
  params = NULL,
  keepref = FALSE,
  time.shift = NULL,
  id.map = NULL,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_vtrack.create_+3A_vtrack">vtrack</code></td>
<td>
<p>virtual track name. If 'NULL' is used, a unique name is generated.</p>
</td></tr>
<tr><td><code id="emr_vtrack.create_+3A_src">src</code></td>
<td>
<p>data source. either a track name or a list of two members: ID-Time Values table (see &quot;User
Manual&quot;) and a logical. If the logical is 'TRUE', the data in the table is treated as categorical, otherwise as quantitative.</p>
</td></tr>
<tr><td><code id="emr_vtrack.create_+3A_func">func</code>, <code id="emr_vtrack.create_+3A_params">params</code></td>
<td>
<p>see below.</p>
</td></tr>
<tr><td><code id="emr_vtrack.create_+3A_keepref">keepref</code></td>
<td>
<p>see below.</p>
</td></tr>
<tr><td><code id="emr_vtrack.create_+3A_time.shift">time.shift</code></td>
<td>
<p>time shift and expansion for iterator time.</p>
</td></tr>
<tr><td><code id="emr_vtrack.create_+3A_id.map">id.map</code></td>
<td>
<p>id mapping.</p>
</td></tr>
<tr><td><code id="emr_vtrack.create_+3A_filter">filter</code></td>
<td>
<p>virtual track filter. Note that filters with a source of another virtual track are not allowed in order to avoid loops.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new virtual track named 'vtrack'.
</p>
<p>During the evaluation of track expression that contains a virtual track
'vtrack' the iterator point of id-time (ID1, Time, Ref) form is transformed
first to an id-time interval: (ID2, Time1, Time2, Ref).
</p>
<p>If 'id.map' is 'NULL' then ID1 == ID2, otherwise ID2 is derived from the
translation table provided in 'id.map'. This table is a data frame with two
first columns named 'id1' and 'id2', where 'id1' is mapped to 'id2'. If
'id.map' contains also a third optional column named 'time.shift' the value
V of this column is used to shift the time accordingly, i.e. Time1 = Time2 =
Time + V.
</p>
<p>'time.shift' parameter (not to be confused with 'time.shift' column of
'id.map') can be either a single number X, in which case Time1 = Time2 =
Time + X. Alternatively 'time.shift' can be a vector of two numbers, i.e.
'c(X1, X2)', which would result in Time1 = Time + X1, Time2 = Time + X2.
</p>
<p>Both 'time.shift' parameter and 'time.shift' column within 'id.map' may be
used simultaneously. In this case the time shifts are applied sequentially.
</p>
<p>At the next step values from the data source 'src' that fall into the new
id-time interval and pass the 'filter' are collected. 'src' may be either a
track name or a list of two members: ID-Time Values table (see &quot;User
Manual&quot;) and a logical. If the logical is 'TRUE', the data in the table is
treated as categorical, otherwise as quantitative.
</p>
<p>If 'keepref' is 'TRUE' the reference of these values must match 'ref' unless
either the reference or 'ref' are '-1'.
</p>
<p>Function 'func' (with 'params') is applied then on the collected values and
produces a single value which is considered to be the value of 'vtrack' for
the given iterator point. If 'NULL' is used as a value for 'func', 'func' is
set then implicitly to 'value', if the data source is categorical, or 'avg',
if the data source is quantitative.
</p>
<p>Use the following table for a reference of all valid functions and
parameters combinations.
</p>
<p>CATEGORICAL DATA SOURCE
</p>

<table>
<tr>
 <td style="text-align: left;"> FUNC </td><td style="text-align: left;"> PARAM </td><td style="text-align: left;"> DESCRIPTION </td>
</tr>
<tr>
 <td style="text-align: left;"> value </td><td style="text-align: left;"> vals/NULL
</td><td style="text-align: left;"> A source value or -1 if there is more than one. </td>
</tr>
<tr>
 <td style="text-align: left;"> exists </td><td style="text-align: left;"> vals
</td><td style="text-align: left;"> 1 if any of the 'vals' exist otherwise 0. </td>
</tr>
<tr>
 <td style="text-align: left;"> sample </td><td style="text-align: left;"> NULL </td><td style="text-align: left;">
Uniformly sampled source value. </td>
</tr>
<tr>
 <td style="text-align: left;"> sample.time </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Time of the
uniformly sampled source value. </td>
</tr>
<tr>
 <td style="text-align: left;"> frequent </td><td style="text-align: left;"> vals/NULL </td><td style="text-align: left;"> The most
frequent source value or -1 if there is more than one value. </td>
</tr>
<tr>
 <td style="text-align: left;"> size </td><td style="text-align: left;">
vals/NULL </td><td style="text-align: left;"> Number of values. </td>
</tr>
<tr>
 <td style="text-align: left;"> earliest </td><td style="text-align: left;"> vals/NULL </td><td style="text-align: left;"> Earliest
value or -1 if there is more than one. </td>
</tr>
<tr>
 <td style="text-align: left;"> latest </td><td style="text-align: left;"> vals/NULL </td><td style="text-align: left;"> Latest
value or -1 if there is more than one. </td>
</tr>
<tr>
 <td style="text-align: left;"> closest </td><td style="text-align: left;"> vals/NULL </td><td style="text-align: left;">
Values closest to the middle of the interval or -1 if there is more than
one. </td>
</tr>
<tr>
 <td style="text-align: left;"> earliest.time </td><td style="text-align: left;"> vals/NULL </td><td style="text-align: left;"> Time of the earliest value. </td>
</tr>
<tr>
 <td style="text-align: left;">
latest.time </td><td style="text-align: left;"> vals/NULL </td><td style="text-align: left;"> Time of the latest value. </td>
</tr>
<tr>
 <td style="text-align: left;">
closest.earlier.time </td><td style="text-align: left;"> vals/NULL </td><td style="text-align: left;"> Time of the of the earlier of the
closest values. </td>
</tr>
<tr>
 <td style="text-align: left;"> closest.later.time </td><td style="text-align: left;"> vals/NULL </td><td style="text-align: left;"> Time of the of
the later of the closest values. </td>
</tr>
<tr>
 <td style="text-align: left;"> dt1.earliest </td><td style="text-align: left;"> vals/NULL </td><td style="text-align: left;"> Time
difference between the earliest value and T1 </td>
</tr>
<tr>
 <td style="text-align: left;"> dt1.latest </td><td style="text-align: left;"> vals/NULL
</td><td style="text-align: left;"> Time difference between the latest value and T1 </td>
</tr>
<tr>
 <td style="text-align: left;"> dt2.earliest </td><td style="text-align: left;">
vals/NULL </td><td style="text-align: left;"> Time difference between T2 and the earliest value </td>
</tr>
<tr>
 <td style="text-align: left;">
dt2.latest </td><td style="text-align: left;"> vals/NULL </td><td style="text-align: left;"> Time difference between T2 and the latest
value </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>* 'vals' is a vector of values. If not 'NULL' it serves as a filter: the
function is applied only to the data source values that appear among 'vals'.
'vals' can be a single NA value, in which case all the values of the track
would be filtered out.
</p>
<p>QUANTITATIVE DATA SOURCE
</p>

<table>
<tr>
 <td style="text-align: left;"> FUNC </td><td style="text-align: left;"> PARAM </td><td style="text-align: left;"> DESCRIPTION </td>
</tr>
<tr>
 <td style="text-align: left;"> avg </td><td style="text-align: left;"> NULL </td><td style="text-align: left;">
Average of all values. </td>
</tr>
<tr>
 <td style="text-align: left;"> min </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Minimal value. </td>
</tr>
<tr>
 <td style="text-align: left;"> max </td><td style="text-align: left;">
NULL </td><td style="text-align: left;"> Maximal value. </td>
</tr>
<tr>
 <td style="text-align: left;"> sample </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Uniformly sampled source
value. </td>
</tr>
<tr>
 <td style="text-align: left;"> sample.time </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Time of the uniformly sampled source
value. </td>
</tr>
<tr>
 <td style="text-align: left;"> size </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Number of values. </td>
</tr>
<tr>
 <td style="text-align: left;"> earliest </td><td style="text-align: left;"> NULL </td><td style="text-align: left;">
Average of the earliest values. </td>
</tr>
<tr>
 <td style="text-align: left;"> latest </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Average of the
latest values. </td>
</tr>
<tr>
 <td style="text-align: left;"> closest </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Average of values closest to the
middle of the interval. </td>
</tr>
<tr>
 <td style="text-align: left;"> stddev </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Unbiased standard
deviation of the values. </td>
</tr>
<tr>
 <td style="text-align: left;"> sum </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Sum of values. </td>
</tr>
<tr>
 <td style="text-align: left;"> quantile
</td><td style="text-align: left;"> Percentile in the range of [0, 1] </td><td style="text-align: left;"> Quantile of the values. </td>
</tr>
<tr>
 <td style="text-align: left;">
percentile.upper </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Average of upper-bound values percentiles.*
</td>
</tr>
<tr>
 <td style="text-align: left;"> percentile.upper.min </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Minimum of upper-bound values
percentiles.* </td>
</tr>
<tr>
 <td style="text-align: left;"> percentile.upper.max </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Maximum of upper-bound
values percentiles.* </td>
</tr>
<tr>
 <td style="text-align: left;"> percentile.lower </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Average of
lower-bound values percentiles.* </td>
</tr>
<tr>
 <td style="text-align: left;"> percentile.lower.min </td><td style="text-align: left;"> NULL </td><td style="text-align: left;">
Minimum of lower-bound values percentiles.* </td>
</tr>
<tr>
 <td style="text-align: left;"> percentile.lower.max </td><td style="text-align: left;">
NULL </td><td style="text-align: left;"> Maximum of lower-bound values percentiles.* </td>
</tr>
<tr>
 <td style="text-align: left;"> lm.intercept </td><td style="text-align: left;">
NULL </td><td style="text-align: left;"> Intercept (aka "alpha") of the simple linear regression (X = time,
Y = values)</td>
</tr>
<tr>
 <td style="text-align: left;"> lm.slope </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Slope (aka "beta") of the simple
linear regression (X = time, Y = values)</td>
</tr>
<tr>
 <td style="text-align: left;"> earliest.time </td><td style="text-align: left;"> NULL </td><td style="text-align: left;">
Time of the earliest value. </td>
</tr>
<tr>
 <td style="text-align: left;"> latest.time </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Time of the
latest value. </td>
</tr>
<tr>
 <td style="text-align: left;"> closest.earlier.time </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Time of the of the
earlier of the closest values. </td>
</tr>
<tr>
 <td style="text-align: left;"> closest.later.time </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Time of
the of the later of the closest values. </td>
</tr>
<tr>
 <td style="text-align: left;"> dt1.earliest </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Time
difference between the earliest value and T1 </td>
</tr>
<tr>
 <td style="text-align: left;"> dt1.latest </td><td style="text-align: left;"> NULL </td><td style="text-align: left;">
Time difference between the latest value and T1 </td>
</tr>
<tr>
 <td style="text-align: left;"> dt2.earliest </td><td style="text-align: left;"> NULL
</td><td style="text-align: left;"> Time difference between T2 and the earliest value </td>
</tr>
<tr>
 <td style="text-align: left;"> dt2.latest </td><td style="text-align: left;">
NULL </td><td style="text-align: left;"> Time difference between T2 and the latest value </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>* Percentile is calculated based on the values of the whole data source even
if a subset or a filter are defined.
</p>
<p>Note: 'time.shift' can be used only when 'keepref' is 'FALSE'. Also when
'keepref' is 'TRUE' only 'avg', 'percentile.upper' and 'percentile.lower'
can be used in 'func'.
</p>


<h3>Value</h3>

<p>Name of the virtual track (invisibly)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_vtrack.attr.src">emr_vtrack.attr.src</a></code>, <code><a href="#topic+emr_vtrack.ls">emr_vtrack.ls</a></code>,
<code><a href="#topic+emr_vtrack.exists">emr_vtrack.exists</a></code>, <code><a href="#topic+emr_vtrack.rm">emr_vtrack.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()

emr_vtrack.create("vtrack1", "dense_track",
    time.shift = 1,
    func = "max"
)
emr_vtrack.create("vtrack2", "dense_track",
    time.shift = c(-5, 10), func = "min"
)
res &lt;- emr_extract("dense_track", keepref = TRUE, names = "value")
emr_vtrack.create("vtrack3", list(res, FALSE),
    time.shift = c(-5, 10),
    func = "min"
)
emr_extract(c("dense_track", "vtrack1", "vtrack2", "vtrack3"),
    keepref = TRUE, iterator = "dense_track"
)
</code></pre>

<hr>
<h2 id='emr_vtrack.create_from_name'>Create a virtual track from an automatically generated name</h2><span id='topic+emr_vtrack.create_from_name'></span>

<h3>Description</h3>

<p>Create a virtual track from an automatically generated name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_vtrack.create_from_name(vtrack_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_vtrack.create_from_name_+3A_vtrack_name">vtrack_name</code></td>
<td>
<p>name of a virtual track automatically generated by <code>emr_vtrack.name</code>. Can be a vector of virtual track names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>emr_vtrack</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_vtrack.create">emr_vtrack.create</a></code>, <code><a href="#topic+emr_vtrack.name">emr_vtrack.name</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_filter.create("f_dense_track", "dense_track", time.shift = c(2, 4))

name &lt;- emr_vtrack.name("dense_track",
    time.shift = 1,
    func = "max",
    filter = "f_dense_track"
)

emr_vtrack.create_from_name(name)
</code></pre>

<hr>
<h2 id='emr_vtrack.exists'>Checks whether the virtual track exists</h2><span id='topic+emr_vtrack.exists'></span>

<h3>Description</h3>

<p>Checks whether the virtual track exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_vtrack.exists(vtrack)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_vtrack.exists_+3A_vtrack">vtrack</code></td>
<td>
<p>virtual track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks whether the virtual track exists.
</p>


<h3>Value</h3>

<p>'TRUE' if the virtual track exists, otherwise 'FALSE'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_vtrack.create">emr_vtrack.create</a></code>, <code><a href="#topic+emr_vtrack.ls">emr_vtrack.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_vtrack.create("vtrack1", "dense_track", time.shift = c(5, 10), func = "max")
emr_vtrack.exists("vtrack1")
</code></pre>

<hr>
<h2 id='emr_vtrack.info'>Returns the definition of a virtual track</h2><span id='topic+emr_vtrack.info'></span>

<h3>Description</h3>

<p>Returns the definition of a virtual track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_vtrack.info(vtrack)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_vtrack.info_+3A_vtrack">vtrack</code></td>
<td>
<p>virtual track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the internal representation of a virtual track.
</p>


<h3>Value</h3>

<p>Internal representation of a virtual track.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_vtrack.create">emr_vtrack.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_vtrack.create("vtrack1", "dense_track", "max", time.shift = c(5, 10))
emr_vtrack.info("vtrack1")
</code></pre>

<hr>
<h2 id='emr_vtrack.ls'>Returns a list of virtual track names</h2><span id='topic+emr_vtrack.ls'></span>

<h3>Description</h3>

<p>Returns a list of virtual track names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_vtrack.ls(
  pattern = "",
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_vtrack.ls_+3A_pattern">pattern</code>, <code id="emr_vtrack.ls_+3A_ignore.case">ignore.case</code>, <code id="emr_vtrack.ls_+3A_perl">perl</code>, <code id="emr_vtrack.ls_+3A_fixed">fixed</code>, <code id="emr_vtrack.ls_+3A_usebytes">useBytes</code></td>
<td>
<p>see 'grep'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list of virtual tracks that exist in current R
environment that match the pattern (see 'grep'). If called without any
arguments all virtual tracks are returned.
</p>


<h3>Value</h3>

<p>An array that contains the names of virtual tracks.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+emr_vtrack.exists">emr_vtrack.exists</a></code>,
<code><a href="#topic+emr_vtrack.create">emr_vtrack.create</a></code>, <code><a href="#topic+emr_vtrack.rm">emr_vtrack.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_vtrack.create("vtrack1", "dense_track", func = "max")
emr_vtrack.create("vtrack2", "dense_track", func = "min")
emr_vtrack.ls()
emr_vtrack.ls("*2")
</code></pre>

<hr>
<h2 id='emr_vtrack.name'>Generate a default name for a virtual track</h2><span id='topic+emr_vtrack.name'></span>

<h3>Description</h3>

<p>Given virtual track parameters, generate a name with the following format:
&quot;vt_(src).func_(func).params_(params).kr(keepref).ts_(time.shift).id_(id.map).filter_(filter)&quot;
Where for 'params', 'time.shift', and 'id.map', the values are separated by an
underscore.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_vtrack.name(
  src,
  func = NULL,
  params = NULL,
  keepref = FALSE,
  time.shift = NULL,
  id.map = NULL,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_vtrack.name_+3A_src">src</code></td>
<td>
<p>a character vector specifying the source dataset(s) or filter(s) that the virtual track is based on</p>
</td></tr>
<tr><td><code id="emr_vtrack.name_+3A_func">func</code></td>
<td>
<p>a character vector specifying the function(s) applied to the source data to generate the virtual track</p>
</td></tr>
<tr><td><code id="emr_vtrack.name_+3A_params">params</code></td>
<td>
<p>a named list specifying the parameters used by the function(s) to generate the virtual track</p>
</td></tr>
<tr><td><code id="emr_vtrack.name_+3A_keepref">keepref</code></td>
<td>
<p>a logical value indicating whether the virtual track should keep the reference column(s) of the source data</p>
</td></tr>
<tr><td><code id="emr_vtrack.name_+3A_time.shift">time.shift</code></td>
<td>
<p>a numeric vector specifying the time shift(s) applied to the virtual track</p>
</td></tr>
<tr><td><code id="emr_vtrack.name_+3A_id.map">id.map</code></td>
<td>
<p>a named list specifying the mapping of the IDs between the source data and the virtual track</p>
</td></tr>
<tr><td><code id="emr_vtrack.name_+3A_filter">filter</code></td>
<td>
<p>a character vector specifying the filter(s) applied to the virtual track. Note that the filter name cannot contain the character '.'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>func</code>, <code>params</code>, <code>time.shift</code>, <code>id.map</code>, or <code>filter</code> are
<code>NULL</code> - their section would not appear in the generated name.
</p>


<h3>Value</h3>

<p>a default name for the virtual track
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_vtrack.create">emr_vtrack.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_vtrack.name("dense_track",
    time.shift = 1,
    func = "max"
)

</code></pre>

<hr>
<h2 id='emr_vtrack.rm'>Deletes a virtual track</h2><span id='topic+emr_vtrack.rm'></span>

<h3>Description</h3>

<p>Deletes a virtual track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emr_vtrack.rm(vtrack)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emr_vtrack.rm_+3A_vtrack">vtrack</code></td>
<td>
<p>virtual track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes a virtual track from current R environment.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emr_vtrack.create">emr_vtrack.create</a></code>, <code><a href="#topic+emr_vtrack.ls">emr_vtrack.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
emr_db.init_examples()
emr_vtrack.create("vtrack1", "dense_track")
emr_vtrack.create("vtrack2", "dense_track")
emr_vtrack.ls()
emr_vtrack.rm("vtrack1")
emr_vtrack.ls()
</code></pre>

<hr>
<h2 id='string_to_var'>Create a syntactically valid variable name from a string</h2><span id='topic+string_to_var'></span>

<h3>Description</h3>

<p>Spaces are replaced with '_' and other non valid characters are encoded as '.' + two bit
hexadecimal representation.
Variables which start with an underscore or a dot are prepended with the letter 'X'.
The result is sent to <code>make.names</code> in order to deal with reserved words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_to_var(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_to_var_+3A_str">str</code></td>
<td>
<p>string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that strings starting with 'X.' would not be translated back correctly using <code>var_to_string</code>,
i.e. <code>string_to_var(var_to_string("X.saba"))</code> would result &quot;.saba&quot;.
</p>


<h3>Value</h3>

<p>a syntactically valid variable name
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string_to_var("a &amp; b")
string_to_var("saba and savta")
string_to_var("/home/mydir")
string_to_var("www.google.com")
string_to_var("my_variable + 3")
string_to_var(".hidden variable")
string_to_var("NULL")

</code></pre>

<hr>
<h2 id='var_to_string'>Decode a variable created by string_to_var</h2><span id='topic+var_to_string'></span>

<h3>Description</h3>

<p>Convert a variable created by <code>string_to_var</code> back to the original string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_to_string(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_to_string_+3A_str">str</code></td>
<td>
<p>string which was generated by <code>string_to_var</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the original string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var_to_string(string_to_var("a &amp; b"))
var_to_string(string_to_var("saba and savta"))
var_to_string(string_to_var("/home/mydir"))
var_to_string(string_to_var("www.google.com"))
var_to_string(string_to_var("my_variable + 3"))
var_to_string(string_to_var(".hidden variable"))
var_to_string(string_to_var("NULL"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
