<!DOCTYPE html><html lang="en"><head><title>Help for package GTFSwizard</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GTFSwizard}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_wizardgtfs'><p>Convert GTFS Object to wizardgtfs Format</p></a></li>
<li><a href='#delay_trip'><p>Delay Specified Trips in a 'wizardgtfs' Object</p></a></li>
<li><a href='#edit_dwelltime'><p>Modify Dwell Times in GTFS Data</p></a></li>
<li><a href='#edit_speed'><p>Adjust Travel Speed in a GTFS Dataset</p></a></li>
<li><a href='#explore_gtfs'><p>Explore GTFS Data in an Interactive Shiny Application</p></a></li>
<li><a href='#filter_functions'><p>Filter GTFS Data by Service, Route, Date, Stop, Trip, and Time</p></a></li>
<li><a href='#for_bus_gtfs'><p>GTFS Data for Fortaleza (Bus System), Brazil.</p></a></li>
<li><a href='#for_rail_gtfs'><p>GTFS Data for Fortaleza (Rail System), Brazil</p></a></li>
<li><a href='#get_1stdeparture'><p>Get First Departure Times for GTFS Trips</p></a></li>
<li><a href='#get_corridor'><p>Identify and Extract Transit Corridors</p></a></li>
<li><a href='#get_distances'><p>Calculate Distances in GTFS Data</p></a></li>
<li><a href='#get_durations'><p>Calculate Trip Durations in GTFS Data</p></a></li>
<li><a href='#get_dwelltimes'><p>Calculate Dwell Times in GTFS Data</p></a></li>
<li><a href='#get_fleet'><p>Estimates Fleet from GTFS Data</p></a></li>
<li><a href='#get_frequency'><p>Calculate Route Frequency in GTFS Data</p></a></li>
<li><a href='#get_headways'><p>Calculate Headways in GTFS Data</p></a></li>
<li><a href='#get_hubs'><p>Identify Transit Hubs</p></a></li>
<li><a href='#get_servicepattern'><p>Identify Service Patterns in GTFS Data</p></a></li>
<li><a href='#get_shapes'><p>Generate Shapes Table for GTFS Data</p></a></li>
<li><a href='#get_shapes_df'><p>Convert Shape Geometries to GTFS Shape Points Data Frame</p></a></li>
<li><a href='#get_shapes_sf'><p>Convert GTFS Shapes Table to Simple Features (sf) Format</p></a></li>
<li><a href='#get_speeds'><p>Calculate Speeds for GTFS Routes and Trips</p></a></li>
<li><a href='#get_stops_sf'><p>Convert GTFS Stops Table to Simple Features (sf) Format</p></a></li>
<li><a href='#latlon2epsg'><p>Transform Spatial Data to a Local UTM Coordinate System</p></a></li>
<li><a href='#merge_gtfs'><p>Merge Two GTFS Datasets</p></a></li>
<li><a href='#plot_calendar'><p>Plot Trip Frequency Calendar for GTFS Data</p></a></li>
<li><a href='#plot_corridor'><p>Plot Transit Corridors</p></a></li>
<li><a href='#plot_frequency'><p>Plot System Frequency by Hour</p></a></li>
<li><a href='#plot_headways'><p>Plot System Average Headway by Hour</p></a></li>
<li><a href='#plot_hubs'><p>Plot Transit Hubs</p></a></li>
<li><a href='#plot_routefrequency'><p>Plot Route Frequency by Hour</p></a></li>
<li><a href='#read_gtfs'><p>Read GTFS file</p></a></li>
<li><a href='#selection'><p>Select Subsets of GTFS Data</p></a></li>
<li><a href='#set_dwelltime'><p>Set Dwell Time for GTFS Stops</p></a></li>
<li><a href='#split_trip'><p>Split a Trip into Sub-Trips within a GTFS Object</p></a></li>
<li><a href='#tidy_raptor'><p>Calculate Travel Times with RAPTOR Algorithm</p></a></li>
<li><a href='#write_gtfs'><p>Write GTFS Data to Zip File</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Exploring and Manipulating 'GTFS' Files</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-15 15:40:02 UTC</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/OPATP/GTFSwizard">https://github.com/OPATP/GTFSwizard</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OPATP/GTFSwizard/issues">https://github.com/OPATP/GTFSwizard/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Exploring, analyzing, and manipulating General Transit Feed Specification (GTFS) files, which represent public transportation schedules and geographic data. The package allows users to filter data by routes, trips, stops, and time, generate spatial visualizations, and perform detailed analyses of transit networks, including headway, dwell times, and route frequencies. Designed for transit planners, researchers, and data analysts, 'GTFSwizard' integrates functionalities from popular packages to enable efficient GTFS data manipulation and visualization.</td>
</tr>
<tr>
<td>Imports:</td>
<td>lubridate, sf, tidyr, data.table, shiny, leaflet, checkmate,
dplyr, ggplot2, gtfsio, purrr, rlang, crayon, forcats,
hrbrthemes, stringr, tibble, plotly, leaflet.extras, geosphere,
stplanr, glue, hms, sfnetworks, gtfstools, tidytransit, igraph,
magrittr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-15 15:21:04 UTC; nelsonquesado</td>
</tr>
<tr>
<td>Author:</td>
<td>Nelson de O. Quesado Filho [aut, cre],
  Caio G. C. Guimar√£es [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nelson de O. Quesado Filho &lt;nquesado@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
</table>
<hr>
<h2 id='as_wizardgtfs'>Convert GTFS Object to wizardgtfs Format</h2><span id='topic+as_wizardgtfs'></span>

<h3>Description</h3>

<p>'as_wizardgtfs' transforms a GTFS object into the 'wizardgtfs' format, providing enhanced functionality and compatibility with the GTFSwizard package. This function supports GTFS objects in various formats, including 'tidygtfs' and list-based structures, and can optionally create a shapes table if it is missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_wizardgtfs(gtfs_list, build_shapes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_wizardgtfs_+3A_gtfs_list">gtfs_list</code></td>
<td>
<p>A GTFS object in list or 'tidygtfs' format.</p>
</td></tr>
<tr><td><code id="as_wizardgtfs_+3A_build_shapes">build_shapes</code></td>
<td>
<p>Logical. If 'TRUE', builds the shapes table if it is missing in the provided GTFS object. Default is 'TRUE'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- 'as_wizardgtfs' is a generic function with S3 methods for different GTFS object formats.
</p>
<p>- The 'wizardgtfs' format includes additional processing and checks, such as validation of unique IDs and structure formatting.
</p>


<h3>Value</h3>

<p>An object of class 'wizardgtfs', which includes multiple data frames for transit data analysis.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::get_shapes()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert a GTFS object to wizardgtfs format
gtfs_wizard &lt;- as_wizardgtfs(for_rail_gtfs, build_shapes = TRUE)

</code></pre>

<hr>
<h2 id='delay_trip'>Delay Specified Trips in a 'wizardgtfs' Object</h2><span id='topic+delay_trip'></span>

<h3>Description</h3>

<p>This function adds a delay to the arrival and departure times of specified trips within a 'wizardgtfs' object.
If the input GTFS object is not of class 'wizardgtfs', it will be converted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delay_trip(gtfs, trip, duration)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delay_trip_+3A_gtfs">gtfs</code></td>
<td>
<p>An object representing GTFS data, preferably of class 'wizardgtfs'.</p>
</td></tr>
<tr><td><code id="delay_trip_+3A_trip">trip</code></td>
<td>
<p>A character vector of 'trip_id's in the 'wizardgtfs' object that will be delayed. Each 'trip_id' must exist in 'gtfs$trips$trip_id'.</p>
</td></tr>
<tr><td><code id="delay_trip_+3A_duration">duration</code></td>
<td>
<p>A delay duration, either as a 'duration' object or a numeric value representing seconds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adjusts the arrival and departure times of the specified 'trip_id's in 'gtfs$stop_times' by the specified 'duration'.
If 'gtfs' is not a 'wizardgtfs' object, the function will attempt to convert it using 'GTFSwizard::as_wizardgtfs()', and a warning will be issued.
The function checks that 'trip' contains valid 'trip_id's and that 'duration' is either a 'duration' or numeric (seconds).
</p>


<h3>Value</h3>

<p>A modified 'wizardgtfs' object with updated arrival and departure times for the specified trips.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()] for converting GTFS objects to 'wizardgtfs' class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Delay trips by 5 minutes
gtfs &lt;- delay_trip(gtfs = for_rail_gtfs, for_rail_gtfs$trips$trip_id[1:2], duration = 300)

# Delay trips by duration
gtfs &lt;- delay_trip(gtfs = for_rail_gtfs,
                    trip = for_rail_gtfs$trips$trip_id[1],
                    duration = lubridate::duration(10, "minutes"))

</code></pre>

<hr>
<h2 id='edit_dwelltime'>Modify Dwell Times in GTFS Data</h2><span id='topic+edit_dwelltime'></span>

<h3>Description</h3>

<p>The 'edit_dwelltime' function adjusts dwell times for specified trips and stops in a GTFS dataset. The dwell times are scaled by a given factor, and arrival and departure times are updated accordingly in the 'stop_times' table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edit_dwelltime(gtfs, trips = "all", stops = "all", factor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edit_dwelltime_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, preferably of class 'wizardgtfs'. If not, the function will attempt to convert it using 'GTFSwizard::as_wizardgtfs()'.</p>
</td></tr>
<tr><td><code id="edit_dwelltime_+3A_trips">trips</code></td>
<td>
<p>A character vector of trip IDs for which dwell times should be modified. Use ''all'' to include all trips (default).</p>
</td></tr>
<tr><td><code id="edit_dwelltime_+3A_stops">stops</code></td>
<td>
<p>A character vector of stop IDs for which dwell times should be modified. Use ''all'' to include all stops (default).</p>
</td></tr>
<tr><td><code id="edit_dwelltime_+3A_factor">factor</code></td>
<td>
<p>A numeric value representing the scaling factor for dwell times. For example, a factor of 1.5 increases dwell times by 50%, while a factor of 0.5 reduces them by 50%.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the original dwell time (the difference between 'departure_time' and 'arrival_time') for the specified trips and stops. The dwell time is then scaled by the 'factor', and the arrival and departure times are updated accordingly.
</p>
<p>If &lsquo;trips' or 'stops' is set to '&rsquo;all'', all trips or stops, respectively, will be considered. Input validation ensures that provided 'trips' and 'stops' exist in the GTFS dataset.
</p>


<h3>Value</h3>

<p>A modified GTFS object with updated arrival and departure times in the 'stop_times' table.
</p>


<h3>Note</h3>

<p>Ensure the 'stop_times' table contains valid 'arrival_time' and 'departure_time' values. Empty or missing times may cause computation issues.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::set_dwelltime()], [GTFSwizard::as_wizardgtfs()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtfs &lt;- set_dwelltime(for_rail_gtfs,
                    trips = for_rail_gtfs$trips$trip_id[1:100],
                    stops = for_rail_gtfs$stops$stop_id[1:20],
                    duration = 10)

gtfs &lt;- edit_dwelltime(gtfs,
                    trips = for_rail_gtfs$trips$trip_id[1:100],
                    stops = for_rail_gtfs$stops$stop_id[1:20],
                    factor = 1.5)

get_dwelltimes(gtfs, method = 'detailed')

</code></pre>

<hr>
<h2 id='edit_speed'>Adjust Travel Speed in a GTFS Dataset</h2><span id='topic+edit_speed'></span>

<h3>Description</h3>

<p>The 'edit_speed' function adjusts the travel speeds between stops in a GTFS dataset by modifying trip durations based on a specified speed multiplier. It allows selective adjustments for specific trips and stops or applies changes globally across the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edit_speed(gtfs, trips = "all", stops = "all", factor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edit_speed_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, preferably of class 'wizardgtfs'. If not, the function attempts to convert it using 'GTFSwizard::as_wizardgtfs()'.</p>
</td></tr>
<tr><td><code id="edit_speed_+3A_trips">trips</code></td>
<td>
<p>A character vector specifying the 'trip_id's to modify. Defaults to '&quot;all&quot;' to include all trips.</p>
</td></tr>
<tr><td><code id="edit_speed_+3A_stops">stops</code></td>
<td>
<p>A character vector specifying the 'stop_id's to include in the adjustment. Defaults to '&quot;all&quot;' to include all stops.</p>
</td></tr>
<tr><td><code id="edit_speed_+3A_factor">factor</code></td>
<td>
<p>A numeric value representing the multiplier for the speed. For example, a value of '2' doubles the speed, halving the travel time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs the following steps:
</p>

<dl>
<dt>1. Retrieve Durations</dt><dd><p>The 'get_durations()' function calculates trip durations, filtered by the specified trips and stops.</p>
</dd>
<dt>2. Adjust Durations</dt><dd><p>Durations are divided by the speed factor to compute new durations. Time differences are calculated.</p>
</dd>
<dt>3. Update Stop Times</dt><dd><p>Cumulative time differences are added to the 'arrival_time' and 'departure_time' columns in the 'stop_times' table.</p>
</dd>
</dl>

<p>If no specific trips or stops are provided, the function adjusts all trips and stops in the GTFS object.
</p>


<h3>Value</h3>

<p>A GTFS object with updated 'stop_times' reflecting the adjusted travel durations.
</p>


<h3>Note</h3>

<p>Ensure that the 'factor' is greater than 0. Using a value less than or equal to 0 will result in invalid or nonsensical time adjustments.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::get_speeds()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edit_speed(for_rail_gtfs,
          trips = for_rail_gtfs$trips$trip_id[1:2],
          stops = for_rail_gtfs$stops$stop_id[1:2],
          factor = 1.5)

</code></pre>

<hr>
<h2 id='explore_gtfs'>Explore GTFS Data in an Interactive Shiny Application</h2><span id='topic+explore_gtfs'></span>

<h3>Description</h3>

<p>This function pops-up a Shiny application for exploring General Transit Feed Specification (GTFS) data.
The application provides an overview of the GTFS data, visualizations of route characteristics, and
detailed information on selected routes, allowing users to analyze various aspects of a GTFS feed interactively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explore_gtfs(gtfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="explore_gtfs_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, preferably of class 'wizardgtfs'. If not, the function attempts to convert it
to 'wizardgtfs' using 'GTFSwizard::as_wizardgtfs()'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Shiny application generated by this function has two main tabs:
- **Overview**: Displays general GTFS information, maps, and summary charts of the transit system, including frequency, fleet, speed, and other statistics.
- **By Route**: Allows users to select specific routes and view detailed maps and visualizations for each selected route.
</p>
<p>If the provided 'gtfs' object does not contain a 'shapes' table, it will attempt to add it using 'GTFSwizard::get_shapes()', issuing a warning
</p>


<h3>Value</h3>

<p>A Shiny app object that, when run, opens an interactive dashboard for GTFS data exploration.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()], [GTFSwizard::get_shapes()], [GTFSwizard::plot_calendar()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  # To run the Shiny application:
  explore_gtfs(gtfs = GTFSwizard::for_rail_gtfs)
}

</code></pre>

<hr>
<h2 id='filter_functions'>Filter GTFS Data by Service, Route, Date, Stop, Trip, and Time</h2><span id='topic+filter_servicepattern'></span><span id='topic+filter_date'></span><span id='topic+filter_service'></span><span id='topic+filter_route'></span><span id='topic+filter_trip'></span><span id='topic+filter_stop'></span><span id='topic+filter_time'></span>

<h3>Description</h3>

<p>The 'filter_' functions selectively filter data within a 'wizardgtfs' object based on criteria such as service patterns, specific dates, service IDs, route IDs, trip IDs, stop IDs, or time ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_servicepattern(gtfs, servicepattern = NULL)

filter_date(gtfs, dates = NULL)

filter_service(gtfs, service)

filter_route(gtfs, route, keep = TRUE)

filter_trip(gtfs, trip, keep = TRUE)

filter_stop(gtfs, stop)

filter_time(gtfs, from = "0:0:0", to = "48:00:00")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_functions_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, preferably of class 'wizardgtfs'. If not, the function will attempt to convert it using 'GTFSwizard::as_wizardgtfs()'.</p>
</td></tr>
<tr><td><code id="filter_functions_+3A_servicepattern">servicepattern</code></td>
<td>
<p>(Optional) A character vector of service patterns to retain. Defaults to the most frequent pattern (typical day) if 'NULL'.</p>
</td></tr>
<tr><td><code id="filter_functions_+3A_dates">dates</code></td>
<td>
<p>(Optional) A date or vector of dates (as &quot;YYYY-MM-DD&quot; character or POSIXct) to filter services active on those dates. Return the furtherst available date if 'NULL'.</p>
</td></tr>
<tr><td><code id="filter_functions_+3A_service">service</code></td>
<td>
<p>(Optional) A character vector of service IDs to retain in the 'wizardgtfs' object.</p>
</td></tr>
<tr><td><code id="filter_functions_+3A_route">route</code></td>
<td>
<p>(Optional) A character vector of route IDs to retain in the 'wizardgtfs' object. When 'keep = FALSE', excludes the specified routes.</p>
</td></tr>
<tr><td><code id="filter_functions_+3A_keep">keep</code></td>
<td>
<p>Logical. When 'TRUE' (default), retains specified 'route' or 'trip' IDs; when 'FALSE', excludes them.</p>
</td></tr>
<tr><td><code id="filter_functions_+3A_trip">trip</code></td>
<td>
<p>(Optional) A character vector of trip IDs to retain in the 'wizardgtfs' object. When 'keep = FALSE', excludes the specified trips.</p>
</td></tr>
<tr><td><code id="filter_functions_+3A_stop">stop</code></td>
<td>
<p>(Optional) A character vector of stop IDs to retain.</p>
</td></tr>
<tr><td><code id="filter_functions_+3A_from">from</code></td>
<td>
<p>(Optional) Start time in &quot;HH:MM:SS&quot; format to include only trips that start after this time. Defaults to '0:0:0'.</p>
</td></tr>
<tr><td><code id="filter_functions_+3A_to">to</code></td>
<td>
<p>(Optional) End time in &quot;HH:MM:SS&quot; format to include only trips that end before this time. Defaults to '48:00:00'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each 'filter_' function targets a specific aspect of the GTFS data, applying filters to the relevant tables:
</p>
<p>- filter_servicepattern: Filters by specified service patterns in the GTFS data. If no pattern is provided, defaults to the most frequent one.
</p>
<p>- filter_date: Filters data by a date or dates, returning only services active on those dates.
</p>
<p>- filter_service: Filters by service ID, retaining data related to specified services.
</p>
<p>- filter_route: Filters by route ID. When 'keep = TRUE', only specified routes are retained; when 'FALSE', the specified routes are excluded.
</p>
<p>- filter_trip: Filters by trip ID, using 'keep' to either retain or exclude specified trips.
</p>
<p>- filter_stop: Filters by stop ID, retaining only stops and related data (trips, routes, etc.) associated with the specified stops.
</p>
<p>- filter_time: Filters stop times within a specified time range (between 'from' and 'to').
</p>
<p>These functions selectively subset the GTFS tables ('trips', 'stop_times', 'routes', 'agency', 'shapes', etc.), maintaining only the records that meet the defined criteria. If a table or required column is missing from the GTFS data, the function will either attempt to infer it using available data or exclude the table as necessary.
</p>


<h3>Value</h3>

<p>A filtered 'wizardgtfs' object containing only the records that match the specified criteria.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()], [GTFSwizard::get_servicepattern()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filter by service pattern
filtered_gtfs &lt;- filter_servicepattern(gtfs = for_rail_gtfs, servicepattern = "servicepattern-1")

# Filter by a specific date
filtered_gtfs &lt;- filter_date(gtfs = for_rail_gtfs, dates = "2021-02-10")

# Filter by route ID, keeping only specified routes
filtered_gtfs &lt;- filter_route(gtfs = for_rail_gtfs, route = for_rail_gtfs$routes$route_id[1:2])

# Filter by trip ID, excluding specified trips
filtered_gtfs &lt;- filter_trip(gtfs = for_rail_gtfs,
                              trip = for_rail_gtfs$trips$trip_id[1:2],
                              keep = FALSE)

# Filter by a time range
filtered_gtfs &lt;- filter_time(gtfs = for_rail_gtfs, from = "06:30:00", to = "10:00:00")

</code></pre>

<hr>
<h2 id='for_bus_gtfs'>GTFS Data for Fortaleza (Bus System), Brazil.</h2><span id='topic+for_bus_gtfs'></span>

<h3>Description</h3>

<p>A dataset containing GTFS (General Transit Feed Specification) data for Fortaleza's transit system by bus. The data includes information on routes, trips, stops, stop times, and other elements necessary for transit planning and analysis.
</p>


<h3>Format</h3>

<p>An object of class <code>wizardgtfs</code>, containing multiple data frames:
</p>

<dl>
<dt>agency</dt><dd><p>Data frame with 1 row and 7 columns, providing information about the transit agency, including agency name, URL, timezone, and contact details.</p>
</dd>
<dt>calendar</dt><dd><p>Data frame with 3 rows and 10 columns, detailing service availability by day of the week, start and end dates for each service.</p>
</dd>
<dt>fare_attributes</dt><dd><p>Data frame with 2 rows and 6 columns, showing fare information, including price, currency, payment method, and transfer rules.</p>
</dd>
<dt>fare_rules</dt><dd><p>Data frame with 259 rows and 5 columns, linking fare IDs to routes, along with optional restrictions on origins, destinations, and zones.</p>
</dd>
<dt>routes</dt><dd><p>Data frame with 259 rows and 9 columns, listing route details such as route ID, agency ID, route short and long names, route type, and colors.</p>
</dd>
<dt>shapes</dt><dd><p>Data frame with 89,846 rows and 5 columns, representing the spatial paths of routes with latitude, longitude, point sequence, and cumulative distance traveled.</p>
</dd>
<dt>stop_times</dt><dd><p>Data frame with 1,719,386 rows and 9 columns, including stop times for each trip, with arrival and departure times, stop sequence, and stop ID information.</p>
</dd>
<dt>stops</dt><dd><p>Data frame with 4,793 rows and 12 columns, containing information about each stop, including stop ID, name, location (latitude and longitude), and accessibility.</p>
</dd>
<dt>trips</dt><dd><p>Data frame with 52,304 rows and 9 columns, detailing trips associated with routes, including trip IDs, route IDs, direction, block, and shape IDs.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The GTFS data format is widely used for representing public transportation schedules and associated geographic information. This dataset follows the GTFS standard and includes elements for advanced analysis in transit planning.
</p>


<h3>Source</h3>

<p>Fortaleza transit agency (ETUFOR).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the dataset
data(for_bus_gtfs)

# Access trips data
head(for_bus_gtfs$trips)

# Access stops data
head(for_bus_gtfs$stops)

</code></pre>

<hr>
<h2 id='for_rail_gtfs'>GTFS Data for Fortaleza (Rail System), Brazil</h2><span id='topic+for_rail_gtfs'></span>

<h3>Description</h3>

<p>This dataset contains GTFS (General Transit Feed Specification) data for Fortaleza's rail transit system, managed by METROFOR. The data includes information on routes, trips, stops, stop times, shapes, and other necessary elements for transit analysis and planning.
</p>


<h3>Format</h3>

<p>An object of class <code>wizardgtfs</code>, consisting of multiple data frames:
</p>

<dl>
<dt>agency</dt><dd><p>Data frame with 1 row and 7 columns, providing information about the transit agency, including agency name, URL, timezone, language, and contact details.</p>
</dd>
<dt>calendar</dt><dd><p>Data frame with 1 row and 10 columns, detailing the service availability by day of the week, along with start and end dates for each service.</p>
</dd>
<dt>calendar_dates</dt><dd><p>Data frame with 26 rows and 3 columns, listing specific dates and exceptions (e.g., holidays) that modify the usual service pattern.</p>
</dd>
<dt>routes</dt><dd><p>Data frame with 3 rows and 9 columns, listing route details such as route ID, short and long names, route type, and colors associated with each route.</p>
</dd>
<dt>stops</dt><dd><p>Data frame with 39 rows and 10 columns, containing information about each stop, including stop ID, name, location (latitude and longitude), and additional details.</p>
</dd>
<dt>stop_times</dt><dd><p>Data frame with 3,420 rows and 10 columns, detailing arrival and departure times for each trip, along with stop sequences and stop IDs.</p>
</dd>
<dt>trips</dt><dd><p>Data frame with 215 rows and 7 columns, providing trip-specific information such as trip ID, headsign, direction, associated service ID, route ID, and shape ID.</p>
</dd>
<dt>shapes</dt><dd><p>Data frame with 80 rows and 5 columns, representing spatial paths of routes using latitude, longitude, point sequence, and cumulative distance traveled.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The GTFS data format is widely adopted for representing public transportation schedules and spatial information. This dataset follows GTFS standards and is tailored for advanced analysis, particularly in transit planning and operations. Key tables included are 'agency', 'routes', 'stops', 'stop_times', 'trips', and 'shapes', each providing essential attributes for a comprehensive transit analysis.
</p>


<h3>Source</h3>

<p>Cia Cearense de Transportes Metropolitanos (METROFOR).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the dataset
data(for_rail_gtfs)

# Access trips data
head(for_rail_gtfs$trips)

# Access stops data
head(for_rail_gtfs$stops)

</code></pre>

<hr>
<h2 id='get_1stdeparture'>Get First Departure Times for GTFS Trips</h2><span id='topic+get_1stdeparture'></span>

<h3>Description</h3>

<p>Extracts the first departure time for each trip in a 'wizardgtfs' object, along with the associated 'route_id', and 'stop_id' where the first departure occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_1stdeparture(gtfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_1stdeparture_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object. If not of class 'wizardgtfs', it will be converted internally using 'as_wizardgtfs()'. This may increase computation time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies the first departure time for each trip in the GTFS dataset. It uses the 'stop_times' table to find the earliest 'departure_time' for each 'trip_id' and joins this information with the 'trips' table to include the corresponding 'route_id'. The result is a tidy tibble suitable for further analysis or visualization.
</p>
<p>If the input GTFS object is not of the 'wizardgtfs' class, the function converts it using 'as_wizardgtfs()'. A message is displayed to inform the user about the conversion.
</p>


<h3>Value</h3>

<p>A tibble with the following columns:
</p>

<dl>
<dt>route_id</dt><dd><p>ID of the route associated with the trip.</p>
</dd>
<dt>trip_id</dt><dd><p>ID of the trip.</p>
</dd>
<dt>departure_time</dt><dd><p>Time of the first departure for the trip, as a character string in &quot;HH:MM:SS&quot; format.</p>
</dd>
<dt>stop_id</dt><dd><p>ID of the stop where the first departure occurs.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load GTFS data
gtfs &lt;- for_rail_gtfs

# Get the first departures
first_departures &lt;- get_1stdeparture(gtfs)
head(first_departures)

</code></pre>

<hr>
<h2 id='get_corridor'>Identify and Extract Transit Corridors</h2><span id='topic+get_corridor'></span>

<h3>Description</h3>

<p>The 'get_corridor' function identifies and extracts high-density transit corridors based on trip frequency between stops. It groups segments into connected corridors, and filters them based on a minimum length criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_corridor(gtfs, i = 0.01, min.length = 1500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_corridor_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, preferably of class 'wizardgtfs'. If not, the function will attempt to convert it using 'GTFSwizard::as_wizardgtfs()'.</p>
</td></tr>
<tr><td><code id="get_corridor_+3A_i">i</code></td>
<td>
<p>A numeric value representing the percentile threshold for selecting high-density segments. Defaults to '0.01' (top 1% of segments by trip frequency).</p>
</td></tr>
<tr><td><code id="get_corridor_+3A_min.length">min.length</code></td>
<td>
<p>A numeric value specifying the minimum corridor length (in meters) to retain. Defaults to '1500'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs the following steps:
</p>

<ol>
<li><p> Filters and orders 'stop_times' data to identify consecutive stops ('stop_from' and 'stop_to') for each trip.
</p>
</li>
<li><p> Counts the number of trips between each stop pair and selects the top 'i' percentile of segments by trip frequency.
</p>
</li>
<li><p> Groups spatially connected segments into corridors using graph theory and adjacency matrices.
</p>
</li>
<li><p> Filters corridors by the minimum length ('min.length').
</p>
</li>
<li><p> Returns the resulting corridors with their metadata and geometry.
</p>
</li></ol>



<h3>Value</h3>

<p>An 'sf' object containing the following columns:
</p>

<dl>
<dt>corridor</dt><dd><p>A unique identifier for each corridor, prefixed with &quot;corridor-&quot;.</p>
</dd>
<dt>stops</dt><dd><p>A list of stop IDs included in each corridor.</p>
</dd>
<dt>trip_id</dt><dd><p>A list of trip IDs included in each corridor.</p>
</dd>
<dt>length</dt><dd><p>The total length of the corridor, in meters.</p>
</dd>
<dt>geometry</dt><dd><p>The spatial representation of the corridor as an 'sf' linestring object.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The function uses 'sf' and 'igraph' for spatial and graph-based computations. Ensure the 'gtfs' object includes 'stop_times' table.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corridors &lt;- get_corridor(for_bus_gtfs, i = 0.02, min.length = 2000)

</code></pre>

<hr>
<h2 id='get_distances'>Calculate Distances in GTFS Data</h2><span id='topic+get_distances'></span>

<h3>Description</h3>

<p>The 'get_distances' function calculates distances within a 'wizardgtfs' object based on various methods.
Depending on the 'method' chosen, it can calculate average route distances, trip-specific distances, or detailed distances between stops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_distances(gtfs, method = "by.route", trips = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_distances_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, ideally of class 'wizardgtfs'. If it is not of this class, it will be converted.</p>
</td></tr>
<tr><td><code id="get_distances_+3A_method">method</code></td>
<td>
<p>A character string indicating the calculation method. Choices are:
</p>

<dl>
<dt>&quot;by.route&quot;</dt><dd><p>Calculates average distances for each route.</p>
</dd>
<dt>&quot;by.trip&quot;</dt><dd><p>Calculates distances for each trip, associating each trip ID with its total distance.</p>
</dd>
<dt>&quot;detailed&quot;</dt><dd><p>Calculates detailed distances between each consecutive stop for all trips. This is the most computationally intensive option and may take several minutes to complete.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_distances_+3A_trips">trips</code></td>
<td>
<p>A character vector of trip IDs to consider. When set to 'all', includes all trips.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls specific sub-functions based on the selected method:
</p>
<p>- &quot;by.route&quot;: Calculates average distances per route.
</p>
<p>- &quot;by.trip&quot;: Calculate distances per trip.
</p>
<p>- &quot;detailed&quot;: Calculates detailed stop-to-stop distances within each route. Note that this method may be slow for large datasets.
</p>
<p>If an invalid 'method' is provided, the function defaults to '&quot;by.route&quot;' and issues a warning.
</p>


<h3>Value</h3>

<p>A data frame with calculated distances based on the specified method:
</p>

<dl>
<dt>If 'method = &quot;by.route&quot;'</dt><dd><p>Returns a summary with columns: 'route_id', 'trips', 'average.distance', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.trip&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'trip_id', 'distance', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;detailed&quot;'</dt><dd><p>Returns a data frame with columns: 'shape_id', 'from_stop_id', 'to_stop_id', and 'distance'.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()], [GTFSwizard::get_servicepattern()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate average route distances
distances_by_route &lt;- get_distances(gtfs = for_rail_gtfs, method = "by.route", trips = 'all')

# Calculate distances by trip
distances_by_trip &lt;- get_distances(gtfs = for_rail_gtfs, method = "by.trip", trips = 'all')


# Calculate detailed distances between stops
detailed_distances &lt;- get_distances(gtfs = for_rail_gtfs, method = "detailed", trips = 'all')


</code></pre>

<hr>
<h2 id='get_durations'>Calculate Trip Durations in GTFS Data</h2><span id='topic+get_durations'></span>

<h3>Description</h3>

<p>The 'get_durations' function calculates trip durations within a 'wizardgtfs' object using different methods. Depending on the selected 'method', it can provide average durations per route, durations for individual trips, or detailed segment durations between stops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_durations(gtfs, method = "by.route", trips = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_durations_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, ideally of class 'wizardgtfs'. If not, it will be converted.</p>
</td></tr>
<tr><td><code id="get_durations_+3A_method">method</code></td>
<td>
<p>A character string specifying the calculation method. Options include:
</p>

<dl>
<dt>&quot;by.route&quot;</dt><dd><p>Calculates the average duration for each route.</p>
</dd>
<dt>&quot;by.trip&quot;</dt><dd><p>Calculates the total duration for each trip.</p>
</dd>
<dt>&quot;detailed&quot;'</dt><dd><p>Calculates detailed durations for each stop-to-stop segment within a trip.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_durations_+3A_trips">trips</code></td>
<td>
<p>A character vector of trip IDs to consider. When set to 'all', includes all trips.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls specific sub-functions based on the selected method:
</p>
<p>- &quot;by.route&quot;: Calculates average durations for each route.
</p>
<p>- &quot;by.trip&quot;: Calculates the total duration of each trip.
</p>
<p>- &quot;detailed&quot;: Calculates detailed durations between consecutive stops within each trip, excluding dwell times.
</p>
<p>If an invalid 'method' is specified, the function defaults to '&quot;by.route&quot;' and provides a warning.
</p>


<h3>Value</h3>

<p>A data frame containing trip durations based on the specified method:
</p>

<dl>
<dt>If 'method = &quot;by.route&quot;'</dt><dd><p>It includes dwell times. Returns a summary data frame with columns: 'route_id', 'trips', 'average.duration', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.trip&quot;'</dt><dd><p>It includes dwell times. Returns a data frame with columns: 'route_id', 'trip_id', 'duration', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;detailed&quot;'</dt><dd><p>It does not include dwell times. Returns a data frame with columns: 'route_id', 'trip_id', 'hour', 'from_stop_id', 'to_stop_id', 'duration', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()], [GTFSwizard::get_servicepattern()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate average route durations
durations_by_route &lt;- get_durations(gtfs = for_rail_gtfs, method = "by.route", trips = 'all')

# Calculate trip durations
durations_by_trip &lt;- get_durations(gtfs = for_rail_gtfs, method = "by.trip", trips = 'all')

# Calculate detailed durations between stops
detailed_durations &lt;- get_durations(gtfs = for_rail_gtfs, method = "detailed", trips = 'all')

</code></pre>

<hr>
<h2 id='get_dwelltimes'>Calculate Dwell Times in GTFS Data</h2><span id='topic+get_dwelltimes'></span>

<h3>Description</h3>

<p>The 'get_dwelltimes' function calculates dwell times within a 'wizardgtfs' object using different methods. Depending on the selected 'method', it can provide average dwell times per route, per trip, by hour, or detailed dwell times at each stop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dwelltimes(gtfs, max.dwelltime = 90, method = "by.route")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dwelltimes_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, ideally of class 'wizardgtfs'. If not, it will be converted.</p>
</td></tr>
<tr><td><code id="get_dwelltimes_+3A_max.dwelltime">max.dwelltime</code></td>
<td>
<p>Numeric. The maximum allowable dwell time (in seconds). Dwell times exceeding this value are excluded from the calculations. Defaults to 90 seconds.</p>
</td></tr>
<tr><td><code id="get_dwelltimes_+3A_method">method</code></td>
<td>
<p>A character string specifying the calculation method. Options include:
</p>

<dl>
<dt>&quot;by.hour&quot;</dt><dd><p>Calculates the average dwell time per hour of the day across all trips.</p>
</dd>
<dt>&quot;by.route&quot;</dt><dd><p>Calculates the average dwell time for each route.</p>
</dd>
<dt>&quot;by.trip&quot;</dt><dd><p>Calculates the average dwell time for each trip.</p>
</dd>
<dt>&quot;detailed&quot;</dt><dd><p>Calculates detailed dwell times at each stop within every trip.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls specific sub-functions based on the selected method:
</p>
<p>- &quot;by.hour&quot;: Calculates the average dwell time for each hour of the day.
</p>
<p>- &quot;by.route&quot;: Calculates average dwell times across each route.
</p>
<p>- &quot;by.trip&quot;: Calculates the total dwell time for each trip.
</p>
<p>- &quot;detailed&quot;: Calculates the dwell time between consecutive stops within each trip.
</p>
<p>If an invalid 'method' is specified, the function defaults to '&quot;by.route&quot;' and provides a warning.
</p>


<h3>Value</h3>

<p>A data frame containing dwell times based on the specified method:
</p>

<dl>
<dt>If 'method = &quot;by.hour&quot;'</dt><dd><p>Returns a data frame with columns: 'hour', 'trips', 'average.dwelltime', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.route&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'trips', 'average.dwelltime', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.trip&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'trip_id', 'average.dwelltime', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;detailed&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'trip_id', 'stop_id', 'hour', 'dwell_time', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()], [GTFSwizard::get_servicepattern()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate dwell times by hour
dwelltimes_by_hour &lt;- get_dwelltimes(gtfs = for_rail_gtfs, max.dwelltime = 120, method = "by.hour")

# Calculate dwell times by route
dwelltimes_by_route &lt;- get_dwelltimes(gtfs = for_rail_gtfs, max.dwelltime = 90, method = "by.route")

# Calculate dwell times by trip
dwelltimes_by_trip &lt;- get_dwelltimes(gtfs = for_rail_gtfs, max.dwelltime = 45, method = "by.trip")

# Calculate detailed dwell times between stops
detailed_dwelltimes &lt;- get_dwelltimes(gtfs = for_rail_gtfs, max.dwelltime = 60, method = "detailed")

</code></pre>

<hr>
<h2 id='get_fleet'>Estimates Fleet from GTFS Data</h2><span id='topic+get_fleet'></span>

<h3>Description</h3>

<p>The 'get_fleet' function estimates the fleet from a 'wizardgtfs' object using different methods. Depending on the selected 'method', it can estimates fleet by route, by hour, peak times, or detailed timepoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fleet(gtfs, method = "by.route")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_fleet_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, ideally of class 'wizardgtfs'. If not, it will be converted.</p>
</td></tr>
<tr><td><code id="get_fleet_+3A_method">method</code></td>
<td>
<p>A character string specifying the calculation method. Options include:
</p>

<dl>
<dt>&quot;by.route&quot;</dt><dd><p>Calculates the maximum number of simultaneous trips for each route.</p>
</dd>
<dt>&quot;by.hour&quot;</dt><dd><p>Calculates the maximum number of simultaneous trips by hour of the day across all routes.</p>
</dd>
<dt>&quot;peak&quot;</dt><dd><p>Calculates the maximum number of simultaneous trips for the three busiest hours.</p>
</dd>
<dt>&quot;detailed&quot;</dt><dd><p>Calculates the maximum number of simultaneous trips across each timepoint within a trip.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls specific sub-functions based on the selected method:
</p>
<p>- &quot;by.route&quot;: Calculates the maximum simultaneous trips per route.
</p>
<p>- &quot;by.hour&quot;: Calculates the maximum simultaneous trips for each hour of the day.
</p>
<p>- &quot;peak&quot;: Calculates the maximum simultaneous trips for the three busiest hours.
</p>
<p>- &quot;detailed&quot;: Provides a timepoint-based fleet calculation, showing detailed fleet fluctutations over the course of the trip.
</p>
<p>If an invalid 'method' is specified, the function defaults to '&quot;by.route&quot;' and provides a warning.
</p>


<h3>Value</h3>

<p>A data frame containing the fleet based on the specified method:
</p>

<dl>
<dt>If 'method = &quot;by.route&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'fleet', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.hour&quot;'</dt><dd><p>Returns a data frame with columns: 'hour', 'fleet', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;peak&quot;'</dt><dd><p>Returns a data frame with columns: 'hour', 'fleet', 'service_pattern', and 'pattern_frequency' for the busiest three hours.</p>
</dd>
<dt>If 'method = &quot;detailed&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'net.fleet', 'fleet', 'time', 'service_pattern', and 'pattern_frequency' for each timepoint.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()], [GTFSwizard::get_servicepattern()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate fleet requirements by route
fleet_by_route &lt;- get_fleet(gtfs = for_rail_gtfs, method = "by.route")

# Calculate fleet requirements by hour
fleet_by_hour &lt;- get_fleet(gtfs = for_rail_gtfs, method = "by.hour")

# Calculate fleet requirements for peak hours
fleet_peak &lt;- get_fleet(gtfs = for_rail_gtfs, method = "peak")

# Calculate detailed fleet requirements over timepoints
fleet_detailed &lt;- get_fleet(gtfs = for_rail_gtfs, method = "detailed")

</code></pre>

<hr>
<h2 id='get_frequency'>Calculate Route Frequency in GTFS Data</h2><span id='topic+get_frequency'></span>

<h3>Description</h3>

<p>The 'get_frequency' function calculates route frequency within a 'wizardgtfs' object using different methods. Depending on the selected 'method', it can provide daily frequencies by route, shape, stop or detailed hourly frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_frequency(gtfs, method = "by.route")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_frequency_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, ideally of class 'wizardgtfs'. If not, it will be converted.</p>
</td></tr>
<tr><td><code id="get_frequency_+3A_method">method</code></td>
<td>
<p>A character string specifying the calculation method. Options include:
</p>

<dl>
<dt>&quot;by.route&quot;</dt><dd><p>Calculates the total daily frequency for each route.</p>
</dd>
<dt>&quot;by.shape&quot;</dt><dd><p>Calculates the total daily frequency for each shape.</p>
</dd>
<dt>&quot;by.stop&quot;</dt><dd><p>Calculates the total daily frequency for each stop.</p>
</dd>
<dt>&quot;detailed&quot;</dt><dd><p>Calculates the hourly frequency for each route.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls specific sub-functions based on the selected method:
</p>
<p>- &quot;by.route&quot;: Calculates the total daily frequency for each route.
</p>
<p>- &quot;by.shape&quot;: Calculates the total daily frequency for each shape.
</p>
<p>- &quot;by.stop&quot;: Calculates the total daily frequency for each stop.
</p>
<p>- &quot;detailed&quot;: Provides an hourly breakdown of frequency, showing the number of departures per hour for each route and direction.
</p>
<p>If an invalid 'method' is specified, the function defaults to '&quot;by.route&quot;' and provides a warning.
</p>


<h3>Value</h3>

<p>A data frame containing route frequencies based on the specified method:
</p>

<dl>
<dt>If 'method = &quot;by.route&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'direction_id', 'daily.frequency', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.shape&quot;'</dt><dd><p>Returns a data frame with columns: 'shape_id', 'direction_id', 'daily.frequency', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.stop&quot;'</dt><dd><p>Returns a data frame with columns: 'stop_id', 'direction_id', 'daily.frequency', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;detailed&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'direction_id', 'hour', 'frequency', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()], [GTFSwizard::get_servicepattern()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate daily route frequency
frequency_by_route &lt;- get_frequency(gtfs = for_rail_gtfs, method = "by.route")

# Calculate daily shape frequency
frequency_by_shape &lt;- get_frequency(gtfs = for_rail_gtfs, method = "by.shape")

# Calculate daily stop frequency
frequency_by_stop &lt;- get_frequency(gtfs = for_rail_gtfs, method = "by.stop")

# Calculate detailed hourly frequency
detailed_frequency &lt;- get_frequency(gtfs = for_rail_gtfs, method = "detailed")

</code></pre>

<hr>
<h2 id='get_headways'>Calculate Headways in GTFS Data</h2><span id='topic+get_headways'></span>

<h3>Description</h3>

<p>The 'get_headways' function calculates headways within a 'wizardgtfs' object using different methods. Depending on the selected 'method', it can provide average headways by route, by trip, by hour, or detailed stop-level headways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_headways(gtfs, method = "by.route")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_headways_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, ideally of class 'wizardgtfs'. If not, it will be converted.</p>
</td></tr>
<tr><td><code id="get_headways_+3A_method">method</code></td>
<td>
<p>A character string specifying the calculation method. Options include:
</p>

<dl>
<dt>&quot;by.route&quot;</dt><dd><p>Calculates the average headway for each route, assuming constant headways along stops.</p>
</dd>
<dt>&quot;by.hour&quot;</dt><dd><p>Calculates the hourly headway for each route, assuming constant headways along stops.</p>
</dd>
<dt>&quot;by.trip&quot;</dt><dd><p>Calculates headways for each trip, assuming constant headways along stops.</p>
</dd>
<dt>&quot;by.stop&quot;</dt><dd><p>Calculates headways for each stop.</p>
</dd>
<dt>&quot;by.shape&quot;</dt><dd><p>Calculates headways for each shape</p>
</dd>
<dt>&quot;detailed&quot;</dt><dd><p>Calculates detailed headways between consecutive stops within each route and trip.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls specific sub-functions based on the selected method:
</p>
<p>- &quot;by.route&quot;: Calculates the average headway for each route based on the first stop time per trip.
</p>
<p>- &quot;by.hour&quot;: Calculates the hourly headway for each route, grouping trips by hour.
</p>
<p>- &quot;by.trip&quot;: Calculates headways for each trip, considering only the first stop time.
</p>
<p>- &quot;by.stop&quot;: Calculates headways for each stop.
</p>
<p>- &quot;by.shape&quot;: Calculates headways for each shape.
</p>
<p>- &quot;detailed&quot;: Provides headway calculations for each consecutive stop within each trip.
</p>
<p>If an invalid 'method' is specified, the function defaults to '&quot;by.route&quot;' and provides a warning.
</p>


<h3>Value</h3>

<p>A data frame containing service headways based on the specified method:
</p>

<dl>
<dt>If 'method = &quot;by.route&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'valid_trips', 'average_headway', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.hour&quot;'</dt><dd><p>Returns a data frame with columns: 'hour', 'valid_trips', 'average_headway', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.trip&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'trip_id', 'headway', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.stop&quot;'</dt><dd><p>Returns a data frame with columns: 'stop_id', 'direction_id', 'valid_trips', 'headway', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.shape&quot;'</dt><dd><p>Returns a data frame with columns: 'shape_id', 'direction_id', 'valid_trips', 'headway', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;detailed&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'trip_id', 'stop_id', 'hour', 'headway', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()], [GTFSwizard::get_servicepattern()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate average route headways
headways_by_route &lt;- get_headways(gtfs = for_rail_gtfs, method = "by.route")

# Calculate hourly headways
headways_by_hour &lt;- get_headways(gtfs = for_rail_gtfs, method = "by.hour")

# Calculate headways for each trip
headways_by_trip &lt;- get_headways(gtfs = for_rail_gtfs, method = "by.trip")

# Calculate headways for each stop
headways_by_stop &lt;- get_headways(gtfs = for_rail_gtfs, method = "by.stop")

# Calculate headways for each shape
headways_by_shape &lt;- get_headways(gtfs = for_rail_gtfs, method = "by.shape")

# Calculate detailed stop-level headways
detailed_headways &lt;- get_headways(gtfs = for_rail_gtfs, method = "detailed")

</code></pre>

<hr>
<h2 id='get_hubs'>Identify Transit Hubs</h2><span id='topic+get_hubs'></span>

<h3>Description</h3>

<p>The 'get_hubs' function identifies transit hubs from a GTFS dataset by calculating the number of trips and unique routes served by each stop. It returns a spatial object with metadata for each hub, allowing for further analysis or visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hubs(gtfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_hubs_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, preferably of class 'wizardgtfs'. If not, the function will attempt to convert it using 'GTFSwizard::as_wizardgtfs()'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs the following steps:
</p>

<ol>
<li><p> Extracts 'stop_id' and 'trip_id' pairs from the 'stop_times' table.
</p>
</li>
<li><p> Joins this data with the 'trips' table to associate 'route_id' with each trip.
</p>
</li>
<li><p> Groups by 'stop_id' to compute the number of trips ('n_trip') and unique routes ('n_route') per stop.
</p>
</li>
<li><p> Joins the resulting data with the spatial geometry of stops, transforming it into an 'sf' object.
</p>
</li>
<li><p> Sorts the hubs by the number of unique routes ('n_routes') in descending order.
</p>
</li></ol>



<h3>Value</h3>

<p>An 'sf' object containing the following columns:
</p>

<dl>
<dt>stop_id</dt><dd><p>The unique identifier for each stop.</p>
</dd>
<dt>trip_id</dt><dd><p>A list of trip IDs associated with the stop.</p>
</dd>
<dt>route_id</dt><dd><p>A list of unique route IDs associated with the stop.</p>
</dd>
<dt>n_trip</dt><dd><p>The total number of trips that pass through the stop.</p>
</dd>
<dt>n_routes</dt><dd><p>The total number of unique routes that pass through the stop.</p>
</dd>
<dt>geometry</dt><dd><p>The spatial location of the stop as an 'sf' point object.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The function uses 'sf' for spatial data manipulation. Ensure that the GTFS dataset includes the 'stop_times', 'trips', and 'stops' tables.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::get_stops_sf()], [GTFSwizard::as_wizardgtfs()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Identify hubs in a GTFS dataset
get_hubs(for_rail_gtfs)

</code></pre>

<hr>
<h2 id='get_servicepattern'>Identify Service Patterns in GTFS Data</h2><span id='topic+get_servicepattern'></span>

<h3>Description</h3>

<p>The 'get_servicepattern' function identifies and organizes unique service patterns within a 'wizardgtfs' object. It groups services by common dates of operation and assigns each a frequency-based pattern identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_servicepattern(gtfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_servicepattern_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, ideally of class 'wizardgtfs'. If not, it will be converted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first checks if the input 'gtfs' object is of class 'wizardgtfs'. If not, it converts it using 'as_wizardgtfs()'. It then groups services by common dates of operation, assigns a frequency to each unique pattern, and organizes these into service pattern identifiers, ordered by their frequency.
</p>


<h3>Value</h3>

<p>A data frame containing unique service patterns with the following columns:
</p>

<dl>
<dt>'service_id'</dt><dd><p>Unique identifier(s) for each service.</p>
</dd>
<dt>'service_pattern'</dt><dd><p>An identifier for each distinct service pattern based on operational dates, in the format &quot;servicepattern-N&quot;.</p>
</dd>
<dt>'pattern_frequency'</dt><dd><p>The frequency of each service pattern, indicating the number of dates associated with that pattern.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate service patterns for a GTFS object
service_patterns &lt;- get_servicepattern(gtfs = for_rail_gtfs)

</code></pre>

<hr>
<h2 id='get_shapes'>Generate Shapes Table for GTFS Data</h2><span id='topic+get_shapes'></span>

<h3>Description</h3>

<p>The 'get_shapes' function reconstructs the 'shapes' table for a GTFS dataset using an approximation based on stop coordinates and sequence information. It creates geometric representations of trips by connecting stops in sequence for each trip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_shapes(gtfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_shapes_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, ideally of class 'wizardgtfs'. If not, it will be converted automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function constructs the 'shapes' table by sequentially connecting stops along each trip using a Euclidean approximation. If the GTFS object already contains a 'shapes' table, it will be overwritten, and a warning will be displayed. The process involves:
</p>
<p>- Selecting and arranging stops by trip and sequence
</p>
<p>- Connecting stops with line segments to form a path for each trip
</p>
<p>- Grouping unique paths into distinct shape IDs
</p>


<h3>Value</h3>

<p>A modified GTFS object that includes a 'shapes' table derived from the stops and trips information.
</p>


<h3>Note</h3>

<p>This approximation may not perfectly represent real-world shapes, especially for complex or curved routes.
'get_shapes()' uses stop sequences to recriate the shapes table; accordingly, it should not be used after 'filter_time()', as this function removes invalid 'stop_times'.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()], [GTFSwizard::get_shapes_df()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a shapes table for a GTFS object
gtfs_with_shapes &lt;- get_shapes(gtfs = for_rail_gtfs)

</code></pre>

<hr>
<h2 id='get_shapes_df'>Convert Shape Geometries to GTFS Shape Points Data Frame</h2><span id='topic+get_shapes_df'></span>

<h3>Description</h3>

<p>The 'get_shapes_df' function converts a spatial object of shapes (with geometry) into a GTFS-compliant 'shapes' data frame format, detailing latitude, longitude, point sequence, and cumulative distance traveled along each shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_shapes_df(shape)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_shapes_df_+3A_shape">shape</code></td>
<td>
<p>A spatial ('sf') object containing shapes, with 'shape_id' and geometry information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs the following steps:
</p>
<p>- Validates that the 'shape' object is of class 'sf' and contains a 'shape_id' column.
</p>
<p>- Extracts point coordinates from each shape‚Äôs geometry, creating a sequence of latitude and longitude points.
</p>
<p>- Computes cumulative distances along the shape, using Euclidean distance between consecutive points.
</p>
<p>The resulting data frame conforms to the GTFS 'shapes.txt' format. Distances are expressed in meters.
</p>


<h3>Value</h3>

<p>A data frame with columns:
</p>

<dl>
<dt>'shape_id'</dt><dd><p>Unique identifier for each shape.</p>
</dd>
<dt>'shape_pt_lon'</dt><dd><p>Longitude coordinates of each shape point.</p>
</dd>
<dt>'shape_pt_lat'</dt><dd><p>Latitude coordinates of each shape point.</p>
</dd>
<dt>'shape_pt_sequence'</dt><dd><p>Sequence of points along each shape.</p>
</dd>
<dt>'shape_dist_traveled'</dt><dd><p>Cumulative distance traveled along the shape in meters.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>[GTFSwizard::get_shapes()], [GTFSwizard::get_shapes_sf()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert a shape geometry to a GTFS-compliant shapes data frame
shape &lt;- get_shapes_sf(for_rail_gtfs$shapes)
shapes_df &lt;- get_shapes_df(shape = shape)

</code></pre>

<hr>
<h2 id='get_shapes_sf'>Convert GTFS Shapes Table to Simple Features (sf) Format</h2><span id='topic+get_shapes_sf'></span>

<h3>Description</h3>

<p>'get_shapes_sf' converts the shapes table in a 'wizardgtfs' object into a simple features ('sf') object, making it suitable for spatial analysis. This function checks and processes the 'shapes' data in the provided GTFS object and structures it as 'LINESTRING' features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_shapes_sf(gtfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_shapes_sf_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object containing the 'shapes' table or the shape table itself. If the 'shapes' table is missing, it will be created using 'get_shapes()'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- When the input 'wizardgtfs' object lacks a 'shapes' table, the function automatically generates one using 'get_shapes()'.
</p>
<p>- The 'shapes' table in the GTFS object are transformed into 'LINESTRING' geometries. If 'shape_pt_sequence' is absent, the points are treated as ordered by their position in the data.
</p>
<p>- If 'shape_dist_traveled' is available, cumulative distance calculations are included for each shape point.
</p>


<h3>Value</h3>

<p>An 'sf' object with shapes as 'LINESTRING' geometries:
</p>


<h3>Note</h3>

<p>If 'shape_pt_sequence' is missing, the function will assume that points are ordered, constructing the shape accordingly.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::get_shapes()], [GTFSwizard::get_shapes_df()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert shapes data in a GTFS object to sf format
gtfs_sf &lt;- get_shapes_sf(for_rail_gtfs)

</code></pre>

<hr>
<h2 id='get_speeds'>Calculate Speeds for GTFS Routes and Trips</h2><span id='topic+get_speeds'></span>

<h3>Description</h3>

<p>'get_speeds' calculates the average speed of trips and routes within a 'wizardgtfs' object. It uses distance and duration to provide speed outputs based on the specified 'method'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_speeds(gtfs, method = "by.route", trips = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_speeds_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, ideally of class 'wizardgtfs'. If the 'shapes' table is missing, it will be created automatically using 'get_shapes()'.</p>
</td></tr>
<tr><td><code id="get_speeds_+3A_method">method</code></td>
<td>
<p>A character string specifying the calculation method. Options include:
</p>

<dl>
<dt>&quot;by.route&quot;</dt><dd><p>Calculates the average speed for each route based on average distance and duration.</p>
</dd>
<dt>&quot;by.trip&quot;</dt><dd><p>Calculates the average speed for each trip based on total distance and duration.</p>
</dd>
<dt>&quot;detailed&quot;</dt><dd><p>Calculates the speed for each segment between stops within a trip.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_speeds_+3A_trips">trips</code></td>
<td>
<p>A character vector of trip IDs to consider. When set to 'all', includes all trips.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- This function calls specific sub-functions based on the selected 'method':
</p>

<dl>
<dt>'by.route'</dt><dd><p>Calculates average speed across each route.</p>
</dd>
<dt>'by.trip'</dt><dd><p>Calculates average speed across each trip.</p>
</dd>
<dt>'detailed'</dt><dd><p>Calculates speeds between consecutive stops within each trip.</p>
</dd>
</dl>

<p>- If an invalid 'method' is specified, the function defaults to '&quot;by.route&quot;' and provides a warning.
</p>


<h3>Value</h3>

<p>A data frame containing speed calculations, depending on the specified method:
</p>

<dl>
<dt>If 'method = &quot;by.route&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'trips', 'average.speed', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;by.trip&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'trip_id', 'average.speed', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
<dt>If 'method = &quot;detailed&quot;'</dt><dd><p>Returns a data frame with columns: 'route_id', 'trip_id', 'hour', 'from_stop_id', 'to_stop_id', 'speed', 'service_pattern', and 'pattern_frequency'.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>[GTFSwizard::get_distances()], [GTFSwizard::get_durations()], [GTFSwizard::get_shapes()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate average route speeds
speeds_by_route &lt;- get_speeds(gtfs = for_rail_gtfs, method = "by.route", trips = 'all')

# Calculate trip speeds
speeds_by_trip &lt;- get_speeds(gtfs = for_rail_gtfs, method = "by.trip", trips = 'all')


# Calculate detailed speeds between stops
detailed_speeds &lt;- get_speeds(gtfs = for_rail_gtfs, method = "detailed", trips = 'all')


</code></pre>

<hr>
<h2 id='get_stops_sf'>Convert GTFS Stops Table to Simple Features (sf) Format</h2><span id='topic+get_stops_sf'></span>

<h3>Description</h3>

<p>'get_stops_sf' converts the stops table in a 'wizardgtfs' object into a simple features ('sf') object, making it suitable for spatial analysis. This function checks the format of the 'stops' data and structures it as point geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stops_sf(gtfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_stops_sf_+3A_gtfs">gtfs</code></td>
<td>
<p>A 'wizardgtfs' object containing a 'stops' table or the stops table itself as a data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- When the input 'stops' table is not in 'sf' format, this function converts it to 'sf' by using the coordinates in the 'stop_lon' and 'stop_lat' columns.
</p>
<p>- The resulting 'sf' object is assigned a CRS of WGS 84 (EPSG:4326) for geographic compatibility.
</p>
<p>- If the 'stops' table is already in 'sf' format, the function simply reassigns the CRS and returns it unchanged.
</p>


<h3>Value</h3>

<p>An 'sf' object with stops as point geometries or a 'wizardgtfs' object.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::get_shapes()], [GTFSwizard::get_shapes_sf()], [GTFSwizard::get_shapes_df()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert stops data in a GTFS object to sf format
gtfs_sf &lt;- get_stops_sf(for_rail_gtfs)

</code></pre>

<hr>
<h2 id='latlon2epsg'>Transform Spatial Data to a Local UTM Coordinate System</h2><span id='topic+latlon2epsg'></span>

<h3>Description</h3>

<p>The 'latlon2epsg' function determines the appropriate UTM (Universal Transverse Mercator) EPSG code for a given 'sf' object
based on its centroid's latitude and longitude. It then transforms the object to the identified coordinate reference system (CRS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlon2epsg(sf_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latlon2epsg_+3A_sf_obj">sf_obj</code></td>
<td>
<p>An 'sf' object representing spatial features. This object must have a valid CRS with latitude and longitude coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the geographic centroid of the input spatial object and determines its latitude and longitude.
Based on the latitude:
</p>

<dl>
<dt>Latitudes above 84¬∞</dt><dd><p>The object is transformed to EPSG:3413 (North Pole).</p>
</dd>
<dt>Latitudes below -80¬∞</dt><dd><p>The object is transformed to EPSG:3031 (South Pole).</p>
</dd>
<dt>Latitudes between -80¬∞ and 84¬∞</dt><dd><p>The function calculates the UTM zone based on longitude and transforms the object
to the appropriate UTM EPSG code (EPSG:326XX for the Northern Hemisphere, EPSG:327XX for the Southern Hemisphere).</p>
</dd>
</dl>



<h3>Value</h3>

<p>An 'sf' object transformed to the appropriate UTM coordinate reference system.
</p>


<h3>Note</h3>

<p>The function requires that the input 'sf' object already has a valid CRS defined (e.g., WGS84).
</p>


<h3>See Also</h3>

<p>[sf::st_transform()], [sf::st_centroid()], [sf::st_union()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>latlon2epsg(get_shapes_sf(for_bus_gtfs)$shapes)

</code></pre>

<hr>
<h2 id='merge_gtfs'>Merge Two GTFS Datasets</h2><span id='topic+merge_gtfs'></span>

<h3>Description</h3>

<p>'merge_gtfs' combines two GTFS datasets into a single 'wizardgtfs' object, with an option to append suffixes to ensure unique identifiers across tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_gtfs(gtfs.x, gtfs.y, suffix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_gtfs_+3A_gtfs.x">gtfs.x</code></td>
<td>
<p>The first GTFS dataset, ideally of class 'wizardgtfs'. If not, it will be converted.</p>
</td></tr>
<tr><td><code id="merge_gtfs_+3A_gtfs.y">gtfs.y</code></td>
<td>
<p>The second GTFS dataset, ideally of class 'wizardgtfs'. If not, it will be converted.</p>
</td></tr>
<tr><td><code id="merge_gtfs_+3A_suffix">suffix</code></td>
<td>
<p>A logical value. If 'TRUE', appends '.x' and '.y' suffixes to identifier columns in 'gtfs.x' and 'gtfs.y', respectively, to prevent conflicts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- When 'suffix = TRUE', unique suffixes are appended to key identifiers in 'gtfs.x' and 'gtfs.y' (e.g., 'agency_id', 'route_id', 'trip_id').
</p>
<p>- After suffix handling, the function merges individual tables, ensuring no duplicated entries.
</p>
<p>- Finally, the resulting list is converted into a 'wizardgtfs' object.
</p>


<h3>Value</h3>

<p>A merged 'wizardgtfs' object containing all records from 'gtfs.x' and 'gtfs.y' across GTFS tables.
</p>


<h3>Note</h3>

<p>This function assumes that both input datasets follow GTFS structure. Non-standard tables or columns may be ignored or cause warnings.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Merge two GTFS datasets with suffix handling
merged_gtfs &lt;- merge_gtfs(for_rail_gtfs, for_bus_gtfs, suffix = TRUE)

</code></pre>

<hr>
<h2 id='plot_calendar'>Plot Trip Frequency Calendar for GTFS Data</h2><span id='topic+plot_calendar'></span>

<h3>Description</h3>

<p>'plot_calendar' creates a calendar heatmap visualization of the number of trips in a GTFS dataset for each day, with options for monthly and yearly faceting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_calendar(gtfs, ncol = 6, facet_by_year = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_calendar_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, ideally of class 'wizardgtfs'. If not, it will be converted.</p>
</td></tr>
<tr><td><code id="plot_calendar_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns for monthly faceting. Ignored if 'facet_by_year = TRUE'.</p>
</td></tr>
<tr><td><code id="plot_calendar_+3A_facet_by_year">facet_by_year</code></td>
<td>
<p>Logical value. If 'TRUE', plots data by year with each month in a separate column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- The function calculates daily trip frequencies from the 'service_id' and 'dates_services' tables in the GTFS object.
</p>
<p>- Days with no trips are marked in black, while other days are shaded on a gradient from pink (low trip count) to red (high trip count).
</p>
<p>- If 'facet_by_year = TRUE', the plot will display each year in separate rows, and 'ncol' is ignored.
</p>


<h3>Value</h3>

<p>A 'ggplot2' object showing a calendar heatmap of the daily trip counts across the specified GTFS date range.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plot a GTFS trip calendar with 4 columns
plot_calendar(for_rail_gtfs, ncol = 4)

# Plot a GTFS trip calendar, faceting by year
plot_calendar(for_rail_gtfs, facet_by_year = TRUE)


</code></pre>

<hr>
<h2 id='plot_corridor'>Plot Transit Corridors</h2><span id='topic+plot_corridor'></span>

<h3>Description</h3>

<p>The 'plot_corridor' function visualizes high-density transit corridors on a map. It overlays the identified corridors
on the route shapes from the GTFS data, providing a representation of the transit network and its key corridors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_corridor(gtfs, i = 0.01, min.length = 1500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_corridor_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, preferably of class 'wizardgtfs'. If not, the function will attempt to convert it using 'GTFSwizard::as_wizardgtfs()'.</p>
</td></tr>
<tr><td><code id="plot_corridor_+3A_i">i</code></td>
<td>
<p>A numeric value representing the percentile threshold for selecting high-density segments. Defaults to '0.01' (top 1% of segments by trip frequency).</p>
</td></tr>
<tr><td><code id="plot_corridor_+3A_min.length">min.length</code></td>
<td>
<p>A numeric value specifying the minimum corridor length (in meters) to retain. Defaults to '1500'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs the following steps:
</p>

<ol>
<li><p> Extracts route shapes from the GTFS data using 'get_shapes_sf'.
</p>
</li>
<li><p> Identifies transit corridors using the 'get_corridor' function with the specified 'i' and 'min.length' parameters.
</p>
</li>
<li><p> Creates a map using 'ggplot2' with:
</p>

<ol>
<li><p> Route shapes as the base layer (gray lines).
</p>
</li>
<li><p> High-density transit corridors as colored lines, with transparency for visualization.
</p>
</li></ol>

</li></ol>



<h3>Value</h3>

<p>A 'ggplot' object representing the transit network with corridors overlaid. The plot includes:
</p>

<dl>
<dt>Base map</dt><dd><p>Route shapes from the GTFS data, displayed in gray.</p>
</dd>
<dt>Corridors</dt><dd><p>High-density transit corridors, colored uniquely for each corridor.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Ensure the 'gtfs' object includes valid 'shapes' and 'stop_times' tables for accurate visualization. The corridors are identified
using the 'get_corridor' function, which relies on stop and trip data.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::get_corridor()], [GTFSwizard::get_shapes_sf()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_corridor(for_bus_gtfs, i = 0.02, min.length = 2000)


</code></pre>

<hr>
<h2 id='plot_frequency'>Plot System Frequency by Hour</h2><span id='topic+plot_frequency'></span>

<h3>Description</h3>

<p>'plot_frequency' generates an interactive plot of the frequency of trips by hour across the GTFS dataset. The plot shows hourly trip distributions, hourly average frequency, and an overall average frequency for the system, providing insights into peak times and overall transit service frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_frequency(gtfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_frequency_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object. This should ideally be of the 'wizardgtfs' class, or it will be converted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first calculates hourly and overall average frequencies using a weighted mean based on &lsquo;pattern_frequency'. Frequencies are plotted by hour of the day to visualize the system&rsquo;s trip distribution patterns.
</p>


<h3>Value</h3>

<p>A 'plotly' interactive plot displaying hourly frequency distributions, including:
</p>
<p>- Hourly Distribution: Boxplots showing frequency distribution across hours.
</p>
<p>- Hourly Average Frequency: A line indicating the weighted average frequency for each hour.
</p>
<p>- Overall Average Frequency: A dashed line marking the system's overall average frequency.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::get_frequency()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Plot the frequency of trips by hour for a GTFS object
plot_frequency(for_rail_gtfs)
}

</code></pre>

<hr>
<h2 id='plot_headways'>Plot System Average Headway by Hour</h2><span id='topic+plot_headways'></span>

<h3>Description</h3>

<p>'plot_headways' generates an interactive plot of the average headways (time between trips) by hour across the GTFS dataset. The plot displays hourly headway distributions for each service pattern and includes an overall average headway line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_headways(gtfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_headways_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object. This should ideally be of the 'wizardgtfs' class, or it will be converted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates hourly and overall average headways by weighting 'pattern_frequency' and 'trips' for each service pattern. The plot provides a visual representation of how average headways vary by hour and across service patterns.
</p>


<h3>Value</h3>

<p>A 'plotly' interactive plot showing the hourly average headway (in minutes) across service patterns, including:
</p>
<p>- Service Pattern Distribution: Lines for each service pattern, showing hourly headway values.
</p>
<p>- Overall Average Headway: A dashed line marking the weighted overall average headway.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::get_headways()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Plot average headway by hour for a GTFS object
plot_headways(for_rail_gtfs)
}

</code></pre>

<hr>
<h2 id='plot_hubs'>Plot Transit Hubs</h2><span id='topic+plot_hubs'></span>

<h3>Description</h3>

<p>The 'plot_hubs' function visualizes high-density potential integration transit stops (hubs) on a map. It overlays the identified stops
on the route shapes from the GTFS data, providing a representation of the transit network and its key integration hubs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hubs(gtfs, i = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_hubs_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, preferably of class 'wizardgtfs'. If not, the function will attempt to convert it using 'GTFSwizard::as_wizardgtfs()'.</p>
</td></tr>
<tr><td><code id="plot_hubs_+3A_i">i</code></td>
<td>
<p>A numeric value representing the percentile threshold for selecting high-density stops. Defaults to '0.05' (top 5% of stops by number of routes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'ggplot' object representing the transit network with hubs overlaid. The plot includes:
</p>

<dl>
<dt>Base map</dt><dd><p>Route shapes from the GTFS data, displayed in gray.</p>
</dd>
<dt>Hubs</dt><dd><p>High-density transit stops.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Ensure the 'gtfs' object includes valid 'shapes' and 'stop_times' tables for accurate visualization. The hubs are identified
using the 'get_hubs' function, which relies on stop and trip data.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::get_hubs()], [GTFSwizard::get_shapes_sf()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_hubs(for_bus_gtfs, i = 0.02)


</code></pre>

<hr>
<h2 id='plot_routefrequency'>Plot Route Frequency by Hour</h2><span id='topic+plot_routefrequency'></span>

<h3>Description</h3>

<p>'plot_routefrequency' generates an interactive plot of the frequency of trips by hour for specified routes in a GTFS dataset. The plot shows the hourly frequency distribution for each route and visualizes different service patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_routefrequency(gtfs, route = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_routefrequency_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object. Ideally, this should be of the 'wizardgtfs' class, or it will be converted.</p>
</td></tr>
<tr><td><code id="plot_routefrequency_+3A_route">route</code></td>
<td>
<p>A character vector specifying one or more 'route_id' values to plot. If 'NULL', all routes are included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function filters the GTFS dataset by route and computes hourly frequencies for each service pattern. The plot shows variations in service frequency across hours and highlights the primary service pattern.
</p>


<h3>Value</h3>

<p>A 'plotly' interactive plot displaying the frequency distribution by hour for each selected route, with:
</p>
<p>- Hourly Frequency: A line for each route, indicating its frequency distribution across the day.
</p>
<p>- Service Patterns: Transparency levels indicate different service patterns, with the primary pattern highlighted.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::filter_route()], [GTFSwizard::get_frequency()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Plot frequency by hour for specific routes
plot_routefrequency(for_rail_gtfs, route = for_rail_gtfs$routes$route_id[1:2])
}

</code></pre>

<hr>
<h2 id='read_gtfs'>Read GTFS file</h2><span id='topic+read_gtfs'></span>

<h3>Description</h3>

<p>Reads GTFS files from a .zip file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_gtfs(file.path, files = NULL, quiet = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_gtfs_+3A_file.path">file.path</code></td>
<td>
<p>A path to a .zip GTFS file.</p>
</td></tr>
<tr><td><code id="read_gtfs_+3A_files">files</code></td>
<td>
<p>A character vector containing the text files to be read from the GTFS zip (without the .txt extension). Defaults to NULL, which reads all files.</p>
</td></tr>
<tr><td><code id="read_gtfs_+3A_quiet">quiet</code></td>
<td>
<p>Logical. If TRUE, suppresses messages from gtfsio::import_gtfs(). Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="read_gtfs_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to gtfsio::import_gtfs().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no specific files are indicated, all GTFS files within the zip archive are read. After importing, the function converts the GTFS data into a 'wizardgtfs' object, which is tailored for efficient handling and analysis of transit data.
</p>


<h3>Value</h3>

<p>A 'wizardgtfs' object: a list of tibbles representing each text file in the .zip and a tibble for services by date.
</p>


<h3>Note</h3>

<p>Additional notes can be added here if needed.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gtfs_data &lt;- read_gtfs("path/to/gtfs.zip")

## End(Not run)

</code></pre>

<hr>
<h2 id='selection'>Select Subsets of GTFS Data</h2><span id='topic+selection'></span><span id='topic+unselection'></span>

<h3>Description</h3>

<p>The ‚Äúselection‚Äù function makes a selection in the GTFS file without altering or filtering the GTFS file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selection(gtfs, ..., add = FALSE)

unselection(gtfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selection_+3A_gtfs">gtfs</code></td>
<td>
<p>An object representing GTFS data. It can be a list or a 'wizardgtfs' class gtfsect.</p>
</td></tr>
<tr><td><code id="selection_+3A_...">...</code></td>
<td>
<p>Expressions used to filter the data within 'gtfs'. The expressions can operate on four GTFS variables:
</p>

<dl>
<dt><code>"stop_id"</code></dt><dd><p>Select the GTFS by stops using a vector of stop_id, must be character.</p>
</dd>
<dt><code>"route_id"</code></dt><dd><p>Select the GTFS by routes using a vector of route_id, must be character.</p>
</dd>
<dt><code>"trip_id"</code></dt><dd><p>Select the GTFS by trip using a vector of trip_id, must be character.</p>
</dd>
<dt><code>"geometry"</code></dt><dd><p>Select the GTFS by stops using an 'sf', 'sfc', or 'sfg' object. The geometry predicate function is evaluated with the geometry of the GTFS stops. Available predicates are:
</p>
<p><code>%intersects%</code>
</p>
<p><code>%touches%</code>
</p>
<p><code>%within%</code>
</p>
<p><code>%equals%</code>
</p>
<p><code>%overlaps%</code>
</p>
<p><code>%contains%</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="selection_+3A_add">add</code></td>
<td>
<p>A logical argument. If 'TRUE', appends the new selection to existing ones in the gtfsect; otherwise, creates a new selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function evaluates the provided expressions in an environment restricted to recognized variables ('stop_id', 'route_id', 'trip_id', 'geometry'). An error is thrown if an unrecognized variable is used, indicating that only specific variables are allowed.
</p>


<h3>Value</h3>

<p>A 'wizardgtfs_selected' wizardgtfs, which is a modified version of the original attributes with the selections applied. If the expression yields no matches, returns the original gtfs unchanged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Apply the selection function
result &lt;- selection(for_rail_gtfs,
 stop_id == for_rail_gtfs$stops$stop_id[1] &amp; trip_id %in% for_rail_gtfs$trips$trip_id[1:5])

# Check the selection
class(result)
attr(result, 'selection')

# Use geometry selection
bbox &lt;- sf::st_bbox(c(
  xmin = -38.57219059002416,
  ymin = -3.7999496173114118,
  xmax = -38.50455165901261,
  ymax = -3.756631724636505
),
crs = sf::st_crs(4326))  # Set CRS to WGS 84

# Convert the bounding box to a polygon
polygon &lt;- sf::st_as_sfc(bbox)

result &lt;- selection(for_rail_gtfs, geometry %intersects% polygon)

</code></pre>

<hr>
<h2 id='set_dwelltime'>Set Dwell Time for GTFS Stops</h2><span id='topic+set_dwelltime'></span>

<h3>Description</h3>

<p>The 'set_dwelltime' function updates the arrival and departure times in the 'stop_times' table of a GTFS object based on a specified dwell time duration. The function modifies the dwell time for selected trips and stops, or for all trips and stops by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_dwelltime(gtfs, duration = 30, trips = "all", stops = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_dwelltime_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, preferably of class 'wizardgtfs'. If not, the function will attempt to convert it using 'GTFSwizard::as_wizardgtfs()'.</p>
</td></tr>
<tr><td><code id="set_dwelltime_+3A_duration">duration</code></td>
<td>
<p>A numeric value specifying the desired dwell time in seconds. Defaults to 30 seconds.</p>
</td></tr>
<tr><td><code id="set_dwelltime_+3A_trips">trips</code></td>
<td>
<p>A character vector of trip IDs for which the dwell time will be updated. Use ''all'' to update all trips (default).</p>
</td></tr>
<tr><td><code id="set_dwelltime_+3A_stops">stops</code></td>
<td>
<p>A character vector of stop IDs for which the dwell time will be updated. Use ''all'' to update all stops (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the midpoint between the original 'arrival_time' and 'departure_time' for the specified trips and stops. It then adjusts these times based on the desired dwell time ('duration'), ensuring that the dwell time is evenly distributed around the midpoint.
</p>


<h3>Value</h3>

<p>A modified GTFS object with updated arrival and departure times in the 'stop_times' table.
</p>


<h3>Note</h3>

<p>Ensure the 'stop_times' table contains valid 'arrival_time' and 'departure_time' values. Empty or missing times may cause computation issues.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::as_wizardgtfs()], [GTFSwizard::get_dwelltimes()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set dwell time to 30 seconds for specific trips and stops
set_dwelltime(for_rail_gtfs, duration = 30,
               trips = for_rail_gtfs$trips$trip_id[1:2],
               stops = for_rail_gtfs$stops$stop_id[1:2])

</code></pre>

<hr>
<h2 id='split_trip'>Split a Trip into Sub-Trips within a GTFS Object</h2><span id='topic+split_trip'></span>

<h3>Description</h3>

<p>'split_trip' divides a specified trip in a 'wizardgtfs' object into multiple sub-trips by updating the stop sequences, trip identifiers, and related data, allowing for analysis or adjustments to different segments of the original trip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_trip(gtfs, trip, split = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_trip_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, ideally of class 'wizardgtfs'. If not, it will be converted.</p>
</td></tr>
<tr><td><code id="split_trip_+3A_trip">trip</code></td>
<td>
<p>A character vector specifying the 'trip_id' to be split.</p>
</td></tr>
<tr><td><code id="split_trip_+3A_split">split</code></td>
<td>
<p>An integer indicating the number of splits to apply. One split means two trip segments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- The function creates sub-trips by dividing the specified trip(s) into equal parts based on the stop sequence.
</p>
<p>- New trip IDs are generated for each sub-trip, and 'stop_times', 'trips', 'frequencies', and 'transfers' tables are updated accordingly.
</p>
<p>- If 'shape_dist_traveled' is present, it is adjusted to reflect distances within each new sub-trip.
</p>
<p>- After the split, the function re-generates the shapes table for the new trips using 'get_shapes', and merges it back into the 'wizardgtfs' object.
</p>
<p>- Be aware: 'get_shapes' reconstructs shapes using euclidean approximation and may not be accurate.
</p>
<p>- The maximum number of sections in a given trip is restricted by its amount of stops
</p>


<h3>Value</h3>

<p>A GTFS object with the specified trip split into new sub-trips.
</p>


<h3>Note</h3>

<p>'split_trip()' uses stop sequences to recriate the shapes table of split trips; accordingly, it should not be used after 'filter_time()', as this function removes invalid 'stop_times'.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::get_shapes()], [GTFSwizard::merge_gtfs()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Split a trip into 3 segments
gtfs_split &lt;- split_trip(for_rail_gtfs, trip = for_rail_gtfs$trips$trip_id[1:3], split = 2)

</code></pre>

<hr>
<h2 id='tidy_raptor'>Calculate Travel Times with RAPTOR Algorithm</h2><span id='topic+tidy_raptor'></span>

<h3>Description</h3>

<p>The 'tidy_raptor' function calculates travel times from a set of origin stops to all reachable stops within a GTFS dataset.
It uses the RAPTOR (Round-Based Public Transit Routing) algorithm from the 'tidytransit' package and integrates it with the GTFSwizard framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_raptor(
  gtfs,
  min_departure = "0:0:0",
  max_arrival = "23:59:59",
  dates = NULL,
  stop_ids,
  arrival = FALSE,
  time_range = 3600,
  max_transfers = NULL,
  keep = "all",
  filter = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_raptor_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object, preferably of class 'wizardgtfs'. If not, the function will attempt to convert it using 'GTFSwizard::as_wizardgtfs()'.</p>
</td></tr>
<tr><td><code id="tidy_raptor_+3A_min_departure">min_departure</code></td>
<td>
<p>A string representing the earliest departure time, in &quot;HH:MM:SS&quot; format. Defaults to '&quot;0:0:0&quot;'.</p>
</td></tr>
<tr><td><code id="tidy_raptor_+3A_max_arrival">max_arrival</code></td>
<td>
<p>A string representing the latest arrival time, in &quot;HH:MM:SS&quot; format. Defaults to '&quot;23:59:59&quot;'.</p>
</td></tr>
<tr><td><code id="tidy_raptor_+3A_dates">dates</code></td>
<td>
<p>A date (in '&quot;YYYY-MM-DD&quot;' format) to filter the GTFS dataset to specific calendar days. Defaults to 'NULL', meaning the furthest date.</p>
</td></tr>
<tr><td><code id="tidy_raptor_+3A_stop_ids">stop_ids</code></td>
<td>
<p>A character vector of stop IDs from where journeys should start (or end, if 'arrival = TRUE').</p>
</td></tr>
<tr><td><code id="tidy_raptor_+3A_arrival">arrival</code></td>
<td>
<p>Logical. If 'FALSE' (default), journeys start from 'stop_ids'. If 'TRUE', journeys end at 'stop_ids'.</p>
</td></tr>
<tr><td><code id="tidy_raptor_+3A_time_range">time_range</code></td>
<td>
<p>Either a range in seconds (numeric) or a vector with the minimal and maximal departure time (e.g., 'c(0, 3600)' or '&quot;HH:MM:SS&quot;') describing the journey window.</p>
</td></tr>
<tr><td><code id="tidy_raptor_+3A_max_transfers">max_transfers</code></td>
<td>
<p>Maximum number of transfers allowed. Defaults to 'NULL' (no limit).</p>
</td></tr>
<tr><td><code id="tidy_raptor_+3A_keep">keep</code></td>
<td>
<p>One of '&quot;all&quot;', '&quot;shortest&quot;', '&quot;earliest&quot;', or '&quot;latest&quot;'. Determines which journeys to retain:
- '&quot;all&quot;': All journeys are returned (default).
- '&quot;shortest&quot;': Only journeys with the shortest travel time.
- '&quot;earliest&quot;': Journeys arriving at stops the earliest.
- '&quot;latest&quot;': Journeys arriving at stops the latest.</p>
</td></tr>
<tr><td><code id="tidy_raptor_+3A_filter">filter</code></td>
<td>
<p>A logical to filter for min_departure, max_arrivel, and dates. Defaults to 'TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the RAPTOR algorithm results, including:
</p>

<dl>
<dt>from_stop_id</dt><dd><p>The ID of the stop where the journey starts.</p>
</dd>
<dt>to_stop_id</dt><dd><p>The ID of the stop where the journey ends.</p>
</dd>
<dt>departure_time</dt><dd><p>Departure time from the origin stop.</p>
</dd>
<dt>arrival_time</dt><dd><p>Arrival time at the destination stop.</p>
</dd>
<dt>travel_time</dt><dd><p>Total travel time in seconds.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Ensure that the 'stop_times' is present and correctly structured in the GTFS dataset.
Time values in 'min_departure', 'max_arrival', and 'time_range' should be correctly formatted to avoid errors.
'max_arrival' must be 23:59:59 or earlier.
</p>


<h3>See Also</h3>

<p>[tidytransit::raptor()], [GTFSwizard::as_wizardgtfs()], [GTFSwizard::filter_time()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tidy_raptor(for_rail_gtfs,
   min_departure = '06:20:00',
   max_arrival = '09:40:00',
   dates = "2021-12-13",
   max_transfers = 2,
   keep = "all",
   stop_ids = '66')

</code></pre>

<hr>
<h2 id='write_gtfs'>Write GTFS Data to Zip File</h2><span id='topic+write_gtfs'></span>

<h3>Description</h3>

<p>'write_gtfs' exports a GTFS object to a zip file format, suitable for use in various GTFS-compatible software. This function supports multiple GTFS object formats and ensures compatibility by converting data frames and spatial objects as needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_gtfs(gtfs, zipfile, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_gtfs_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS object. This can be in 'wizardgtfs' or list format.</p>
</td></tr>
<tr><td><code id="write_gtfs_+3A_zipfile">zipfile</code></td>
<td>
<p>A character string specifying the path to the output zip file.</p>
</td></tr>
<tr><td><code id="write_gtfs_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to 'gtfsio::export_gtfs()'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function converts spatial data frames (e.g., shapes and stops) to standard data frames, removes additional service pattern tables, and exports.
</p>


<h3>Value</h3>

<p>None. This function writes the GTFS data directly to the specified 'zipfile'.
</p>


<h3>See Also</h3>

<p>[GTFSwizard::read_gtfs()], [GTFSwizard::as_wizardgtfs()],
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Export a wizardgtfs object to a zip file
write_gtfs(for_rail_gtfs, "gtfs_export.zip")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
