<!DOCTYPE html><html lang="en"><head><title>Help for package joineRML</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {joineRML}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#joineRML-package'><p>joineRML: Joint Modelling of Multivariate Longitudinal Data and Time-to-Event Outcomes</p></a></li>
<li><a href='#baseHaz'><p>The baseline hazard estimate of an <code>mjoint</code> object</p></a></li>
<li><a href='#bootSE'><p>Standard errors via bootstrap for an <code>mjoint</code> object</p></a></li>
<li><a href='#confint.mjoint'><p>Confidence intervals for model parameters of an <code>mjoint</code> object</p></a></li>
<li><a href='#dynLong'><p>Dynamic predictions for the longitudinal data sub-model</p></a></li>
<li><a href='#dynSurv'><p>Dynamic predictions for the time-to-event data sub-model</p></a></li>
<li><a href='#epileptic.qol'><p>Quality of life data following epilepsy drug treatment</p></a></li>
<li><a href='#fitted.mjoint'><p>Extract <code>mjoint</code> fitted values</p></a></li>
<li><a href='#fixef.mjoint'><p>Extract fixed effects estimates from an <code>mjoint</code> object</p></a></li>
<li><a href='#formula.mjoint'><p>Extract model formulae from an <code>mjoint</code> object</p></a></li>
<li><a href='#getVarCov.mjoint'><p>Extract variance-covariance matrix of random effects from an <code>mjoint</code></p>
object</a></li>
<li><a href='#heart.valve'><p>Aortic valve replacement surgery data</p></a></li>
<li><a href='#joineRML'><p>joineRML</p></a></li>
<li><a href='#logLik.mjoint'><p>Extract log-likelihood from an <code>mjoint</code> object</p></a></li>
<li><a href='#mjoint'><p>Fit a joint model to time-to-event data and multivariate longitudinal data</p></a></li>
<li><a href='#mjoint_tidiers'><p>Tidying methods for joint models for time-to-event data and multivariate</p>
longitudinal data</a></li>
<li><a href='#mjoint.object'><p>Fitted <code>mjoint</code> object</p></a></li>
<li><a href='#pbc2'><p>Mayo Clinic primary biliary cirrhosis data</p></a></li>
<li><a href='#plot.dynLong'><p>Plot a <code>dynLong</code> object</p></a></li>
<li><a href='#plot.dynSurv'><p>Plot a <code>dynSurv</code> object</p></a></li>
<li><a href='#plot.mjoint'><p>Plot diagnostics from an <code>mjoint</code> object</p></a></li>
<li><a href='#plot.ranef.mjoint'><p>Plot a <code>ranef.mjoint</code> object</p></a></li>
<li><a href='#plotConvergence'><p>Plot convergence time series for parameter vectors from an <code>mjoint</code></p>
object</a></li>
<li><a href='#ranef.mjoint'><p>Extract random effects estimates from an <code>mjoint</code> object</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#renal'><p>Renal transplantation data</p></a></li>
<li><a href='#residuals.mjoint'><p>Extract <code>mjoint</code> residuals</p></a></li>
<li><a href='#sampleData'><p>Sample from an <code>mjoint</code> object</p></a></li>
<li><a href='#sigma.mjoint'><p>Extract residual standard deviation(s) from an <code>mjoint</code> object</p></a></li>
<li><a href='#simData'><p>Simulate data from a joint model</p></a></li>
<li><a href='#summary.mjoint'><p>Summary of an <code>mjoint</code> object</p></a></li>
<li><a href='#vcov.mjoint'><p>Extract an approximate variance-covariance matrix of estimated parameters</p>
from an <code>mjoint</code> object</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Joint Modelling of Multivariate Longitudinal Data and
Time-to-Event Outcomes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.7</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits the joint model proposed by Henderson and colleagues (2000) 
    &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2F1.4.465">doi:10.1093/biostatistics/1.4.465</a>&gt;, but extended to the case of multiple 
    continuous longitudinal measures. The time-to-event data is modelled using a 
    Cox proportional hazards regression model with time-varying covariates. The 
    multiple longitudinal outcomes are modelled using a multivariate version of the 
    Laird and Ware linear mixed model. The association is captured by a multivariate
    latent Gaussian process. The model is estimated using a Monte Carlo Expectation 
    Maximization algorithm. This project was funded by the Medical Research Council 
    (Grant number MR/M013227/1).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/graemeleehickey/joineRML">https://github.com/graemeleehickey/joineRML</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/graemeleehickey/joineRML/issues">https://github.com/graemeleehickey/joineRML/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), nlme, survival</td>
</tr>
<tr>
<td>Imports:</td>
<td>cobs, doParallel, foreach, generics, ggplot2, graphics, lme4
(&ge; 1.1-8), MASS, Matrix, mvtnorm, parallel, randtoolbox, Rcpp
(&ge; 0.12.7), RcppArmadillo, stats, tibble, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bindrcpp, dplyr, JM, joineR, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-04 15:47:38 UTC; hickeg3</td>
</tr>
<tr>
<td>Author:</td>
<td>Graeme L. Hickey <a href="https://orcid.org/0000-0002-4989-0054"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Pete Philipson <a href="https://orcid.org/0000-0001-7846-0208"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Andrea Jorgensen <a href="https://orcid.org/0000-0002-6977-9337"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ruwanthi Kolamunnage-Dona
    <a href="https://orcid.org/0000-0003-3886-6208"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Paula Williamson <a href="https://orcid.org/0000-0001-9802-6636"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Dimitris Rizopoulos [ctb, dtc] (data/renal.rda, R/hessian.R, R/vcov.R),
  Alessandro Gasparini
    <a href="https://orcid.org/0000-0002-8319-7624"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Medical Research Council [fnd] (Grant number: MR/M013227/1)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Graeme L. Hickey &lt;graemeleehickey@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-04 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='joineRML-package'>joineRML: Joint Modelling of Multivariate Longitudinal Data and Time-to-Event Outcomes</h2><span id='topic+joineRML-package'></span>

<h3>Description</h3>

<p>Fits the joint model proposed by Henderson and colleagues (2000) <a href="https://doi.org/10.1093/biostatistics/1.4.465">doi:10.1093/biostatistics/1.4.465</a>, but extended to the case of multiple continuous longitudinal measures. The time-to-event data is modelled using a Cox proportional hazards regression model with time-varying covariates. The multiple longitudinal outcomes are modelled using a multivariate version of the Laird and Ware linear mixed model. The association is captured by a multivariate latent Gaussian process. The model is estimated using a Monte Carlo Expectation Maximization algorithm. This project was funded by the Medical Research Council (Grant number MR/M013227/1).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Graeme L. Hickey <a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a> (<a href="https://orcid.org/0000-0002-4989-0054">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Pete Philipson <a href="mailto:peter.philipson1@newcastle.ac.uk">peter.philipson1@newcastle.ac.uk</a> (<a href="https://orcid.org/0000-0001-7846-0208">ORCID</a>)
</p>
</li>
<li><p> Ruwanthi Kolamunnage-Dona <a href="mailto:kdrr@liverpool.ac.uk">kdrr@liverpool.ac.uk</a> (<a href="https://orcid.org/0000-0003-3886-6208">ORCID</a>)
</p>
</li>
<li><p> Alessandro Gasparini <a href="mailto:alessandro.gasparini@ki.se">alessandro.gasparini@ki.se</a> (<a href="https://orcid.org/0000-0002-8319-7624">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Andrea Jorgensen <a href="mailto:aljorgen@liverpool.ac.uk">aljorgen@liverpool.ac.uk</a> (<a href="https://orcid.org/0000-0002-6977-9337">ORCID</a>) [contributor]
</p>
</li>
<li><p> Paula Williamson <a href="mailto:p.r.williamson@liverpool.ac.uk">p.r.williamson@liverpool.ac.uk</a> (<a href="https://orcid.org/0000-0001-9802-6636">ORCID</a>) [contributor]
</p>
</li>
<li><p> Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a> (data/renal.rda, R/hessian.R, R/vcov.R) [contributor, data contributor]
</p>
</li>
<li><p> Medical Research Council (Grant number: MR/M013227/1) [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/graemeleehickey/joineRML">https://github.com/graemeleehickey/joineRML</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/graemeleehickey/joineRML/issues">https://github.com/graemeleehickey/joineRML/issues</a>
</p>
</li></ul>


<hr>
<h2 id='baseHaz'>The baseline hazard estimate of an <code>mjoint</code> object</h2><span id='topic+baseHaz'></span>

<h3>Description</h3>

<p>This function returns the (baseline) hazard increment from a
fitted <code>mjoint</code> object. In addition, it can report either the
<em>uncentered</em> or the more ubiquitous <em>centered</em> version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseHaz(object, centered = TRUE, se = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="baseHaz_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="baseHaz_+3A_centered">centered</code></td>
<td>
<p>logical: should the baseline hazard be for the mean-centered
covariates model or not? Default is <code>centered=TRUE</code>. See
<strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="baseHaz_+3A_se">se</code></td>
<td>
<p>logical: should standard errors be approximated for the hazard
increments? Default is <code>se=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When covariates are included in the time-to-event sub-model,
<code><a href="#topic+mjoint">mjoint</a></code> automatically centers them about their respective
means. This also applies to non-continuous covariates, which are first
coded using a dummy-transformation for the design matrix and subsequently
centered. The reason for the mean-centering is to improve numerical
stability, as the survival function involves exponential terms. Extracting
the baseline hazard increments from <code><a href="#topic+mjoint.object">mjoint.object</a></code> returns the
Breslow hazard estimate (Lin, 2007) that corresponds to this mean-centered
model. This is the same as is done in the R <code>survival</code> package when
using <code><a href="survival.html#topic+coxph.detail">coxph.detail</a></code> (Therneau and Grambsch, 2000).
If the user wants to access the baseline hazard estimate for the model in
which no mean-centering is applied, then they can use this function, which
scales the mean-centered baseline hazard by
</p>
<p style="text-align: center;"><code class="reqn">\exp\{-\bar{w}^\top \gamma_v\},</code>
</p>

<p>where <code class="reqn">\bar{w}</code> is a vector of the means from the time-to-event
sub-model design matrix.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with two columns: the unique failure times and
the estimate baseline hazard. If <code>se=TRUE</code>, then a third column is
appended with the corresponding standard errors (for the centred case).
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Therneau TM, Grambsch PM. <em>Modeling Survival Data: Extending the Cox
Model.</em> New Jersey: Springer-Verlag; 2000.
</p>
<p>Lin DY. On the Breslow estimator. <em>Lifetime Data Anal.</em> 2007;
<strong>13(4)</strong>: 471-480.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjoint">mjoint</a></code> and <code><a href="stats.html#topic+coef">coef</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)
baseHaz(fit2, centered = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='bootSE'>Standard errors via bootstrap for an <code>mjoint</code> object</h2><span id='topic+bootSE'></span>

<h3>Description</h3>

<p>This function takes a model fit from an <code>mjoint</code> object and
calculates standard errors and confidence intervals for the main
longitudinal and survival coefficient parameters, including the latent
association parameters, using bootstrapping (Efron and Tibshirani, 2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootSE(
  object,
  nboot = 100,
  ci = 0.95,
  use.mle = TRUE,
  verbose = FALSE,
  control = list(),
  progress = TRUE,
  ncores = 1L,
  safe.boot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootSE_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="bootSE_+3A_nboot">nboot</code></td>
<td>
<p>the number of bootstrap samples. Default is <code>nboot=100</code>.</p>
</td></tr>
<tr><td><code id="bootSE_+3A_ci">ci</code></td>
<td>
<p>the confidence interval to be estimated using the
percentile-method. Default is <code>ci=0.95</code> for a 95% confidence
interval.</p>
</td></tr>
<tr><td><code id="bootSE_+3A_use.mle">use.mle</code></td>
<td>
<p>logical: should the algorithm use the maximizer from the
converged model in <code>object</code> as initial values for coefficients in each
bootstrap iteration. Default is <code>use.mle=TRUE</code>.</p>
</td></tr>
<tr><td><code id="bootSE_+3A_verbose">verbose</code></td>
<td>
<p>logical: if <code>TRUE</code>, the parameter estimates and other
convergence statistics are value are printed at each iteration of the MCEM
algorithm. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bootSE_+3A_control">control</code></td>
<td>
<p>a list of control values with components: </p>

<dl>
<dt><code>nMC</code></dt><dd><p>integer: the initial number of Monte Carlo samples to be
used for integration in the burn-in phase of the MCEM. Default is
<code>nMC=</code>100<em>K</em>.</p>
</dd>
<dt><code>nMCscale</code></dt><dd><p>integer: the scale factor for the increase in Monte
Carlo size when Monte Carlo has not reduced from the previous iteration.
Default is <code>nMCscale=5</code>.</p>
</dd>
<dt><code>nMCmax</code></dt><dd><p>integer: the maximum number of Monte Carlo samples
that the algorithm is allowed to reach. Default is <code>nMCmax=20000</code>.</p>
</dd>
<dt><code>burnin</code></dt><dd><p>integer: the number of iterations for 'burn-in' phase
of the optimization algorithm. It is computationally inefficient to use a
large number of Monte Carlo samples early on until one is approximately
near the maximum likelihood estimate. Default is <code>burnin=</code>100<em>K</em>
for <code>type='antithetic'</code> or <code>type='montecarlo'</code> and
<code>burnin=</code>5 for <code>type='sobol'</code> or <code>type='halton'</code>. For
standard methods, such a large burn-in will generally be unnecessary and
can be reduced on an application-specific basis.</p>
</dd>
<dt><code>mcmaxIter</code></dt><dd><p>integer: the maximum number of MCEM algorithm
iterations allowed. Default is <code>mcmaxIter=burnin+200</code>.</p>
</dd>
<dt><code>convCrit</code></dt><dd><p>character string: the convergence criterion to be
used. See <strong>Details</strong>.</p>
</dd>
<dt><code>gammaOpt</code></dt><dd><p>character string: by default (<code>gammaOpt='NR'</code>),
<code class="reqn">\gamma</code> is updated using a one-step Newton-Raphson iteration, with the
Hessian matrix calculated exactly. If <code>gammaOpt='GN'</code>, a Gauss-Newton
algorithm-type iteration is implemented, where the Hessian matrix is
approximated based on calculations similar to those used for calculating
the empirical information matrix? If it is used, then the step-length is
adjusted by a nominal scaling parameter of 0.5 in order to reduce the
chance of over-shooting the maximizer.</p>
</dd>
<dt><code>tol0</code></dt><dd><p>numeric: tolerance value for convergence in the
parameters; see <strong>Details</strong>. Default is <code>tol0=1e-03</code>.</p>
</dd>
<dt><code>tol1</code></dt><dd><p>numeric: tolerance value for convergence in the
parameters; see <strong>Details</strong>. Default is <code>tol1=1e-03</code>.</p>
</dd>
<dt><code>tol2</code></dt><dd><p>numeric: tolerance value for convergence in the
parameters; see <strong>Details</strong>. Default is <code>tol2=5e-03</code> for
<code>type='antithetic'</code> or <code>type='montecarlo'</code> and <code>tol2=1e-03</code>
for <code>type='sobol'</code> or <code>type='halton'</code>.</p>
</dd>
<dt><code>tol.em</code></dt><dd><p>numeric: tolerance value for convergence in the
multivariate linear mixed model (MV-LMM). When <code class="reqn">K &gt; 1</code>, the optimal
initial parameters are those from the MV-LMM, which is estimated using a
separate EM algorithm. Since both the E- and M-steps are available in
closed-form, this algorithm convergences relatively rapidly with a high
precision. Default is min(<code>1e-04</code>, <code>tol2</code>).</p>
</dd>
<dt><code>rav</code></dt><dd><p>numeric: threshold when using <code>convCrit='sas'</code> that
applies absolute change (when <code class="reqn">&lt;</code><code>rav</code>) or relative change (when
<code class="reqn">\ge</code><code>rav</code>) criterion; see <strong>Details</strong>. Default is
<code>0.1</code>, which is an order of magnitude higher than the SAS
implementation.</p>
</dd>
<dt><code>type</code></dt><dd><p>character: type of Monte Carlo integration method to
use. Options are </p>

<dl>
<dt><code>type='montecarlo'</code></dt><dd><p>Vanilla Monte Carlo sampling.</p>
</dd>
<dt><code>type='antithetic'</code></dt><dd><p>Variance reduction method using antithetic
simulation. This is the default option.</p>
</dd>
<dt><code>type='sobol'</code></dt><dd><p>Quasi-Monte Carlo with a low
deterministic Sobol sequence with Owen-type scrambling.</p>
</dd>
<dt><code>type='halton'</code></dt><dd><p>Quasi-Monte Carlo with a low deterministic
Halton sequence.</p>
</dd>
</dl>
</dd>
</dl>
</td></tr>
<tr><td><code id="bootSE_+3A_progress">progress</code></td>
<td>
<p>logical: should a progress bar be shown on the console to
indicate the percentage of bootstrap iterations completed? Default is
<code>progress=TRUE</code>.</p>
</td></tr>
<tr><td><code id="bootSE_+3A_ncores">ncores</code></td>
<td>
<p>integer: if more than one core is available, then the <code>bootSE</code>
function can run in parallel via the <code><a href="foreach.html#topic+foreach">foreach</a></code>
function. By default, <code>ncores=1</code>, which defaults to serial mode. Note
that if <code>ncores</code>&gt;1, then <code>progress</code> is set to <code>FALSE</code> by
default, as it is not possible to display progress bars for parallel
processes at the current time.</p>
</td></tr>
<tr><td><code id="bootSE_+3A_safe.boot">safe.boot</code></td>
<td>
<p>logical: should each bootstrap replication be wrapped in a
<code><a href="base.html#topic+tryCatch">tryCatch</a></code> statement to catch errors (e.g. during the
optimisation progress)? When model fitting throws errors, a new bootstrap
sample is drawn for the current iteration and the model is re-fit; this
process continues until a model fits successfully. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bootSE_+3A_...">...</code></td>
<td>
<p>options passed to the <code>control</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard errors and confidence intervals are obtained by repeated
fitting of the requisite joint model to bootstrap samples of the original
longitudinal and time-to-event data. Note that bootstrap is done by
sampling subjects, not individual records.
</p>


<h3>Value</h3>

<p>An object of class <code>bootSE</code>.
</p>


<h3>Note</h3>

<p>This function is computationally intensive. A dynamic progress bar is
displayed showing the percentage of bootstrap models fitted. On computer
systems with more than one core available, computational time can be
reduced by passing the argument <code>ncores</code> (with integer value &gt;1) to
<code>bootSE</code>, which implements parallel processing via the
<code><a href="foreach.html#topic+foreach">foreach</a></code> package. <strong>Note:</strong> if parallel
processing is implemented, then the progress bar is not displayed.
</p>
<p>Due to random sampling, an <code>mjoint</code> model fitted to some bootstrap
samples may not converge within the specified control parameter settings.
The <code>bootSE</code> code discards any models that failed to converge when
calculating the standard errors and confidence intervals. If a large
proportion of models have failed to converge, it is likely that it will
need to be refitted with changes to the <code>control</code> arguments.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Efron B, Tibshirani R. <em>An Introduction to the Bootstrap.</em> 2000; Boca
Raton, FL: Chapman &amp; Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjoint">mjoint</a></code> for approximate standard errors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)

fit.boot &lt;- bootSE(fit, 50, use.mle = TRUE, control = list(
    burnin = 25, convCrit = "either",
    tol0 = 6e-03, tol2 = 6e-03, mcmaxIter = 60))

## End(Not run)
</code></pre>

<hr>
<h2 id='confint.mjoint'>Confidence intervals for model parameters of an <code>mjoint</code> object</h2><span id='topic+confint.mjoint'></span>

<h3>Description</h3>

<p>This function computes confidence intervals for one or more
parameters in a fitted <code>mjoint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
confint(
  object,
  parm = c("Both", "Longitudinal", "Event"),
  level = 0.95,
  bootSE = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.mjoint_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="confint.mjoint_+3A_parm">parm</code></td>
<td>
<p>a character string specifying which sub-model parameter
confidence intervals should be returned for. Can be specified as
<code>parm='Longitudinal'</code> (multivariate longitudinal sub-model),
<code>parm='Event'</code> (time-to-event sub-model), or <code>parm='both'</code>
(default).</p>
</td></tr>
<tr><td><code id="confint.mjoint_+3A_level">level</code></td>
<td>
<p>the confidence level required. Default is <code>level=0.95</code> for
a 95% confidence interval.</p>
</td></tr>
<tr><td><code id="confint.mjoint_+3A_bootse">bootSE</code></td>
<td>
<p>an object inheriting from class <code>bootSE</code> for the
corresponding model. If <code>bootSE=NULL</code>, the function will attempt to
utilize approximate standard error estimates (if available) calculated from
the empirical information matrix.</p>
</td></tr>
<tr><td><code id="confint.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the confidence intervals for either the
longitudinal, time-to-event, or both sub-models.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>McLachlan GJ, Krishnan T. <em>The EM Algorithm and Extensions.</em> Second
Edition. Wiley-Interscience; 2008.
</p>
<p>Henderson R, Diggle PJ, Dobson A. Joint modelling of longitudinal
measurements and event time data. <em>Biostatistics.</em> 2000; <strong>1(4)</strong>:
465-480.
</p>
<p>Lin H, McCulloch CE, Mayne ST. Maximum likelihood estimation in the joint
analysis of time-to-event and multiple longitudinal variables. <em>Stat
Med.</em> 2002; <strong>21</strong>: 2369-2382.
</p>
<p>Wulfsohn MS, Tsiatis AA. A joint model for survival and longitudinal data
measured with error. <em>Biometrics.</em> 1997; <strong>53(1)</strong>: 330-339.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjoint">mjoint</a></code>, <code><a href="#topic+bootSE">bootSE</a></code>, and
<code><a href="stats.html#topic+confint">confint</a></code> for the generic method description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a classical univariate joint model with a single longitudinal outcome
# and a single time-to-event outcome

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

gamma &lt;- c(0.1059417, 1.0843359)
sigma2 &lt;- 0.03725999
beta &lt;- c(4.9988669999, -0.0093527634, 0.0004317697)
D &lt;- matrix(c(0.128219108, -0.006665505, -0.006665505, 0.002468688),
            nrow = 2, byrow = TRUE)

set.seed(1)
fit1 &lt;- mjoint(formLongFixed = log.lvmi ~ time + age,
    formLongRandom = ~ time | num,
    formSurv = Surv(fuyrs, status) ~ age,
    data = hvd,
    timeVar = "time",
    inits = list(gamma = gamma, sigma2 = sigma2, beta = beta, D = D),
    control = list(nMCscale = 2, burnin = 5)) # controls for illustration only

confint(fit1, parm = "Longitudinal")

## End(Not run)

## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)
confint(fit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='dynLong'>Dynamic predictions for the longitudinal data sub-model</h2><span id='topic+dynLong'></span>

<h3>Description</h3>

<p>Calculates the conditional expected longitudinal values for a
<em>new</em> subject from the last observation time given their longitudinal
history data and a fitted <code>mjoint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynLong(
  object,
  newdata,
  newSurvData = NULL,
  u = NULL,
  type = "first-order",
  M = 200,
  scale = 1.6,
  ci,
  progress = TRUE,
  ntimes = 100,
  level = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynLong_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="dynLong_+3A_newdata">newdata</code></td>
<td>
<p>a list of <code>data.frame</code> objects for each longitudinal
outcome for a single new patient in which to interpret the variables named
in the <code>formLongFixed</code> and <code>formLongRandom</code> formulae of
<code>object</code>. As per <code><a href="#topic+mjoint">mjoint</a></code>, the <code>list</code> structure
enables one to include multiple longitudinal outcomes with different
measurement protocols. If the multiple longitudinal outcomes are measured
at the same time points for each patient, then a <code>data.frame</code> object
can be given instead of a <code>list</code>. It is assumed that each data frame
is in long format.</p>
</td></tr>
<tr><td><code id="dynLong_+3A_newsurvdata">newSurvData</code></td>
<td>
<p>a <code>data.frame</code> in which to interpret the variables
named in the <code>formSurv</code> formulae from the <code>mjoint</code> object. This
is optional, and if omitted, the data will be searched for in
<code>newdata</code>. Note that no event time or censoring indicator data are
required for dynamic prediction. Defaults to <code>newSurvData=NULL</code>.</p>
</td></tr>
<tr><td><code id="dynLong_+3A_u">u</code></td>
<td>
<p>an optional time that must be greater than the last observed
measurement time. If omitted (default is <code>u=NULL</code>), then conditional
failure probabilities are reported for <em>all</em> observed failure times in
the <code>mjoint</code> object data from the last known follow-up time of the
subject.</p>
</td></tr>
<tr><td><code id="dynLong_+3A_type">type</code></td>
<td>
<p>a character string for whether a first-order
(<code>type="first-order"</code>) or Monte Carlo simulation approach
(<code>type="simulated"</code>) should be used for the dynamic prediction.
Defaults to the computationally faster first-order prediction method.</p>
</td></tr>
<tr><td><code id="dynLong_+3A_m">M</code></td>
<td>
<p>for <code>type="simulated"</code>, the number of simulations to performs.
Default is <code>M=200</code>.</p>
</td></tr>
<tr><td><code id="dynLong_+3A_scale">scale</code></td>
<td>
<p>a numeric scalar that scales the variance parameter of the
proposal distribution for the Metropolis-Hastings algorithm, which
therefore controls the acceptance rate of the sampling algorithm.</p>
</td></tr>
<tr><td><code id="dynLong_+3A_ci">ci</code></td>
<td>
<p>a numeric value with value in the interval <code class="reqn">(0, 1)</code> specifying
the confidence interval level for predictions of <code>type='simulated'</code>.
If missing, defaults to <code>ci=0.95</code> for a 95% confidence interval. If
<code>type='first-order'</code> is used, then this argument is ignored.</p>
</td></tr>
<tr><td><code id="dynLong_+3A_progress">progress</code></td>
<td>
<p>logical: should a progress bar be shown on the console to
indicate the percentage of simulations completed? Default is
<code>progress=TRUE</code>.</p>
</td></tr>
<tr><td><code id="dynLong_+3A_ntimes">ntimes</code></td>
<td>
<p>an integer controlling the number of points to discretize the
extrapolated time region into. Default is <code>ntimes=100</code>.</p>
</td></tr>
<tr><td><code id="dynLong_+3A_level">level</code></td>
<td>
<p>an optional integer giving the level of grouping to be used in
extracting the residuals from object. Level values increase from outermost
to innermost grouping, with level 0 corresponding to the population model
fit and level 1 corresponding to subject-specific model fit. Defaults to
<code>level=1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dynamic predictions for the longitudinal data sub-model based on an
observed measurement history for the longitudinal outcomes of a new subject
are based on either a first-order approximation or Monte Carlo simulation
approach, both of which are described in Rizopoulos (2011). Namely, given
that the subject was last observed at time <em>t</em>, we calculate the
conditional expectation of each longitudinal outcome at time <em>u</em> as
</p>
<p style="text-align: center;"><code class="reqn">E[y_k(u) | T \ge t, y, \theta] \approx x^T(u)\beta_k +
  z^T(u)\hat{b}_k,</code>
</p>

<p>where <code class="reqn">T</code> is the failure time for the new subject, and <code class="reqn">y</code> is the
stacked-vector of longitudinal measurements up to time <em>t</em>.
</p>
<p><strong>First order predictions</strong>
</p>
<p>For <code>type="first-order"</code>, <code class="reqn">\hat{b}</code> is the mode of the posterior
distribution of the random effects given by
</p>
<p style="text-align: center;"><code class="reqn">\hat{b} = {\arg \max}_b f(b | y, T \ge t; \theta).</code>
</p>

<p>The predictions are based on plugging in <code class="reqn">\theta = \hat{\theta}</code>, which
is extracted from the <code>mjoint</code> object.
</p>
<p><strong>Monte Carlo simulation predictions</strong>
</p>
<p>For <code>type="simulated"</code>, <code class="reqn">\theta</code> is drawn from a multivariate
normal distribution with means <code class="reqn">\hat{\theta}</code> and variance-covariance
matrix both extracted from the fitted <code>mjoint</code> object via the
<code>coef()</code> and <code>vcov()</code> functions. <code class="reqn">\hat{b}</code> is drawn from the
the posterior distribution of the random effects
</p>
<p style="text-align: center;"><code class="reqn">f(b | y, T \ge t; \theta)</code>
</p>

<p>by means of a Metropolis-Hasting algorithm with independent multivariate
non-central <em>t</em>-distribution proposal distributions with
non-centrality parameter <code class="reqn">\hat{b}</code> from the first-order prediction and
variance-covariance matrix equal to <code>scale</code> <code class="reqn">\times</code> the inverse
of the negative Hessian of the posterior distribution. The choice os
<code>scale</code> can be used to tune the acceptance rate of the
Metropolis-Hastings sampler. This simulation algorithm is iterated <code>M</code>
times, at each time calculating the conditional survival probability.
</p>


<h3>Value</h3>

<p>A list object inheriting from class <code>dynLong</code>. The list returns
the arguments of the function and a list containing <em>K</em>
<code>data.frame</code>s of 2 columns, with first column (named
<code>timeVar[k]</code>; see <code><a href="#topic+mjoint">mjoint</a></code>) denoting times and the second
column (named <code>y.pred</code>) denoting the expected outcome at each time
point.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Rizopoulos D. Dynamic predictions and prospective accuracy in joint models
for longitudinal and time-to-event data. <em>Biometrics</em>. 2011;
<strong>67</strong>: 819–829.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjoint">mjoint</a></code>, <code><a href="#topic+dynSurv">dynSurv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)

hvd2 &lt;- droplevels(hvd[hvd$num == 1, ])
dynLong(fit2, hvd2)
dynLong(fit2, hvd2, u = 7) # outcomes at 7-years only

out &lt;- dynLong(fit2, hvd2, type = "simulated")
out

## End(Not run)
</code></pre>

<hr>
<h2 id='dynSurv'>Dynamic predictions for the time-to-event data sub-model</h2><span id='topic+dynSurv'></span>

<h3>Description</h3>

<p>Calculates the conditional time-to-event distribution for a
<em>new</em> subject from the last observation time given their longitudinal
history data and a fitted <code>mjoint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynSurv(
  object,
  newdata,
  newSurvData = NULL,
  u = NULL,
  horizon = NULL,
  type = "first-order",
  M = 200,
  scale = 2,
  ci,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynSurv_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="dynSurv_+3A_newdata">newdata</code></td>
<td>
<p>a list of <code>data.frame</code> objects for each longitudinal
outcome for a single new patient in which to interpret the variables named
in the <code>formLongFixed</code> and <code>formLongRandom</code> formulae of
<code>object</code>. As per <code><a href="#topic+mjoint">mjoint</a></code>, the <code>list</code> structure
enables one to include multiple longitudinal outcomes with different
measurement protocols. If the multiple longitudinal outcomes are measured
at the same time points for each patient, then a <code>data.frame</code> object
can be given instead of a <code>list</code>. It is assumed that each data frame
is in long format.</p>
</td></tr>
<tr><td><code id="dynSurv_+3A_newsurvdata">newSurvData</code></td>
<td>
<p>a <code>data.frame</code> in which to interpret the variables
named in the <code>formSurv</code> formulae from the <code>mjoint</code> object. This
is optional, and if omitted, the data will be searched for in
<code>newdata</code>. Note that no event time or censoring indicator data are
required for dynamic prediction. Defaults to <code>newSurvData=NULL</code>.</p>
</td></tr>
<tr><td><code id="dynSurv_+3A_u">u</code></td>
<td>
<p>an optional time that must be greater than the last observed
measurement time. If omitted (default is <code>u=NULL</code>), then conditional
failure probabilities are reported for <em>all</em> observed failure times in
the <code>mjoint</code> object data from the last known follow-up time of the
subject.</p>
</td></tr>
<tr><td><code id="dynSurv_+3A_horizon">horizon</code></td>
<td>
<p>an optional horizon time. Instead of specifying a specific
time <code>u</code> relative to the time origin, one can specify a horizon time
that is relative to the last known follow-up time. The prediction time is
essentially equivalent to <code>horizon</code> + <code class="reqn">t_{obs}</code>, where
<code class="reqn">t_{obs}</code> is the last known follow-up time where the patient had
not yet experienced the event. Default is <code>horizon=NULL</code>. If
<code>horizon</code> is non-<code>NULL</code>, then the output will be reported still
in terms of absolute time (from origin), <code>u</code>.</p>
</td></tr>
<tr><td><code id="dynSurv_+3A_type">type</code></td>
<td>
<p>a character string for whether a first-order
(<code>type="first-order"</code>) or Monte Carlo simulation approach
(<code>type="simulated"</code>) should be used for the dynamic prediction.
Defaults to the computationally faster first-order prediction method.</p>
</td></tr>
<tr><td><code id="dynSurv_+3A_m">M</code></td>
<td>
<p>for <code>type="simulated"</code>, the number of simulations to performs.
Default is <code>M=200</code>.</p>
</td></tr>
<tr><td><code id="dynSurv_+3A_scale">scale</code></td>
<td>
<p>a numeric scalar that scales the variance parameter of the
proposal distribution for the Metropolis-Hastings algorithm, which
therefore controls the acceptance rate of the sampling algorithm.</p>
</td></tr>
<tr><td><code id="dynSurv_+3A_ci">ci</code></td>
<td>
<p>a numeric value with value in the interval <code class="reqn">(0, 1)</code> specifying
the confidence interval level for predictions of <code>type='simulated'</code>.
If missing, defaults to <code>ci=0.95</code> for a 95% confidence interval. If
<code>type='first-order'</code> is used, then this argument is ignored.</p>
</td></tr>
<tr><td><code id="dynSurv_+3A_progress">progress</code></td>
<td>
<p>logical: should a progress bar be shown on the console to
indicate the percentage of simulations completed? Default is
<code>progress=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dynamic predictions for the time-to-event data sub-model based on an
observed measurement history for the longitudinal outcomes of a new subject
are based on either a first-order approximation or Monte Carlo simulation
approach, both of which are described in Rizopoulos (2011). Namely, given
that the subject was last observed at time <em>t</em>, we calculate the
conditional survival probability at time <code class="reqn">u &gt; t</code> as
</p>
<p style="text-align: center;"><code class="reqn">P[T \ge u | T \ge t; y, \theta] \approx \frac{S(u | \hat{b};
  \theta)}{S(t | \hat{b}; \theta)},</code>
</p>

<p>where <code class="reqn">T</code> is the failure time for the new subject, <code class="reqn">y</code> is the
stacked-vector of longitudinal measurements up to time <em>t</em> and
<code class="reqn">S(u | \hat{b}; \theta)</code> is the survival function.
</p>
<p><strong>First order predictions</strong>
</p>
<p>For <code>type="first-order"</code>, <code class="reqn">\hat{b}</code> is the mode
of the posterior distribution of the random effects given by
</p>
<p style="text-align: center;"><code class="reqn">\hat{b} = {\arg \max}_b f(b | y, T \ge t; \theta).</code>
</p>

<p>The predictions are based on plugging in <code class="reqn">\theta = \hat{\theta}</code>, which
is extracted from the <code>mjoint</code> object.
</p>
<p><strong>Monte Carlo simulation predictions</strong>
</p>
<p>For <code>type="simulated"</code>, <code class="reqn">\theta</code> is drawn from a multivariate
normal distribution with means <code class="reqn">\hat{\theta}</code> and variance-covariance
matrix both extracted from the fitted <code>mjoint</code> object via the
<code>coef()</code> and <code>vcov()</code> functions. <code class="reqn">\hat{b}</code> is drawn from the
the posterior distribution of the random effects
</p>
<p style="text-align: center;"><code class="reqn">f(b | y, T \ge t; \theta)</code>
</p>

<p>by means of a Metropolis-Hasting algorithm with independent multivariate
non-central <em>t</em>-distribution proposal distributions with
non-centrality parameter <code class="reqn">\hat{b}</code> from the first-order prediction and
variance-covariance matrix equal to <code>scale</code> <code class="reqn">\times</code> the inverse
of the negative Hessian of the posterior distribution. The choice os
<code>scale</code> can be used to tune the acceptance rate of the
Metropolis-Hastings sampler. This simulation algorithm is iterated <code>M</code>
times, at each time calculating the conditional survival probability.
</p>


<h3>Value</h3>

<p>A list object inheriting from class <code>dynSurv</code>. The list returns
the arguments of the function and a <code>data.frame</code> with first column
(named <code>u</code>) denoting times and the subsequent columns returning
summary statistics for the conditional failure probabilities For
<code>type="first-order"</code>, a single column named <code>surv</code> is appended.
For <code>type="simulated"</code>, four columns named <code>mean</code>, <code>median</code>,
<code>lower</code> and <code>upper</code> are appended, denoting the mean, median and
lower and upper confidence intervals from the Monte Carlo draws. Additional
objects are returned that are used in the intermediate calculations.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Rizopoulos D. Dynamic predictions and prospective accuracy in joint models
for longitudinal and time-to-event data. <em>Biometrics</em>. 2011;
<strong>67</strong>: 819–829.
</p>
<p>Taylor JMG, Park Y, Ankerst DP, Proust-Lima C, Williams S, Kestin L, et al.
Real-time individual predictions of prostate cancer recurrence using joint
models. <em>Biometrics</em>. 2013; <strong>69</strong>: 206–13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjoint">mjoint</a></code>, <code><a href="#topic+dynLong">dynLong</a></code>, and
<code><a href="#topic+plot.dynSurv">plot.dynSurv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)

hvd2 &lt;- droplevels(hvd[hvd$num == 1, ])
dynSurv(fit2, hvd2)
dynSurv(fit2, hvd2, u = 7) # survival at 7-years only

out &lt;- dynSurv(fit2, hvd2, type = "simulated")
out

## End(Not run)
</code></pre>

<hr>
<h2 id='epileptic.qol'>Quality of life data following epilepsy drug treatment</h2><span id='topic+epileptic.qol'></span>

<h3>Description</h3>

<p>The SANAD (Standard and New Antiepileptic Drugs) study (Marson
et al., 2007) is a randomised control trial of standard and new
antiepileptic drugs, comparing effects on longer term clinical outcomes.
Quality of life (QoL) data were collected by mail at baseline, 3 months,
and at 1 and 2 years using validated measures. This data is a subset of the
trial for 544 patients randomised to one of 2 drugs: carbamazepine and
lamotrigine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(epileptic.qol)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1853 observations on the following 9 variables:
</p>

<dl>
<dt><code>id</code></dt><dd><p>patients identifier; in total there are 544 patients.</p>
</dd>
<dt><code>with.time</code></dt><dd><p>number of days between registration and the earlier
of treatment failure or study analysis time.</p>
</dd>
<dt><code>trt</code></dt><dd><p>a factor with levels <code>CBZ</code> and <code>LTG</code> denoting
carbamazepine and lamotrigine, respectively.</p>
</dd>
<dt><code>with.status</code></dt><dd><p>the reason for treatment failure. Coded as
<code>0=</code>censored; <code>1=</code>unacceptable adverse effects;
<code>2=</code>inadequate seizure control.</p>
</dd>
<dt><code>time</code></dt><dd><p>the time the quality of life measures were recorded
(days). The first measurement for each subject is the baseline measurement,
however there was variability between the time taken to return the
questionnaires; hence the reason this is non-zero. Similarly, the second,
third, and fourth follow-up times, which were scheduled for 3-months,
1-year, and 2-years, respectively, also had variability in completion
times.</p>
</dd>
<dt><code>anxiety</code></dt><dd><p>a continuous measure of anxiety, as defined according
to the NEWQOL (Newly Diagnosed Epilepsy Quality of Life) assessment. Higher
scores are indicative of worse QoL.</p>
</dd>
<dt><code>depress</code></dt><dd><p>a continuous measure of depression, as defined
according to the NEWQOL (Newly Diagnosed Epilepsy Quality of Life)
assessment. Higher scores are indicative of worse QoL.</p>
</dd>
<dt><code>aep</code></dt><dd><p>a continuous measure of the Liverpool Adverse Events
Profile (AEP), as defined according to the NEWQOL (Newly Diagnosed Epilepsy
Quality of Life) assessment. Higher scores are indicative of worse QoL.</p>
</dd>
<dt><code>with.status2</code></dt><dd><p>a binary indicator of composite treatment
failure (for any reason), coded <code>status2=1</code>, or right-censoring
<code>status2=0</code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>SANAD Trial: University of Liverpool. See Jacoby et al. (2015).
</p>


<h3>References</h3>

<p>Jacoby A, Sudell M, Tudur Smith C, et al. Quality-of-life outcomes of
initiating treatment with standard and newer antiepileptic drugs in adults
with new-onset epilepsy: Findings from the SANAD trial. <em>Epilepsia</em>.
2015; <strong>56(3)</strong>: 460-472.
</p>
<p>Marson AG, Appleton R, Baker GA, et al. A randomised controlled trial
examining longer-term outcomes of standard versus new antiepileptic drugs.
The SANAD Trial. <em>Health Technology Assessment</em>. 2007; <strong>11(37)</strong>.
</p>
<p>Marson AG, Al-Kharusi AM, Alwaidh M, et al. The SANAD study of effectiveness
of carbamazepine, gabapentin, lamotrigine, oxcarbazepine, or topiramate for
treatment of partial epilepsy: an unblinded randomised controlled trial.
<em>Lancet</em>. 2007; <strong>365</strong>: 2007-2013.
</p>
<p>Abetz L, Jacoby A, Baker GA, et al. Patient-based assessments of quality of
life in newly diagnosed epilepsy patients: validation of the NEWQOL.
<em>Epilepsia</em>. 2000; <strong>41</strong>: 1119-1128.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbc2">pbc2</a></code>, <code><a href="#topic+heart.valve">heart.valve</a></code>, <code><a href="#topic+renal">renal</a></code>.
</p>

<hr>
<h2 id='fitted.mjoint'>Extract <code>mjoint</code> fitted values</h2><span id='topic+fitted.mjoint'></span>

<h3>Description</h3>

<p>The fitted values at level <em>i</em> are obtained by adding
together the population fitted values (based only on the fixed effects
estimates) and the estimated contributions of the random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
fitted(object, level = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.mjoint_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="fitted.mjoint_+3A_level">level</code></td>
<td>
<p>an optional integer giving the level of grouping to be used in
extracting the fitted values from object. Level values increase from outermost
to innermost grouping, with level 0 corresponding to the population
fitted values and level 1 corresponding to subject-specific fitted values Defaults
to level 0.</p>
</td></tr>
<tr><td><code id="fitted.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of length <em>K</em> with each element a vector of
fitted values for the <em>k</em>-th longitudinal outcome.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Pinheiro JC, Bates DM. <em>Mixed-Effects Models in S and S-PLUS.</em> New York:
Springer Verlag; 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjoint">mjoint</a></code>, <code><a href="#topic+residuals.mjoint">residuals.mjoint</a></code>
</p>

<hr>
<h2 id='fixef.mjoint'>Extract fixed effects estimates from an <code>mjoint</code> object</h2><span id='topic+fixef.mjoint'></span>

<h3>Description</h3>

<p>Extract fixed effects estimates from an <code>mjoint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
fixef(object, process = c("Longitudinal", "Event"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixef.mjoint_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="fixef.mjoint_+3A_process">process</code></td>
<td>
<p>character string: if <code>process='Longitudinal'</code> the fixed
effects coefficients from the (multivariate) longitudinal sub-model are
returned. Else, if <code>process='Event'</code>, the coefficients from the
time-to-event sub-model are returned.</p>
</td></tr>
<tr><td><code id="fixef.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of length equal to the number of sub-model
coefficients estimated.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Pinheiro JC, Bates DM. <em>Mixed-Effects Models in S and S-PLUS.</em> New York:
Springer Verlag; 2000.
</p>
<p>Wulfsohn MS, Tsiatis AA. A joint model for survival and longitudinal data
measured with error. <em>Biometrics.</em> 1997; <strong>53(1)</strong>: 330-339.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+fixef">fixef</a></code> for the generic method description, and
<code><a href="#topic+ranef.mjoint">ranef.mjoint</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a classical univariate joint model with a single longitudinal outcome
# and a single time-to-event outcome

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

set.seed(1)
fit1 &lt;- mjoint(formLongFixed = log.lvmi ~ time + age,
    formLongRandom = ~ time | num,
    formSurv = Surv(fuyrs, status) ~ age,
    data = hvd,
    timeVar = "time",
    control = list(nMCscale = 2, burnin = 5)) # controls for illustration only

fixef(fit1, process = "Longitudinal")
fixef(fit1, process = "Event")

## End(Not run)

## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)

fixef(fit2, process = "Longitudinal")
fixef(fit2, process = "Event")

## End(Not run)
</code></pre>

<hr>
<h2 id='formula.mjoint'>Extract model formulae from an <code>mjoint</code> object</h2><span id='topic+formula.mjoint'></span>

<h3>Description</h3>

<p>Extract model formulae from an <code>mjoint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
formula(x, process = c("Longitudinal", "Event"), k = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula.mjoint_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model of
time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="formula.mjoint_+3A_process">process</code></td>
<td>
<p>character string: if <code>process='Longitudinal'</code> a fixed
effects formula from the (multivariate) longitudinal sub-model is returned
for the <code>k</code>-th outcome. Else, if <code>process='Event'</code>, the
time-to-event model formula is returned.</p>
</td></tr>
<tr><td><code id="formula.mjoint_+3A_k">k</code></td>
<td>
<p>integer: a number between 1 and <em>K</em> (the total number of
longitudinal outcomes) that specifies the longitudinal outcome of interest.</p>
</td></tr>
<tr><td><code id="formula.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;formula&quot; which contains a symbolic model formula
for the separate sub-model fixed effect terms only.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Pinheiro JC, Bates DM. <em>Mixed-Effects Models in S and S-PLUS.</em> New York:
Springer Verlag; 2000.
</p>
<p>Wulfsohn MS, Tsiatis AA. A joint model for survival and longitudinal data
measured with error. <em>Biometrics.</em> 1997; <strong>53(1)</strong>: 330-339.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code> for the generic method description, and
<code><a href="#topic+ranef.mjoint">ranef.mjoint</a></code>.
</p>

<hr>
<h2 id='getVarCov.mjoint'>Extract variance-covariance matrix of random effects from an <code>mjoint</code>
object</h2><span id='topic+getVarCov.mjoint'></span>

<h3>Description</h3>

<p>Extract variance-covariance matrix of random effects from an
<code>mjoint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
getVarCov(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getVarCov.mjoint_+3A_obj">obj</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model of
time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="getVarCov.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance-covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Pinheiro JC, Bates DM. <em>Mixed-Effects Models in S and S-PLUS.</em> New York:
Springer Verlag; 2000.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+getVarCov">getVarCov</a></code> for the generic method description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)

getVarCov(fit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='heart.valve'>Aortic valve replacement surgery data</h2><span id='topic+heart.valve'></span>

<h3>Description</h3>

<p>This is longitudinal data on an observational study on detecting
effects of different heart valves, differing on type of tissue, implanted
in the aortic position. The data consists of longitudinal measurements on
three different heart function outcomes, after surgery occurred. There are
several baseline covariates available, and also survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(heart.valve)
</code></pre>


<h3>Format</h3>

<p>This is a data frame in the unbalanced format, that is, with one row
per observation. The data consists in columns for patient identification,
time of measurements, longitudinal multiple longitudinal measurements,
baseline covariates, and survival data. The column names are identified as
follows: </p>

<dl>
<dt><code>num</code></dt><dd><p>number for patient identification.</p>
</dd>
<dt><code>sex</code></dt><dd><p>gender of patient (<code>0=</code>Male and <code>1=</code>Female).</p>
</dd>
<dt><code>age</code></dt><dd><p>age of patient at day of surgery (years).</p>
</dd>
<dt><code>time</code></dt><dd><p>observed time point, with surgery date as the time
origin (years).</p>
</dd>
<dt><code>fuyrs</code></dt><dd><p>maximum follow up time, with surgery date as the time
origin (years).</p>
</dd>
<dt><code>status</code></dt><dd><p>censoring indicator (<code>1=</code>died and <code>0=</code>lost
at follow up).</p>
</dd>
<dt><code>grad</code></dt><dd><p>valve gradient at follow-up visit.</p>
</dd>
<dt><code>log.grad</code></dt><dd><p>natural log transformation of <code>grad</code>.</p>
</dd>
<dt><code>lvmi</code></dt><dd><p>left ventricular mass index (standardised) at follow-up
visit.</p>
</dd>
<dt><code>log.lvmi</code></dt><dd><p>natural log transformation of <code>lvmi</code>.</p>
</dd>
<dt><code>ef</code></dt><dd><p>ejection fraction at follow-up visit.</p>
</dd>
<dt><code>bsa</code></dt><dd><p>preoperative body surface area.</p>
</dd>
<dt><code>lvh</code></dt><dd><p>preoperative left ventricular hypertrophy.</p>
</dd>
<dt><code>prenyha</code></dt><dd><p>preoperative New York Heart Association (NYHA)
classification (<code>1=</code>I/II and <code>3=</code>III/IV).</p>
</dd>
<dt><code>redo</code></dt><dd><p>previous cardiac surgery.</p>
</dd>
<dt><code>size</code></dt><dd><p>size of the valve (millimeters).</p>
</dd>
<dt><code>con.cabg</code></dt><dd><p>concomitant coronary artery bypass graft.</p>
</dd>
<dt><code>creat</code></dt><dd><p>preoperative serum creatinine (<code class="reqn">\mu</code>mol/mL).</p>
</dd>
<dt><code>dm</code></dt><dd><p>preoperative diabetes.</p>
</dd>
<dt><code>acei</code></dt><dd><p>preoperative use of ace inhibitor.</p>
</dd>
<dt><code>lv</code></dt><dd><p>preoperative left ventricular ejection fraction (LVEF)
(<code>1=</code>good, <code>2=</code>moderate, and <code>3=</code>poor).</p>
</dd>
<dt><code>emergenc</code></dt><dd><p>operative urgency (<code>0=</code>elective, <code>1 =
  </code>urgent, and <code>3=</code>emergency).</p>
</dd>
<dt><code>hc</code></dt><dd><p>preoperative high cholesterol (<code>0=</code>absent, <code>1
  =</code>present treated, and <code>2=</code>present untreated).</p>
</dd>
<dt><code>sten.reg.mix</code></dt><dd><p>aortic valve haemodynamics (<code>1=</code>stenosis,
<code>2=</code>regurgitation, <code>3=</code>mixed).</p>
</dd>
<dt><code>hs</code></dt><dd><p>implanted aortic prosthesis type (<code>1=</code>homograft and
<code>0=</code>stentless porcine tissue).</p>
</dd>
</dl>



<h3>References</h3>

<p>Lim E, Ali A, Theodorou P, Sousa I, Ashrafian H, Chamageorgakis T, Duncan M,
Diggle P, Pepper J. A longitudinal study of the profile and predictors of
left ventricular mass regression after stentless aortic valve replacement.
<em>Ann Thorac Surg.</em> 2008; <strong>85(6)</strong>: 2026-2029.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbc2">pbc2</a></code>, <code><a href="#topic+renal">renal</a></code>,
<code><a href="#topic+epileptic.qol">epileptic.qol</a></code>.
</p>

<hr>
<h2 id='joineRML'>joineRML</h2><span id='topic+joineRML'></span>

<h3>Description</h3>

<p>joineRML is an extension of the joineR package for fitting joint
models of time-to-event data and multivariate longitudinal data. The model
fitted in joineRML is an extension of the Wulfsohn and Tsiatis (1997) and
Henderson et al. (2000) models, which is comprised on
<code class="reqn">(K+1)</code>-sub-models: a Cox proportional hazards regression model (Cox,
1972) and a <em>K</em>-variate linear mixed-effects model - a direct
extension of the Laird and Ware (1982) regression model. The model is
fitted using a Monte Carlo Expectation-Maximization (MCEM) algorithm, which
closely follows the methodology presented by Lin et al. (2002).
</p>


<h3>References</h3>

<p>Wulfsohn MS, Tsiatis AA. A joint model for survival and longitudinal data
measured with error. <em>Biometrics.</em> 1997; <strong>53(1)</strong>: 330-339.
</p>
<p>Henderson R, Diggle PJ, Dobson A. Joint modelling of longitudinal
measurements and event time data. <em>Biostatistics.</em> 2000; <strong>1(4)</strong>:
465-480.
</p>
<p>Cox DR. Regression models and life-tables. <em>J R Stat Soc Ser B Stat
Methodol.</em> 1972; <strong>34(2)</strong>: 187-220.
</p>
<p>Laird NM, Ware JH. Random-effects models for longitudinal data.
<em>Biometrics.</em> 1982; <strong>38(4)</strong>: 963-974.
</p>

<hr>
<h2 id='logLik.mjoint'>Extract log-likelihood from an <code>mjoint</code> object</h2><span id='topic+logLik.mjoint'></span>

<h3>Description</h3>

<p>Extract log-likelihood from an <code>mjoint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.mjoint_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="logLik.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>logLik</code>. This is a number with two
attributes: <code>df</code> (degrees of freedom), giving the number of parameters
in the model, and <code>nobs</code>, the number of observations used in
estimation.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Henderson R, Diggle PJ, Dobson A. Joint modelling of longitudinal
measurements and event time data. <em>Biostatistics.</em> 2000; <strong>1(4)</strong>:
465-480.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code> for the generic method description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]
fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)

logLik(fit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='mjoint'>Fit a joint model to time-to-event data and multivariate longitudinal data</h2><span id='topic+mjoint'></span>

<h3>Description</h3>

<p>This function fits the joint model proposed by Henderson et al.
(2000), but extended to the case of multiple continuous longitudinal
measures. The time-to-event data is modelled using a Cox proportional
hazards regression model with time-varying covariates. The multiple
longitudinal outcomes are modelled using a multivariate version of the
Laird and Ware linear mixed model. The association is captured by a
multivariate latent Gaussian process. The model is estimated using a
(quasi-) Monte Carlo Expectation Maximization (MCEM) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mjoint(
  formLongFixed,
  formLongRandom,
  formSurv,
  data,
  survData = NULL,
  timeVar,
  inits = NULL,
  verbose = FALSE,
  pfs = TRUE,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mjoint_+3A_formlongfixed">formLongFixed</code></td>
<td>
<p>a list of formulae for the fixed effects component of
each longitudinal outcome. The left hand-hand side defines the response,
and the right-hand side specifies the fixed effect terms. If a single
formula is given (either as a list of length 1 or a formula), then it is
assumed that a standard univariate joint model is being fitted.</p>
</td></tr>
<tr><td><code id="mjoint_+3A_formlongrandom">formLongRandom</code></td>
<td>
<p>a list of one-sided formulae specifying the model for
the random effects effects of each longitudinal outcome. The length of the
list must be equal to <code>formLongFixed</code>.</p>
</td></tr>
<tr><td><code id="mjoint_+3A_formsurv">formSurv</code></td>
<td>
<p>a formula specifying the proportional hazards regression
model (not including the latent association structure). See
<code><a href="survival.html#topic+coxph">coxph</a></code> for examples.</p>
</td></tr>
<tr><td><code id="mjoint_+3A_data">data</code></td>
<td>
<p>a list of <code>data.frame</code> objects for each longitudinal outcome
in which to interpret the variables named in the <code>formLongFixed</code> and
<code>formLongRandom</code>. The <code>list</code> structure enables one to include
multiple longitudinal outcomes with different measurement protocols. If the
multiple longitudinal outcomes are measured at the same time points for
each patient, then a <code>data.frame</code> object can be given instead of a
<code>list</code>. It is assumed that each data frame is in long format. <code>tibble</code>
objects are automatically converted to plain <code>data.frame</code> objects.</p>
</td></tr>
<tr><td><code id="mjoint_+3A_survdata">survData</code></td>
<td>
<p>a <code>data.frame</code> in which to interpret the variables named
in the <code>formSurv</code>. This is optional, and if not given, the required
data is searched for in <code>data</code>. Default is <code>survData=NULL</code>.</p>
</td></tr>
<tr><td><code id="mjoint_+3A_timevar">timeVar</code></td>
<td>
<p>a character string indicating the time variable in the linear
mixed effects model. If there are multiple longitudinal outcomes and the
time variable is labelled differently in each model, then a character
string vector can be given instead.</p>
</td></tr>
<tr><td><code id="mjoint_+3A_inits">inits</code></td>
<td>
<p>a list of initial values for some or all of the parameters
estimated in the model. Default is <code>NULL</code>, with initial values
estimated using separate multivariate linear mixed effects and Cox
proportional hazard regression models.</p>
</td></tr>
<tr><td><code id="mjoint_+3A_verbose">verbose</code></td>
<td>
<p>logical: if <code>TRUE</code>, the parameter estimates and other
convergence statistics are value are printed at each iteration of the MCEM
algorithm. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mjoint_+3A_pfs">pfs</code></td>
<td>
<p>logical: if <code>TRUE</code>, then assuming the MCEM algorithm has
converged, post-fit statistics including the posterior means and variances
of the random effects, and the approximate standard errors are calculated
and returned as part of the model object. Default is <code>TRUE</code>. If
<code>FALSE</code>, then these additional calculations are not performed, which
can reduce the overall computational time. This option is intended to be
used with computationally intensive routines such as simulation and
bootstrap standard error estimation where these calculations are not
required.</p>
</td></tr>
<tr><td><code id="mjoint_+3A_control">control</code></td>
<td>
<p>a list of control values with components: </p>

<dl>
<dt><code>nMC</code></dt><dd><p>integer: the initial number of Monte Carlo samples to be
used for integration in the burn-in phase of the MCEM. Default is
<code>nMC=</code>100<em>K</em>.</p>
</dd>
<dt><code>nMCscale</code></dt><dd><p>integer: the scale factor for the increase in Monte
Carlo size when Monte Carlo has not reduced from the previous iteration.
Default is <code>nMCscale=5</code>.</p>
</dd>
<dt><code>nMCmax</code></dt><dd><p>integer: the maximum number of Monte Carlo samples
that the algorithm is allowed to reach. Default is <code>nMCmax=20000</code>.</p>
</dd>
<dt><code>burnin</code></dt><dd><p>integer: the number of iterations for 'burn-in' phase
of the optimization algorithm. It is computationally inefficient to use a
large number of Monte Carlo samples early on until one is approximately
near the maximum likelihood estimate. Default is <code>burnin=</code>100<em>K</em>
for <code>type='antithetic'</code> or <code>type='montecarlo'</code> and
<code>burnin=</code>5 for <code>type='sobol'</code> or <code>type='halton'</code>. For
standard methods, such a large burn-in will generally be unnecessary and
can be reduced on an application-specific basis.</p>
</dd>
<dt><code>mcmaxIter</code></dt><dd><p>integer: the maximum number of MCEM algorithm
iterations allowed. Default is <code>mcmaxIter=burnin+200</code>.</p>
</dd>
<dt><code>convCrit</code></dt><dd><p>character string: the convergence criterion to be
used. See <strong>Details</strong>.</p>
</dd>
<dt><code>gammaOpt</code></dt><dd><p>character string: by default (<code>gammaOpt='NR'</code>),
<code class="reqn">\gamma</code> is updated using a one-step Newton-Raphson iteration, with the
Hessian matrix calculated exactly. If <code>gammaOpt='GN'</code>, a Gauss-Newton
algorithm-type iteration is implemented, where the Hessian matrix is
approximated based on calculations similar to those used for calculating
the empirical information matrix? If it is used, then the step-length is
adjusted by a nominal scaling parameter of 0.5 in order to reduce the
chance of over-shooting the maximizer.</p>
</dd>
<dt><code>tol0</code></dt><dd><p>numeric: tolerance value for convergence in the
parameters; see <strong>Details</strong>. Default is <code>tol0=1e-03</code>.</p>
</dd>
<dt><code>tol1</code></dt><dd><p>numeric: tolerance value for convergence in the
parameters; see <strong>Details</strong>. Default is <code>tol1=1e-03</code>.</p>
</dd>
<dt><code>tol2</code></dt><dd><p>numeric: tolerance value for convergence in the
parameters; see <strong>Details</strong>. Default is <code>tol2=5e-03</code> for
<code>type='antithetic'</code> or <code>type='montecarlo'</code> and <code>tol2=1e-03</code>
for <code>type='sobol'</code> or <code>type='halton'</code>.</p>
</dd>
<dt><code>tol.em</code></dt><dd><p>numeric: tolerance value for convergence in the
multivariate linear mixed model (MV-LMM). When <code class="reqn">K &gt; 1</code>, the optimal
initial parameters are those from the MV-LMM, which is estimated using a
separate EM algorithm. Since both the E- and M-steps are available in
closed-form, this algorithm convergences relatively rapidly with a high
precision. Default is min(<code>1e-04</code>, <code>tol2</code>).</p>
</dd>
<dt><code>rav</code></dt><dd><p>numeric: threshold when using <code>convCrit='sas'</code> that
applies absolute change (when <code class="reqn">&lt;</code><code>rav</code>) or relative change (when
<code class="reqn">\ge</code><code>rav</code>) criterion; see <strong>Details</strong>. Default is
<code>0.1</code>, which is an order of magnitude higher than the SAS
implementation.</p>
</dd>
<dt><code>type</code></dt><dd><p>character: type of Monte Carlo integration method to
use. Options are </p>

<dl>
<dt><code>type='montecarlo'</code></dt><dd><p>Vanilla Monte Carlo sampling.</p>
</dd>
<dt><code>type='antithetic'</code></dt><dd><p>Variance reduction method using antithetic
simulation. This is the default option.</p>
</dd>
<dt><code>type='sobol'</code></dt><dd><p>Quasi-Monte Carlo with a low
deterministic Sobol sequence with Owen-type scrambling.</p>
</dd>
<dt><code>type='halton'</code></dt><dd><p>Quasi-Monte Carlo with a low deterministic
Halton sequence.</p>
</dd>
</dl>
</dd>
</dl>
</td></tr>
<tr><td><code id="mjoint_+3A_...">...</code></td>
<td>
<p>options passed to the <code>control</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>mjoint</code> fits joint models for time-to-event and
multivariate longitudinal data. A review of relevant statistical
methodology for joint models of multivariate data is given in Hickey et al.
(2016). This is a direct extension of the models developed in the seminal
works of Wulfsohn and Tsiatis (1997) and Henderson et al. (2000), with the
calculations based largely on Lin et al. (2002) who also extended the model
to multivariate joint data. A more detailed explanation of the model
formulation is given in the technical vignette. Each longitudinal outcome
is modelled according to a linear mixed model (LMM), akin to the models fit
by <code><a href="nlme.html#topic+lme">lme</a></code>, with independent and identically distributed
Gaussian errors. The latent term in each model (specified by
<code>formLongRandom</code>) is a linear combination of subject-specific
zero-mean Gaussian random effects with outcome-specific variance
components. We denote these as <code class="reqn">W_{i1}(t, b_{i1})</code>, <code class="reqn">W_{i2}(t,
  b_{i2})</code>, <code class="reqn">\dots</code>, <code class="reqn">W_{iK}(t, b_{iK})</code>, for the <em>K</em>-outcomes.
Usually, <code class="reqn">W(t, b)</code> will be specified as either <code class="reqn">b_0</code> (a
random-intercepts model) or <code class="reqn">b_0 + b_1t</code> (a random-intercepts and
random-slopes model); however, more general structures are allowed The
time-to-event model is modelled as per the usual Cox model formulation,
with an additional (possibly) time-varying term given by
</p>
<p style="text-align: center;"><code class="reqn">\gamma_{y1} W_{i1}(t, b_{i1}) + \gamma_{y2} W_{i2}(t, b_{i2}) + \dots
  + \gamma_{yK} W_{iK}(t, b_{iK}),</code>
</p>

<p>where <code class="reqn">\gamma_y</code> is a parameter vector of proportional latent
association parameters of length <em>K</em> for estimation.
</p>
<p>The optimization routine is based on a Monte Carlo Expectation Maximization
algorithm (MCEM) algorithm, as described by Wei and Tanner (1990). With
options for using antithetic simulation for variance reduction in the Monte
Carlo integration, or quasi-Monte Carlo based on low order deterministic
sequences.
</p>


<h3>Value</h3>

<p>An object of class <code>mjoint</code>. See <code><a href="#topic+mjoint.object">mjoint.object</a></code> for
details.
</p>


<h3>Convergence criteria</h3>

<p>The routine internally scales and centers data to avoid overflow in the
argument to the exponential function. These actions do not change the
result, but lead to more numerical stability. Several convergence criteria
are available: </p>

<dl>
<dt><code>abs</code></dt><dd><p>the maximum absolute parameter change is
<code class="reqn">&lt;</code><code>tol0</code>. The baseline hazard parameters are not included in this
convergence statistic.</p>
</dd>
<dt><code>rel</code></dt><dd><p>the maximum (absolute) relative parameter change is
<code class="reqn">&lt;</code><code>tol2</code>. A small value (<code>tol1</code>) is added to the denominator
of the relative change statistic to avoid numerical problems when the
parameters are close to zero.</p>
</dd>
<dt><code>either</code></dt><dd><p><em>either</em> the <code>abs</code> or <code>rel</code> criteria
are satisfied.</p>
</dd>
<dt><code>sas</code></dt><dd><p>if <code class="reqn">| \theta_p | &lt; </code><code>rav</code>, then the <code>abs</code>
criteria is applied for the <em>l</em>-th parameter; otherwise, <code>rel</code> is
applied. This is the approach used in the SAS EM algorithm program for
missing data.</p>
</dd>
</dl>

<p>Due to the Monte Caro error, the algorithm could spuriously declare
convergence. Therefore, we require convergence to be satisfied for 3
consecutive iterations. The algorithm starts with a low number of Monte
Carlo samples in the 'burn-in' phase, as it would be computationally
inefficient to use a large sample whilst far away from the true maximizer.
After the algorithm moves out of this adaptive phase, it uses an automated
criterion based on the coefficient of variation of the relative parameter
change of the last 3 iterations to decide whether to increase the Monte
Carlo sample size. See the technical vignette and Ripatti et al. (2002) for
further details.
</p>


<h3>Standard error estimation</h3>

<p>Approximate standard errors (SEs) are calculated (if <code>pfs=TRUE</code>).
These are based on the empirical observed information function (McLachlan &amp;
Krishnan, 2008). Through simulation studies, we have found that this
approximation does not work particularly well for <code class="reqn">n &lt; 100</code> (where
<em>n</em> is the number of subjects). In these cases, one would need to
appeal to the bootstrap SE estimation approach. However, in practice, the
reliability of the approximate SEs will depend of a multitude of factors,
including but not limited to, the average number of repeated measurements
per subject, the total number of events, and the convergence of the MCEM
algorithm.
</p>
<p>Bootstrap SEs are also available, however they are not calculated using the
<code>mjoint</code> function due to the intense computational time. Instead, a
separate function is available: <code>bootSE</code>, which takes the fitted joint
model as its main argument. Given a fitted joint model (of class
<code>mjoint</code>) and a bootstrap fit object (of class <code>bootSE</code>), the SEs
reported in the model can be updated by running
<code>summary(fit_obj,boot_obj)</code>. For details, consult the
<code><a href="#topic+bootSE">bootSE</a></code> documentation.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Henderson R, Diggle PJ, Dobson A. Joint modelling of longitudinal
measurements and event time data. <em>Biostatistics.</em> 2000; <strong>1(4)</strong>:
465-480.
</p>
<p>Hickey GL, Philipson P, Jorgensen A, Kolamunnage-Dona R. Joint modelling of
time-to-event and multivariate longitudinal outcomes: recent developments and
issues. <em>BMC Med Res Methodol.</em> 2016; <strong>16(1)</strong>: 117.
</p>
<p>Lin H, McCulloch CE, Mayne ST. Maximum likelihood estimation in the joint
analysis of time-to-event and multiple longitudinal variables. <em>Stat
Med.</em> 2002; <strong>21</strong>: 2369-2382.
</p>
<p>McLachlan GJ, Krishnan T. <em>The EM Algorithm and Extensions.</em> Second
Edition. Wiley-Interscience; 2008.
</p>
<p>Ripatti S, Larsen K, Palmgren J. Maximum likelihood inference for
multivariate frailty models using an automated Monte Carlo EM algorithm.
<em>Lifetime Data Anal.</em> 2002; <strong>8</strong>: 349-360.
</p>
<p>Wei GC, Tanner MA. A Monte Carlo implementation of the EM algorithm and the
poor man's data augmentation algorithms. <em>J Am Stat Assoc.</em> 1990;
<strong>85(411)</strong>: 699-704.
</p>
<p>Wulfsohn MS, Tsiatis AA. A joint model for survival and longitudinal data
measured with error. <em>Biometrics.</em> 1997; <strong>53(1)</strong>: 330-339.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjoint.object">mjoint.object</a></code>, <code><a href="#topic+bootSE">bootSE</a></code>,
<code><a href="#topic+plot.mjoint">plot.mjoint</a></code>, <code><a href="#topic+summary.mjoint">summary.mjoint</a></code>,
<code><a href="#topic+getVarCov.mjoint">getVarCov.mjoint</a></code>, <code><a href="#topic+simData">simData</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a classical univariate joint model with a single longitudinal outcome
# and a single time-to-event outcome

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

set.seed(1)
fit1 &lt;- mjoint(formLongFixed = log.lvmi ~ time + age,
    formLongRandom = ~ time | num,
    formSurv = Surv(fuyrs, status) ~ age,
    data = hvd,
    timeVar = "time",
    control = list(nMCscale = 2, burnin = 5)) # controls for illustration only
summary(fit1)

## End(Not run)

## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)
summary(fit2)

## End(Not run)

## Not run: 
# Fit a univariate joint model and compare to the joineR package

data(pbc2)
pbc2$log.b &lt;- log(pbc2$serBilir)

# joineRML package
fit.joineRML &lt;- mjoint(
    formLongFixed = list("log.bil" = log.b ~ year),
    formLongRandom = list("log.bil" = ~ 1 | id),
    formSurv = Surv(years, status2) ~ age,
    data = pbc2,
    timeVar = "year")
summary(fit.joineRML)

# joineR package
pbc.surv &lt;- UniqueVariables(pbc2, var.col = c("years", "status2"),
                            id.col = "id")
pbc.long &lt;- pbc2[, c("id", "year", "log.b")]
pbc.cov &lt;- UniqueVariables(pbc2, "age", id.col = "id")
pbc.jd &lt;- jointdata(longitudinal = pbc.long, baseline = pbc.cov,
                    survival = pbc.surv, id.col = "id", time.col = "year")
fit.joineR &lt;- joint(data = pbc.jd,
    long.formula = log.b ~ 1 + year,
    surv.formula = Surv(years, status2) ~ age,
    model = "int")
summary(fit.joineR)

## End(Not run)
</code></pre>

<hr>
<h2 id='mjoint_tidiers'>Tidying methods for joint models for time-to-event data and multivariate
longitudinal data</h2><span id='topic+mjoint_tidiers'></span><span id='topic+tidy.mjoint'></span><span id='topic+augment.mjoint'></span><span id='topic+glance.mjoint'></span>

<h3>Description</h3>

<p>These methods tidy the coefficients of joint models for time-to-event data
and multivariate longitudinal data of the <code>mjoint</code> class from the
<code>joineRML</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
tidy(
  x,
  component = "survival",
  bootSE = NULL,
  conf.int = FALSE,
  conf.level = 0.95,
  ...
)

## S3 method for class 'mjoint'
augment(x, data = x$data, ...)

## S3 method for class 'mjoint'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mjoint_tidiers_+3A_x">x</code></td>
<td>
<p>An object of class <code>mjoint</code>.</p>
</td></tr>
<tr><td><code id="mjoint_tidiers_+3A_component">component</code></td>
<td>
<p>Either <code>survival</code> (the survival component of the model,
default) or <code>longitudinal</code> (the longitudinal component).</p>
</td></tr>
<tr><td><code id="mjoint_tidiers_+3A_bootse">bootSE</code></td>
<td>
<p>An object of class <code>bootSE</code> for the corresponding model.
If <code>bootSE = NULL</code> (the default), the function will use approximate
standard error estimates calculated from the empirical information matrix.</p>
</td></tr>
<tr><td><code id="mjoint_tidiers_+3A_conf.int">conf.int</code></td>
<td>
<p>Include (1 - <code>conf.level</code>)% confidence intervals?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mjoint_tidiers_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
<tr><td><code id="mjoint_tidiers_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
<tr><td><code id="mjoint_tidiers_+3A_data">data</code></td>
<td>
<p>Original data this was fitted on, in a list (e.g.
<code>list(data)</code>). This will be extracted from <code>x</code> if not given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All tidying methods return a <code>data.frame</code> without rownames. The
structure depends on the method chosen.
</p>
<p><code>tidy</code> returns one row for each estimated fixed effect depending
on the <code>component</code> parameter. It contains the following  columns:
</p>
<table role = "presentation">
<tr><td><code>term</code></td>
<td>
<p>The term being estimated</p>
</td></tr> <tr><td><code>estimate</code></td>
<td>
<p>Estimated value</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>Standard error</p>
</td></tr> <tr><td><code>statistic</code></td>
<td>
<p>Z-statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value computed from Z-statistic</p>
</td></tr> <tr><td><code>conf.low</code></td>
<td>
<p>The lower
bound of a confidence interval on <code>estimate</code>, if required</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>The upper bound of a confidence interval on
<code>estimate</code>, if required</p>
</td></tr></table>
<p>.
</p>
<p><code>augment</code> returns one row for each original observation, with
columns (each prepended by a .) added. Included are the columns:
</p>
<table role = "presentation">
<tr><td><code>.fitted_j_0</code></td>
<td>
<p>population-level fitted values for the j-th longitudinal
process</p>
</td></tr> <tr><td><code>.fitted_j_1</code></td>
<td>
<p>individuals-level fitted values for the j-th
longitudinal process</p>
</td></tr> <tr><td><code>.resid_j_0</code></td>
<td>
<p>population-level residuals for the
j-th longitudinal process</p>
</td></tr> <tr><td><code>.resid_j_1</code></td>
<td>
<p>individual-level residuals for
the j-th longitudinal process</p>
</td></tr></table>
<p> See <code><a href="#topic+fitted.mjoint">fitted.mjoint</a></code>
and <code><a href="#topic+residuals.mjoint">residuals.mjoint</a></code> for more information on the
difference between population-level and individual-level fitted values and
residuals.
</p>
<p><code>glance</code> returns one row with the columns </p>
<table role = "presentation">
<tr><td><code>sigma2_j</code></td>
<td>
<p>the
square root of the estimated residual variance for the j-th longitudinal
process</p>
</td></tr> <tr><td><code>AIC</code></td>
<td>
<p>the Akaike Information Criterion</p>
</td></tr> <tr><td><code>BIC</code></td>
<td>
<p>the
Bayesian Information Criterion</p>
</td></tr> <tr><td><code>logLik</code></td>
<td>
<p>the data's log-likelihood
under the model</p>
</td></tr></table>
<p>.
</p>


<h3>Note</h3>

<p>If fitting a joint model with a single longitudinal process, please
make sure you are using a named <code>list</code> to define the formula for the
fixed and random effects of the longitudinal submodel.
</p>


<h3>Author(s)</h3>

<p>Alessandro Gasparini (<a href="mailto:alessandro.gasparini@ki.se">alessandro.gasparini@ki.se</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a joint model with bivariate longitudinal outcomes
library(joineRML)
data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp;
  !is.na(heart.valve$log.lvmi) &amp;
  heart.valve$num &lt;= 50, ]
fit &lt;- mjoint(
  formLongFixed = list(
    "grad" = log.grad ~ time + sex + hs,
    "lvmi" = log.lvmi ~ time + sex
  ),
  formLongRandom = list(
    "grad" = ~ 1 | num,
    "lvmi" = ~ time | num
  ),
  formSurv = Surv(fuyrs, status) ~ age,
  data = hvd,
  inits = list("gamma" = c(0.11, 1.51, 0.80)),
  timeVar = "time"
)

# Extract the survival fixed effects
tidy(fit)

# Extract the longitudinal fixed effects
tidy(fit, component = "longitudinal")

# Extract the survival fixed effects with confidence intervals
tidy(fit, ci = TRUE)

# Extract the survival fixed effects with confidence intervals based on 
# bootstrapped standard errors
bSE &lt;- bootSE(fit, nboot = 5, safe.boot = TRUE)
tidy(fit, bootSE = bSE, ci = TRUE)

# Augment original data with fitted longitudinal values and residuals
hvd2 &lt;- augment(fit)

# Extract model statistics
glance(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='mjoint.object'>Fitted <code>mjoint</code> object</h2><span id='topic+mjoint.object'></span>

<h3>Description</h3>

<p>An object returned by the <code>mjoint</code> function, inheriting
from class <code>mjoint</code> and representing a fitted joint model for
multivariate longitudinal and time-to-event data. Objects of this class
have methods for the generic functions <code>coef</code>, <code>logLik</code>,
<code>plot</code>, <code>print</code>, <code>ranef</code>, <code>fixef</code>, <code>summary</code>,
<code>AIC</code>, <code>getVarCov</code>, <code>vcov</code>, <code>confint</code>, <code>sigma</code>,
<code>fitted</code>, <code>residuals</code>, and <code>formula</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mjoint.object
</code></pre>


<h3>Format</h3>

<p>An object of class <code>NULL</code> of length 0.
</p>


<h3>Value</h3>

<p>A list with the following components. </p>

<dl>
<dt><code>coefficients</code></dt><dd><p>a list with the estimated coefficients. The
components of this list are: </p>

<dl>
<dt><code>beta</code></dt><dd><p>the vector of fixed effects for the linear mixed
effects sub-model.</p>
</dd>
<dt><code>D</code></dt><dd><p>the variance-covariance matrix of the random effects.</p>
</dd>
<dt><code>sigma2</code></dt><dd><p>the measurement error standard deviations for the
linear mixed effects sub-model.</p>
</dd>
<dt><code>haz</code></dt><dd><p>the estimated baseline hazard values for each unique
failure time. Note that this is the <em>centered</em> hazard, equivalent to
that returned by <code><a href="survival.html#topic+coxph.detail">coxph.detail</a></code>.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>the vector of baseline covariates for the survival
model and the latent association coefficient parameter estimates.</p>
</dd>
</dl>
</dd>
<dt><code>history</code></dt><dd><p>a matrix with parameter estimates at each iteration
of the MCEM algorithm.</p>
</dd>
<dt><code>nMC.hx</code></dt><dd><p>a vector with the number of Monte Carlo samples for
each MCEM algorithm iteration.</p>
</dd>
<dt><code>formLongFixed</code></dt><dd><p>a list of formulae for the fixed effects
component of each longitudinal outcome.</p>
</dd>
<dt><code>formLongRandom</code></dt><dd><p>a list of formulae for the fixed effects
component of each longitudinal outcome. The length of the list will be
equal to <code>formLongFixed</code>.</p>
</dd>
<dt><code>formSurv</code></dt><dd><p>a formula specifying the proportional hazards
regression model (not including the latent association structure).</p>
</dd>
<dt><code>data</code></dt><dd><p>a list of data.frames for each longitudinal outcome.</p>
</dd>
<dt><code>survData</code></dt><dd><p>a data.frame of the time-to-event dataset.</p>
</dd>
<dt><code>timeVar</code></dt><dd><p>a character string vector of length K denoting the
column name(s) for time in <code>data</code>.</p>
</dd>
<dt><code>id</code></dt><dd><p>a character string denoting the column name for subject
IDs in <code>data</code> and <code>survData</code>.</p>
</dd>
<dt><code>dims</code></dt><dd><p>a list giving the dimensions of model parameters with
components: </p>

<dl>
<dt><code>p</code></dt><dd><p>a vector of the number of fixed effects for each
longitudinal outcome.</p>
</dd>
<dt><code>r</code></dt><dd><p>a vector of the number of random effects for each
longitudinal outcome.</p>
</dd>
<dt><code>K</code></dt><dd><p>an integer of the number of different longitudinal
outcome types.</p>
</dd>
<dt><code>q</code></dt><dd><p>an integer of the number of baseline covariates in the
time-to-event sub-model.</p>
</dd>
<dt><code>n</code></dt><dd><p>an integer of the total number of subjects in the study.</p>
</dd>
<dt><code>nk</code></dt><dd><p>a vector of the number of measurements for each
longitudinal outcome.</p>
</dd>
</dl>
</dd>
<dt><code>sfit</code></dt><dd><p>an object of class <code>coxph</code> for the separate
time-to-event model fit. See <code><a href="survival.html#topic+coxph">coxph</a></code> for details.</p>
</dd>
<dt><code>lfit</code></dt><dd><p>a list of objects each of class <code>lme</code> from fitting
separate linear mixed effects models; one per each longitudinal outcome
type. See <code><a href="nlme.html#topic+lme">lme</a></code> for details.</p>
</dd>
<dt><code>log.lik0</code></dt><dd><p>the combined log-likelihood from separate sub-model
fits.</p>
</dd>
<dt><code>log.lik</code></dt><dd><p>the log-likelihood from the joint model fit.</p>
</dd>
<dt><code>ll.hx</code></dt><dd><p>a vector of the log-likelihood values for each MCEM
algorithm interaction.</p>
</dd>
<dt><code>control</code></dt><dd><p>a list of control parameters used in the estimation
of the joint model. See <code><a href="#topic+mjoint">mjoint</a></code> for details.</p>
</dd>
<dt><code>finalnMC</code></dt><dd><p>the final number of Monte Carlo samples required
prior to convergence.</p>
</dd>
<dt><code>call</code></dt><dd><p>the matched call.</p>
</dd>
<dt><code>inits</code></dt><dd><p>the initial values passed as an argument in the
<code>mjoint</code> function.</p>
</dd>
<dt><code>inits.long</code></dt><dd><p>the computed initial values from fitting a
multivariate longitudinal model.</p>
</dd>
<dt><code>inits.surv</code></dt><dd><p>the computed initial values from fitting a Cox
proportional hazards model with time-dependent covariates calculated from
the fitted multivariate LME model.</p>
</dd>
<dt><code>conv</code></dt><dd><p>logical: did the MCEM algorithm converge within the
specified maximum number of iterations?</p>
</dd>
<dt><code>comp.time</code></dt><dd><p>a vector of length 2 with each element an object of
class <code>difftime</code> that reports the <em>total</em> time taken for model
fitting (including all stages) and the time spent in the <em>EM
algorithm</em>.</p>
</dd>
</dl>



<h3>Post model fit statistics</h3>

<p>If <code>pfs=TRUE</code>, indicating that post-fit statistics are to be returned,
then the output also includes the following objects. </p>

<dl>
<dt><code>vcov</code></dt><dd><p>the variance-covariance matrix of model parameters, as
approximated by the empirical information matrix, is reported. See
<code><a href="#topic+mjoint">mjoint</a></code> for details.</p>
</dd>
<dt><code>SE.approx</code></dt><dd><p>the square-root of the diagonal of <code>vcov</code> is
returned, which are estimates of the standard errors for the parameters.</p>
</dd>
<dt><code>Eb</code></dt><dd><p>a matrix with the estimated random effects values for
each subject.</p>
</dd>
<dt><code>Vb</code></dt><dd><p>an array with the estimated variance-covariance matrices
for the random effects values for each subject.</p>
</dd>
<dt><code>dmats</code></dt><dd><p>a list of length 3 containing the design matrices,
data frames, and vectors used in the MCEM algorithm. These are required
for prediction and to calculate the residuals and . The 3 items in the
list are <code>l</code> (longitudinal data), <code>t</code> (time-to-event data), and
<code>z</code> (design matrices expanded over unique failure times). These are
not intended to be extracted by the user.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjoint">mjoint</a></code>.
</p>

<hr>
<h2 id='pbc2'>Mayo Clinic primary biliary cirrhosis data</h2><span id='topic+pbc2'></span>

<h3>Description</h3>

<p>This data is from the Mayo Clinic trial in primary biliary
cirrhosis (PBC) of the liver conducted between 1974 and 1984. A total of
424 PBC patients, referred to Mayo Clinic during that ten-year interval met
eligibility criteria for the randomized placebo controlled trial of the
drug D-penicillamine, but only the first 312 cases in the data set
participated in the randomized trial. Therefore, the data here are for the
312 patients with largely complete data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pbc2)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1945 observations on the following 20 variables:
</p>

<dl>
<dt><code>id</code></dt><dd><p>patients identifier; in total there are 312 patients.</p>
</dd>
<dt><code>years</code></dt><dd><p>number of years between registration and the earlier of
death, transplantation, or study analysis time.</p>
</dd>
<dt><code>status</code></dt><dd><p>a factor with levels <code>alive</code>, <code>transplanted</code>
and <code>dead</code>.</p>
</dd>
<dt><code>drug</code></dt><dd><p>a factor with levels <code>placebo</code> and
<code>D-penicil</code>.</p>
</dd>
<dt><code>age</code></dt><dd><p>at registration in years.</p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>male</code> and <code>female</code>.</p>
</dd>
<dt><code>year</code></dt><dd><p>number of years between enrollment and this visit date,
remaining values on the line of data refer to this visit.</p>
</dd>
<dt><code>ascites</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>hepatomegaly</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>spiders</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>edema</code></dt><dd><p>a factor with levels <code>No edema</code> (i.e. no edema and
no diuretic therapy for edema), <code>edema no diuretics</code> (i.e. edema
present without diuretics, or edema resolved by diuretics), and
<code>edema despite diuretics</code> (i.e. edema despite diuretic therapy).</p>
</dd>
<dt><code>serBilir</code></dt><dd><p>serum bilirubin in mg/dl.</p>
</dd>
<dt><code>serChol</code></dt><dd><p>serum cholesterol in mg/dl.</p>
</dd>
<dt><code>albumin</code></dt><dd><p>albumin in mg/dl.</p>
</dd>
<dt><code>alkaline</code></dt><dd><p>alkaline phosphatase in U/liter.</p>
</dd>
<dt><code>SGOT</code></dt><dd><p>SGOT in U/ml.</p>
</dd>
<dt><code>platelets</code></dt><dd><p>platelets per cubic ml/1000.</p>
</dd>
<dt><code>prothrombin</code></dt><dd><p>prothrombin time in seconds.</p>
</dd>
<dt><code>histologic</code></dt><dd><p>histologic stage of disease.</p>
</dd>
<dt><code>status2</code></dt><dd><p>a numeric vector with the value 1 denoting if the
patient was dead, and 0 if the patient was alive or transplanted.</p>
</dd>
</dl>



<h3>Source</h3>

<p><code><a href="JM.html#topic+pbc2">pbc2</a></code> and <code><a href="survival.html#topic+pbc">pbc</a></code>.
</p>


<h3>References</h3>

<p>Fleming T, Harrington D. <em>Counting Processes and Survival Analysis</em>.
1991; New York: Wiley.
</p>
<p>Therneau T, Grambsch P. <em>Modeling Survival Data: Extending the Cox
Model</em>. 2000; New York: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heart.valve">heart.valve</a></code>, <code><a href="#topic+renal">renal</a></code>,
<code><a href="#topic+epileptic.qol">epileptic.qol</a></code>.
</p>

<hr>
<h2 id='plot.dynLong'>Plot a <code>dynLong</code> object</h2><span id='topic+plot.dynLong'></span>

<h3>Description</h3>

<p>Plots the conditional longitudinal expectations for a
<em>new</em> subject calculated using the <code><a href="#topic+dynLong">dynLong</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynLong'
plot(x, main = NULL, xlab = NULL, ylab = NULL, grid = TRUE, estimator, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dynLong_+3A_x">x</code></td>
<td>
<p>an object of class <code>dynLong</code> calculated by the
<code><a href="#topic+dynLong">dynLong</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.dynLong_+3A_main">main</code></td>
<td>
<p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dynLong_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x [time] axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dynLong_+3A_ylab">ylab</code></td>
<td>
<p>a character vector of the titles for the <em>K</em> longitudinal
outcomes y-axes: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dynLong_+3A_grid">grid</code></td>
<td>
<p>adds a rectangular grid to an existing plot: see
<code><a href="graphics.html#topic+grid">grid</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dynLong_+3A_estimator">estimator</code></td>
<td>
<p>a character string that can take values <code>mean</code> or
<code>median</code> to specify what prediction statistic is plotted from an
objecting inheritting of class <code>dynSurv</code>. Default is
<code>estimator='median'</code>. This argument is ignored for non-simulated
<code>dynSurv</code> objects, i.e. those of <code>type='first-order'</code>, as in that
case a mode-based prediction is plotted.</p>
</td></tr>
<tr><td><code id="plot.dynLong_+3A_...">...</code></td>
<td>
<p>additional plotting arguments; currently limited to <code>lwd</code> and
<code>cex</code>. See <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dynamic prediction plot.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Rizopoulos D. Dynamic predictions and prospective accuracy in joint models
for longitudinal and time-to-event data. <em>Biometrics</em>. 2011;
<strong>67</strong>: 819–829.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dynLong">dynLong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)

hvd2 &lt;- droplevels(hvd[hvd$num == 1, ])
out &lt;- dynLong(fit2, hvd2)
plot(out, main = "Patient 1")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.dynSurv'>Plot a <code>dynSurv</code> object</h2><span id='topic+plot.dynSurv'></span>

<h3>Description</h3>

<p>Plots the conditional time-to-event distribution for a
<em>new</em> subject calculated using the <code><a href="#topic+dynSurv">dynSurv</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynSurv'
plot(
  x,
  main = NULL,
  xlab = NULL,
  ylab1 = NULL,
  ylab2 = NULL,
  grid = TRUE,
  estimator,
  smooth = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dynSurv_+3A_x">x</code></td>
<td>
<p>an object of class <code>dynSurv</code> calculated by the
<code><a href="#topic+dynSurv">dynSurv</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.dynSurv_+3A_main">main</code></td>
<td>
<p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dynSurv_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x [time] axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dynSurv_+3A_ylab1">ylab1</code></td>
<td>
<p>a character vector of the titles for the <em>K</em> longitudinal
outcomes y-axes: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dynSurv_+3A_ylab2">ylab2</code></td>
<td>
<p>a title for the event-time outcome axis: see
<code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dynSurv_+3A_grid">grid</code></td>
<td>
<p>adds a rectangular grid to an existing plot: see
<code><a href="graphics.html#topic+grid">grid</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dynSurv_+3A_estimator">estimator</code></td>
<td>
<p>a character string that can take values <code>mean</code> or
<code>median</code> to specify what prediction statistic is plotted from an
objecting inheritting of class <code>dynSurv</code>. Default is
<code>estimator='median'</code>. This argument is ignored for non-simulated
<code>dynSurv</code> objects, i.e. those of <code>type='first-order'</code>, as in that
case a mode-based prediction is plotted.</p>
</td></tr>
<tr><td><code id="plot.dynSurv_+3A_smooth">smooth</code></td>
<td>
<p>logical: whether to overlay a smooth survival curve (see
<strong>Details</strong>). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.dynSurv_+3A_...">...</code></td>
<td>
<p>additional plotting arguments; currently limited to <code>lwd</code> and
<code>cex</code>. See <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>joineRML</code> package is based on a semi-parametric model,
such that the baseline hazards function is left unspecified. For
prediction, it might be preferable to have a smooth survival curve. Rather
than changing modelling framework <em>a prior</em>, a constrained B-splines
non-parametric median quantile curve is estimated using
<code><a href="cobs.html#topic+cobs">cobs</a></code>, with a penalty function of <code class="reqn">\lambda=1</code>, and
subject to constraints of monotonicity and <code class="reqn">S(t)=1</code>.
</p>


<h3>Value</h3>

<p>A dynamic prediction plot.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Ng P, Maechler M. A fast and efficient implementation of qualitatively
constrained quantile smoothing splines. <em>Statistical Modelling</em>. 2007;
<strong>7(4)</strong>: 315-328.
</p>
<p>Rizopoulos D. Dynamic predictions and prospective accuracy in joint models
for longitudinal and time-to-event data. <em>Biometrics</em>. 2011;
<strong>67</strong>: 819–829.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dynSurv">dynSurv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)

hvd2 &lt;- droplevels(hvd[hvd$num == 1, ])
out1 &lt;- dynSurv(fit2, hvd2)
plot(out1, main = "Patient 1")

## End(Not run)

## Not run: 
# Monte Carlo simulation with 95% confidence intervals on plot

out2 &lt;- dynSurv(fit2, hvd2, type = "simulated", M = 200)
plot(out2, main = "Patient 1")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.mjoint'>Plot diagnostics from an <code>mjoint</code> object</h2><span id='topic+plot.mjoint'></span>

<h3>Description</h3>

<p>Plot diagnostics from an <code>mjoint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
plot(x, type = "convergence", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mjoint_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model of
time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="plot.mjoint_+3A_type">type</code></td>
<td>
<p>currently the only option is <code>type='convergence'</code> for
graphical examination of convergence over MCEM iteration.</p>
</td></tr>
<tr><td><code id="plot.mjoint_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code><a href="#topic+plotConvergence">plotConvergence</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="graphics.html#topic+abline">abline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a classical univariate joint model with a single longitudinal outcome
# and a single time-to-event outcome

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

set.seed(1)
fit1 &lt;- mjoint(formLongFixed = log.lvmi ~ time + age,
    formLongRandom = ~ time | num,
    formSurv = Surv(fuyrs, status) ~ age,
    data = hvd,
    timeVar = "time",
    control = list(nMCscale = 2, burnin = 5)) # controls for illustration only

plot(fit1, param = "beta")  # LMM fixed effect parameters
plot(fit1, param = "gamma") # event model parameters

## End(Not run)

## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    control = list(burnin = 50),
    verbose = TRUE)

plot(fit2, type = "convergence", params = "gamma")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.ranef.mjoint'>Plot a <code>ranef.mjoint</code> object</h2><span id='topic+plot.ranef.mjoint'></span>

<h3>Description</h3>

<p>Displays a plot of the BLUPs and approximate 95% prediction
interval for each subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ranef.mjoint'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ranef.mjoint_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>ranef.mjoint</code>, representing
the estimated random effects for the <code>mjoint</code> object from which it was
produced.</p>
</td></tr>
<tr><td><code id="plot.ranef.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object inheriting from class <code>ggplot</code>, which displays a
trellis plot with a separate panel for each effect, showing a dotplot (with
optional error bars indicating approximate 95% prediction intervals if the
argument <code>postVar=TRUE</code> is set in the call to
<code><a href="nlme.html#topic+ranef">ranef</a></code>) for each subject (by row).
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Pinheiro JC, Bates DM. <em>Mixed-Effects Models in S and S-PLUS.</em> New York:
Springer Verlag; 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranef.mjoint">ranef.mjoint</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(ggplot2)
data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]
set.seed(1)

fit1 &lt;- mjoint(formLongFixed = log.lvmi ~ time,
    formLongRandom = ~ time | num,
    formSurv = Surv(fuyrs, status) ~ 1,
    data = hvd,
    timeVar = "time")

plot(ranef(fit1, postVar = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotConvergence'>Plot convergence time series for parameter vectors from an <code>mjoint</code>
object</h2><span id='topic+plotConvergence'></span>

<h3>Description</h3>

<p>Plot convergence time series for parameter vectors from an
<code>mjoint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConvergence(object, params = "gamma", discard = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotConvergence_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="plotConvergence_+3A_params">params</code></td>
<td>
<p>a string indicating what parameters are to be shown. Options
are <code>params='gamma'</code> for the time-to-event sub-model covariate
coefficients, including the latent association parameters;
<code>params='beta'</code> for the longitudinal sub-model fixed effects
coefficients; <code>params='sigma2'</code> for the residual error variances from
the longitudinal sub-model; <code>params='D'</code> for the lower triangular
matrix of the variance-covariance matrix of random effects;
<code>params='loglik'</code> for the log-likelihood.</p>
</td></tr>
<tr><td><code id="plotConvergence_+3A_discard">discard</code></td>
<td>
<p>logical; if <code>TRUE</code> then the 'burn-in' phase iterations of
the MCEM algorithm are discarded. Default is <code>discard=FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Wei GC, Tanner MA. A Monte Carlo implementation of the EM algorithm and the
poor man's data augmentation algorithms. <em>J Am Stat Assoc.</em> 1990;
<strong>85(411)</strong>: 699-704.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.mjoint">plot.mjoint</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>, <code><a href="graphics.html#topic+abline">abline</a></code>.
</p>

<hr>
<h2 id='ranef.mjoint'>Extract random effects estimates from an <code>mjoint</code> object</h2><span id='topic+ranef.mjoint'></span>

<h3>Description</h3>

<p>Extract random effects estimates from an <code>mjoint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
ranef(object, postVar = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranef.mjoint_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="ranef.mjoint_+3A_postvar">postVar</code></td>
<td>
<p>logical: if <code>TRUE</code> the variance of the posterior
distribution is also returned.</p>
</td></tr>
<tr><td><code id="ranef.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> (also of class <code>ranef.mjoint</code>) with rows
denoting the individuals and columns the random effects (e.g., intercepts,
slopes, etc.). If <code>postVar=TRUE</code>, the numeric matrix has an extra
attribute, <code>postVar</code>.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Pinheiro JC, Bates DM. <em>Mixed-Effects Models in S and S-PLUS.</em> New York:
Springer Verlag; 2000.
</p>
<p>Wulfsohn MS, Tsiatis AA. A joint model for survival and longitudinal data
measured with error. <em>Biometrics.</em> 1997; <strong>53(1)</strong>: 330-339.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+ranef">ranef</a></code> for the generic method description, and
<code><a href="#topic+fixef.mjoint">fixef.mjoint</a></code>. To plot <code>ranef.mjoint</code> objects, see
<code><a href="#topic+plot.ranef.mjoint">plot.ranef.mjoint</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)

ranef(fit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+augment'></span><span id='topic+glance'></span><span id='topic+tidy'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code>, <code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='renal'>Renal transplantation data</h2><span id='topic+renal'></span>

<h3>Description</h3>

<p>This is a dataset on 407 patients suffering from chronic kidney
disease who underwent a primary renal transplantation with a graft from a
deceased or living donor in the University Hospital of the Catholic
University of Leuven (Belgium) between 21 January 1983 and 16 August 2000.
Chronic kidney (renal) disease is a progressive loss of renal function over
a period of months or years through five stages. Each stage is a
progression through an abnormally low and progressively worse glomerular
filtration rate (GFR). The dataset records 3 repeated measures (2
continuous and 1 binary), and an event time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(renal)
</code></pre>


<h3>Format</h3>

<p>This is a list with 4 data frames: </p>

<ol>
<li><p><code>prot</code>: repeated measurement data for proteinuria (binary) that
measures whether the kidneys succeed in sustaining the proteins in the
blood and not discard them in the urine.
</p>
</li>
<li><p><code>haem</code>: repeated measurement data for blood haematocrit level
(continuous) that measures whether the kidneys produce adequate amounts of
the hormone erythropoietin that regulates the red blood cell production.
</p>
</li>
<li><p><code>gfr</code>: repeated measurement data for GFR (continuous) that
measures the filtration rate of the kidneys.
</p>
</li>
<li><p><code>surv</code>: time-to-event data for renal graft failure.
</p>
</li></ol>

<p><strong>All datasets</strong> have the common data columns, which are in long
format for the 3 longitudinal data data frames, and 1-per-subject for the
time-to-event data frame: </p>

<dl>
<dt><code>id</code></dt><dd><p>number for patient identification.</p>
</dd>
<dt><code>age</code></dt><dd><p>age of patient at day of surgery (years).</p>
</dd>
<dt><code>weight</code></dt><dd><p>preoperative weight of patient (kg).</p>
</dd>
<dt><code>sex</code></dt><dd><p>gender of patient.</p>
</dd>
<dt><code>fuyears</code></dt><dd><p>maximum follow up time, with transplant date as the
time origin (years).</p>
</dd>
<dt><code>failure</code></dt><dd><p>censoring indicator (<code>1=</code>graft failure and
<code>0=</code>censored).</p>
</dd>
</dl>

<p><strong>The longitudinal datasets only</strong> contain 2 further columns:
</p>

<dl>
<dt><code>time</code></dt><dd><p>observed time point, with surgery date as the time
origin (years).</p>
</dd>
<dt>biomarker value</dt><dd><p>a recorded measurement of the biomarker taken at
time <code>time</code>. The 3 biomarkers (one per data frame) are: </p>

<ul>
<li><p><code>proteinuria</code>: recorded as binary indicator: present or
not-present. Present in the <code>prot</code> data.
</p>
</li>
<li><p><code>haematocrit</code>: recorded as percentage (%) of the ratio of the
volume of red blood cells to the total volume of blood. Present in the
<code>haem</code> data.
</p>
</li>
<li><p><code>gfr</code>: measured as ml/min/1.73<code class="reqn">m^2</code>. Present in the
<code>gfr</code> data.
</p>
</li></ul>
</dd>
</dl>



<h3>Source</h3>

<p>Dr Dimitris Rizopoulos (<a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>).
</p>


<h3>References</h3>

<p>Rizopoulos D, Ghosh, P. A Bayesian semiparametric multivariate joint model
for multiple longitudinal outcomes and a time-to-event. <em>Stat Med.</em>
2011; <strong>30(12)</strong>: 1366-80.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbc2">pbc2</a></code>, <code><a href="#topic+heart.valve">heart.valve</a></code>,
<code><a href="#topic+epileptic.qol">epileptic.qol</a></code>.
</p>

<hr>
<h2 id='residuals.mjoint'>Extract <code>mjoint</code> residuals</h2><span id='topic+residuals.mjoint'></span>

<h3>Description</h3>

<p>The residuals at level <em>i</em> are obtained by subtracting the fitted
levels at that level from the response vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
residuals(object, level = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.mjoint_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="residuals.mjoint_+3A_level">level</code></td>
<td>
<p>an optional integer giving the level of grouping to be used in
extracting the residuals from object. Level values increase from outermost
to innermost grouping, with level 0 corresponding to the population
residuals and level 1 corresponding to subject-specific residuals. Defaults
to <code>level=0</code>.</p>
</td></tr>
<tr><td><code id="residuals.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of length <em>K</em> with each element a vector of
residuals for the <em>k</em>-th longitudinal outcome.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Pinheiro JC, Bates DM. <em>Mixed-Effects Models in S and S-PLUS.</em> New York:
Springer Verlag; 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjoint">mjoint</a></code>, <code><a href="#topic+fitted.mjoint">fitted.mjoint</a></code>
</p>

<hr>
<h2 id='sampleData'>Sample from an <code>mjoint</code> object</h2><span id='topic+sampleData'></span>

<h3>Description</h3>

<p>Generic function used to sample a subset of data from an object
of class <code>mjoint</code> with a specific number of subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleData(object, size = NULL, replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleData_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="sampleData_+3A_size">size</code></td>
<td>
<p>number of subjects to include in the sampled subset. If
<code>size=NULL</code> (default), then size is set equal to the number of
subjects used to fit the <code>mjoint</code> model.</p>
</td></tr>
<tr><td><code id="sampleData_+3A_replace">replace</code></td>
<td>
<p>use replacement when sampling subjects? Default is
<code>TRUE</code>. If replacement is used, then the subjects are re-labelled from
1 to <code>size</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily intended for internal use in the
<code><a href="#topic+bootSE">bootSE</a></code> function in order to permit bootstrapping. However, it
can be used for other purposes given a fitted <code>mjoint</code> object.
</p>


<h3>Value</h3>

<p>A list of 2 data.frames: one recording the requisite longitudinal
outcomes data, and the other recording the time-to-event data.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjoint">mjoint</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)
sampleData(fit2, size = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='sigma.mjoint'>Extract residual standard deviation(s) from an <code>mjoint</code> object</h2><span id='topic+sigma.mjoint'></span>

<h3>Description</h3>

<p>Extract residual standard deviation(s) from an <code>mjoint</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma.mjoint_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="sigma.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number (standard deviation) if <code class="reqn">K = 1</code> (univariate model), or a
vector if <code class="reqn">K&gt;1</code> (multivariate model).
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Pinheiro JC, Bates DM. <em>Mixed-Effects Models in S and S-PLUS.</em> New York:
Springer Verlag; 2000.
</p>


<h3>See Also</h3>

<p><code><a href="lme4.html#topic+sigma">sigma</a></code> in the <strong>lme4</strong> package.
</p>

<hr>
<h2 id='simData'>Simulate data from a joint model</h2><span id='topic+simData'></span>

<h3>Description</h3>

<p>This function simulates multivariate longitudinal and
time-to-event data from a joint model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simData(
  n = 100,
  ntms = 5,
  beta = rbind(c(1, 1, 1, 1), c(1, 1, 1, 1)),
  gamma.x = c(1, 1),
  gamma.y = c(0.5, -1),
  sigma2 = c(1, 1),
  D = NULL,
  df = Inf,
  model = "intslope",
  theta0 = -3,
  theta1 = 1,
  censoring = TRUE,
  censlam = exp(-3),
  truncation = TRUE,
  trunctime = (ntms - 1) + 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simData_+3A_n">n</code></td>
<td>
<p>the number of subjects to simulate data for.</p>
</td></tr>
<tr><td><code id="simData_+3A_ntms">ntms</code></td>
<td>
<p>the maximum number of (discrete) time points to simulate repeated
longitudinal measurements at.</p>
</td></tr>
<tr><td><code id="simData_+3A_beta">beta</code></td>
<td>
<p>a matrix of <code>dim=c(K,4)</code> specifying the coefficients of the
fixed effects. The order in each row is intercept, time, a continuous
covariate, and a binary covariate.</p>
</td></tr>
<tr><td><code id="simData_+3A_gamma.x">gamma.x</code></td>
<td>
<p>a vector of <code>length=2</code> specifying the coefficients for
the time-to-event baseline covariates, in the order of a continuous
covariate and a binary covariate.</p>
</td></tr>
<tr><td><code id="simData_+3A_gamma.y">gamma.y</code></td>
<td>
<p>a vector of <code>length=K</code> specifying the latent association
parameters for each longitudinal outcome.</p>
</td></tr>
<tr><td><code id="simData_+3A_sigma2">sigma2</code></td>
<td>
<p>a vector of <code>length=K</code> specifying the residual standard
errors.</p>
</td></tr>
<tr><td><code id="simData_+3A_d">D</code></td>
<td>
<p>a positive-definite matrix specifying the variance-covariance
matrix. If <code>model='int'</code>, the matrix has dimension <code>dim=c(K, K)</code>,
else if <code>model='intslope'</code>, the matrix has dimension <code>dim =c(2K,
2K)</code>. If <code>D=NULL</code> (default), an identity matrix is assumed.</p>
</td></tr>
<tr><td><code id="simData_+3A_df">df</code></td>
<td>
<p>a non-negative scalar specifying the degrees of freedom for the
random effects if sampled from a multivariate <em>t</em>-distribution. The
default is <code>df=Inf</code>, which corresponds to a multivariate normal
distribution.</p>
</td></tr>
<tr><td><code id="simData_+3A_model">model</code></td>
<td>
<p>follows the model definition in the <code><a href="joineR.html#topic+joint">joint</a></code>
function. See <strong>Details</strong> for choices.</p>
</td></tr>
<tr><td><code id="simData_+3A_theta0">theta0</code>, <code id="simData_+3A_theta1">theta1</code></td>
<td>
<p>parameters controlling the failure rate. See Details.</p>
</td></tr>
<tr><td><code id="simData_+3A_censoring">censoring</code></td>
<td>
<p>logical: if <code>TRUE</code>, includes an independent censoring
time.</p>
</td></tr>
<tr><td><code id="simData_+3A_censlam">censlam</code></td>
<td>
<p>a scale (<code class="reqn">&gt; 0</code>) parameter for an exponential distribution
used to simulate random censoring times for when <code>censoring=TRUE</code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_truncation">truncation</code></td>
<td>
<p>logical: if <code>TRUE</code>, adds a truncation time for a
maximum event time.</p>
</td></tr>
<tr><td><code id="simData_+3A_trunctime">trunctime</code></td>
<td>
<p>a truncation time for use when <code>truncation=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>simData</code> simulates data from a joint model,
similar to that performed in Henderson et al. (2000). It works by first
simulating multivariate longitudinal data for all possible follow-up times
using random draws for the multivariate Gaussian random effects and
residual error terms. Data can be simulated assuming either
random-intercepts only in each of the longitudinal sub-models, or
random-intercepts and random-slopes. Currently, all models must have the
same structure. The failure times are simulated from proportional hazards
time-to-event models using the following methodologies:
</p>

<dl>
<dt><code>model="int"</code></dt><dd><p>The baseline hazard function is specified to be
an exponential distribution with
</p>
<p style="text-align: center;"><code class="reqn">\lambda_0(t) = \exp{\theta_0}.</code>
</p>

<p>Simulation is conditional on known time-independent effects, and the
methodology of Bender et al. (2005) is used to simulate the failure time.</p>
</dd>
<dt><code>model="intslope"</code></dt><dd><p>The baseline hazard function is specified to
be a Gompertz distribution with
</p>
<p style="text-align: center;"><code class="reqn">\lambda_0(t) = \exp{\theta_0 + \theta_1 t}.</code>
</p>

<p>In the usual representation of the Gompertz distribution, <code class="reqn">\theta_1</code> is
the shape parameter, and the scale parameter is equivalent to
<code class="reqn">\exp(\theta_0)</code>. Simulation is conditional on on a predictable
(linear) time-varying process, and the methodology of Austin (2012) is used
to simulate the failure time.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list of 2 <code>data.frame</code>s: one recording the requisite
longitudinal outcomes data, and one recording the time-to-event data.
</p>


<h3>Author(s)</h3>

<p>Pete Philipson (<a href="mailto:peter.philipson1@newcastle.ac.uk">peter.philipson1@newcastle.ac.uk</a>) and Graeme
L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Austin PC. Generating survival times to simulate Cox proportional hazards
models with time-varying covariates. <em>Stat Med.</em> 2012; <strong>31(29)</strong>:
3946-3958.
</p>
<p>Bender R, Augustin T, Blettner M. Generating survival times to simulate Cox
proportional hazards models. <em>Stat Med.</em> 2005; <strong>24</strong>: 1713-1723.
</p>
<p>Henderson R, Diggle PJ, Dobson A. Joint modelling of longitudinal
measurements and event time data. <em>Biostatistics.</em> 2000; <strong>1(4)</strong>:
465-480.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beta &lt;- rbind(c(0.5, 2, 1, 1),
c(2, 2, -0.5, -1))
D &lt;- diag(4)
D[1, 1] &lt;- D[3, 3] &lt;- 0.5
D[1, 2] &lt;- D[2, 1] &lt;- D[3, 4] &lt;- D[4, 3] &lt;- 0.1
D[1, 3] &lt;- D[3, 1] &lt;- 0.01

sim &lt;- simData(n = 250, beta = beta, D = D, sigma2 = c(0.25, 0.25),
               censlam = exp(-0.2), gamma.y = c(-.2, 1), ntms = 8)
</code></pre>

<hr>
<h2 id='summary.mjoint'>Summary of an <code>mjoint</code> object</h2><span id='topic+summary.mjoint'></span>

<h3>Description</h3>

<p>This function provides a summary of an <code>mjoint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
summary(object, bootSE = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mjoint_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="summary.mjoint_+3A_bootse">bootSE</code></td>
<td>
<p>an object inheriting from class <code>bootSE</code> for the
corresponding model. If <code>bootSE=NULL</code>, the function will attempt to
utilize approximate standard error estimates (if available) calculated from
the empirical information matrix.</p>
</td></tr>
<tr><td><code id="summary.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the coefficient matrices for the longitudinal and
time-to-event sub-models; variance-covariance matrix for the random
effects; residual error variances; log-likelihood of joint model; AIC and
BIC statistics; and model fit objects.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Wulfsohn MS, Tsiatis AA. A joint model for survival and longitudinal data
measured with error. <em>Biometrics.</em> 1997; <strong>53(1)</strong>: 330-339.
</p>
<p>Henderson R, Diggle PJ, Dobson A. Joint modelling of longitudinal
measurements and event time data. <em>Biostatistics.</em> 2000; <strong>1(4)</strong>:
465-480.
</p>
<p>Lin H, McCulloch CE, Mayne ST. Maximum likelihood estimation in the joint
analysis of time-to-event and multiple longitudinal variables. <em>Stat
Med.</em> 2002; <strong>21</strong>: 2369-2382.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mjoint">mjoint</a></code>, <code><a href="#topic+mjoint.object">mjoint.object</a></code>, and
<code><a href="base.html#topic+summary">summary</a></code> for the generic method description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)
summary(fit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcov.mjoint'>Extract an approximate variance-covariance matrix of estimated parameters
from an <code>mjoint</code> object</h2><span id='topic+vcov.mjoint'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the main parameters of
a fitted <code>mjoint</code> model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
vcov(object, correlation = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.mjoint_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>mjoint</code> for a joint model
of time-to-event and multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="vcov.mjoint_+3A_correlation">correlation</code></td>
<td>
<p>logical: if <code>TRUE</code> returns the correlation matrix,
otherwise returns the variance-covariance matrix (default).</p>
</td></tr>
<tr><td><code id="vcov.mjoint_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function that extracts the variance-covariance
matrix of parameters from an <code>mjoint</code> model fit. It is based on a
profile likelihood, so no estimates are given for the baseline hazard
function, which is generally considered a nuisance parameter. It is based
on the empirical information matrix (see Lin et al. 2002, and McLachlan
and Krishnan 2008 for details), so is only approximate.
</p>


<h3>Value</h3>

<p>A variance-covariance matrix.
</p>


<h3>Note</h3>

<p>This function is not to be confused with <code><a href="nlme.html#topic+getVarCov">getVarCov</a></code>,
which returns the extracted variance-covariance matrix for the random
effects distribution.
</p>


<h3>Author(s)</h3>

<p>Graeme L. Hickey (<a href="mailto:graemeleehickey@gmail.com">graemeleehickey@gmail.com</a>)
</p>


<h3>References</h3>

<p>Lin H, McCulloch CE, Mayne ST. Maximum likelihood estimation in the joint
analysis of time-to-event and multiple longitudinal variables. <em>Stat
Med.</em> 2002; <strong>21</strong>: 2369-2382.
</p>
<p>McLachlan GJ, Krishnan T. <em>The EM Algorithm and Extensions</em>. Second
Edition. Wiley-Interscience; 2008.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+vcov">vcov</a></code> for the generic method description, and
<code><a href="stats.html#topic+cov2cor">cov2cor</a></code> for details of efficient scaling of a
covariance matrix into the corresponding correlation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit a classical univariate joint model with a single longitudinal outcome
# and a single time-to-event outcome

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

set.seed(1)
fit1 &lt;- mjoint(formLongFixed = log.lvmi ~ time + age,
    formLongRandom = ~ time | num,
    formSurv = Surv(fuyrs, status) ~ age,
    data = hvd,
    timeVar = "time",
    control = list(nMCscale = 2, burnin = 5)) # controls for illustration only

vcov(fit1)

## End(Not run)

## Not run: 
# Fit a joint model with bivariate longitudinal outcomes

data(heart.valve)
hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp; !is.na(heart.valve$log.lvmi), ]

fit2 &lt;- mjoint(
    formLongFixed = list("grad" = log.grad ~ time + sex + hs,
                         "lvmi" = log.lvmi ~ time + sex),
    formLongRandom = list("grad" = ~ 1 | num,
                          "lvmi" = ~ time | num),
    formSurv = Surv(fuyrs, status) ~ age,
    data = list(hvd, hvd),
    inits = list("gamma" = c(0.11, 1.51, 0.80)),
    timeVar = "time",
    verbose = TRUE)

vcov(fit2)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
