<!DOCTYPE html><html><head><title>Help for package LCAextend</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LCAextend}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alpha.compute'><p> computes cumulative logistic coefficients using probabilities</p></a></li>
<li><a href='#attrib.dens'><p> associates to a function of density parameter optimization an attribute to distinguish between ordinal and normal cases</p></a></li>
<li><a href='#dens.norm'><p> computes the multinormal density of a given continuous</p>
measurement vector for all classes</a></li>
<li><a href='#dens.prod.ordi'><p> computes the probability of a given discrete</p>
measurement vector for all classes under a product of multinomial</a></li>
<li><a href='#downward'><p> performs the downward step of the peeling algorithm and computes unnormalized triplet and individual weights</p></a></li>
<li><a href='#downward.connect'><p> performs a downward step for a connector</p></a></li>
<li><a href='#e.step'><p> performs the E step of the EM algorithm for a single pedigree for both cases with and without familial dependence</p></a></li>
<li><a href='#init.norm'><p> computes initial values for the EM algorithm in the case of continuous measurements</p></a></li>
<li><a href='#init.ordi'><p> computes the initial values for EM algorithm in the case of ordinal measurements</p></a></li>
<li><a href='#init.p.trans'><p> initializes the transition probabilities</p></a></li>
<li><a href='#lca.model'><p>fits latent class models for phenotypic measurements in pedigrees</p>
with or without
familial dependence using an Expectation-Maximization (EM) algorithm</a></li>
<li><a href='#model.select'><p> selects a latent class model for pedigree data</p></a></li>
<li><a href='#n.param'><p> computes the number of parameters of a model</p></a></li>
<li><a href='#optim.const.ordi'><p> performs the M step for the measurement distribution parameters</p>
in multinomial case, with an ordinal constraint on the parameters</a></li>
<li><a href='#optim.diff.norm'><p> performs the M step for measurement density parameters in multinormal case</p></a></li>
<li><a href='#optim.equal.norm'><p> performs the M step for measurement density parameters in multinormal case</p></a></li>
<li><a href='#optim.gene.norm'><p> performs the M step for measurement density parameters in multinormal case</p></a></li>
<li><a href='#optim.indep.norm'><p> performs the M step for measurement density parameters in multinormal case</p></a></li>
<li><a href='#optim.noconst.ordi'><p> performs the M step for the measurement distribution parameters in multinomial case without constraint on the parameters</p></a></li>
<li><a href='#optim.probs'><p> performs the M step of the EM algorithm for the probability parameters</p></a></li>
<li><a href='#p.compute'><p> computes the probability vector using logistic coefficients</p></a></li>
<li><a href='#p.post.child'><p> computes the posterior probability of observations of a child</p></a></li>
<li><a href='#p.post.found'><p> computes the posterior probability of observations of a founder</p></a></li>
<li><a href='#param.cont'><p> parameters to be used for examples in the case of continuous measurements</p></a></li>
<li><a href='#param.ordi'><p> parameters to be used for examples in the case of discrete or ordinal measurements</p></a></li>
<li><a href='#ped.cont'><p> pedigrees with continuous data to be used for examples</p></a></li>
<li><a href='#ped.ordi'><p> pedigrees with discrete or ordinal data to be used for examples</p></a></li>
<li><a href='#peel'><p> peeling order of pedigrees and couples in pedigrees</p></a></li>
<li><a href='#probs'><p> probabilities parameters to be used for examples</p></a></li>
<li><a href='#upward'><p> performs the upward step of the peeling algorithm of a pedigree</p></a></li>
<li><a href='#upward.connect'><p> performs the upward step for a connector</p></a></li>
<li><a href='#weight.famdep'><p> performs the computation of triplet and individual weights for a pedigree under familial dependence</p></a></li>
<li><a href='#weight.nuc'><p> performs the computation of unnormalized triplet and individuals weights for a nuclear family in the pedigree</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Latent Class Analysis (LCA) with Familial Dependence in Extended
Pedigrees</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-07-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Arafat TAYEB &lt;arafat.tayeb@ircm.qc.ca&gt;, Alexandre BUREAU
        &lt;alexandre.bureau@msp.ulaval.ca&gt; and Aurelie Labbe
        &lt;aurelie.labbe@mcgill.ca&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexandre BUREAU &lt;alexandre.bureau@msp.ulaval.ca&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, mvtnorm, rms, kinship2</td>
</tr>
<tr>
<td>Description:</td>
<td>Latent Class Analysis of
        phenotypic measurements in pedigrees and model selection
        based on one of two methods: likelihood-based cross-validation
        and Bayesian Information Criterion. Computation of individual
        and triplet child-parents weights in a pedigree is performed using an
        upward-downward algorithm. The model takes into account the familial
        dependence defined by the pedigree structure by considering
        that a class of a child depends on his parents classes via
        triplet-transition probabilities of the classes. The package
        handles the case where measurements are available on all
        subjects and the case where measurements are available only on
        symptomatic (i.e. affected) subjects. Distributions for
        discrete (or ordinal) and continuous data are currently
        implemented. The package can deal with missing data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=LCAextend">https://CRAN.R-project.org/package=LCAextend</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-06 19:14:03 UTC; alexandrebureau</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-07 15:40:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='alpha.compute'> computes cumulative logistic coefficients using probabilities </h2><span id='topic+alpha.compute'></span>

<h3>Description</h3>

<p>computes cumulative logistic coefficients using probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha.compute(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha.compute_+3A_p">p</code></td>
<td>
<p>a vector of probabilities (positive entries summing to 1). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>p</code> has one value (equal to 1) <code>alpha.compute</code> returns <code>NA</code>, if it has <code>S (S&gt;=2)</code> values, <code>alpha.compute</code> returns <code>S-1</code> coefficients 
<code>alpha</code> such that if <code>Y</code> is a random variable taking values in <code>{1,...,S}</code> with probabilities <code>p</code>, coefficients <code>alpha[i]</code> are given by:
</p>
<p style="text-align: center;"><code class="reqn"> p_1+...+p_i=P(Y\leq i)=\frac{\exp(\alpha_1+...+\alpha_i)}{1+\exp(\alpha_1+...+\alpha_i)},  </code>
</p>

<p>for all <code>i&lt;=S-1</code>.
</p>


<h3>Value</h3>

<p>The function returns <code>alpha</code>:  a vector of <code>S-1</code> cumulative logistic coefficients.
</p>


<h3>See Also</h3>

 <p><code>alpha.compute</code> is the inverse function of <code><a href="#topic+p.compute">p.compute</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># a vector of probability
p &lt;- c(0,0.2,0,0,0.3,0.4,0.1,0,0)
alpha.compute(p)
#gives -Inf -1.38 0 0 1.38 0 2.19 Inf Inf
p.compute(alpha.compute(rep(1/5,5)))
</code></pre>

<hr>
<h2 id='attrib.dens'> associates to a function of density parameter optimization an attribute to distinguish between ordinal and normal cases </h2><span id='topic+attrib.dens'></span>

<h3>Description</h3>

<p> associates to a function of density parameter optimization an attribute to distinguish between ordinal and normal cases. This is an internal function not meant to be called by the user. </p>


<h3>Usage</h3>

<pre><code class='language-R'>attrib.dens(optim.param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attrib.dens_+3A_optim.param">optim.param</code></td>
<td>
<p>the function used to estimate the parameters of the measurements. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available <code>optim.param</code> functions are <code><a href="#topic+optim.noconst.ordi">optim.noconst.ordi</a></code>, <code><a href="#topic+optim.const.ordi">optim.const.ordi</a></code> for ordinal measurements and <code><a href="#topic+optim.indep.norm">optim.indep.norm</a></code>, <code><a href="#topic+optim.diff.norm">optim.diff.norm</a></code>, <code><a href="#topic+optim.equal.norm">optim.equal.norm</a></code> and <code><a href="#topic+optim.gene.norm">optim.gene.norm</a></code> for multinormal measurements. The attribution uses the internal function <code>attr</code> and the attribute name used is <code>type</code>. The user can make his own <code>optima.param</code> function and has to associate an attribute <code>type</code> to it to be used instead of the available ones.
</p>


<h3>Value</h3>

<p>The function returns the same <code>optim.param</code> with an attribute <code>type</code> taking values in <code>ordi</code> or <code>norm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>optim.param &lt;- optim.indep.norm
optim.param &lt;- attrib.dens(optim.param)
</code></pre>

<hr>
<h2 id='dens.norm'> computes the multinormal density of a given continuous
measurement vector for all classes </h2><span id='topic+dens.norm'></span>

<h3>Description</h3>

<p>computes the density of an individual's continuous measurement vector for all latent classes,
eventually taking covariates into account. This is an internal
function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens.norm(y.x, param, var.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens.norm_+3A_y.x">y.x</code></td>
<td>
<p> a vector <code>y</code> of values of the measurement followed by the values <code>x</code> of covariates, if any,</p>
</td></tr>
<tr><td><code id="dens.norm_+3A_param">param</code></td>
<td>
<p> a list of the multinormal density parameters: means <code>mu</code> and variances-covariances <code>sigma</code>, </p>
</td></tr>
<tr><td><code id="dens.norm_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating which covariates (taken from <code>x</code>) are used for a given type of measurement. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each class <code>k</code>, the function computes the multinormal density with means <code>param$mu[[k]]</code> and variances-covariances matrix 
<code>param$sigma[[k]]</code> for the individual's measurement
vector. Treatment of covariates is not yet implemented, and any
provided covariate value will be ignored.
</p>


<h3>Value</h3>

<p>The function returns a vector <code>dens</code> of length <code>K</code>, where
<code>dens[k]</code> is the density of the measurements if the individual belongs to class <code>k</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
status &lt;- ped.cont[,6]
y &lt;- ped.cont[status==2,7:ncol(ped.cont)]
#param
data(param.cont)
#the function applied for measurement of the first individual in the ped.ordi
dens.norm(y.x=y[1,],param.cont)
</code></pre>

<hr>
<h2 id='dens.prod.ordi'> computes the probability of a given discrete
measurement vector for all classes under a product of multinomial </h2><span id='topic+dens.prod.ordi'></span>

<h3>Description</h3>

<p>computes the probability of an individual's discrete measurement vector for all
latent classes under a multinomial distribution product, eventually
taking covariates into account. This is an internal
function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens.prod.ordi(y.x, param, var.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens.prod.ordi_+3A_y.x">y.x</code></td>
<td>
<p> a vector <code>y</code> of values of the ordinal variables (measurements) followed by the values <code>x</code> of covariates, if any, </p>
</td></tr>
<tr><td><code id="dens.prod.ordi_+3A_param">param</code></td>
<td>
<p> a list of the parameters alpha (cumulative logistic coefficients), see <code><a href="#topic+init.ordi">init.ordi</a></code>, </p>
</td></tr>
<tr><td><code id="dens.prod.ordi_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating which covariates (taken from <code>x</code>) are used for a given type of measurement. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are <code>K</code> latent classes, <code>d</code> measurements and each measurement has <code>S[j]</code> possible values, <code>alpha</code> is a list of <code>d</code> 
elements, each is a <code>K</code> times <code>S[j]+length{var.list[[j]]}</code> matrix. For a class <code>C=k</code>, <code>dens[k]=</code><code class="reqn">\displaystyle\prod_{j=1}^d{P(Y_j=y_j|C=k,X_j=x_j)}</code>, where <code class="reqn">P(Y_j=y_j|C=k,X_j=x_j)</code> is
computed from the cumulative logistic coefficients <code>alpha[[j]][k,]</code> and 
covariates <code>x[var.list[[j]]]</code>,
</p>


<h3>Value</h3>

<p>The function returns a vector <code>dens</code> of length <code>K</code>,  where
<code>dens[k]</code> is the probability of measurement vector <code>y</code> with covariates <code>x</code>, 
if the individual belongs to class <code>k</code>.
</p>


<h3>See Also</h3>

<p>  See Also <code><a href="#topic+init.ordi">init.ordi</a></code>, </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.ordi)
status &lt;- ped.ordi[,6]
y &lt;- ped.ordi[status==2,7:ncol(ped.ordi)]
#param
data(param.ordi)
#the function applied for measurement of the first individual in the ped.ordi
dens.prod.ordi(y.x=y[1,],param.ordi)
</code></pre>

<hr>
<h2 id='downward'> performs the downward step of the peeling algorithm and computes unnormalized triplet and individual weights </h2><span id='topic+downward'></span>

<h3>Description</h3>

<p>computes the probability of measurements above connectors and their
classes given the model parameters, and returns the unnormalized
triplet and individual weights. This is an internal
function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downward(id, dad, mom, status, probs, fyc, peel, res.upward)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downward_+3A_id">id</code></td>
<td>
<p> individual ID of the pedigree, </p>
</td></tr>
<tr><td><code id="downward_+3A_dad">dad</code></td>
<td>
<p> dad ID, </p>
</td></tr>
<tr><td><code id="downward_+3A_mom">mom</code></td>
<td>
<p> mom ID, </p>
</td></tr>
<tr><td><code id="downward_+3A_status">status</code></td>
<td>
<p> symptom status: (2: symptomatic, 1: without symptoms, 0: missing), </p>
</td></tr>
<tr><td><code id="downward_+3A_probs">probs</code></td>
<td>
<p> a list of probability parameters of the model, </p>
</td></tr>
<tr><td><code id="downward_+3A_fyc">fyc</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K+1</code> given the density of observations of each individual if allocated to class <code>k</code>, where <code>n</code> is the 
number of individuals and <code>K</code> is the total number of latent classes in the model, </p>
</td></tr>
<tr><td><code id="downward_+3A_peel">peel</code></td>
<td>
<p> a list of pedigree peeling containing connectors by peeling order and couples of parents, </p>
</td></tr>
<tr><td><code id="downward_+3A_res.upward">res.upward</code></td>
<td>
<p> result of the upward step of the peeling algorithm, see <code><a href="#topic+upward">upward</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the probability of observations above connectors and their classes using the function <code><a href="#topic+downward.connect">downward.connect</a></code>, for each connector, 
if <code>Y_above(i)</code> is the observations above connector <code>i</code> and <code>S_i</code> and <code>C_i</code> are his status and his class respectively, the functions computes 
<code>P(Y_above(i),S_i,C_i)</code> by computing a downward step for the parent of connector <code>i</code> who is also a connector. These quantities are used by the function <code><a href="#topic+weight.nuc">weight.nuc</a></code> to compute the unnormalized triplet weights <code>ww</code> and the unnormalized 
individual weights <code>w</code>.
</p>


<h3>Value</h3>

<p>The function returns a list of 2 elements:
</p>
<table>
<tr><td><code>ww</code></td>
<td>
<p> unnormalized triplet weights, an array of <code>n</code> times 2 times <code>K+1</code> times <code>K+1</code> times <code>K+1</code>, where <code>n</code> is the 
number of individulas and <code>K</code> is the total number of latent classes in the model, see <code><a href="#topic+e.step">e.step</a></code> for more details, </p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p> unnormalized individual weights, an array of <code>n</code> times 2 times <code>K+1</code>, see <code><a href="#topic+e.step">e.step</a></code>. </p>
</td></tr>
</table>


<h3>References</h3>

<p> TAYEB et al.: Solving Genetic Heterogeneity in Extended Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 2011, DOI: 10.1007/s00180-010-0224-2. </p>


<h3>See Also</h3>

<p>  See also <code><a href="#topic+downward.connect">downward.connect</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
data(peel)
fam &lt;- ped.cont[,1]
id &lt;- ped.cont[fam==1,2]
dad &lt;- ped.cont[fam==1,3]
mom &lt;- ped.cont[fam==1,4]
status &lt;- ped.cont[fam==1,6]
y &lt;- ped.cont[fam==1,7:ncol(ped.cont)]
peel &lt;- peel[[1]]
#standardize id to be 1, 2, 3, ...
id.origin &lt;- id
standard &lt;- function(vec) ifelse(vec%in%id.origin,which(id.origin==vec),0)
id &lt;- apply(t(id),2,standard)
dad &lt;- apply(t(dad),2,standard)
mom &lt;- apply(t(mom),2,standard)
peel$couple &lt;- cbind(apply(t(peel$couple[,1]),2,standard),
                     apply(t(peel$couple[,2]),2,standard))
for(generat in 1:peel$generation) 
    peel$peel.connect[generat,] &lt;- apply(t(peel$peel.connect[generat,]),2,standard)
#probs and param
data(probs)
data(param.cont)
#densities of the observations
fyc &lt;- matrix(1,nrow=length(id),ncol=length(probs$p)+1)
fyc[status==2,1:length(probs$p)] &lt;- t(apply(y[status==2,],1,dens.norm,param.cont,NULL))
#the upward step
res.upward &lt;- upward(id,dad,mom,status,probs,fyc,peel)
#the function
downward(id,dad,mom,status,probs,fyc,peel,res.upward)
</code></pre>

<hr>
<h2 id='downward.connect'> performs a downward step for a connector </h2><span id='topic+downward.connect'></span>

<h3>Description</h3>

<p>computes the probability of the measurements above a connector and the
connector latent class given the model parameters. This is an internal
function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downward.connect(connect, parent1, parent2, bro.connect, status, 
                 probs, fyc, p.ybarF.c, res.upward)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downward.connect_+3A_connect">connect</code></td>
<td>
<p> a connector in the pedigree (individual with parents and children in the pedigree), </p>
</td></tr>
<tr><td><code id="downward.connect_+3A_parent1">parent1</code></td>
<td>
<p> one of the connector parent who is also a connector, </p>
</td></tr>
<tr><td><code id="downward.connect_+3A_parent2">parent2</code></td>
<td>
<p> the other parent of the connector (not a connector), </p>
</td></tr>
<tr><td><code id="downward.connect_+3A_bro.connect">bro.connect</code></td>
<td>
<p> siblings of the connector, </p>
</td></tr>
<tr><td><code id="downward.connect_+3A_status">status</code></td>
<td>
<p> a vector of symptom status, </p>
</td></tr>
<tr><td><code id="downward.connect_+3A_probs">probs</code></td>
<td>
<p> a list of all probability parameters of the model, </p>
</td></tr>
<tr><td><code id="downward.connect_+3A_fyc">fyc</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K+1</code> given the density of observations of each individual if allocated to class <code>k</code>, where <code>n</code> is the 
number of individuals and <code>K</code> is the total number of latent classes in the model. the <code>K+1</code> corresponds to the unaffected class, </p>
</td></tr>
<tr><td><code id="downward.connect_+3A_p.ybarf.c">p.ybarF.c</code></td>
<td>
<p> a array of dimension <code>n</code> times 2 times <code>K+1</code> giving the probability of observations above the individual, 
depending on his status and his class and conditionally to his class, </p>
</td></tr>
<tr><td><code id="downward.connect_+3A_res.upward">res.upward</code></td>
<td>
<p> the result of the upward step of the peeling algorithm, see <code><a href="#topic+upward">upward</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>Y_above(i)</code> is the measurements above connector <code>i</code> and <code>S_i</code> and <code>C_i</code> are his status and his class respectively, the function computes 
<code>P(Y_above(i),S_i,C_i)</code> by computing a downward step for the parent of connector <code>i</code> who is also a connector.
</p>


<h3>Value</h3>

<p>The function returns <code>p.ybarF.c</code> updated for connector <code>i</code>.
</p>


<h3>References</h3>

<p> TAYEB et al.: Solving Genetic Heterogeneity in Extended Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 2011, DOI: 10.1007/s00180-010-0224-2. </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+downward">downward</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
data(peel)
fam &lt;- ped.cont[,1]
id &lt;- ped.cont[fam==1,2]
dad &lt;- ped.cont[fam==1,3]
mom &lt;- ped.cont[fam==1,4]
status &lt;- ped.cont[fam==1,6]
y &lt;- ped.cont[fam==1,7:ncol(ped.cont)]
peel &lt;- peel[[1]]
#standardize id to be 1, 2, 3, ...
id.origin &lt;- id
standard &lt;- function(vec) ifelse(vec%in%id.origin,which(id.origin==vec),0)
id &lt;- apply(t(id),2,standard)
dad &lt;- apply(t(dad),2,standard)
mom &lt;- apply(t(mom),2,standard)
peel$couple &lt;- cbind(apply(t(peel$couple[,1]),2,standard),
                     apply(t(peel$couple[,2]),2,standard))
for(generat in 1:peel$generation) 
peel$peel.connect[generat,] &lt;- apply(t(peel$peel.connect[generat,]),2,standard)
#the 2nd connector
generat &lt;- peel$generation-1
connect &lt;- peel$peel.connect[generat,]
connect &lt;- connect[connect&gt;0][1]
parent1.connect &lt;- intersect(peel$peel.connect[generat+1,],c(dad[id==connect],
                                                             mom[id==connect]))
parent2.connect &lt;- setdiff(c(dad[id==connect],mom[id==connect]),parent1.connect)
bro.connect &lt;- union(id[dad==parent1.connect],id[mom==parent1.connect])
bro.connect &lt;- setdiff(bro.connect,connect)
#probs and param
data(probs)
data(param.cont)
#densities of the observations
fyc &lt;- matrix(1,nrow=length(id),ncol=length(probs$p)+1)
fyc[status==2,1:length(probs$p)] &lt;- t(apply(y[status==2,],1,dens.norm,param.cont,NULL))
#probability of the observations below
p.ybarF.c &lt;- array(1,dim=c(length(id),2,length(probs$p)+1))
#the upward step
res.upward &lt;- upward(id,dad,mom,status,probs,fyc,peel)
#the function
downward.connect(connect,parent1.connect,parent2.connect,bro.connect,status,
                 probs,fyc,p.ybarF.c,res.upward)
</code></pre>

<hr>
<h2 id='e.step'> performs the E step of the EM algorithm for a single pedigree for both cases with and without familial dependence</h2><span id='topic+e.step'></span>

<h3>Description</h3>

<p>computes triplet and individual weights the E step of the EM algorithm
for all pedigrees in the data, in both cases with and without familial
dependence. This is an internal
function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e.step(ped, probs, param, dens, peel, x = NULL, var.list = NULL, 
       famdep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e.step_+3A_ped">ped</code></td>
<td>
<p> a matrix representing pedigrees and measurements: <code>ped[,1]</code> family ID, <code>ped[,2]</code> subjects ID, <code>ped[,3]</code> dad ID, 
<code>ped[,4]</code> mom ID, <code>ped[,5]</code> sex, <code>ped[,6]</code> symptom status: (2: symptomatic, 1: without symptoms, 0: missing), 
<code>ped[,7:ncol(ped)]</code> measurements, each column corresponds to a phenotypic measurement, </p>
</td></tr>
<tr><td><code id="e.step_+3A_probs">probs</code></td>
<td>
<p> a list of probability parameters of the model, see below for more details, </p>
</td></tr>
<tr><td><code id="e.step_+3A_param">param</code></td>
<td>
<p> a list of measurement distribution parameters of the model, see below for more details, </p>
</td></tr>
<tr><td><code id="e.step_+3A_dens">dens</code></td>
<td>
<p> distribution of the mesurements, used in the model (multinormal, multinomial,...)</p>
</td></tr>
<tr><td><code id="e.step_+3A_peel">peel</code></td>
<td>
<p> a list of pedigree peeling containing connectors by peeling order and couples of parents, </p>
</td></tr>
<tr><td><code id="e.step_+3A_x">x</code></td>
<td>
<p> covariates, if any. Default is <code>NULL</code>, </p>
</td></tr>
<tr><td><code id="e.step_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating which covariates (taken from <code>x</code>) are used for a given type of measurement. Default is <code>NULL</code>, </p>
</td></tr>
<tr><td><code id="e.step_+3A_famdep">famdep</code></td>
<td>
<p> a logical variable indicating if familial dependence model is used or not. Default is <code>TRUE</code>. In models without familial dependence, individuals 
are treated as independent and pedigree structure is meaningless. In models with familial dependence, a child class depends in his parents classes via a 
triplet-transition probability, </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>probs </code> is a list of initial probability parameters:
</p>
<p>For models with familial dependence:
</p>

<dl>
<dt><code>p</code></dt><dd><p> a probability vector, each <code>p[c]</code> is the probability that an symptomatic founder is in class  <code>c</code> for <code>c&gt;=1</code>, </p>
</dd>
<dt><code>p0</code></dt><dd><p> the probability that a founder without symptoms is in class 0, </p>
</dd>
<dt><code>p.trans</code></dt><dd><p> an array of dimension <code>K</code> times <code>K+1</code>
times <code>K+1</code>, where <code>K</code> is the number of latent classes of
the model, and is such that <code>p.trans[c_i,c_1,c_2]</code> is the
conditional probability that a symptomatic individual
<code>i</code> is in class <code>c_i</code> given that his parents are in classes
<code>c_1</code> and <code>c_2</code>, </p>
</dd>
<dt><code>p0connect</code></dt><dd><p> a vector of length <code>K</code>, where
<code>p0connect[c]</code> is the probability that a connector without
symptoms is in class <code>0</code>, 
given that one of his parents is in class <code>c&gt;=1</code> and the other in class 0, </p>
</dd>
<dt><code>p.found</code></dt><dd><p> the probability that a founder is symptomatic, </p>
</dd>
<dt><code>p.child</code></dt><dd><p> the probability that a child is symptomatic, </p>
</dd>
</dl>

<p>For models without familial dependence, all individuals are independent:
</p>

<dl>
<dt><code>p</code></dt><dd><p> a probability vector, each <code>p[c]</code> is the probability that an symptomatic individual is in class <code>c</code> for <code>c&gt;=1</code>, </p>
</dd>
<dt><code>p0</code></dt><dd><p> the probability that an individual without symptoms is in class 0, </p>
</dd>
<dt><code>p.aff</code></dt><dd><p> the probability that an individual is symptomatic, </p>
</dd>
</dl>

<p><code>param</code> is a list of measurement density parameters: the coefficients <code>alpha</code> (cumulative logistic coefficients see <code><a href="#topic+alpha.compute">alpha.compute</a></code>) in 
the case of discrete or ordinal data, and means <code>mu</code> and variances-covariances matrices <code>sigma</code> in the case of continuous data,
</p>


<h3>Value</h3>

<p>The function returns a list of 3 elements:
</p>
<table>
<tr><td><code>ww</code></td>
<td>
<p> triplet posterior probabilities, an array of <code>n</code> (the number of individuals) times 2 times <code>K+1</code> times <code>K+1</code> times <code>K+1</code>, 
where <code>K</code> is the total number of latent classes of the model. For an individual <code>i</code>, the triplet probability <code>ww[i,s,c,c_1,c_2]</code> is the 
posterior probability that individual <code>i</code> belongs to class <code>c</code> when his symptom status is <code>s</code> and given that his parents classes are <code>c_1</code> 
and <code>c_2</code>, where <code>s</code> takes two values 1 for affected and 2 for unaffected. In particular, all <code>ww[,2,,,]</code> are zeros for affected individuals and 
all <code>ww[,1,,,]</code> are zeros for unaffected individuals. For missing individuals (unkown symptom status), both <code>ww[,1,,,]</code> and <code>ww[,2,,,]</code> are full,</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p> individual posterior probabilities, an array of <code>n</code> times 2 times <code>K+1</code> , where <code>n</code> is the number of individuals and is such that 
<code>w[i,s,c]</code> is the posterior probability that individual <code>i</code> belongs to class <code>c</code> when his symptom status is <code>s</code>, where 
<code>s</code> takes two values 1 for affected and 2 for unaffected. In particular, all <code>w[,2,]</code> are zeros for affected individuals and all <code>w[,1,]</code> are 
zeros for unaffected individuals. For missing individuals (unkown symptom status), both <code>w[,1,]</code> and <code>w[,2,]</code> are full, </p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p> log-likelihood of the considered model and parameters. </p>
</td></tr>
</table>


<h3>References</h3>

<p> TAYEB et al.: Solving Genetic Heterogeneity in Extended Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 2011, DOI: 10.1007/s00180-010-0224-2. </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+weight.famdep">weight.famdep</a></code>, <code><a href="#topic+lca.model">lca.model</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
data(peel)
#probs and probs
data(probs)
data(param.cont)
#the function
e.step(ped.cont,probs,param.cont,dens.norm,peel,x=NULL,var.list=NULL,
       famdep=TRUE)
</code></pre>

<hr>
<h2 id='init.norm'> computes initial values for the EM algorithm in the case of continuous measurements </h2><span id='topic+init.norm'></span>

<h3>Description</h3>

<p>computes initial values of means and variance-covariance matrices for the EM algorithm in the case of continuous measurements and multinormal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.norm(y, K, x = NULL, var.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.norm_+3A_y">y</code></td>
<td>
<p> a <code>n</code> times <code>d</code> matrix of continuous measurements, where <code>n</code> is the number of indivduals and <code>d</code> is the number of measurements.
All entries must be finite, if not an error is produced, </p>
</td></tr>
<tr><td><code id="init.norm_+3A_k">K</code></td>
<td>
<p> number of latent classes of the model, </p>
</td></tr>
<tr><td><code id="init.norm_+3A_x">x</code></td>
<td>
<p> a matrix of covariates if any, default is <code>NULL</code> (no covariates), </p>
</td></tr>
<tr><td><code id="init.norm_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating which covariates (taken from <code>x</code>) are used for a given measurement (a column of <code>y</code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allocates every individual to a class by a simple
clustering of the data and evaluates the means and variance-covariance matrices of
measurements in each class. Treatment of covariates is not yet implemented, and any
provided covariate value will be ignored.
</p>


<h3>Value</h3>

<p>The function returns a list of 2 elements <code>mu</code> and <code>sigma</code> of length <code>K</code> each, <code>mu[k]</code> is the means vector 
(of length <code>d</code>) of measurements in class <code>k</code> and <code>sigma[k]</code> is the variances-covariances matrix 
(of dimension <code>d</code> times <code>d</code>) of measurements in class <code>k</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
status &lt;- ped.cont[,6]
y &lt;- ped.cont[status==2,7:ncol(ped.cont)]
#the function
init.norm(y,K=3)
</code></pre>

<hr>
<h2 id='init.ordi'> computes the initial values for EM algorithm in the case of ordinal measurements </h2><span id='topic+init.ordi'></span>

<h3>Description</h3>

<p>computes the initial values of cumulative logistic coefficients alpha
for the EM algorithm in the case of ordinal measurements and a product multinomial model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.ordi(y, K, x = NULL, var.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.ordi_+3A_y">y</code></td>
<td>
<p> a <code>n</code> times <code>d</code> matrix of ordinal (or discrete) measurements, where <code>n</code> is the number of individuals and <code>d</code> is the number of 
measurements. All entries must be finite, if not an error is produced, </p>
</td></tr>
<tr><td><code id="init.ordi_+3A_k">K</code></td>
<td>
<p> number of latent classes of the model, </p>
</td></tr>
<tr><td><code id="init.ordi_+3A_x">x</code></td>
<td>
<p> a matrix of covariates if any, default is <code>NULL</code> (no covariates), </p>
</td></tr>
<tr><td><code id="init.ordi_+3A_var.list">var.list</code></td>
<td>
<p> list of integers indicating which covariates (taken from <code>x</code>) are used for a given measurement (a column of <code>y</code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allocates every individual to a class and evaluates the
cumulative logistic coefficients for each measurement and each
class. Regression coefficients for the covariates are set to 0.
</p>


<h3>Value</h3>

<p>The function returns a list of one element <code>alpha</code> which is a list of <code>d</code> elements, each element <code>alpha[[j]]</code> is a <code>K</code> times 
<code>S-1</code> matrix, where <code>S</code> is the number of values of the measurement <code>y[,j]</code>, a row <code>alpha[[j]][k,]</code> gives the the cumulative logistic 
coefficients of class <code>k</code> and measurement <code>j</code> using <code><a href="#topic+alpha.compute">alpha.compute</a></code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+alpha.compute">alpha.compute</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.ordi)
status &lt;- ped.ordi[,6]
y &lt;- ped.ordi[,7:ncol(ped.ordi)]
#the function
init.ordi(y[status==2,],K=3)
</code></pre>

<hr>
<h2 id='init.p.trans'> initializes the transition probabilities </h2><span id='topic+init.p.trans'></span>

<h3>Description</h3>

<p>initializes the marginal transition probabilities with or without parental constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.p.trans(K, trans.const = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.p.trans_+3A_k">K</code></td>
<td>
<p> number of latent classes, </p>
</td></tr>
<tr><td><code id="init.p.trans_+3A_trans.const">trans.const</code></td>
<td>
<p> a logical variable indicating if the parental constraint is used. Parental constraint means that the class of a subject can be only one 
of his parents classes. Default is <code>TRUE</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All non-zero transition probabilities are set to be equal. The
parental constraint indicator determines which transition probabilities
are non-zero.
</p>


<h3>Value</h3>

<p>the function returns <code>p.trans</code> an array of dimension <code>K</code> times <code>K+1</code> times <code>K+1</code>: <code>p.trans[c_i,c_1,c_2]</code> is the probability that 
the subject <code>i</code> is assigned to class <code>c_i</code> and his parents to classes <code>c_1</code> and <code>c_2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init.p.trans(3) #parental constraint is TRUE,
init.p.trans(3,trans.const=FALSE) #parental constraint is FALSE.
</code></pre>

<hr>
<h2 id='lca.model'>fits latent class models for phenotypic measurements in pedigrees
with or without 
familial dependence using an Expectation-Maximization (EM) algorithm </h2><span id='topic+lca.model'></span>

<h3>Description</h3>

<p>This is the main function for fitting latent class models. It performs some checks of the pedigrees (it exits if an individual has only one 
parent in the pedigree, if no children is in the pedigree or if there
are not enough individuals for parameters estimation) and of the
initial values (positivity of probabilites and their summation to
one). For models with familial dependence, the child latent class
depends on his parents classes via 
triplet-transition probabilities. In the case of models without
familial dependence, it performs the classical Latent 
Class Analysis (LCA) where all individuals are supposed independent 
and the pedigree structure is meaningless. The EM algorithm stops when
the difference between log-likelihood is smaller then <code>tol</code> that
is fixed by the user. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lca.model(ped, probs, param, optim.param, fit = TRUE, 
optim.probs.indic = c(TRUE, TRUE, TRUE, TRUE), tol = 0.001, 
x = NULL, var.list = NULL, famdep = TRUE, modify.init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lca.model_+3A_ped">ped</code></td>
<td>
<p> a matrix or data frame representing pedigrees and measurements: <code>ped[,1]</code> family ID, <code>ped[,2]</code> subjects ID, <code>ped[,3]</code> dad ID, 
<code>ped[,4]</code> mom ID, <code>ped[,5]</code> sex, <code>ped[,6]</code> symptom
status (2: symptomatic, 1: without symptoms, 0: missing), 
<code>ped[,7:ncol(ped)]</code> measurements, each column corresponds to a phenotypic measurement. If the measurement distribution specified with <code>optim.param</code> is multinomial, then these columns must either be of type <code>integer</code> of <code>factor</code>,  </p>
</td></tr>
<tr><td><code id="lca.model_+3A_probs">probs</code></td>
<td>
<p> a list of initial probability parameters (see below
for more details). The function <code><a href="#topic+init.p.trans">init.p.trans</a></code> can be
used to compute an initial value  
of the component <code>p.trans</code> of <code>probs</code>, </p>
</td></tr>
<tr><td><code id="lca.model_+3A_param">param</code></td>
<td>
<p> a list of initial measurement distribution parameters (see below for more details). The function <code><a href="#topic+init.ordi">init.ordi</a></code> can be used to compute an initial 
value of <code>param</code> in the case of discrete or ordinal data (product
multinomial distribution) and <code><a href="#topic+init.norm">init.norm</a></code> in the case of
continous data (mutivariate normal distribution), </p>
</td></tr>
<tr><td><code id="lca.model_+3A_optim.param">optim.param</code></td>
<td>
<p> a variable indicating how measurement distribution parameter optimization is performed (see below for more details), </p>
</td></tr>
<tr><td><code id="lca.model_+3A_fit">fit</code></td>
<td>
<p> a logical variable, if <code>TRUE</code>, the EM algorithm is
performed, if <code>FALSE</code>, only computation of weights and
log-likelihood are performed with the initial parameter values
without log-likelihood maximization, </p>
</td></tr>
<tr><td><code id="lca.model_+3A_optim.probs.indic">optim.probs.indic</code></td>
<td>
<p> a vector of logical values indicating which probability parameters to estimate, </p>
</td></tr>
<tr><td><code id="lca.model_+3A_tol">tol</code></td>
<td>
<p> a small number governing the stopping rule of the EM algorithm. Default is 0.001, </p>
</td></tr>
<tr><td><code id="lca.model_+3A_x">x</code></td>
<td>
<p> a matrix of covariates (optional), default is <code>NULL</code>, </p>
</td></tr>
<tr><td><code id="lca.model_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating the columns of
<code>x</code> containing the covariates to use for a given phenotypic measurement, default is <code>NULL</code>, </p>
</td></tr>
<tr><td><code id="lca.model_+3A_famdep">famdep</code></td>
<td>
<p> a logical variable indicating if familial dependence model is used or not. Default is <code>TRUE</code>. In models without familial dependence, individuals 
are treated as independent and pedigree structure is meaningless. In models with familial dependence, a child class depends in his parents classes via a 
triplet-transition probability, </p>
</td></tr>
<tr><td><code id="lca.model_+3A_modify.init">modify.init</code></td>
<td>
<p> a function to modify initial values of the EM algorithm, or <code>NULL</code>, default is <code>NULL</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The symptom status vector (column 6 of <code>ped</code>) takes value 1 for
subjects that have been
examined and show no symptoms (i.e. completely unaffected
subjects). When applying the LCA to
measurements available on all subjects, the status vector must take the
value of 2 for every individual with measurements.
</p>
<p><code>probs </code> is a list of initial probability parameters:
</p>
<p>For models with familial dependence:
</p>

<dl>
<dt><code>p</code></dt><dd><p> a probability vector, each <code>p[c]</code> is the probability that an symptomatic founder is in class  <code>c</code> for <code>c&gt;=1</code>, </p>
</dd>
<dt><code>p0</code></dt><dd><p> the probability that a founder without symptoms is in class 0, </p>
</dd>
<dt><code>p.trans</code></dt><dd><p> an array of dimension <code>K</code> times <code>K+1</code>
times <code>K+1</code>, where <code>K</code> is the number of latent classes of
the model, and is such that <code>p.trans[c_i,c_1,c_2]</code> is the
conditional probability that a symptomatic individual
<code>i</code> is in class <code>c_i</code> given that his parents are in classes
<code>c_1</code> and <code>c_2</code>, </p>
</dd>
<dt><code>p0connect</code></dt><dd><p> a vector of length <code>K</code>, where
<code>p0connect[c]</code> is the probability that a connector without
symptoms is in class <code>0</code>, 
given that one of his parents is in class <code>c&gt;=1</code> and the other in class 0, </p>
</dd>
<dt><code>p.found</code></dt><dd><p> the probability that a founder is symptomatic, </p>
</dd>
<dt><code>p.child</code></dt><dd><p> the probability that a child is symptomatic, </p>
</dd>
</dl>

<p>For models without familial dependence, all individuals are independent:
</p>

<dl>
<dt><code>p</code></dt><dd><p> a probability vector, each <code>p[c]</code> is the probability that an symptomatic individual is in class <code>c</code> for <code>c&gt;=1</code>, </p>
</dd>
<dt><code>p0</code></dt><dd><p> the probability that an individual without symptoms is in class 0, </p>
</dd>
<dt><code>p.aff</code></dt><dd><p> the probability that an individual is symptomatic, </p>
</dd>
</dl>

<p><code>param</code> is a list of measurement distribution parameters: the coefficients <code>alpha</code> (cumulative logistic coefficients see <code><a href="#topic+alpha.compute">alpha.compute</a></code>) in 
the case of discrete or ordinal data, and means <code>mu</code> and variances-covariances matrices <code>sigma</code> in the case of continuous data,
</p>
<p><code>optim.param</code> is a variable indicating how the measurement distribution parameter estimation of the M step is performed. Two possibilities, 
<code><a href="#topic+optim.noconst.ordi">optim.noconst.ordi</a></code> and <code><a href="#topic+optim.const.ordi">optim.const.ordi</a></code>, are now available in the case of discrete or ordinal measurements, and four possibilities 
<code><a href="#topic+optim.indep.norm">optim.indep.norm</a></code> (measurements are independent, diagonal variance-covariance matrix), 
<code><a href="#topic+optim.diff.norm">optim.diff.norm</a></code> (general variance-covariance matrix but equal for all classes), 
<code><a href="#topic+optim.equal.norm">optim.equal.norm</a></code> (variance-covariance matrices are different for each class but equal variance and equal covariance for a class) and  
<code><a href="#topic+optim.gene.norm">optim.gene.norm</a></code> (general variance-covariance matrices for all classes), are now available in the case of continuous measurements, 
One of the allowed values of <code>optim.param</code> must be entered without quotes. 
</p>
<p><code>optim.probs.indic</code> is a vector of logical values of length 4 for
models with familial dependence and 2 for models without familial
dependence.
</p>
<p>For models with familial dependence:
</p>

<dl>
<dt><code>optim.probs.indic[1]</code></dt><dd><p> indicates whether <code>p0</code> will be estimated or not, </p>
</dd>
<dt><code>optim.probs.indic[2]</code></dt><dd><p> indicates whether <code>p0connect</code> will be estimated or not, </p>
</dd>
<dt><code>optim.probs.indic[3]</code></dt><dd><p> indicates whether <code>p.found</code> will be estimated or not, </p>
</dd>
<dt><code>optim.probs.indic[4]</code></dt><dd><p> indicates whether <code>p.connect</code> will
be estimated or not. </p>
</dd>
</dl>
 
<p>For models without familial dependence:
</p>

<dl>
<dt><code>optim.probs.indic[1]</code></dt><dd><p> indicates whether <code>p0</code> will be estimated or not, </p>
</dd>
<dt><code>optim.probs.indic[2]</code></dt><dd><p> indicates whether <code>p.aff</code> will be
estimated or not. </p>
</dd>
</dl>

<p>All defaults are <code>TRUE</code>. If the dataset contains only nuclear families, there is no information to estimate p0connect and p.connect, and these parameters will not be estimated, irrespective of the indicator value.
</p>


<h3>Value</h3>

<p>The function returns a list of 4 elements:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p> the Maximum Likelihood Estimator (MLE) of the
measurement  distribution parameters if <code>fit=TRUE</code> or the input
<code>param</code> if <code>fit=FALSE</code>, </p>
</td></tr> 
<tr><td><code>probs</code></td>
<td>
<p> the MLE of probability parameters if <code>fit=TRUE</code> or the input <code>probs</code> if <code>fit=FALSE</code>, </p>
</td></tr>
</table>
<p>When measurements are available on all subjects, the probability parameters <code>p0</code> and <code>p0connect</code> are degenerated to 0 and 
<code>p.afound</code>, <code>p.child</code> and <code>p.aff</code> to 1 in the output. 
</p>
<table>
<tr><td><code>weight</code></td>
<td>
<p> an array of dimension <code>n</code> (the number of individuals) times 2 times <code>K+1</code> (<code>K</code> being the number of latent classes in the selected 
model and the <code>K+1</code>th class being the unaffected class) giving
the individual posterior probabilities. 
<code>weight[i,s,c]</code> is the
posterior probability  
that individual <code>i</code> belongs to class <code>c</code> when his symptom
status is <code>s</code>, where  
<code>s</code> takes two values: 1 for symptomatic and 2 for without
symptom. In particular, all <code>weight[,2,]</code> are 0 for symptomatic
individuals and all <code>weight[,1,]</code> are  
0 for individuals without symptoms. For missing individuals (unkown
symptom status), both <code>weight[,1,]</code> and <code>weight[,2,]</code> may be
greater than 0. </p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p> the maximum log-likelihood value (log-ML) if <code>fit=TRUE</code> or the log-likelihood computed with the input values of <code>param</code> 
and <code>probs</code> if <code>fit=FALSE</code>, </p>
</td></tr> 
</table>


<h3>References</h3>

<p> TAYEB, A. LABBE, A., BUREAU, A. and MERETTE, C. (2011) Solving Genetic Heterogeneity in Extended
Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 26(3): 539-560. DOI: 10.1007/s00180-010-0224-2, <br />
</p>
<p>LABBE, A., BUREAU, A. et MERETTE, C. (2009) Integration of Genetic Familial Dependence Structure in Latent Class Models. The International Journal of Biostatistics, 5(1): Article 6. </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.ordi)
fam &lt;- ped.ordi[,1]
#probs and param
data(param.ordi)
data(probs)
#the function applied only to two first families of ped.ordi
lca.model(ped.ordi[fam%in%1:2,],probs,param.ordi,optim.noconst.ordi,
          fit=TRUE,optim.probs.indic=c(TRUE,TRUE,TRUE,TRUE),tol=0.001,x=NULL,
          var.list=NULL,famdep=TRUE,modify.init=NULL)
</code></pre>

<hr>
<h2 id='model.select'> selects a latent class model for pedigree data </h2><span id='topic+model.select'></span>

<h3>Description</h3>

<p>Performs selection of a latent class model for phenotypic measurements
in pedigrees based on one of
two possible methods: likelihood-based cross-validation or Bayesian
Information Criterion (BIC) selection. This is the top-level
function to perform a Latent Class Analysis (LCA), which calls the
model fitting function
<code>lca.model</code>. Model selection is performed among models within one of two
types: with and without familial dependence. Two families of
distributions are currently implemented: product multinomial for discrete (or
ordinal) data and mutivariate 
normal for continuous data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.select(ped, distribution, trans.const = TRUE, optim.param,
             optim.probs.indic = c(TRUE, TRUE, TRUE, TRUE), 
             famdep = TRUE, selec = "bic", H = 5, K.vec = 1:7, 
             tol = 0.001, x = NULL, var.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.select_+3A_ped">ped</code></td>
<td>
<p> a matrix containing variables coding the pedigree
structure and the phenotype measurements: <code>ped[,1]</code> family ID, <code>ped[,2]</code> subjects ID, <code>ped[,3]</code> dad ID, 
<code>ped[,4]</code> mom ID, <code>ped[,5]</code> sex, <code>ped[,6]</code> symptom
status (2: symptomatic, 1: without symptoms, 0: missing), 
<code>ped[,7:ncol(ped)]</code> measurements, each column corresponds to a
phenotypic measurement. If the argument <code>distribution</code> is <code>"multinomial"</code>, then these columns must either be of type <code>integer</code> of <code>factor</code>, </p>
</td></tr>
<tr><td><code id="model.select_+3A_distribution">distribution</code></td>
<td>
<p> a character variable taking the value <code>"normal"</code> for multivariate normal measurements and <code>"multinomial"</code> for ordinal or discrete 
multinomial measurements, </p>
</td></tr>
<tr><td><code id="model.select_+3A_trans.const">trans.const</code></td>
<td>
<p> a logical variable indicating if the parental constraint is used. Parental constraint means that the class of a subject must be one 
of his parents classes. Default is <code>TRUE</code>, </p>
</td></tr>
<tr><td><code id="model.select_+3A_optim.param">optim.param</code></td>
<td>
<p> a variable indicating how the measurement distribution parameter optimization is performed (see below for more details), </p>
</td></tr>
<tr><td><code id="model.select_+3A_optim.probs.indic">optim.probs.indic</code></td>
<td>
<p> a vector of logical values indicating which probability parameters to estimate (see below for more details), </p>
</td></tr>
<tr><td><code id="model.select_+3A_famdep">famdep</code></td>
<td>
<p> a logical variable indicating if the familial dependence model is used or not. Default is <code>TRUE</code>. In models without familial dependence, individuals 
are treated as independent and pedigree structure is meaningless. In models with familial dependence, a child class depends in his parents classes via a 
triplet transition probability, </p>
</td></tr>
<tr><td><code id="model.select_+3A_selec">selec</code></td>
<td>
<p> a character variables taking the value <code>bic</code> if BIC selection is used and the value <code>cross</code> if cross-validation is used, </p>
</td></tr>
<tr><td><code id="model.select_+3A_h">H</code></td>
<td>
<p> an integer giving the number of equal parts into which data
will be splitted for the likelihood-based cross-validation model
selection (see below for more details), </p>
</td></tr>
<tr><td><code id="model.select_+3A_k.vec">K.vec</code></td>
<td>
<p> a vector of integers, the number of latent classes of
candidate models, if <code>K.vec</code> has one value, only models with that
number of classes will be fitted, </p>
</td></tr>
<tr><td><code id="model.select_+3A_tol">tol</code></td>
<td>
<p> a small number governing the stopping rule of the EM algorithm. Default is 0.001, </p>
</td></tr>
<tr><td><code id="model.select_+3A_x">x</code></td>
<td>
<p> a matrix of covariates (optional), default is <code>NULL</code>, </p>
</td></tr>
<tr><td><code id="model.select_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating the columns of
<code>x</code> containing the covariates to use for a given phenotypic measurement, default is <code>NULL</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of cross-validation based-likelihood method, data is
splitted into <code>H</code> parts: <code>H-1</code> parts as a training set and one part as a 
test set. For each model, a validation log-likelihood is obtained by
evaluating the log-likelihood of the test set data using the parameter
values estimated in the training set. This is repeated <code>H</code> times
using a different part as training set each time, and a total
validation log-likelihood is obtained by summation over the <code>H</code>
test sets. The best model is the one having the largest 
validation log-likelihood. In the case of BIC selection method, the
BIC is computed for each candidate model. The model with the smallest
BIC is selected.
</p>
<p>The symptom status vector (column 6 of <code>ped</code>) takes value 1 for
subjects that have been
examined and show no symptoms (i.e. completely unaffected
subjects). When applying the LCA to
measurements available on all subjects, the status vector must take the
value of 2 for every individual with measurements. If covariates are used, covariate values must be provided for subjects with symptom status 0 (missing) but not for subjects with symptom status 1 (if covariate values are provided, they will be ignored).
</p>
<p><code>optim.param</code> is a variable indicating how the measurement
distribution parameter optimization of the M step is performed. Two
possibilities, 
<code><a href="#topic+optim.noconst.ordi">optim.noconst.ordi</a></code> and <code><a href="#topic+optim.const.ordi">optim.const.ordi</a></code>, are now available in the case of discrete or ordinal measurements, and four possibilities, 
<code><a href="#topic+optim.indep.norm">optim.indep.norm</a></code> (measurements are independent, diagonal variance-covariance matrix), 
<code><a href="#topic+optim.diff.norm">optim.diff.norm</a></code> (general variance-covariance matrix but equal for all classes), 
<code><a href="#topic+optim.equal.norm">optim.equal.norm</a></code> (variance-covariance matrices are different for each class but equal variance and equal covariance for a class) and  
<code><a href="#topic+optim.gene.norm">optim.gene.norm</a></code> (general variance-covariance matrices for all classes), in the case of continuous measurements. 
One of the allowed values of <code>optim.param</code> must be entered without quotes.
</p>
<p><code>optim.probs.indic</code> is a vector of logical values of length 4 for
models with familial dependence and 2 for models without familial
dependence indicating which probability parameters to estimate. See the
help page for <code><a href="#topic+lca.model">lca.model</a></code> for a definition of the parameters. 
</p>
<p>For models with familial dependence:
</p>

<dl>
<dt><code>optim.probs.indic[1]</code></dt><dd><p> indicates whether <code>p0</code> will be estimated or not, </p>
</dd>
<dt><code>optim.probs.indic[2]</code></dt><dd><p> indicates whether <code>p0connect</code> will be estimated or not, </p>
</dd>
<dt><code>optim.probs.indic[3]</code></dt><dd><p> indicates whether <code>p.found</code> will be estimated or not, </p>
</dd>
<dt><code>optim.probs.indic[4]</code></dt><dd><p> indicates whether <code>p.connect</code> will
be estimated or not. </p>
</dd>
</dl>
 
<p>For models without familial dependence:
</p>

<dl>
<dt><code>optim.probs.indic[1]</code></dt><dd><p> indicates whether <code>p0</code> will be estimated or not, </p>
</dd>
<dt><code>optim.probs.indic[2]</code></dt><dd><p> indicates whether <code>p.aff</code> will be
estimated or not. </p>
</dd>
</dl>

<p>All defaults are <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>The function returns a list of 5 elements, the first 3 elements are common for BIC and cross-validation model selection methods and are:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p> the Maximum Likelihood Estimator (MLE) of the measurement distribution parameters of the selected model, </p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p> the Maximum Likelihood Estimator (MLE) of the probability parameters of the selected model, </p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p> an array of dimension <code>n</code> (the number of
individuals) times 2 times <code>K+1</code> (<code>K</code> being the number of latent classes in the selected 
model and the <code>K+1</code>th class being the unaffected class) giving
the individual posterior probabilities. <code>weight[i,s,c]</code> is the
posterior probability  
that individual <code>i</code> belongs to class <code>c</code> when his affection
status is <code>s</code>, where  
<code>s</code> takes two values: 1 for symptomatic and 2 for without
symptom. In particular, all <code>weight[,2,]</code> are 0 for symptomatic
individuals and all <code>weight[,1,]</code> are  
0 for individuals without symptoms. For missing individuals (unkown
symptom status), both <code>weight[,1,]</code> and <code>weight[,2,]</code> may be
greater than 0. </p>
</td></tr>
</table>
<p>If the cross-validation selection method is used, the function returns also 
</p>
<table>
<tr><td><code>ll</code></td>
<td>
<p> the value of the maximum log-likelihood (log-ML) of the selected model, </p>
</td></tr>
<tr><td><code>ll.valid</code></td>
<td>
<p>  the total cross-validation log-likelihood of all candidate models, </p>
</td></tr>
</table>
<p>and if the Bayesian Information Criterion selection method is used, the function returns also 
</p>
<table>
<tr><td><code>ll</code></td>
<td>
<p> the value of maximum log-likelihood (log-ML) of all candidate models, </p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p> the Bayesian Information Criterion
<code>BIC=-2*log(ll)+m*log(n)</code> of all candidate models, where <code>m</code> is the number of free parameters of 
the model and <code>n</code> the total number of individuals. </p>
</td></tr>
</table>


<h3>References</h3>

<p> TAYEB, A. LABBE, A., BUREAU, A. and MERETTE, C. (2011) Solving Genetic Heterogeneity in Extended
Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 26(3): 539-560. DOI: 10.1007/s00180-010-0224-2, <br />
</p>
<p>LABBE, A., BUREAU, A. et MERETTE, C. (2009) Integration of Genetic Familial Dependence Structure in Latent Class Models. The International Journal of Biostatistics, 5(1): Article 6. </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+lca.model">lca.model</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
fam &lt;- ped.cont[,1]
#the function applied for the two first families of ped.cont
model.select(ped.cont[fam%in%1:2,],distribution="normal",trans.const=TRUE,
             optim.indep.norm,optim.probs.indic=c(TRUE,TRUE,TRUE,TRUE),
             famdep=TRUE,selec="bic",K.vec=1:3,tol=0.001,x=NULL,var.list=NULL)
</code></pre>

<hr>
<h2 id='n.param'> computes the number of parameters of a model </h2><span id='topic+n.param'></span>

<h3>Description</h3>

<p>computes the number of free parameters of a model, depending in the number of classes, the type of parameter optimization and the used of 
familial dependence, to be used in BIC model selection. This is an internal function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.param(y, K, trans.const = TRUE, optim.param, 
        optim.probs.indic = c(TRUE, TRUE, TRUE, TRUE), famdep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.param_+3A_y">y</code></td>
<td>
<p> a matrix of measurements, </p>
</td></tr>
<tr><td><code id="n.param_+3A_k">K</code></td>
<td>
<p> an integer, the number of latent classes of a candiate model, </p>
</td></tr>
<tr><td><code id="n.param_+3A_trans.const">trans.const</code></td>
<td>
<p> a logical variable indicating if the parental constraint is used. Parental constraint means that the class of a subject can be only one 
of his parents classes. Default is <code>TRUE</code>, </p>
</td></tr>
<tr><td><code id="n.param_+3A_optim.param">optim.param</code></td>
<td>
<p> a function used for parameter optimization, see <code><a href="#topic+lca.model">lca.model</a></code> for more details, </p>
</td></tr>
<tr><td><code id="n.param_+3A_optim.probs.indic">optim.probs.indic</code></td>
<td>
<p> a vector of logical values indicating which probability parameters to be updated, see <code><a href="#topic+lca.model">lca.model</a></code> for more details, </p>
</td></tr>
<tr><td><code id="n.param_+3A_famdep">famdep</code></td>
<td>
<p> a logical variable indicating if familial dependence model is used or not. Default is <code>TRUE</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the number of free parameters (of the measurement
distribution and the probabilities of the latent classes).
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+model.select">model.select</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ped.cont)
y &lt;- ped.cont[,7:ncol(ped.cont)]
n.param(y,K=3,trans.const=TRUE,optim.indep.norm, 
        optim.probs.indic=c(TRUE,TRUE,TRUE,TRUE),famdep=TRUE)
</code></pre>

<hr>
<h2 id='optim.const.ordi'> performs the M step for the measurement distribution parameters
in multinomial case, with an ordinal constraint on the parameters </h2><span id='topic+optim.const.ordi'></span>

<h3>Description</h3>

<p>Estimates the cumulative logistic coefficients <code>alpha</code> in the
case of multinomial (or ordinal) data with an ordinal constraint on
the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.const.ordi(y, status, weight, param, x = NULL, var.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.const.ordi_+3A_y">y</code></td>
<td>
<p> a matrix of discrete (or ordinal) measurements (only for symptomatic subjects), </p>
</td></tr>
<tr><td><code id="optim.const.ordi_+3A_status">status</code></td>
<td>
<p> symptom status of all individuals, </p>
</td></tr>
<tr><td><code id="optim.const.ordi_+3A_weight">weight</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K</code> of individual weights, where <code>n</code> is the number of individuals and <code>K</code> is 
the total number of latent classes in the model, </p>
</td></tr>
<tr><td><code id="optim.const.ordi_+3A_param">param</code></td>
<td>
<p> a list of measurement density parameters, here is a list of <code>alpha</code>, </p>
</td></tr>
<tr><td><code id="optim.const.ordi_+3A_x">x</code></td>
<td>
<p> a matrix of covariates (optional). Default id <code>NULL</code>, </p>
</td></tr>
<tr><td><code id="optim.const.ordi_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating which covariates (taken from <code>x</code>) are used for a given type of measurement </p>
</td></tr>
</table>


<h3>Details</h3>

<p>the constraint on the parameters is that, for a symptom <code>j</code>, the rows <code>alpha[[j]][k,]</code> are equal for all classes <code>k</code> except the first values. 
Therefore, maximum likelihood estimators are not explicit and the
function <code>lrm</code> of the package <code>rms</code> is used to perform a
numerical optimization.
</p>


<h3>Value</h3>

<p>The function returns a list of estimated parameters <code>param</code> satisfying the constraint.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.ordi)
status &lt;- ped.ordi[,6]
y &lt;- ped.ordi[,7:ncol(ped.ordi)]
data(peel)
#probs and param
data(probs)
data(param.ordi)
#e step
weight &lt;- e.step(ped.ordi,probs,param.ordi,dens.prod.ordi,peel,x=NULL,
                 var.list=NULL,famdep=TRUE)$w
weight &lt;- matrix(weight[,1,1:length(probs$p)],nrow=nrow(ped.ordi),
                 ncol=length(probs$p))
#the function
optim.const.ordi(y[status==2,],status,weight,param.ordi,x=NULL,
                 var.list=NULL)
</code></pre>

<hr>
<h2 id='optim.diff.norm'> performs the M step for measurement density parameters in multinormal case </h2><span id='topic+optim.diff.norm'></span>

<h3>Description</h3>

<p>Estimates the mean
<code>mu</code> and parameters of the variance-covariance matrix
<code>sigma</code> of a multinormal distribution for the measurements with
a general variance-covariance matrix identical for all classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.diff.norm(y, status, weight, param, x = NULL, var.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.diff.norm_+3A_y">y</code></td>
<td>
<p> a matrix of continuous measurements (only for symptomatic subjects), </p>
</td></tr>
<tr><td><code id="optim.diff.norm_+3A_status">status</code></td>
<td>
<p> symptom status of all individuals, </p>
</td></tr>
<tr><td><code id="optim.diff.norm_+3A_weight">weight</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K</code> of individual weights, where <code>n</code> is the number of individuals and <code>K</code> is 
the total number of latent classes in the model, </p>
</td></tr>
<tr><td><code id="optim.diff.norm_+3A_param">param</code></td>
<td>
<p> a list of measurement density parameters, here is a list of <code>mu</code> and <code>sigma</code>, </p>
</td></tr>
<tr><td><code id="optim.diff.norm_+3A_x">x</code></td>
<td>
<p> a matrix of covariates (optional). Default id <code>NULL</code>, </p>
</td></tr>
<tr><td><code id="optim.diff.norm_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating which covariates (taken from <code>x</code>) are used for a given type of measurement. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of explicit estimators are computed for both <code>mu</code> and
<code>sigma</code>. The variance-covariance matrices <code>sigma</code> are
identical  for all classes. Treatment of covariates is not yet implemented, and any
provided covariate value will be ignored.
</p>


<h3>Value</h3>

<p>The function returns a list of estimated parameters <code>param</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
status &lt;- ped.cont[,6]
y &lt;- ped.cont[,7:ncol(ped.cont)]
data(peel)
#probs and param
data(probs)
data(param.cont)
#e step
weight &lt;- e.step(ped.cont,probs,param.cont,dens.norm,peel,x=NULL,
                 var.list=NULL,famdep=TRUE)$w
weight &lt;- matrix(weight[,1,1:length(probs$p)],nrow=nrow(ped.cont),
                 ncol=length(probs$p))
#the function
optim.diff.norm(y[status==2,],status,weight,param.cont,x=NULL,
                 var.list=NULL)
</code></pre>

<hr>
<h2 id='optim.equal.norm'> performs the M step for measurement density parameters in multinormal case </h2><span id='topic+optim.equal.norm'></span>

<h3>Description</h3>

<p>Estimates the mean
<code>mu</code> and parameters of the variance-covariance matrix
<code>sigma</code> of a multinormal distribution for the measurements
with equal variance for all measurements and equal covariance between
all pairs of measurements within each class. The variance and
covariance parameters are however distinct for each class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.equal.norm(y, status, weight, param, x = NULL, var.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.equal.norm_+3A_y">y</code></td>
<td>
<p> a matrix of continuous measurements (only for symptomatic subjects), </p>
</td></tr>
<tr><td><code id="optim.equal.norm_+3A_status">status</code></td>
<td>
<p> symptom status of all individuals, </p>
</td></tr>
<tr><td><code id="optim.equal.norm_+3A_weight">weight</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K</code> of individual weights, where <code>n</code> is the number of individuals and <code>K</code> is 
the total number of latent classes in the model, </p>
</td></tr>
<tr><td><code id="optim.equal.norm_+3A_param">param</code></td>
<td>
<p> a list of measurement density parameters, here is a list of <code>mu</code> and <code>sigma</code>, </p>
</td></tr>
<tr><td><code id="optim.equal.norm_+3A_x">x</code></td>
<td>
<p> a matrix of covariates (optional). Default id <code>NULL</code>, </p>
</td></tr>
<tr><td><code id="optim.equal.norm_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating which covariates (taken from <code>x</code>) are used for a given type of measurement. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of explicit estimators are computed for both <code>mu</code> and
<code>sigma</code>. The variance-covariance matrices <code>sigma</code> are
distinct for each class. Treatment of covariates is not yet implemented, and any
provided covariate value will be ignored.
</p>


<h3>Value</h3>

<p>The function returns a list of estimated parameters <code>param</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
status &lt;- ped.cont[,6]
y &lt;- ped.cont[,7:ncol(ped.cont)]
data(peel)
#probs and param
data(probs)
data(param.cont)
#e step
weight &lt;- e.step(ped.cont,probs,param.cont,dens.norm,peel,x=NULL,
                 var.list=NULL,famdep=TRUE)$w
weight &lt;- matrix(weight[,1,1:length(probs$p)],nrow=nrow(ped.cont),
                 ncol=length(probs$p))
#the function
optim.equal.norm(y[status==2,],status,weight,param.cont,x=NULL,
                 var.list=NULL)
</code></pre>

<hr>
<h2 id='optim.gene.norm'> performs the M step for measurement density parameters in multinormal case </h2><span id='topic+optim.gene.norm'></span>

<h3>Description</h3>

<p>Estimates the mean
<code>mu</code> and parameters of the variance-covariance matrix
<code>sigma</code> of a multinormal distribution for the measurements with 
general variance-covariance matrices distinct for each class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.gene.norm(y, status, weight, param, x = NULL, var.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.gene.norm_+3A_y">y</code></td>
<td>
<p> a matrix of continuous measurements (only for symptomatic subjects), </p>
</td></tr>
<tr><td><code id="optim.gene.norm_+3A_status">status</code></td>
<td>
<p> symptom status of all individuals, </p>
</td></tr>
<tr><td><code id="optim.gene.norm_+3A_weight">weight</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K</code> of individual weights, where <code>n</code> is the number of individuals and <code>K</code> is 
the total number of latent classes in the model, </p>
</td></tr>
<tr><td><code id="optim.gene.norm_+3A_param">param</code></td>
<td>
<p> a list of measurement density parameters, here is a list of <code>mu</code> and <code>sigma</code>, </p>
</td></tr>
<tr><td><code id="optim.gene.norm_+3A_x">x</code></td>
<td>
<p> a matrix of covariates (optional). Default id <code>NULL</code>, </p>
</td></tr>
<tr><td><code id="optim.gene.norm_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating which covariates (taken from <code>x</code>) are used for a given type of measurement. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of explicit estimators are computed for both <code>mu</code> and
<code>sigma</code>. This is the general case, the variance-covariance 
matrices <code>sigma</code> of the different classes are distinct and
unconstrained. Treatment of covariates is not yet implemented, and any
provided covariate value will be ignored.
</p>


<h3>Value</h3>

<p>The function returns a list of estimated parameters <code>param</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
status &lt;- ped.cont[,6]
y &lt;- ped.cont[,7:ncol(ped.cont)]
data(peel)
#probs and param
data(probs)
data(param.cont)
#e step
weight &lt;- e.step(ped.cont,probs,param.cont,dens.norm,peel,x=NULL,
                 var.list=NULL,famdep=TRUE)$w
weight &lt;- matrix(weight[,1,1:length(probs$p)],nrow=nrow(ped.cont),
                 ncol=length(probs$p))
#the function
optim.gene.norm(y[status==2,],status,weight,param.cont,x=NULL,
                 var.list=NULL)
</code></pre>

<hr>
<h2 id='optim.indep.norm'> performs the M step for measurement density parameters in multinormal case </h2><span id='topic+optim.indep.norm'></span>

<h3>Description</h3>

<p>Estimates the mean
<code>mu</code> and parameters of the variance-covariance matrix
<code>sigma</code> of a multinormal distribution for the measurements with 
diagonal variance-covariance matrices for each class, i.e. measurements are supposed independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.indep.norm(y, status, weight, param, x = NULL, var.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.indep.norm_+3A_y">y</code></td>
<td>
<p> a matrix of continuous measurements (only for symptomatic subjects), </p>
</td></tr>
<tr><td><code id="optim.indep.norm_+3A_status">status</code></td>
<td>
<p> symptom status of all individuals, </p>
</td></tr>
<tr><td><code id="optim.indep.norm_+3A_weight">weight</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K</code> of individual weights, where <code>n</code> is the number of individuals and <code>K</code> is 
the total number of latent classes in the model, </p>
</td></tr>
<tr><td><code id="optim.indep.norm_+3A_param">param</code></td>
<td>
<p> a list of measurement density parameters, here is a list of <code>mu</code> and <code>sigma</code>, </p>
</td></tr>
<tr><td><code id="optim.indep.norm_+3A_x">x</code></td>
<td>
<p> a matrix of covariates (optional). Default id <code>NULL</code>, </p>
</td></tr>
<tr><td><code id="optim.indep.norm_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating which covariates (taken from <code>x</code>) are used for a given type of measurement. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of explicit estimators are computed for both <code>mu</code> and
<code>sigma</code>. All variance-covariance matrices <code>sigma</code> are
diagonal, i.e.  measurements are supposed independent. Treatment of
covariates is not yet implemented, and any 
provided covariate value will be ignored.
</p>


<h3>Value</h3>

<p>The function returns a list of estimated parameters <code>param</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
status &lt;- ped.cont[,6]
y &lt;- ped.cont[,7:ncol(ped.cont)]
data(peel)
#probs and param
data(probs)
data(param.cont)
#e step
weight &lt;- e.step(ped.cont,probs,param.cont,dens.norm,peel,x=NULL,
                 var.list=NULL,famdep=TRUE)$w
weight &lt;- matrix(weight[,1,1:length(probs$p)],nrow=nrow(ped.cont),
                 ncol=length(probs$p))
#the function
optim.indep.norm(y[status==2,],status,weight,param.cont,x=NULL,
                 var.list=NULL)
</code></pre>

<hr>
<h2 id='optim.noconst.ordi'> performs the M step for the measurement distribution parameters in multinomial case without constraint on the parameters </h2><span id='topic+optim.noconst.ordi'></span>

<h3>Description</h3>

<p>Estimates the cumulative logistic coefficients <code>alpha</code> in the case of multinomial (or ordinal) data without constraint on the coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.noconst.ordi(y, status, weight, param, x = NULL, var.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.noconst.ordi_+3A_y">y</code></td>
<td>
<p> a matrix of discrete (or ordinal) measurements (only for symptomatic subjects), </p>
</td></tr>
<tr><td><code id="optim.noconst.ordi_+3A_status">status</code></td>
<td>
<p> symptom status of all individuals, </p>
</td></tr>
<tr><td><code id="optim.noconst.ordi_+3A_weight">weight</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K</code> of individual weights, where <code>n</code> is the number of individuals and <code>K</code> is 
the total number of latent classes in the model, </p>
</td></tr>
<tr><td><code id="optim.noconst.ordi_+3A_param">param</code></td>
<td>
<p> a list of measurement distribution parameters, here is a list <code>alpha</code> of cumulative logistic coefficients, </p>
</td></tr>
<tr><td><code id="optim.noconst.ordi_+3A_x">x</code></td>
<td>
<p> a matrix of covariates (optional). Default is <code>NULL</code>, </p>
</td></tr>
<tr><td><code id="optim.noconst.ordi_+3A_var.list">var.list</code></td>
<td>
<p> a list of integers indicating which covariates (taken from <code>x</code>) are used for a given type of measurment. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of explicit estimators are computed by logistic
transformation of weighted empirical frequencies.
</p>


<h3>Value</h3>

<p>the function returns a list of estimated parameters <code>param</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.ordi)
status &lt;- ped.ordi[,6]
y &lt;- ped.ordi[,7:ncol(ped.ordi)]
data(peel)
#probs and param
data(probs)
data(param.ordi)
#e step
weight &lt;- e.step(ped.ordi,probs,param.ordi,dens.prod.ordi,peel,x=NULL,
                 var.list=NULL,famdep=TRUE)$w
weight &lt;- matrix(weight[,1,1:length(probs$p)],nrow=nrow(ped.ordi),
                 ncol=length(probs$p))
#the function
optim.noconst.ordi(y[status==2,],status,weight,param.ordi,x=NULL,
                   var.list=NULL)
</code></pre>

<hr>
<h2 id='optim.probs'> performs the M step of the EM algorithm for the probability parameters </h2><span id='topic+optim.probs'></span>

<h3>Description</h3>

<p>estimates the probability parameters (<code>p</code>, <code>p.trans</code>, <code>p0</code>,...) in the M step of the EM algorithm in both cases 
with and without familial dependence. This is an internal
function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.probs(ped, probs, optim.probs.indic = c(TRUE, TRUE, TRUE, TRUE), 
            res.weight, famdep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.probs_+3A_ped">ped</code></td>
<td>
<p> a matrix of pedigrees data, see <code><a href="#topic+e.step">e.step</a></code> for more details, </p>
</td></tr>
<tr><td><code id="optim.probs_+3A_probs">probs</code></td>
<td>
<p> all probability parameters to be optimized, </p>
</td></tr>
<tr><td><code id="optim.probs_+3A_optim.probs.indic">optim.probs.indic</code></td>
<td>
<p> a vector of logical values indicating which probability parameters to be updated, </p>
</td></tr>
<tr><td><code id="optim.probs_+3A_res.weight">res.weight</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K</code>, individual weights, where <code>n</code> is the number of individuals and <code>K</code> is 
the total number of latent classes in the model, resulting from the E step of the EM algorithm (see <code><a href="#topic+e.step">e.step</a></code>)</p>
</td></tr>
<tr><td><code id="optim.probs_+3A_famdep">famdep</code></td>
<td>
<p> a logical variable indicating if familial dependence model is used or not. Default is <code>TRUE</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>explicit estimators are computed in function of the weights.
</p>


<h3>Value</h3>

<p>the function returns the estimated <code>probs</code> of all probability parameters.
</p>


<h3>References</h3>

<p> TAYEB et al.: Solving Genetic Heterogeneity in Extended Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 2011, DOI: 10.1007/s00180-010-0224-2. </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
data(peel)
#probs and param
data(probs)
data(param.cont)
#e step
weight &lt;- e.step(ped.cont,probs,param.cont,dens.norm,peel,x=NULL,
                 var.list=NULL,famdep=TRUE)
#the function
optim.probs(ped.cont,probs,weight,optim.probs.indic=
            c(TRUE,TRUE,TRUE,TRUE),famdep=TRUE)
</code></pre>

<hr>
<h2 id='p.compute'> computes the probability vector using logistic coefficients</h2><span id='topic+p.compute'></span>

<h3>Description</h3>

<p>computes the probability vector using cumulative logistic coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.compute(alpha,decal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p.compute_+3A_alpha">alpha</code></td>
<td>
<p> a vector of cumulative logistic coefficients, the first value can
be <code>-Inf</code>, followed by, eventually, only one negative value, 
then only positive values. It can end by <code>Inf</code> values.</p>
</td></tr>
<tr><td><code id="p.compute_+3A_decal">decal</code></td>
<td>
<p> offset term to be applied to sums of logistic coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>alpha</code> has <code>S-1</code> values, <code>p.compute</code> returns <code>p</code> of length <code>S</code>. If <code>Y</code> is a random variable taking values in <code>{1,...,S}</code> with 
probabilities <code>p</code>, coefficients <code>alpha[i]</code> are given by:
</p>
<p style="text-align: center;"><code class="reqn"> p_1+...+p_i=P(Y\leq i)=\frac{\exp(\alpha_1+...+\alpha_i)}{(1+\exp(\alpha_1+...+\alpha_i)} </code>
</p>

<p>for all <code>i&lt;=S-1</code>.
</p>


<h3>Value</h3>

<p><code>p</code>:  a probability vector 
</p>


<h3>See Also</h3>

 <p><code>p.compute</code> is the inverse function of <code><a href="#topic+alpha.compute">alpha.compute</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># a vector of probability
p &lt;- c(0,0.2,0,0,0.3,0.4,0.1,0,0)
alpha &lt;- alpha.compute(p)
#gives alpha= -Inf -1.38 0 0 1.38 0 2.19 Inf Inf
p.compute(alpha) #gives p
</code></pre>

<hr>
<h2 id='p.post.child'> computes the posterior probability of observations of a child </h2><span id='topic+p.post.child'></span>

<h3>Description</h3>

<p>computes the posterior probability of measurements of a child for each
class and each symptom status of the subject given the classes of both
of his parents. This is an internal function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.post.child(child, c.connect, c.spouse, status, probs, fyc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p.post.child_+3A_child">child</code></td>
<td>
<p> a child in the pedigree, </p>
</td></tr>
<tr><td><code id="p.post.child_+3A_c.connect">c.connect</code></td>
<td>
<p> the class of one parent (who is a connector) of the child, </p>
</td></tr>
<tr><td><code id="p.post.child_+3A_c.spouse">c.spouse</code></td>
<td>
<p> the class of the other parent of the child, </p>
</td></tr>
<tr><td><code id="p.post.child_+3A_status">status</code></td>
<td>
<p> the symptom status vector of the whole pedigree, </p>
</td></tr>
<tr><td><code id="p.post.child_+3A_probs">probs</code></td>
<td>
<p> a list of all probability parameters of the model, </p>
</td></tr>
<tr><td><code id="p.post.child_+3A_fyc">fyc</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K+1</code> giving the density of measurements of each individual if allocated to class <code>k</code>, where <code>n</code> is 
the number of individuals and <code>K</code> is the total number of latent classes in the model, </p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns <code>p.child</code> a matrix of 2 times <code>K+1</code> entries such that <code>p.child[s,k]</code> is the posterior probability of the measurements <code>Y_child</code> 
under status <code>S_child=s</code> and when he is assigned to class <code>k</code> and his parents are assigned to classes <code>c.connect</code> and <code>c.spouse</code>.
</p>


<h3>References</h3>

<p> TAYEB et al.: Solving Genetic Heterogeneity in Extended
Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 2011, DOI: 10.1007/s00180-010-0224-2. </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
fam &lt;- ped.cont[,1]
dad &lt;- ped.cont[fam==1,3]
status &lt;- ped.cont[fam==1,6]
y &lt;- ped.cont[fam==1,7:ncol(ped.cont)]
#a child
child &lt;- which(dad!=0)[1]
data(probs)
data(param.cont)
#densities of the observations
fyc &lt;- matrix(1,nrow=nrow(y),ncol=length(probs$p)+1)
fyc[status==2,1:length(probs$p)] &lt;- t(apply(y[status==2,],1,dens.norm,
                                            param.cont,NULL))
#the function
p.post.child(child,c.connect=1,c.spouse=3,status,probs,fyc)
</code></pre>

<hr>
<h2 id='p.post.found'> computes the posterior probability of observations of a founder </h2><span id='topic+p.post.found'></span>

<h3>Description</h3>

<p>computes the posterior probability of measurements of a founder for each class and each symptom status of the founder. This is an internal function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.post.found(found, status, probs, fyc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p.post.found_+3A_found">found</code></td>
<td>
<p> a founder in the pedigree (individual without parents in the pedigree), </p>
</td></tr>
<tr><td><code id="p.post.found_+3A_status">status</code></td>
<td>
<p> the symptom status vector of the whole pedigree,</p>
</td></tr>
<tr><td><code id="p.post.found_+3A_probs">probs</code></td>
<td>
<p> a list of all probability parameters of the model, </p>
</td></tr>
<tr><td><code id="p.post.found_+3A_fyc">fyc</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K+1</code> given the density of measurements of each individual if allocated to class <code>k</code>, where <code>n</code> is 
the number of individuals and <code>K</code> is the total number of latent classes in the model, </p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns <code>p.found</code> a matrix of 2 times <code>K+1</code> entries: <code>p.found[s,k]</code> is the posterior probability of the observations <code>Y_found</code> 
under status <code>S_found=s</code> and when he is assigned to class <code>k</code>.
</p>


<h3>References</h3>

<p> TAYEB et al.: Solving Genetic Heterogeneity in Extended
Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 2001, DOI: 10.1007/s00180-010-0224-2. </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
fam &lt;- ped.cont[,1]
dad &lt;- ped.cont[fam==1,3]
status &lt;- ped.cont[fam==1,6]
y &lt;- ped.cont[fam==1,7:ncol(ped.cont)]
#a founder
found &lt;- which(dad==0)[1]
data(probs)
data(param.cont)
#densities of the observations
fyc &lt;- matrix(1,nrow=nrow(y),ncol=length(probs$p)+1)
fyc[status==2,1:length(probs$p)] &lt;- t(apply(y[status==2,],1,dens.norm,
                                            param.cont,NULL))
#the function
p.post.found(found,status,probs,fyc)
</code></pre>

<hr>
<h2 id='param.cont'> parameters to be used for examples in the case of continuous measurements </h2><span id='topic+param.cont'></span>

<h3>Description</h3>

<p>means and variance-covariance matrices for each class to be used in examples with continuous measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(param.cont)</code></pre>


<h3>Details</h3>

<p><code>ped.param</code> is a list of 2 elements:
</p>

<dl>
<dt><code>mu</code></dt><dd><p> a list of <code>K=3</code> (the number of latent classes) entries, each represents the means of the measurement multinormal density in the class, </p>
</dd>
<dt><code>sigma</code></dt><dd><p> a list of <code>K=3</code> entries, each is the
variance-covariance matrix of the measurement multinormal density in the class. </p>
</dd></dl>

<p>The dimension (the number of multinormal measurements) used in the dataset is 4.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+init.norm">init.norm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(param.cont)
</code></pre>

<hr>
<h2 id='param.ordi'> parameters to be used for examples in the case of discrete or ordinal measurements </h2><span id='topic+param.ordi'></span>

<h3>Description</h3>

<p>list of cumulative logistic coefficients for each measurement and each class to be used in examples for discrete or ordinal models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(param.ordi)</code></pre>


<h3>Details</h3>

<p><code>ped.param</code> is a list of 1 element:
<code>alpha</code> a list of <code>d=4</code> (the number of measurements) entries, each is a matrix of <code>K=3</code> (the number of classes) times <code>S[j]</code> 
(the number of possible values of measurement <code>j</code>), a row <code>alpha[[j]][k,]</code> contains the logistic coefficients of the measurement <code>j</code> for class <code>k</code>. 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+init.ordi">init.ordi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(param.ordi)
</code></pre>

<hr>
<h2 id='ped.cont'> pedigrees with continuous data to be used for examples </h2><span id='topic+ped.cont'></span>

<h3>Description</h3>

<p>data set of 48 pedigrees: a matrix of pedigrees data with continuous observations to be used for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ped.cont)</code></pre>


<h3>Details</h3>

<p><code>ped</code> is a matrix of 10 columns:
<code>ped[,1]</code> family ID, 
<code>ped[,2]</code> subject ID, 
<code>ped[,3]</code> father ID, 0 for founders (i.e. subjects having no parents in the pedigree),
<code>ped[,4]</code> mother ID, 0 for founders (i.e. subjects having no parents in the pedigree), 
<code>ped[,5]</code> subject sex: 1 male, 2 female, 
<code>ped[,6]</code> symptom status (2: symptomatic, 1: without symptoms, 0: missing), 
<code>ped[,7:10]</code> continuous observations, <code>NA</code> for
missing and without symptoms, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ped.cont)
</code></pre>

<hr>
<h2 id='ped.ordi'> pedigrees with discrete or ordinal data to be used for examples </h2><span id='topic+ped.ordi'></span>

<h3>Description</h3>

<p>data set of 48 pedigrees: a matrix of pedigrees data with discrete or ordinal observations to be used for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ped.ordi)</code></pre>


<h3>Details</h3>

<p><code>ped</code> is a matrix of 10 columns:
<code>ped[,1]</code> family ID, 
<code>ped[,2]</code> subject ID, 
<code>ped[,3]</code> father ID, 0 for founders (i.e. subjects having no parents in the pedigree),
<code>ped[,4]</code> mother ID, 0 for founders (i.e. subjects having no parents in the pedigree), 
<code>ped[,5]</code> subject sex: 1 male, 2 female, 
<code>ped[,6]</code> symptom status (2: symptomatic, 1: without symptoms, 0: missing),  
<code>ped[,7:10]</code> discrete or ordinal observations,
<code>NA</code> for missing and without symptoms,  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ped.ordi)
</code></pre>

<hr>
<h2 id='peel'> peeling order of pedigrees and couples in pedigrees </h2><span id='topic+peel'></span>

<h3>Description</h3>

<p><code>peel</code> is a list of 48 entries, each gives the peeling order of the pedigrees and lists the couples in the 48 pedigrees of <code>ped.cont</code> and <code>peed.ordi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(peel)</code></pre>


<h3>Value</h3>

<p>For a pedigree <code>f</code> in the data <code>ped.cont</code> or <code>ped.ordi</code>,
<code>peel[[f]]</code> is a list of three entries:
</p>

<dl>
<dt><code>generation</code></dt><dd><p> the number of generations in the pedigree, </p>
</dd>
<dt><code>peel.connect</code></dt><dd><p> a matrix of <code>generation</code> rows, each giving the connectors of the generation in the order of peeling, </p>
</dd>
<dt><code>couple</code></dt><dd><p> a matrix of two columns, giving the couples in the pedigree. </p>
</dd>
</dl>



<h3>See Also</h3>

<p>See also <code><a href="#topic+ped.cont">ped.cont</a></code> and <code><a href="#topic+ped.ordi">ped.ordi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(peel)
</code></pre>

<hr>
<h2 id='probs'> probabilities parameters to be used for examples </h2><span id='topic+probs'></span>

<h3>Description</h3>

<p>a list of probability parameters such as the probability that a
founder is assigned to each class, the transition probabilities and the probability that a child is symptomatic. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(probs)</code></pre>


<h3>Details</h3>

<p><code>probs </code> a list of probability parameters: 
</p>
<p>For models with familial dependence:
</p>

<dl>
<dt><code>p</code></dt><dd><p> a probability vector, each <code>p[c]</code> is the probability that an symptomatic founder is in class  <code>c</code> for <code>c&gt;=1</code>, </p>
</dd>
<dt><code>p0</code></dt><dd><p> the probability that a founder without symptoms is in class 0, </p>
</dd>
<dt><code>p.trans</code></dt><dd><p> an array of dimension <code>K</code> times <code>K+1</code>
times <code>K+1</code>, where <code>K</code> is the number of latent classes of
the model, and is such that <code>p.trans[c_i,c_1,c_2]</code> is the
conditional probability that a symptomatic individual
<code>i</code> is in class <code>c_i</code> given that his parents are in classes
<code>c_1</code> and <code>c_2</code>, </p>
</dd>
<dt><code>p0connect</code></dt><dd><p> a vector of length <code>K</code>, where
<code>p0connect[c]</code> is the probability that a connector without
symptoms is in class <code>0</code>, 
given that one of his parents is in class <code>c&gt;=1</code> and the other in class 0, </p>
</dd>
<dt><code>p.found</code></dt><dd><p> the probability that a founder is symptomatic, </p>
</dd>
<dt><code>p.child</code></dt><dd><p> the probability that a child is symptomatic, </p>
</dd>
</dl>

<p>For models without familial dependence, all individuals are independent:
</p>

<dl>
<dt><code>p</code></dt><dd><p> a probability vector, each <code>p[c]</code> is the probability that an symptomatic individual is in class <code>c</code> for <code>c&gt;=1</code>, </p>
</dd>
<dt><code>p0</code></dt><dd><p> the probability that an individual without symptoms is in class 0, </p>
</dd>
<dt><code>p.aff</code></dt><dd><p> the probability that an individual is symptomatic, </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(probs)
</code></pre>

<hr>
<h2 id='upward'> performs the upward step of the peeling algorithm of a pedigree </h2><span id='topic+upward'></span>

<h3>Description</h3>

<p>computes the probability of observations below connectors
conditionally to their classes given the model parameters. This is an internal
function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upward(id, dad, mom, status, probs, fyc, peel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upward_+3A_id">id</code></td>
<td>
<p> individual ID of the pedigree, </p>
</td></tr>
<tr><td><code id="upward_+3A_dad">dad</code></td>
<td>
<p> dad ID, </p>
</td></tr>
<tr><td><code id="upward_+3A_mom">mom</code></td>
<td>
<p> mom ID, </p>
</td></tr>
<tr><td><code id="upward_+3A_status">status</code></td>
<td>
<p> symptom status: (2: symptomatic, 1: without symptoms, 0: missing), </p>
</td></tr>
<tr><td><code id="upward_+3A_probs">probs</code></td>
<td>
<p> a list of probability parameters of the model, </p>
</td></tr>
<tr><td><code id="upward_+3A_fyc">fyc</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K+1</code> given the density of observations of each individual if allocated to class <code>k</code>, where <code>n</code> is the 
number of individuals and <code>K</code> is the total number of latent classes in the model, </p>
</td></tr>
<tr><td><code id="upward_+3A_peel">peel</code></td>
<td>
<p> a list of pedigree peeling result containing connectors by peeling order and couples of parents. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the probability of observations below connectors conditionally to their classes using the function <code><a href="#topic+upward.connect">upward.connect</a></code>
</p>


<h3>Value</h3>

<p>The function returns a list of 2 elements:
</p>
<table>
<tr><td><code>sum.child</code></td>
<td>
<p>an array of dimension <code>n</code> times <code>K+1</code> times <code>K+1</code> such that <code>sum.child[i,c_1,c_2]</code> is the probability of 
individual <code>i</code> measurements when his parent are assigned to classes <code>c_1</code> and <code>c_2</code>, </p>
</td></tr>
<tr><td><code>p.yF.c</code></td>
<td>
<p> an array of dimension <code>n</code> times 2 times <code>K+1</code> giving the probability of all measurements below the individual, 
depending on his status and his class. </p>
</td></tr>
</table>


<h3>References</h3>

<p> TAYEB et al.: Solving Genetic Heterogeneity in Extended Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 2011, DOI: 10.1007/s00180-010-0224-2. </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+upward.connect">upward.connect</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
data(peel)
fam &lt;- ped.cont[,1]
id &lt;- ped.cont[fam==1,2]
dad &lt;- ped.cont[fam==1,3]
mom &lt;- ped.cont[fam==1,4]
status &lt;- ped.cont[fam==1,6]
y &lt;- ped.cont[fam==1,7:ncol(ped.cont)]
peel &lt;- peel[[1]]
#standardize id to be 1, 2, 3, ...
id.origin &lt;- id
standard &lt;- function(vec) ifelse(vec%in%id.origin,which(id.origin==vec),0)
id &lt;- apply(t(id),2,standard)
dad &lt;- apply(t(dad),2,standard)
mom &lt;- apply(t(mom),2,standard)
peel$couple &lt;- cbind(apply(t(peel$couple[,1]),2,standard),
                     apply(t(peel$couple[,2]),2,standard))
for(generat in 1:peel$generation)
peel$peel.connect[generat,] &lt;- apply(t(peel$peel.connect[generat,]),2,standard)
#probs and param
data(probs)
data(param.cont)
#densities of the observations
fyc &lt;- matrix(1,nrow=length(id),ncol=length(probs$p)+1)
fyc[status==2,1:length(probs$p)] &lt;- t(apply(y[status==2,],1,dens.norm,
                                      param.cont,NULL))
#the function
upward(id,dad,mom,status,probs,fyc,peel)
</code></pre>

<hr>
<h2 id='upward.connect'> performs the upward step for a connector </h2><span id='topic+upward.connect'></span>

<h3>Description</h3>

<p>computes the probability of the measurements below a connector
conditionally to the connector latent class given the model
parameters. This is an internal function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upward.connect(connect, spouse.connect, children.connect, status,
probs, p.yF.c, fyc, sum.child)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upward.connect_+3A_connect">connect</code></td>
<td>
<p> a connector in the pedigree, </p>
</td></tr>
<tr><td><code id="upward.connect_+3A_spouse.connect">spouse.connect</code></td>
<td>
<p> spouse of the connector, </p>
</td></tr>
<tr><td><code id="upward.connect_+3A_children.connect">children.connect</code></td>
<td>
<p> children of the connector, </p>
</td></tr>
<tr><td><code id="upward.connect_+3A_status">status</code></td>
<td>
<p> a vector of symptom status of the whole pedigree, </p>
</td></tr>
<tr><td><code id="upward.connect_+3A_probs">probs</code></td>
<td>
<p> a list of probability parameters of the model, </p>
</td></tr>
<tr><td><code id="upward.connect_+3A_p.yf.c">p.yF.c</code></td>
<td>
<p> an array of dimension <code>n</code> times 2 times <code>K+1</code> giving the probability of measurements below the individual, 
depending on his status and his class, where <code>n</code> is the 
number of individuals and <code>K</code> is the total number of latent classes in the model, </p>
</td></tr>
<tr><td><code id="upward.connect_+3A_fyc">fyc</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K+1</code> given the density of measurements of each individual if allocated to class <code>k</code>, </p>
</td></tr>
<tr><td><code id="upward.connect_+3A_sum.child">sum.child</code></td>
<td>
<p> an array of dimension <code>nber.indiv</code> times <code>K+1</code> times <code>K+1</code> such that <code>sum.child[i,c_1,c_2]</code> is the probability of 
individual <code>i</code> measurements when his parent are assigned to classes <code>c_1</code> and <code>c_1</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>Y_above(i)</code> is the observations below connector <code>i</code> and <code>C_i</code> is his class, the functions computes <code>P(Y_below(i)|C_i)</code>.
</p>


<h3>Value</h3>

<p>The function returns a list of 2 elements:
</p>
<table>
<tr><td><code>sum.child</code></td>
<td>
<p>an array of dimension <code>n</code> times <code>K+1</code> times <code>K+1</code> such that <code>sum.child[i,c_1,c_2]</code> is the probability of 
individual <code>i</code> observations when his parent are assigned to classes <code>c_1</code> and <code>c_2</code>, </p>
</td></tr>
<tr><td><code>p.yF.c</code></td>
<td>
<p>a array of dimension <code>n</code> times 2 times <code>K+1</code> giving the probability of measurements below the individual, 
depending on his status and his class, updated for the current connector. </p>
</td></tr>
</table>


<h3>References</h3>

<p> TAYEB et al.: Solving Genetic Heterogeneity in Extended Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 2011, DOI: 10.1007/s00180-010-0224-2. </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+upward">upward</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
data(peel)
fam &lt;- ped.cont[,1]
id &lt;- ped.cont[fam==1,2]
dad &lt;- ped.cont[fam==1,3]
mom &lt;- ped.cont[fam==1,4]
status &lt;- ped.cont[fam==1,6]
y &lt;- ped.cont[fam==1,7:ncol(ped.cont)]
peel &lt;- peel[[1]]
#standardize id to be 1, 2, 3, ...
id.origin &lt;- id
standard &lt;- function(vec) ifelse(vec%in%id.origin,which(id.origin==vec),0)
id &lt;- apply(t(id),2,standard)
dad &lt;- apply(t(dad),2,standard)
mom &lt;- apply(t(mom),2,standard)
peel$couple &lt;- cbind(apply(t(peel$couple[,1]),2,standard),
                     apply(t(peel$couple[,2]),2,standard))
for(generat in 1:peel$generation) 
peel$peel.connect[generat,] &lt;- apply(t(peel$peel.connect[generat,]),2,standard)
#a nuclear family
#connector in the pedigree 1
connect &lt;- peel$peel.connect[1,1]
#soupse of connector connect
spouse.connect &lt;- peel$couple[peel$couple[,1]==connect,2]
#children of connector connect
children.connect &lt;- union(id[dad==connect],id[mom==connect])
#probs and param
data(probs)
data(param.cont)
#probabilitiy of observations above
p.yF.c &lt;- matrix(1,nrow=length(id),ncol=length(probs$p)+1)
#densities of the observations
fyc &lt;- matrix(1,nrow=length(id),ncol=length(probs$p)+1)
fyc[status==2,1:length(probs$p)] &lt;- t(apply(y[status==2,],1,dens.norm,
                                      param.cont,NULL))
#sums over childs
sum.child &lt;- array(0,c(length(id),length(probs$p)+1,length(probs$p)+1))
#the function
upward.connect(connect,spouse.connect,children.connect,status,probs,
               p.yF.c,fyc,sum.child)
</code></pre>

<hr>
<h2 id='weight.famdep'> performs the computation of triplet and individual weights for a pedigree under familial dependence</h2><span id='topic+weight.famdep'></span>

<h3>Description</h3>

<p>computes the triplet and the individual weights of the E step of the EM algorithm for a pedigree in the case of familial dependence. It returns also the 
overall log-likelihood of the observations. This is an internal
function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight.famdep(id, dad, mom, status, probs, fyc, peel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight.famdep_+3A_id">id</code></td>
<td>
<p> individual ID of the pedigree, </p>
</td></tr>
<tr><td><code id="weight.famdep_+3A_dad">dad</code></td>
<td>
<p> dad ID, </p>
</td></tr>
<tr><td><code id="weight.famdep_+3A_mom">mom</code></td>
<td>
<p> mom ID, </p>
</td></tr>
<tr><td><code id="weight.famdep_+3A_status">status</code></td>
<td>
<p> symptom status: (2: symptomatic, 1: without symptoms, 0: missing), </p>
</td></tr>
<tr><td><code id="weight.famdep_+3A_probs">probs</code></td>
<td>
<p> list of probability parameters of the model, </p>
</td></tr>
<tr><td><code id="weight.famdep_+3A_fyc">fyc</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K+1</code> given the density of observations of each individual if allocated to class <code>k</code>, where <code>n</code> is the 
number of individuals and <code>K</code> is the total number of latent classes in the model, </p>
</td></tr>
<tr><td><code id="weight.famdep_+3A_peel">peel</code></td>
<td>
<p> a list of pedigree peeling containing connectors by peeling order and couples of parents </p>
</td></tr>
</table>


<h3>Details</h3>

<p>the function calls the functions <code><a href="#topic+upward">upward</a></code> and
<code><a href="#topic+downward">downward</a></code> which perform the required probability
computations by processing the pedigree by nuclear family (or
equivalently by connector) following the peeling order.
</p>


<h3>Value</h3>

<p>the function returns a list of 3 elements:
</p>
<table>
<tr><td><code>ww</code></td>
<td>
<p> triplet weights: an array of <code>n</code> times 2 times <code>K+1</code> times <code>K+1</code> times <code>K+1</code>, see <code><a href="#topic+e.step">e.step</a></code>, </p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p> individual weights: an array of <code>n</code> times 2 times <code>K+1</code>, see <code><a href="#topic+e.step">e.step</a></code>, </p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p> log-likelihood. </p>
</td></tr>
</table>


<h3>References</h3>

<p> TAYEB et al.: Solving Genetic Heterogeneity in Extended Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 2011, DOI: 10.1007/s00180-010-0224-2. </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+upward">upward</a></code>, <code><a href="#topic+downward">downward</a></code>, <code><a href="#topic+e.step">e.step</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
data(peel)
fam &lt;- ped.cont[,1]
id &lt;- ped.cont[fam==1,2]
dad &lt;- ped.cont[fam==1,3]
mom &lt;- ped.cont[fam==1,4]
status &lt;- ped.cont[fam==1,6]
y &lt;- ped.cont[fam==1,7:ncol(ped.cont)]
peel &lt;- peel[[1]]
#probs and param
data(probs)
data(param.cont)
#densities of the observations
fyc &lt;- matrix(1,nrow=length(id),ncol=length(probs$p)+1)
fyc[status==2,1:length(probs$p)] &lt;- t(apply(y[status==2,],1,dens.norm,
                                      param.cont,NULL))
#the function
weight.famdep(id,dad,mom,status,probs,fyc,peel)
</code></pre>

<hr>
<h2 id='weight.nuc'> performs the computation of unnormalized triplet and individuals weights for a nuclear family in the pedigree </h2><span id='topic+weight.nuc'></span>

<h3>Description</h3>

<p>the weighting algorithm proceeds by nuclear family, the function <code>weight.nuc</code> computes the unnormalized triplet and individuals weights for a 
nuclear family in the pedigree. This is an internal
function not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight.nuc(connect, spouse.connect, children.connect, status, 
probs, fyc, p.ybarF.c, ww, w, res.upward)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight.nuc_+3A_connect">connect</code></td>
<td>
<p> a connector in the pedigree, </p>
</td></tr>
<tr><td><code id="weight.nuc_+3A_spouse.connect">spouse.connect</code></td>
<td>
<p> spouse of the connector, </p>
</td></tr>
<tr><td><code id="weight.nuc_+3A_children.connect">children.connect</code></td>
<td>
<p> children of the connector, </p>
</td></tr>
<tr><td><code id="weight.nuc_+3A_status">status</code></td>
<td>
<p> vector of symptom status of the whole pedigree, </p>
</td></tr>
<tr><td><code id="weight.nuc_+3A_probs">probs</code></td>
<td>
<p> all probability parameters of the model, </p>
</td></tr>
<tr><td><code id="weight.nuc_+3A_fyc">fyc</code></td>
<td>
<p> a matrix of <code>n</code> times <code>K+1</code> given the density of observations of each individual if allocated to class <code>k</code>, where <code>n</code> is the 
number of individuals and <code>K</code> is the total number of latent classes in the model, </p>
</td></tr>
<tr><td><code id="weight.nuc_+3A_p.ybarf.c">p.ybarF.c</code></td>
<td>
<p> a array of dimension <code>n</code> times 2 times <code>K+1</code> giving the probability of observations above the individual, 
depending on his status and his class and conditionally on his class, </p>
</td></tr>
<tr><td><code id="weight.nuc_+3A_ww">ww</code></td>
<td>
<p> unnormalized triplet weights, an array of <code>n</code> times 2 times <code>K+1</code> times <code>K+1</code> times <code>K+1</code>, where <code>n</code> is the 
number of individuals and <code>K</code> is the total number of latent classes in the model, see <code><a href="#topic+e.step">e.step</a></code>, </p>
</td></tr>
<tr><td><code id="weight.nuc_+3A_w">w</code></td>
<td>
<p> unnormalized individual weights, an array of <code>n</code> times 2 times <code>K+1</code>, see <code><a href="#topic+e.step">e.step</a></code>, </p>
</td></tr>
<tr><td><code id="weight.nuc_+3A_res.upward">res.upward</code></td>
<td>
<p> result of the upward step of the weighting algorithm, see <code><a href="#topic+upward">upward</a></code>, </p>
</td></tr>
</table>


<h3>Details</h3>

<p>updated <code>ww</code> and <code>w</code> are computed for the current nuclear family.
</p>


<h3>Value</h3>

<p>the function returns a list of 2 elements:
</p>
<table>
<tr><td><code>ww</code></td>
<td>
<p> unnormalized triplet weights, an array of <code>n</code> times 2 times <code>K+1</code> times <code>K+1</code> times <code>K+1</code>, see <code><a href="#topic+e.step">e.step</a></code>, </p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p> unnormalized individual weights, an array of <code>n</code> times 2 times <code>K+1</code>, see <code><a href="#topic+e.step">e.step</a></code>. </p>
</td></tr>
</table>


<h3>References</h3>

<p> TAYEB et al.: Solving Genetic Heterogeneity in Extended Families by Identifying Sub-types of Complex Diseases. Computational Statistics, 2011, DOI: 10.1007/s00180-010-0224-2. </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+downward">downward</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#data
data(ped.cont)
data(peel)
fam &lt;- ped.cont[,1]
id &lt;- ped.cont[fam==1,2]
dad &lt;- ped.cont[fam==1,3]
mom &lt;- ped.cont[fam==1,4]
status &lt;- ped.cont[fam==1,6]
y &lt;- ped.cont[fam==1,7:ncol(ped.cont)]
peel &lt;- peel[[1]]
#standardize id to be 1, 2, 3, ...
id.origin &lt;- id
standard &lt;- function(vec) ifelse(vec%in%id.origin,which(id.origin==vec),0)
id &lt;- apply(t(id),2,standard)
dad &lt;- apply(t(dad),2,standard)
mom &lt;- apply(t(mom),2,standard)
peel$couple &lt;- cbind(apply(t(peel$couple[,1]),2,standard),
                     apply(t(peel$couple[,2]),2,standard))
for(generat in 1:peel$generation)
peel$peel.connect[generat,] &lt;- apply(t(peel$peel.connect[generat,]),2,standard)
#the first nuclear family
generat &lt;- peel$generation
connect &lt;- peel$peel.connect[generat,]
connect &lt;- connect[connect&gt;0]
spouse.connect &lt;- peel$couple[peel$couple[,1]==connect,2]
children.connect &lt;- union(id[dad==connect],id[mom==connect])
#probs and param
data(probs)
data(param.cont)
#densities of the observations
fyc &lt;- matrix(1,nrow=length(id),ncol=length(probs$p)+1)
fyc[status==2,1:length(probs$p)] &lt;- t(apply(y[status==2,],1,dens.norm,
                                            param.cont,NULL))
#triplet and individual weights
ww &lt;- array(0,dim=c(length(id),rep(2,3),rep(length(probs$p)+1,3)))
w &lt;- array(0,dim=c(length(id),2,length(probs$p)+1))
#probability of the observations below
p.ybarF.c &lt;- array(1,dim=c(length(id),2,length(probs$p)+1))
p.ybarF.c[connect,,] &lt;- p.post.found(connect,status,probs,fyc)
#the upward step
res.upward &lt;- upward(id,dad,mom,status,probs,fyc,peel)
#the function
weight.nuc(connect,spouse.connect,children.connect,status,probs,fyc,
           p.ybarF.c,ww,w,res.upward)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
