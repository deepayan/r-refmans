<!DOCTYPE html><html><head><title>Help for package finalfit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {finalfit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#finalfit-package'><p>finalfit: Quickly create elegant final results tables and plots when modelling.</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#%&lt;&gt;%'><p>magrittr compound assignment pipe-operator</p></a></li>
<li><a href='#%$%'><p>magrittr exposition pipe-operator</p></a></li>
<li><a href='#boot_compare'><p>Compare bootstrapped distributions</p></a></li>
<li><a href='#boot_predict'><p>Bootstrap simulation for model prediction</p></a></li>
<li><a href='#catTestfisher'><p>Deprecated catTest from Hmisc for reverse dependencies</p></a></li>
<li><a href='#check_recode'><p>Check accurate recoding of variables</p></a></li>
<li><a href='#coefficient_plot'><p>Produce a coefficient table and plot</p></a></li>
<li><a href='#colon_s'><p>Chemotherapy for Stage B/C colon cancer</p></a></li>
<li><a href='#condense_fit'><p>Condense model output dataframe for final tables</p></a></li>
<li><a href='#coxphmulti'><p>Cox proprotional hazards multivariable models: <code>finalfit</code> model wrapper</p></a></li>
<li><a href='#coxphuni'><p>Cox proprotional hazards univariable models: <code>finalfit</code> model wrapper</p></a></li>
<li><a href='#crrmulti'><p>Competing risks multivariable regression: <code>finalfit</code> model wrapper</p></a></li>
<li><a href='#crruni'><p>Competing risks univariable regression: <code>finalfit</code> model wrapper</p></a></li>
<li><a href='#dependent_label'><p>Make a label for the dependent variable</p></a></li>
<li><a href='#error_colon_fct_levels'><p>Errors: colon in factor levels</p></a></li>
<li><a href='#extract_fit'><p>Extract model output to dataframe</p></a></li>
<li><a href='#extract_labels'><p>Extract variable labels and names</p></a></li>
<li><a href='#extract_variable_label'><p>Extract variable labels from dataframe</p></a></li>
<li><a href='#ff_column_totals'><p>Add column totals to <code>summary_factorlist()</code> output</p></a></li>
<li><a href='#ff_eval'><p>Eval for 'lm' and 'glm' model wrappers</p></a></li>
<li><a href='#ff_formula'><p>Generate formula as character string</p></a></li>
<li><a href='#ff_glimpse'><p>Descriptive statistics for dataframe</p></a></li>
<li><a href='#ff_interaction'><p>Make an interaction variable and add to dataframe</p></a></li>
<li><a href='#ff_label'><p>Label a variable</p></a></li>
<li><a href='#ff_merge'><p>Merge a <code>summary_factorlist()</code> table with any number of model</p>
results tables.</a></li>
<li><a href='#ff_metrics'><p>Generate common metrics for regression model results</p></a></li>
<li><a href='#ff_newdata'><p>Generate newdata for simulations</p></a></li>
<li><a href='#ff_parse_formula'><p>Parse a formula to finalfit grammar</p></a></li>
<li><a href='#ff_percent_only'><p>Include only percentages for factors in <code>summary_factorlist</code> output</p></a></li>
<li><a href='#ff_permute'><p>Permuate explanatory variables to produce multiple output tables for common</p>
regression models</a></li>
<li><a href='#ff_plot'><p>Produce a table and plot</p></a></li>
<li><a href='#ff_relabel'><p>Relabel variables in a data frame</p></a></li>
<li><a href='#ff_relabel_df'><p>Relabel variables from data frame after tidyverse functions</p></a></li>
<li><a href='#ff_remove_p'><p>Remove p-value from output</p></a></li>
<li><a href='#ff_remove_ref'><p>Remove regression reference level row from table</p></a></li>
<li><a href='#ff_row_totals'><p>Add row totals to <code>summary_factorlist()</code> output</p></a></li>
<li><a href='#ff_stratify_helper'><p>Help making stratified summary_factorlist tables</p></a></li>
<li><a href='#finalfit'><p>Final output tables for common regression models</p></a></li>
<li><a href='#fit2df'><p>Extract model fit results to dataframe (generic): <code>finalfit</code> model</p>
extractors</a></li>
<li><a href='#format_n_percent'><p>Format n and percent as a character</p></a></li>
<li><a href='#glmmixed'><p>Mixed effects binomial logistic regression models: <code>finalfit</code> model wrapper</p></a></li>
<li><a href='#glmmulti'><p>Binomial logistic regression multivariable models: <code>finalfit</code> model</p>
wrapper</a></li>
<li><a href='#glmmulti_boot'><p>Binomial logistic regression multivariable models with bootstrapped</p>
confidence intervals: <code>finalfit</code> model wrapper</a></li>
<li><a href='#glmuni'><p>Binomial logistic regression univariable models: <code>finalfit</code> model wrapper</p></a></li>
<li><a href='#hr_plot'><p>Produce a hazard ratio table and plot</p></a></li>
<li><a href='#is.survival'><p>Test character describes survival object</p></a></li>
<li><a href='#labels_to_column'><p>Labels to column names</p></a></li>
<li><a href='#labels_to_level'><p>Labels to level</p></a></li>
<li><a href='#lmmixed'><p>Mixed effects linear regression models: <code>finalfit</code> model wrapper</p></a></li>
<li><a href='#lmmulti'><p>Linear regression multivariable models: <code>finalfit</code> model wrapper</p></a></li>
<li><a href='#lmuni'><p>Linear regression univariable models: <code>finalfit</code> model wrapper</p></a></li>
<li><a href='#metrics_hoslem'><p>Hosmer-Lemeshow goodness of fit test</p></a></li>
<li><a href='#missing_compare'><p>Compare missing data</p></a></li>
<li><a href='#missing_df'><p>Missing values data frame</p></a></li>
<li><a href='#missing_glimpse'><p>Summary of missing values</p></a></li>
<li><a href='#missing_pairs'><p>Missing values pairs plot</p></a></li>
<li><a href='#missing_pattern'><p>Characterise missing data for <code>finalfit</code> models</p></a></li>
<li><a href='#missing_plot'><p>Missing values occurrence plot</p></a></li>
<li><a href='#missing_predictorMatrix'><p>Create predictorMatrix for use with mice</p></a></li>
<li><a href='#or_plot'><p>Produce an odds ratio table and plot</p></a></li>
<li><a href='#p_tidy'><p>Round p-values but keep trailing zeros</p></a></li>
<li><a href='#plot_title'><p>Label plot title</p></a></li>
<li><a href='#print.data.frame.ff'><p>Print methods for finalfit data frames</p></a></li>
<li><a href='#remove_intercept'><p>Remove intercept from model output</p></a></li>
<li><a href='#remove_labels'><p>Remove variable labels.</p></a></li>
<li><a href='#rm_duplicate_labels'><p>Remove duplicate levels within <code>summary_factorlist</code>: <code>finalfit</code> helper function</p></a></li>
<li><a href='#rm_duplicates'><p>Remove duplicates and replace</p></a></li>
<li><a href='#rm_empty_block'><p>Remove rows where all specified variables are missing</p></a></li>
<li><a href='#round_tidy'><p>Round values but keep trailing zeros</p></a></li>
<li><a href='#summary_factorlist'><p>Summarise a set of factors (or continuous variables) by a dependent variable</p></a></li>
<li><a href='#summary_factorlist_stratified'><p>Summarise a set of factors (or continuous variables) by a dependent variable</p></a></li>
<li><a href='#summary_mipo'><p>Call to mice:::summary.mipo</p></a></li>
<li><a href='#surv_plot'><p>Plot survival curves with number-at-risk table</p></a></li>
<li><a href='#svyglmmulti'><p>Multivariable survey-weighted generalised linear models</p></a></li>
<li><a href='#svyglmuni'><p>Univariable survey-weighted generalised linear models</p></a></li>
<li><a href='#variable_type'><p>Determine type/class of a variable</p></a></li>
<li><a href='#wcgs'><p>Western Collaborative Group Study</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quickly Create Elegant Regression Results Tables and Plots when
Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ewen Harrison &lt;ewen.harrison@ed.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate regression results tables and plots in final 
    format for publication. Explore models and export directly to PDF 
    and 'Word' using 'RMarkdown'. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENCE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ewenharrison/finalfit/issues">https://github.com/ewenharrison/finalfit/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ewenharrison/finalfit">https://github.com/ewenharrison/finalfit</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>bdsmatrix, boot, broom, dplyr, forcats, GGally, ggplot2, grid,
gridExtra, lme4, magrittr, mice, pillar, pROC, purrr, scales,
stats, stringr, survival, tidyr (&ge; 1.0.0), tidyselect</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cmprsk, coxme, Hmisc, knitr, lmtest, readr, rlang, rmarkdown,
rstan, sandwich, survey, survminer, testthat, tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-16 14:14:01 UTC; eharrison</td>
</tr>
<tr>
<td>Author:</td>
<td>Ewen Harrison [aut, cre],
  Tom Drake [aut],
  Riinu Pius [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-16 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='finalfit-package'>finalfit: Quickly create elegant final results tables and plots when modelling.</h2><span id='topic+finalfit-package'></span>

<h3>Description</h3>

<p>Quickly create elegant final results tables and plots when modelling.
</p>


<h3><code>finalfit</code> model wrappers</h3>

<p><a href="#topic+glmuni">glmuni</a>,
<a href="#topic+glmmulti">glmmulti</a>,
<a href="#topic+glmmulti_boot">glmmulti_boot</a>,
<a href="#topic+glmmixed">glmmixed</a>,
<a href="#topic+lmuni">lmuni</a>,
<a href="#topic+lmmulti">lmmulti</a>,
<a href="#topic+lmmixed">lmmixed</a>,
<a href="#topic+coxphuni">coxphuni</a>,
<a href="#topic+coxphmulti">coxphmulti</a>,
<a href="#topic+crruni">crruni</a>,
<a href="#topic+crrmulti">crrmulti</a>,
<a href="#topic+svyglmuni">svyglmuni</a>,
<a href="#topic+svyglmmulti">svyglmmulti</a>.
</p>


<h3><code>finalfit</code> model extractor</h3>

<p>Generic:
<a href="#topic+fit2df">fit2df</a>
</p>
<p>Methods (not called directly):
<a href="#topic+fit2df.glm">fit2df.glm</a>,
<a href="#topic+fit2df.glmlist">fit2df.glmlist</a>,
<a href="#topic+fit2df.glmboot">fit2df.glmboot</a>,
<a href="#topic+fit2df.lm">fit2df.lm</a>,
<a href="#topic+fit2df.lmlist">fit2df.lmlist</a>,
<a href="#topic+fit2df.glmerMod">fit2df.glmerMod</a>,
<a href="#topic+fit2df.lmerMod">fit2df.lmerMod</a>,
<a href="#topic+fit2df.coxph">fit2df.coxph</a>,
<a href="#topic+fit2df.coxphlist">fit2df.coxphlist</a>,
<a href="#topic+fit2df.crr">fit2df.crr</a>,
<a href="#topic+fit2df.crrlist">fit2df.crrlist</a>,
<a href="#topic+fit2df.stanfit">fit2df.stanfit</a>.
</p>


<h3><code>finalfit</code> all-in-one function</h3>

<p>Generic:
<a href="#topic+finalfit">finalfit</a>.
<a href="#topic+finalfit_permute">finalfit_permute</a>.
</p>
<p>Methods (not called directly):
<a href="#topic+finalfit.glm">finalfit.glm</a>,
<a href="#topic+finalfit.lm">finalfit.lm</a>,
<a href="#topic+finalfit.coxph">finalfit.coxph</a>.
</p>


<h3><code>finalfit</code> plotting functions</h3>

<p><a href="#topic+coefficient_plot">coefficient_plot</a>,
<a href="#topic+or_plot">or_plot</a>,
<a href="#topic+hr_plot">hr_plot</a>,
<a href="#topic+surv_plot">surv_plot</a>,
<a href="#topic+ff_plot">ff_plot</a>.
</p>


<h3><code>finalfit</code> helper functions</h3>

<p><a href="#topic+ff_glimpse">ff_glimpse</a>,
<a href="#topic+ff_label">ff_label</a>,
<a href="#topic+ff_merge">ff_merge</a>,
<a href="#topic+ff_interaction">ff_interaction</a>.
</p>


<h3><code>finalfit</code> prediction functions</h3>

<p><a href="#topic+boot_predict">boot_predict</a>,
<a href="#topic+finalfit_newdata">finalfit_newdata</a>.
</p>
<p>Methods (not called directly):
<a href="#topic+boot_compare">boot_compare</a>.
</p>


<h3><code>finalfit</code> missing data functions</h3>

<p><a href="#topic+missing_glimpse">missing_glimpse</a>,
<a href="#topic+missing_pattern">missing_pattern</a>,
<a href="#topic+missing_compare">missing_compare</a>,
<a href="#topic+missing_plot">missing_plot</a>,
<a href="#topic+missing_pairs">missing_pairs</a>.
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='+25+26lt+3B+26gt+3B+25'>magrittr compound assignment pipe-operator</h2><span id='topic++25+3C+3E+25'></span>

<h3>Description</h3>

<p>magrittr compound assignment pipe-operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&lt;&gt;% rhs
</code></pre>

<hr>
<h2 id='+25+24+25'>magrittr exposition pipe-operator</h2><span id='topic++25+24+25'></span>

<h3>Description</h3>

<p>magrittr exposition pipe-operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %$% rhs
</code></pre>

<hr>
<h2 id='boot_compare'>Compare bootstrapped distributions</h2><span id='topic+boot_compare'></span>

<h3>Description</h3>

<p>Not usually called directly. Included in <code><a href="#topic+boot_predict">boot_predict</a></code>. Usually used in combination with A function that takes the output from <code><a href="#topic+summary_factorlist">summary_factorlist</a>(...,
fit_id=TRUE)</code> and merges with any number of model dataframes, usually
produced with a model wrapper followed by the <code><a href="#topic+fit2df">fit2df</a>()</code> function
(see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_compare(
  bs.out,
  confint_level = 0.95,
  confint_sep = " to ",
  comparison = "difference",
  condense = TRUE,
  compare_name = NULL,
  digits = c(2, 3),
  ref_symbol = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_compare_+3A_bs.out">bs.out</code></td>
<td>
<p>Output from <code>boot::boot</code>,</p>
</td></tr>
<tr><td><code id="boot_compare_+3A_confint_level">confint_level</code></td>
<td>
<p>The confidence level to use for the confidence interval. 
Must be strictly greater than 0 and less than 1. Defaults to 0.95, 
which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="boot_compare_+3A_confint_sep">confint_sep</code></td>
<td>
<p>String separating lower and upper confidence interval</p>
</td></tr>
<tr><td><code id="boot_compare_+3A_comparison">comparison</code></td>
<td>
<p>Either &quot;difference&quot; or &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="boot_compare_+3A_condense">condense</code></td>
<td>
<p>Logical. FALSE gives numeric values, usually for plotting.
TRUE gives table for final output.</p>
</td></tr>
<tr><td><code id="boot_compare_+3A_compare_name">compare_name</code></td>
<td>
<p>Name to be given to comparison metric.</p>
</td></tr>
<tr><td><code id="boot_compare_+3A_digits">digits</code></td>
<td>
<p>Rounding for estimate values and p-values, default c(2,3).</p>
</td></tr>
<tr><td><code id="boot_compare_+3A_ref_symbol">ref_symbol</code></td>
<td>
<p>Reference level symbol</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of first differences or ratios for boostrapped distributions of a metric of interest.
</p>
<p><code>finalfit</code> predict functions
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot_predict">boot_predict</a></code> <code><a href="#topic+finalfit_newdata">finalfit_newdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See boot_predict.
</code></pre>

<hr>
<h2 id='boot_predict'>Bootstrap simulation for model prediction</h2><span id='topic+boot_predict'></span>

<h3>Description</h3>

<p>Generate model predictions against a specified set of explanatory levels with
bootstrapped confidence intervals. Add a comparison by difference or ratio of
the first row of <code>newdata</code> with all subsequent rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_predict(
  fit,
  newdata,
  type = "response",
  R = 100,
  estimate_name = NULL,
  confint_level = 0.95,
  conf.method = "perc",
  confint_sep = " to ",
  condense = TRUE,
  boot_compare = TRUE,
  compare_name = NULL,
  comparison = "difference",
  ref_symbol = "-",
  digits = c(2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_predict_+3A_fit">fit</code></td>
<td>
<p>A model generated using <code>lm</code>, <code>glm</code>,
<code><a href="#topic+lmmulti">lmmulti</a></code>, and <code><a href="#topic+glmmulti">glmmulti</a></code>.</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_newdata">newdata</code></td>
<td>
<p>Dataframe usually generated with
<code><a href="#topic+finalfit_newdata">finalfit_newdata</a></code>.</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_type">type</code></td>
<td>
<p>the type of prediction required, see
<code><a href="stats.html#topic+predict.glm">predict.glm</a></code>. The default for glm models is on the
scale of the response variable. Thus for a binomial model the default
predictions are predicted probabilities.</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_r">R</code></td>
<td>
<p>Number of simulations. Note default R=100 is very low.</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_estimate_name">estimate_name</code></td>
<td>
<p>Name to be given to prediction variable y-hat.</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_confint_level">confint_level</code></td>
<td>
<p>The confidence level to use for the confidence interval. 
Must be strictly greater than 0 and less than 1. Defaults to 0.95, 
which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_conf.method">conf.method</code></td>
<td>
<p>Passed to the type argument of boot::boot.ci(). 
Defaults to &quot;perc&quot;. The allowed types are &quot;perc&quot;, &quot;basic&quot;, &quot;bca&quot;, and &quot;norm&quot;. 
Does not support &quot;stud&quot; or &quot;all&quot;</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_confint_sep">confint_sep</code></td>
<td>
<p>String separating lower and upper confidence interval</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_condense">condense</code></td>
<td>
<p>Logical. FALSE gives numeric values, usually for plotting.
TRUE gives table for final output.</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_boot_compare">boot_compare</code></td>
<td>
<p>Include a comparison with the first row of <code>newdata</code>
with all subsequent rows. See <code><a href="#topic+boot_compare">boot_compare</a></code>.</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_compare_name">compare_name</code></td>
<td>
<p>Name to be given to comparison metric.</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_comparison">comparison</code></td>
<td>
<p>Either &quot;difference&quot; or &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_ref_symbol">ref_symbol</code></td>
<td>
<p>Reference level symbol</p>
</td></tr>
<tr><td><code id="boot_predict_+3A_digits">digits</code></td>
<td>
<p>Rounding for estimate values and p-values, default c(2,3).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use this, first generate <code>newdata</code> for specified levels of
explanatory variables using <code><a href="#topic+finalfit_newdata">finalfit_newdata</a></code>. Pass model
objects from <code>lm</code>, <code>glm</code>, <code><a href="#topic+lmmulti">lmmulti</a></code>, and
<code><a href="#topic+glmmulti">glmmulti</a></code>. The comparison metrics are made on individual
bootstrap samples distribution returned as a mean with confidence intervals.
A p-value is generated on the proportion of values on the other side of the
null from the mean, e.g. for a ratio greater than 1.0, p is the number of
bootstrapped predictions under 1.0, multiplied by two so is two-sided.
</p>


<h3>Value</h3>

<p>A dataframe of predicted values and confidence intervals, with the
option of including a comparison of difference between first row and all
subsequent rows of <code>newdata</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+finalfit_newdata">finalfit_newdata</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)

# Predict probability of death across combinations of factor levels
explanatory = c("age.factor", "extent.factor", "perfor.factor")
dependent = 'mort_5yr'

# Generate combination of factor levels
colon_s %&gt;%
  finalfit_newdata(explanatory = explanatory, newdata = list(
    c("&lt;40 years",  "Submucosa", "No"),
    c("&lt;40 years", "Submucosa", "Yes"),
    c("&lt;40 years", "Adjacent structures", "No"),
    c("&lt;40 years", "Adjacent structures", "Yes")
   )) -&gt; newdata

# Run simulation
colon_s %&gt;%
  glmmulti(dependent, explanatory) %&gt;%
  boot_predict(newdata, estimate_name = "Predicted probability of death",
    compare_name = "Absolute risk difference", R=100, digits = c(2,3))

# Plotting
explanatory = c("nodes", "extent.factor", "perfor.factor")
colon_s %&gt;%
  finalfit_newdata(explanatory = explanatory, rowwise = FALSE, newdata = list(
  rep(seq(0, 30), 4),
  c(rep("Muscle", 62), rep("Adjacent structures", 62)),
  c(rep("No", 31), rep("Yes", 31), rep("No", 31), rep("Yes", 31))
)) -&gt; newdata

colon_s %&gt;%
  glmmulti(dependent, explanatory) %&gt;%
  boot_predict(newdata, boot_compare = FALSE, R=100, condense=FALSE) -&gt; plot

  library(ggplot2)
  theme_set(theme_bw())
  plot %&gt;%
    ggplot(aes(x = nodes, y = estimate, ymin = estimate_conf.low,
        ymax = estimate_conf.high, fill=extent.factor))+
      geom_line(aes(colour = extent.factor))+
      geom_ribbon(alpha=0.1)+
      facet_grid(.~perfor.factor)+
      xlab("Number of postive lymph nodes")+
      ylab("Probability of death")+
      labs(fill = "Extent of tumour", colour = "Extent of tumour")+
      ggtitle("Probability of death by lymph node count")
</code></pre>

<hr>
<h2 id='catTestfisher'>Deprecated catTest from Hmisc for reverse dependencies</h2><span id='topic+catTestfisher'></span>

<h3>Description</h3>

<p>Deprecated catTest from Hmisc for reverse dependencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catTestfisher(.)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catTestfisher_+3A_.">.</code></td>
<td>
<p>Null</p>
</td></tr>
</table>

<hr>
<h2 id='check_recode'>Check accurate recoding of variables</h2><span id='topic+check_recode'></span>

<h3>Description</h3>

<p>This was written a few days after the retraction of a paper in JAMA due to an
error in recoding the treatment variable
(<a href="https://jamanetwork.com/journals/jama/fullarticle/2752474">https://jamanetwork.com/journals/jama/fullarticle/2752474</a>). This
takes a data frame or tibble, fuzzy matches variable names, and produces
crosstables of all matched variables. A visual inspection should reveal any
miscoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_recode(
  .data,
  dependent = NULL,
  explanatory = NULL,
  include_numerics = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_recode_+3A_.data">.data</code></td>
<td>
<p>Data frame or tibble.</p>
</td></tr>
<tr><td><code id="check_recode_+3A_dependent">dependent</code></td>
<td>
<p>Optional character vector: name(s) of depdendent
variable(s).</p>
</td></tr>
<tr><td><code id="check_recode_+3A_explanatory">explanatory</code></td>
<td>
<p>Optional character vector: name(s) of explanatory
variable(s).</p>
</td></tr>
<tr><td><code id="check_recode_+3A_include_numerics">include_numerics</code></td>
<td>
<p>Logical. Include numeric variables in function.</p>
</td></tr>
<tr><td><code id="check_recode_+3A_...">...</code></td>
<td>
<p>Pass other arguments to <code><a href="base.html#topic+agrep">agrep</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length two. The first is an index of variable combiations.
The second is a nested list of crosstables as tibbles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(colon_s)
colon_s_small = colon_s %&gt;%
  select(-id, -rx, -rx.factor) %&gt;%
  mutate(
    age.factor2 = forcats::fct_collapse(age.factor,
      "&lt;60 years" = c("&lt;40 years", "40-59 years")),
    sex.factor2 = forcats::fct_recode(sex.factor,
    # Intentional miscode
      "F" = "Male",
      "M" = "Female")
  )

# Check
colon_s_small %&gt;%
  check_recode(include_numerics = FALSE)

out = colon_s_small %&gt;%
  select(-extent, -extent.factor,-time, -time.years) %&gt;%
  check_recode()
out

# Select a tibble and expand
out$counts[[9]]
# Note this variable (node4) appears miscoded in original dataset survival::colon.

# Choose to only include variables that you actually use. 
# This uses standard Finalfit grammar. 
dependent = "mort_5yr"
explanatory = c("age.factor2", "sex.factor2")
colon_s_small %&gt;% 
  check_recode(dependent, explanatory)
</code></pre>

<hr>
<h2 id='coefficient_plot'>Produce a coefficient table and plot</h2><span id='topic+coefficient_plot'></span>

<h3>Description</h3>

<p>Produce a coefficient and plot from a <code>lm()</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefficient_plot(
  .data,
  dependent,
  explanatory,
  random_effect = NULL,
  factorlist = NULL,
  lmfit = NULL,
  confint_type = "default",
  remove_ref = FALSE,
  breaks = NULL,
  column_space = c(-0.5, -0.1, 0.5),
  dependent_label = NULL,
  prefix = "",
  suffix = ": Coefficient, 95% CI, p-value)",
  table_text_size = 4,
  title_text_size = 13,
  plot_opts = NULL,
  table_opts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefficient_plot_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1:  name of depdendent variable
(must be numeric/continuous).</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_random_effect">random_effect</code></td>
<td>
<p>Character vector of length 1, name of random effect
variable.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_factorlist">factorlist</code></td>
<td>
<p>Option to provide output directly from
<code><a href="#topic+summary_factorlist">summary_factorlist</a>()</code>.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_lmfit">lmfit</code></td>
<td>
<p>Option to provide output directly from <code><a href="#topic+lmmulti">lmmulti</a>()</code>
and <code><a href="#topic+lmmixed">lmmixed</a>()</code>.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_confint_type">confint_type</code></td>
<td>
<p>For for <code>lmer</code> models, one of <code>c("default",
"Wald", "profile", "boot")</code> Note &quot;default&quot; == &quot;Wald&quot;.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_remove_ref">remove_ref</code></td>
<td>
<p>Logical. Remove reference level for factors.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_breaks">breaks</code></td>
<td>
<p>Manually specify x-axis breaks in format <code>c(0.1, 1, 10)</code>.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_column_space">column_space</code></td>
<td>
<p>Adjust table column spacing.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_dependent_label">dependent_label</code></td>
<td>
<p>Main label for plot.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_prefix">prefix</code></td>
<td>
<p>Plots are titled by default with the dependent variable. This
adds text before that label.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_suffix">suffix</code></td>
<td>
<p>Plots are titled with the dependent variable. This adds text
after that label.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_table_text_size">table_text_size</code></td>
<td>
<p>Alter font size of table text.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_title_text_size">title_text_size</code></td>
<td>
<p>Alter font size of title text.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_plot_opts">plot_opts</code></td>
<td>
<p>A list of arguments to be appended to the ggplot call by
&quot;+&quot;.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_table_opts">table_opts</code></td>
<td>
<p>A list of arguments to be appended to the ggplot table call
by &quot;+&quot;.</p>
</td></tr>
<tr><td><code id="coefficient_plot_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table and plot produced in <code>ggplot2</code>.
</p>


<h3>See Also</h3>

<p>Other finalfit plot functions: 
<code><a href="#topic+ff_plot">ff_plot</a>()</code>,
<code><a href="#topic+hr_plot">hr_plot</a>()</code>,
<code><a href="#topic+or_plot">or_plot</a>()</code>,
<code><a href="#topic+surv_plot">surv_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(ggplot2)

# Coefficient plot
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "nodes"
colon_s %&gt;%
  coefficient_plot(dependent, explanatory)

colon_s %&gt;%
  coefficient_plot(dependent, explanatory, table_text_size=4, title_text_size=14,
    plot_opts=list(xlab("Beta, 95% CI"), theme(axis.title = element_text(size=12))))
</code></pre>

<hr>
<h2 id='colon_s'>Chemotherapy for Stage B/C colon cancer</h2><span id='topic+colon_s'></span>

<h3>Description</h3>

<p>This is a modified version of <code>survival::<a href="survival.html#topic+colon">colon</a></code>.These
are data from one of the first successful trials of adjuvant chemotherapy for
colon cancer. Levamisole is a low-toxicity compound previously used to treat
worm infestations in animals; 5-FU is a moderately toxic (as these things go)
chemotherapy agent. There are two records per person, one for recurrence and
one for death
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(colon_s)
</code></pre>


<h3>Format</h3>

<p>A data frame with 929 rows and 33 variables
</p>


<h3>Source</h3>

<p><code><a href="survival.html#topic+colon">colon</a></code>
</p>

<hr>
<h2 id='condense_fit'>Condense model output dataframe for final tables</h2><span id='topic+condense_fit'></span>

<h3>Description</h3>

<p>Internal function, not called directly. Can only be used in conjunction with
extract_fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condense_fit(
  .data,
  explanatory_name = "explanatory",
  estimate_name = NA,
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condense_fit_+3A_.data">.data</code></td>
<td>
<p>Dataframe of four or five columns, must be this order, (1) explanatory
variable names, (2) estimate, (3) confidence interval lower limit, (4)
confidence interval upper limit, (5) p-value (optional).</p>
</td></tr>
<tr><td><code id="condense_fit_+3A_explanatory_name">explanatory_name</code></td>
<td>
<p>Name for this column in output</p>
</td></tr>
<tr><td><code id="condense_fit_+3A_estimate_name">estimate_name</code></td>
<td>
<p>Name for this column in output</p>
</td></tr>
<tr><td><code id="condense_fit_+3A_estimate_suffix">estimate_suffix</code></td>
<td>
<p>Appeneded to estimate name</p>
</td></tr>
<tr><td><code id="condense_fit_+3A_p_name">p_name</code></td>
<td>
<p>Name given to p-value estimate</p>
</td></tr>
<tr><td><code id="condense_fit_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round to (1) estimate, (2) confidence
interval limits, (3) p-value.</p>
</td></tr>
<tr><td><code id="condense_fit_+3A_confint_sep">confint_sep</code></td>
<td>
<p>String to separate confidence intervals, typically &quot;-&quot; or
&quot; to &quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='coxphmulti'>Cox proprotional hazards multivariable models: <code>finalfit</code> model wrapper</h2><span id='topic+coxphmulti'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces multivariable Cox
Proportional Hazard regression models for a set of explanatory variables
against a survival object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxphmulti(.data, dependent, explanatory, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxphmulti_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="coxphmulti_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1:  name of survival object in
form <code>Surv(time, status)</code>.</p>
</td></tr>
<tr><td><code id="coxphmulti_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="coxphmulti_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="survival.html#topic+coxph">coxph</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="survival.html#topic+coxph">coxph</a></code> with <code>finalfit</code> modelling
conventions. Output can be passed to <code><a href="#topic+fit2df">fit2df</a></code>.
</p>


<h3>Value</h3>

<p>A multivariable <code><a href="survival.html#topic+coxph">coxph</a></code> fitted model
output. Output is of class <code>coxph</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a>, <a href="#topic+finalfit_merge">finalfit_merge</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cox Proportional Hazards multivariable analysis.
library(finalfit)
library(dplyr)

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "Surv(time, status)"
colon_s %&gt;%
	coxphmulti(dependent, explanatory) %&gt;%
	fit2df()
</code></pre>

<hr>
<h2 id='coxphuni'>Cox proprotional hazards univariable models: <code>finalfit</code> model wrapper</h2><span id='topic+coxphuni'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces multiple univariable Cox Proportional Hazard
regression models for a set of explanatory variables against a survival object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxphuni(.data, dependent, explanatory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxphuni_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="coxphuni_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1:  name of survival object in form <code>Surv(time, status)</code>.</p>
</td></tr>
<tr><td><code id="coxphuni_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="survival.html#topic+coxph">coxph</a></code> with <code>finalfit</code> modelling conventions. Output can be
passed to <code><a href="#topic+fit2df">fit2df</a></code>.
</p>


<h3>Value</h3>

<p>A list of univariable <code><a href="survival.html#topic+coxph">coxph</a></code> fitted model outputs.
Output is of class <code>coxphlist</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a>, <a href="#topic+finalfit_merge">finalfit_merge</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cox Proportional Hazards univariable analysis.
library(finalfit)
library(dplyr)

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "Surv(time, status)"
colon_s %&gt;%
	coxphuni(dependent, explanatory) %&gt;%
	fit2df()
</code></pre>

<hr>
<h2 id='crrmulti'>Competing risks multivariable regression: <code>finalfit</code> model wrapper</h2><span id='topic+crrmulti'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces multivariable Competing Risks
Regression models for a set of explanatory variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crrmulti(.data, dependent, explanatory, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crrmulti_+3A_.data">.data</code></td>
<td>
<p>Data frame or tibble.</p>
</td></tr>
<tr><td><code id="crrmulti_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1: name of survival object in
form <code>Surv(time, status)</code>. <code>Status</code> default values should be 0
censored (e.g. alive), 1 event of interest (e.g. died of disease of
interest), 2 competing event (e.g. died of other cause).</p>
</td></tr>
<tr><td><code id="crrmulti_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="crrmulti_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="cmprsk.html#topic+crr">crr</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="cmprsk.html#topic+crr">crr</a></code> with <code>finalfit</code> modelling conventions.
Output can be passed to <code><a href="#topic+fit2df">fit2df</a></code>.
</p>


<h3>Value</h3>

<p>A multivariable <code><a href="cmprsk.html#topic+crr">crr</a></code> fitted model
class <code>crr</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a>, <a href="#topic+finalfit_merge">finalfit_merge</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
melanoma = boot::melanoma
melanoma = melanoma %&gt;%
  mutate(
    # Cox PH to determine cause-specific hazards
    status_coxph = ifelse(status == 2, 0, # "still alive"
      ifelse(status == 1, 1, # "died of melanoma"
        0)), # "died of other causes is censored"
        
    # Fine and Gray to determine subdistribution hazards
    status_crr = ifelse(status == 2, 0, # "still alive"
      ifelse(status == 1, 1, # "died of melanoma"
        2)), # "died of other causes"
    sex = factor(sex),
    ulcer = factor(ulcer)
  )

dependent_coxph = c("Surv(time, status_coxph)")
dependent_crr = c("Surv(time, status_crr)")
explanatory = c("sex", "age", "ulcer")

# Create single well-formatted table
melanoma %&gt;%
  summary_factorlist(dependent_crr, explanatory, column = TRUE, fit_id = TRUE) %&gt;%
  ff_merge(
    melanoma %&gt;%
      coxphmulti(dependent_coxph, explanatory) %&gt;%
      fit2df(estimate_suffix = " (Cox PH multivariable)")
    ) %&gt;%
  ff_merge(
    melanoma %&gt;%
      crrmulti(dependent_crr, explanatory) %&gt;%
      fit2df(estimate_suffix = " (competing risks multivariable)")
    ) %&gt;%
  select(-fit_id, -index) %&gt;%
  dependent_label(melanoma, dependent_crr)
</code></pre>

<hr>
<h2 id='crruni'>Competing risks univariable regression: <code>finalfit</code> model wrapper</h2><span id='topic+crruni'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces univariable Competing Risks
Regression models for a set of explanatory variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crruni(.data, dependent, explanatory, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crruni_+3A_.data">.data</code></td>
<td>
<p>Data frame or tibble.</p>
</td></tr>
<tr><td><code id="crruni_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1: name of survival object in
form <code>Surv(time, status)</code>. <code>Status</code> default values should be 0
censored (e.g. alive), 1 event of interest (e.g. died of disease of
interest), 2 competing event (e.g. died of other cause).</p>
</td></tr>
<tr><td><code id="crruni_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="crruni_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="cmprsk.html#topic+crr">crr</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="cmprsk.html#topic+crr">crr</a></code> with <code>finalfit</code> modelling conventions.
Output can be passed to <code><a href="#topic+fit2df">fit2df</a></code>.
</p>


<h3>Value</h3>

<p>A list of univariable <code><a href="cmprsk.html#topic+crr">crr</a></code> fitted models class
<code>crrlist</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a>, <a href="#topic+finalfit_merge">finalfit_merge</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
melanoma = boot::melanoma
melanoma = melanoma %&gt;%
  mutate(
    # Cox PH to determine cause-specific hazards
    status_coxph = ifelse(status == 2, 0, # "still alive"
      ifelse(status == 1, 1, # "died of melanoma"
        0)), # "died of other causes is censored"
        
    # Fine and Gray to determine subdistribution hazards
    status_crr = ifelse(status == 2, 0, # "still alive"
      ifelse(status == 1, 1, # "died of melanoma"
        2)), # "died of other causes"
    sex = factor(sex),
    ulcer = factor(ulcer)
  )

dependent_coxph = c("Surv(time, status_coxph)")
dependent_crr = c("Surv(time, status_crr)")
explanatory = c("sex", "age", "ulcer")

# Create single well-formatted table
melanoma %&gt;%
  summary_factorlist(dependent_crr, explanatory, column = TRUE, fit_id = TRUE) %&gt;%
  ff_merge(
    melanoma %&gt;%
      coxphmulti(dependent_coxph, explanatory) %&gt;%
      fit2df(estimate_suffix = " (Cox PH multivariable)")
    ) %&gt;%
  ff_merge(
    melanoma %&gt;%
      crrmulti(dependent_crr, explanatory) %&gt;%
      fit2df(estimate_suffix = " (competing risks multivariable)")
    ) %&gt;%
  select(-fit_id, -index) %&gt;%
  dependent_label(melanoma, dependent_crr)
</code></pre>

<hr>
<h2 id='dependent_label'>Make a label for the dependent variable</h2><span id='topic+dependent_label'></span>

<h3>Description</h3>

<p>Can be add dependent label to final results dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dependent_label(df.out, .data, dependent, prefix = "Dependent: ", suffix = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dependent_label_+3A_df.out">df.out</code></td>
<td>
<p>Dataframe (results table) to be altered.</p>
</td></tr>
<tr><td><code id="dependent_label_+3A_.data">.data</code></td>
<td>
<p>Original dataframe.</p>
</td></tr>
<tr><td><code id="dependent_label_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1:  quoted name of depdendent
variable. Can be continuous, a binary factor, or a survival object of form
<code>Surv(time, status)</code></p>
</td></tr>
<tr><td><code id="dependent_label_+3A_prefix">prefix</code></td>
<td>
<p>Prefix for dependent label</p>
</td></tr>
<tr><td><code id="dependent_label_+3A_suffix">suffix</code></td>
<td>
<p>Suffix for dependent label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the label for the dependent variable, if specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
explanatory_multi = c("age.factor", "obstruct.factor")
random_effect = "hospital"
dependent = 'mort_5yr'

# Separate tables
colon_s %&gt;%
	summary_factorlist(dependent, explanatory, fit_id=TRUE) -&gt; example.summary

colon_s %&gt;%
	glmuni(dependent, explanatory) %&gt;%
	fit2df(estimate_suffix=" (univariable)") -&gt; example.univariable

colon_s %&gt;%
	 glmmulti(dependent, explanatory) %&gt;%
	 fit2df(estimate_suffix=" (multivariable)") -&gt; example.multivariable

colon_s %&gt;%
  glmmixed(dependent, explanatory, random_effect) %&gt;%
	 fit2df(estimate_suffix=" (multilevel") -&gt; example.multilevel

# Pipe together
example.summary %&gt;%
  finalfit_merge(example.univariable) %&gt;%
  finalfit_merge(example.multivariable) %&gt;%
	 finalfit_merge(example.multilevel) %&gt;%
	 select(-c(fit_id, index)) %&gt;%
	 dependent_label(colon_s, dependent) -&gt; example.final
  example.final
</code></pre>

<hr>
<h2 id='error_colon_fct_levels'>Errors: colon in factor levels</h2><span id='topic+error_colon_fct_levels'></span>

<h3>Description</h3>

<p>Errors: colon in factor levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error_colon_fct_levels(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="error_colon_fct_levels_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>

<hr>
<h2 id='extract_fit'>Extract model output to dataframe</h2><span id='topic+extract_fit'></span><span id='topic+extract_fit.glm'></span><span id='topic+extract_fit.glmerMod'></span><span id='topic+extract_fit.lm'></span><span id='topic+extract_fit.lmerMod'></span><span id='topic+extract_fit.coxph'></span><span id='topic+extract_fit.crr'></span><span id='topic+extract_fit.coxme'></span><span id='topic+extract_fit.stanfit'></span>

<h3>Description</h3>

<p>Internal function, not usually called directly.
</p>
<p>Internal function, not called directly.
</p>
<p>Internal function, not called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_fit(...)

## S3 method for class 'glm'
extract_fit(
  .data,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  exp = TRUE,
  confint_type = "profile",
  confint_level = 0.95,
  ...
)

## S3 method for class 'glmerMod'
extract_fit(
  .data,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  exp = TRUE,
  confint_type = "Wald",
  confint_level = 0.95,
  ...
)

## S3 method for class 'lm'
extract_fit(
  .data,
  explanatory_name = "explanatory",
  estimate_name = "Coefficient",
  estimate_suffix = "",
  p_name = "p",
  confint_level = 0.95,
  ...
)

## S3 method for class 'lmerMod'
extract_fit(
  .data,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  confint_type = "Wald",
  confint_level = 0.95,
  ...
)

## S3 method for class 'coxph'
extract_fit(
  .data,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  ...
)

## S3 method for class 'crr'
extract_fit(
  .data,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  ...
)

## S3 method for class 'coxme'
extract_fit(
  .data,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  confint_level = 0.95,
  ...
)

## S3 method for class 'stanfit'
extract_fit(
  .data,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  X,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_fit_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
<tr><td><code id="extract_fit_+3A_.data">.data</code></td>
<td>
<p>Model output.</p>
</td></tr>
<tr><td><code id="extract_fit_+3A_explanatory_name">explanatory_name</code></td>
<td>
<p>Name for this column in output.</p>
</td></tr>
<tr><td><code id="extract_fit_+3A_estimate_name">estimate_name</code></td>
<td>
<p>Name for this column in output.</p>
</td></tr>
<tr><td><code id="extract_fit_+3A_estimate_suffix">estimate_suffix</code></td>
<td>
<p>Appeneded to estimate name.</p>
</td></tr>
<tr><td><code id="extract_fit_+3A_p_name">p_name</code></td>
<td>
<p>Name given to p-value estimate</p>
</td></tr>
<tr><td><code id="extract_fit_+3A_confint_type">confint_type</code></td>
<td>
<p>One of <code>c("profile", "default")</code> for GLM
models or <code>c("profile", "Wald", "boot")</code> for <code>glmer/lmer</code> models.
Not implemented for <code>lm, coxph or coxphlist</code>.</p>
</td></tr>
<tr><td><code id="extract_fit_+3A_confint_level">confint_level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
<tr><td><code id="extract_fit_+3A_x">X</code></td>
<td>
<p>Design matrix from Stan modelling procedure.</p>
</td></tr>
</table>

<hr>
<h2 id='extract_labels'>Extract variable labels and names</h2><span id='topic+extract_labels'></span>

<h3>Description</h3>

<p>Extract variable labels and names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_labels(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_labels_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns: first (vname), variabe names; second
(vlabel), variables labels; third (vfill), variable labels and when null
variable names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colon_s %&gt;%
  extract_labels()
</code></pre>

<hr>
<h2 id='extract_variable_label'>Extract variable labels from dataframe</h2><span id='topic+extract_variable_label'></span>

<h3>Description</h3>

<p>Variable labels can be created using <code><a href="#topic+ff_label">ff_label</a></code>. Some functions
strip variable labels (variable attributes), e.g. <code>forcats::fct_recode</code>.
Use this function to create a vector of variable labels from a data frame.
Then use <code><a href="#topic+ff_relabel">ff_relabel</a></code> to relabel variables in data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_variable_label(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_variable_label_+3A_.data">.data</code></td>
<td>
<p>Dataframe containing labelled variables.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>colon_s %&gt;%
  extract_variable_label
</code></pre>

<hr>
<h2 id='ff_column_totals'>Add column totals to <code>summary_factorlist()</code> output</h2><span id='topic+ff_column_totals'></span><span id='topic+finalfit_column_totals'></span>

<h3>Description</h3>

<p>Add column totals to <code>summary_factorlist()</code> output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_column_totals(
  df.in,
  .data,
  dependent,
  na_include_dependent = FALSE,
  percent = TRUE,
  digits = c(1, 0),
  label = NULL,
  prefix = "",
  weights = NULL
)

finalfit_column_totals(
  df.in,
  .data,
  dependent,
  na_include_dependent = FALSE,
  percent = TRUE,
  digits = c(1, 0),
  label = NULL,
  prefix = "",
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_column_totals_+3A_df.in">df.in</code></td>
<td>
<p><code>summary_factorlist()</code> output.</p>
</td></tr>
<tr><td><code id="ff_column_totals_+3A_.data">.data</code></td>
<td>
<p>Data frame used to create <code>summary_factorlist()</code>.</p>
</td></tr>
<tr><td><code id="ff_column_totals_+3A_dependent">dependent</code></td>
<td>
<p>Character. Name of dependent variable.</p>
</td></tr>
<tr><td><code id="ff_column_totals_+3A_na_include_dependent">na_include_dependent</code></td>
<td>
<p>Logical. When TRUE, missing data in the dependent
variable is included in totals.</p>
</td></tr>
<tr><td><code id="ff_column_totals_+3A_percent">percent</code></td>
<td>
<p>Logical. Include percentage.</p>
</td></tr>
<tr><td><code id="ff_column_totals_+3A_digits">digits</code></td>
<td>
<p>Integer length 2. Number of digits for (1) percentage, (2) weighted count.</p>
</td></tr>
<tr><td><code id="ff_column_totals_+3A_label">label</code></td>
<td>
<p>Character. Label for total row.</p>
</td></tr>
<tr><td><code id="ff_column_totals_+3A_prefix">prefix</code></td>
<td>
<p>Character. Prefix for column totals, e.g &quot;N=&quot;.</p>
</td></tr>
<tr><td><code id="ff_column_totals_+3A_weights">weights</code></td>
<td>
<p>Character vector of length 1: name of column to use for weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = 'mort_5yr'
colon_s %&gt;%
 summary_factorlist(dependent, explanatory) %&gt;%
 ff_column_totals(colon_s, dependent)

# Ensure works with missing data in dependent
colon_s = colon_s %&gt;%
 dplyr::mutate(
  mort_5yr = forcats::fct_na_value_to_level(mort_5yr, level = "(Missing)")
 )
 colon_s %&gt;%
 summary_factorlist(dependent, explanatory) %&gt;%
 ff_column_totals(colon_s, dependent)
</code></pre>

<hr>
<h2 id='ff_eval'>Eval for 'lm' and 'glm' model wrappers</h2><span id='topic+ff_eval'></span>

<h3>Description</h3>

<p>Internal function, not called directly. This is in reponse to a long running
issue of the best way to pass 'weights' to 'lm()' and 'glm()'. See here
https://stackoverflow.com/questions/54383414/passing-weights-to-glm-using-rlang
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_eval(.)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_eval_+3A_.">.</code></td>
<td>
</td></tr>
</table>

<hr>
<h2 id='ff_formula'>Generate formula as character string</h2><span id='topic+ff_formula'></span><span id='topic+finalfit_formula'></span>

<h3>Description</h3>

<p>Useful when passing finalfit dependent and explanatory lists to base R
functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_formula(dependent, explanatory, random_effect = NULL)

finalfit_formula(dependent, explanatory, random_effect = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_formula_+3A_dependent">dependent</code></td>
<td>
<p>Optional character vector: name(s) of depdendent
variable(s).</p>
</td></tr>
<tr><td><code id="ff_formula_+3A_explanatory">explanatory</code></td>
<td>
<p>Optional character vector: name(s) of explanatory
variable(s).</p>
</td></tr>
<tr><td><code id="ff_formula_+3A_random_effect">random_effect</code></td>
<td>
<p>Optional character vector: name(s) of random effect
variable(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>explanatory = c("age", "nodes", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"
ff_formula(dependent, explanatory)

explanatory = c("age", "nodes", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"
random_effect = "(age.factor | hospital)"
ff_formula(dependent, explanatory)
</code></pre>

<hr>
<h2 id='ff_glimpse'>Descriptive statistics for dataframe</h2><span id='topic+ff_glimpse'></span><span id='topic+finalfit_glimpse'></span>

<h3>Description</h3>

<p>Everyone has a funcion like this, str, glimpse, glance etc. This one is
specifically designed for use with <code>finalfit</code> language. It is different
in dividing variables by numeric vs factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_glimpse(
  .data,
  dependent = NULL,
  explanatory = NULL,
  digits = 1,
  levels_cut = 5
)

finalfit_glimpse(
  .data,
  dependent = NULL,
  explanatory = NULL,
  digits = 1,
  levels_cut = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_glimpse_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="ff_glimpse_+3A_dependent">dependent</code></td>
<td>
<p>Optional character vector: name(s) of depdendent
variable(s).</p>
</td></tr>
<tr><td><code id="ff_glimpse_+3A_explanatory">explanatory</code></td>
<td>
<p>Optional character vector: name(s) of explanatory
variable(s).</p>
</td></tr>
<tr><td><code id="ff_glimpse_+3A_digits">digits</code></td>
<td>
<p>Significant digits for continuous variable summaries</p>
</td></tr>
<tr><td><code id="ff_glimpse_+3A_levels_cut">levels_cut</code></td>
<td>
<p>Max number of factor levels to include in factor levels
summary (in order to avoid the long printing of variables with many
factors).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe on summary data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
dependent = 'mort_5yr'
explanatory = c("age", "nodes", "age.factor", "extent.factor", "perfor.factor")
colon_s %&gt;%
  finalfit_glimpse(dependent, explanatory)
</code></pre>

<hr>
<h2 id='ff_interaction'>Make an interaction variable and add to dataframe</h2><span id='topic+ff_interaction'></span><span id='topic+finalfit_interaction'></span>

<h3>Description</h3>

<p>Combine two factor variables to make an interaction variable. Factor level
order is determined by the order in the variables themselves. Note, names of
the factor variables should not be quoted. The name of the variable is
created from the names of the two factors. The variable is also
labelled with a name derived from any pre-existing labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_interaction(.data, ..., levels_sep = "_", var_sep = "_", label_sep = ":")

finalfit_interaction(
  .data,
  ...,
  levels_sep = "_",
  var_sep = "_",
  label_sep = ":"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_interaction_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="ff_interaction_+3A_...">...</code></td>
<td>
<p>The unquoted names of two factors.</p>
</td></tr>
<tr><td><code id="ff_interaction_+3A_levels_sep">levels_sep</code></td>
<td>
<p>Quoted character: how levels are separated in new variable.</p>
</td></tr>
<tr><td><code id="ff_interaction_+3A_var_sep">var_sep</code></td>
<td>
<p>Quoted character: how variable name is separated.</p>
</td></tr>
<tr><td><code id="ff_interaction_+3A_label_sep">label_sep</code></td>
<td>
<p>Quoted character: how variable label is separated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Original data frame with new variable added via 'dplyr::mutate'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
colon_s %&gt;%
  ff_interaction(sex.factor, perfor.factor) %&gt;%
    summary_factorlist("mort_5yr", "sex.factor_perfor.factor")
</code></pre>

<hr>
<h2 id='ff_label'>Label a variable</h2><span id='topic+ff_label'></span><span id='topic+finalfit_label'></span>

<h3>Description</h3>

<p>Label a variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_label(.var, variable_label)

finalfit_label(.var, variable_label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_label_+3A_.var">.var</code></td>
<td>
<p>Quoted variable name</p>
</td></tr>
<tr><td><code id="ff_label_+3A_variable_label">variable_label</code></td>
<td>
<p>Quoted variable label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Labelled variable
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_variable_label">extract_variable_label</a></code> <code><a href="#topic+ff_relabel">ff_relabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colon_s$sex.factor %&gt;%
  ff_label("Sex") %&gt;%
  str()
</code></pre>

<hr>
<h2 id='ff_merge'>Merge a <code><a href="#topic+summary_factorlist">summary_factorlist</a>()</code> table with any number of model
results tables.</h2><span id='topic+ff_merge'></span><span id='topic+finalfit_merge'></span>

<h3>Description</h3>

<p>A function that takes the output from <code><a href="#topic+summary_factorlist">summary_factorlist</a>(...,
fit_id=TRUE)</code> and merges with any number of model dataframes, usually
produced with a model wrapper followed by the <code><a href="#topic+fit2df">fit2df</a>()</code> function
(see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_merge(
  factorlist,
  fit2df_df,
  ref_symbol = "-",
  estimate_name = NULL,
  last_merge = FALSE
)

finalfit_merge(
  factorlist,
  fit2df_df,
  ref_symbol = "-",
  estimate_name = NULL,
  last_merge = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_merge_+3A_factorlist">factorlist</code></td>
<td>
<p>Output from <code><a href="#topic+summary_factorlist">summary_factorlist</a>(...,
fit_id=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="ff_merge_+3A_fit2df_df">fit2df_df</code></td>
<td>
<p>Output from model wrappers followed by
<code><a href="#topic+fit2df">fit2df</a>()</code>.</p>
</td></tr>
<tr><td><code id="ff_merge_+3A_ref_symbol">ref_symbol</code></td>
<td>
<p>Reference symbol for model reference levels, typically &quot;-&quot;
or &quot;1.0&quot;.</p>
</td></tr>
<tr><td><code id="ff_merge_+3A_estimate_name">estimate_name</code></td>
<td>
<p>If you have chosen a new 'estimate name' (e.g. &quot;Odds
ratio&quot;) when running a model wrapper (e.g. 'glmuni'), then you need to pass
this new name to 'finalfit_merge' to generate correct table. Defaults to
OR/HR/Coefficient</p>
</td></tr>
<tr><td><code id="ff_merge_+3A_last_merge">last_merge</code></td>
<td>
<p>Logical. Set to try for the final merge in a series to
remove index and fit_id columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe of combined tables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary_factorlist">summary_factorlist</a></code> <code><a href="#topic+fit2df">fit2df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
explanatory_multi = c("age.factor", "obstruct.factor")
random_effect = "hospital"
dependent = "mort_5yr"

# Create separate tables
colon_s %&gt;%
 summary_factorlist(dependent, explanatory, fit_id=TRUE) -&gt; example.summary

colon_s %&gt;%
 glmuni(dependent, explanatory) %&gt;%
 fit2df(estimate_suffix=" (univariable)") -&gt; example.univariable

colon_s %&gt;%
 glmmulti(dependent, explanatory) %&gt;%
 fit2df(estimate_suffix=" (multivariable)") -&gt; example.multivariable

colon_s %&gt;%
 glmmixed(dependent, explanatory, random_effect) %&gt;%
 fit2df(estimate_suffix=" (multilevel)") -&gt; example.multilevel

# Pipe together
example.summary %&gt;%
 ff_merge(example.univariable) %&gt;%
 ff_merge(example.multivariable) %&gt;%
 ff_merge(example.multilevel, last_merge = TRUE)

# Using finalfit()
colon_s %&gt;%
 finalfit(dependent, explanatory, keep_fit_id = TRUE) %&gt;%
 ff_merge(example.multilevel, last_merge = TRUE)
</code></pre>

<hr>
<h2 id='ff_metrics'>Generate common metrics for regression model results</h2><span id='topic+ff_metrics'></span><span id='topic+ff_metrics.lm'></span><span id='topic+ff_metrics.lmlist'></span><span id='topic+ff_metrics.glm'></span><span id='topic+ff_metrics.glmlist'></span><span id='topic+ff_metrics.lmerMod'></span><span id='topic+ff_metrics.glmerMod'></span><span id='topic+ff_metrics.coxph'></span><span id='topic+ff_metrics.coxphlist'></span>

<h3>Description</h3>

<p>Generate common metrics for regression model results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_metrics(.data)

## S3 method for class 'lm'
ff_metrics(.data)

## S3 method for class 'lmlist'
ff_metrics(.data)

## S3 method for class 'glm'
ff_metrics(.data)

## S3 method for class 'glmlist'
ff_metrics(.data)

## S3 method for class 'lmerMod'
ff_metrics(.data)

## S3 method for class 'glmerMod'
ff_metrics(.data)

## S3 method for class 'coxph'
ff_metrics(.data)

## S3 method for class 'coxphlist'
ff_metrics(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_metrics_+3A_.data">.data</code></td>
<td>
<p>Model output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model metrics vector for output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)

# glm
fit = glm(mort_5yr ~  age.factor + sex.factor + obstruct.factor + perfor.factor,
  data=colon_s, family="binomial")
fit %&gt;%
  ff_metrics()

# glmlist
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"
colon_s %&gt;%
  glmmulti(dependent, explanatory) %&gt;%
  ff_metrics()

# glmerMod
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
random_effect = "hospital"
dependent = "mort_5yr"
colon_s %&gt;%
  glmmixed(dependent, explanatory, random_effect) %&gt;%
  ff_metrics()

# lm
fit = lm(nodes ~  age.factor + sex.factor + obstruct.factor + perfor.factor,
  data=colon_s)
fit %&gt;%
  ff_metrics()

# lmerMod
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
random_effect = "hospital"
dependent = "nodes"

colon_s %&gt;%
  lmmixed(dependent, explanatory, random_effect) %&gt;%
  ff_metrics()

# coxphlist
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "Surv(time, status)"


colon_s %&gt;%
  coxphmulti(dependent, explanatory) %&gt;%
  ff_metrics()

# coxph
fit = survival::coxph(survival::Surv(time, status) ~ age.factor + sex.factor +
  obstruct.factor + perfor.factor,
  data = colon_s)

fit %&gt;%
  ff_metrics()
</code></pre>

<hr>
<h2 id='ff_newdata'>Generate newdata for simulations</h2><span id='topic+ff_newdata'></span><span id='topic+finalfit_newdata'></span>

<h3>Description</h3>

<p>Generate newdata while respecting the variable types and factor levels in the
primary data frame used to run model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_newdata(
  .data,
  dependent = NULL,
  explanatory = NULL,
  rowwise = TRUE,
  newdata
)

finalfit_newdata(
  .data,
  dependent = NULL,
  explanatory = NULL,
  rowwise = TRUE,
  newdata
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_newdata_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="ff_newdata_+3A_dependent">dependent</code></td>
<td>
<p>Optional character vector of length 1:  name of depdendent
variable. Not usually specified in bootstrapping model predictions.</p>
</td></tr>
<tr><td><code id="ff_newdata_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="ff_newdata_+3A_rowwise">rowwise</code></td>
<td>
<p>Logical. Format <code>newdata</code> is provided in.</p>
</td></tr>
<tr><td><code id="ff_newdata_+3A_newdata">newdata</code></td>
<td>
<p>A list of rows or columns coresponding exactly to the order of
explanatory variables. Useful errors generated if requirements not fulfilled</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate model predictions against a specified set of explanatory levels with
bootstrapped confidence intervals. Add a comparison by difference or ratio of
the first row of <code>newdata</code> with all subsequent rows.
</p>


<h3>Value</h3>

<p>A list of multivariable <code><a href="stats.html#topic+glm">glm</a></code> fitted model
outputs. Output is of class <code>glmlist</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot_predict">boot_predict</a></code> <code><a href="#topic+boot_compare">boot_compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See boot_predict.
library(finalfit)
library(dplyr)

# Predict probability of death across combinations of factor levels
explanatory = c("age.factor", "extent.factor", "perfor.factor")
dependent = 'mort_5yr'

# Generate combination of explanatory variable levels rowwise
colon_s %&gt;%
  finalfit_newdata(explanatory = explanatory, newdata = list(
    c("&lt;40 years",  "Submucosa", "No"),
    c("&lt;40 years", "Submucosa", "Yes"),
    c("&lt;40 years", "Adjacent structures", "No"),
    c("&lt;40 years", "Adjacent structures", "Yes")
   )) -&gt; newdata

# Generate combination of explanatory variable levels colwise.
explanatory = c("nodes", "extent.factor", "perfor.factor")
colon_s %&gt;%
  finalfit_newdata(explanatory = explanatory, rowwise = FALSE, newdata = list(
  rep(seq(0, 30), 4),
  c(rep("Muscle", 62), rep("Adjacent structures", 62)),
  c(rep("No", 31), rep("Yes", 31), rep("No", 31), rep("Yes", 31))
)) -&gt; newdata

</code></pre>

<hr>
<h2 id='ff_parse_formula'>Parse a formula to finalfit grammar</h2><span id='topic+ff_parse_formula'></span>

<h3>Description</h3>

<p>Parse a formula to finalfit grammar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_parse_formula(.formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_parse_formula_+3A_.formula">.formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing dependent, explanatory and random effects variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff_parse_formula(mort ~ age + sex + (1 | hospital))
</code></pre>

<hr>
<h2 id='ff_percent_only'>Include only percentages for factors in <code><a href="#topic+summary_factorlist">summary_factorlist</a></code> output</h2><span id='topic+ff_percent_only'></span><span id='topic+finalfit_percent_only'></span>

<h3>Description</h3>

<p>Include only percentages for factors in <code><a href="#topic+summary_factorlist">summary_factorlist</a></code> output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_percent_only(.data)

finalfit_percent_only(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_percent_only_+3A_.data">.data</code></td>
<td>
<p>Output from <code><a href="#topic+finalfit">finalfit</a></code> or similar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = 'mort_5yr'
colon_s %&gt;%
  summary_factorlist(dependent, explanatory) %&gt;%
  ff_percent_only()
</code></pre>

<hr>
<h2 id='ff_permute'>Permuate explanatory variables to produce multiple output tables for common
regression models</h2><span id='topic+ff_permute'></span><span id='topic+finalfit_permute'></span>

<h3>Description</h3>

<p>Permuate explanatory variables to produce multiple output tables for common
regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_permute(
  .data,
  dependent = NULL,
  explanatory_base = NULL,
  explanatory_permute = NULL,
  multiple_tables = FALSE,
  include_base_model = TRUE,
  include_full_model = TRUE,
  base_on_top = TRUE,
  ...
)

finalfit_permute(
  .data,
  dependent = NULL,
  explanatory_base = NULL,
  explanatory_permute = NULL,
  multiple_tables = FALSE,
  include_base_model = TRUE,
  include_full_model = TRUE,
  base_on_top = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_permute_+3A_.data">.data</code></td>
<td>
<p>Data frame or tibble.</p>
</td></tr>
<tr><td><code id="ff_permute_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1:  quoted name of dependent
variable. Can be continuous, a binary factor, or a survival object of form
<code>Surv(time, status)</code>.</p>
</td></tr>
<tr><td><code id="ff_permute_+3A_explanatory_base">explanatory_base</code></td>
<td>
<p>Character vector of any length: quoted name(s) of
base model explanatory variables.</p>
</td></tr>
<tr><td><code id="ff_permute_+3A_explanatory_permute">explanatory_permute</code></td>
<td>
<p>Character vector of any length: quoted name(s) of
explanatory variables to permute through models.</p>
</td></tr>
<tr><td><code id="ff_permute_+3A_multiple_tables">multiple_tables</code></td>
<td>
<p>Logical. Multiple model tables as a list, or a single
table including multiple models.</p>
</td></tr>
<tr><td><code id="ff_permute_+3A_include_base_model">include_base_model</code></td>
<td>
<p>Logical. Include model using <code>explanatory_base</code>
variables only.</p>
</td></tr>
<tr><td><code id="ff_permute_+3A_include_full_model">include_full_model</code></td>
<td>
<p>Logical. Include model using all <code>explanatory_base</code>
and <code>explanatory_permute</code> variables.</p>
</td></tr>
<tr><td><code id="ff_permute_+3A_base_on_top">base_on_top</code></td>
<td>
<p>Logical. Base variables at top of table, or bottom of
table.</p>
</td></tr>
<tr><td><code id="ff_permute_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+finalfit">finalfit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of data frame with the final model table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>explanatory_base = c("age.factor", "sex.factor")
explanatory_permute = c("obstruct.factor", "perfor.factor", "node4.factor")

# Linear regression
colon_s %&gt;%
  finalfit_permute("nodes", explanatory_base, explanatory_permute)

# Cox proportional hazards regression
colon_s %&gt;%
  finalfit_permute("Surv(time, status)", explanatory_base, explanatory_permute)

# Logistic regression
# colon_s %&gt;%
#   finalfit_permute("mort_5yr", explanatory_base, explanatory_permute)

# Logistic regression with random effect (glmer)
# colon_s %&gt;%
#   finalfit_permute("mort_5yr", explanatory_base, explanatory_permute,
#     random_effect = "hospital")
</code></pre>

<hr>
<h2 id='ff_plot'>Produce a table and plot</h2><span id='topic+ff_plot'></span><span id='topic+finalfit_plot'></span>

<h3>Description</h3>

<p>Wraps <code><a href="#topic+or_plot">or_plot</a></code>, <code><a href="#topic+hr_plot">hr_plot</a></code>, and
<code><a href="#topic+coefficient_plot">coefficient_plot</a></code> and sends to the appropriate method depending
on the dependent variable type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_plot(.data, dependent, explanatory, ...)

finalfit_plot(.data, dependent, explanatory, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_plot_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="ff_plot_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1.</p>
</td></tr>
<tr><td><code id="ff_plot_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="ff_plot_+3A_...">...</code></td>
<td>
<p>Pass arguments <code><a href="#topic+or_plot">or_plot</a></code>, <code><a href="#topic+hr_plot">hr_plot</a></code>, or
<code><a href="#topic+coefficient_plot">coefficient_plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table and a plot using <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>
</p>


<h3>See Also</h3>

<p>Other finalfit plot functions: 
<code><a href="#topic+coefficient_plot">coefficient_plot</a>()</code>,
<code><a href="#topic+hr_plot">hr_plot</a>()</code>,
<code><a href="#topic+or_plot">or_plot</a>()</code>,
<code><a href="#topic+surv_plot">surv_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Coefficient plot
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "nodes"
colon_s %&gt;%
	ff_plot(dependent, explanatory)

# Odds ratio plot
dependent = "mort_5yr"
colon_s %&gt;%
	ff_plot(dependent, explanatory)

	# Hazard ratio plot	
dependent = "Surv(time, status)"
colon_s %&gt;%
	ff_plot(dependent, explanatory, dependent_label = "Survival")
</code></pre>

<hr>
<h2 id='ff_relabel'>Relabel variables in a data frame</h2><span id='topic+ff_relabel'></span><span id='topic+finalfit_relabel'></span>

<h3>Description</h3>

<p>Variable labels can be created using <code><a href="#topic+ff_label">ff_label</a></code>. Some functions
strip variable labels (variable attributes), e.g. <code>forcats::fct_recode</code>.
Use this function to create a vector of variable labels from a data frame.
Then use <code><a href="#topic+ff_relabel">ff_relabel</a></code> to relabel variables in data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_relabel(.data, .labels)

finalfit_relabel(.data, .labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_relabel_+3A_.data">.data</code></td>
<td>
<p>Data frame to be relabelled</p>
</td></tr>
<tr><td><code id="ff_relabel_+3A_.labels">.labels</code></td>
<td>
<p>Vector of variable labels (usually created using
<code><a href="#topic+extract_variable_label">extract_variable_label</a></code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Label variable
colon_s$sex.factor %&gt;%
  ff_label("Sex") %&gt;%
  str()

# Make factor level "Unknown" NA
colon_s %&gt;%
  dplyr::mutate_if(is.factor, forcats::fct_recode, 
  NULL = "Unknown") %&gt;% 
  str()

# Reset data
data(colon_s)

# Extract variable labels
vlabels = colon_s %&gt;% extract_variable_label()

# Run function where labels are lost
colon_s %&gt;%
  dplyr::mutate_if(is.factor, forcats::fct_recode, 
  NULL = "Unknown") %&gt;% 
  str()

# Relabel
colon_s %&lt;&gt;% ff_relabel(vlabels)
colon_s %&gt;% str()
  
</code></pre>

<hr>
<h2 id='ff_relabel_df'>Relabel variables from data frame after tidyverse functions</h2><span id='topic+ff_relabel_df'></span><span id='topic+finalfit_relabel_df'></span>

<h3>Description</h3>

<p>Relabel variables from data frame after tidyverse functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_relabel_df(.data, .df)

finalfit_relabel_df(.data, .df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_relabel_df_+3A_.data">.data</code></td>
<td>
<p>Data frame or tibble after applicaton of label stripping functions.</p>
</td></tr>
<tr><td><code id="ff_relabel_df_+3A_.df">.df</code></td>
<td>
<p>Original data frame which contains labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame or tibble
</p>

<hr>
<h2 id='ff_remove_p'>Remove p-value from output</h2><span id='topic+ff_remove_p'></span><span id='topic+finalfit_remove_p'></span>

<h3>Description</h3>

<p>This will work with <code><a href="#topic+finalfit">finalfit</a></code> and any <code><a href="#topic+fit2df">fit2df</a></code>
output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_remove_p(.data)

finalfit_remove_p(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_remove_p_+3A_.data">.data</code></td>
<td>
<p>Output from <code><a href="#topic+finalfit">finalfit</a></code> or similar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = 'mort_5yr'
colon_s %&gt;%
  finalfit(dependent, explanatory) %&gt;%
  ff_remove_p()
</code></pre>

<hr>
<h2 id='ff_remove_ref'>Remove regression reference level row from table</h2><span id='topic+ff_remove_ref'></span><span id='topic+finalfit_remove_ref'></span>

<h3>Description</h3>

<p>This looks for a column with a name including &quot;Coefficient&quot;, &quot;OR&quot;, or &quot;HR&quot;
(<code><a href="#topic+finalfit">finalfit</a></code> defaults) and removes any rows with &quot;-&quot; (the default
for the reference level). Can also be combined to produce an
<code><a href="#topic+or_plot">or_plot</a></code>, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_remove_ref(.data, only_binary = TRUE)

finalfit_remove_ref(.data, only_binary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_remove_ref_+3A_.data">.data</code></td>
<td>
<p>Output from <code><a href="#topic+finalfit">finalfit</a></code> or similar.</p>
</td></tr>
<tr><td><code id="ff_remove_ref_+3A_only_binary">only_binary</code></td>
<td>
<p>Logical. Remove reference level only for two-level
factors. When set to false, reference level for all factors removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Table example
explanatory = c("age.factor", "age", "sex.factor", "nodes", "obstruct.factor", "perfor.factor")
dependent = 'mort_5yr'
colon_s %&gt;%
	 finalfit(dependent, explanatory, add_dependent_label = FALSE) %&gt;%
	 ff_remove_ref() %&gt;%
	 dependent_label(colon_s, dependent)

# Plot example
explanatory = c("age.factor", "age", "sex.factor", "nodes", "obstruct.factor", "perfor.factor")
dependent = 'mort_5yr'
colon_s %&gt;%
  summary_factorlist(dependent, explanatory, total_col = TRUE, fit_id=TRUE) %&gt;%
  ff_merge(
    glmuni(colon_s, dependent, explanatory) %&gt;%
    fit2df()) %&gt;%
  ff_remove_ref() %&gt;%
  dplyr::select(-`OR`) -&gt; factorlist_plot

colon_s %&gt;%
   or_plot(dependent, explanatory, factorlist = factorlist_plot)
</code></pre>

<hr>
<h2 id='ff_row_totals'>Add row totals to <code>summary_factorlist()</code> output</h2><span id='topic+ff_row_totals'></span><span id='topic+finalfit_row_totals'></span>

<h3>Description</h3>

<p>This adds a total and missing count to variables. This is useful for
continuous variables. Compare this to <code>summary_factorlist(total_col =
TRUE)</code> which includes a count for each dummy variable as a factor and mean
(sd) or median (iqr) for continuous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_row_totals(
  df.in,
  .data,
  dependent,
  explanatory,
  missing_column = TRUE,
  percent = TRUE,
  digits = 1,
  na_include_dependent = FALSE,
  na_complete_cases = FALSE,
  total_name = "Total N",
  na_name = "Missing N"
)

finalfit_row_totals(
  df.in,
  .data,
  dependent,
  explanatory,
  missing_column = TRUE,
  percent = TRUE,
  digits = 1,
  na_include_dependent = FALSE,
  na_complete_cases = FALSE,
  total_name = "Total N",
  na_name = "Missing N"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_row_totals_+3A_df.in">df.in</code></td>
<td>
<p><code>summary_factorlist()</code> output.</p>
</td></tr>
<tr><td><code id="ff_row_totals_+3A_.data">.data</code></td>
<td>
<p>Data frame used to create <code>summary_factorlist()</code>.</p>
</td></tr>
<tr><td><code id="ff_row_totals_+3A_dependent">dependent</code></td>
<td>
<p>Character. Name of dependent variable.</p>
</td></tr>
<tr><td><code id="ff_row_totals_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="ff_row_totals_+3A_missing_column">missing_column</code></td>
<td>
<p>Logical. Include a column of counts of missing data.</p>
</td></tr>
<tr><td><code id="ff_row_totals_+3A_percent">percent</code></td>
<td>
<p>Logical. Include percentage.</p>
</td></tr>
<tr><td><code id="ff_row_totals_+3A_digits">digits</code></td>
<td>
<p>Integer length 1. Number of digits for percentage.</p>
</td></tr>
<tr><td><code id="ff_row_totals_+3A_na_include_dependent">na_include_dependent</code></td>
<td>
<p>Logical. When TRUE, missing data in the dependent
variable is included in totals.</p>
</td></tr>
<tr><td><code id="ff_row_totals_+3A_na_complete_cases">na_complete_cases</code></td>
<td>
<p>Logical. When TRUE, missing data counts for variables
are for compelte cases across all included variables.</p>
</td></tr>
<tr><td><code id="ff_row_totals_+3A_total_name">total_name</code></td>
<td>
<p>Character. Name of total column.</p>
</td></tr>
<tr><td><code id="ff_row_totals_+3A_na_name">na_name</code></td>
<td>
<p>Character. Name of missing column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = 'mort_5yr'
colon_s %&gt;%
 summary_factorlist(dependent, explanatory) %&gt;%
	ff_row_totals(colon_s, dependent, explanatory)
</code></pre>

<hr>
<h2 id='ff_stratify_helper'>Help making stratified summary_factorlist tables</h2><span id='topic+ff_stratify_helper'></span>

<h3>Description</h3>

<p>Help making stratified summary_factorlist tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff_stratify_helper(df.out, .data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_stratify_helper_+3A_df.out">df.out</code></td>
<td>
<p>Output from <code>summary_factorlist</code></p>
</td></tr>
<tr><td><code id="ff_stratify_helper_+3A_.data">.data</code></td>
<td>
<p>Original data frame used for <code>summary_factorlist</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
explanatory = c("age.factor", "sex.factor")
dependent = "perfor.factor"

# Pick option below
split = "rx.factor"
split = c("rx.factor", "node4.factor")

# Piped function to generate stratified crosstabs table
colon_s %&gt;%
  group_by(!!! syms(split)) %&gt;% #Looks awkward, but avoids unquoted var names
  group_modify(~ summary_factorlist(.x, dependent, explanatory)) %&gt;%
  ff_stratify_helper(colon_s)
</code></pre>

<hr>
<h2 id='finalfit'>Final output tables for common regression models</h2><span id='topic+finalfit'></span><span id='topic+finalfit.lm'></span><span id='topic+finalfit.glm'></span><span id='topic+finalfit.coxph'></span>

<h3>Description</h3>

<p>An &quot;all-in-one&quot; function that takes a single dependent variable with a vector
of explanatory variable names (continuous or categorical variables) to
produce a final table for publication including summary statistics. The
appropriate model is selected on the basis of dependent variable and whether
a random effect is specified.
</p>
<p><code>finalfit.lm</code> method (not called directly)
</p>
<p><code>finalfit.glm</code> method (not called directly)
</p>
<p><code>finalfit.coxph</code> method (not called directly)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalfit(
  .data,
  dependent = NULL,
  explanatory = NULL,
  explanatory_multi = NULL,
  random_effect = NULL,
  formula = NULL,
  model_args = list(),
  weights = NULL,
  cont_cut = 5,
  column = NULL,
  keep_models = FALSE,
  metrics = FALSE,
  add_dependent_label = TRUE,
  dependent_label_prefix = "Dependent: ",
  dependent_label_suffix = "",
  keep_fit_id = FALSE,
  ...
)

finalfit.lm(
  .data,
  dependent,
  explanatory,
  explanatory_multi = NULL,
  random_effect = NULL,
  model_args = NULL,
  weights = NULL,
  cont_cut = 5,
  column = FALSE,
  keep_models = FALSE,
  metrics = FALSE,
  add_dependent_label = TRUE,
  dependent_label_prefix = "Dependent: ",
  dependent_label_suffix = "",
  keep_fit_id = FALSE,
  ...
)

finalfit.glm(
  .data,
  dependent,
  explanatory,
  explanatory_multi = NULL,
  random_effect = NULL,
  model_args = NULL,
  weights = NULL,
  cont_cut = 5,
  column = FALSE,
  keep_models = FALSE,
  metrics = FALSE,
  add_dependent_label = TRUE,
  dependent_label_prefix = "Dependent: ",
  dependent_label_suffix = "",
  keep_fit_id = FALSE,
  ...
)

finalfit.coxph(
  .data,
  dependent,
  explanatory,
  explanatory_multi = NULL,
  random_effect = NULL,
  model_args = NULL,
  column = TRUE,
  cont_cut = 5,
  keep_models = FALSE,
  metrics = FALSE,
  add_dependent_label = TRUE,
  dependent_label_prefix = "Dependent: ",
  dependent_label_suffix = "",
  keep_fit_id = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finalfit_+3A_.data">.data</code></td>
<td>
<p>Data frame or tibble.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1:  quoted name of dependent
variable. Can be continuous, a binary factor, or a survival object of form
<code>Surv(time, status)</code>.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: quoted name(s) of
explanatory variables.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_explanatory_multi">explanatory_multi</code></td>
<td>
<p>Character vector of any length: quoted name(s) of a
subset of explanatory variables to generate reduced multivariable model
(must only contain variables contained in <code>explanatory</code>).</p>
</td></tr>
<tr><td><code id="finalfit_+3A_random_effect">random_effect</code></td>
<td>
<p>Character vector of length 1, either, (1) name of random
intercept variable, e.g. &quot;var1&quot;, (automatically convered to &quot;(1 | var1)&quot;);
or, (2) the full <code>lme4</code> specification, e.g. &quot;(var1 | var2)&quot;. Note
parenthesis MUST be included in (2) but NOT included in (1).</p>
</td></tr>
<tr><td><code id="finalfit_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to 
that class). Optional instead of standard dependent/explanatory format. 
Do not include if using dependent/explanatory.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_model_args">model_args</code></td>
<td>
<p>List. A list of arguments to pass to 
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="survival.html#topic+coxph">coxph</a></code>.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_weights">weights</code></td>
<td>
<p>Character vector of length 1: quoted name of weights variable. 
Passed to <code><a href="#topic+summary_factorlist">summary_factorlist</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, and <code><a href="stats.html#topic+glm">glm</a></code> 
to provide weighted summary table and regression (e.g. IPTW). If wish weighted regression
and non-weighted summary table, pass <code>weights</code> argument within <code>model_args</code>. 
Not available with surival dependent variable.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_cont_cut">cont_cut</code></td>
<td>
<p>Numeric: number of unique values in continuous variable at
which to consider it a factor.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_column">column</code></td>
<td>
<p>Logical: Compute margins by column rather than row.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_keep_models">keep_models</code></td>
<td>
<p>Logical: include full multivariable model in output when
working with reduced multivariable model (<code>explanatory_multi</code>) and/or
mixed effect models (<code>random_effect</code>).</p>
</td></tr>
<tr><td><code id="finalfit_+3A_metrics">metrics</code></td>
<td>
<p>Logical: include useful model metrics in output in
publication format.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_add_dependent_label">add_dependent_label</code></td>
<td>
<p>Add the name of the dependent label to the top
left of table.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_dependent_label_prefix">dependent_label_prefix</code></td>
<td>
<p>Add text before dependent label.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_dependent_label_suffix">dependent_label_suffix</code></td>
<td>
<p>Add text after dependent label.</p>
</td></tr>
<tr><td><code id="finalfit_+3A_keep_fit_id">keep_fit_id</code></td>
<td>
<p>Keep original model output coefficient label (internal).</p>
</td></tr>
<tr><td><code id="finalfit_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+fit2df">fit2df</a></code>:
<code>estimate_name, digits, confint_type, confint_level,
confint_sep</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the final model table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)

# Summary, univariable and multivariable analyses of the form:
# glm(depdendent ~ explanatory, family="binomial")
# lmuni(), lmmulti(), lmmixed(), glmuni(), glmmulti(), glmmixed(), glmmultiboot(),
#   coxphuni(), coxphmulti()

data(colon_s) # Modified from survival::colon
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = 'mort_5yr'
colon_s %&gt;%
  finalfit(dependent, explanatory)

# Multivariable analysis with subset of explanatory
#   variable set used in univariable analysis
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
explanatory_multi = c("age.factor", "obstruct.factor")
dependent = "mort_5yr"
colon_s %&gt;%
  finalfit(dependent, explanatory, explanatory_multi)

# Summary, univariable and multivariable analyses of the form:
# lme4::glmer(dependent ~ explanatory + (1 | random_effect), family="binomial")

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
explanatory_multi = c("age.factor", "obstruct.factor")
random_effect = "hospital"
dependent = "mort_5yr"
# colon_s %&gt;%
#   finalfit(dependent, explanatory, explanatory_multi, random_effect)

# Include model metrics:
colon_s %&gt;%
  finalfit(dependent, explanatory, explanatory_multi,  metrics=TRUE)

# Summary, univariable and multivariable analyses of the form:
# survival::coxph(dependent ~ explanatory)

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "Surv(time, status)"

colon_s %&gt;%
  finalfit(dependent, explanatory)

# Rather than going all-in-one, any number of subset models can
# be manually added on to a summary_factorlist() table using finalfit.merge().
# This is particularly useful when models take a long-time to run or are complicated.

# Note requirement for fit_id=TRUE.
# `fit2df` is a subfunction extracting most common models to a dataframe.

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = 'mort_5yr'
colon_s %&gt;%
  finalfit(dependent, explanatory, metrics=TRUE)

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
explanatory_multi = c("age.factor", "obstruct.factor")
random_effect = "hospital"
dependent = 'mort_5yr'

# Separate tables
colon_s %&gt;%
  summary_factorlist(dependent, explanatory, fit_id=TRUE) -&gt; example.summary

colon_s %&gt;%
  glmuni(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix=" (univariable)") -&gt; example.univariable

colon_s %&gt;%
  glmmulti(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix=" (multivariable)") -&gt; example.multivariable

# Edited as CRAN slow to run these
# colon_s %&gt;%
#   glmmixed(dependent, explanatory, random_effect) %&gt;%
#   fit2df(estimate_suffix=" (multilevel") -&gt; example.multilevel

# Pipe together
example.summary %&gt;%
  finalfit_merge(example.univariable) %&gt;%
  finalfit_merge(example.multivariable, last_merge = TRUE)
# finalfit_merge(example.multilevel)
</code></pre>

<hr>
<h2 id='fit2df'>Extract model fit results to dataframe (generic): <code>finalfit</code> model
extractors</h2><span id='topic+fit2df'></span><span id='topic+fit2df.lm'></span><span id='topic+fit2df.lmlist'></span><span id='topic+fit2df.glm'></span><span id='topic+fit2df.glmboot'></span><span id='topic+fit2df.glmlist'></span><span id='topic+fit2df.svyglmlist'></span><span id='topic+fit2df.lmerMod'></span><span id='topic+fit2df.glmerMod'></span><span id='topic+fit2df.coxph'></span><span id='topic+fit2df.coxphlist'></span><span id='topic+fit2df.crr'></span><span id='topic+fit2df.coxme'></span><span id='topic+fit2df.crrlist'></span><span id='topic+fit2df.stanfit'></span><span id='topic+fit2df.mipo'></span>

<h3>Description</h3>

<p>Takes output from <code>finalfit</code> model wrappers and extracts to a dataframe,
convenient for further processing in preparation for final results table.
</p>
<p><code>fit2df.lm</code> is the model extract method for <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
<p><code>fit2df.lmlist</code> is the model extract method for <code>lmuni</code> and
<code>lmmulti</code>.
</p>
<p><code>fit2df.glm</code> is the model extract method for standard
<code><a href="stats.html#topic+glm">glm</a></code> models, which have not used <code>finalfit</code> model
wrappers.
</p>
<p><code>fit2df.glmboot</code> is the model extract method for <code><a href="#topic+glmmulti_boot">glmmulti_boot</a></code> models.
</p>
<p><code>fit2df.glmlist</code> is the model extract method for <code>glmuni</code> and <code>glmmulti</code>.
</p>
<p><code>fit2df.svyglmlist</code> is the model extract method for <code>svyglmuni</code> and <code>svyglmmulti</code>.
</p>
<p><code>fit2df.lmerMod</code> is the model extract method for standard
<code>lme4::<a href="lme4.html#topic+lmer">lmer</a></code> models and for the
<code>finalfit::<a href="#topic+lmmixed">lmmixed</a></code> model wrapper.
</p>
<p><code>fit2df.glmerMod</code> is the model extract method for standard
<code>lme4::<a href="lme4.html#topic+glmer">glmer</a></code> models and for the
<code>finalfit::<a href="#topic+glmmixed">glmmixed</a></code> model wrapper.
</p>
<p><code>fit2df.coxph</code> is the model extract method for <code>survival::<a href="survival.html#topic+coxph">coxph</a></code>.
</p>
<p><code>fit2df.coxphlist</code> is the model extract method for <code>coxphuni</code> and <code>coxphmulti</code>.
</p>
<p><code>fit2df.crr</code> is the model extract method for <code>cmprsk::<a href="cmprsk.html#topic+crr">crr</a></code>.
</p>
<p><code>fit2df.coxme</code> is the model extract method for <code>eoxme::<a href="coxme.html#topic+coxme">coxme</a></code>.
</p>
<p><code>fit2df.crr</code> is the model extract method for
<code>crruni</code> and <code>crrmulti</code>.
</p>
<p><code>fit2df.stanfit</code> is the model extract method for our standard Bayesian
hierarchical binomial logistic regression models. These models will be fully
documented separately. However this should work for a single or multilevel
Bayesian logistic regression done in Stan, as long as the fixed effects are
specified in the parameters block as a vector named <code>beta</code>, of length
<code>P</code>, where <code>P</code> is the number of fixed effect parameters. e.g.
parameters( vector[P] beta; )
</p>
<p><code>fit2df.mipo</code> is the model extract method for the <code>mipo</code> object
created using <code>mice::pool</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit2df(...)

## S3 method for class 'lm'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "Coefficient",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_level = 0.95,
  confint_sep = " to ",
  ...
)

## S3 method for class 'lmlist'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "Coefficient",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_level = 0.95,
  confint_sep = " to ",
  ...
)

## S3 method for class 'glm'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = TRUE,
  confint_type = "profile",
  confint_level = 0.95,
  confint_sep = "-",
  ...
)

## S3 method for class 'glmboot'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = TRUE,
  confint_level = 0.95,
  confint_sep = "-",
  ...
)

## S3 method for class 'glmlist'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = TRUE,
  confint_type = "profile",
  confint_level = 0.95,
  confint_sep = "-",
  ...
)

## S3 method for class 'svyglmlist'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "Coefficient",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = FALSE,
  confint_type = "profile",
  confint_level = 0.95,
  confint_sep = "-",
  ...
)

## S3 method for class 'lmerMod'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "Coefficient",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_type = "Wald",
  confint_level = 0.95,
  confint_sep = " to ",
  ...
)

## S3 method for class 'glmerMod'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = TRUE,
  confint_type = "Wald",
  confint_level = 0.95,
  confint_sep = "-",
  ...
)

## S3 method for class 'coxph'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'coxphlist'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'crr'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'coxme'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'crrlist'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'stanfit'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'mipo'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "Coefficient",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = FALSE,
  confint_level = 0.95,
  confint_sep = "-",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit2df_+3A_...">...</code></td>
<td>
<p>Other arguments: <code>X</code>: Design matrix from stanfit modelling.
Details documented else where.</p>
</td></tr>
<tr><td><code id="fit2df_+3A_.data">.data</code></td>
<td>
<p>Output from <code>finalfit</code> model wrappers.</p>
</td></tr>
<tr><td><code id="fit2df_+3A_condense">condense</code></td>
<td>
<p>Logical: when true, effect estimates, confidence intervals
and p-values are pasted conveniently together in single cell.</p>
</td></tr>
<tr><td><code id="fit2df_+3A_metrics">metrics</code></td>
<td>
<p>Logical: when true, useful model metrics are extracted.</p>
</td></tr>
<tr><td><code id="fit2df_+3A_remove_intercept">remove_intercept</code></td>
<td>
<p>Logical: remove the results for the intercept term.</p>
</td></tr>
<tr><td><code id="fit2df_+3A_explanatory_name">explanatory_name</code></td>
<td>
<p>Name for this column in output</p>
</td></tr>
<tr><td><code id="fit2df_+3A_estimate_name">estimate_name</code></td>
<td>
<p>Name for this column in output</p>
</td></tr>
<tr><td><code id="fit2df_+3A_estimate_suffix">estimate_suffix</code></td>
<td>
<p>Appeneded to estimate name</p>
</td></tr>
<tr><td><code id="fit2df_+3A_p_name">p_name</code></td>
<td>
<p>Name given to p-value estimate</p>
</td></tr>
<tr><td><code id="fit2df_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round to (1) estimate, (2) confidence
interval limits, (3) p-value.</p>
</td></tr>
<tr><td><code id="fit2df_+3A_confint_level">confint_level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
<tr><td><code id="fit2df_+3A_confint_sep">confint_sep</code></td>
<td>
<p>String to separate confidence intervals, typically &quot;-&quot; or
&quot; to &quot;.</p>
</td></tr>
<tr><td><code id="fit2df_+3A_exp">exp</code></td>
<td>
<p>Currently GLM only. Exponentiate coefficients and confidence
intervals. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="fit2df_+3A_confint_type">confint_type</code></td>
<td>
<p>One of <code>c("profile", "default")</code> for GLM models
(<a href="MASS.html#topic+confint">confint.glm</a>) or <code>c("profile", "Wald", "boot")</code>
for <code>glmer/lmer</code> models (<code><a href="lme4.html#topic+confint.merMod">confint.merMod</a></code>.). Not
implemented for <code>lm, coxph or coxphlist</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fit2df</code> is a generic (S3) function for model extract.
</p>


<h3>Value</h3>

<p>A dataframe of model parameters. When <code>metrics=TRUE</code> output is a
list of two dataframes, one is model parameters, one is model metrics.
length two
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)
library(survival)
# glm
fit = glm(mort_5yr ~  age.factor + sex.factor + obstruct.factor + perfor.factor,
  data=colon_s, family="binomial")
fit %&gt;%
  fit2df(estimate_suffix=" (multivariable)")

# glmlist
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"
colon_s %&gt;%
  glmmulti(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix=" (univariable)")

# glmerMod
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
random_effect = "hospital"
dependent = "mort_5yr"
colon_s %&gt;%
  glmmixed(dependent, explanatory, random_effect) %&gt;%
  fit2df(estimate_suffix=" (multilevel)")

# glmboot
## Note number of draws set to 100 just for speed in this example
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"
colon_s %&gt;%
  glmmulti_boot(dependent, explanatory,  R = 100) %&gt;%
  fit2df(estimate_suffix=" (multivariable (BS CIs))")

# lm
fit = lm(nodes ~  age.factor + sex.factor + obstruct.factor + perfor.factor,
  data=colon_s)
fit %&gt;%
  fit2df(estimate_suffix=" (multivariable)")

# lmerMod
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
random_effect = "hospital"
dependent = "nodes"

colon_s %&gt;%
  lmmixed(dependent, explanatory, random_effect) %&gt;%
  fit2df(estimate_suffix=" (multilevel")

# coxphlist
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "Surv(time, status)"

colon_s %&gt;%
  coxphuni(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix=" (univariable)")

colon_s %&gt;%
  coxphmulti(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix=" (multivariable)")

# coxph
fit = coxph(Surv(time, status) ~ age.factor + sex.factor + obstruct.factor + perfor.factor,
  data = colon_s)

fit %&gt;%
  fit2df(estimate_suffix=" (multivariable)")
	
# crr: competing risks
melanoma = boot::melanoma
melanoma = melanoma %&gt;% 
  mutate(
    status_crr = ifelse(status == 2, 0, # "still alive"
      ifelse(status == 1, 1, # "died of melanoma"
      2)), # "died of other causes" 
    sex = factor(sex),
    ulcer = factor(ulcer)
  )

dependent = c("Surv(time, status_crr)")
explanatory = c("sex", "age", "ulcer")
melanoma %&gt;% 
  summary_factorlist(dependent, explanatory, column = TRUE, fit_id = TRUE) %&gt;% 
  ff_merge(
    melanoma %&gt;% 
      crrmulti(dependent, explanatory) %&gt;% 
      fit2df(estimate_suffix = " (competing risks)")
  ) %&gt;% 
select(-fit_id, -index) %&gt;% 
dependent_label(melanoma, dependent)
</code></pre>

<hr>
<h2 id='format_n_percent'>Format n and percent as a character</h2><span id='topic+format_n_percent'></span>

<h3>Description</h3>

<p>Internal, function, not called directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_n_percent(n, percent, digits, digits_n = 0, na_include = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_n_percent_+3A_n">n</code></td>
<td>
<p>Value</p>
</td></tr>
<tr><td><code id="format_n_percent_+3A_percent">percent</code></td>
<td>
<p>Value</p>
</td></tr>
<tr><td><code id="format_n_percent_+3A_digits">digits</code></td>
<td>
<p>Value</p>
</td></tr>
<tr><td><code id="format_n_percent_+3A_digits_n">digits_n</code></td>
<td>
<p>Value. Used when using weighted frequency counts</p>
</td></tr>
<tr><td><code id="format_n_percent_+3A_na_include">na_include</code></td>
<td>
<p>When proportion missing, include in parentheses?</p>
</td></tr>
</table>

<hr>
<h2 id='glmmixed'>Mixed effects binomial logistic regression models: <code>finalfit</code> model wrapper</h2><span id='topic+glmmixed'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces mixed effects binomial logistic
regression models for a set of explanatory variables against a binary dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmmixed(.data, dependent, explanatory, random_effect, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmmixed_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="glmmixed_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1, name of depdendent variable (must have 2 levels).</p>
</td></tr>
<tr><td><code id="glmmixed_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory variables.</p>
</td></tr>
<tr><td><code id="glmmixed_+3A_random_effect">random_effect</code></td>
<td>
<p>Character vector of length 1, either, (1) name of random
intercept variable, e.g. &quot;var1&quot;, (automatically convered to &quot;(1 | var1)&quot;);
or, (2) the full <code>lme4</code> specification, e.g. &quot;(var1 | var2)&quot;. Note
parenthesis MUST be included in (2) but NOT included in (1).</p>
</td></tr>
<tr><td><code id="glmmixed_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code>lme4::<a href="lme4.html#topic+glmer">glmer</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>lme4::<a href="lme4.html#topic+glmer">glmer</a></code> with <code>finalfit</code> modelling conventions. Output can be
passed to <code><a href="#topic+fit2df">fit2df</a></code>. This is only currently set-up to take a single random effect
as a random intercept. Can be updated in future to allow multiple random intercepts,
random gradients and interactions on random effects if there is a need
</p>


<h3>Value</h3>

<p>A list of multivariable <code>lme4::<a href="lme4.html#topic+glmer">glmer</a></code> fitted model outputs.
Output is of class <code>glmerMod</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a>, <a href="#topic+finalfit_merge">finalfit_merge</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
random_effect = "hospital"
dependent = "mort_5yr"

colon_s %&gt;%
  glmmixed(dependent, explanatory, random_effect) %&gt;%
	 fit2df(estimate_suffix=" (multilevel)")
</code></pre>

<hr>
<h2 id='glmmulti'>Binomial logistic regression multivariable models: <code>finalfit</code> model
wrapper</h2><span id='topic+glmmulti'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces a multivariable binomial
logistic regression model for a set of explanatory variables against a
binary dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmmulti(.data, dependent, explanatory, family = "binomial", weights = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmmulti_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="glmmulti_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1: name of dependent variable
(must have 2 levels).</p>
</td></tr>
<tr><td><code id="glmmulti_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="glmmulti_+3A_family">family</code></td>
<td>
<p>Character vector quoted or unquoted of the error distribution
and link function to be used in the model, see <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="glmmulti_+3A_weights">weights</code></td>
<td>
<p>Character vector of length 1: name of variabe for weighting. 
'Prior weights' to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="glmmulti_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="stats.html#topic+glm">glm</a></code> with <code>finalfit</code> modelling conventions.
Output can be passed to <code><a href="#topic+fit2df">fit2df</a></code>.
</p>


<h3>Value</h3>

<p>A multivariable <code><a href="stats.html#topic+glm">glm</a></code> fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a>, <a href="#topic+finalfit_merge">finalfit_merge</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"

colon_s %&gt;%
	glmmulti(dependent, explanatory) %&gt;%
	fit2df(estimate_suffix=" (multivariable)")

</code></pre>

<hr>
<h2 id='glmmulti_boot'>Binomial logistic regression multivariable models with bootstrapped
confidence intervals: <code>finalfit</code> model wrapper</h2><span id='topic+glmmulti_boot'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces a multivariable binomial logistic
regression models for a set of explanatory variables against a binary
dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmmulti_boot(.data, dependent, explanatory, R = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmmulti_boot_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="glmmulti_boot_+3A_dependent">dependent</code></td>
<td>
<p>Character vector length 1:  name of depdendent variable
(must have 2 levels).</p>
</td></tr>
<tr><td><code id="glmmulti_boot_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="glmmulti_boot_+3A_r">R</code></td>
<td>
<p>Number of draws.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="stats.html#topic+glm">glm</a></code> with <code>finalfit</code> modelling conventions.
<code>boot::<a href="boot.html#topic+boot">boot</a></code> is used to draw bootstrapped confidence
intervals on fixed effect model coefficients. Output can be passed to
<code><a href="#topic+fit2df">fit2df</a></code>.
</p>


<h3>Value</h3>

<p>A multivariable <code><a href="stats.html#topic+glm">glm</a></code> fitted model with
bootstrapped confidence intervals. Output is of class <code>glmboot</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a>, <a href="#topic+finalfit_merge">finalfit_merge</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)
## Note number of draws set to 100 just for speed in this example
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"

colon_s %&gt;%
  glmmulti_boot(dependent, explanatory, R=100) %&gt;%
  fit2df(estimate_suffix="(multivariable (BS CIs))")

</code></pre>

<hr>
<h2 id='glmuni'>Binomial logistic regression univariable models: <code>finalfit</code> model wrapper</h2><span id='topic+glmuni'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces multiple univariable binomial logistic
regression models for a set of explanatory variables against a binary dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmuni(.data, dependent, explanatory, family = "binomial", weights = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmuni_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="glmuni_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1:  name of depdendent variable (must have 2 levels).</p>
</td></tr>
<tr><td><code id="glmuni_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory variables.</p>
</td></tr>
<tr><td><code id="glmuni_+3A_family">family</code></td>
<td>
<p>Character vector quoted or unquoted of the error distribution
and link function to be used in the model, see <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="glmuni_+3A_weights">weights</code></td>
<td>
<p>Character vector of length 1: name of variabe for weighting. 
'Prior weights' to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="glmuni_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="stats.html#topic+glm">glm</a></code> with <code>finalfit</code> modelling conventions. Output can be
passed to <code><a href="#topic+fit2df">fit2df</a></code>.
</p>


<h3>Value</h3>

<p>A list of univariable <code><a href="stats.html#topic+glm">glm</a></code> fitted model outputs.
Output is of class <code>glmlist</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a>, <a href="#topic+finalfit_merge">finalfit_merge</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"

colon_s %&gt;%
	glmuni(dependent, explanatory) %&gt;%
	fit2df(estimate_suffix=" (univariable)")


</code></pre>

<hr>
<h2 id='hr_plot'>Produce a hazard ratio table and plot</h2><span id='topic+hr_plot'></span>

<h3>Description</h3>

<p>Produce hazard ratio table and plot from a Cox Proportional Hazards analysis, <code>survival::coxph()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_plot(
  .data,
  dependent,
  explanatory,
  factorlist = NULL,
  coxfit = NULL,
  remove_ref = FALSE,
  breaks = NULL,
  column_space = c(-0.5, 0, 0.5),
  dependent_label = "Survival",
  prefix = "",
  suffix = ": HR (95% CI, p-value)",
  table_text_size = 4,
  title_text_size = 13,
  plot_opts = NULL,
  table_opts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_plot_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1:  name of survival object in form <code>Surv(time, status)</code>.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory variables.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_factorlist">factorlist</code></td>
<td>
<p>Option to provide output directly from <code><a href="#topic+summary_factorlist">summary_factorlist</a>()</code>.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_coxfit">coxfit</code></td>
<td>
<p>Option to provide output directly from <code>coxphmulti()</code>.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_remove_ref">remove_ref</code></td>
<td>
<p>Logical. Remove reference level for factors.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_breaks">breaks</code></td>
<td>
<p>Manually specify x-axis breaks in format <code>c(0.1, 1, 10)</code>.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_column_space">column_space</code></td>
<td>
<p>Adjust table column spacing.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_dependent_label">dependent_label</code></td>
<td>
<p>Main label for plot.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_prefix">prefix</code></td>
<td>
<p>Plots are titled by default with the dependent variable. This adds text before that label.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_suffix">suffix</code></td>
<td>
<p>Plots are titled with the dependent variable. This adds text after that label.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_table_text_size">table_text_size</code></td>
<td>
<p>Alter font size of table text.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_title_text_size">title_text_size</code></td>
<td>
<p>Alter font size of title text.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_plot_opts">plot_opts</code></td>
<td>
<p>A list of arguments to be appended to the ggplot call by &quot;+&quot;.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_table_opts">table_opts</code></td>
<td>
<p>A list of arguments to be appended to the ggplot table call by &quot;+&quot;.</p>
</td></tr>
<tr><td><code id="hr_plot_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>fit2df()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table and plot produced in <code>ggplot2</code>.
</p>


<h3>See Also</h3>

<p>Other finalfit plot functions: 
<code><a href="#topic+coefficient_plot">coefficient_plot</a>()</code>,
<code><a href="#topic+ff_plot">ff_plot</a>()</code>,
<code><a href="#topic+or_plot">or_plot</a>()</code>,
<code><a href="#topic+surv_plot">surv_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># HR plot
library(finalfit)
library(dplyr)
library(ggplot2)

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "Surv(time, status)"
colon_s %&gt;%
  hr_plot(dependent, explanatory, dependent_label = "Survival")

colon_s %&gt;%
  hr_plot(dependent, explanatory, dependent_label = "Survival",
    table_text_size=4, title_text_size=14,
    plot_opts=list(xlab("HR, 95% CI"), theme(axis.title = element_text(size=12))))

</code></pre>

<hr>
<h2 id='is.survival'>Test character describes survival object</h2><span id='topic+is.survival'></span>

<h3>Description</h3>

<p>Test character describes survival object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.survival(.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.survival_+3A_.name">.name</code></td>
<td>
<p>Character string to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var_s = "Surv(mort, time)"
is.survival(var_s) #TRUE
var_s = "Sur(mort, time)"
is.survival(var_s) #FALSE
</code></pre>

<hr>
<h2 id='labels_to_column'>Labels to column names</h2><span id='topic+labels_to_column'></span>

<h3>Description</h3>

<p>Labels to column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels_to_column(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_to_column_+3A_.data">.data</code></td>
<td>
<p>Data frame or tibble.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame or tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
colon_s %&gt;% 
  select(sex.factor) %&gt;% 
  labels_to_column()
</code></pre>

<hr>
<h2 id='labels_to_level'>Labels to level</h2><span id='topic+labels_to_level'></span>

<h3>Description</h3>

<p>For use with forcats::fct_relabel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels_to_level(.data, .labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_to_level_+3A_.data">.data</code></td>
<td>
<p>Data frame or tibble.</p>
</td></tr>
<tr><td><code id="labels_to_level_+3A_.labels">.labels</code></td>
<td>
<p>Output from <code>extract_variable_label</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame or tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
vlabels = extract_variable_label(colon_s)
colon_s %&gt;%
 select(sex.factor, obstruct.factor) %&gt;% 
 tidyr::gather() %&gt;% 
 mutate(
  key = forcats::fct_relabel(key, labels_to_level, vlabels)
 )
</code></pre>

<hr>
<h2 id='lmmixed'>Mixed effects linear regression models: <code>finalfit</code> model wrapper</h2><span id='topic+lmmixed'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces mixed effects linear regression
models for a set of explanatory variables against a continuous dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmmixed(.data, dependent, explanatory, random_effect, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmmixed_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="lmmixed_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1, name of depdendent variable
(must be continuous vector).</p>
</td></tr>
<tr><td><code id="lmmixed_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="lmmixed_+3A_random_effect">random_effect</code></td>
<td>
<p>Character vector of length 1, either, (1) name of random
intercept variable, e.g. &quot;var1&quot;, (automatically convered to &quot;(1 | var1)&quot;);
or, (2) the full <code>lme4</code> specification, e.g. &quot;(var1 | var2)&quot;. Note
parenthesis MUST be included in (2)2 but NOT included in (1).</p>
</td></tr>
<tr><td><code id="lmmixed_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code>lme4::<a href="lme4.html#topic+lmer">lmer</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>lme4::<a href="lme4.html#topic+lmer">lmer</a></code> with <code>finalfit</code> modelling
conventions. Output can be passed to <code><a href="#topic+fit2df">fit2df</a></code>. This is only
currently set-up to take a single random effect as a random intercept. Can be
updated in future to allow multiple random intercepts, random gradients and
interactions on random effects if there is a need.
</p>


<h3>Value</h3>

<p>A list of multivariable <code>lme4::<a href="lme4.html#topic+lmer">lmer</a></code> fitted model
outputs. Output is of class <code>lmerMod</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
random_effect = "hospital"
dependent = "nodes"

colon_s %&gt;%
  lmmixed(dependent, explanatory, random_effect) %&gt;%
	 fit2df(estimate_suffix=" (multilevel")
</code></pre>

<hr>
<h2 id='lmmulti'>Linear regression multivariable models: <code>finalfit</code> model wrapper</h2><span id='topic+lmmulti'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces a multivariable linear regression
model for a set of explanatory variables against a continuous dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmmulti(.data, dependent, explanatory, weights = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmmulti_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="lmmulti_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1: name of depdendent variable
(must a continuous vector).</p>
</td></tr>
<tr><td><code id="lmmulti_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="lmmulti_+3A_weights">weights</code></td>
<td>
<p>Character vector of length 1: name of variabe for weighting. 
'Prior weights' to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="lmmulti_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="stats.html#topic+lm">lm</a></code> with <code>finalfit</code> modelling conventions.
Output can be passed to <code><a href="#topic+fit2df">fit2df</a></code>.
</p>


<h3>Value</h3>

<p>A multivariable <code><a href="stats.html#topic+lm">lm</a></code> fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "nodes"

colon_s %&gt;%
  lmmulti(dependent, explanatory) %&gt;%
  fit2df()

</code></pre>

<hr>
<h2 id='lmuni'>Linear regression univariable models: <code>finalfit</code> model wrapper</h2><span id='topic+lmuni'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces multiple univariable linear
regression models for a set of explanatory variables against a continuous dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmuni(.data, dependent, explanatory, weights = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmuni_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="lmuni_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1, name of depdendent variable (must be continuous vector).</p>
</td></tr>
<tr><td><code id="lmuni_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory variables.</p>
</td></tr>
<tr><td><code id="lmuni_+3A_weights">weights</code></td>
<td>
<p>Character vector of length 1: name of variabe for weighting. 
'Prior weights' to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="lmuni_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="stats.html#topic+lm">lm</a></code> with <code>finalfit</code> modelling conventions. Output can be
passed to <code><a href="#topic+fit2df">fit2df</a></code>.
</p>


<h3>Value</h3>

<p>A list of multivariable <code><a href="stats.html#topic+lm">lm</a></code> fitted model outputs.
Output is of class <code>lmlist</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)

explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "nodes"

colon_s %&gt;%
  lmuni(dependent, explanatory) %&gt;%
  fit2df()

</code></pre>

<hr>
<h2 id='metrics_hoslem'>Hosmer-Lemeshow goodness of fit test</h2><span id='topic+metrics_hoslem'></span>

<h3>Description</h3>

<p>Internal, not usually called directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics_hoslem(y, yhat, g = 10, digits = c(2, 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrics_hoslem_+3A_y">y</code></td>
<td>
<p>Observed y, usually of the form <code>fit$y</code>.</p>
</td></tr>
<tr><td><code id="metrics_hoslem_+3A_yhat">yhat</code></td>
<td>
<p>Predicted y_hat, usually for the form <code>fit$fitted</code></p>
</td></tr>
<tr><td><code id="metrics_hoslem_+3A_g">g</code></td>
<td>
<p>Number of bins to calculate quantiles.</p>
</td></tr>
<tr><td><code id="metrics_hoslem_+3A_digits">digits</code></td>
<td>
<p>Number of decimal places of form <code>c(2,3)</code>, where <code>digits[1]</code> is
for chi-sq estimate and <code>digits[2]</code> is for p-value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string of chi-sq result, df, and p-value. Significant
p-value suggests poor fit.
</p>


<h3>Author(s)</h3>

<p>Adapted from Peter Solymos.
</p>


<h3>Source</h3>

<p>https://github.com/psolymos/ResourceSelection/blob/master/R/hoslem.test.R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit = glm(mort_5yr~age.factor+extent.factor, data=colon_s, family="binomial")
metrics_hoslem(fit$y, fit$fitted)
</code></pre>

<hr>
<h2 id='missing_compare'>Compare missing data</h2><span id='topic+missing_compare'></span>

<h3>Description</h3>

<p>Compare missing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_compare(
  .data,
  dependent,
  explanatory,
  p = TRUE,
  na_include = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_compare_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="missing_compare_+3A_dependent">dependent</code></td>
<td>
<p>Variable to test missingness against other variables with.</p>
</td></tr>
<tr><td><code id="missing_compare_+3A_explanatory">explanatory</code></td>
<td>
<p>Variables to have missingness tested against.</p>
</td></tr>
<tr><td><code id="missing_compare_+3A_p">p</code></td>
<td>
<p>Logical: Include null hypothesis statistical test.</p>
</td></tr>
<tr><td><code id="missing_compare_+3A_na_include">na_include</code></td>
<td>
<p>Include missing data in explanatory variables as a factor
level.</p>
</td></tr>
<tr><td><code id="missing_compare_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+summary_factorlist">summary_factorlist</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe comparing missing data in the dependent variable across
explanatory variables. Continuous data are compared with an Analysis of Variance F-test by default. 
Discrete data are compared with a chi-squared test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)

explanatory = c("age", "age.factor", "extent.factor", "perfor.factor")
dependent = "mort_5yr"

colon_s %&gt;%
  ff_glimpse(dependent, explanatory)

colon_s %&gt;%
 missing_pattern(dependent, explanatory)

colon_s %&gt;%
  missing_compare(dependent, explanatory)
</code></pre>

<hr>
<h2 id='missing_df'>Missing values data frame</h2><span id='topic+missing_df'></span>

<h3>Description</h3>

<p>Create a data frame of missing vs. observed values for all variables
provided. <code>Dependent</code> and <code>explanatory</code> are for convenience and are
optional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_df(.data, dependent = NULL, explanatory = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_df_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="missing_df_+3A_dependent">dependent</code></td>
<td>
<p>Character vector. Optional name of dependent variable.</p>
</td></tr>
<tr><td><code id="missing_df_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector. Optional name(s) of explanatory
variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of missing values for all variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colon_s %&gt;%
  missing_df()
</code></pre>

<hr>
<h2 id='missing_glimpse'>Summary of missing values</h2><span id='topic+missing_glimpse'></span>

<h3>Description</h3>

<p>Summary of missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_glimpse(.data, dependent = NULL, explanatory = NULL, digits = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_glimpse_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="missing_glimpse_+3A_dependent">dependent</code></td>
<td>
<p>Optional character vector: name(s) of depdendent
variable(s).</p>
</td></tr>
<tr><td><code id="missing_glimpse_+3A_explanatory">explanatory</code></td>
<td>
<p>Optional character vector: name(s) of explanatory
variable(s).</p>
</td></tr>
<tr><td><code id="missing_glimpse_+3A_digits">digits</code></td>
<td>
<p>Number of decmial places to show for percentage missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colon_s %&gt;%
	missing_glimpse()
</code></pre>

<hr>
<h2 id='missing_pairs'>Missing values pairs plot</h2><span id='topic+missing_pairs'></span>

<h3>Description</h3>

<p>Compare the occurence of missing values in all variables by each other.
Suggest limit the number of variables to a maximum of around six.
<code>Dependent</code> and <code>explanatory</code> are for convenience of variable
selection, are optional, and have no other specific function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_pairs(
  .data,
  dependent = NULL,
  explanatory = NULL,
  use_labels = TRUE,
  title = NULL,
  position = "stack",
  showXAxisPlotLabels = TRUE,
  showYAxisPlotLabels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_pairs_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="missing_pairs_+3A_dependent">dependent</code></td>
<td>
<p>Character vector. Optional name of dependent variable.</p>
</td></tr>
<tr><td><code id="missing_pairs_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector. Optional name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="missing_pairs_+3A_use_labels">use_labels</code></td>
<td>
<p>Use variable label names in plot labelling.</p>
</td></tr>
<tr><td><code id="missing_pairs_+3A_title">title</code></td>
<td>
<p>Character vector. Optional title for plot.</p>
</td></tr>
<tr><td><code id="missing_pairs_+3A_position">position</code></td>
<td>
<p>For discrete variables, choose &quot;stack&quot; or &quot;fill&quot; to show
counts or proportions.</p>
</td></tr>
<tr><td><code id="missing_pairs_+3A_showxaxisplotlabels">showXAxisPlotLabels</code></td>
<td>
<p>Show x-axis plot labels.</p>
</td></tr>
<tr><td><code id="missing_pairs_+3A_showyaxisplotlabels">showYAxisPlotLabels</code></td>
<td>
<p>Show y-axis plot labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot matrix comparing missing values in all variables against each
other.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
explanatory = c("age", "nodes", "age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = 'mort_5yr'
colon_s %&gt;%
  missing_pairs(dependent, explanatory)

## End(Not run)
</code></pre>

<hr>
<h2 id='missing_pattern'>Characterise missing data for <code>finalfit</code> models</h2><span id='topic+missing_pattern'></span>

<h3>Description</h3>

<p>Using <code>finalfit</code> conventions, produces a missing data matrix using
<code><a href="mice.html#topic+md.pattern">md.pattern</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_pattern(
  .data,
  dependent = NULL,
  explanatory = NULL,
  rotate.names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_pattern_+3A_.data">.data</code></td>
<td>
<p>Data frame. Missing values must be coded <code>NA</code>.</p>
</td></tr>
<tr><td><code id="missing_pattern_+3A_dependent">dependent</code></td>
<td>
<p>Character vector usually of length 1, name of depdendent
variable.</p>
</td></tr>
<tr><td><code id="missing_pattern_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="missing_pattern_+3A_rotate.names">rotate.names</code></td>
<td>
<p>Logical. Should the orientation of variable names on plot
should be vertical.</p>
</td></tr>
<tr><td><code id="missing_pattern_+3A_...">...</code></td>
<td>
<p>pass other arguments such as <code>plot = TRUE</code> to
<code><a href="mice.html#topic+md.pattern">md.pattern</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>ncol(x)+1</code> columns, in which each row corresponds
to a missing data pattern (1=observed, 0=missing). Rows and columns are
sorted in increasing amounts of missing information. The last column and
row contain row and column counts, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"

colon_s %&gt;%
	missing_pattern(dependent, explanatory)

</code></pre>

<hr>
<h2 id='missing_plot'>Missing values occurrence plot</h2><span id='topic+missing_plot'></span>

<h3>Description</h3>

<p>Create a plot of missing values by observations on the x-axis and variable on
the y-axis. <code>Dependent</code> and <code>explanatory</code> are for convenience and are optional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_plot(
  .data,
  dependent = NULL,
  explanatory = NULL,
  use_labels = TRUE,
  title = NULL,
  plot_opts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_plot_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="missing_plot_+3A_dependent">dependent</code></td>
<td>
<p>Character vector. Optional name of dependent variable.</p>
</td></tr>
<tr><td><code id="missing_plot_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector. Optional name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="missing_plot_+3A_use_labels">use_labels</code></td>
<td>
<p>Use variable label names in plot labelling.</p>
</td></tr>
<tr><td><code id="missing_plot_+3A_title">title</code></td>
<td>
<p>Character vector. Optional title for plot.</p>
</td></tr>
<tr><td><code id="missing_plot_+3A_plot_opts">plot_opts</code></td>
<td>
<p>A list of arguments to be appended to the ggplot call by
&quot;+&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Heat map of missing values in dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
colon_s %&gt;%
  missing_plot()
</code></pre>

<hr>
<h2 id='missing_predictorMatrix'>Create predictorMatrix for use with mice</h2><span id='topic+missing_predictorMatrix'></span>

<h3>Description</h3>

<p>Create predictorMatrix for use with mice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_predictorMatrix(
  .data,
  drop_from_imputed = NULL,
  drop_from_imputer = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_predictorMatrix_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="missing_predictorMatrix_+3A_drop_from_imputed">drop_from_imputed</code></td>
<td>
<p>Quoted names of variables not to impute.</p>
</td></tr>
<tr><td><code id="missing_predictorMatrix_+3A_drop_from_imputer">drop_from_imputer</code></td>
<td>
<p>Quoted names of variables not to use in imputation
algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix formatted for predictorMatrix argument in mice.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mice)
library(dplyr)

# Create some extra missing data
## Smoking missing completely at random
set.seed(1)
colon_s$smoking_mcar =
  sample(c("Smoker", "Non-smoker", NA),
  dim(colon_s)[1], replace=TRUE,
  prob = c(0.2, 0.7, 0.1)) %&gt;%
  factor() %&gt;%
  ff_label("Smoking (MCAR)")

## Make smoking missing conditional on patient sex
colon_s$smoking_mar[colon_s$sex.factor == "Female"] =
  sample(c("Smoker", "Non-smoker", NA),
	 sum(colon_s$sex.factor == "Female"),
	 replace = TRUE, prob = c(0.1, 0.5, 0.4))

colon_s$smoking_mar[colon_s$sex.factor == "Male"] =
  sample(c("Smoker", "Non-smoker", NA),
	 sum(colon_s$sex.factor == "Male"),
	 replace=TRUE, prob = c(0.15, 0.75, 0.1))
colon_s$smoking_mar = factor(colon_s$smoking_mar)%&gt;%
  ff_label("Smoking (MAR)")

explanatory = c("age", "sex.factor",
  "nodes", "obstruct.factor", "smoking_mar")
dependent = "mort_5yr"

colon_s %&gt;%
select(dependent, explanatory) %&gt;%
  missing_predictorMatrix(drop_from_imputed =
    c("obstruct.factor", "mort_5yr")) -&gt; predM

colon_s %&gt;%
	select(dependent, explanatory) %&gt;%
	mice(m = 2, predictorMatrix = predM) %&gt;% # e.g. m=10 when for real
	# Run logistic regression on each imputed set
	with(glm(formula(ff_formula(dependent, explanatory)),
					 family="binomial")) %&gt;%
	pool() %&gt;%
	summary(conf.int = TRUE, exponentiate = TRUE) %&gt;%
	# Jiggle into finalfit format
	mutate(explanatory_name = rownames(.)) %&gt;%
	select(explanatory_name, estimate, `2.5 %`, `97.5 %`, p.value) %&gt;%
	condense_fit(estimate_suffix = " (multiple imputation)") %&gt;%
	remove_intercept() -&gt; fit_imputed

</code></pre>

<hr>
<h2 id='or_plot'>Produce an odds ratio table and plot</h2><span id='topic+or_plot'></span>

<h3>Description</h3>

<p>Produce an odds ratio table and plot from a <code>glm()</code> or
<code>lme4::glmer()</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>or_plot(
  .data,
  dependent,
  explanatory,
  random_effect = NULL,
  factorlist = NULL,
  glmfit = NULL,
  confint_type = NULL,
  remove_ref = FALSE,
  breaks = NULL,
  column_space = c(-0.5, 0, 0.5),
  dependent_label = NULL,
  prefix = "",
  suffix = ": OR (95% CI, p-value)",
  table_text_size = 4,
  title_text_size = 13,
  plot_opts = NULL,
  table_opts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="or_plot_+3A_.data">.data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1:  name of depdendent variable
(must have 2 levels).</p>
</td></tr>
<tr><td><code id="or_plot_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_random_effect">random_effect</code></td>
<td>
<p>Character vector of length 1, name of random effect variable.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_factorlist">factorlist</code></td>
<td>
<p>Option to provide output directly from
<code><a href="#topic+summary_factorlist">summary_factorlist</a>()</code>.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_glmfit">glmfit</code></td>
<td>
<p>Option to provide output directly from <code><a href="#topic+glmmulti">glmmulti</a>()</code>
and <code><a href="#topic+glmmixed">glmmixed</a>()</code>.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_confint_type">confint_type</code></td>
<td>
<p>One of <code>c("profile", "default")</code> for GLM models or
<code>c("default", "Wald", "profile", "boot")</code> for <code>glmer</code>
models.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_remove_ref">remove_ref</code></td>
<td>
<p>Logical. Remove reference level for factors.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_breaks">breaks</code></td>
<td>
<p>Manually specify x-axis breaks in format <code>c(0.1, 1, 10)</code>.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_column_space">column_space</code></td>
<td>
<p>Adjust table column spacing.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_dependent_label">dependent_label</code></td>
<td>
<p>Main label for plot.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_prefix">prefix</code></td>
<td>
<p>Plots are titled by default with the dependent variable. This
adds text before that label.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_suffix">suffix</code></td>
<td>
<p>Plots are titled with the dependent variable. This adds text
after that label.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_table_text_size">table_text_size</code></td>
<td>
<p>Alter font size of table text.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_title_text_size">title_text_size</code></td>
<td>
<p>Alter font size of title text.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_plot_opts">plot_opts</code></td>
<td>
<p>A list of arguments to be appended to the ggplot call by
&quot;+&quot;.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_table_opts">table_opts</code></td>
<td>
<p>A list of arguments to be appended to the ggplot table call
by &quot;+&quot;.</p>
</td></tr>
<tr><td><code id="or_plot_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table and plot produced in <code>ggplot2</code>.
</p>


<h3>See Also</h3>

<p>Other finalfit plot functions: 
<code><a href="#topic+coefficient_plot">coefficient_plot</a>()</code>,
<code><a href="#topic+ff_plot">ff_plot</a>()</code>,
<code><a href="#topic+hr_plot">hr_plot</a>()</code>,
<code><a href="#topic+surv_plot">surv_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)
library(ggplot2)

# OR plot
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"
colon_s %&gt;%
	 or_plot(dependent, explanatory)

colon_s %&gt;%
  or_plot(dependent, explanatory, table_text_size=4, title_text_size=14,
    plot_opts=list(xlab("OR, 95% CI"), theme(axis.title = element_text(size=12))))
</code></pre>

<hr>
<h2 id='p_tidy'>Round p-values but keep trailing zeros</h2><span id='topic+p_tidy'></span>

<h3>Description</h3>

<p>Internal function, not called directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_tidy(x, digits, prefix = "=")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_tidy_+3A_x">x</code></td>
<td>
<p>Numeric vector of values to round</p>
</td></tr>
<tr><td><code id="p_tidy_+3A_digits">digits</code></td>
<td>
<p>Integer of length one: value to round to.</p>
</td></tr>
<tr><td><code id="p_tidy_+3A_prefix">prefix</code></td>
<td>
<p>Appended in front of values for use with <code>condense_fit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>e.g. for 3 decimal places I want 0.100, not 0.1. Note this function with
convert 0.000 to &lt;0.001. All other values are prefixed with &quot;=&quot; by default
</p>


<h3>Value</h3>

<p>Vector of strings.
</p>

<hr>
<h2 id='plot_title'>Label plot title</h2><span id='topic+plot_title'></span>

<h3>Description</h3>

<p>Not called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_title(.data, dependent, dependent_label, prefix = "", suffix = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_title_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="plot_title_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1: quoted name of dependent
variable. Can be continuous, a binary factor, or a survival object of form
<code>Surv(time, status)</code></p>
</td></tr>
<tr><td><code id="plot_title_+3A_prefix">prefix</code></td>
<td>
<p>Prefix for dependent label</p>
</td></tr>
<tr><td><code id="plot_title_+3A_suffix">suffix</code></td>
<td>
<p>Suffix for dependent label</p>
</td></tr>
</table>

<hr>
<h2 id='print.data.frame.ff'>Print methods for finalfit data frames</h2><span id='topic+print.data.frame.ff'></span>

<h3>Description</h3>

<p>Print methods for finalfit data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame.ff'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.data.frame.ff_+3A_x">x</code></td>
<td>
<p>Data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with no line numbers
</p>

<hr>
<h2 id='remove_intercept'>Remove intercept from model output</h2><span id='topic+remove_intercept'></span>

<h3>Description</h3>

<p>Internal function, not called directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_intercept(.data, intercept_name = "(Intercept)")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_intercept_+3A_.data">.data</code></td>
<td>
<p>Numeric vector of values to round</p>
</td></tr>
<tr><td><code id="remove_intercept_+3A_intercept_name">intercept_name</code></td>
<td>
<p>Name given to interept in model. Should never have to
change from default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of strings.
</p>

<hr>
<h2 id='remove_labels'>Remove variable labels.</h2><span id='topic+remove_labels'></span>

<h3>Description</h3>

<p>Remove variable labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_labels(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_labels_+3A_.data">.data</code></td>
<td>
<p>Data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data frame with variable label attributes removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colon_s %&gt;%
  remove_labels()
</code></pre>

<hr>
<h2 id='rm_duplicate_labels'>Remove duplicate levels within <code><a href="#topic+summary_factorlist">summary_factorlist</a></code>: <code>finalfit</code> helper function</h2><span id='topic+rm_duplicate_labels'></span>

<h3>Description</h3>

<p>Not called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_duplicate_labels(factorlist, na_to_missing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm_duplicate_labels_+3A_factorlist">factorlist</code></td>
<td>
<p>A factorlist intermediary.</p>
</td></tr>
<tr><td><code id="rm_duplicate_labels_+3A_na_to_missing">na_to_missing</code></td>
<td>
<p>Logical: convert <code>NA</code> to 'Missing' when <code>na_include=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>factorlist</code> dataframe.
</p>

<hr>
<h2 id='rm_duplicates'>Remove duplicates and replace</h2><span id='topic+rm_duplicates'></span>

<h3>Description</h3>

<p>Remove duplicates and replace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_duplicates(.var, fromLast = FALSE, replacement = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm_duplicates_+3A_.var">.var</code></td>
<td>
<p>Vector.</p>
</td></tr>
<tr><td><code id="rm_duplicates_+3A_fromlast">fromLast</code></td>
<td>
<p>Logical. Consider duplication from last to first.</p>
</td></tr>
<tr><td><code id="rm_duplicates_+3A_replacement">replacement</code></td>
<td>
<p>Character for what to replace duplicate with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector.
</p>

<hr>
<h2 id='rm_empty_block'>Remove rows where all specified variables are missing</h2><span id='topic+rm_empty_block'></span>

<h3>Description</h3>

<p>It is common to want to remove cases/rows where all variables in a particular set are missing, 
e.g. all symptom variables are missing in a health care dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_empty_block(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm_empty_block_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="rm_empty_block_+3A_...">...</code></td>
<td>
<p>Unquoted variable/column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pretend that we want to remove rows that are missing in group1, group2, and group3 
# but keep rest of dataset. 
colon_s %&gt;% 
  dplyr::mutate(
    group1 = rep(c(NA, 1), length.out = 929),
    group2 = rep(c(NA, 1), length.out = 929),
	 group3 = rep(c(NA, 1), length.out = 929)
  ) %&gt;% 
rm_empty_block(group1, group2, group3) %&gt;% 
  head()
</code></pre>

<hr>
<h2 id='round_tidy'>Round values but keep trailing zeros</h2><span id='topic+round_tidy'></span>

<h3>Description</h3>

<p>e.g. for 3 decimal places I want 1.200, not 1.2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_tidy(x, digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_tidy_+3A_x">x</code></td>
<td>
<p>Numeric vector of values to round</p>
</td></tr>
<tr><td><code id="round_tidy_+3A_digits">digits</code></td>
<td>
<p>Integer of length one: value to round to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>round_tidy(0.01023, 3)
</code></pre>

<hr>
<h2 id='summary_factorlist'>Summarise a set of factors (or continuous variables) by a dependent variable</h2><span id='topic+summary_factorlist'></span>

<h3>Description</h3>

<p>A function that takes a single dependent variable with a vector of
explanatory variable names (continuous or categorical variables) to produce a
summary table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_factorlist(
  .data,
  dependent = NULL,
  explanatory = NULL,
  formula = NULL,
  cont = "mean",
  cont_nonpara = NULL,
  cont_cut = 5,
  cont_range = TRUE,
  p = FALSE,
  p_cont_para = "aov",
  p_cat = "chisq",
  column = TRUE,
  total_col = FALSE,
  orderbytotal = FALSE,
  digits = c(1, 1, 3, 1, 0),
  na_include = FALSE,
  na_include_dependent = FALSE,
  na_complete_cases = FALSE,
  na_to_p = FALSE,
  na_to_prop = TRUE,
  fit_id = FALSE,
  add_dependent_label = FALSE,
  dependent_label_prefix = "Dependent: ",
  dependent_label_suffix = "",
  add_col_totals = FALSE,
  include_col_totals_percent = TRUE,
  col_totals_rowname = NULL,
  col_totals_prefix = "",
  add_row_totals = FALSE,
  include_row_totals_percent = TRUE,
  include_row_missing_col = TRUE,
  row_totals_colname = "Total N",
  row_missing_colname = "Missing N",
  catTest = NULL,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_factorlist_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1:  name of dependent variable (2
to 5 factor levels).</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to 
that class). Optional instead of standard dependent/explanatory format. 
Do not include if using dependent/explanatory.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_cont">cont</code></td>
<td>
<p>Summary for continuous explanatory variables: &quot;mean&quot; (standard
deviation) or &quot;median&quot; (interquartile range). If &quot;median&quot; then
non-parametric hypothesis test performed (see below).</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_cont_nonpara">cont_nonpara</code></td>
<td>
<p>Numeric vector of form e.g. <code>c(1,2)</code>. Specify which
variables to perform non-parametric hypothesis tests on and summarise with
&quot;median&quot;.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_cont_cut">cont_cut</code></td>
<td>
<p>Numeric: number of unique values in continuous variable at
which to consider it a factor.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_cont_range">cont_range</code></td>
<td>
<p>Logical. Median is show with 1st and 3rd quartiles.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_p">p</code></td>
<td>
<p>Logical: Include null hypothesis statistical test.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_p_cont_para">p_cont_para</code></td>
<td>
<p>Character. Continuous variable parametric test. One of
either &quot;aov&quot; (analysis of variance) or &quot;t.test&quot; for Welch two sample
t-test. Note continuous non-parametric test is always Kruskal Wallis
(kruskal.test) which in two-group setting is equivalent to Mann-Whitney U
/Wilcoxon rank sum test.
</p>
<p>For continous dependent and continuous explanatory, the parametric test
p-value returned is for the Pearson correlation coefficient. The
non-parametric equivalent is for the p-value for the Spearman correlation
coefficient.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_p_cat">p_cat</code></td>
<td>
<p>Character. Categorical variable test. One of either &quot;chisq&quot; or
&quot;fisher&quot;.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_column">column</code></td>
<td>
<p>Logical: Compute margins by column rather than row.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_total_col">total_col</code></td>
<td>
<p>Logical: include a total column summing across factor
levels.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_orderbytotal">orderbytotal</code></td>
<td>
<p>Logical: order final table by total column high to low.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round to (1) mean/median, (2) standard
deviation / interquartile range, (3) p-value, (4) count percentage, 
(5) weighted count.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_na_include">na_include</code></td>
<td>
<p>Logical: make explanatory variables missing data explicit
(<code>NA</code>).</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_na_include_dependent">na_include_dependent</code></td>
<td>
<p>Logical: make dependent variable missing data
explicit.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_na_complete_cases">na_complete_cases</code></td>
<td>
<p>Logical: include only rows with complete data.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_na_to_p">na_to_p</code></td>
<td>
<p>Logical: include missing as group in statistical test.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_na_to_prop">na_to_prop</code></td>
<td>
<p>Logical: include missing in calculation of column proportions.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_fit_id">fit_id</code></td>
<td>
<p>Logical: allows merging via <code><a href="#topic+finalfit_merge">finalfit_merge</a></code>.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_add_dependent_label">add_dependent_label</code></td>
<td>
<p>Add the name of the dependent label to the top
left of table.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_dependent_label_prefix">dependent_label_prefix</code></td>
<td>
<p>Add text before dependent label.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_dependent_label_suffix">dependent_label_suffix</code></td>
<td>
<p>Add text after dependent label.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_add_col_totals">add_col_totals</code></td>
<td>
<p>Logical. Include column total n.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_include_col_totals_percent">include_col_totals_percent</code></td>
<td>
<p>Include column percentage of total.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_col_totals_rowname">col_totals_rowname</code></td>
<td>
<p>Logical. Row name for column totals.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_col_totals_prefix">col_totals_prefix</code></td>
<td>
<p>Character. Prefix to column totals, e.g. &quot;N=&quot;.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_add_row_totals">add_row_totals</code></td>
<td>
<p>Logical. Include row totals. Note this differs from
<code>total_col</code> above particularly for continuous explanatory variables.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_include_row_totals_percent">include_row_totals_percent</code></td>
<td>
<p>Include row percentage of total.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_include_row_missing_col">include_row_missing_col</code></td>
<td>
<p>Logical. Include missing data total for each
row. Only used when <code>add_row_totals</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_row_totals_colname">row_totals_colname</code></td>
<td>
<p>Character. Column name for row totals.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_row_missing_colname">row_missing_colname</code></td>
<td>
<p>Character. Column name for missing data totals for
each row.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_cattest">catTest</code></td>
<td>
<p>Deprecated. See <code>p_cat</code> above.</p>
</td></tr>
<tr><td><code id="summary_factorlist_+3A_weights">weights</code></td>
<td>
<p>Character vector of length 1: name of column to use for weights. 
Explanatory continuous variables are multiplied by weights. 
Explanatory categorical variables are counted with a frequency weight (sum(weights)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aims to produce publication-ready summary tables for
categorical or continuous dependent variables. It usually takes a categorical
dependent variable to produce a cross table of counts and proportions
expressed as percentages or summarised continuous explanatory variables.
However, it will take a continuous dependent variable to produce mean
(standard deviation) or median (interquartile range) for use with linear
regression models.
</p>


<h3>Value</h3>

<p>Returns a <code>factorlist</code> dataframe.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a></code> <code><a href="#topic+ff_column_totals">ff_column_totals</a></code>
<code><a href="#topic+ff_row_totals">ff_row_totals</a></code> <code><a href="#topic+ff_label">ff_label</a></code> <code><a href="#topic+ff_glimpse">ff_glimpse</a></code>
<code><a href="#topic+ff_percent_only">ff_percent_only</a></code>. For lots of examples, see <a href="https://finalfit.org/">https://finalfit.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)
# Load example dataset, modified version of survival::colon
data(colon_s)

# Table 1 - Patient demographics ----
explanatory = c("age", "age.factor", "sex.factor", "obstruct.factor")
dependent = "perfor.factor"
colon_s %&gt;%
  summary_factorlist(dependent, explanatory, p=TRUE)

# summary.factorlist() is also commonly used to summarise any number of
# variables by an outcome variable (say dead yes/no).

# Table 2 - 5 yr mortality ----
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"
colon_s %&gt;%
  summary_factorlist(dependent, explanatory)
</code></pre>

<hr>
<h2 id='summary_factorlist_stratified'>Summarise a set of factors (or continuous variables) by a dependent variable</h2><span id='topic+summary_factorlist_stratified'></span>

<h3>Description</h3>

<p>A function that takes a single dependent variable with a vector of
explanatory variable names (continuous or categorical variables) to produce a
summary table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_factorlist_stratified(
  .data,
  ...,
  split,
  colname_sep = "|",
  level_max_length = 10,
  n_common_cols = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_factorlist_stratified_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="summary_factorlist_stratified_+3A_...">...</code></td>
<td>
<p>Arguments to <code><a href="#topic+summary_factorlist">summary_factorlist</a></code>.</p>
</td></tr>
<tr><td><code id="summary_factorlist_stratified_+3A_split">split</code></td>
<td>
<p>Quoted variable name to stratify columns by.</p>
</td></tr>
<tr><td><code id="summary_factorlist_stratified_+3A_colname_sep">colname_sep</code></td>
<td>
<p>Separator for creation of new column name.</p>
</td></tr>
<tr><td><code id="summary_factorlist_stratified_+3A_level_max_length">level_max_length</code></td>
<td>
<p>Maximum name for each factor level contributing to column name.</p>
</td></tr>
<tr><td><code id="summary_factorlist_stratified_+3A_n_common_cols">n_common_cols</code></td>
<td>
<p>Number of common columns in <code><a href="#topic+summary_factorlist">summary_factorlist</a></code> table, usually 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aims to produce publication-ready summary tables for
categorical or continuous dependent variables. It usually takes a categorical
dependent variable to produce a cross table of counts and proportions
expressed as percentages or summarised continuous explanatory variables.
However, it will take a continuous dependent variable to produce mean
(standard deviation) or median (interquartile range) for use with linear
regression models.
Stratify a <code><a href="#topic+summary_factorlist">summary_factorlist</a></code> table (beta testing)
</p>


<h3>Value</h3>

<p>Dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Table 1 - Perforation status stratified by sex ----
explanatory = c("age", "obstruct.factor")
dependent = "perfor.factor"

# Single split
colon_s %&gt;%
  summary_factorlist_stratified(dependent, explanatory, split = c("sex.factor"))

# Double split
colon_s %&gt;%
 summary_factorlist_stratified(dependent, explanatory, split = c("sex.factor", "age.factor"))
</code></pre>

<hr>
<h2 id='summary_mipo'>Call to mice:::summary.mipo</h2><span id='topic+summary_mipo'></span>

<h3>Description</h3>

<p>Not called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_mipo(
  object,
  type = c("tests", "all"),
  conf.int = FALSE,
  conf.level = 0.95,
  exponentiate = FALSE,
  ...
)
</code></pre>

<hr>
<h2 id='surv_plot'>Plot survival curves with number-at-risk table</h2><span id='topic+surv_plot'></span>

<h3>Description</h3>

<p>Produce a survival curve plot and number-at-risk table using <code>survminer::ggsurvplot</code>
and <code>finalfit</code> conventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_plot(.data, dependent, explanatory, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv_plot_+3A_.data">.data</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="surv_plot_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1:  Survival object of the form <code>Surv(time, status)</code>.</p>
</td></tr>
<tr><td><code id="surv_plot_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of max length 2: quoted name(s) of explanatory variables.</p>
</td></tr>
<tr><td><code id="surv_plot_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="survminer.html#topic+ggsurvplot">ggsurvplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table and plot produced in <code>ggplot2</code>.
</p>


<h3>See Also</h3>

<p>Other finalfit plot functions: 
<code><a href="#topic+coefficient_plot">coefficient_plot</a>()</code>,
<code><a href="#topic+ff_plot">ff_plot</a>()</code>,
<code><a href="#topic+hr_plot">hr_plot</a>()</code>,
<code><a href="#topic+or_plot">or_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finalfit)
library(dplyr)

# Survival plot
data(colon_s)
explanatory = c("perfor.factor")
dependent = "Surv(time, status)"
colon_s %&gt;%
  surv_plot(dependent, explanatory, xlab="Time (days)", pval=TRUE, legend="none")

</code></pre>

<hr>
<h2 id='svyglmmulti'>Multivariable survey-weighted generalised linear models</h2><span id='topic+svyglmmulti'></span>

<h3>Description</h3>

<p>Wrapper for <code><a href="survey.html#topic+svyglm">svyglm</a></code>. Fit a generalised linear model to
data from a complex survey design, with inverse-probability weighting and
design-based standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svyglmmulti(design, dependent, explanatory, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svyglmmulti_+3A_design">design</code></td>
<td>
<p>Survey design.</p>
</td></tr>
<tr><td><code id="svyglmmulti_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1: name of depdendent variable
(must have 2 levels).</p>
</td></tr>
<tr><td><code id="svyglmmulti_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="svyglmmulti_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="survey.html#topic+svyglm">svyglm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of univariable fitted model outputs. Output is of class
<code>svyglmlist</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a>, <a href="#topic+finalfit_merge">finalfit_merge</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmuni">svyglmuni</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples taken from survey::svyglm() help page. 

library(survey)
library(dplyr)

data(api)
dependent = "api00"
explanatory = c("ell", "meals", "mobility")

library(survey)
library(dplyr)

data(api)

apistrat = apistrat %&gt;% 
  mutate(
  api00 = ff_label(api00, "API in 2000 (api00)"),
  ell = ff_label(ell, "English language learners (percent)(ell)"),
  meals = ff_label(meals, "Meals eligible (percent)(meals)"),
  mobility = ff_label(mobility, "First year at the school (percent)(mobility)"),
  sch.wide = ff_label(sch.wide, "School-wide target met (sch.wide)")
  )

# Linear example
dependent = "api00"
explanatory = c("ell", "meals", "mobility")

# Stratified design
dstrat = svydesign(id=~1,strata=~stype, weights=~pw, data=apistrat, fpc=~fpc)

# Univariable fit
fit_uni = dstrat %&gt;%
  svyglmuni(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix = " (univariable)")

# Multivariable fit
fit_multi = dstrat %&gt;%
  svyglmmulti(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix = " (multivariable)")

# Pipe together
apistrat %&gt;%
  summary_factorlist(dependent, explanatory, fit_id = TRUE) %&gt;%
  ff_merge(fit_uni) %&gt;% 
  ff_merge(fit_multi) %&gt;% 
  select(-fit_id, -index) %&gt;%
  dependent_label(apistrat, dependent)

# Binomial example
## Note model family needs specified and exponentiation if desired

dependent = "sch.wide"
explanatory = c("ell", "meals", "mobility")

# Univariable fit
fit_uni = dstrat %&gt;%
  svyglmuni(dependent, explanatory, family = "quasibinomial") %&gt;%
  fit2df(exp = TRUE, estimate_name = "OR", estimate_suffix = " (univariable)")

# Multivariable fit
fit_multi = dstrat %&gt;%
  svyglmmulti(dependent, explanatory, family = "quasibinomial") %&gt;%
  fit2df(exp = TRUE, estimate_name = "OR", estimate_suffix = " (multivariable)")

# Pipe together
apistrat %&gt;%
  summary_factorlist(dependent, explanatory, fit_id = TRUE) %&gt;%
  ff_merge(fit_uni) %&gt;% 
  ff_merge(fit_multi) %&gt;% 
  select(-fit_id, -index) %&gt;%
  dependent_label(apistrat, dependent)
</code></pre>

<hr>
<h2 id='svyglmuni'>Univariable survey-weighted generalised linear models</h2><span id='topic+svyglmuni'></span>

<h3>Description</h3>

<p>Wrapper for <code><a href="survey.html#topic+svyglm">svyglm</a></code>. Fit a generalised linear model to
data from a complex survey design, with inverse-probability weighting and
design-based standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svyglmuni(design, dependent, explanatory, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svyglmuni_+3A_design">design</code></td>
<td>
<p>Survey design.</p>
</td></tr>
<tr><td><code id="svyglmuni_+3A_dependent">dependent</code></td>
<td>
<p>Character vector of length 1: name of depdendent variable
(must have 2 levels).</p>
</td></tr>
<tr><td><code id="svyglmuni_+3A_explanatory">explanatory</code></td>
<td>
<p>Character vector of any length: name(s) of explanatory
variables.</p>
</td></tr>
<tr><td><code id="svyglmuni_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="survey.html#topic+svyglm">svyglm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of univariable fitted model outputs. Output is of class
<code>svyglmlist</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit2df">fit2df</a>, <a href="#topic+finalfit_merge">finalfit_merge</a></code>
</p>
<p>Other finalfit model wrappers: 
<code><a href="#topic+coxphmulti">coxphmulti</a>()</code>,
<code><a href="#topic+coxphuni">coxphuni</a>()</code>,
<code><a href="#topic+crrmulti">crrmulti</a>()</code>,
<code><a href="#topic+crruni">crruni</a>()</code>,
<code><a href="#topic+glmmixed">glmmixed</a>()</code>,
<code><a href="#topic+glmmulti_boot">glmmulti_boot</a>()</code>,
<code><a href="#topic+glmmulti">glmmulti</a>()</code>,
<code><a href="#topic+glmuni">glmuni</a>()</code>,
<code><a href="#topic+lmmixed">lmmixed</a>()</code>,
<code><a href="#topic+lmmulti">lmmulti</a>()</code>,
<code><a href="#topic+lmuni">lmuni</a>()</code>,
<code><a href="#topic+svyglmmulti">svyglmmulti</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples taken from survey::svyglm() help page. 

library(survey)
library(dplyr)

data(api)
dependent = "api00"
explanatory = c("ell", "meals", "mobility")

library(survey)
library(dplyr)

data(api)

apistrat = apistrat %&gt;% 
  mutate(
  api00 = ff_label(api00, "API in 2000 (api00)"),
  ell = ff_label(ell, "English language learners (percent)(ell)"),
  meals = ff_label(meals, "Meals eligible (percent)(meals)"),
  mobility = ff_label(mobility, "First year at the school (percent)(mobility)"),
  sch.wide = ff_label(sch.wide, "School-wide target met (sch.wide)")
  )

# Linear example
dependent = "api00"
explanatory = c("ell", "meals", "mobility")

# Stratified design
dstrat = svydesign(id=~1,strata=~stype, weights=~pw, data=apistrat, fpc=~fpc)

# Univariable fit
fit_uni = dstrat %&gt;%
  svyglmuni(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix = " (univariable)")

# Multivariable fit
fit_multi = dstrat %&gt;%
  svyglmmulti(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix = " (multivariable)")

# Pipe together
apistrat %&gt;%
  summary_factorlist(dependent, explanatory, fit_id = TRUE) %&gt;%
  ff_merge(fit_uni) %&gt;% 
  ff_merge(fit_multi) %&gt;% 
  select(-fit_id, -index) %&gt;%
  dependent_label(apistrat, dependent)

# Binomial example
## Note model family needs specified and exponentiation if desired

dependent = "sch.wide"
explanatory = c("ell", "meals", "mobility")

# Univariable fit
fit_uni = dstrat %&gt;%
  svyglmuni(dependent, explanatory, family = "quasibinomial") %&gt;%
  fit2df(exp = TRUE, estimate_name = "OR", estimate_suffix = " (univariable)")

# Multivariable fit
fit_multi = dstrat %&gt;%
  svyglmmulti(dependent, explanatory, family = "quasibinomial") %&gt;%
  fit2df(exp = TRUE, estimate_name = "OR", estimate_suffix = " (multivariable)")

# Pipe together
apistrat %&gt;%
  summary_factorlist(dependent, explanatory, fit_id = TRUE) %&gt;%
  ff_merge(fit_uni) %&gt;% 
  ff_merge(fit_multi) %&gt;% 
  select(-fit_id, -index) %&gt;%
  dependent_label(apistrat, dependent)
</code></pre>

<hr>
<h2 id='variable_type'>Determine type/class of a variable</h2><span id='topic+variable_type'></span>

<h3>Description</h3>

<p>Determine type/class of a variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variable_type(.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable_type_+3A_.var">.var</code></td>
<td>
<p>A vector, data frame column, or equivalent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One of &quot;factor&quot;, &quot;character&quot;, &quot;numeric&quot;, &quot;logical&quot;, &quot;date&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var_d = as.Date("12.03.18", "%d.%m.%y")
var_f = factor(c("yes", "no"))
var_c = c("yes", "no")
var_n = 1:10
var_l = as.logical(c("true", "false"))
variable_type(var_d)
variable_type(var_f)
variable_type(var_c)
variable_type(var_n)
variable_type(var_l)
</code></pre>

<hr>
<h2 id='wcgs'>Western Collaborative Group Study</h2><span id='topic+wcgs'></span>

<h3>Description</h3>

<p>3154 healthy young men aged 39-59 from the San Francisco area were assessed
for their personality type. All were free from coronary heart disease at the
start of the research. Eight and a half years later change in this situation
was recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wcgs)
</code></pre>


<h3>Format</h3>

<p>A data frame with 3154 observations on the following 13 variables.
</p>
 <dl>
<dt><code>id</code></dt><dd><p> Subject ID </p>
</dd> <dt><code>age</code></dt><dd><p> Age: age in
years </p>
</dd> <dt><code>height</code></dt><dd><p> Height: height in inches </p>
</dd>
<dt><code>weight</code></dt><dd><p> Weight: weight in pounds </p>
</dd> <dt><code>sbp</code></dt><dd>
<p>Systolic blood pressure: mmHg </p>
</dd> <dt><code>dbp</code></dt><dd><p> Diastolic blood
pressure: mmHg </p>
</dd> <dt><code>chol</code></dt><dd><p> Cholesterol: mg/100 ml </p>
</dd>
<dt><code>personality</code></dt><dd><p>Personality type/Behavior pattern: a factor with
levels <code>A1</code>, <code>A2</code>, <code>B3</code>, <code>B4</code> </p>
</dd>
<dt><code>personality_2L</code></dt><dd><p> Dichotomous personality type / behavior
pattern: <code>A</code> = aggressive; <code>B</code> = passive </p>
</dd>  <dt><code>ncigs</code></dt><dd>
<p>Smoking: Cigarettes/day </p>
</dd> <dt><code>smoking</code></dt><dd><p> Smoking: <code>No</code>,
<code>Yes</code> </p>
</dd> <dt><code>arcus</code></dt><dd><p> Corneal arcus: <code>No</code>, <code>Yes</code> </p>
</dd>
<dt><code>chd</code></dt><dd><p> Coronary heart disease event: <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>typechd</code></dt><dd><p> coronary heart disease is a factor with levels
<code>No</code>, <code>MI_SD</code> (MI or sudden death), <code>Silent_MI</code>,
<code>Angina</code> </p>
</dd> <dt><code>timechd</code></dt><dd><p> Observation (follow up) time: Days </p>
</dd>
</dl>



<h3>Details</h3>

<p>The WCGS began in 1960 with 3,524 male volunteers who were employed by 11
California companies. Subjects were 39 to 59 years old and free of heart
disease as determined by electrocardiogram. After the initial screening, the
study population dropped to 3,154 and the number of companies to 10 because
of various exclusions. The cohort comprised both blue- and white-collar
employees. At baseline the following information was collected:
socio-demographic including age, education, marital status, income,
occupation; physical and physiological including height, weight, blood
pressure, electrocardiogram, and corneal arcus; biochemical including
cholesterol and lipoprotein fractions; medical and family history and use of
medications; behavioral data including Type A interview, smoking, exercise,
and alcohol use. Later surveys added data on anthropometry, triglycerides,
Jenkins Activity Survey, and caffeine use. Average follow-up continued for
8.5 years with repeat examinations
</p>


<h3>Source</h3>

<p>Statistics for Epidemiology by N. Jewell (2004)
</p>


<h3>References</h3>

<p>Coronary Heart Disease in the Western Collaborative Group Study
Final Follow-up Experience of 8 1/2 Years Ray H. Rosenman, MD; Richard J.
Brand, PhD; C. David Jenkins, PhD; Meyer Friedman, MD; Reuben Straus, MD;
Moses Wurm, MD JAMA. 1975;233(8):872-877.
doi:10.1001/jama.1975.03260080034016.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
