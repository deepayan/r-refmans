<!DOCTYPE html><html><head><title>Help for package circhelp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<script type="text/javascript" src="mathjax-config.js"></script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {circhelp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#circhelp-package'><p>circhelp: Circular Analyses Helper Functions</p></a></li>
<li><a href='#angle_diff_rad'><p>Differences between angles in different circular spaces</p></a></li>
<li><a href='#Bae_Luck_2018_data'><p>Data from a motion estimation task</p></a></li>
<li><a href='#circ_corr'><p>Circular correlation coefficient</p></a></li>
<li><a href='#circ_descr'><p>A set of descriptive statistics for circular data</p></a></li>
<li><a href='#circ_lin_corr'><p>Circular-linear correlation</p></a></li>
<li><a href='#circ_loess'><p>An implementation of circular-linear locally-weighted regression (LOESS)</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></a></li>
<li><a href='#circ_mean_rad'><p>Circular mean</p></a></li>
<li><a href='#circ_sd_rad'><p>Circular standard deviation</p></a></li>
<li><a href='#correct_angle_rad'><p>Get angle value in [-pi, pi] space</p></a></li>
<li><a href='#get_boundary_preds'><p>Get polynomial predictions for values at the boundaries</p></a></li>
<li><a href='#make_plots_of_biases'><p>Plots biases using the data from <code>remove_cardinal_biases</code></p></a></li>
<li><a href='#pad_circ'><p>Pad circular data on both ends</p></a></li>
<li><a href='#Pascucci_et_al_2019_data'><p>Data from an orientation estimation task</p></a></li>
<li><a href='#predict.circ_loess'><p>Compute predictions for circular LOESS</p></a></li>
<li><a href='#remove_cardinal_biases'><p>Remove cardinal biases</p></a></li>
<li><a href='#remove_cardinal_biases_discrete'><p>Remove cardinal biases for data with orientation (color, motion, ...) set in discrete steps</p></a></li>
<li><a href='#vm_kappa_to_circ_sd'><p>Conversion between the circular SD and kappa of von Mises</p></a></li>
<li><a href='#weighted_circ_mean'><p>Weighted circular parameters</p></a></li>
<li><a href='#weighted_sem'><p>Weighted standard error of the mean (SEM_w)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Circular Analyses Helper Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Light-weight functions for computing descriptive statistics in different circular spaces (e.g., 2pi, 180, or 360 degrees), to handle angle-dependent biases, pad circular data, and more. Specifically aimed for psychologists and neuroscientists analyzing circular data. Basic methods are based on Jammalamadaka and SenGupta (2001) &lt;<a href="https://doi.org/10.1142%2F4031">doi:10.1142/4031</a>&gt;, removal of cardinal biases is based on the approach introduced in van Bergen, Ma, Pratte, &amp; Jehee (2015) &lt;<a href="https://doi.org/10.1038%2Fnn.4150">doi:10.1038/nn.4150</a>&gt; and Chetverikov and Jehee (2023) &lt;<a href="https://doi.org/10.1038%2Fs41467-023-43251-w">doi:10.1038/s41467-023-43251-w</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://achetverikov.github.io/circhelp/index.html">https://achetverikov.github.io/circhelp/index.html</a>,
<a href="https://github.com/achetverikov/circhelp">https://github.com/achetverikov/circhelp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/achetverikov/circhelp/issues">https://github.com/achetverikov/circhelp/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), circular, knitr, rmarkdown, BAMBI, mgcv,
ragg</td>
</tr>
<tr>
<td>Imports:</td>
<td>gamlss, MASS, mathjaxr, patchwork</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, data.table, ggplot2, R (&ge; 2.10)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, patchwork, ggplot2, MASS, gamlss, mgcv, ragg</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-04 11:36:14 UTC; anche7026</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrey Chetverikov
    <a href="https://orcid.org/0000-0003-2767-6310"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Eline Van Geert <a href="https://orcid.org/0000-0002-7848-5998"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrey Chetverikov &lt;andrey.chetverikov@uib.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-04 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='circhelp-package'>circhelp: Circular Analyses Helper Functions</h2><span id='topic+circhelp'></span><span id='topic+circhelp-package'></span>

<h3>Description</h3>

<p>Light-weight functions for computing descriptive statistics in different circular spaces (e.g., 2pi, 180, or 360 degrees), to handle angle-dependent biases, pad circular data, and more. Specifically aimed for psychologists and neuroscientists analyzing circular data. Basic methods are based on Jammalamadaka and SenGupta (2001) <a href="https://doi.org/10.1142/4031">doi:10.1142/4031</a>, removal of cardinal biases is based on the approach introduced in van Bergen, Ma, Pratte, &amp; Jehee (2015) <a href="https://doi.org/10.1038/nn.4150">doi:10.1038/nn.4150</a> and Chetverikov and Jehee (2023) <a href="https://doi.org/10.1038/s41467-023-43251-w">doi:10.1038/s41467-023-43251-w</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Andrey Chetverikov <a href="mailto:andrey.chetverikov@uib.no">andrey.chetverikov@uib.no</a> (<a href="https://orcid.org/0000-0003-2767-6310">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Eline Van Geert <a href="mailto:eline.vangeert@kuleuven.be">eline.vangeert@kuleuven.be</a> (<a href="https://orcid.org/0000-0002-7848-5998">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://achetverikov.github.io/circhelp/index.html">https://achetverikov.github.io/circhelp/index.html</a>
</p>
</li>
<li> <p><a href="https://github.com/achetverikov/circhelp">https://github.com/achetverikov/circhelp</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/achetverikov/circhelp/issues">https://github.com/achetverikov/circhelp/issues</a>
</p>
</li></ul>


<hr>
<h2 id='angle_diff_rad'>Differences between angles in different circular spaces</h2><span id='topic+angle_diff_rad'></span><span id='topic+angle_diff_360'></span><span id='topic+angle_diff_180'></span><span id='topic+angle_diff_90'></span><span id='topic+angle_diff_180_45'></span><span id='topic+angle_diff_360_90'></span>

<h3>Description</h3>

<p>Differences between angles in different circular spaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle_diff_rad(a, b)

angle_diff_360(a, b)

angle_diff_180(a, b)

angle_diff_90(a, b)

angle_diff_180_45(a, b)

angle_diff_360_90(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle_diff_rad_+3A_a">a</code></td>
<td>
<p>first angle</p>
</td></tr>
<tr><td><code id="angle_diff_rad_+3A_b">b</code></td>
<td>
<p>second angle</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, all functions return values in Â± half-range space (e.g., -pi to pi for 2pi radian space used by <code>angle_diff_rad()</code>) but <code>angle_diff_180_45()</code> and <code>angle_diff_360_90()</code> return values in [-1/4 range, 3/4 range] space
</p>


<h3>Value</h3>

<p>difference between a and b
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>angle_diff_rad()</code>: angle difference in radians
</p>
</li>
<li> <p><code>angle_diff_360()</code>: angle difference in 360 degree space
</p>
</li>
<li> <p><code>angle_diff_180()</code>: angle difference in 180 degree space (e.g., line orientation)
</p>
</li>
<li> <p><code>angle_diff_90()</code>: angle difference in 90 degree space
</p>
</li>
<li> <p><code>angle_diff_180_45()</code>: angle difference in 180 degree space from -45 to 135
</p>
</li>
<li> <p><code>angle_diff_360_90()</code>: angle difference in 360 degree space from -90 to 270
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>angle_diff_180(5, 175)
angle_diff_360(5, 175)
angle_diff_90(5, 175)
angle_diff_rad(5, 175)

angle_diff_360(300, 0)
angle_diff_360_90(300, 0)
</code></pre>

<hr>
<h2 id='Bae_Luck_2018_data'>Data from a motion estimation task</h2><span id='topic+Bae_Luck_2018_data'></span>

<h3>Description</h3>

<p>A dataset with the motion estimation results from Bae &amp; Luck (2018) available from https://osf.io/4m2kb/ (some variables are removed, see the link for the full dataset).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bae_Luck_2018_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 20480 rows and 8 variables:
</p>

<dl>
<dt>subject_Num</dt><dd><p>observer ID</p>
</dd>
<dt>trial_Num</dt><dd><p>trial number</p>
</dd>
<dt>TargetDirection</dt><dd><p>true motion direction</p>
</dd>
<dt>RespAngle</dt><dd><p>reported motion direction</p>
</dd>
<dt>motionCoh</dt><dd><p>motion coherence</p>
</dd>
<dt>Block</dt><dd><p>block number</p>
</dd>
<dt>Session</dt><dd><p>session number</p>
</dd>
<dt>err</dt><dd><p>estimation error</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://osf.io/4m2kb/download">https://osf.io/4m2kb/download</a>
</p>


<h3>References</h3>


<p>Bae, G.-Y., &amp; Luck, S. J. (2018). Decoding motion direction using the topography of sustained ERPs and alpha oscillations. NeuroImage, 184(August 2018), 242â255. <a href="https://doi.org/10.1016/J.NEUROIMAGE.2018.09.029">doi:10.1016/J.NEUROIMAGE.2018.09.029</a>

</p>

<hr>
<h2 id='circ_corr'>Circular correlation coefficient</h2><span id='topic+circ_corr'></span>

<h3>Description</h3>

<p>Computes a circular correlation coefficient as defined in Jammalamadaka &amp; SenGupta (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_corr(a, b, ill_defined = FALSE, mu = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_corr_+3A_a">a</code></td>
<td>
<p>first variable</p>
</td></tr>
<tr><td><code id="circ_corr_+3A_b">b</code></td>
<td>
<p>second variable</p>
</td></tr>
<tr><td><code id="circ_corr_+3A_ill_defined">ill_defined</code></td>
<td>
<p>is one of the variables mean is not well-defined (e.g., it is uniformly distributed)?</p>
</td></tr>
<tr><td><code id="circ_corr_+3A_mu">mu</code></td>
<td>
<p>fix the mean parameter of both vectors to a certain value</p>
</td></tr>
<tr><td><code id="circ_corr_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be removed before the computation proceeds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>correlation coefficient
</p>


<h3>References</h3>


<p>Jammalamadaka, S. R., &amp; SenGupta, A. (2001). Topics in Circular Statistics. WORLD SCIENTIFIC. <a href="https://doi.org/10.1142/4031">doi:10.1142/4031</a>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("mgcv")
data &lt;- mgcv::rmvn(10000, c(0, 0), V = matrix(c(1, 0.5, 0.5, 1), ncol = 2))
circ_corr(data[, 1], data[, 2])
</code></pre>

<hr>
<h2 id='circ_descr'>A set of descriptive statistics for circular data</h2><span id='topic+circ_descr'></span>

<h3>Description</h3>

<p>A set of descriptive statistics for circular data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_descr(x, w = NULL, d = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_descr_+3A_x">x</code></td>
<td>
<p>vector of angles</p>
</td></tr>
<tr><td><code id="circ_descr_+3A_w">w</code></td>
<td>
<p>weights for the values in the vector</p>
</td></tr>
<tr><td><code id="circ_descr_+3A_d">d</code></td>
<td>
<p>correction for the bias for data with known spacing</p>
</td></tr>
<tr><td><code id="circ_descr_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be removed before the computation proceeds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with descriptive statistics
</p>

<ul>
<li><p> mu - mean
</p>
</li>
<li><p> sigma - standard deviation
</p>
</li>
<li><p> skew_pewsey - skewness as defined by Pewsey
</p>
</li>
<li><p> skew_fischer - skewness as defined by Fischer
</p>
</li>
<li><p> rho - mean resultant length
</p>
</li>
<li><p> skew_rel_to_zero - skewness relative to zero
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(50, 0, 0.5), rnorm(20, 1, 0.5))
circ_descr(x)

</code></pre>

<hr>
<h2 id='circ_lin_corr'>Circular-linear correlation</h2><span id='topic+circ_lin_corr'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Implementation of the circular-linear correlation measure introduced by Mardia (1976) and Johnson and Wehrly (1977) as cited in Jammalamadaka &amp; Sengupta (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_lin_corr(circ_x, lin_x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_lin_corr_+3A_circ_x">circ_x</code></td>
<td>
<p>circular variable</p>
</td></tr>
<tr><td><code id="circ_lin_corr_+3A_lin_x">lin_x</code></td>
<td>
<p>linear variable</p>
</td></tr>
<tr><td><code id="circ_lin_corr_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be removed before the computation proceeds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This measure is computed as \[r^2 = (r_{xc}^2+r_{xs}^2-2 r_{xc} r_{xs}r_{cs})/(1-r_{cs}^2)\] where \(r_{xc} = corr(x, cos(\alpha))\), \(r_{xs} = corr(x, sin(\alpha))\), \(r_{cs} = corr(cos(\alpha), sin(\alpha))\), and \(\alpha\) and \(x\) are the circular and linear variables, respectively.
</p>


<h3>Value</h3>

<p>circular-linear correlation measure
</p>


<h3>References</h3>


<p>Jammalamadaka, S. R., &amp; SenGupta, A. (2001). Topics in Circular Statistics. WORLD SCIENTIFIC. <a href="https://doi.org/10.1142/4031">doi:10.1142/4031</a>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(50)
a &lt;- as.vector(circular::rvonmises(50, 0, 5))
circ_lin_corr(x + a, x)
</code></pre>

<hr>
<h2 id='circ_loess'>An implementation of circular-linear locally-weighted regression (LOESS)
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></h2><span id='topic+circ_loess'></span>

<h3>Description</h3>

<p>Provides an locally-weighted average when the independent variable is circular and depended variable is linear. Mainly to use with ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_loess(
  formula = NULL,
  data = NULL,
  angle = NULL,
  y = NULL,
  xseq = NULL,
  circ_space = NULL,
  span = 0.75,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_loess_+3A_formula">formula</code></td>
<td>
<p>the formula, e.g., y ~ x</p>
</td></tr>
<tr><td><code id="circ_loess_+3A_data">data</code></td>
<td>
<p>data to use</p>
</td></tr>
<tr><td><code id="circ_loess_+3A_angle">angle</code></td>
<td>
<p>a vector of angles (not used if a formula is provided)</p>
</td></tr>
<tr><td><code id="circ_loess_+3A_y">y</code></td>
<td>
<p>dependent variable vector (not used if a formula is provided)</p>
</td></tr>
<tr><td><code id="circ_loess_+3A_xseq">xseq</code></td>
<td>
<p>a grid to compute predictions on (optional, the default is to use 500 points spanning the circle)</p>
</td></tr>
<tr><td><code id="circ_loess_+3A_circ_space">circ_space</code></td>
<td>
<p>circular space to use (90, 180, 360, or 2*pi)</p>
</td></tr>
<tr><td><code id="circ_loess_+3A_span">span</code></td>
<td>
<p>a span to adjust the degree of smoothing</p>
</td></tr>
<tr><td><code id="circ_loess_+3A_...">...</code></td>
<td>
<p>other arguments (ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weights for the regression are computed as
\[w = (1-(d/d_{max})^3)^3\]
where <em>d</em> is the angular difference between the point at which the estimate is computed and the angles in the data, and \(d_{max}\) is the maximum possible distance. If <code>span</code> is above 1, all points are included and \(d_{max} = {circ\_space}/(4*span)\). Otherwise, a proportion \(\alpha\) of the points included based on their distance to the point at which the estimate is computed and \(d_{max}\) is the corresponding maximal distance.
</p>


<h3>Value</h3>

<p>an object of <code>circ_loess</code> class with the following parameters:
</p>

<ul>
<li> <p><code>angle</code> the angles in the data
</p>
</li>
<li> <p><code>y</code> the dependent variable vales in the data
</p>
</li>
<li> <p><code>xseq</code> the grid on which the loess values are estimated
</p>
</li>
<li> <p><code>y_est</code> the estimated loess values
</p>
</li>
<li> <p><code>y_se</code> standard errors
</p>
</li>
<li> <p><code>w</code> weights
</p>
</li>
<li> <p><code>circ_space</code> circular space used
</p>
</li>
<li> <p><code>span</code> span used
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+loess">stats::loess()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(Pascucci_et_al_2019_data, aes(x = orientation, y = err)) +
  geom_point(alpha = 0.05) +
  labs(x = "Orientation, deg.", y = "Error, deg.")
p1 &lt;- p + geom_smooth(method = "loess") + ggtitle("Standard LOESS")
p2 &lt;- p + geom_smooth(method = "circ_loess", method.args = list(circ_space = 180, span = 0.5)) +
  ggtitle("Circular LOESS, span = 0.5")
p3 &lt;- p + geom_smooth(method = "circ_loess", method.args = list(circ_space = 180, span = 0.2)) +
  ggtitle("Circular LOESS, span = 0.2")
(p1 + p2 + p3)

</code></pre>

<hr>
<h2 id='circ_mean_rad'>Circular mean</h2><span id='topic+circ_mean_rad'></span><span id='topic+circ_mean_180'></span><span id='topic+circ_mean_360'></span>

<h3>Description</h3>

<p>Circular mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_mean_rad(x, na.rm = FALSE)

circ_mean_180(x, na.rm = FALSE)

circ_mean_360(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_mean_rad_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="circ_mean_rad_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be removed before the computation proceeds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean of values in the vector
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>circ_mean_rad()</code>: circular mean in 2pi space
</p>
</li>
<li> <p><code>circ_mean_180()</code>: circular mean in 180Â° space (e.g., line orientation)
</p>
</li>
<li> <p><code>circ_mean_360()</code>: circular mean in 360Â° space
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(1000, -pi, pi)
mean(x)
circ_mean_rad(x)

</code></pre>

<hr>
<h2 id='circ_sd_rad'>Circular standard deviation</h2><span id='topic+circ_sd_rad'></span><span id='topic+circ_sd_360'></span><span id='topic+circ_sd_180'></span>

<h3>Description</h3>

<p>Circular standard deviation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_sd_rad(x, na.rm = FALSE)

circ_sd_360(x, na.rm = FALSE)

circ_sd_180(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_sd_rad_+3A_x">x</code></td>
<td>
<p>vector of angles</p>
</td></tr>
<tr><td><code id="circ_sd_rad_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be removed before the computation proceeds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>standard deviation of values in the vector
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>circ_sd_rad()</code>: SD of angles in radians
</p>
</li>
<li> <p><code>circ_sd_360()</code>: SD of angles in 360 degree space
</p>
</li>
<li> <p><code>circ_sd_180()</code>: SD of angles in 180 degree space
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>circ_sd_rad(rnorm(50))
circ_sd_180(rnorm(50))

</code></pre>

<hr>
<h2 id='correct_angle_rad'>Get angle value in [-pi, pi] space</h2><span id='topic+correct_angle_rad'></span>

<h3>Description</h3>

<p>Get angle value in [-pi, pi] space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_angle_rad(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correct_angle_rad_+3A_x">x</code></td>
<td>
<p>angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>angle in [-pi, pi] space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>correct_angle_rad(4 * pi)

</code></pre>

<hr>
<h2 id='get_boundary_preds'>Get polynomial predictions for values at the boundaries</h2><span id='topic+get_boundary_preds'></span>

<h3>Description</h3>

<p>A helper function for <code><a href="#topic+remove_cardinal_biases">remove_cardinal_biases()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_boundary_preds(
  group,
  data,
  space,
  reassign_range,
  gam_ctrl,
  poly_deg,
  angle_diff_fun,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_boundary_preds_+3A_group">group</code></td>
<td>
<p>group (bin) id</p>
</td></tr>
<tr><td><code id="get_boundary_preds_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="get_boundary_preds_+3A_space">space</code></td>
<td>
<p>see <code><a href="#topic+remove_cardinal_biases">remove_cardinal_biases()</a></code></p>
</td></tr>
<tr><td><code id="get_boundary_preds_+3A_reassign_range">reassign_range</code></td>
<td>
<p>see <code><a href="#topic+remove_cardinal_biases">remove_cardinal_biases()</a></code></p>
</td></tr>
<tr><td><code id="get_boundary_preds_+3A_gam_ctrl">gam_ctrl</code></td>
<td>
<p>control object for gam models</p>
</td></tr>
<tr><td><code id="get_boundary_preds_+3A_poly_deg">poly_deg</code></td>
<td>
<p>see <code><a href="#topic+remove_cardinal_biases">remove_cardinal_biases()</a></code></p>
</td></tr>
<tr><td><code id="get_boundary_preds_+3A_angle_diff_fun">angle_diff_fun</code></td>
<td>
<p>a function to compute difference between angles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with predicted values
</p>

<hr>
<h2 id='make_plots_of_biases'>Plots biases using the data from <code>remove_cardinal_biases</code></h2><span id='topic+make_plots_of_biases'></span>

<h3>Description</h3>

<p>Plots biases using the data from <code>remove_cardinal_biases</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_plots_of_biases(data, poly_deg, sd_val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_plots_of_biases_+3A_data">data</code></td>
<td>
<p>data prepared by  <code>remove_cardinal_biases</code></p>
</td></tr>
<tr><td><code id="make_plots_of_biases_+3A_poly_deg">poly_deg</code></td>
<td>
<p>the degree of polynomial</p>
</td></tr>
<tr><td><code id="make_plots_of_biases_+3A_sd_val">sd_val</code></td>
<td>
<p>sd used to determine the outliers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>does not return anything
</p>

<hr>
<h2 id='pad_circ'>Pad circular data on both ends</h2><span id='topic+pad_circ'></span>

<h3>Description</h3>

<p>Pad circular data on both ends
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_circ(
  data,
  circ_var,
  circ_borders = c(-90, 90),
  circ_part = 1/6,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_circ_+3A_data">data</code></td>
<td>
<p>data.table to pad</p>
</td></tr>
<tr><td><code id="pad_circ_+3A_circ_var">circ_var</code></td>
<td>
<p>circular variable</p>
</td></tr>
<tr><td><code id="pad_circ_+3A_circ_borders">circ_borders</code></td>
<td>
<p>range of the circular variable</p>
</td></tr>
<tr><td><code id="pad_circ_+3A_circ_part">circ_part</code></td>
<td>
<p>padding proportion</p>
</td></tr>
<tr><td><code id="pad_circ_+3A_verbose">verbose</code></td>
<td>
<p>print extra info</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pads the data by adding a part of the data (default: 1/6th) from one end to another end. Useful to roughly account for circularity when using non-circular methods.
</p>


<h3>Value</h3>

<p>a padded data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dt &lt;- data.table(x = runif(1000, -90, 90), y = rnorm(1000))
pad_circ(dt, "x", verbose = TRUE)

</code></pre>

<hr>
<h2 id='Pascucci_et_al_2019_data'>Data from an orientation estimation task</h2><span id='topic+Pascucci_et_al_2019_data'></span>

<h3>Description</h3>

<p>A dataset with the orientation estimation results from Experiment 2 in Pascucci et al. (2019) available from https://doi.org/10.5281/zenodo.2544946.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pascucci_et_al_2019_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 4400 rows and 5 variables:
</p>

<dl>
<dt>observer</dt><dd><p>observer ID</p>
</dd>
<dt>orientation</dt><dd><p>true orientation</p>
</dd>
<dt>reported</dt><dd><p>reported orientation</p>
</dd>
<dt>rt</dt><dd><p>response time</p>
</dd>
<dt>err</dt><dd><p>estimation error</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://zenodo.org/record/2544946/files/Experiment2_rawdata.csv?download=1">https://zenodo.org/record/2544946/files/Experiment2_rawdata.csv?download=1</a>
</p>


<h3>References</h3>


<p>Pascucci, D., Mancuso, G., Santandrea, E., Libera, C. D., Plomp, G., &amp; Chelazzi, L. (2019). Laws of concatenated perception: Vision goes for novelty, decisions for perseverance. PLoS Biology, 17(3). <a href="https://doi.org/10.1371/journal.pbio.3000144">doi:10.1371/journal.pbio.3000144</a>

</p>

<hr>
<h2 id='predict.circ_loess'>Compute predictions for circular LOESS</h2><span id='topic+predict.circ_loess'></span>

<h3>Description</h3>

<p>Compute predictions for circular LOESS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circ_loess'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.circ_loess_+3A_object">object</code></td>
<td>
<p>a circular LOESS object</p>
</td></tr>
<tr><td><code id="predict.circ_loess_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame with a variable x on which the predictions are computed</p>
</td></tr>
<tr><td><code id="predict.circ_loess_+3A_...">...</code></td>
<td>
<p>other arguments (passed to circ_loess)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with predictions
</p>

<hr>
<h2 id='remove_cardinal_biases'>Remove cardinal biases</h2><span id='topic+remove_cardinal_biases'></span>

<h3>Description</h3>

<p>Remove cardinal biases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_cardinal_biases(
  err,
  x,
  space = "180",
  bias_type = "fit",
  plots = "hide",
  poly_deg = 4,
  var_sigma = TRUE,
  var_sigma_poly_deg = 4,
  reassign_at_boundaries = TRUE,
  reassign_range = 2,
  break_points = NULL,
  init_outliers = NULL,
  debug = FALSE,
  do_plots = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_cardinal_biases_+3A_err">err</code></td>
<td>
<p>a vector of errors, deviations of response from the true stimuli</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_x">x</code></td>
<td>
<p>a vector of true stimuli in degrees (see space)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_space">space</code></td>
<td>
<p>circular space to use (a string: <code>180</code> or <code>360</code>)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_bias_type">bias_type</code></td>
<td>
<p>bias type to use (<code>fit</code>, <code>card</code>, <code>obl</code>, or <code>custom</code>, see details)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_plots">plots</code></td>
<td>
<p>a string <code>hide</code>, <code>show</code>, or <code>return</code> to hide, show, or return plots (default: <code>hide</code>)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_poly_deg">poly_deg</code></td>
<td>
<p>degree of the fitted polynomials for each bin (default: 4)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_var_sigma">var_sigma</code></td>
<td>
<p>allow standard deviation (width) of the fitted response distribution to vary as a function of distance to the nearest cardinal (default: True)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_var_sigma_poly_deg">var_sigma_poly_deg</code></td>
<td>
<p>degree of the fitted polynomials for each bin for the first approximation for the response distribution to select the best fitting model (default: 4)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_reassign_at_boundaries">reassign_at_boundaries</code></td>
<td>
<p>select the bin for the observations at the boundaries between bins based on the best-fitting polynomial (default: True)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_reassign_range">reassign_range</code></td>
<td>
<p>maximum distance to the boundary at which reassignment can occur (default: 2 degrees)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_break_points">break_points</code></td>
<td>
<p>can be used to assign custom break points instead of cardinal/oblique ones with <code>bias_type</code> set to <code>custom</code> (default: NULL)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_init_outliers">init_outliers</code></td>
<td>
<p>a vector determining which errors are initially assumed to be outliers (default: NULL)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_debug">debug</code></td>
<td>
<p>print some extra info (default: False)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_+3A_do_plots">do_plots</code></td>
<td>
<p>deprecated, use the parameter <code>plots</code> instead</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>bias_type</code> is set to <code>fit</code>, the function computes the cardinal biases in the following way:
</p>

<ol>
<li><p> Create two sets of bins, splitting the stimuli vector into bins centered at cardinal and at oblique directions.
</p>
</li>
<li><p> For each set of bins, fit a nth-degree polynomial for the responses in each bin, optionally allowing the distribution of responses to vary in width as a function of distance to the nearest cardinal (regardless of whether the bins are centered at the cardinal or at the oblique, the width of the response distribution usually increases as the distance to cardinals increase).
</p>
</li>
<li><p> Choose the best-fitting model between the one using cardinal and the one using oblique bins.
</p>
</li>
<li><p> Compute the residuals of the best-fitting model - that's your bias-corrected error - and the biases (see below).
</p>
</li></ol>

<p>The bias is computed by flipping the sign of errors when the average predicted error is negative, so, that, for example, if on average the responses are shifted clockwise relative to the true values, the trial-by-trial error would count as bias when it is also shifted clockwise.
</p>
<p>If <code>bias_type</code> is set to <code>obl</code> or <code>card</code>, only one set of bins is used, centred at cardinal or oblique angles, respectively.
</p>


<h3>Value</h3>

<p>If <code>plots=='return'</code>, returns the three plots showing the biases
(combined together with <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>). Otherwise, returns a list with the following elements:
</p>

<ul>
<li><p> is_outlier - 0 for outliers (defined as <code style="white-space: pre;">&#8288;Â±3*pred_sigma&#8288;</code> for the model with varying sigma or as <code style="white-space: pre;">&#8288;Â±3\*SD&#8288;</code> for the simple model)
</p>
</li>
<li><p> pred predicted error
</p>
</li>
<li><p> be_c error corrected for biases (<code style="white-space: pre;">&#8288;be_c = observed error - pred&#8288;</code>)
</p>
</li>
<li><p> which_bin the numeric ID of the bin that the stimulus belong to
</p>
</li>
<li><p> bias the bias computed as described above
</p>
</li>
<li><p> bias_typ bias type (cardinal or oblique)
</p>
</li>
<li><p> pred_lin predicted error for a simple linear model for comparison
</p>
</li>
<li><p> pred_sigma predicted SD of the error distribution
</p>
</li>
<li><p> coef_sigma_int, coef_sigma_slope intercept and slope for the sigma prediction
</p>
</li></ul>



<h3>References</h3>



<ul>
<li><p> Chetverikov, A., &amp; Jehee, J. F. M. (2023). Motion direction is represented as a bimodal probability distribution in the human visual cortex. Nature Communications, 14(7634). <a href="https://doi.org/10.1038/s41467-023-43251-w">doi:10.1038/s41467-023-43251-w</a>
</p>
</li>
<li><p> van Bergen, R. S., Ma, W. J., Pratte, M. S., &amp; Jehee, J. F. M. (2015). Sensory uncertainty decoded from visual cortex predicts behavior. Nature Neuroscience, 18(12), 1728â1730. <a href="https://doi.org/10.1038/nn.4150">doi:10.1038/nn.4150</a>
</p>
</li></ul>




<h3>Examples</h3>

<pre><code class='language-R'>
# Data in orientation domain from Pascucci et al. (2019, PLOS Bio),
# https://doi.org/10.5281/zenodo.2544946

ex_data &lt;- Pascucci_et_al_2019_data[observer == 4, ]
remove_cardinal_biases(ex_data$err, ex_data$orientation, plots = "show")

# Data in motion domain from Bae &amp; Luck (2018, Neuroimage),
# https://osf.io/2h6w9/
ex_data_bae &lt;- Bae_Luck_2018_data[subject_Num == unique(subject_Num)[5], ]
remove_cardinal_biases(ex_data_bae$err, ex_data_bae$TargetDirection,
  space = "360", plots = "show"
)

# Using a stricter initial outlier boundary

remove_cardinal_biases(ex_data_bae$err, ex_data_bae$TargetDirection,
  space = "360", plots = "show",
  init_outliers = abs(ex_data_bae$err) &gt; 60
)

# We can also use just one bin by setting `bias_type` to custom
# and setting the `break_points` at the ends of the range for x

remove_cardinal_biases(ex_data_bae$err, ex_data_bae$TargetDirection,
  space = "360", bias_type = "custom",
  break_points = c(-180, 180), plots = "show",
  reassign_at_boundaries = FALSE, poly_deg = 8,
  init_outliers = abs(ex_data_bae$err) &gt; 60
)

</code></pre>

<hr>
<h2 id='remove_cardinal_biases_discrete'>Remove cardinal biases for data with orientation (color, motion, ...) set in discrete steps</h2><span id='topic+remove_cardinal_biases_discrete'></span>

<h3>Description</h3>

<p>Remove cardinal biases for data with orientation (color, motion, ...) set in discrete steps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_cardinal_biases_discrete(err, x, space, init_outliers = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_cardinal_biases_discrete_+3A_err">err</code></td>
<td>
<p>a vector of errors, deviations of response from the true stimuli</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_discrete_+3A_x">x</code></td>
<td>
<p>a vector of true stimuli in degrees (see space)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_discrete_+3A_space">space</code></td>
<td>
<p>circular space to use (a string: <code>180</code> or <code>360</code>)</p>
</td></tr>
<tr><td><code id="remove_cardinal_biases_discrete_+3A_init_outliers">init_outliers</code></td>
<td>
<p>a vector determining which errors are initially assumed to be outliers (default: NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data.table with the following columns:
</p>

<ul>
<li><p> is_outlier - 0 for outliers (defined as Â±3*predicted SD, where SD and mean are computed after excluding initially assumed outliers)
</p>
</li>
<li><p> be_c error corrected for biases (<code style="white-space: pre;">&#8288;be_c = observed error - pred&#8288;</code>)
</p>
</li></ul>


<hr>
<h2 id='vm_kappa_to_circ_sd'>Conversion between the circular SD and kappa of von Mises</h2><span id='topic+vm_kappa_to_circ_sd'></span><span id='topic+vm_kappa_to_circ_sd_deg'></span><span id='topic+vm_circ_sd_to_kappa'></span><span id='topic+vm_circ_sd_deg_to_kappa'></span>

<h3>Description</h3>

<p>Conversion between the circular SD and kappa of von Mises
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vm_kappa_to_circ_sd(kappa)

vm_kappa_to_circ_sd_deg(kappa)

vm_circ_sd_to_kappa(sd)

vm_circ_sd_deg_to_kappa(sd_deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vm_kappa_to_circ_sd_+3A_kappa">kappa</code></td>
<td>
<p>von Mises kappa parameter</p>
</td></tr>
<tr><td><code id="vm_kappa_to_circ_sd_+3A_sd">sd</code></td>
<td>
<p>circular SD of von Mises (radians)</p>
</td></tr>
<tr><td><code id="vm_kappa_to_circ_sd_+3A_sd_deg">sd_deg</code></td>
<td>
<p>circular SD of von Mises (degrees)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vm_kappa_to_circ_sd</code> and <code>vm_kappa_to_circ_sd_deg</code> return circular SD (in radians or degrees, respectively) corresponding to a given kappa. <code>vm_circ_sd_to_kappa</code> and <code>vm_circ_sd_deg_to_kappa</code> return kappa corresponding to a given circular SD (in radians or degrees, respectively).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>vm_kappa_to_circ_sd_deg()</code>: get circular SD (in degrees) from kappa
</p>
</li>
<li> <p><code>vm_circ_sd_to_kappa()</code>: get kappa from circular SD (in radians)
</p>
</li>
<li> <p><code>vm_circ_sd_deg_to_kappa()</code>: get kappa from circular SD (in degrees)
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
vm_kappa &lt;- 5
vm_sd &lt;- vm_kappa_to_circ_sd(vm_kappa)

vm_circ_sd_to_kappa(vm_sd)

x &lt;- circular::rvonmises(10000, mu = circular::circular(0), kappa = vm_kappa)

sprintf("Expected SD: %.2f, actual SD: %.2f", vm_sd, circ_sd_rad(x))

</code></pre>

<hr>
<h2 id='weighted_circ_mean'>Weighted circular parameters</h2><span id='topic+weighted_circ_mean'></span><span id='topic+weighted_circ_mean2'></span><span id='topic+weighted_circ_sd'></span><span id='topic+weighted_circ_rho'></span>

<h3>Description</h3>

<p>Weighted circular parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_circ_mean(x, w, na.rm = FALSE)

weighted_circ_mean2(x, w, na.rm = FALSE)

weighted_circ_sd(x, w, na.rm = FALSE)

weighted_circ_rho(x, w, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_circ_mean_+3A_x">x</code></td>
<td>
<p>vector of values (in radians)</p>
</td></tr>
<tr><td><code id="weighted_circ_mean_+3A_w">w</code></td>
<td>
<p>vector of weights</p>
</td></tr>
<tr><td><code id="weighted_circ_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be removed before the computation proceeds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>weighted mean of values in the vector
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>weighted_circ_mean()</code>: weighted circular mean
</p>
</li>
<li> <p><code>weighted_circ_mean2()</code>: an alternative way to compute weighted circular mean (the results are the same)
</p>
</li>
<li> <p><code>weighted_circ_sd()</code>: weighted circular SD
</p>
</li>
<li> <p><code>weighted_circ_rho()</code>: weighted mean resultant length
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000, 0, 0.5)
w &lt;- runif(1000, 0, 1)
weighted.mean(x, w)
weighted_circ_mean(x, w)

</code></pre>

<hr>
<h2 id='weighted_sem'>Weighted standard error of the mean (SEM_w)</h2><span id='topic+weighted_sem'></span>

<h3>Description</h3>

<p>Computes the variance of a weighted mean following the definitions given by Kirchner (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_sem(x, w, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_sem_+3A_x">x</code></td>
<td>
<p>variable to compute the SEM for</p>
</td></tr>
<tr><td><code id="weighted_sem_+3A_w">w</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="weighted_sem_+3A_na.rm">na.rm</code></td>
<td>
<p>should NAs be removed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>James Kirchner describes two different cases when the weighted variance is computed. The code here implements Case I where &quot;one wants to give more weight to some points than to others, because they are considered to be more important&quot; and &quot;the weights differ but the uncertainties associated with the individual xi are assumed to be the same&quot; (Kirchner, 2006, p. 1). The formula used is:
\[SEM_w = \sqrt{\left(\sum_{i = 1}^{N} (w_{i} x_i^2)-\bar{x}^2\right)\frac{\sum_{i = 1}^{N} w_i^2}{1-\sum_{i = 1}^{N} w_i^2}} \]
The expected error is within 5% of the bootstrapped SEM (at larger sample sizes).
</p>


<h3>Value</h3>

<p>weighted standard error of the mean
</p>


<h3>References</h3>



<ul>
<li><p> Kirchner, J. 2006. Data Analysis Toolkit #12: Weighted averages and their uncertainties. <a href="https://seismo.berkeley.edu/~kirchner/Toolkits/Toolkit_12.pdf">https://seismo.berkeley.edu/~kirchner/Toolkits/Toolkit_12.pdf</a>.  Retrieved on 04.07.2024.
</p>
</li>
<li><p> Bevington, P. R. 1969. Data Reduction and Error Analysis for the Physical Sciences. McGraw-Hill, 336 pp.
</p>
</li></ul>




<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n_obs &lt;- 200
w &lt;- runif(n_obs)
w &lt;- w/sum(w)
x &lt;- rnorm(n_obs, sd = 5)
weighted_sem(x, w)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
