<!DOCTYPE html><html lang="en"><head><title>Help for package paropt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {paropt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#optimize'><p>Optimize parameters of ode-systems</p></a></li>
<li><a href='#solve'><p>Solves an ode-system</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parameter Optimizing of ODE-Systems</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Krämer Konrad [aut, cre],
  Krämer Johannes [aut],
  Heyer Arnd [ths],
  University of Stuttgart [uvp],
  Institute of Biomaterials and Biomolecular Systems at the University of Stuttgart [his]
  | file AUTHORS</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Krämer Konrad &lt;Konrad_kraemer@yahoo.de&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Konrad1991/paropt">https://github.com/Konrad1991/paropt</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Enable optimization of parameters of ordinary differential equations.
             Therefore, using 'SUNDIALS' to solve the ODE-System (see Hindmarsh, Alan C., Peter N. Brown, Keith E. Grant, Steven L. Lee, Radu Serban, Dan E. Shumaker, and Carol S. Woodward. (2005) &lt;<a href="https://doi.org/10.1145%2F1089014.1089020">doi:10.1145/1089014.1089020</a>&gt;).
             Furthermore, for optimization the particle swarm algorithm is used (see: Akman, Devin, Olcay Akman, and Elsa Schaefer. (2018) &lt;<a href="https://doi.org/10.1155%2F2018%2F9160793">doi:10.1155/2018/9160793</a>&gt; and Sengupta, Saptarshi, Sanchita Basak, and Richard Peters. (2018) &lt;<a href="https://doi.org/10.3390%2Fmake1010010">doi:10.3390/make1010010</a>&gt;). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.4), ast2ast, methods, dfdr, RcppThread, rlang</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppThread, ast2ast</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tinytest, deSolve</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-22 12:20:50 UTC; konrad</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-22 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='optimize'>Optimize parameters of ode-systems</h2><span id='topic+optimize'></span>

<h3>Description</h3>

<p>Optimize parameters used in an ode equation in order to match values defined in the state-data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize(
  ode,
  lb,
  ub,
  npop,
  ngen,
  reltol,
  abstol,
  error,
  states,
  solvertype,
  own_error_fct,
  own_spline_fct,
  own_jac_fct,
  number_threads,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_+3A_ode">ode</code></td>
<td>
<p>the ode-system for which the parameter should be optimized.</p>
</td></tr>
<tr><td><code id="optimize_+3A_lb">lb</code></td>
<td>
<p>a data.frame containing the lower bounds for the parameters.</p>
</td></tr>
<tr><td><code id="optimize_+3A_ub">ub</code></td>
<td>
<p>a data.frame containing the upper bounds for the parameters.</p>
</td></tr>
<tr><td><code id="optimize_+3A_npop">npop</code></td>
<td>
<p>a number defining the number of particles used by the Particle Swarm Optimizer. The default value is 40.</p>
</td></tr>
<tr><td><code id="optimize_+3A_ngen">ngen</code></td>
<td>
<p>a number defining the number of generations the Particle Swarm Optimizer (PSO) should run. The default value is 10000</p>
</td></tr>
<tr><td><code id="optimize_+3A_reltol">reltol</code></td>
<td>
<p>a number defining the relative tolerance used by the ode-solver. The default value is 1e-06</p>
</td></tr>
<tr><td><code id="optimize_+3A_abstol">abstol</code></td>
<td>
<p>a vector containing the absolute tolerance(s) for each state used by the ode-solver. The default value is 1e-08</p>
</td></tr>
<tr><td><code id="optimize_+3A_error">error</code></td>
<td>
<p>a number defining a sufficient small error. When the PSO reach this value optimization is stopped. The default value is 0.0001</p>
</td></tr>
<tr><td><code id="optimize_+3A_states">states</code></td>
<td>
<p>a data.frame containing the predetermined course of the states. <br /> The data.frame is used to extract the initial values of the states. <br />
Furthermore, the ode-solver returns <em>in silico</em> values of the states at the timepoints which has to be defined in the first column</p>
</td></tr>
<tr><td><code id="optimize_+3A_solvertype">solvertype</code></td>
<td>
<p>a string defining the type of solver which should be used &quot;bdf&quot; or &quot;adams&quot; are the possible values. The default value is &quot;bdf&quot;. <br />
&quot;bdf&quot; is an abbreviation for Backward Differentiation Formulas. &quot;adams&quot; is an abbreviation for the Adams-Moulton algorithm</p>
</td></tr>
<tr><td><code id="optimize_+3A_own_error_fct">own_error_fct</code></td>
<td>
<p>An optional function to calculate the error between <em>in silico</em> value and the specified value in the data.frame states. The default error calculation is specified in the section notes.</p>
</td></tr>
<tr><td><code id="optimize_+3A_own_spline_fct">own_spline_fct</code></td>
<td>
<p>An optional function to interpolate the values for variable parameters. The default function is a CatmullRome spline interpolation.</p>
</td></tr>
<tr><td><code id="optimize_+3A_own_jac_fct">own_jac_fct</code></td>
<td>
<p>An optional function which returns the jacobian function. Furthermore it is possible to calculate the jacobian using the R package dfdr. If this is desired &quot;dfdr&quot; has to be passed as argument. If nothing is passed the jacobian matrix is numerically calculated.</p>
</td></tr>
<tr><td><code id="optimize_+3A_number_threads">number_threads</code></td>
<td>
<p>An optional numeric value defining the number of threads which should be used. If nothing is passed the maximum number of cores is used. The default value is NULL</p>
</td></tr>
<tr><td><code id="optimize_+3A_verbose">verbose</code></td>
<td>
<p>A logical value defining whether the output during compilation should be shown or not. The default value is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>The ode system:</strong>
<br />___________________________________________________________<br />
The ode system is an R function which accepts four arguments and returns one.
</p>

<ol>
<li><p> the first argument is <strong>t</strong> which defines the (time-) point of then independent variable at which the ode-system is evaluated.
</p>
</li>
<li><p> the second argument is a vector called <strong>y</strong> which defines the current states at timepoint <strong>t</strong>
</p>
</li>
<li><p> the third argument is a vector called <strong>ydot</strong> which should be filled with the derivative (left hand side) of the ode-system. It has already the correct length! <strong>This vector has to be returned.</strong>
</p>
</li>
<li><p> the last argument is called <strong>parameter</strong> and is a vector containing the current parameter-set which is tested by the optimization algorithm. <br />
<strong>If the parameters can change over time. The already interpolated value is passed to the ode-system.</strong> <br />
</p>
</li></ol>

<p><code style="white-space: pre;">&#8288;
# theoretical Example: The parameter 'a' can change over time whereas 'b' is constant over time.
  parameter_set &lt;- data.frame(
          time = c(0, 10, 20, 30, 40),
          a = c(1, 2, 3, 4, 5),
          b = c(1, NA, NA, NA, NA, NA))
  t &lt;- 5
# Interpolation would result in 1.5 for parameter 'a'
  parameter &lt;- c(1.5, 1) # 'a', 'b'
  y &lt;- 1
  ydot &lt;- vector(length(1))
  ode(t, y, ydot, parameter)
&#8288;</code>
</p>

<ul>
<li><p> The function returns <em>ydot</em>. It is only necessary to fill the vector <strong>ydot</strong>. Check the package <em>ast2ast</em> for more details how this works.
</p>
</li>
<li><p> The R function is translated to a C++ function using the package <em>ast2ast</em>, see also <a href="https://CRAN.R-project.org/package=ast2ast">ast2ast on CRAN</a> and <code><a href="ast2ast.html#topic+translate">ast2ast::translate()</a></code>. Therefore, if you are starting the simulation for the first time the function has to be compiled. This can require a bit of time.
</p>
</li></ul>

<p><strong>The boundaries:</strong>
<br />___________________________________________________________<br />
The lower and upper boundaries are defined as data.frames that contain 'time' as the first column. <br />
The subsequent columns contain the information of the parameter. <br />
<br />
<code style="white-space: pre;">&#8288;
# Here some examples
# all parameters are constant over the entire integration_time
  example1 &lt;- data.frame(
                     time = 0,
                     a = 0,
                     b = 0.1,
                     c = 0.2,
                     d = 0.2)

# The parameter a, b, and c are constant whereas the parameter d can change over time
  example2 &lt;- data.frame(
                time = c(0, 5, 10, 15),
                a = c(0, NA, NA, NA),
                b = c(0.1, NA, NA, NA),
                c = c(0.2, NA, NA, NA),
                d = c(0, 0.1, 0.2, 1))

# The parameter a, b are constant
# whereas parameter c and d can change over time.
# However, d is not known for all points of c
  example3 &lt;- data.frame(
                   time = c(0, 5, 10, 15, 20, 25),
                   a = c(0, NA, NA, NA, NA, NA),
                   b = c(0.1, NA, NA, NA, NA, NA),
                   c = c(0.2, 0.2, 0, 0, 0, 0),
                   d = c(0, 0.1, 0.2, 1, NA, NA))
&#8288;</code>
</p>
<p><strong>The states data.frame: </strong>
<br />___________________________________________________________<br />
The states are defined as a data.frame that contains the 'time' as the first column.
The subsequent columns are the individual states. <br />
<br />
<code style="white-space: pre;">&#8288;
# Here some examples
# Only the initial values are defined.
  example1 &lt;- data.frame(
                     time = seq(0, 100, 0.5),
                     prey = c(10, rep(NA, 200)),
                     predator = c(10, rep(NA, 200)))

# All values are defined at each timepoint
  example2 &lt;- data.frame(
                time =  seq(0, 100, 0.5),
                prey =  c(10, runif(200)),
                predator =  c(10, runif(200)) )

# Only the values for prey are known and are used during optimization
  example3 &lt;- data.frame(
                time =  seq(0, 100, 0.5),
                prey =  c(10, runif(200)),
                predator =  c(10, rep(NA, 200)) )

&#8288;</code>
</p>
<p><strong>solvertype: </strong>
<br />___________________________________________________________<br />
For solving the ode system the SUNDIALS Software is used check the <a href="https://computing.llnl.gov/projects/sundials">Sundials homepage</a> for more informations.
The solver-type which is used during optimization: “bdf“, “adams“. bdf is an abbreviation for Backward Differentiation Formulas and adams means Adams-Moulton.
All solvers are used in the NORMAL-Step method in a for-loop using the time-points defined in the first column of the 'states' data.frame.
The bdf solver use the SUNLinSol_Dense as linear solver.
</p>
<p><strong>own_error_fct: </strong>
<br />___________________________________________________________<br />
The error function calculates the error at one of the possible time-points. Moreover, the function expects three numerical scalars as arguments. The first one is the number of data-points at which the error is calculated. The second argument describes the <em>in silico</em> value at one specific time-point. The third argument is the input of the user at the specific time-point which should be matched. <br />
Here is one example shown using the sum of squares as an alternative error function.
<code style="white-space: pre;">&#8288;
error_fct &lt;- function(num_points, insilico, measured) {
  ret = (insilico - measured)^2
  return(ret/num_points)
}
&#8288;</code>
</p>
<p><strong>own_spline_fct: </strong>
<br />___________________________________________________________<br />
The spline function is called, directly before the ode-system is evaluated. However, the function is only called for non-constant parameters. See example Nr.2 and Nr.3 parameter <em>d</em> as described above. The results of the spline function is then stored in the vector <strong>parameter</strong> which is passed to the ode-system. The function expects three arguments:
</p>

<ul>
<li><p> The time-point at which the function is evaluated
</p>
</li>
<li><p> a vector containing the time-points for which parameters are defined
</p>
</li>
<li><p> a vector containing the parameters at the respective time-points
</p>
</li></ul>

<p>The function has to return a scalar value.See the example above for a linear interpolation:
<code style="white-space: pre;">&#8288;
linear_interpolation &lt;- function(t, time_vec, par_vec) {
  left = 0
  left_time = 0
  right = 0
  right_time = 0
  for(i in 1:length(time_vec)) {

    if(t == time_vec[i]) {
      return(par_vec[i])
    }

    if(t &lt; time_vec[i]) {
      left = par_vec[i - 1]
      right = par_vec[i]
      left_time = time_vec[i - 1]
      right_time = time_vec[i]
      break
    }
  }

  timespan = right_time - left_time
  m = (right - left) / timespan
  ret = left + m*(t - left_time)
  return(ret)
}
&#8288;</code>
Mentionable, is that it hasn't to be a interpolation function. See the example above:
<code style="white-space: pre;">&#8288;
fct &lt;- function(t, time_vec, par_vec) {
  ret = 0
  for(i in par_vec) {
    ret = ret + i
  }
  return(ret)
}
&#8288;</code>
</p>
<p><strong>own_jac_fct: </strong>
<br />___________________________________________________________<br />
The jacobian function expects 5 arguments.
</p>

<ol>
<li><p> the first argument is <strong>t</strong> which defines the (time-) point of then independent variable at which the ode-system is evaluated.
</p>
</li>
<li><p> the second argument is a vector called <strong>y</strong> which defines the current states at timepoint <strong>t</strong>
</p>
</li>
<li><p> the third argument is a vector called <strong>ydot</strong> which should be filled with the derivative (left hand side) of the ode-system. It has already the correct length! Please do not return the vector.
</p>
</li>
<li><p> the foruth argument is a matrix called <strong>J</strong> which should be filled with the respective derivatives of <strong>ydot</strong>. The matrix has already the correct dimensions. <strong>This matrix has to be returned.</strong>
</p>
</li>
<li><p> the last argument is called <strong>parameter</strong> and is a vector containing the current parameter-set which is tested by the optimization algorithm. <br />
<strong>If the parameters can change over time. The already interpolated value is passed to the ode-system.</strong> <br />
</p>
</li></ol>



<h3>Value</h3>

<p>A list is returned which contains three elements. The first one is the error of the best particle. Subsequently, a data.frame with the best parameters is included in the list.
The last element are the <em>in silico</em> states returned from the ode-solver using the parameter-set at index 2.
</p>


<h3>Note</h3>


<ul>
<li><p> The error between the defined states and the <em>in silico</em> states is the absolute difference normalised using the true state.
</p>
</li>
<li><p> The optimization algorithms runs in parallel. Therefore, the ode-system should not contain any printing terms or random number generators.
</p>
</li>
<li><p> a particle swarm algorithm is used for optimization.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+solve">solve</a>()</code>,
<code><a href="ast2ast.html#topic+translate">ast2ast::translate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Optimize (all parameters are constant)
ode &lt;- function(t, y, ydot, parameter) {
  a_db = at(parameter, 1)
  b_db = at(parameter, 2)
  c_db = at(parameter, 3)
  d_db = at(parameter, 4)
  predator_db = at(y,1)
  prey_db = at(y, 2)
  ydot[1] = predator_db*prey_db*c_db - predator_db*d_db
  ydot[2] = prey_db*a_db - prey_db*predator_db*b_db
  return(ydot)
}
path &lt;- system.file("examples", package = "paropt")
states &lt;- read.table(paste(path,"/states_LV.txt", sep = ""), header = TRUE)
lb &lt;- data.frame(time = 0, a = 0.8, b = 0.3, c = 0.09, d = 0.09)
ub &lt;- data.frame(time = 0, a = 1.3, b = 0.7, c = 0.4, d = 0.7)
set.seed(1)
res &lt;- paropt::optimize(ode,
                        lb = lb, ub = ub,
                        reltol = 1e-06, abstol = c(1e-08, 1e-08),
                        error = 0.0001,
                        npop = 40, ngen = 100, # 1000 would be better
                        states = states)


# Optimize (parameter a,b and c are constant. d is variable!)
r &lt;- function(a) {
  c(a, rep(NA, 3))
}

lb &lt;- data.frame(time = c(0, 20, 60, 80),
                 a = r(0.8), b = r(0.3), c = r(0.09), d = 0.1)
ub &lt;- data.frame(time = c(0, 20, 60, 80),
                 a = r(1.3), b = r(0.7), c = r(0.4), d = 0.6)
set.seed(1)
res &lt;- paropt::optimize(ode,
                        lb = lb, ub = ub,
                        reltol = 1e-06, abstol = c(1e-08, 1e-08),
                        error = 0.0001,
                        npop = 40, ngen = 100, # 1000 would be better
                        states = states)


# Optimization with own error, spline and jacobian function
ode &lt;- function(t, y, ydot, parameter) {
  a_db = at(parameter, 1)
  b_db = at(parameter, 2)
  c_db = at(parameter, 3)
  d_db = at(parameter, 4)
  predator_db = at(y,1)
  prey_db = at(y, 2)
  ydot[1] = predator_db*prey_db*c_db - predator_db*d_db
  ydot[2] = prey_db*a_db - prey_db*predator_db*b_db
  return(ydot)
}

jac &lt;- function(t, y, ydot, J, parameter) {
  a_db = at(parameter, 1)
  b_db = at(parameter, 2)
  c_db = at(parameter, 3)
  d_db = at(parameter, 4)
  predator_db = at(y,1)
  prey_db = at(y, 2)

  J[1, 1] = prey_db*c_db - d_db
  J[2, 1] = - prey_db*b_db
  J[1, 2] = predator_db*c_db
  J[2, 2] = a_db - predator_db*b_db

  return(J)
}

error_fct &lt;- function(c, a, b) {
  ret = (a - b)^2
  return(ret)
}

spline_fct &lt;- function(t, time_vec, par_vec) {
  ret = 0
  for(i in par_vec) {
    ret = ret + i
  }
  return(ret)
}

path &lt;- system.file("examples", package = "paropt")
states &lt;- read.table(paste(path,"/states_LV.txt", sep = ""), header = TRUE)
lb &lt;- data.frame(time = 0, a = 0.8, b = 0.3, c = 0.09, d = 0.09)
ub &lt;- data.frame(time = 0, a = 1.3, b = 0.7, c = 0.4, d = 0.7)
set.seed(1)
res &lt;- paropt::optimize(ode,
                        lb = lb, ub = ub,
                        reltol = 1e-06, abstol = c(1e-08, 1e-08),
                        error = 0.0001,
                        npop = 40, ngen = 100, # 1000 would be better
                        states = states,
                        verbose = TRUE,
                        own_error_fct = error_fct,
                        own_spline_fct = spline_fct,
                        own_jac_fct = jac)



</code></pre>

<hr>
<h2 id='solve'>Solves an ode-system</h2><span id='topic+solve'></span>

<h3>Description</h3>

<p>Solves an ode equation and calculate an error based on the difference on a user-defined state-data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  solve(
    ode,
    parameter,
    reltol,
    abstol,
    states,
    solvertype,
    own_error_fct,
    own_spline_fct,
    own_jac_fct,
    verbose
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solve_+3A_ode">ode</code></td>
<td>
<p>the ode-system for which the parameter should be optimized.</p>
</td></tr>
<tr><td><code id="solve_+3A_parameter">parameter</code></td>
<td>
<p>a data.frame containing the parameters.</p>
</td></tr>
<tr><td><code id="solve_+3A_reltol">reltol</code></td>
<td>
<p>a number defining the relative tolerance used by the ode-solver. The default value is 1e-06</p>
</td></tr>
<tr><td><code id="solve_+3A_abstol">abstol</code></td>
<td>
<p>a vector containing the absolute tolerance(s) for each state used by the ode-solver. The default value is 1e-08</p>
</td></tr>
<tr><td><code id="solve_+3A_states">states</code></td>
<td>
<p>a data.frame containing the predetermined course of the states. <br /> The data.frame is used to extract the initial values of the states. <br />
Furthermore, the ode-solver returns <em>in silico</em> values of the states at the timepoints which has to be defined in the first column</p>
</td></tr>
<tr><td><code id="solve_+3A_solvertype">solvertype</code></td>
<td>
<p>a string defining the type of solver which should be used &quot;bdf&quot; or &quot;adams&quot; are the possible values. The default value is &quot;bdf&quot;. <br />
&quot;bdf&quot; is an abbreviation for Backward Differentiation Formulas. &quot;adams&quot; is an abbreviation for the Adams-Moulton algorithm</p>
</td></tr>
<tr><td><code id="solve_+3A_own_error_fct">own_error_fct</code></td>
<td>
<p>An optional function to calculate the error between <em>in silico</em> value and the specified value in the data.frame states. The default error calculation is specified in the section notes.</p>
</td></tr>
<tr><td><code id="solve_+3A_own_spline_fct">own_spline_fct</code></td>
<td>
<p>An optional function to interpolate the values for variable parameters. The default function is a CatmullRome spline interpolation.</p>
</td></tr>
<tr><td><code id="solve_+3A_own_jac_fct">own_jac_fct</code></td>
<td>
<p>An optional function which returns the jacobian function. Furthermore it is possible to calculate the jacobian using the R package dfdr. If this is desired &quot;dfdr&quot; has to be passed as argument. If nothing is passed the jacobian matrix is numerically calculated.</p>
</td></tr>
<tr><td><code id="solve_+3A_verbose">verbose</code></td>
<td>
<p>A logical value defining whether the output during compilation should be shown or not. The default value is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>The ode system:</strong>
<br />___________________________________________________________<br />
The ode system is an R function which accepts four arguments and returns one.
</p>

<ol>
<li><p> the first argument is <strong>t</strong> which defines the (time-) point of then independent variable at which the ode-system is evaluated.
</p>
</li>
<li><p> the second argument is a vector called <strong>y</strong> which defines the current states at timepoint <strong>t</strong>
</p>
</li>
<li><p> the third argument is a vector called <strong>ydot</strong> which should be filled with the derivative (left hand side) of the ode-system. It has already the correct length! <strong>This vector has to be returned.</strong>
</p>
</li>
<li><p> the last argument is called <strong>parameter</strong> and is a vector containing the current parameter-set which is tested by the optimization algorithm. <br />
<strong>If the parameters can change over time. The already interpolated value is passed to the ode-system.</strong> <br />
</p>
</li></ol>

<p><code style="white-space: pre;">&#8288;
    # theoretical Example: The parameter 'a' can change over time whereas 'b' is constant over time.
    parameter_set &lt;- data.frame(
      time = c(0, 10, 20, 30, 40),
      a = c(1, 2, 3, 4, 5),
      b = c(1, NA, NA, NA, NA, NA))
    t &lt;- 5
    # Interpolation would result in 1.5 for parameter 'a'
    parameter &lt;- c(1.5, 1) # 'a', 'b'
    y &lt;- 1
    ydot &lt;- vector(length(1))
    ode(t, y, ydot, parameter)
  &#8288;</code>
</p>

<ul>
<li><p> The function returns <em>ydot</em>. It is only necessary to fill the vector <strong>ydot</strong>. Check the package <em>ast2ast</em> for more details how this works.
</p>
</li>
<li><p> The R function is translated to a C++ function using the package <em>ast2ast</em>, see also <a href="https://CRAN.R-project.org/package=ast2ast">ast2ast on CRAN</a> and <code><a href="ast2ast.html#topic+translate">ast2ast::translate()</a></code>. Therefore, if you are calling 'solve' for the first time the function has to be compiled. This can require a bit of time.
</p>
</li></ul>

<p><strong>The parameters:</strong>
<br />___________________________________________________________<br />
The lower and upper boundaries are defined as a data.frame that contains 'time' as the first column. <br />
The subsequent columns contain the information of the parameter. <br />
<br />
<code style="white-space: pre;">&#8288;
    # Here some examples
    # all parameters are constant over the entire integration_time
    example1 &lt;- data.frame(
      time = 0,
      a = 0.4,
      b = 1.1,
      c = 0.1,
      d = 0.4)

    # The parameter a, b, and c are constant whereas the parameter d can change over time
    example2 &lt;- data.frame(
      time = c(0, 5, 10, 15),
      a = c(0.4, NA, NA, NA),
      b = c(1.1, NA, NA, NA),
      c = c(0.1, NA, NA, NA),
      d = c(0.4, 0.5, 0.3, 0.4))

    # The parameter a, b are constant
    # whereas parameter c and d can change over time.
    # However, d is not known for all points of c
    example3 &lt;- data.frame(
      time = c(0, 5, 10, 15, 20, 25),
      a = c(1.1, NA, NA, NA, NA, NA),
      b = c(0.1, NA, NA, NA, NA, NA),
      c = c(0.2, 0.2, 0, 0, 0, 0),
      d = c(0, 0.1, 0.2, 1, NA, NA))
  &#8288;</code>
<strong>The states data.frame: </strong>
<br />___________________________________________________________<br />
The states are defined as a data.frame that contains the 'time' as the first column.
The subsequent columns are the individual states. <br />
<br />
<code style="white-space: pre;">&#8288;
    # Here some examples
    # Only the initial values are defined.
    example1 &lt;- data.frame(
      time = seq(0, 100, 0.5),
      prey = c(10, rep(NA, 200)),
      predator = c(10, rep(NA, 200)))

    # All values are defined at each timepoint
    example2 &lt;- data.frame(
      time =  seq(0, 100, 0.5),
      prey =  c(10, runif(200)),
      predator =  c(10, runif(200)) )

    # Only the values for prey are known and are used during optimization
    example3 &lt;- data.frame(
      time =  seq(0, 100, 0.5),
      prey =  c(10, runif(200)),
      predator =  c(10, rep(NA, 200)) )

  &#8288;</code>
</p>
<p><strong>solvertype: </strong>
<br />___________________________________________________________<br />
For solving the ode system the SUNDIALS Software is used check the <a href="https://computing.llnl.gov/projects/sundials">Sundials homepage</a> for more informations.
The solver-type which is used during optimization: “bdf“, “adams“. bdf is an abbreviation for Backward Differentiation Formulas and adams means Adams-Moulton.
All solvers are used in the NORMAL-Step method in a for-loop using the time-points defined in the first column of the 'states' data.frame.
The bdf solver use the SUNLinSol_Dense as linear solver.
</p>
<p><strong>own_error_fct: </strong>
<br />___________________________________________________________<br />
The error function calculates the error at one of the possible time-points. Moreover, the function expects three numerical scalars as arguments. The first one is the number of data-points at which the error is calculated. The second argument describes the <em>in silico</em> value at one specific time-point. The third argument is the input of the user at the specific time-point which should be matched. <br />
Here is one example shown using the sum of squares as an alternative error function.
<code style="white-space: pre;">&#8288;
error_fct &lt;- function(num_points, insilico, measured) {
  ret = (insilico - measured)^2
  return(ret/num_points)
}
&#8288;</code>
</p>
<p><strong>own_spline_fct: </strong>
<br />___________________________________________________________<br />
The spline function is called, directly before the ode-system is evaluated. However, the function is only called for non-constant parameters. See example Nr.2 and Nr.3 parameter <em>d</em> as described above. The results of the spline function is then stored in the vector <strong>parameter</strong> which is passed to the ode-system. The function expects three arguments:
</p>

<ul>
<li><p> The time-point at which the function is evaluated
</p>
</li>
<li><p> a vector containing the time-points for which parameters are defined
</p>
</li>
<li><p> a vector containing the parameters at the respective time-points
</p>
</li></ul>

<p>The function has to return a scalar value.See the example above for a linear interpolation:
<code style="white-space: pre;">&#8288;
linear_interpolation &lt;- function(t, time_vec, par_vec) {
  left = 0
  left_time = 0
  right = 0
  right_time = 0
  for(i in 1:length(time_vec)) {

    if(t == time_vec[i]) {
      return(par_vec[i])
    }

    if(t &lt; time_vec[i]) {
      left = par_vec[i - 1]
      right = par_vec[i]
      left_time = time_vec[i - 1]
      right_time = time_vec[i]
      break
    }
  }

  timespan = right_time - left_time
  m = (right - left) / timespan
  ret = left + m*(t - left_time)
  return(ret)
}
&#8288;</code>
Mentionable, is that it hasn't to be a interpolation function. See the example above:
<code style="white-space: pre;">&#8288;
fct &lt;- function(t, time_vec, par_vec) {
  ret = 0
  for(i in par_vec) {
    ret = ret + i
  }
  return(ret)
}
&#8288;</code>
</p>
<p><strong>own_jac_fct: </strong>
<br />___________________________________________________________<br />
The jacobian function expects 5 arguments.
</p>

<ol>
<li><p> the first argument is <strong>t</strong> which defines the (time-) point of then independent variable at which the ode-system is evaluated.
</p>
</li>
<li><p> the second argument is a vector called <strong>y</strong> which defines the current states at timepoint <strong>t</strong>
</p>
</li>
<li><p> the third argument is a vector called <strong>ydot</strong> which should be filled with the derivative (left hand side) of the ode-system. It has already the correct length! Please do not return the vector.
</p>
</li>
<li><p> the foruth argument is a matrix called <strong>J</strong> which should be filled with the respective derivatives of <strong>ydot</strong>. The matrix has already the correct dimensions. <strong>This matrix has to be returned.</strong>
</p>
</li>
<li><p> the last argument is called <strong>parameter</strong> and is a vector containing the current parameter-set which is tested by the optimization algorithm. <br />
<strong>If the parameters can change over time. The already interpolated value is passed to the ode-system.</strong> <br />
</p>
</li></ol>



<h3>Value</h3>

<p>A list is returned which contains two elements. The first one is the error of the best particle.
The other element is a data.frame containing the <em>in silico</em> states returned from the ode-solver using the parameter-set passed by the user..
</p>


<h3>Note</h3>


<ul>
<li><p> The error between the defined states and the <em>in silico</em> states is the absolute difference normalised using the true state.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+optimize">optimize</a>()</code>,
<code><a href="ast2ast.html#topic+translate">ast2ast::translate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
# Solve an ode-system
ode &lt;- function(t, y, ydot, parameter) {
  a_db = at(parameter, 1)
  b_db = at(parameter, 2)
  c_db = at(parameter, 3)
  d_db = at(parameter, 4)
  predator_db = at(y,1)
  prey_db = at(y, 2)
  ydot[1] = predator_db*prey_db*c_db - predator_db*d_db
  ydot[2] = prey_db*a_db - prey_db*predator_db*b_db
  return(ydot)
}
path &lt;- system.file("examples", package = "paropt")
states &lt;- read.table(paste(path,"/states_LV.txt", sep = ""), header = TRUE)
parameter &lt;- data.frame(time = 0, a = 1.1, b = 0.4, c = 0.1, d = 0.4)
res &lt;- paropt::solve(ode,
                     parameter = parameter,
                     reltol = 1e-06, abstol = c(1e-08, 1e-08),
                     states = states, verbose = FALSE)


 # solving with own error, spline and jacobian function

 jac &lt;- function(t, y, ydot, J, parameter) {
  a_db = at(parameter, 1)
  b_db = at(parameter, 2)
  c_db = at(parameter, 3)
  d_db = at(parameter, 4)
  predator_db = at(y,1)
  prey_db = at(y, 2)

  J[1, 1] = prey_db*c_db - d_db
  J[2, 1] = - prey_db*b_db
  J[1, 2] = predator_db*c_db
  J[2, 2] = a_db - predator_db*b_db

  return(J)
}

error_fct &lt;- function(c, a, b) {
  ret = (a - b)^2
  return(ret)
}

spline_fct &lt;- function(t, time_vec, par_vec) {
  ret = 0
  for(i in par_vec) {
    ret = ret + i
  }
  return(ret)
}

path &lt;- system.file("examples", package = "paropt")
states &lt;- read.table(paste(path,"/states_LV.txt", sep = ""), header = TRUE)
parameter &lt;- data.frame(time = 0, a = 1.1, b = 0.4, c = 0.1, d = 0.4)
res &lt;- paropt::solve(ode,
                     parameter = parameter,
                     reltol = 1e-06, abstol = c(1e-08, 1e-08),
                     states = states, verbose = FALSE)

res &lt;- paropt::solve(ode,
                        parameter = parameter,
                        reltol = 1e-06, abstol = c(1e-08, 1e-08),
                        states = states, verbose = FALSE,
                        own_error_fct = error_fct,
                        own_spline_fct = spline_fct,
                        own_jac_fct = jac)


  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
