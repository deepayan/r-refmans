<!DOCTYPE html><html><head><title>Help for package SpatPCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatPCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checkInputData'><p>Internal function: Validate input data for a spatpca object</p></a></li>
<li><a href='#checkNewLocationsForSpatpcaObject'><p>Internal function: Validate new locations for a spatpca object</p></a></li>
<li><a href='#detrend'><p>Internal function: Detrend Y by column-wise centering</p></a></li>
<li><a href='#eigenFunction'><p>Interpolated Eigen-function</p></a></li>
<li><a href='#fetchUpperBoundNumberEigenfunctions'><p>Internal function: Fetch the upper bound of the number of eigenfunctions</p></a></li>
<li><a href='#plot.spatpca'><p>Display the cross-validation results</p></a></li>
<li><a href='#predict'><p>Spatial predictions on new locations</p></a></li>
<li><a href='#predictEigenfunction'><p>Spatial dominant patterns on new locations</p></a></li>
<li><a href='#scaleLocation'><p>Internal function: Scale one-dimension locations</p></a></li>
<li><a href='#setCores'><p>Internal function: Set the number of cores for parallel computing</p></a></li>
<li><a href='#setGamma'><p>Internal function: Set tuning parameter - gamma</p></a></li>
<li><a href='#setL2'><p>Internal function: Set tuning parameter - l2</p></a></li>
<li><a href='#setNumberEigenfunctions'><p>Internal function: Set the number of eigenfunctions for a spatpca object</p></a></li>
<li><a href='#setTau1'><p>Internal function: Set tuning parameter - tau1</p></a></li>
<li><a href='#setTau2'><p>Internal function: Set tuning parameter - tau2</p></a></li>
<li><a href='#spatialPrediction'><p>Internal function: Spatial prediction</p></a></li>
<li><a href='#spatpca'><p>Regularized PCA for spatial data</p></a></li>
<li><a href='#SpatPCA-package'><p>Regularized Principal Component Analysis for Spatial Data</p></a></li>
<li><a href='#spatpcaCV'><p>Internal function: M-fold Cross-validation</p></a></li>
<li><a href='#spatpcaCVWithSelectedK'><p>Internal function: M-fold CV of SpatPCA with selected K</p></a></li>
<li><a href='#thinPlateSplineMatrix'><p>Thin-plane spline matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Regularized Principal Component Analysis for Spatial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Provide regularized principal component analysis incorporating smoothness, sparseness and orthogonality of eigen-functions
  by using the alternating direction method of multipliers algorithm (Wang and Huang, 2017, &lt;<a href="https://doi.org/10.1080%2F10618600.2016.1157483">doi:10.1080/10618600.2016.1157483</a>&gt;). The
  method can be applied to either regularly or irregularly spaced data, including 1D, 2D, and 3D.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/egpivo/SpatPCA/issues">https://github.com/egpivo/SpatPCA/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), RcppParallel (&ge; 5.1.7), ggplot2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppParallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0), dplyr (&ge; 1.0.3),
gifski, tidyr, fields, scico, plot3D, pracma, RColorBrewer,
maps, covr, styler, V8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/egpivo/SpatPCA">https://github.com/egpivo/SpatPCA</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-12 12:12:19 UTC; joseph</td>
</tr>
<tr>
<td>Author:</td>
<td>Wen-Ting Wang <a href="https://orcid.org/0000-0003-3051-7302"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Hsin-Cheng Huang <a href="https://orcid.org/0000-0002-5613-349X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wen-Ting Wang &lt;egpivo@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-13 09:33:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='checkInputData'>Internal function: Validate input data for a spatpca object</h2><span id='topic+checkInputData'></span>

<h3>Description</h3>

<p>Internal function: Validate input data for a spatpca object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkInputData(Y, x, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkInputData_+3A_y">Y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="checkInputData_+3A_x">x</code></td>
<td>
<p>Location matrix.</p>
</td></tr>
<tr><td><code id="checkInputData_+3A_m">M</code></td>
<td>
<p>Number of folds for cross-validation</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>.
</p>

<hr>
<h2 id='checkNewLocationsForSpatpcaObject'>Internal function: Validate new locations for a spatpca object</h2><span id='topic+checkNewLocationsForSpatpcaObject'></span>

<h3>Description</h3>

<p>Internal function: Validate new locations for a spatpca object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkNewLocationsForSpatpcaObject(spatpca_object, x_new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkNewLocationsForSpatpcaObject_+3A_spatpca_object">spatpca_object</code></td>
<td>
<p>An <code>spatpca</code> class object</p>
</td></tr>
<tr><td><code id="checkNewLocationsForSpatpcaObject_+3A_x_new">x_new</code></td>
<td>
<p>New location matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>.
</p>

<hr>
<h2 id='detrend'>Internal function: Detrend Y by column-wise centering</h2><span id='topic+detrend'></span>

<h3>Description</h3>

<p>Internal function: Detrend Y by column-wise centering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrend(Y, is_Y_detrended)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detrend_+3A_y">Y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Detrended data matrix
</p>

<hr>
<h2 id='eigenFunction'>Interpolated Eigen-function</h2><span id='topic+eigenFunction'></span>

<h3>Description</h3>

<p>Produce Eigen-function values based on new locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenFunction(new_location, original_location, Phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenFunction_+3A_new_location">new_location</code></td>
<td>
<p>A location matrix</p>
</td></tr>
<tr><td><code id="eigenFunction_+3A_original_location">original_location</code></td>
<td>
<p>A location matrix</p>
</td></tr>
<tr><td><code id="eigenFunction_+3A_phi">Phi</code></td>
<td>
<p>An eigenvector matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A predictive estimate matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pesudo_sequence &lt;- seq(-5, 5, length = 2)
original_location &lt;- as.matrix(expand.grid(x = pesudo_sequence, y = pesudo_sequence))
new_location &lt;- matrix(c(0.1, 0.2), nrow = 1, ncol = 2)
Phi &lt;- matrix(c(1, 0, 0, 0), nrow = 4, ncol = 1)
thin_plate_matrix &lt;- eigenFunction(new_location, original_location, Phi)
</code></pre>

<hr>
<h2 id='fetchUpperBoundNumberEigenfunctions'>Internal function: Fetch the upper bound of the number of eigenfunctions</h2><span id='topic+fetchUpperBoundNumberEigenfunctions'></span>

<h3>Description</h3>

<p>Internal function: Fetch the upper bound of the number of eigenfunctions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetchUpperBoundNumberEigenfunctions(Y, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetchUpperBoundNumberEigenfunctions_+3A_y">Y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="fetchUpperBoundNumberEigenfunctions_+3A_m">M</code></td>
<td>
<p>Number of folds for cross-validation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>

<hr>
<h2 id='plot.spatpca'>Display the cross-validation results</h2><span id='topic+plot.spatpca'></span>

<h3>Description</h3>

<p>Display the M-fold cross-validation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spatpca'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.spatpca_+3A_x">x</code></td>
<td>
<p>An spatpca class object for <code>plot</code> method</p>
</td></tr>
<tr><td><code id="plot.spatpca_+3A_...">...</code></td>
<td>
<p>Not used directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+spatpca">spatpca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_1D &lt;- as.matrix(seq(-5, 5, length = 10))
Phi_1D &lt;- exp(-x_1D^2) / norm(exp(-x_1D^2), "F")
set.seed(1234)
Y_1D &lt;- rnorm(n = 100, sd = 3) %*% t(Phi_1D) + matrix(rnorm(n = 100 * 10), 100, 10)
cv_1D &lt;- spatpca(x = x_1D, Y = Y_1D, num_cores = 2)
plot(cv_1D)
</code></pre>

<hr>
<h2 id='predict'>Spatial predictions on new locations</h2><span id='topic+predict'></span>

<h3>Description</h3>

<p>Predict the response on new locations with the estimated spatial structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict(spatpca_object, x_new, eigen_patterns_on_new_site = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_spatpca_object">spatpca_object</code></td>
<td>
<p>An <code>spatpca</code> class object</p>
</td></tr>
<tr><td><code id="predict_+3A_x_new">x_new</code></td>
<td>
<p>New location matrix.</p>
</td></tr>
<tr><td><code id="predict_+3A_eigen_patterns_on_new_site">eigen_patterns_on_new_site</code></td>
<td>
<p>Eigen-patterns on x_new</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A prediction matrix of Y at the new locations, x_new.
</p>


<h3>See Also</h3>

<p><a href="#topic+spatpca">spatpca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1D: artificial irregular locations
x_1D &lt;- as.matrix(seq(-5, 5, length = 10))
Phi_1D &lt;- exp(-x_1D^2) / norm(exp(-x_1D^2), "F")
set.seed(1234)
Y_1D &lt;- rnorm(n = 100, sd = 3) %*% t(Phi_1D) + matrix(rnorm(n = 100 * 10), 100, 10)
removed_location &lt;- sample(1:10, 3)
removed_x_1D &lt;- x_1D[-removed_location]
removed_Y_1D &lt;- Y_1D[, -removed_location]
new_x_1D &lt;- as.matrix(seq(-5, 5, length = 20))
cv_1D &lt;- spatpca(x = removed_x_1D, Y = removed_Y_1D, tau2 = 1:100, num_cores = 2)
predictions &lt;- predict(cv_1D, x_new = new_x_1D)

</code></pre>

<hr>
<h2 id='predictEigenfunction'>Spatial dominant patterns on new locations</h2><span id='topic+predictEigenfunction'></span>

<h3>Description</h3>

<p>Estimate K eigenfunctions on new locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictEigenfunction(spatpca_object, x_new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictEigenfunction_+3A_spatpca_object">spatpca_object</code></td>
<td>
<p>An <code>spatpca</code> class object</p>
</td></tr>
<tr><td><code id="predictEigenfunction_+3A_x_new">x_new</code></td>
<td>
<p>New location matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with K Eigenfunction values on new locations.
</p>


<h3>See Also</h3>

<p><a href="#topic+spatpca">spatpca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1D: artificial irregular locations
x_1D &lt;- as.matrix(seq(-5, 5, length = 10))
Phi_1D &lt;- exp(-x_1D^2) / norm(exp(-x_1D^2), "F")
set.seed(1234)
Y_1D &lt;- rnorm(n = 100, sd = 3) %*% t(Phi_1D) + matrix(rnorm(n = 100 * 10), 100, 10)
rm_loc &lt;- sample(1:10, 2)
x_1Drm &lt;- x_1D[-rm_loc]
Y_1Drm &lt;- Y_1D[, -rm_loc]
x_1Dnew &lt;- as.matrix(seq(-5, 5, length = 20))
cv_1D &lt;- spatpca(x = x_1Drm, Y = Y_1Drm, tau2 = 1:100, num_cores = 2)
dominant_patterns &lt;- predictEigenfunction(cv_1D, x_new = x_1Dnew)

</code></pre>

<hr>
<h2 id='scaleLocation'>Internal function: Scale one-dimension locations</h2><span id='topic+scaleLocation'></span>

<h3>Description</h3>

<p>Internal function: Scale one-dimension locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleLocation(location)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleLocation_+3A_location">location</code></td>
<td>
<p>Location matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scaled location matrix
</p>

<hr>
<h2 id='setCores'>Internal function: Set the number of cores for parallel computing</h2><span id='topic+setCores'></span>

<h3>Description</h3>

<p>Internal function: Set the number of cores for parallel computing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCores(num_cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setCores_+3A_num_cores">num_cores</code></td>
<td>
<p>Number of number of cores for parallel computing. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>

<hr>
<h2 id='setGamma'>Internal function: Set tuning parameter - gamma</h2><span id='topic+setGamma'></span>

<h3>Description</h3>

<p>Internal function: Set tuning parameter - gamma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGamma(gamma, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setGamma_+3A_gamma">gamma</code></td>
<td>
<p>Vector of a nonnegative hyper parameter sequence for tuning eigenvalues. Default is NULL.</p>
</td></tr>
<tr><td><code id="setGamma_+3A_y">Y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified vector of a nonnegative hyper parameter sequence for tuning eigenvalues.
</p>

<hr>
<h2 id='setL2'>Internal function: Set tuning parameter - l2</h2><span id='topic+setL2'></span>

<h3>Description</h3>

<p>Internal function: Set tuning parameter - l2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setL2(tau2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setL2_+3A_tau2">tau2</code></td>
<td>
<p>Vector of a nonnegative sparseness parameter sequence. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified vector of a nonnegative tuning parameter sequence for ADMM use
</p>

<hr>
<h2 id='setNumberEigenfunctions'>Internal function: Set the number of eigenfunctions for a spatpca object</h2><span id='topic+setNumberEigenfunctions'></span>

<h3>Description</h3>

<p>Internal function: Set the number of eigenfunctions for a spatpca object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setNumberEigenfunctions(K, Y, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setNumberEigenfunctions_+3A_k">K</code></td>
<td>
<p>Optional user-supplied number of eigenfunctions.</p>
</td></tr>
<tr><td><code id="setNumberEigenfunctions_+3A_y">Y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="setNumberEigenfunctions_+3A_m">M</code></td>
<td>
<p>Number of folds for cross-validation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>

<hr>
<h2 id='setTau1'>Internal function: Set tuning parameter - tau1</h2><span id='topic+setTau1'></span>

<h3>Description</h3>

<p>Internal function: Set tuning parameter - tau1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTau1(tau1, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setTau1_+3A_tau1">tau1</code></td>
<td>
<p>Vector of a nonnegative smoothness parameter sequence. Default is NULL.</p>
</td></tr>
<tr><td><code id="setTau1_+3A_m">M</code></td>
<td>
<p>Number of folds for cross-validation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified vector of a nonnegative smoothness parameter sequence.
</p>

<hr>
<h2 id='setTau2'>Internal function: Set tuning parameter - tau2</h2><span id='topic+setTau2'></span>

<h3>Description</h3>

<p>Internal function: Set tuning parameter - tau2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTau2(tau2, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setTau2_+3A_tau2">tau2</code></td>
<td>
<p>Vector of a nonnegative sparseness parameter sequence. Default is NULL.</p>
</td></tr>
<tr><td><code id="setTau2_+3A_m">M</code></td>
<td>
<p>Number of folds for cross-validation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified vector of a nonnegative sparseness parameter sequence.
</p>

<hr>
<h2 id='spatialPrediction'>Internal function: Spatial prediction</h2><span id='topic+spatialPrediction'></span>

<h3>Description</h3>

<p>Internal function: Spatial prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialPrediction(phir, Yr, gamma, predicted_eignefunction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialPrediction_+3A_phir">phir</code></td>
<td>
<p>A matrix of estimated eigenfunctions based on original locations</p>
</td></tr>
<tr><td><code id="spatialPrediction_+3A_yr">Yr</code></td>
<td>
<p>A data matrix</p>
</td></tr>
<tr><td><code id="spatialPrediction_+3A_gamma">gamma</code></td>
<td>
<p>A gamma value</p>
</td></tr>
<tr><td><code id="spatialPrediction_+3A_predicted_eignefunction">predicted_eignefunction</code></td>
<td>
<p>A vector of values of an eigenfunction on new locations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects
</p>
<table>
<tr><td><code>prediction</code></td>
<td>
<p>A vector of spatial predictions</p>
</td></tr>
<tr><td><code>estimated_covariance</code></td>
<td>
<p>An estimated covariance matrix.</p>
</td></tr>
<tr><td><code>eigenvalue</code></td>
<td>
<p>A vector of estimated eigenvalues.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>Error rate for the ADMM algorithm</p>
</td></tr>
</table>

<hr>
<h2 id='spatpca'>Regularized PCA for spatial data</h2><span id='topic+spatpca'></span>

<h3>Description</h3>

<p>Produce spatial dominant patterns and spatial predictions at the designated locations according to the specified tuning parameters or the selected tuning parameters by the M-fold cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatpca(
  x,
  Y,
  M = 5,
  K = NULL,
  is_K_selected = ifelse(is.null(K), TRUE, FALSE),
  tau1 = NULL,
  tau2 = NULL,
  gamma = NULL,
  is_Y_detrended = FALSE,
  maxit = 100,
  thr = 1e-04,
  num_cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatpca_+3A_x">x</code></td>
<td>
<p>Location matrix (<code class="reqn">p \times d</code>). Each row is a location. <code class="reqn">d</code> is the dimension of locations</p>
</td></tr>
<tr><td><code id="spatpca_+3A_y">Y</code></td>
<td>
<p>Data matrix (<code class="reqn">n \times p</code>) stores the values at <code class="reqn">p</code> locations with sample size <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="spatpca_+3A_m">M</code></td>
<td>
<p>Optional number of folds for cross validation; default is 5.</p>
</td></tr>
<tr><td><code id="spatpca_+3A_k">K</code></td>
<td>
<p>Optional user-supplied number of eigenfunctions; default is NULL. If K is NULL or is_K_selected is TRUE, K is selected automatically.</p>
</td></tr>
<tr><td><code id="spatpca_+3A_is_k_selected">is_K_selected</code></td>
<td>
<p>If TRUE, K is selected automatically; otherwise, is_K_selected is set to be user-supplied K. Default depends on user-supplied K.</p>
</td></tr>
<tr><td><code id="spatpca_+3A_tau1">tau1</code></td>
<td>
<p>Optional user-supplied numeric vector of a non-negative smoothness parameter sequence. If NULL, 10 tau1 values in a range are used.</p>
</td></tr>
<tr><td><code id="spatpca_+3A_tau2">tau2</code></td>
<td>
<p>Optional user-supplied numeric vector of a non-negative sparseness parameter sequence. If NULL, none of tau2 is used.</p>
</td></tr>
<tr><td><code id="spatpca_+3A_gamma">gamma</code></td>
<td>
<p>Optional user-supplied numeric vector of a non-negative tuning parameter sequence. If NULL, 10 values in a range are used.</p>
</td></tr>
<tr><td><code id="spatpca_+3A_is_y_detrended">is_Y_detrended</code></td>
<td>
<p>If TRUE, center the columns of Y. Default is FALSE.</p>
</td></tr>
<tr><td><code id="spatpca_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations. Default value is 100.</p>
</td></tr>
<tr><td><code id="spatpca_+3A_thr">thr</code></td>
<td>
<p>Threshold for convergence. Default value is <code class="reqn">10^{-4}</code>.</p>
</td></tr>
<tr><td><code id="spatpca_+3A_num_cores">num_cores</code></td>
<td>
<p>Number of cores used to parallel computing. Default value is NULL (See <code>RcppParallel::defaultNumThreads()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An ADMM form of the proposed objective function is written as
</p>
<p style="text-align: center;"><code class="reqn">\min_{\mathbf{\Phi}} \|\mathbf{Y}-\mathbf{Y}\mathbf{\Phi}\mathbf{\Phi}'\|^2_F +\tau_1\mbox{tr}(\mathbf{\Phi}^T\mathbf{\Omega}\mathbf{\Phi})+\tau_2\sum_{k=1}^K\sum_{j=1}^p |\phi_{jk}|,</code>
</p>

<p><code class="reqn">\mbox{subject to $ \mathbf{\Phi}^T\mathbf{\Phi}=\mathbf{I}_K$,}</code> where <code class="reqn">\mathbf{Y}</code> is a data matrix, <code class="reqn">{\mathbf{\Omega}}</code> is a smoothness matrix, and <code class="reqn">\mathbf{\Phi}=\{\phi_{jk}\}</code>.
</p>


<h3>Value</h3>

<p>A list of objects including
</p>
<table>
<tr><td><code>eigenfn</code></td>
<td>
<p>Estimated eigenfunctions at the new locations, x_new.</p>
</td></tr>
<tr><td><code>selected_K</code></td>
<td>
<p>Selected K based on CV. Execute the algorithm when <code>is_K_selected</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>selected_tau1</code></td>
<td>
<p>Selected tau1.</p>
</td></tr>
<tr><td><code>selected_tau2</code></td>
<td>
<p>Selected tau2.</p>
</td></tr>
<tr><td><code>selected_gamma</code></td>
<td>
<p>Selected gamma.</p>
</td></tr>
<tr><td><code>cv_score_tau1</code></td>
<td>
<p>cv scores for tau1.</p>
</td></tr>
<tr><td><code>cv_score_tau2</code></td>
<td>
<p>cv scores for tau2.</p>
</td></tr>
<tr><td><code>cv_score_gamma</code></td>
<td>
<p>cv scores for gamma.</p>
</td></tr>
<tr><td><code>tau1</code></td>
<td>
<p>Sequence of tau1-values used in the process.</p>
</td></tr>
<tr><td><code>tau2</code></td>
<td>
<p>Sequence of tau2-values used in the process.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>Sequence of gamma-values used in the process.</p>
</td></tr>
<tr><td><code>detrended_Y</code></td>
<td>
<p>If is_Y_detrended is TRUE, detrended_Y means Y is detrended; else, detrended_Y is equal to Y.</p>
</td></tr>
<tr><td><code>scaled_x</code></td>
<td>
<p>Input location matrix. Only scale when it is one-dimensional</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wen-Ting Wang and Hsin-Cheng Huang
</p>


<h3>References</h3>

<p>Wang, W.-T. and Huang, H.-C. (2017). Regularized principal component analysis for spatial data. <em>Journal of Computational and Graphical Statistics</em> <b>26</b> 14-25.
</p>


<h3>See Also</h3>

<p><a href="#topic+predict">predict</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following examples only use two threads for parallel computing.
## 1D: regular locations
x_1D &lt;- as.matrix(seq(-5, 5, length = 50))
Phi_1D &lt;- exp(-x_1D^2) / norm(exp(-x_1D^2), "F")
set.seed(1234)
Y_1D &lt;- rnorm(n = 100, sd = 3) %*% t(Phi_1D) + matrix(rnorm(n = 100 * 50), 100, 50)
cv_1D &lt;- spatpca(x = x_1D, Y = Y_1D, num_cores = 2)
plot(x_1D, cv_1D$eigenfn[, 1], type = "l", main = "1st eigenfunction")
lines(x_1D, svd(Y_1D)$v[, 1], col = "red")
legend("topleft", c("SpatPCA", "PCA"), lty = 1:1, col = 1:2)


## 2D: Daily 8-hour ozone averages for sites in the Midwest (USA)
library(fields)
library(pracma)
library(maps)
data(ozone2)
x &lt;- ozone2$lon.lat
Y &lt;- ozone2$y
date &lt;- as.Date(ozone2$date, format = "%y%m%d")
rmna &lt;- !colSums(is.na(Y))
YY &lt;- matrix(Y[, rmna], nrow = nrow(Y))
YY &lt;- detrend(YY, "linear")
xx &lt;- x[rmna, ]
cv &lt;- spatpca(x = xx, Y = YY)
quilt.plot(xx, cv$eigenfn[, 1])
map("state", xlim = range(xx[, 1]), ylim = range(xx[, 2]), add = TRUE)
map.text("state", xlim = range(xx[, 1]), ylim = range(xx[, 2]), cex = 2, add = TRUE)
plot(date, YY %*% cv$eigenfn[, 1], type = "l", ylab = "1st Principal Component")
### new loactions
new_p &lt;- 200
x_lon &lt;- seq(min(xx[, 1]), max(xx[, 1]), length = new_p)
x_lat &lt;- seq(min(xx[, 2]), max(xx[, 2]), length = new_p)
xx_new &lt;- as.matrix(expand.grid(x = x_lon, y = x_lat))
eof &lt;- spatpca(x = xx,
               Y = YY,
               K = cv$selected_K,
               tau1 = cv$selected_tau1,
               tau2 = cv$selected_tau2)
predicted_eof &lt;- predictEigenfunction(eof, xx_new)
quilt.plot(xx_new,
           predicted_eof[,1],
           nx = new_p,
           ny = new_p,
           xlab = "lon.",
           ylab = "lat.")
map("state", xlim = range(x_lon), ylim = range(x_lat), add = TRUE)
map.text("state", xlim = range(x_lon), ylim = range(x_lat), cex = 2, add = TRUE)
## 3D: regular locations
p &lt;- 10
x &lt;- y &lt;- z &lt;- as.matrix(seq(-5, 5, length = p))
d &lt;- expand.grid(x, y, z)
Phi_3D &lt;- rowSums(exp(-d^2)) / norm(as.matrix(rowSums(exp(-d^2))), "F")
Y_3D &lt;- rnorm(n = 100, sd = 3) %*% t(Phi_3D) + matrix(rnorm(n = 100 * p^3), 100, p^3)
cv_3D &lt;- spatpca(x = d, Y = Y_3D, tau2 = seq(0, 1000, length = 10))
library(plot3D)
library(RColorBrewer)
cols &lt;- colorRampPalette(brewer.pal(9, "Blues"))(p)
isosurf3D(x, y, z,
         colvar = array(cv_3D$eigenfn[, 1], c(p, p, p)),
         level= seq(min(cv_3D$eigenfn[, 1]), max(cv_3D$eigenfn[, 1]), length = p),
         ticktype = "detailed",
         colkey = list(side = 1),
         col = cols)

</code></pre>

<hr>
<h2 id='SpatPCA-package'>Regularized Principal Component Analysis for Spatial Data</h2><span id='topic+SpatPCA-package'></span>

<h3>Description</h3>

<p>A new regularization approach to estimate the leading spatial patterns via smoothness and sparseness penalties, and spatial predictions for spatial data that may be irregularly located in space (including 1D, 2D and 3D), and obtain the spatial prediction at the designated locations.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package:</td><td style="text-align: left;"> SpatPCA</td>
</tr>
<tr>
 <td style="text-align: left;">
Type:</td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version:</td><td style="text-align: left;">  1.3.3.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date:</td><td style="text-align: left;"> 2021-02-11</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL version 3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

 
<p>Wen-Ting Wang &lt;egpivo@gmail.com&gt; and Hsin-Cheng Huang &lt;hchuang@stat.sinica.edu.tw&gt;
</p>

<hr>
<h2 id='spatpcaCV'>Internal function: M-fold Cross-validation</h2><span id='topic+spatpcaCV'></span>

<h3>Description</h3>

<p>Internal function: M-fold Cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatpcaCV(sxyr, Yr, M, K, tau1r, tau2r, gammar, nkr, maxit, tol, l2r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatpcaCV_+3A_sxyr">sxyr</code></td>
<td>
<p>A location matrix</p>
</td></tr>
<tr><td><code id="spatpcaCV_+3A_yr">Yr</code></td>
<td>
<p>A data matrix</p>
</td></tr>
<tr><td><code id="spatpcaCV_+3A_m">M</code></td>
<td>
<p>The number of folds for CV</p>
</td></tr>
<tr><td><code id="spatpcaCV_+3A_k">K</code></td>
<td>
<p>The number of estimated eigen-functions</p>
</td></tr>
<tr><td><code id="spatpcaCV_+3A_tau1r">tau1r</code></td>
<td>
<p>A range of tau1</p>
</td></tr>
<tr><td><code id="spatpcaCV_+3A_tau2r">tau2r</code></td>
<td>
<p>A range of tau2</p>
</td></tr>
<tr><td><code id="spatpcaCV_+3A_gammar">gammar</code></td>
<td>
<p>A range of gamma</p>
</td></tr>
<tr><td><code id="spatpcaCV_+3A_nkr">nkr</code></td>
<td>
<p>A vector of fold numbers</p>
</td></tr>
<tr><td><code id="spatpcaCV_+3A_maxit">maxit</code></td>
<td>
<p>A maximum number of iteration</p>
</td></tr>
<tr><td><code id="spatpcaCV_+3A_tol">tol</code></td>
<td>
<p>A tolerance rate</p>
</td></tr>
<tr><td><code id="spatpcaCV_+3A_l2r">l2r</code></td>
<td>
<p>A given tau2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of selected parameters
</p>

<hr>
<h2 id='spatpcaCVWithSelectedK'>Internal function: M-fold CV of SpatPCA with selected K</h2><span id='topic+spatpcaCVWithSelectedK'></span>

<h3>Description</h3>

<p>Internal function: M-fold CV of SpatPCA with selected K
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatpcaCVWithSelectedK(
  x,
  Y,
  M,
  tau1,
  tau2,
  gamma,
  shuffle_split,
  maxit,
  thr,
  l2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatpcaCVWithSelectedK_+3A_x">x</code></td>
<td>
<p>Location matrix</p>
</td></tr>
<tr><td><code id="spatpcaCVWithSelectedK_+3A_y">Y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="spatpcaCVWithSelectedK_+3A_m">M</code></td>
<td>
<p>The number of folds for cross validation; default is 5.</p>
</td></tr>
<tr><td><code id="spatpcaCVWithSelectedK_+3A_tau1">tau1</code></td>
<td>
<p>Vector of a non-negative smoothness parameter sequence. If NULL, 10 tau1 values in a range are used.</p>
</td></tr>
<tr><td><code id="spatpcaCVWithSelectedK_+3A_tau2">tau2</code></td>
<td>
<p>Vector of a non-negative sparseness parameter sequence. If NULL, none of tau2 is used.</p>
</td></tr>
<tr><td><code id="spatpcaCVWithSelectedK_+3A_gamma">gamma</code></td>
<td>
<p>Vector of a non-negative hyper parameter sequence for tuning eigenvalues. If NULL, 10 values in a range are used.</p>
</td></tr>
<tr><td><code id="spatpcaCVWithSelectedK_+3A_shuffle_split">shuffle_split</code></td>
<td>
<p>Vector of indices for random splitting Y into training and test sets</p>
</td></tr>
<tr><td><code id="spatpcaCVWithSelectedK_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations. Default value is 100.</p>
</td></tr>
<tr><td><code id="spatpcaCVWithSelectedK_+3A_thr">thr</code></td>
<td>
<p>Threshold for convergence. Default value is <code class="reqn">10^{-4}</code>.</p>
</td></tr>
<tr><td><code id="spatpcaCVWithSelectedK_+3A_l2">l2</code></td>
<td>
<p>Vector of a non-negative tuning parameter sequence for ADMM use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects including
</p>
<table>
<tr><td><code>cv_result</code></td>
<td>
<p>A list of resultant objects produced by <code>spatpcaCV</code></p>
</td></tr>
<tr><td><code>selected_K</code></td>
<td>
<p>Selected K based on CV.</p>
</td></tr>
</table>

<hr>
<h2 id='thinPlateSplineMatrix'>Thin-plane spline matrix</h2><span id='topic+thinPlateSplineMatrix'></span>

<h3>Description</h3>

<p>Produce a thin-plane spline matrix based on a given location matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thinPlateSplineMatrix(location)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thinPlateSplineMatrix_+3A_location">location</code></td>
<td>
<p>A location matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A thin-plane spline matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pesudo_sequence &lt;- seq(-5, 5, length = 5)
two_dim_location &lt;- as.matrix(expand.grid(x = pesudo_sequence, y = pesudo_sequence))
thin_plate_matrix &lt;- thinPlateSplineMatrix(two_dim_location)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
