<!DOCTYPE html><html><head><title>Help for package samc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {samc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#absorption'><p>Calculate absorption metrics</p></a></li>
<li><a href='#char_null-class'><p>samc char_null class</p></a></li>
<li><a href='#check'><p>Check landscape data</p></a></li>
<li><a href='#cond_passage'><p>Conditional Mean First Passage Time</p></a></li>
<li><a href='#dispersal'><p>Calculate dispersal metrics</p></a></li>
<li><a href='#distribution'><p>Calculate distribution metrics</p></a></li>
<li><a href='#example_maze'><p>Simple maze example</p></a></li>
<li><a href='#example_split_corridor'><p>Simple split corridor example</p></a></li>
<li><a href='#example_toy_res'><p>Toy resistance data</p></a></li>
<li><a href='#locate'><p>Get cell numbers</p></a></li>
<li><a href='#location-class'><p>location class</p></a></li>
<li><a href='#map'><p>Map vector data</p></a></li>
<li><a href='#mat_null-class'><p>samc mat_null class</p></a></li>
<li><a href='#mortality'><p>Calculate mortality metrics</p></a></li>
<li><a href='#pairwise'><p>Pairwise analyses</p></a></li>
<li><a href='#rasterize'><p>Rasterize input</p></a></li>
<li><a href='#samc'><p>Create an samc object</p></a></li>
<li><a href='#samc_data-class'><p>data class</p></a></li>
<li><a href='#samc-class'><p>samc class</p></a></li>
<li><a href='#samc-class-access'><p>Access samc-class components</p></a></li>
<li><a href='#samc-class-modify'><p>Modify samc-class components</p></a></li>
<li><a href='#survival'><p>Calculate survival metrics</p></a></li>
<li><a href='#visitation'><p>Calculate visitation metrics</p></a></li>
<li><a href='#visitation_net'><p>Calculate net visitation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Absorbing Markov Chains</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements functions for working with absorbing Markov chains. The
    implementation is based on the framework described in "Toward a unified
    framework for connectivity that disentangles movement and mortality in space
    and time" by Fletcher et al. (2019) &lt;<a href="https://doi.org/10.1111%2Fele.13333">doi:10.1111/ele.13333</a>&gt;, which applies
    them to spatial ecology. This framework incorporates both resistance and 
    absorption with spatial absorbing Markov chains (SAMC) to provide several
    short-term and long-term predictions for metrics related to connectivity in 
    landscapes. Despite the ecological context of the framework, this package
    can be used in any application of absorbing Markov chains.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://andrewmarx.github.io/samc/">https://andrewmarx.github.io/samc/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/andrewmarx/samc/issues/">https://github.com/andrewmarx/samc/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Matrix (&ge; 1.5-3), raster, terra (&ge; 1.7-3), circular</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, gdistance, viridisLite</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'location-class.R' 'internal-classes.R'
'samc-class.R' 'absorption.R' 'check.R' 'cond_passage.R'
'data.R' 'visitation.R' 'dispersal.R' 'distribution.R'
'generics.R' 'internal-functions.R' 'locate.R' 'map.R'
'mortality.R' 'pairwise.R' 'rasterize.R' 'samc.R' 'survival.R'
'zzz.R'</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.10), RcppEigen (&ge; 0.3.3.9.3), RcppThread (&ge;
2.1.3)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-08 22:35:04 UTC; andrewjmarx</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Marx <a href="https://orcid.org/0000-0002-7456-1631"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Robert Fletcher <a href="https://orcid.org/0000-0003-1717-5707"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Miguel Acevedo <a href="https://orcid.org/0000-0002-8289-1497"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jorge Sefair <a href="https://orcid.org/0000-0002-5887-8938"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Chao Wang <a href="https://orcid.org/0000-0003-2706-5122"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Hughes Josie <a href="https://orcid.org/0000-0001-7875-9015"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Barrett Griffin [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Marx &lt;ajm.rpackages@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-09 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='absorption'>Calculate absorption metrics</h2><span id='topic+absorption'></span><span id='topic+absorption+2Csamc+2Cmissing+2Cmissing-method'></span><span id='topic+absorption+2Csamc+2Cmissing+2Clocation-method'></span><span id='topic+absorption+2Csamc+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Calculates the probability of absorption for absorbing states rather
than individual transient states. This is distint from, yet very closely linked
to, the mortality() metric, which calculates the probability of absorption at
individual transient states. If the results of the mortality() metric are decomposed
into individual results for each absorbing state, then the sums of the individual
results for every transient state are equivalent to the results of the absorption()
metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absorption(samc, init, origin)

## S4 method for signature 'samc,missing,missing'
absorption(samc)

## S4 method for signature 'samc,missing,location'
absorption(samc, origin)

## S4 method for signature 'samc,ANY,missing'
absorption(samc, init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absorption_+3A_samc">samc</code></td>
<td>
<p>A <code><a href="#topic+samc-class">samc-class</a></code> object created using the <code><a href="#topic+samc">samc</a></code> function.</p>
</td></tr>
<tr><td><code id="absorption_+3A_init">init</code></td>
<td>
<p>Sets the initial state <code class="reqn">\psi</code> of the transients states. Input
must be able to pass the <code><a href="#topic+check">check</a></code> function when compared against
the <code><a href="#topic+samc-class">samc-class</a></code> object. Can only contain positive finite values.</p>
</td></tr>
<tr><td><code id="absorption_+3A_origin">origin</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{i}</code>. Corresponds to row <code class="reqn">\mathit{i}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>dest</code>
parameter, multiple values may be provided as a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">A = F R</code>
</p>

<ul>
<li> <p><strong>absorption(samc)</strong>
</p>
<p>The result is a matrix <code class="reqn">M</code> where <code class="reqn">M_{i,k}</code> is the
probability of absorption due to absorbing state <code class="reqn">\mathit{k}</code> if starting
at transient state <code class="reqn">\mathit{i}</code>.
</p>
</li>
<li> <p><strong>absorption(samc, origin)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_{k}</code> is the
probability of absorption due to absorbing state <code class="reqn">\mathit{k}</code> if starting
at transient state <code class="reqn">\mathit{i}</code>.
</p>
</li></ul>

<p><code class="reqn">\psi^T A</code>
</p>

<ul>
<li> <p><strong>absorption(samc, init)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_{k}</code> is the
probability of absorption due to absorbing state <code class="reqn">\mathit{k}</code> given an
initial state <code class="reqn">\psi</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>See Details
</p>


<h3>Performance</h3>

<p>Any relevant performance information about this function can be found in the
performance vignette: <a href="../doc/performance.html"><code>vignette("performance", package = "samc")</code></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

<hr>
<h2 id='char_null-class'>samc char_null class</h2><span id='topic+char_null-class'></span>

<h3>Description</h3>

<p>Class for grouping character and NULL data types
</p>

<hr>
<h2 id='check'>Check landscape data</h2><span id='topic+check'></span><span id='topic+check+2CRaster+2Cmissing-method'></span><span id='topic+check+2CSpatRaster+2Cmissing-method'></span><span id='topic+check+2Cmatrix+2Cmissing-method'></span><span id='topic+check+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+check+2CRaster+2CRaster-method'></span><span id='topic+check+2Cmatrix+2Cmatrix-method'></span><span id='topic+check+2Csamc+2CRaster-method'></span><span id='topic+check+2Csamc+2CSpatRaster-method'></span><span id='topic+check+2Csamc+2Cmatrix-method'></span><span id='topic+check+2Csamc+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Check that landscape inputs have valid values and matching properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check(a, b)

## S4 method for signature 'Raster,missing'
check(a)

## S4 method for signature 'SpatRaster,missing'
check(a)

## S4 method for signature 'matrix,missing'
check(a)

## S4 method for signature 'SpatRaster,SpatRaster'
check(a, b)

## S4 method for signature 'Raster,Raster'
check(a, b)

## S4 method for signature 'matrix,matrix'
check(a, b)

## S4 method for signature 'samc,Raster'
check(a, b)

## S4 method for signature 'samc,SpatRaster'
check(a, b)

## S4 method for signature 'samc,matrix'
check(a, b)

## S4 method for signature 'samc,numeric'
check(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_+3A_a">a</code></td>
<td>
<p>A <code><a href="#topic+samc-class">samc-class</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>, or <code><a href="raster.html#topic+RasterLayer-class">RasterLayer-class</a></code> object</p>
</td></tr>
<tr><td><code id="check_+3A_b">b</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="raster.html#topic+RasterLayer-class">RasterLayer-class</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to ensure that inputs (resistance, absorption, fidelity,
and occupancy) have valid values and the same properties. This includes
checking the CRS (if using raster inputs), dimensions, and locations of
cells with NA data. It can be used to directly compare two matrices or two
rasters, or it can be used to check a <code><a href="#topic+samc-class">samc-class</a></code> object
against a matrix or raster.
</p>
<p>It can also be used to check a numeric vector against a <code><a href="#topic+samc-class">samc-class</a></code> object
created from a P matrix. In this case, the length of the vector must be equal to
the number of transient states. If the transient states are named, the vector
must contain the same names.
</p>
<p>The function returns <code>TRUE</code> if the inputs have matching properties. Otherwise,
it will stop execution and print an error message with details about the
difference between the two inputs.
</p>
<p>Note that the package assumes the different landscape inputs will be the same
type, either matrices or RasterLayers. Mixing RasterLayer data and matrix
data is not supported.
</p>


<h3>Value</h3>

<p>See <em>Details</em> section.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

<hr>
<h2 id='cond_passage'>Conditional Mean First Passage Time</h2><span id='topic+cond_passage'></span><span id='topic+cond_passage+2Csamc+2Cmissing+2Cmissing+2Clocation-method'></span><span id='topic+cond_passage+2Csamc+2Cmissing+2Clocation+2Clocation-method'></span>

<h3>Description</h3>

<p>Calculate the mean number of steps to first passage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_passage(samc, init, origin, dest)

## S4 method for signature 'samc,missing,missing,location'
cond_passage(samc, dest)

## S4 method for signature 'samc,missing,location,location'
cond_passage(samc, origin, dest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_passage_+3A_samc">samc</code></td>
<td>
<p>A <code><a href="#topic+samc-class">samc-class</a></code> object created using the <code><a href="#topic+samc">samc</a></code> function.</p>
</td></tr>
<tr><td><code id="cond_passage_+3A_init">init</code></td>
<td>
<p>Placeholder/not currently implemented.</p>
</td></tr>
<tr><td><code id="cond_passage_+3A_origin">origin</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{i}</code>. Corresponds to row <code class="reqn">\mathit{i}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>dest</code>
parameter, multiple values may be provided as a vector.</p>
</td></tr>
<tr><td><code id="cond_passage_+3A_dest">dest</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{j}</code>. Corresponds to column <code class="reqn">\mathit{j}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>origin</code> parameter,
multiple values may be provided as a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">\tilde{t}=\tilde{B}_j^{-1}\tilde{F}\tilde{B}_j{\cdot}1</code>
</p>

<ul>
<li> <p><strong>cond_passage(samc, dest)</strong>
</p>
<p>The result is a vector where each element corresponds to a cell in the landscape,
and can be mapped back to the landscape using the <code><a href="#topic+map">map</a></code> function.
Element <em>i</em> is the mean number of steps before absorption starting from
location <em>i</em> conditional on absorption into <em>j</em>
</p>
<p>Note that mathematically, the formula actually does not return a value for when
<em>i</em> is equal to <em>j</em>. This leads to a situation where the resultant vector
is actually one element short and the index for some of the elements may be shifted.
The <strong>cond_passage()</strong> function fills inserts a <code>0</code> value for vector indices
corresponding to <em>i == j</em>. This corrects the final result so that vector indices
work as expected, and allows the vector to be properly used in the <code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>cond_passage(samc, origin, dest)</strong>
</p>
<p>The result is a numeric value representing the mean number of steps before
absorption starting from a given origin conditional on absorption into <em>j</em>.
</p>
<p>As described above, mathematically the formula does not return a result for when
the <code>origin</code> and <code>dest</code> inputs are equal, so the function simply returns a <code>0</code>
in this case.
</p>
</li></ul>

<p><strong>WARNING</strong>: This function is not compatible when used with data where there
are states with total absorption present. When present, states representing
total absorption leads to unsolvable linear equations. The only exception to this
is when there is a single total absorption state that corresponds to input to
the <code>dest</code> parameter. In this case, the total absorption is effectively
ignored when the linear equations are solved.
</p>
<p><strong>WARNING</strong>: This function will crash when used with data representing
a disconnected graph. This includes, for example, isolated pixels or islands
in raster data. This is a result of the transition matrix for disconnected
graphs leading to some equations being unsolvable. Different options
are being explored for how to best identify these situations in data and
handle them accordingly.
</p>


<h3>Value</h3>

<p>See Details
</p>


<h3>Performance</h3>

<p>Any relevant performance information about this function can be found in the
performance vignette: <a href="../doc/performance.html"><code>vignette("performance", package = "samc")</code></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

<hr>
<h2 id='dispersal'>Calculate dispersal metrics</h2><span id='topic+dispersal'></span><span id='topic+dispersal+2Csamc+2Cmissing+2Cmissing+2Clocation+2Cnumeric-method'></span><span id='topic+dispersal+2Csamc+2CANY+2Cmissing+2Clocation+2Cnumeric-method'></span><span id='topic+dispersal+2Csamc+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+dispersal+2Csamc+2Cmissing+2Clocation+2Cmissing+2Cmissing-method'></span><span id='topic+dispersal+2Csamc+2Cmissing+2Cmissing+2Clocation+2Cmissing-method'></span><span id='topic+dispersal+2Csamc+2Cmissing+2Clocation+2Clocation+2Cmissing-method'></span><span id='topic+dispersal+2Csamc+2CANY+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+dispersal+2Csamc+2CANY+2Cmissing+2Clocation+2Cmissing-method'></span>

<h3>Description</h3>

<p>Calculates the probability of individuals visiting locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispersal(samc, init, origin, dest, time)

## S4 method for signature 'samc,missing,missing,location,numeric'
dispersal(samc, dest, time)

## S4 method for signature 'samc,ANY,missing,location,numeric'
dispersal(samc, init, dest, time)

## S4 method for signature 'samc,missing,missing,missing,missing'
dispersal(samc)

## S4 method for signature 'samc,missing,location,missing,missing'
dispersal(samc, origin)

## S4 method for signature 'samc,missing,missing,location,missing'
dispersal(samc, dest)

## S4 method for signature 'samc,missing,location,location,missing'
dispersal(samc, origin, dest)

## S4 method for signature 'samc,ANY,missing,missing,missing'
dispersal(samc, init)

## S4 method for signature 'samc,ANY,missing,location,missing'
dispersal(samc, init, dest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersal_+3A_samc">samc</code></td>
<td>
<p>A <code><a href="#topic+samc-class">samc-class</a></code> object created using the <code><a href="#topic+samc">samc</a></code> function.</p>
</td></tr>
<tr><td><code id="dispersal_+3A_init">init</code></td>
<td>
<p>Sets the initial state <code class="reqn">\psi</code> of the transients states. Input
must be able to pass the <code><a href="#topic+check">check</a></code> function when compared against
the <code><a href="#topic+samc-class">samc-class</a></code> object. Can only contain positive finite values.</p>
</td></tr>
<tr><td><code id="dispersal_+3A_origin">origin</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{i}</code>. Corresponds to row <code class="reqn">\mathit{i}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>dest</code>
parameter, multiple values may be provided as a vector.</p>
</td></tr>
<tr><td><code id="dispersal_+3A_dest">dest</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{j}</code>. Corresponds to column <code class="reqn">\mathit{j}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>origin</code> parameter,
multiple values may be provided as a vector.</p>
</td></tr>
<tr><td><code id="dispersal_+3A_time">time</code></td>
<td>
<p>A positive integer or a vector of positive integers representing
<code class="reqn">\mathit{t}</code> time steps. Vectors must be ordered and contain no duplicates.
Vectors may not be used for metrics that return dense matrices. The maximum time
step value is capped at 10,000 due to numerical precision issues.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">\tilde{D}_{jt}=(\sum_{n=0}^{t-1}\tilde{Q}^n)\tilde{q}_j</code>
</p>

<ul>
<li> <p><strong>dispersal(samc, dest, time)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_i</code> is the probability
of visiting transient state <code class="reqn">\mathit{j}</code> within <code class="reqn">\mathit{t}</code> or fewer
time steps if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>Note: Given the current derivation, when <code class="reqn">\mathit{i=j}</code>, then <code class="reqn">\mathbf{v}_i</code>
is unknown and has been set to <code>NA</code>.
</p>
<p>If multiple time steps were provided as a vector, then the result will be an
ordered named list containing a vector for each time step.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li></ul>

<p><code class="reqn">\psi^T\tilde{D}_{jt}</code>
</p>

<ul>
<li> <p><strong>dispersal(samc, init, dest, time)</strong>
</p>
<p>The result is a numeric that is the probability of visiting transient state <code class="reqn">\mathit{j}</code>
within <code class="reqn">\mathit{t}</code> or fewer time steps given an initial state <code class="reqn">\psi</code>
</p>
<p>If multiple time steps were provided as a vector, then the result will be an
ordered named list containing a vector for each time step.
</p>
</li></ul>

<p><code class="reqn">D=(F-I)diag(F)^{-1}</code>
</p>

<ul>
<li> <p><strong>dispersal(samc)</strong>
</p>
<p>The result is a matrix <code class="reqn">M</code> where <code class="reqn">M_{i,j}</code> is the probability of visiting
transient state <code class="reqn">\mathit{j}</code> if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>The returned matrix will always be dense and cannot be optimized. Must enable
override to use (see <code><a href="#topic+samc-class">samc-class</a></code>).
</p>
</li>
<li> <p><strong>dispersal(samc, origin)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the probability
of visiting transient state <code class="reqn">\mathit{j}</code> if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>dispersal(samc, dest)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_i</code> is the probability
of visiting transient state <code class="reqn">\mathit{j}</code> if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>dispersal(samc, origin, dest)</strong>
</p>
<p>The result is a numeric value that is the probability of visiting transient
state <code class="reqn">\mathit{j}</code> if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
</li></ul>

<p><code class="reqn">\psi^TD</code>
</p>

<ul>
<li> <p><strong>dispersal(samc, init)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the probability
of visiting transient state <code class="reqn">\mathit{j}</code> given an initial state <code class="reqn">\psi</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>dispersal(samc, init, dest)</strong>
</p>
<p>The result is a numeric value that is the probability of visiting transient
state <code class="reqn">\mathit{j}</code> given an initial state <code class="reqn">\psi</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>See Details
</p>


<h3>Performance</h3>

<p>Any relevant performance information about this function can be found in the
performance vignette: <a href="../doc/performance.html"><code>vignette("performance", package = "samc")</code></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

<hr>
<h2 id='distribution'>Calculate distribution metrics</h2><span id='topic+distribution'></span><span id='topic+distribution+2Csamc+2Cmissing+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+distribution+2Csamc+2Cmissing+2Clocation+2Cmissing+2Cnumeric-method'></span><span id='topic+distribution+2Csamc+2Cmissing+2Cmissing+2Clocation+2Cnumeric-method'></span><span id='topic+distribution+2Csamc+2Cmissing+2Clocation+2Clocation+2Cnumeric-method'></span><span id='topic+distribution+2Csamc+2CANY+2Cmissing+2Cmissing+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Calculate the probability of being at a transient state at a specific time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribution(samc, init, origin, dest, time)

## S4 method for signature 'samc,missing,missing,missing,numeric'
distribution(samc, time)

## S4 method for signature 'samc,missing,location,missing,numeric'
distribution(samc, origin, time)

## S4 method for signature 'samc,missing,missing,location,numeric'
distribution(samc, dest, time)

## S4 method for signature 'samc,missing,location,location,numeric'
distribution(samc, origin, dest, time)

## S4 method for signature 'samc,ANY,missing,missing,numeric'
distribution(samc, init, time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution_+3A_samc">samc</code></td>
<td>
<p>A <code><a href="#topic+samc-class">samc-class</a></code> object created using the <code><a href="#topic+samc">samc</a></code> function.</p>
</td></tr>
<tr><td><code id="distribution_+3A_init">init</code></td>
<td>
<p>Sets the initial state <code class="reqn">\psi</code> of the transients states. Input
must be able to pass the <code><a href="#topic+check">check</a></code> function when compared against
the <code><a href="#topic+samc-class">samc-class</a></code> object. Can only contain positive finite values.</p>
</td></tr>
<tr><td><code id="distribution_+3A_origin">origin</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{i}</code>. Corresponds to row <code class="reqn">\mathit{i}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>dest</code>
parameter, multiple values may be provided as a vector.</p>
</td></tr>
<tr><td><code id="distribution_+3A_dest">dest</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{j}</code>. Corresponds to column <code class="reqn">\mathit{j}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>origin</code> parameter,
multiple values may be provided as a vector.</p>
</td></tr>
<tr><td><code id="distribution_+3A_time">time</code></td>
<td>
<p>A positive integer or a vector of positive integers representing
<code class="reqn">\mathit{t}</code> time steps. Vectors must be ordered and contain no duplicates.
Vectors may not be used for metrics that return dense matrices. The maximum time
step value is capped at 10,000 due to numerical precision issues.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">Q^t</code>
</p>

<ul>
<li> <p><strong>distribution(samc, time)</strong>
</p>
<p>The result is a matrix <code class="reqn">M</code> where <code class="reqn">M_{i,j}</code> is the probability of being
at transient state <code class="reqn">\mathit{j}</code> after <code class="reqn">\mathit{t}</code> time steps if starting
at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>The returned matrix will always be dense and cannot be optimized. Must enable
override to use (see <code><a href="#topic+samc-class">samc-class</a></code>).
</p>
</li>
<li> <p><strong>distribution(samc, origin, time)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the probability
of being at transient state <code class="reqn">\mathit{j}</code> after <code class="reqn">\mathit{t}</code> time steps
if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If multiple time steps were provided as a vector, then the result will be an
ordered named list containing a vector for each time step.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>distribution(samc, dest, time)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_i</code> is the probability
of being at transient state <code class="reqn">\mathit{j}</code> after <code class="reqn">\mathit{t}</code> time steps
if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If multiple time steps were provided as a vector, then the result will be an
ordered named list containing a vector for each time step.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>distribution(samc, origin, dest, time)</strong>
</p>
<p>The result is a numeric value that is the probability of being at a transient
state <code class="reqn">\mathit{j}</code> after <code class="reqn">\mathit{t}</code> time steps if starting at transient
state <code class="reqn">\mathit{i}</code>.
</p>
<p>If multiple time steps were provided as a vector, then the result will be an
ordered named list containing a vector for each time step.
</p>
</li></ul>

<p><code class="reqn">\psi^TQ^t</code>
</p>

<ul>
<li> <p><strong>distribution(samc, init, time)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the probability
of being at transient state <code class="reqn">\mathit{i}</code> after <code class="reqn">\mathit{t}</code> time steps
given an initial state <code class="reqn">\psi</code>.
</p>
<p>If multiple time steps were provided as a vector, then the result will be an
ordered named list containing a vector for each time step.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li></ul>



<h3>Value</h3>

<p>See Details
</p>


<h3>Performance</h3>

<p>Any relevant performance information about this function can be found in the
performance vignette: <a href="../doc/performance.html"><code>vignette("performance", package = "samc")</code></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

<hr>
<h2 id='example_maze'>Simple maze example</h2><span id='topic+example_maze'></span>

<h3>Description</h3>

<p>A simple maze layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_maze
</code></pre>


<h3>Format</h3>

<p>A 20x20 matrix.
</p>


<h3>Source</h3>

<p>Generated for Maze Example vignettes
</p>

<hr>
<h2 id='example_split_corridor'>Simple split corridor example</h2><span id='topic+example_split_corridor'></span>

<h3>Description</h3>

<p>A fabricated dataset of a simple split corridor. Contains resistance,
absorption, and occupancy data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_split_corridor
</code></pre>


<h3>Format</h3>

<p>A list of three matrices. Matrices have 34 rows and 202 columns.
</p>


<h3>Source</h3>

<p>Fletcher et al (2019) &lt;doi:10.1111/ele.13333&gt;
</p>

<hr>
<h2 id='example_toy_res'>Toy resistance data</h2><span id='topic+example_toy_res'></span>

<h3>Description</h3>

<p>Toy resistance data used in a workshop at IALE 2021
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_toy_res
</code></pre>


<h3>Format</h3>

<p>A 10x10 matrix.
</p>


<h3>Source</h3>

<p>IALE 2021 workshop
</p>

<hr>
<h2 id='locate'>Get cell numbers</h2><span id='topic+locate'></span><span id='topic+locate+2Csamc+2Cmissing-method'></span><span id='topic+locate+2Csamc+2CANY-method'></span>

<h3>Description</h3>

<p>Get cell numbers from raster data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate(samc, xy)

## S4 method for signature 'samc,missing'
locate(samc)

## S4 method for signature 'samc,ANY'
locate(samc, xy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locate_+3A_samc">samc</code></td>
<td>
<p>A <code><a href="#topic+samc-class">samc-class</a></code> object</p>
</td></tr>
<tr><td><code id="locate_+3A_xy">xy</code></td>
<td>
<p>Any valid input to the y argument of the <code><a href="terra.html#topic+extract">extract</a></code> function in the raster package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to get cell numbers from raster data. The numbers used
for origin and destination values in many samc metrics refer to column/row
numbers of the P matrix. For a P matrix derived from raster data, these numbers
would normally line up with the cell numbers of the raster, but this is not
always true. This is the case when the raster contains NA data; the cells
associated with this data are excluded from the P matrix. This causes issues
trying to determine the cell numbers that should be used in analyses.
</p>
<p>The <code><a href="#topic+locate">locate</a></code> function operates more-or-less like the
<code><a href="terra.html#topic+cellFromXY">cellFromXY</a></code> function in the raster package, but unlike
<code><a href="terra.html#topic+cellFromXY">cellFromXY</a></code>, locate properly accounts for NA cells
in identifying cell numbers from coordinate data.
</p>
<p>This function can also be used if the samc object was created from matrix inputs
for the resistance, absorption, and fidelity parameters. In this case, the
values in the xy coordinate parameter can be column-row values with the caveat
that (1,1) is the bottom left corner.
</p>
<p>The xy parameter can also be excluded. In this case, the function returns a
raster where the values of the cells contains the cell number.
</p>
<p>Internally, this function relies on the <code><a href="terra.html#topic+extract">extract</a></code> function
from the raster package, and any valid input for the y argument of that function
is valid here.
</p>


<h3>Value</h3>

<p>A SpatRaster, RasterLayer, matrix, or a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(samc)


# Load example data
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs


# Create samc-class object
samc_obj &lt;- samc(res_data, abs_data,
                 model = list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE))


# We can use locate() to return an object with the cell numbers encoded as data
# in the cells
cell_raster &lt;- locate(samc_obj)
print(cell_raster)

# We can use a variety of spatial inputs to get cell numbers using locate()
# The simplest is a two-column data.frame
coords &lt;- data.frame(x = c(50, 79, 22),
                     y = c(25, 11, 19))
print(coords)
locate(samc_obj, coords)

# You will get an error if you input a coordinate that does not correspond
# to a non-NA cell
coords &lt;- data.frame(x = c(1),
                     y = c(1))
print(coords)
try(locate(samc_obj, coords))
</code></pre>

<hr>
<h2 id='location-class'>location class</h2><span id='topic+location-class'></span>

<h3>Description</h3>

<p>Union class for location inputs
</p>


<h3>Details</h3>

<p>The location class is a union class of the &quot;numeric&quot; and &quot;character&quot; classes.
Users generally do not need to worry about it except to know that any method
parameter with &quot;location&quot; as the type can have either an integer or a character
name provided as input.
</p>

<hr>
<h2 id='map'>Map vector data</h2><span id='topic+map'></span><span id='topic+map+2Csamc+2Cnumeric-method'></span><span id='topic+map+2Csamc+2Clist-method'></span>

<h3>Description</h3>

<p>Map vector data to a RasterLayer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(samc, vec)

## S4 method for signature 'samc,numeric'
map(samc, vec)

## S4 method for signature 'samc,list'
map(samc, vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_samc">samc</code></td>
<td>
<p>Spatial absorbing Markov chain object. This should be output from the samc() function.</p>
</td></tr>
<tr><td><code id="map_+3A_vec">vec</code></td>
<td>
<p>Vector data to fill into the map.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function to ensure that vector data is properly mapped
back to the original landscape data. The reason this is needed is that the package
supports matrices, RasterLayers, and SpatRasters, which can differ in the order
that data is read and written (R matrices are column-major order, whereas the
raster package uses row-major order). Internally, the package uses only a
single order, regardless of the original data. This can cause issues with
mapping vector results if care is not taken, and this function is provided to
simplify the process. It also correctly maps results for landscape data that
has NA cells, which are another potential source of error if not careful.
</p>
<p>The only requirement of the <code>vec</code> input is that the number of elements
in it matches the number of non-NA cells in the landscape data that was used
to create the samc object.
</p>


<h3>Value</h3>

<p>A matrix, RasterLayer, or SpatRaster object. The returned type will match
the type used to create the samc object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

<hr>
<h2 id='mat_null-class'>samc mat_null class</h2><span id='topic+mat_null-class'></span>

<h3>Description</h3>

<p>Class for grouping matrix and NULL data types
</p>

<hr>
<h2 id='mortality'>Calculate mortality metrics</h2><span id='topic+mortality'></span><span id='topic+mortality+2Csamc+2Cmissing+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+mortality+2Csamc+2Cmissing+2Clocation+2Cmissing+2Cnumeric-method'></span><span id='topic+mortality+2Csamc+2Cmissing+2Cmissing+2Clocation+2Cnumeric-method'></span><span id='topic+mortality+2Csamc+2Cmissing+2Clocation+2Clocation+2Cnumeric-method'></span><span id='topic+mortality+2Csamc+2CANY+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+mortality+2Csamc+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+mortality+2Csamc+2Cmissing+2Clocation+2Cmissing+2Cmissing-method'></span><span id='topic+mortality+2Csamc+2Cmissing+2Cmissing+2Clocation+2Cmissing-method'></span><span id='topic+mortality+2Csamc+2Cmissing+2Clocation+2Clocation+2Cmissing-method'></span><span id='topic+mortality+2Csamc+2CANY+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Calculates the probability of absorption at individual transient states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mortality(samc, init, origin, dest, time)

## S4 method for signature 'samc,missing,missing,missing,numeric'
mortality(samc, time)

## S4 method for signature 'samc,missing,location,missing,numeric'
mortality(samc, origin, time)

## S4 method for signature 'samc,missing,missing,location,numeric'
mortality(samc, dest, time)

## S4 method for signature 'samc,missing,location,location,numeric'
mortality(samc, origin, dest, time)

## S4 method for signature 'samc,ANY,missing,missing,numeric'
mortality(samc, init, time)

## S4 method for signature 'samc,missing,missing,missing,missing'
mortality(samc)

## S4 method for signature 'samc,missing,location,missing,missing'
mortality(samc, origin)

## S4 method for signature 'samc,missing,missing,location,missing'
mortality(samc, dest)

## S4 method for signature 'samc,missing,location,location,missing'
mortality(samc, origin, dest)

## S4 method for signature 'samc,ANY,missing,missing,missing'
mortality(samc, init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mortality_+3A_samc">samc</code></td>
<td>
<p>A <code><a href="#topic+samc-class">samc-class</a></code> object created using the <code><a href="#topic+samc">samc</a></code> function.</p>
</td></tr>
<tr><td><code id="mortality_+3A_init">init</code></td>
<td>
<p>Sets the initial state <code class="reqn">\psi</code> of the transients states. Input
must be able to pass the <code><a href="#topic+check">check</a></code> function when compared against
the <code><a href="#topic+samc-class">samc-class</a></code> object. Can only contain positive finite values.</p>
</td></tr>
<tr><td><code id="mortality_+3A_origin">origin</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{i}</code>. Corresponds to row <code class="reqn">\mathit{i}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>dest</code>
parameter, multiple values may be provided as a vector.</p>
</td></tr>
<tr><td><code id="mortality_+3A_dest">dest</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{j}</code>. Corresponds to column <code class="reqn">\mathit{j}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>origin</code> parameter,
multiple values may be provided as a vector.</p>
</td></tr>
<tr><td><code id="mortality_+3A_time">time</code></td>
<td>
<p>A positive integer or a vector of positive integers representing
<code class="reqn">\mathit{t}</code> time steps. Vectors must be ordered and contain no duplicates.
Vectors may not be used for metrics that return dense matrices. The maximum time
step value is capped at 10,000 due to numerical precision issues.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">\tilde{B}_t = \tilde{F} \tilde{R}</code>
</p>

<ul>
<li> <p><strong>mortality(samc, time)</strong>
</p>
<p>The result is a matrix <code class="reqn">M</code> where <code class="reqn">M_{i,j}</code> is the
probability of absorption at transient state <code class="reqn">\mathit{j}</code> within <code class="reqn">\mathit{t}</code>
or fewer steps if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>The returned matrix will always be dense and cannot be optimized. Must enable
override to use (see <code><a href="#topic+samc-class">samc-class</a></code>).
</p>
</li>
<li> <p><strong>mortality(samc, origin, time)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the probability
of absorption at transient state <code class="reqn">\mathit{j}</code> within <code class="reqn">\mathit{t}</code> or
fewer steps if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If multiple time steps were provided as a vector, then the result will be an
ordered named list containing a vector for each time step.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>mortality(samc, dest, time)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_i</code> is the probability
of absorption at transient state <code class="reqn">\mathit{j}</code> within <code class="reqn">\mathit{t}</code> or
fewer steps if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If multiple time steps were provided as a vector, then the result will be an
ordered named list containing a vector for each time step.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>mortality(samc, origin, dest, time)</strong>
</p>
<p>The result is a numeric value that is the probability of absorption at transient
state <code class="reqn">\mathit{j}</code> within <code class="reqn">\mathit{t}</code> or fewer time steps if starting
at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If multiple time steps were provided as a vector, then the result will be an
ordered named list containing a numeric value for each time step.
</p>
</li></ul>

<p><code class="reqn">\psi^T \tilde{B}_t</code>
</p>

<ul>
<li> <p><strong>mortality(samc, init, time)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the unconditional
probability of absorption at transient state <code class="reqn">\mathit{j}</code> within <code class="reqn">\mathit{t}</code>
or fewer steps given an initial state <code class="reqn">\psi</code>.
</p>
<p>If multiple time steps were provided as a vector, then the result will be an
ordered named list containing a vector for each time step.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li></ul>

<p><code class="reqn">B = F \tilde{R}</code>
</p>

<ul>
<li> <p><strong>mortality(samc)</strong>
</p>
<p>The result is a matrix <code class="reqn">M</code> where <code class="reqn">M_{i,j}</code> is the
probability of absorption at transient state <code class="reqn">\mathit{j}</code> if starting at
transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>The returned matrix will always be dense and cannot be optimized. Must enable
override to use (see <code><a href="#topic+samc-class">samc-class</a></code>).
</p>
</li>
<li> <p><strong>mortality(samc, origin)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the probability of absorption
at transient state <code class="reqn">\mathit{j}</code> if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>mortality(samc, dest)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_i</code> is the probability of absorption
at transient state <code class="reqn">\mathit{j}</code> if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>mortality(samc, origin, dest)</strong>
</p>
<p>The result is a numeric value that is the probability of absorption
at transient state <code class="reqn">\mathit{j}</code> if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
</li></ul>

<p><code class="reqn">\psi^T B</code>
</p>

<ul>
<li> <p><strong>mortality(samc, init)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the unconditional
probability of absorption at transient state <code class="reqn">\mathit{j}</code> given an initial
state <code class="reqn">\psi</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li></ul>



<h3>Value</h3>

<p>See Details
</p>


<h3>Performance</h3>

<p>Any relevant performance information about this function can be found in the
performance vignette: <a href="../doc/performance.html"><code>vignette("performance", package = "samc")</code></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

<hr>
<h2 id='pairwise'>Pairwise analyses</h2><span id='topic+pairwise'></span><span id='topic+pairwise+2Cfunction+2Csamc+2Clocation+2Clocation-method'></span><span id='topic+pairwise+2Cfunction+2Csamc+2Clocation+2Cmissing-method'></span>

<h3>Description</h3>

<p>Analysis for pairwise combinations locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise(fun, samc, origin, dest)

## S4 method for signature ''function',samc,location,location'
pairwise(fun, samc, origin, dest)

## S4 method for signature ''function',samc,location,missing'
pairwise(fun, samc, origin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise_+3A_fun">fun</code></td>
<td>
<p>A samc analytical function with signature fun(samc, origin, dest)</p>
</td></tr>
<tr><td><code id="pairwise_+3A_samc">samc</code></td>
<td>
<p>A <code><a href="#topic+samc-class">samc-class</a></code> object</p>
</td></tr>
<tr><td><code id="pairwise_+3A_origin">origin</code></td>
<td>
<p>A vector of locations</p>
</td></tr>
<tr><td><code id="pairwise_+3A_dest">dest</code></td>
<td>
<p>A vector of locations. Can be excluded to reuse the origin parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When providing vector inputs for the 'origin' and 'dest' parameters to analytical
functions, the package assumes that users are providing pairs of 'origin' and
'dest'. That is, 'origin[1]' is paired with 'dest[1]', 'origin[2]' is paired
'dest[2]', etc. Another way to think about it is that these two vector inputs
can be treated as columns in the same dataframe. The result of the analytical
function then is a vector of the same length as the input. This behavior works
for any situation, so it is the default for the package.
</p>
<p>However, some users may wish to run an analytical function for all the pairwise
combinations of the values in the input vectors. That is, 'origin[1]' is paired
with 'dest[1]','dest[2]', 'dest[3]', etc, before moving on to the next elements
in 'origin'. This approach has the advantage of potentially reducing the amount
of code needed for an analysis, and the results can be represented as a pairwise
matrix, but it is not suitable for all situations. To enable this second approach
more easily, the 'pairwise()' function runs all the combinations of the 'origin'
and 'dest' parameters for an analytical function and returns the results in a
'long' format data.frame. This data.frame can then be reshaped into a pairwise
matrix or 'wide' format data.frame using tools like the reshape2 or tidyr packages.
</p>
<p>This function is not intended to be used with other inputs such as 'init' or 'time'
</p>


<h3>Value</h3>

<p>A 'long' format data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(samc)

# Load example data
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs


# Create samc-class object
samc_obj &lt;- samc(res_data, abs_data,
                 model = list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE))

# pairwise() example
pw &lt;- pairwise(cond_passage, samc_obj, origin = 1:4, dest = 5)
print(pw)

# pairwise() example without dest
pw &lt;- pairwise(dispersal, samc_obj, origin = c(2, 7))
print(pw)


</code></pre>

<hr>
<h2 id='rasterize'>Rasterize input</h2><span id='topic+rasterize'></span><span id='topic+rasterize+2Cmatrix-method'></span><span id='topic+rasterize+2CRasterLayer-method'></span><span id='topic+rasterize+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Convert input to a SpatRaster object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterize(x)

## S4 method for signature 'matrix'
rasterize(x)

## S4 method for signature 'RasterLayer'
rasterize(x)

## S4 method for signature 'SpatRaster'
rasterize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterize_+3A_x">x</code></td>
<td>
<p>A matrix, RasterLayer, or SpatRaster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily used to convert an input matrix or raster to a SpatRaster
object. The main thing it is useful for is setting a standard extent and CRS for
converting matrices. It is used internally by the package to ensure consistent
results for the different data types for maps.
</p>
<p>When converting matrices, the extents are set to match the number of rows and
columns of the matrix. Pixels in the result are centered on whole number coordinates
with (1,1) corresponding to the bottom left pixel. The CRS is set to &quot;local&quot;, which
treats it as Euclidean (Cartesian) plane with the units in meters.
</p>
<p>The main benefit will be for users that want an easy way to plot matrix data.
If the input type to the <code><a href="#topic+samc">samc</a></code> function is matrices, then the output
of <code><a href="#topic+map">map</a></code> will also be matrices. Plotting these matrices can require
more work than simply using SpatRaster objects for <code><a href="#topic+samc">samc</a></code> and getting
SpatRaster results back from <code><a href="#topic+map">map</a></code>.
</p>
<p>The raster and terra packages both also have a rasterize function that serves
a different purpose. If either of these packages are used directly, then the order of
package loading becomes very important because it will determine which version
of rasterize is used by default.
</p>


<h3>Value</h3>

<p>A SpatRaster object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

<hr>
<h2 id='samc'>Create an samc object</h2><span id='topic+samc'></span><span id='topic+samc+2CSpatRaster+2CSpatRaster+2CSpatRaster+2Clist-method'></span><span id='topic+samc+2CRasterLayer+2CRasterLayer+2CRasterLayer+2Clist-method'></span><span id='topic+samc+2CSpatRaster+2CSpatRaster+2Cmissing+2Clist-method'></span><span id='topic+samc+2CRasterLayer+2CRasterLayer+2Cmissing+2Clist-method'></span><span id='topic+samc+2Cmatrix+2Cmatrix+2Cmatrix+2Clist-method'></span><span id='topic+samc+2Cmatrix+2Cmatrix+2Cmissing+2Clist-method'></span><span id='topic+samc+2CdgCMatrix+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+samc+2Cmatrix+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Create an samc object that contains the absorbing Markov chain data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samc(data, absorption, fidelity, model, options = NULL)

## S4 method for signature 'SpatRaster,SpatRaster,SpatRaster,list'
samc(data, absorption, fidelity, model, options = NULL)

## S4 method for signature 'RasterLayer,RasterLayer,RasterLayer,list'
samc(data, absorption, fidelity, model, options = NULL)

## S4 method for signature 'SpatRaster,SpatRaster,missing,list'
samc(data, absorption, model, options = NULL)

## S4 method for signature 'RasterLayer,RasterLayer,missing,list'
samc(data, absorption, model, options = NULL)

## S4 method for signature 'matrix,matrix,matrix,list'
samc(data, absorption, fidelity, model, options = NULL)

## S4 method for signature 'matrix,matrix,missing,list'
samc(data, absorption, model, options = NULL)

## S4 method for signature 'dgCMatrix,missing,missing,missing'
samc(data, options = NULL)

## S4 method for signature 'matrix,missing,missing,missing'
samc(data, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samc_+3A_data">data</code></td>
<td>
<p>A <code><a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a></code> or <code><a href="raster.html#topic+RasterLayer-class">RasterLayer-class</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code> or Matrix package dgCMatrix sparse matrix.</p>
</td></tr>
<tr><td><code id="samc_+3A_absorption">absorption</code></td>
<td>
<p>A <code><a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a></code> or <code><a href="raster.html#topic+RasterLayer-class">RasterLayer-class</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code></p>
</td></tr>
<tr><td><code id="samc_+3A_fidelity">fidelity</code></td>
<td>
<p>A <code><a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a></code> or <code><a href="raster.html#topic+RasterLayer-class">RasterLayer-class</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code></p>
</td></tr>
<tr><td><code id="samc_+3A_model">model</code></td>
<td>
<p>A list with args for constructing a transition matrix.</p>
</td></tr>
<tr><td><code id="samc_+3A_options">options</code></td>
<td>
<p>A list of options that changes how the samc behaves computationally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to create a <code><a href="#topic+samc-class">samc-class</a></code> object. There are
multiple options for creating this object.
</p>
<p><strong>Option 1: Raster or Matrix Maps</strong>
</p>
<p><em><code>samc(data = matrix, absorption = matrix, fidelity = matrix, model = list())</code></em>
</p>
<p><em><code>samc(data = SpatRaster, absorption = SpatRaster, fidelity = SpatRaster, model = list())</code></em>
</p>
<p><em><code>samc(data = RasterLayer, absorption = RasterLayer, fidelity = RasterLayer, model = list())</code></em>
</p>
<p>The <code><a href="#topic+samc-class">samc-class</a></code> object can be created from a combination of
resistance (or conductance), absorption, and fidelity data. These different landscape data
inputs must be the same type (a matrix, SpatRaster, or RasterLayer), and have identical
properties, including dimensions, location of NA cells, and CRS (if using
raster inputs).
</p>
<p>The <code>data</code> and <code>absorption</code> inputs are always mandatory for this approach. The
<code>fidelity</code> input is optional. If the <code>fidelity</code> input is not provided, then it
is assumed that there is no site fidelity (i.e., individuals will always move
to an adjacent cell each time step).
</p>
<p>The <code>model</code> parameter is mandatory. It is used when calculating the values for
the transition matrix. <code>model</code> must be constructed as a list with a
transition function, the number of directions (4 or 8), and if the transition
function is symmetric (TRUE or FALSE; currently not used). Here is the template:
<code>list(fun = `function`, dir = `numeric`, sym = `logical`)</code>
</p>
<p>When using raster inputs, SpatRaster objects (from the terra package) are recommended
over RasterLayer objects (from the raster package). Internally, samc is using SpatRaster
objects, which means RasterLayer objects are being converted to SpatRaster objects,
which is a source of memory inefficiency.
</p>
<p><strong>Option 2: P Matrix</strong>
</p>
<p><em><code>samc(data = matrix)</code></em>
</p>
<p><em><code>samc(data = dgCMatrix)</code></em>
</p>
<p>The <code>data</code> parameter can be used alone to create a <code><a href="#topic+samc-class">samc-class</a></code> object
directly from a preconstructed P matrix. This matrix must be either a base R
matrix, or a sparse matrix (dgCMatrix format) from the Matrix package. It
must meet the following requirements:
</p>

<ul>
<li><p> The number of rows must equal the number of columns (a square matrix)
</p>
</li>
<li><p> Total absorption must be a single column on the right-hand side of the matrix
</p>
</li>
<li><p> At the bottom of the matrix, there must be a row filled with 0's except
for the last element (bottom-right of the matrix diagonal), which must be set to 1
</p>
</li>
<li><p> Every disconnected region of the matrix must have at least one non-zero
absorbing value
</p>
</li>
<li><p> Each row must sum to 1
</p>
</li>
<li><p> All values must be in the range of 0-1
</p>
</li></ul>

<p>Additionally, the columns and rows of the P matrix may be named (e.g., using
dimnames(), rowname(), colnames(), etc). When specifying <code>origin</code> or <code>dest</code> inputs
to metrics, these names may be used instead of cell numbers. This has the
advantage of making the code for an analysis easier to read and interpret,
which may also help to eliminate unintentional mistakes. There are two
requirements for naming the rows/cols of a P matrix. First, since the P matrix
represents a pairwise matrix, the row and column names must be the same. Second,
there must be no duplicate names. The exception to these rules is the very last
column and the very last row of the P matrix. Since these are not part of the
pairwise transition matrix, they may have whatever names the user prefers.
</p>
<p><strong>Additional Information</strong>
</p>
<p>Depending on the data used to construct the samc-class object, some metrics
may cause crashes. This is a result of the underlying P matrix having specific
properties that make some equations unsolvable. One known case is a P matrix
that represents a disconnected graph, which can lead to the <code>cond_passage()</code>
function crashing. In terms of raster/matrix inputs, a disconnected graph
occurs when one or more pixels/cells are unreachable from other pixels/cells
due to the presence of a full barrier made up of NA values. In a raster, these
may be obvious as islands but can be as inconspicuous as a rogue isolated
pixel. There may be other currently unknown situations that lead to unsolvable
metrics.
</p>
<p>Future work is planned towards identifying these issues during the creation of
the samc-class object and handling them appropriately to prevent inadvertent
crashes.
</p>
<p><strong>Version 3 Changes</strong>
</p>
<p>Support for creating samc-class objects from TransitionLayer objects was removed
so that the package is not dependent on gdistance.
</p>
<p><strong>Version 2 Changes</strong>
</p>
<p>Version 1.5.0 officially removed support for the deprecated <code>resistance</code>, <code>tr_fun</code>,
<code>directions</code>, <code>p_mat</code>, <code>latlon</code>, and <code>override</code> arguments. Old
code will have to be updated to the new samc() function structure in order to work.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+samc-class">samc-class</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

<hr>
<h2 id='samc_data-class'>data class</h2><span id='topic+samc_data-class'></span>

<h3>Description</h3>

<p>Contains the data fields used in the samc-class
</p>


<h3>Slots</h3>


<dl>
<dt><code>f</code></dt><dd><p>F matrix</p>
</dd>
<dt><code>t_abs</code></dt><dd><p>Total absorption</p>
</dd>
<dt><code>c_abs</code></dt><dd><p>Component absorption states</p>
</dd>
</dl>

<hr>
<h2 id='samc-class'>samc class</h2><span id='topic+samc-class'></span>

<h3>Description</h3>

<p>S4 class to manage SAMC data.
</p>


<h3>Details</h3>

<p>The samc class is used to help ensure that the package is used correctly and
to minimize the possibility for users to accidentally produce nonsensical
results that may not be obviously incorrect. This class contains the p matrix
necessary for all the calculations in the package, and enforces its type so
that users are less likely to inadvertently alter it in a way that will cause
issues in calculations.
</p>
<p>The <code><a href="#topic+samc">samc</a>()</code> function is used to create <code><a href="#topic+samc-class">samc-class</a></code>
objects.
</p>
<p>The samc-class slots are subject to change, so users should not be using the
<code>@</code> operator to access or change them. Doing so leads to the risk of broken
code in the future. Instead, where relevant, the <code>$</code> operator can be used
to get and set components of the class safely. This is a current list of what can
be accessed and modified in the class:
</p>

<ul>
<li> <p><strong>override</strong>
</p>
<p>Some analyses are memory intensive and have the potential to make a user's
system non-responsive or crash. By default, a samc-class object cannot be used
in these analyses to prevent unintentional loss of work. In some cases, users
may wish to use these particular analyses, in which case this behavior can
be overridden. To get the current state of the override, use <code>samc_obj$override</code>.
To enable the use of the analyses, the override can be set to <code>TRUE</code> using
<code>samc_obj$override &lt;- TRUE</code>. Before enabling the override, users should
familiarize themselves with the Performance vignette.
</p>
</li>
<li> <p><strong>q_matrix</strong>
</p>
<p>Advanced users may wish to have direct access to the Q matrix for developing
custom calculations/analyses. Assumptions should not be made about the internal
storage and management of the P and Q matrices in the samc-class; these things
are subject to change in the future. To safely access the Q matrix, use
<code>samc_obj$q_matrix</code>. The Q matrix inside of the samc-class cannot be
modified.
</p>
</li>
<li> <p><strong>p_matrix</strong>
</p>
<p><code>samc_obj$p_matrix</code> can be used to get a copy of the P matrix.
</p>
</li>
<li> <p><strong>abs_states</strong>
</p>
<p>Used to attach additional absorbing states to an samc object. This does not
cause P/Q matrices to be updated. Instead, it is intended to provide decomposed
results from the <code><a href="#topic+mortality">mortality</a>()</code> and <code><a href="#topic+absorption">absorption</a>()</code> metrics for different sources
of absorption that might be contributing to the total absorption values that
were used to create the samc object.
</p>
<p>The input must be in the same form as the absorption inputs used in <code><a href="#topic+samc">samc</a>()</code>.
Matrices are passed in as a <code>list</code>, and rasters are passed in as a <code>RasterStack</code>.
Using <code>NA</code> as the input will reset it.
</p>
</li>
<li> <p><strong>solver</strong>
</p>
<p><code>samc_obj$solver</code> can be used to change the default linear algebra solver
used in some of the metrics. The default value of &quot;direct&quot; means a direct solver
is used, and is what was used in previous versions of the package. The alternative
value of &quot;iter&quot; switches the package to an iterative solver, which is significantly
more memory efficient for larger datasets, but in general will be noticeably slower
depending on patterns in the data.
</p>
</li>
<li> <p><strong>threads</strong>
</p>
<p><code>samc_obj$threads</code> can be used to get or set the number of threads used
for parallel computations. Details can be found in the Parallel Computing
vignette.
</p>
</li></ul>



<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>Data associated with different components of the P matrix</p>
</dd>
<dt><code>conv_cache</code></dt><dd><p>Convolution cache</p>
</dd>
<dt><code>model</code></dt><dd><p>List containing model info used to build the samc object</p>
</dd>
<dt><code>source</code></dt><dd><p>Information about the data source for the P matrix</p>
</dd>
<dt><code>map</code></dt><dd><p>Used to verify landscape inputs and mapping of vector data</p>
</dd>
<dt><code>crw_map</code></dt><dd><p>Matrix used to map location and direction to edges description</p>
</dd>
<dt><code>names</code></dt><dd><p>Names of the transient states</p>
</dd>
<dt><code>clumps</code></dt><dd><p>Number of discontinuous regions in data</p>
</dd>
<dt><code>override</code></dt><dd><p>Used to prevent accidental use of memory intensive functions</p>
</dd>
<dt><code>solver</code></dt><dd><p>Controls the linear solver used for relevant metrics</p>
</dd>
<dt><code>threads</code></dt><dd><p>Used for multi-threading</p>
</dd>
<dt><code>.cache</code></dt><dd><p>Cached data for performance boosts</p>
</dd>
</dl>

<hr>
<h2 id='samc-class-access'>Access samc-class components</h2><span id='topic+samc-class-access'></span><span id='topic++24+2Csamc-method'></span>

<h3>Description</h3>

<p>Allows users to access a subset of the samc-class components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'samc'
x$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samc-class-access_+3A_x">x</code></td>
<td>
<p>samc-class object</p>
</td></tr>
<tr><td><code id="samc-class-access_+3A_name">name</code></td>
<td>
<p>Component of the samc-class to access</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Component value
</p>

<hr>
<h2 id='samc-class-modify'>Modify samc-class components</h2><span id='topic+samc-class-modify'></span><span id='topic++24+3C-+2Csamc-method'></span>

<h3>Description</h3>

<p>Allows users to modify a subset of the samc-class components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'samc'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samc-class-modify_+3A_x">x</code></td>
<td>
<p>samc-class object</p>
</td></tr>
<tr><td><code id="samc-class-modify_+3A_name">name</code></td>
<td>
<p>Component of the samc-class to modify</p>
</td></tr>
<tr><td><code id="samc-class-modify_+3A_value">value</code></td>
<td>
<p>Value to assign to samc-class component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated samc-class object
</p>

<hr>
<h2 id='survival'>Calculate survival metrics</h2><span id='topic+survival'></span><span id='topic+survival+2Csamc+2Cmissing-method'></span><span id='topic+survival+2Csamc+2CANY-method'></span>

<h3>Description</h3>

<p>Calculates the expected time to absorption
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survival(samc, init)

## S4 method for signature 'samc,missing'
survival(samc)

## S4 method for signature 'samc,ANY'
survival(samc, init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survival_+3A_samc">samc</code></td>
<td>
<p>A <code><a href="#topic+samc-class">samc-class</a></code> object created using the <code><a href="#topic+samc">samc</a></code> function.</p>
</td></tr>
<tr><td><code id="survival_+3A_init">init</code></td>
<td>
<p>Sets the initial state <code class="reqn">\psi</code> of the transients states. Input
must be able to pass the <code><a href="#topic+check">check</a></code> function when compared against
the <code><a href="#topic+samc-class">samc-class</a></code> object. Can only contain positive finite values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">z=(I-Q)^{-1}{\cdot}1=F{\cdot}1</code>
</p>

<ul>
<li> <p><strong>survival(samc)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_i</code> is the expected
time to absorption if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li></ul>

<p><code class="reqn">\psi^Tz</code>
</p>

<ul>
<li> <p><strong>survival(samc, init)</strong>
</p>
<p>The result is a numeric that is the expected time to absorption given an initial
state <code class="reqn">\psi</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>See Details
</p>


<h3>Performance</h3>

<p>Any relevant performance information about this function can be found in the
performance vignette: <a href="../doc/performance.html"><code>vignette("performance", package = "samc")</code></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

<hr>
<h2 id='visitation'>Calculate visitation metrics</h2><span id='topic+visitation'></span><span id='topic+visitation+2Csamc+2Cmissing+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+visitation+2Csamc+2Cmissing+2Clocation+2Cmissing+2Cnumeric-method'></span><span id='topic+visitation+2Csamc+2Cmissing+2Cmissing+2Clocation+2Cnumeric-method'></span><span id='topic+visitation+2Csamc+2Cmissing+2Clocation+2Clocation+2Cnumeric-method'></span><span id='topic+visitation+2Csamc+2CANY+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+visitation+2Csamc+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+visitation+2Csamc+2Cmissing+2Clocation+2Cmissing+2Cmissing-method'></span><span id='topic+visitation+2Csamc+2Cmissing+2Cmissing+2Clocation+2Cmissing-method'></span><span id='topic+visitation+2Csamc+2Cmissing+2Clocation+2Clocation+2Cmissing-method'></span><span id='topic+visitation+2Csamc+2CANY+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+visitation+2Csamc+2CANY+2Cmissing+2Clocation+2Cmissing-method'></span>

<h3>Description</h3>

<p>Calculates the number of times that transient states are visited before absorption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visitation(samc, init, origin, dest, time)

## S4 method for signature 'samc,missing,missing,missing,numeric'
visitation(samc, time)

## S4 method for signature 'samc,missing,location,missing,numeric'
visitation(samc, origin, time)

## S4 method for signature 'samc,missing,missing,location,numeric'
visitation(samc, dest, time)

## S4 method for signature 'samc,missing,location,location,numeric'
visitation(samc, origin, dest, time)

## S4 method for signature 'samc,ANY,missing,missing,numeric'
visitation(samc, init, time)

## S4 method for signature 'samc,missing,missing,missing,missing'
visitation(samc)

## S4 method for signature 'samc,missing,location,missing,missing'
visitation(samc, origin)

## S4 method for signature 'samc,missing,missing,location,missing'
visitation(samc, dest)

## S4 method for signature 'samc,missing,location,location,missing'
visitation(samc, origin, dest)

## S4 method for signature 'samc,ANY,missing,missing,missing'
visitation(samc, init)

## S4 method for signature 'samc,ANY,missing,location,missing'
visitation(samc, init, dest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visitation_+3A_samc">samc</code></td>
<td>
<p>A <code><a href="#topic+samc-class">samc-class</a></code> object created using the <code><a href="#topic+samc">samc</a></code> function.</p>
</td></tr>
<tr><td><code id="visitation_+3A_init">init</code></td>
<td>
<p>Sets the initial state <code class="reqn">\psi</code> of the transients states. Input
must be able to pass the <code><a href="#topic+check">check</a></code> function when compared against
the <code><a href="#topic+samc-class">samc-class</a></code> object. Can only contain positive finite values.</p>
</td></tr>
<tr><td><code id="visitation_+3A_origin">origin</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{i}</code>. Corresponds to row <code class="reqn">\mathit{i}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>dest</code>
parameter, multiple values may be provided as a vector.</p>
</td></tr>
<tr><td><code id="visitation_+3A_dest">dest</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{j}</code>. Corresponds to column <code class="reqn">\mathit{j}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>origin</code> parameter,
multiple values may be provided as a vector.</p>
</td></tr>
<tr><td><code id="visitation_+3A_time">time</code></td>
<td>
<p>A positive integer or a vector of positive integers representing
<code class="reqn">\mathit{t}</code> time steps. Vectors must be ordered and contain no duplicates.
Vectors may not be used for metrics that return dense matrices. The maximum time
step value is capped at 10,000 due to numerical precision issues.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">\tilde{F}_{t} = (\sum_{n=0}^{t-1}{Q}^n)</code>
</p>

<ul>
<li> <p><strong>visitation(samc, time)</strong>
</p>
<p>The result is a matrix <code class="reqn">M</code> where <code class="reqn">M_{i,j}</code> is the number of times that
transient state <code class="reqn">\mathit{j}</code> is visited after <code class="reqn">\mathit{t}</code> time steps
if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>The returned matrix will always be dense and cannot be optimized. Must enable
override to use (see <code><a href="#topic+samc-class">samc-class</a></code>).
</p>
</li>
<li> <p><strong>visitation(samc, origin, time)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the number
of times that transient state <code class="reqn">\mathit{j}</code> is visited after <code class="reqn">\mathit{t}</code>
time steps if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>visitation(samc, dest, time)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_i</code> is the number
of times that transient state <code class="reqn">\mathit{j}</code> is visited after <code class="reqn">\mathit{t}</code>
time steps if starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>visitation(samc, origin, dest, time)</strong>
</p>
<p>The result is a numeric value that is the number of times transient state
<code class="reqn">\mathit{j}</code> is visited after <code class="reqn">\mathit{t}</code> time steps if starting at
transient state <code class="reqn">\mathit{i}</code>.
</p>
</li></ul>

<p><code class="reqn">\psi^T \tilde{F}_{t}</code>
</p>

<ul>
<li> <p><strong>visitation(samc, init, time)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the number
of times that transient state <code class="reqn">\mathit{j}</code> is visited after <code class="reqn">\mathit{t}</code>
time steps before absorption given an initial state <code class="reqn">\psi</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>visitation(samc, init, dest, time)</strong>
</p>
<p>The result is a numeric value that is the number of times transient state
<code class="reqn">\mathit{j}</code> is visited after <code class="reqn">\mathit{t}</code> time steps given an initial
state <code class="reqn">\psi</code>.
</p>
</li></ul>

<p><code class="reqn">F = (I-Q)^{-1}</code>
</p>

<ul>
<li> <p><strong>visitation(samc)</strong>
</p>
<p>The result is a matrix <code class="reqn">M</code> where <code class="reqn">M_{i,j}</code> is the number of times that
transient state <code class="reqn">\mathit{j}</code> is visited before absorption if starting at
transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>The returned matrix will always be dense and cannot be optimized. Must enable
override to use (see <code><a href="#topic+samc-class">samc-class</a></code>).
</p>
</li>
<li> <p><strong>visitation(samc, origin)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the number
of times that transient state <code class="reqn">\mathit{j}</code> is visited before absorption if
starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>visitation(samc, dest)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_i</code> is the number
of times that transient state <code class="reqn">\mathit{j}</code> is visited before absorption if
starting at transient state <code class="reqn">\mathit{i}</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>visitation(samc, origin, dest)</strong>
</p>
<p>The result is a numeric value that is the number of times transient state
<code class="reqn">\mathit{j}</code> is visited before absorption if starting at transient
state <code class="reqn">\mathit{i}</code>.
</p>
</li></ul>

<p><code class="reqn">\psi^TF</code>
</p>

<ul>
<li> <p><strong>visitation(samc, init)</strong>
</p>
<p>The result is a vector <code class="reqn">\mathbf{v}</code> where <code class="reqn">\mathbf{v}_j</code> is the number
of times that transient state <code class="reqn">\mathit{j}</code> is visited before absorption
given an initial state <code class="reqn">\psi</code>.
</p>
<p>If the samc-class object was created using matrix or RasterLayer maps, then
vector <code class="reqn">\mathbf{v}</code> can be mapped to a RasterLayer using the
<code><a href="#topic+map">map</a></code> function.
</p>
</li>
<li> <p><strong>visitation(samc, init, dest)</strong>
</p>
<p>The result is a numeric value that is the number of times transient state
<code class="reqn">\mathit{j}</code> is visited before absorption given an initial state <code class="reqn">\psi</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>See Details
</p>


<h3>Performance</h3>

<p>Any relevant performance information about this function can be found in the
performance vignette: <a href="../doc/performance.html"><code>vignette("performance", package = "samc")</code></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

<hr>
<h2 id='visitation_net'>Calculate net visitation</h2><span id='topic+visitation_net'></span><span id='topic+visitation_net+2Csamc+2Cmissing+2Clocation+2Clocation-method'></span>

<h3>Description</h3>

<p>Calculates the net number of times that transient states are visited before absorption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visitation_net(samc, init, origin, dest)

## S4 method for signature 'samc,missing,location,location'
visitation_net(samc, origin, dest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visitation_net_+3A_samc">samc</code></td>
<td>
<p>A <code><a href="#topic+samc-class">samc-class</a></code> object created using the <code><a href="#topic+samc">samc</a></code> function.</p>
</td></tr>
<tr><td><code id="visitation_net_+3A_init">init</code></td>
<td>
<p>Sets the initial state <code class="reqn">\psi</code> of the transients states. Input
must be able to pass the <code><a href="#topic+check">check</a></code> function when compared against
the <code><a href="#topic+samc-class">samc-class</a></code> object. Can only contain positive finite values.</p>
</td></tr>
<tr><td><code id="visitation_net_+3A_origin">origin</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{i}</code>. Corresponds to row <code class="reqn">\mathit{i}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>dest</code>
parameter, multiple values may be provided as a vector.</p>
</td></tr>
<tr><td><code id="visitation_net_+3A_dest">dest</code></td>
<td>
<p>A positive integer or character name representing transient state
<code class="reqn">\mathit{j}</code>. Corresponds to column <code class="reqn">\mathit{j}</code> of matrix <code class="reqn">\mathbf{P}</code>
in the <code><a href="#topic+samc-class">samc-class</a></code> object. When paired with the <code>origin</code> parameter,
multiple values may be provided as a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+visitation">visitation</a></code> function calculates the
</p>


<h3>Value</h3>

<p>See Details
</p>


<h3>Performance</h3>

<p>Any relevant performance information about this function can be found in the
performance vignette: <a href="../doc/performance.html"><code>vignette("performance", package = "samc")</code></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Load" the data. In this case we are using data built into the package.
# In practice, users will likely load raster data using the raster() function
# from the raster package.
res_data &lt;- samc::example_split_corridor$res
abs_data &lt;- samc::example_split_corridor$abs
init_data &lt;- samc::example_split_corridor$init


# Make sure our data meets the basic input requirements of the package using
# the check() function.
check(res_data, abs_data)
check(res_data, init_data)

# Setup the details for a random-walk model
rw_model &lt;- list(fun = function(x) 1/mean(x), # Function for calculating transition probabilities
                 dir = 8, # Directions of the transitions. Either 4 or 8.
                 sym = TRUE) # Is the function symmetric?


# Create a `samc-class` object with the resistance and absorption data using
# the samc() function. We use the recipricol of the arithmetic mean for
# calculating the transition matrix. Note, the input data here are matrices,
# not RasterLayers.
samc_obj &lt;- samc(res_data, abs_data, model = rw_model)


# Convert the initial state data to probabilities
init_prob_data &lt;- init_data / sum(init_data, na.rm = TRUE)


# Calculate short- and long-term metrics using the analytical functions
short_mort &lt;- mortality(samc_obj, init_prob_data, time = 50)
short_dist &lt;- distribution(samc_obj, origin = 3, time = 50)
long_disp &lt;- dispersal(samc_obj, init_prob_data)
visit &lt;- visitation(samc_obj, dest = 4)
surv &lt;- survival(samc_obj)


# Use the map() function to turn vector results into RasterLayer objects.
short_mort_map &lt;- map(samc_obj, short_mort)
short_dist_map &lt;- map(samc_obj, short_dist)
long_disp_map &lt;- map(samc_obj, long_disp)
visit_map &lt;- map(samc_obj, visit)
surv_map &lt;- map(samc_obj, surv)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
