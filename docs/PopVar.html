<!DOCTYPE html><html><head><title>Help for package PopVar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PopVar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#internal'><p>Internal functions</p></a></li>
<li><a href='#mppop.predict'><p>Predict genetic variance and genetic correlations in multi-parent populations</p>
using a deterministic equation.</a></li>
<li><a href='#pop.predict'><p>A genome-wide procedure for predicting genetic variance and correlated response in bi-parental breeding populations</p></a></li>
<li><a href='#pop.predict2'><p>Predict genetic variance and genetic correlations in bi-parental populations using a deterministic model</p></a></li>
<li><a href='#PopVar-package'><p>Genomic breeding tools to 1) predict standard statistics and correlated response in plant populations, and 2) performs cross-validation to estimate genome-wide prediction accuracy</p></a></li>
<li><a href='#think_barley.rda'><p>An example barley dataset</p></a></li>
<li><a href='#x.val'><p>Estimate genome-wide prediction accuracy using cross-validation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Genomic Breeding Tools: Genetic Variance Prediction and
Cross-Validation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The main attribute of 'PopVar' is the prediction of genetic variance in bi-parental populations, 
    from which the package derives its name. 'PopVar' contains a set of functions that use phenotypic and genotypic
    data from a set of candidate parents to 1) predict the mean, genetic variance, and superior progeny value of all, 
    or a defined set of pairwise bi-parental crosses, and 2) perform cross-validation to estimate genome-wide prediction 
    accuracy of multiple statistical models. More details are available in Mohammadi, Tiede, and Smith (2015, &lt;<a href="https://doi.org/10.2135%2Fcropsci2015.01.0030">doi:10.2135/cropsci2015.01.0030</a>&gt;). 
    A dataset 'think_barley.rda' is included for reference and examples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>BGLR, qtl, rrBLUP, stats, utils, methods, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-28 21:40:37 UTC; jln54</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Tiede [aut],
  Jeffrey Neyhart <a href="https://orcid.org/0000-0002-1991-5310"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb, cre],
  Mohsen Mohammadi <a href="https://orcid.org/0000-0002-4536-1200"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Kevin Smith <a href="https://orcid.org/0000-0001-8253-3326"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeffrey Neyhart &lt;neyhartje@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-29 13:30:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='internal'>Internal functions</h2><span id='topic+internal'></span><span id='topic+par_position'></span><span id='topic+par_name'></span><span id='topic+tails'></span><span id='topic+maf_filt'></span><span id='topic+XValidate_nonInd'></span><span id='topic+XValidate_Ind'></span><span id='topic+calc_marker_effects'></span>

<h3>Description</h3>

<p>Internal functions generally not to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_position(crossing.table, par.entries)

par_name(crossing.mat, par.entries)

tails(GEBVs, tail.p)

maf_filt(G)

XValidate_nonInd(
  y.CV = NULL,
  G.CV = NULL,
  models.CV = NULL,
  frac.train.CV = NULL,
  nCV.iter.CV = NULL,
  burnIn.CV = NULL,
  nIter.CV = NULL
)

XValidate_Ind(
  y.CV = NULL,
  G.CV = NULL,
  models.CV = NULL,
  nFold.CV = NULL,
  nFold.CV.reps = NULL,
  burnIn.CV = NULL,
  nIter.CV = NULL
)

calc_marker_effects(
  M,
  y.df,
  models = c("rrBLUP", "BayesA", "BayesB", "BayesC", "BL", "BRR"),
  nIter,
  burnIn
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internal_+3A_crossing.table">crossing.table</code></td>
<td>
<p>The crossing table.</p>
</td></tr>
<tr><td><code id="internal_+3A_par.entries">par.entries</code></td>
<td>
<p>The parent entries.</p>
</td></tr>
<tr><td><code id="internal_+3A_crossing.mat">crossing.mat</code></td>
<td>
<p>The crossing matrix.</p>
</td></tr>
<tr><td><code id="internal_+3A_gebvs">GEBVs</code></td>
<td>
<p>The genomic estimated breeding values.</p>
</td></tr>
<tr><td><code id="internal_+3A_tail.p">tail.p</code></td>
<td>
<p>The proportion from the population to select.</p>
</td></tr>
<tr><td><code id="internal_+3A_g">G</code></td>
<td>
<p>The marker genotypes</p>
</td></tr>
<tr><td><code id="internal_+3A_y.cv">y.CV</code></td>
<td>
<p>The phenotypes for cross-validation.</p>
</td></tr>
<tr><td><code id="internal_+3A_g.cv">G.CV</code></td>
<td>
<p>The marker genotypes for cross-validation.</p>
</td></tr>
<tr><td><code id="internal_+3A_models.cv">models.CV</code></td>
<td>
<p>The models for cross-validation.</p>
</td></tr>
<tr><td><code id="internal_+3A_frac.train.cv">frac.train.CV</code></td>
<td>
<p>The fraction of data to use as training data in cross-validation.</p>
</td></tr>
<tr><td><code id="internal_+3A_ncv.iter.cv">nCV.iter.CV</code></td>
<td>
<p>The number of iterations of cross-validation.</p>
</td></tr>
<tr><td><code id="internal_+3A_burnin.cv">burnIn.CV</code></td>
<td>
<p>The burn-in number for cross-validation.</p>
</td></tr>
<tr><td><code id="internal_+3A_niter.cv">nIter.CV</code></td>
<td>
<p>The number of iterations for Bayesian models in cross-validation.</p>
</td></tr>
<tr><td><code id="internal_+3A_nfold.cv">nFold.CV</code></td>
<td>
<p>The number of folds in k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="internal_+3A_nfold.cv.reps">nFold.CV.reps</code></td>
<td>
<p>The number of replications of k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="internal_+3A_m">M</code></td>
<td>
<p>The marker matrix.</p>
</td></tr>
<tr><td><code id="internal_+3A_y.df">y.df</code></td>
<td>
<p>The phenotype data.</p>
</td></tr>
<tr><td><code id="internal_+3A_models">models</code></td>
<td>
<p>The models to use.</p>
</td></tr>
<tr><td><code id="internal_+3A_niter">nIter</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
<tr><td><code id="internal_+3A_burnin">burnIn</code></td>
<td>
<p>The burn-in rate.</p>
</td></tr>
</table>

<hr>
<h2 id='mppop.predict'>Predict genetic variance and genetic correlations in multi-parent populations
using a deterministic equation.</h2><span id='topic+mppop.predict'></span><span id='topic+mppop_predict2'></span>

<h3>Description</h3>

<p>Predicts the genotypic mean, genetic variance, and
usefulness criterion (superior progeny mean) in a set of multi-parent populations
using marker effects and a genetic map. If more than two traits are specified,
the function will also return predictions of the genetic correlation in the population
and the correlated response to selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mppop.predict(
  G.in,
  y.in,
  map.in,
  crossing.table,
  parents,
  n.parents = 4,
  tail.p = 0.1,
  self.gen = 10,
  DH = FALSE,
  models = c("rrBLUP", "BayesA", "BayesB", "BayesC", "BL", "BRR"),
  n.core = 1,
  ...
)

mppop_predict2(
  M,
  y.in,
  marker.effects,
  map.in,
  crossing.table,
  parents,
  n.parents = 4,
  tail.p = 0.1,
  self.gen = 10,
  DH = FALSE,
  models = c("rrBLUP", "BayesA", "BayesB", "BayesC", "BL", "BRR"),
  n.core = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mppop.predict_+3A_g.in">G.in</code></td>
<td>
<p>See <code>G.in</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_y.in">y.in</code></td>
<td>
<p>See <code>y.in</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_map.in">map.in</code></td>
<td>
<p>See <code>map.in</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_crossing.table">crossing.table</code></td>
<td>
<p>A <code>data.frame</code> with 2 columns (for bi-parental crosses) or 4 columns (for four-way crosses), each of which contains the names of parents to use in a potential cross. Rows contain individual crosses. See Details.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_parents">parents</code></td>
<td>
<p>See <code>parents</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_n.parents">n.parents</code></td>
<td>
<p>Integer number of parents per cross. May be 2 or 4. If <code>crossing.table</code> is passed,
this argument is ignored.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_tail.p">tail.p</code></td>
<td>
<p>See <code>tail.p</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_self.gen">self.gen</code></td>
<td>
<p>The number of selfing generations in the potential cross. Can be an integer or <code>Inf</code> for
recombinant inbreds. Note: <code>self.gen = 1</code> corresponds to an F2 population.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_dh">DH</code></td>
<td>
<p>Indicator if doubled-haploids are to be induced after the number of selfing generations indicated by
<code>self.gen</code>. For example, if <code>self.gen = 0</code> and <code>DH = TRUE</code>, then doubled-haploids are assumed
to be induced using gametes from F1 plants.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_models">models</code></td>
<td>
<p>See <code>models</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_n.core">n.core</code></td>
<td>
<p>Number of cores for parallelization. Parallelization is supported
only on a Linux or Mac OS operating system; if working on a Windows system, the function
is executed on a single core.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass depending on the choice of <code>model</code>.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_m">M</code></td>
<td>
<p>A Matrix of marker genotypes of dimensions <code>nLine</code> x <code>nMarker</code>, coded as
-1, 0, and 1.</p>
</td></tr>
<tr><td><code id="mppop.predict_+3A_marker.effects">marker.effects</code></td>
<td>
<p>A data frame of marker effects. The first column should include the marker name and
subsequent columns should include the marker effects. Supercedes <code>y.in</code> if passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions are based on the deterministic equations specified by Allier et al. (2019).
</p>
<p>In the case of four-way crosses (i.e. 4 parents), the function assumes that the first two parents are mated,
producing a <code class="reqn">F_1</code> offspring; then, the next two parents are mated, producing another <code class="reqn">F_1</code> offspring.
The two <code class="reqn">F_1</code> offspring are then mated and inbreeding or doubled haploid induction (if specified) proceeds
from there. For example, say cross <em>i</em> uses parents P1, P2, P3, and P4. P1 and P2 are first mated,
producing O1; then, P3 and P4 are mated, producing O2; then, O1 and O2 are mated, producing a segregating family.
</p>
<p>The <code>mppop.predict</code> function takes similarly formatted arguments as the <code><a href="#topic+pop.predict">pop.predict</a></code> function
in the <code>PopVar</code> package. For the sake of simplicity, we also include the <code>mppop_predict2</code> function, which
takes arguments in a format more consistent with other genomewide prediction packages/functions.
</p>
<p>If you select a <code>model</code> other than &quot;rrBLUP&quot;, you must specify the following additional arguments:
</p>

<ul>
<li><p><code>nIter</code>: See <code><a href="#topic+pop.predict">pop.predict</a></code>.
</p>
</li>
<li><p><code>burnIn</code>: See <code><a href="#topic+pop.predict">pop.predict</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> containing predictions of <code class="reqn">\mu</code>, <code class="reqn">V_G</code>, and <code class="reqn">\mu_{sp}</code> for
each trait for each potential multi-parent cross. When multiple traits are provided, the correlated
responses and correlation between all pairs of traits is also returned.
</p>


<h3>References</h3>

<p>Allier, A., L. Moreau, A. Charcosset, S. Teyssèdre, and C. Lehermeier, 2019 Usefulness Criterion and Post-selection Parental
Contributions in Multi-parental Crosses: Application to Polygenic Trait Introgression. G3 (Bethesda) 9: 1469–1479.
https://doi.org/https://doi.org/10.1534/g3.119.400129
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Load data
data("think_barley")

# Vector with 8 parents
parents &lt;- sample(y.in_ex$Entry, 8)

# Create a crossing table with four parents per cross
cross_tab &lt;- as.data.frame(t(combn(x = parents, m = 4)))
names(cross_tab) &lt;- c("parent1", "parent2", "parent3", "parent4")

out &lt;- mppop_predict2(M = G.in_ex_mat, y.in = y.in_ex, map.in = map.in_ex, 
                      crossing.table = cross_tab, models = "rrBLUP")






</code></pre>

<hr>
<h2 id='pop.predict'>A genome-wide procedure for predicting genetic variance and correlated response in bi-parental breeding populations</h2><span id='topic+pop.predict'></span>

<h3>Description</h3>

<p><code>pop.predict</code> uses phenotypic and genotypic data from a set of individuals known as a training population (TP) and a set of candidate parents, which may or may not be included in the TP, to predict the mean (<code class="reqn">\mu</code>), genetic variance (<em>V_G</em>), and superior progeny values (<code class="reqn">\mu</code><em>_sp</em>) of the half-diallel, or a defined set of pairwise bi-parental crosses between parents. When multiple traits are provided <code>pop.predict</code> will also predict the correlated responses and correlation between all pairwise traits. See <cite>Mohammadi, Tiede, and Smith (2015)</cite> for further details.
</p>
<div class="sourceCode"><pre>         NOTE - \code{pop.predict} writes and reads files to disk so it is highly recommended to set your working directory
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>pop.predict(
  G.in = NULL,
  y.in = NULL,
  map.in = NULL,
  crossing.table = NULL,
  parents = NULL,
  tail.p = 0.1,
  nInd = 200,
  map.plot = FALSE,
  min.maf = 0.01,
  mkr.cutoff = 0.5,
  entry.cutoff = 0.5,
  remove.dups = TRUE,
  impute = "EM",
  nSim = 25,
  frac.train = 0.6,
  nCV.iter = 100,
  nFold = NULL,
  nFold.reps = 1,
  nIter = 12000,
  burnIn = 3000,
  models = c("rrBLUP", "BayesA", "BayesB", "BayesC", "BL", "BRR"),
  return.raw = FALSE,
  saveAt = tempdir()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.predict_+3A_g.in">G.in</code></td>
<td>
<p><code>Matrix</code> of genotypic data. First row contains marker names and the first column contains entry (taxa) names. Genotypes should be coded as follows: </p>

<ul>
<li> <p><code>1</code>: homozygous for minor allele
</p>
</li>
<li> <p><code>0</code>: heterozygous
</p>
</li>
<li> <p><code>-1</code>: homozygous for major allele
</p>
</li>
<li> <p><code>NA</code>: missing data
</p>
</li>
<li><p> Imputed genotypes can be passed, see <code>impute</code> below for details
</p>
</li></ul>

<p>TIP - Set header=<code>FALSE</code> within <code><a href="utils.html#topic+read.table">read.table</a></code> or <code><a href="utils.html#topic+read.csv">read.csv</a></code> when importing a tab-delimited file containing data for <code>G.in</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_y.in">y.in</code></td>
<td>
<p><code>Matrix</code> of phenotypic data. First column contains entry (taxa) names found in <code>G.in</code>, regardless of whether the entry has a phenotype for any or all traits. Additional columns contain phenotypic data; column names should reflect the trait name(s). TIP - Set header=<code>TRUE</code> within <code><a href="utils.html#topic+read.table">read.table</a></code> or <code><a href="utils.html#topic+read.csv">read.csv</a></code> when importing a tab-delimited file containing data for <code>y.in</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_map.in">map.in</code></td>
<td>
<p><code>Matrix</code> of genetic map data, three columns total. Column 1 contains marker names, column 2 contains chromosome number, and column 3 contains cM positions. TIP - Set header=<code>TRUE</code> within <code>read.table</code> or <code>read.csv</code> when importing a tab-delimited file contianing data for <code>map.in</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_crossing.table">crossing.table</code></td>
<td>
<p>Optional <code>matrix</code> specifying which crosses are to be simulated, two columns total. Column 1 contains the first parent of the cross (Par1) and column 2 contains the second parent of the cross (Par2).</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_parents">parents</code></td>
<td>
<p>Optional <code>character vector</code>. If <code>parents="TP"</code> then only the entries (taxa) within the training population (i.e. are phenotyped for the trait) are considered as parents; all pairwise crosses will be simulated for these. User could otherwise provide a character vector of entry names; all pairwise crosses will be simulated for these.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_tail.p">tail.p</code></td>
<td>
<p>Optional <code>numeric</code> indicating the percentile of the simulated progeny to be included into the calculation of <code class="reqn">\mu</code><em>_sp</em> and correlated response. Default is <code>0.10</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_nind">nInd</code></td>
<td>
<p>Optional <code>integer</code> indicating the number of progeny simulated per cross, per iteration, using <code><a href="qtl.html#topic+sim.cross">sim.cross</a></code> in R/qtl (<em>Broman et al., 2003</em>). Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_map.plot">map.plot</code></td>
<td>
<p>Optional <code>logical</code>. If <code>TRUE</code> then a plot of the genetic map will be generated by <code><a href="qtl.html#topic+plot.map">plot.map</a></code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_min.maf">min.maf</code></td>
<td>
<p>Optional <code>numeric</code> indicating a minimum minor allele frequency (MAF) when filtering <code>G.in</code>. Markers with an MAF &lt; <code>min.maf</code> will be removed. Default is <code>0.01</code> to remove monomorphic markers. Set to <code>0</code> for no filtering.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_mkr.cutoff">mkr.cutoff</code></td>
<td>
<p>Optional <code>numeric</code> indicating the maximum missing data per marker when filtering <code>G.in</code>. Markers missing &gt; <code>mkr.cutoff</code> data will be removed. Default is <code>0.50</code>. Set to <code>1</code> for no filtering.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_entry.cutoff">entry.cutoff</code></td>
<td>
<p>Optional <code>numeric</code> indicating the maximum missing genotypic data per entry allowed when filtering <code>G.in</code>. Entries missing &gt; <code>entry.cutoff</code> marker data will be removed. Default is <code>0.50</code>. Set to <code>1</code> for no filtering.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_remove.dups">remove.dups</code></td>
<td>
<p>Optional <code>logical</code>. If <code>TRUE</code> duplicate entries in the genotype matrix, if present, will be removed. This step may be necessary for missing marker imputation (see <code>impute</code> below). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_impute">impute</code></td>
<td>
<p>Options include <code>c("EM", "mean", "pass")</code>. By default (i.e. <code>"EM"</code>), after filtering missing genotypic data will be imputed via the EM algorithm implemented in <code><a href="rrBLUP.html#topic+rrBLUP-package">rrBLUP-package</a></code> (<cite>Endelman, 2011</cite>; <cite>Poland et al., 2012</cite>). If <code>"mean"</code> missing genotypic data will be imputed via the 'marker mean' method, also implemented in <code><a href="rrBLUP.html#topic+rrBLUP-package">rrBLUP-package</a></code>. Enter <code>"pass"</code> if a pre-filtered and imputed genotype matrix is provided to <code>G.in</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_nsim">nSim</code></td>
<td>
<p>Optional <code>integer</code> indicating the number of iterations a population should be simulated for each pairwise cross. Returned values are reported as means of parameters estimated in each of <code>nSim</code> simulations. Default is <code>25</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_frac.train">frac.train</code></td>
<td>
<p>Optional <code>numeric</code> indicating the fraction of the TP that is used to estimate marker effects (i.e. the prediction set) under cross-validation (CV) method 1 (see <code>Details</code> in <code><a href="#topic+x.val">x.val</a></code>). The remaining <code class="reqn">(1-frac.trait)</code> of the TP will then comprise the prediction set.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_ncv.iter">nCV.iter</code></td>
<td>
<p>Optional <code>integer</code> indicating the number of times to iterate <em>CV method 1</em> (see <code>Details</code> in <code><a href="#topic+x.val">x.val</a></code>). Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_nfold">nFold</code></td>
<td>
<p>Optional <code>integer</code>. If a number is provided, denoting the number of &quot;folds&quot;, then CV will be conducted using <em>CV method 2</em> (see <code>Details</code> in <code><a href="#topic+x.val">x.val</a></code>). Default is <code>NULL</code>, resulting in the default use of the <em>CV method 1</em>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_nfold.reps">nFold.reps</code></td>
<td>
<p>Optional <code>integer</code> indicating the number of times <em>CV method 2</em> is repeated. The CV accuracy returned is the average <em>r</em> of each rep. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_niter">nIter</code>, <code id="pop.predict_+3A_burnin">burnIn</code></td>
<td>
<p>Optional <code>integer</code> arguments used by <code><a href="BGLR.html#topic+BGLR">BGLR</a></code> (<cite>de los Compos and Rodriguez, 2014</cite>) when fitting Bayesian models to estimate marker effects. The defaults are <code>12000</code> and <code>3000</code>, respectively. These values when conducting CV are fixed <code>1500</code> and <code>500</code>, respectively, for computational efficiency.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_models">models</code></td>
<td>
<p>Optional <code>Character vector</code> of the regression models to be used in CV and to estimate marker effects. Options include <code>rrBLUP, BayesA, BayesB, BayesC, BL, BRR</code>, one or more may be included at a time. CV will be conducted regardless of how many models are included. By default all models are tested.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_return.raw">return.raw</code></td>
<td>
<p>Optional <code>logical</code>. If <code>TRUE</code> then <code>pop.predict</code> will return the results of each simulation in addition to the summarized dataframe. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_saveat">saveAt</code></td>
<td>
<p>When using models other than &quot;rrBLUP&quot; (i.e. Bayesian models), this is a path and prefix for saving temporary files
the are produced by the <code><a href="BGLR.html#topic+BGLR">BGLR</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pop.predict</code> can be used to predict the mean (<code class="reqn">\mu</code>), genetic variance (<em>V_G</em>), superior progeny values (<code class="reqn">\mu</code><code class="reqn">_sp</code>), as well as the predicted correlated response and correlations between all pairwise traits. The methodology and procedure to do so has been described in <cite>Bernardo (2014)</cite> and <cite>Mohammadi, Tiede, and K.P. Smith (2015)</cite>. Users familiar with genome-wide prediction, association mapping, and/or linkage mapping will be familiar with the
required inputs of <code>pop.predict</code>. <code>G.in</code> includes all of the entries (taxa) in the TP as well as additional entries to be considered as parent candidates. Entries included in <code>G.in</code> that do have a phenotype for any or all traits in <code>y.in</code> are considered TP entries for those respective traits. <code>G.in</code> is filtered according to <code>min.maf</code>, <code>mkr.cutoff</code>, <code>entry.cutoff</code>, and <code>remove.dups</code>;
remaining missing marker data is imputed using the EM algorithm (<cite>Poland et al., 2012</cite>) when possible, and the marker mean otherwise, both implemented in <code><a href="rrBLUP.html#topic+rrBLUP-package">rrBLUP-package</a></code>. For each trait, the TP (i.e. entries with phenotype) is used to: </p>

<ol>
<li><p> Perform CV to select a regression model. NOTE - Using the model with the highest CV accuracy is expected to result in the most accurate marker effect estimates (<cite>Bernardo, 2014</cite>). This expectation, however, is yet to be empirically validated and the user is encouraged to investigate the various models in order to make an educated decision about which one to ultimately use.
</p>
</li>
<li><p> Estimate marker effects using the model resulting in the highest CV accuracy
</p>
</li></ol>

<p>Models include ridge regression BLUP implemented in <code><a href="rrBLUP.html#topic+rrBLUP-package">rrBLUP-package</a></code> (<cite>Endelman, 2011</cite>) and BayesA, BayesB, BayesC<code class="reqn">\pi</code>, Bayesian lasso (BL), and Bayesian ridge regression (BRR) implemented in <code><a href="BGLR.html#topic+BGLR">BGLR</a></code> (<cite>de los Compos and Rodriguez, 2014</cite>).
Information from the <code>map.in</code> is then used to simulate chromosomal recombination expected in a recombinant inbred line (i.e. <em>F-infinity</em>) (<cite>Broman et al., 2003</cite>) population (size=<code>nInd</code>). A function then converts the recombined chromosomal segments of the generic RIL population to the chromosomal segments of the population's respective parents and GEBVs of the simulated progeny are calculated.
The simulation and conversion process is repeated <em>s</em> times, where <em>s</em> = <code>nSim</code>, to calculate dispersion statistics for <code class="reqn">\mu</code> and <em>V_G</em>; the remainder of the values in the <code>predictions</code> output are means of the <em>s</em> simulations.  During each iteration the correlation (<em>r</em>) and correlated response of each pairwise combination of traits is also calculated and their mean across <em>n</em> simulations is returned.
The correlated response of trait.B when predicting trait.A is the mean of trait.B for the (<code class="reqn">\mu</code><code class="reqn">_sp</code>) of trait.A, and vice-versa; a correlated response for the bottom <code>tail.p</code> and upper <code class="reqn">1-tail.p</code> is returned for each trait.
</p>
<div class="sourceCode"><pre>     A dataset \code{\link{think_barley.rda}} is provided as an example of the proper formatting of input files and also for users to become familiar with \code{pop.predict}.
</pre></div>


<h3>Value</h3>

<p>A <code>list</code> containing: </p>

<ul>
<li> <p><code>predictions</code> A <code>list</code> of dataframes containing predictions of (<code class="reqn">\mu</code>), (<em>V_G</em>), and (<code class="reqn">\mu</code><em>_sp</em>). When multiple traits are provided the correlated responses and correlation between all pairwise traits is also included. More specifically, for a given trait pair the correlated response of the secondary trait with both the high and low superior progeny of the primary trait is returned since the favorable values cannot be known by <code>PopVar</code>.
</p>
</li>
<li> <p><code>preds.per.sim</code> If return.raw is <code>TRUE</code> then a <code>dataframe</code> containing the results of each simulation is returned. This is useful for calculating dispersion statistics for traits not provided in the standard <code>predictions</code> dataframe.
</p>
</li>
<li> <p><code>CVs</code> A <code>dataframe</code> of CV results for each trait/model combination specified.
</p>
</li>
<li> <p><code>models.chosen</code> A <code>matrix</code> listing the statistical model chosen for each trait.
</p>
</li>
<li> <p><code>markers.removed</code> A <code>vector</code> of markers removed during filtering for MAF and missing data.
</p>
</li>
<li> <p><code>entries.removed</code> A <code>vector</code> of entries removed during filtering for missing data and duplicate entries.
</p>
</li></ul>



<h3>References</h3>

<div class="sourceCode"><pre> Bernardo, R. 2014. Genomewide Selection of Parental Inbreds: Classes of Loci and Virtual Biparental Populations. Crop Sci. 55:2586-2595.
 
 Broman, K. W., H. Wu, S. Sen and G.A. Churchill. 2003. R/qtl: QTL mapping in experimental crosses. Bioinformatics 19:889-890.
 
 Endelman, J. B. 2011. Ridge regression and other kernels for genomic selection with R package rrBLUP. Plant Genome 4:250-255. doi: 10.3835/plantgenome2011.08.0024

 Gustavo de los Campos and Paulino Perez Rodriguez, (2014). BGLR: Bayesian Generalized Linear Regression. R package version 1.0.3. http://CRAN.R-project.org/package=BGLR
 
 Mohammadi M., T. Tiede, and K.P. Smith. 2015. PopVar: A genome-wide procedure for predicting genetic variance and correlated response in bi-parental breeding populations. Crop Sci. \emph{Accepted}.
 
 Munoz-Amatriain, M., M. J. Moscou, P. R. Bhat, J. T. Svensson, J. Bartos, P. Suchankova, H. Simkova, T. R. Endo, R. D. Fenton, S. Lonardi, A. M. Castillo, S. Chao, L. Cistue, A. Cuesta-Marcos, K. L. Forrest, M. J. Hayden, P. M. Hayes, R. D. Horsley, K. Makoto, D. Moody, K. Sato, M. P. Valles, B. B. H. Wulff, G. J. Muehlbauer, J. Dolezel, and T. J. Close. 2011 An improved consensus linkage map of barley based on flow-sorted chromosomes and single nucleotide polymorphism markers. Plant Gen. 4:238-249.
 
 Poland, J., J. Endelman, J. Dawson, J. Rutkoski, S. Wu, Y. Manes, S. Dreisigacker, J. Crossa, H. Sanches-Villeda, M. Sorrells, and J.-L. Jannink. 2012. Genomic Selection in Wheat Breeding using Genotyping-by-Sequencing. Plant Genome 5:103-113.
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Load data
data("think_barley")

## Ex. 1 - Predict a defined set of crosses
## This example uses CV method 1 (see Details of x.val() function)
ex1.out &lt;- pop.predict(G.in = G.in_ex, y.in = y.in_ex, 
   map.in = map.in_ex, crossing.table = cross.tab_ex,
   nSim=5, nCV.iter=2)
ex1.out$predictions  ## Predicted parameters
ex1.out$CVs          ## CV results
               
## Ex. 2 - Predict all pairwise crosses between a list of parents
## This example uses CV method 2 (see Details of x.val() function)
par.list &lt;- sample(y.in_ex[,1], size = 10, replace = FALSE)
ex2.out &lt;- pop.predict(G.in = G.in_ex, y.in = y.in_ex,
   map.in = map.in_ex, parents = par.list, 
   nSim=5, nFold=5, nFold.reps=2)
       
## Ex. 3 - Use only rrBLUP and Bayesian lasso (BL) models
ex3.out &lt;- pop.predict(G.in = G.in_ex, y.in = y.in_ex,
   map.in = map.in_ex, crossing.table = cross.tab_ex,
   models = c("rrBLUP", "BL"), nSim=5, nCV.iter=10)  

## Ex. 4 - Same as Ex. 3, but return all raw SNP and prediction data for each simulated population
ex4.out &lt;- pop.predict(G.in = G.in_ex, y.in = y.in_ex,
   map.in = map.in_ex, crossing.table = cross.tab_ex,
   models = c("rrBLUP", "BL"), nSim=5, nCV.iter=2, return.raw = TRUE)  

## End(Not run)

</code></pre>

<hr>
<h2 id='pop.predict2'>Predict genetic variance and genetic correlations in bi-parental populations using a deterministic model</h2><span id='topic+pop.predict2'></span><span id='topic+pop_predict2'></span>

<h3>Description</h3>

<p>Generates predictions of the genetic variance and genetic correlation in bi-parental populations using a set of deterministic equations instead of simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.predict2(
  G.in,
  y.in,
  map.in,
  crossing.table,
  parents,
  tail.p = 0.1,
  self.gen = Inf,
  DH = FALSE,
  models = c("rrBLUP", "BayesA", "BayesB", "BayesC", "BL", "BRR"),
  ...
)

pop_predict2(
  M,
  y.in,
  marker.effects,
  map.in,
  crossing.table,
  parents,
  tail.p = 0.1,
  self.gen = Inf,
  DH = FALSE,
  models = c("rrBLUP", "BayesA", "BayesB", "BayesC", "BL", "BRR"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.predict2_+3A_g.in">G.in</code></td>
<td>
<p>See <code>G.in</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="pop.predict2_+3A_y.in">y.in</code></td>
<td>
<p>See <code>y.in</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="pop.predict2_+3A_map.in">map.in</code></td>
<td>
<p>See <code>map.in</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="pop.predict2_+3A_crossing.table">crossing.table</code></td>
<td>
<p>See <code>crossing.table</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="pop.predict2_+3A_parents">parents</code></td>
<td>
<p>See <code>parents</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="pop.predict2_+3A_tail.p">tail.p</code></td>
<td>
<p>See <code>tail.p</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="pop.predict2_+3A_self.gen">self.gen</code></td>
<td>
<p>The number of selfing generations in the potential cross. Can be an integer or <code>Inf</code> for
recombinant inbreds. Note: <code>self.gen = 1</code> corresponds to an F2 population.</p>
</td></tr>
<tr><td><code id="pop.predict2_+3A_dh">DH</code></td>
<td>
<p>Indicator if doubled-haploids are to be induced after the number of selfing generations indicated by
<code>self.gen</code>. For example, if <code>self.gen = 0</code> and <code>DH = TRUE</code>, then doubled-haploids are assumed
to be induced using gametes from F1 plants.</p>
</td></tr>
<tr><td><code id="pop.predict2_+3A_models">models</code></td>
<td>
<p>See <code>models</code> in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
<tr><td><code id="pop.predict2_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass depending on the choice of <code>model</code>.</p>
</td></tr>
<tr><td><code id="pop.predict2_+3A_m">M</code></td>
<td>
<p>A Matrix of marker genotypes of dimensions <code>nLine</code> x <code>nMarker</code>, coded as
-1, 0, and 1.</p>
</td></tr>
<tr><td><code id="pop.predict2_+3A_marker.effects">marker.effects</code></td>
<td>
<p>A data frame of marker effects. The first column should include the marker name and
subsequent columns should include the marker effects. Supercedes <code>y.in</code> if passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions are based on the deterministic equations specified by Zhong and Jannink (2007), Allier et al. (2019),
and Neyhart et al. (2019).
</p>
<p>If you select a <code>model</code> other than &quot;rrBLUP&quot;, you must specify the following additional arguments:
</p>

<ul>
<li><p><code>nIter</code>: See <code><a href="#topic+pop.predict">pop.predict</a></code>.
</p>
</li>
<li><p><code>burnIn</code>: See <code><a href="#topic+pop.predict">pop.predict</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> containing predictions of <code class="reqn">\mu</code>, <code class="reqn">V_G</code>, and <code class="reqn">\mu_{sp}</code> for
each trait for each potential bi-parental cross. When multiple traits are provided, the correlated
responses and correlation between all pairs of traits is also returned.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pop_predict2()</code>: 
</p>
</li></ul>


<h3>References</h3>

<p>Zhong, S., and J.-L. Jannink, 2007 Using quantitative trait loci results to discriminate among crosses on the basis of their
progeny mean and variance. Genetics 177: 567–576. https://doi.org/10.1534/ genetics.107.075358
</p>
<p>Allier, A., L. Moreau, A. Charcosset, S. Teyssèdre, and C. Lehermeier, 2019 Usefulness Criterion and Post-selection Parental
Contributions in Multi-parental Crosses: Application to Polygenic Trait Introgression. G3 9: 1469–1479.
doi: 10.1534/g3.119.400129
</p>
<p>Neyhart, J.L., A.J. Lorenz, and K.P. Smith, 2019 Multi-trait Improvement by Predicting Genetic Correlations in Breeding
Crosses. G3 9: 3153-3165. doi: 10.1534/g3.119.400406
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Load data
data("think_barley")

# Use example data to make predictions
out &lt;- pop.predict2(G.in = G.in_ex_imputed, y.in = y.in_ex, map.in = map.in_ex, 
                    crossing.table = cross.tab_ex)
                    
# Provide a vector of parents to predict all possible crosses (some parents
# have missing phenotypic data)
out &lt;- pop.predict2(G.in = G.in_ex_imputed, y.in = y.in_ex, map.in = map.in_ex, 
                    parents = y.in_ex$Entry[1:5])
                    
# Make predictions for 5 crosses with various levels of inbreeding
out_list &lt;- lapply(X = 1:10, FUN = function(self.gen) {
  out &lt;- pop.predict2(G.in = G.in_ex_imputed, y.in = y.in_ex, map.in = map.in_ex, 
                      crossing.table = cross.tab_ex[1:5,], self.gen = self.gen)
  out$self.gen &lt;- self.gen
  out })
               
# Plot predictions of grain yield genetic variance over levels of inbreeding
dat &lt;- do.call("rbind", lapply(out_list, subset, trait == "Yield"))
plot(pred_varG ~ self.gen, data = dat, type = "b", 
     subset = parent1 == parent1[1] &amp; parent2 == parent2[1])






# Load data
data("think_barley")

# Use example data to make predictions
out &lt;- pop_predict2(M = G.in_ex_mat, y.in = y.in_ex, map.in = map.in_ex, 
                    crossing.table = cross.tab_ex)
                    
# Provide a vector of parents to predict all possible crosses (some parents
# have missing phenotypic data)
out &lt;- pop_predict2(M = G.in_ex_mat, y.in = y.in_ex, map.in = map.in_ex, 
                    parents = y.in_ex$Entry[1:10])
                    

                    

</code></pre>

<hr>
<h2 id='PopVar-package'>Genomic breeding tools to 1) predict standard statistics and correlated response in plant populations, and 2) performs cross-validation to estimate genome-wide prediction accuracy</h2><span id='topic+PopVar-package'></span><span id='topic+PopVar'></span>

<h3>Description</h3>

<p>PopVar includes two functions useful for genome-based breeding: </p>

<ul>
<li> <p><code><a href="#topic+pop.predict">pop.predict</a></code> uses phenotypic and genotypic data from a set of individuals known as a training population (TP) and a set of candidate parents, which may or may not be included in the TP, to predict the mean (<code class="reqn">\mu</code>), genetic variance (<em>V_G</em>), and superior progeny value (<code class="reqn">\mu</code><em>_sp</em>) of the half-diallel, or a defined set of pairwise bi-parental crosses between parents. When multiple traits are provided <code>pop.predict</code> will also predict the correlated responses and correlation between all pairwise traits. See <cite>Mohammadi, Tiede, and Smith (2015)</cite> for further details.
</p>
</li>
<li> <p><code><a href="#topic+x.val">x.val</a></code> performs cross-validation (CV) to estimate the accuracy of genome-wide prediction (otherwise known as genomic selection) for a specific training population (TP), i.e. a set of individuals for which phenotypic and genotypic data is available. Cross-validation can be conducted via one of two methods, see <code>Details</code> in <code>x.val</code> documentation for more information.
</p>
</li></ul>

<p>The dataset <code><a href="#topic+think_barley.rda">think_barley.rda</a></code>, previously described in <cite>Sallam et al. (2014)</cite>, is provided as an example of the proper formatting of input files and also for users to become familiar with the functions within <code>PopVar</code>.
</p>


<h3>Author(s)</h3>

<p>Tyler Tiede (maintainer) <a href="mailto:tyler.tiede7@gmail.com">tyler.tiede7@gmail.com</a> and Mohsen Mohammadi
</p>
<div class="sourceCode"><pre>    Many thanks to Kevin Smith for supporting the project and Jeff Neyhart for helping with the initial 'debugging' efforts.
</pre></div>


<h3>References</h3>

<p>Mohammadi M., T. Tiede, and K.P. Smith. 2015. PopVar: A genome-wide procedure for predicting genetic variance and correlated response in bi-parental breeding populations. Crop Sci. <em>Accepted</em>.
</p>
<p>Sallam, A.H., J.B. Endelman, J-L. Jannink, and K.P. Smith. 2015. Assessing Genomic Selection Prediction Accuracy in a Dynamic Barley Breeding Population. Plant Gen. 8(1)
</p>

<hr>
<h2 id='think_barley.rda'>An example barley dataset</h2><span id='topic+think_barley.rda'></span><span id='topic+G.in_ex'></span><span id='topic+G.in_ex_mat'></span><span id='topic+G.in_ex_imputed'></span><span id='topic+y.in_ex'></span><span id='topic+map.in_ex'></span><span id='topic+cross.tab_ex'></span>

<h3>Description</h3>

<p>A sample dataset, previously described in <cite>Sallam et al. (2014)</cite> is provided as an example of the proper formatting of input files and also for users to become familiar with <code>PopVar</code>; the <code>think_barley</code> dataset is useful in demonstrating both <code><a href="#topic+pop.predict">pop.predict</a></code> and <code><a href="#topic+x.val">x.val</a></code>. Note that a number of entries are missing data for one or both traits,
which is representative of a real breeding scenario where phenotypic data may not be available for all parent candidates.
</p>


<h3>Format</h3>

<p>The names of the example files are:
</p>

<dl>
<dt>G.in_ex</dt><dd><p>A set of 245 barley lines genotyped with 742 SNP markers</p>
</dd>
<dt>G.in_ex_mat</dt><dd><p>A n x p matrix of n = 245 barley lines genotyped with p = 742 SNP markers</p>
</dd>
<dt>G.in_ex_imputed</dt><dd><p>A n x p matrix of n = 245 barley lines and p = 742 <em>imputed</em> SNP marker genotypes</p>
</dd>
<dt>y.in_ex</dt><dd><p>Phenotypes of four traits for a portion of the 245 barley lines, Fusarium head blight (FHB), deoxynivalenol (DON) in ppm, grain yield in bushels/acre, and plant height in cm.</p>
</dd>
<dt>map.in_ex</dt><dd><p>Genetic map (i.e. chromosome assignment and genetic distance (cM) between markers) of the 742 SNP markers based on <cite>Munoz-Amatriain et al., 2011</cite></p>
</dd>
<dt>cross.tab_ex</dt><dd><p>A table of user-defined crosses</p>
</dd>
</dl>



<h3>References</h3>

<p>Sallam, A.H., J.B. Endelman, J-L. Jannink, and K.P. Smith. 2015. Assessing Genomic Selection Prediction Accuracy in a Dynamic Barley Breeding Population. Plant Gen. 8(1)
</p>

<hr>
<h2 id='x.val'>Estimate genome-wide prediction accuracy using cross-validation</h2><span id='topic+x.val'></span>

<h3>Description</h3>

<p><code>x.val</code> performs cross-validation (CV) to estimate the accuracy of genome-wide prediction (otherwise known as genomic selection) for a specific training population (TP), i.e. a set of individuals for which phenotypic and genotypic data is available. Cross-validation can be conducted via one of two methods within <code>x.val</code>, see <code>Details</code> for more information.
</p>
<div class="sourceCode"><pre>         NOTE - \code{x.val}, specifically \code{\link[BGLR]{BGLR}} writes and reads files to disk so it is highly recommended to set your working directory
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>x.val(
  G.in = NULL,
  y.in = NULL,
  min.maf = 0.01,
  mkr.cutoff = 0.5,
  entry.cutoff = 0.5,
  remove.dups = TRUE,
  impute = "EM",
  frac.train = 0.6,
  nCV.iter = 100,
  nFold = NULL,
  nFold.reps = 1,
  return.estimates = FALSE,
  CV.burnIn = 750,
  CV.nIter = 1500,
  models = c("rrBLUP", "BayesA", "BayesB", "BayesC", "BL", "BRR"),
  saveAt = tempdir()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x.val_+3A_g.in">G.in</code></td>
<td>
<p><code>Matrix</code> of genotypic data. First row contains marker names and the first column contains entry (taxa) names. Genotypes should be coded as follows: </p>

<ul>
<li> <p><code>1</code>: homozygous for minor allele
</p>
</li>
<li> <p><code>0</code>: heterozygous
</p>
</li>
<li> <p><code>-1</code>: homozygous for major allele
</p>
</li>
<li> <p><code>NA</code>: missing data
</p>
</li>
<li><p> Imputed genotypes can be passed, see <code>impute</code> below for details
</p>
</li></ul>

<p>TIP - Set header=<code>FALSE</code> within <code><a href="utils.html#topic+read.table">read.table</a></code> or <code><a href="utils.html#topic+read.csv">read.csv</a></code> when importing a tab-delimited file containing data for <code>G.in</code>.</p>
</td></tr>
<tr><td><code id="x.val_+3A_y.in">y.in</code></td>
<td>
<p><code>Matrix</code> of phenotypic data. First column contains entry (taxa) names found in <code>G.in</code>, regardless of whether the entry has a phenotype for any or all traits. Additional columns contain phenotypic data; column names should reflect the trait name(s). TIP - Set header=<code>TRUE</code> within <code>read.table</code> or <code>read.csv</code> when importing a tab-delimited file containing dat</p>
</td></tr>
<tr><td><code id="x.val_+3A_min.maf">min.maf</code></td>
<td>
<p>Optional <code>numeric</code> indicating a minimum minor allele frequency (MAF) when filtering <code>G.in</code>. Markers with an MAF &lt; <code>min.maf</code> will be removed. Default is <code>0.01</code> to remove monomorphic markers. Set to <code>0</code> for no filtering.</p>
</td></tr>
<tr><td><code id="x.val_+3A_mkr.cutoff">mkr.cutoff</code></td>
<td>
<p>Optional <code>numeric</code> indicating the maximum missing data per marker when filtering <code>G.in</code>. Markers missing &gt; <code>mkr.cutoff</code> data will be removed. Default is <code>0.50</code>. Set to <code>1</code> for no filtering.</p>
</td></tr>
<tr><td><code id="x.val_+3A_entry.cutoff">entry.cutoff</code></td>
<td>
<p>Optional <code>numeric</code> indicating the maximum missing genotypic data per entry allowed when filtering <code>G.in</code>. Entries missing &gt; <code>entry.cutoff</code> marker data will be removed. Default is <code>0.50</code>. Set to <code>1</code> for no filtering.</p>
</td></tr>
<tr><td><code id="x.val_+3A_remove.dups">remove.dups</code></td>
<td>
<p>Optional <code>logical</code>. If <code>TRUE</code> duplicate entries in the genotype matrix, if present, will be removed. This step may be necessary for missing marker imputation (see <code>impute</code>). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="x.val_+3A_impute">impute</code></td>
<td>
<p>Options include <code>c("EM", "mean", "pass")</code>. By default (i.e. <code>"EM"</code>), after filtering missing genotypic data will be imputed via the EM algorithm implemented in <code><a href="rrBLUP.html#topic+rrBLUP-package">rrBLUP-package</a></code> (<cite>Endelman, 2011</cite>; <cite>Poland et al., 2012</cite>). If <code>"mean"</code> missing genotypic data will be imputed via the 'marker mean' method, also implemented in <code><a href="rrBLUP.html#topic+rrBLUP-package">rrBLUP-package</a></code>. Enter <code>"pass"</code> if a pre-filtered and imputed genotype matrix is provided to <code>G.in</code>.</p>
</td></tr>
<tr><td><code id="x.val_+3A_frac.train">frac.train</code></td>
<td>
<p>Optional <code>numeric</code> indicating the fraction of the TP that is used to estimate marker effects (i.e. the prediction set) under cross-validation (CV) method 1 (see <code>Details</code>). The remaining <code class="reqn">(1-frac.trait)</code> of the TP will then comprise the prediction set.</p>
</td></tr>
<tr><td><code id="x.val_+3A_ncv.iter">nCV.iter</code></td>
<td>
<p>Optional <code>integer</code> indicating the number of times to iterate <em>CV method 1</em> described in <code>Details</code>. Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="x.val_+3A_nfold">nFold</code></td>
<td>
<p>Optional <code>integer</code>. If a number is provided, denoting the number of &quot;folds&quot;, then CV will be conducted using <em>CV method 2</em> (see <code>Details</code>). Default is <code>NULL</code>, resulting in the default use of the <em>CV method 1</em>.</p>
</td></tr>
<tr><td><code id="x.val_+3A_nfold.reps">nFold.reps</code></td>
<td>
<p>Optional <code>integer</code> indicating the number of times <em>CV method 2</em> is repeated. The CV accuracy returned is the average <em>r</em> of each rep. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="x.val_+3A_return.estimates">return.estimates</code></td>
<td>
<p>Optional <code>logical</code>. If <code>TRUE</code> additional items including the marker effect and beta estimates from the selected prediction model (i.e. highest CV accuracy) will be returned.</p>
</td></tr>
<tr><td><code id="x.val_+3A_cv.burnin">CV.burnIn</code></td>
<td>
<p>Optional <code>integer</code> argument used by <code><a href="BGLR.html#topic+BGLR">BGLR</a></code> when fitting Bayesian models. Default is <code>750</code>.</p>
</td></tr>
<tr><td><code id="x.val_+3A_cv.niter">CV.nIter</code></td>
<td>
<p>Optional <code>integer</code> argument used by <code><a href="BGLR.html#topic+BGLR">BGLR</a></code> (<cite>de los Compos and Rodriguez, 2014</cite>) when fitting Bayesian models. Default is <code>1500</code>.</p>
</td></tr>
<tr><td><code id="x.val_+3A_models">models</code></td>
<td>
<p>Optional <code>character vector</code> of the regression models to be used in CV and to estimate marker effects. Options include <code>rrBLUP, BayesA, BayesB, BayesC, BL, BRR</code>, one or more may be included at a time. By default all models are tested.</p>
</td></tr>
<tr><td><code id="x.val_+3A_saveat">saveAt</code></td>
<td>
<p>When using models other than &quot;rrBLUP&quot; (i.e. Bayesian models), this is a path and prefix for saving temporary files
the are produced by the <code><a href="BGLR.html#topic+BGLR">BGLR</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two CV methods are available within <code>PopVar</code>: </p>

<ul>
<li> <p><code>CV method 1</code>: During each iteration a training (i.e. model training) set will be <strong>randomly sampled</strong> from the TP of size <code class="reqn">N*(frac.train)</code>, where <em>N</em> is the size of the TP, and the remainder of the TP is assigned to the validation set. The accuracies of individual models are expressed as average Pearson's correlation coefficient (<em>r</em>) between the genome estimated breeding value (GEBV) and observed phenotypic values in the validation set across all <code>nCV.iter</code> iterations. Due to its amendibility to various TP sizes, <em>CV method 1</em> is the default CV method in <code><a href="#topic+pop.predict">pop.predict</a></code>.
</p>
</li>
<li> <p><code>CV method 2</code>: <code>nFold</code> <strong>independent</strong> validation sets are sampled from the TP and predicted by the remainder. For example, if <code class="reqn">nFold = 10</code> the TP will be split into 10 equal sets, each containing <code class="reqn">1/10</code>-th of the TP, which will be predicted by the remaining <code class="reqn">9/10</code>-ths of the TP. The accuracies of individual models are expressed as the average (<em>r</em>) between the GEBV and observed phenotypic values in the validation set across all <code>nFold</code> folds. The process can be repeated <code>nFold.reps</code> times with <code>nFold</code> new independent sets being sampled each replication, in which case the reported prediction accuracies are averages across all folds and replications.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing: </p>

<ul>
<li> <p><code>CVs</code> A <code>dataframe</code> of CV results for each trait/model combination specified
</p>
</li>
<li><p> If <code>return.estimates</code> is <code>TRUE</code> the additional items will be returned: </p>

<ul>
<li> <p><code>models.used</code> A <code>list</code> of the models chosen to estimate marker effects for each trait
</p>
</li>
<li> <p><code>mkr.effects</code> A <code>vector</code> of marker effect estimates for each trait generated by the respective prediction model used
</p>
</li>
<li> <p><code>betas</code> A <code>list</code> of beta values for each trait generated by the respective prediction model used
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## CV using method 1 with 25 iterations
CV.mthd1 &lt;- x.val(G.in = G.in_ex, y.in = y.in_ex, nCV.iter = 25)
CV.mthd1$CVs

## CV using method 2 with 5 folds and 3 replications
x.val(G.in = G.in_ex, y.in = y.in_ex, nFold = 5, nFold.reps = 3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
