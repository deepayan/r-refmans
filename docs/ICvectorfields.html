<!DOCTYPE html><html><head><title>Help for package ICvectorfields</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ICvectorfields}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DispField'><p>Displacement fields based on 2D cross-covariance</p></a></li>
<li><a href='#DispFieldbb'><p>Displacement fields based on 2D cross-covariance using bounding box</p></a></li>
<li><a href='#DispFieldST'><p>Displacement fields for spatiotemporal data when velocity is spatially constant</p></a></li>
<li><a href='#DispFieldSTall'><p>Diplacement fields for spatiotemporal data when velocity varies spatially</p></a></li>
<li><a href='#DispFieldSTbb'><p>Displacement fields for spatiotemporal data using a bounding box</p></a></li>
<li><a href='#DispFieldSTbball'><p>Diplacement fields using bounding box when velocity varies spatially</p></a></li>
<li><a href='#DispMoransI'><p>Calculate statistics in source or sink regions</p></a></li>
<li><a href='#GetRowCol'><p>Retrieve matrix row and column indices</p></a></li>
<li><a href='#MoransI'><p>Efficiently compute Moran's I statistic</p></a></li>
<li><a href='#PatternDetect'><p>Detect Patterns in Vector Fields</p></a></li>
<li><a href='#PixelCt'><p>Count populated pixels in a raster stack</p></a></li>
<li><a href='#RastStackData'><p>Creating a raster stack from formatted datasets</p></a></li>
<li><a href='#RooksGradient'><p>Calculate Gradient Statistics in the Rook's Neighbourhood</p></a></li>
<li><a href='#RooksNeighCt'><p>Define a subset of grid locations with non-overlapping rook neighborhoods</p></a></li>
<li><a href='#RooksNeighFind'><p>Classify Rook's Neighbours Comprising Spread Patterns in Vector Fields</p></a></li>
<li><a href='#RotationDetect'><p>Detect Rotating Patterns in Vector Fields</p></a></li>
<li><a href='#SimData'><p>Simulated movement data</p></a></li>
<li><a href='#SubgridMoransI'><p>Compute statistics for subgrids</p></a></li>
<li><a href='#Xcov2D'><p>Cross-covariance in two spatial dimensions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Vector Fields from Spatial Time Series of Population Abundance</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for converting time series of spatial abundance or density 
    data in raster format to vector fields of population movement using the digital 
    image correlation technique. More specifically, the functions in the package 
    compute cross-covariance using discrete fast Fourier transforms for computational 
    efficiency. Vectors in vector fields point in the direction of highest two 
    dimensional cross-covariance. The package has a novel implementation of the 
    digital image correlation algorithm that is designed to detect persistent 
    directional movement when image time series extend beyond a sequence of 
    two raster images. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggnewscale, ggplot2, knitr, metR, ncf, rmarkdown, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>fftwtools, Rcpp, terra (&ge; 1.5-21)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/goodsman/ICvectorfields/issues">https://github.com/goodsman/ICvectorfields/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-26 22:09:45 UTC; goods</td>
</tr>
<tr>
<td>Author:</td>
<td>Devin Goodsman <a href="https://orcid.org/0000-0003-1935-5779"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Devin Goodsman &lt;goodsman@ualberta.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-26 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DispField'>Displacement fields based on 2D cross-covariance</h2><span id='topic+DispField'></span>

<h3>Description</h3>

<p>Calculates a displacement field based on the cross-covariance of two input
rasters presumably representing spatial population abundance or density at
two different instances of time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DispField(inputrast1, inputrast2, factv1, facth1, restricted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DispField_+3A_inputrast1">inputrast1</code></td>
<td>
<p>a raster as produced by terra::rast</p>
</td></tr>
<tr><td><code id="DispField_+3A_inputrast2">inputrast2</code></td>
<td>
<p>a raster of equivalent dimension to inputrast1 as produced
by terra::rast</p>
</td></tr>
<tr><td><code id="DispField_+3A_factv1">factv1</code></td>
<td>
<p>an odd integer for the vertical dimension of sub-grids</p>
</td></tr>
<tr><td><code id="DispField_+3A_facth1">facth1</code></td>
<td>
<p>an odd integer for the horizontal dimension of sub-grids</p>
</td></tr>
<tr><td><code id="DispField_+3A_restricted">restricted</code></td>
<td>
<p>logical (TRUE or FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input rasters are first converted to equivalent matrices. The function
then divides the domain up into sub-grids of size factv1 X facth1, which are
vertical and horizontal sub-grid dimensions.
</p>
<p>If restricted is set to FALSE (the default), the function computes
cross-covariance between each sub-grid of the first input raster and the
entirety of the second input raster and then uses the location of maximum
cross-covariance to estimate displacement in the vertical and horizontal
directions from the centre of each sub-grid.
</p>
<p>If restricted is set to TRUE, the function uses cross-covariance between each
sub-grid in the first input raster and the equivalent sub-grid in the second
input raster to estimate vertical and horizontal displacement.
</p>
<p>Reference coordinates and cell size are extracted from the first input raster
such that the locations from whence displacement is estimated as well as
displacement estimates can be expressed in the units of the projected
coordinates.
</p>
<p>The coordinates are assumed to increase vertically and horizontally from the
lower left corner of the two-dimensional domain.
</p>
<p>Caution is warranted when defining the sub-grid dimensions because the
function can produce erroneous results when sub-grids are too small.
</p>


<h3>Value</h3>

<p>A data frame is returned with the following column names: rowcent,
colcent, frowmin, frowmax, fcolmin, fcolmax, centx, centy, dispx, and
dispy. The rowcent and colcent column names are the row and column indices
for the center of each sub-grid; frowmin and frowmax are the sub-grid
minimum and maximum row indices; fcolmin and fcolmax are the sub-grid
minimum and maximum column indices; centx and centy are the projected
coordinates of the centre of the subgrid derived from the raster input
files; dispx and dispy are the displacement in the horizontal and vertical
directions in the same units as the projected coordinates of the raster
input files.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DispFieldbb">DispFieldbb</a></code> for a similar function using a bounding
box to define a focal region, <code><a href="#topic+DispFieldST">DispFieldST</a></code> for a version
designed to quantify persistent directional movement when the time series
features more than two time instances, <code><a href="#topic+DispFieldSTall">DispFieldSTall</a></code> for a
version designed to quantify persistent directional movement when velocity
is variable in space, and <code><a href="#topic+Xcov2D">Xcov2D</a></code> for demonstration of how
two-dimensional cross-covariance is used to determine displacement (see
examples of Xcov2D function documentation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(Mat1 &lt;- matrix(rep(c(1:5, 0, 0, 0, 0), 9), nrow = 9, byrow = TRUE))
(Mat2 &lt;- matrix(rep(c(0, 1:5, 0, 0, 0), 9), nrow = 9, byrow = TRUE))

# rasterizing
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)

(VFdf1 &lt;- DispField(rast1, rast2, factv1 = 9, facth1 = 9))
# The second raster is shifted right by 1 unit relative to the first raster
# dispx = 1
</code></pre>

<hr>
<h2 id='DispFieldbb'>Displacement fields based on 2D cross-covariance using bounding box</h2><span id='topic+DispFieldbb'></span>

<h3>Description</h3>

<p>Calculates a displacement field based on the cross-covariance of two input
rasters presumably representing spatial population abundance or density at
two different instances of time. This version differs from
<code><a href="#topic+DispField">DispField</a></code> in that the user defines a bounding box that
determines a single sub-grid. The center of the bounding box is the location
from whence displacement is estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DispFieldbb(
  inputrast1,
  inputrast2,
  rowmn,
  rowmx,
  colmn,
  colmx,
  restricted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DispFieldbb_+3A_inputrast1">inputrast1</code></td>
<td>
<p>a raster as produced by terra::rast</p>
</td></tr>
<tr><td><code id="DispFieldbb_+3A_inputrast2">inputrast2</code></td>
<td>
<p>a raster of equivalent dimension to inputrast1 as produced
by terra::rast</p>
</td></tr>
<tr><td><code id="DispFieldbb_+3A_rowmn">rowmn</code></td>
<td>
<p>an integer denoting the minimum row index of the sub-grid</p>
</td></tr>
<tr><td><code id="DispFieldbb_+3A_rowmx">rowmx</code></td>
<td>
<p>an integer denoting the maximum row index of the sub-grid</p>
</td></tr>
<tr><td><code id="DispFieldbb_+3A_colmn">colmn</code></td>
<td>
<p>an integer denoting the minimum column index of the sub-grid</p>
</td></tr>
<tr><td><code id="DispFieldbb_+3A_colmx">colmx</code></td>
<td>
<p>an integer denoting the maximum column index of the sub-grid</p>
</td></tr>
<tr><td><code id="DispFieldbb_+3A_restricted">restricted</code></td>
<td>
<p>logical (TRUE or FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input rasters are first converted to equivalent matrices. If restricted
is set to FALSE (the default), the function computes cross-covariance between
the sub-grid of the first input raster and the entirety of the second input
raster and then uses the location of maximum cross-covariance to estimate
displacement in the vertical and horizontal directions from the centre of the
sub-grid.
</p>
<p>If restricted is set to TRUE, the function uses cross-covariance between the
sub-grid of the first input raster and the equivalent sub-grid of the second
input raster to estimate vertical and horizontal displacement.
</p>
<p>Reference coordinates and cell size are extracted from the first input raster
such that the locations from whence displacement is estimated as well as
displacement estimates can be expressed in the units of the projected
coordinates.
</p>
<p>The coordinates are assumed to increase vertically and horizontally from the
lower left corner of the two-dimensional domain.
</p>
<p>Caution is warranted when defining the bounding box because the function can
produce erroneous results when the bounding box is too small.
</p>


<h3>Value</h3>

<p>A data frame is returned with the following column names: rowcent,
colcent, frowmin, frowmax, fcolmin, fcolmax, centx, centy, dispx, and
dispy. The rowcent and colcent column names are the row and column indices
for the center of the sub-grid; frowmin and frowmax are the sub-grid
minimum and maximum row indices; fcolmin and fcolmax are the sub-grid
minimum and maximum column indices; centx and centy are the projected
coordinates of the centre of the subgrid derived from the raster input
files; dispx and dispy are the displacement in the horizontal and vertical
directions in the same units as the projected coordinates of the raster
input files.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DispField">DispField</a></code> for a similar function with a grid of focal
regions, <code><a href="#topic+DispFieldSTbb">DispFieldSTbb</a></code> for a version designed to quantify
persistent directional movement when the time series features more than two
time instances, <code><a href="#topic+DispFieldSTbball">DispFieldSTbball</a></code> for a version designed to
quantify persistent directional movement when velocity is variable in
space, and <code><a href="#topic+Xcov2D">Xcov2D</a></code> for demonstration of how two-dimensional
cross-covariance is used to determine displacement (see examples of Xcov2D
function documentation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rseq &lt;- stats::runif(72)
Mat1 &lt;- matrix(rep(0, 81), nrow = 9)
Mat2 &lt;- Mat1
Mat1[1:9, 1:8] &lt;- rseq
Mat1
Mat2[1:9, 2:9] &lt;- rseq
Mat2

# rasterizing
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)

(VFdf1 &lt;- DispFieldbb(rast1, rast2, 2, 8, 2, 8))
# The second raster is shifted right by 1 unit relative to the first raster
# dispx = 1
</code></pre>

<hr>
<h2 id='DispFieldST'>Displacement fields for spatiotemporal data when velocity is spatially constant</h2><span id='topic+DispFieldST'></span>

<h3>Description</h3>

<p>This is an implementation of a novel algorithm that differs from more
traditional digital image correlation implementations that are applied in the
<code><a href="#topic+DispField">DispField</a></code> and <code><a href="#topic+DispFieldbb">DispFieldbb</a></code> functions. The function
calculates a displacement field representing persistent movement based on the
cross-covariance in a raster stack (in this case a sequential series of
rasters) presumably representing spatial population abundance or density at
more than two different instances of time. If analysis is restricted to only
two time instances, <code><a href="#topic+DispField">DispField</a></code> is more appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DispFieldST(inputstack1, lag1, factv1, facth1, restricted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DispFieldST_+3A_inputstack1">inputstack1</code></td>
<td>
<p>a raster stack with each raster layer representing an
instance of time. The raster stack should be organized such that the first
raster in the stack is the first observed spatial dataset and time
progresses forward with the third dimension index of the raster stack. The
raster stack should contain only numeric values. Any NA value will be
converted to a zero</p>
</td></tr>
<tr><td><code id="DispFieldST_+3A_lag1">lag1</code></td>
<td>
<p>an integer time lag</p>
</td></tr>
<tr><td><code id="DispFieldST_+3A_factv1">factv1</code></td>
<td>
<p>an odd integer for the vertical dimension of subgrids</p>
</td></tr>
<tr><td><code id="DispFieldST_+3A_facth1">facth1</code></td>
<td>
<p>an odd integer for the horizontal dimension of subgrids</p>
</td></tr>
<tr><td><code id="DispFieldST_+3A_restricted">restricted</code></td>
<td>
<p>logical (TRUE or FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input rasters in the raster stack are first converted to equivalent
matrices, which together represent a three-dimensional array with two spatial
dimensions and one time dimension. The prescribed lag is applied to the three
dimensional array derived from the raster stack by first producing two
equivalent arrays and then removing appropriate numbers of layers from the
top of one and the bottom of the other. These are referred to as unlagged and
lagged spatiotemporal arrays in the description that follows.
</p>
<p>Prior to computing displacement based on direction of maximum
cross-covariance, the function divides the spatial domain up into sub-grids
of size factv1 X facth1, which are vertical and horizontal sub-grid spatial
dimensions.
</p>
<p>The function converts three dimensional lagged and unlagged spatiotemporal
arrays to two-dimensional lagged and unlagged spatiotemporal matrices by
averaging along one of the spatial dimensions (either rows or columns) to
obtain two pairs of two-dimensional matrices in which one dimension is
spatial (either rows or columns) and one dimension is temporal. One of each
pair corresponds to the  unlagged spatiotemporal array and the other
corresponds to the lagged spatiotemporal array. Displacement in the vertical
direction is computed using unlagged and lagged matrices that have been
averaged along rows and displacement in the horizontal direction is computed
using unlagged and lagged matrices that have been averaged along columns.
</p>
<p>If restricted is set to FALSE (the default), the function computes
cross-covariance between each sub-grid of the unlagged row-averaged
spatiotemporal matrix and the whole row-averaged lagged spatiotemporal matrix
and between each sub-grid of the unlagged column-averaged spatiotemporal
matrix and the entirety corresponding lagged matrix.
</p>
<p>If restricted is set to TRUE, the function uses cross-covariance between
lagged and unlagged version of row-averaged and column averaged
spatiotemporal matrices that have all been either row or column-averaged
within sub-grids to estimate vertical and horizontal displacement.
</p>
<p>Regardless of whether restricted is set to TRUE or FALSE, for each sub-grid,
displacement in the x and y direction is divided by the shift in the time
dimension to produce orthogonal velocity vetors. Note that for this reason,
the lag1 argument of the function does not necessarily determine the time lag
that is used to produce each orthoganal velocity vector.
</p>
<p>Reference coordinates and cell size are extracted from the first raster stack
such that the locations from whence displacement is estimated as well as
displacement (or velocity) estimates can be expressed in the units of the
projected coordinates.
</p>
<p>The coordinates are assumed to increase vertically and horizontally from the
lower left corner of the two-dimensional domain.
</p>
<p>Caution is warranted when defining the sub-grid dimensions because the
function can produce erroneous results when sub-grids are too small.
</p>
<p>In addition, results can be quite sensitive to specification of the time lag.
If velocities are highly variable in space or over time, avoid specifying a
single time lag by calling the related <code><a href="#topic+DispFieldSTall">DispFieldSTall</a></code> function.
</p>


<h3>Value</h3>

<p>A data frame is returned with the following column names: rowcent,
colcent, frowmin, frowmax, fcolmin, fcolmax, centx, centy, dispx, and
dispy. The rowcent and colcent column names are the row and column indices
for the center of each sub-grid; frowmin and frowmax are the sub-grid
minimum and maximum row indices; fcolmin and fcolmax are the sub-grid
minimum and maximum column indices; centx and centy are the projected
coordinates of the centre of the subgrid derived from the raster input
files; dispx and dispy are the orthoganal velocity vectors in units of
space per timestep in the horizontal and vertical directions in the same
spatial units as the projected coordinates of the raster input files.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DispField">DispField</a></code> for a similar function with a grid of focal
regions for only two time instances, <code><a href="#topic+DispFieldSTbb">DispFieldSTbb</a></code> for a
version designed to quantify persistent directional movement when the time
series features more than two time instances but using a bounding pox to
define a focal region, see <code><a href="#topic+DispFieldSTall">DispFieldSTall</a></code> for a version
designed to quantify persistent directional movement when velocity is
variable in space, and <code><a href="#topic+Xcov2D">Xcov2D</a></code> for demonstration of how
two-dimensional cross-covariance is used to determine displacement (see
examples of Xcov2D function documentation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(Mat1 &lt;- matrix(rep(c(1:5, 0, 0, 0, 0), 9), nrow = 9, byrow = TRUE))
(Mat2 &lt;- matrix(rep(c(0, 1:5, 0, 0, 0), 9), nrow = 9, byrow = TRUE))
(Mat3 &lt;- matrix(rep(c(0, 0, 1:5, 0, 0), 9), nrow = 9, byrow = TRUE))
(Mat4 &lt;- matrix(rep(c(0, 0, 0, 1:5, 0), 9), nrow = 9, byrow = TRUE))

# rasterizing
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)
rast3 &lt;- terra::rast(Mat3)
terra::plot(rast3)
rast4 &lt;- terra::rast(Mat4)
terra::plot(rast4)

teststack1 &lt;- c(rast1, rast2, rast3, rast4)
(VFdf2 &lt;- DispFieldST(teststack1, lag1 = 1, factv1 = 9, facth1 = 9))
# block is moving rightward at a speed of 1 unit of space per unit of time
# dispx = 1
</code></pre>

<hr>
<h2 id='DispFieldSTall'>Diplacement fields for spatiotemporal data when velocity varies spatially</h2><span id='topic+DispFieldSTall'></span>

<h3>Description</h3>

<p>This is an implementation of a novel algorithm that differs from more
traditional digital image correlation implementations that are applied in the
<code><a href="#topic+DispField">DispField</a></code> and <code><a href="#topic+DispFieldbb">DispFieldbb</a></code> functions. This version
is similar to the <code><a href="#topic+DispFieldST">DispFieldST</a></code> function except that it does not
require a specific time lag. Instead the user specifies a maximum time lag
and the function computes displacement vectors using the time lag that
produces the maximum speed (magnitude of displacement divided by time lag).
The function calculates a displacement field representing persistent movement
based on the cross-covariance in a raster stack (in this case a sequential
series of rasters) presumably representing spatial population abundance or
density at more than two different instances of time. If analysis is
restricted to only two time instances, <code><a href="#topic+DispField">DispField</a></code> is more
appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DispFieldSTall(inputstack1, lagmax, factv1, facth1, restricted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DispFieldSTall_+3A_inputstack1">inputstack1</code></td>
<td>
<p>a raster stack with each raster layer representing an
instance of time. The raster stack should be organized such that the first
raster in the stack is the first observed spatial dataset and time
progresses forward with the third dimension index of the raster stack. The
raster stack should contain only numeric values. Any NA value will be
converted to a zero</p>
</td></tr>
<tr><td><code id="DispFieldSTall_+3A_lagmax">lagmax</code></td>
<td>
<p>an integer representing the maximum time lag</p>
</td></tr>
<tr><td><code id="DispFieldSTall_+3A_factv1">factv1</code></td>
<td>
<p>an odd integer for the vertical dimension of subgrids</p>
</td></tr>
<tr><td><code id="DispFieldSTall_+3A_facth1">facth1</code></td>
<td>
<p>an odd integer for the horizontal dimension of subgrids</p>
</td></tr>
<tr><td><code id="DispFieldSTall_+3A_restricted">restricted</code></td>
<td>
<p>logical (TRUE or FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DispFieldSTall function has the same inner workings as the
<code><a href="#topic+DispFieldST">DispFieldST</a></code> function except that instead of specifying a
specific time lag, the user specifies a maximum time lag. The function then
cycles through all lags up to the maximum time lag and chooses the for each
location the maximum speed. The DispFieldSTall function is more appropriate
than <code><a href="#topic+DispFieldST">DispFieldST</a></code> when velocity is variable in space.
</p>
<p>Caution is warranted when defining the sub-grid dimensions because the
function can produce erroneous results when sub-grids are too small.
</p>


<h3>Value</h3>

<p>A data frame is returned with the following column names: rowcent,
colcent, frowmin, frowmax, fcolmin, fcolmax, centx, centy, dispx, and
dispy. The rowcent and colcent column names are the row and column indices
for the center of each sub-grid; frowmin and frowmax are the sub-grid
minimum and maximum row indices; fcolmin and fcolmax are the sub-grid
minimum and maximum column indices; centx and centy are the projected
coordinates of the centre of the subgrid derived from the raster input
files; dispx and dispy are the orthoganal velocity vectors in units of
space per timestep in the horizontal and vertical directions in the same
spatial units as the projected coordinates of the raster input files.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DispField">DispField</a></code> for a similar function with a grid of focal
regions for only two time instances, <code><a href="#topic+DispFieldST">DispFieldST</a></code> for a
version designed to quantify persistent directional movement when the time
series features more than two time instances and the velocity is constant
in space, <code><a href="#topic+DispFieldSTbball">DispFieldSTbball</a></code> for a version designed to quantify
persistent directional movement when velocity is variable in space and the
focal region is defined using a bounding box, and <code><a href="#topic+Xcov2D">Xcov2D</a></code> for
demonstration of how two-dimensional cross-covariance is used to determine
displacement (see examples of Xcov2D function documentation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(Mat1 &lt;- matrix(rep(c(1:5, 0, 0, 0, 0), 9), nrow = 9, byrow = TRUE))
(Mat2 &lt;- matrix(rep(c(0, 1:5, 0, 0, 0), 9), nrow = 9, byrow = TRUE))
(Mat3 &lt;- matrix(rep(c(0, 0, 1:5, 0, 0), 9), nrow = 9, byrow = TRUE))
(Mat4 &lt;- matrix(rep(c(0, 0, 0, 1:5, 0), 9), nrow = 9, byrow = TRUE))

# rasterizing
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)
rast3 &lt;- terra::rast(Mat3)
terra::plot(rast3)
rast4 &lt;- terra::rast(Mat4)
terra::plot(rast4)

teststack1 &lt;- c(rast1, rast2, rast3, rast4)
(VFdf4 &lt;- DispFieldSTall(teststack1, lagmax = 2, factv1 = 9, facth1 = 9))
# block is moving rightward at a speed of 1 unit of space per unit of time
# dispx = 1
</code></pre>

<hr>
<h2 id='DispFieldSTbb'>Displacement fields for spatiotemporal data using a bounding box</h2><span id='topic+DispFieldSTbb'></span>

<h3>Description</h3>

<p>This is an implementation of a novel algorithm that differs from more
traditional digital image correlation implementations that are applied in the
<code><a href="#topic+DispField">DispField</a></code> and <code><a href="#topic+DispFieldbb">DispFieldbb</a></code> functions. The function
calculates a displacement field representing persistent movement based on the
cross-covariance in a raster stack (in this case a sequential series of
rasters) presumably representing spatial population abundance or density at
more than two different instances of time. If analysis is restricted to only
two time instances, <code><a href="#topic+DispFieldbb">DispFieldbb</a></code> is more appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DispFieldSTbb(
  inputstack1,
  lag1,
  rowmn,
  rowmx,
  colmn,
  colmx,
  restricted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DispFieldSTbb_+3A_inputstack1">inputstack1</code></td>
<td>
<p>a raster stack with each raster layer representing an
instance of time. The raster stack should be organized such that the first
raster in the stack is the first observed spatial dataset and time
progresses forward with the third dimension index of the raster stack. The
raster stack should contain only numeric values. Any NA value will be
converted to a zero</p>
</td></tr>
<tr><td><code id="DispFieldSTbb_+3A_lag1">lag1</code></td>
<td>
<p>an integer time lag</p>
</td></tr>
<tr><td><code id="DispFieldSTbb_+3A_rowmn">rowmn</code></td>
<td>
<p>an integer for the minimum row index of the bounding box</p>
</td></tr>
<tr><td><code id="DispFieldSTbb_+3A_rowmx">rowmx</code></td>
<td>
<p>an integer for the maximum row index of the bounding box</p>
</td></tr>
<tr><td><code id="DispFieldSTbb_+3A_colmn">colmn</code></td>
<td>
<p>an integer for the minimum column index of the bounding box</p>
</td></tr>
<tr><td><code id="DispFieldSTbb_+3A_colmx">colmx</code></td>
<td>
<p>an integer for the maximum column index of the bounding box</p>
</td></tr>
<tr><td><code id="DispFieldSTbb_+3A_restricted">restricted</code></td>
<td>
<p>logical (TRUE or FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input rasters in the raster stack are first converted to equivalent
matrices, which together represent a three-dimensional array with two spatial
dimensions and one time dimension. The prescribed lag is applied to the three
dimensional array derived from the raster stack by first producing two
equivalent arrays and then removing appropriate numbers of layers from the
top of one and the bottom of the other. These are referred to as unlagged and
lagged spatiotemporal arrays in the description that follows.
</p>
<p>The function converts three dimensional lagged and unlagged spatiotemporal
arrays to two-dimensional lagged and unlagged spatiotemporal matrices by
averaging along one of the spatial dimensions (either rows or columns) to
obtain two pairs of two-dimensional matrices in which one dimension is
spatial (either rows or columns) and one dimension is temporal. One of each
pair corresponds to the  unlagged spatiotemporal array and the other
corresponds to the lagged spatiotemporal array. Displacement in the vertical
direction is computed using unlagged and lagged matrices that have been
averaged along rows and displacement in the horizontal direction is computed
using unlagged and lagged matrices that have been averaged along columns.
</p>
<p>If restricted is set to FALSE (the default), the function computes
cross-covariance between the values within the bounding box of the unlagged
row-averaged spatiotemporal matrix and the whole row-averaged lagged
spatiotemporal matrix and between the values within the bounding box of the
unlagged column-averaged spatiotemporal matrix and the entirety corresponding
lagged matrix.
</p>
<p>If restricted is set to TRUE, the function uses cross-covariance between
lagged and unlagged version of row-averaged and column averaged
spatiotemporal matrices that have all been either row or column-averaged
within the bounding box to estimate vertical and horizontal displacement.
</p>
<p>Regardless of whether restricted is set to TRUE or FALSE, for each sub-grid,
displacement in the x and y direction is divided by the shift in the time
dimension to produce orthogonal velocity vetors. Note that for this reason,
the lag1 argument of the function does not necessarily determine the time lag
that is used to produce each orthoganal velocity vector.
</p>
<p>Reference coordinates and cell size are extracted from the first raster stack
such that the locations from whence displacement is estimated as well as
displacement (or velocity) estimates can be expressed in the units of the
projected coordinates.
</p>
<p>The coordinates are assumed to increase vertically and horizontally from the
lower left corner of the two-dimensional domain.
</p>
<p>Caution is warranted when defining the sub-grid dimensions because the
function can produce erroneous results when sub-grids are too small.
</p>
<p>#' In addition, results can be quite sensitive to specification of the time
lag. If velocities are highly variable in space or over time, avoid
specifying a single time lag by calling the related
<code><a href="#topic+DispFieldSTbball">DispFieldSTbball</a></code> function.
</p>


<h3>Value</h3>

<p>A data frame is returned with the following column names: rowcent,
colcent, frowmin, frowmax, fcolmin, fcolmax, centx, centy, dispx, and
dispy. The rowcent and colcent column names are the row and column indices
for the center of each sub-grid; frowmin and frowmax are the sub-grid
minimum and maximum row indices; fcolmin and fcolmax are the sub-grid
minimum and maximum column indices; centx and centy are the projected
coordinates of the centre of the subgrid derived from the raster input
files; dispx and dispy are the orthoganal velocity vectors in units of
space per timestep in the horizontal and vertical directions in the same
spatial units as the projected coordinates of the raster input files.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DispField">DispField</a></code> for a similar function with a grid of focal
regions for only two time instances, <code><a href="#topic+DispFieldST">DispFieldST</a></code> for a
version designed to quantify persistent directional movement when the time
series features more than two time instances but using a grid to define
focal regions, see <code><a href="#topic+DispFieldSTbball">DispFieldSTbball</a></code> for a version designed to
quantify persistent directional movement when velocity is variable in
space, and <code><a href="#topic+Xcov2D">Xcov2D</a></code> for demonstration of how two-dimensional
cross-covariance is used to determine displacement (see examples of Xcov2D
function documentation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rseq &lt;- stats::runif(54)
Mat1 &lt;- matrix(rep(0, 9*9), nrow = 9)
Mat2 &lt;- Mat1; Mat3 &lt;- Mat1; Mat4 &lt;- Mat1
Mat1[1:9, 1:6] &lt;- rseq
Mat1
Mat2[1:9, 2:7] &lt;- rseq
Mat2
Mat3[1:9, 3:8] &lt;- rseq
Mat3
Mat4[1:9, 4:9] &lt;- rseq
Mat4

# rasterizing
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)
rast3 &lt;- terra::rast(Mat3)
terra::plot(rast3)
rast4 &lt;- terra::rast(Mat4)
terra::plot(rast4)

teststack1 &lt;- c(rast1, rast2, rast3, rast4)
(VFdf3 &lt;- DispFieldSTbb(teststack1, lag1 = 1, 2, 8, 2, 8))
# block is moving rightward at a speed of 1 unit of space per unit of time
# dispx = 1
</code></pre>

<hr>
<h2 id='DispFieldSTbball'>Diplacement fields using bounding box when velocity varies spatially</h2><span id='topic+DispFieldSTbball'></span>

<h3>Description</h3>

<p>This is an implementation of a novel algorithm that differs from more
traditional digital image correlation implementations that are applied in the
<code><a href="#topic+DispField">DispField</a></code> and <code><a href="#topic+DispFieldbb">DispFieldbb</a></code> functions. This version
is similar to the <code><a href="#topic+DispFieldSTbb">DispFieldSTbb</a></code> function except that it does
not require a specific time lag. Instead the user specifies a maximum time
lag and the function computes displacement vectors using the time lag that
produces the maximum speed (magnitude of displacement divided by time lag).
The function calculates a displacement field representing persistent movement
based on the cross-covariance in a raster stack (in this case a sequential
series of rasters) presumably representing spatial population abundance or
density at more than two different instances of time. If analysis is
restricted to only two time instances, <code><a href="#topic+DispFieldbb">DispFieldbb</a></code> is more
appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DispFieldSTbball(
  inputstack1,
  lagmax,
  rowmn,
  rowmx,
  colmn,
  colmx,
  restricted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DispFieldSTbball_+3A_inputstack1">inputstack1</code></td>
<td>
<p>a raster stack with each raster layer representing an
instance of time. The raster stack should be organized such that the first
raster in the stack is the first observed spatial dataset and time
progresses forward with the third dimension index of the raster stack. The
raster stack should contain only numeric values. Any NA value will be
converted to a zero</p>
</td></tr>
<tr><td><code id="DispFieldSTbball_+3A_lagmax">lagmax</code></td>
<td>
<p>an integer representing the maximum time lag</p>
</td></tr>
<tr><td><code id="DispFieldSTbball_+3A_rowmn">rowmn</code></td>
<td>
<p>an integer denoting the minimum row index of the sub-grid</p>
</td></tr>
<tr><td><code id="DispFieldSTbball_+3A_rowmx">rowmx</code></td>
<td>
<p>an integer denoting the maximum row index of the sub-grid</p>
</td></tr>
<tr><td><code id="DispFieldSTbball_+3A_colmn">colmn</code></td>
<td>
<p>an integer denoting the minimum column index of the sub-grid</p>
</td></tr>
<tr><td><code id="DispFieldSTbball_+3A_colmx">colmx</code></td>
<td>
<p>an integer denoting the maximum column index of the sub-grid</p>
</td></tr>
<tr><td><code id="DispFieldSTbball_+3A_restricted">restricted</code></td>
<td>
<p>logical (TRUE or FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DispFieldSTbball function has the same inner workings as the
<code><a href="#topic+DispFieldSTbb">DispFieldSTbb</a></code> function except that instead of specifying a
specific time lag, the user specifies a maximum time lag. The function then
cycles through all lags up to the maximum time lag and chooses the for each
location the maximum speed. The DispFieldSTbball function is more appropriate
than <code><a href="#topic+DispFieldSTbb">DispFieldSTbb</a></code> when velocity is variable in space.
</p>
<p>Caution is warranted when defining the bounding box dimensions because the
function can produce erroneous results when the bounding box is too small.
</p>


<h3>Value</h3>

<p>A data frame is returned with the following column names: rowcent,
colcent, frowmin, frowmax, fcolmin, fcolmax, centx, centy, dispx, and
dispy. The rowcent and colcent column names are the row and column indices
for the center of each sub-grid; frowmin and frowmax are the sub-grid
minimum and maximum row indices; fcolmin and fcolmax are the sub-grid
minimum and maximum column indices; centx and centy are the projected
coordinates of the centre of the subgrid derived from the raster input
files; dispx and dispy are the orthoganal velocity vectors in units of
space per timestep in the horizontal and vertical directions in the same
spatial units as the projected coordinates of the raster input files.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DispFieldbb">DispFieldbb</a></code> for a similar function with focal region
defined using a bounding box for only two time instances,
<code><a href="#topic+DispFieldSTbb">DispFieldSTbb</a></code> for a version designed to quantify persistent
directional movement when velocity is constant in space and the focal
region is defined using a bounding box, see <code><a href="#topic+DispFieldSTall">DispFieldSTall</a></code>
for a version designed to quantify persistent directional movement when
velocity is variable in space and focal regions are defined based on a
grid, and <code><a href="#topic+Xcov2D">Xcov2D</a></code> for demonstration of how two-dimensional
cross-covariance is used to determine displacement (see examples of Xcov2D
function documentation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(Mat1 &lt;- matrix(rep(c(1:5, 0, 0, 0, 0), 9), nrow = 9, byrow = TRUE))
(Mat2 &lt;- matrix(rep(c(0, 1:5, 0, 0, 0), 9), nrow = 9, byrow = TRUE))
(Mat3 &lt;- matrix(rep(c(0, 0, 1:5, 0, 0), 9), nrow = 9, byrow = TRUE))
(Mat4 &lt;- matrix(rep(c(0, 0, 0, 1:5, 0), 9), nrow = 9, byrow = TRUE))

# Rasterizing
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)
rast3 &lt;- terra::rast(Mat3)
terra::plot(rast3)
rast4 &lt;- terra::rast(Mat4)
terra::plot(rast4)

teststack1 &lt;- c(rast1, rast2, rast3, rast4)
(VFdf5 &lt;- DispFieldSTbball(teststack1, lagmax = 2, 1, 9, 1, 9))
# block is moving rightward at a speed of 1 unit of space per unit of time
# dispx = 1

</code></pre>

<hr>
<h2 id='DispMoransI'>Calculate statistics in source or sink regions</h2><span id='topic+DispMoransI'></span><span id='topic+DispStats'></span>

<h3>Description</h3>

<p>Functions for computing the statistics which may be driving variables of
movement that has been quantified using the <code><a href="#topic+DispField">DispField</a></code> or
<code><a href="#topic+DispFieldbb">DispFieldbb</a></code> functions. The same raster data as were supplied to
the aforementioned functions must be supplied to these in addition to a
raster layer for which statistics are sought. Then for each region of
interest defined when <code><a href="#topic+DispField">DispField</a></code> or <code><a href="#topic+DispFieldbb">DispFieldbb</a></code>
were called, these functions compute statistics for presumed source (sourceloc =
TRUE) locations or presumed sink locations (sourceloc = FALSE). Note that in the
DispMornasI function, defining radius using distance means that a radius of
one corresponds to the rook's neighbourhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DispMoransI(inputrast1, inputrast2, statrast, vfdf, sourceloc = TRUE, rad1)

DispStats(
  inputrast1,
  inputrast2,
  statrast,
  vfdf,
  sourceloc = TRUE,
  statistic = "var"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DispMoransI_+3A_inputrast1">inputrast1</code></td>
<td>
<p>a raster as produced by terra::rast</p>
</td></tr>
<tr><td><code id="DispMoransI_+3A_inputrast2">inputrast2</code></td>
<td>
<p>a raster of equivalent dimension to inputrast1 as produced
by terra::rast</p>
</td></tr>
<tr><td><code id="DispMoransI_+3A_statrast">statrast</code></td>
<td>
<p>a raster of equivalent dimension to inputrast1 as produced by
terra::rast which contains the variable that will be used to compute
statistics</p>
</td></tr>
<tr><td><code id="DispMoransI_+3A_vfdf">vfdf</code></td>
<td>
<p>a data frame returned by the <code><a href="#topic+DispField">DispField</a></code> or
<code><a href="#topic+DispFieldbb">DispFieldbb</a></code> functions, which contains all of the information
necessary for defining regions of interest as well as the displacement
estimates</p>
</td></tr>
<tr><td><code id="DispMoransI_+3A_sourceloc">sourceloc</code></td>
<td>
<p>logical (TRUE or FALSE) indicating whether statistics are to be
returned at source or sink locations</p>
</td></tr>
<tr><td><code id="DispMoransI_+3A_rad1">rad1</code></td>
<td>
<p>an ingeger indicating the neighbourhood radius for Moran's I
statistic calculations in rows/columns. Any cell within a distance of rad1
cells of the focal cell is considered to be in its neighbourhood.</p>
</td></tr>
<tr><td><code id="DispMoransI_+3A_statistic">statistic</code></td>
<td>
<p>desired output statistic: It should be one of &quot;mean&quot;, &quot;var&quot;,
or &quot;sum&quot;. Default setting is var.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame is returned with all of the same columns as the vfdf
input data frame plus an additional column containing the computed
statistic in each region of interest defined in vfdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Illustrating use of DispMoransI:

(Mat1 &lt;- matrix(c(0.1,1,0.1,0,0,0,0,0,0,
                  1,0.1,1,0,0,0,0,0,0,
                  0.1,1,0.1,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0),
                 nrow = 9))
(Mat2 &lt;- matrix(c(0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0.1,1,0.1,0,0,0,0,0,0,
                  1,0.1,1,0,0,0,0,0,0,
                  0.1,1,0.1,0,0,0,0,0,0),
                 nrow = 9))

# Note that rasterizing a matrix causes it to be rotated 90 degrees.
# Therefore, any shift in the x direction is in fact now a shift in the y direction
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)

(VFdf1 &lt;- DispField(rast1, rast2, factv1 = 3, facth1 = 3))
# The second raster is shifted down by -0.6666667 units relative to the first raster
# dispy = -0.6666667 (the width of each box is 0.1111111).

# Now to compute the statistics at the source: the Moran's I of the original values
# in each region of interest (should be minus one in first row)
(VFdf2 &lt;- DispMoransI(rast1, rast2, rast1, VFdf1, sourceloc = TRUE, rad1 = 1))

# Illustrating use of DispStats:

(Mat1 &lt;- matrix(c(1,1,1,0,0,0,0,0,0,
                  1,1,1,0,0,0,0,0,0,
                  1,1,1,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0),
                 nrow = 9))
(Mat2 &lt;- matrix(c(0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,
                  1,1,1,0,0,0,0,0,0,
                  1,1,1,0,0,0,0,0,0,
                  1,1,1,0,0,0,0,0,0),
                 nrow = 9))

# Note that rasterizing a matrix causes it to be rotated 90 degrees.
# Therefore, any shift in the x direction is in fact now a shift in the y direction
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)

(VFdf1 &lt;- DispField(rast1, rast2, factv1 = 3, facth1 = 3))
# The second raster is shifted down by -0.6666667 units relative to the first raster
# dispy = -0.6666667 (the width of each box is 0.1111111).

# Now to compute the statistics at the source: the mean of the original values
# in each region of interest (should be one in first row)
(VFdf2 &lt;- DispStats(rast1, rast2, rast1, VFdf1, sourceloc = TRUE, statistic = "mean"))
# sum in each region of interest (should be nine in first row)
(VFdf3 &lt;- DispStats(rast1, rast2, rast1, VFdf1, sourceloc = TRUE, statistic = "sum"))
# variance in each region of interest (should be zero in all rows)
(VFdf4 &lt;- DispStats(rast1, rast2, rast1, VFdf1, sourceloc = TRUE, statistic = "var"))
</code></pre>

<hr>
<h2 id='GetRowCol'>Retrieve matrix row and column indices</h2><span id='topic+GetRowCol'></span>

<h3>Description</h3>

<p>Here is a function that will find the row and column indices of a matrix that
are associated with a vector index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetRowCol(Index, dim1, dim2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetRowCol_+3A_index">Index</code></td>
<td>
<p>an integer vector index</p>
</td></tr>
<tr><td><code id="GetRowCol_+3A_dim1">dim1</code></td>
<td>
<p>integer row dimension of the matrix from which the row and column
indices are to be extracted</p>
</td></tr>
<tr><td><code id="GetRowCol_+3A_dim2">dim2</code></td>
<td>
<p>integer column dimension of the matrix from which the row and
column indices are to be extracted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often when applying functions like the R function which.max(matrix) to a
matrix, a vector index is returned when the coder would prefer to have a row
and column indices. This function converts the vector index to row and column
indices.
</p>
<p>The function assumes that the elements of the matrix are filled by column
(byrow = FALSE), which is the default R matrix behaviour.
</p>


<h3>Value</h3>

<p>a numeric vector of length two with two integers indicating row and
column respectively
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetRowCol(6, dim1 = 3, dim2 = 3) # should return c(3, 2)
</code></pre>

<hr>
<h2 id='MoransI'>Efficiently compute Moran's I statistic</h2><span id='topic+MoransI'></span>

<h3>Description</h3>

<p>Compute Moran's I for a matrix. A fast implementation of Moran's I for
gridded data, with neighbours defined based on a radial distance. Note
that when using radius to define the neighbourhood, a radius of one
corresponds to the rook's neibhourhood. There is currently no
equivalent to queen's neighbourhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoransI(mat1, r1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MoransI_+3A_mat1">mat1</code></td>
<td>
<p>a matrix of values; NA/Inf values must be coded as NA and are ignored</p>
</td></tr>
<tr><td><code id="MoransI_+3A_r1">r1</code></td>
<td>
<p>an integer representing the distance (radius), within which nearby
cells are considered neighbours in units of rows/columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value for Moran's I
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(TestMat &lt;- matrix(c(1, 0, 1, 0, 1,
                     0, 1, 0, 1, 0,
                     1, 0, 1, 0, 1,
                     0, 1, 0, 1, 0,
                     1, 0, 1, 0, 1),
                   nrow =5))
# the code below should return -1
MoransI(TestMat, r1 = 1)
</code></pre>

<hr>
<h2 id='PatternDetect'>Detect Patterns in Vector Fields</h2><span id='topic+PatternDetect'></span>

<h3>Description</h3>

<p>Detect patterns in vector fields represented on a grid by looking in the
rook's neighbourhood of each grid cell. Four patterns are detected:
convergences occur when the vectors in the four adjacent cells in the rook's
neighbourhood point towards the focal cell; divergences occur when the
vectors in the four adjacent cells point away from the focal cell; Partial
convergences occur when three of the four vectors point towards the focal
cell and the final vector points neither towards nor away from the focal
cell; Partial divergences occur when three of the four vectors point away the
focal grid cell and the final vector points neither towards nor away from the
focal grid. For all of the patterns above a sub-pattern is specified if all
arrows point clockwise or counter-clockwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PatternDetect(vfdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PatternDetect_+3A_vfdf">vfdf</code></td>
<td>
<p>A data frame as returned by <code><a href="#topic+DispField">DispField</a></code>,
<code><a href="#topic+DispFieldST">DispFieldST</a></code>, or <code><a href="#topic+DispFieldSTall">DispFieldSTall</a></code> with at least
five rows (more is better)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame as returned by <code><a href="#topic+DispField">DispField</a></code>,
<code><a href="#topic+DispFieldST">DispFieldST</a></code>, or <code><a href="#topic+DispFieldSTall">DispFieldSTall</a></code>, with three
additional columns. The first additional column is called Pattern in which
the patterns around each focal cell are categorized as convergence,
divergence, partial convergence, partial divergence, or NA. The second
additional column, called SubPattern, indicates whether all arrows point
clockwise or counter-clockwise. The third additional column is called
PatternCt, which contains a one if all four neighbourhood grid cells
contain displacement estimates, and a NA otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating convergence/divergence patterns
Mat1 &lt;- matrix(rep(0,9*9), nrow = 9)
Mat1[3, c(4, 6)] &lt;- 1
Mat1[7, c(4, 6)] &lt;- 1
Mat1[c(4, 6), 3] &lt;- 1
Mat1[c(4, 6), 7] &lt;- 1
Mat1

Mat2 &lt;- matrix(rep(0,9*9), nrow = 9)
Mat2[2, c(4, 6)] &lt;- 1
Mat2[8, c(4, 6)] &lt;- 1
Mat2[c(4, 6), 2] &lt;- 1
Mat2[c(4, 6), 8] &lt;- 1
Mat2

# rasterizing
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)

# Detecting a divergence
(VFdf1 &lt;- DispField(rast1, rast2, factv1 = 3, facth1 = 3, restricted = TRUE))
(patdf1 &lt;- PatternDetect(VFdf1))

# Detecting a convergence
(VFdf2 &lt;- DispField(rast2, rast1, factv1 = 3, facth1 = 3, restricted = TRUE))
(patdf2 &lt;- PatternDetect(VFdf2))
</code></pre>

<hr>
<h2 id='PixelCt'>Count populated pixels in a raster stack</h2><span id='topic+PixelCt'></span>

<h3>Description</h3>

<p>In order to produce reliable results, the cross-covariance approach
implemented in <code><a href="#topic+DispField">DispField</a></code>. <code><a href="#topic+DispFieldST">DispFieldST</a></code>, and
<code><a href="#topic+DispFieldSTall">DispFieldSTall</a></code> needs a certain minimum number of non-zero or
non-NA valued pixels in pairs of images or pairs of arrays derived from a
raster stack that it uses to compute cross-covariance. The user may define a
threshold such as ten percent of the pixels within each sub-grid. This
function allows the user to assess whether the minimum threshold number of
non-zero pixels per sub-grid are surpassed by returning the number of
non-zero pixels within each sub-grid over all of the time instances in the
user-supplied raster stack. The user may choose to disregard or mistrust
displacement or velocity estimates derived from sub-grids with insufficient
numbers of non-zero pixels. This function is designed to be called before or
after one of the functions referenced above in order to enable the user to
quantify their confidence in displacement or velocity estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PixelCt(inputstack1, factv1, facth1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PixelCt_+3A_inputstack1">inputstack1</code></td>
<td>
<p>a raster stack with each raster layer representing an
instance of time. The raster stack should be organized such that the first
raster in the stack is the first observed spatial dataset and time
progresses forward with the third dimension index of the raster stack. The
raster stack should contain only numeric values. Any NA value will be
converted to a zero</p>
</td></tr>
<tr><td><code id="PixelCt_+3A_factv1">factv1</code></td>
<td>
<p>an odd integer for the vertical dimension of subgrids</p>
</td></tr>
<tr><td><code id="PixelCt_+3A_facth1">facth1</code></td>
<td>
<p>an odd integer for the horizontal dimension of subgrids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame is returned with the following column names: rowcent,
colcent, frowmin, frowmax, fcolmin, fcolmax, and PixelCt. The rowcent and
colcent column names are the row and column indices for the center of each
sub-grid; frowmin and frowmax are the sub-grid minimum and maximum row
indices; fcolmin and fcolmax are the sub-grid minimum and maximum column
indices; pixelct is the count of non-zero pixels in the sub-grid over the
entire time period covered by the input raster stack.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># below the example in the DispField function documentation is reproduced
(Mat1 &lt;- matrix(rep(c(1:5, 0, 0, 0, 0), 9), nrow = 9, byrow = TRUE))
(Mat2 &lt;- matrix(rep(c(0, 1:5, 0, 0, 0), 9), nrow = 9, byrow = TRUE))

# Note that rasterizing a matrix causes it to be rotated 90 degrees.
# Therefore, any shift in the x direction is in fact now a shift in the y direction
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)

(Confdf1 &lt;- PixelCt(c(rast1, rast2), factv1 = 9, facth1 = 9))
# This should return a pixel count of 54: This is the number
# of pixels that were occupied in either the first or second
# time instance.
</code></pre>

<hr>
<h2 id='RastStackData'>Creating a raster stack from formatted datasets</h2><span id='topic+RastStackData'></span>

<h3>Description</h3>

<p>This function converts the data that accompany the ICvectorfields R package
to a raster stack. The raster stack is the only accepted data input format
for the following ICvectorfields functions: <code><a href="#topic+DispFieldST">DispFieldST</a></code>,
<code><a href="#topic+DispFieldSTbb">DispFieldSTbb</a></code>, <code><a href="#topic+DispFieldSTall">DispFieldSTall</a></code>,
<code><a href="#topic+DispFieldSTbball">DispFieldSTbball</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RastStackData(inputdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RastStackData_+3A_inputdf">inputdf</code></td>
<td>
<p>a data frame object in which the first column is longitude (or
x coordinate), the second column is latitude (or y coordinate), and all of
the subsequent columns represent a measure of population abundance or
density at a unique instance of time. Each row of the input data frame,
therefore, represents a unique spatial location, which should be on an
evenly spaced grid. Note, however, that not all grid locations need to have
observations; some grid locations can have values of NA or can be missing
entirely.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once a raster stack has been created, individual layers can be subsetted
using rasterstack[[index]], where index is an integer index for the third
dimension of the raster stack.
</p>


<h3>Value</h3>

<p>The function returns a raster stack constructed using inputdf. Each
layer in the stack corresponds to a column of the input dataset (after the
first two columns, which are longitude and latitude). The extent of all of
the rasters in the stack is constructed using the minimum and maximum
longitudes and latitudes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# creating random data in the correct data format
xyzdf &lt;- expand.grid(x = c(1:3), y = c(1:3))
xyzdf$z1 &lt;- runif(9)
xyzdf$z2 &lt;- runif(9)
xyzdf$z3 &lt;- runif(9)

zstack &lt;- RastStackData(xyzdf)

dim(zstack)
terra::plot(zstack[[1]])
terra::plot(zstack[[2]])
terra::plot(zstack[[3]])
</code></pre>

<hr>
<h2 id='RooksGradient'>Calculate Gradient Statistics in the Rook's Neighbourhood</h2><span id='topic+RooksGradient'></span>

<h3>Description</h3>

<p>The movement of populations into adjacent cells may sometimes be influenced
by the gradient of some predictive variable. This function enables the
calculation of a simple gradient statistic in the rook's neighbourhood of
each cell in a dataset. The statistic must first be computed for each grid
cell using <code><a href="#topic+SubgridStats">SubgridStats</a></code>. Then for each grid, the RooksGradient
function computes the arithmetic average of the difference between the
statistic at the focal grid cell and the statistic in the four (or fewer)
adjacent neighbours in its Rook's neibourhood. This arithmetically averaged
difference is then returned under the column header of 'Gradient'. A negative
gradient estimate indicates that the statistic in the central cell is higher
than that in neighbouring cells whereas a positive gradient estimate
indicates the opposite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RooksGradient(vfdf, statistic = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RooksGradient_+3A_vfdf">vfdf</code></td>
<td>
<p>A data frame as returned by <code><a href="#topic+SubgridStats">SubgridStats</a></code></p>
</td></tr>
<tr><td><code id="RooksGradient_+3A_statistic">statistic</code></td>
<td>
<p>desired output statistic: It should be one of &quot;mean&quot;, &quot;var&quot;,
or &quot;sum&quot;. Default setting is mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame similar to vfdf except that it includes an additional
column called Gradient as described above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating pattern patterns
Mat1 &lt;- matrix(rep(0,9*9), nrow = 9)
Mat1[c(4:6), c(4:6)] &lt;- 2
Mat1[c(4:6), c(1:3)] &lt;- 1
Mat1[c(1:3), c(4:6)] &lt;- 1
Mat1[c(7:9), c(4:6)] &lt;- 1
Mat1[c(4:6), c(7:9)] &lt;- 1
Mat1

Rast1 &lt;- terra::rast(Mat1)
terra::plot(Rast1)

# calculating the mean in 9 subgrids
(statsdf1 &lt;- SubgridStats(Rast1, factv1 = 3, facth1 = 3, statistic = "mean"))

# computing the gradient statistic on the mean
(graddf1 &lt;- RooksGradient(statsdf1, statistic = "mean"))
# the Gradient statistic in the central grid in row 5 should
# be equal to negative one

</code></pre>

<hr>
<h2 id='RooksNeighCt'>Define a subset of grid locations with non-overlapping rook neighborhoods</h2><span id='topic+RooksNeighCt'></span>

<h3>Description</h3>

<p>This function prunes the data frame returned by the
<code><a href="#topic+PatternDetect">PatternDetect</a></code> function such that it includes only rook's
neighborhoods that do not overlap. Pruning is done by sequential removal of
observations that are too near one another and as a result are overlapping.
Locations that are the most highly connected are removed first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RooksNeighCt(vfdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RooksNeighCt_+3A_vfdf">vfdf</code></td>
<td>
<p>A data frame as returned by <code><a href="#topic+PatternDetect">PatternDetect</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reason for this function's existence is to facilitate probabilistic
calculations regarding whether certain patterns are occurring more or less
often that would be expected by chance. If rook's neighborhoods in which
patterns are observed overlap, then the assumption of probabilistic
independence is necessarily incorrect. Thus, overlap invalidates any
calculation of the probability of occurrence of a particular pattern if that
calculation assumes independence. The pruning actions of this function enable
the user to more safely assume probabilistic independence.
</p>


<h3>Value</h3>

<p>A data frame similar to vfdf except that it includes only grid
locations with speed estimates in all four adjacent grid locations in their
rook's neighborhood. An additional column called IndPatternCt is appended
which contains NA values for locations that are overlapping other locations
and ones for all non-overlapping locations that have speed estimates in all
four adjacent cells.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# creating convergence/divergence patterns
Mat1 &lt;- matrix(rep(0,9*9), nrow = 9)
Mat1[3, c(4, 6)] &lt;- 1
Mat1[7, c(4, 6)] &lt;- 1
Mat1[c(4, 6), 3] &lt;- 1
Mat1[c(4, 6), 7] &lt;- 1
Mat1

Mat2 &lt;- matrix(rep(0,9*9), nrow = 9)
Mat2[2, c(4, 6)] &lt;- 1
Mat2[8, c(4, 6)] &lt;- 1
Mat2[c(4, 6), 2] &lt;- 1
Mat2[c(4, 6), 8] &lt;- 1
Mat2

Mat1 &lt;- cbind(Mat1, Mat1)
Mat1 &lt;- rbind(Mat1, Mat1)

Mat2 &lt;- cbind(Mat2, Mat2)
Mat2 &lt;- rbind(Mat2, Mat2)

# rasterizing
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)

# Detecting a divergence
(VFdf1 &lt;- DispField(rast1, rast2, factv1 = 3, facth1 = 3, restricted = TRUE))
(patdf1 &lt;- PatternDetect(VFdf1))
(subdf1 &lt;- RooksNeighCt(patdf1))
# The last call should print a data table with four rows, each with a one under
# the column header of IndPatternCt
</code></pre>

<hr>
<h2 id='RooksNeighFind'>Classify Rook's Neighbours Comprising Spread Patterns in Vector Fields</h2><span id='topic+RooksNeighFind'></span>

<h3>Description</h3>

<p>After running the <code><a href="#topic+PatternDetect">PatternDetect</a></code> function, this function enables
classification of neighbour cells. Because the pattern detect function
classifies central cells according to the patterns of vector direction in
their Rook's neighbourhood, the neighbouring grid locations that comprise the
pattern are not labeled. This is remedied by the RooksNeighFind function
which classifies neighbour cells around focal grids classified with one of
the four patterns that the <code><a href="#topic+PatternDetect">PatternDetect</a></code> function is able to
recognize. The function returns a data frame similar to the input data frame
with a column appended. In the appended column, neighbours surrounding focal
cells labeled with a particular pattern will be labeled as follows:
neighbours of the divergence pattern are labeled with a one, neighbours of
the convergence pattern are labeled with a two, neighbours of the partial
divergence pattern are labeled with a three, and neighbours of the partial
convergence pattern are labeled with a four. In cases where neighbours are
shared, the priority order from lowest to highest is four for partial
convergence to one for divergence. Thus, a neighbour that is shared between a
focal grid classified as a convergence and a nearby focal grid classified as
a divergence will be labeled with a one instead of a two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RooksNeighFind(vfdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RooksNeighFind_+3A_vfdf">vfdf</code></td>
<td>
<p>A data frame as returned by <code><a href="#topic+PatternDetect">PatternDetect</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame similar to vfdf except that it includes an additional
column called NeighType as described above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating convergence/divergence patterns
Mat1 &lt;- matrix(rep(0,9*9), nrow = 9)
Mat1[3, c(4, 6)] &lt;- 1
Mat1[7, c(4, 6)] &lt;- 1
Mat1[c(4, 6), 3] &lt;- 1
Mat1[c(4, 6), 7] &lt;- 1
Mat1

Mat2 &lt;- matrix(rep(0,9*9), nrow = 9)
Mat2[2, c(4, 6)] &lt;- 1
Mat2[8, c(4, 6)] &lt;- 1
Mat2[c(4, 6), 2] &lt;- 1
Mat2[c(4, 6), 8] &lt;- 1
Mat2

# rasterizing
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)

# Detecting a divergence
(VFdf1 &lt;- DispField(rast1, rast2, factv1 = 3, facth1 = 3, restricted = TRUE))
(patdf1 &lt;- PatternDetect(VFdf1))
(neighdf1 &lt;- RooksNeighFind(patdf1))
# Rook's neighbour grids are labeled with a one.

# Detecting a convergence
(VFdf2 &lt;- DispField(rast2, rast1, factv1 = 3, facth1 = 3, restricted = TRUE))
(patdf2 &lt;- PatternDetect(VFdf2))
(neighdf2 &lt;- RooksNeighFind(patdf2))
# Rook's neighbour grids are labeled with a two.

</code></pre>

<hr>
<h2 id='RotationDetect'>Detect Rotating Patterns in Vector Fields</h2><span id='topic+RotationDetect'></span>

<h3>Description</h3>

<p>Detect patterns in vector fields represented on a grid by looking in the
rook's neighbourhood of each grid cell. This function is analogous to
<code><a href="#topic+PatternDetect">PatternDetect</a></code>, except that it detects rotational patterns. Four
patterns are detected: clockwise rotation when rotation in all four
neighbbour grids appears clockwise, counter clockwise rotation when rotation
in all four neighbour grids appears counter-clockwise, and partial clockwise
and counter-clockwise rotation, when all but one of the four adjacent
neighbour cells has vectors that indicate rotation. For all of the patterns
above a sub-pattern is specified as convergence when all of the vectors in
the four adjacent grids point towards the focal cell or a divergence when all
of the vectors in the four adjacent grids point away from the focal cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RotationDetect(vfdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RotationDetect_+3A_vfdf">vfdf</code></td>
<td>
<p>A data frame as returned by <code><a href="#topic+DispField">DispField</a></code>,
<code><a href="#topic+DispFieldST">DispFieldST</a></code>, or <code><a href="#topic+DispFieldSTall">DispFieldSTall</a></code> with at least
five rows (more is better)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame as returned by <code><a href="#topic+DispField">DispField</a></code>,
<code><a href="#topic+DispFieldST">DispFieldST</a></code>, or <code><a href="#topic+DispFieldSTall">DispFieldSTall</a></code>, with three
additional columns. The first additional column is called Pattern in which
the patterns around each focal cell are categorized as clockwise,
counter-clockwise, partial clockwise, partial counter-clockwise, or NA. The
second additional column, called SubPattern, indicates whether all arrows
point towards (convergence) or away (divergence) from the focal cell. The
third additional column is called PatternCt, which contains a one if all
four neighbourhood grid cells contain displacement estimates, and a NA
otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating rotation patterns
Mat1 &lt;- matrix(rep(0,9*9), nrow = 9)
Mat1[c(1:3), 4] &lt;- 1
Mat1[c(7:9), 6] &lt;- 1
Mat1[4, c(7:9)] &lt;- 1
Mat1[6, c(1:3)] &lt;- 1
Mat1

Mat2 &lt;- matrix(rep(0,9*9), nrow = 9)
Mat2[c(1:3), 5] &lt;- 1
Mat2[c(7:9), 5] &lt;- 1
Mat2[5, c(7:9)] &lt;- 1
Mat2[5, c(1:3)] &lt;- 1
Mat2

# rasterizing
rast1 &lt;- terra::rast(Mat1)
terra::plot(rast1)
rast2 &lt;- terra::rast(Mat2)
terra::plot(rast2)

# Detecting clockwise rotation
(VFdf1 &lt;- DispField(rast1, rast2, factv1 = 3, facth1 = 3, restricted = TRUE))
(patdf1 &lt;- RotationDetect(VFdf1))

# Detecting counter-clockwise rotation
(VFdf2 &lt;- DispField(rast2, rast1, factv1 = 3, facth1 = 3, restricted = TRUE))
(patdf2 &lt;- RotationDetect(VFdf2))
</code></pre>

<hr>
<h2 id='SimData'>Simulated movement data</h2><span id='topic+SimData'></span>

<h3>Description</h3>

<p>Data based on a partial differential equation were simulated using the
ReacTran R package (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SimData)
</code></pre>


<h3>Format</h3>

<p>A data-frame with 40804 rows and 8 columns. </p>

<dl>
<dt>xcoord</dt><dd><p>in arbitrary units</p>
</dd> <dt>ycoord</dt><dd><p>in arbitrary units</p>
</dd>
<dt>t1</dt><dd><p>concentration in arbitrary units at t = 1</p>
</dd>
<dt>t2</dt><dd><p>concentration in arbitrary units at t = 2</p>
</dd>
<dt>t3</dt><dd><p>concentration in arbitrary units at t = 3</p>
</dd>
<dt>t4</dt><dd><p>concentration in arbitrary units at t = 4</p>
</dd>
<dt>t5</dt><dd><p>concentration in arbitrary units at t = 5</p>
</dd>
<dt>t6</dt><dd><p>concentration in arbitrary units at t = 6</p>
</dd> </dl>



<h3>Details</h3>

<p>The simulation algorithm uses a finite differencing scheme with backwards
differencing. The model used for simulation is a reaction diffusion-advection
equation in which the advection term is variable in space but diffusion and
reactions are constant in space see
<a href="https://en.wikipedia.org/wiki/Convection%E2%80%93diffusion_equation">convection-diffusion
equation</a> for an example.
</p>
<p>The parameters used in the general partial differntial equation in the link
above are
</p>
<p>D = 0.01 per squared spatial unit
</p>
<p>R = 0.5 per unit time
</p>
<p>v (advection is variable in space): in the upper left quadrant of the square
domain v = (0.2, 0); in the upper right quadrant v = (0, -0.2); in the lower
right quadrant v = (-0.2, 0); in the lower right quadrant v = (0, 0.2).
Obviously v is discontinous at the quadrant boundaries, which causes some
interesting model behaviour that is limited by considering only the first six
time steps such that the bulk of the concentration in each quadrant does not
cross a quadrant boundary.
</p>
<p>The intial condition at time = 0 is a concentration of one unit per arbitrary
unit of volume in the central cell of each quadrant.
</p>
<p>External boundary conditions are zero-gradient (reflecting).
</p>
<p>The data are formatted such that they can easily be converted to a raster
stack using ICvectorfields::RastStackData(SimData).
</p>

<hr>
<h2 id='SubgridMoransI'>Compute statistics for subgrids</h2><span id='topic+SubgridMoransI'></span><span id='topic+SubgridStats'></span>

<h3>Description</h3>

<p>Functions that facilitate calculation of statistics at the sub-grid level.
These may be useful for drivers  of movement speed or direction if used in
tandem with <code><a href="#topic+DispField">DispField</a></code>, <code><a href="#topic+DispFieldST">DispFieldST</a></code>, or
<code><a href="#topic+DispFieldSTall">DispFieldSTall</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubgridMoransI(inputrast1, factv1, facth1, rad1 = 1)

SubgridStats(inputrast1, factv1, facth1, statistic = "var")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SubgridMoransI_+3A_inputrast1">inputrast1</code></td>
<td>
<p>a raster as produced by terra::rast</p>
</td></tr>
<tr><td><code id="SubgridMoransI_+3A_factv1">factv1</code></td>
<td>
<p>an odd integer for the vertical dimension of sub-grids</p>
</td></tr>
<tr><td><code id="SubgridMoransI_+3A_facth1">facth1</code></td>
<td>
<p>an odd integer for the horizontal dimension of sub-grids</p>
</td></tr>
<tr><td><code id="SubgridMoransI_+3A_rad1">rad1</code></td>
<td>
<p>an integer indicating the neighbourhood radius for Moran's I
statistic calculations in rows/columns. Any cell within a distance of rad1
cells of the focal cell is considered to be in its neighbourhood.</p>
</td></tr>
<tr><td><code id="SubgridMoransI_+3A_statistic">statistic</code></td>
<td>
<p>desired output statistic: It should be one of &quot;mean&quot;,
&quot;var&quot;, or &quot;sum&quot;. Default setting is var.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when using radius to define the neighbourhood in Moran's I
calculations, a radius of one corresponds to the rook's neibhourhood. Values
that are NA or Inf are not included in calculations of the Moran's I
statistic nor in any of the other statistics that can be computed.
</p>


<h3>Value</h3>

<p>A data frame is returned with the following column names: rowcent,
colcent, frowmin, frowmax, fcolmin, fcolmax, and a column for the output
statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DispStats">DispStats</a></code> and <code><a href="#topic+DispMoransI">DispMoransI</a></code>for functions
that compute statistics at presumed source or sink locations in each region
of interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(TestMat &lt;- matrix(c(1, 0, 1, 0, 1,
                     0, 1, 0, 1, 0,
                     1, 0, 1, 0, 1,
                     0, 1, 0, 1, 0,
                     1, 0, 1, 0, 1),
                    nrow = 5))

TestRast &lt;- terra::rast(TestMat)
terra::plot(TestRast)

SubgridMoransI(TestRast, factv1 = 5, facth1 = 5, rad1 = 1)
# using rad1 = 1 is equivalent to using the rooks neighbourhood
# and so the output should be -1.

(TestMat &lt;- matrix(c(1, 0, 1, 0, 1,
                    0, 1, 0, 1, 0,
                    1, 0, 1, 0, 1,
                    0, 1, 0, 1, 0,
                    1, 0, 1, 0, 1),
                    nrow = 5))

TestRast &lt;- terra::rast(TestMat)
terra::plot(TestRast)

SubgridStats(TestRast, factv1 = 5, facth1 = 5, statistic = "mean")
SubgridStats(TestRast, factv1 = 5, facth1 = 5, statistic = "var")
SubgridStats(TestRast, factv1 = 5, facth1 = 5, statistic = "sum")

</code></pre>

<hr>
<h2 id='Xcov2D'>Cross-covariance in two spatial dimensions</h2><span id='topic+Xcov2D'></span>

<h3>Description</h3>

<p>This function efficiently computes two dimensional cross-covariance of two
equal dimensioned matrices of real numbers using efficient discrete fast
Fourier trasforms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xcov2D(mat1, mat2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xcov2D_+3A_mat1">mat1</code></td>
<td>
<p>a real valued matrix</p>
</td></tr>
<tr><td><code id="Xcov2D_+3A_mat2">mat2</code></td>
<td>
<p>a real valued matrix of equal dimension to mat1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm first pads each matrix with zeros so that the outer edges of
the matrices do not interact with one another due to the circular nature of
the discrete fast Fourier transform. Cross-covariance calculations require
computation of the complex conjugate of one of the two imput matrices.
Assuming all of it's elements are real, computing the complex conjugate is
equivalent to flipping the matrix in the horizontal and vertical directions.
Then to compute cross-covariance, the first matrix is convolved with the
flipped second matrix as described in the convolution theorem.
</p>
<p>This function is called by the main functions that compute displacement
fields and vector fields and is included here primarily for demonstration
purposes. Specifically, the method for computing the magnitude and direction
of shifts is demonstrated in the examples.
</p>
<p>The shift that produces the maximum cross-covariance between the two input
matrices can be obtained by finding the row and column indices associated
with the maximum cross-covariance. The shift in each direction is obtained by
subracting one plus the half the dimension of the output matrix (the same for
rows and columns) from the row and column values that are associated with the
maximum cross-covariance as demonstrated in the examples below. Note that
shifts to the right and up are denoted with positive numbers and shifts to
the left and down are denoted by negative numbers. This is contrary to some
conventions but efficient for producing vector fields. For more details on
cross-covariance see
<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>.
</p>


<h3>Value</h3>

<p>a real valued matrix showing cross-covariance in each direction
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matrix(c(1:6, rep(0, 3)), nrow = 3); matrix(c(rep(0, 3), 1:6), nrow = 3)
dim(Xcov2D(matrix(c(1:6, rep(0, 3)), nrow = 3),
    matrix(c(rep(0, 3), 1:6), nrow = 3)))
ICvectorfields::GetRowCol(
    which.max(Xcov2D(matrix(c(1:6, rep(0, 3)), nrow = 3),
        matrix(c(rep(0, 3), 1:6), nrow = 3))),
    dim1 = dim(Xcov2D(matrix(c(1:6, rep(0, 3)), nrow = 3),
        matrix(c(rep(0, 3), 1:6), nrow = 3)))[1],
    dim2 = dim(Xcov2D(matrix(c(1:6, rep(0, 3)), nrow = 3),
        matrix(c(rep(0, 3), 1:6), nrow = 3)))[2]
        )
# This implies that the shift is 6 - (10/2 + 1) in the vertical
# direction and 7 - (10/2 + 1) in the horizonatal direction.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
