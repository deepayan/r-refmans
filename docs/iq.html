<!DOCTYPE html><html><head><title>Help for package iq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#create_protein_list'>
<p>Creating a list of matrices of fragment ion intensities for all proteins</p></a></li>
<li><a href='#create_protein_table'>
<p>Protein quantification for a list of proteins</p></a></li>
<li><a href='#extract_annotation'>
<p>Protein annotation extraction</p></a></li>
<li><a href='#fast_MaxLFQ'>
<p>The MaxLFQ algorithm</p></a></li>
<li><a href='#fast_preprocess'>
<p>Data filtering and normalization</p></a></li>
<li><a href='#fast_read'>
<p>Reading data from an input file</p></a></li>
<li><a href='#maxLFQ'>
<p>The MaxLFQ algorithm for protein quantification</p></a></li>
<li><a href='#meanInt'>
<p>The meanInt algorithm for protein quantification</p></a></li>
<li><a href='#median_polish'>
<p>A wrapper for the R implementation of the median polish algorithm</p></a></li>
<li><a href='#plot_protein'>
<p>Plotting the underlying quantitative data for a protein</p></a></li>
<li><a href='#preprocess'>
<p>Data preprocessing for protein quantification</p></a></li>
<li><a href='#process_long_format'>
<p>Long format to a wide format table using the MaxLFQ algorithm</p></a></li>
<li><a href='#process_wide_format'>
<p>Merging rows with identical values in a particular column in a table</p></a></li>
<li><a href='#spikeins'>
<p>An example dataset of 12 spike-in proteins</p></a></li>
<li><a href='#topN'>
<p>The topN algorithm for protein quantification</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Protein Quantification in Mass Spectrometry-Based Proteomics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.12</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thang Pham &lt;t.pham@amsterdamumc.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the MaxLFQ algorithm by
    Cox et al. (2014) &lt;<a href="https://doi.org/10.1074%2Fmcp.M113.031591">doi:10.1074/mcp.M113.031591</a>&gt; in a comprehensive
    pipeline for processing proteomics data in data-independent acquisition mode
    (Pham et al. 2020 &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtz961">doi:10.1093/bioinformatics/btz961</a>&gt;).
    It offers additional options for protein quantification using
    the N most intense fragment ions, using all fragment ions, and
    a wrapper for the median polish algorithm by Tukey (1977, ISBN:0201076160).
    In general, the tool can be used to integrate multiple 
    proportional observations into a single quantitative value.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tvpham/iq">https://github.com/tvpham/iq</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tvpham/iq/issues">https://github.com/tvpham/iq/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-06 16:55:09 UTC; t.pham</td>
</tr>
<tr>
<td>Author:</td>
<td>Thang Pham <a href="https://orcid.org/0000-0003-0333-2492"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph, ctb],
  Alex Henneman <a href="https://orcid.org/0000-0002-3746-4410"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-06 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='create_protein_list'>
Creating a list of matrices of fragment ion intensities for all proteins
</h2><span id='topic+create_protein_list'></span>

<h3>Description</h3>

<p>For each protein, a numerical matrix is formed where the columns are samples and rows are fragment ions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_protein_list(preprocessed_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_protein_list_+3A_preprocessed_data">preprocessed_data</code></td>
<td>
<p>A data frame of four components as output of the <code>preprocess</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each element contains the quantitative data of a protein. The column names are sample names and the row names fragment ions.
</p>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+preprocess">preprocess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("spikeins")
head(spikeins)
# This example set of spike-in proteins has been 'median-normalized'.
norm_data &lt;- iq::preprocess(spikeins, median_normalization = FALSE, pdf_out = NULL)
protein_list &lt;- iq::create_protein_list(norm_data)

</code></pre>

<hr>
<h2 id='create_protein_table'>
Protein quantification for a list of proteins
</h2><span id='topic+create_protein_table'></span>

<h3>Description</h3>

<p>Travels through the input list and quantifies all proteins one by one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_protein_table(protein_list, method = "maxLFQ", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_protein_table_+3A_protein_list">protein_list</code></td>
<td>
<p>The input protein list</p>
</td></tr>
<tr><td><code id="create_protein_table_+3A_method">method</code></td>
<td>
<p>Possible values are &quot;maxLFQ&quot;, &quot;median_polish&quot;, &quot;topN&quot;, and &quot;meanInt&quot;.</p>
</td></tr>
<tr><td><code id="create_protein_table_+3A_...">...</code></td>
<td>
<p>Additional parameters for individual quantitation methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two components is returned
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A table of protein abundances for all samples in log2 space.</p>
</td></tr>
<tr><td><code>annotation</code></td>
<td>
<p>A vector of annotations, one for each protein.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_protein_list">create_protein_list</a></code>, <code><a href="#topic+maxLFQ">maxLFQ</a></code>, <code><a href="#topic+median_polish">median_polish</a></code>, <code><a href="#topic+topN">topN</a></code>, <code><a href="#topic+meanInt">meanInt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("spikeins")
# This example set of spike-in proteins has been 'median-normalized'.
norm_data &lt;- iq::preprocess(spikeins, median_normalization = FALSE, pdf_out = NULL)
protein_list &lt;- iq::create_protein_list(norm_data)
result &lt;- iq::create_protein_table(protein_list)
head(result)
</code></pre>

<hr>
<h2 id='extract_annotation'>
Protein annotation extraction
</h2><span id='topic+extract_annotation'></span>

<h3>Description</h3>

<p>Extracts annotation columns from a long-format input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_annotation(protein_ids, quant_table, primary_id = "PG.ProteinGroups",
                   annotation_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_annotation_+3A_protein_ids">protein_ids</code></td>
<td>
<p>A vector of protein ids.</p>
</td></tr>
<tr><td><code id="extract_annotation_+3A_quant_table">quant_table</code></td>
<td>
<p>A long-format input table. The input is typically the same as input to the <code>preprocess</code> function.</p>
</td></tr>
<tr><td><code id="extract_annotation_+3A_primary_id">primary_id</code></td>
<td>
<p>The column containing protein ids.</p>
</td></tr>
<tr><td><code id="extract_annotation_+3A_annotation_columns">annotation_columns</code></td>
<td>
<p>A vector of columns for annotation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of proteins and associated annotation extracted from the input.
</p>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+preprocess">preprocess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("spikeins")
extra_names &lt;- iq::extract_annotation(levels(spikeins$PG.ProteinGroups),
                                      spikeins,
                                      annotation_columns = c("PG.Genes", "PG.ProteinNames"))

</code></pre>

<hr>
<h2 id='fast_MaxLFQ'>
The MaxLFQ algorithm
</h2><span id='topic+fast_MaxLFQ'></span>

<h3>Description</h3>

<p>A fast implementation of the MaxLFQ algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_MaxLFQ(norm_data, row_names = NULL, col_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_MaxLFQ_+3A_norm_data">norm_data</code></td>
<td>
<p>A list of four vectors with equal length <code>protein_list</code>, <code>sample_list</code>, <code>id</code> and <code>quant</code> as prepared by the <code>fast_preprocess</code> function or the <code>quant_table</code> component returned by the <code>fast_read</code> function. Note that <code>quant</code> should contain log2 intensities.</p>
</td></tr>
<tr><td><code id="fast_MaxLFQ_+3A_row_names">row_names</code></td>
<td>
<p>A vector of character strings for row names. If <code>NULL</code>, unique values in the <code>protein_list</code> component of <code>norm_data</code> will be used. Otherwise, it should be the first column of the <code>protein</code> component returned by the <code>fast_read</code>.</p>
</td></tr>
<tr><td><code id="fast_MaxLFQ_+3A_col_names">col_names</code></td>
<td>
<p>A vector of character strings for column names. If <code>NULL</code>, unique values in the <code>sample_list</code> component of <code>norm_data</code> will be used. Otherwise, it should be the <code>sample</code> component returned by the <code>fast_read</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned with two components
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A quantification result table in log2 space.</p>
</td></tr>
<tr><td><code>annotation</code></td>
<td>
<p>A vector of strings indicating membership in case of multiple connected components for each row of <code>estimate</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fast_read">fast_read</a></code>, <code><a href="#topic+fast_preprocess">fast_preprocess</a></code></p>

<hr>
<h2 id='fast_preprocess'>
Data filtering and normalization
</h2><span id='topic+fast_preprocess'></span>

<h3>Description</h3>

<p>Filters out low intensities and performs median normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_preprocess(quant_table,
                median_normalization = TRUE,
                log2_intensity_cutoff = 0,
                pdf_out = "qc-plots-fast.pdf",
                pdf_width = 12,
                pdf_height = 8,
                show_boxplot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_preprocess_+3A_quant_table">quant_table</code></td>
<td>
<p>The <code>quant_table</code> component as returned by <code>fast_read</code>.
</p>
</td></tr>
<tr><td><code id="fast_preprocess_+3A_median_normalization">median_normalization</code></td>
<td>
<p>A logical value. The default <code>TRUE</code> value is to perform median normalization.</p>
</td></tr>
<tr><td><code id="fast_preprocess_+3A_log2_intensity_cutoff">log2_intensity_cutoff</code></td>
<td>
<p>Entries lower than this value in log2 space are ignored. Plot a histogram of all intensities to set this parameter.</p>
</td></tr>
<tr><td><code id="fast_preprocess_+3A_pdf_out">pdf_out</code></td>
<td>
<p>A character string specifying the name of the PDF output. A <code>NULL</code> value will suppress the PDF output.</p>
</td></tr>
<tr><td><code id="fast_preprocess_+3A_pdf_width">pdf_width</code></td>
<td>
<p>Width of the pdf output in inches.</p>
</td></tr>
<tr><td><code id="fast_preprocess_+3A_pdf_height">pdf_height</code></td>
<td>
<p>Height of the pdf output in inches.</p>
</td></tr>
<tr><td><code id="fast_preprocess_+3A_show_boxplot">show_boxplot</code></td>
<td>
<p>A logical value. The default <code>TRUE</code> value is to create boxplots of fragment intensities for each sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned with the same components as input data in which low intensities are filtered out and median normalization is performed if requested.
</p>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fast_read">fast_read</a></code></p>

<hr>
<h2 id='fast_read'>
Reading data from an input file
</h2><span id='topic+fast_read'></span>

<h3>Description</h3>

<p>A highly efficient reading of a tab-separated text file for iq processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_read(filename,
          sample_id = "R.Condition",
          primary_id = "PG.ProteinGroups",
          secondary_id = c("EG.ModifiedSequence", "FG.Charge", "F.FrgIon", "F.Charge"),
          intensity_col = "F.PeakArea",
          annotation_col = c("PG.Genes", "PG.ProteinNames"),
          filter_string_equal = c("F.ExcludedFromQuantification" = "False"),
          filter_string_not_equal = NULL,
          filter_double_less = c("PG.Qvalue" = "0.01", "EG.Qvalue" = "0.01"),
          filter_double_greater = NULL,
          intensity_col_sep = NULL,
          intensity_col_id = NULL,
          na_string = "0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_read_+3A_filename">filename</code></td>
<td>

<p>A long-format tab-separated text file with a primary column of protein identification, secondary columns of fragment ions, a column of sample names, a column for quantitative intensities, and extra columns for annotation.
</p>
</td></tr>
<tr><td><code id="fast_read_+3A_primary_id">primary_id</code></td>
<td>
<p>Unique values in this column form the list of proteins to be quantified.</p>
</td></tr>
<tr><td><code id="fast_read_+3A_secondary_id">secondary_id</code></td>
<td>
<p>A concatenation of these columns determines the fragment ions used for quantification.</p>
</td></tr>
<tr><td><code id="fast_read_+3A_sample_id">sample_id</code></td>
<td>
<p>Unique values in this column form the list of samples.</p>
</td></tr>
<tr><td><code id="fast_read_+3A_intensity_col">intensity_col</code></td>
<td>
<p>The column for intensities.</p>
</td></tr>
<tr><td><code id="fast_read_+3A_annotation_col">annotation_col</code></td>
<td>
<p>Annotation columns</p>
</td></tr>
<tr><td><code id="fast_read_+3A_filter_string_equal">filter_string_equal</code></td>
<td>
<p>A named vector of strings. Only rows satisfying the condition are kept.</p>
</td></tr>
<tr><td><code id="fast_read_+3A_filter_string_not_equal">filter_string_not_equal</code></td>
<td>
<p>A named vector of strings. Only rows satisfying the condition are kept.</p>
</td></tr>
<tr><td><code id="fast_read_+3A_filter_double_less">filter_double_less</code></td>
<td>
<p>A named vector of strings. Only rows satisfying the condition are kept. Default PG.Qvalue &lt; 0.01 and EG.Qvalue &lt; 0.01.</p>
</td></tr>
<tr><td><code id="fast_read_+3A_filter_double_greater">filter_double_greater</code></td>
<td>
<p>A named vector of strings. Only rows satisfying the condition are kept.</p>
</td></tr>
<tr><td><code id="fast_read_+3A_intensity_col_sep">intensity_col_sep</code></td>
<td>
<p>A separator character when entries in the intensity column contain multiple values.</p>
</td></tr>
<tr><td><code id="fast_read_+3A_intensity_col_id">intensity_col_id</code></td>
<td>
<p>The column for identities of multiple quantitative values.</p>
</td></tr>
<tr><td><code id="fast_read_+3A_na_string">na_string</code></td>
<td>
<p>The value considered as NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When entries in the intensity column contain multiple values, this function will replicate entries in other column and the <code>secondary_id</code> will be appended with corresponding entries in <code>intensity_col_id</code> when it is provided. Otherwise, integer values 1, 2, 3, etc... will be used.
</p>


<h3>Value</h3>

<p>A list is returned with following components
</p>
<table>
<tr><td><code>protein</code></td>
<td>
<p>A table of proteins in the first column followed by annotation columns.</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>A vector of samples.</p>
</td></tr>
<tr><td><code>ion</code></td>
<td>
<p>A vector of fragment ions to be used for quantification.</p>
</td></tr>
<tr><td><code>quant_table</code></td>
<td>
<p>A list of four components: protein_list (index pointing to <code>protein</code>)), sample_list (index pointing to <code>sample</code>), id (index pointing to <code>ion</code>), and quant (intensities).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>

<hr>
<h2 id='maxLFQ'>
The MaxLFQ algorithm for protein quantification
</h2><span id='topic+maxLFQ'></span>

<h3>Description</h3>

<p>Estimates protein abundances by aiming to maintain the fragment intensity ratios between samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxLFQ(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxLFQ_+3A_x">X</code></td>
<td>
<p>A matrix of ion intensities in log2 space. Columns are samples and rows are fragment ions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two components is returned
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A vector with length equal to the number of columns of the input containing the protein abundances in log2 space.</p>
</td></tr>
<tr><td><code>annotation</code></td>
<td>
<p>An empty string if all quantified samples are connected. Otherwise, a string of membership of the connected components is returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Cox J, Hein MY, Luber CA, et al. Accurate proteome-wide label-free quantification
by delayed normalization and maximal peptide ratio extraction, termed MaxLFQ.
<em>Mol Cell Proteomics</em>. 2014;13(9):2513–2526.
</p>
<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>

<hr>
<h2 id='meanInt'>
The meanInt algorithm for protein quantification
</h2><span id='topic+meanInt'></span>

<h3>Description</h3>

<p>Estimates protein abundances by averaging all associated ion intensities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanInt(X, aggregation_in_log_space = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanInt_+3A_x">X</code></td>
<td>
<p>A matrix of ion intensities in log2 space. Columns are samples and rows are fragment ions.</p>
</td></tr>
<tr><td><code id="meanInt_+3A_aggregation_in_log_space">aggregation_in_log_space</code></td>
<td>
<p>A logical value. If <code>FALSE</code>, the data aggregation is performed in the original intensity space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two components is returned
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A vector with length equal to the number of columns of the input containing the protein abundances in log2 space.</p>
</td></tr>
<tr><td><code>annotation</code></td>
<td>
<p>Reserved, currently an empty string.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>

<hr>
<h2 id='median_polish'>
A wrapper for the R implementation of the median polish algorithm
</h2><span id='topic+median_polish'></span>

<h3>Description</h3>

<p>Estimates protein abundances using the Tukey median polish algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_polish(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median_polish_+3A_x">X</code></td>
<td>
<p>A matrix of ion intensities in log2 space. Columns are samples and rows are fragment ions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two components is returned
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A vector with length equal to the number of columns of the input containing the protein abundances in log2 space.</p>
</td></tr>
<tr><td><code>annotation</code></td>
<td>
<p>Reserved, currently an empty string</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>
<p>Tukey JW. <em>Exploratory Data Analysis</em>, Reading Massachusetts: Addison-Wesley,
1977.
</p>

<hr>
<h2 id='plot_protein'>
Plotting the underlying quantitative data for a protein
</h2><span id='topic+plot_protein'></span>

<h3>Description</h3>

<p>Displays the underlying data for a protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_protein(X, main = "", col = NULL, split = 0.6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_protein_+3A_x">X</code></td>
<td>
<p>Protein data matrix.</p>
</td></tr>
<tr><td><code id="plot_protein_+3A_main">main</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="plot_protein_+3A_col">col</code></td>
<td>
<p>Colors of the rows of the data matrix.</p>
</td></tr>
<tr><td><code id="plot_protein_+3A_split">split</code></td>
<td>
<p>Fraction of the plotting area for the main figure. The remaining one is for legend. Set this parameter to <code>NULL</code> to ignore the legend area.</p>
</td></tr>
<tr><td><code id="plot_protein_+3A_...">...</code></td>
<td>
<p>Additional parameters for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>NULL</code> value is returned.
</p>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("spikeins")
head(spikeins)
# This example set of spike-in proteins has been 'median-normalized'.
norm_data &lt;- iq::preprocess(spikeins, median_normalization = FALSE, pdf_out = NULL)
protein_list &lt;- iq::create_protein_list(norm_data)
iq::plot_protein(protein_list$P00366, main = "Protein P00366", split = NULL)
</code></pre>

<hr>
<h2 id='preprocess'>
Data preprocessing for protein quantification
</h2><span id='topic+preprocess'></span>

<h3>Description</h3>

<p>Prepares a long-format input including removing low-intensity ions and performing median normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess(quant_table,
           primary_id = "PG.ProteinGroups",
           secondary_id = c("EG.ModifiedSequence", "FG.Charge", "F.FrgIon", "F.Charge"),
           sample_id = "R.Condition",
           intensity_col = "F.PeakArea",
           median_normalization = TRUE,
           log2_intensity_cutoff = 0,
           pdf_out = "qc-plots.pdf",
           pdf_width = 12,
           pdf_height = 8,
           intensity_col_sep = NULL,
           intensity_col_id = NULL,
           na_string = "0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_+3A_quant_table">quant_table</code></td>
<td>

<p>A long-format table with a primary column of protein identification, secondary columns of fragment ions, a column of sample names, and a column for quantitative intensities.
</p>
</td></tr>
<tr><td><code id="preprocess_+3A_primary_id">primary_id</code></td>
<td>
<p>Unique values in this column form the list of proteins to be quantified.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_secondary_id">secondary_id</code></td>
<td>
<p>A concatenation of these columns determines the fragment ions used for quantification.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_sample_id">sample_id</code></td>
<td>
<p>Unique values in this column form the list of samples.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_intensity_col">intensity_col</code></td>
<td>
<p>The column for intensities.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_median_normalization">median_normalization</code></td>
<td>
<p>A logical value. The default <code>TRUE</code> value is to perform median normalization.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_log2_intensity_cutoff">log2_intensity_cutoff</code></td>
<td>
<p>Entries lower than this value in log2 space are ignored. Plot a histogram of all intensities to set this parameter.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_pdf_out">pdf_out</code></td>
<td>
<p>A character string specifying the name of the PDF output. A <code>NULL</code> value will suppress the PDF output.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_pdf_width">pdf_width</code></td>
<td>
<p>Width of the pdf output in inches.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_pdf_height">pdf_height</code></td>
<td>
<p>Height of the pdf output in inches.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_intensity_col_sep">intensity_col_sep</code></td>
<td>
<p>A separator character when entries in the intensity column contain multiple values.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_intensity_col_id">intensity_col_id</code></td>
<td>
<p>The column for identities of multiple quantitative values.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_na_string">na_string</code></td>
<td>
<p>The value considered as NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When entries in the intensity column contain multiple values, this function will replicate entries in other column and the <code>secondary_id</code> will be appended with corresponding entries in <code>intensity_col_id</code> when it is provided. Otherwise, integer values 1, 2, 3, etc... will be used.
</p>


<h3>Value</h3>

<p>A data frame is returned with following components
</p>
<table>
<tr><td><code>protein_list</code></td>
<td>
<p>A vector of proteins.</p>
</td></tr>
<tr><td><code>sample_list</code></td>
<td>
<p>A vector of samples.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>A vector of fragment ions to be used for quantification.</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>A vector of log2 intensities.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("spikeins")
head(spikeins)
# This example set of spike-in proteins has been 'median-normalized'.
norm_data &lt;- iq::preprocess(spikeins, median_normalization = FALSE, pdf_out = NULL)

</code></pre>

<hr>
<h2 id='process_long_format'>
Long format to a wide format table using the MaxLFQ algorithm
</h2><span id='topic+process_long_format'></span>

<h3>Description</h3>

<p>A convenient function combining multiple steps to process a long format table using the MaxLFQ algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_long_format(input_filename,
                    output_filename,
                    sample_id = "File.Name",
                    primary_id = "Protein.Group",
                    secondary_id = "Precursor.Id",
                    intensity_col = "Fragment.Quant.Corrected",
                    annotation_col = NULL,
                    filter_string_equal = NULL,
                    filter_string_not_equal = NULL,
                    filter_double_less = c("Q.Value" = "0.01", "PG.Q.Value" = "0.01"),
                    filter_double_greater = NULL,
                    intensity_col_sep = ";",
                    intensity_col_id = NULL,
                    na_string = "0",
                    normalization = "median",
                    log2_intensity_cutoff = 0,
                    pdf_out = "qc-plots.pdf",
                    pdf_width = 12,
                    pdf_height = 8,
                    show_boxplot = TRUE,
                    peptide_extractor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_long_format_+3A_input_filename">input_filename</code></td>
<td>
<p>See <code>filename</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_output_filename">output_filename</code></td>
<td>
<p>Output filename.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_sample_id">sample_id</code></td>
<td>
<p>See <code>sample_id</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_primary_id">primary_id</code></td>
<td>
<p>See <code>primary_id</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_secondary_id">secondary_id</code></td>
<td>
<p>See <code>secondary_id</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_intensity_col">intensity_col</code></td>
<td>
<p>See <code>intensity_col</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_annotation_col">annotation_col</code></td>
<td>
<p>See <code>annotation_col</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_filter_string_equal">filter_string_equal</code></td>
<td>
<p>See <code>filter_string_equal</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_filter_string_not_equal">filter_string_not_equal</code></td>
<td>
<p>See <code>filter_string_not_equal</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_filter_double_less">filter_double_less</code></td>
<td>
<p>See <code>filter_double_less</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_filter_double_greater">filter_double_greater</code></td>
<td>
<p>See <code>filter_double_greater</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_intensity_col_sep">intensity_col_sep</code></td>
<td>
<p>See <code>intensity_col_sep</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_intensity_col_id">intensity_col_id</code></td>
<td>
<p>See <code>intensity_col_id</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_na_string">na_string</code></td>
<td>
<p>See <code>intensity_col_id</code> in <code><a href="#topic+fast_read">fast_read</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_normalization">normalization</code></td>
<td>
<p>Normalization type. Possible values are <code>median</code> and <code>none</code>. The default value <code>median</code> is for median normalization in <code><a href="#topic+fast_preprocess">fast_preprocess</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_log2_intensity_cutoff">log2_intensity_cutoff</code></td>
<td>
<p>See <code>log2_intensity_cutoff</code> in <code><a href="#topic+fast_preprocess">fast_preprocess</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_pdf_out">pdf_out</code></td>
<td>
<p>See <code>pdf_out</code> in <code><a href="#topic+fast_preprocess">fast_preprocess</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_pdf_width">pdf_width</code></td>
<td>
<p>See <code>pdf_width</code> in <code><a href="#topic+fast_preprocess">fast_preprocess</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_pdf_height">pdf_height</code></td>
<td>
<p>See <code>pdf_height</code> in <code><a href="#topic+fast_preprocess">fast_preprocess</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_show_boxplot">show_boxplot</code></td>
<td>
<p>See <code>show_boxplot</code> in <code><a href="#topic+fast_preprocess">fast_preprocess</a></code>.</p>
</td></tr>
<tr><td><code id="process_long_format_+3A_peptide_extractor">peptide_extractor</code></td>
<td>
<p>A function to parse peptides.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>After processing with <code><a href="#topic+fast_read">fast_read</a></code>, <code><a href="#topic+fast_preprocess">fast_preprocess</a></code>, and <code><a href="#topic+fast_MaxLFQ">fast_MaxLFQ</a></code>, the result table is written to <code>output_filename</code>. The quantification values are in log2 space. A <code>NULL</code> value is returned. If <code>peptide_extractor</code> is not <code>NULL</code>, fragment statistics for each protein will be calculated based on the result of the extractor function. Counting the number of peptides contributing to a protein is possible using an appropriate extractor function. An example value for <code>peptide_extractor</code> is <code>function(x) gsub("[0-9].*$", "", x)</code>, which removes the charge state and fragment descriptors in an ion descriptor to obtain unique peptide sequences. One can examine the <code>ion</code> component returned by the <code><a href="#topic+fast_read">fast_read</a></code> function to derive a regular expression to be used in the <code>gsub</code> function above.
</p>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fast_read">fast_read</a></code>, <code><a href="#topic+fast_preprocess">fast_preprocess</a></code>, <code><a href="#topic+fast_MaxLFQ">fast_MaxLFQ</a></code>
</p>

<hr>
<h2 id='process_wide_format'>
Merging rows with identical values in a particular column in a table
</h2><span id='topic+process_wide_format'></span>

<h3>Description</h3>

<p>Collapses rows with identical values in a particular column in a table. When the values in each row are proportional such as intensities of multiple fragments of a protein, the MaxLFQ algorithm is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_wide_format(input_filename,
                    output_filename,
                    id_column,
                    quant_columns,
                    data_in_log_space = FALSE,
                    annotation_columns = NULL,
                    method = "maxLFQ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_wide_format_+3A_input_filename">input_filename</code></td>
<td>
<p>Input filename of a tab-separated value text file.</p>
</td></tr>
<tr><td><code id="process_wide_format_+3A_output_filename">output_filename</code></td>
<td>
<p>Output filename.</p>
</td></tr>
<tr><td><code id="process_wide_format_+3A_id_column">id_column</code></td>
<td>
<p>The column where unique values will be kept. Rows with identical values in this column are merged. Rows with empty values here are removed.</p>
</td></tr>
<tr><td><code id="process_wide_format_+3A_quant_columns">quant_columns</code></td>
<td>
<p>Columns containing numerical data to be merged.</p>
</td></tr>
<tr><td><code id="process_wide_format_+3A_data_in_log_space">data_in_log_space</code></td>
<td>
<p>A logical value. If <code>FALSE</code>, the numerical data will be log2-transformed.</p>
</td></tr>
<tr><td><code id="process_wide_format_+3A_annotation_columns">annotation_columns</code></td>
<td>
<p>Columns in the input file apart from <code>id_column</code> and <code>quant_columns</code> that will be kept in the output.</p>
</td></tr>
<tr><td><code id="process_wide_format_+3A_method">method</code></td>
<td>
<p>Method for merging. Default value is <code>"maxLFQ"</code>. Possible values are <code>"maxLFQ"</code>, <code>"maxLFQ_R"</code>, <code>"median_polish"</code>, <code>"top3"</code>, <code>"top5"</code>, <code>"meanInt"</code>, <code>"maxInt"</code>, <code>"sum"</code>, <code>"least_na"</code> and any function for collapsing a numerical matrix to a row vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method <code>"maxLFQ_R"</code> implements the MaxLFQ algorithm pure R. It is slower than <code>"maxLFQ"</code>.
</p>
<p>Method <code>"maxInt"</code> selects row with maximum intensity (top 1).
</p>
<p>Method <code>"sum"</code> sum all intensities.
</p>
<p>Method <code>"least_na"</code> selects row with the least number of missing values.
</p>
<p>The value of <code>method</code> can be a function such as <code>function(x) log2(colSums(2^x, na.rm = TRUE))</code> for summing all intensities in the original space.
</p>


<h3>Value</h3>

<p>The result table is written to <code>output_filename</code>. A <code>NULL</code> value is returned.
</p>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>

<hr>
<h2 id='spikeins'>
An example dataset of 12 spike-in proteins
</h2><span id='topic+spikeins'></span>

<h3>Description</h3>

<p>A subset of the Bruderer 2015 dataset containing 12 spike-in proteins. The full dataset was exported from the Spectronaut software. The complete dataset has been median-normalized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("spikeins")</code></pre>


<h3>Format</h3>

<p>A data frame with 18189 observations on the following 9 variables.
</p>

<dl>
<dt><code>R.Condition</code></dt><dd><p>Sample names.</p>
</dd>
<dt><code>PG.ProteinGroups</code></dt><dd><p>Protein identifiers.</p>
</dd>
<dt><code>EG.ModifiedSequence</code></dt><dd><p>Sequence of the fragment ions.</p>
</dd>
<dt><code>FG.Charge</code></dt><dd><p>Fragment group charge.</p>
</dd>
<dt><code>F.FrgIon</code></dt><dd><p>Fragment ions.</p>
</dd>
<dt><code>F.Charge</code></dt><dd><p>Fragment charges.</p>
</dd>
<dt><code>F.PeakArea</code></dt><dd><p>Quantitative values.</p>
</dd>
<dt><code>PG.Genes</code></dt><dd><p>Gene names.</p>
</dd>
<dt><code>PG.ProteinNames</code></dt><dd><p>Protein names.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("spikeins")
head(spikeins)
</code></pre>

<hr>
<h2 id='topN'>
The topN algorithm for protein quantification
</h2><span id='topic+topN'></span>

<h3>Description</h3>

<p>Estimates protein abundances using the N most intense ions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topN(X, N = 3, aggregation_in_log_space = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topN_+3A_x">X</code></td>
<td>
<p>A matrix of ion intensities in log2 space. Columns are samples and rows are fragment ions.</p>
</td></tr>
<tr><td><code id="topN_+3A_n">N</code></td>
<td>
<p>The number of top ions used for quantification.</p>
</td></tr>
<tr><td><code id="topN_+3A_aggregation_in_log_space">aggregation_in_log_space</code></td>
<td>
<p>A logical value. If <code>FALSE</code>, data aggregation is performed in the original intensity space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two components is returned
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A vector with length equal to the number of columns of the input containing the protein abundances in log2 space.</p>
</td></tr>
<tr><td><code>annotation</code></td>
<td>
<p>Reserved, currently an empty string.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thang V. Pham
</p>


<h3>References</h3>

<p>Pham TV, Henneman AA, Jimenez CR. iq: an R package to estimate relative protein
abundances from ion quantification in DIA-MS-based proteomics. <em>Bioinformatics</em> 2020 Apr 15;36(8):2611-2613.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
