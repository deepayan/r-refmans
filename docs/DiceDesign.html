<!DOCTYPE html><html><head><title>Help for package DiceDesign</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiceDesign}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coverage'><p>Coverage</p></a></li>
<li><a href='#DiceDesign-package'><p>Designs of Computer Experiments</p></a></li>
<li><a href='#discrepancyCriteria'><p>Discrepancy measure</p></a></li>
<li><a href='#discrepESE_LHS'><p>Enhanced Stochastic Evolutionnary (ESE) algorithm for Latin Hypercube Sample (LHS) optimization via L2-discrepancy criteria</p></a></li>
<li><a href='#discrepSA_LHS'><p>Simulated annealing (SA) routine for Latin Hypercube Sample (LHS) optimization via L2-discrepancy criteria</p></a></li>
<li><a href='#dmaxDesign'><p> Maximum Entropy Designs</p></a></li>
<li><a href='#factDesign'><p>Full Factorial Designs</p></a></li>
<li><a href='#faureprimeDesign'><p>A special case of the low discrepancy Faure sequence</p></a></li>
<li><a href='#lhsDesign'><p>Latin Hypercube Designs</p></a></li>
<li><a href='#maximinESE_LHS'><p>Enhanced Stochastic Evolutionnary (ESE) algorithm for Latin Hypercube Sample (LHS) optimization via phiP criteria</p></a></li>
<li><a href='#maximinSA_LHS'><p>Simulated annealing (SA) routine for Latin Hypercube Sample (LHS) optimization via phiP criteria</p></a></li>
<li><a href='#meshRatio'><p>MeshRatio measure</p></a></li>
<li><a href='#mindist'><p>Mindist measure</p></a></li>
<li><a href='#mstCriteria'><p>Deriving the MST criteria</p></a></li>
<li><a href='#nolhDesign'><p>Cioppa's Nearly Orthogonal Latin Hypercube Designs</p></a></li>
<li><a href='#NOLHdesigns'><p>List of Cioppa's Nearly Orthogonal Latin Hypercubes designs</p></a></li>
<li><a href='#nolhdrDesign'><p>De Rainville's Nearly Orthogonal Latin Hypercube Designs</p></a></li>
<li><a href='#NOLHDRdesigns'><p>List of De Rainville's Nearly Orthogonal Latin Hypercubes designs</p></a></li>
<li><a href='#OA131'><p> A 3D orthogonal array of strength 2</p></a></li>
<li><a href='#OA131_scrambled'><p> A scrambled 3D orthogonal array of strength 2</p></a></li>
<li><a href='#olhDesign'><p>Nguyen's Orthogonal Latin Hypercube Designs</p></a></li>
<li><a href='#phiP'><p>phiP criterion</p></a></li>
<li><a href='#rss2d'><p>2D graphical tool for defect detection of Space-Filling Designs.</p></a></li>
<li><a href='#rss3d'><p>3D graphical tool for defect detection of Space-Filling Designs.</p></a></li>
<li><a href='#runif.faure'><p>Low discrepancy sequence : Faure</p></a></li>
<li><a href='#scaleDesign'><p>Scale a Design</p></a></li>
<li><a href='#straussDesign'><p> Designs based on Strauss process</p></a></li>
<li><a href='#unif.test.quantile'><p>Quantile of some uniformity tests</p></a></li>
<li><a href='#unif.test.statistic'><p>Statistic of some uniformity tests</p></a></li>
<li><a href='#unscaleDesign'><p>Unscale a Design</p></a></li>
<li><a href='#wspDesign'><p>WSP algorithm</p></a></li>
<li><a href='#xDRDN'><p>Extract a Design and Give it a Range and Dimnames</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Designs of Computer Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>1.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Jessica Franco, Delphine Dupuy, Olivier Roustant, 
        Patrice Kiener, Guillaume Damblin and Bertrand Iooss.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Celine Helbert &lt;Celine.Helbert@ec-lyon.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Space-Filling Designs and space-filling criteria (distance-based and uniformity-based), with emphasis to computer experiments; &lt;<a href="https://doi.org/10.18637%2Fjss.v065.i11">doi:10.18637/jss.v065.i11</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, randtoolbox, lattice</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 08:35:30 UTC; chelbert</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-07 12:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='coverage'>Coverage</h2><span id='topic+coverage'></span>

<h3>Description</h3>

<p>Compute the coverage measure</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage(design)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverage_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) representing the design of experiments representing the design of experiments in the unit cube [0,1]<code class="reqn">^d</code>. If this last condition is not fulfilled, a transformation into [0,1]<code class="reqn">^{d}</code> is applied before the computation of the criteria.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coverage criterion is defined by
</p>
<p style="text-align: center;"><code class="reqn">coverage=\frac{1}{\bar{\gamma}} \left[ \frac{1}{n} \sum_{i=1}^{n}
	\left( \gamma_{i} - \bar{\gamma} \right)^2 \right]^{1/2}</code>
</p>

<p>where <code class="reqn">\gamma_{i}</code> is the minimal distance between the point <code class="reqn">x_{i}</code>
and the other points of the <code>design</code> and <code class="reqn">\bar{\gamma}</code> is
the mean of the <code class="reqn">\gamma_{i}</code>. 
</p>
<p>Note that for a regular mesh, <code>cov</code>=0. Then, a small value of <code>cov</code> means that the design is close to a regular grid.</p>


<h3>Value</h3>

<p>A real number equal to the value of the coverage criterion for the <code>design</code>.</p>


<h3>Author(s)</h3>

<p>J. Franco</p>


<h3>References</h3>

<p>Gunzburer M., Burkdart J. (2004) <em>Uniformity measures for point samples in hypercubes</em>, <a href="https://people.sc.fsu.edu/~jburkardt/">https://people.sc.fsu.edu/~jburkardt/</a>.</p>


<h3>See Also</h3>

<p>other distance criteria like <code><a href="#topic+meshRatio">meshRatio</a></code>, <code><a href="#topic+phiP">phiP</a></code> and <code><a href="#topic+mindist">mindist</a></code>.
</p>
<p>discrepancy measures provided by <code><a href="#topic+discrepancyCriteria">discrepancyCriteria</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 2
n &lt;- 40
X &lt;- matrix(runif(n*dimension), n, dimension)
coverage(X)
</code></pre>

<hr>
<h2 id='DiceDesign-package'>Designs of Computer Experiments</h2><span id='topic+DiceDesign-package'></span><span id='topic+DiceDesign'></span>

<h3>Description</h3>

<p>Space-Filling Designs (SFD) and space-filling criteria (distance-based and uniformity-based).</p>


<h3>Details</h3>








<p>This package provides tools to create some specific Space-Filling Design (SFD) and to test their quality:
</p>

<ul>
<li><p> Latin Hypercube designs (randomized or centered)
</p>
</li>
<li><p> Strauss SFD and Maximum entropy SFD, WSP designs
</p>
</li>
<li><p> Optimal (low-discrepancy and maximin) Latin Hypercube desigsn by simulated annealing and genetic algorithms,
</p>
</li>
<li><p> Orthogonal and Nearly Orthogonal Latin Hypercube designs,
</p>
</li>
<li><p> Discrepancies criteria, distance measures,
</p>
</li>
<li><p> Minimal spanning tree criteria,
</p>
</li>
<li><p> Radial scanning statistic
</p>
</li></ul>



<h3>Note</h3>

<p>Part of this work was conducted on 2006-2009 within the frame of the DICE (Deep Inside Computer Experiments) Consortium between ARMINES, Renault, EDF, IRSN, ONERA and TOTAL S.A. (http://dice.emse.fr/).
</p>
<p>In this package, only Faure's sequence is implemented. Note that the <span class="pkg">randtoolbox</span> package provides the following quasi random sequences: the Sobol sequence, the Halton (hence Van Der Corput) sequence and the Torus sequence (also known as Kronecker sequence). Note also that the <span class="pkg">lhs</span> package provides other types of algorithms to compute optimized LHS.
</p>


<h3>Author(s)</h3>

<p>J. Franco, D. Dupuy, O. Roustant, P. Kiener, G. Damblin and B. Iooss. Thanks to A. Jourdan for discussions about OA131.
</p>
<p>Maintainer: Celine Helbert <a href="mailto:Celine.Helbert@ec-lyon.fr">Celine.Helbert@ec-lyon.fr</a> 
</p>


<h3>References</h3>

<p>Cioppa T.M., Lucas T.W. (2007). Efficient nearly orthogonal and space-filling Latin hypercubes. <em>Technometrics</em> 49, 45-55.
</p>
<p>Damblin G., Couplet M., and Iooss B. (2013). Numerical studies of space filling designs: optimization of Latin Hypercube Samples and subprojection properties, <em>Journal of Simulation</em>, 7:276-289, 2013.
</p>
<p>De Rainville F.-M., Gagne C., Teytaud O., Laurendeau D. (2012). Evolutionary optimization of low-discrepancy sequences. <em>ACM Transactions on Modeling and Computer Simulation (TOMACS)</em>, 22(2), 9.
</p>
<p>Dupuy D., Helbert C., Franco J. (2015), DiceDesign and DiceEval: Two R-Packages for Design and Analysis of Computer Experiments, <em>Journal of Statistical Software</em>, <b>65</b>(11), 1&ndash;38.
</p>
<p>Fang K.-T., Li R. and Sudjianto A. (2006) Design and Modeling for Computer Experiments, <em>Chapman &amp; Hall</em>.
</p>
<p>Fang K-T., Liu M-Q., Qin H. and Zhou Y-D. (2018) Theory and application of uniform experimental designs. <em>Springer</em>.
</p>
<p>Nguyen N.K. (2008) A new class of orthogonal Latinhypercubes, <em>Statistics and Applications</em>, Volume 6, issues 1 and 2, pp.119-123.
</p>
<p>Owen A.B. (2020), On dropping the first Sobol point, <a href="https://arxiv.org/abs/2008.08051">https://arxiv.org/abs/2008.08051</a>.
</p>
<p>Roustant O., Franco J., Carraro L., Jourdan A. (2010), A radial scanning statistic for selecting space-filling designs in computer experiments, <em>MODA-9 proceedings</em>.
</p>
<p>Santner T.J., Williams B.J. and Notz W.I. (2003) The Design and Analysis of Computer Experiments, <em>Springer</em>, 121-161.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># **********************
# Designs of experiments
# **********************

# A maximum entropy design with 20 points in [0,1]^2
p &lt;- dmaxDesign(20,2,0.9,200)
plot(p$design,xlim=c(0,1),ylim=c(0,1))

# Change the dimnames, adjust to range (-10, 10) and round to 2 digits
xDRDN(p, letter = "T", dgts = 2, range = c(-10, 10))

# ************************
# Criteria: L2-discrepancy
# ************************
dp &lt;- discrepancyCriteria(p$design,type=c('L2','C2'))
# Coverage measure
covp &lt;- coverage(p$design)

# *******************************
# Criteria: Minimal Spanning Tree
# *******************************
mstCriteria(p$design,plot2d=TRUE)

# ****************************************************************
# Radial scanning statistic: Detection of defects of Sobol designs
# ****************************************************************

# requires randtoolbox package
library(randtoolbox)

# in 2D
rss &lt;- rss2d(design=sobol(n=20, dim=2), lower=c(0,0), upper=c(1,1),
	type="l", col="red")

# in 8D. All pairs of dimensions are tried to detect the worst defect
# (according to the specified goodness-of-fit statistic).
d &lt;- 8
n &lt;- 10*d
rss &lt;- rss2d(design=sobol(n=n, dim=d), lower=rep(0,d), upper=rep(1,d),
	type="l", col="red")

# avoid this defect with scrambling ?
#    1. Faure-Tezuka scrambling (type "?sobol" for more details and options)
rss &lt;- rss2d(design=sobol(n=n, dim=d, scrambling=2), lower=rep(0,d),
	upper=rep(1,d), type="l", col="red")
#    2. Owen scrambling
rss &lt;- rss2d(design=sobol(n=n, dim=d, scrambling=1), lower=rep(0,d),
	upper=rep(1,d), type="l", col="red")

</code></pre>

<hr>
<h2 id='discrepancyCriteria'>Discrepancy measure</h2><span id='topic+discrepancyCriteria'></span>

<h3>Description</h3>

<p>Compute discrepancy criteria. </p>


<h3>Usage</h3>

<pre><code class='language-R'>discrepancyCriteria(design,type='all')</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrepancyCriteria_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) corresponding to the design of experiments.
The discrepancy criteria are computed for a design in the unit cube [0,1]<code class="reqn">^d</code>.
If this condition is not satisfied the design is automatically rescaled.</p>
</td></tr>
<tr><td><code id="discrepancyCriteria_+3A_type">type</code></td>
<td>
<p>type of discrepancies (single value or vector) to be computed:
</p>

<table>
<tr>
 <td style="text-align: left;">
		<code>'all'</code> </td><td style="text-align: left;"> all type of discrepancies (default) </td>
</tr>
<tr>
 <td style="text-align: left;">
  	<code>'C2'</code> </td><td style="text-align: left;"> centered L2-discrepancy </td>
</tr>
<tr>
 <td style="text-align: left;">
  	<code>'L2'</code> </td><td style="text-align: left;"> L2-discrepancy </td>
</tr>
<tr>
 <td style="text-align: left;">
  	<code>'L2star'</code> </td><td style="text-align: left;"> L2star-discrepancy </td>
</tr>
<tr>
 <td style="text-align: left;">
		<code>'M2'</code> </td><td style="text-align: left;"> modified L2-discrepancy </td>
</tr>
<tr>
 <td style="text-align: left;">
		<code>'S2'</code> </td><td style="text-align: left;"> symmetric L2-discrepancy </td>
</tr>
<tr>
 <td style="text-align: left;">
		<code>'W2'</code> </td><td style="text-align: left;"> wrap-around L2-discrepancy </td>
</tr>
<tr>
 <td style="text-align: left;">
		<code>'Mix2'</code> </td><td style="text-align: left;"> mixture L2-discrepancy </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>

</td></tr>
</table>


<h3>Details</h3>

<p>The discrepancy measures how far a given distribution of points deviates
from a perfectly uniform one. Different L2 discrepancies are available in DiceDesign.
For example, if we denote by <code class="reqn">Vol(J)</code> the volume of a subset <code class="reqn">J</code> of <code class="reqn">[0; 1]^d</code> and <code class="reqn">A(X; J)</code> the number of points of <code class="reqn">X</code> falling in <code class="reqn">J</code>, the <code class="reqn">L2</code> discrepancy is:
</p>
<p style="text-align: center;"><code class="reqn">D_{L2} (X) = \left[ \int_{[0,1]^{2d}}{} \left( \frac{A(X,J_{a,b})}{n} - Vol (J_{a,b}) \right)^{2} da db \right]^{1/2}</code>
</p>

<p>where <code class="reqn">a = (a_{1}; ... ; a_{d})'</code>, <code class="reqn">b = (b_{1};...; b_{d})'</code> and <code class="reqn">J_{a,b} =
[a_{1}; b_{1}) \times ... \times [a_{d};b_{d})</code>. The other L2-discrepancies are defined according to the same principle with different form from the subset <code class="reqn">J</code>.
Among all the possibilities, discrepancyCriteria implements only the L2 discrepancies because it can be expressed analytically even for high dimension.
</p>
<p>Centered L2-discrepancy is computed using the analytical expression done by Hickernell (1998). The user will refer to Pleming and Manteufel (2005) to have more details about the wrap around discrepancy.
</p>


<h3>Value</h3>

<p>A list containing the L2-discrepancies of the <code>design</code>.</p>


<h3>Author(s)</h3>

<p>J. Franco, D. Dupuy &amp; B. Iooss</p>


<h3>References</h3>

<p>Fang K.T, Li R. and Sudjianto A. (2006) Design and Modeling for
Computer Experiments, <em>Chapman &amp; Hall</em>.
</p>
<p>Fang K-T., Liu M-Q., Qin H. and Zhou Y-D. (2018) Theory and application of uniform
experimental designs. <em>Springer</em>.
</p>
<p>Franco J. (2008) Planification d'experiences numerique en phase exploratoire pour
la simulation des phenomenes complexes, <em>PhD thesis, Ecole Nationale Superieure
des Mines de Saint Etienne</em>.
</p>
<p>Hickernell F.J. (1998) A generalized discrepancy and quadrature error bound.
<em>Mathematics of Computation</em>, <b>67</b>, 299-322.
</p>
<p>Pleming J.B. and Manteufel R.D. (2005) <em>Replicated Latin Hypercube Sampling</em>,
46th Structures, Structural Dynamics &amp; Materials Conference, 16-21 April 2005, Austin
(Texas) &ndash; AIAA 2005-1819.
</p>


<h3>See Also</h3>

<p>distance criteria (<code><a href="#topic+coverage">coverage</a></code>, <code><a href="#topic+meshRatio">meshRatio</a></code>,
<code><a href="#topic+mindist">mindist</a></code> and <code><a href="#topic+phiP">phiP</a></code>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 2
n &lt;- 40
X &lt;- matrix(runif(n*dimension), n, dimension)
discrepancyCriteria(X)
</code></pre>

<hr>
<h2 id='discrepESE_LHS'>Enhanced Stochastic Evolutionnary (ESE) algorithm for Latin Hypercube Sample (LHS) optimization via L2-discrepancy criteria</h2><span id='topic+discrepESE_LHS'></span>

<h3>Description</h3>

<p>The objective is to produce low-discrepancy LHS. ESE is a powerful genetic algorithm to produce space-filling designs. It has been adapted here to main discrepancy criteria.</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrepESE_LHS(design, T0=0.005*discrepancyCriteria(design,type='C2')[[1]], 
inner_it=100, J=50, it=2, criterion="C2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrepESE_LHS_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) corresponding to the design of experiments.</p>
</td></tr>
<tr><td><code id="discrepESE_LHS_+3A_t0">T0</code></td>
<td>
<p>The initial temperature  of the ESE algorithm</p>
</td></tr>
<tr><td><code id="discrepESE_LHS_+3A_inner_it">inner_it</code></td>
<td>
<p>The number of iterations for inner loop</p>
</td></tr>
<tr><td><code id="discrepESE_LHS_+3A_j">J</code></td>
<td>
<p>The number of new proposed LHS inside the inner loop</p>
</td></tr>
<tr><td><code id="discrepESE_LHS_+3A_it">it</code></td>
<td>
<p> The number of iterations for outer loop</p>
</td></tr>
<tr><td><code id="discrepESE_LHS_+3A_criterion">criterion</code></td>
<td>
<p>The criterion to be optimized. One can choose three different L2-discrepancies: the C2 (centered) discrepancy (&quot;C2&quot;), the L2-star discrepancy (&quot;L2star&quot;) and the W2 (wrap-around) discrepancy (&quot;W2&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a stochastic algorithm (ESE) to produce optimized LHS. It is based on Jin et al works (2005). Here, it has been adapted to some discrepancy criteria taking into account new ideas about the revaluations of discrepancy value after a LHS elementary perturbation (in order to avoid computing all terms in the discrepancy formulas).</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>InitialDesign</code></td>
<td>
<p>the starting design</p>
</td></tr>
<tr><td><code>T0</code></td>
<td>
<p>the initial temperature of the ESE algorithm</p>
</td></tr>
<tr><td><code>inner_it</code></td>
<td>
<p>the number of iterations for inner loop</p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p>the number of new proposed LHS inside the inner loop</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>the number of iterations for outer loop</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>the criterion to be optimized</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the matrix of the final design (low-discrepancy LHS)</p>
</td></tr>
<tr><td><code>critValues</code></td>
<td>
<p>vector of criterion values along the iterations</p>
</td></tr>
<tr><td><code>tempValues</code></td>
<td>
<p>vector of temperature values along the iterations</p>
</td></tr>
<tr><td><code>probaValues</code></td>
<td>
<p>vector of acceptation probability values along the iterations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G.Damblin &amp; B. Iooss</p>


<h3>References</h3>

<p>Damblin G., Couplet M., and Iooss B. (2013). Numerical studies of space filling designs: optimization of Latin Hypercube Samples and subprojection properties, <em>Journal of Simulation,</em> 7:276-289, 2013.
</p>
<p>M. Morris and J. Mitchell (1995) Exploratory designs for computational experiments. Journal of Statistical Planning and Inference, 43:381-402.
</p>
<p>R. Jin, W. Chen and A. Sudjianto (2005) An efficient algorithm for constructing optimal design of computer experiments. Journal of Statistical Planning and Inference, 134:268-287.
</p>


<h3>See Also</h3>

<p>Latin Hypercube Sample(<code><a href="#topic+lhsDesign">lhsDesign</a></code>), 
discrepancy criteria(<code><a href="#topic+discrepancyCriteria">discrepancyCriteria</a></code>), 
geometric criterion (<code><a href="#topic+mindist">mindist</a></code><code><a href="#topic+phiP">phiP</a></code>), 
optimization (<code><a href="#topic+maximinSA_LHS">maximinSA_LHS</a></code>, <code><a href="#topic+maximinESE_LHS">maximinESE_LHS</a></code>, <code><a href="#topic+discrepSA_LHS">discrepSA_LHS</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dimension &lt;- 2
n &lt;- 10
X &lt;- lhsDesign(n, dimension)$design
Xopt &lt;- discrepESE_LHS(X, T0=0.005*discrepancyCriteria(X, type='C2')[[1]], 
                       inner_it=100, J=50, it=2)
plot(Xopt$design)
plot(Xopt$critValues, type="l")

## End(Not run)
</code></pre>

<hr>
<h2 id='discrepSA_LHS'>Simulated annealing (SA) routine for Latin Hypercube Sample (LHS) optimization via L2-discrepancy criteria</h2><span id='topic+discrepSA_LHS'></span>

<h3>Description</h3>

<p>The objective is to produce low-discrepancy LHS. SA is an efficient algorithm to produce space-filling designs. It has been adapted here to main discrepancy criteria.</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrepSA_LHS(design, T0=10, c=0.95, it=2000, criterion="C2", profile="GEOM", Imax=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrepSA_LHS_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) corresponding to the design of experiments</p>
</td></tr>
<tr><td><code id="discrepSA_LHS_+3A_t0">T0</code></td>
<td>
<p>The initial temperature</p>
</td></tr>
<tr><td><code id="discrepSA_LHS_+3A_c">c</code></td>
<td>
<p>A constant parameter regulating how the temperature goes down</p>
</td></tr>
<tr><td><code id="discrepSA_LHS_+3A_it">it</code></td>
<td>
<p>The number of iterations</p>
</td></tr>
<tr><td><code id="discrepSA_LHS_+3A_criterion">criterion</code></td>
<td>
<p>The criterion to be optimized. One can choose three different L2-discrepancies: the C2 (centered) discrepancy (&quot;C2&quot;), the L2-star discrepancy (&quot;L2star&quot;) and the W2 (wrap-around) discrepancy (&quot;W2&quot;)</p>
</td></tr>
<tr><td><code id="discrepSA_LHS_+3A_profile">profile</code></td>
<td>
<p>The temperature down-profile, purely geometric called &quot;GEOM&quot;, geometrical according to the Morris algorithm called &quot;GEOM_MORRIS&quot; or purely linear called &quot;LINEAR&quot;</p>
</td></tr>
<tr><td><code id="discrepSA_LHS_+3A_imax">Imax</code></td>
<td>
<p>A parameter given only if you choose the Morris down-profile. It adjusts the number of iterations without improvement before a new elementary perturbation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a classical routine to produce optimized LHS. It is based on the work of Morris and Mitchell (1995). They have proposed a SA version for LHS optimization according to mindist criterion. Here, it has been adapted to some discrepancy criteria taking in account new ideas about the reevaluations of a discrepancy value after a LHS elementary perturbation (in order to avoid computing all terms in the discrepancy formulas).</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>InitialDesign</code></td>
<td>
<p>the starting design</p>
</td></tr>
<tr><td><code>T0</code></td>
<td>
<p>the initial temperature of the SA algorithm</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>the constant parameter regulating how the temperature goes down</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>the number of iterations</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>the criterion to be optimized</p>
</td></tr>
<tr><td><code>profile</code></td>
<td>
<p>the temperature down-profile</p>
</td></tr>
<tr><td><code>Imax</code></td>
<td>
<p>The parameter given in the Morris down-profile</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the matrix of the final design (low-discrepancy LHS)</p>
</td></tr>
<tr><td><code>critValues</code></td>
<td>
<p>vector of criterion values along the iterations</p>
</td></tr>
<tr><td><code>tempValues</code></td>
<td>
<p>vector of temperature values along the iterations</p>
</td></tr>
<tr><td><code>probaValues</code></td>
<td>
<p>vector of acceptation probability values along the iterations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G. Damblin &amp; B. Iooss</p>


<h3>References</h3>

<p>Damblin G., Couplet M., and Iooss B. (2013). Numerical studies of space filling designs: optimization of Latin Hypercube Samples and subprojection properties, <em>Journal of Simulation,</em> 7:276-289, 2013.
</p>
<p>M. Morris and J. Mitchell (1995) Exploratory designs for computationnal experiments. Journal of 
Statistical Planning and Inference, 43:381-402.
</p>
<p>R. Jin, W. Chen and A. Sudjianto (2005) An efficient algorithm for constructing optimal design
of computer experiments. Journal of Statistical Planning and Inference, 134:268-287.
</p>


<h3>See Also</h3>

<p>Latin Hypercube Sample(<code><a href="#topic+lhsDesign">lhsDesign</a></code>),discrepancy criteria(<code><a href="#topic+discrepancyCriteria">discrepancyCriteria</a></code>), geometric criterion (<code><a href="#topic+mindist">mindist</a></code><code><a href="#topic+phiP">phiP</a></code>), optimization (<code><a href="#topic+maximinSA_LHS">maximinSA_LHS</a></code>,<code><a href="#topic+maximinESE_LHS">maximinESE_LHS</a></code> ,<code><a href="#topic+discrepESE_LHS">discrepESE_LHS</a></code>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 2
n &lt;- 10
X &lt;- lhsDesign(n, dimension)$design

## Optimize the LHS with C2 criterion
Xopt &lt;- discrepSA_LHS(X, T0=10, c=0.99, it=2000, criterion="C2")
plot(Xopt$design)
plot(Xopt$critValues, type="l")

## Optimize the LHS with C2 criterion and GEOM_MORRIS profile
## Not run: 
Xopt2 &lt;- discrepSA_LHS(X, T0=10, c=0.99, it=1000, criterion="C2", profile="GEOM_MORRIS")
plot(Xopt2$design)

## End(Not run)
</code></pre>

<hr>
<h2 id='dmaxDesign'> Maximum Entropy Designs </h2><span id='topic+dmaxDesign'></span>

<h3>Description</h3>

<p>Space-Filling Designs with <code class="reqn">n</code> experiments based on covariance matrix in
[0,1]<code class="reqn">^d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmaxDesign(n, dimension, range, niter_max=1000, seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmaxDesign_+3A_n">n</code></td>
<td>
<p> number of experiments </p>
</td></tr>
<tr><td><code id="dmaxDesign_+3A_dimension">dimension</code></td>
<td>
<p> number of variables </p>
</td></tr>
<tr><td><code id="dmaxDesign_+3A_range">range</code></td>
<td>
<p> range of variogram </p>
</td></tr>
<tr><td><code id="dmaxDesign_+3A_niter_max">niter_max</code></td>
<td>
<p> number of iterations</p>
</td></tr>
<tr><td><code id="dmaxDesign_+3A_seed">seed</code></td>
<td>
<p> seed used to generate uniform design</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maximum entropy design is a kind of optimal design based
on Shannon's definition of entropy as the amount of information.
Originally, maximum entropy sampling was proposed by Shewry and
Wynn (1987). The goal of the design is to maximize the entropy
defined as the determinant of the correlation matrix using a Fedorov-Mitchell
exchange algorithm.
</p>
<p>The spatial correlation matrix is defined by <code class="reqn">C=\left( \rho_{ij}
\right)</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code class="reqn">\rho_{ij}=1-\gamma\left(h_{ij}\right)</code> </td><td style="text-align: left;"> if <code class="reqn">h_{ij}\leq a</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code class="reqn">\rho_{ij}=0</code> </td><td style="text-align: left;"> if <code class="reqn">h_{ij}&gt;a</code>,</td>
</tr>

</table>

<p>where <code class="reqn">h_{ij}</code> is the distance between <code class="reqn">x_{i}</code> and
<code class="reqn">x_{j}</code>, <code class="reqn">a</code> denotes the range of the variogram and
<code class="reqn">\gamma</code> is a spherical variogram:
</p>
<p style="text-align: center;"><code class="reqn">\gamma(h) = 1.5 \frac{h}{a}- 0.5\left(\frac{h}{a}\right)^3
\textnormal{ for } h \leq a</code>
</p>



<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>the number of points</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the design of experiments</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>the number of variables</p>
</td></tr>
<tr><td><code>range</code></td>
<td>
<p>the range of the variogram</p>
</td></tr>
<tr><td><code>niter_mx</code></td>
<td>
<p>the number of iterations</p>
</td></tr>
<tr><td><code>design_init</code></td>
<td>
<p>the initial distribution</p>
</td></tr>
<tr><td><code>det_init</code></td>
<td>
<p>the value of the determinant for the initial distribution</p>
</td></tr>
<tr><td><code>det_end</code></td>
<td>
<p>the value of the determinant at the end of the procedure</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>the value of the seed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. Franco</p>


<h3>References</h3>

<p>Currin C., Mitchell T., Morris M. and Ylvisaker D. (1991)
<em>Bayesian Prediction of Deterministic Functions With Applications
to the Design and Analysis of Computer Experiments</em>, American
Statistical Association, <b>86</b>, 416, 953-963.
</p>
<p>Shewry, M. C. and Wynn and H. P. (1987) <em>Maximum entropy sampling</em>,
Journal of Applied Statistics 14, 165-170.</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
dimension &lt;- 2
range &lt;-0.9
niter_max &lt;- 200
out &lt;- dmaxDesign(n, dimension, range, niter_max)

## Change the dimnames, adjust to range (-10, 10) and round to 2 digits
xDRDN(out, letter = "T", dgts = 2, range = c(-10, 10))
</code></pre>

<hr>
<h2 id='factDesign'>Full Factorial Designs</h2><span id='topic+factDesign'></span>

<h3>Description</h3>

<p>Create a factorial design with <code class="reqn">n</code> = pow(levels,dimension) experiments
in [0,1]<code class="reqn">^d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factDesign(dimension, levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factDesign_+3A_dimension">dimension</code></td>
<td>
<p>an integer given the number of input variables </p>
</td></tr>
<tr><td><code id="factDesign_+3A_levels">levels</code></td>
<td>
<p>an integer given the number of levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to take a different number of levels for
any factor. In this case, the argument <code>levels</code> should be a
vector.
</p>


<h3>Value</h3>

<p><code>factDesign</code> returns a list containing all the
input arguments detailed before, plus the following components:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>the number of experiments</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the design of experiments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G. Pujol and J. Franco</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First example
g1 &lt;- factDesign(2, 7)
plot(g1$design, xlim=c(0,1), ylim=c(0,1))

## Second example
g2 &lt;- factDesign(2, c(2,7))
plot(g2$design, xlim=c(0,1), ylim=c(0,1))

## Change the dimnames, adjust to range (-10, 10) and round to 2 digits
xDRDN(g1, letter = "T", dgts = 2, range = c(-10, 10))
xDRDN(g2, letter = "T", dgts = 2, range = c(-10, 10))
</code></pre>

<hr>
<h2 id='faureprimeDesign'>A special case of the low discrepancy Faure sequence</h2><span id='topic+faureprimeDesign'></span>

<h3>Description</h3>

<p>Generate a Faure sequence with <code class="reqn">n=p^u-1</code> experiments in [0,1]<code class="reqn">^d</code> 
or other domains (see the details) where <code class="reqn">p</code> is the first prime number equal 
or larger than <code class="reqn">d</code> and <code class="reqn">u</code> is an exponent, usually 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faureprimeDesign(dimension, u = 2, range = c(0, -1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faureprimeDesign_+3A_dimension">dimension</code></td>
<td>
<p>the number of variables (&lt; 199)</p>
</td></tr>
<tr><td><code id="faureprimeDesign_+3A_u">u</code></td>
<td>
<p>the exponent applied to the prime number</p>
</td></tr>
<tr><td><code id="faureprimeDesign_+3A_range">range</code></td>
<td>
<p>the scale (min and max) of the inputs. See the details for the six predefined ranges.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a special case of <code><a href="#topic+runif.faure">runif.faure</a></code> where the number of 
generated points depends exclusively on the dimension and the selected exponent. 
For the exponent <code class="reqn">u=2</code>, the design is orthogonal and has resolution
4. It is a perfect grid <code class="reqn">(p-1)(p+1)</code> on each pair of 
variables where <code class="reqn">p</code> is the first prime number equal or 
larger than the dimension <code class="reqn">d</code>. 
</p>
<p>Six domain ranges are predefined and cover most applications:
</p>

<ul>
<li><p><code>c(0, 0)</code>  corresponds to <code class="reqn">[0, n]^d</code>.
</p>
</li>
<li><p><code>c(1, 1)</code>  corresponds to <code class="reqn">[1-n, n-1]^d = [2-p^u, p^u -2]^d</code>.
</p>
</li>
<li><p><code>c(0, 1)</code>  corresponds to <code class="reqn">[0, 1]^d</code>.
</p>
</li>
<li><p><code>c(0,-1)</code>  corresponds to <code class="reqn">[p^{-u}, 1-p^{-u}]^d</code>.
</p>
</li>
<li><p><code>c(-1,-1)</code> corresponds to <code class="reqn">[-1+2p^{-u}, 1-2p^{-u}]^d</code>.
</p>
</li>
<li><p><code>c(-1, 1)</code> corresponds to <code class="reqn">[-1, 1]^d</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>faureprimeDesign</code> returns a list with the following components:
</p>

<ul>
<li><p>design: the design of experiments
</p>
</li>
<li><p>n: the number of experiments
</p>
</li>
<li><p>dimension: the dimension
</p>
</li>
<li><p>prime: the prime number
</p>
</li>
<li><p>u: the exponent
</p>
</li></ul>



<h3>Author(s)</h3>

<p>P. Kiener</p>


<h3>References</h3>

<p>Faure H. (1982), Discrepance de suites associees a un systeme de numeration 
(en dimension s), <em>Acta Arith.</em>, 41, 337-351.
</p>
<p>Owen A.B. (2020), On dropping the first Sobol point, 
<a href="https://arxiv.org/abs/2008.08051">https://arxiv.org/abs/2008.08051</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Range c(0,-1) returns the design produced by runif.faure()
plan1 &lt;- runif.faure(n = 24, dimension = 5)$design ; plan1
plan2 &lt;- faureprimeDesign(dimension = 5, range = c(0,-1))$design ; plan2
all.equal(plan1, plan2, tolerance = 1e-15)

## Range c(0,0) returns the original sequence of integers.
## The first (p-1) lines are on the first diagonal.
## The remaining lines are LHSs grouped in p-1 blocks of p rows.
d &lt;- p &lt;- 5
plan &lt;- faureprimeDesign(dimension = d, range = c(0,0))$design ; plan
apply(plan, 2, sort)

## A regular grid (p-1)x(p+1) rotated by a small angle
pairs(plan)

plot(plan[,1], plan[,2], las = 1)
points(plan[1:(p-1),1], plan[1:(p-1),2], pch = 17, cex = 1.6)
abline(v = plan[1:(p-1),1], col = 4)

## Designs of dimensions 24x5 in various ranges
lstrg &lt;- list(p0p0 = c(0,0),  p1p1 = c(1,1),   p0p1 = c(0,1),
              p0m1 = c(0,-1), m1m1 = c(-1,-1), m1p1 = c(-1,1))
lst &lt;- lapply(lstrg, function(rg) faureprimeDesign(
              dimension = 5, u = 2, range = rg)$design)
lapply(lst, tail)
sapply(lst, range)

## The odd designs (p1m1, m1m1, m1p1) are orthogonal and have resolution 4.
library(lattice)

mat &lt;- lst$m1m1 ; colnames(mat) &lt;- LETTERS[1:5]
fml &lt;- ~ (A+B+C+D+E)^2+I(A^2)+I(B^2)+I(C^2)+I(D^2)+I(E^2)
mmm &lt;- model.matrix(fml, data = as.data.frame(mat))[,-1] ; tail(mmm)
cmm &lt;- round(cov2cor(crossprod(mmm)), 3) ; cmm
lattice::levelplot(cmm[, ncol(cmm):1], at = seq(-1, 1, length.out = 10),
                   col.regions = rev(grDevices::hcl.colors(9, "PuOr")))
</code></pre>

<hr>
<h2 id='lhsDesign'>Latin Hypercube Designs</h2><span id='topic+lhsDesign'></span>

<h3>Description</h3>

<p>Simple (random) Latin Hypercube Design (randomized or centered) with <code class="reqn">n</code> experiments in [0,1]<code class="reqn">^d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhsDesign(n, dimension, randomized=TRUE, seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lhsDesign_+3A_n">n</code></td>
<td>
<p> number of experiments </p>
</td></tr>
<tr><td><code id="lhsDesign_+3A_dimension">dimension</code></td>
<td>
<p> number of variables </p>
</td></tr>
<tr><td><code id="lhsDesign_+3A_randomized">randomized</code></td>
<td>
<p> TRUE for randomized LHS; FALSE for centered LHS</p>
</td></tr>
<tr><td><code id="lhsDesign_+3A_seed">seed</code></td>
<td>
<p> seed used to generate the random permutations and perturbations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program builds a Latin Hypercube Design (LHD), also called a Latin Hypercube Sample (LHS), on the space [0,1]<code class="reqn">^d</code> (with uniform probability measures). LHD aims at ensuring that each variable has its whole range well scanned: the range of each variable is divided into <code class="reqn">n</code> equally probable stratas. Each stratum of each variable contains only one point of the LHD. Centered LHD is obtained by choosing for each point the center of the corresponding case, while randomized LHD is obtained by adding random perturbations inside each point case.
</p>
<p>Once the sample is generated, the uniform sample from a column can be transformed to any distribution by using the quantile functions.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>the number of points</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>the number of variables</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the design of experiments</p>
</td></tr>
<tr><td><code>randomized</code></td>
<td>
<p>the type of LHD</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>the value of the seed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Iooss</p>


<h3>References</h3>

<p>McKay M., Conover W. and Beckman R. (1979)
<em>A comparison of three methods for selecting values of input variables in the analysis of output from a computer code</em>, Technometrics, <b>21</b>, 2, 239-245.
</p>
<p>Stein M. (1987)
<em>Large sample properties of simulations using Latin hypercube sampling</em>, Technometrics, <b>29</b>, 143-151.
</p>


<h3>See Also</h3>

<p>LHD optimization (<code><a href="#topic+maximinSA_LHS">maximinSA_LHS</a></code>,<code><a href="#topic+discrepSA_LHS">discrepSA_LHS</a></code>,<code><a href="#topic+maximinESE_LHS">maximinESE_LHS</a></code> ,<code><a href="#topic+discrepESE_LHS">discrepESE_LHS</a></code>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
dimension &lt;- 2
out &lt;- lhsDesign(n, dimension)
out$design

## Change the dimnames, adjust to range (-10, 10) and round to 2 digits
xDRDN(out, letter = "T", dgts = 2, range = c(-10, 10))
</code></pre>

<hr>
<h2 id='maximinESE_LHS'>Enhanced Stochastic Evolutionnary (ESE) algorithm for Latin Hypercube Sample (LHS) optimization via phiP criteria</h2><span id='topic+maximinESE_LHS'></span>

<h3>Description</h3>

<p>The objective is to produce maximin LHS. ESE is a powerful genetic algorithm allowing to produce space-filling designs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximinESE_LHS(design, T0=0.005*phiP(design,p=50), inner_it=100, J=50, it=1, p=50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximinESE_LHS_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) corresponding to the design of experiments.</p>
</td></tr>
<tr><td><code id="maximinESE_LHS_+3A_t0">T0</code></td>
<td>
<p>The initial temperature of the ESE algorithm</p>
</td></tr>
<tr><td><code id="maximinESE_LHS_+3A_inner_it">inner_it</code></td>
<td>
<p>The number of iterations for inner loop</p>
</td></tr>
<tr><td><code id="maximinESE_LHS_+3A_j">J</code></td>
<td>
<p>The number of new proposed LHS inside the inner loop</p>
</td></tr>
<tr><td><code id="maximinESE_LHS_+3A_it">it</code></td>
<td>
<p>The number of iterations for outer loop</p>
</td></tr>
<tr><td><code id="maximinESE_LHS_+3A_p">p</code></td>
<td>
<p>power required in phiP criterion</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a stochastic algorithm (ESE) to produce optimized LHS. It is based on Jin et al works (2005).</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>InitialDesign</code></td>
<td>
<p>the starting design</p>
</td></tr>
<tr><td><code>T0</code></td>
<td>
<p>the initial temperature of the ESE algorithm</p>
</td></tr>
<tr><td><code>inner_it</code></td>
<td>
<p>the number of iterations for inner loop</p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p>the number of new proposed LHS inside the inner loop</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>the number of iterations for outer loop</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>power required in phiP criterion</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the matrix of the final design (maximin LHS)</p>
</td></tr>
<tr><td><code>critValues</code></td>
<td>
<p>vector of criterion values along the iterations</p>
</td></tr>
<tr><td><code>tempValues</code></td>
<td>
<p>vector of temperature values along the iterations</p>
</td></tr>
<tr><td><code>probaValues</code></td>
<td>
<p>vector of acceptation probability values along the iterations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G. Damblin &amp; B. Iooss</p>


<h3>References</h3>

<p>Damblin G., Couplet M., and Iooss B. (2013). Numerical studies of space filling designs: optimization of Latin Hypercube Samples and subprojection properties, <em>Journal of Simulation,</em> 7:276-289, 2013.
</p>
<p>M. Morris and J. Mitchell (1995) Exploratory designs for computationnal experiments. Journal of 
Statistical Planning and Inference, 43:381-402.
</p>
<p>R. Jin, W. Chen and A. Sudjianto (2005) An efficient algorithm for constructing optimal design
of computer experiments. Journal of Statistical Planning and Inference, 134:268-287.
</p>
<p>Pronzato, L. and Muller, W. (2012). Design of computer experiments: space filling and beyond, <em>Statistics and Computing,</em> 22:681-701.
</p>


<h3>See Also</h3>

<p>Latin Hypercube Sample (<code><a href="#topic+lhsDesign">lhsDesign</a></code>), 
discrepancy criteria (<code><a href="#topic+discrepancyCriteria">discrepancyCriteria</a></code>), 
geometric criterion (<code><a href="#topic+mindist">mindist</a></code>, <code><a href="#topic+phiP">phiP</a></code>), 
optimization (<code><a href="#topic+maximinSA_LHS">maximinSA_LHS</a></code>, <code><a href="#topic+discrepESE_LHS">discrepESE_LHS</a></code>, <code><a href="#topic+discrepSA_LHS">discrepSA_LHS</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 2
n &lt;- 10
X &lt;- lhsDesign(n, dimension)$design
Xopt &lt;- maximinESE_LHS(X, T0=0.005*phiP(X), inner_it=100, J=50, it=2)
plot(Xopt$design)
plot(Xopt$critValues, type="l")

</code></pre>

<hr>
<h2 id='maximinSA_LHS'>Simulated annealing (SA) routine for Latin Hypercube Sample (LHS) optimization via phiP criteria</h2><span id='topic+maximinSA_LHS'></span>

<h3>Description</h3>

<p>The objective is to produce maximin LHS. SA is an efficient algorithm to produce space-filling designs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximinSA_LHS(design, T0=10, c=0.95, it=2000, p=50, profile="GEOM", Imax=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximinSA_LHS_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) corresponding to the design of experiments</p>
</td></tr>
<tr><td><code id="maximinSA_LHS_+3A_t0">T0</code></td>
<td>
<p>The initial temperature of the SA algorithm</p>
</td></tr>
<tr><td><code id="maximinSA_LHS_+3A_c">c</code></td>
<td>
<p>A constant parameter regulating how the temperature goes down</p>
</td></tr>
<tr><td><code id="maximinSA_LHS_+3A_it">it</code></td>
<td>
<p>The number of iterations</p>
</td></tr>
<tr><td><code id="maximinSA_LHS_+3A_p">p</code></td>
<td>
<p>power required in phiP criterion</p>
</td></tr>
<tr><td><code id="maximinSA_LHS_+3A_profile">profile</code></td>
<td>
<p>The temperature down-profile, purely geometric called &quot;GEOM&quot;, geometrical according to the Morris algorithm called &quot;GEOM_MORRIS&quot; or purely linear called &quot;LINEAR&quot;</p>
</td></tr>
<tr><td><code id="maximinSA_LHS_+3A_imax">Imax</code></td>
<td>
<p>A parameter given only if you choose the Morris down-profile. It adjusts the number of iterations without improvement before a new elementary perturbation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a classical routine to produce optimized LHS. It is based on the work of Morris and Mitchell (1995). They have proposed a SA version for LHS optimization according to mindist criterion. Here, it has been adapted to the <code>phiP</code> criterion. It has been shown (Pronzato and Muller, 2012, Damblin et al., 2013) that optimizing phiP is more efficient to produce maximin designs than optimizing mindist. When <code class="reqn">p</code> tends to infinity, optimizing a design with <code>phi_p</code> is equivalent to optimizing a design with <code>mindist</code>.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>InitialDesign</code></td>
<td>
<p>the starting design</p>
</td></tr>
<tr><td><code>T0</code></td>
<td>
<p>the initial temperature of the SA algorithm</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>the constant parameter regulating how the temperature goes down</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>the number of iterations</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>power required in phiP criterion</p>
</td></tr>
<tr><td><code>profile</code></td>
<td>
<p>the temperature down-profile</p>
</td></tr>
<tr><td><code>Imax</code></td>
<td>
<p>The parameter given in the Morris down-profile</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the matrix of the final design (maximin LHS)</p>
</td></tr>
<tr><td><code>critValues</code></td>
<td>
<p>vector of criterion values along the iterations</p>
</td></tr>
<tr><td><code>tempValues</code></td>
<td>
<p>vector of temperature values along the iterations</p>
</td></tr>
<tr><td><code>probaValues</code></td>
<td>
<p>vector of acceptation probability values along the iterations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G. Damblin &amp; B. Iooss</p>


<h3>References</h3>

<p>Damblin G., Couplet M., and Iooss B. (2013). Numerical studies of space filling designs: optimization of Latin Hypercube Samples and subprojection properties, <em>Journal of Simulation,</em> 7:276-289, 2013. 
</p>
<p>M. Morris and J. Mitchell (1995) Exploratory designs for computationnal experiments. Journal of 
Statistical Planning and Inference, 43:381-402.
</p>
<p>R. Jin, W. Chen and A. Sudjianto (2005) An efficient algorithm for constructing optimal design
of computer experiments. Journal of Statistical Planning and Inference, 134:268-287.
</p>
<p>Pronzato, L. and Muller, W. (2012). Design of computer experiments: space filling and beyond, <em>Statistics and Computing,</em> 22:681-701.
</p>


<h3>See Also</h3>

<p>Latin Hypercube Sample (<code><a href="#topic+lhsDesign">lhsDesign</a></code>), 
discrepancy criteria (<code><a href="#topic+discrepancyCriteria">discrepancyCriteria</a></code>), 
geometric criterion (<code><a href="#topic+mindist">mindist</a></code>, <code><a href="#topic+phiP">phiP</a></code>), 
optimization (<code><a href="#topic+discrepSA_LHS">discrepSA_LHS</a></code>, <code><a href="#topic+maximinESE_LHS">maximinESE_LHS</a></code>, <code><a href="#topic+discrepESE_LHS">discrepESE_LHS</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 2
n &lt;- 10
X &lt;- lhsDesign(n ,dimension)$design
Xopt &lt;- maximinSA_LHS(X, T0=10, c=0.99, it=2000)
plot(Xopt$design)
plot(Xopt$critValues, type="l")
plot(Xopt$tempValues, type="l")

## Not run: 
  Xopt &lt;- maximinSA_LHS(X, T0=10, c=0.99, it=1000, profile="GEOM_MORRIS")

## End(Not run)
</code></pre>

<hr>
<h2 id='meshRatio'>MeshRatio measure</h2><span id='topic+meshRatio'></span>

<h3>Description</h3>

<p> The <code>meshRatio</code> criterion is the ratio between the
maximimum and the minimum distance between two points of the experimental design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meshRatio(design)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meshRatio_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) representing the design of experiments in the unit cube [0,1]<code class="reqn">^d</code>. If this last condition is not fulfilled, a transformation into [0,1]<code class="reqn">^{d}</code> is applied before the computation of the criteria.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>meshRatio</code> criterion is defined by
</p>
<p style="text-align: center;"><code class="reqn">meshRatio=\frac{\max_{1\leq i \leq n} \gamma_{i}}{\min_{1\leq i \leq n}
\gamma_{i}}</code>
</p>

<p>where <code class="reqn">\gamma_{i}</code> denotes the minimal distance between the point
<code class="reqn">x_{i}</code> and the other points of the <code>design</code>.
</p>
<p>Note that for a regular mesh, <code>meshRatio</code>=1.
</p>


<h3>Value</h3>

<p>A real number equal to the value of the meshRatio criterion for the <code>design</code>.
</p>


<h3>Author(s)</h3>

<p>J. Franco</p>


<h3>References</h3>

<p>Gunzburer M. and Burkdart J. (2004), Uniformity measures for point samples in hypercubes, <a href="https://people.sc.fsu.edu/~jburkardt/">https://people.sc.fsu.edu/~jburkardt/</a>.
</p>


<h3>See Also</h3>

<p>Other distance criteria like <code><a href="#topic+meshRatio">meshRatio</a></code>, <code><a href="#topic+phiP">phiP</a></code> and <code><a href="#topic+mindist">mindist</a></code>.
</p>
<p>Discrepancy measures provided by <code><a href="#topic+discrepancyCriteria">discrepancyCriteria</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 2
n &lt;- 40
X &lt;- matrix(runif(n*dimension), n, dimension)
meshRatio(X)
</code></pre>

<hr>
<h2 id='mindist'>Mindist measure</h2><span id='topic+mindist'></span>

<h3>Description</h3>

<p>Compute the <code>mindist</code> criterion (also called maximin)</p>


<h3>Usage</h3>

<pre><code class='language-R'>mindist(design)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mindist_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) representing the design of experiments in the unit cube [0,1]<code class="reqn">^d</code>. If this last condition is not fulfilled, a transformation into [0,1]<code class="reqn">^{d}</code> is applied before the computation of the criteria.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mindist criterion is defined by
</p>
<p style="text-align: center;"><code class="reqn">mindist= \min_{x_{i}\in X} \left( \gamma_{i} \right)</code>
</p>

<p>where <code class="reqn">\gamma_{i}</code> is the minimal distance between the point <code class="reqn">x_{i}</code>
and the other points <code class="reqn">x_{k}</code> of the <code>design</code>.
</p>
<p>A higher value corresponds to a more regular scaterring of design points.
</p>


<h3>Value</h3>

<p>A real number equal to the value of the mindist criterion for the <code>design</code>.</p>


<h3>Author(s)</h3>

<p>J. Franco</p>


<h3>References</h3>

<p>Gunzburer M., Burkdart J. (2004), Uniformity measures for point samples in hypercubes, <a href="https://people.sc.fsu.edu/~jburkardt/">https://people.sc.fsu.edu/~jburkardt/</a>.
</p>
<p>Jonshon M.E., Moore L.M. and Ylvisaker D. (1990), Minmax and maximin distance designs, <em>J. of Statis. Planning and Inference</em>, 26, 131-148.
</p>
<p>Chen V.C.P., Tsui K.L., Barton R.R. and Allen J.K. (2003), A review of design and modeling in computer experiments, <em>Handbook of Statistics</em>, 22, 231-261.
</p>


<h3>See Also</h3>

 
<p>other distance criteria like <code><a href="#topic+meshRatio">meshRatio</a></code> and <code><a href="#topic+phiP">phiP</a></code>, 
discrepancy measures provided by <code><a href="#topic+discrepancyCriteria">discrepancyCriteria</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 2
n &lt;- 40
X &lt;- matrix(runif(n*dimension), n, dimension)
mindist(X)
</code></pre>

<hr>
<h2 id='mstCriteria'>Deriving the MST criteria</h2><span id='topic+mstCriteria'></span>

<h3>Description</h3>

<p>Compute both the mean and the standard deviation of the Minimal Spanning Tree (MST)</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstCriteria(design, plot2d="FALSE")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstCriteria_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) corresponding to the design of experiments.</p>
</td></tr>
<tr><td><code id="mstCriteria_+3A_plot2d">plot2d</code></td>
<td>
<p>an argument for visualizing the mst of a 2d design</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>In our context, a MST is a tree whose the sum of the lengthes of the edges is minimal. Even if unicity does not hold, the overall length is stable. The mean and the standard deviation of the lengthes of the edges are usually derived to analyze the geometric profile of the design. A large mean and a small standard deviation characterize a so-called quasi-periodic design.</p>


<h3>Value</h3>

<p>A list containing two components:
</p>
<table>
<tr><td><code>tree</code></td>
<td>
<p>a list containing the MST: each component of it contains a vector with all vertices which are connected with the experiment corresponding to the number of the components</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>vector with both the mean and the standard deviation values of the lengthes of the edges</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G. Damblin &amp; B. Iooss</p>


<h3>References</h3>

<p>Damblin G., Couplet M., and Iooss B. (2013). Numerical studies of space filling designs: optimization of Latin hypercube samples and subprojection properties,
<em>Journal of Simulation,</em> 7:276-289, 2013. 
</p>
<p>Dussert, C., Rasigni, G., Rasigni, M., and Palmari, J. (1986). Minimal spanning tree: A new approach for studying order and disorder. <em>Physical Review B</em>, 34(5):3528-3531.
</p>
<p>Franco J. (2008). Planification d'experiences numerique en phase exploratoire pour la simulation des phenomenes complexes, <em>PhD thesis, Ecole Nationale Superieure des Mines de Saint Etienne</em>.
</p>
<p>Franco, J., Vasseur, O., Corre, B., and Sergent, M. (2009). Minimum spanning tree: A new approach to assess the quality of the design of computer experiments. <em>Chemometrics and Intelligent Laboratory Systems</em>, 97:164-169.
</p>
<p>Prim, R.C. (1957). Shortest connection networks and some generalizations, <em>in Bell System Technical Journal 36:1389-1401</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 2
n &lt;- 40
X &lt;- matrix(runif(n*dimension), n, dimension)
mstCriteria(X, plot2d=TRUE)
</code></pre>

<hr>
<h2 id='nolhDesign'>Cioppa's Nearly Orthogonal Latin Hypercube Designs</h2><span id='topic+nolhDesign'></span>

<h3>Description</h3>

<p>This function generates a NOLH design of dimension 2 to 29 and normalizes it to the selected range. The design is extracted from Cioppa's <code><a href="#topic+NOLHdesigns">NOLHdesigns</a></code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nolhDesign(dimension, range = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nolhDesign_+3A_dimension">dimension</code></td>
<td>
<p> number of input variables </p>
</td></tr>
<tr><td><code id="nolhDesign_+3A_range">range</code></td>
<td>
<p> the scale (min and max) of the inputs. Range (0, 0) and (1, 1) are special cases and call integer ranges <code class="reqn">(-m, m)</code> and <code class="reqn">(0, 2m)</code>. See the examples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>the number of lines/experiments</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>the number of columns/input variables</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the design of experiments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>T.M. Cioppa for the designs. P. Kiener for the R code.</p>


<h3>See Also</h3>

<p>Cioppa's list <code><a href="#topic+NOLHdesigns">NOLHdesigns</a></code>. Other NOLH and OLH designs: <code><a href="#topic+nolhdrDesign">nolhdrDesign</a></code>, <code><a href="#topic+olhDesign">olhDesign</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Classical normalizations
nolhDesign(8, range = c(1, 1))
nolhDesign(8, range = c(0, 0))
nolhDesign(8, range = c(0, 1))
nolhDesign(8, range = c(-1, 1))

## Change the dimnames, adjust to range (-10, 10) and round to 2 digits
xDRDN(nolhDesign(8), letter = "T", dgts = 2, range = c(-10, 10))

## A list of designs
lapply(5:9, function(n) nolhDesign(n, range = c(-1, 1))$design)
</code></pre>

<hr>
<h2 id='NOLHdesigns'>List of Cioppa's Nearly Orthogonal Latin Hypercubes designs</h2><span id='topic+NOLHdesigns'></span>

<h3>Description</h3>

<p>A list of the NOLH designs for 2 to 29 input variables proposed by Cioppa in 2007. These designs combine a latin structure, orthogonality between the main terms and the interactions (+ squares) and reduced correlations between the interactions (+ squares). 
</p>
<p>This list combines the Excel spreadsheets published by Sanchez (see Source). It is used internally by the function <code><a href="#topic+nolhDesign">nolhDesign</a></code> which provides various normalizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOLHdesigns</code></pre>


<h3>Format</h3>

<p>A list of 5 matrices representing designs of experiments for 8 to 29 input variables: 
</p>

<dl>
<dt><code>nolh2_7: </code></dt><dd><p>2 to 7 input variables, 17 experiments.</p>
</dd>
<dt><code>nolh8_11: </code></dt><dd><p>8 to 11 input variables, 33 experiments.</p>
</dd>
<dt><code>nolh12_16: </code></dt><dd><p>12 to 16 input variables, 65 experiments.</p>
</dd>
<dt><code>nolh17_22: </code></dt><dd><p>17 to 22 input variables, 129 experiments.</p>
</dd>
<dt><code>nolh23_29: </code></dt><dd><p>23 to 29 input variables, 257 experiments.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>T.M. Cioppa for the designs. P. Kiener for the R code.</p>


<h3>Source</h3>

<p>Sanchez, S. M. (2011). NOLHdesigns in Excel file. Available online at <a href="https://nps.edu/web/seed/software-downloads/">https://nps.edu/web/seed/software-downloads/</a> 
</p>


<h3>References</h3>

<p>Cioppa T.M., Lucas T.W. (2007). Efficient nearly orthogonal and space-filling Latin hypercubes. Technometrics 49, 45-55.
</p>
<p>Kleijnen, J.P.C., Sanchez S.M., T.W. Lucas and Cioppa T. M.. A user's guide to the brave new world of designing simulation experiments. INFORMS Journal on Computing 17(3): 263-289.
</p>
<p>Ye, K. Q. (1998). Orthogonal Latin hypercubes and their application in computer experiments. J. Amer. Statist. Asso. 93, 1430-
1439.
</p>


<h3>See Also</h3>

<p>The main function <code><a href="#topic+nolhDesign">nolhDesign</a></code>. De Rainville's NOLH design list: <code><a href="#topic+NOLHDRdesigns">NOLHDRdesigns</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data(NOLHdesigns)

## all matrices 
names(NOLHdesigns)
lapply(NOLHDRdesigns, tail, 2)

## The first matrix/design
NOLHdesigns[["nolh2_7"]]
</code></pre>

<hr>
<h2 id='nolhdrDesign'>De Rainville's Nearly Orthogonal Latin Hypercube Designs</h2><span id='topic+nolhdrDesign'></span>

<h3>Description</h3>

<p>This function generates a NOLH design of dimension 2 to 29 and normalizes it to the selected range. From 2 to 7 input variables, the design is extracted from Cioppa's <code><a href="#topic+NOLHdesigns">NOLHdesigns</a></code> list and from 8 to 29 input variables it is extracted from De Rainville's <code><a href="#topic+NOLHDRdesigns">NOLHDRdesigns</a></code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nolhdrDesign(dimension, range = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nolhdrDesign_+3A_dimension">dimension</code></td>
<td>
<p> number of input variables </p>
</td></tr>
<tr><td><code id="nolhdrDesign_+3A_range">range</code></td>
<td>
<p> the scale (min and max) of the inputs. Range (0, 0) and (1, 1) are special cases and call integer ranges <code class="reqn">(-m, m)</code> and <code class="reqn">(0, 2m)</code>. See the examples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>the number of lines/experiments</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>the number of columns/input variables</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the design of experiments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>T.M. Cioppa and F.-M. De Rainville for the designs. P. Kiener for the R code.</p>


<h3>See Also</h3>

<p>De Rainville's list <code><a href="#topic+NOLHDRdesigns">NOLHDRdesigns</a></code>. Other NOLH or OLH designs: <code><a href="#topic+nolhDesign">nolhDesign</a></code>, <code><a href="#topic+olhDesign">olhDesign</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Classical normalizations
nolhdrDesign(8, range = c(1, 1))
nolhdrDesign(8, range = c(0, 1))
nolhdrDesign(8, range = c(0, 0))
nolhdrDesign(8, range = c(-1, 1))

## Change the dimnames, adjust to range (-10, 10) and round to 2 digits
xDRDN(nolhdrDesign(8), letter = "T", dgts = 2, range = c(-10, 10))

## A list of designs
lapply(5:9, function(n) nolhdrDesign(n, range = c(-1, 1))$design)
</code></pre>

<hr>
<h2 id='NOLHDRdesigns'>List of De Rainville's Nearly Orthogonal Latin Hypercubes designs</h2><span id='topic+NOLHDRdesigns'></span>

<h3>Description</h3>

  
<p>A list of the NOLH designs for 8 to 29 input variables proposed by De Rainville in 2012. These designs are said to be an improvment of Cioppa's NOLH designs as they have the same structure but better dispersion measures like the discrepancy. 
</p>
<p>This list combines the csv files published by De Rainville (see Source), centered and normalized to integer values. It is used internally by the function <code><a href="#topic+nolhdrDesign">nolhdrDesign</a></code> which provides various normalizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOLHDRdesigns</code></pre>


<h3>Format</h3>

<p>A list of 22 matrices representing designs of experiments for 8 to 29 input variables: 
</p>

<dl>
<dt><code>nolhdr08 to nolhdr11: </code></dt><dd><p>8, 9, 10, 11 input variables, 33 experiments.</p>
</dd>   
<dt><code>nolhdr12 to nolhdr16: </code></dt><dd><p>12, 13, 14, 15, 16 input variables, 65 experiments.</p>
</dd>
<dt><code>nolhdr17 to nolhdr22: </code></dt><dd><p>17, 18, 19, 20, 21, 22 input variables, 129 experiments.</p>
</dd>
<dt><code>nolhdr23 to nolhdr29: </code></dt><dd><p>23, 24, 25, 26, 27, 28, 29 input variables, 257 experiments.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>F.-M. De Rainville for the designs. P. Kiener for the R code.</p>


<h3>Source</h3>

 
<p>Main website: <a href="http://qrand.gel.ulaval.ca/">http://qrand.gel.ulaval.ca/</a>
</p>
<p>The python source code: <a href="https://github.com/fmder/pynolh/">https://github.com/fmder/pynolh/</a> 
</p>
<p>The python package: <a href="https://pypi.org/project/pynolh/">https://pypi.org/project/pynolh/</a>.
</p>


<h3>References</h3>

<p>De Rainville F.-M., Gagne C., Teytaud O., Laurendeau D. (2012). Evolutionary optimization of low-discrepancy sequences. ACM Transactions on Modeling and Computer Simulation (TOMACS), 22(2), 9. 
</p>
<p>Cioppa T.M., Lucas T.W. (2007). Efficient nearly orthogonal and space-filling Latin hypercubes. Technometrics 49, 45-55.
</p>


<h3>See Also</h3>

<p>The main function <code><a href="#topic+nolhdrDesign">nolhdrDesign</a></code>. Cioppa's NOLH design list: <code><a href="#topic+NOLHdesigns">NOLHdesigns</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data(NOLHDRdesigns)

## all matrices 
names(NOLHDRdesigns)
lapply(NOLHDRdesigns, tail, 2)

## The first matrix/design
NOLHDRdesigns[["nolhdr08"]]

</code></pre>

<hr>
<h2 id='OA131'> A 3D orthogonal array of strength 2</h2><span id='topic+OA131'></span>

<h3>Description</h3>

<p>A 3-dimensional linear orthogonal array (OA) of strength 2 with 49 points. The design points are equally spaced into 2 dimensional coordinate planes. However by construction, such OAs satisfy a linear relation, here: <code>x1 + 3*x2 + x3 = 0 (mod 7)</code>. As a consequence, the design points are contained in parallel planes orthogonal to (1,3,1). Actually, they are also contained in parallel planes orthogonal to other directions, as (2,-1,2) or (3,2,3), since the congruence relation leads to <code>2*x1 - x2 + 2*x3 = 0 (mod 7)</code> or <code>3*x1 + 2*x2 + 3*x3 = 0 (mod 7)</code>. For instance, they are contained in 4 parallel planes orthogonal to (2,-1,2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OA131)</code></pre>


<h3>Format</h3>

<p>A data frame with 49 observations on the following 3 variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>first coordinate</p>
</dd>
<dt><code>x2</code></dt><dd><p>second coordinate</p>
</dd>
<dt><code>x3</code></dt><dd><p>third coordinate</p>
</dd>
</dl>



<h3>Source</h3>

 
<p>Roustant O., Franco J., Carraro L., Jourdan A. (2010), A radial scanning statistic for selecting space-filling designs in computer experiments, MODA-9 proceedings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OA131)

# centering and reducing to [0,1]^3
OA &lt;- (OA131 + 0.5)/7
pairs(OA, xlim=c(0,1), ylim=c(0,1))

## Not run: 
library(lattice)
cloud(x3~x1+x2, data=OA, xlim=c(0,1), ylim=c(0,1), zlim=c(0,1), 
      screen = list(z = 50, x = -70, y = 0))
## End(Not run)
</code></pre>

<hr>
<h2 id='OA131_scrambled'> A scrambled 3D orthogonal array of strength 2</h2><span id='topic+OA131_scrambled'></span>

<h3>Description</h3>

<p>This design is obtained by adding a uniform noise to each coordinate of the orthogonal array OA131.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OA131_scrambled)</code></pre>


<h3>Format</h3>

<p>A data frame with 49 observations on the following 3 variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>first coordinate</p>
</dd>
<dt><code>x2</code></dt><dd><p>second coordinate</p>
</dd>
<dt><code>x3</code></dt><dd><p>third coordinate</p>
</dd>
</dl>



<h3>Source</h3>

<p>Roustant O., Franco J., Carraro L., Jourdan A. (2010), A radial scanning statistic for selecting space-filling designs in computer experiments, MODA-9 proceedings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OA131)
data(OA131_scrambled)

pairs(OA131, xlim=c(0,1), ylim=c(0,1))
pairs(OA131_scrambled, xlim=c(0,1), ylim=c(0,1))
</code></pre>

<hr>
<h2 id='olhDesign'>Nguyen's Orthogonal Latin Hypercube Designs</h2><span id='topic+olhDesign'></span>

<h3>Description</h3>

<p>Generate the Orthogonal Latin Hypercube (OLH) designs proposed by Nguyen in 2008. These OLHs have a latin structure, an orthogonality between the main terms and the interactions (+ squares) and low correlations between the interactions (+ squares). Very larges matrices can be obtained as the number of input variables and hence the number of lines is unconstrained. When the number of input variables is a power of 2, OLHs have <code class="reqn">d</code> columns and <code class="reqn">n = 2d + 1</code> lines (experiments). A vertical truncature is applied when the number of input variables is not a power of 2. Various normalizations can be applied. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>olhDesign(dimension, range = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="olhDesign_+3A_dimension">dimension</code></td>
<td>
<p> number of input variables </p>
</td></tr>
<tr><td><code id="olhDesign_+3A_range">range</code></td>
<td>
<p> the scale (min and max) of the inputs. Ranges (0, 0) and (1, 1) are special cases and call integer ranges <code class="reqn">(-d, d)</code> and <code class="reqn">(0, 2d)</code>. See the examples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>the number of lines/experiments</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>the number of columns/input variables</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the design of experiments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>N.K. Nguyen for the algorithm. P. Kiener for the recursive R code.</p>


<h3>References</h3>

<p>Nguyen N.K. (2008) <em>A new class of orthogonal Latinhypercubes</em>, Statistics and Applications, Volume 6, issues 1 and 2, pp.119-123.
</p>


<h3>See Also</h3>

<p>Cioppa's and De Rainville's NOLH designs: <code><a href="#topic+nolhDesign">nolhDesign</a></code>, <code><a href="#topic+nolhdrDesign">nolhdrDesign</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Classical normalizations
olhDesign(4, range = c(0, 0))
olhDesign(4, range = c(1, 1))
olhDesign(4, range = c(0, 1))
olhDesign(4, range = c(-1, 1))

## Change the dimnames, adjust to range (-10, 10) and round to 2 digits
xDRDN(olhDesign(4), letter = "T", dgts = 2, range = c(-10, 10))

## A list of designs
lapply(1:5, function(n) olhDesign(n, range = c(-1, 1))$design)
</code></pre>

<hr>
<h2 id='phiP'>phiP criterion</h2><span id='topic+phiP'></span>

<h3>Description</h3>

<p>Compute the <code class="reqn">\phi_p</code> criterion (strongly linked to mindist criterion)</p>


<h3>Usage</h3>

<pre><code class='language-R'>phiP(design, p=50)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phiP_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) corresponding to the design of experiments.</p>
</td></tr>
<tr><td><code id="phiP_+3A_p">p</code></td>
<td>
<p>the &quot;p&quot; in the Lp norm which is taken</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The <code class="reqn">\phi_p</code> criterion is defined by the <code class="reqn">L_p</code> norm of the sum of the inverses of the design inter-point euclidean distances:
</p>
<p style="text-align: center;"><code class="reqn">\phi_{p}=\left[\sum_{i,j=1\ldots N,i&lt;j}\,\,d_{ij}^{-p}\right]^{\frac{1}{p}}</code>
</p>

<p>A higher value corresponds to a more regular scaterring of design points.
</p>
<p>When <code class="reqn">p</code> tends to infinity, optimizing a design with <code class="reqn">\phi_p</code> is equivalent to optimizing a design with <code>mindist</code>.
</p>


<h3>Value</h3>

<p>A real number equal to the value of the <code class="reqn">\phi_p</code> criterion for the <code>design</code>.</p>


<h3>Author(s)</h3>

<p>G. Damblin &amp; B.Iooss</p>


<h3>References</h3>

<p>Damblin G., Couplet M., and Iooss B. (2013). Numerical studies of sapce filling designs: optimization of Latin Hypercube Samples and subprojection properties, <em>Journal of Simulation</em>, 7:276-289, 2013.
</p>
<p>Fang K.-T., Li R. and Sudjianto A. (2006). Design and Modeling for Computer Experiments, <em>Chapman &amp; Hall</em>.
</p>
<p>Pronzato, L. and Muller, W. (2012). Design of computer experiments: space filling and beyond, <em>Statistics and Computing</em>, 22:681-701.
</p>


<h3>See Also</h3>

<p>geometric criterion (<code><a href="#topic+mindist">mindist</a></code>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 2
n &lt;- 40
X &lt;- matrix(runif(n*dimension), n, dimension)
phiP(X)
</code></pre>

<hr>
<h2 id='rss2d'>2D graphical tool for defect detection of Space-Filling Designs.</h2><span id='topic+rss2d'></span>

<h3>Description</h3>

<p>For a 2-dimensional design, the 2D radial scanning statistic (RSS) scans angularly the domain. In each direction, it compares the distribution of projected points to their theoretical distribution under the assumption that all design points are drawn from uniform distribution. For a d-dimensional design, all pairs of dimensions are scanned.The RSS detects the defects of low discrepancy sequences or orthogonal arrays, and can be used for selecting space-filling designs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rss2d(design, lower, upper, gof.test.type="greenwood", 
      gof.test.stat=NULL, transform=NULL, n.angle=360, graphics=1, 
      trace=TRUE, lines.lwd = 1, lines.lty = "dotted", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rss2d_+3A_design">design</code></td>
<td>
<p>a matrix or data.frame containing the d-dimensional design of experiments. The row no. i contains the values of the d input variables corresponding to simulation no. i</p>
</td></tr>
<tr><td><code id="rss2d_+3A_lower">lower</code></td>
<td>
<p>the domain lower boundaries.</p>
</td></tr>
<tr><td><code id="rss2d_+3A_upper">upper</code></td>
<td>
<p>the domain upper boundaries.</p>
</td></tr>
<tr><td><code id="rss2d_+3A_gof.test.type">gof.test.type</code></td>
<td>
<p> an optional character indicating the kind of statistical test to be used to test the goodness-of-fit of the design projections to their theoretical distribution. Several tests are available, see <code><a href="#topic+unif.test.statistic">unif.test.statistic</a></code>. Default is &quot;greenwood&quot;.</p>
</td></tr>
<tr><td><code id="rss2d_+3A_gof.test.stat">gof.test.stat</code></td>
<td>
<p> an optional number equal to the goodness-of-fit statistic at level <code>5%</code>. Default is the modified test statistic for fully specified distribution (see details below).</p>
</td></tr>
<tr><td><code id="rss2d_+3A_transform">transform</code></td>
<td>
<p> an optional character indicating what type of transformation should be applied before testing uniformity. Only one choice available &quot;spacings&quot;, that lead to over-detection. Default - and recommended - is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rss2d_+3A_n.angle">n.angle</code></td>
<td>
<p> an optional number indicating the number of angles used. Default is <code>360</code> corresponding to a 0.5-degree discretization step. Note that the RSS curve is continuous.</p>
</td></tr>
<tr><td><code id="rss2d_+3A_graphics">graphics</code></td>
<td>
<p> an optional integer indicating whether a graph should be produced. If negative, no graph is produced. If superior to 2, the RSS curve only is plotted in the worst 2D coordinate subspace (corr. to the worst value of statistic). If 1 (default), the design is also added, with its projections onto the worst (oblique) axis.</p>
</td></tr>
<tr><td><code id="rss2d_+3A_trace">trace</code></td>
<td>
<p> an optional boolean. Turn it to <code>FALSE</code> if you want no verbosity.</p>
</td></tr>
<tr><td><code id="rss2d_+3A_lines.lwd">lines.lwd</code></td>
<td>
<p>optional number specifying the width of the straight lines involved in the graphical outputs (axis and projections)</p>
</td></tr>
<tr><td><code id="rss2d_+3A_lines.lty">lines.lty</code></td>
<td>
<p>optional character string specifying the type of the straight lines involved in the graphical outputs (axis and projections)</p>
</td></tr>
<tr><td><code id="rss2d_+3A_...">...</code></td>
<td>
<p> optional graphical parameters of plot function, to draw the RSS curve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>
<table>
<tr><td><code>global.stat</code></td>
<td>
<p>a matrix containing the values of the global statistic (equal to the maximum of statistic values over the RSS curve) for all pairs of dimensions.</p>
</td></tr>
<tr><td><code>worst.case</code></td>
<td>
<p>the worst pair of dimensions, that is the one that gives the worst value of <code>global.stat</code>.</p>
</td></tr>
<tr><td><code>worst.dir</code></td>
<td>
<p>the worst direction, that is the one that gives the worst value of the global statistic in the coordinate plane defined by <code>worst.case</code>.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector of length <code>n.angle</code> containing the statitic values for each angle, in the coordinate plane defined by <code>worst.case</code>.</p>
</td></tr>
<tr><td><code>angle</code></td>
<td>
<p>a vector of length <code>n.angle</code> containing the corresponding angles used.</p>
</td></tr>
<tr><td><code>curve</code></td>
<td>
<p>a <code>(2*n.angle)x2</code> matrix containing the discretized RSS curve.</p>
</td></tr>
<tr><td><code>gof.test.stat</code></td>
<td>
<p>the threshold at significance level 0.05 for the specified goodness-of-fit statistic. It is equal to the radius of the circle superimposed on the RSS figure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>O. Roustant</p>


<h3>References</h3>

 
<p>Roustant O., Franco J., Carraro L., Jourdan A. (2010), A radial scanning statistic for selecting space-filling designs in computer experiments, MODA-9 proceedings.
</p>
<p>D Agostino R.B., Stephens M.A. (1986), Goodness-of-fit techniques, CRC Press, New York.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+unif.test.statistic">unif.test.statistic</a></code>, <code><a href="#topic+unif.test.quantile">unif.test.quantile</a></code>, <code><a href="#topic+rss3d">rss3d</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Detection of defects of Sobol designs

## requires randtoolbox package
library(randtoolbox)

## In 2D
rss &lt;- rss2d(design=sobol(n=20, dim=2), lower=c(0,0), upper=c(1,1), 
             type="l", col="red")

## In 8D 
## All pairs of dimensions are tried to detect the worst defect 
## (according to the specified goodness-of-fit statistic).
d &lt;- 8
n &lt;- 10*d
rss &lt;- rss2d(design=sobol(n=n, dim=d), lower=rep(0,d), upper=rep(1,d), 
             type="l", col="red")

## Avoid this defect with scrambling?
## 1. Faure-Tezuka scrambling (type "?sobol" for more details and options)
rss &lt;- rss2d(design=sobol(n=n, dim=d, scrambling=2), lower=rep(0,d), upper=rep(1,d), 
             type="l", col="red")   
## 2. Owen scrambling
rss &lt;- rss2d(design=sobol(n=n, dim=d, scrambling=1), lower=rep(0,d), upper=rep(1,d), 
             type="l", col="red")
</code></pre>

<hr>
<h2 id='rss3d'>3D graphical tool for defect detection of Space-Filling Designs.</h2><span id='topic+rss3d'></span>

<h3>Description</h3>

<p>For a 3-dimensional design, the 3D radial scanning statistic (RSS) scans angularly the domain. In each direction, it compares the distribution of projected points to their theoretical distribution under the assumption that all design points are drawn from uniform distribution. For a d-dimensional design, all triplets of dimensions are scanned. The RSS detects the defects of low discrepancy sequences or orthogonal arrays, and can be used for selecting space-filling designs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rss3d(design, lower, upper, gof.test.type = "greenwood", 
      gof.test.stat = NULL, transform = NULL, n.angle = 60, 
      graphics = 1, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rss3d_+3A_design">design</code></td>
<td>
<p>a matrix or data.frame containing the d-dimensional design of experiments. The row no. i contains the values of the d input variables corresponding to simulation no. i</p>
</td></tr>
<tr><td><code id="rss3d_+3A_lower">lower</code></td>
<td>
<p>the domain lower boundaries.</p>
</td></tr>
<tr><td><code id="rss3d_+3A_upper">upper</code></td>
<td>
<p>the domain upper boundaries.</p>
</td></tr>
<tr><td><code id="rss3d_+3A_gof.test.type">gof.test.type</code></td>
<td>
<p>an optional character indicating the kind of statistical test to be used to test the goodness-of-fit of the design projections to their theoretical distribution. Several tests are available, see <code><a href="#topic+unif.test.statistic">unif.test.statistic</a></code>. Default is &quot;greenwood&quot;.</p>
</td></tr>
<tr><td><code id="rss3d_+3A_gof.test.stat">gof.test.stat</code></td>
<td>
<p>an optional number equal to the goodness-of-fit statistic at level <code>5%</code>. Default is the modified test statistic for fully specified distribution (see details below).</p>
</td></tr>
<tr><td><code id="rss3d_+3A_transform">transform</code></td>
<td>
<p> an optional character indicating what type of transformation should be applied before testing uniformity. Only one choice available &quot;spacings&quot;, that lead to over-detection. Default - and recommended - is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rss3d_+3A_n.angle">n.angle</code></td>
<td>
<p> an optional number indicating the number of angles used. Default is <code>60</code> corresponding to a 3-degree discretization step. Note that the RSS surface is continuous.</p>
</td></tr>
<tr><td><code id="rss3d_+3A_graphics">graphics</code></td>
<td>
<p> an optional integer indicating whether a graph should be produced. If negative, no graph is produced. Otherwise (default), the design is plotted in the worst 3D coordinate subspace (corr. to the worst value of statistic), with its projections onto the worst (oblique) axis.</p>
</td></tr>
<tr><td><code id="rss3d_+3A_trace">trace</code></td>
<td>
<p> an optional boolean. Turn it to <code>FALSE</code> if you want no verbosity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RSS surface is continuous. However for computational purposes, a discretization is used. The default discretization step is tunable with <code>n.angle</code>.
</p>


<h3>Value</h3>

<p>a list with components:
</p>
<table>
<tr><td><code>global.stat</code></td>
<td>
<p>an array containing the values of the global statistic (equal to the maximum of statistic values over the RSS surface) for all triplets of dimensions.</p>
</td></tr>
<tr><td><code>print.out</code></td>
<td>
<p>the same as <code>global.stat</code>, but with a user-friendly printing.</p>
</td></tr>
<tr><td><code>worst.case</code></td>
<td>
<p>the worst triplet of dimensions, that is the one that gives the worst value of <code>global.stat</code>.</p>
</td></tr>
<tr><td><code>worst.dir</code></td>
<td>
<p>the worst direction, that is the one that gives the worst value of the statistic in the coordinate 3D subspace defined by <code>worst.case</code>.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a matrix of size <code>n.angle*n.angle</code> containing the statistic values for each angles (spherical coordinates).</p>
</td></tr>
<tr><td><code>angle</code></td>
<td>
<p>a matrix of size <code>n.angle*n.angle</code> containing the corresponding angles used (spherical coordinates).</p>
</td></tr>
<tr><td><code>gof.test.stat</code></td>
<td>
<p>the threshold at significance level 0.05 for the specified goodness-of-fit statistic.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>O. Roustant</p>


<h3>References</h3>

 
<p>Roustant O., Franco J., Carraro L., Jourdan A. (2010), A radial scanning statistic for selecting space-filling designs in computer experiments, MODA-9 proceedings.
</p>
<p>D Agostino R.B., Stephens M.A. (1986), Goodness-of-fit techniques, CRC Press, New York.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+unif.test.statistic">unif.test.statistic</a></code>, <code><a href="#topic+unif.test.quantile">unif.test.quantile</a></code>, <code><a href="#topic+rss2d">rss2d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## An orthogonal array in 3D   
data(OA131)

## centering the design points of this 7-levels design
OA &lt;- (OA131 + 0.5)/7

## 2D projections onto coordinate axis 
pairs(OA, xlim=c(0,1), ylim=c(0,1))
## Now let us look at the 3D properties with the 3D RSS (requires the rgl package)
rss &lt;- rss3d(OA, lower=c(0,0,0), upper=c(1,1,1))
## The worst direction detected is nearly proportional to (2,-1,2)
## (type "?OA131" for explanations about this linear orthogonal array)
print(rss$worst.dir)

## Now, scramble this design
## X &lt;- (OA131 + matrix(runif(49*3, 49, 3)))/7
## or load the design obtained this way
data(OA131_scrambled)
OA2 &lt;- OA131_scrambled

## No feature is detected by the 2D RSS:
rss &lt;- rss2d(OA2, lower=c(0,0,0), upper=c(1,1,1))    
## 4 clusters are detected by the 3D RSS:
rss &lt;- rss3d(OA2, lower=c(0,0,0), upper=c(1,1,1))	

	
## Defect detection of 8D Sobol sequences
## All triplets of dimensions are tried to detect the worst defect 
## (according to the specified goodness-of-fit statistic).
## requires randtoolbox library to generate the Sobol sequence
## Not run: 
library(randtoolbox)
d &lt;- 8
n &lt;- 10*d
rss &lt;- rss3d(design=sobol(n=n, dim=d), lower=rep(0,d), upper=rep(1,d))
## End(Not run)
</code></pre>

<hr>
<h2 id='runif.faure'>Low discrepancy sequence : Faure</h2><span id='topic+runif.faure'></span>

<h3>Description</h3>

<p>Generate a Faure sequence with <code class="reqn">n</code> experiments in [0,1]<code class="reqn">^d</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif.faure(n, dimension)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif.faure_+3A_n">n</code></td>
<td>
<p>the number of experiments</p>
</td></tr>
<tr><td><code id="runif.faure_+3A_dimension">dimension</code></td>
<td>
<p>the number of variables (&lt;100)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A quasirandom or low discrepancy sequence, such as the
Faure, Halton, Hammersley, Niederreiter or Sobol sequences,
is &quot;less random&quot; than a pseudorandom number sequence, but more
useful for such tasks as approximation of integrals in higher
dimensions, and in global optimization. This is because low
discrepancy sequences tend to sample space &quot;more uniformly&quot;
than random numbers.
</p>
<p>see <span class="pkg">randtoolbox</span> or <span class="pkg">fOptions</span> packages for other low discrepancy sequences.</p>


<h3>Value</h3>

<p><code>runif.halton</code> returns a list containing all the
input arguments detailed before, plus the following component:
</p>
<table>
<tr><td><code>design</code></td>
<td>
<p>the design of experiments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. Franco</p>


<h3>References</h3>

<p>Faure H. (1982), Discrepance de suites associees a un systeme de numeration (en dimension s), <em>Acta Arith.</em>, 41, 337-351
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- runif.faure(20,2)
plot(f$design, xlim=c(0,1), ylim=c(0,1))
xDRDN(f, letter="T", dgts=2, range=c(-10, 10))
</code></pre>

<hr>
<h2 id='scaleDesign'>Scale a Design</h2><span id='topic+scaleDesign'></span>

<h3>Description</h3>

<p>This function scales the values of the design points to values comprised in [0,1].
The scaling can be made by the Rosenblatt transformation (uniformization by applying the empirical cumulative distribution function) or by translating the design from maximum and minimum values (given for each variable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleDesign(design, min=NULL, max=NULL, uniformize=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleDesign_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) corresponding to the design of experiments to scale</p>
</td></tr>
<tr><td><code id="scaleDesign_+3A_min">min</code></td>
<td>
<p>the vector of minimal bounds of each design variable. If not given, the minimal value of each variable is taken</p>
</td></tr>
<tr><td><code id="scaleDesign_+3A_max">max</code></td>
<td>
<p>the vector of maximal bounds of each design variable. If not given, the maximal value of each variable is taken</p>
</td></tr>
<tr><td><code id="scaleDesign_+3A_uniformize">uniformize</code></td>
<td>
<p>boolean: TRUE to use the Rosenblatt transformation (the min and max vectors are useless in this case). If FALSE (default value), the translation from max and min values is applied</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>design</code></td>
<td>
<p>the scaled design</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>the vector of minimal bounds that has been used</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>the vector of maximal bounds that has been used</p>
</td></tr>
<tr><td><code>uniformize</code></td>
<td>
<p>the value of this boolean argument</p>
</td></tr>
<tr><td><code>InitialDesign</code></td>
<td>
<p>the starting design</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Iooss</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- 2
  n &lt;- 100
  x &lt;- matrix(rnorm(d*n), ncol=d)
  xscale1 &lt;- scaleDesign(x, uniformize=FALSE)
  xscale2 &lt;- scaleDesign(x, uniformize=TRUE)
  par(mfrow=c(1,2))
  plot(xscale1$design) ; plot(xscale2$design)
</code></pre>

<hr>
<h2 id='straussDesign'> Designs based on Strauss process</h2><span id='topic+straussDesign'></span>

<h3>Description</h3>

<p>Space-Filling Designs based on Strauss process</p>


<h3>Usage</h3>

<pre><code class='language-R'>straussDesign(n,dimension, RND, alpha=0.5, repulsion=0.001, NMC=1000,
              constraints1D=0, repulsion1D=0.0001, seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="straussDesign_+3A_n">n</code></td>
<td>
<p>the number of experiments</p>
</td></tr>
<tr><td><code id="straussDesign_+3A_dimension">dimension</code></td>
<td>
<p>the number of input variables</p>
</td></tr>
<tr><td><code id="straussDesign_+3A_rnd">RND</code></td>
<td>
<p>a real number which represents the radius of interaction</p>
</td></tr> 
<tr><td><code id="straussDesign_+3A_alpha">alpha</code></td>
<td>
<p>the potential power (default, fixed at 0.5)</p>
</td></tr>
<tr><td><code id="straussDesign_+3A_repulsion">repulsion</code></td>
<td>
<p>the repulsion parameter in the unit cube (gamma)</p>
</td></tr>
<tr><td><code id="straussDesign_+3A_nmc">NMC</code></td>
<td>
<p>the number of McMC iterations (this number must be large to converge)</p>
</td></tr>
<tr><td><code id="straussDesign_+3A_constraints1d">constraints1D</code></td>
<td>
<p>1 to impose 1D projection constraints, 0 otherwise</p>
</td></tr>
<tr><td><code id="straussDesign_+3A_repulsion1d">repulsion1D</code></td>
<td>
<p>the repulsion parameter in 1D</p>
</td></tr>
<tr><td><code id="straussDesign_+3A_seed">seed</code></td>
<td>
<p> seed for the uniform generation of number</p>
</td></tr></table>


<h3>Details</h3>

<p>Strauss designs are Space-Filling designs initially defined from Strauss process:
</p>
<p style="text-align: center;"><code class="reqn">\pi (X) = k \gamma^{s(X)}</code>
</p>

<p>where <code class="reqn">s(X)</code> is is the number of pairs of points <code class="reqn">(x^{i}, x^{j})</code> of the design <code class="reqn">X = \left( x^{1}, \ldots, x^{n} \right)</code> that are separated by a distance no greater than the radius of interaction <code>RND</code>, <code class="reqn">k</code> is the normalizing constant and <code class="reqn">\gamma</code> is the repulsion parameter. This distribution corresponds to the particular case <code>alpha</code>=0.
</p>
<p>For the general case, a stochastic simulation is used to construct a Markov chain which converges to a spatial density of points <code class="reqn">\pi(X)</code> described by the Strauss-Gibbs potential. In practice, the Metropolis-Hastings algorithm is implemented to simulate a distribution of points which converges to the stationary law: 
</p>
<p style="text-align: center;"><code class="reqn">\pi (X) \propto exp(-U(X))</code>
</p>

<p>with a potentiel <code class="reqn">U</code> defined by:
</p>
<p style="text-align: center;"><code class="reqn">U(X) = \beta \sum_{1 \leq i &lt; j \leq n} \varphi  \left( \| x^{i}-x^{j} \| \right)</code>
</p>

<p>where <code class="reqn">\beta = - \ln \gamma</code>, <code class="reqn">\varphi (h) = \left( 1 - \frac{h}{RND} \right) ^{\alpha}</code> if <code class="reqn">h \leq</code> <code>RND</code> and 0 otherwise.
</p>
<p>The input parameters of <code>straussDesign</code> function can be interpreted as follows: 
</p>
<p>- <code>RND</code> is used to compute the number of pairs of points of the design separated by a distance no more than <code>RND</code>. A point is said &quot;in interaction&quot; with another if the spheres of radius <code>RND</code>/2 centered on these points intersect.
</p>
<p>- <code>alpha</code> is the potential power <code class="reqn">\alpha</code>. The case <code>alpha</code>=0 corresponds to Strauss process (0-1 potential). 
</p>
<p>- <code>repulsion</code> is equal to the <code class="reqn">\gamma</code> parameter of the Strauss process. Note that <code class="reqn">\gamma</code> belongs to ]0,1].
</p>
<p>- <code>constraints1D</code> allows to specify some constraints into the margin. If <code>constraints1D</code>==1, two repulsion parameters are needed: one for the all space (<code>repulsion</code>) and the other for the 1D projection (<code>repulsion1D</code>). Default values are <code>repulsion</code>=0.001 and <code>repulsion1D</code>=0.001. Note that the value of the radius of interaction in the one-dimensional axis is not an input parameter and is automatically fixed at <code class="reqn">0.75/n</code>.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>the number of experiments</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>the number <code class="reqn">d</code> of variables</p>
</td></tr>
<tr><td><code>design_init</code></td>
<td>
<p>the initial distribution of <code class="reqn">n</code> points <code class="reqn">[0,1]^{d}</code></p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>the radius of interaction</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the potential power alpha</p>
</td></tr>
<tr><td><code>repulsion</code></td>
<td>
<p>the repulsion parameter <code class="reqn">\gamma</code></p>
</td></tr>
<tr><td><code>NMC</code></td>
<td>
<p>the number of iterations McMC</p>
</td></tr>
<tr><td><code>constraints1D</code></td>
<td>
<p>an integer indicating if constraints on the factorial axis are imposed. If its value is different from zero, a component <code>repulsion1D</code> containing the value of the repulsion parameter <code class="reqn">\gamma</code> in dimension 1 is added at the list.</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the design of experiments in [0,1]<code class="reqn">^{d}</code></p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>the seed corresponding to the design</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. Franco</p>


<h3>References</h3>

<p>J. Franco, X. Bay, B. Corre and D. Dupuy (2008) Planification d'experiences numeriques a partir du processus ponctuel de Strauss, <a href="https://hal.science/hal-00260701/fr/">https://hal.science/hal-00260701/fr/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Strauss-Gibbs designs in dimension 2 (n=20 points)
S1 &lt;- straussDesign(n=20, dimension=2, RND=0.2)
plot(S1$design, xlim=c(0,1), ylim=c(0,1))
theta &lt;- seq(0,2*pi, by=2*pi/(100 - 1))
for(i in 1:S1$n){
   lines(S1$design[i,1]+S1$radius/2*cos(theta),
	     S1$design[i,2]+S1$radius/2*sin(theta), col='red')
}

## 2D-Strauss design
S2 &lt;- straussDesign(n=20, dimension=2, RND=0.2, NMC=200,
	         constraints1D=0, alpha=0, repulsion=0.01)
plot(S2$design,xlim=c(0,1),ylim=c(0,1))

## 2D-Strauss designs with constraints on the axis
S3 &lt;- straussDesign(n=20, dimension=2, RND=0.18, NMC=200, 
	         constraints1D=1, alpha=0.5, repulsion=0.1, repulsion1D=0.01)
plot(S3$design, xlim=c(0,1),ylim=c(0,1))
rug(S3$design[,1], side=1)
rug(S3$design[,2], side=2)

## Change the dimnames, adjust to range (-10, 10) and round to 2 digits
xDRDN(S3, letter="T", dgts=2, range=c(-10, 10))
</code></pre>

<hr>
<h2 id='unif.test.quantile'>Quantile of some uniformity tests</h2><span id='topic+unif.test.quantile'></span>

<h3>Description</h3>

<p>Computes the quantile of a uniformity test at a given significance level (see available tests and levels below).</p>


<h3>Usage</h3>

<pre><code class='language-R'>unif.test.quantile(type, n, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unif.test.quantile_+3A_type">type</code></td>
<td>
<p>a character indicating which test is used. The choices are the following: &quot;greenwood&quot;, &quot;qm&quot; (for Quesenberry-Miller), &quot;ks&quot; (Kolmogorov-Smirnov), &quot;cvm&quot; (Cramer-Von Mises) and &quot;V&quot; (D+ + D- from Kolmogorov-Smirnov).</p>
</td></tr>
<tr><td><code id="unif.test.quantile_+3A_n">n</code></td>
<td>
<p>an integer equal to the sample size.</p>
</td></tr>
<tr><td><code id="unif.test.quantile_+3A_alpha">alpha</code></td>
<td>
<p>a real number equal to significance level. At present stage, only four values are available: 0.1, 0.05, 0.025 and 0.01.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modified statistics are used. For <code>alpha = 0.05</code>, the quantile is (see D Agostino and Stephens, 1986, section 4.4.): <code>1.358/(sqrt(n) + 0.12 + 0.11/sqrt(n))</code> for Kolmogorov-Smirnov and <code>0.461/(1+1/n) + 0.4/n - 0.6/n^2</code> for Cramer-von Mises. When the design size is <code>&lt; 20</code>, the corrected value seems to be a good approximation, but the non asymptotical value should be preferred.
</p>


<h3>Value</h3>

<p>A real number equal to the quantile of the specified test at significance level <code>alpha</code> for <code>n</code> observations.</p>


<h3>Author(s)</h3>

<p>O. Roustant</p>


<h3>References</h3>

 
<p>D Agostino R.B., Stephens M.A. (1986), Goodness-of-fit techniques, CRC Press, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unif.test.statistic">unif.test.statistic</a></code>, <code><a href="#topic+rss2d">rss2d</a></code>, <code><a href="#topic+rss3d">rss3d</a></code></p>

<hr>
<h2 id='unif.test.statistic'>Statistic of some uniformity tests</h2><span id='topic+unif.test.statistic'></span>

<h3>Description</h3>

<p>Computes the statistic of a uniformity test (see available tests below).</p>


<h3>Usage</h3>

<pre><code class='language-R'>unif.test.statistic(x, type, transform=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unif.test.statistic_+3A_x">x</code></td>
<td>
<p>a vector containing the sample values.</p>
</td></tr>
<tr><td><code id="unif.test.statistic_+3A_type">type</code></td>
<td>
<p>a character indicating which test is used. The choices are the following: &quot;greenwood&quot;, &quot;qm&quot; (for Quesenberry-Miller), &quot;ks&quot; (Kolmogorov-Smirnov), &quot;cvm&quot; (Cramer-Von Mises) and &quot;V&quot; (D+ + D- from Kolmogorov-Smirnov).</p>
</td></tr>
<tr><td><code id="unif.test.statistic_+3A_transform">transform</code></td>
<td>
<p> an optional character indicating what type of transformation should be applied before testing uniformity. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number equal to the statistic of the specified test.</p>


<h3>Author(s)</h3>

<p>O. Roustant</p>


<h3>References</h3>

 
<p>D Agostino R.B., Stephens M.A. (1986), Goodness-of-fit techniques, CRC Press, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unif.test.quantile">unif.test.quantile</a></code>, <code><a href="#topic+rss2d">rss2d</a></code></p>

<hr>
<h2 id='unscaleDesign'>Unscale a Design</h2><span id='topic+unscaleDesign'></span>

<h3>Description</h3>

<p>This function unscales the values of a scaled design (values in [0,1]).
The unscaling can be made by the inverse Rosenblatt transformation (by applying the empirical quantile function given by another design) or by translating the design from maximum and minimum values (given for each variable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unscaleDesign(design, min=NULL, max=NULL, uniformize=FALSE, InitialDesign=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unscaleDesign_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) corresponding to the design of experiments to unscale</p>
</td></tr>
<tr><td><code id="unscaleDesign_+3A_min">min</code></td>
<td>
<p>the vector of minimal bounds of each design variable</p>
</td></tr>
<tr><td><code id="unscaleDesign_+3A_max">max</code></td>
<td>
<p>the vector of maximal bounds of each design variable</p>
</td></tr>
<tr><td><code id="unscaleDesign_+3A_uniformize">uniformize</code></td>
<td>
<p>boolean: TRUE to use the inverse Rosenblatt transformation (the min and max vectors are useless in this case). If FALSE (default value), the translation from max and min values is applied</p>
</td></tr>
<tr><td><code id="unscaleDesign_+3A_initialdesign">InitialDesign</code></td>
<td>
<p>If the inverse Rosenblatt transformation is applied (uniformize = TRUE): a matrix (or a data.frame) corresponding to the design which gives the empirical quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>design</code></td>
<td>
<p>the unscaled design</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>the vector of minimal bounds that has been used</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>the vector of maximal bounds that has been used</p>
</td></tr>
<tr><td><code>uniformize</code></td>
<td>
<p>the value of this boolean argument</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Iooss</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- 2
  n &lt;- 100
  x &lt;- matrix(rnorm(d*n), ncol=d)
  xscale &lt;- scaleDesign(x, uniformize=TRUE)
  xunscale1 &lt;- unscaleDesign(xscale$design, uniformize=TRUE, InitialDesign=x)
  xunscale2 &lt;- unscaleDesign(xscale$design, 
  min=c(min(x[,1]), min(x[,2])), max = c(max(x[,1]), max(x[,2])))
  par(mfrow=c(2,2))
  plot(x) ; plot(xscale$design)
  plot(xunscale1$design) ; plot(xunscale2$design) 
</code></pre>

<hr>
<h2 id='wspDesign'>WSP algorithm</h2><span id='topic+wspDesign'></span>

<h3>Description</h3>

<p>The WSP (Wooton, Sergent, Phan-Tan-Luu) algorithm is an iterative algorithm based on suppression of some experiments from an initial design in each step. WSP leads to a space filling design</p>


<h3>Usage</h3>

<pre><code class='language-R'>wspDesign(design, dmin, init = "center")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wspDesign_+3A_design">design</code></td>
<td>
<p>a matrix (or a data.frame) corresponding to the design of experiments</p>
</td></tr>
<tr><td><code id="wspDesign_+3A_dmin">dmin</code></td>
<td>
<p>a minimum bound for mindist value of the final design</p>
</td></tr> 
<tr><td><code id="wspDesign_+3A_init">init</code></td>
<td>
<p>defines the initialization point (input coordinates) of the algorithm: 
&quot;center&quot; (default value) takes the central point of the domain
&quot;random&quot; takes a random point inside the domain</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WSP enables to create a design D which is such that mindist(D)&gt;dmin. 
However, it cannot assess the number of experiments. 
Similarly to straussDesign function, WSP is a powerful algorithm to construct 
space filling designs in high dimension
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>InitialDesign</code></td>
<td>
<p>the starting design</p>
</td></tr>
<tr><td><code>dmin</code></td>
<td>
<p>minimum bound for mindist value of the final design</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the matrix of the final design</p>
</td></tr>
<tr><td><code>ResidualDesign</code></td>
<td>
<p>the matrix of the residual design (points of 
InitialDesign not in design)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G. Damblin &amp; B. Iooss</p>


<h3>References</h3>

<p>J. Santiago, M. Claeys-Bruno, M.Sergent (2012). Construction of space filling 
designs using WSP algorithm for high dimensional spaces,
<em>Chenometrics and Intelligent Laboratory Systems</em>, 113:26-31.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 2
n &lt;- 100
X &lt;- matrix(runif(n*dimension), n, dimension)
m &lt;- wspDesign(X, 0.1)
plot(m$design)
xDRDN(m, letter = "T", dgts = 2, range = c(-10, 10))
</code></pre>

<hr>
<h2 id='xDRDN'>Extract a Design and Give it a Range and Dimnames</h2><span id='topic+xDRDN'></span>

<h3>Description</h3>

<p>Extract a design contained in a list (i.e. with a <code class="reqn">design</code> item), adjust the range, give it dimnames and finally round the values to a certain number of digits. Colnames will look like (<code>A,B,C</code>), (<code>X1,X2,X3</code>), (<code>X01,X02,X03</code>), (<code>X001,X002,X003</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xDRDN(obj, width = 1, letter = "X", dgts = NULL, range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xDRDN_+3A_obj">obj</code></td>
<td>
<p> a list that contains a <code>design</code> item. Matrix or data.frame are also accepted </p>
</td></tr>
<tr><td><code id="xDRDN_+3A_width">width</code></td>
<td>
<p> the digit width in colnames (to write for instance  X1, X01, X001). If 0, colnames are filled with capital and small letters (without letters <code>I</code> and <code>i</code>) up to 50 columns </p>
</td></tr>
<tr><td><code id="xDRDN_+3A_letter">letter</code></td>
<td>
<p> the generic letter used in colnames </p>
</td></tr>
<tr><td><code id="xDRDN_+3A_dgts">dgts</code></td>
<td>
<p> the number of digits to which the design is rounded </p>
</td></tr>
<tr><td><code id="xDRDN_+3A_range">range</code></td>
<td>
<p> a vector <code>c(min, max)</code> to adjust the range of the design. The default <code>NULL</code> keeps the original range. Special ranges <code>c(0, 0)</code> and <code>c(1, 1)</code> are not accepted </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rounded matrix or a data.frame with appropriate dimnames and an adjusted range. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xDRDN(lhsDesign(5, 12))
xDRDN(lhsDesign(5, 12), width = 2, letter = "V", dgts = 2, range = c(-10, 10))
head(xDRDN(olhDesign(50, range = c(1,1)), width = 0, letter = "Z"), 3)
head(xDRDN(olhDesign(51, range = c(1,1)), width = 0, letter = "Z"), 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
