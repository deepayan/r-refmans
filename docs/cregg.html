<!DOCTYPE html><html><head><title>Help for package cregg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cregg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cj'><p>Simple Conjoint Analyses and Visualization</p></a></li>
<li><a href='#amce'><p>Tidy estimation of AMCEs</p></a></li>
<li><a href='#amce_diffs'><p>Preference Heterogeneity Diagnostics</p></a></li>
<li><a href='#cj_df'><p>Create a &ldquo;cj_df&rdquo; data frame</p></a></li>
<li><a href='#cj_freqs'><p>Conjoint feature frequencies</p></a></li>
<li><a href='#cj_tidy'><p>Tidy a conjoint dataset</p></a></li>
<li><a href='#immigration'><p>Immigration Conjoint Experiment Dataset from Hainmueller et. al. (2014)</p></a></li>
<li><a href='#mm'><p>Marginal Means</p></a></li>
<li><a href='#plot.cj_amce'><p>Plot AMCE estimates, MM descriptives, and frequency plots</p></a></li>
<li><a href='#taxes'><p>Tax Preference Conjoint Experiment Dataset from Ballard-Rosa et al. (2016)</p></a></li>
<li><a href='#wide_conjoint'><p>Example of a raw, &ldquo;wide&rdquo; conjoint dataset to demonstrate functionality of <code>cj_tidy</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simple Conjoint Tidying, Analysis, and Visualization</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-06-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Simple tidying, analysis, and visualization of conjoint (factorial) experiments, including estimation and visualization of average marginal component effects ('AMCEs') and marginal means ('MMs') for weighted and un-weighted survey data, along with useful reference category diagnostics and statistical tests. Estimation of 'AMCEs' is based upon methods described by Hainmueller, Hopkins, and Yamamoto (2014) &lt;<a href="https://doi.org/10.1093%2Fpan%2Fmpt024">doi:10.1093/pan/mpt024</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/leeper/cregg">https://github.com/leeper/cregg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/leeper/cregg/issues">https://github.com/leeper/cregg/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, sandwich (&ge; 2.4-0), survey (&ge; 3.33), lmtest, ggplot2
(&ge; 2.0), ggstance, scales, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-28 20:56:31 UTC; THOMAS</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas J. Leeper <a href="https://orcid.org/0000-0003-4097-6326"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Matthew Barnfield [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas J. Leeper &lt;thosjleeper@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-28 21:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='cj'>Simple Conjoint Analyses and Visualization</h2><span id='topic+cj'></span><span id='topic+cregg-package'></span><span id='topic+cregg'></span>

<h3>Description</h3>

<p>Simple analyses of conjoint (factorial) experiments and visualization of results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cj(
  data,
  formula,
  id = ~0,
  weights = NULL,
  estimate = c("amce", "frequencies", "mm", "amce_differences", "mm_differences"),
  feature_order = NULL,
  feature_labels = NULL,
  level_order = c("ascending", "descending"),
  by = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cj_+3A_data">data</code></td>
<td>
<p>A data frame containing variables specified in <code>formula</code>. All RHS variables should be factors; the base level for each will be used in estimation and for AMCEs the base level's AMCE will be zero. Optionally, this can instead be an object of class &ldquo;survey.design&rdquo; returned by <code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="cj_+3A_formula">formula</code></td>
<td>
<p>A formula specifying a model to be estimated. ; all levels across features should be unique. For <code>estimate = "amce"</code> in a constrained conjoint design, two-way interactions can be specified to handle constraints between factors in the design. These are detected automatically. Higher-order constraints are not allowed and interactions are ignored for all other values of <code>estimate</code> as constraints are irrelevant to those statistics.</p>
</td></tr>
<tr><td><code id="cj_+3A_id">id</code></td>
<td>
<p>An RHS formula specifying a variable holding respondent identifiers, to be used for clustering standard errors.</p>
</td></tr>
<tr><td><code id="cj_+3A_weights">weights</code></td>
<td>
<p>An (optional) RHS formula specifying a variable holding survey weights.</p>
</td></tr>
<tr><td><code id="cj_+3A_estimate">estimate</code></td>
<td>
<p>A character string specifying an estimate type. Current options are average marginal component effects (or AMCEs, &ldquo;amce&rdquo;, estimated via <code><a href="#topic+amce">amce</a></code>), display frequencies (&ldquo;frequncies&rdquo;, estimated via <code><a href="#topic+cj_freqs">cj_freqs</a></code>), marginal means (or AMMs, &ldquo;mm&rdquo;, estimated via <code><a href="#topic+mm">mm</a></code>), differences in MMs (&ldquo;mm_differences&rdquo;, via <code><a href="#topic+mm_diffs">mm_diffs</a></code>), or differences in AMCEs (&ldquo;amce_differences&rdquo;, via <code><a href="#topic+amce_diffs">amce_diffs</a></code>). Additional options may be made available in the future. Non-ambiguous abbreviations are allowed.</p>
</td></tr>
<tr><td><code id="cj_+3A_feature_order">feature_order</code></td>
<td>
<p>An (optional) character vector specifying the names of feature (RHS) variables in the order they should be encoded in the resulting data frame.</p>
</td></tr>
<tr><td><code id="cj_+3A_feature_labels">feature_labels</code></td>
<td>
<p>A named list of &ldquo;fancy&rdquo; feature labels to be used in output. By default, the function looks for a &ldquo;label&rdquo; attribute on each variable in <code>formula</code> and uses that for pretty printing. This argument overrides those attributes or otherwise provides fancy labels for this purpose. This should be a list with names equal to variables on the righthand side of <code>formula</code> and character string values; arguments passed here override variable attributes.</p>
</td></tr>
<tr><td><code id="cj_+3A_level_order">level_order</code></td>
<td>
<p>A character string specifying levels (within each feature) should be ordered increasing or decreasing in the final output. This is mostly only consequential for plotting via <code><a href="#topic+plot.cj_mm">plot.cj_mm</a></code>, etc.</p>
</td></tr>
<tr><td><code id="cj_+3A_by">by</code></td>
<td>
<p>A formula containing only RHS variables, specifying grouping factors over which to perform estimation.</p>
</td></tr>
<tr><td><code id="cj_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+amce">amce</a></code>, <code><a href="#topic+cj_freqs">cj_freqs</a></code>, <code><a href="#topic+mm">mm</a></code>, <code><a href="#topic+mm_diffs">mm_diffs</a></code>, or <code><a href="#topic+amce_diffs">amce_diffs</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main function <code>cj</code> is a convenience function wrapper around the underlying estimation functions that provide for average marginal component effects (AMCEs), by default, via the <code><a href="#topic+amce">amce</a></code> function, marginal means (MMs) via the <code><a href="#topic+mm">mm</a></code> function, and display frequencies via <code><a href="#topic+cj_freqs">cj_freqs</a></code> and <code><a href="#topic+cj_props">cj_props</a></code>. Additional estimands may be supported in the future through their own functions and through the <code>cj</code> interface. Plotting is provided via ggplot2 for all types of estimates.
</p>
<p>The only additional functionality provided by <code>cj</code> over the underlying functions is the <code>by</code> argument, which will perform operations on subsets of <code>data</code>, returning a single data frame. This can be useful, for example, for evaluating profile spillover effects and subgroup results, or in any situation where one might be inclined to use a <code>for</code> loop or <code>lapply</code>, calling <code>cj</code> repeatedly on subgroups.
</p>
<p>Note: Some features of cregg (namely, the <code><a href="#topic+amce_diffs">amce_diffs</a></code>) function, or <code>estimate = "amce_diff"</code> here) only work with full factorial conjoint experiments. Designs involving two-way constraints between features are supported simply by expressing interactions between constrained terms in <code>formula</code> (again, except for <code>amce_diffs</code>). Higher-order constraints may be supported in the future.
</p>


<h3>Value</h3>

<p>A data frame with special class to facilitate plotting (e.g., &ldquo;cj_amce&rdquo;, &ldquo;cj_mm&rdquo;, etc.)
</p>


<h3>Author(s)</h3>

<p>Thomas J. Leeper &lt;thosjleeper@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Functions: <code><a href="#topic+amce">amce</a></code>, <code><a href="#topic+mm">mm</a></code>, <code><a href="#topic+cj_freqs">cj_freqs</a></code>, <code><a href="#topic+mm_diffs">mm_diffs</a></code>, <code><a href="#topic+plot.cj_amce">plot.cj_amce</a></code>, <code><a href="#topic+cj_tidy">cj_tidy</a></code>
Data: <code><a href="#topic+immigration">immigration</a></code>, <code><a href="#topic+taxes">taxes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
requireNamespace("ggplot2")
data("immigration")
immigration$contest_no &lt;- factor(immigration$contest_no)
data("taxes")

# calculate MMs
f1 &lt;- ChosenImmigrant ~ Gender + Education + 
         LanguageSkills + CountryOfOrigin + Job + JobExperience + 
         JobPlans + ReasonForApplication + PriorEntry
d1 &lt;- cj(immigration, f1, id = ~ CaseID, estimate = "mm", h0 = 0.5)
# plot MMs
plot(d1, vline = 0.5)

# calculate MMs for survey-weighted data
d1 &lt;- cj(taxes, chose_plan ~ taxrate1 + taxrate2 + taxrate3 +
         taxrate4 + taxrate5 + taxrate6 + taxrev, id = ~ ID,
         weights = ~ weight, estimate = "mm", h0 = 0.5)
# plot MMs
plot(d1, vline = 0.5)

# MMs split by profile number
stacked &lt;- cj(immigration, f1, id = ~ CaseID,
              estimate = "mm", by = ~ contest_no)

## plot with grouping
plot(stacked, group = "contest_no", vline = 0.5, feature_headers = FALSE)

## plot with facetting
plot(stacked) + ggplot2::facet_wrap(~ contest_no, nrow = 1L)

# estimate AMCEs
d2 &lt;- cj(immigration, f1, id = ~ CaseID)

# plot AMCEs
plot(d2)

## subgroup analysis
immigration$ethnosplit &lt;- cut(immigration$ethnocentrism, 2)
x &lt;- cj(na.omit(immigration), ChosenImmigrant ~ Gender + Education + LanguageSkills,
        id = ~ CaseID, estimate = "mm", h0 = 0.5, by = ~ ethnosplit)
plot(x, group = "ethnosplit", vline = 0.5)

# combinations of/interactions between features
immigration$language_entry &lt;- 
  interaction(immigration$LanguageSkills, immigration$PriorEntry, sep = "_")

## higher-order MMs for feature combinations
cj(immigration, ChosenImmigrant ~ language_entry,
   id = ~CaseID, estimate = "mm", h0 = 0.5)

## constrained designs
## in a constrained design, some cells are unobserved:
subset(cj_props(immigration, ~ Job + Education), Proportion == 0)
## MMs and AMCEs only use data from observed cells
## In `immigraation`, this means while the MM for `Job == "Janitor"` is an average 
## across all levels of Education:
mm(subset(immigration, Job == "Janitor"), ChosenImmigrant ~ Education)
## the MM for `Job == "Doctor"` is an average across only 3 levels of education:
mm(subset(immigration, Job == "Doctor"), ChosenImmigrant ~ Education)
## Use `cj_props()` to see constraints:
subset(cj_props(immigration, ~ Job + Education), Job == "Doctor" &amp; Proportion != 0)

## Substantively, the MM of "Doctor" might be higher than other levels of `Job`
## this could be due to the feature itself or due to the fact that it is constrained
## with a different subset of other feature levels than alternative levels of `Job`
## this may mean analysts want to report MMs (or AMCEs) only for the unconstrained levels:
elev &lt;- c("Two-Year College", "College Degree", "Graduate Degree")
jlev &lt;- c("Financial Analyst", "Computer Programmer", "Research Scientist", "Doctor")
mm(subset(immigration, Education %in% elev), ChosenImmigrant ~ Job)
mm(subset(immigration, Job %in% jlev), ChosenImmigrant ~ Education)
## or, present estimates excluding constrained levels:
mm(subset(immigration, !Education %in% elev), ChosenImmigrant ~ Job)
mm(subset(immigration, !Job %in% jlev), ChosenImmigrant ~ Education)

</code></pre>

<hr>
<h2 id='amce'>Tidy estimation of AMCEs</h2><span id='topic+amce'></span><span id='topic+amce_by_reference'></span>

<h3>Description</h3>

<p>Estimate AMCEs for a conjoint analysis and return a tidy data frame of results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amce(
  data,
  formula,
  id = ~0,
  weights = NULL,
  feature_order = NULL,
  feature_labels = NULL,
  level_order = c("ascending", "descending"),
  alpha = 0.05,
  ...
)

amce_by_reference(data, formula, variable, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amce_+3A_data">data</code></td>
<td>
<p>A data frame containing variables specified in <code>formula</code>. All RHS variables should be factors; the base level for each will be used in estimation and its reported AMCE will be NA (for printing). Optionally, this can instead be an object of class &ldquo;survey.design&rdquo; returned by <code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="amce_+3A_formula">formula</code></td>
<td>
<p>A formula specifying an AMCE model to be estimated. All variables should be factors; all levels across features should be unique. Two-way constraints can be specified with an asterisk (*) between RHS features. The specific constrained level pairs within these features are then detected automatically. Higher-order constraints are not allowed.</p>
</td></tr>
<tr><td><code id="amce_+3A_id">id</code></td>
<td>
<p>An RHS formula specifying a variable holding respondent identifiers, to be used for clustering standard errors. By default, data are unclustered.</p>
</td></tr>
<tr><td><code id="amce_+3A_weights">weights</code></td>
<td>
<p>An (optional) RHS formula specifying a variable holding survey weights.</p>
</td></tr>
<tr><td><code id="amce_+3A_feature_order">feature_order</code></td>
<td>
<p>An (optional) character vector specifying the names of feature (RHS) variables in the order they should be encoded in the resulting data frame.</p>
</td></tr>
<tr><td><code id="amce_+3A_feature_labels">feature_labels</code></td>
<td>
<p>A named list of &ldquo;fancy&rdquo; feature labels to be used in output. By default, the function looks for a &ldquo;label&rdquo; attribute on each variable in <code>formula</code> and uses that for pretty printing. This argument overrides those attributes or otherwise provides fancy labels for this purpose. This should be a list with names equal to variables on the righthand side of <code>formula</code> and character string values; arguments passed here override variable attributes.</p>
</td></tr>
<tr><td><code id="amce_+3A_level_order">level_order</code></td>
<td>
<p>A character string specifying levels (within each feature) should be ordered increasing or decreasing in the final output. This is mostly only consequential for plotting via <code><a href="#topic+plot.cj_mm">plot.cj_mm</a></code>, etc.</p>
</td></tr>
<tr><td><code id="amce_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value indicating the significance level at which to calculate confidence intervals for the MMs (by default 0.95, meaning 95-percent CIs are returned).</p>
</td></tr>
<tr><td><code id="amce_+3A_...">...</code></td>
<td>
<p>For <code>amce</code>: additional arguments to <code><a href="stats.html#topic+glm">glm</a></code> or <code><a href="survey.html#topic+svyglm">svyglm</a></code>, the latter being used if <code>weights</code> is non-NULL. For <code>amce_by_reference</code>: additional arguments passed to <code>amce</code>.</p>
</td></tr>
<tr><td><code id="amce_+3A_variable">variable</code></td>
<td>
<p>An RHS formula containing a single factor variable from <code>formula</code>. This will be used by <code>amce_by_reference</code> to estimate AMCEs relative to each possible factor level as a reference category. If more than one RHS variables are specified, the first will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>amce</code> provides estimates of AMCEs (or rather, average marginal effects for each feature level). Two-way constraints can be specified with an asterisk (*) between features. The specific constrained level pairs within these features are then detected automatically. The function can also be used for calculating average component interaction effects when combined with <code>interaction</code>, and for balance testing by specifying a covariate rather outcome on the left-hand side of <code>formula</code>. See examples.
</p>
<p><code>amce_by_reference</code> provides a tool for quick sensitivity analysis. AMCEs are defined relative to an arbitrary reference category (i.e., feature level). This function will loop over all feature levels (for a specified feature) to show how interpretation will be affected by choice of reference category. The resulting data frame will be a stacked result from <code>amce</code>, containing an additional <code>REFERENCE</code> column specifying which level of <code>variable</code> was used as the reference category. In unconstrained conjoint designs, only AMCEs for <code>variable</code> will vary by reference category; in constrained designs, AMCEs for any factor constrained by <code>variable</code> may also vary.
</p>
<p>Users may desire to specify a <code>family</code> argument via <code>...</code>, which should be a &ldquo;family&rdquo; object such as <code>gaussian</code>. Sensible alternatives are <code>binomial</code> (for binary outcomes) and quasibinomial (for weighted survey data). See <code><a href="stats.html#topic+family">family</a></code> for details. In such cases, effects are always reported on the link (not outcome) scale.
</p>


<h3>Value</h3>

<p>A data frame of class &ldquo;cj_amce&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amce_diffs">amce_diffs</a></code> <code><a href="#topic+mm">mm</a></code> <code><a href="#topic+plot.cj_amce">plot.cj_amce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("taxes")
# estimating AMCEs
amce(taxes, chose_plan ~ taxrate1 + taxrate2 + taxrate3 + 
     taxrate4 + taxrate5 + taxrate6 + taxrev, id = ~ ID)


data("immigration")
# estimating AMCEs with constraints
amce(immigration, ChosenImmigrant ~ Gender + ReasonForApplication * CountryOfOrigin,
     id = ~CaseID)

# estimating average component interaction effects (AMCEs of feature combinations)
immigration$language_entry &lt;- interaction(immigration$LanguageSkills, 
                                          immigration$PriorEntry, sep = "_")
amce(immigration,ChosenImmigrant ~ language_entry, id = ~CaseID)

# balance testing example
plot(amce(immigration[!is.na(immigration$ethnocentrism),],
     ethnocentrism ~ Gender + Education + LanguageSkills, id = ~ CaseID))

# reference category sensitivity
x &lt;- amce_by_reference(immigration, ChosenImmigrant ~ LanguageSkills + Education, 
       variable = ~ LanguageSkills, id = ~ CaseID)
# plot
plot(x)

</code></pre>

<hr>
<h2 id='amce_diffs'>Preference Heterogeneity Diagnostics</h2><span id='topic+amce_diffs'></span><span id='topic+cj_anova'></span><span id='topic+mm_diffs'></span>

<h3>Description</h3>

<p>Tests for preference heterogeneity in conjoint experiments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amce_diffs(
  data,
  formula,
  by,
  id = ~0,
  weights = NULL,
  feature_order = NULL,
  feature_labels = NULL,
  level_order = c("ascending", "descending"),
  alpha = 0.05,
  ...
)

cj_anova(data, formula, id = NULL, weights = NULL, by = NULL, ...)

mm_diffs(
  data,
  formula,
  by,
  id = ~0,
  weights = NULL,
  feature_order = NULL,
  feature_labels = NULL,
  level_order = c("ascending", "descending"),
  alpha = 0.05,
  h0 = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amce_diffs_+3A_data">data</code></td>
<td>
<p>A data frame containing variables specified in <code>formula</code>. All RHS variables should be factors; the base level for each will be used in estimation and for AMCEs the base level's AMCE will be NA. Optionally, this can instead be an object of class &ldquo;survey.design&rdquo; returned by <code><a href="survey.html#topic+svydesign">svydesign</a></code>.</p>
</td></tr>
<tr><td><code id="amce_diffs_+3A_formula">formula</code></td>
<td>
<p>A formula specifying a model to be estimated. All variables should be factors; all levels across features should be unique.</p>
</td></tr>
<tr><td><code id="amce_diffs_+3A_by">by</code></td>
<td>
<p>A formula containing only RHS variables, specifying grouping factors over which to perform estimation. For <code>amce_diffs</code>, this can be a factor or something coercable to factor. For <code>mm_diffs</code>, differences are calculated against the base level of this variable.</p>
</td></tr>
<tr><td><code id="amce_diffs_+3A_id">id</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="amce_diffs_+3A_weights">weights</code></td>
<td>
<p>An (optional) RHS formula specifying a variable holding survey weights.</p>
</td></tr>
<tr><td><code id="amce_diffs_+3A_feature_order">feature_order</code></td>
<td>
<p>An (optional) character vector specifying the names of feature (RHS) variables in the order they should be encoded in the resulting data frame.</p>
</td></tr>
<tr><td><code id="amce_diffs_+3A_feature_labels">feature_labels</code></td>
<td>
<p>A named list of &ldquo;fancy&rdquo; feature labels to be used in output. By default, the function looks for a &ldquo;label&rdquo; attribute on each variable in <code>formula</code> and uses that for pretty printing. This argument overrides those attributes or otherwise provides fancy labels for this purpose. This should be a list with names equal to variables on the righthand side of <code>formula</code> and character string values; arguments passed here override variable attributes.</p>
</td></tr>
<tr><td><code id="amce_diffs_+3A_level_order">level_order</code></td>
<td>
<p>A character string specifying levels (within each feature) should be ordered increasing or decreasing in the final output. This is mostly only consequential for plotting via <code><a href="#topic+plot.cj_mm">plot.cj_mm</a></code>, etc.</p>
</td></tr>
<tr><td><code id="amce_diffs_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value indicating the significance level at which to calculate confidence intervals for the MMs (by default 0.95, meaning 95-percent CIs are returned).</p>
</td></tr>
<tr><td><code id="amce_diffs_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+amce">amce</a></code>, <code><a href="#topic+cj_freqs">cj_freqs</a></code>, or <code><a href="#topic+mm">mm</a></code>.</p>
</td></tr>
<tr><td><code id="amce_diffs_+3A_h0">h0</code></td>
<td>
<p>A numeric value specifying a null hypothesis value to use when generating z-statistics and p-values (only used for <code>mm_diffs</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cj_anova</code> takes a model formula (&ldquo;reduced&rdquo; model) and generates a &ldquo;full&rdquo; model with two-way interactions between the variables specified in <code>by</code> and all RHS variables in <code>formula</code>, then computes an F-test comparing the two models, providing a test for whether preferences vary across levels of <code>by</code>. This is, in essence, a test of whether all such interaction coefficients are distinguishable from zero. (Because the test depends on overall model fit, not the coefficient variances, clustering is irrelevant.)
</p>
<p><code>mm_diffs</code> provides a data frame of differences in marginal means (literally differencing the results from <code><a href="#topic+mm">mm</a></code> across levels of <code>by</code>. This provides the clearest direct measure of preference differences from a conjoint design.
</p>
<p><code>amce_diffs</code> provides a data frame of differences in AMCEs (the coefficient on an interaction between each RHS factor and the variable in <code>by</code>). This provides an estimate of the difference in causal effects of each factor level relative to the baseline level (i.e., the difference in conditional AMCEs). This quantity is easily misinterpreted as the difference in preferences, which it is not. Rather it is a difference in the effect of the factor on preferences relative to the baseline/reference category of that feature. If preferences in the reference category differ across levels of <code>by</code>, the the difference in conditional AMCEs will have an unpredictable sign and significance, making differences in marginal means a more sensible quantity of interest. See <code><a href="#topic+amce_by_reference">amce_by_reference</a></code> for a diagnostic.
</p>
<p>Note: <code>amce_diffs</code> does not work with constrained designs. To obtain such differences, subset the design by constraints and calculate differences within each subset.
</p>


<h3>Value</h3>

<p><code>amce_diffs</code> and <code>mm_diffs</code> return a data frame similar to the one returned by <code><a href="#topic+cj">cj</a></code>, including a <code>BY</code> column (with the value &ldquo;Difference&rdquo;) for easy merging with results returned by that function.
</p>
<p><code>cj_anova</code> returns an <code><a href="stats.html#topic+anova">anova</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Thomas J. Leeper &lt;thosjleeper@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amce">amce</a></code> <code><a href="#topic+mm">mm</a></code> <code><a href="#topic+cj_freqs">cj_freqs</a></code> <code><a href="#topic+plot.cj_amce">plot.cj_amce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("immigration")
immigration$contest_no &lt;- factor(immigration$contest_no)
# Test for heterogeneity by profile order
cj_anova(immigration, ChosenImmigrant ~ Gender + Education + LanguageSkills, by = ~ contest_no)

# Test for heterogeneity by CountryOfOrigin feature
cj_anova(immigration, ChosenImmigrant ~ Gender + Education, by = ~ CountryOfOrigin)


# Differences in MMs by Gender feature
mm_diffs(immigration, ChosenImmigrant ~ LanguageSkills + Education, ~ Gender, id = ~ CaseID)

# Differences in AMCEs by Gender feature (i.e., feature interactions)
amce_diffs(immigration, ChosenImmigrant ~ LanguageSkills + Education, ~ Gender, id = ~ CaseID)


# preferences differ for Male and Female immigrants with 'Broken English' ability
(m1 &lt;- mm_diffs(immigration, ChosenImmigrant ~ LanguageSkills, ~ Gender, id = ~ CaseID))

# yet differences in conditional AMCEs  depend on the reference category
amce_diffs(immigration, ChosenImmigrant ~ LanguageSkills, ~ Gender, id = ~ CaseID)
immigration$LanguageSkills2 &lt;- relevel(immigration$LanguageSkills, "Used Interpreter")
amce_diffs(immigration, ChosenImmigrant ~ LanguageSkills2, ~ Gender, id = ~ CaseID)

# while differences in MMs do not depend on the reference cateory
(m2 &lt;- mm_diffs(immigration, ChosenImmigrant ~ LanguageSkills2, ~ Gender, id = ~ CaseID))

</code></pre>

<hr>
<h2 id='cj_df'>Create a &ldquo;cj_df&rdquo; data frame</h2><span id='topic+cj_df'></span><span id='topic+cj_df.data.frame'></span><span id='topic++5B.cj_df'></span>

<h3>Description</h3>

<p>A simple data frame extension that preserves attributes during subsetting operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cj_df(x)

## S3 method for class 'data.frame'
cj_df(x)

## S3 method for class 'cj_df'
x[i, j, drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cj_df_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="cj_df_+3A_i">i</code></td>
<td>
<p>See <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code></p>
</td></tr>
<tr><td><code id="cj_df_+3A_j">j</code></td>
<td>
<p>See <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code></p>
</td></tr>
<tr><td><code id="cj_df_+3A_drop">drop</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An data frame with additional &ldquo;cj_df&rdquo; class, which has subsetting methods that preserve variables attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- data.frame(a = 1:3, b = 4:6)
attr(x1$a, "label") &lt;- "Variable A"

# cj_df() returns a data frame
inherits(x1, "data.frame")
class(x1)

# attributes dropped for data frames
attr(x1[1:2,]$a, "label")

# attributes preserved with a cj_df
attr(cj_df(x1)[1:2,]$a, "label")

</code></pre>

<hr>
<h2 id='cj_freqs'>Conjoint feature frequencies</h2><span id='topic+cj_freqs'></span><span id='topic+cj_props'></span><span id='topic+cj_table'></span>

<h3>Description</h3>

<p>Tabulate and visualize conjoint features, and their display frequencies and proportions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cj_freqs(
  data,
  formula,
  id = NULL,
  weights = NULL,
  feature_order = NULL,
  feature_labels = NULL,
  level_order = c("ascending", "descending"),
  ...
)

cj_props(data, formula, id, weights = NULL, margin = NULL, ...)

cj_table(
  data,
  formula,
  feature_order = NULL,
  feature_labels = NULL,
  level_order = c("ascending", "descending"),
  include_reference = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cj_freqs_+3A_data">data</code></td>
<td>
<p>A data frame containing variables specified in <code>formula</code>. All RHS variables should be factors; all levels across features should be unique.</p>
</td></tr>
<tr><td><code id="cj_freqs_+3A_formula">formula</code></td>
<td>
<p>An RHS formula specifying conjoint features to tabulate. All RHS variables should be factors; all levels across features should be unique.</p>
</td></tr>
<tr><td><code id="cj_freqs_+3A_id">id</code></td>
<td>
<p>An RHS formula specifying a variable holding respondent identifiers, to be used for clustering standard errors. By default, data are unclustered.</p>
</td></tr>
<tr><td><code id="cj_freqs_+3A_weights">weights</code></td>
<td>
<p>An (optional) RHS formula specifying a variable holding survey weights.</p>
</td></tr>
<tr><td><code id="cj_freqs_+3A_feature_order">feature_order</code></td>
<td>
<p>An (optional) character vector specifying the names of feature (RHS) variables in the order they should be encoded in the resulting data frame.</p>
</td></tr>
<tr><td><code id="cj_freqs_+3A_feature_labels">feature_labels</code></td>
<td>
<p>A named list of &ldquo;fancy&rdquo; feature labels to be used in output. By default, the function looks for a &ldquo;label&rdquo; attribute on each variable in <code>formula</code> and uses that for pretty printing. This argument overrides those attributes or otherwise provides fancy labels for this purpose. This should be a list with names equal to variables on the righthand side of <code>formula</code> and character string values; arguments passed here override variable attributes.</p>
</td></tr>
<tr><td><code id="cj_freqs_+3A_level_order">level_order</code></td>
<td>
<p>A character string specifying levels (within each feature) should be ordered increasing or decreasing in the final output. This is mostly only consequential for plotting via <code><a href="#topic+plot.cj_mm">plot.cj_mm</a></code>, etc.</p>
</td></tr>
<tr><td><code id="cj_freqs_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="cj_freqs_+3A_margin">margin</code></td>
<td>
<p>A numeric value passed to <code>prop.table</code>. If <code>NULL</code> overall proportions are calculated.</p>
</td></tr>
<tr><td><code id="cj_freqs_+3A_include_reference">include_reference</code></td>
<td>
<p>A logical indicating whether to include a &ldquo;reference&rdquo; column that indicates whether a feature level is the reference category for that feature. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide related but slightly different functionality. <code>cj_table</code> simply creates a data frame of features and their levels, which is useful for printing. <code>cj_props</code> provides tidy proportion tables to examine cross-feature restrictions in conjoint designs that are not equally randomized. This enables, for example, tabulation and visualization of complete restrictions (where combinations of two or more features are not permitted), as well as calculation of AMCEs for constrained designs appropriately weighted by the display proportions for particular combinations of features.
</p>
<p><code>cj_freqs</code> provides <em>marginal</em> display frequencies, which are a descriptive check on the presentation of individual conjoint features (for example, to ensure equal or intentionally unequal appearance of levels). This is mostly useful for plotting functionality provided in <code><a href="#topic+plot.cj_freqs">plot.cj_freqs</a></code>, which provides barcharts for the frequency with which each level of each feature was presented.
</p>


<h3>Value</h3>

<p>A data frame of class &ldquo;cj_freqs&rdquo;, &ldquo;cj_props&rdquo;, etc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cj_mm">plot.cj_mm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immigration)
# identify all levels
cj_table(immigration, ~ Gender + Education + LanguageSkills)
cj_table(immigration, ~ Gender + Education + LanguageSkills, include_ref = TRUE)

# display frequencies
(f &lt;- cj_freqs(immigration, ~ Gender + Education + LanguageSkills, id = ~ CaseID))

# restrictions
## check display proportions
cj_props(immigration, ~ Job, id = ~ CaseID)
## check which combinations were not allowed
subset(cj_props(immigration, ~ Job + Education, id = ~ CaseID), Proportion == 0)


# plotting
(p &lt;- plot(f))

## change ggplot2 theme
p + ggplot2::theme_bw()

## monochrome bars
p + ggplot2::scale_fill_manual(values = rep("black", 9)) + 
  ggplot2::theme(legend.position = "none")

</code></pre>

<hr>
<h2 id='cj_tidy'>Tidy a conjoint dataset</h2><span id='topic+cj_tidy'></span>

<h3>Description</h3>

<p>Coerce a &ldquo;wide&rdquo; conjoint dataset into a &ldquo;long&rdquo;/&ldquo;tidy&rdquo; one for use with cregg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cj_tidy(data, profile_variables, task_variables, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cj_tidy_+3A_data">data</code></td>
<td>
<p>A data frame containing a conjoint dataset in &ldquo;wide&rdquo; format (see Details).</p>
</td></tr>
<tr><td><code id="cj_tidy_+3A_profile_variables">profile_variables</code></td>
<td>
<p>A named list of two-element lists capturing profile-specific variables (either features, or profile-specific outcomes, like rating scales). For each element in the list, the first element contains vectors of feature variable names for the first profile in each decision task (hereafter, profile &ldquo;A&rdquo;) and the second element contains vectors of feature variable names for the second profile in each decision task (hereafter, profile &ldquo;B&rdquo;). Variables can be specified as character strings or an RHS formula. The names at the highest level are used to name variables in the long/tidy output.</p>
</td></tr>
<tr><td><code id="cj_tidy_+3A_task_variables">task_variables</code></td>
<td>
<p>A named list of vectors of variables constituting task-level variables (i.e., variables that differ by task but not across profiles within a task). Variables can be specified as character strings or an RHS formula. These could be outcome variables, response times, etc.</p>
</td></tr>
<tr><td><code id="cj_tidy_+3A_id">id</code></td>
<td>
<p>An RHS formula specifying a variable holding respondent identifiers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A conjoint survey typically comes to the analyst in a &ldquo;wide&rdquo; form, where the number of rows is equal to the number of survey respondents and columns represent choices and features for each choice task and task profile. For example, a design with 1000 respondents and five forced-choice decision tasks, with 6 features each, will have 1000 rows and 5x2x6 feature columns, plus five forced-choice outcome variable columns recording which alternative was selected for each task. To analyse these data, the data frame needs to be reshaped to &ldquo;long&rdquo; or &ldquo;tidy&rdquo; format, with 1000x5x2 rows, six feature columns, and one outcome column. Multiple outcomes or other task-specific variables would increase the number of columns in the result, as will respondent-varying characteristics which need to be replicated across each decision task and profile.
</p>
<p>This a complex operation because variables vary at three levels: respondent, task, and profile. Thus the reshape is not a simple wide-to-long transformation. It instead requires two reshaping steps, one to create a task-level dataset and a further one to create a profile-level dataset. <code>cj_tidy</code> performs this tidying in two steps, through a single function with an easy-to-use API. Users can specify variable names in the <code>wide</code> format using either character vectors of righthand-side (RHS) formulae. They are equivalent but depending on the naming of variables, character vectors can be easier to specify (e.g., using regular expressions for pattern matching).
</p>
<p>Particular care is needed to decide whether a particular set of &ldquo;wide&rdquo; columns belong in <code>profile_variables</code> or <code>task_variables</code>. This especially applies to outcomes variables. If a variable in the original format records <em>which</em> of the two profiles was chosen (e.g., &ldquo;left&rdquo; and &ldquo;right&rdquo;), it should go in <code>task_variables</code>. If it records whether a profile was chosen (e.g., for each task there is a &ldquo;left_chosen&rdquo; and &ldquo;right_chosen&rdquo; variable), then both variables should go in <code>profile_variables</code> as they vary at the profile level. Similarly, one needs to be careful with the output of <code>cj_tidy</code> to ensure that a task-level variable is further recoded to encode which alternative was selected (see examples).
</p>
<p>Users may find that it is easier to recode features <em>after</em> using <code>cj_tidy</code> rather than before, as it requires recoding only a number of variables equal to the number of features in the design, rather than recoding all &ldquo;wide&rdquo; feature columns before reshaping. Again, however, care should be taken that these variables encode information in the same way so that stacking does not produce a loss of information.
</p>
<p>Finally, <code>data</code> should not use the variable names &ldquo;task&rdquo;, &ldquo;pair&rdquo;, or &ldquo;profile&rdquo;, which are the names of metadata columns created by reshaping.
</p>


<h3>Value</h3>

<p>A data frame with rows equal to the number of respondents times the number of tasks times the number of profiles (fixed at 2), to be fed into any other function in the package. The columns will include the names of elements in <code>profile_variables</code> and <code>task_variables</code>, and <code>id</code>, along with an indicator <code>task</code> (from 1 to the number of tasks), <code>pair</code> (an indicator for each task pair from 1 to the number of pairs), <code>profile</code> (a fator indicator for profile, either &ldquo;A&rdquo; or &ldquo;B&rdquo;), and any other respondent-varying covariates not specified. As such, respondent-varying variables do not need to be specified to <code>cj_tidy</code> at all. 
</p>
<p>The returned data frame carries an additional S3 class (&ldquo;cj_df&rdquo;) with methods that preserve column attributes. See <code><a href="#topic+cj_df">cj_df</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cj">cj</a></code>, <code><a href="#topic+cj_df">cj_df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("wide_conjoint")

# character string interface
## profile_variables
list1 &lt;- list(
 feature1 = list(
     names(wide_conjoint)[grep("^feature1.{1}1", names(wide_conjoint))],
     names(wide_conjoint)[grep("^feature1.{1}2", names(wide_conjoint))]
 ),
 feature2 = list(
     names(wide_conjoint)[grep("^feature2.{1}1", names(wide_conjoint))],
     names(wide_conjoint)[grep("^feature2.{1}2", names(wide_conjoint))]
 ),
 feature3 = list(
     names(wide_conjoint)[grep("^feature3.{1}1", names(wide_conjoint))],
     names(wide_conjoint)[grep("^feature3.{1}2", names(wide_conjoint))]
 ),
 rating = list(
     names(wide_conjoint)[grep("^rating.+1", names(wide_conjoint))],
     names(wide_conjoint)[grep("^rating.+2", names(wide_conjoint))]
 )
)
## task variables
list2 &lt;- list(choice = paste0("choice_", letters[1:4]),
              timing = paste0("timing_", letters[1:4]))

# formula interface
## profile_variables
list1 &lt;- list(
   feature1 = list(
       ~ feature1a1 + feature1b1 + feature1c1 + feature1d1,
       ~ feature1a2 + feature1b2 + feature1c2 + feature1d2
   ),
   feature2 = list(
       ~ feature2a1 + feature2b1 + feature2c1 + feature2d1,
       ~ feature2a2 + feature2b2 + feature2c2 + feature2d2
   ),
   feature3 = list(
       ~ feature3a1 + feature3b1 + feature3c1 + feature3d1,
       ~ feature3a2 + feature3b2 + feature3c2 + feature3d2
   ),
   rating = list(
       ~ rating_a1 + rating_b1 + rating_c1 + rating_d1,
       ~ rating_a2 + rating_b2 + rating_c2 + rating_d2
   )
)
# task variables
list2 &lt;- list(choice = ~ choice_a + choice_b + choice_c + choice_d,
              timing = ~ timing_a + timing_b + timing_c + timing_d)


# perform reshape
str(long &lt;- cj_tidy(wide_conjoint,
                    profile_variables = list1,
                    task_variables = list2,
                    id = ~ respondent))
stopifnot(nrow(long) == nrow(wide_conjoint)*4*2)

# recode outcome so it is coded sensibly
long$chosen &lt;- ifelse((long$profile == "A" &amp; long$choice == 1) | 
                       (long$profile == "B" &amp; long$choice == 2), 1, 0)
# use for analysis
cj(long, chosen ~ feature1 + feature2 + feature3, id = ~ respondent)

## End(Not run)
</code></pre>

<hr>
<h2 id='immigration'>Immigration Conjoint Experiment Dataset from Hainmueller et. al. (2014)</h2><span id='topic+immigration'></span>

<h3>Description</h3>

<p>A dataset containing the results of a conjoint survey of a representative sample of American adults who were asked to choose which hypothetical immigrants they think should be admitted into the United States. Each row corresponds to a single profile presented to the respondent. The dataset results from a mostly full factorial design with restrictions on two combinations of features. (1) Profile immigrants from &lsquo;<span class="samp">&#8288;CountryOfOrigin&#8288;</span>&rsquo; &ldquo;India&rdquo;, &ldquo;Germany&rdquo;, &ldquo;France&rdquo;, &ldquo;Mexico&rdquo;, &ldquo;Philippines&rdquo;, and &ldquo;Poland&rdquo; could be paired only with &lsquo;<span class="samp">&#8288;ReasonForApplication&#8288;</span>&rsquo; &ldquo;Seek better job&rdquo; or &ldquo;Reunite with family&rdquo;; profiles from the remaining countries could be paired with any &lsquo;<span class="samp">&#8288;ReasonForApplication&#8288;</span>&rsquo;. (2) Profile immigrants with &lsquo;<span class="samp">&#8288;Job&#8288;</span>&rsquo; &ldquo;Financial Analyst&rdquo;, &ldquo;Computer Programmer&rdquo;, &ldquo;Research Scientist&rdquo;, or &ldquo;Doctor&rdquo; could not be paired with &lsquo;<span class="samp">&#8288;Education&#8288;</span>&rsquo; levels &ldquo;No Formal&rdquo;, &ldquo;4th Grade&rdquo;, &ldquo;8th Grade&rdquo;, or &ldquo;High School&rdquo;. All other features were fully randomized against all other features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(immigration)
</code></pre>


<h3>Format</h3>

<p>A data frame (with additional &ldquo;cj_df&rdquo; class) with 13960 observations on the following 16 variables.
</p>

<dl>
<dt>&lsquo;<span class="samp">&#8288;CaseID&#8288;</span>&rsquo;</dt><dd><p>a numeric vector indicating the respondent to which the particular profile corresponds</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;contest_no&#8288;</span>&rsquo;</dt><dd><p>a numeric vector indicating the number of the task to which the profile corresponds</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;Education&#8288;</span>&rsquo;</dt><dd><p>a factor with levels &ldquo;No formal&rdquo;, &ldquo;4th grade&rdquo;, &ldquo;8th grade&rdquo;, &ldquo;High school&rdquo;, &ldquo;Two-year college&rdquo;, &ldquo;college Degree&rdquo;, &ldquo;Graduate degree&rdquo;</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;Gender&#8288;</span>&rsquo;</dt><dd><p>a factor with levels &ldquo;Female&rdquo;, &ldquo;Male&rdquo;</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;CountryOfOrigin&#8288;</span>&rsquo;</dt><dd><p>a factor with levels &ldquo;India&rdquo;, &ldquo;Germany&rdquo;, &ldquo;France&rdquo;, &ldquo;Mexico&rdquo;, &ldquo;Philippines&rdquo;, &ldquo;Poland&rdquo;, &ldquo;China&rdquo;, &ldquo;Sudan&rdquo;, &ldquo;Somalia&rdquo;, &ldquo;Iraq&rdquo;</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;ReasonForApplication&#8288;</span>&rsquo;</dt><dd><p>a factor with levels &ldquo;Reunite with family&rdquo;, &ldquo;Seek better job&rdquo;, &ldquo;Escape persecution&rdquo;</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;Job&#8288;</span>&rsquo;</dt><dd><p>a factor with levels &ldquo;Janitor&rdquo;, &ldquo;Waiter&rdquo;, &ldquo;Child care provider&rdquo;, &ldquo;Gardener&rdquo;, &ldquo;Financial analyst&rdquo;, &ldquo;Construction worker&rdquo;, &ldquo;Teacher&rdquo;, &ldquo;Computer programmer&rdquo;, &ldquo;Nurse&rdquo;, &ldquo;Research scientist&rdquo;, &ldquo;Doctor&rdquo;</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;JobExperience&#8288;</span>&rsquo;</dt><dd><p>a factor with levels &ldquo;None&rdquo;, &ldquo;1-2 years&rdquo;, &ldquo;3-5 years&rdquo;, &ldquo;5+ years&rdquo;</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;JobPlans&#8288;</span>&rsquo;</dt><dd><p>a factor with levels &ldquo;Will look for work&rdquo;, &ldquo;Contract with employer&rdquo;, &ldquo;Interviews with employer&rdquo;, &ldquo;No plans to look for work&rdquo;</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;PriorEntry&#8288;</span>&rsquo;</dt><dd><p>a factor with levels &ldquo;Never&rdquo;, &ldquo;Once as tourist&rdquo;, &ldquo;Many times as tourist&rdquo;, &ldquo;Six months with family&rdquo;, &ldquo;Once w/o authorization&rdquo;</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;LanguageSkills&#8288;</span>&rsquo;</dt><dd><p>a factor with levels &ldquo;Fluent English&rdquo;, &ldquo;Broken English&rdquo;, &ldquo;Tried English but unable&rdquo;, &ldquo;Used interpreter&rdquo;</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;ChosenImmigrant&#8288;</span>&rsquo;</dt><dd><p>a numeric vector denoting whether the immigrant profile was selected</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;ethnocentrism&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;profile&#8288;</span>&rsquo;</dt><dd><p>a numeric vector giving the profile number</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;LangPos&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;PriorPos&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
</dl>


<h3>Note</h3>

<p>This is a modified version of the &lsquo;<span class="samp">&#8288;hainmueller&#8288;</span>&rsquo; dataset available from the <a href="https://cran.r-project.org/package=cjoint">cjoint</a> package.
</p>


<h3>Source</h3>

<p>Hainmueller, J., Hopkins, D., and Yamamoto T. 2014. &ldquo;Causal Inference in Conjoint Analysis: Understanding Multi-Dimensional Choices via Stated Preference Experiments.&rdquo; <em>Political Analysis</em> 22(1): 1-30. <a href="http://doi.org/10.1093/pan/mpt024">http://doi.org/10.1093/pan/mpt024</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cj">cj</a></code> <code><a href="#topic+taxes">taxes</a></code> <code><a href="#topic+cj_df">cj_df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("immigration")

# view constraints between features
subset(cj_props(immigration, ~ Job + Education, id = ~ CaseID), Proportion == 0)
subset(cj_props(immigration, ~ ReasonForApplication + CountryOfOrigin, 
                id = ~ CaseID), Proportion == 0)

# AMCEs with interactions for constraints
f1 &lt;- ChosenImmigrant ~ Gender + Education * Job +
         LanguageSkills + CountryOfOrigin * ReasonForApplication + 
         JobExperience + JobPlans + PriorEntry
cj(immigration, f1, id = ~ CaseID)

</code></pre>

<hr>
<h2 id='mm'>Marginal Means</h2><span id='topic+mm'></span>

<h3>Description</h3>

<p>Calculate (descriptive) marginal means (MMs) from a conjoint design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mm(
  data,
  formula,
  id = ~0,
  weights = NULL,
  feature_order = NULL,
  feature_labels = NULL,
  level_order = c("ascending", "descending"),
  alpha = 0.05,
  h0 = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mm_+3A_data">data</code></td>
<td>
<p>A data frame containing variables specified in <code>formula</code>. All RHS variables should be factors.</p>
</td></tr>
<tr><td><code id="mm_+3A_formula">formula</code></td>
<td>
<p>A formula specifying an outcome (LHS) and conjoint features (RHS) to describe. All variables should be factors; all levels across features should be unique, with constraints specified with an asterisk (*) between features, as in <code>amce</code>.</p>
</td></tr>
<tr><td><code id="mm_+3A_id">id</code></td>
<td>
<p>An RHS formula specifying a variable holding respondent identifiers, to be used for clustering standard errors. By default, data are unclustered.</p>
</td></tr>
<tr><td><code id="mm_+3A_weights">weights</code></td>
<td>
<p>An (optional) RHS formula specifying a variable holding survey weights.</p>
</td></tr>
<tr><td><code id="mm_+3A_feature_order">feature_order</code></td>
<td>
<p>An (optional) character vector specifying the names of feature (RHS) variables in the order they should be encoded in the resulting data frame.</p>
</td></tr>
<tr><td><code id="mm_+3A_feature_labels">feature_labels</code></td>
<td>
<p>A named list of &ldquo;fancy&rdquo; feature labels to be used in output. By default, the function looks for a &ldquo;label&rdquo; attribute on each variable in <code>formula</code> and uses that for pretty printing. This argument overrides those attributes or otherwise provides fancy labels for this purpose. This should be a list with names equal to variables on the righthand side of <code>formula</code> and character string values; arguments passed here override variable attributes.</p>
</td></tr>
<tr><td><code id="mm_+3A_level_order">level_order</code></td>
<td>
<p>A character string specifying levels (within each feature) should be ordered increasing or decreasing in the final output. This is mostly only consequential for plotting via <code><a href="#topic+plot.cj_mm">plot.cj_mm</a></code>, etc.</p>
</td></tr>
<tr><td><code id="mm_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value indicating the significance level at which to calculate confidence intervals for the MMs (by default 0.95, meaning 95-percent CIs are returned).</p>
</td></tr>
<tr><td><code id="mm_+3A_h0">h0</code></td>
<td>
<p>A numeric value specifying a null hypothesis value to use when generating z-statistics and p-values.</p>
</td></tr>
<tr><td><code id="mm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mm</code> provides descriptive representations of conjoint data as marginal means (MMs), which represent the mean outcome across all appearances of a particular conjoint feature level, averaging across all other features. In forced choice conjoint designs with two profiles per choice task, MMs by definition average 0.5 with values above 0.5 indicating features that increase profile favorability and values below 0.5 indicating features that decrease profile favorability. For continuous outcomes, MMs can take any value in the full range of the outcome.
</p>
<p>But note that if feature levels can co-occur, such that both alternatives share a feature level, then the MMs on forced choice outcomes are bounded by the probability of co-occurrence (as a lower bound) and 1 minus that probability as an upper bound.
</p>
<p>Plotting functionality is provided in <code><a href="#topic+plot.cj_mm">plot.cj_mm</a></code>.
</p>


<h3>Value</h3>

<p>A data frame of class &ldquo;cj_mm&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mm_diffs">mm_diffs</a></code> <code><a href="#topic+plot.cj_mm">plot.cj_mm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(immigration)
# marginal means
mm(immigration, ChosenImmigrant ~ Gender + Education + LanguageSkills,
   id = ~ CaseID, h0 = 0.5)

# higher-order marginal means with feature interactions
immigration$language_entry &lt;- 
  interaction(immigration$LanguageSkills, immigration$PriorEntry, sep = "_")
mm(immigration, ChosenImmigrant ~ language_entry,
   id = ~CaseID)

</code></pre>

<hr>
<h2 id='plot.cj_amce'>Plot AMCE estimates, MM descriptives, and frequency plots</h2><span id='topic+plot.cj_amce'></span><span id='topic+plot.cj_mm'></span><span id='topic+plot.cj_freqs'></span><span id='topic+plot.cj_diffs'></span>

<h3>Description</h3>

<p>ggplot2-based plotting of conjoint AMCEs estimates and MMs, and differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cj_amce'
plot(
  x,
  group = attr(x, "by"),
  feature_headers = TRUE,
  header_fmt = "(%s)",
  size = 1,
  xlab = "Estimated AMCE",
  ylab = "",
  legend_title = if (is.null(group)) "Feature" else group,
  legend_pos = "bottom",
  xlim = NULL,
  vline = 0,
  vline_color = "gray",
  theme = ggplot2::theme_bw(),
  ...
)

## S3 method for class 'cj_diffs'
plot(
  x,
  group = attr(x, "by"),
  feature_headers = TRUE,
  header_fmt = "(%s)",
  size = 1,
  xlab = "Estimated Difference",
  ylab = "",
  legend_title = if (is.null(group)) "Feature" else group,
  legend_pos = "bottom",
  xlim = NULL,
  vline = 0,
  vline_color = "gray",
  theme = ggplot2::theme_bw(),
  ...
)

## S3 method for class 'cj_freqs'
plot(
  x,
  group = attr(x, "by"),
  feature_headers = TRUE,
  header_fmt = "(%s)",
  xlab = "",
  ylab = "Frequency",
  legend_title = if (is.null(group)) "Feature" else group,
  legend_pos = "bottom",
  theme = ggplot2::theme_bw(),
  ...
)

## S3 method for class 'cj_mm'
plot(
  x,
  group = attr(x, "by"),
  feature_headers = TRUE,
  header_fmt = "(%s)",
  size = 1,
  xlab = "Marginal Mean",
  ylab = "",
  legend_title = if (is.null(group)) "Feature" else group,
  legend_pos = "bottom",
  xlim = NULL,
  vline = 0,
  vline_color = "gray",
  theme = ggplot2::theme_bw(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cj_amce_+3A_x">x</code></td>
<td>
<p>A data frame returned from <code><a href="#topic+cj">cj</a></code> or <code><a href="#topic+mm">mm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_group">group</code></td>
<td>
<p>Optionally a character string specifying a grouping factor. This is useful when, for example, subgroup analyses or comparing AMCEs for different outcomes. An alternative is to use <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> for faceted graphics.</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_feature_headers">feature_headers</code></td>
<td>
<p>A logical indicating whether to include headers for each feature to visually separate levels for each feature (beyond the color palette).</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_header_fmt">header_fmt</code></td>
<td>
<p>A character string specifying a <code>fmt</code> argument to <code><a href="base.html#topic+sprintf">sprintf</a></code>, which will be used when generating the feature headers (if <code>feature_headers = TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_size">size</code></td>
<td>
<p>A numeric value specifying point size in <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x-axis</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_ylab">ylab</code></td>
<td>
<p>A label for the y-axis</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_legend_title">legend_title</code></td>
<td>
<p>A character string specifying a label for the legend.</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_legend_pos">legend_pos</code></td>
<td>
<p>An argument forwarded to the <code>legend.position</code> argument in <code><a href="ggplot2.html#topic+theme">theme</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_xlim">xlim</code></td>
<td>
<p>A two-element number vector specifying limits for the x-axis. If <code>NULL</code>, a default value is calculated from the data.</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_vline">vline</code></td>
<td>
<p>Optionally, a numeric value specifying an x-intercept for a vertical line. This can be useful in distinguishing the midpoint of the estimates (e.g., a zero line for AMCEs).</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_vline_color">vline_color</code></td>
<td>
<p>A character string specifying a color for the <code>vline</code>.</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_theme">theme</code></td>
<td>
<p>A ggplot2 theme object</p>
</td></tr>
<tr><td><code id="plot.cj_amce_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are convenience functions for quickly plotting results from cregg. Because <code>plot</code> returns ggplot2 objects, these are easily manipulated using standard ggplot2 operations.
</p>
<p>Note that ggplot2, by default, sorts factors (like feature names here) in what might be the opposite order of what you would expect and in the opposite order that cregg functions sort their output.
</p>


<h3>Value</h3>

<p>A ggplot2 object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amce">amce</a></code>, <code><a href="#topic+mm">mm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require("ggplot2")
# load data
data("immigration")
immigration$contest_no &lt;- factor(immigration$contest_no)

# calculate MMs
d1 &lt;- mm(immigration, ChosenImmigrant ~ Gender + Education + 
         LanguageSkills + CountryOfOrigin + Job + JobExperience + 
         JobPlans + ReasonForApplication + PriorEntry, id = ~ CaseID)

# plot MMs
## simple plot
(p &lt;- plot(d1, vline = 0.5))

## gridlines to aid interpretation
p + ggplot2::theme_grey()

## monochrome bars
p + scale_color_manual(values = rep("black", 9))

## plot with estimates shown as text labels
p + ggplot2::geom_text(
  aes(label = sprintf("%0.2f (%0.2f)", estimate, std.error)),
  colour = "black", position = position_nudge(y = .5)
)

## plot with facetting by feature
plot(d1, feature_headers = FALSE) + 
  ggplot2::facet_wrap(~feature, ncol = 1L, 
                      scales = "free_y", strip.position = "right")

# MMs split by profile number
stacked &lt;- cj(immigration, ChosenImmigrant ~ Gender + 
              Education + LanguageSkills + CountryOfOrigin + Job + JobExperience + 
              JobPlans + ReasonForApplication + PriorEntry, id = ~ CaseID,
              estimate = "mm", by = ~ contest_no)

## plot with grouping
plot(stacked, group = "contest_no", feature_headers = FALSE)

## plot with facetting
plot(stacked) + ggplot2::facet_wrap(~contest_no, nrow = 1L)

## plot with shapes instead of colors for groups
plot(stacked, group = "contest_no", vline = 0.5) + 
 aes(shape = contest_no) + # map group to `shape` aesthetic
 scale_shape_manual(values=c(1, 2, 3, 4, 5)) +
 scale_colour_manual(values=rep("black", 5)) 

# estimate AMCEs over different subsets of data
reasons12 &lt;- subset(
  immigration, ReasonForApplication %in% levels(ReasonForApplication)[1:2]
)
d2_1 &lt;- cj(immigration, ChosenImmigrant ~ CountryOfOrigin, id = ~ CaseID)
d2_2 &lt;- cj(reasons12, ChosenImmigrant ~ CountryOfOrigin, id = ~ CaseID,
           feature_labels = list(CountryOfOrigin = "Country Of Origin"))
d2_1$reasons &lt;- "1,2,3"
d2_2$reasons &lt;- "1,2"
plot(rbind(d2_1, d2_2), group = "reasons")

</code></pre>

<hr>
<h2 id='taxes'>Tax Preference Conjoint Experiment Dataset from Ballard-Rosa et al. (2016)</h2><span id='topic+taxes'></span>

<h3>Description</h3>

<p>A dataset containing the results of a fully randomized conjoint survey of a representative sample of 2000 American adults who were asked to choose between alternative tax rate policies. Variables &lsquo;<span class="samp">&#8288;taxrate1&#8288;</span>&rsquo;-&lsquo;<span class="samp">&#8288;taxrate6&#8288;</span>&rsquo; refer to tax rates for different income brackets and &lsquo;<span class="samp">&#8288;taxrev&#8288;</span>&rsquo; refers to levels of total tax revenue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(taxes)
</code></pre>


<h3>Format</h3>

<p>A data frame (with additional &ldquo;cj_df&rdquo; class) with 32000 observations on the following 13 variables. Each row corresponds to a single profile presented to a respondent.
</p>

<dl>
<dt>&lsquo;<span class="samp">&#8288;chose_plan&#8288;</span>&rsquo;</dt><dd><p>A numeric vector denoting whether the immigrant profile was selected (=1) or not (=0).</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;taxrate1&#8288;</span>&rsquo;</dt><dd><p>An experimental factor with levels &ldquo;&lt;10k: 0%&rdquo;, &ldquo;&lt;10k: 5%&rdquo;, &ldquo;&lt;10k: 15%&rdquo;, &ldquo;&lt;10k: 25%&rdquo;.</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;taxrate2&#8288;</span>&rsquo;</dt><dd><p>An experimental factor with levels &ldquo;10-35k: 5%&rdquo;, &ldquo;10-35k: 15%&rdquo;, &ldquo;10-35k: 25%&rdquo;, &ldquo;10-35k: 35%&rdquo;.</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;taxrate3&#8288;</span>&rsquo;</dt><dd><p>An experimental factor with levels &ldquo;35-85k: 5%&rdquo;, &ldquo;35-85k: 15%&rdquo;, &ldquo;35-85k: 25%&rdquo;, &ldquo;35-85k: 35%&rdquo;.</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;taxrate4&#8288;</span>&rsquo;</dt><dd><p>An experimental factor with levels &ldquo;85-175k: 5%&rdquo;, &ldquo;85-175k: 15%&rdquo;, &ldquo;85-175k: 25%&rdquo;, &ldquo;85-175k: 35%&rdquo;.</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;taxrate5&#8288;</span>&rsquo;</dt><dd><p>An experimental factor with levels &ldquo;175-375k: 5%&rdquo;, &ldquo;175-375k: 15%&rdquo;, &ldquo;175-375k: 25%&rdquo;, &ldquo;175-375k: 35%&rdquo;, &ldquo;175-375k: 45%&rdquo;.</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;taxrate6&#8288;</span>&rsquo;</dt><dd><p>An experimental factor with levels &ldquo;&gt;375k: 5%&rdquo;, &ldquo;&gt;375k: 15%&rdquo;, &ldquo;&gt;375k: 25%&rdquo;, &ldquo;&gt;375k: 35%&rdquo;, &ldquo;&gt;375k: 45%&rdquo;, &ldquo;&gt;375k: 55%&rdquo;.</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;taxrev&#8288;</span>&rsquo;</dt><dd><p>An experimental factor with levels &ldquo;&lt;75%&rdquo;, &ldquo;75-95%&rdquo;, &ldquo;95-105%&rdquo;, &ldquo;105-125%&rdquo;, &ldquo;&gt;125%&rdquo;.</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;inequality_aversion&#8288;</span>&rsquo;</dt><dd><p>A covariate specifying whether respondent is inequality averse (=1) or not (=0).</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;taxes_harm_economy&#8288;</span>&rsquo;</dt><dd><p>A covariate specifying whether respondent believes taxes harm the economy (=1) or not (=0).</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;partyid&#8288;</span>&rsquo;</dt><dd><p>A factor specifying the respondent's party identification; one of &ldquo;Independent&rdquo;, &ldquo;Democrat&rdquo;, &ldquo;Republican&rdquo;.</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;ID&#8288;</span>&rsquo;</dt><dd><p>A numeric vector indicating the respondent to which the profile corresponds.</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;weight&#8288;</span>&rsquo;</dt><dd><p>A numeric vector containing survey weights.</p>
</dd>
</dl>


<h3>Source</h3>

<p>Ballard-Rosa, Cameron, Lucy Martin, and Kenneth Scheve. 2016. &ldquo;The Structure of American Income Tax Policy Preferences.&rdquo; <em>The Journal of Politics</em> 79(1): 1-16. <a href="http://doi.org/10.1086/687324">http://doi.org/10.1086/687324</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cj">cj</a></code> <code><a href="#topic+immigration">immigration</a></code> <code><a href="#topic+cj_df">cj_df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("taxes")
f1 &lt;- chose_plan ~ taxrate1 + taxrate2 + taxrate3 + 
        taxrate4 + taxrate5 + taxrate6 + taxrev
cj(taxes, f1, id = ~ ID, weights = ~     weight)

</code></pre>

<hr>
<h2 id='wide_conjoint'>Example of a raw, &ldquo;wide&rdquo; conjoint dataset to demonstrate functionality of <code><a href="#topic+cj_tidy">cj_tidy</a></code></h2><span id='topic+wide_conjoint'></span>

<h3>Description</h3>

<p>A simulated dataset containing 100 respondents' responses to four decision tasks (a,b,c,d) involving a forced choice between two alternative profiles, described by three features (1,2,3), as well as a secondary rating-scale outcome and a response time measure, along with two respondent-varying covariates. This is used in testing and examples within the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wide_conjoint)
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following variables:
</p>

<dl>
<dt>&lsquo;<span class="samp">&#8288;respondent&#8288;</span>&rsquo;</dt><dd><p>a numeric vector indicating the respondent identifier</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature1a1&#8288;</span>&rsquo;</dt><dd><p>Feature 1 for task A left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature1b1&#8288;</span>&rsquo;</dt><dd><p>Feature 1 for task B left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature1c1&#8288;</span>&rsquo;</dt><dd><p>Feature 1 for task C left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature1d1&#8288;</span>&rsquo;</dt><dd><p>Feature 1 for task D left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature1a2&#8288;</span>&rsquo;</dt><dd><p>Feature 1 for task A right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature1b2&#8288;</span>&rsquo;</dt><dd><p>Feature 1 for task B right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature1c2&#8288;</span>&rsquo;</dt><dd><p>Feature 1 for task C right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature1d2&#8288;</span>&rsquo;</dt><dd><p>Feature 1 for task D right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature2a1&#8288;</span>&rsquo;</dt><dd><p>Feature 2 for task A left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature2b1&#8288;</span>&rsquo;</dt><dd><p>Feature 2 for task B left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature2c1&#8288;</span>&rsquo;</dt><dd><p>Feature 2 for task C left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature2d1&#8288;</span>&rsquo;</dt><dd><p>Feature 2 for task D left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature2a2&#8288;</span>&rsquo;</dt><dd><p>Feature 2 for task A right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature2b2&#8288;</span>&rsquo;</dt><dd><p>Feature 2 for task B right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature2c2&#8288;</span>&rsquo;</dt><dd><p>Feature 2 for task C right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature2d2&#8288;</span>&rsquo;</dt><dd><p>Feature 2 for task D right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature3a1&#8288;</span>&rsquo;</dt><dd><p>Feature 3 for task A left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature3b1&#8288;</span>&rsquo;</dt><dd><p>Feature 3 for task B left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature3c1&#8288;</span>&rsquo;</dt><dd><p>Feature 3 for task C left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature3d1&#8288;</span>&rsquo;</dt><dd><p>Feature 3 for task D left profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature3a2&#8288;</span>&rsquo;</dt><dd><p>Feature 3 for task A right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature3b2&#8288;</span>&rsquo;</dt><dd><p>Feature 3 for task B right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature3c2&#8288;</span>&rsquo;</dt><dd><p>Feature 3 for task C right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;feature3d2&#8288;</span>&rsquo;</dt><dd><p>Feature 3 for task D right profile, a factor</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;choice_a&#8288;</span>&rsquo;</dt><dd><p>outcome for task A indicating which profile was chosen, randomly 1 or 2, each equally probable</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;choice_b&#8288;</span>&rsquo;</dt><dd><p>outcome for task B indicating which profile was chosen, randomly 1 or 2, each equally probable</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;choice_c&#8288;</span>&rsquo;</dt><dd><p>outcome for task C indicating which profile was chosen, randomly 1 or 2, each equally probable</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;choice_d&#8288;</span>&rsquo;</dt><dd><p>outcome for task D indicating which profile was chosen, randomly 1 or 2, each equally probable</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;rating_a1&#8288;</span>&rsquo;</dt><dd><p>rating for task A left profile, random variable between 1 and 7, uniformly distributed</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;rating_a2&#8288;</span>&rsquo;</dt><dd><p>rating for task A right profile, random variable between 1 and 7, uniformly distributed</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;rating_b1&#8288;</span>&rsquo;</dt><dd><p>rating for task B left profile, random variable between 1 and 7, uniformly distributed</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;rating_b2&#8288;</span>&rsquo;</dt><dd><p>rating for task B right profile, random variable between 1 and 7, uniformly distributed</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;rating_c1&#8288;</span>&rsquo;</dt><dd><p>rating for task C left profile, random variable between 1 and 7, uniformly distributed</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;rating_c2&#8288;</span>&rsquo;</dt><dd><p>rating for task C right profile, random variable between 1 and 7, uniformly distributed</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;rating_d1&#8288;</span>&rsquo;</dt><dd><p>rating for task D left profile, random variable between 1 and 7, uniformly distributed</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;rating_d2&#8288;</span>&rsquo;</dt><dd><p>rating for task D right profile, random variable between 1 and 7, uniformly distributed</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;timing_a&#8288;</span>&rsquo;</dt><dd><p>timing for task A in seconds, random draws from a beta distribution (2,5) times 10</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;timing_b&#8288;</span>&rsquo;</dt><dd><p>timing for task A in seconds, random draws from a beta distribution (2,5) times 10</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;timing_c&#8288;</span>&rsquo;</dt><dd><p>timing for task A in seconds, random draws from a beta distribution (2,5) times 10</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;timing_d&#8288;</span>&rsquo;</dt><dd><p>timing for task A in seconds, random draws from a beta distribution (2,5) times 10</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;covariate1&#8288;</span>&rsquo;</dt><dd><p>random draws from a uniform distribution between -1 and 1</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;covariate2&#8288;</span>&rsquo;</dt><dd><p>random draws from the set of 1 and 2</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+cj_tidy">cj_tidy</a></code> <code><a href="#topic+cj">cj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("wide_conjoint")
# feature_variables
list1 &lt;- list(
 feature1 = list(
     names(wide_conjoint)[grep("^feature1.{1}1", names(wide_conjoint))],
     names(wide_conjoint)[grep("^feature1.{1}2", names(wide_conjoint))]
 ),
 feature2 = list(
     names(wide_conjoint)[grep("^feature2.{1}1", names(wide_conjoint))],
     names(wide_conjoint)[grep("^feature2.{1}2", names(wide_conjoint))]
 ),
 feature3 = list(
     names(wide_conjoint)[grep("^feature3.{1}1", names(wide_conjoint))],
     names(wide_conjoint)[grep("^feature3.{1}2", names(wide_conjoint))]
 ),
 rating = list(
     names(wide_conjoint)[grep("^rating.+1", names(wide_conjoint))],
     names(wide_conjoint)[grep("^rating.+2", names(wide_conjoint))]
 )
)
# task variables
list2 &lt;- list(choice = paste0("choice_", letters[1:4]),
              timing = paste0("timing_", letters[1:4]))
str(cj_tidy(wide_conjoint, profile_variables = list1, task_variables = list2, id = ~ respondent))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
