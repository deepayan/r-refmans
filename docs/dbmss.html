<!DOCTYPE html><html lang="en"><head><title>Help for package dbmss</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dbmss}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dbmss-package'>
<p>Distance Based Measures of Spatial Structures</p></a></li>
<li><a href='#as.Dtable'>
<p>Converts data to class Dtable</p></a></li>
<li><a href='#as.wmppp'>
<p>Converts data to class wmppp</p></a></li>
<li><a href='#autoplot'>
<p>ggplot methods to plot dbmss objects</p></a></li>
<li><a href='#CheckdbmssArguments'>
<p>Checks the arguments of a function of the package dbmss</p></a></li>
<li><a href='#dbmssEnvelope.object'>
<p>Class of envelope of function values (fv)</p></a></li>
<li><a href='#DEnvelope'>
<p>Estimation of the confidence envelope of the D function under its null hypothesis</p></a></li>
<li><a href='#Dhat'>
<p>Estimation of the D function</p></a></li>
<li><a href='#Dtable'>
<p>Create a Distance table object.</p></a></li>
<li><a href='#envelope.Dtable'>
<p>Computes simulation envelopes of a summary function.</p></a></li>
<li><a href='#FillEnvelope'>
<p>Transform simulation values to an fv</p></a></li>
<li><a href='#gEnvelope'>
<p>Estimation of the confidence envelope of the g function under its null hypothesis</p></a></li>
<li><a href='#ghat'>
<p>Estimation of the g function</p></a></li>
<li><a href='#GlobalEnvelope'>
<p>Estimation of the global confidence interval of simulations</p></a></li>
<li><a href='#GoFtest'>
<p>Goodness of Fit test between a distance based measure of spatial structure and simulations of its null hypothesis</p></a></li>
<li><a href='#is.wmppp'>
<p>Test whether an object is a weighted, marked, planar point pattern</p></a></li>
<li><a href='#KdEnvelope'>
<p>Estimation of the confidence envelope of the Kd function under its null hypothesis</p></a></li>
<li><a href='#Kdhat'>
<p>Estimation of the Kd function</p></a></li>
<li><a href='#KEnvelope'>
<p>Estimation of the confidence envelope of the K function under its null hypothesis</p></a></li>
<li><a href='#Khat'>
<p>Estimation of the K function</p></a></li>
<li><a href='#KinhomEnvelope'>
<p>Estimation of the confidence envelope of the Kinhom function under its null hypothesis</p></a></li>
<li><a href='#Kinhomhat'>
<p>Estimation of the inhomogenous K function</p></a></li>
<li><a href='#KmmEnvelope'>
<p>Estimation of the confidence envelope of the Lmm function under its null hypothesis</p></a></li>
<li><a href='#Kmmhat'>
<p>Estimation of the Kmm function</p></a></li>
<li><a href='#Ktest'>
<p>Test of a point pattern against Complete Spatial Randomness</p></a></li>
<li><a href='#LEnvelope'>
<p>Estimation of the confidence envelope of the L function under its null hypothesis</p></a></li>
<li><a href='#Lhat'>
<p>Estimation of the L function</p></a></li>
<li><a href='#LmmEnvelope'>
<p>Estimation of the confidence envelope of the Lmm function under its null hypothesis</p></a></li>
<li><a href='#Lmmhat'>
<p>Estimation of the Lmm function</p></a></li>
<li><a href='#mEnvelope'>
<p>Estimation of the confidence envelope of the m function under its null hypothesis</p></a></li>
<li><a href='#MEnvelope'>
<p>Estimation of the confidence envelope of the M function under its null hypothesis</p></a></li>
<li><a href='#mhat'>
<p>Estimation of the m function</p></a></li>
<li><a href='#Mhat'>
<p>Estimation of the M function</p></a></li>
<li><a href='#paracou16'>
<p>Paracou field station plot 16, partial map</p></a></li>
<li><a href='#parallelCountNbd'>
<p>Auxiliary functions to count point neighbors</p></a></li>
<li><a href='#print.dbmssEnvelope'>
<p>Print a confidence envelope</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rPopulationIndependenceK'>
<p>Simulations of a point pattern according to the null hypothesis of population independence defined for K</p></a></li>
<li><a href='#rPopulationIndependenceM'>
<p>Simulations of a point pattern according to the null hypothesis of population independence defined for M</p></a></li>
<li><a href='#rRandomLabeling'>
<p>Simulations of a point pattern according to the null hypothesis of random labeling</p></a></li>
<li><a href='#rRandomLabelingM'>
<p>Simulations of a point pattern according to the null hypothesis of random labelling defined for M</p></a></li>
<li><a href='#rRandomLocation'>
<p>Simulations of a point pattern according to the null hypothesis of random location</p></a></li>
<li><a href='#rRandomPositionK'>
<p>Simulations of a point pattern according to the null hypothesis of random position defined for K</p></a></li>
<li><a href='#Smooth.wmppp'><p>Spatial smoothing of individual dbmss's</p></a></li>
<li><a href='#spatstat+20generic+20functions'>
<p>Methods for weighted, marked planar point patterns (of class wmppp) from spatstat</p></a></li>
<li><a href='#summary.dbmssEnvelope'>
<p>Summary of a confidence envelope</p></a></li>
<li><a href='#wmppp'>
<p>Create a Weighted, Marked, Planar Point Pattern</p></a></li>
<li><a href='#wmppp.object'>
<p>Class of Weighted, Marked, Planar Point Patterns</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Distance-Based Measures of Spatial Structures</td>
</tr>
<tr>
<td>Version:</td>
<td>2.9-2</td>
</tr>
<tr>
<td>Description:</td>
<td>Simple computation of spatial statistic functions of distance to characterize the spatial structures of mapped objects, following Marcon, Traissac, Puech, and Lang (2015) &lt;<a href="https://doi.org/10.18637%2Fjss.v067.c03">doi:10.18637/jss.v067.c03</a>&gt;.
  Includes classical functions (Ripley's K and others) and more recent ones used by spatial economists (Duranton and Overman's Kd, Marcon and Puech's M). 
  Relies on 'spatstat' for some core calculation.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ericmarcon.github.io/dbmss/">https://ericmarcon.github.io/dbmss/</a>,
<a href="https://github.com/EricMarcon/dbmss/">https://github.com/EricMarcon/dbmss/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EricMarcon/dbmss/issues/">https://github.com/EricMarcon/dbmss/issues/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GNU General Public License]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Rcpp (&ge; 0.12.14), spatstat.explore</td>
</tr>
<tr>
<td>Imports:</td>
<td>cubature, ggplot2, RcppParallel, reshape2, rlang,
spatstat.utils, stats, tibble, spatstat.geom, spatstat.random</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, pkgdown, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>pandoc, GNU make</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-24 10:27:49 UTC; emarc</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric Marcon <a href="https://orcid.org/0000-0002-5249-321X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Gabriel Lang <a href="https://orcid.org/0000-0002-4325-6044"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Stephane Traissac <a href="https://orcid.org/0000-0001-9255-1616"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Florence Puech <a href="https://orcid.org/0000-0002-5279-6878"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Marcon &lt;eric.marcon@agroparistech.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-24 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dbmss-package'>
Distance Based Measures of Spatial Structures
</h2><span id='topic+dbmss-package'></span><span id='topic+dbmss'></span>

<h3>Description</h3>

<p>Simple computation of spatial statistic functions of distance to characterize the spatial structures of mapped objects, including classical ones (Ripley's <em>K</em> and others) and more recent ones used by spatial economists (Duranton and Overman's <em>Kd</em>, Marcon and Puech's <em>M</em>). Relies on spatstat for some core calculation.
</p>


<h3>Author(s)</h3>

<p>Eric Marcon,
Gabriel Lang,
Stephane Traissac,
Florence Puech
</p>
<p>Maintainer: Eric Marcon &lt;Eric.Marcon@agroparistech.fr&gt;
</p>


<h3>References</h3>

<p>Marcon, E., and Puech, F. (2003). Evaluating the Geographic Concentration of Industries Using Distance-Based Methods. <em>Journal of Economic Geography</em>, 3(4), 409-428.
</p>
<p>Marcon, E. and Puech, F. (2010). Measures of the Geographic Concentration of Industries: Improving Distance-Based Methods. <em>Journal of Economic Geography</em> 10(5): 745-762.
</p>
<p>Marcon, E., Puech F. and Traissac, S. (2012). Characterizing the relative spatial structure of point patterns. <em>International Journal of Ecology</em> 2012(Article ID 619281): 11.
</p>
<p>Lang G., Marcon E. and Puech F. (2014) Distance-Based Measures of Spatial Concentration: Introducing a Relative Density Function. <em>HAL</em> 01082178, 1-18.
</p>
<p>Marcon, E., Traissac, S., Puech, F. and Lang, G. (2015). Tools to Characterize Point Patterns: dbmss for R. <em>Journal of Statistical Software</em>. 67(3): 1-15.
</p>
<p>Marcon, E. and Puech, F. (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>

<hr>
<h2 id='as.Dtable'>
Converts data to class Dtable
</h2><span id='topic+as.Dtable'></span><span id='topic+as.Dtable.ppp'></span><span id='topic+as.Dtable.data.frame'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"Dtable"</code> representing a set of points with weights and labels and the distances between them.. This is a generic method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.Dtable(X, ...)
  ## S3 method for class 'ppp'
as.Dtable(X, ...)
  ## S3 method for class 'data.frame'
as.Dtable(X, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.Dtable_+3A_x">X</code></td>
<td>

<p>Data to be converted into a <code>"Dtable"</code>.
</p>
</td></tr>
<tr><td><code id="as.Dtable_+3A_...">...</code></td>
<td>

<p>Extra arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic method, implemented for <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> and <code><a href="base.html#topic+data.frame">data.frame</a></code>. 
</p>
<p>Data is first converted to a (<code><a href="#topic+wmppp.object">wmppp.object</a></code>). Then, the distance matrix between points is calculated and the marks are kept.
</p>


<h3>Value</h3>

<p>An object of class <code>"Dtable"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.wmppp">as.wmppp</a></code>
</p>

<hr>
<h2 id='as.wmppp'>
Converts data to class wmppp
</h2><span id='topic+as.wmppp'></span><span id='topic+as.wmppp.ppp'></span><span id='topic+as.wmppp.data.frame'></span>

<h3>Description</h3>

<p>Creates a Weighted, Marked, Planar Point Pattern, <em>i.e.</em> an object of class <code>"wmppp"</code> representing a two-dimensional point pattern with weights and labels. This is a generic method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.wmppp(X, ...)
  ## S3 method for class 'ppp'
as.wmppp(X, ...)
  ## S3 method for class 'data.frame'
as.wmppp(X, window = NULL, unitname = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.wmppp_+3A_x">X</code></td>
<td>

<p>Data to be converted into a weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>)
</p>
</td></tr>
<tr><td><code id="as.wmppp_+3A_window">window</code></td>
<td>

<p>An object of calls &quot;owin&quot; (<code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>).  
</p>
</td></tr>
<tr><td><code id="as.wmppp_+3A_unitname">unitname</code></td>
<td>

<p>Name of unit of length. Either a single character string, or a vector of two character strings giving the singular and plural forms, respectively.  
</p>
</td></tr>
<tr><td><code id="as.wmppp_+3A_...">...</code></td>
<td>

<p>Extra arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic method, implemented for <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> and <code><a href="base.html#topic+data.frame">data.frame</a></code>:
</p>

<ul>
<li><p>If the dataset <code>X</code> is an object of class &quot;ppp&quot; (<code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code>), the marks are converted to point weights if they are numeric or to point types if they are factors. Default weights are set to 1, default types to &quot;All&quot;. If marks are a dataframe with column names equal to <code>PointType</code> and <code>PointWeight</code>, they are not modified. Row names of the dataframe are preserved as row names of the marks, to identify points.

</p>
</li>
<li><p>If the dataset <code>X</code> is a dataframe, see <code><a href="#topic+wmppp">wmppp</a></code>.

</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"wmppp"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wmppp.object">wmppp.object</a></code>
</p>

<hr>
<h2 id='autoplot'>
ggplot methods to plot dbmss objects
</h2><span id='topic+autoplot.envelope'></span><span id='topic+autoplot.fv'></span><span id='topic+autoplot.wmppp'></span>

<h3>Description</h3>

<p>S3 methods for the <code><a href="#topic+autoplot">autoplot</a></code> generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'envelope'
autoplot(object, fmla, ..., ObsColor = "black", 
        H0Color = "red", ShadeColor = "grey75", alpha = 0.3, main = NULL, 
        xlab = NULL, ylab = NULL, LegendLabels = NULL)
  ## S3 method for class 'fv'
autoplot(object, fmla, ..., ObsColor = "black", 
        H0Color = "red", ShadeColor = "grey75", alpha = 0.3, main = NULL, 
        xlab = NULL, ylab = NULL, LegendLabels = NULL)
  ## S3 method for class 'wmppp'
autoplot(object, ..., show.window = TRUE, 
        MaxPointTypes = 6, Other = "Other",
        main = NULL, xlab = NULL, ylab = NULL, LegendLabels = NULL, 
        labelSize = "Weight", labelColor = "Type", palette="Set1",
        windowColor = "black", windowFill = "transparent", alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot_+3A_object">object</code></td>
<td>

<p>An object to be plotted.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_fmla">fmla</code></td>
<td>

<p>An R language formula determining which variables or expressions are plotted. Either a formula object, or a string that can be parsed as a formula. See <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_...">...</code></td>
<td>

<p>Extra arguments, currently unused.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_obscolor">ObsColor</code></td>
<td>

<p>The color of the line representing observed values of the function.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_h0color">H0Color</code></td>
<td>

<p>The color of the line representing the null hypothesis values of the function.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_shadecolor">ShadeColor</code></td>
<td>

<p>The color of the confidence envelope.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_alpha">alpha</code></td>
<td>

<p>The opacity of the confidence envelope (in function values) or the points (in maps), between 0 and 1.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_main">main</code></td>
<td>

<p>The title of the plot.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_xlab">xlab</code>, <code id="autoplot_+3A_ylab">ylab</code></td>
<td>

<p>The axes labels.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_legendlabels">LegendLabels</code></td>
<td>

<p>A vector of characters. The first two items describe the observed and null-hypothesis curves, the third and last item the confidence interval.
To be used only in plots with two curves (typically observed and expected values).
The default is 'NULL' to display the full description of functions.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_show.window">show.window</code></td>
<td>

<p>if 'TRUE', the borders of the window containing the points are shown on the point map.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_maxpointtypes">MaxPointTypes</code></td>
<td>

<p>The maximum number of different point types to show. If the point set contains more of them, the less frequent ones are gathered as &quot;Other&quot;. This number must be limited for readability and not to exceed the number of colors offered by the palette.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_other">Other</code></td>
<td>

<p>The name of the point types gathered as &quot;Other&quot;.
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_labelsize">labelSize</code></td>
<td>

<p>The guide of the point size legend in point maps, i.e. what the 'PointSize' mark represents. 
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_labelcolor">labelColor</code></td>
<td>

<p>The guide of the point color legend in point maps, i.e. what the 'PointType' mark represents. 
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_palette">palette</code></td>
<td>

<p>The color palette used to display point types in maps. See <code><a href="ggplot2.html#topic+scale_colour_brewer">scale_colour_brewer</a></code>
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_windowcolor">windowColor</code></td>
<td>

<p>The color used to draw the limits of the windows in point maps. 
</p>
</td></tr>
<tr><td><code id="autoplot_+3A_windowfill">windowFill</code></td>
<td>

<p>The color used to fill the windows in point maps. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots of 'wmppp' objects are a single representation of both point types and point weights.
Rectangular and polygonal windows (see <code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>) are supported but mask windows are ignored (use the 'plot' method if necessary).
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Eric Marcon &lt;Eric.Marcon@agroparistech.fr&gt;, parts of the code from <code>spatstat.explore::plot.fv</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 20% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.2))
autoplot(X)

# Plot the envelope (should be 1000 simulations, reduced to 20 to save time)
autoplot(KdEnvelope(X, ReferenceType="Q. Rosea", NumberOfSimulations=20))

# With a formula and a compact legend
autoplot(KEnvelope(X, NumberOfSimulations=20), 
    ./(pi*r^2) ~ r,
    LegendLabels=c("Observed", "Expected", "Confidence\n enveloppe"))
</code></pre>

<hr>
<h2 id='CheckdbmssArguments'>
Checks the arguments of a function of the package dbmss
</h2><span id='topic+CheckdbmssArguments'></span>

<h3>Description</h3>

<p>This function is used internally to verify that arguments passed to dbmss functions such as <code><a href="#topic+Mhat">Mhat</a></code> are correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckdbmssArguments()
</code></pre>


<h3>Details</h3>

<p>The function compares the arguments passed to its parent function to the type they should be and performs some extra tests (<em>e.g.</em> risk threshold must be between 0 and 1). It stops if an argument is not correct.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> or stops if a problem is detected.
</p>

<hr>
<h2 id='dbmssEnvelope.object'>
Class of envelope of function values (fv)
</h2><span id='topic+dbmssEnvelope.object'></span>

<h3>Description</h3>

<p>A class <code>"dbmssEnvelope"</code>, <em>i.e.</em> a particular type of see <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code> to represent several estimates of the same function and its confidence envelope.
</p>


<h3>Details</h3>

<p>&quot;dbmssEnvelope&quot; objects are similar to envelope objects. The differences are that the risk level is chosen (instead of the simulation rank to use as the envelope), so the rank is calculated (interpolation is used if necessary), and a global envelope can be calculated following Duranton and Overman (2005).
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.dbmssEnvelope">summary.dbmssEnvelope</a></code>,
<code><a href="#topic+KdEnvelope">KdEnvelope</a></code>,
<code><a href="#topic+MEnvelope">MEnvelope</a></code>
</p>

<hr>
<h2 id='DEnvelope'>
Estimation of the confidence envelope of the D function under its null hypothesis
</h2><span id='topic+DEnvelope'></span>

<h3>Description</h3>

<p>Simulates point patterns according to the null hypothesis and returns the envelope of <em>D</em> according to the confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEnvelope(X, r = NULL, NumberOfSimulations = 100, Alpha = 0.05, 
          Cases, Controls, Intertype = FALSE, Global = FALSE,
          verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DEnvelope_+3A_x">X</code></td>
<td>

<p>A point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="DEnvelope_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="DEnvelope_+3A_numberofsimulations">NumberOfSimulations</code></td>
<td>

<p>The number of simulations to run, 100 by default.
</p>
</td></tr>
<tr><td><code id="DEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level, 5% by default.
</p>
</td></tr>
<tr><td><code id="DEnvelope_+3A_cases">Cases</code></td>
<td>

<p>One of the point types
</p>
</td></tr>
<tr><td><code id="DEnvelope_+3A_controls">Controls</code></td>
<td>

<p>One of the point types.
</p>
</td></tr>
<tr><td><code id="DEnvelope_+3A_intertype">Intertype</code></td>
<td>

<p>Logical; if <code>TRUE</code>, <em>D</em> is computed as <em>Di</em> in Marcon and Puech (2012). 
</p>
</td></tr>
<tr><td><code id="DEnvelope_+3A_global">Global</code></td>
<td>

<p>Logical; if <code>TRUE</code>, a global envelope sensu Duranton and Overman (2005) is calculated.
</p>
</td></tr>
<tr><td><code id="DEnvelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if <code>TRUE</code>, print progress reports during the simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only null hypothesis is random labeling: marks are distributed randomly across points.
</p>
<p>This envelope is local by default, that is to say it is computed separately at each distance. See Loosmore and Ford (2006) for a discussion.
</p>
<p>The global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>Value</h3>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>). There are methods for print and plot for this class.
</p>
<p>The <code>fv</code> contains the observed value of the function, its average simulated value and the confidence envelope.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Kenkel, N. C. (1988). Pattern of Self-Thinning in Jack Pine: Testing the Random Mortality Hypothesis. <em>Ecology</em> 69(4): 1017-1024.
</p>
<p>Loosmore, N. B. and Ford, E. D. (2006). Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87(8): 1925-1931.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Dhat">Dhat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 20% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.2))
autoplot(X, 
  labelSize = expression("Basal area (" ~cm^2~ ")"), 
  labelColor = "Species")

# Calculate confidence envelope (should be 1000 simulations, reduced to 20 to save time)
r &lt;- 0:30
NumberOfSimulations &lt;- 20
Alpha &lt;- .05
# Plot the envelope (after normalization by pi.r^2)
autoplot(DEnvelope(X, r, NumberOfSimulations, Alpha,
    "V. Americana", "Q. Rosea", Intertype = TRUE), ./(pi*r^2) ~ r)
</code></pre>

<hr>
<h2 id='Dhat'>
Estimation of the D function
</h2><span id='topic+Dhat'></span>

<h3>Description</h3>

<p>Estimates the <em>D</em> function</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dhat(X, r = NULL, Cases, Controls = NULL, Intertype = FALSE, CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dhat_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="Dhat_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="Dhat_+3A_cases">Cases</code></td>
<td>

<p>One of the point types.
</p>
</td></tr>
<tr><td><code id="Dhat_+3A_controls">Controls</code></td>
<td>

<p>One of the point types. If <code>NULL</code>, controls are all types except for cases.
</p>
</td></tr>
<tr><td><code id="Dhat_+3A_intertype">Intertype</code></td>
<td>

<p>Logical; if <code>TRUE</code>, <em>D</em> is computed as <em>Di</em> in Marcon and Puech (2012). 
</p>
</td></tr>
<tr><td><code id="Dhat_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>Di</em> function allows comparing the structure of the cases to that of the controls around cases, that is to say the comparison is made around the same points. This has been advocated by Arbia et al. (2008) and formalized by Marcon and Puech (2012).
</p>


<h3>Value</h3>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, which can be plotted directly using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>Note</h3>

<p>The computation of <code>Dhat</code> relies on spatstat functions <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> and <code><a href="spatstat.explore.html#topic+Kcross">Kcross</a></code>.
</p>


<h3>References</h3>

<p>Arbia, G., Espa, G. and Quah, D. (2008). A class of spatial econometric methods in the empirical analysis of clusters of firms in the space. <em>Empirical Economics</em> 34(1): 81-103.
</p>
<p>Diggle, P. J. and Chetwynd, A. G. (1991). Second-Order Analysis of Spatial Clustering for Inhomogeneous Populations. <em>Biometrics</em> 47(3): 1155-1163.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Khat">Khat</a></code>, <code><a href="#topic+DEnvelope">DEnvelope</a></code>, <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>, <code><a href="spatstat.explore.html#topic+Kcross">Kcross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
autoplot(paracou16)

# Calculate D
r &lt;- 0:30
(Paracou &lt;- Dhat(paracou16, r, "V. Americana", "Q. Rosea", Intertype = TRUE))

# Plot (after normalization by pi.r^2)
autoplot(Paracou, ./(pi*r^2) ~ r)
</code></pre>

<hr>
<h2 id='Dtable'>
Create a Distance table object.
</h2><span id='topic+Dtable'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"Dtable"</code> representing a set of points with weights and labels and the distances between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dtable(Dmatrix, PointType = NULL, PointWeight = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dtable_+3A_dmatrix">Dmatrix</code></td>
<td>

<p>A square matrix containing distances.
</p>
</td></tr>
<tr><td><code id="Dtable_+3A_pointtype">PointType</code></td>
<td>

<p>A vector describing the point types. Its length must correspond to the number of points. 
</p>
</td></tr>
<tr><td><code id="Dtable_+3A_pointweight">PointWeight</code></td>
<td>

<p>A vector describing the point weights. Its length must correspond to the number of points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance matrix is not necessarily symmetric, so distances are understood in the common sense, not in the mathematical sense. Asymmetric distances are appropriate when paths between points are one-way only.
</p>
<p>The points of origin are in lines, the targets in columns. The diagonal of the matrix must contain zeros (the distance between a point and itself is 0), and all other distances must be positive (they can be 0).
</p>


<h3>Value</h3>

<p>An object of class <code>"Dtable"</code>. It is a list:
</p>
<table role = "presentation">
<tr><td><code>Dmatrix</code></td>
<td>
<p>The distance matrix.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of points.</p>
</td></tr>
<tr><td><code>marks</code></td>
<td>
<p>A list of two items: <code>PointType</code>, a vector of factors containing the point types and <code>PointWeight</code>, the numeric vector of weights.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+as.Dtable">as.Dtable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A Dtable containing two points
Dmatrix &lt;- matrix(c(0,1,1,0), nrow=2)
PointType &lt;- c("Type1", "Type2")
PointWeight &lt;- c(2,3)
Dtable(Dmatrix, PointType, PointWeight)
</code></pre>

<hr>
<h2 id='envelope.Dtable'>
Computes simulation envelopes of a summary function.
</h2><span id='topic+envelope.Dtable'></span>

<h3>Description</h3>

<p>Prints a useful summary of a confidence envelope of class &quot;dbmssEnvelope&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Dtable'
envelope(Y, fun = Kest, nsim = 99, nrank = 1, ..., 
          funargs = list(), funYargs = funargs, simulate = NULL, 
          verbose = TRUE, savefuns = FALSE, Yname = NULL, envir.simul = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="envelope.Dtable_+3A_y">Y</code></td>
<td>

<p>An object of class <code><a href="#topic+Dtable">Dtable</a></code>.
</p>
</td></tr>
<tr><td><code id="envelope.Dtable_+3A_fun">fun</code></td>
<td>

<p>Function that computes the desired summary statistic for <code>Y</code>.
</p>
</td></tr>
<tr><td><code id="envelope.Dtable_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated point patterns to be generated when computing the envelopes.
</p>
</td></tr>
<tr><td><code id="envelope.Dtable_+3A_nrank">nrank</code></td>
<td>

<p>Integer. Rank of the envelope value amongst the nsim simulated values. A rank of 1 means that the minimum and maximum simulated values will be used.
</p>
</td></tr>
<tr><td><code id="envelope.Dtable_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="envelope.Dtable_+3A_funargs">funargs</code></td>
<td>

<p>A list, containing extra arguments to be passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="envelope.Dtable_+3A_funyargs">funYargs</code></td>
<td>

<p>Optional. A list, containing extra arguments to be passed to fun when applied to the original data <code>Y</code> only.
</p>
</td></tr>
<tr><td><code id="envelope.Dtable_+3A_simulate">simulate</code></td>
<td>

<p>Optional. Specifies how to generate the simulated point patterns.
</p>
</td></tr>
<tr><td><code id="envelope.Dtable_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports during the simulations.
</p>
</td></tr>
<tr><td><code id="envelope.Dtable_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical flag indicating whether to save all the simulated function values.
</p>
</td></tr>
<tr><td><code id="envelope.Dtable_+3A_yname">Yname</code></td>
<td>

<p>Character string that should be used as the name of the data <code>Y</code> when printing or plotting the results.
</p>
</td></tr>
<tr><td><code id="envelope.Dtable_+3A_envir.simul">envir.simul</code></td>
<td>

<p>Environment in which to evaluate the expression <code>simulate</code>, if not the current environment.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the S3 method <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code> for <code><a href="#topic+Dtable">Dtable</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Eric Marcon &lt;Eric.Marcon@agroparistech.fr&gt;. Relies on the <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code> engine of <strong>spatstat</strong>.
</p>

<hr>
<h2 id='FillEnvelope'>
Transform simulation values to an fv
</h2><span id='topic+FillEnvelope'></span>

<h3>Description</h3>

<p>This function is used internally to calculate envelope values and store them into an <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FillEnvelope(Envelope, Alpha, Global)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FillEnvelope_+3A_envelope">Envelope</code></td>
<td>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>) containing all the simulated function values.
</p>
</td></tr>
<tr><td><code id="FillEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level.
</p>
</td></tr>
<tr><td><code id="FillEnvelope_+3A_global">Global</code></td>
<td>

<p>Logical; if <code>TRUE</code>, a global envelope sensu Duranton and Overman (2005) is calculated. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>) with <code>hi</code> and <code>lo</code> values calculated from the simlations.
</p>

<hr>
<h2 id='gEnvelope'>
Estimation of the confidence envelope of the g function under its null hypothesis
</h2><span id='topic+gEnvelope'></span>

<h3>Description</h3>

<p>Simulates point patterns according to the null hypothesis and returns the envelope of <em>g</em> according to the confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gEnvelope(X, r = NULL, NumberOfSimulations = 100, Alpha = 0.05, 
         ReferenceType = "", NeighborType = "", SimulationType = "RandomPosition",
         Global = FALSE, verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gEnvelope_+3A_x">X</code></td>
<td>

<p>A point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="gEnvelope_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="gEnvelope_+3A_numberofsimulations">NumberOfSimulations</code></td>
<td>

<p>The number of simulations to run, 100 by default.
</p>
</td></tr>
<tr><td><code id="gEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level, 5% by default.
</p>
</td></tr>
<tr><td><code id="gEnvelope_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="gEnvelope_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="gEnvelope_+3A_simulationtype">SimulationType</code></td>
<td>

<p>A string describing the null hypothesis to simulate. The null hypothesis may be &quot;<em>RandomPosition</em>&quot;: points are drawn in a Poisson process (default); &quot;<em>RandomLabeling</em>&quot;: randomizes point types, keeping locations unchanged; &quot;<em>PopulationIndependence</em>&quot;: keeps reference points unchanged, shifts other point locations.
</p>
</td></tr>
<tr><td><code id="gEnvelope_+3A_global">Global</code></td>
<td>

<p>Logical; if <code>TRUE</code>, a global envelope sensu Duranton and Overman (2005) is calculated.
</p>
</td></tr>
<tr><td><code id="gEnvelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if <code>TRUE</code>, print progress reports during the simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This envelope is local by default, that is to say it is computed separately at each distance. See Loosmore and Ford (2006) for a discussion.
</p>
<p>The global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>Value</h3>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>). There are methods for print and plot for this class.
</p>
<p>The <code>fv</code> contains the observed value of the function, its average simulated value and the confidence envelope.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Kenkel, N. C. (1988). Pattern of Self-Thinning in Jack Pine: Testing the Random Mortality Hypothesis. <em>Ecology</em> 69(4): 1017-1024.
</p>
<p>Loosmore, N. B. and Ford, E. D. (2006). Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87(8): 1925-1931.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ghat">ghat</a></code>, <code><a href="#topic+rRandomPositionK">rRandomPositionK</a></code>, <code><a href="#topic+rRandomLocation">rRandomLocation</a></code>, <code><a href="#topic+rPopulationIndependenceK">rPopulationIndependenceK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 20% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.2))
autoplot(X, 
  labelSize = expression("Basal area (" ~cm^2~ ")"), 
  labelColor = "Species")

# Calculate confidence envelope (should be 1000 simulations, reduced to 10 to save time)
r &lt;- 0:40
NumberOfSimulations &lt;- 10
# Plot the envelope
autoplot(gEnvelope(X, r, NumberOfSimulations))
</code></pre>

<hr>
<h2 id='ghat'>
Estimation of the g function
</h2><span id='topic+ghat'></span>

<h3>Description</h3>

<p>Estimates the <em>g</em> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghat(X, r = NULL, ReferenceType = "", NeighborType = "", CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ghat_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="ghat_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="ghat_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="ghat_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="ghat_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of <code>ghat</code> relies on spatstat function <code><a href="spatstat.explore.html#topic+sewpcf">sewpcf</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, which can be plotted directly using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>References</h3>

<p>Stoyan, D. and Stoyan, H. (1994) <em>Fractals, random shapes and point fields: methods of geometrical statistics</em>. John Wiley and Sons. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gEnvelope">gEnvelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
autoplot(paracou16)

# Calculate g
r &lt;- 0:30
(Paracou &lt;- ghat(paracou16, r, "Q. Rosea", "V. Americana"))

# Plot
autoplot(Paracou)
</code></pre>

<hr>
<h2 id='GlobalEnvelope'>
Estimation of the global confidence interval of simulations
</h2><span id='topic+GlobalEnvelope'></span>

<h3>Description</h3>

<p>Calculates the global confidence interval envelope sensu Duranton and Overman (2005) according to simulations of the null hypothesis of a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GlobalEnvelope(Simulations, Alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GlobalEnvelope_+3A_simulations">Simulations</code></td>
<td>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, containing the simulated values.
</p>
</td></tr>
<tr><td><code id="GlobalEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>Value</h3>

<p>A matrix with two lines:
</p>
<table role = "presentation">
<tr><td><code>Glo</code></td>
<td>
<p>the lower bound of the envelope</p>
</td></tr>
<tr><td><code>Ghi</code></td>
<td>
<p>the upper bound of the envelope</p>
</td></tr>
</table>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.  
</p>

<hr>
<h2 id='GoFtest'>
Goodness of Fit test between a distance based measure of spatial structure and simulations of its null hypothesis
</h2><span id='topic+GoFtest'></span>

<h3>Description</h3>

<p>Calculates the risk to reject the null hypothesis erroneously, based on the distribution of the simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GoFtest(Envelope)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GoFtest_+3A_envelope">Envelope</code></td>
<td>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>) containing simulations in its <code>simfuns</code> attribute. It may be the result of any estimation function of the dbmss package or obtained by the <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code> function with argument <code>savefuns=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test was introduced by Diggle(1983) and extensively developped by Loosmore and Ford (2006) for <em>K</em>, and applied to <em>M</em> by Marcon et al. (2012).
</p>


<h3>Value</h3>

<p>A p-value.
</p>


<h3>Note</h3>

<p>No support exists in the literature to apply the GoF test to non-cumulative functions (<em>g</em>, <em>Kd</em>...).
</p>
<p><code><a href="#topic+Ktest">Ktest</a></code> is a much better test (it does not rely on simulations) but it is limited to the <em>K</em> function against complete spatial randomness (CSR) in a rectangle window.
</p>


<h3>References</h3>

<p>Diggle, P. J. (1983). <em>Statistical analysis of spatial point patterns</em>. Academic Press, London. 148 p.
</p>
<p>Loosmore, N. B. and  Ford, E. D. (2006). Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87(8): 1925-1931.
</p>
<p>Marcon, E., F. Puech and S. Traissac (2012). Characterizing the relative spatial structure of point patterns. International <em>Journal of Ecology</em> 2012(Article ID 619281): 11.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ktest">Ktest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a Matern (Neyman Scott) point pattern
nclust &lt;- function(x0, y0, radius, n) {
  return(runifdisc(n, radius, centre=c(x0, y0)))
}
X &lt;- rNeymanScott(20, 0.2, nclust, radius=0.3, n=10)
autoplot(as.wmppp(X))

# Calculate confidence envelope (should be 1000 simulations, reduced to 50 to save time)
r &lt;- seq(0, 0.3, 0.01)
NumberOfSimulations &lt;- 50
Alpha &lt;- .10
Envelope &lt;- KEnvelope(as.wmppp(X), r, NumberOfSimulations, Alpha)
autoplot(Envelope, ./(pi*r^2) ~ r)

# GoF test. Power is correct if enough simulations are run (say &gt;1000).
paste("p-value =", GoFtest(Envelope))
</code></pre>

<hr>
<h2 id='is.wmppp'>
Test whether an object is a weighted, marked, planar point pattern
</h2><span id='topic+is.wmppp'></span>

<h3>Description</h3>

<p>Check whether its argument is an object of class &quot;wmppp&quot; (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wmppp(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.wmppp_+3A_x">X</code></td>
<td>

<p>Any object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>X</code> is a weighted, marked, planar point pattern, otherwise <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wmppp.object">wmppp.object</a></code>
</p>

<hr>
<h2 id='KdEnvelope'>
Estimation of the confidence envelope of the Kd function under its null hypothesis
</h2><span id='topic+KdEnvelope'></span>

<h3>Description</h3>

<p>Simulates point patterns according to the null hypothesis and returns the envelope of <em>Kd</em> according to the confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KdEnvelope(X, r = NULL, NumberOfSimulations = 100, Alpha = 0.05, ReferenceType, 
           NeighborType = ReferenceType, Weighted = FALSE, Original = TRUE, 
           Approximate = ifelse(X$n &lt; 10000, 0, 1), Adjust = 1, MaxRange = "ThirdW", 
           StartFromMinR = FALSE,
           SimulationType = "RandomLocation", Global = FALSE, 
           verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KdEnvelope_+3A_x">X</code></td>
<td>

<p>A point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>) or a <code><a href="#topic+Dtable">Dtable</a></code> object.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a default value is set: 512 equally spaced values are used, and the first 256 are returned, corresponding to half the maximum distance between points (following Duranton and Overman, 2005).
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_numberofsimulations">NumberOfSimulations</code></td>
<td>

<p>The number of simulations to run, 100 by default.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level, 5% by default.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types. By default, the same as reference type.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_weighted">Weighted</code></td>
<td>

<p>Logical; if <code>TRUE</code>, estimates the <em>Kemp</em> function.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_original">Original</code></td>
<td>

<p>Logical; if <code>TRUE</code> (by default), the original bandwidth selection by Duranton and Overman (2005) following Silverman (2006: eq 3.31) is used. If <code>FALSE</code>, it is calculated following Sheather and Jones (1991), <em>i.e.</em> the state of the art. See <code><a href="stats.html#topic+bw.SJ">bw.SJ</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_approximate">Approximate</code></td>
<td>

<p>if not 0 (1 is a good choice), exact distances between pairs of points are rounded to 1024 times <code>Approximate</code> single values equally spaced between 0 and the largest distance. This technique (Scholl and Brenner, 2015) allows saving a lot of memory when addressing large point sets (the default value is 1 over 10000 points). Increasing <code>Approximate</code> allows better precision at the cost of proportional memory use. Ignored if <code>X</code> is a <code><a href="#topic+Dtable">Dtable</a></code> object.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_adjust">Adjust</code></td>
<td>

<p>Force the automatically selected bandwidth (following Silverman, 1986) to be multiplied by <code>Adjust</code>. Setting it to values lower than one (1/2 for example) will sharpen the estimation. If not 1, <code>Original</code> is ignored.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_maxrange">MaxRange</code></td>
<td>

<p>The maximum value of <code>r</code> to consider, ignored if <code>r</code> is not <code>NULL</code>. Default is &quot;ThirdW&quot;, one third of the diameter of the window. Other choices are &quot;HalfW&quot;, and &quot;QuarterW&quot; and &quot;D02005&quot;.
&quot;HalfW&quot;, and &quot;QuarterW&quot; are for half or the quarter of the diameter of the window.
&quot;D02005&quot; is for the median distance observed between points, following Duranton and Overman (2005). &quot;ThirdW&quot; should be close to &quot;DO2005&quot; but has the advantage to be independent of the point types chosen as <code>ReferenceType</code> and <code>NeighborType</code>, to simplify comparisons between different types. &quot;D02005&quot; is approximated by &quot;ThirdW&quot; if <code>Approximate</code> is not 0.
if <code>X</code> is a <code><a href="#topic+Dtable">Dtable</a></code> object, the diameter of the window is taken as the max distance between points.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_startfromminr">StartFromMinR</code></td>
<td>

<p>Logical; if <code>TRUE</code>, points are assumed to be further from each other than the minimum observed distance, So <em>Kd</em> will not be estimated below it: it is assumed to be 0. If <code>FALSE</code>, by default, distances are smoothed down to <code class="reqn">r=0</code>.
Ignored if <code>Approximate</code> is not 0: then, estimation always starts from <code class="reqn">r=0</code>.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_simulationtype">SimulationType</code></td>
<td>

<p>A string describing the null hypothesis to simulate. The null hypothesis may be
&quot;<em>RandomLocation</em>&quot;: points are redistributed on the actual locations (default);
&quot;<em>RandomLabeling</em>&quot;: randomizes point types, keeping locations and weights unchanged;
&quot;<em>PopulationIndependence</em>&quot;: keeps reference points unchanged, randomizes other point locations.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_global">Global</code></td>
<td>

<p>Logical; if <code>TRUE</code>, a global envelope sensu Duranton and Overman (2005) is calculated.
</p>
</td></tr>
<tr><td><code id="KdEnvelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if <code>TRUE</code>, print progress reports during the simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This envelope is local by default, that is to say it is computed separately at each distance. See Loosmore and Ford (2006) for a discussion.
</p>
<p>The global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>Value</h3>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>). There are methods for print and plot for this class.
</p>
<p>The <code>fv</code> contains the observed value of the function, its average simulated value and the confidence envelope.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Kenkel, N. C. (1988). Pattern of Self-Thinning in Jack Pine: Testing the Random Mortality Hypothesis. <em>Ecology</em> 69(4): 1017-1024.
</p>
<p>Loosmore, N. B. and Ford, E. D. (2006). Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87(8): 1925-1931.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>
<p>Scholl, T. and Brenner, T. (2015) Optimizing distance-based methods for large data sets, <em>Journal of Geographical Systems</em> 17(4): 333-351.
</p>
<p>Silverman, B. W. (1986). <em>Density estimation for statistics and data analysis</em>. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kdhat">Kdhat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
autoplot(paracou16[paracou16$marks$PointType=="Q. Rosea"])

# Calculate confidence envelope
plot(KdEnvelope(paracou16, , ReferenceType="Q. Rosea", Global=TRUE))

# Center of the confidence interval
Kdhat(paracou16, ReferenceType="") -&gt; kd
lines(kd$Kd ~ kd$r, lty=3, col="green")
</code></pre>

<hr>
<h2 id='Kdhat'>
Estimation of the Kd function
</h2><span id='topic+Kdhat'></span>

<h3>Description</h3>

<p>Estimates the <em>Kd</em> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'> Kdhat(X, r = NULL, ReferenceType, NeighborType = ReferenceType, Weighted = FALSE,
       Original = TRUE, Approximate = ifelse(X$n &lt; 10000, 0, 1), Adjust = 1,
       MaxRange = "ThirdW", StartFromMinR = FALSE, CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kdhat_+3A_x">X</code></td>
<td>

<p>A weighted, marked planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>) or a <code><a href="#topic+Dtable">Dtable</a></code> object.
</p>
</td></tr>
<tr><td><code id="Kdhat_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a default value is set: 512 equally spaced values are used, from the smallest distance between points to half the diameter of the window.
</p>
</td></tr>
<tr><td><code id="Kdhat_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. If &quot;&quot;, all points are considered (this is not the default value; <code>NeighborType</code> is ignored then) to estimate the average value of simulated <em>Kd</em> values under the null hypothesis of <em>RandomLocation</em> (Marcon and Puech, 2012).
</p>
</td></tr>
<tr><td><code id="Kdhat_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types. By default, the same as reference type.
</p>
</td></tr>
<tr><td><code id="Kdhat_+3A_weighted">Weighted</code></td>
<td>

<p>Logical; if <code>TRUE</code>, estimates the <em>Kemp</em> function.
</p>
</td></tr>
<tr><td><code id="Kdhat_+3A_original">Original</code></td>
<td>

<p>Logical; if <code>TRUE</code> (by default), the original bandwidth selection by Duranton and Overman (2005) following Silverman (1986: eq 3.31) is used. If <code>FALSE</code>, it is calculated following Sheather and Jones (1991), <em>i.e.</em> the state of the art. See <code><a href="stats.html#topic+bw.SJ">bw.SJ</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="Kdhat_+3A_approximate">Approximate</code></td>
<td>

<p>if not 0 (1 is a good choice), exact distances between pairs of points are rounded to 1024 times <code>Approximate</code> single values equally spaced between 0 and the largest distance. This technique (Scholl and Brenner, 2015) allows saving a lot of memory when addressing large point sets (the default value is 1 over 10000 points). Increasing <code>Approximate</code> allows better precision at the cost of proportional memory use. Ignored if <code>X</code> is a <code><a href="#topic+Dtable">Dtable</a></code> object.
</p>
</td></tr>
<tr><td><code id="Kdhat_+3A_adjust">Adjust</code></td>
<td>

<p>Force the automatically selected bandwidth (following <code>Original</code>) to be multiplied by <code>Adjust</code>. Setting it to values lower than one (1/2 for example) will sharpen the estimation.
</p>
</td></tr>
<tr><td><code id="Kdhat_+3A_maxrange">MaxRange</code></td>
<td>

<p>The maximum value of <code>r</code> to consider, ignored if <code>r</code> is not <code>NULL</code>. Default is &quot;ThirdW&quot;, one third of the diameter of the window. Other choices are &quot;HalfW&quot;, and &quot;QuarterW&quot; and &quot;D02005&quot;.
&quot;HalfW&quot;, and &quot;QuarterW&quot; are for half or the quarter of the diameter of the window.
&quot;D02005&quot; is for the median distance observed between points, following Duranton and Overman (2005). &quot;ThirdW&quot; should be close to &quot;DO2005&quot; but has the advantage to be independent of the point types chosen as <code>ReferenceType</code> and <code>NeighborType</code>, to simplify comparisons between different types. &quot;D02005&quot; is approximated by &quot;ThirdW&quot; if <code>Approximate</code> is not 0.
if <code>X</code> is a <code><a href="#topic+Dtable">Dtable</a></code> object, the diameter of the window is taken as the max distance between points.
</p>
</td></tr>
<tr><td><code id="Kdhat_+3A_startfromminr">StartFromMinR</code></td>
<td>

<p>Logical; if <code>TRUE</code>, points are assumed to be further from each other than the minimum observed distance, So <em>Kd</em> will not be estimated below it: it is assumed to be 0. If <code>FALSE</code>, distances are smoothed down to <code class="reqn">r=0</code>.
Ignored if <code>Approximate</code> is not 0: then, estimation always starts from <code class="reqn">r=0</code>.
</p>
</td></tr>
<tr><td><code id="Kdhat_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Kd</em> is a density, absolute measure of a point pattern structure. <em>Kd</em> is computed efficiently by building a matrix of distances between point pairs and calculating the density of their distribution (the default values of <code>r</code> are those of the <code><a href="stats.html#topic+density">density</a></code> function). The kernel estimator is Gaussian.
</p>
<p>The weighted <em>Kd</em> function has been named <em>Kemp</em> (<em>emp</em> is for employees) by Duranton and Overman (2005).
</p>
<p>If <code>X</code> is not a <code><a href="#topic+Dtable">Dtable</a></code> object, the maximum value of <code>r</code> is obtained from the geometry of the window rather than caculating the median distance between points as suggested by Duranton and Overman (2005) to save (a lot of) calculation time.
</p>


<h3>Value</h3>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, which can be plotted directly using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>Note</h3>

<p>Estimating <em>Kd</em> relies on calculating distances, exactly or approximately (if <code>Approximate</code> is not 0).
Then distances are smoothed by estimating their probability density.
Reflection is used to estimate density close to the lowest distance, that is the minimum observed distance (if <code>StartFromMinR</code> is <code>TRUE</code>) or 0: all distances below 4 times the estimation kernel bandwith apart from the lowest distance are duplicated (symmetrically with respect to the lowest distance) to avoid edge effects (underestimation of the density close to the lowest distance).
</p>
<p>Density estimation heavily relies on the bandwith.
Starting from version 2.7, the optimal bandwith is computed from the distribution of distances between pairs of points up to twice the maximum distance considered.
The consequence is that choosing a smaller range of distances in argument <code>r</code> results in less smoothed <code class="reqn">Kd</code> values.
The default values (<code>r = NULL</code>, <code>MaxRange = "ThirdW"</code>) are such that almost all the pairs of points (except those more than 2/3 of the window diameter apart) are taken into account to determine the bandwith.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>
<p>Scholl, T. and Brenner, T. (2015) Optimizing distance-based methods for large data sets, <em>Journal of Geographical Systems</em> 17(4): 333-351.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991) A reliable data-based bandwidth selection method for kernel density estimation. <em>Journal of the Royal Statistical Society series B</em>, 53, 683-690.
</p>
<p>Silverman, B. W. (1986). <em>Density estimation for statistics and data analysis</em>. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KdEnvelope">KdEnvelope</a></code>, <code><a href="#topic+Mhat">Mhat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
autoplot(paracou16)

# Calculate Kd
(Paracou &lt;- Kdhat(paracou16, , "Q. Rosea", "V. Americana"))
# Plot
autoplot(Paracou)
</code></pre>

<hr>
<h2 id='KEnvelope'>
Estimation of the confidence envelope of the K function under its null hypothesis
</h2><span id='topic+KEnvelope'></span>

<h3>Description</h3>

<p>Simulates point patterns according to the null hypothesis and returns the envelope of <em>K</em> according to the confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KEnvelope(X, r = NULL, NumberOfSimulations = 100, Alpha = 0.05, 
          ReferenceType = "", NeighborType = ReferenceType, 
          SimulationType = "RandomPosition", Precision = 0, Global = FALSE,
          verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KEnvelope_+3A_x">X</code></td>
<td>

<p>A point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="KEnvelope_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="KEnvelope_+3A_numberofsimulations">NumberOfSimulations</code></td>
<td>

<p>The number of simulations to run, 100 by default.
</p>
</td></tr>
<tr><td><code id="KEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level, 5% by default.
</p>
</td></tr>
<tr><td><code id="KEnvelope_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="KEnvelope_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types. By default, the same as reference type.
</p>
</td></tr>
<tr><td><code id="KEnvelope_+3A_simulationtype">SimulationType</code></td>
<td>

<p>A string describing the null hypothesis to simulate. The null hypothesis may be
&quot;<em>RandomPosition</em>&quot;: points are drawn in a Poisson process (default);
&quot;<em>RandomLabeling</em>&quot;: randomizes point types, keeping locations unchanged;
&quot;<em>PopulationIndependence</em>&quot;: keeps reference points unchanged, shifts other point locations.
</p>
</td></tr>
<tr><td><code id="KEnvelope_+3A_precision">Precision</code></td>
<td>

<p>Accuracy of point coordinates, measured as a part of distance unit. See <code><a href="#topic+rRandomPositionK">rRandomPositionK</a></code>. Default is 0 for no approximation.
</p>
</td></tr>
<tr><td><code id="KEnvelope_+3A_global">Global</code></td>
<td>

<p>Logical; if <code>TRUE</code>, a global envelope sensu Duranton and Overman (2005) is calculated.
</p>
</td></tr>
<tr><td><code id="KEnvelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if <code>TRUE</code>, print progress reports during the simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This envelope is local by default, that is to say it is computed separately at each distance. See Loosmore and Ford (2006) for a discussion.
</p>
<p>The global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>Value</h3>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>). There are methods for print and plot for this class.
</p>
<p>The <code>fv</code> contains the observed value of the function, its average simulated value and the confidence envelope.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Kenkel, N. C. (1988). Pattern of Self-Thinning in Jack Pine: Testing the Random Mortality Hypothesis. <em>Ecology</em> 69(4): 1017-1024.
</p>
<p>Loosmore, N. B. and Ford, E. D. (2006). Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87(8): 1925-1931.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>
<p>Silverman, B. W. (1986). <em>Density estimation for statistics and data analysis</em>. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Khat">Khat</a></code>, <code><a href="#topic+rRandomPositionK">rRandomPositionK</a></code>, <code><a href="#topic+rRandomLocation">rRandomLocation</a></code>, <code><a href="#topic+rPopulationIndependenceK">rPopulationIndependenceK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 20% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.2))
autoplot(X, 
  labelSize = expression("Basal area (" ~cm^2~ ")"), 
  labelColor = "Species")

# Calculate confidence envelope (should be 1000 simulations, reduced to 20 to save time)
r &lt;- 0:30
NumberOfSimulations &lt;- 20
# Plot the envelope
autoplot(KEnvelope(X, r, NumberOfSimulations), ./(pi*r^2) ~ r)
</code></pre>

<hr>
<h2 id='Khat'>
Estimation of the K function
</h2><span id='topic+Khat'></span>

<h3>Description</h3>

<p>Estimates the <em>K</em> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Khat(X, r = NULL, ReferenceType = "", NeighborType = ReferenceType, CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Khat_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="Khat_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="Khat_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="Khat_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types. By default, the same as reference type.
</p>
</td></tr>
<tr><td><code id="Khat_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>K</em> is a cumulative, topographic measure of a point pattern structure.
</p>


<h3>Value</h3>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, which can be plotted directly using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>Note</h3>

<p>The computation of <code>Khat</code> relies on spatstat functions <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> and <code><a href="spatstat.explore.html#topic+Kcross">Kcross</a></code>.
</p>


<h3>References</h3>

<p>Ripley, B. D. (1976). The Foundations of Stochastic Geometry. <em>Annals of Probability</em> 4(6): 995-998.
</p>
<p>Ripley, B. D. (1977). Modelling Spatial Patterns. <em>Journal of the Royal Statistical Society B</em> 39(2): 172-212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lhat">Lhat</a></code>, <code><a href="#topic+KEnvelope">KEnvelope</a></code>, <code><a href="#topic+Ktest">Ktest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
autoplot(paracou16)

# Calculate K
r &lt;- 0:30
(Paracou &lt;- Khat(paracou16, r))

# Plot (after normalization by pi.r^2)
autoplot(Paracou, ./(pi*r^2) ~ r)
</code></pre>

<hr>
<h2 id='KinhomEnvelope'>
Estimation of the confidence envelope of the Kinhom function under its null hypothesis
</h2><span id='topic+KinhomEnvelope'></span>

<h3>Description</h3>

<p>Simulates point patterns according to the null hypothesis and returns the envelope of <em>Kinhom</em> according to the confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KinhomEnvelope(X, r = NULL, NumberOfSimulations = 100, Alpha = 0.05, 
               ReferenceType = "", lambda = NULL, SimulationType = "RandomPosition", 
               Global = FALSE, verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KinhomEnvelope_+3A_x">X</code></td>
<td>

<p>A point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="KinhomEnvelope_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="KinhomEnvelope_+3A_numberofsimulations">NumberOfSimulations</code></td>
<td>

<p>The number of simulations to run.
</p>
</td></tr>
<tr><td><code id="KinhomEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level.
</p>
</td></tr>
<tr><td><code id="KinhomEnvelope_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="KinhomEnvelope_+3A_lambda">lambda</code></td>
<td>

<p>An estimation of the point pattern density, obtained by the <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> function.
</p>
</td></tr>
<tr><td><code id="KinhomEnvelope_+3A_simulationtype">SimulationType</code></td>
<td>

<p>A string describing the null hypothesis to simulate. The null hypothesis, may be 
&quot;<em>RandomPosition</em>&quot;: points are drawn in an inhomogenous Poisson process (intensity is either <code>lambda</code> or estimated from <code>X</code>); 
&quot;<em>RandomLocation</em>&quot;: points are redistributed across actual locations;
&quot;<em>RandomLabeling</em>&quot;: randomizes point types, keeping locations unchanged;
&quot;<em>PopulationIndependence</em>&quot;: keeps reference points unchanged, redistributes others across actual locations.
</p>
</td></tr>
<tr><td><code id="KinhomEnvelope_+3A_global">Global</code></td>
<td>

<p>Logical; if <code>TRUE</code>, a global envelope sensu Duranton and Overman (2005) is calculated. 
</p>
</td></tr>
<tr><td><code id="KinhomEnvelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if <code>TRUE</code>, print progress reports during the simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random location null hypothesis is that of Duranton and Overman (2005). It is appropriate to test the univariate <em>Kinhom</em> function of a single point type, redistributing it over all point locations.
It allows fixing lambda along simulations so the warning message can be ignored.
</p>
<p>The random labeling hypothesis is appropriate for the bivariate <em>Kinhom</em> function.
</p>
<p>The population independence hypothesis is that of Marcon and Puech (2010).
</p>
<p>This envelope is local by default, that is to say it is computed separately at each distance. See Loosmore and Ford (2006) for a discussion.
</p>
<p>The global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>Value</h3>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>). There are methods for print and plot for this class.
</p>
<p>The <code>fv</code> contains the observed value of the function, its average simulated value and the confidence envelope.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Kenkel, N. C. (1988). Pattern of Self-Thinning in Jack Pine: Testing the Random Mortality Hypothesis. <em>Ecology</em> 69(4): 1017-1024.
</p>
<p>Loosmore, N. B. and Ford, E. D. (2006). Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87(8): 1925-1931.
</p>
<p>Marcon, E. and Puech, F. (2010). Measures of the Geographic Concentration of Industries: Improving Distance-Based Methods. <em>Journal of Economic Geography</em> 10(5): 745-762.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kinhomhat">Kinhomhat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 20% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.2))
autoplot(X, 
  labelSize = expression("Basal area (" ~cm^2~ ")"), 
  labelColor = "Species")

# Density of all trees
lambda &lt;- density.ppp(X, bw.diggle(X))
plot(lambda)
V.americana &lt;- X[X$marks$PointType=="V. Americana"]
plot(V.americana, add=TRUE)

# Calculate Kinhom according to the density of all trees
# and confidence envelope (should be 1000 simulations, reduced to 4 to save time)
r &lt;- 0:30
NumberOfSimulations &lt;- 4
Alpha &lt;- .10
autoplot(KinhomEnvelope(X, r,NumberOfSimulations, Alpha, , 
    SimulationType="RandomPosition", lambda=lambda), ./(pi*r^2) ~ r)
</code></pre>

<hr>
<h2 id='Kinhomhat'>
Estimation of the inhomogenous K function
</h2><span id='topic+Kinhomhat'></span>

<h3>Description</h3>

<p>Estimates the <em>Kinhom</em> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kinhomhat(X, r = NULL, ReferenceType = "", lambda = NULL, CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kinhomhat_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="Kinhomhat_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="Kinhomhat_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="Kinhomhat_+3A_lambda">lambda</code></td>
<td>

<p>An estimation of the point pattern density, obtained by the <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> function.
</p>
</td></tr>
<tr><td><code id="Kinhomhat_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Kinhom</em> is a cumulative, topographic measure of an inhomogenous point pattern structure.
</p>
<p>By default, density estimation is performed at points by <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> using the optimal bandwith (<code><a href="spatstat.explore.html#topic+bw.diggle">bw.diggle</a></code>). It can be calculated separately (see example), including at pixels if the point pattern is too large for the default estimation to succeed, and provided as the argument <code>lambda</code>:
Arbia et al. (2012) for example use another point pattern as a reference to estimate density.
</p>
<p>Bivariate <em>Kinhom</em> is not currently supported.
</p>


<h3>Value</h3>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, which can be plotted directly using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>Note</h3>

<p>The computation of <code>Kinhomhat</code> relies on spatstat functions <code><a href="spatstat.explore.html#topic+Kinhom">Kinhom</a></code>, <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> and <code><a href="spatstat.explore.html#topic+bw.diggle">bw.diggle</a></code>.
</p>


<h3>References</h3>

<p>Baddeley, A. J., J. Moller, et al. (2000). Non- and semi-parametric estimation of interaction in inhomogeneous point patterns. <em>Statistica Neerlandica</em> 54(3): 329-350.
</p>
<p>Arbia, G., G. Espa, et al. (2012). Clusters of firms in an inhomogeneous space: The high-tech industries in Milan. <em>Economic Modelling</em> 29(1): 3-11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KinhomEnvelope">KinhomEnvelope</a></code>, <code><a href="spatstat.explore.html#topic+Kinhom">Kinhom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)

# Density of all trees
lambda &lt;- density.ppp(paracou16, bw.diggle(paracou16))
plot(lambda)
# Reduce the point pattern to one type of trees
V.americana &lt;- paracou16[paracou16$marks$PointType=="V. Americana"]
plot(V.americana, add=TRUE)

# Calculate Kinhom according to the density of all trees
r &lt;- 0:30
autoplot(Kinhomhat(paracou16, r, "V. Americana", lambda), ./(pi*r^2) ~ r)
</code></pre>

<hr>
<h2 id='KmmEnvelope'>
Estimation of the confidence envelope of the Lmm function under its null hypothesis
</h2><span id='topic+KmmEnvelope'></span>

<h3>Description</h3>

<p>Simulates point patterns according to the null hypothesis and returns the envelope of <em>Lmm</em> according to the confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KmmEnvelope(X, r = NULL, NumberOfSimulations = 100, Alpha = 0.05, ReferenceType = "",
            Global = FALSE, verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KmmEnvelope_+3A_x">X</code></td>
<td>

<p>A point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="KmmEnvelope_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="KmmEnvelope_+3A_numberofsimulations">NumberOfSimulations</code></td>
<td>

<p>The number of simulations to run, 100 by default.
</p>
</td></tr>
<tr><td><code id="KmmEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level, 5% by default.
</p>
</td></tr>
<tr><td><code id="KmmEnvelope_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Others are ignored. Default is all point types.
</p>
</td></tr>
<tr><td><code id="KmmEnvelope_+3A_global">Global</code></td>
<td>

<p>Logical; if <code>TRUE</code>, a global envelope sensu Duranton and Overman (2005) is calculated. 
</p>
</td></tr>
<tr><td><code id="KmmEnvelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if <code>TRUE</code>, print progress reports during the simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This envelope is local by default, that is to say it is computed separately at each distance. See Loosmore and Ford (2006) for a discussion.
</p>
<p>The global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>Value</h3>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>). There are methods for print and plot for this class.
</p>
<p>The <code>fv</code> contains the observed value of the function, its average simulated value and the confidence envelope.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Kenkel, N. C. (1988). Pattern of Self-Thinning in Jack Pine: Testing the Random Mortality Hypothesis. <em>Ecology</em> 69(4): 1017-1024.
</p>
<p>Loosmore, N. B. and Ford, E. D. (2006). Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87(8): 1925-1931.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kmmhat">Kmmhat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 20% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.2))
autoplot(X, 
  labelSize = expression("Basal area (" ~cm^2~ ")"), 
  labelColor = "Species")

# Calculate confidence envelope (should be 1000 simulations, reduced to 4 to save time)
r &lt;- seq(0, 30, 2)
NumberOfSimulations &lt;- 4
Alpha &lt;- .10
autoplot(KmmEnvelope(X, r, NumberOfSimulations, Alpha), ./(pi*r^2) ~ r)
</code></pre>

<hr>
<h2 id='Kmmhat'>
Estimation of the Kmm function
</h2><span id='topic+Kmmhat'></span>

<h3>Description</h3>

<p>Estimates of the <em>Kmm</em> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kmmhat(X, r = NULL, ReferenceType = "", CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kmmhat_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="Kmmhat_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="Kmmhat_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Others are ignored. Default is all point types.
</p>
</td></tr>
<tr><td><code id="Kmmhat_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>Kmm</em> function is used to test the independence of marks.
</p>


<h3>Value</h3>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, which can be plotted directly using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>Note</h3>

<p>The function is computed using <code><a href="spatstat.explore.html#topic+markcorrint">markcorrint</a></code> in spatstat.
</p>


<h3>References</h3>

<p>Penttinen, A., Stoyan, D. and Henttonen, H. M. (1992). Marked Point Processes in Forest Statistics. <em>Forest Science</em> 38(4): 806-824.
</p>
<p>Penttinen, A. (2006). Statistics for Marked Point Patterns. in <em>The Yearbook of the Finnish Statistical Society</em>. The Finnish Statistical Society, Helsinki: 70-91.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lmmhat">Lmmhat</a></code>, <code><a href="#topic+LmmEnvelope">LmmEnvelope</a></code>, <code><a href="spatstat.explore.html#topic+markcorrint">markcorrint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 50% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.5))
autoplot(X, 
  labelSize = expression("Basal area (" ~cm^2~ ")"), 
  labelColor = "Species")

# Calculate Kmm
r &lt;- seq(0, 30, 2)
(Paracou &lt;- Kmmhat(X, r))

# Plot
autoplot(Paracou, ./(pi*r^2) ~ r)
</code></pre>

<hr>
<h2 id='Ktest'>
Test of a point pattern against Complete Spatial Randomness
</h2><span id='topic+Ktest'></span>

<h3>Description</h3>

<p>Tests the point pattern against CSR using values of the <em>K</em> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ktest(X, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ktest_+3A_x">X</code></td>
<td>

<p>A point pattern (<code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code>). Marks are ignored. The window must be a rectangle sensu spatstat (tested by <code><a href="spatstat.geom.html#topic+is.rectangle">is.rectangle</a></code>).
</p>
</td></tr>
<tr><td><code id="Ktest_+3A_r">r</code></td>
<td>

<p>A vector of distances.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test returns the risk to reject CSR erroneously, i.e. the p-value of the test, based on the distribution of the <em>K</em> function.
</p>
<p>If <code>r</code> includes 0, it will be silently removed because no neighbor point can be found at distance 0.
The longer <code>r</code>, the more accurate the test is in theory but at the cost of computation time first, and of computation accuracy then because a matrix of size the length of <code>r</code> must be inverted.
10 values in <code>r</code> seems to be a reasonable choice.
</p>


<h3>Value</h3>

<p>A p-value.
</p>


<h3>Author(s)</h3>

<p>Gabriel Lang &lt;Gabriel.Lang@agroparistech.fr&gt;, Eric Marcon&lt;Eric.Marcon@agroparistech.fr&gt;
</p>


<h3>References</h3>

<p>Lang, G. and Marcon, E. (2013). Testing randomness of spatial point patterns with the Ripley statistic. <em>ESAIM: Probability and Statistics.</em> 17: 767-788.
</p>
<p>Marcon, E., S. Traissac, and Lang, G. (2013). A Statistical Test for Ripley's Function Rejection of Poisson Null Hypothesis. <em>ISRN Ecology</em> 2013(Article ID 753475): 9.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Khat">Khat</a></code>, <code><a href="#topic+GoFtest">GoFtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a Matern (Neyman Scott) point pattern
nclust &lt;- function(x0, y0, radius, n) {
  return(runifdisc(n, radius, centre=c(x0, y0)))
}
X &lt;- rNeymanScott(20, 0.1, nclust, radius=0.2, n=5)
autoplot(as.wmppp(X))

# Test it
Ktest(X, r=seq(0.1, .5, .1))
</code></pre>

<hr>
<h2 id='LEnvelope'>
Estimation of the confidence envelope of the L function under its null hypothesis
</h2><span id='topic+LEnvelope'></span>

<h3>Description</h3>

<p>Simulates point patterns according to the null hypothesis and returns the envelope of <em>L</em> according to the confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LEnvelope(X, r = NULL, NumberOfSimulations = 100, Alpha = 0.05, 
          ReferenceType = "", NeighborType = "", SimulationType = "RandomPosition", 
          Precision = 0, Global = FALSE, verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LEnvelope_+3A_x">X</code></td>
<td>

<p>A point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="LEnvelope_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="LEnvelope_+3A_numberofsimulations">NumberOfSimulations</code></td>
<td>

<p>The number of simulations to run, 100 by default.
</p>
</td></tr>
<tr><td><code id="LEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level, 5% by default.
</p>
</td></tr>
<tr><td><code id="LEnvelope_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="LEnvelope_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="LEnvelope_+3A_simulationtype">SimulationType</code></td>
<td>

<p>A string describing the null hypothesis to simulate. The null hypothesis may be &quot;<em>RandomPosition</em>&quot;: points are drawn in a Poisson process (default); &quot;<em>RandomLabeling</em>&quot;: randomizes point types, keeping locations unchanged; &quot;<em>PopulationIndependence</em>&quot;: keeps reference points unchanged, randomizes other point locations.
</p>
</td></tr>
<tr><td><code id="LEnvelope_+3A_precision">Precision</code></td>
<td>

<p>Accuracy of point coordinates, measured as a part of distance unit. See <code><a href="#topic+rRandomPositionK">rRandomPositionK</a></code>. Default is 0 for no approximation.
</p>
</td></tr>
<tr><td><code id="LEnvelope_+3A_global">Global</code></td>
<td>

<p>Logical; if <code>TRUE</code>, a global envelope sensu Duranton and Overman (2005) is calculated.
</p>
</td></tr>
<tr><td><code id="LEnvelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if <code>TRUE</code>, print progress reports during the simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This envelope is local by default, that is to say it is computed separately at each distance. See Loosmore and Ford (2006) for a discussion.
</p>
<p>The global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>Value</h3>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>). There are methods for print and plot for this class.
</p>
<p>The <code>fv</code> contains the observed value of the function, its average simulated value and the confidence envelope.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Kenkel, N. C. (1988). Pattern of Self-Thinning in Jack Pine: Testing the Random Mortality Hypothesis. <em>Ecology</em> 69(4): 1017-1024.
</p>
<p>Loosmore, N. B. and Ford, E. D. (2006). Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87(8): 1925-1931.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Khat">Khat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 20% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.2))
autoplot(X, 
  labelSize = expression("Basal area (" ~cm^2~ ")"), 
  labelColor = "Species")

# Calculate confidence envelope (should be 1000 simulations, reduced to 20 to save time)
r &lt;- 0:30
NumberOfSimulations &lt;- 20
# Plot the envelope
autoplot(LEnvelope(X, r, NumberOfSimulations))
</code></pre>

<hr>
<h2 id='Lhat'>
Estimation of the L function
</h2><span id='topic+Lhat'></span>

<h3>Description</h3>

<p>Estimates the <em>L</em> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lhat(X, r = NULL, ReferenceType = "", NeighborType = "", CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lhat_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="Lhat_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="Lhat_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="Lhat_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types. Default is all point types.
</p>
</td></tr>
<tr><td><code id="Lhat_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>L</em> is the normalized version of <em>K</em>: <code class="reqn">L(r)=\sqrt{\frac{K}{\pi}}-r</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, which can be plotted directly using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>Note</h3>

<p><em>L</em> was originally defined as <code class="reqn">L(r)=\sqrt{\frac{K}{\pi}}</code>. It has been used as <code class="reqn">L(r)=\sqrt{\frac{K}{\pi}}-r</code> in a part of the literature because this normalization is easier to plot.
</p>


<h3>References</h3>

<p>Besag, J. E. (1977). Comments on Ripley's paper. <em>Journal of the Royal Statistical Society B</em> 39(2): 193-195.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Khat">Khat</a></code>, <code><a href="#topic+LEnvelope">LEnvelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
autoplot(paracou16)

# Calculate L
r &lt;- 0:30
(Paracou &lt;- Lhat(paracou16, r))

# Plot
autoplot(Paracou)
</code></pre>

<hr>
<h2 id='LmmEnvelope'>
Estimation of the confidence envelope of the Lmm function under its null hypothesis
</h2><span id='topic+LmmEnvelope'></span>

<h3>Description</h3>

<p>Simulates point patterns according to the null hypothesis and returns the envelope of <em>Lmm</em> according to the confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LmmEnvelope(X, r = NULL, NumberOfSimulations = 100, Alpha = 0.05, ReferenceType = "", 
            Global = FALSE, verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LmmEnvelope_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="LmmEnvelope_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="LmmEnvelope_+3A_numberofsimulations">NumberOfSimulations</code></td>
<td>

<p>The number of simulations to run, 100 by default.
</p>
</td></tr>
<tr><td><code id="LmmEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level, 5% by default.
</p>
</td></tr>
<tr><td><code id="LmmEnvelope_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Others are ignored. Default is all point types.
</p>
</td></tr>
<tr><td><code id="LmmEnvelope_+3A_global">Global</code></td>
<td>

<p>Logical; if <code>TRUE</code>, a global envelope sensu Duranton and Overman (2005) is calculated.
</p>
</td></tr>
<tr><td><code id="LmmEnvelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if <code>TRUE</code>, print progress reports during the simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This envelope is local by default, that is to say it is computed separately at each distance. See Loosmore and Ford (2006) for a discussion.
</p>
<p>The global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>Value</h3>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>). There are methods for print and plot for this class.
</p>
<p>The <code>fv</code> contains the observed value of the function, its average simulated value and the confidence envelope.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Kenkel, N. C. (1988). Pattern of Self-Thinning in Jack Pine: Testing the Random Mortality Hypothesis. <em>Ecology</em> 69(4): 1017-1024.
</p>
<p>Loosmore, N. B. and Ford, E. D. (2006). Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87(8): 1925-1931.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lmmhat">Lmmhat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 20% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.2))
autoplot(X, 
  labelSize = expression("Basal area (" ~cm^2~ ")"), 
  labelColor = "Species")

# Calculate confidence envelope (should be 1000 simulations, reduced to 4 to save time)
r &lt;- seq(0, 30, 2)
NumberOfSimulations &lt;- 4
Alpha &lt;- .10
autoplot(LmmEnvelope(X, r, NumberOfSimulations, Alpha))
</code></pre>

<hr>
<h2 id='Lmmhat'>
Estimation of the Lmm function
</h2><span id='topic+Lmmhat'></span>

<h3>Description</h3>

<p>Estimates the <em>Lmm</em> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lmmhat(X, r = NULL, ReferenceType = "", CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lmmhat_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="Lmmhat_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a sensible default value is chosen (512 intervals, from 0 to half the diameter of the window) following <strong>spatstat</strong>.
</p>
</td></tr>
<tr><td><code id="Lmmhat_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types. Others are ignored. Default is all point types.
</p>
</td></tr>
<tr><td><code id="Lmmhat_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Lmm</em> is the normalized version of <em>Kmm</em>: <code class="reqn">Lmm(r)=\sqrt{\frac{Kmm}{\pi}}-r</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, which can be plotted directly using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>


<h3>References</h3>

<p>Penttinen, A., Stoyan, D. and Henttonen, H. M. (1992). Marked Point Processes in Forest Statistics. <em>Forest Science</em> 38(4): 806-824.
</p>
<p>Espa, G., Giuliani, D. and Arbia, G. (2010). Weighting Ripley's K-function to account for the firm dimension in the analysis of spatial concentration. <em>Discussion Papers</em>, 12/2010. Universita di Trento, Trento: 26.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kmmhat">Kmmhat</a></code>, <code><a href="#topic+LmmEnvelope">LmmEnvelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 50% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.5))
autoplot(X, 
  labelSize = expression("Basal area (" ~cm^2~ ")"), 
  labelColor = "Species")

# Calculate Lmm
r &lt;- seq(0, 30, 2)
(Paracou &lt;- Lmmhat(X, r))

# Plot
autoplot(Paracou)
</code></pre>

<hr>
<h2 id='mEnvelope'>
Estimation of the confidence envelope of the m function under its null hypothesis
</h2><span id='topic+mEnvelope'></span>

<h3>Description</h3>

<p>Simulates point patterns according to the null hypothesis and returns the envelope of <em>m</em> according to the confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mEnvelope(X, r = NULL, NumberOfSimulations = 100, Alpha = 0.05,
          ReferenceType, NeighborType = ReferenceType, CaseControl = FALSE,
          Original = TRUE, Approximate = ifelse(X$n &lt; 10000, 0, 1), Adjust = 1, 
          MaxRange = "ThirdW", SimulationType = "RandomLocation", Global = FALSE,
          verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mEnvelope_+3A_x">X</code></td>
<td>

<p>A point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a default value is set: 512 equally spaced values are used up to the median distance between points (following Duranton and Overman, 2005).
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_numberofsimulations">NumberOfSimulations</code></td>
<td>

<p>The number of simulations to run, 100 by default.
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level, 5% by default.
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types.
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types, equal to the reference type by default to caculate univariate M.
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_casecontrol">CaseControl</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the case-control version of <em>M</em> is computed. <em>ReferenceType</em> points are cases, <em>NeighborType</em> points are controls.
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_original">Original</code></td>
<td>

<p>Logical; if <code>TRUE</code> (by default), the original bandwidth selection by Duranton and Overman (2005) following Silverman (1986: eq 3.31) is used. If <code>FALSE</code>, it is calculated following Sheather and Jones (1991), <em>i.e.</em> the state of the art. See <code><a href="stats.html#topic+bw.SJ">bw.SJ</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_approximate">Approximate</code></td>
<td>

<p>if not 0 (1 is a good choice), exact distances between pairs of points are rounded to 1024 times <code>Approximate</code> single values equally spaced between 0 and the largest distance. This technique (Scholl and Brenner, 2015) allows saving a lot of memory when addressing large point sets (the default value is 1 over 10000 points). Increasing <code>Approximate</code> allows better precision at the cost of proportional memory use.
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_adjust">Adjust</code></td>
<td>

<p>Force the automatically selected bandwidth (following <code>Original</code>) to be multiplied by <code>Adjust</code>. Setting it to values lower than one (1/2 for example) will sharpen the estimation. 
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_maxrange">MaxRange</code></td>
<td>

<p>The maximum value of <code>r</code> to consider, ignored if <code>r</code> is not <code>NULL</code>. Default is &quot;ThirdW&quot;, one third of the diameter of the window. Other choices are &quot;HalfW&quot;, and &quot;QuarterW&quot; and &quot;D02005&quot;.
&quot;HalfW&quot;, and &quot;QuarterW&quot; are for half or the quarter of the diameter of the window.
&quot;D02005&quot; is for the median distance observed between points, following Duranton and Overman (2005). &quot;ThirdW&quot; should be close to &quot;DO2005&quot; but has the advantage to be independent of the point types chosen as <code>ReferenceType</code> and <code>NeighborType</code>, to simplify comparisons between different types. &quot;D02005&quot; is approximated by &quot;ThirdW&quot; if <code>Approximate</code> is not 0.
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_simulationtype">SimulationType</code></td>
<td>

<p>A string describing the null hypothesis to simulate. The null hypothesis may be
&quot;<em>RandomLocation</em>&quot;: points are redistributed on the actual locations (default);
&quot;<em>RandomLabeling</em>&quot;: randomizes point types, keeping locations and weights unchanged;
&quot;<em>PopulationIndependence</em>&quot;: keeps reference points unchanged, randomizes other point locations.
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_global">Global</code></td>
<td>

<p>Logical; if <code>TRUE</code>, a global envelope sensu Duranton and Overman (2005) is calculated. 
</p>
</td></tr>
<tr><td><code id="mEnvelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if <code>TRUE</code>, print progress reports during the simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This envelope is local by default, that is to say it is computed separately at each distance. See Loosmore and Ford (2006) for a discussion.
</p>
<p>The global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>Value</h3>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>). There are methods for print and plot for this class.
</p>
<p>The <code>fv</code> contains the observed value of the function, its average simulated value and the confidence envelope.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Kenkel, N. C. (1988). Pattern of Self-Thinning in Jack Pine: Testing the Random Mortality Hypothesis. <em>Ecology</em> 69(4): 1017-1024.
</p>
<p>Lang G., Marcon E. and Puech F. (2014) Distance-Based Measures of Spatial Concentration: Introducing a Relative Density Function. <em>HAL</em> 01082178, 1-18.
</p>
<p>Loosmore, N. B. and Ford, E. D. (2006). Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87(8): 1925-1931.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>
<p>Scholl, T. and Brenner, T. (2015) Optimizing distance-based methods for large data sets, <em>Journal of Geographical Systems</em> 17(4): 333-351.
</p>
<p>Silverman, B. W. (1986). <em>Density estimation for statistics and data analysis</em>. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mhat">mhat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 50% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.5))
autoplot(X, 
  labelSize = expression("Basal area (" ~cm^2~ ")"), 
  labelColor = "Species")

# Calculate confidence envelope (should be 1000 simulations, reduced to 4 to save time)
NumberOfSimulations &lt;- 4
Alpha &lt;- .10
autoplot(mEnvelope(X, , NumberOfSimulations, Alpha, 
    "V. Americana", "Q. Rosea", Original = FALSE, SimulationType = "RandomLabeling"))
</code></pre>

<hr>
<h2 id='MEnvelope'>
Estimation of the confidence envelope of the M function under its null hypothesis
</h2><span id='topic+MEnvelope'></span>

<h3>Description</h3>

<p>Simulates point patterns according to the null hypothesis and returns the envelope of <em>M</em> according to the confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEnvelope(X, r = NULL, NumberOfSimulations = 100, Alpha = 0.05,
          ReferenceType, NeighborType = ReferenceType, 
          CaseControl = FALSE, SimulationType = "RandomLocation", Global = FALSE,
          verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MEnvelope_+3A_x">X</code></td>
<td>

<p>A point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>) or a <code><a href="#topic+Dtable">Dtable</a></code> object.
</p>
</td></tr>
<tr><td><code id="MEnvelope_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a default value is set: 32 unequally spaced values are used up to half the maximum distance between points <code class="reqn">d_m</code>. The first value is 0, first steps are small (<code class="reqn">d_m/200</code>) then incresase progressively up to <code class="reqn">d_m/20</code>.
</p>
</td></tr>
<tr><td><code id="MEnvelope_+3A_numberofsimulations">NumberOfSimulations</code></td>
<td>

<p>The number of simulations to run, 100 by default.
</p>
</td></tr>
<tr><td><code id="MEnvelope_+3A_alpha">Alpha</code></td>
<td>

<p>The risk level, 5% by default.
</p>
</td></tr>
<tr><td><code id="MEnvelope_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types.
</p>
</td></tr>
<tr><td><code id="MEnvelope_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types, equal to the reference type by default to caculate univariate M.
</p>
</td></tr>
<tr><td><code id="MEnvelope_+3A_casecontrol">CaseControl</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the case-control version of <em>M</em> is computed. <em>ReferenceType</em> points are cases, <em>NeighborType</em> points are controls.
</p>
</td></tr>
<tr><td><code id="MEnvelope_+3A_simulationtype">SimulationType</code></td>
<td>

<p>A string describing the null hypothesis to simulate. The null hypothesis may be
&quot;<em>RandomLocation</em>&quot;: points are redistributed on the actual locations (default);
&quot;<em>RandomLabeling</em>&quot;: randomizes point types, keeping locations and weights unchanged;
&quot;<em>PopulationIndependence</em>&quot;: keeps reference points unchanged, randomizes other point locations.
</p>
</td></tr>
<tr><td><code id="MEnvelope_+3A_global">Global</code></td>
<td>

<p>Logical; if <code>TRUE</code>, a global envelope sensu Duranton and Overman (2005) is calculated.
</p>
</td></tr>
<tr><td><code id="MEnvelope_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if <code>TRUE</code>, print progress reports during the simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This envelope is local by default, that is to say it is computed separately at each distance. See Loosmore and Ford (2006) for a discussion.
</p>
<p>The global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>Value</h3>

<p>An envelope object (<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>). There are methods for print and plot for this class.
</p>
<p>The <code>fv</code> contains the observed value of the function, its average simulated value and the confidence envelope.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Kenkel, N. C. (1988). Pattern of Self-Thinning in Jack Pine: Testing the Random Mortality Hypothesis. <em>Ecology</em> 69(4): 1017-1024.
</p>
<p>Loosmore, N. B. and Ford, E. D. (2006). Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87(8): 1925-1931.
</p>
<p>Marcon, E. and F. Puech (2017). A typology of distance-based measures of spatial concentration. <em>Regional Science and Urban Economics</em>. 62:56-67.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mhat">Mhat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Keep only 50% of points to run this example
X &lt;- as.wmppp(rthin(paracou16, 0.5))
autoplot(X, 
  labelSize = expression("Basal area (" ~cm^2~ ")"), 
  labelColor = "Species")

# Calculate confidence envelope (should be 1000 simulations, reduced to 4 to save time)
NumberOfSimulations &lt;- 4
Alpha &lt;- .10
autoplot(MEnvelope(X, , NumberOfSimulations, Alpha, 
    "V. Americana", "Q. Rosea", FALSE, "RandomLabeling"))
</code></pre>

<hr>
<h2 id='mhat'>
Estimation of the m function
</h2><span id='topic+mhat'></span>

<h3>Description</h3>

<p>Estimates the <em>m</em> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mhat(X, r = NULL, ReferenceType, NeighborType = ReferenceType,
    CaseControl = FALSE, Original = TRUE, Approximate = ifelse(X$n &lt; 10000, 0, 1),
    Adjust = 1, MaxRange = "ThirdW", Individual = FALSE, CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mhat_+3A_x">X</code></td>
<td>

<p>A weighted, marked planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>) or a <code><a href="#topic+Dtable">Dtable</a></code> object.
</p>
</td></tr>
<tr><td><code id="mhat_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a default value is set: 512 equally spaced values are used, from the smallest distance to the range defined by <code>MaxRange</code>. the between points to half the diameter of the window.
</p>
</td></tr>
<tr><td><code id="mhat_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types.
</p>
</td></tr>
<tr><td><code id="mhat_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types. By default, the same as reference type.
</p>
</td></tr>
<tr><td><code id="mhat_+3A_casecontrol">CaseControl</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the case-control version of <em>M</em> is computed. <em>ReferenceType</em> points are cases, <em>NeighborType</em> points are controls.
</p>
</td></tr>
<tr><td><code id="mhat_+3A_original">Original</code></td>
<td>

<p>Logical; if <code>TRUE</code> (by default), the original bandwidth selection by Duranton and Overman (2005) following Silverman (1986: eq 3.31) is used. If <code>FALSE</code>, it is calculated following Sheather and Jones (1991), <em>i.e.</em> the state of the art. See <code><a href="stats.html#topic+bw.SJ">bw.SJ</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="mhat_+3A_approximate">Approximate</code></td>
<td>

<p>if not 0 (1 is a good choice), exact distances between pairs of points are rounded to 1024 times <code>Approximate</code> single values equally spaced between 0 and the largest distance. This technique (Scholl and Brenner, 2015) allows saving a lot of memory when addressing large point sets (the default value is 1 over 10000 points). Increasing <code>Approximate</code> allows better precision at the cost of proportional memory use. Ignored if <code>X</code> is a <code><a href="#topic+Dtable">Dtable</a></code> object.
</p>
</td></tr>
<tr><td><code id="mhat_+3A_adjust">Adjust</code></td>
<td>

<p>Force the automatically selected bandwidth (following <code>Original</code>) to be multiplied by <code>Adjust</code>. Setting it to values lower than one (1/2 for example) will sharpen the estimation. 
</p>
</td></tr>
<tr><td><code id="mhat_+3A_maxrange">MaxRange</code></td>
<td>

<p>The maximum value of <code>r</code> to consider, ignored if <code>r</code> is not <code>NULL</code>. Default is &quot;ThirdW&quot;, one third of the diameter of the window. Other choices are &quot;HalfW&quot;, and &quot;QuarterW&quot; and &quot;D02005&quot;.
&quot;HalfW&quot;, and &quot;QuarterW&quot; are for half or the quarter of the diameter of the window.
&quot;D02005&quot; is for the median distance observed between points, following Duranton and Overman (2005). &quot;ThirdW&quot; should be close to &quot;DO2005&quot; but has the advantage to be independent of the point types chosen as <code>ReferenceType</code> and <code>NeighborType</code>, to simplify comparisons between different types. &quot;D02005&quot; is approximated by &quot;ThirdW&quot; if <code>Approximate</code> is not 0.
If <code>X</code> is a <code><a href="#topic+Dtable">Dtable</a></code> object, the diameter of the window is taken as the max distance between points.
</p>
</td></tr>
<tr><td><code id="mhat_+3A_individual">Individual</code></td>
<td>

<p>Logical; if <code>TRUE</code>, values of the function around each individual point are returned.
</p>
</td></tr>
<tr><td><code id="mhat_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>m</em> is a weighted, density, relative measure of a point pattern structure (Lang <em>et al.</em>, 2014). Its value at any distance is the ratio of neighbors of the <em>NeighborType</em> to all points around <em>ReferenceType</em> points, normalized by its value over the windows.
</p>
<p>The number of neighbors at each distance is estimated by a Gaussian kernel whose bandwith is chosen optimally according to Silverman (1986: eq 3.31). It can be sharpened or smoothed by multiplying it by <code>Adjust</code>. The bandwidth of Sheather and Jones (1991) would be better but it is very slow to calculate for large point patterns and it sometimes fails. It is often sharper than that of Silverman. 
</p>
<p>If <code>X</code> is not a <code><a href="#topic+Dtable">Dtable</a></code> object, the maximum value of <code>r</code> is obtained from the geometry of the window rather than caculating the median distance between points as suggested by Duranton and Overman (2005) to save (a lot of) calculation time.
</p>
<p>If <em>CaseControl</em> is <code>TRUE</code>, then <em>ReferenceType</em> points are cases and <em>NeighborType</em> points are controls. The univariate concentration of cases is calculated as if <em>NeighborType</em> was equal to <em>ReferenceType</em>, but only controls are considered when counting all points around cases (Marcon et al., 2012). This makes sense when the sampling design is such that all points of <em>ReferenceType</em> (the cases) but only a sample of the other points (the controls) are recorded. Then, the whole distribution of points is better represented by the controls alone.
</p>


<h3>Value</h3>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, which can be plotted directly using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>
<p>If <code>Individual</code> is set to <code>TRUE</code>, the object also contains the value of the function around each individual <em>ReferenceType</em> point taken as the only reference point. The column names of the <code>fv</code> are &quot;m_&quot; followed by the point names, i.e. the row names of the marks of the point pattern.
</p>


<h3>Note</h3>

<p>Estimating <em>m</em> relies on calculating distances, exactly or approximately (if <code>Approximate</code> is not 0).
Then distances are smoothed by estimating their probability density.
In contrast with <code><a href="#topic+Kdhat">Kdhat</a></code>, reflection is not used to estimate density close to the lowest distance.
The same kernel estimation is applied to the distances from reference points of neighbor points and of all points.
Since <em>m</em> is a relative function, a ratio of densities is calculated, that makes the features of the estimation vanish.
</p>
<p>Density estimation heavily relies on the bandwith.
Starting from version 2.7, the optimal bandwith is computed from the distribution of distances between pairs of points up to twice the maximum distance considered.
The consequence is that choosing a smaller range of distances in argument <code>r</code> results in less smoothed <code class="reqn">m</code> values.
The default values (<code>r = NULL</code>, <code>MaxRange = "ThirdW"</code>) are such that almost all the pairs of points (except those more than 2/3 of the window diameter apart) are taken into account to determine the bandwith.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Lang G., Marcon E. and Puech F. (2014) Distance-Based Measures of Spatial Concentration: Introducing a Relative Density Function. <em>HAL</em> 01082178, 1-18.
</p>
<p>Marcon, E., F. Puech and S. Traissac (2012). Characterizing the relative spatial structure of point patterns. <em>International Journal of Ecology</em> 2012(Article ID 619281): 11.
</p>
<p>Scholl, T. and Brenner, T. (2015) Optimizing distance-based methods for large data sets, <em>Journal of Geographical Systems</em> 17(4): 333-351.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991) A reliable data-based bandwidth selection method for kernel density estimation. <em>Journal of the Royal Statistical Society series B</em>, 53, 683-690.
</p>
<p>Silverman, B. W. (1986). <em>Density estimation for statistics and data analysis</em>. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mEnvelope">mEnvelope</a></code>, <code><a href="#topic+Kdhat">Kdhat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
autoplot(paracou16)

# Calculate M
autoplot(mhat(paracou16, , "V. Americana", "Q. Rosea"))
</code></pre>

<hr>
<h2 id='Mhat'>
Estimation of the M function
</h2><span id='topic+Mhat'></span>

<h3>Description</h3>

<p>Estimates the <em>M</em> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mhat(X, r = NULL, ReferenceType, NeighborType = ReferenceType,
    CaseControl = FALSE, Individual = FALSE, CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mhat_+3A_x">X</code></td>
<td>

<p>A weighted, marked planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>) or a <code><a href="#topic+Dtable">Dtable</a></code> object.
</p>
</td></tr>
<tr><td><code id="Mhat_+3A_r">r</code></td>
<td>

<p>A vector of distances. If <code>NULL</code>, a default value is set: 64 unequally spaced values are used up to half the maximum distance between points <code class="reqn">d_m</code>. The first value is 0, first steps are small (<code class="reqn">d_m/800</code>) then increase progressively up to <code class="reqn">d_m/40</code>.
</p>
</td></tr>
<tr><td><code id="Mhat_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types.
</p>
</td></tr>
<tr><td><code id="Mhat_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types. By default, the same as reference type.
</p>
</td></tr>
<tr><td><code id="Mhat_+3A_casecontrol">CaseControl</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the case-control version of <em>M</em> is computed. <em>ReferenceType</em> points are cases, <em>NeighborType</em> points are controls.
</p>
</td></tr>
<tr><td><code id="Mhat_+3A_individual">Individual</code></td>
<td>

<p>Logical; if <code>TRUE</code>, values of the function around each individual point are returned.
</p>
</td></tr>
<tr><td><code id="Mhat_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>M</em> is a weighted, cumulative, relative measure of a point pattern structure. Its value at any distance is the ratio of neighbors of the <em>NeighborType</em> to all points around <em>ReferenceType</em> points, normalized by its value over the windows.
</p>
<p>If <em>CaseControl</em> is <code>TRUE</code>, then <em>ReferenceType</em> points are cases and <em>NeighborType</em> points are controls. The univariate concentration of cases is calculated as if <em>NeighborType</em> was equal to <em>ReferenceType</em>, but only controls are considered when counting all points around cases (Marcon et al., 2012). This makes sense when the sampling design is such that all points of <em>ReferenceType</em> (the cases) but only a sample of the other points (the controls) are recorded. Then, the whole distribution of points is better represented by the controls alone.
</p>


<h3>Value</h3>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, which can be plotted directly using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>
<p>If <code>Individual</code> is set to <code>TRUE</code>, the object also contains the value of the function around each individual <em>ReferenceType</em> point taken as the only reference point. The column names of the <code>fv</code> are &quot;M_&quot; followed by the point names, i.e. the row names of the marks of the point pattern.
</p>


<h3>References</h3>

<p>Marcon, E. and Puech, F. (2010). Measures of the Geographic Concentration of Industries: Improving Distance-Based Methods. <em>Journal of Economic Geography</em> 10(5): 745-762.
</p>
<p>Marcon, E., F. Puech and S. Traissac (2012). Characterizing the relative spatial structure of point patterns. <em>International Journal of Ecology</em> 2012(Article ID 619281): 11.
</p>
<p>Marcon, E., and Puech, F. (2017). A Typology of Distance-Based Measures of Spatial Concentration. <em>Regional Science and Urban Economics</em> 62:56-67
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEnvelope">MEnvelope</a></code>, <code><a href="#topic+Kdhat">Kdhat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
autoplot(paracou16)

# Calculate M
autoplot(Mhat(paracou16, , "V. Americana", "Q. Rosea"))
</code></pre>

<hr>
<h2 id='paracou16'>
Paracou field station plot 16, partial map
</h2><span id='topic+paracou16'></span>

<h3>Description</h3>

<p>This point pattern is from Paracou field station, French Guiana, managed by <a href="https://www.cirad.fr">Cirad</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(paracou16)
</code></pre>


<h3>Format</h3>

<p>An object of class <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> representing the point pattern of tree locations in a 250 x 300 meter sampling region. Each tree is marked with its species (&quot;Q. Rosea&quot;, &quot;V. Americana&quot; or &quot;Other&quot;), and basal area (square centimeters).
</p>


<h3>Source</h3>

<p>Permanent data census of Paracou and Marcon et al. (2012).
</p>


<h3>References</h3>

<p>Gourlet-Fleury, S., Guehl, J. M. and Laroussinie, O., Eds. (2004). <em>Ecology &amp; management of a neotropical rainforest. Lessons drawn from Paracou, a long-term experimental research site in French Guiana</em>. Paris, Elsevier.
</p>
<p>Marcon, E., F. Puech and S. Traissac (2012). Characterizing the relative spatial structure of point patterns. <em>International Journal of Ecology</em> 2012(Article ID 619281): 11.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
# Plot (second column of marks is Point Types) 
autoplot(paracou16, which.marks=2, leg.side="right")

</code></pre>

<hr>
<h2 id='parallelCountNbd'>
Auxiliary functions to count point neighbors
</h2><span id='topic+parallelCountNbd'></span><span id='topic+parallelCountNbdDt'></span><span id='topic+parallelCountNbdCC'></span><span id='topic+parallelCountNbdDtCC'></span><span id='topic+parallelCountNbdm'></span><span id='topic+DistKd'></span><span id='topic+CountNbdKd'></span>

<h3>Description</h3>

<p>C++ routines used for fast count of neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallelCountNbd(r, x, y, Weight, IsReferenceType, IsNeighborType)
parallelCountNbdCC(r, x, y, Weight, IsReferenceType, IsNeighborType)
parallelCountNbdm(x, y, ReferencePoints)
parallelCountNbdDt(r, Dmatrix, Weight, IsReferenceType, IsNeighborType)
parallelCountNbdDtCC(r, Dmatrix, Weight, IsReferenceType, IsNeighborType)
DistKd(x, y, PointWeight, Weight, Dist, IsReferenceType, IsNeighborType)
CountNbdKd(r, x, y, Weight, Nbd, IsReferenceType, IsNeighborType)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallelCountNbd_+3A_r">r</code></td>
<td>

<p>A vector of distances.
</p>
</td></tr>
<tr><td><code id="parallelCountNbd_+3A_x">x</code></td>
<td>

<p>A vector of <em>x</em> coordinates.
</p>
</td></tr>
<tr><td><code id="parallelCountNbd_+3A_y">y</code></td>
<td>

<p>A vector of <em>y</em> coordinates.
</p>
</td></tr>
<tr><td><code id="parallelCountNbd_+3A_dmatrix">Dmatrix</code></td>
<td>

<p>A matrix of distances.
</p>
</td></tr>
<tr><td><code id="parallelCountNbd_+3A_pointweight">PointWeight</code></td>
<td>

<p>A vector of point weights.
</p>
</td></tr>
<tr><td><code id="parallelCountNbd_+3A_weight">Weight</code></td>
<td>

<p>A vector of point weights.
</p>
</td></tr>
<tr><td><code id="parallelCountNbd_+3A_referencepoints">ReferencePoints</code></td>
<td>

<p>A vector of pont indices.
</p>
</td></tr>
<tr><td><code id="parallelCountNbd_+3A_nbd">Nbd</code></td>
<td>

<p>A matrix to store the weight of neighbors.
</p>
</td></tr>
<tr><td><code id="parallelCountNbd_+3A_dist">Dist</code></td>
<td>

<p>A vector of point-pair distances.
</p>
</td></tr>
<tr><td><code id="parallelCountNbd_+3A_isreferencetype">IsReferenceType</code></td>
<td>

<p>A boolean vector to recognize reference points.
</p>
</td></tr>
<tr><td><code id="parallelCountNbd_+3A_isneighbortype">IsNeighborType</code></td>
<td>

<p>A boolean vector to recognize neighbor points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These routines are called internally.
</p>

<hr>
<h2 id='print.dbmssEnvelope'>
Print a confidence envelope
</h2><span id='topic+print.dbmssEnvelope'></span>

<h3>Description</h3>

<p>Prints useful information of a confidence envelope of class &quot;dbmssEnvelope&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbmssEnvelope'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.dbmssEnvelope_+3A_x">x</code></td>
<td>

<p>An object of class &quot;dbmssEnvelope&quot;.
</p>
</td></tr>
<tr><td><code id="print.dbmssEnvelope_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;dbmssEnvelope&quot; objects are similar to <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code> objects. The way they are printed is different to take into account the possibility of building global envelope following Duranton and Overman (2005):  the global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
autoplot(paracou16)

# Calculate intertype K envelope
Envelope &lt;- KEnvelope(paracou16, NumberOfSimulations = 20, Global = TRUE,
  ReferenceType = "V. Americana", NeighborType = "Q. Rosea")
autoplot(Envelope)
# print
print(Envelope)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+autoplot'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+autoplot">autoplot</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rPopulationIndependenceK'>
Simulations of a point pattern according to the null hypothesis of population independence defined for K
</h2><span id='topic+rPopulationIndependenceK'></span>

<h3>Description</h3>

<p>Simulates of a point pattern according to the null hypothesis of population independence defined for <em>K</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rPopulationIndependenceK(X, ReferenceType, NeighborType, CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rPopulationIndependenceK_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="rPopulationIndependenceK_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types.
</p>
</td></tr>
<tr><td><code id="rPopulationIndependenceK_+3A_neighbortype">NeighborType</code></td>
<td>

<p>One of the point types.
</p>
</td></tr>
<tr><td><code id="rPopulationIndependenceK_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reference points are kept unchanged, neighbor type point positions are shifted by <code><a href="spatstat.random.html#topic+rshift">rshift</a></code>.
Other points are lost and point weights are not kept (they are set to 1) since the K function ignores them.
</p>


<h3>Value</h3>

<p>A new weighted, marked, planar point pattern (an object of class <code>wmppp</code>, see <code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>


<h3>References</h3>

<p>Goreaud, F. et Pelissier, R. (2003). Avoiding misinterpretation of biotic interactions with the intertype K12 fonction: population independence vs random labelling hypotheses. <em>Journal of Vegetation Science</em> 14(5): 681-692.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rPopulationIndependenceM">rPopulationIndependenceM</a></code>, <code><a href="#topic+rRandomLabeling">rRandomLabeling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a point pattern with three types
X &lt;- rpoispp(50) 
PointType   &lt;- sample(c("A", "B", "C"), X$n, replace=TRUE)
PointWeight &lt;- runif(X$n, min=1, max=10)
X$marks &lt;- data.frame(PointType, PointWeight)
X &lt;- as.wmppp(X)

# Plot the point pattern, using PointType as marks
autoplot(X, main="Original pattern")

# Randomize it
Y &lt;- rPopulationIndependenceK(X, "A", "B")
# Points of type "A" are unchanged, points of type "B" have been moved altogether
# Other points are lost and point weights are set to 1
autoplot(Y, main="Randomized pattern")
</code></pre>

<hr>
<h2 id='rPopulationIndependenceM'>
Simulations of a point pattern according to the null hypothesis of population independence defined for M
</h2><span id='topic+rPopulationIndependenceM'></span>

<h3>Description</h3>

<p>Simulates of a point pattern according to the null hypothesis of population independence defined for <em>M</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rPopulationIndependenceM(X, ReferenceType, CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rPopulationIndependenceM_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="rPopulationIndependenceM_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types.
</p>
</td></tr>
<tr><td><code id="rPopulationIndependenceM_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reference points are kept unchanged, other points are redistributed randomly across locations.
</p>


<h3>Value</h3>

<p>A new weighted, marked, planar point pattern (an object of class <code>wmppp</code>, see <code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>


<h3>References</h3>

<p>Marcon, E. and Puech, F. (2010). Measures of the Geographic Concentration of Industries: Improving Distance-Based Methods. <em>Journal of Economic Geography</em> 10(5): 745-762.
</p>
<p>Marcon, E., F. Puech and S. Traissac (2012). Characterizing the relative spatial structure of point patterns. <em>International Journal of Ecology</em> 2012(Article ID 619281): 11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rPopulationIndependenceK">rPopulationIndependenceK</a></code>, <code><a href="#topic+rRandomLabelingM">rRandomLabelingM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a point pattern with five types
X &lt;- rpoispp(50) 
PointType   &lt;- sample(c("A", "B", "C", "D", "E"), X$n, replace=TRUE)
PointWeight &lt;- runif(X$n, min=1, max=10)
X$marks &lt;- data.frame(PointType, PointWeight)
X &lt;- as.wmppp(X)


autoplot(X, main="Original pattern")

# Randomize it
Y &lt;- rPopulationIndependenceM(X, "A")
# Points of type "A" are unchanged, 
# all other points have been redistributed randomly across locations
autoplot(Y, main="Randomized pattern")
</code></pre>

<hr>
<h2 id='rRandomLabeling'>
Simulations of a point pattern according to the null hypothesis of random labeling
</h2><span id='topic+rRandomLabeling'></span>

<h3>Description</h3>

<p>Simulates of a point pattern according to the null hypothesis of random labeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rRandomLabeling(X, CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rRandomLabeling_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="rRandomLabeling_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Marks are redistributed randomly across the original point pattern.
</p>


<h3>Value</h3>

<p>A new weighted, marked, planar point pattern (an object of class <code>wmppp</code>, see <code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>


<h3>References</h3>

<p>Goreaud, F. et Pelissier, R. (2003). Avoiding misinterpretation of biotic interactions with the intertype K12 fonction: population independence vs random labelling hypotheses. <em>Journal of Vegetation Science</em> 14(5): 681-692.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rRandomLabelingM">rRandomLabelingM</a></code>, <code><a href="#topic+rPopulationIndependenceK">rPopulationIndependenceK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a point pattern with five types
X &lt;- rpoispp(50) 
PointType   &lt;- sample(c("A", "B", "C", "D", "E"), X$n, replace=TRUE)
PointWeight &lt;- runif(X$n, min=1, max=10)
X$marks &lt;- data.frame(PointType, PointWeight)
X &lt;- as.wmppp(X)

autoplot(X, main="Original pattern")

# Randomize it
Y &lt;- rRandomLabeling(X)
# Types and weights have been redistributed randomly across locations
autoplot(Y, main="Randomized pattern")
</code></pre>

<hr>
<h2 id='rRandomLabelingM'>
Simulations of a point pattern according to the null hypothesis of random labelling defined for M
</h2><span id='topic+rRandomLabelingM'></span>

<h3>Description</h3>

<p>Simulates of a point pattern according to the null hypothesis of random labelling defined for <em>M</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rRandomLabelingM(X, CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rRandomLabelingM_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>) or a <code><a href="#topic+Dtable">Dtable</a></code> object.
</p>
</td></tr>
<tr><td><code id="rRandomLabelingM_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Point types are randomized. Locations and weights are kept unchanged. If both types and weights must be randomized together (Duranton and Overman, 2005; Marcon and Puech, 2010), use <code><a href="#topic+rRandomLocation">rRandomLocation</a></code>.
</p>


<h3>Value</h3>

<p>A new weighted, marked, planar point pattern (an object of class <code>wmppp</code>, see <code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Marcon, E. and Puech, F. (2010). Measures of the Geographic Concentration of Industries: Improving Distance-Based Methods. <em>Journal of Economic Geography</em> 10(5): 745-762.
</p>
<p>Marcon, E., F. Puech and S. Traissac (2012). Characterizing the relative spatial structure of point patterns. <em>International Journal of Ecology</em> 2012(Article ID 619281): 11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rRandomLabeling">rRandomLabeling</a></code>, <code><a href="#topic+rPopulationIndependenceM">rPopulationIndependenceM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a point pattern with five types
X &lt;- rpoispp(50) 
PointType   &lt;- sample(c("A", "B", "C", "D", "E"), X$n, replace=TRUE)
PointWeight &lt;- runif(X$n, min=1, max=10)
X$marks &lt;- data.frame(PointType, PointWeight)
X &lt;- as.wmppp(X)

autoplot(X, main="Original pattern")

# Randomize it
Y &lt;- rRandomLabelingM(X)
# Labels have been redistributed randomly across locations
# But weights are unchanged
autoplot(Y, main="Randomized pattern")
</code></pre>

<hr>
<h2 id='rRandomLocation'>
Simulations of a point pattern according to the null hypothesis of random location
</h2><span id='topic+rRandomLocation'></span>

<h3>Description</h3>

<p>Simulates of a point pattern according to the null hypothesis of random location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rRandomLocation(X, ReferenceType = "", CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rRandomLocation_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="rRandomLocation_+3A_referencetype">ReferenceType</code></td>
<td>

<p>One of the point types.
</p>
</td></tr>
<tr><td><code id="rRandomLocation_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Points are redistributed randomly across the locations of the original point pattern. This randomization is equivalent to random labeling, considering the label is both point type and point weight.
If <code>ReferenceType</code> is specified, then only reference type points are kept in the orginal point pattern before randomization.
</p>


<h3>Value</h3>

<p>A new weighted, marked, planar point pattern (an object of class <code>wmppp</code>, see <code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106.
</p>
<p>Marcon, E. and Puech, F. (2010). Measures of the Geographic Concentration of Industries: Improving Distance-Based Methods. <em>Journal of Economic Geography</em> 10(5): 745-762.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rRandomPositionK">rRandomPositionK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a point pattern with five types
X &lt;- rpoispp(50) 
PointType   &lt;- sample(c("A", "B", "C", "D", "E"), X$n, replace=TRUE)
PointWeight &lt;- runif(X$n, min=1, max=10)
X$marks &lt;- data.frame(PointType, PointWeight)
X &lt;- as.wmppp(X)

autoplot(X, main="Original pattern")

# Randomize it
Y &lt;- rRandomLocation(X)
# Points have been redistributed randomly across locations
autoplot(Y, main="Randomized pattern")
</code></pre>

<hr>
<h2 id='rRandomPositionK'>
Simulations of a point pattern according to the null hypothesis of random position defined for K
</h2><span id='topic+rRandomPositionK'></span>

<h3>Description</h3>

<p>Simulations of a point pattern according to the null hypothesis of random position defined for <em>K</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rRandomPositionK(X, Precision = 0, CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rRandomPositionK_+3A_x">X</code></td>
<td>

<p>A weighted, marked, planar point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="rRandomPositionK_+3A_precision">Precision</code></td>
<td>

<p>Accuracy of point coordinates, measured as a part of distance unit. See notes. Default is 0 for no approximation.
</p>
</td></tr>
<tr><td><code id="rRandomPositionK_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>Logical; if <code>TRUE</code>, the function arguments are verified. Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Points marks are kept unchanged and their position is drawn in a binomial process by <code><a href="spatstat.random.html#topic+runifpoint">runifpoint</a></code>.
</p>


<h3>Value</h3>

<p>A new weighted, marked, planar point pattern (an object of class <code>wmppp</code>, see <code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>


<h3>Note</h3>

<p>Simulations in a binomial process keeps the same number of points, so that marks can be redistributed. If a real CSR simulation is needed and marks are useless, use <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>.
</p>
<p>Actual data coordinates are often rounded. Use the <code>Precision</code> argument to simulate point patterns with the same rounding procedure. For example, if point coordinates are in meters and rounded to the nearest half meter, use <code>Precision = 0.5</code> so that the same approximation is applied to the simulated point patterns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rRandomLocation">rRandomLocation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a point pattern with two types
X &lt;- rpoispp(5) 
PointType   &lt;- sample(c("A", "B"), X$n, replace=TRUE)
PointWeight &lt;- runif(X$n, min=1, max=10)
X$marks &lt;- data.frame(PointType, PointWeight)
X &lt;- as.wmppp(X)

autoplot(X, main="Original pattern")

# Randomize it
Y &lt;- rRandomPositionK(X)
# Points are randomly distributed
autoplot(Y, main="Randomized pattern")
</code></pre>

<hr>
<h2 id='Smooth.wmppp'>Spatial smoothing of individual dbmss's</h2><span id='topic+Smooth.wmppp'></span>

<h3>Description</h3>

<p>Performs spatial smoothing of the individual values of distance-based measures computed in the neighborhood of each point (Marcon and Puech, 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'wmppp'
 Smooth(X, fvind, distance = NULL, Quantiles = FALSE, 
      sigma = bw.scott(X, isotropic = TRUE), Weighted = TRUE, Adjust = 1, 
      Nbx = 128, Nby = 128, ..., CheckArguments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Smooth.wmppp_+3A_x">X</code></td>
<td>

<p>A point pattern (<code><a href="#topic+wmppp.object">wmppp.object</a></code>).
</p>
</td></tr>
<tr><td><code id="Smooth.wmppp_+3A_fvind">fvind</code></td>
<td>

<p>An object of class <code>fv</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, obtained a distance-based method, such as <code><a href="#topic+Mhat">Mhat</a></code> with individual values (argument <code>Individual = TRUE</code>).
</p>
</td></tr>
<tr><td><code id="Smooth.wmppp_+3A_distance">distance</code></td>
<td>

<p>The distance at which the function value must be considered.
The default value is the median distance used to calculate the function values.
</p>
</td></tr>
<tr><td><code id="Smooth.wmppp_+3A_quantiles">Quantiles</code></td>
<td>

<p>If <code>FALSE</code> (default), the dbmss is smoothed to produce a map of the measure.
If <code>TRUE</code>, its quantiles (computed by <code><a href="#topic+Mhat">Mhat</a></code> with argument <code>Quantiles = TRUE</code>) are smoothed to produce a map of the confidence level of the measure.
</p>
</td></tr>
<tr><td><code id="Smooth.wmppp_+3A_weighted">Weighted</code></td>
<td>

<p>If <code>TRUE</code> (default), the point weights are taken into account for smoothing.
</p>
</td></tr>
<tr><td><code id="Smooth.wmppp_+3A_sigma">sigma</code></td>
<td>

<p>The bandwidth used for smoothing.
A Gaussian kernel is used (see <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>).
Its bandwidth is chosen by default according to Scott's rule (see <code><a href="spatstat.explore.html#topic+bw.scott">bw.scott</a></code>).
</p>
</td></tr>
<tr><td><code id="Smooth.wmppp_+3A_adjust">Adjust</code></td>
<td>

<p>Force the selected bandwidth (<code>sigma</code>) to be multiplied by <code>Adjust</code>. Setting it to values smaller than one (1/2 for example) will sharpen the estimation. 
</p>
</td></tr>
<tr><td><code id="Smooth.wmppp_+3A_nbx">Nbx</code>, <code id="Smooth.wmppp_+3A_nby">Nby</code></td>
<td>

<p>The number of columns and rows (pixels) of the resulting map, 128 by default.
Increase it for quality, paid by increasing computing time.
</p>
</td></tr>
<tr><td><code id="Smooth.wmppp_+3A_...">...</code></td>
<td>

<p>Extra arguments, passed to <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="Smooth.wmppp_+3A_checkarguments">CheckArguments</code></td>
<td>

<p>If <code>TRUE</code> (default), the function arguments are verified.
Should be set to <code>FALSE</code> to save time in simulations for example, when the arguments have been checked elsewhere.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An image that can be plotted.
If quantiles have been computed in <code>fvind</code>, attributes &quot;High&quot; and &quot;Low&quot; contain logical vectors to indentify significantly high and low quantiles.
</p>


<h3>References</h3>

<p>Marcon, E. and Puech, F. (2023). Mapping distributions in non-homogeneous space with distance-based methods. <em>Journal of Spatial Econometrics</em> 4(1), 13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ReferenceType &lt;- "V. Americana"
  NeighborType &lt;- "Q. Rosea"
  # Calculate individual intertype M(distance) values
  fvind &lt;- Mhat(paracou16, r=c(0, 30), ReferenceType, NeighborType, Individual=TRUE)
  # Plot the point pattern with values of M(30 meters)
  p16_map &lt;- Smooth(paracou16, fvind, distance=30)
  plot(p16_map, main = "")
  # Add the reference points to the plot
  is.ReferenceType &lt;- paracou16$marks$PointType == ReferenceType
  points(x=paracou16$x[is.ReferenceType], y=paracou16$y[is.ReferenceType], pch=20)
  # Add contour lines
  contour(p16_map, nlevels = 5, add = TRUE)
</code></pre>

<hr>
<h2 id='spatstat+20generic+20functions'>
Methods for weighted, marked planar point patterns (of class wmppp) from spatstat
</h2><span id='topic+sharpen.wmppp'></span><span id='topic+split.wmppp'></span><span id='topic+superimpose.wmppp'></span><span id='topic+unique.wmppp'></span><span id='topic++5B.wmppp'></span>

<h3>Description</h3>

<p><strong>spatstat</strong> methods for a <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> applied to a <code><a href="#topic+wmppp.object">wmppp.object</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wmppp'
sharpen(X, ...)
## S3 method for class 'wmppp'
split(...)
## S3 method for class 'wmppp'
superimpose(...)
## S3 method for class 'wmppp'
unique(x, ...)
## S3 method for class 'wmppp'
i[j, drop=FALSE, ..., clip=FALSE]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatstat+2B20generic+2B20functions_+3A_x">X</code>, <code id="spatstat+2B20generic+2B20functions_+3A_x">x</code></td>
<td>

<p>A two-dimensional point pattern. An object of class &quot;wmppp&quot;.
</p>
</td></tr>
<tr><td><code id="spatstat+2B20generic+2B20functions_+3A_...">...</code></td>
<td>

<p>Arguments passed to the <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> method.
</p>
</td></tr>
<tr><td><code id="spatstat+2B20generic+2B20functions_+3A_i">i</code></td>
<td>

<p>Subset index. Either a valid subset index in the usual R sense, indicating which points should be retained, or a window (an object of class &quot;owin&quot;) delineating a subset of the original observation window, or a pixel image with logical values defining a subset of the original observation window.
</p>
</td></tr>
<tr><td><code id="spatstat+2B20generic+2B20functions_+3A_j">j</code></td>
<td>

<p>Redundant. Included for backward compatibility.
</p>
</td></tr>
<tr><td><code id="spatstat+2B20generic+2B20functions_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating whether to remove unused levels of the marks, if the marks are a factor.
</p>
</td></tr>
<tr><td><code id="spatstat+2B20generic+2B20functions_+3A_clip">clip</code></td>
<td>

<p>Logical value indicating how to form the window of the resulting point pattern, when <code>i</code> is a window. If <code>clip=FALSE</code> (the default), the result has window equal to <code>i</code>. If <code>clip=TRUE</code>, the resulting window is the intersection between the window of <code>x</code> and the window <code>i</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>spatstat</strong> methods for <code>ppp</code> objects returning a <code>ppp</code> object can be applied to a <code>wmppp</code> and return a <code>wpppp</code> with these methods which just call the <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> method and change the class of the result for convenience.
</p>
<p>Some <strong>spatstat</strong> functions such as <code><a href="spatstat.random.html#topic+rthin">rthin</a></code> are not generic so they always return a <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> when applied to a <code><a href="#topic+wmppp.object">wmppp.object</a></code>. Their result may be converted by <code><a href="#topic+as.wmppp">as.wmppp</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"wmppp"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+sharpen.ppp">sharpen.ppp</a></code>, <code><a href="spatstat.geom.html#topic+split.ppp">split.ppp</a></code>, <code><a href="spatstat.geom.html#topic+superimpose.ppp">superimpose.ppp</a></code>, <code><a href="spatstat.geom.html#topic+unique.ppp">unique.ppp</a></code>
</p>

<hr>
<h2 id='summary.dbmssEnvelope'>
Summary of a confidence envelope
</h2><span id='topic+summary.dbmssEnvelope'></span>

<h3>Description</h3>

<p>Prints a useful summary of a confidence envelope of class &quot;dbmssEnvelope&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbmssEnvelope'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.dbmssEnvelope_+3A_object">object</code></td>
<td>

<p>An object of class &quot;dbmssEnvelope&quot;.
</p>
</td></tr>
<tr><td><code id="summary.dbmssEnvelope_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;dbmssEnvelope&quot; objects are similar to <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code> objects. Their summary is different to take into account the possibility of building global envelope following Duranton and Overman (2005):  the global envelope is calculated by iteration: the simulations reaching one of the upper or lower values at any distance are eliminated at each step. The process is repeated until <em>Alpha / Number of simulations</em> simulations are dropped. The remaining upper and lower bounds at all distances constitute the global envelope. Interpolation is used if the exact ratio cannot be reached.
</p>


<h3>References</h3>

<p>Duranton, G. and Overman, H. G. (2005). Testing for Localisation Using Micro-Geographic Data. <em>Review of Economic Studies</em> 72(4): 1077-1106
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(paracou16)
autoplot(paracou16)

# Calculate intertype K envelope
Envelope &lt;- KEnvelope(paracou16, NumberOfSimulations = 20, Global = TRUE,
  ReferenceType = "V. Americana", NeighborType = "Q. Rosea")
autoplot(Envelope)
summary(Envelope)
</code></pre>

<hr>
<h2 id='wmppp'>
Create a Weighted, Marked, Planar Point Pattern
</h2><span id='topic+wmppp'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"wmppp"</code> representing a two-dimensional point pattern with weights and labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wmppp(df, window = NULL, unitname = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wmppp_+3A_df">df</code></td>
<td>

<p>A dataframe with at least two columns containing point coordinates.  
</p>
</td></tr>
<tr><td><code id="wmppp_+3A_window">window</code></td>
<td>

<p>An object of calls &quot;owin&quot; (<code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>).  
</p>
</td></tr>
<tr><td><code id="wmppp_+3A_unitname">unitname</code></td>
<td>

<p>Name of unit of length. Either a single character string, or a vector of two character strings giving the singular and plural forms, respectively. Ignored if <code>window</code> is not <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Columns named &quot;X&quot;, &quot;Y&quot;, &quot;PointType&quot;, &quot;PointWeight&quot; (capitalization is ignored) are searched to build the <code>"wmppp"</code> object and set the point coordinates, type and weight. If they are not found, columns are used in this order. If columns are missing, <code>PointType</code> is set to &quot;All&quot; and <code>PointWeight</code> to 1.
If a &quot;PointName&quot; column is found, it is used to set the row names of the marks, else the original row names are used.
</p>
<p>If the window is not specified, a rectangle containing all points is used, and <code>unitname</code> is used.
</p>


<h3>Value</h3>

<p>An object of class <code>"wmppp"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wmppp.object">wmppp.object</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Draw the coordinates of 10 points
X &lt;- runif(10)
Y &lt;- runif(10)
# Draw the point types.
PointType   &lt;- sample(c("A", "B"), 10, replace=TRUE)
# Plot the point pattern. Weights are set to 1 ant the window is adjusted.
plot(wmppp(data.frame(X, Y, PointType)), , which.marks=2)
</code></pre>

<hr>
<h2 id='wmppp.object'>
Class of Weighted, Marked, Planar Point Patterns
</h2><span id='topic+wmppp.object'></span>

<h3>Description</h3>

<p>A class <code>"wmppp"</code> to represent a two-dimensional point pattern of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> whose marks are a dataframe with two columns:
</p>

<ul>
<li> <p><code>PointType</code>: labels, as factors
</p>
</li>
<li> <p><code>PointWeight</code>: weights.
</p>
</li></ul>



<h3>Details</h3>

<p>This class represents a two-dimensional point pattern dataset. <code>wmppp</code> objects are also of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>.
</p>
<p>Objects of class <code>wmppp</code> may be created by the function <code><a href="#topic+wmppp">wmppp</a></code> and converted from other types of data by the function <code><a href="#topic+as.wmppp">as.wmppp</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+wmppp">wmppp</a></code>,
<code><a href="#topic+as.wmppp">as.wmppp</a></code>
<code><a href="#topic+autoplot.wmppp">autoplot.wmppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Draw the coordinates of 10 points
X &lt;- runif(10)
Y &lt;- runif(10)
# Draw the point types and weights
PointType   &lt;- sample(c("A", "B"), 10, replace=TRUE)
PointWeight &lt;- runif(10)
# Build the point pattern
X &lt;- wmppp(data.frame(X, Y, PointType, PointWeight), owin())

# Plot the point pattern. which.marks=1 for point weights, 2 for point types
par(mfrow=c(1,2))
plot(X, which.marks=1, main="Point weights")
plot(X, which.marks=2, main="Point types")

# Or use autoplot for a ggplot
autoplot(X)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
