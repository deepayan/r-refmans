<!DOCTYPE html><html><head><title>Help for package splitTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {splitTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#create_folds'><p>Create Folds</p></a></li>
<li><a href='#create_timefolds'><p>Creates Folds for Time Series Data</p></a></li>
<li><a href='#multi_strata'><p>Create Strata from Multiple Features</p></a></li>
<li><a href='#partition'><p>Split Data into Partitions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Data Splitting</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast, lightweight toolkit for data splitting. Data sets can
    be partitioned into disjoint groups (e.g. into training, validation,
    and test) or into (repeated) k-folds for subsequent cross-validation.
    Besides basic splits, the package supports stratified, grouped as well
    as blocked splitting. Furthermore, cross-validation folds for time
    series data can be created. See e.g. Hastie et al. (2001)
    &lt;<a href="https://doi.org/10.1007%2F978-0-387-84858-7">doi:10.1007/978-0-387-84858-7</a>&gt; for the basic background on data
    partitioning and cross-validation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mayer79/splitTools">https://github.com/mayer79/splitTools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mayer79/splitTools/issues">https://github.com/mayer79/splitTools/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-06 13:37:09 UTC; Michael</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Mayer [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Mayer &lt;mayermichael79@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-06 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='create_folds'>Create Folds</h2><span id='topic+create_folds'></span>

<h3>Description</h3>

<p>This function provides a list of row indices used for k-fold cross-validation
(basic, stratified, grouped, or blocked). Repeated fold creation is supported as well.
By default, in-sample indices are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_folds(
  y,
  k = 5L,
  type = c("stratified", "basic", "grouped", "blocked"),
  n_bins = 10L,
  m_rep = 1L,
  use_names = TRUE,
  invert = FALSE,
  shuffle = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_folds_+3A_y">y</code></td>
<td>
<p>Either the variable used for &quot;stratification&quot; or &quot;grouped&quot; splits.
For other types of splits, any vector of the same length as the data
intended to split.</p>
</td></tr>
<tr><td><code id="create_folds_+3A_k">k</code></td>
<td>
<p>Number of folds.</p>
</td></tr>
<tr><td><code id="create_folds_+3A_type">type</code></td>
<td>
<p>Split type. One of &quot;stratified&quot; (default), &quot;basic&quot;, &quot;grouped&quot;, &quot;blocked&quot;.</p>
</td></tr>
<tr><td><code id="create_folds_+3A_n_bins">n_bins</code></td>
<td>
<p>Approximate numbers of bins for numeric <code>y</code>
(only for <code>type = "stratified"</code>).</p>
</td></tr>
<tr><td><code id="create_folds_+3A_m_rep">m_rep</code></td>
<td>
<p>How many times should the data be split into k folds?
Default is 1, i.e., no repetitions.</p>
</td></tr>
<tr><td><code id="create_folds_+3A_use_names">use_names</code></td>
<td>
<p>Should folds be named? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="create_folds_+3A_invert">invert</code></td>
<td>
<p>Set to <code>TRUE</code> in order to receive out-of-sample indices.
Default is <code>FALSE</code>, i.e., in-sample indices are returned.</p>
</td></tr>
<tr><td><code id="create_folds_+3A_shuffle">shuffle</code></td>
<td>
<p>Should row indices be randomly shuffled within folds?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="create_folds_+3A_seed">seed</code></td>
<td>
<p>Integer random seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the function uses stratified splitting. This will balance the folds
regarding the distribution of the input vector <code>y</code>.
(Numeric input is first binned into <code>n_bins</code> quantile groups.)
If <code>type = "grouped"</code>, groups specified by <code>y</code> are kept together
when splitting. This is relevant for clustered or panel data.
In contrast to basic splitting, <code>type = "blocked"</code> does not sample
indices at random, but rather keeps them in sequential groups.
</p>


<h3>Value</h3>

<p>If <code>invert = FALSE</code> (the default), a list with in-sample row indices.
If <code>invert = TRUE</code>, a list with out-of-sample indices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partition">partition()</a></code>, <code><a href="#topic+create_timefolds">create_timefolds()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rep(c(letters[1:4]), each = 5)
create_folds(y)
create_folds(y, k = 2)
create_folds(y, k = 2, m_rep = 2)
create_folds(y, k = 3, type = "blocked")
</code></pre>

<hr>
<h2 id='create_timefolds'>Creates Folds for Time Series Data</h2><span id='topic+create_timefolds'></span>

<h3>Description</h3>

<p>This function provides a list with in- and out-of-sample indices per fold used for
time series k-fold cross-validation, see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_timefolds(y, k = 5L, use_names = TRUE, type = c("extending", "moving"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_timefolds_+3A_y">y</code></td>
<td>
<p>Any vector of the same length as the data intended to split.</p>
</td></tr>
<tr><td><code id="create_timefolds_+3A_k">k</code></td>
<td>
<p>Number of folds.</p>
</td></tr>
<tr><td><code id="create_timefolds_+3A_use_names">use_names</code></td>
<td>
<p>Should folds be named? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="create_timefolds_+3A_type">type</code></td>
<td>
<p>Should in-sample data be &quot;extending&quot; over the folds (default)
or consist of one single fold (&quot;moving&quot;)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data is first partitioned into <code class="reqn">k+1</code> sequential blocks <code class="reqn">B_1</code> to
<code class="reqn">B_{k+1}</code>. Each fold consists of two index vectors: one with in-sample row numbers,
the other with out-of-sample row numbers. The first fold uses <code class="reqn">B_1</code> as in-sample
and <code class="reqn">B_2</code> as out-of-sample data. The second one uses either <code class="reqn">B_2</code>
(if <code>type = "moving"</code>) or <code class="reqn">\{B_1, B_2\}</code> (if <code>type = "extending"</code>)
as in-sample, and <code class="reqn">B_3</code> as out-of-sample data etc. Finally, the kth fold uses
<code class="reqn">\{B_1, ..., B_k\}</code> (&quot;extending&quot;) or <code class="reqn">B_k</code> (&quot;moving&quot;) as in-sample data,
and <code class="reqn">B_{k+1}</code> as out-of-sample data. This makes sure that out-of-sample data
always follows in-sample data.
</p>


<h3>Value</h3>

<p>A nested list with in-sample and out-of-sample indices per fold.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partition">partition()</a></code>, <code><a href="#topic+create_folds">create_folds()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- runif(100)
create_timefolds(y)
create_timefolds(y, use_names = FALSE)
create_timefolds(y, use_names = FALSE, type = "moving")
</code></pre>

<hr>
<h2 id='multi_strata'>Create Strata from Multiple Features</h2><span id='topic+multi_strata'></span>

<h3>Description</h3>

<p>Creates a stratification vector based on multiple columns of
a <code>data.frame</code> that can then be passed to the splitting functions.
</p>
<p>Currently, the function offers two strategies to create the strata:
</p>

<ul>
<li><p> &quot;kmeans&quot;: k-means cluster analysis on scaled input. (Ordered factors are integer
encoded first, unordered factors and character columns are one-hot-encoded.)
</p>
</li>
<li><p> &quot;interaction&quot;: All combinations (after binning numeric columns into
approximately <code>k</code> bins).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>multi_strata(df, strategy = c("kmeans", "interaction"), k = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_strata_+3A_df">df</code></td>
<td>
<p>A <code>data.frame</code> used to form the stratification vector.</p>
</td></tr>
<tr><td><code id="multi_strata_+3A_strategy">strategy</code></td>
<td>
<p>A string (either &quot;kmeans&quot; or &quot;interaction&quot;) to compute the strata,
see description.</p>
</td></tr>
<tr><td><code id="multi_strata_+3A_k">k</code></td>
<td>
<p>An integer. For <code>strategy = "kmeans"</code>, it is the desired number of strata,
while for <code>strategy = "interaction"</code>, it is the approximate number of bins per
numeric feature before forming all combinations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Factor with strata as levels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partition">partition()</a></code>, <code><a href="#topic+create_folds">create_folds()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y_multi &lt;- data.frame(
  A = rep(c(letters[1:4]), each = 20),
  B = factor(sample(c(0, 1), 80, replace = TRUE)),
  c = rnorm(80)
)
y &lt;- multi_strata(y_multi, k = 3)
folds &lt;- create_folds(y, k = 5)
</code></pre>

<hr>
<h2 id='partition'>Split Data into Partitions</h2><span id='topic+partition'></span>

<h3>Description</h3>

<p>This function provides row indices for data splitting, e.g., to split data
into training, validation, and test. Different types of split strategies are
supported, see Details.
The partition indices are either returned as list with one element per partition
(the default) or as vector of partition IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(
  y,
  p,
  type = c("stratified", "basic", "grouped", "blocked"),
  n_bins = 10L,
  split_into_list = TRUE,
  use_names = TRUE,
  shuffle = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_+3A_y">y</code></td>
<td>
<p>Either the variable used for &quot;stratification&quot; or &quot;grouped&quot; splits.
For other types of splits, any vector of the same length as the data
intended to split.</p>
</td></tr>
<tr><td><code id="partition_+3A_p">p</code></td>
<td>
<p>A vector with split probabilities per partition, e.g.,
<code>c(train = 0.7, valid = 0.3)</code>. Names are passed to the output.</p>
</td></tr>
<tr><td><code id="partition_+3A_type">type</code></td>
<td>
<p>Split type. One of &quot;stratified&quot; (default), &quot;basic&quot;, &quot;grouped&quot;, &quot;blocked&quot;.</p>
</td></tr>
<tr><td><code id="partition_+3A_n_bins">n_bins</code></td>
<td>
<p>Approximate numbers of bins for numeric <code>y</code>
(only for <code>type = "stratified"</code>).</p>
</td></tr>
<tr><td><code id="partition_+3A_split_into_list">split_into_list</code></td>
<td>
<p>Should the resulting partition vector be split into a list?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="partition_+3A_use_names">use_names</code></td>
<td>
<p>Should names of <code>p</code> be used as partition names?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="partition_+3A_shuffle">shuffle</code></td>
<td>
<p>Should row indices be randomly shuffled within partition?
Default is <code>FALSE</code>. Shuffling is only possible when <code>split_into_list = TRUE</code>.</p>
</td></tr>
<tr><td><code id="partition_+3A_seed">seed</code></td>
<td>
<p>Integer random seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the function uses stratified splitting. This will balance the partitions
as good as possible regarding the distribution of the input vector <code>y</code>.
(Numeric input is first binned into <code>n_bins</code> quantile groups.)
If <code>type = "grouped"</code>, groups specified by <code>y</code> are kept together when
splitting. This is relevant for clustered or panel data.
In contrast to basic splitting, <code>type = "blocked"</code> does not sample indices
at random, but rather keeps them in groups: e.g., the first 80% of observations form
a training set and the remaining 20% are used for testing.
</p>


<h3>Value</h3>

<p>A list with row indices per partition (if <code>split_into_list = TRUE</code>)
or a vector of partition IDs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_folds">create_folds()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rep(c(letters[1:4]), each = 5)
partition(y, p = c(0.7, 0.3), seed = 1)
partition(y, p = c(0.7, 0.3), split_into_list = FALSE, seed = 1)
p &lt;- c(train = 0.8, valid = 0.1, test = 0.1)
partition(y, p, seed = 1)
partition(y, p, split_into_list = FALSE, seed = 1)
partition(y, p, split_into_list = FALSE, use_names = FALSE, seed = 1)
partition(y, p = c(0.7, 0.3), type = "grouped")
partition(y, p = c(0.7, 0.3), type = "blocked")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
