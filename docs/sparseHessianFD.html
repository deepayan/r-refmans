<!DOCTYPE html><html><head><title>Help for package sparseHessianFD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sparseHessianFD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binary'><p>Binary choice example</p></a></li>
<li><a href='#binary-data'><p>Sample simulated data for binary choice example in vignette</p></a></li>
<li><a href='#coloring'><p>Triangular partitioning of variables</p></a></li>
<li><a href='#Coord.to.Pointers'><p>Convert a matrix defined by row and column indices to one</p>
defined by a row- or column-oriented compression scheme.</a></li>
<li><a href='#deprecated'><p>Deprecated functions</p></a></li>
<li><a href='#get_colors'><p>Vertex coloring of a sparse undirected graph</p></a></li>
<li><a href='#Matrix.to.Coord'><p>Row and column indices from sparse matrix.</p></a></li>
<li><a href='#Matrix.to.Pointers'><p>Extract row and column indices, pointers and values from a</p>
sparse matrix.</a></li>
<li><a href='#sparseHessianFD'><p>sparseHessianFD</p></a></li>
<li><a href='#sparseHessianFD-package'><p>Estimate sparse Hessians using finite differences of</p>
gradients.</a></li>
<li><a href='#subst'><p>Estimate sparse Hessian</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Numerical Estimation of Sparse Hessians</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Braun &lt;braunm@smu.edu&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://braunm.github.io/sparseHessianFD/">https://braunm.github.io/sparseHessianFD/</a>,
<a href="https://github.com/braunm/sparseHessianFD/">https://github.com/braunm/sparseHessianFD/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/braunm/sparseHessianFD/issues/">https://github.com/braunm/sparseHessianFD/issues/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates Hessian of a scalar-valued function, and returns it
    in a sparse Matrix format. The sparsity pattern must be known in advance. The
    algorithm is especially efficient for hierarchical models with a large number of
    heterogeneous units.  See Braun, M. (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v082.i10">doi:10.18637/jss.v082.i10</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL (== 2.0)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix (&ge; 1.4), methods, Rcpp (&ge; 0.12.13)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, numDeriv, scales, knitr, xtable, dplyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen (&ge; 0.3.3.3.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-19 22:12:47 UTC; braunm</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Braun <a href="https://orcid.org/0000-0003-4774-2119"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-19 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binary'>Binary choice example</h2><span id='topic+binary'></span><span id='topic+binary.f'></span><span id='topic+binary.grad'></span><span id='topic+binary.hess'></span>

<h3>Description</h3>

<p>Functions for binary choice example in the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary.f(P, data, priors, order.row = FALSE)

binary.grad(P, data, priors, order.row = FALSE)

binary.hess(P, data, priors, order.row = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_+3A_p">P</code></td>
<td>
<p>Numeric vector of length <code class="reqn">(N+1)k</code>.  First <code class="reqn">Nk</code>
elements are heterogeneous coefficients. The remaining k elements are population parameters.</p>
</td></tr>
<tr><td><code id="binary_+3A_data">data</code></td>
<td>
<p>Named list of data matrices Y and X, and choice count integer T</p>
</td></tr>
<tr><td><code id="binary_+3A_priors">priors</code></td>
<td>
<p>Named list of matrices inv.Omega and inv.Sigma</p>
</td></tr>
<tr><td><code id="binary_+3A_order.row">order.row</code></td>
<td>
<p>Determines order of heterogeneous coefficients in
parameter vector. If TRUE, heterogeneous coefficients are ordered by unit.  If FALSE, they are ordered by covariate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used by the heterogeneous binary
choice example in the vignette. There are N heterogeneous units, each making T binary choices.  The choice probabilities depend on k covariates.
</p>


<h3>Value</h3>

<p>Log posterior density, gradient and Hessian. The Hessian is
a dgCMatrix object.
</p>

<hr>
<h2 id='binary-data'>Sample simulated data for binary choice example in vignette</h2><span id='topic+binary-data'></span><span id='topic+binary_small'></span><span id='topic+binary_large'></span><span id='topic+binary_super'></span><span id='topic+binary_small-data'></span><span id='topic+binary_large-data'></span><span id='topic+binary_super-data'></span>

<h3>Description</h3>

<p>Sample datasets for vignette
</p>


<h3>Details</h3>

<p>The package provides four sample datasets for the hierarchical binary choice model described in the vignette. These datasets are:
</p>

<dl>
<dt>binary</dt><dd><p><code class="reqn">N=50</code>, <code class="reqn">k=3</code></p>
</dd>
<dt>binary_small</dt><dd><p><code class="reqn">N=20</code>, <code class="reqn">k=2</code></p>
</dd>
<dt>binary_large</dt><dd><p><code class="reqn">N=800</code>, <code class="reqn">k=3</code></p>
</dd>
<dt>binary_super</dt><dd><p><code class="reqn">N=1200</code>, <code class="reqn">k=3</code></p>
</dd>
</dl>

<p><code class="reqn">N</code> is the number of heterogeneous units.
<code class="reqn">k</code> is the number of covariates.
</p>
<p>The datasets were generated using the code in data-raw/binary_sim.R.
</p>

<hr>
<h2 id='coloring'>Triangular partitioning of variables</h2><span id='topic+coloring'></span>

<h3>Description</h3>

<p>cyclic coloring from a lower triangular pattern matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloring(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coloring_+3A_l">L</code></td>
<td>
<p>sparsity pattern of the Hessian as a lower triangular pattern
matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use.  Exported in order for replication files for
JSS article to run.
</p>


<h3>Value</h3>

<p>Integer vector of length nvars with color assignments for each
variable.
</p>

<hr>
<h2 id='Coord.to.Pointers'>Convert a matrix defined by row and column indices to one
defined by a row- or column-oriented compression scheme.</h2><span id='topic+Coord.to.Pointers'></span>

<h3>Description</h3>

<p>Returns indices and pointers that define a sparse
Hessian in compressed format.  Inputs are the row and column indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Coord.to.Pointers(
  rows,
  cols,
  dims,
  triangle = TRUE,
  lower = TRUE,
  symmetric = FALSE,
  order = c("column", "row", "triplet"),
  index1 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Coord.to.Pointers_+3A_rows">rows</code>, <code id="Coord.to.Pointers_+3A_cols">cols</code></td>
<td>
<p>row and column indices of non-zero elements</p>
</td></tr>
<tr><td><code id="Coord.to.Pointers_+3A_dims">dims</code></td>
<td>
<p>2-element vector for number of rows and columns.</p>
</td></tr>
<tr><td><code id="Coord.to.Pointers_+3A_triangle">triangle</code></td>
<td>
<p>Is input intended to be a triangular (TRUE) or full
(FALSE) matrix. See details for how this argument is interpreted
for different values of <code>order</code>.</p>
</td></tr>
<tr><td><code id="Coord.to.Pointers_+3A_lower">lower</code></td>
<td>
<p>If <code>triangular</code> is true, this argument identifies
the input matrix as lower- or upper-triangular.  This argument is
ignored if <code>triangle</code> is FALSE.</p>
</td></tr>
<tr><td><code id="Coord.to.Pointers_+3A_symmetric">symmetric</code></td>
<td>
<p>If TRUE, and matrix is triangular, then the matrix
will be treated as symmetric, with only the triangular elements
provided.  If matrix is neither triangular nor symmetric, then
symmetric=TRUE will probably trigger an error.</p>
</td></tr>
<tr><td><code id="Coord.to.Pointers_+3A_order">order</code></td>
<td>
<p>Determines the indexing/compression scheme for the
output matrix.  Use &quot;triplet&quot; to get row and column indices.
Defaults to the same class as M.</p>
</td></tr>
<tr><td><code id="Coord.to.Pointers_+3A_index1">index1</code></td>
<td>
<p>TRUE if using 1-based indexing.  FALSE for 0-based indexing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>triangle</code> and <code>order</code> have the following interpretation:
</p>

<dl>
<dt>triangle=TRUE</dt><dd><p>Input <code>rows</code> and cols represent lower
or upper triangle of a matrix. If <code>order="symmetric"</code>, then
the output list will be for a full, symmetric matrix. Otherwise,
the output list will be for only the lower or upper triangle.  Any
elements outside of the specified triangle will trigger an error.</p>
</dd>
<dt>triangle=FALSE</dt><dd><p>Input <code>rows</code> and cols represent a full
matrix. If that matrix is not symmetric, then
<code>order=="symmetric"</code> will trigger an error.</p>
</dd>
</dl>
<p>If <code>symmetric=FALSE</code> and <code>order='triplet'</code>, the output
list should contain the same row and column indices as the input
list.
</p>


<h3>Value</h3>

<p>A list.  See Matrix.to.Pointers (no values are included in
return list).
</p>


<h3>See Also</h3>

<p>Matrix.to.Pointers
</p>

<hr>
<h2 id='deprecated'>Deprecated functions</h2><span id='topic+deprecated'></span><span id='topic+Sym.CSC.to.Matrix'></span><span id='topic+Coord.to.Sym.Pattern.Matrix'></span><span id='topic+Coord.to.Pattern.Matrix'></span><span id='topic+new.sparse.hessian.obj'></span><span id='topic+sparseHessianFD.new'></span>

<h3>Description</h3>

<p>These functions were in earlier versions, but will no
longer be maintained, and are not even guaranteed to work now.
</p>
<p>Build sparse matrix from data in CSC (column
compressed) format.
</p>
<p>Converts row and column indices to a pattern Matrix
object of Matrix class
</p>
<p>This function is deprecated.  Use <code>sparseHessianFD</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sym.CSC.to.Matrix(H, nvars)

Coord.to.Sym.Pattern.Matrix(H, nvars)

Coord.to.Pattern.Matrix(
  rows,
  cols,
  dims,
  compressed = TRUE,
  symmetric = FALSE,
  index1 = TRUE
)

new.sparse.hessian.obj(
  x,
  fn,
  gr,
  hs,
  fd.method = 0L,
  eps = sqrt(.Machine$double.eps),
  ...
)

sparseHessianFD.new(
  x,
  fn,
  gr,
  rows,
  cols,
  direct = NULL,
  eps = sqrt(.Machine$double.eps),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deprecated_+3A_h">H</code></td>
<td>
<p>a list containing Hessian data.  See details.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_nvars">nvars</code></td>
<td>
<p>the number of rows (and columns) in the matrix.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_rows">rows</code>, <code id="deprecated_+3A_cols">cols</code></td>
<td>
<p>row and column indices of non-zero elements</p>
</td></tr>
<tr><td><code id="deprecated_+3A_dims">dims</code></td>
<td>
<p>2-element vector for number of rows and columns in
matrix</p>
</td></tr>
<tr><td><code id="deprecated_+3A_compressed">compressed</code></td>
<td>
<p>If TRUE, returns a matrix is compressed column (default=TRUE)</p>
</td></tr>
<tr><td><code id="deprecated_+3A_symmetric">symmetric</code></td>
<td>
<p>If TRUE, matrix will be symmetric, and only the
lower triangular elements need to be provided (default=FALSE)</p>
</td></tr>
<tr><td><code id="deprecated_+3A_index1">index1</code></td>
<td>
<p>TRUE if input row and col use 1-based indexing, and FALSE for 0-based indexing.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_x">x</code></td>
<td>
<p>variable vector for initialization</p>
</td></tr>
<tr><td><code id="deprecated_+3A_fn">fn</code></td>
<td>
<p>R function that returns function value</p>
</td></tr>
<tr><td><code id="deprecated_+3A_gr">gr</code></td>
<td>
<p>R function that returns the gradient of the function</p>
</td></tr>
<tr><td><code id="deprecated_+3A_hs">hs</code></td>
<td>
<p>list of two vectors:  row and column indices of non-zero
elements of lower triangle of Hessian.  See details.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_fd.method">fd.method</code></td>
<td>
<p>If TRUE, use direct method for computatation.  Otherwise, use
indirect/substitution method.  See references.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_eps">eps</code></td>
<td>
<p>The perturbation amount for finite differencing of the
gradient to compute the Hessian. Defaults to
sqrt(.Machine$double.eps).</p>
</td></tr>
<tr><td><code id="deprecated_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to fn and gr.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_direct">direct</code></td>
<td>
<p>If TRUE, use direct method for computatation.  Otherwise, use
indirect/substitution method.  See references.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use Matrix::sparseMatrix instead of Sym.CSC.to.Matrix.
</p>
<p>Use Coord.to.Pattern.Matrix with symmetric=TRUE instead of Coord.to.Sym.Pattern.Matrix.
</p>
<p>This function is useful to prototype a sparsity pattern.
No assumptions are made about symmetry.
</p>
<p>hs is a list of two elements:
</p>

<dl>
<dt>iRow</dt><dd><p> Integer vector of row indices of non-zero elements in
lower triangle of Hessian.</p>
</dd>
<dt>jCol</dt><dd><p> Integer vector of column indices of non-zero elements in
lower triangle of Hessian.</p>
</dd>
</dl>

<p>This function is deprecated.  Use <code>sparseHessianFD</code> instead.
</p>


<h3>Value</h3>

<p>An object of Matrix class.
</p>
<p>A sparse pattern matrix
</p>
<p>An object of class sparseHessianFD
</p>

<hr>
<h2 id='get_colors'>Vertex coloring of a sparse undirected graph</h2><span id='topic+get_colors'></span>

<h3>Description</h3>

<p>Generate proper vertex coloring of a sparse undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_colors(pntr, idx, nvars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_colors_+3A_pntr">pntr</code>, <code id="get_colors_+3A_idx">idx</code></td>
<td>
<p>row pointers and column indices of the adjacency matrix, in compressed column-oriented format. Must use zero-based indexing.</p>
</td></tr>
<tr><td><code id="get_colors_+3A_nvars">nvars</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use.  You should not have to call this function directly.
</p>


<h3>Value</h3>

<p>An integer vector of length nvars, where each element represents the color of the corresponding vertex. Indices are zero-based.
</p>

<hr>
<h2 id='Matrix.to.Coord'>Row and column indices from sparse matrix.</h2><span id='topic+Matrix.to.Coord'></span>

<h3>Description</h3>

<p>Utility function to extract row and column indices of
the non-zero
elements of a sparse matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Matrix.to.Coord(M, index1 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matrix.to.Coord_+3A_m">M</code></td>
<td>
<p>A matrix that is a subclass of sparseMatrix, as defined in
the Matrix package.</p>
</td></tr>
<tr><td><code id="Matrix.to.Coord_+3A_index1">index1</code></td>
<td>
<p>TRUE if the index of the first element should be 1,
and FALSE if 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wrapper to <a href="#topic+Matrix.to.Pointers">Matrix.to.Pointers</a> for <code>order='triplet'</code>
and <code>values=FALSE</code>, for extracting the row and column indices
of a sparsity pattern from a matrix that has that same pattern.
</p>


<h3>Value</h3>

<p>A list with two named elements.
</p>

<dl>
<dt>rows</dt><dd><p>Integer vector containing row indices of non-zero elements</p>
</dd>
<dt>cols</dt><dd><p>Integer vector containing column indices of non-zero elements</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>M1 &lt;- as(kronecker(diag(3), matrix(TRUE,2,2)),"sparseMatrix")
C &lt;- Matrix.to.Coord(M1)
M2 &lt;- Matrix::sparseMatrix(i=C$rows, j=C$cols)
all.equal(M1,M2)
</code></pre>

<hr>
<h2 id='Matrix.to.Pointers'>Extract row and column indices, pointers and values from a
sparse matrix.</h2><span id='topic+Matrix.to.Pointers'></span>

<h3>Description</h3>

<p>Returns a list of row indices, column indices,
pointers, and/or values of a sparse Hessian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Matrix.to.Pointers(
  M,
  as.symmetric = Matrix::isSymmetric(M),
  values = !is(M, "nMatrix"),
  order = NULL,
  index1 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matrix.to.Pointers_+3A_m">M</code></td>
<td>
<p>A sparse Matrix, as defined in the Matrix package.</p>
</td></tr>
<tr><td><code id="Matrix.to.Pointers_+3A_as.symmetric">as.symmetric</code></td>
<td>
<p>Defaults to isSymmetric(M).  If M is symmetric,
and as.symmetric is FALSE, then index/pointer elements in the
output list will be labeled according to order. If M is not
symmetric, and as.symmetric is TRUE, then an error will be triggered.</p>
</td></tr>
<tr><td><code id="Matrix.to.Pointers_+3A_values">values</code></td>
<td>
<p>If TRUE, values are returned in list as 'x'.
Defaults to TRUE for numeric and logical matrices, and FALSE for
pattern matrices.  If M is a pattern matrix, values=TRUE will
trigger a warning.</p>
</td></tr>
<tr><td><code id="Matrix.to.Pointers_+3A_order">order</code></td>
<td>
<p>Determines the indexing/compression scheme for the
output matrix.  Use 'triplet&quot; to get row and column indices.
Defaults to the same class as M.</p>
</td></tr>
<tr><td><code id="Matrix.to.Pointers_+3A_index1">index1</code></td>
<td>
<p>TRUE (default) if return indices and pointers should
use 1-based indexing.  FALSE for 0-based indexing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is included primarily for debugging
purposes.  It is used internally, but would not ordinarily be
called by an end user.
</p>


<h3>Value</h3>

<p>A list with the following elements. If order=='row',
</p>

<dl>
<dt>jCol</dt><dd><p> Integer vector containing column indices of non-zero elements</p>
</dd>
<dt>ipntr</dt><dd><p> Integer vector containing pointers to elements of
jCol at which the next row begins.</p>
</dd>
</dl>

<p>If order=='column'
</p>

<dl>
<dt>iRow</dt><dd><p> Integer vector containing row indices of non-zero elements</p>
</dd>
<dt>jpntr</dt><dd><p> Integer vector containing pointers to elements of
iRow at which the next column begins.</p>
</dd>
</dl>

<p>If order=='triplet'
</p>

<dl>
<dt>rows</dt><dd><p>Row indices of non-zero elements</p>
</dd>
<dt>cols</dt><dd><p>Column indices of non-zero elements</p>
</dd>
</dl>

<p>If as.symmetric is TRUE, then the row/column orientation does not matter.
</p>

<dl>
<dt>idx</dt><dd><p> Integer vector containing indices of non-zero elements</p>
</dd>
<dt>pntr</dt><dd><p> Integer vector containing pointers to elements of idx
at which the next row or column begins.</p>
</dd>
</dl>

<p>If values=TRUE, the return list includes x, the values of the
non-zero elements.
The 'class' element is the name of the sparse matrix class to which
the output corresponds (identifies numeric type, pattern, and
indexing/compression scheme).
</p>


<h3>See Also</h3>

<p>Matrix.to.Coord
</p>

<hr>
<h2 id='sparseHessianFD'>sparseHessianFD</h2><span id='topic+sparseHessianFD'></span>

<h3>Description</h3>

<p>A reference class for computing sparse Hessians
</p>


<h3>Details</h3>

<p>The sparseHessianFD function calls the initializer for the
sparseHessianFD class, and returns a sparseHessianFD object.
</p>
<pre>sparseHessianFD(x, fn, gr, rows, cols, delta, index1, complex, ...)</pre>
<p>The function, gradient and sparsity pattern are
declared as part of the initialization.
</p>
<p>Once initialized, the $hessian method will evaluate the Hessian at x.
</p>
<pre>
obj &lt;- sparseHessian(x, fn, gr, rows, cols, ...)
obj$hessian(x)
</pre>
<p>For convenience, the class provides wrapper methods to the <code>fn</code> and <code>gr</code> functions that were specified in the initializer.
</p>
<pre>
obj$fn(P) ## wrapper to objective function
obj$gr(P) ## wrapper to gradient
obj$fngr(P) ## list of obj function and gradient
obj$fngrhs(P) ## list of obj function, gradient and Hessian.
</pre>


<h4>Arguments to initializer</h4>


<dl>
<dt>x</dt><dd><p>an vector at which the function, gradient and Hessian are initialized and tested.</p>
</dd>
<dt>fn, gr</dt><dd><p>R functions that return the function value and
gradient, evaluated at x.</p>
</dd>
<dt>rows, cols</dt><dd><p>Numeric vectors with row and column indices of
the non-zero elements in the lower triangle (including diagonal) of
the Hessian.</p>
</dd>
<dt>delta</dt><dd><p>The perturbation amount for finite difference (or
complex step) of the gradient to compute the Hessian.  Defaults to 1e-07.</p>
</dd>
<dt>index1</dt><dd><p>TRUE if rows and cols use 1-based (R format)
indexing (FALSE for 0-based (C format) indexing.</p>
</dd>
<dt>complex</dt><dd><p>TRUE if Hessian will be computed using the complex
step method, and FALSE (default) if using finite differences. If
TRUE, both fn and gr must accept complex arguments and return complex values.</p>
</dd>
<dt>...</dt><dd><p>other arguments to be passed to fn and gr.</p>
</dd>
</dl>


<p>Other methods are described below.  Do not access any of the
fields directly.  The internal structure is subject to change in future versions.
</p>


<h3>Fields</h3>


<dl>
<dt><code>fn1</code></dt><dd><p>A closure for calling fn(x, ...).</p>
</dd>
<dt><code>gr1</code></dt><dd><p>A closure for calling gr(x, ...).</p>
</dd>
<dt><code>iRow,jCol</code></dt><dd><p>Numeric vectors with row and column indices of
the non-zero elements in the lower triangle (including diagonal) of
the Hessian.</p>
</dd>
<dt><code>delta</code></dt><dd><p>The perturbation amount for finite differencing of
the gradient to compute the Hessian. Defaults to 1e-07.</p>
</dd>
<dt><code>index1</code></dt><dd><p>TRUE if rows and cols use 1-based (R format)
indexing (FALSE for 0-based (C format) indexing.</p>
</dd>
<dt><code>complex</code></dt><dd><p>TRUE if Hessian will be computed using the complex
step method, and FALSE (default) if using finite differences.</p>
</dd>
<dt><code>D</code></dt><dd><p>raw finite differences (internal use only)</p>
</dd>
<dt><code>nvars</code></dt><dd><p>Number of variables (length of x)</p>
</dd>
<dt><code>nnz</code></dt><dd><p>Number of non-zero elements in the lower triangle of the Hessian.</p>
</dd>
<dt><code>ready</code></dt><dd><p>TRUE if object has been initialized, and Hessian has
been partitioned.</p>
</dd>
<dt><code>idx,pntr</code></dt><dd><p>Column indices and row pointers for non-zero
elements in lower triangle of the permuted Hessian.  Row-oriented
compressed storage.</p>
</dd>
<dt><code>colors</code></dt><dd><p>A vector representation of the partitioning of the columns.
There are nvars elements, one for each column of the permuted
Hessian.  The value corresponds to the &quot;color&quot; for that column.</p>
</dd>
<dt><code>perm,invperm</code></dt><dd><p>Permutation vector and its inverse</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>fn(x)</code></dt><dd><p>Return function value, evaluated at x: fn(x, ...)</p>
</dd>
<dt><code>fngr(x)</code></dt><dd><p>Return list of function value and gradient, evaluated at x</p>
</dd>
<dt><code>fngrhs(x)</code></dt><dd><p>Return list of function value, gradient, and Hessian, evaluated at x</p>
</dd>
<dt><code>get_invperm()</code></dt><dd><p>Return integer vector of inverse of permutation used for computing Hessian</p>
</dd>
<dt><code>get_nnz()</code></dt><dd><p>Return number of non-zero elements in lower triangle of Hessian</p>
</dd>
<dt><code>get_nvars()</code></dt><dd><p>Return dimension (number of rows or columns) of Hessian</p>
</dd>
<dt><code>get_pattern()</code></dt><dd><p>Return pattern matrix of lower triangle of Hessian</p>
</dd>
<dt><code>get_perm()</code></dt><dd><p>Return integer vector of permutation used for computing Hessian</p>
</dd>
<dt><code>get_perm_pattern()</code></dt><dd><p>Return pattern matrix of lower triangle of *permuted* Hessian</p>
</dd>
<dt><code>gr(x)</code></dt><dd><p>Return gradient, evaluated at x:  gr(x,...)</p>
</dd>
<dt><code>hessian(x)</code></dt><dd><p>Return sparse Hessian, evaluated at x, as a dgCMatrix object.</p>
</dd>
<dt><code>initialize(
  x,
  fn,
  gr,
  rows,
  cols,
  delta = 1e-07,
  index1 = TRUE,
  complex = FALSE,
  ...
)</code></dt><dd><p>Initialize object with functions to compute the objective function and gradient (fn and gr), row and column indices of non-zero elements (rows and cols), an initial variable vector x at which fn and gr can be evaluated, a finite differencing parameter delta, flags for 0 or 1-based indexing (index1), whether the complex step method will be used, and other arguments (...) to be passed to fn and gr.</p>
</dd>
<dt><code>partition()</code></dt><dd><p>Return the partitioning used to compute finite differences</p>
</dd>
<dt><code>pointers(out.index1 = index1)</code></dt><dd><p>Return list with indices (idx) and pointers (pntr) for sparsity pattern of the compressed sparse Hessian.  Since the Hessian is symmetric, the indices and pointers for row-oriented and column-oriented storage patterns are the same.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## Log posterior density of hierarchical binary choice model. See vignette.
set.seed(123)
data("binary_small")
N &lt;- length(binary[["Y"]])
k &lt;- NROW(binary[["X"]])
T &lt;- binary[["T"]]
P &lt;- rnorm((N+1)*k)
priors &lt;- list(inv.Sigma = rWishart(1,k+5,diag(k))[,,1],
               inv.Omega = diag(k))
true.hess &lt;- binary.hess(P, binary, priors)
pattern &lt;- Matrix.to.Coord(Matrix::tril(true.hess))
str(pattern)
obj &lt;- sparseHessianFD(P, fn=binary.f, gr=binary.grad,
       rows=pattern[["rows"]], cols=pattern[["cols"]],
                      data=binary, priors=priors)
hs &lt;- obj$hessian(P)
all.equal(hs, true.hess)

f &lt;- obj$fn(P) ## obj function
df &lt;- obj$gr(P) ## gradient
fdf &lt;- obj$fngr(P) ## list of obj function and gradient
fdfhs &lt;- obj$fngrhs(P) ## list of obj function, gradient and Hessian.
</code></pre>

<hr>
<h2 id='sparseHessianFD-package'>Estimate sparse Hessians using finite differences of
gradients.</h2><span id='topic+sparseHessianFD-package'></span>

<h3>Description</h3>

<p>Estimate sparse Hessians using finite differences of
gradients.
</p>


<h3>Details</h3>

<p>The Hessian is returned as a sparse Matrix
(dgCMatrix-class).  The user supplies the
objective function, the gradient, and the row and column indices of
the non-zero elements of the lower triangle of the Hessian (i.e.,
the sparsity structure must be known in advance).
</p>
<p>In a typical case, you should only need to use the
<a href="#topic+sparseHessianFD">sparseHessianFD</a> initializer,
and the fn, gr and hessian methods of the sparseHessian class, and the
<a href="#topic+Matrix.to.Coord">Matrix.to.Coord</a> utility function.
</p>


<h3>References</h3>

<p>Braun, Michael. 2017. sparseHessianFD: An R Package for Estimating
Sparse Hessian Matrices.  Journal of Statistical Software 82 (10): 1-22.
</p>
<p>Coleman, Thomas F, and Jin-Yi Cai. 1986.  The Cyclic Coloring Problem
and Estimation of Sparse Hessian Matrices.  SIAM Journal on Algebraic
Discrete Methods 7 (2): 221-235
</p>
<p>Coleman, Thomas F, Burton S Garbow, and Jorge J More. 1985. Software
for Estimating Sparse Hessian Matrices. ACM Transaction on
Mathematical Software 11 (4) (December): 363-377.
</p>
<p>Coleman, Thomas F and Jorge J More. 1984. Estimation of Sparse Hessian
Matrices and Graph Coloring Problems.  Mathematical Programming
28 (3) (October): 243-270
</p>
<p>Powell, M J D and Ph L Toint. 1979. On the Estimation of Sparse
Hessian Matrices.  SIAM Journal on Numerical Analysis 16 (6)
(December): 1060-1074.
</p>

<hr>
<h2 id='subst'>Estimate sparse Hessian</h2><span id='topic+subst'></span>

<h3>Description</h3>

<p>Estimate Hessian using triangular subsitution algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subst(Y, colors, jCol, ipntr, delta, nvars, nnz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subst_+3A_y">Y</code></td>
<td>
<p>Matrix of finite differences of gradients</p>
</td></tr>
<tr><td><code id="subst_+3A_colors">colors</code></td>
<td>
<p>Vector of length nvars that identifies color of each variable</p>
</td></tr>
<tr><td><code id="subst_+3A_jcol">jCol</code>, <code id="subst_+3A_ipntr">ipntr</code></td>
<td>
<p>Column indices and row pointers for non-zero elements of lower triangle of Hessian (row-oriented compressed format).</p>
</td></tr>
<tr><td><code id="subst_+3A_delta">delta</code></td>
<td>
<p>Perturbation factor used to compute finite differences of gradients.</p>
</td></tr>
<tr><td><code id="subst_+3A_nvars">nvars</code></td>
<td>
<p>Dimension of Hessian (number of variables)</p>
</td></tr>
<tr><td><code id="subst_+3A_nnz">nnz</code></td>
<td>
<p>Number of non-zero elements in the lower triangle of the Hessian.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use.  You should not have to call this function directly.
</p>


<h3>Value</h3>

<p>A sparse Hessian of class dgCMatrix.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
