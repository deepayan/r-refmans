<!DOCTYPE html><html><head><title>Help for package phylopairs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phylopairs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#phylopairs-package'><p>The 'phylopairs' package.</p></a></li>
<li><a href='#betareg.stan'><p>betareg.stan</p></a></li>
<li><a href='#covmat.check'><p>covmat.check</p></a></li>
<li><a href='#linreg.stan'><p>linreg.stan</p></a></li>
<li><a href='#node.averager'><p>node.averager</p></a></li>
<li><a href='#pair.age.in.tree'><p>pair.age.in.tree</p></a></li>
<li><a href='#simulated.datasets'><p>Simulated Datasets</p></a></li>
<li><a href='#taxapair.vcv'><p>taxapair.vcv</p></a></li>
<li><a href='#twoterm.plmm.mats'><p>twoterm.plmm.mats</p></a></li>
<li><a href='#twoterm.plmm.stan'><p>twoterm.plmm.stan</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Comparative Analyses of Lineage-Pair Traits</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates the testing of causal relationships among lineage-pair traits in a phylogenetically informed context. Lineage-pair traits are characters that are defined for pairs of lineages instead of individual taxa. Examples include the strength of reproductive isolation, range overlap, competition coefficient, diet niche similarity, and relative hybrid fitness. Users supply a lineage-pair dataset and a phylogeny. 'phylopairs' calculates a covariance matrix for the pairwise-defined data and provides built-in models to test for relationships among variables while taking this covariance into account. Bayesian sampling is run through built-in 'Stan' programs via the 'rstan' package. The various models and methods that this package makes available are described in Anderson et al. (In Review), Coyne and Orr (1989) &lt;<a href="https://doi.org/10.1111%2Fj.1558-5646.1989.tb04233.x">doi:10.1111/j.1558-5646.1989.tb04233.x</a>&gt;, Fitzpatrick (2002) &lt;<a href="https://doi.org/10.1111%2Fj.0014-3820.2002.tb00860.x">doi:10.1111/j.0014-3820.2002.tb00860.x</a>&gt;, and Castillo (2007) &lt;<a href="https://doi.org/10.1002%2Fece3.3093">doi:10.1002/ece3.3093</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, loo, methods, phytools, Rcpp (&ge; 0.12.0), RcppParallel
(&ge; 5.0.1), rstan (&ge; 2.18.1), rstantools (&ge; 2.4.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.18.1), StanHeaders (&ge;
2.18.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-24 15:29:55 UTC; Sean</td>
</tr>
<tr>
<td>Author:</td>
<td>Sean A. S. Anderson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sean A. S. Anderson &lt;sean.as.anderson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-25 11:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='phylopairs-package'>The 'phylopairs' package.</h2><span id='topic+phylopairs-package'></span><span id='topic+phylopairs'></span>

<h3>Description</h3>

<p><code>phylopairs</code> provides tools for conducting comparative analyses of lineage-pair traits in a phylogenetically informed context. Comparative analyses of pairwise-defined traits like &quot;strength of RI&quot; or &quot;diet niche overlap&quot; collected for numerous pairs of related taxa can yield important insights to biologists, but it is important to recognize that such data are not independent. <code>phylopairs</code> provides a function, <code>taxapair.vcv()</code>, that calculates the expected covariance structure of a pairwise-defined trait given (1) a table of pairs, (2) a phylogeny, and (3) a chosen model (as described in Anderson et al. <em>in review</em>). This covariance structure can be used in any number of downstream analyses. <code>phylopairs</code> provides tools for a few such analyses, including linear regression, linear mixed models, generalized least squares, and two forms of beta regression for use with bounded response variables. All analyses are conducted in a Bayesian framework using built-in <code>Stan</code> software programs interfaced through the <code>rstan</code> package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sean A. S. Anderson <a href="mailto:sean.as.anderson@gmail.com">sean.as.anderson@gmail.com</a>
</p>


<h3>References</h3>

<div class="sourceCode"><pre>	Stan Development Team (NA). RStan: the R interface to Stan. R package version 
 2.32.6. https://mc-stan.org

	Anderson et al. *in review*. The comparative analysis of lineage-pair data. 
</pre></div>

<hr>
<h2 id='betareg.stan'>betareg.stan</h2><span id='topic+betareg.stan'></span>

<h3>Description</h3>

<p>Fits one of two beta regression models to a dataset in a Bayesian
framework using <code>Stan</code> software via the <code>rstan</code> package. Response variable must be
bounded between 0 and 1. Users can fit either (1) a basic beta regression model or a
(2) beta mixed-effects model in which there are covarying random intercepts in the
linear predictor. For the latter, users must supply a covariance matrix. In both
models, users can choose one of four link functions. Users can alter parameters for
model-parameter prior distributions and Bayesian sampling settings. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betareg.stan(des, y, model="beta.ols", link="logit", covmat=NULL, 
  iter=2000, chains=4, coef.u=0, coef.sd=10, phi.shape=0.01, phi.rate=0.01,
  physig2.u=-1, physig2.sd=1, cores=4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betareg.stan_+3A_des">des</code></td>
<td>
<p>A vector of predictor variable observations OR, in the case of multiple predictors, a matrix in which each column is a vector of observations of a given predictor. <code>betareg.stan()</code> adds a column of 1s to make this a design matrix whose first column corresponds to the model intercept (unless such a column already exists).</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_y">y</code></td>
<td>
<p>One of &quot;beta.ols&quot; or &quot;beta.mm&quot; for a basic beta regression model or beta mixed model, respectively; defaults to &quot;beta.ols&quot;.</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_model">model</code></td>
<td>
<p>A vector of response variable observations.</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_link">link</code></td>
<td>
<p>The link function to be used. Default is &quot;logit&quot;. Other possible choices are &quot;probit&quot;, &quot;cloglog&quot; (complementary log-log), and &quot;loglog&quot;.</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_covmat">covmat</code></td>
<td>
<p>Covariance matrix for model residuals (a lineage-pair covariance matrix if analyzing lineage-pair data or a phylogenetic vcv matrix if analyzing  bounded species data).</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_iter">iter</code></td>
<td>
<p>Number of iterations to run on each chain; defaults to 2000 (more are often necessary).</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains to run; defaults to 4.</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_coef.u">coef.u</code></td>
<td>
<p>Mean of the Gaussian prior for each preditor variable coefficient; defaults to 0.</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_coef.sd">coef.sd</code></td>
<td>
<p>SD of the Gaussian prior for each preditor variable coefficient; defaults to 10.</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_phi.shape">phi.shape</code></td>
<td>
<p>Shape parameter for gamma prior of beta distribution's precision parameter (phi); defaults to 0.01.</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_phi.rate">phi.rate</code></td>
<td>
<p>Rate parameter for gamma prior of beta distribution's precision parameter (phi); defaults to 0.01.</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_physig2.u">physig2.u</code></td>
<td>
<p>Mean of the lognormal prior for the scale of the residual covariance; defaults to -1.</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_physig2.sd">physig2.sd</code></td>
<td>
<p>SD of the lognormal prior for the scale of the residual covariance; defaults to 1.</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used; defaults to 4 (one chain per core).</p>
</td></tr>
<tr><td><code id="betareg.stan_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>rstan::sampling</code>, including control parmeters (see rstan::sampling documentation)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two models that can be chosen differ in terms of their linear predictor
on the scale of the link function. These predictors are
</p>

<ol>
<li><p> Simple beta regression: <code>g(u) = XB</code>
</p>
</li>
<li><p> Beta mixed-effects regression: <code>g(u) = XB + u, u~N(0, physig2*C)</code>, where C is a
lineage-pair covariance matrix (if analyzing lineage-pair data) or a
phylogenetic vcv matrix (if analyzing species data) and physig2 is the
scaling parameter for C.
</p>
</li></ol>

<p><strong>NOTE</strong>: For model 2, the user must supply a covariance matrix.
</p>
<p><strong>Prior Distributions for Model Parameters</strong>:
The underlying stan models assume the following prior distributions for model
parameters.
</p>

<ol>
<li><p> Regression coefficients: Gaussian prior (users can set prior mean and sd).
</p>
</li>
<li><p> Precision parameter <code>phi</code>: gamma prior (users can set prior shape and rate of gamma).
</p>
</li>
<li> <p><code>physig</code>: lognormal prior (users can set prior mean and sd).
</p>
</li></ol>



<h3>Value</h3>

<p>A list containing two elements: (1) the posterior distribution of model parameters, and (2) the log-likelihood of the posteriors for use in downstream analyses (e.g. the calculation of model fitting metrics like loo or waic)
</p>


<h3>References</h3>

<p>Anderson, S. A. S., et al. <em>In review</em>. The comparative analysis of lineage-pair data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1: Fit beta regression models with different link functions to independent data
# Load a dataset of independent response observations simulated with a logit link function
data(data5)
# Note: data were simulated with Coef[1]=1 (intercept), Coef[2]=0.8 (slope), phi=5

# Run the betareg function
result1 = betareg.stan(des=data5[,3], y=data5[,4], iter=1000, cores=2)

# Fit the model again but this time use a probit link function
result2 = betareg.stan(des=data5[,3], y=data5[,4], link="probit", iter=1000, cores=2)

# Compare posterior parameter estimates
result1[[1]]
result2[[1]]

## Example 2: Fit beta regression models to a dataset with simulated non-independence
# Load a dataset of non-independent response observations simulated with a logit link function
data(data7)
# Note: data were simulated with Coef[1]=1 (intercept), Coef[2]=0.8 (slope), phi=5
# Load the lineage-pair covariance matrix that arose from those simulations
data(sim.cov.pairs)

# Run the betareg function
result1 = betareg.stan(des=data7[,3], y=data7[,4], model="beta.mm", cov=sim.cov.pairs, 
 iter=1000, cores=2)

# Fit the model again but this time without the covariance matrix
result2 = betareg.stan(des=data7[,3], y=data7[,4], iter=1000, cores=2)

# Fit the model a third time with the cov. matrix but now with a probit link function
result3 = betareg.stan(des=data7[,3], y=data7[,4], model="beta.mm", 
  cov=sim.cov.pairs, link="probit", iter=1000, cores=2)

# Compare posterior parameter estimates
result1[[1]]
result2[[1]]
result3[[1]]

# Compare the fit of the three models via leave-on-out (loo) cross validation.
loo1 = suppressWarnings(loo::loo(result1[[2]]))
loo2 = suppressWarnings(loo::loo(result2[[2]]))
loo3 = suppressWarnings(loo::loo(result3[[2]]))
loo::loo_compare(loo1, loo2, loo3)

</code></pre>

<hr>
<h2 id='covmat.check'>covmat.check</h2><span id='topic+covmat.check'></span>

<h3>Description</h3>

<p>Tets for validity of a covariance matrix based on four conditions:
symmetry, diagonal dominance, positive definiteness, and positive variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covmat.check(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covmat.check_+3A_mat">mat</code></td>
<td>
<p>A putative covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A valid covariance matrix must be symmetric, diagonally dominant (largest values
in each row are on the diagonal), positive definite, and have positive variance.
<code>covmat.check</code> takes a matrix as input and tests for these four conditions.
</p>


<h3>Value</h3>

<p>A data.frame containing logical &quot;TRUE&quot; or &quot;FALSE&quot; for each condition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load sample covariance matrix
data(sim.cov.pairs)
# Test for validity
covmat.check(sim.cov.pairs)
</code></pre>

<hr>
<h2 id='linreg.stan'>linreg.stan</h2><span id='topic+linreg.stan'></span>

<h3>Description</h3>

<p>Fits one of three models of linear regression to a dataset in a Bayesian
framework. Bayesian sampling is conducted in the Stan software via the 'rstan'
package. Users supply vectors of observations and, unless an &quot;ols&quot; model is chosen,
a covariance matrix. Users can alter parameters for model-parameter prior distributions
and Bayesian sampling settings. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linreg.stan(des, y, model="ols", covmat=NULL, iter=2000, 
  chains=4, cores=4, coef.u=0, coef.sd=10, physig2.u=-1, physig2.sd=1, 
  randsig2.loc=0, randsig2.sc=2.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linreg.stan_+3A_des">des</code></td>
<td>
<p>A vector of predictor variable observations OR, in the case of multiple predictors, a matrix in which each column is a vector of observations of a given predictor. Function will add a column of 1s to make this a design matrix whose first column corresponds to the model intercept (unless such a column already exists).</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_y">y</code></td>
<td>
<p>A vector of response variable observations.</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_model">model</code></td>
<td>
<p>Choice of &quot;ols&quot;, &quot;pgls&quot;, or &quot;pgls.mm&quot;; defaults to ols.</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_covmat">covmat</code></td>
<td>
<p>Covariance matrix for model residuals (a lineage-pair covariance matrix if analyzing lineage-pair data or a phylogenetic vcv matrix if analyzing species data).</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_iter">iter</code></td>
<td>
<p>Number of iterations to run on each chain; defaults to 2000 (more are often necessary).</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains to run; defaults to 4.</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use.</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_coef.u">coef.u</code></td>
<td>
<p>Mean of the Gaussian prior for each preditor variable coefficient; defaults to 0.</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_coef.sd">coef.sd</code></td>
<td>
<p>SD of the Gaussian prior for each preditor variable coefficient; defaults to 10.</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_physig2.u">physig2.u</code></td>
<td>
<p>Mean of the prior distribution (lognormal) for the scale of the phylogenetic component of residual covariance; defaults to -1.</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_physig2.sd">physig2.sd</code></td>
<td>
<p>SD of the prior distribution (lognormal) for the scale of the phylogenetic component of residual covariance; defaults to 1.</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_randsig2.loc">randsig2.loc</code></td>
<td>
<p>Location parameter of the prior distribution (cauchy) for the scale of the independent component of residual covariance ; defaults to 0.</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_randsig2.sc">randsig2.sc</code></td>
<td>
<p>Scale parameter of the prior distribution (cauchy) for the scale of the independent component of residual covariance ; defaults to 2.5.</p>
</td></tr>
<tr><td><code id="linreg.stan_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>rstan::sampling()</code>, including control parmeters (see <code>rstan::sampling()</code> documentation)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The models that can be chosen are:
</p>

<ol>
<li><p> &quot;ols&quot;: basic ordinary least-squares regression.
</p>
<p><code>Y = XB + epsilon</code>; where <code>epsilon~N(0,randsig2*I)</code> and randsig2 is the scaling parameter for identity matrix I.
</p>
</li>
<li><p> &quot;pgls&quot;: phylogenetic generalized least-squares regression in which residuals
covary according to covariance matrix C. This is a lineage-pair covariance
matrix (if analyzing lineage-pair data) or a phylogenetic vcv matrix
(if analyzing species data).
</p>
<p><code>Y = XB + epsilon</code>; where <code>epsilon~N(0,physig2*C)</code> and physig2 is the scaling parameter for covariance matrix C.
</p>
</li>
<li><p> &quot;pgls.mm&quot; a mixed-effects version of pgls in which the residuals have both
uncorrelated and correlated components, where the latter are structured according
to covariance matrix C.
</p>
<p><code>Y = XB + epsilon + u</code>; where <code>epsilon~N(0,randsig2*I)</code> and <code>u~N(0,physig2*C)</code>.
</p>
</li></ol>

<p><strong>NOTE</strong>: For models 2 and 3, the user must supply a covariance matrix.
</p>
<p><strong>Prior Distributions for Regression Model Parameters</strong>:
The underlying stan models assume the following prior distributions for model
parameters
</p>

<ol>
<li><p> Regression coefficients: Gaussian prior (users can set prior mean and sd).
</p>
</li>
<li> <p><code>physig2</code>: lognormal prior (users can set prior mean and sd).
</p>
</li>
<li> <p><code>randsig2</code>: cauchy prior (users can set location and scale parameters of prior).
</p>
</li></ol>



<h3>Value</h3>

<p>A list containing two elements: (1) the posterior distribution of model parameters, and (2) the log-likelihood of the posteriors for use in downstream analyses (e.g. the calculation of model fitting metrics like loo or waic)
</p>


<h3>References</h3>

<p>Anderson, S. A. S., et al. <em>In review</em>. The comparative analysis of lineage-pair data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Fit regression models with and without covariance matrix
# Note: data were simulated with Coef[1]=1 (intercept), Coef[2]=0.8 (slope)
# Load a data simulated with a non-independent response observations
data(data3)
# Also load the lineage-pair covariance matrix that arose from those simulations
data(sim.cov.pairs)
# Fit an OLS model
result1 = linreg.stan(des=data3[,3], y=data3[,4], cores=2)
# Fit an pgls model
result2 = linreg.stan(des=data3[,3], y=data3[,4], model="pgls", covmat=sim.cov.pairs, cores=2)

# Compare posterior parameter estimates
result1[[1]]
result2[[1]]

# Compare the fit of the two models via loo and waic
loo1 = loo::loo(result1[[2]])
loo2 = loo::loo(result2[[2]])
waic1 = loo::waic(result1[[2]])
waic2 = loo::waic(result2[[2]])
loo1
loo2
waic1
waic2
loo::loo_compare(loo1, loo2)
loo::loo_compare(waic1, waic2)

# Extend the comparison by fitting a pgls.mm model
result3 = linreg.stan(des=data3[,3], y=data3[,4], model="pgls.mm", 
 covmat=sim.cov.pairs, cores=2)

# Compare posterior parameter estimates
result1[[1]]
result2[[1]]
result3[[1]]

# Compare the fit of the three models via loo and waic
loo3 = loo::loo(result3[[2]])
waic3 = loo::waic(result3[[2]])
loo::loo_compare(loo1, loo2, loo3)
loo::loo_compare(waic1, waic2, waic3)

</code></pre>

<hr>
<h2 id='node.averager'>node.averager</h2><span id='topic+node.averager'></span>

<h3>Description</h3>

<p>Calculate weighted or unweighted node-averaged values of a lineage-pair trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node.averager(dataset, tree, taxacolumns, varb, 
  weighted=FALSE, prune=TRUE, av=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node.averager_+3A_dataset">dataset</code></td>
<td>
<p>A data.frame in which each row corresponds to a pair in the dataset. Must contain two columns of taxa names (one for each taxon in every pair) and at least one data column with the pairwise-defined trait that is to be averaged. Taxa names must be in same format as that used in the tree.</p>
</td></tr>
<tr><td><code id="node.averager_+3A_tree">tree</code></td>
<td>
<p>An ultrametric phylogenetic tree ('phylo' object) containing the species that appear in at least one pair in the dataset. Names must be in the same format as those used in 'dataset'.</p>
</td></tr>
<tr><td><code id="node.averager_+3A_taxacolumns">taxacolumns</code></td>
<td>
<p>Character vector containing the column names for the two columns containing species names (e.g. c(&quot;sp1&quot;, &quot;sp2&quot;))</p>
</td></tr>
<tr><td><code id="node.averager_+3A_varb">varb</code></td>
<td>
<p>The variable to be averaged (e.g. &quot;RI&quot;, &quot;range_overlap&quot;, etc.)</p>
</td></tr>
<tr><td><code id="node.averager_+3A_weighted">weighted</code></td>
<td>
<p>Logical indicating whether weighted node averages are to be calculated; defaults to FALSE.</p>
</td></tr>
<tr><td><code id="node.averager_+3A_prune">prune</code></td>
<td>
<p>Logical indicating whether tree should be pruned to contain just the species represented in the dataset; defaults to TRUE.</p>
</td></tr>
<tr><td><code id="node.averager_+3A_av">av</code></td>
<td>
<p>Logical indicating whether to average the values of multiple entries for the same pair, should they appear in the dataset; defaults to TRUE. If set to FALSE, function will stop in the case of more than one entry in the dataset corresponding to the same pair.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>node.averager()</code> takes a lineage-pair dataset and a phylogenetic tree and
returns the average value of the pairwise-defined trait at each node. It calculates,
at each node in the tree, the average value of a pairwise-defined trait for all pairs
whose species span the node.
</p>
<p>The simple or 'unweighted' average is calculated as introduced by Coyne
and Orr (1989). The 'weighted' node averaging procedure was introduced by
Fitzpatrick (2002) and discussed in Fitzpatrick and Turelli (2006). In weighted
averaging, the trait values for the pairs spanning a node are first halved K-1
times, where K is the number of nodes between the species in a pair. These halved
values are then summed to get arrive at a weighted average for a node.
</p>
<p><strong>Note:</strong> For datasets containing many individual species, the best available
tree might be very large. By default, <code>node.averager()</code> prunes the tree to
contain just the species represented in the dataset. Beware that pruning can
affect both the number of nodes and the node averaged values (for example by
altering the number of nodes between pairs when calculating weighted node averages).
</p>


<h3>Value</h3>

<p>Numeric vector of node averages, named according to node indices.
</p>


<h3>References</h3>

<p>Coyne, J. A., Orr, H. A. 1989. Patterns of speciation in Drosophila. Evolution 43:362-381.
</p>
<p>Fitzpatrick, B. M. 2002. Molecular correlates of reproductive isolation. Evolution 56:191-198.
</p>
<p>Fitzpatrick, B. M., Turelli. 2006. The geography of mammalian speciation: mixed signals from phylogenies and range maps. Evolution 60:601-615.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load simulated dataset and tree
data(data1)
data(sim.tree1)

# Perform node averaging
unwtd &lt;- node.averager(dataset = data1, tree = sim.tree1, varb = "pred", 
  taxacolumns = c("sp1", "sp2"))
wtd &lt;- node.averager(dataset = data1, tree = sim.tree1, varb = "pred", 
  taxacolumns = c("sp1", "sp2"), weighted = TRUE)

# Compare outcomes of weighted and unweighted node averaging
unwtd
wtd
summary(unwtd)
summary(wtd)

# Calculate data loss
nrow(data1) - length(wtd)
nrow(data1) - length(unwtd)


# Plot tree and node labels
library(ape)
plot(sim.tree1)
nodelabels()

</code></pre>

<hr>
<h2 id='pair.age.in.tree'>pair.age.in.tree</h2><span id='topic+pair.age.in.tree'></span>

<h3>Description</h3>

<p>Takes a lineage-pair dataset and a phylogenetic tree and returns the 'age' of the node representing the MRCA for each pair. 'Age' is measured from the present and is in whatever units are represented by branch lengths of the tree (which is time in a dated phylogeny).
</p>
<p>Takes a lineage-pair dataset and a phylogenetic tree and returns the 'age' of the node representing the MRCA for each pair. 'Age' is measured from the present and is in whatever units are represented by branch lengths of the tree (which is time in a dated phylogeny).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair.age.in.tree(dataset, tree, taxacolumns)

pair.age.in.tree(dataset, tree, taxacolumns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair.age.in.tree_+3A_dataset">dataset</code></td>
<td>
<p>A data.frame in which each row corresponds to a pair in the dataset. Must contain two columns of taxa names (one for each taxon in every pair), and the taxa names must be in same format as that used in the tree.</p>
</td></tr>
<tr><td><code id="pair.age.in.tree_+3A_tree">tree</code></td>
<td>
<p>An ultrametric phylogenetic tree ('phylo' object) containing the species that appear in at least one pair in the dataset. Names must be in the same format as those used in 'dataset'.</p>
</td></tr>
<tr><td><code id="pair.age.in.tree_+3A_taxacolumns">taxacolumns</code></td>
<td>
<p>Character vector containing the column names for the two columns containing species names (e.g. c(&quot;sp1&quot;, &quot;sp2&quot;))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function is a wrapper for <code>ape::node.depth.edgelength</code>. That function returns the depths of all the nodes in a tree as measured from the root. <code>phylopairs::node.age</code> converts these values to depth as measured from the present and returns the values corresponding to each pair in a user-supplied lineage-pair dataset.
</p>
<p>Function is a wrapper for <code>ape::node.depth.edgelength()</code>. That function returns the depths of all the nodes in a tree as measured from the root. <code>phylopairs::node.age()</code> converts these values to depth as measured from the present and returns the values corresponding to each pair in a user-supplied lineage-pair dataset.
</p>


<h3>Value</h3>

<p>A numeric vector of node ages ordered to match the rows in 'dataset'.
</p>
<p>A numeric vector of node ages ordered to match the rows in 'dataset'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a dataset and a tree
data(data1)
data(sim.tree1)

# Find the node.ages and add as a column to the dataset
data1$age = pair.age.in.tree(dataset=data1, tree=sim.tree1, taxacolumns=c("sp1","sp2"))
head(data1)

# Plot tree with axis in units of branch lengths and perform visual check that dates are correct

library(ape)
plot(sim.tree1)
axisPhylo()

# Load a dataset and a tree
data(data1)
data(sim.tree1)

# Find the node.ages and add as a column to the dataset
data1$age = pair.age.in.tree(dataset=data1, tree=sim.tree1, taxacolumns=c("sp1","sp2"))
head(data1)


# Plot tree with axis in units of branch lengths and perform visual check that dates are correct
library(ape)
plot(sim.tree1)
axisPhylo()

</code></pre>

<hr>
<h2 id='simulated.datasets'>Simulated Datasets</h2><span id='topic+simulated.datasets'></span><span id='topic+data1'></span><span id='topic+data2'></span><span id='topic+data3'></span><span id='topic+data4'></span><span id='topic+data5'></span><span id='topic+data6'></span><span id='topic+data7'></span><span id='topic+data8'></span><span id='topic+sim.cov.pairs'></span><span id='topic+sim.tree1'></span>

<h3>Description</h3>

<p>Simulated datasets are provided to help users understand functions. Lineage-pairs (n=190) were created from a simulated phylogenetic tree with 20 tips. A predictor variable was generated from random draws of a standard normal. Reponse variables of various structures were simulated as follows:
</p>

<ol>
<li> <p><strong>Simulated Dataset 1</strong> Unbounded response, linear relationship between response and predictor, no covariance in residuals
</p>
</li>
<li> <p><strong>Simulated Dataset 2</strong> Unbounded response, no relationship between response and predictor, no covariance in residuals
</p>
</li>
<li> <p><strong>Simulated Dataset 3</strong> Unbounded response, linear relationship between response and predictor, covariance in residuals
</p>
</li>
<li> <p><strong>Simulated Dataset 4</strong> Unbounded response, no relationship between response and predictor, covariance in residuals
</p>
</li>
<li> <p><strong>Simulated Dataset 5</strong> Bounded response, linear relationship between response and predictor on link scale, no covariance in residuals
</p>
</li>
<li> <p><strong>Simulated Dataset 6</strong> Bounded response, no relationship between response and predictor on link scale, no covariance in residuals
</p>
</li>
<li> <p><strong>Simulated Dataset 7</strong> Bounded response, linear relationship between response and predictor on link scale, covariance in residuals
</p>
</li>
<li> <p><strong>Simulated Dataset 8</strong> Bounded response, no relationship between response and predictor on link scale, covariance in residuals
</p>
</li>
<li> <p><strong>Simulated Lineage-Pair Covariance Matrix</strong> A 190*190 covariance matrix used in simulating the example datasets in this package.
</p>
</li>
<li> <p><strong>Simulated Phylogenetic Tree</strong> A 20-species ultrametric phylogenetic tree used in simulating the example datasets in this package.
</p>
</li></ol>



<h3>Format</h3>

<p>The datasets are as follows
</p>

<dl>
<dt>data1</dt><dd><p>A data frame with 190 rows and 4 columns.
</p>

<dl>
<dt>sp1</dt><dd><p>Identity of Species 1 in Pair</p>
</dd>
<dt>sp2</dt><dd><p>Identity of Species 2 in Pair</p>
</dd>
<dt>pred</dt><dd><p>Numeric predictor variable</p>
</dd>
<dt>y</dt><dd><p>Numeric response variable</p>
</dd>
</dl>

</dd>
<dt>data2</dt><dd><p>A data frame with 190 rows and 4 columns.
</p>

<dl>
<dt>sp1</dt><dd><p>Identity of Species 1 in Pair</p>
</dd>
<dt>sp2</dt><dd><p>Identity of Species 2 in Pair</p>
</dd>
<dt>pred</dt><dd><p>Numeric predictor variable</p>
</dd>
<dt>y</dt><dd><p>Numeric response variable</p>
</dd>
</dl>

</dd>
<dt>data3</dt><dd><p>A data frame with 190 rows and 4 columns.
</p>

<dl>
<dt>sp1</dt><dd><p>Identity of Species 1 in Pair</p>
</dd>
<dt>sp2</dt><dd><p>Identity of Species 2 in Pair</p>
</dd>
<dt>pred</dt><dd><p>Numeric predictor variable</p>
</dd>
<dt>y</dt><dd><p>Numeric response variable</p>
</dd>
</dl>

</dd>
<dt>data4</dt><dd><p>A data frame with 190 rows and 4 columns.
</p>

<dl>
<dt>sp1</dt><dd><p>Identity of Species 1 in Pair</p>
</dd>
<dt>sp2</dt><dd><p>Identity of Species 2 in Pair</p>
</dd>
<dt>pred</dt><dd><p>Numeric predictor variable</p>
</dd>
<dt>y</dt><dd><p>Numeric response variable</p>
</dd>
</dl>

</dd>
<dt>data5</dt><dd><p>A data frame with 190 rows and 4 columns.
</p>

<dl>
<dt>sp1</dt><dd><p>Identity of Species 1 in Pair</p>
</dd>
<dt>sp2</dt><dd><p>Identity of Species 2 in Pair</p>
</dd>
<dt>pred</dt><dd><p>Numeric predictor variable</p>
</dd>
<dt>y</dt><dd><p>Numeric response variable</p>
</dd>
</dl>

</dd>
<dt>data6</dt><dd><p>A data frame with 190 rows and 4 columns.
</p>

<dl>
<dt>sp1</dt><dd><p>Identity of Species 1 in Pair</p>
</dd>
<dt>sp2</dt><dd><p>Identity of Species 2 in Pair</p>
</dd>
<dt>pred</dt><dd><p>Numeric predictor variable</p>
</dd>
<dt>y</dt><dd><p>Numeric response variable</p>
</dd>
</dl>

</dd>
<dt>data7</dt><dd><p>A data frame with 190 rows and 4 columns.
</p>

<dl>
<dt>sp1</dt><dd><p>Identity of Species 1 in Pair</p>
</dd>
<dt>sp2</dt><dd><p>Identity of Species 2 in Pair</p>
</dd>
<dt>pred</dt><dd><p>Numeric predictor variable</p>
</dd>
<dt>y</dt><dd><p>Numeric response variable</p>
</dd>
</dl>

</dd>
<dt>data8</dt><dd><p>A data frame with 190 rows and 4 columns.
</p>

<dl>
<dt>sp1</dt><dd><p>Identity of Species 1 in Pair</p>
</dd>
<dt>sp2</dt><dd><p>Identity of Species 2 in Pair</p>
</dd>
<dt>pred</dt><dd><p>Numeric predictor variable</p>
</dd>
<dt>y</dt><dd><p>Numeric response variable</p>
</dd>
</dl>

</dd>
<dt>sim.cov.pairs</dt><dd><p>A 190x190 covariance matrix
</p>
</dd>
<dt>sim.tree1</dt><dd><p>A phylo object
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated data generated with the script provided in the 'inst' directory.
</p>

<hr>
<h2 id='taxapair.vcv'>taxapair.vcv</h2><span id='topic+taxapair.vcv'></span>

<h3>Description</h3>

<p>Calculates an unscaled lineage-pair covariance matrix for use in
downstream analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxapair.vcv(sp.pairs, tree, spnames=FALSE, dec=2, model="sq.diff", 
  regularize=FALSE, regparam=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taxapair.vcv_+3A_sp.pairs">sp.pairs</code></td>
<td>
<p>A table (matrix or data.frame) in which the first column contains the names of 'species 1' and the second column contains the names of 'species 2'. Names must be in the same format used in the phylogenetic tree.</p>
</td></tr>
<tr><td><code id="taxapair.vcv_+3A_tree">tree</code></td>
<td>
<p>An ultrametric phylogenetic tree ('phylo' object) containing species that appear in the dataset (as either a species 1 or species 2 or both).</p>
</td></tr>
<tr><td><code id="taxapair.vcv_+3A_spnames">spnames</code></td>
<td>
<p>Logical determining whether to use species names as row and column labels for matrix. If TRUE, then the name of a row or column will be in the form &quot;species1_species2&quot;. If FALSE, names are formed from the indices of the species names in the tree &quot;indexOfSpecies1_indexOfSpecies2&quot;. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="taxapair.vcv_+3A_dec">dec</code></td>
<td>
<p>Number of decimal places to round the values in the matrix; defaults to 2.</p>
</td></tr>
<tr><td><code id="taxapair.vcv_+3A_model">model</code></td>
<td>
<p>One of 'sq.diff', 'sq.sum', 'simple.sum', and 'product'. Defaults to 'sq.diff'. See details.</p>
</td></tr>
<tr><td><code id="taxapair.vcv_+3A_regularize">regularize</code></td>
<td>
<p>Logical indicating whether regularization should be used if resulting matrix is numerically singular; defaults to FALSE. If TRUE, regularization is conducted by adding a small value to the diagonal of the matrix. By default, this value is equal to 1% of the median value on the diagonal, which is continually added until matrix is no longer numerically singular.</p>
</td></tr>
<tr><td><code id="taxapair.vcv_+3A_regparam">regparam</code></td>
<td>
<p>Custom regularization parameter. Instead of adding the default 1% of the median diagonal value to the diagonal, it will add regparam * that median value. IMPORTANT: it only does this once and does not continue adding the number until the matrix is non-singular. For 2%, write 0.02; for 10%, write 0.10, and so on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just as the traits of different species are not independent due to varying
amounts of shared evolutionary history, so too are pairwise-defined traits like
'strength of RI' and 'range overlap' not independent among related taxonomic pairs.
The function <code>taxapair.vcv()</code> calculates the expected covariance structure for
lineage-pair datasets given the taxa in each pair and a phylogenetic tree
(containing the taxa that appear in the dataset). The exact structure of this
covariance depends on the underlying model by which phylogenetic signal among
taxa is expected to translate into non-independence among taxonomic pairs
(Anderson et al. <em>in review</em>).
</p>
<p>Let X be some underlying continuous biological character (or set of characters)
that is defined for each taxon and that has phylogenetic signal. Users can choose
one of four models by which signal in X generates covariance among pairs in a
lineage-pair trait:
</p>

<ol>
<li><p> sq.diff (default) &ndash; the lineage-pair trait is influenced by the absolute
difference between the two taxa in X.
</p>
</li>
<li><p> sq.sum &ndash; the lineage-pair trait is linearly by the squared sum of
the value of X in each taxon.
</p>
</li>
<li><p> simple.sum &ndash; the lineage-pair trait is influenced by the sum of the
the value of X in each taxon. IMPORTANT: this model tends to result in
a singular matrix.
</p>
</li>
<li><p> product &ndash; the lineage-pair trait is influenced by the product of the
the value of X in each taxon.
</p>
</li></ol>

<p>In each case, it is assumed that there is a linear relationship between
the value calculated in each model and the response variable.
</p>


<h3>Value</h3>

<p>A lineage-pair covariance matrix.
</p>


<h3>References</h3>

<p>Anderson, S. A. S., et al. <em>In review</em>. The comparative analysis of lineage-pair data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
# Load simulated dataset and tree
data(data1)
data(sim.tree1)
# Calculate the lineage-pair covariance matrix
linpair.mat = taxapair.vcv(sp.pairs=data1[,1:2], tree=sim.tree1)
dim(linpair.mat)
# Check the validity of the matrix
covmat.check(linpair.mat)
</code></pre>

<hr>
<h2 id='twoterm.plmm.mats'>twoterm.plmm.mats</h2><span id='topic+twoterm.plmm.mats'></span>

<h3>Description</h3>

<p>Calculates the four matrices required for fitting the two-term plmm model
of Castillo (2007). See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoterm.plmm.mats(sp.pairs, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoterm.plmm.mats_+3A_sp.pairs">sp.pairs</code></td>
<td>
<p>A table (matrix or data.frame) in which the first column contains the names of 'species 1' and the second column contains the names of 'species 2'. Names must be in the same format used in the phylogenetic tree.</p>
</td></tr>
<tr><td><code id="twoterm.plmm.mats_+3A_tree">tree</code></td>
<td>
<p>An ultrametric phylogenetic tree ('phylo' object) describing the relationships among the species that appear in the dataset (as either a species 1 or species 2 or both).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Castillo (2007) introduced a framework for analyzing lineage-pair data via an
extension of a phylogenetic linear mixed model (plmm) in which there are two
random-effect terms, one for the 'species 1' and another for the 'species 2' in
every pair. The model is <code>Y = Xb + Z1u1 + Z1u2 + epsilon</code>, where b is the vector of
coefficients, X is a design matrix, u1 and u2 are vectors of species-specific random
effects that covary according to a phylogenetic covariance matrix C (<code>u1 ~ N(0,C)</code>
and <code>u2 ~ N(0,C)</code>), Z1 and Z2 are design matrices that map the species-specific
effects to the correct species in each pair, and epsilon is residual error (<code>epsilon~N(0,C)</code>).
The C matrix in the model is scaled by parameters that do not come into play here.
</p>
<p>This function takes a table containng columsn for species 1 and species 2 for every
pair and a  phylogenetic tree and returns the matrices Z1 and Z2 as well as pruned
phylogenetic covariance matrices for  u1 and u2. This pruning is sometimes required
because not all species found in the  dataset will appear as both 'species 1' and
'species 2'. Z1 and Z2 will therefore have different sizes and u1 and u2 require
different covariance matrices. Note that the matrices themselves are pruned, not
the tree from which they are derived, as the latter could result in the covariance
between two species being different for the 'species 1' and 'species 2' random effects.
</p>


<h3>Value</h3>

<p>A list of four matrices: Z1, Z2, cov1, and cov2, where the latter two describe the covariance among the random effects in u1 and u2.
</p>


<h3>References</h3>

<p>Castillo, D. M. (2007). Factors contributing to the accumulation of reproductive isolation: A mixed model approach. Ecology and Evolution 7:5808-5820. doi.org/10.1002/ece3.3093
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a tree
lin.tree = phytools::pbtree(n=20)
# Generate lineage pairs as the pairwise combinations of species in the tree
lin.pairs = data.frame(t(combn(lin.tree$tip.label,2))); colnames(lin.pairs)=c("sp1", "sp2")
# Calculate the matrices
mats = twoterm.plmm.mats(sp.pairs=lin.pairs, tree=lin.tree)
# Check structure of design matrices
sapply(mats, dim)
head(mats$Z1[,1:5])
head(mats$Z2[,1:5])
head(mats$cov2[,1:5])
head(mats$cov2[,1:5])
# Ensure covariance matrices are valid covariance matrices
sapply(mats[3:4], covmat.check)
</code></pre>

<hr>
<h2 id='twoterm.plmm.stan'>twoterm.plmm.stan</h2><span id='topic+twoterm.plmm.stan'></span>

<h3>Description</h3>

<p>Fits the two-term plmm model of Castillo (2007) in a Bayesian
framework. Bayesian sampling is conducted in the Stan software via the 'rstan'
package. Users supply vectors of observations and an ultrametric phylogenetic tree.
Users can alter parameters for model-parameter prior distributions and Bayesian sampling
settings. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoterm.plmm.stan(des, y, sp1s, sp2s, tree, 
  iter=2000, chains=4, coef.u=0, coef.sd=10, physig2.u=-1, 
  physig2.sd=1, randsig2.loc=0, randsig2.sc=2.5, cores=4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoterm.plmm.stan_+3A_des">des</code></td>
<td>
<p>A vector of predictor variable observations OR, in the case of multiple predictors, a matrix in which each column is a vector of observations of a given predictor. Function will add a column of 1s to make this a design matrix whose first column corresponds to the model intercept (unless such a column already exists).</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_y">y</code></td>
<td>
<p>A vector of response variable observations.</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_sp1s">sp1s</code></td>
<td>
<p>Character vector naming the &quot;species 1&quot; of every pair. IMPORTANT: name formatting must match that used in the tip.label of the tree</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_sp2s">sp2s</code></td>
<td>
<p>Character vector naming the &quot;species 2&quot; of every pair. IMPORTANT: name formatting must match that used in the tip.label of the tree</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_tree">tree</code></td>
<td>
<p>Phylogenetic tree (a 'phylo' object) for the species included in the analysis (regardless of whether they are species 1 or 2).</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_iter">iter</code></td>
<td>
<p>Number of iterations to run on each chain; defaults to 2000 (more are often necessary).</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains to run; defaults to 4.</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_coef.u">coef.u</code></td>
<td>
<p>Mean of the Gaussian prior for each preditor variable coefficient; defaults to 0.</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_coef.sd">coef.sd</code></td>
<td>
<p>SD of the Gaussian prior for each preditor variable coefficient; defaults to 10.</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_physig2.u">physig2.u</code></td>
<td>
<p>Mean of the prior distribution (lognormal) for the scale of the phylogenetic component of residual covariance; defaults to -1.</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_physig2.sd">physig2.sd</code></td>
<td>
<p>SD of the prior distribution (lognormal) for the scale of the phylogenetic component of residual covariance; defaults to 1.</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_randsig2.loc">randsig2.loc</code></td>
<td>
<p>Location parameter of the prior distribution (cauchy) for the scale of the independent component of residual covariance ; defaults to 0.</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_randsig2.sc">randsig2.sc</code></td>
<td>
<p>Scale parameter of the prior distribution (cauchy) for the scale of the independent component of residual covariance ; defaults to 2.5.</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use.</p>
</td></tr>
<tr><td><code id="twoterm.plmm.stan_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>rstan::sampling</code>, including control parmeters (see rstan::sampling documentation)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model introduced by Castillo (2007) for analyzing lineage-pair data is a
version of a phylogenetic linear mixed model (plmm) in which there are two
random-effect terms, one for the 'species 1' and another for the 'species 2' in
every pair. The model is <code>Y = Xb + Z1u1 + Z1u2 + epsilon</code>, where u1 and u2 are
vectors of species-specific random effects that covary according to a phylogenetic
covariance matrix C. In this model, <code>u1 ~ N(0,physig2*C)</code>, <code>u2 ~ N(0,physig2*C)</code>, and
<code>epsilon~N(0, randsig2*I)</code>, where randsig2 is the scaling parameter for identity
matrix I and physig2 is the scaling parameter for phylogenetic covariance
matrix C. See <code>twoterm_plmm_mats</code> for details on calculating
the Z1 and Z2 matrices.
</p>
<p><strong>Prior Distributions for Model Parameters</strong>:
The underlying stan models assume the following prior distributions for model parameters
</p>

<ol>
<li><p> Regression coefficients: Gaussian prior (users can set prior mean and sd)
</p>
</li>
<li> <p><code>physig2</code>: lognormal prior (users can set prior mean and sd)
</p>
</li>
<li> <p><code>randsig2</code>: cauchy prior (users can set location and scale parameters of prior)
</p>
</li></ol>



<h3>Value</h3>

<p>A list containing two elements: (1) the posterior distribution of model parameters, and (2) the log-likelihood of the posteriors for use in downstream analyses (e.g. the calculation of model fitting metrics like loo or waic)
</p>


<h3>References</h3>

<p>Castillo, D. M. (2007). Factors contributing to the accumulation of reproductive isolation: A mixed model approach. Ecology and Evolution 7:5808-5820. doi.org/10.1002/ece3.3093
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load a dataset simulated with a non-independent response observations
data(data3)
# Also load the simulated tree that was used to generate those pairs
data(sim.tree1)
# Fit an OLS model
result1 = linreg.stan(des=data3[,3], y=data3[,4], cores=2)
# Fit the twoterm.plmm.stan model
result2 = twoterm.plmm.stan(des=data3[,3], y=data3[,4], sp1s=data3[,1], 
  sp2s=data3[,2], tree=sim.tree1, cores=2)
# Compare posterior parameter estimates
result1[[1]]
result2[[1]]
# Compare the fit of the two models via loo and waic
loo1 = loo::loo(result1[[2]])
loo2 = loo::loo(result2[[2]])
waic1 = loo::waic(result1[[2]])
waic2 = loo::waic(result2[[2]])
loo1
loo2
waic1
waic2
loo::loo_compare(loo1, loo2)
loo::loo_compare(waic1, waic2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
