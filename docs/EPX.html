<!DOCTYPE html><html><head><title>Help for package EPX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EPX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AHR'><p>Calculate AHR (or expected AHR)</p></a></li>
<li><a href='#BNhold'><p>AID348 hold-out data using Burden Numbers for testing the EPX package</p></a></li>
<li><a href='#BNsample'><p>AID348 sample (training) data with Burden Numbers for testing the EPX package</p></a></li>
<li><a href='#cv.epx'><p>Balanced K-fold cross-validation for an &quot;<code>epx</code>&quot; object</p></a></li>
<li><a href='#epx'><p>Fitting an Ensemble of Phalanxes</p></a></li>
<li><a href='#harvest'><p>Simulated dataset for testing the EPX package</p></a></li>
<li><a href='#hit.curve'><p>Plot hit curve</p></a></li>
<li><a href='#IE'><p>Calculate Initial Enhancement</p></a></li>
<li><a href='#plot.epx'><p>Plot hit curve for an &quot;<code>epx</code>&quot; object</p></a></li>
<li><a href='#predict.epx'><p>Predict with an &quot;<code>epx</code>&quot; object</p></a></li>
<li><a href='#RKL'><p>Calculate rank last</p></a></li>
<li><a href='#summary.epx'><p>Summarising an &quot;<code>epx</code>&quot; object</p></a></li>
<li><a href='#TOP1'><p>Calculate TOP1</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ensemble of Phalanxes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jabed Tomal &lt;jtomal@tru.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An ensemble method for the statistical detection of
    a rare class in two-class classification problems. The method uses an
    ensemble of classifiers where the constituent
    models of the ensemble use disjoint subsets (phalanxes) of explanatory
    variables. We provide an implementation of the phalanx-formation algorithm.
    Please see Tomal et al. (2015) &lt;<a href="https://doi.org/10.1214%2F14-AOAS778">doi:10.1214/14-AOAS778</a>&gt;,
    Tomal et al. (2016) &lt;<a href="https://doi.org/10.1021%2Facs.jcim.5b00663">doi:10.1021/acs.jcim.5b00663</a>&gt;, and
    Tomal et al. (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1706.06971">doi:10.48550/arXiv.1706.06971</a>&gt; for more details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), foreach, randomForest, doRNG</td>
</tr>
<tr>
<td>Imports:</td>
<td>nnet, doParallel, rngtools</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-06 21:03:08 UTC; jtomal</td>
</tr>
<tr>
<td>Author:</td>
<td>Jabed Tomal [aut, cre],
  Grace Hsu [aut],
  William Welch [aut],
  Marcia Wang [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-06 21:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='AHR'>Calculate AHR (or expected AHR)</h2><span id='topic+AHR'></span>

<h3>Description</h3>

<p>Calculates average hitrate (AHR), which is equivalent to average precision.
When there are ties in ranking (not all values in phat are unique), the
result is the expection of AHR. The algorithm that produces this analytic
result assumes that the items in any tied group are in an arbitrary order
within the group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AHR(y, phat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AHR_+3A_y">y</code></td>
<td>
<p>True (binary) response vector where 1 is the rare/relevant class.</p>
</td></tr>
<tr><td><code id="AHR_+3A_phat">phat</code></td>
<td>
<p>Numeric vector of estimated probabilities of relevance.</p>
</td></tr>
<tr><td><code id="AHR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implementation adapted from Wang (2005, Chapter 3). Please also see Chapter 3
of Wang (2005) for AHR and expected AHR formulas.
</p>


<h3>Value</h3>

<p>Numeric value of average hitrate; expected average hitrate when there
are ties.
</p>


<h3>References</h3>

<p>Wang, M. (2005).
<em>Statistical Methods for High Throughput Screening Drug Discovery Data</em>
(Doctoral thesis).
University of Waterloo, Waterloo, Ontario, Canada.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## AHR when there are no ties in phat:
resp &lt;- c(1, 0, 0, 0, 1)
prob &lt;- (1:5)*0.1
AHR(y = resp, phat = prob)
# expect answer: 1/2 * (1 + 0 + 0 + 0 + 2/5)

## (Expected) AHR when there are ties in phat:
resp &lt;- c(1, 1, 0,   0,   0,   0,   0,    1,   0, 0)
prob &lt;- c(1, 1, 1, 0.4, 0.4, 0.3, 0.2, 0.15, 0.1, 0)
AHR(y = resp, phat = prob)
# expect answer: 1/3 * (2/3 + 1/2 * (1/3 + 2/3) + 1/3 * 4/3 +
#                       1/8 * (2/3 + 2/3 + 2/3 + 1))

</code></pre>

<hr>
<h2 id='BNhold'>AID348 hold-out data using Burden Numbers for testing the EPX package</h2><span id='topic+BNhold'></span>

<h3>Description</h3>

<p>AID348 hold-out data with 24 burden numbers as explanatory variables.
Demonstrates in a timely manner <code><a href="#topic+epx">epx</a></code>, the phalanx-formation
algorithm in <span class="pkg">EPX</span> and associated functions <code><a href="#topic+summary.epx">summary.epx</a></code>,
<code><a href="#topic+predict.epx">predict.epx</a></code> , <code><a href="#topic+plot.epx">plot.epx</a></code>, <code><a href="#topic+hit.curve">hit.curve</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BNhold
</code></pre>


<h3>Format</h3>

<p>A dataframe with 3946 rows and 25 variables:
</p>

<dl>
<dt>WBN</dt><dd><p>Burden numbers descriptor set with 24 variables.</p>
</dd>
<dt>y</dt><dd><p>The response variable where 1 denotes active and 0 inactive.</p>
</dd>
</dl>



<h3>References</h3>

<p>Tomal, J. H., Welch, W. J., &amp; Zamar, R. H. (2015).
Ensembling classification models based on phalanxes of variables with
applications in drug discovery.
<em>The Annals of Applied Statistics</em>,
<em>9</em>(1), 69-93.
doi: <a href="https://doi.org/10.1214/14-AOAS778">10.1214/14-AOAS778</a>
</p>

<hr>
<h2 id='BNsample'>AID348 sample (training) data with Burden Numbers for testing the EPX package</h2><span id='topic+BNsample'></span>

<h3>Description</h3>

<p>AID348 sample (training) dataset with 24 burden numbers as explanatory variables.
Demonstrates in a timely manner <code><a href="#topic+epx">epx</a></code>, the phalanx-formation
algorithm in <span class="pkg">EPX</span> and associated functions <code><a href="#topic+summary.epx">summary.epx</a></code>,
<code><a href="#topic+predict.epx">predict.epx</a></code> , <code><a href="#topic+plot.epx">plot.epx</a></code>, <code><a href="#topic+cv.epx">cv.epx</a></code>,
<code><a href="#topic+hit.curve">hit.curve</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BNsample
</code></pre>


<h3>Format</h3>

<p>A dataframe with 1000 rows and 25 variables:
</p>

<dl>
<dt>WBN</dt><dd><p>Burden numbers descriptor set with 24 variables.</p>
</dd>
<dt>y</dt><dd><p>The response variable where 1 denotes active and 0 inactive.</p>
</dd>
</dl>



<h3>References</h3>

<p>Tomal, J. H., Welch, W. J., &amp; Zamar, R. H. (2015).
Ensembling classification models based on phalanxes of variables with
applications in drug discovery.
<em>The Annals of Applied Statistics</em>,
<em>9</em>(1), 69-93.
doi: <a href="https://doi.org/10.1214/14-AOAS778">10.1214/14-AOAS778</a>
</p>

<hr>
<h2 id='cv.epx'>Balanced K-fold cross-validation for an &quot;<code>epx</code>&quot; object</h2><span id='topic+cv.epx'></span>

<h3>Description</h3>

<p>Balanced K-fold cross-validation based on an &quot;<code><a href="#topic+epx">epx</a></code>&quot; object.
Hence, we have biased cross-validation as we do not re-run the
phalanx-formation algorithm for each fold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.epx(
  epx,
  folds = NULL,
  K = 10,
  folds.out = FALSE,
  classifier.args = list(),
  performance.args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.epx_+3A_epx">epx</code></td>
<td>
<p>Object of class &quot;<code><a href="#topic+epx">epx</a></code>&quot;.</p>
</td></tr>
<tr><td><code id="cv.epx_+3A_folds">folds</code></td>
<td>
<p>Optional vector specifying to which fold each observation belongs. Must be an <code class="reqn">n</code>-length vector (<code class="reqn">n</code> being the number of
observations) with integer values only in the range from 1 to <code class="reqn">K</code>.</p>
</td></tr>
<tr><td><code id="cv.epx_+3A_k">K</code></td>
<td>
<p>Number of folds; default is 10.</p>
</td></tr>
<tr><td><code id="cv.epx_+3A_folds.out">folds.out</code></td>
<td>
<p>Indicates whether a vector indicating fold membership for
each of the observations will be output; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cv.epx_+3A_classifier.args">classifier.args</code></td>
<td>
<p>Arguments for the base classifier specified by
<code>epx</code>; default is that used in <code>epx</code> formation.</p>
</td></tr>
<tr><td><code id="cv.epx_+3A_performance.args">performance.args</code></td>
<td>
<p>Arguments for the performance measure specified by
<code>epx</code>; default is that used in <code>epx</code> formation.</p>
</td></tr>
<tr><td><code id="cv.epx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">(n + 1)</code> by <code class="reqn">(p + 1)</code> matrix, where <code class="reqn">n</code> is the number
of observations used to train <code>epx</code> and <code class="reqn">p</code> is the number of
(final) phalanxes. Column <code class="reqn">p + 1</code> of the matrix contains the predicted
probabilities of relevance from the ensemble of phalanxes,
and row <code class="reqn">n + 1</code> is the performance (choice of performance measure determined by the
&quot;<code><a href="#topic+epx">epx</a></code>&quot; object) of the corresponding column.
</p>
<p>Setting <code>folds.out</code> as <code>TRUE</code> changes the output of
<code>cv.epx</code> into a list of two elements:
</p>
<table>
<tr><td><code>EPX.CV</code></td>
<td>
<p>The <code class="reqn">(n + 1)</code> by <code class="reqn">(p + 1)</code> matrix returned by
default when <code>folds.out = FALSE</code>.</p>
</td></tr>
<tr><td><code>FOLDS.USED</code></td>
<td>
<p>A vector of length <code class="reqn">n</code> with integer values only
in the range from 1 to <code>K</code> indicating to which fold
each observation was randomly assigned for cross-validation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example with data(harvest)

## Phalanx-formation using a base classifier with 50 trees (default = 500)
 
set.seed(761)
model &lt;- epx(x = harvest[, -4], y = harvest[, 4],
            classifier.args = list(ntree = 50))

## 10-fold balanced cross-validation (different base classifier settings)
## Not run: 
set.seed(761)
cv.100 &lt;- cv.epx(model, classifier.args = list(ntree = 100))
tail(cv.100) # see performance (here, AHR) for all phalanxes and the ensemble


## Option to output the vector assigning observations to the K folds
## (Commented out for speed.)
set.seed(761)
cv.folds &lt;- cv.epx(model, folds.out = TRUE)
tail(cv.folds[[1]])  # same as first example
table(cv.folds[[2]])  # number of observations in each of the 10 folds

## 10 runs of 10-fold balanced cross-validation (using default settings)
set.seed(761)
cv.ahr &lt;- NULL  # store AHR of each ensemble
for (i in 1:10) {
  cv.i &lt;- cv.epx(model)
  cv.ahr &lt;- c(cv.ahr, cv.i[nrow(cv.i), ncol(cv.i)])
}
boxplot(cv.ahr)  # to see variation in AHR

## End(Not run)

</code></pre>

<hr>
<h2 id='epx'>Fitting an Ensemble of Phalanxes</h2><span id='topic+epx'></span>

<h3>Description</h3>

<p><code>epx</code> forms phalanxes of variables from training data for
binary classification with a rare class. The phalanxes are
disjoint subsets of variables, each of which is fit with a base classifier.
Together they form an ensemble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epx(
  x,
  y,
  phalanxes.initial = c(1:ncol(x)),
  alpha = 0.95,
  nsim = 1000,
  rmin.target = 1,
  classifier = "random forest",
  classifier.args = list(),
  performance = "AHR",
  performance.args = list(),
  computing = "sequential",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epx_+3A_x">x</code></td>
<td>
<p>Explanatory variables (predictors, features) contained in a data frame.</p>
</td></tr>
<tr><td><code id="epx_+3A_y">y</code></td>
<td>
<p>Binary response variable vector (numeric or integer):
1 for the rare class, 0 for the majority class.</p>
</td></tr>
<tr><td><code id="epx_+3A_phalanxes.initial">phalanxes.initial</code></td>
<td>
<p>Initial variable group indices; default one group
per variable. Example: vector c(1, 1, 2, 2, 3, ...) puts variables 1 and 2
in group 1, variables 3 and 4 in group, 2, etc.  Indices cannot
be skipped, e.g., c( 1, 3, 3, 4, 4, 3, 1) skips group 2 and is invalid.</p>
</td></tr>
<tr><td><code id="epx_+3A_alpha">alpha</code></td>
<td>
<p>Lower-tail probability for the critical quantile of the reference
distribution of the <code>performance</code> measure for a classifier that ranks
at random (i.e., the predictors have no explanatory power); default is 0.95.</p>
</td></tr>
<tr><td><code id="epx_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations for the reference empirical distribution of
the performance measure; default is 1000.</p>
</td></tr>
<tr><td><code id="epx_+3A_rmin.target">rmin.target</code></td>
<td>
<p>To merge the pair of groups with the
minimum ratio of performance measures (ensemble of models to single model)
into a single group their ratio must be less than
<code>rmin.target</code>, otherwise merging stops; default is 1.</p>
</td></tr>
<tr><td><code id="epx_+3A_classifier">classifier</code></td>
<td>
<p>Base classifier, one of
<code>c("random forest", "logistic regression", "neural network")</code>;
default is &quot;random forest&quot;, which uses
<code><a href="randomForest.html#topic+randomForest">randomForest</a></code>.</p>
</td></tr>
<tr><td><code id="epx_+3A_classifier.args">classifier.args</code></td>
<td>
<p>Arguments for the base <code>classifier</code>
specified in a list as follows: <code>list(argName1 = value1, argName2 =
  value2, ...)</code>. If the list is empty, the classifier will use
its defaults.  For &quot;random forest&quot;, user may specify <code>replace, cutoff,
  nodesize, maxnodes</code>. For &quot;logistic regression&quot; there are no options. For
&quot;neural network&quot;, user may specify <code>size, trace</code>.</p>
</td></tr>
<tr><td><code id="epx_+3A_performance">performance</code></td>
<td>
<p>Performance assessment metric, one of
<code>c("<a href="#topic+AHR">AHR</a>", "<a href="#topic+IE">IE</a>", "<a href="#topic+TOP1">TOP1</a>", "<a href="#topic+RKL">RKL</a>")</code>;
default is <code><a href="#topic+AHR">AHR</a></code>.</p>
</td></tr>
<tr><td><code id="epx_+3A_performance.args">performance.args</code></td>
<td>
<p>Arguments for the <code>performance</code> measure
specified in a list as follows:
<code>list(argName1 = value1, argName2 = value2, ...)</code>.
If the list is empty, the performance measure will use its
defaults. Currently,  only <code><a href="#topic+IE">IE</a></code> takes an argument list,
and its only argument is <code>cutoff</code>.</p>
</td></tr>
<tr><td><code id="epx_+3A_computing">computing</code></td>
<td>
<p>Whether to compute sequentially or in parallel. Input is one
of <code>c("sequential", "parallel")</code>; default is &quot;sequential&quot;.</p>
</td></tr>
<tr><td><code id="epx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see Tomal et al. (2015) for more description of phalanx formation.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>epx</code>, which is
a list containing the following components:
</p>
<table>
<tr><td><code>PHALANXES</code></td>
<td>
<p>List of four vectors, each the same length as the number of
explanatory variables (columns in <code>x</code>): <code>phalanxes.initial</code>,
<code>phalanxes.filtered</code>, <code>phalanxes.merged</code>, <code>phalanxes.final</code>.
Each vector contains the phalanx membership indices of all explanatory variables
at one of the four stages of phalanx-formation. Element <code class="reqn">i</code> of a vector
is the index of the phalanx to which variable <code class="reqn">i</code> belongs. Phalanx 0 does
not exist and so membership in phalanx 0 indicates that the variable does not
belong to any phalanx; it has been screened out.</p>
</td></tr>
<tr><td><code>PHALANXES.FINAL.PERFORMANCE</code></td>
<td>
<p>Vector of <code>performance</code> measures of
the final phalanxes: the first element is for phalanx 1, etc.</p>
</td></tr>
<tr><td><code>PHALANXES.FINAL.FITS</code></td>
<td>
<p>A matrix with number of rows equal to the number
of observations in the training data and number of columns equal to the
number of final phalanxes.  Column <code class="reqn">i</code> contains the predicted
probabilities of class 1 from fitting the base <code>classifier</code> to the
variables in phalanx <code class="reqn">i</code>.</p>
</td></tr>
<tr><td><code>ENSEMBLED.FITS</code></td>
<td>
<p>The predicted probabilities of class 1 from the
ensemble of phalanxes based on <code>phalanxes.final</code>.</p>
</td></tr>
<tr><td><code>BASE.CLASSIFIER.ARGS</code></td>
<td>
<p>(Parsed) record of user-specified arguments for
<code>classifier</code>.</p>
</td></tr>
<tr><td><code>PERFORMANCE.ARGS</code></td>
<td>
<p>(Parsed) record of user-specified arguments for
<code>performance</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>User-provided data frame of explanatory variables.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>User-provided binary response vector.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tomal, J. H., Welch, W. J., &amp; Zamar, R. H. (2015).
Ensembling classification models based on phalanxes of variables with
applications in drug discovery.
<em>The Annals of Applied Statistics</em>,
<em>9</em>(1), 69-93.
doi: <a href="https://doi.org/10.1214/14-AOAS778">10.1214/14-AOAS778</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.epx">summary.epx</a></code> prints a summary of the results,
and <code><a href="#topic+cv.epx">cv.epx</a></code> assesses performance via cross-validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with data(harvest)

## Phalanx-formation using a base classifier with 50 trees (default = 500)

set.seed(761)
model &lt;- epx(x = harvest[, -4], y = harvest[, 4],
             classifier.args = list(ntree = 50))

## Phalanx-membership of explanatory variables at the four stages
## of phalanx formation (0 means not in a phalanx)
model$PHALANXES

## Summary of the final phalanxes (matches above)
summary(model)
## Not run: 
## Parallel computing
clusters &lt;- parallel::detectCores()
cl &lt;- parallel::makeCluster(clusters)
doParallel::registerDoParallel(cl)
set.seed(761)
model.par &lt;- epx(x = harvest[, -4], y = harvest[, 4],
                 computing = "parallel")
parallel::stopCluster(cl)

## End(Not run)

</code></pre>

<hr>
<h2 id='harvest'>Simulated dataset for testing the EPX package</h2><span id='topic+harvest'></span>

<h3>Description</h3>

<p>A simulated dataset from Yuan et al. (2012) with three explanatory variables.
Demonstrates in a timely manner <code><a href="#topic+epx">epx</a></code>, the phalanx-formation
algorithm in <span class="pkg">EPX</span> and associated functions <code><a href="#topic+summary.epx">summary.epx</a></code>,
<code><a href="#topic+predict.epx">predict.epx</a></code> , <code><a href="#topic+plot.epx">plot.epx</a></code>, <code><a href="#topic+cv.epx">cv.epx</a></code>,
<code><a href="#topic+hit.curve">hit.curve</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harvest
</code></pre>


<h3>Format</h3>

<p>A dataframe with 190 rows and 4 variables:
</p>

<dl>
<dt>LogP</dt><dd><p>Octanol/water partition coefficient (-2 to 7).</p>
</dd>
<dt>MeltPt</dt><dd><p>Melting point (120 to 280 degrees Celsius).</p>
</dd>
<dt>MolWt</dt><dd><p>Molecular weight (200 to 800).</p>
</dd>
<dt>y</dt><dd><p>The response variable where 1 denotes active and 0 inactive.</p>
</dd>
</dl>



<h3>References</h3>

<p>Yuan, Y., Chipman, H. A., &amp; Welch, W. J. (2012).
Harvesting Classification Trees for Drug Discovery.
<em>Journal of Chemical Information and Modeling</em>,
<em>52</em>(12), 3169-3180.
doi: <a href="https://doi.org/10.1021/ci3000216">10.1021/ci3000216</a>
</p>

<hr>
<h2 id='hit.curve'>Plot hit curve</h2><span id='topic+hit.curve'></span>

<h3>Description</h3>

<p>Plots the hit curve corresponding to <code>phat</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hit.curve(y, phat, max.cutoff = min(100, length(y)), plot.hc = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hit.curve_+3A_y">y</code></td>
<td>
<p>True binary response vector where 1 denotes the relevant rare class.</p>
</td></tr>
<tr><td><code id="hit.curve_+3A_phat">phat</code></td>
<td>
<p>Vector of estimated probabilities of relevance.</p>
</td></tr>
<tr><td><code id="hit.curve_+3A_max.cutoff">max.cutoff</code></td>
<td>
<p>Maximum number of observations selected, equivalently the
maximum shortlist cutoff; default is <code>min(100, length(y))</code>.</p>
</td></tr>
<tr><td><code id="hit.curve_+3A_plot.hc">plot.hc</code></td>
<td>
<p>Whether to return a plot of the hit curve; default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hit.curve_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Order the cases by decreasing <code>phat</code> (predicted probabilities of
relevance) values, and plot the expected number and actual number of hits as
cases are selected. Cases with tied <code>phat</code> values are grouped together.
See <a href="#topic+plot.epx">plot.epx</a> for plotting the hit curve for an &quot;<code><a href="#topic+epx">epx</a></code>&quot;
object.
</p>


<h3>Value</h3>

<p>Plot of the hit curve (if <code>plot.hc = TRUE</code>) and a list with the
following vectors:
</p>
<table>
<tr><td><code>select</code></td>
<td>
<p>Number of observations in each tied <code>phat</code> group;
<code>select[1]</code>, <code>select[2]</code>, <code>...</code> are the numbers of
observations with the largest predicted probability of relevance
(<code>max(phat)</code>), the second largest value in <code>phat</code>, etc.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Unique <code>phat</code> values; <code>p[1]</code>, <code>p[2]</code>, <code>...</code> are
the largest value in <code>phat</code>, the second largest value in <code>phat</code>,
etc.</p>
</td></tr>
<tr><td><code>nhits</code></td>
<td>
<p>Number of hits (truly relevant observations) in each tied
<code>phat</code> group.</p>
</td></tr>
<tr><td><code>nhitlast</code></td>
<td>
<p>Number of hits after <code>max.cutoff</code> observations
selected.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example with data(harvest)

## Phalanx-formation using a base classifier with 50 trees (default = 500)

set.seed(761)
model &lt;- epx(x = harvest[, -4], y = harvest[, 4],
             classifier.args = list(ntree = 50))

## Plot hit curve for cross-validated predicted probabilities of relevence
set.seed(761)
model.cv &lt;- cv.epx(model)
preds.cv &lt;- model.cv[-nrow(model.cv), ncol(model.cv)]
cv.hc &lt;- hit.curve(phat = as.numeric(preds.cv), y = model$Y)

</code></pre>

<hr>
<h2 id='IE'>Calculate Initial Enhancement</h2><span id='topic+IE'></span>

<h3>Description</h3>

<p>Calculates initial enhancement (IE), which is the precision at one specific
shortlist length (cutoff) normalised by the proportion of relevants in the
total sample size (Tomal et al. 2015). Since IE is a rescaling of
precision, we expect IE and AHR to lead to similar conclusions as an
assessment metric for the EPX algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IE(y, phat, cutoff = length(y)/2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IE_+3A_y">y</code></td>
<td>
<p>True (binary) response vector where 1 is the rare/relevant class.</p>
</td></tr>
<tr><td><code id="IE_+3A_phat">phat</code></td>
<td>
<p>Numeric vector of estimated probabilities of relevance.</p>
</td></tr>
<tr><td><code id="IE_+3A_cutoff">cutoff</code></td>
<td>
<p>Shortlist cutoff length, and so must not exceed length of
<code>y</code>; default is half the sample size.</p>
</td></tr>
<tr><td><code id="IE_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">c</code> be the cutoff and <code class="reqn">h(c)</code> be the hitrate at <code class="reqn">c</code>. Let also
<code class="reqn">A</code> be the total number of relevants and <code class="reqn">N</code> be the total number of
observations. IE is defined as </p>
<p style="text-align: center;"><code class="reqn">IE = h(c) / (A / N)</code>
</p>

<p>IE calculation does not change whether there are ties in <code>phat</code> or not.
</p>


<h3>Value</h3>

<p>Numeric value of IE.
</p>


<h3>References</h3>

<p>Tomal, J. H., Welch, W. J., &amp; Zamar, R. H. (2015).
Ensembling classification models based on phalanxes of variables with
applications in drug discovery.
<em>The Annals of Applied Statistics</em>,
<em>9</em>(1), 69-93.
doi: <a href="https://doi.org/10.1214/14-AOAS778">10.1214/14-AOAS778</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## IE when there are no ties in phat:

resp &lt;- c(1, 1, 0,   0,   0,   0,   0,    1,   0, 0)
prob &lt;- (10:1) * 0.1
IE(y = resp, phat = prob, cutoff = 3)
# expect answer: (2/3) / (3/10)

## IE when there are ties
resp &lt;- c(1, 1, 0,   0,   0,   0,   0,    1,   0, 0)
prob &lt;- c(1, 1, 1, 0.4, 0.4, 0.3, 0.2, 0.15, 0.1, 0)
IE(y = resp, phat = prob, cutoff = 3)

# expect answer: same as above
</code></pre>

<hr>
<h2 id='plot.epx'>Plot hit curve for an &quot;<code>epx</code>&quot; object</h2><span id='topic+plot.epx'></span>

<h3>Description</h3>

<p>Plots the hit curve for the fitted values of an &quot;<code><a href="#topic+epx">epx</a></code>&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epx'
plot(x, max.cutoff = min(100, length(x$Y)), plot.hc = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.epx_+3A_x">x</code></td>
<td>
<p>Object of class &quot;<code><a href="#topic+epx">epx</a></code>&quot;.</p>
</td></tr>
<tr><td><code id="plot.epx_+3A_max.cutoff">max.cutoff</code></td>
<td>
<p>Maximum number of observations selected, equivalently the
maximum shortlist cutoff; default is <code>min(100, length(x$Y))</code>.</p>
</td></tr>
<tr><td><code id="plot.epx_+3A_plot.hc">plot.hc</code></td>
<td>
<p>Whether to make a plot of the hit curve; default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.epx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Order the cases by decreasing <code>phat</code> (predicted probabilities of
relevance) values, and plot the expected number and actual number of hits as
cases are selected. Cases with tied <code>phat</code> values are grouped together.
See <a href="#topic+hit.curve">hit.curve</a> in order to plot a hit curve in general.
</p>


<h3>Value</h3>

<p>Plot of the hit curve (if <code>plot.hc = TRUE</code>) and a list with the
following vectors:
</p>
<table>
<tr><td><code>select</code></td>
<td>
<p>Number of observations in each tied <code>phat</code> group;
<code>select[1]</code>, <code>select[2]</code>, <code>...</code> are the numbers of
observations with the largest predicted probability of relevance
(<code>max(phat)</code>), the second largest value in <code>phat</code>, etc.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Unique <code>phat</code> values; <code>p[1]</code>, <code>p[2]</code>, <code>...</code> are
the largest value in <code>phat</code>, the second largest value in <code>phat</code>,
etc.</p>
</td></tr>
<tr><td><code>nhits</code></td>
<td>
<p>Number of hits (truly relevant observations) in each tied
<code>phat</code> group.</p>
</td></tr>
<tr><td><code>nhitlast</code></td>
<td>
<p>Number of hits after <code>max.cutoff</code> observations
selected.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example with data(harvest)

## Phalanx-formation using a base classifier with 50 trees (default = 500)

set.seed(761)
model &lt;- epx(x = harvest[, -4], y = harvest[, 4],
             classifier.args = list(ntree = 50))

## Hit curve for model with default settings
model.hc &lt;- plot(model)

## In the top 100 ranked observations selected, the number that are truly
## relevant is
model.hc$nhitlast

## Hit curve with max.cutoff at 150 (Note: Commented off for time.)
model.hc.150 &lt;- plot(model, max.cutoff = 150)
model.hc.150$nhitlast  # Number of hits in top 150 ranked observations.

</code></pre>

<hr>
<h2 id='predict.epx'>Predict with an &quot;<code>epx</code>&quot; object</h2><span id='topic+predict.epx'></span>

<h3>Description</h3>

<p>Predicted values based on an &quot;<code><a href="#topic+epx">epx</a></code>&quot; object; may specify
different base classifier arguments than those used for phalanx-formation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epx'
predict(object, newdata, classifier.args = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.epx_+3A_object">object</code></td>
<td>
<p>Object of class &quot;<code><a href="#topic+epx">epx</a></code>&quot;.</p>
</td></tr>
<tr><td><code id="predict.epx_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame specifiying variables with which to
predict; if omitted and <code>classifier.args</code> are not specified, the
fitted (ensembled) values are used.</p>
</td></tr>
<tr><td><code id="predict.epx_+3A_classifier.args">classifier.args</code></td>
<td>
<p>Additional arguments for the base classifier; same
base classifier as that used for phalanx-formation (specified in
<code><a href="#topic+epx">epx</a></code>).</p>
</td></tr>
<tr><td><code id="predict.epx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of predicted values (double).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with data(harvest)

## Phalanx-formation using a base classifier with 50 trees (default = 500)

set.seed(761)
model &lt;- epx(x = harvest[, -4], y = harvest[, 4],
             classifier.args = list(ntree = 50))

## Predict training values without additional classifier.args and newdata
## returns the object's ENSEMBLED.FITS
all.equal(predict(model), model$ENSEMBLED.FITS)

## Predict training values using 100 trees (default = 500)
set.seed(761)
preds100 &lt;- predict(model, classifier.args = list(ntree = 100))

## Predict test values by passing dataframe of test predictors to newdata as
## with the predict(model, newdata = . ) function etc.

</code></pre>

<hr>
<h2 id='RKL'>Calculate rank last</h2><span id='topic+RKL'></span>

<h3>Description</h3>

<p>The peformance measure rank last (RKL) is calculated as follows: after
ranking the observations in decreasing order via <code>phat</code>, RKL is the rank
of the last truly relevant observation. Hence, RKL can take on integer values
from 1 to <code class="reqn">n</code>, where <code class="reqn">n</code> is the total number of observations. If
there are ties, the last object in the tied group determines RKL. That is, if
all <code class="reqn">n</code> objects are tied at the first rank but only one object is truly
relevant, RKL will have a value of <code class="reqn">n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RKL(y, phat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RKL_+3A_y">y</code></td>
<td>
<p>True (binary) response vector where 1 is the rare/relevant class.</p>
</td></tr>
<tr><td><code id="RKL_+3A_phat">phat</code></td>
<td>
<p>Numeric vector of estimated probabilities of relevance.</p>
</td></tr>
<tr><td><code id="RKL_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value of RKL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## without ties in phat

resp &lt;- c(rep(1, 50), rep(0, 50))
prob &lt;- (1:100)*0.01
RKL(y = resp, phat = prob) # expect 100

resp &lt;- c(rep(0, 50), rep(1, 50))
RKL(y = resp, phat = prob) # expect 50

## with ties in phat
resp &lt;- sample(c(1, 0), 100, replace = TRUE)
prob &lt;- rep(1, 100)
RKL(y = resp, phat = prob) # expect 100

</code></pre>

<hr>
<h2 id='summary.epx'>Summarising an &quot;<code>epx</code>&quot; object</h2><span id='topic+summary.epx'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;<code><a href="#topic+epx">epx</a></code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epx'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.epx_+3A_object">object</code></td>
<td>
<p>Object of class &quot;<code>epx</code>&quot; returned by <code><a href="#topic+epx">epx</a></code>.</p>
</td></tr>
<tr><td><code id="summary.epx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary of the object returned by the phalanx-formation
algorithm <code><a href="#topic+epx">epx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with data(harvest)


## Phalanx-formation using a base classifier with 50 trees (default = 500)

set.seed(761)
model &lt;- epx(x = harvest[, -4], y = harvest[, 4],
            classifier.args = list(ntree = 50))
summary(model)

## The summary agrees with
(model$PHALANXES)[[4]]

</code></pre>

<hr>
<h2 id='TOP1'>Calculate TOP1</h2><span id='topic+TOP1'></span>

<h3>Description</h3>

<p>The performance measure TOP1 is calculated as follows: after sorting the
observations by their predicted probabilities of relevance (<code>phat</code>) in
decreasing order so the first ranked observation has the highest probability
of relevance, if the first ranked observation is truly relevant, TOP1 has a
value of 1. Otherwise TOP1 is 0. If there are ties for the first rank, all
the corresponding observations must be truly relevant for TOP1 to score 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOP1(y, phat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TOP1_+3A_y">y</code></td>
<td>
<p>True (binary) response vector where 1 is the rare/relevant class.</p>
</td></tr>
<tr><td><code id="TOP1_+3A_phat">phat</code></td>
<td>
<p>Numeric vector of estimated probabilities of relevance.</p>
</td></tr>
<tr><td><code id="TOP1_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value of TOP1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## with ties in phat

resp &lt;- c(0, rep(1, 99))
prob &lt;- rep(1, 100)
TOP1(y = resp, phat = prob)  # expect 0

resp &lt;- c(1, 1, 1, rep(0, 95), 1, 1)
prob &lt;- c(1, 1, 1, rep(0, 97))
TOP1(y = resp, phat = prob)  # expect 1

## no ties in phat
resp &lt;- c(0, rep(1, 99))
prob &lt;- (100:1)*0.01
TOP1(y = resp, phat = prob)  # expect 0

resp &lt;- c(1, rep(0, 99))
TOP1(y = resp, phat = prob)  # expect 1

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
