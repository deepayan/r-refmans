<!DOCTYPE html><html><head><title>Help for package rlang</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rlang}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abort'><p>Signal an error, warning, or message</p></a></li>
<li><a href='#are_na'><p>Test for missing values</p></a></li>
<li><a href='#arg_match'><p>Match an argument to a character vector</p></a></li>
<li><a href='#args_data_masking'><p>Argument type: data-masking</p></a></li>
<li><a href='#args_dots_empty'><p>Helper for consistent documentation of empty dots</p></a></li>
<li><a href='#args_dots_used'><p>Helper for consistent documentation of used dots</p></a></li>
<li><a href='#args_error_context'><p>Documentation anchor for error arguments</p></a></li>
<li><a href='#as_box'><p>Convert object to a box</p></a></li>
<li><a href='#as_closure'><p>Transform to a closure</p></a></li>
<li><a href='#as_data_mask'><p>Create a data mask</p></a></li>
<li><a href='#as_environment'><p>Coerce to an environment</p></a></li>
<li><a href='#as_function'><p>Convert to function</p></a></li>
<li><a href='#as_label'><p>Create a default name for an R object</p></a></li>
<li><a href='#as_name'><p>Extract names from symbols</p></a></li>
<li><a href='#as_string'><p>Cast symbol to string</p></a></li>
<li><a href='#as_utf8_character'><p>Coerce to a character vector and attempt encoding conversion</p></a></li>
<li><a href='#bare-type-predicates'><p>Bare type predicates</p></a></li>
<li><a href='#box'><p>Box a value</p></a></li>
<li><a href='#bytes-class'><p>Human readable memory sizes</p></a></li>
<li><a href='#call_args'><p>Extract arguments from a call</p></a></li>
<li><a href='#call_fn'><p>Extract function from a call</p></a></li>
<li><a href='#call_inspect'><p>Inspect a call</p></a></li>
<li><a href='#call_match'><p>Match supplied arguments to function definition</p></a></li>
<li><a href='#call_modify'><p>Modify the arguments of a call</p></a></li>
<li><a href='#call_name'><p>Extract function name or namespace of a call</p></a></li>
<li><a href='#call_standardise'><p>Standardise a call</p></a></li>
<li><a href='#call2'><p>Create a call</p></a></li>
<li><a href='#caller_arg'><p>Find the caller argument for error messages</p></a></li>
<li><a href='#catch_cnd'><p>Catch a condition</p></a></li>
<li><a href='#check_dots_empty'><p>Check that dots are empty</p></a></li>
<li><a href='#check_dots_empty0'><p>Check that dots are empty (low level variant)</p></a></li>
<li><a href='#check_dots_unnamed'><p>Check that all dots are unnamed</p></a></li>
<li><a href='#check_dots_used'><p>Check that all dots have been used</p></a></li>
<li><a href='#check_exclusive'><p>Check that arguments are mutually exclusive</p></a></li>
<li><a href='#check_required'><p>Check that argument is supplied</p></a></li>
<li><a href='#child_env'><p>Create a child environment</p></a></li>
<li><a href='#chr_unserialise_unicode'><p>Translate unicode points to UTF-8</p></a></li>
<li><a href='#cnd'><p>Create a condition object</p></a></li>
<li><a href='#cnd_inherits'><p>Does a condition or its ancestors inherit from a class?</p></a></li>
<li><a href='#cnd_message'><p>Build an error message from parts</p></a></li>
<li><a href='#cnd_muffle'><p>Muffle a condition</p></a></li>
<li><a href='#cnd_signal'><p>Signal a condition object</p></a></li>
<li><a href='#cnd_type'><p>What type is a condition?</p></a></li>
<li><a href='#defusing-advanced'><p>Advanced defusal operators</p></a></li>
<li><a href='#dev-notes-dots'><p>Development notes - <code>dots.R</code></p></a></li>
<li><a href='#done'><p>Box a final value for early termination</p></a></li>
<li><a href='#dot-data'><p><code>.data</code> and <code>.env</code> pronouns</p></a></li>
<li><a href='#dots_n'><p>How many arguments are currently forwarded in dots?</p></a></li>
<li><a href='#dots_splice'><p>Splice lists</p></a></li>
<li><a href='#dots_values'><p>Evaluate dots with preliminary splicing</p></a></li>
<li><a href='#duplicate'><p>Duplicate an R object</p></a></li>
<li><a href='#dyn-dots'><p>Dynamic dots features</p></a></li>
<li><a href='#embrace-operator'><p>Embrace operator <code style="white-space: pre;">&#8288;{{&#8288;</code></p></a></li>
<li><a href='#empty_env'><p>Get the empty environment</p></a></li>
<li><a href='#englue'><p>Defuse function arguments with glue</p></a></li>
<li><a href='#enquo'><p>Defuse function arguments</p></a></li>
<li><a href='#entrace'><p>Add backtrace from error handler</p></a></li>
<li><a href='#env'><p>Create a new environment</p></a></li>
<li><a href='#env_bind'><p>Bind symbols to objects in an environment</p></a></li>
<li><a href='#env_binding_are_active'><p>What kind of environment binding?</p></a></li>
<li><a href='#env_binding_lock'><p>Lock or unlock environment bindings</p></a></li>
<li><a href='#env_browse'><p>Browse environments</p></a></li>
<li><a href='#env_bury'><p>Mask bindings by defining symbols deeper in a scope</p></a></li>
<li><a href='#env_cache'><p>Cache a value in an environment</p></a></li>
<li><a href='#env_clone'><p>Clone or coalesce an environment</p></a></li>
<li><a href='#env_depth'><p>Depth of an environment chain</p></a></li>
<li><a href='#env_get'><p>Get an object in an environment</p></a></li>
<li><a href='#env_has'><p>Does an environment have or see bindings?</p></a></li>
<li><a href='#env_inherits'><p>Does environment inherit from another environment?</p></a></li>
<li><a href='#env_is_user_facing'><p>Is frame environment user facing?</p></a></li>
<li><a href='#env_lock'><p>Lock an environment</p></a></li>
<li><a href='#env_name'><p>Label of an environment</p></a></li>
<li><a href='#env_names'><p>Names and numbers of symbols bound in an environment</p></a></li>
<li><a href='#env_parent'><p>Get parent environments</p></a></li>
<li><a href='#env_poke'><p>Poke an object in an environment</p></a></li>
<li><a href='#env_print'><p>Pretty-print an environment</p></a></li>
<li><a href='#env_unbind'><p>Remove bindings from an environment</p></a></li>
<li><a href='#env_unlock'><p>Unlock an environment</p></a></li>
<li><a href='#eval_bare'><p>Evaluate an expression in an environment</p></a></li>
<li><a href='#eval_tidy'><p>Evaluate an expression with quosures and pronoun support</p></a></li>
<li><a href='#exec'><p>Execute a function</p></a></li>
<li><a href='#expr'><p>Defuse an R expression</p></a></li>
<li><a href='#expr_interp'><p>Process unquote operators in a captured expression</p></a></li>
<li><a href='#expr_label'><p>Turn an expression to a label</p></a></li>
<li><a href='#expr_print'><p>Print an expression</p></a></li>
<li><a href='#exprs_auto_name'><p>Ensure that all elements of a list of expressions are named</p></a></li>
<li><a href='#f_rhs'><p>Get or set formula components</p></a></li>
<li><a href='#f_text'><p>Turn RHS of formula into a string or label</p></a></li>
<li><a href='#faq-options'><p>Global options for rlang</p></a></li>
<li><a href='#ffi_standalone_types_check'><p>Internal API for standalone-types-check</p></a></li>
<li><a href='#flatten'><p>Flatten or squash a list of lists into a simpler vector</p></a></li>
<li><a href='#fn_body'><p>Get or set function body</p></a></li>
<li><a href='#fn_env'><p>Return the closure environment of a function</p></a></li>
<li><a href='#fn_fmls'><p>Extract arguments from a function</p></a></li>
<li><a href='#format_error_bullets'><p>Format bullets for error messages</p></a></li>
<li><a href='#format_error_call'><p>Validate and format a function call for use in error messages</p></a></li>
<li><a href='#friendly_type'><p>Format a type for error messages</p></a></li>
<li><a href='#get_env'><p>Get or set the environment of an object</p></a></li>
<li><a href='#global_entrace'><p>Entrace unexpected errors</p></a></li>
<li><a href='#global_handle'><p>Register default global handlers</p></a></li>
<li><a href='#global_prompt_install'><p>Prompt user to install missing packages</p></a></li>
<li><a href='#glue-operators'><p>Name injection with <code>"{"</code> and <code>"{{"</code></p></a></li>
<li><a href='#has_length'><p>How long is an object?</p></a></li>
<li><a href='#has_name'><p>Does an object have an element with this name?</p></a></li>
<li><a href='#hash'><p>Hashing</p></a></li>
<li><a href='#inherits_any'><p>Does an object inherit from a set of classes?</p></a></li>
<li><a href='#inject'><p>Inject objects in an R expression</p></a></li>
<li><a href='#injection-operator'><p>Injection operator <code style="white-space: pre;">&#8288;!!&#8288;</code></p></a></li>
<li><a href='#interrupt'><p>Simulate interrupt condition</p></a></li>
<li><a href='#invoke'><p>Invoke a function with a list of arguments</p></a></li>
<li><a href='#is_call'><p>Is object a call?</p></a></li>
<li><a href='#is_callable'><p>Is an object callable?</p></a></li>
<li><a href='#is_condition'><p>Is object a condition?</p></a></li>
<li><a href='#is_copyable'><p>Is an object copyable?</p></a></li>
<li><a href='#is_dictionaryish'><p>Is a vector uniquely named?</p></a></li>
<li><a href='#is_empty'><p>Is object an empty vector or NULL?</p></a></li>
<li><a href='#is_environment'><p>Is object an environment?</p></a></li>
<li><a href='#is_expression'><p>Is an object an expression?</p></a></li>
<li><a href='#is_formula'><p>Is object a formula?</p></a></li>
<li><a href='#is_function'><p>Is object a function?</p></a></li>
<li><a href='#is_installed'><p>Are packages installed in any of the libraries?</p></a></li>
<li><a href='#is_integerish'><p>Is a vector integer-like?</p></a></li>
<li><a href='#is_interactive'><p>Is R running interactively?</p></a></li>
<li><a href='#is_lang'><p>Is object a call?</p></a></li>
<li><a href='#is_named'><p>Is object named?</p></a></li>
<li><a href='#is_namespace'><p>Is an object a namespace environment?</p></a></li>
<li><a href='#is_pairlist'><p>Is object a node or pairlist?</p></a></li>
<li><a href='#is_reference'><p>Is an object referencing another?</p></a></li>
<li><a href='#is_symbol'><p>Is object a symbol?</p></a></li>
<li><a href='#is_true'><p>Is object identical to TRUE or FALSE?</p></a></li>
<li><a href='#is_weakref'><p>Is object a weak reference?</p></a></li>
<li><a href='#lang'><p>Create a call</p></a></li>
<li><a href='#last_error'><p>Last <code>abort()</code> error</p></a></li>
<li><a href='#last_warnings'><p>Display last messages and warnings</p></a></li>
<li><a href='#list2'><p>Collect dynamic dots in a list</p></a></li>
<li><a href='#local_bindings'><p>Temporarily change bindings of an environment</p></a></li>
<li><a href='#local_error_call'><p>Set local error call in an execution environment</p></a></li>
<li><a href='#local_options'><p>Change global options</p></a></li>
<li><a href='#local_use_cli'><p>Use cli to format error messages</p></a></li>
<li><a href='#missing'><p>Missing values</p></a></li>
<li><a href='#missing_arg'><p>Generate or handle a missing argument</p></a></li>
<li><a href='#names_inform_repair'><p>Inform about name repair</p></a></li>
<li><a href='#names2'><p>Get names of a vector</p></a></li>
<li><a href='#new_call'><p>Create a new call from components</p></a></li>
<li><a href='#new_formula'><p>Create a formula</p></a></li>
<li><a href='#new_function'><p>Create a function</p></a></li>
<li><a href='#new_node'><p>Helpers for pairlist and language nodes</p></a></li>
<li><a href='#new_quosure'><p>Create a quosure from components</p></a></li>
<li><a href='#new_quosures'><p>Create a list of quosures</p></a></li>
<li><a href='#new_weakref'><p>Create a weak reference</p></a></li>
<li><a href='#new-vector'><p>Create vectors matching a given length</p></a></li>
<li><a href='#ns_env'><p>Get the namespace of a package</p></a></li>
<li><a href='#ns_registry_env'><p>Return the namespace registry env</p></a></li>
<li><a href='#obj_address'><p>Address of an R object</p></a></li>
<li><a href='#on_load'><p>Run expressions on load</p></a></li>
<li><a href='#op-get-attr'><p>Infix attribute accessor and setter</p></a></li>
<li><a href='#op-na-default'><p>Replace missing values</p></a></li>
<li><a href='#op-null-default'><p>Default value for <code>NULL</code></p></a></li>
<li><a href='#pairlist2'><p>Collect dynamic dots in a pairlist</p></a></li>
<li><a href='#parse_expr'><p>Parse R code</p></a></li>
<li><a href='#prim_name'><p>Name of a primitive function</p></a></li>
<li><a href='#qq_show'><p>Show injected expression</p></a></li>
<li><a href='#quo_expr'><p>Squash a quosure</p></a></li>
<li><a href='#quo_label'><p>Format quosures for printing or labelling</p></a></li>
<li><a href='#quo_squash'><p>Squash a quosure</p></a></li>
<li><a href='#quosure-tools'><p>Quosure getters, setters and predicates</p></a></li>
<li><a href='#raw_deparse_str'><p>Serialize a raw vector to a string</p></a></li>
<li><a href='#rep_along'><p>Create vectors matching the length of a given vector</p></a></li>
<li><a href='#return_from'><p>Jump to or from a frame</p></a></li>
<li><a href='#rlang_backtrace_on_error'><p>Display backtrace on error</p></a></li>
<li><a href='#rlang_error'><p>Errors of class <code>rlang_error</code></p></a></li>
<li><a href='#rlang-package'><p>rlang: Functions for Base Types and Core R and 'Tidyverse' Features</p></a></li>
<li><a href='#rlib_trace_spec'><p>Backtrace specification</p></a></li>
<li><a href='#scalar-type-predicates'><p>Scalar type predicates</p></a></li>
<li><a href='#scoped_env'><p>Deprecated <code>scoped</code> functions</p></a></li>
<li><a href='#scoped_interactive'><p>Deprecated <code>scoped_</code> functions</p></a></li>
<li><a href='#search_envs'><p>Search path environments</p></a></li>
<li><a href='#seq2'><p>Increasing sequence of integers in an interval</p></a></li>
<li><a href='#set_attrs'><p>Add attributes to an object</p></a></li>
<li><a href='#set_expr'><p>Set and get an expression</p></a></li>
<li><a href='#set_names'><p>Set names of a vector</p></a></li>
<li><a href='#splice'><p>Splice values at dots collection time</p></a></li>
<li><a href='#splice-operator'><p>Splice operator <code style="white-space: pre;">&#8288;!!!&#8288;</code></p></a></li>
<li><a href='#stack'><p>Get properties of the current or caller frame</p></a></li>
<li><a href='#stack-deprecated'><p>Call stack information</p></a></li>
<li><a href='#string'><p>Create a string</p></a></li>
<li><a href='#switch_type'><p>Dispatch on base types</p></a></li>
<li><a href='#sym'><p>Create a symbol or list of symbols</p></a></li>
<li><a href='#topic-condition-customisation'><p>Customising condition messages</p></a></li>
<li><a href='#topic-condition-formatting'><p>Formatting messages with cli</p></a></li>
<li><a href='#topic-data-mask'><p>What is data-masking and why do I need <code style="white-space: pre;">&#8288;{{&#8288;</code>?</p></a></li>
<li><a href='#topic-data-mask-ambiguity'><p>The data mask ambiguity</p></a></li>
<li><a href='#topic-data-mask-programming'><p>Data mask programming patterns</p></a></li>
<li><a href='#topic-defuse'><p>Defusing R expressions</p></a></li>
<li><a href='#topic-double-evaluation'><p>The double evaluation problem</p></a></li>
<li><a href='#topic-embrace-constants'><p>Why are strings and other constants enquosed in the empty environment?</p></a></li>
<li><a href='#topic-embrace-non-args'><p>Does <code style="white-space: pre;">&#8288;{{&#8288;</code> work on regular objects?</p></a></li>
<li><a href='#topic-error-call'><p>Including function calls in error messages</p></a></li>
<li><a href='#topic-error-chaining'><p>Including contextual information with error chains</p></a></li>
<li><a href='#topic-inject'><p>Injecting with <code style="white-space: pre;">&#8288;!!&#8288;</code>, <code style="white-space: pre;">&#8288;!!!&#8288;</code>, and glue syntax</p></a></li>
<li><a href='#topic-inject-out-of-context'><p>What happens if I use injection operators out of context?</p></a></li>
<li><a href='#topic-metaprogramming'><p>Metaprogramming patterns</p></a></li>
<li><a href='#topic-multiple-columns'><p>Taking multiple columns without <code>...</code></p></a></li>
<li><a href='#topic-quosure'><p>What are quosures and when are they needed?</p></a></li>
<li><a href='#trace_back'><p>Capture a backtrace</p></a></li>
<li><a href='#try_fetch'><p>Try an expression with condition handlers</p></a></li>
<li><a href='#type_of'><p>Base type of an object</p></a></li>
<li><a href='#type-predicates'><p>Type predicates</p></a></li>
<li><a href='#UQ'><p>Deprecated <code>UQ()</code> and <code>UQS()</code> operators</p></a></li>
<li><a href='#vec_poke_n'><p>Poke values into a vector</p></a></li>
<li><a href='#vector-coercion'><p>Coerce an object to a base type</p></a></li>
<li><a href='#vector-construction'><p>Create vectors</p></a></li>
<li><a href='#with_env'><p>Evaluate an expression within a given environment</p></a></li>
<li><a href='#with_handlers'><p>Establish handlers on the stack</p></a></li>
<li><a href='#wref_key'><p>Get key/value from a weak reference object</p></a></li>
<li><a href='#zap'><p>Create zap objects</p></a></li>
<li><a href='#zap_srcref'><p>Zap source references</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Base Types and Core R and 'Tidyverse' Features</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox for working with base types, core R features
  like the condition system, and core 'Tidyverse' features like tidy
  evaluation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cli (&ge; 3.1.0), covr, crayon, fs, glue, knitr, magrittr,
methods, pillar, rmarkdown, stats, testthat (&ge; 3.0.0), tibble,
usethis, vctrs (&ge; 0.2.3), withr</td>
</tr>
<tr>
<td>Enhances:</td>
<td>winch</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rlang.r-lib.org">https://rlang.r-lib.org</a>, <a href="https://github.com/r-lib/rlang">https://github.com/r-lib/rlang</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/rlang/issues">https://github.com/r-lib/rlang/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>dplyr, tidyverse/tidytemplate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 13:33:10 UTC; lionel</td>
</tr>
<tr>
<td>Author:</td>
<td>Lionel Henry [aut, cre],
  Hadley Wickham [aut],
  mikefc [cph] (Hash implementation based on Mike's xxhashlite),
  Yann Collet [cph] (Author of the embedded xxHash library),
  Posit, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lionel Henry &lt;lionel@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 12:00:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-02-12 05:22:19 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='abort'>Signal an error, warning, or message</h2><span id='topic+abort'></span><span id='topic+warn'></span><span id='topic+inform'></span><span id='topic+signal'></span><span id='topic+reset_warning_verbosity'></span><span id='topic+reset_message_verbosity'></span>

<h3>Description</h3>

<p>These functions are equivalent to base functions <code><a href="base.html#topic+stop">base::stop()</a></code>,
<code><a href="base.html#topic+warning">base::warning()</a></code>, and <code><a href="base.html#topic+message">base::message()</a></code>. They signal a condition
(an error, warning, or message respectively) and make it easy to
supply condition metadata:
</p>

<ul>
<li><p> Supply <code>class</code> to create a classed condition that can be caught
or handled selectively, allowing for finer-grained error
handling.
</p>
</li>
<li><p> Supply metadata with named <code>...</code> arguments. This data is stored
in the condition object and can be examined by handlers.
</p>
</li>
<li><p> Supply <code>call</code> to inform users about which function the error
occurred in.
</p>
</li>
<li><p> Supply another condition as <code>parent</code> to create a <a href="rlang.html#topic+topic-error-chaining">chained condition</a>.
</p>
</li></ul>

<p>Certain components of condition messages are formatted with unicode
symbols and terminal colours by default. These aspects can be
customised, see <a href="rlang.html#topic+topic-condition-customisation">Customising condition messages</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abort(
  message = NULL,
  class = NULL,
  ...,
  call,
  body = NULL,
  footer = NULL,
  trace = NULL,
  parent = NULL,
  use_cli_format = NULL,
  .inherit = TRUE,
  .internal = FALSE,
  .file = NULL,
  .frame = caller_env(),
  .trace_bottom = NULL,
  .subclass = deprecated()
)

warn(
  message = NULL,
  class = NULL,
  ...,
  body = NULL,
  footer = NULL,
  parent = NULL,
  use_cli_format = NULL,
  .inherit = NULL,
  .frequency = c("always", "regularly", "once"),
  .frequency_id = NULL,
  .subclass = deprecated()
)

inform(
  message = NULL,
  class = NULL,
  ...,
  body = NULL,
  footer = NULL,
  parent = NULL,
  use_cli_format = NULL,
  .inherit = NULL,
  .file = NULL,
  .frequency = c("always", "regularly", "once"),
  .frequency_id = NULL,
  .subclass = deprecated()
)

signal(message = "", class, ..., .subclass = deprecated())

reset_warning_verbosity(id)

reset_message_verbosity(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abort_+3A_message">message</code></td>
<td>
<p>The message to display, formatted as a <strong>bulleted
list</strong>. The first element is displayed as an <em>alert</em> bullet
prefixed with <code>!</code> by default. Elements named <code>"*"</code>, <code>"i"</code>, <code>"v"</code>,
<code>"x"</code>, and <code>"!"</code> are formatted as regular, info, success,
failure, and error bullets respectively. See <a href="rlang.html#topic+topic-condition-formatting">Formatting messages with cli</a>
for more about bulleted messaging.
</p>
<p>If a message is not supplied, it is expected that the message is
generated <strong>lazily</strong> through <code><a href="rlang.html#topic+cnd_header">cnd_header()</a></code> and <code><a href="rlang.html#topic+cnd_body">cnd_body()</a></code>
methods. In that case, <code>class</code> must be supplied. Only <code>inform()</code>
allows empty messages as it is occasionally useful to build user
output incrementally.
</p>
<p>If a function, it is stored in the <code>header</code> field of the error
condition. This acts as a <code><a href="rlang.html#topic+cnd_header">cnd_header()</a></code> method that is invoked
lazily when the error message is displayed.</p>
</td></tr>
<tr><td><code id="abort_+3A_class">class</code></td>
<td>
<p>Subclass of the condition.</p>
</td></tr>
<tr><td><code id="abort_+3A_...">...</code></td>
<td>
<p>Additional data to be stored in the condition object.
If you supply condition fields, you should usually provide a
<code>class</code> argument. You may consider prefixing condition fields
with the name of your package or organisation to prevent name
collisions.</p>
</td></tr>
<tr><td><code id="abort_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently running
function, e.g. <code>call = caller_env()</code>. The corresponding function
call is retrieved and mentioned in error messages as the source
of the error.
</p>
<p>You only need to supply <code>call</code> when throwing a condition from a
helper function which wouldn't be relevant to mention in the
message.
</p>
<p>Can also be <code>NULL</code> or a <a href="rlang.html#topic+topic-defuse">defused function call</a> to
respectively not display any call or hard-code a code to display.
</p>
<p>For more information about error calls, see <a href="rlang.html#topic+topic-error-call">Including function calls in error messages</a>.</p>
</td></tr>
<tr><td><code id="abort_+3A_body">body</code>, <code id="abort_+3A_footer">footer</code></td>
<td>
<p>Additional bullets.</p>
</td></tr>
<tr><td><code id="abort_+3A_trace">trace</code></td>
<td>
<p>A <code>trace</code> object created by <code><a href="rlang.html#topic+trace_back">trace_back()</a></code>.</p>
</td></tr>
<tr><td><code id="abort_+3A_parent">parent</code></td>
<td>
<p>Supply <code>parent</code> when you rethrow an error from a
condition handler (e.g. with <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>).
</p>

<ul>
<li><p> If <code>parent</code> is a condition object, a <em>chained error</em> is
created, which is useful when you want to enhance an error with
more details, while still retaining the original information.
</p>
</li>
<li><p> If <code>parent</code> is <code>NA</code>, it indicates an unchained rethrow, which
is useful when you want to take ownership over an error and
rethrow it with a custom message that better fits the
surrounding context.
</p>
<p>Technically, supplying <code>NA</code> lets <code>abort()</code> know it is called
from a condition handler. This helps it create simpler
backtraces where the condition handling context is hidden by
default.
</p>
</li></ul>

<p>For more information about error calls, see <a href="rlang.html#topic+topic-error-chaining">Including contextual information with error chains</a>.</p>
</td></tr>
<tr><td><code id="abort_+3A_use_cli_format">use_cli_format</code></td>
<td>
<p>Whether to format <code>message</code> lazily using
<a href="https://cli.r-lib.org/">cli</a> if available. This results in
prettier and more accurate formatting of messages. See
<code><a href="rlang.html#topic+local_use_cli">local_use_cli()</a></code> to set this condition field by default in your
package namespace.
</p>
<p>If set to <code>TRUE</code>, <code>message</code> should be a character vector of
individual and unformatted lines. Any newline character <code>"\\n"</code>
already present in <code>message</code> is reformatted by cli's paragraph
formatter. See <a href="rlang.html#topic+topic-condition-formatting">Formatting messages with cli</a>.</p>
</td></tr>
<tr><td><code id="abort_+3A_.inherit">.inherit</code></td>
<td>
<p>Whether the condition inherits from <code>parent</code>
according to <code><a href="rlang.html#topic+cnd_inherits">cnd_inherits()</a></code> and <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>. By default,
parent conditions of higher severity are not inherited. For
instance an error chained to a warning is not inherited to avoid
unexpectedly catching an error downgraded to a warning.</p>
</td></tr>
<tr><td><code id="abort_+3A_.internal">.internal</code></td>
<td>
<p>If <code>TRUE</code>, a footer bullet is added to <code>message</code>
to let the user know that the error is internal and that they
should report it to the package authors. This argument is
incompatible with <code>footer</code>.</p>
</td></tr>
<tr><td><code id="abort_+3A_.file">.file</code></td>
<td>
<p>A connection or a string specifying where to print the
message. The default depends on the context, see the <code>stdout</code> vs
<code>stderr</code> section.</p>
</td></tr>
<tr><td><code id="abort_+3A_.frame">.frame</code></td>
<td>
<p>The throwing context. Used as default for
<code>.trace_bottom</code>, and to determine the internal package to mention
in internal errors when <code>.internal</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="abort_+3A_.trace_bottom">.trace_bottom</code></td>
<td>
<p>Used in the display of simplified backtraces
as the last relevant call frame to show. This way, the irrelevant
parts of backtraces corresponding to condition handling
(<code><a href="base.html#topic+tryCatch">tryCatch()</a></code>, <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>, <code>abort()</code>, etc.) are hidden by
default. Defaults to <code>call</code> if it is an environment, or <code>.frame</code>
otherwise. Without effect if <code>trace</code> is supplied.</p>
</td></tr>
<tr><td><code id="abort_+3A_.subclass">.subclass</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> This argument
was renamed to <code>class</code> in rlang 0.4.2 for consistency with our
conventions for class constructors documented in
<a href="https://adv-r.hadley.nz/s3.html#s3-subclassing">https://adv-r.hadley.nz/s3.html#s3-subclassing</a>.</p>
</td></tr>
<tr><td><code id="abort_+3A_.frequency">.frequency</code></td>
<td>
<p>How frequently should the warning or message be
displayed? By default (<code>"always"</code>) it is displayed at each
time. If <code>"regularly"</code>, it is displayed once every 8 hours. If
<code>"once"</code>, it is displayed once per session.</p>
</td></tr>
<tr><td><code id="abort_+3A_.frequency_id">.frequency_id</code></td>
<td>
<p>A unique identifier for the warning or
message. This is used when <code>.frequency</code> is supplied to recognise
recurring conditions. This argument must be supplied if
<code>.frequency</code> is not set to <code>"always"</code>.</p>
</td></tr>
<tr><td><code id="abort_+3A_id">id</code></td>
<td>
<p>The identifying string of the condition that was supplied
as <code>.frequency_id</code> to <code>warn()</code> or <code>inform()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>abort()</code> throws subclassed errors, see
<code><a href="rlang.html#topic+rlang_error">&quot;rlang_error&quot;</a></code>.
</p>
</li>
<li> <p><code>warn()</code> temporarily set the <code>warning.length</code> global option to
the maximum value (8170), unless that option has been changed
from the default value. The default limit (1000 characters) is
especially easy to hit when the message contains a lot of ANSI
escapes, as created by the crayon or cli packages
</p>
</li></ul>



<h3>Error prefix</h3>

<p>As with <code><a href="base.html#topic+stop">base::stop()</a></code>, errors thrown with <code>abort()</code> are prefixed
with <code>"Error: "</code>. Calls and source references are included in the
prefix, e.g. <code style="white-space: pre;">&#8288;"Error in &#8288;</code>my_function()<code style="white-space: pre;">&#8288; at myfile.R:1:2:"&#8288;</code>. There
are a few cosmetic differences:
</p>

<ul>
<li><p> The call is stripped from its arguments to keep it simple. It is
then formatted using the <a href="https://cli.r-lib.org/">cli package</a> if
available.
</p>
</li>
<li><p> A line break between the prefix and the message when the former
is too long. When a source location is included, a line break is
always inserted.
</p>
</li></ul>

<p>If your throwing code is highly structured, you may have to
explicitly inform <code>abort()</code> about the relevant user-facing call to
include in the prefix. Internal helpers are rarely relevant to end
users. See the <code>call</code> argument of <code>abort()</code>.
</p>


<h3>Backtrace</h3>

<p><code>abort()</code> saves a backtrace in the <code>trace</code> component of the error
condition. You can print a simplified backtrace of the last error
by calling <code><a href="rlang.html#topic+last_error">last_error()</a></code> and a full backtrace with
<code>summary(last_error())</code>. Learn how to control what is displayed
when an error is thrown with <code><a href="rlang.html#topic+rlang_backtrace_on_error">rlang_backtrace_on_error</a></code>.
</p>


<h3>Muffling and silencing conditions</h3>

<p>Signalling a condition with <code>inform()</code> or <code>warn()</code> displays a
message in the console. These messages can be muffled as usual with
<code><a href="base.html#topic+message">base::suppressMessages()</a></code> or <code><a href="base.html#topic+warning">base::suppressWarnings()</a></code>.
</p>
<p><code>inform()</code> and <code>warn()</code> messages can also be silenced with the
global options <code>rlib_message_verbosity</code> and
<code>rlib_warning_verbosity</code>. These options take the values:
</p>

<ul>
<li> <p><code>"default"</code>: Verbose unless the <code>.frequency</code> argument is supplied.
</p>
</li>
<li> <p><code>"verbose"</code>: Always verbose.
</p>
</li>
<li> <p><code>"quiet"</code>: Always quiet.
</p>
</li></ul>

<p>When set to quiet, the message is not displayed and the condition
is not signalled.
</p>


<h3><code>stdout</code> and <code>stderr</code></h3>

<p>By default, <code>abort()</code> and <code>inform()</code> print to standard output in
interactive sessions. This allows rlang to be in control of the
appearance of messages in IDEs like RStudio.
</p>
<p>There are two situations where messages are streamed to <code>stderr</code>:
</p>

<ul>
<li><p> In non-interactive sessions, messages are streamed to standard
error so that R scripts can easily filter them out from normal
output by redirecting <code>stderr</code>.
</p>
</li>
<li><p> If a sink is active (either on output or on messages) messages
are always streamd to <code>stderr</code>.
</p>
</li></ul>

<p>These exceptions ensure consistency of behaviour in interactive and
non-interactive sessions, and when sinks are active.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-error-call">Including function calls in error messages</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+topic-error-chaining">Including contextual information with error chains</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># These examples are guarded to avoid throwing errors
if (FALSE) {

# Signal an error with a message just like stop():
abort("The error message.")


# Unhandled errors are saved automatically by `abort()` and can be
# retrieved with `last_error()`. The error prints with a simplified
# backtrace:
f &lt;- function() try(g())
g &lt;- function() evalq(h())
h &lt;- function() abort("Tilt.")
last_error()

# Use `summary()` to print the full backtrace and the condition fields:
summary(last_error())


# Give a class to the error:
abort("The error message", "mypkg_bad_error")

# This allows callers to handle the error selectively
tryCatch(
  mypkg_function(),
  mypkg_bad_error = function(err) {
    warn(conditionMessage(err)) # Demote the error to a warning
    NA                          # Return an alternative value
  }
)

# You can also specify metadata that will be stored in the condition:
abort("The error message.", "mypkg_bad_error", data = 1:10)

# This data can then be consulted by user handlers:
tryCatch(
  mypkg_function(),
  mypkg_bad_error = function(err) {
    # Compute an alternative return value with the data:
    recover_error(err$data)
  }
)


# If you call low-level APIs it may be a good idea to create a
# chained error with the low-level error wrapped in a more
# user-friendly error. Use `try_fetch()` to fetch errors of a given
# class and rethrow them with the `parent` argument of `abort()`:
file &lt;- "http://foo.bar/baz"
try(
  try_fetch(
    download(file),
    error = function(err) {
      msg &lt;- sprintf("Can't download `%s`", file)
      abort(msg, parent = err)
  })
)

}
</code></pre>

<hr>
<h2 id='are_na'>Test for missing values</h2><span id='topic+are_na'></span><span id='topic+is_na'></span><span id='topic+is_lgl_na'></span><span id='topic+is_int_na'></span><span id='topic+is_dbl_na'></span><span id='topic+is_chr_na'></span><span id='topic+is_cpl_na'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a>
</p>
<p><code>are_na()</code> checks for missing values in a vector and is equivalent
to <code><a href="base.html#topic+NA">base::is.na()</a></code>. It is a vectorised predicate, meaning that its
output is always the same length as its input. On the other hand,
<code>is_na()</code> is a scalar predicate and always returns a scalar
boolean, <code>TRUE</code> or <code>FALSE</code>. If its input is not scalar, it returns
<code>FALSE</code>. Finally, there are typed versions that check for
particular <a href="base.html#topic+missing">missing types</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_na(x)

is_na(x)

is_lgl_na(x)

is_int_na(x)

is_dbl_na(x)

is_chr_na(x)

is_cpl_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are_na_+3A_x">x</code></td>
<td>
<p>An object to test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scalar predicates accept non-vector inputs. They are equivalent
to <code><a href="purrr.html#topic+is_null">is_null()</a></code> in that respect. In contrast the vectorised
predicate <code>are_na()</code> requires a vector input since it is defined
over vector values.
</p>


<h3>Life cycle</h3>

<p>These functions might be moved to the vctrs package at some
point. This is why they are marked as questioning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># are_na() is vectorised and works regardless of the type
are_na(c(1, 2, NA))
are_na(c(1L, NA, 3L))

# is_na() checks for scalar input and works for all types
is_na(NA)
is_na(na_dbl)
is_na(character(0))

# There are typed versions as well:
is_lgl_na(NA)
is_lgl_na(na_dbl)
</code></pre>

<hr>
<h2 id='arg_match'>Match an argument to a character vector</h2><span id='topic+arg_match'></span><span id='topic+arg_match0'></span>

<h3>Description</h3>

<p>This is equivalent to <code><a href="base.html#topic+match.arg">base::match.arg()</a></code> with a few differences:
</p>

<ul>
<li><p> Partial matches trigger an error.
</p>
</li>
<li><p> Error messages are a bit more informative and obey the tidyverse
standards.
</p>
</li></ul>

<p><code>arg_match()</code> derives the possible values from the
<a href="rlang.html#topic+caller_fn">caller function</a>.
</p>
<p><code>arg_match0()</code> is a bare-bones version if performance is at a premium.
It requires a string as <code>arg</code> and explicit character <code>values</code>.
For convenience, <code>arg</code> may also be a character vector containing
every element of <code>values</code>, possibly permuted.
In this case, the first element of <code>arg</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arg_match(
  arg,
  values = NULL,
  ...,
  multiple = FALSE,
  error_arg = caller_arg(arg),
  error_call = caller_env()
)

arg_match0(arg, values, arg_nm = caller_arg(arg), error_call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arg_match_+3A_arg">arg</code></td>
<td>
<p>A symbol referring to an argument accepting strings.</p>
</td></tr>
<tr><td><code id="arg_match_+3A_values">values</code></td>
<td>
<p>A character vector of possible values that <code>arg</code> can take.</p>
</td></tr>
<tr><td><code id="arg_match_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="arg_match_+3A_multiple">multiple</code></td>
<td>
<p>Whether <code>arg</code> may contain zero or several values.</p>
</td></tr>
<tr><td><code id="arg_match_+3A_error_arg">error_arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
<tr><td><code id="arg_match_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="arg_match_+3A_arg_nm">arg_nm</code></td>
<td>
<p>Same as <code>error_arg</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The string supplied to <code>arg</code>.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+check_required">check_required()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- function(x = c("foo", "bar")) arg_match(x)
fn("bar")

# Throws an informative error for mismatches:
try(fn("b"))
try(fn("baz"))

# Use the bare-bones version with explicit values for speed:
arg_match0("bar", c("foo", "bar", "baz"))

# For convenience:
fn1 &lt;- function(x = c("bar", "baz", "foo")) fn3(x)
fn2 &lt;- function(x = c("baz", "bar", "foo")) fn3(x)
fn3 &lt;- function(x) arg_match0(x, c("foo", "bar", "baz"))
fn1()
fn2("bar")
try(fn3("zoo"))
</code></pre>

<hr>
<h2 id='args_data_masking'>Argument type: data-masking</h2><span id='topic+args_data_masking'></span>

<h3>Description</h3>

<p>This page describes the <code style="white-space: pre;">&#8288;&lt;data-masking&gt;&#8288;</code> argument modifier which
indicates that the argument uses tidy evaluation with <strong>data masking</strong>.
If you've never heard of tidy evaluation before, start with
<code>vignette("programming", package = "dplyr")</code>.
</p>


<h3>Key terms</h3>

<p>The primary motivation for tidy evaluation in tidyverse packages is that it
provides <strong>data masking</strong>, which blurs the distinction between two types of
variables:
</p>

<ul>
<li> <p><strong>env-variables</strong> are &quot;programming&quot; variables and live in an environment.
They are usually created with <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>. Env-variables can be any type of R
object.
</p>
</li>
<li> <p><strong>data-variables</strong> are &quot;statistical&quot; variables and live in a data frame.
They usually come from data files (e.g. <code>.csv</code>, <code>.xls</code>), or are created by
manipulating existing variables. Data-variables live inside data frames,
so must be vectors.
</p>
</li></ul>



<h3>General usage</h3>

<p>Data masking allows you to refer to variables in the &quot;current&quot; data frame
(usually supplied in the <code>.data</code> argument), without any other prefix.
It's what allows you to type (e.g.) <code>filter(diamonds, x == 0 &amp; y == 0 &amp; z == 0)</code>
instead of <code>diamonds[diamonds$x == 0 &amp; diamonds$y == 0 &amp; diamonds$z == 0, ]</code>.
</p>


<h3>Indirection</h3>

<p>The main challenge of data masking arises when you introduce some
indirection, i.e. instead of directly typing the name of a variable you
want to supply it in a function argument or character vector.
</p>
<p>There are two main cases:
</p>

<ul>
<li><p> If you want the user to supply the variable (or function of variables)
in a function argument, embrace the argument, e.g. <code>filter(df, {{ var }})</code>.
</p>
<div class="sourceCode"><pre>dist_summary &lt;- function(df, var) {
  df %&gt;%
    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))
}
mtcars %&gt;% dist_summary(mpg)
mtcars %&gt;% group_by(cyl) %&gt;% dist_summary(mpg)
</pre></div>
</li>
<li><p> If you have the column name as a character vector, use the <code>.data</code>
pronoun, e.g. <code>summarise(df, mean = mean(.data[[var]]))</code>.
</p>
<div class="sourceCode"><pre>for (var in names(mtcars)) {
  mtcars %&gt;% count(.data[[var]]) %&gt;% print()
}

lapply(names(mtcars), function(var) mtcars %&gt;% count(.data[[var]]))
</pre></div>
<p>(Note that the contents of <code>[[</code>, e.g. <code>var</code> above, is never evaluated
in the data environment so you don't need to worry about a data-variable
called <code>var</code> causing problems.)
</p>
</li></ul>



<h3>Dot-dot-dot (...)</h3>

<p>When this modifier is applied to <code>...</code>, there is one other useful technique
which solves the problem of creating a new variable with a name supplied by
the user. Use the interpolation syntax from the glue package: <code>"{var}" := expression</code>. (Note the use of <code style="white-space: pre;">&#8288;:=&#8288;</code> instead of <code>=</code> to enable this syntax).
</p>
<div class="sourceCode"><pre>var_name &lt;- "l100km"
mtcars %&gt;% mutate("{var_name}" := 235 / mpg)
</pre></div>
<p>Note that <code>...</code> automatically provides indirection, so you can use it as is
(i.e. without embracing) inside a function:
</p>
<div class="sourceCode"><pre>grouped_mean &lt;- function(df, var, ...) {
  df %&gt;%
    group_by(...) %&gt;%
    summarise(mean = mean({{ var }}))
}
</pre></div>


<h3>See Also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-data-mask">What is data-masking and why do I need {{?</a>.
</p>
</li>
<li> <p><a href="rlang.html#topic+topic-data-mask-programming">Data mask programming patterns</a>.
</p>
</li></ul>


<hr>
<h2 id='args_dots_empty'>Helper for consistent documentation of empty dots</h2><span id='topic+args_dots_empty'></span>

<h3>Description</h3>

<p>Use <code style="white-space: pre;">&#8288;@inheritParams rlang::args_dots_empty&#8288;</code> in your package
to consistently document <code>...</code> that must be empty.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="args_dots_empty_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>

<hr>
<h2 id='args_dots_used'>Helper for consistent documentation of used dots</h2><span id='topic+args_dots_used'></span>

<h3>Description</h3>

<p>Use <code style="white-space: pre;">&#8288;@inheritParams rlang::args_dots_used&#8288;</code> in your package
to consistently document <code>...</code> that must be used.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="args_dots_used_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='args_error_context'>Documentation anchor for error arguments</h2><span id='topic+args_error_context'></span>

<h3>Description</h3>

<p>Use <code style="white-space: pre;">&#8288;@inheritParams rlang::args_error_context&#8288;</code> in your package to
document <code>arg</code> and <code>call</code> arguments (or equivalently their prefixed
versions <code>error_arg</code> and <code>error_call</code>).
</p>

<ul>
<li> <p><code>arg</code> parameters should be formatted as argument (e.g. using
cli's <code>.arg</code> specifier) and included in error messages. See also
<code><a href="rlang.html#topic+caller_arg">caller_arg()</a></code>.
</p>
</li>
<li> <p><code>call</code> parameters should be included in error conditions in a
field named <code>call</code>. An easy way to do this is by passing a <code>call</code>
argument to <code><a href="rlang.html#topic+abort">abort()</a></code>. See also <code><a href="rlang.html#topic+local_error_call">local_error_call()</a></code>.
</p>
</li></ul>



<h3>Arguments</h3>

<table>
<tr><td><code id="args_error_context_+3A_arg">arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
<tr><td><code id="args_error_context_+3A_error_arg">error_arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
<tr><td><code id="args_error_context_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="args_error_context_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>

<hr>
<h2 id='as_box'>Convert object to a box</h2><span id='topic+as_box'></span><span id='topic+as_box_if'></span>

<h3>Description</h3>


<ul>
<li> <p><code>as_box()</code> boxes its input only if it is not already a box. The
class is also checked if supplied.
</p>
</li>
<li> <p><code>as_box_if()</code> boxes its input only if it not already a box, or if
the predicate <code>.p</code> returns <code>TRUE</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>as_box(x, class = NULL)

as_box_if(.x, .p, .class = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_box_+3A_x">x</code>, <code id="as_box_+3A_.x">.x</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="as_box_+3A_class">class</code>, <code id="as_box_+3A_.class">.class</code></td>
<td>
<p>A box class. If the input is already a box of
that class, it is returned as is. If the input needs to be boxed,
<code>class</code> is passed to <code><a href="rlang.html#topic+new_box">new_box()</a></code>.</p>
</td></tr>
<tr><td><code id="as_box_+3A_.p">.p</code></td>
<td>
<p>A predicate function.</p>
</td></tr>
<tr><td><code id="as_box_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>.p</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='as_closure'>Transform to a closure</h2><span id='topic+as_closure'></span>

<h3>Description</h3>

<p><code>as_closure()</code> is like <code><a href="rlang.html#topic+as_function">as_function()</a></code> but also wraps primitive
functions inside closures. Some special control flow primitives
like <code>if</code>, <code>for</code>, or <code>break</code> can't be wrapped and will cause an
error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_closure(x, env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_closure_+3A_x">x</code></td>
<td>
<p>A function or formula.
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function
with up to two arguments: <code>.x</code> (single argument) or <code>.x</code> and <code>.y</code>
(two arguments). The <code>.</code> placeholder can be used instead of <code>.x</code>.
This allows you to create very compact anonymous functions (lambdas) with up
to two inputs. Functions created from formulas have a special
class. Use <code>is_lambda()</code> to test for it.
</p>
<p>If a <strong>string</strong>, the function is looked up in <code>env</code>. Note that
this interface is strictly for user convenience because of the
scoping issues involved. Package developers should avoid
supplying functions by name and instead supply them by value.</p>
</td></tr>
<tr><td><code id="as_closure_+3A_env">env</code></td>
<td>
<p>Environment in which to fetch the function in case <code>x</code>
is a string.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Primitive functions are regularised as closures
as_closure(list)
as_closure("list")

# Operators have `.x` and `.y` as arguments, just like lambda
# functions created with the formula syntax:
as_closure(`+`)
as_closure(`~`)

</code></pre>

<hr>
<h2 id='as_data_mask'>Create a data mask</h2><span id='topic+as_data_mask'></span><span id='topic+as_data_pronoun'></span><span id='topic+new_data_mask'></span>

<h3>Description</h3>

<p>A <a href="rlang.html#topic+topic-data-mask">data mask</a> is an environment (or possibly
multiple environments forming an ancestry) containing user-supplied
objects. Objects in the mask have precedence over objects in the
environment (i.e. they mask those objects). Many R functions
evaluate quoted expressions in a data mask so these expressions can
refer to objects within the user data.
</p>
<p>These functions let you construct a tidy eval data mask manually.
They are meant for developers of tidy eval interfaces rather than
for end users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_data_mask(data)

as_data_pronoun(data)

new_data_mask(bottom, top = bottom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_data_mask_+3A_data">data</code></td>
<td>
<p>A data frame or named vector of masking data.</p>
</td></tr>
<tr><td><code id="as_data_mask_+3A_bottom">bottom</code></td>
<td>
<p>The environment containing masking objects if the
data mask is one environment deep. The bottom environment if the
data mask comprises multiple environment.
</p>
<p>If you haven't supplied <code>top</code>, this <strong>must</strong> be an environment
that you own, i.e. that you have created yourself.</p>
</td></tr>
<tr><td><code id="as_data_mask_+3A_top">top</code></td>
<td>
<p>The last environment of the data mask. If the data mask
is only one environment deep, <code>top</code> should be the same as
<code>bottom</code>.
</p>
<p>This <strong>must</strong> be an environment that you own, i.e. that you have
created yourself. The parent of <code>top</code> will be changed by the tidy
eval engine and should be considered undetermined. Never make
assumption about the parent of <code>top</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data mask that you can supply to <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code>.
</p>


<h3>Why build a data mask?</h3>

<p>Most of the time you can just call <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code> with a list or a
data frame and the data mask will be constructed automatically.
There are three main use cases for manual creation of data masks:
</p>

<ul>
<li><p> When <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code> is called with the same data in a tight loop.
Because there is some overhead to creating tidy eval data masks,
constructing the mask once and reusing it for subsequent
evaluations may improve performance.
</p>
</li>
<li><p> When several expressions should be evaluated in the exact same
environment because a quoted expression might create new objects
that can be referred in other quoted expressions evaluated at a
later time. One example of this is <code>tibble::lst()</code> where new
columns can refer to previous ones.
</p>
</li>
<li><p> When your data mask requires special features. For instance the
data frame columns in dplyr data masks are implemented with
<a href="base.html#topic+delayedAssign">active bindings</a>.
</p>
</li></ul>



<h3>Building your own data mask</h3>

<p>Unlike <code><a href="base.html#topic+eval">base::eval()</a></code> which takes any kind of environments as data
mask, <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code> has specific requirements in order to support
<a href="rlang.html#topic+nse-defuse">quosures</a>. For this reason you can't supply bare
environments.
</p>
<p>There are two ways of constructing an rlang data mask manually:
</p>

<ul>
<li> <p><code>as_data_mask()</code> transforms a list or data frame to a data mask.
It automatically installs the data pronoun <code><a href="dplyr.html#topic+.data">.data</a></code>.
</p>
</li>
<li> <p><code>new_data_mask()</code> is a bare bones data mask constructor for
environments. You can supply a bottom and a top environment in
case your data mask comprises multiple environments (see section
below).
</p>
<p>Unlike <code>as_data_mask()</code> it does not install the <code>.data</code> pronoun
so you need to provide one yourself. You can provide a pronoun
constructed with <code>as_data_pronoun()</code> or your own pronoun class.
</p>
<p><code>as_data_pronoun()</code> will create a pronoun from a list, an
environment, or an rlang data mask. In the latter case, the whole
ancestry is looked up from the bottom to the top of the mask.
Functions stored in the mask are bypassed by the pronoun.
</p>
</li></ul>

<p>Once you have built a data mask, simply pass it to <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code> as
the <code>data</code> argument. You can repeat this as many times as
needed. Note that any objects created there (perhaps because of a
call to <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>) will persist in subsequent evaluations.
</p>


<h3>Top and bottom of data mask</h3>

<p>In some cases you'll need several levels in your data mask. One
good reason is when you include functions in the mask. It's a good
idea to keep data objects one level lower than function objects, so
that the former cannot override the definitions of the latter (see
examples).
</p>
<p>In that case, set up all your environments and keep track of the
bottom child and the top parent. You'll need to pass both to
<code>new_data_mask()</code>.
</p>
<p>Note that the parent of the top environment is completely
undetermined, you shouldn't expect it to remain the same at all
times. This parent is replaced during evaluation by <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code>
to one of the following environments:
</p>

<ul>
<li><p> The default environment passed as the <code>env</code> argument of <code>eval_tidy()</code>.
</p>
</li>
<li><p> The environment of the current quosure being evaluated, if applicable.
</p>
</li></ul>

<p>Consequently, all masking data should be contained between the
bottom and top environment of the data mask.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Evaluating in a tidy evaluation environment enables all tidy
# features:
mask &lt;- as_data_mask(mtcars)
eval_tidy(quo(letters), mask)

# You can install new pronouns in the mask:
mask$.pronoun &lt;- as_data_pronoun(list(foo = "bar", baz = "bam"))
eval_tidy(quo(.pronoun$foo), mask)

# In some cases the data mask can leak to the user, for example if
# a function or formula is created in the data mask environment:
cyl &lt;- "user variable from the context"
fn &lt;- eval_tidy(quote(function() cyl), mask)
fn()

# If new objects are created in the mask, they persist in the
# subsequent calls:
eval_tidy(quote(new &lt;- cyl + am), mask)
eval_tidy(quote(new * 2), mask)


# In some cases your data mask is a whole chain of environments
# rather than a single environment. You'll have to use
# `new_data_mask()` and let it know about the bottom of the mask
# (the last child of the environment chain) and the topmost parent.

# A common situation where you'll want a multiple-environment mask
# is when you include functions in your mask. In that case you'll
# put functions in the top environment and data in the bottom. This
# will prevent the data from overwriting the functions.
top &lt;- new_environment(list(`+` = base::paste, c = base::paste))

# Let's add a middle environment just for sport:
middle &lt;- env(top)

# And finally the bottom environment containing data:
bottom &lt;- env(middle, a = "a", b = "b", c = "c")

# We can now create a mask by supplying the top and bottom
# environments:
mask &lt;- new_data_mask(bottom, top = top)

# This data mask can be passed to eval_tidy() instead of a list or
# data frame:
eval_tidy(quote(a + b + c), data = mask)

# Note how the function `c()` and the object `c` are looked up
# properly because of the multi-level structure:
eval_tidy(quote(c(a, b, c)), data = mask)

# new_data_mask() does not create data pronouns, but
# data pronouns can be added manually:
mask$.fns &lt;- as_data_pronoun(top)

# The `.data` pronoun should generally be created from the
# mask. This will ensure data is looked up throughout the whole
# ancestry. Only non-function objects are looked up from this
# pronoun:
mask$.data &lt;- as_data_pronoun(mask)
mask$.data$c

# Now we can reference values with the pronouns:
eval_tidy(quote(c(.data$a, .data$b, .data$c)), data = mask)
</code></pre>

<hr>
<h2 id='as_environment'>Coerce to an environment</h2><span id='topic+as_environment'></span>

<h3>Description</h3>

<p><code>as_environment()</code> coerces named vectors (including lists) to an
environment. The names must be unique. If supplied an unnamed
string, it returns the corresponding package environment (see
<code><a href="pkgload.html#topic+pkg_env">pkg_env()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_environment(x, parent = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_environment_+3A_x">x</code></td>
<td>
<p>An object to coerce.</p>
</td></tr>
<tr><td><code id="as_environment_+3A_parent">parent</code></td>
<td>
<p>A parent environment, <code><a href="rlang.html#topic+empty_env">empty_env()</a></code> by default. This
argument is only used when <code>x</code> is data actually coerced to an
environment (as opposed to data representing an environment, like
<code>NULL</code> representing the empty environment).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is an environment and <code>parent</code> is not <code>NULL</code>, the
environment is duplicated before being set a new parent. The return
value is therefore a different environment than <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Coerce a named vector to an environment:
env &lt;- as_environment(mtcars)

# By default it gets the empty environment as parent:
identical(env_parent(env), empty_env())


# With strings it is a handy shortcut for pkg_env():
as_environment("base")
as_environment("rlang")

# With NULL it returns the empty environment:
as_environment(NULL)
</code></pre>

<hr>
<h2 id='as_function'>Convert to function</h2><span id='topic+as_function'></span><span id='topic+is_lambda'></span>

<h3>Description</h3>

<p><code>as_function()</code> transforms a one-sided formula into a function.
This powers the lambda syntax in packages like purrr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_function(
  x,
  env = global_env(),
  ...,
  arg = caller_arg(x),
  call = caller_env()
)

is_lambda(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_function_+3A_x">x</code></td>
<td>
<p>A function or formula.
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function
with up to two arguments: <code>.x</code> (single argument) or <code>.x</code> and <code>.y</code>
(two arguments). The <code>.</code> placeholder can be used instead of <code>.x</code>.
This allows you to create very compact anonymous functions (lambdas) with up
to two inputs. Functions created from formulas have a special
class. Use <code>is_lambda()</code> to test for it.
</p>
<p>If a <strong>string</strong>, the function is looked up in <code>env</code>. Note that
this interface is strictly for user convenience because of the
scoping issues involved. Package developers should avoid
supplying functions by name and instead supply them by value.</p>
</td></tr>
<tr><td><code id="as_function_+3A_env">env</code></td>
<td>
<p>Environment in which to fetch the function in case <code>x</code>
is a string.</p>
</td></tr>
<tr><td><code id="as_function_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="as_function_+3A_arg">arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
<tr><td><code id="as_function_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- as_function(~ .x + 1)
f(10)

g &lt;- as_function(~ -1 * .)
g(4)

h &lt;- as_function(~ .x - .y)
h(6, 3)

# Functions created from a formula have a special class:
is_lambda(f)
is_lambda(as_function(function() "foo"))
</code></pre>

<hr>
<h2 id='as_label'>Create a default name for an R object</h2><span id='topic+as_label'></span>

<h3>Description</h3>

<p><code>as_label()</code> transforms R objects into a short, human-readable
description. You can use labels to:
</p>

<ul>
<li><p> Display an object in a concise way, for example to labellise axes
in a graphical plot.
</p>
</li>
<li><p> Give default names to columns in a data frame. In this case,
labelling is the first step before name repair.
</p>
</li></ul>

<p>See also <code><a href="lazyeval.html#topic+as_name">as_name()</a></code> for transforming symbols back to a
string. Unlike <code>as_label()</code>, <code>as_name()</code> is a well defined
operation that guarantees the roundtrip symbol -&gt; string -&gt;
symbol.
</p>
<p>In general, if you don't know for sure what kind of object you're
dealing with (a call, a symbol, an unquoted constant), use
<code>as_label()</code> and make no assumption about the resulting string. If
you know you have a symbol and need the name of the object it
refers to, use <code><a href="lazyeval.html#topic+as_name">as_name()</a></code>. For instance, use <code>as_label()</code> with
objects captured with <code>enquo()</code> and <code>as_name()</code> with symbols
captured with <code>ensym()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_label(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_label_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Transformation to string</h3>


<ul>
<li><p> Quosures are <a href="rlang.html#topic+quo_squash">squashed</a> before being labelled.
</p>
</li>
<li><p> Symbols are transformed to string with <code>as_string()</code>.
</p>
</li>
<li><p> Calls are abbreviated.
</p>
</li>
<li><p> Numbers are represented as such.
</p>
</li>
<li><p> Other constants are represented by their type, such as <code style="white-space: pre;">&#8288;&lt;dbl&gt;&#8288;</code>
or <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="lazyeval.html#topic+as_name">as_name()</a></code> for transforming symbols back to a string
deterministically.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># as_label() is useful with quoted expressions:
as_label(expr(foo(bar)))

as_label(expr(foobar))

# It works with any R object. This is also useful for quoted
# arguments because the user might unquote constant objects:
as_label(1:3)

as_label(base::list)
</code></pre>

<hr>
<h2 id='as_name'>Extract names from symbols</h2><span id='topic+as_name'></span>

<h3>Description</h3>

<p><code>as_name()</code> converts <a href="dplyr.html#topic+sym">symbols</a> to character strings. The
conversion is deterministic. That is, the roundtrip <code>symbol -&gt; name -&gt; symbol</code> always gives the same result.
</p>

<ul>
<li><p> Use <code>as_name()</code> when you need to transform a symbol to a string
to <em>refer</em> to an object by its name.
</p>
</li>
<li><p> Use <code><a href="dplyr.html#topic+as_label">as_label()</a></code> when you need to transform any kind of object to
a string to <em>represent</em> that object with a short description.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>as_name(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_name_+3A_x">x</code></td>
<td>
<p>A string or symbol, possibly wrapped in a <a href="rlang.html#topic+quosure">quosure</a>.
If a string, the attributes are removed, if any.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rlang::as_name()</code> is the <em>opposite</em> of <code><a href="base.html#topic+name">base::as.name()</a></code>. If
you're writing base R code, we recommend using <code><a href="base.html#topic+name">base::as.symbol()</a></code>
which is an alias of <code>as.name()</code> that follows a more modern
terminology (R types instead of S modes).
</p>


<h3>Value</h3>

<p>A character vector of length 1.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+as_label">as_label()</a></code> for converting any object to a single string
suitable as a label. <code><a href="rlang.html#topic+as_string">as_string()</a></code> for a lower-level version that
doesn't unwrap quosures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let's create some symbols:
foo &lt;- quote(foo)
bar &lt;- sym("bar")

# as_name() converts symbols to strings:
foo
as_name(foo)

typeof(bar)
typeof(as_name(bar))

# as_name() unwraps quosured symbols automatically:
as_name(quo(foo))
</code></pre>

<hr>
<h2 id='as_string'>Cast symbol to string</h2><span id='topic+as_string'></span>

<h3>Description</h3>

<p><code>as_string()</code> converts <a href="dplyr.html#topic+sym">symbols</a> to character strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_string(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_string_+3A_x">x</code></td>
<td>
<p>A string or symbol. If a string, the attributes are
removed, if any.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length 1.
</p>


<h3>Unicode tags</h3>

<p>Unlike <code><a href="base.html#topic+name">base::as.symbol()</a></code> and <code><a href="base.html#topic+name">base::as.name()</a></code>, <code>as_string()</code>
automatically transforms unicode tags such as <code>"&lt;U+5E78&gt;"</code> to the
proper UTF-8 character. This is important on Windows because:
</p>

<ul>
<li><p> R on Windows has no UTF-8 support, and uses native encoding instead.
</p>
</li>
<li><p> The native encodings do not cover all Unicode characters. For
example, Western encodings do not support CKJ characters.
</p>
</li>
<li><p> When a lossy UTF-8 -&gt; native transformation occurs, uncovered
characters are transformed to an ASCII unicode tag like <code>"&lt;U+5E78&gt;"</code>.
</p>
</li>
<li><p> Symbols are always encoded in native. This means that
transforming the column names of a data frame to symbols might be
a lossy operation.
</p>
</li>
<li><p> This operation is very common in the tidyverse because of data
masking APIs like dplyr where data frames are transformed to
environments. While the names of a data frame are stored as a
character vector, the bindings of environments are stored as
symbols.
</p>
</li></ul>

<p>Because it reencodes the ASCII unicode tags to their UTF-8
representation, the string -&gt; symbol -&gt; string roundtrip is
more stable with <code>as_string()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="lazyeval.html#topic+as_name">as_name()</a></code> for a higher-level variant of <code>as_string()</code>
that automatically unwraps quosures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let's create some symbols:
foo &lt;- quote(foo)
bar &lt;- sym("bar")

# as_string() converts symbols to strings:
foo
as_string(foo)

typeof(bar)
typeof(as_string(bar))
</code></pre>

<hr>
<h2 id='as_utf8_character'>Coerce to a character vector and attempt encoding conversion</h2><span id='topic+as_utf8_character'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Unlike specifying the <code>encoding</code> argument in <code>as_string()</code> and
<code>as_character()</code>, which is only declarative, these functions
actually attempt to convert the encoding of their input. There are
two possible cases:
</p>

<ul>
<li><p> The string is tagged as UTF-8 or latin1, the only two encodings
for which R has specific support. In this case, converting to the
same encoding is a no-op, and converting to native always works
as expected, as long as the native encoding, the one specified by
the <code>LC_CTYPE</code> locale has support for all characters occurring in
the strings. Unrepresentable characters are serialised as unicode
points: &quot;&lt;U+xxxx&gt;&quot;.
</p>
</li>
<li><p> The string is not tagged. R assumes that it is encoded in the
native encoding. Conversion to native is a no-op, and conversion
to UTF-8 should work as long as the string is actually encoded in
the locale codeset.
</p>
</li></ul>

<p>When translating to UTF-8, the strings are parsed for serialised
unicode points (e.g. strings looking like &quot;U+xxxx&quot;) with
<code><a href="rlang.html#topic+chr_unserialise_unicode">chr_unserialise_unicode()</a></code>. This helps to alleviate the effects of
character-to-symbol-to-character roundtrips on systems with
non-UTF-8 native encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_utf8_character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_utf8_character_+3A_x">x</code></td>
<td>
<p>An object to coerce.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Let's create a string marked as UTF-8 (which is guaranteed by the
# Unicode escaping in the string):
utf8 &lt;- "caf\uE9"
Encoding(utf8)
charToRaw(utf8)
</code></pre>

<hr>
<h2 id='bare-type-predicates'>Bare type predicates</h2><span id='topic+bare-type-predicates'></span><span id='topic+is_bare_list'></span><span id='topic+is_bare_atomic'></span><span id='topic+is_bare_vector'></span><span id='topic+is_bare_double'></span><span id='topic+is_bare_complex'></span><span id='topic+is_bare_integer'></span><span id='topic+is_bare_numeric'></span><span id='topic+is_bare_character'></span><span id='topic+is_bare_logical'></span><span id='topic+is_bare_raw'></span><span id='topic+is_bare_string'></span><span id='topic+is_bare_bytes'></span>

<h3>Description</h3>

<p>These predicates check for a given type but only return <code>TRUE</code> for
bare R objects. Bare objects have no class attributes. For example,
a data frame is a list, but not a bare list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_bare_list(x, n = NULL)

is_bare_atomic(x, n = NULL)

is_bare_vector(x, n = NULL)

is_bare_double(x, n = NULL)

is_bare_complex(x, n = NULL)

is_bare_integer(x, n = NULL)

is_bare_numeric(x, n = NULL)

is_bare_character(x, n = NULL)

is_bare_logical(x, n = NULL)

is_bare_raw(x, n = NULL)

is_bare_string(x, n = NULL)

is_bare_bytes(x, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bare-type-predicates_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
<tr><td><code id="bare-type-predicates_+3A_n">n</code></td>
<td>
<p>Expected length of a vector.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The predicates for vectors include the <code>n</code> argument for
pattern-matching on the vector length.
</p>
</li>
<li><p> Like <code><a href="lazyeval.html#topic+is_atomic">is_atomic()</a></code> and unlike base R <code>is.atomic()</code>,
<code>is_bare_atomic()</code> does not return <code>TRUE</code> for <code>NULL</code>.
</p>
</li>
<li><p> Unlike base R <code>is.numeric()</code>, <code>is_bare_double()</code> only returns
<code>TRUE</code> for floating point numbers.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="rlang.html#topic+type-predicates">type-predicates</a>, <a href="rlang.html#topic+scalar-type-predicates">scalar-type-predicates</a>
</p>

<hr>
<h2 id='box'>Box a value</h2><span id='topic+box'></span><span id='topic+new_box'></span><span id='topic+is_box'></span><span id='topic+unbox'></span>

<h3>Description</h3>

<p><code>new_box()</code> is similar to <code><a href="base.html#topic+AsIs">base::I()</a></code> but it protects a value by
wrapping it in a scalar list rather than by adding an attribute.
<code>unbox()</code> retrieves the boxed value. <code>is_box()</code> tests whether an
object is boxed with optional class. <code>as_box()</code> ensures that a
value is wrapped in a box. <code>as_box_if()</code> does the same but only if
the value matches a predicate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_box(.x, class = NULL, ...)

is_box(x, class = NULL)

unbox(box)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="box_+3A_class">class</code></td>
<td>
<p>For <code>new_box()</code>, an additional class for the
boxed value (in addition to <code>rlang_box</code>). For <code>is_box()</code>, a class
or vector of classes passed to <code><a href="rlang.html#topic+inherits_all">inherits_all()</a></code>.</p>
</td></tr>
<tr><td><code id="box_+3A_...">...</code></td>
<td>
<p>Additional attributes passed to <code><a href="base.html#topic+structure">base::structure()</a></code>.</p>
</td></tr>
<tr><td><code id="box_+3A_x">x</code>, <code id="box_+3A_.x">.x</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="box_+3A_box">box</code></td>
<td>
<p>A boxed value to unbox.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>boxed &lt;- new_box(letters, "mybox")
is_box(boxed)
is_box(boxed, "mybox")
is_box(boxed, "otherbox")

unbox(boxed)

# as_box() avoids double-boxing:
boxed2 &lt;- as_box(boxed, "mybox")
boxed2
unbox(boxed2)

# Compare to:
boxed_boxed &lt;- new_box(boxed, "mybox")
boxed_boxed
unbox(unbox(boxed_boxed))

# Use `as_box_if()` with a predicate if you need to ensure a box
# only for a subset of values:
as_box_if(NULL, is_null, "null_box")
as_box_if("foo", is_null, "null_box")
</code></pre>

<hr>
<h2 id='bytes-class'>Human readable memory sizes</h2><span id='topic+bytes-class'></span><span id='topic+as_bytes'></span><span id='topic+parse_bytes'></span>

<h3>Description</h3>

<p>Construct, manipulate and display vectors of byte sizes. These are numeric
vectors, so you can compare them numerically, but they can also be compared
to human readable values such as '10MB'.
</p>

<ul>
<li> <p><code>parse_bytes()</code> takes a character vector of human-readable bytes
and returns a structured bytes vector.
</p>
</li>
<li> <p><code>as_bytes()</code> is a generic conversion function for objects
representing bytes.
</p>
</li></ul>

<p>Note: A <code>bytes()</code> constructor will be exported soon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_bytes(x)

parse_bytes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bytes-class_+3A_x">x</code></td>
<td>
<p>A numeric or character vector. Character representations can use
shorthand sizes (see examples).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These memory sizes are always assumed to be base 1000, rather than 1024.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_bytes("1")
parse_bytes("1K")
parse_bytes("1Kb")
parse_bytes("1KiB")
parse_bytes("1MB")

parse_bytes("1KB") &lt; "1MB"

sum(parse_bytes(c("1MB", "5MB", "500KB")))
</code></pre>

<hr>
<h2 id='call_args'>Extract arguments from a call</h2><span id='topic+call_args'></span><span id='topic+call_args_names'></span>

<h3>Description</h3>

<p>Extract arguments from a call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_args(call)

call_args_names(call)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_args_+3A_call">call</code></td>
<td>
<p>A defused call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of arguments.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+fn_fmls">fn_fmls()</a></code> and <code><a href="rlang.html#topic+fn_fmls_names">fn_fmls_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>call &lt;- quote(f(a, b))

# Subsetting a call returns the arguments converted to a language
# object:
call[-1]

# On the other hand, call_args() returns a regular list that is
# often easier to work with:
str(call_args(call))

# When the arguments are unnamed, a vector of empty strings is
# supplied (rather than NULL):
call_args_names(call)
</code></pre>

<hr>
<h2 id='call_fn'>Extract function from a call</h2><span id='topic+call_fn'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Deprecated in rlang 0.4.11.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_fn(call, env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_fn_+3A_call">call</code>, <code id="call_fn_+3A_env">env</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>

<hr>
<h2 id='call_inspect'>Inspect a call</h2><span id='topic+call_inspect'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code><a href="base.html#topic+match.call">base::match.call()</a></code>. It returns
its own function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_inspect(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_inspect_+3A_...">...</code></td>
<td>
<p>Arguments to display in the returned call.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># When you call it directly, it simply returns what you typed
call_inspect(foo(bar), "" %&gt;% identity())

# Pass `call_inspect` to functionals like `lapply()` or `map()` to
# inspect the calls they create around the supplied function
lapply(1:3, call_inspect)
</code></pre>

<hr>
<h2 id='call_match'>Match supplied arguments to function definition</h2><span id='topic+call_match'></span>

<h3>Description</h3>

<p><code>call_match()</code> is like <code><a href="base.html#topic+match.call">match.call()</a></code> with these differences:
</p>

<ul>
<li><p> It supports matching missing argument to their defaults in the
function definition.
</p>
</li>
<li><p> It requires you to be a little more specific in some cases.
Either all arguments are inferred from the call stack or none of
them are (see the Inference section).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>call_match(
  call = NULL,
  fn = NULL,
  ...,
  defaults = FALSE,
  dots_env = NULL,
  dots_expand = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_match_+3A_call">call</code></td>
<td>
<p>A call. The arguments will be matched to <code>fn</code>.</p>
</td></tr>
<tr><td><code id="call_match_+3A_fn">fn</code></td>
<td>
<p>A function definition to match arguments to.</p>
</td></tr>
<tr><td><code id="call_match_+3A_...">...</code></td>
<td>
<p>These dots must be empty.</p>
</td></tr>
<tr><td><code id="call_match_+3A_defaults">defaults</code></td>
<td>
<p>Whether to match missing arguments to their
defaults.</p>
</td></tr>
<tr><td><code id="call_match_+3A_dots_env">dots_env</code></td>
<td>
<p>An execution environment where to find dots. If
supplied and dots exist in this environment, and if <code>call</code>
includes <code>...</code>, the forwarded dots are matched to numbered dots
(e.g. <code>..1</code>, <code>..2</code>, etc). By default this is set to the empty
environment which means that <code>...</code> expands to nothing.</p>
</td></tr>
<tr><td><code id="call_match_+3A_dots_expand">dots_expand</code></td>
<td>
<p>If <code>FALSE</code>, arguments passed through <code>...</code> will
not be spliced into <code>call</code>. Instead, they are gathered in a
pairlist and assigned to an argument named <code>...</code>. Gathering dots
arguments is useful if you need to separate them from the other
named arguments.
</p>
<p>Note that the resulting call is not meant to be evaluated since R
does not support passing dots through a named argument, even if
named <code>"..."</code>.</p>
</td></tr>
</table>


<h3>Inference from the call stack</h3>

<p>When <code>call</code> is not supplied, it is inferred from the call stack
along with <code>fn</code> and <code>dots_env</code>.
</p>

<ul>
<li> <p><code>call</code> and <code>fn</code> are inferred from the calling environment:
<code>sys.call(sys.parent())</code> and <code>sys.function(sys.parent())</code>.
</p>
</li>
<li> <p><code>dots_env</code> is inferred from the caller of the calling
environment: <code>caller_env(2)</code>.
</p>
</li></ul>

<p>If <code>call</code> is supplied, then you must supply <code>fn</code> as well. Also
consider supplying <code>dots_env</code> as it is set to the empty environment
when not inferred.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `call_match()` supports matching missing arguments to their
# defaults
fn &lt;- function(x = "default") fn
call_match(quote(fn()), fn)
call_match(quote(fn()), fn, defaults = TRUE)
</code></pre>

<hr>
<h2 id='call_modify'>Modify the arguments of a call</h2><span id='topic+call_modify'></span>

<h3>Description</h3>

<p>If you are working with a user-supplied call, make sure the
arguments are standardised with <code><a href="rlang.html#topic+call_match">call_match()</a></code> before
modifying the call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_modify(
  .call,
  ...,
  .homonyms = c("keep", "first", "last", "error"),
  .standardise = NULL,
  .env = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_modify_+3A_.call">.call</code></td>
<td>
<p>Can be a call, a formula quoting a call in the
right-hand side, or a frame object from which to extract the call
expression.</p>
</td></tr>
<tr><td><code id="call_modify_+3A_...">...</code></td>
<td>
<p>&lt;<a href="rlang.html#topic+dyn-dots">dynamic</a>&gt; Named or unnamed expressions
(constants, names or calls) used to modify the call. Use <code><a href="purrr.html#topic+zap">zap()</a></code>
to remove arguments. Empty arguments are preserved.</p>
</td></tr>
<tr><td><code id="call_modify_+3A_.homonyms">.homonyms</code></td>
<td>
<p>How to treat arguments with the same name. The
default, <code>"keep"</code>, preserves these arguments. Set <code>.homonyms</code> to
<code>"first"</code> to only keep the first occurrences, to <code>"last"</code> to keep
the last occurrences, and to <code>"error"</code> to raise an informative
error and indicate what arguments have duplicated names.</p>
</td></tr>
<tr><td><code id="call_modify_+3A_.standardise">.standardise</code>, <code id="call_modify_+3A_.env">.env</code></td>
<td>
<p>Deprecated as of rlang 0.3.0. Please
call <code><a href="rlang.html#topic+call_match">call_match()</a></code> manually.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A quosure if <code>.call</code> is a quosure, a call otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>call &lt;- quote(mean(x, na.rm = TRUE))

# Modify an existing argument
call_modify(call, na.rm = FALSE)
call_modify(call, x = quote(y))

# Remove an argument
call_modify(call, na.rm = zap())

# Add a new argument
call_modify(call, trim = 0.1)

# Add an explicit missing argument:
call_modify(call, na.rm = )

# Supply a list of new arguments with `!!!`
newargs &lt;- list(na.rm = NULL, trim = 0.1)
call &lt;- call_modify(call, !!!newargs)
call

# Remove multiple arguments by splicing zaps:
newargs &lt;- rep_named(c("na.rm", "trim"), list(zap()))
call &lt;- call_modify(call, !!!newargs)
call


# Modify the `...` arguments as if it were a named argument:
call &lt;- call_modify(call, ... = )
call

call &lt;- call_modify(call, ... = zap())
call


# When you're working with a user-supplied call, standardise it
# beforehand in case it includes unmatched arguments:
user_call &lt;- quote(matrix(x, nc = 3))
call_modify(user_call, ncol = 1)

# `call_match()` applies R's argument matching rules. Matching
# ensures you're modifying the intended argument.
user_call &lt;- call_match(user_call, matrix)
user_call
call_modify(user_call, ncol = 1)


# By default, arguments with the same name are kept. This has
# subtle implications, for instance you can move an argument to
# last position by removing it and remapping it:
call &lt;- quote(foo(bar = , baz))
call_modify(call, bar = NULL, bar = missing_arg())

# You can also choose to keep only the first or last homonym
# arguments:
args &lt;-  list(bar = NULL, bar = missing_arg())
call_modify(call, !!!args, .homonyms = "first")
call_modify(call, !!!args, .homonyms = "last")
</code></pre>

<hr>
<h2 id='call_name'>Extract function name or namespace of a call</h2><span id='topic+call_name'></span><span id='topic+call_ns'></span><span id='topic+is_call_simple'></span>

<h3>Description</h3>

<p><code>call_name()</code> and <code>call_ns()</code> extract the function name or
namespace of <em>simple</em> calls as a string. They return <code>NULL</code> for
complex calls.
</p>

<ul>
<li><p> Simple calls: <code>foo()</code>, <code>bar::foo()</code>.
</p>
</li>
<li><p> Complex calls: <code>foo()()</code>, <code>bar::foo</code>, <code>foo$bar()</code>, <code>(function() NULL)()</code>.
</p>
</li></ul>

<p>The <code>is_call_simple()</code> predicate helps you determine whether a call
is simple. There are two invariants you can count on:
</p>

<ol>
<li><p> If <code>is_call_simple(x)</code> returns <code>TRUE</code>, <code>call_name(x)</code> returns a
string. Otherwise it returns <code>NULL</code>.
</p>
</li>
<li><p> If <code>is_call_simple(x, ns = TRUE)</code> returns <code>TRUE</code>, <code>call_ns()</code>
returns a string. Otherwise it returns <code>NULL</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>call_name(call)

call_ns(call)

is_call_simple(x, ns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_name_+3A_call">call</code></td>
<td>
<p>A defused call.</p>
</td></tr>
<tr><td><code id="call_name_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
<tr><td><code id="call_name_+3A_ns">ns</code></td>
<td>
<p>Whether call is namespaced. If <code>NULL</code>, <code>is_call_simple()</code>
is insensitive to namespaces. If <code>TRUE</code>, <code>is_call_simple()</code>
detects namespaced calls. If <code>FALSE</code>, it detects unnamespaced
calls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function name or namespace as a string, or <code>NULL</code> if
the call is not named or namespaced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Is the function named?
is_call_simple(quote(foo()))
is_call_simple(quote(foo[[1]]()))

# Is the function namespaced?
is_call_simple(quote(list()), ns = TRUE)
is_call_simple(quote(base::list()), ns = TRUE)

# Extract the function name from quoted calls:
call_name(quote(foo(bar)))
call_name(quo(foo(bar)))

# Namespaced calls are correctly handled:
call_name(quote(base::matrix(baz)))

# Anonymous and subsetted functions return NULL:
call_name(quote(foo$bar()))
call_name(quote(foo[[bar]]()))
call_name(quote(foo()()))

# Extract namespace of a call with call_ns():
call_ns(quote(base::bar()))

# If not namespaced, call_ns() returns NULL:
call_ns(quote(bar()))
</code></pre>

<hr>
<h2 id='call_standardise'>Standardise a call</h2><span id='topic+call_standardise'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Deprecated in rlang 0.4.11 in favour of <code><a href="rlang.html#topic+call_match">call_match()</a></code>.
<code>call_standardise()</code> was designed for call wrappers that include an
environment like formulas or quosures. The function definition was
plucked from that environment. However in practice it is rare to
use it with wrapped calls, and then it's easy to forget to supply
the environment. For these reasons, we have designed <code><a href="rlang.html#topic+call_match">call_match()</a></code>
as a simpler wrapper around <code><a href="base.html#topic+match.call">match.call()</a></code>.
</p>
<p>This is essentially equivalent to <code><a href="base.html#topic+match.call">base::match.call()</a></code>, but with
experimental handling of primitive functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_standardise(call, env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_standardise_+3A_call">call</code>, <code id="call_standardise_+3A_env">env</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A quosure if <code>call</code> is a quosure, a raw call otherwise.
</p>

<hr>
<h2 id='call2'>Create a call</h2><span id='topic+call2'></span>

<h3>Description</h3>

<p>Quoted function calls are one of the two types of
<a href="rlang.html#topic+is_symbolic">symbolic</a> objects in R. They represent the action of
calling a function, possibly with arguments. There are two ways of
creating a quoted call:
</p>

<ul>
<li><p> By <a href="rlang.html#topic+nse-defuse">quoting</a> it. Quoting prevents functions from being
called. Instead, you get the description of the function call as
an R object. That is, a quoted function call.
</p>
</li>
<li><p> By constructing it with <code><a href="base.html#topic+call">base::call()</a></code>, <code><a href="base.html#topic+call">base::as.call()</a></code>, or
<code>call2()</code>. In this case, you pass the call elements (the function
to call and the arguments to call it with) separately.
</p>
</li></ul>

<p>See section below for the difference between <code>call2()</code> and the base
constructors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call2(.fn, ..., .ns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call2_+3A_.fn">.fn</code></td>
<td>
<p>Function to call. Must be a callable object: a string,
symbol, call, or a function.</p>
</td></tr>
<tr><td><code id="call2_+3A_...">...</code></td>
<td>
<p>&lt;<a href="rlang.html#topic+dyn-dots">dynamic</a>&gt; Arguments for the function
call. Empty arguments are preserved.</p>
</td></tr>
<tr><td><code id="call2_+3A_.ns">.ns</code></td>
<td>
<p>Namespace with which to prefix <code>.fn</code>. Must be a string
or symbol.</p>
</td></tr>
</table>


<h3>Difference with base constructors</h3>

<p><code>call2()</code> is more flexible than <code>base::call()</code>:
</p>

<ul>
<li><p> The function to call can be a string or a <a href="rlang.html#topic+is_callable">callable</a>
object: a symbol, another call (e.g. a <code>$</code> or <code>[[</code> call), or a
function to inline. <code>base::call()</code> only supports strings and you
need to use <code>base::as.call()</code> to construct a call with a callable
object.
</p>
<div class="sourceCode"><pre>call2(list, 1, 2)

as.call(list(list, 1, 2))
</pre></div>
</li>
<li><p> The <code>.ns</code> argument is convenient for creating namespaced calls.
</p>
<div class="sourceCode"><pre>call2("list", 1, 2, .ns = "base")

# Equivalent to
ns_call &lt;- call("::", as.symbol("list"), as.symbol("base"))
as.call(list(ns_call, 1, 2))
</pre></div>
</li>
<li> <p><code>call2()</code> has <a href="rlang.html#topic+list2">dynamic dots</a> support. You can splice lists
of arguments with <code style="white-space: pre;">&#8288;!!!&#8288;</code> or unquote an argument name with glue
syntax.
</p>
<div class="sourceCode"><pre>args &lt;- list(na.rm = TRUE, trim = 0)

call2("mean", 1:10, !!!args)

# Equivalent to
as.call(c(list(as.symbol("mean"), 1:10), args))
</pre></div>
</li></ul>



<h3>Caveats of inlining objects in calls</h3>

<p><code>call2()</code> makes it possible to inline objects in calls, both in
function and argument positions. Inlining an object or a function
has the advantage that the correct object is used in all
environments. If all components of the code are inlined, you can
even evaluate in the <a href="rlang.html#topic+empty_env">empty environment</a>.
</p>
<p>However inlining also has drawbacks. It can cause issues with NSE
functions that expect symbolic arguments. The objects may also leak
in representations of the call stack, such as <code><a href="base.html#topic+traceback">traceback()</a></code>.
</p>


<h3>See Also</h3>

<p>call_modify
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fn can either be a string, a symbol or a call
call2("f", a = 1)
call2(quote(f), a = 1)
call2(quote(f()), a = 1)

#' Can supply arguments individually or in a list
call2(quote(f), a = 1, b = 2)
call2(quote(f), !!!list(a = 1, b = 2))

# Creating namespaced calls is easy:
call2("fun", arg = quote(baz), .ns = "mypkg")

# Empty arguments are preserved:
call2("[", quote(x), , drop = )
</code></pre>

<hr>
<h2 id='caller_arg'>Find the caller argument for error messages</h2><span id='topic+caller_arg'></span>

<h3>Description</h3>

<p><code>caller_arg()</code> is a variant of <code>substitute()</code> or <code><a href="dplyr.html#topic+ensym">ensym()</a></code> for
arguments that reference other arguments. Unlike <code>substitute()</code>
which returns an expression, <code>caller_arg()</code> formats the expression
as a single line string which can be included in error messages.
</p>

<ul>
<li><p> When included in an error message, the resulting label should
generally be formatted as argument, for instance using the <code>.arg</code>
in the cli package.
</p>
</li>
<li><p> Use <code style="white-space: pre;">&#8288;@inheritParams rlang::args_error_context&#8288;</code> to document an
<code>arg</code> or <code>error_arg</code> argument that takes <code>error_arg()</code> as default.
</p>
</li></ul>



<h3>Arguments</h3>

<table>
<tr><td><code id="caller_arg_+3A_arg">arg</code></td>
<td>
<p>An argument name in the current function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>arg_checker &lt;- function(x, arg = caller_arg(x), call = caller_env()) {
  cli::cli_abort("{.arg {arg}} must be a thingy.", arg = arg, call = call)
}

my_function &lt;- function(my_arg) {
  arg_checker(my_arg)
}

try(my_function(NULL))
</code></pre>

<hr>
<h2 id='catch_cnd'>Catch a condition</h2><span id='topic+catch_cnd'></span>

<h3>Description</h3>

<p>This is a small wrapper around <code>tryCatch()</code> that captures any
condition signalled while evaluating its argument. It is useful for
situations where you expect a specific condition to be signalled,
for debugging, and for unit testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catch_cnd(expr, classes = "condition")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catch_cnd_+3A_expr">expr</code></td>
<td>
<p>Expression to be evaluated with a catching condition
handler.</p>
</td></tr>
<tr><td><code id="catch_cnd_+3A_classes">classes</code></td>
<td>
<p>A character vector of condition classes to catch. By
default, catches all conditions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A condition if any was signalled, <code>NULL</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>catch_cnd(10)
catch_cnd(abort("an error"))
catch_cnd(signal("my_condition", message = "a condition"))
</code></pre>

<hr>
<h2 id='check_dots_empty'>Check that dots are empty</h2><span id='topic+check_dots_empty'></span>

<h3>Description</h3>

<p><code>...</code> can be inserted in a function signature to force users to
fully name the details arguments. In this case, supplying data in
<code>...</code> is almost always a programming error. This function checks
that <code>...</code> is empty and fails otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dots_empty(
  env = caller_env(),
  error = NULL,
  call = caller_env(),
  action = abort
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_dots_empty_+3A_env">env</code></td>
<td>
<p>Environment in which to look for <code>...</code>.</p>
</td></tr>
<tr><td><code id="check_dots_empty_+3A_error">error</code></td>
<td>
<p>An optional error handler passed to <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>. Use
this e.g. to demote an error into a warning.</p>
</td></tr>
<tr><td><code id="check_dots_empty_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="check_dots_empty_+3A_action">action</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In packages, document <code>...</code> with this standard tag:
</p>
<div class="sourceCode"><pre> @inheritParams rlang::args_dots_empty
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x, ..., foofy = 8) {
  check_dots_empty()
  x + foofy
}

# This fails because `foofy` can't be matched positionally
try(f(1, 4))

# This fails because `foofy` can't be matched partially by name
try(f(1, foof = 4))

# Thanks to `...`, it must be matched exactly
f(1, foofy = 4)

</code></pre>

<hr>
<h2 id='check_dots_empty0'>Check that dots are empty (low level variant)</h2><span id='topic+check_dots_empty0'></span>

<h3>Description</h3>

<p><code>check_dots_empty0()</code> is a more efficient version of
<code><a href="ellipsis.html#topic+check_dots_empty">check_dots_empty()</a></code> with a slightly different interface. Instead
of inspecting the current environment for dots, it directly takes
<code>...</code>. It is only meant for very low level functions where a
couple microseconds make a difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dots_empty0(..., call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_dots_empty0_+3A_...">...</code></td>
<td>
<p>Dots which should be empty.</p>
</td></tr>
</table>

<hr>
<h2 id='check_dots_unnamed'>Check that all dots are unnamed</h2><span id='topic+check_dots_unnamed'></span>

<h3>Description</h3>

<p>In functions like <code>paste()</code>, named arguments in <code>...</code> are often a
sign of misspelled argument names. Call <code>check_dots_unnamed()</code> to
fail with an error when named arguments are detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dots_unnamed(
  env = caller_env(),
  error = NULL,
  call = caller_env(),
  action = abort
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_dots_unnamed_+3A_env">env</code></td>
<td>
<p>Environment in which to look for <code>...</code>.</p>
</td></tr>
<tr><td><code id="check_dots_unnamed_+3A_error">error</code></td>
<td>
<p>An optional error handler passed to <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>. Use
this e.g. to demote an error into a warning.</p>
</td></tr>
<tr><td><code id="check_dots_unnamed_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="check_dots_unnamed_+3A_action">action</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(..., foofy = 8) {
  check_dots_unnamed()
  c(...)
}

f(1, 2, 3, foofy = 4)

try(f(1, 2, 3, foof = 4))
</code></pre>

<hr>
<h2 id='check_dots_used'>Check that all dots have been used</h2><span id='topic+check_dots_used'></span>

<h3>Description</h3>

<p>When <code>...</code> arguments are passed to methods, it is assumed there
method will match and use these arguments. If this isn't the case,
this often indicates a programming error. Call <code>check_dots_used()</code>
to fail with an error when unused arguments are detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dots_used(
  env = caller_env(),
  call = caller_env(),
  error = NULL,
  action = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_dots_used_+3A_env">env</code></td>
<td>
<p>Environment in which to look for <code>...</code> and to set up handler.</p>
</td></tr>
<tr><td><code id="check_dots_used_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="check_dots_used_+3A_error">error</code></td>
<td>
<p>An optional error handler passed to <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>. Use
this e.g. to demote an error into a warning.</p>
</td></tr>
<tr><td><code id="check_dots_used_+3A_action">action</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In packages, document <code>...</code> with this standard tag:
</p>
<div class="sourceCode"><pre> @inheritParams rlang::args_dots_used
</pre></div>
<p><code>check_dots_used()</code> implicitly calls <code><a href="base.html#topic+on.exit">on.exit()</a></code> to check that all
elements of <code>...</code> have been used when the function exits. If you
use <code><a href="base.html#topic+on.exit">on.exit()</a></code> elsewhere in your function, make sure to use <code>add = TRUE</code> so that you don't override the handler set up by
<code>check_dots_used()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(...) {
  check_dots_used()
  g(...)
}

g &lt;- function(x, y, ...) {
  x + y
}
f(x = 1, y = 2)

try(f(x = 1, y = 2, z = 3))

try(f(x = 1, y = 2, 3, 4, 5))

# Use an `error` handler to handle the error differently.
# For instance to demote the error to a warning:
fn &lt;- function(...) {
  check_dots_empty(
    error = function(cnd) {
      warning(cnd)
    }
  )
  "out"
}
fn()

</code></pre>

<hr>
<h2 id='check_exclusive'>Check that arguments are mutually exclusive</h2><span id='topic+check_exclusive'></span>

<h3>Description</h3>

<p><code>check_exclusive()</code> checks that only one argument is supplied out of
a set of mutually exclusive arguments. An informative error is
thrown if multiple arguments are supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_exclusive(..., .require = TRUE, .frame = caller_env(), .call = .frame)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_exclusive_+3A_...">...</code></td>
<td>
<p>Function arguments.</p>
</td></tr>
<tr><td><code id="check_exclusive_+3A_.require">.require</code></td>
<td>
<p>Whether at least one argument must be supplied.</p>
</td></tr>
<tr><td><code id="check_exclusive_+3A_.frame">.frame</code></td>
<td>
<p>Environment where the arguments in <code>...</code> are defined.</p>
</td></tr>
<tr><td><code id="check_exclusive_+3A_.call">.call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The supplied argument name as a string. If <code>.require</code> is
<code>FALSE</code> and no argument is supplied, the empty string <code>""</code> is
returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x, y) {
  switch(
    check_exclusive(x, y),
    x = message("`x` was supplied."),
    y = message("`y` was supplied.")
  )
}

# Supplying zero or multiple arguments is forbidden
try(f())
try(f(NULL, NULL))

# The user must supply one of the mutually exclusive arguments
f(NULL)
f(y = NULL)


# With `.require` you can allow zero arguments
f &lt;- function(x, y) {
  switch(
    check_exclusive(x, y, .require = FALSE),
    x = message("`x` was supplied."),
    y = message("`y` was supplied."),
    message("No arguments were supplied")
  )
}
f()
</code></pre>

<hr>
<h2 id='check_required'>Check that argument is supplied</h2><span id='topic+check_required'></span>

<h3>Description</h3>

<p>Throws an error if <code>x</code> is missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_required(x, arg = caller_arg(x), call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_required_+3A_x">x</code></td>
<td>
<p>A function argument. Must be a symbol.</p>
</td></tr>
<tr><td><code id="check_required_+3A_arg">arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
<tr><td><code id="check_required_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+arg_match">arg_match()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x)  {
  check_required(x)
}

# Fails because `x` is not supplied
try(f())

# Succeeds
f(NULL)
</code></pre>

<hr>
<h2 id='child_env'>Create a child environment</h2><span id='topic+child_env'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code><a href="rlang.html#topic+env">env()</a></code> now supports creating child environments, please use it
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>child_env(.parent, ...)
</code></pre>

<hr>
<h2 id='chr_unserialise_unicode'>Translate unicode points to UTF-8</h2><span id='topic+chr_unserialise_unicode'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>For historical reasons, R translates strings to the native encoding
when they are converted to symbols. This string-to-symbol
conversion is not a rare occurrence and happens for instance to the
names of a list of arguments converted to a call by <code>do.call()</code>.
</p>
<p>If the string contains unicode characters that cannot be
represented in the native encoding, R serialises those as an ASCII
sequence representing the unicode point. This is why Windows users
with western locales often see strings looking like <code style="white-space: pre;">&#8288;&lt;U+xxxx&gt;&#8288;</code>. To
alleviate some of the pain, rlang parses strings and looks for
serialised unicode points to translate them back to the proper
UTF-8 representation. This transformation occurs automatically in
functions like <code><a href="rlang.html#topic+env_names">env_names()</a></code> and can be manually triggered with
<code>as_utf8_character()</code> and <code>chr_unserialise_unicode()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chr_unserialise_unicode(chr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chr_unserialise_unicode_+3A_chr">chr</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Life cycle</h3>

<p>This function is experimental.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ascii &lt;- "&lt;U+5E78&gt;"
chr_unserialise_unicode(ascii)

identical(chr_unserialise_unicode(ascii), "\u5e78")
</code></pre>

<hr>
<h2 id='cnd'>Create a condition object</h2><span id='topic+cnd'></span><span id='topic+error_cnd'></span><span id='topic+warning_cnd'></span><span id='topic+message_cnd'></span>

<h3>Description</h3>

<p>These constructors create subclassed conditions, the objects that
power the error, warning, and message system in R.
</p>

<ul>
<li> <p><code>cnd()</code> creates bare conditions that only inherit from
<code>condition</code>.
</p>
</li>
<li><p> Conditions created with <code>error_cnd()</code>, <code>warning_cnd()</code>, and
<code>message_cnd()</code> inherit from <code>"error"</code>, <code>"warning"</code>, or <code>"message"</code>.
</p>
</li>
<li> <p><code>error_cnd()</code> creates subclassed errors. See
<code><a href="rlang.html#topic+rlang_error">&quot;rlang_error&quot;</a></code>.
</p>
</li></ul>

<p>Use <code><a href="rlang.html#topic+cnd_signal">cnd_signal()</a></code> to emit the relevant signal for a particular
condition class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnd(class, ..., message = "", call = NULL, use_cli_format = NULL)

error_cnd(
  class = NULL,
  ...,
  message = "",
  call = NULL,
  trace = NULL,
  parent = NULL,
  use_cli_format = NULL
)

warning_cnd(
  class = NULL,
  ...,
  message = "",
  call = NULL,
  use_cli_format = NULL
)

message_cnd(
  class = NULL,
  ...,
  message = "",
  call = NULL,
  use_cli_format = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnd_+3A_class">class</code></td>
<td>
<p>The condition subclass.</p>
</td></tr>
<tr><td><code id="cnd_+3A_...">...</code></td>
<td>
<p>&lt;<a href="rlang.html#topic+dyn-dots">dynamic</a>&gt; Named data fields stored inside
the condition object.</p>
</td></tr>
<tr><td><code id="cnd_+3A_message">message</code></td>
<td>
<p>A default message to inform the user about the
condition when it is signalled.</p>
</td></tr>
<tr><td><code id="cnd_+3A_call">call</code></td>
<td>
<p>A function call to be included in the error message.
If an execution environment of a running function, the
corresponding function call is retrieved.</p>
</td></tr>
<tr><td><code id="cnd_+3A_use_cli_format">use_cli_format</code></td>
<td>
<p>Whether to use the cli package to format
<code>message</code>. See <code><a href="rlang.html#topic+local_use_cli">local_use_cli()</a></code>.</p>
</td></tr>
<tr><td><code id="cnd_+3A_trace">trace</code></td>
<td>
<p>A <code>trace</code> object created by <code><a href="rlang.html#topic+trace_back">trace_back()</a></code>.</p>
</td></tr>
<tr><td><code id="cnd_+3A_parent">parent</code></td>
<td>
<p>A parent condition object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+cnd_signal">cnd_signal()</a></code>, <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a condition inheriting only from the S3 class "foo":
cnd &lt;- cnd("foo")

# Signal the condition to potential handlers. Since this is a bare
# condition the signal has no effect if no handlers are set up:
cnd_signal(cnd)

# When a relevant handler is set up, the signal transfers control
# to the handler
with_handlers(cnd_signal(cnd), foo = function(c) "caught!")
tryCatch(cnd_signal(cnd), foo = function(c) "caught!")
</code></pre>

<hr>
<h2 id='cnd_inherits'>Does a condition or its ancestors inherit from a class?</h2><span id='topic+cnd_inherits'></span>

<h3>Description</h3>

<p>Like any R objects, errors captured with catchers like <code><a href="base.html#topic+tryCatch">tryCatch()</a></code>
have a <code><a href="base.html#topic+class">class()</a></code> which you can test with <code><a href="base.html#topic+inherits">inherits()</a></code>.  However,
with chained errors, the class of a captured error might be
different than the error that was originally signalled. Use
<code>cnd_inherits()</code> to detect whether an error or any of its <em>parent</em>
inherits from a class.
</p>
<p>Whereas <code>inherits()</code> tells you whether an object is a particular
kind of error, <code>cnd_inherits()</code> answers the question whether an
object is a particular kind of error or has been caused by such an
error.
</p>
<p>Some chained conditions carry parents that are not inherited. See
the <code>.inherit</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code>, <code><a href="rlang.html#topic+warn">warn()</a></code>, and <code><a href="rlang.html#topic+inform">inform()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnd_inherits(cnd, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnd_inherits_+3A_cnd">cnd</code></td>
<td>
<p>A condition to test.</p>
</td></tr>
<tr><td><code id="cnd_inherits_+3A_class">class</code></td>
<td>
<p>A class passed to <code><a href="base.html#topic+inherits">inherits()</a></code>.</p>
</td></tr>
</table>


<h3>Capture an error with <code>cnd_inherits()</code></h3>

<p>Error catchers like <code><a href="base.html#topic+tryCatch">tryCatch()</a></code> and <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code> can only match
the class of a condition, not the class of its parents. To match a
class across the ancestry of an error, you'll need a bit of
craftiness.
</p>
<p>Ancestry matching can't be done with <code>tryCatch()</code> at all so you'll
need to switch to <code><a href="base.html#topic+withCallingHandlers">withCallingHandlers()</a></code>. Alternatively, you can
use the experimental rlang function <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code> which is able to
perform the roles of both <code>tryCatch()</code> and <code>withCallingHandlers()</code>.
</p>


<h4><code>withCallingHandlers()</code></h4>

<p>Unlike <code>tryCatch()</code>, <code>withCallingHandlers()</code> does not capture an
error. If you don't explicitly jump with an <em>error</em> or a <em>value</em>
throw, nothing happens.
</p>
<p>Since we don't want to throw an error, we'll throw a value using
<code><a href="base.html#topic+callCC">callCC()</a></code>:
</p>
<div class="sourceCode r"><pre>f &lt;- function() {
  parent &lt;- error_cnd("bar", message = "Bar")
  abort("Foo", parent = parent)
}

cnd &lt;- callCC(function(throw) {
  withCallingHandlers(
    f(),
    error = function(x) if (cnd_inherits(x, "bar")) throw(x)
  )
})

class(cnd)
#&gt; [1] "rlang_error" "error"       "condition"
class(cnd$parent)
#&gt; [1] "bar"         "rlang_error" "error"       "condition"
</pre></div>



<h4><code>try_fetch()</code></h4>

<p>This pattern is easier with <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>. Like
<code>withCallingHandlers()</code>, it doesn't capture a matching error right
away. Instead, it captures it only if the handler doesn't return a
<code><a href="purrr.html#topic+zap">zap()</a></code> value.
</p>
<div class="sourceCode r"><pre>cnd &lt;- try_fetch(
  f(),
  error = function(x) if (cnd_inherits(x, "bar")) x else zap()
)

class(cnd)
#&gt; [1] "rlang_error" "error"       "condition"
class(cnd$parent)
#&gt; [1] "bar"         "rlang_error" "error"       "condition"
</pre></div>
<p>Note that <code>try_fetch()</code> uses <code>cnd_inherits()</code> internally. This
makes it very easy to match a parent condition:
</p>
<div class="sourceCode r"><pre>cnd &lt;- try_fetch(
  f(),
  bar = function(x) x
)

# This is the parent
class(cnd)
#&gt; [1] "bar"         "rlang_error" "error"       "condition"
</pre></div>


<hr>
<h2 id='cnd_message'>Build an error message from parts</h2><span id='topic+cnd_message'></span><span id='topic+cnd_header'></span><span id='topic+cnd_body'></span><span id='topic+cnd_footer'></span>

<h3>Description</h3>

<p><code>cnd_message()</code> assembles an error message from three generics:
</p>

<ul>
<li> <p><code>cnd_header()</code>
</p>
</li>
<li> <p><code>cnd_body()</code>
</p>
</li>
<li> <p><code>cnd_footer()</code>
</p>
</li></ul>

<p>Methods for these generics must return a character vector. The
elements are combined into a single string with a newline
separator. Bullets syntax is supported, either through rlang (see
<code><a href="rlang.html#topic+format_error_bullets">format_error_bullets()</a></code>), or through cli if the condition has
<code>use_cli_format</code> set to <code>TRUE</code>.
</p>
<p>The default method for the error header returns the <code>message</code> field
of the condition object. The default methods for the body and
footer return the the <code>body</code> and <code>footer</code> fields if any, or empty
character vectors otherwise.
</p>
<p><code>cnd_message()</code> is automatically called by the <code>conditionMessage()</code>
for rlang errors, warnings, and messages. Error classes created
with <code><a href="rlang.html#topic+abort">abort()</a></code> only need to implement header, body or footer
methods. This provides a lot of flexibility for hierarchies of
error classes, for instance you could inherit the body of an error
message from a parent class while overriding the header and footer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnd_message(cnd, ..., inherit = TRUE, prefix = FALSE)

cnd_header(cnd, ...)

cnd_body(cnd, ...)

cnd_footer(cnd, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnd_message_+3A_cnd">cnd</code></td>
<td>
<p>A condition object.</p>
</td></tr>
<tr><td><code id="cnd_message_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="cnd_message_+3A_inherit">inherit</code></td>
<td>
<p>Wether to include parent messages. Parent messages
are printed with a &quot;Caused by error:&quot; prefix, even if <code>prefix</code> is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cnd_message_+3A_prefix">prefix</code></td>
<td>
<p>Whether to print the full message, including the
condition prefix (<code style="white-space: pre;">&#8288;Error:&#8288;</code>, <code style="white-space: pre;">&#8288;Warning:&#8288;</code>, <code style="white-space: pre;">&#8288;Message:&#8288;</code>, or
<code style="white-space: pre;">&#8288;Condition:&#8288;</code>). The prefix mentions the <code>call</code> field if present,
and the <code>srcref</code> info if present. If <code>cnd</code> has a <code>parent</code> field
(i.e. the condition is chained), the parent messages are included
in the message with a <code style="white-space: pre;">&#8288;Caused by&#8288;</code> prefix.</p>
</td></tr>
</table>


<h3>Overriding header, body, and footer methods</h3>

<p>Sometimes the contents of an error message depends on the state of
your checking routine. In that case, it can be tricky to lazily
generate error messages with <code>cnd_header()</code>, <code>cnd_body()</code>, and
<code>cnd_footer()</code>: you have the choice between overspecifying your
error class hierarchies with one class per state, or replicating
the type-checking control flow within the <code>cnd_body()</code> method. None
of these options are ideal.
</p>
<p>A better option is to define <code>header</code>, <code>body</code>, or <code>footer</code> fields
in your condition object. These can be a static string, a
<a href="rlang.html#topic+as_function">lambda-formula</a>, or a function with the same
signature as <code>cnd_header()</code>, <code>cnd_body()</code>, or <code>cnd_footer()</code>. These
fields override the message generics and make it easy to generate
an error message tailored to the state in which the error was
constructed.
</p>

<hr>
<h2 id='cnd_muffle'>Muffle a condition</h2><span id='topic+cnd_muffle'></span>

<h3>Description</h3>

<p>Unlike <code><a href="rlang.html#topic+exiting">exiting()</a></code> handlers, <code><a href="rlang.html#topic+calling">calling()</a></code> handlers must be explicit
that they have handled a condition to stop it from propagating to
other handlers. Use <code>cnd_muffle()</code> within a calling handler (or as
a calling handler, see examples) to prevent any other handlers from
being called for that condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnd_muffle(cnd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnd_muffle_+3A_cnd">cnd</code></td>
<td>
<p>A condition to muffle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>cnd</code> is mufflable, <code>cnd_muffle()</code> jumps to the muffle
restart and doesn't return. Otherwise, it returns <code>FALSE</code>.
</p>


<h3>Mufflable conditions</h3>

<p>Most conditions signalled by base R are muffable, although the name
of the restart varies. cnd_muffle() will automatically call the
correct restart for you. It is compatible with the following
conditions:
</p>

<ul>
<li> <p><code>warning</code> and <code>message</code> conditions. In this case <code>cnd_muffle()</code>
is equivalent to <code><a href="base.html#topic+message">base::suppressMessages()</a></code> and
<code><a href="base.html#topic+warning">base::suppressWarnings()</a></code>.
</p>
</li>
<li><p> Bare conditions signalled with <code>signal()</code> or <code><a href="rlang.html#topic+cnd_signal">cnd_signal()</a></code>. Note
that conditions signalled with <code><a href="base.html#topic+conditions">base::signalCondition()</a></code> are not
mufflable.
</p>
</li>
<li><p> Interrupts are sometimes signalled with a <code>resume</code> restart on
recent R versions. When this is the case, you can muffle the
interrupt with <code>cnd_muffle()</code>. Check if a restart is available
with <code>base::findRestart("resume")</code>.
</p>
</li></ul>

<p>If you call <code>cnd_muffle()</code> with a condition that is not mufflable
you will cause a new error to be signalled.
</p>

<ul>
<li><p> Errors are not mufflable since they are signalled in critical
situations where execution cannot continue safely.
</p>
</li>
<li><p> Conditions captured with <code><a href="base.html#topic+conditions">base::tryCatch()</a></code>, <code><a href="rlang.html#topic+with_handlers">with_handlers()</a></code> or
<code><a href="rlang.html#topic+catch_cnd">catch_cnd()</a></code> are no longer mufflable. Muffling restarts <em>must</em>
be called from a <a href="rlang.html#topic+calling">calling</a> handler.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- function() {
  inform("Beware!", "my_particular_msg")
  inform("On your guard!")
  "foobar"
}

# Let's install a muffling handler for the condition thrown by `fn()`.
# This will suppress all `my_particular_wng` warnings but let other
# types of warnings go through:
with_handlers(fn(),
  my_particular_msg = calling(function(cnd) {
    inform("Dealt with this particular message")
    cnd_muffle(cnd)
  })
)

# Note how execution of `fn()` continued normally after dealing
# with that particular message.

# cnd_muffle() can also be passed to with_handlers() as a calling
# handler:
with_handlers(fn(),
  my_particular_msg = calling(cnd_muffle)
)
</code></pre>

<hr>
<h2 id='cnd_signal'>Signal a condition object</h2><span id='topic+cnd_signal'></span>

<h3>Description</h3>

<p><code>cnd_signal()</code> takes a condition as argument and emits the
corresponding signal. The type of signal depends on the class of
the condition:
</p>

<ul>
<li><p> A message is signalled if the condition inherits from
<code>"message"</code>. This is equivalent to signalling with <code><a href="rlang.html#topic+inform">inform()</a></code> or
<code><a href="base.html#topic+message">base::message()</a></code>.
</p>
</li>
<li><p> A warning is signalled if the condition inherits from
<code>"warning"</code>. This is equivalent to signalling with <code><a href="rlang.html#topic+warn">warn()</a></code> or
<code><a href="base.html#topic+warning">base::warning()</a></code>.
</p>
</li>
<li><p> An error is signalled if the condition inherits from
<code>"error"</code>. This is equivalent to signalling with <code><a href="rlang.html#topic+abort">abort()</a></code> or
<code><a href="base.html#topic+stop">base::stop()</a></code>.
</p>
</li>
<li><p> An interrupt is signalled if the condition inherits from
<code>"interrupt"</code>. This is equivalent to signalling with
<code><a href="httpuv.html#topic+interrupt">interrupt()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cnd_signal(cnd, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnd_signal_+3A_cnd">cnd</code></td>
<td>
<p>A condition object (see <code><a href="rlang.html#topic+cnd">cnd()</a></code>). If <code>NULL</code>,
<code>cnd_signal()</code> returns without signalling a condition.</p>
</td></tr>
<tr><td><code id="cnd_signal_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="rlang.html#topic+cnd_type">cnd_type()</a></code> to determine the type of a condition.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+abort">abort()</a></code>, <code><a href="rlang.html#topic+warn">warn()</a></code> and <code><a href="rlang.html#topic+inform">inform()</a></code> for creating and signalling
structured R conditions in one go.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code> for establishing condition handlers for
particular condition classes.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># The type of signal depends on the class. If the condition
# inherits from "warning", a warning is issued:
cnd &lt;- warning_cnd("my_warning_class", message = "This is a warning")
cnd_signal(cnd)

# If it inherits from "error", an error is raised:
cnd &lt;- error_cnd("my_error_class", message = "This is an error")
try(cnd_signal(cnd))
</code></pre>

<hr>
<h2 id='cnd_type'>What type is a condition?</h2><span id='topic+cnd_type'></span>

<h3>Description</h3>

<p>Use <code>cnd_type()</code> to check what type a condition is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnd_type(cnd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnd_type_+3A_cnd">cnd</code></td>
<td>
<p>A condition object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string, either <code>"condition"</code>, <code>"message"</code>, <code>"warning"</code>,
<code>"error"</code> or <code>"interrupt"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cnd_type(catch_cnd(abort("Abort!")))
cnd_type(catch_cnd(interrupt()))
</code></pre>

<hr>
<h2 id='defusing-advanced'>Advanced defusal operators</h2><span id='topic+defusing-advanced'></span><span id='topic+enexpr'></span><span id='topic+exprs'></span><span id='topic+enexprs'></span><span id='topic+ensym'></span><span id='topic+ensyms'></span><span id='topic+quo'></span><span id='topic+quos'></span><span id='topic+enquo0'></span><span id='topic+enquos0'></span>

<h3>Description</h3>

<p>These advanced operators <a href="rlang.html#topic+topic-defuse">defuse</a> R expressions.
<code><a href="dplyr.html#topic+expr">expr()</a></code>, <code><a href="dplyr.html#topic+enquo">enquo()</a></code>, and <code><a href="dplyr.html#topic+enquos">enquos()</a></code> are sufficient for most
purposes but rlang provides these other operations, either for
completeness or because they are useful to experts.
</p>

<ul>
<li> <p><code>exprs()</code> is the plural variant of <code>expr()</code>. It returns a list of
expressions. It is like <code><a href="base.html#topic+list">base::alist()</a></code> but with
<a href="rlang.html#topic+nse-inject">injection</a> support.
</p>
</li>
<li> <p><code>quo()</code> and <code>quos()</code> are like <code>expr()</code> and <code>exprs()</code> but return
quosures instead of naked expressions. When you are defusing
your own local expressions (by opposition to function arguments
where non-local expressions are supplied by your users), there
is generally no need to attach the current environment in a
quosure. See <a href="rlang.html#topic+topic-quosure">What are quosures and when are they needed?</a>.
</p>
</li>
<li> <p><code>enexpr()</code> and <code>enexprs()</code> are like <code><a href="dplyr.html#topic+enquo">enquo()</a></code> and <code><a href="dplyr.html#topic+enquos">enquos()</a></code> but
return naked expressions instead of quosures. These operators
should very rarely be used because they lose track of the
environment of defused arguments.
</p>
</li>
<li> <p><code>ensym()</code> and <code>ensyms()</code> are like <code>enexpr()</code> and <code>enexprs()</code> but
they throw an error when the defused expressions are not simple
symbols. They also support strings which are interpreted as
symbols. These functions are modelled on the behaviour of the
left-hand side of <code>=</code> and <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> where you can supply symbols and
strings interchangeably.
</p>
<div class="sourceCode"><pre>"foo" &lt;- NULL
list("foo" = NULL)
</pre></div>
</li>
<li> <p><code>enquo0</code> and <code>enquos0()</code> are like <code>enquo()</code> and <code>enquos()</code> but
without injection support. The injection operators <code style="white-space: pre;">&#8288;!!&#8288;</code>, <code style="white-space: pre;">&#8288;!!!&#8288;</code>,
and <code style="white-space: pre;">&#8288;{{&#8288;</code> are not processed, instead they are preserved in the
defused expression. This makes it possible to defuse
expressions that potentially contain injection operators meant
for later use. The trade off is that it makes it harder for
users to inject expressions in your function. They have to
enable injection explicitly with <code><a href="rlang.html#topic+inject">inject()</a></code>.
</p>
<p>None of the features of <a href="rlang.html#topic+dyn-dots">dynamic dots</a> are available
when defusing with <code>enquos0()</code>. For instance, trailing empty
arguments are not automatically trimmed.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>enexpr(arg)

exprs(
  ...,
  .named = FALSE,
  .ignore_empty = c("trailing", "none", "all"),
  .unquote_names = TRUE
)

enexprs(
  ...,
  .named = FALSE,
  .ignore_empty = c("trailing", "none", "all"),
  .ignore_null = c("none", "all"),
  .unquote_names = TRUE,
  .homonyms = c("keep", "first", "last", "error"),
  .check_assign = FALSE
)

ensym(arg)

ensyms(
  ...,
  .named = FALSE,
  .ignore_empty = c("trailing", "none", "all"),
  .ignore_null = c("none", "all"),
  .unquote_names = TRUE,
  .homonyms = c("keep", "first", "last", "error"),
  .check_assign = FALSE
)

quo(expr)

quos(
  ...,
  .named = FALSE,
  .ignore_empty = c("trailing", "none", "all"),
  .unquote_names = TRUE
)

enquo0(arg)

enquos0(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defusing-advanced_+3A_arg">arg</code></td>
<td>
<p>An unquoted argument name. The expression
supplied to that argument is defused and returned.</p>
</td></tr>
<tr><td><code id="defusing-advanced_+3A_...">...</code></td>
<td>
<p>For <code>enexprs()</code>, <code>ensyms()</code> and <code>enquos()</code>, names of
arguments to defuse. For <code>exprs()</code> and <code>quos()</code>, expressions
to defuse.</p>
</td></tr>
<tr><td><code id="defusing-advanced_+3A_.named">.named</code></td>
<td>
<p>If <code>TRUE</code>, unnamed inputs are automatically named
with <code><a href="dplyr.html#topic+as_label">as_label()</a></code>. This is equivalent to applying
<code><a href="rlang.html#topic+exprs_auto_name">exprs_auto_name()</a></code> on the result. If <code>FALSE</code>, unnamed elements
are left as is and, if fully unnamed, the list is given minimal
names (a vector of <code>""</code>). If <code>NULL</code>, fully unnamed results are
left with <code>NULL</code> names.</p>
</td></tr>
<tr><td><code id="defusing-advanced_+3A_.ignore_empty">.ignore_empty</code></td>
<td>
<p>Whether to ignore empty arguments. Can be one
of <code>"trailing"</code>, <code>"none"</code>, <code>"all"</code>. If <code>"trailing"</code>, only the
last argument is ignored if it is empty. Named arguments are not
considered empty.</p>
</td></tr>
<tr><td><code id="defusing-advanced_+3A_.unquote_names">.unquote_names</code></td>
<td>
<p>Whether to treat <code style="white-space: pre;">&#8288;:=&#8288;</code> as <code>=</code>. Unlike <code>=</code>, the
<code style="white-space: pre;">&#8288;:=&#8288;</code> syntax supports <a href="rlang.html#topic+glue-operators">names injection</a>.</p>
</td></tr>
<tr><td><code id="defusing-advanced_+3A_.ignore_null">.ignore_null</code></td>
<td>
<p>Whether to ignore unnamed null arguments. Can be
<code>"none"</code> or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="defusing-advanced_+3A_.homonyms">.homonyms</code></td>
<td>
<p>How to treat arguments with the same name. The
default, <code>"keep"</code>, preserves these arguments. Set <code>.homonyms</code> to
<code>"first"</code> to only keep the first occurrences, to <code>"last"</code> to keep
the last occurrences, and to <code>"error"</code> to raise an informative
error and indicate what arguments have duplicated names.</p>
</td></tr>
<tr><td><code id="defusing-advanced_+3A_.check_assign">.check_assign</code></td>
<td>
<p>Whether to check for <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> calls. When <code>TRUE</code> a
warning recommends users to use <code>=</code> if they meant to match a
function parameter or wrap the <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> call in curly braces otherwise.
This ensures assignments are explicit.</p>
</td></tr>
<tr><td><code id="defusing-advanced_+3A_expr">expr</code></td>
<td>
<p>An expression to defuse.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># `exprs()` is the plural variant of `expr()`
exprs(foo, bar, bar)

# `quo()` and `quos()` are the quosure variants of `expr()` and `exprs()`
quo(foo)
quos(foo, bar)

# `enexpr()` and `enexprs()` are the naked variants of `enquo()` and `enquos()`
my_function1 &lt;- function(arg) enexpr(arg)
my_function2 &lt;- function(arg, ...) enexprs(arg, ...)
my_function1(1 + 1)
my_function2(1 + 1, 10 * 2)


# `ensym()` and `ensyms()` are symbol variants of `enexpr()` and `enexprs()`
my_function3 &lt;- function(arg) ensym(arg)
my_function4 &lt;- function(arg, ...) ensyms(arg, ...)

# The user must supply symbols
my_function3(foo)
my_function4(foo, bar)

# Complex expressions are an error
try(my_function3(1 + 1))
try(my_function4(1 + 1, 10 * 2))


# `enquo0()` and `enquos0()` disable injection operators
automatic_injection &lt;- function(x) enquo(x)
no_injection &lt;- function(x) enquo0(x)

automatic_injection(foo(!!!1:3))
no_injection(foo(!!!1:3))

# Injection can still be done explicitly
inject(no_injection(foo(!!!1:3)))

</code></pre>

<hr>
<h2 id='dev-notes-dots'>Development notes - <code>dots.R</code></h2><span id='topic+dev-notes-dots'></span>

<h3>Description</h3>

<p>Development notes - <code>dots.R</code>
</p>


<h3><code>.__error_call__.</code> flag in dots collectors</h3>

<p>Dots collectors like <code><a href="rlang.html#topic+dots_list">dots_list()</a></code> are a little tricky because they
may error out in different situations. Do we want to forward the
context, i.e. set the call flag to the calling environment?
Collectors throw errors in these cases:
</p>

<ol>
<li><p> While checking their own parameters, in which case the relevant
context is the collector itself and we don't forward.
</p>
</li>
<li><p> While collecting the dots, during evaluation of the supplied
arguments. In this case forwarding or not is irrelevant because
expressions in <code>...</code> are evaluated in their own environment
which is not connected to the collector's context.
</p>
</li>
<li><p> While collecting the dots, during argument constraints checks
such as determined by the <code>.homonyms</code> argument. In this case we
want to forward the context because the caller of the dots
collector is the one who determines the constraints for its
users.
</p>
</li></ol>


<hr>
<h2 id='done'>Box a final value for early termination</h2><span id='topic+done'></span><span id='topic+is_done_box'></span>

<h3>Description</h3>

<p>A value boxed with <code>done()</code> signals to its caller that it
should stop iterating. Use it to shortcircuit a loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>done(x)

is_done_box(x, empty = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="done_+3A_x">x</code></td>
<td>
<p>For <code>done()</code>, a value to box. For <code>is_done_box()</code>, a
value to test.</p>
</td></tr>
<tr><td><code id="done_+3A_empty">empty</code></td>
<td>
<p>Whether the box is empty. If <code>NULL</code>, <code>is_done_box()</code>
returns <code>TRUE</code> for all done boxes. If <code>TRUE</code>, it returns <code>TRUE</code>
only for empty boxes. Otherwise it returns <code>TRUE</code> only for
non-empty boxes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="rlang.html#topic+new_box">boxed</a> value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>done(3)

x &lt;- done(3)
is_done_box(x)
</code></pre>

<hr>
<h2 id='dot-data'><code>.data</code> and <code>.env</code> pronouns</h2><span id='topic+dot-data'></span><span id='topic+.data'></span><span id='topic+tidyeval-data'></span><span id='topic+.env'></span>

<h3>Description</h3>

<p>The <code>.data</code> and <code>.env</code> pronouns make it explicit where to find
objects when programming with <a href="rlang.html#topic+topic-data-mask">data-masked</a>
functions.
</p>
<div class="sourceCode"><pre>m &lt;- 10
mtcars %&gt;% mutate(disp = .data$disp * .env$m)
</pre></div>

<ul>
<li> <p><code>.data</code> retrieves data-variables from the data frame.
</p>
</li>
<li> <p><code>.env</code> retrieves env-variables from the environment.
</p>
</li></ul>

<p>Because the lookup is explicit, there is no ambiguity between both
kinds of variables. Compare:
</p>
<div class="sourceCode"><pre>disp &lt;- 10
mtcars %&gt;% mutate(disp = .data$disp * .env$disp)
mtcars %&gt;% mutate(disp = disp * disp)
</pre></div>
<p>Note that <code>.data</code> is only a pronoun, it is not a real data
frame. This means that you can't take its names or map a function
over the contents of <code>.data</code>. Similarly, <code>.env</code> is not an actual R
environment. For instance, it doesn't have a parent and the
subsetting operators behave differently.
</p>


<h3><code>.data</code> versus the magrittr pronoun <code>.</code></h3>

<p>In a <a href="https://magrittr.tidyverse.org/">magrittr pipeline</a>, <code>.data</code>
is not necessarily interchangeable with the magrittr pronoun <code>.</code>.
With grouped data frames in particular, <code>.data</code> represents the
current group slice whereas the pronoun <code>.</code> represents the whole
data frame. Always prefer using <code>.data</code> in data-masked context.
</p>


<h3>Where does <code>.data</code> live?</h3>

<p>The <code>.data</code> pronoun is automatically created for you by
data-masking functions using the <a href="rlang.html#topic+eval_tidy">tidy eval framework</a>.
You don't need to import <code>rlang::.data</code> or use <code>library(rlang)</code> to
work with this pronoun.
</p>
<p>However, the <code>.data</code> object exported from rlang is useful to import
in your package namespace to avoid a <code style="white-space: pre;">&#8288;R CMD check&#8288;</code> note when
referring to objects from the data mask. R does not have any way of
knowing about the presence or absence of <code>.data</code> in a particular
scope so you need to import it explicitly or equivalently declare
it with <code>utils::globalVariables(".data")</code>.
</p>
<p>Note that <code>rlang::.data</code> is a &quot;fake&quot; pronoun. Do not refer to
<code>rlang::.data</code> with the <code style="white-space: pre;">&#8288;rlang::&#8288;</code> qualifier in data masking
code. Use the unqualified <code>.data</code> symbol that is automatically put
in scope by data-masking functions.
</p>

<hr>
<h2 id='dots_n'>How many arguments are currently forwarded in dots?</h2><span id='topic+dots_n'></span>

<h3>Description</h3>

<p>This returns the number of arguments currently forwarded in <code>...</code>
as an integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dots_n(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dots_n_+3A_...">...</code></td>
<td>
<p>Forwarded arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- function(...) dots_n(..., baz)
fn(foo, bar)
</code></pre>

<hr>
<h2 id='dots_splice'>Splice lists</h2><span id='topic+dots_splice'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>dots_splice()</code> is like <code><a href="rlang.html#topic+dots_list">dots_list()</a></code> but automatically splices
list inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dots_splice(
  ...,
  .ignore_empty = c("trailing", "none", "all"),
  .preserve_empty = FALSE,
  .homonyms = c("keep", "first", "last", "error"),
  .check_assign = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dots_splice_+3A_...">...</code></td>
<td>
<p>Arguments to collect in a list. These dots are
<a href="rlang.html#topic+dyn-dots">dynamic</a>.</p>
</td></tr>
<tr><td><code id="dots_splice_+3A_.ignore_empty">.ignore_empty</code></td>
<td>
<p>Whether to ignore empty arguments. Can be one
of <code>"trailing"</code>, <code>"none"</code>, <code>"all"</code>. If <code>"trailing"</code>, only the
last argument is ignored if it is empty.</p>
</td></tr>
<tr><td><code id="dots_splice_+3A_.preserve_empty">.preserve_empty</code></td>
<td>
<p>Whether to preserve the empty arguments that
were not ignored. If <code>TRUE</code>, empty arguments are stored with
<code><a href="lazyeval.html#topic+missing_arg">missing_arg()</a></code> values. If <code>FALSE</code> (the default) an error is
thrown when an empty argument is detected.</p>
</td></tr>
<tr><td><code id="dots_splice_+3A_.homonyms">.homonyms</code></td>
<td>
<p>How to treat arguments with the same name. The
default, <code>"keep"</code>, preserves these arguments. Set <code>.homonyms</code> to
<code>"first"</code> to only keep the first occurrences, to <code>"last"</code> to keep
the last occurrences, and to <code>"error"</code> to raise an informative
error and indicate what arguments have duplicated names.</p>
</td></tr>
<tr><td><code id="dots_splice_+3A_.check_assign">.check_assign</code></td>
<td>
<p>Whether to check for <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> calls. When <code>TRUE</code> a
warning recommends users to use <code>=</code> if they meant to match a
function parameter or wrap the <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> call in curly braces otherwise.
This ensures assignments are explicit.</p>
</td></tr>
</table>

<hr>
<h2 id='dots_values'>Evaluate dots with preliminary splicing</h2><span id='topic+dots_values'></span>

<h3>Description</h3>

<p>This is a tool for advanced users. It captures dots, processes
unquoting and splicing operators, and evaluates them. Unlike
<code><a href="rlang.html#topic+dots_list">dots_list()</a></code>, it does not flatten spliced objects, instead they
are attributed a <code>spliced</code> class (see <code><a href="purrr.html#topic+splice">splice()</a></code>). You can process
spliced objects manually, perhaps with a custom predicate (see
<code><a href="rlang.html#topic+flatten_if">flatten_if()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dots_values(
  ...,
  .ignore_empty = c("trailing", "none", "all"),
  .preserve_empty = FALSE,
  .homonyms = c("keep", "first", "last", "error"),
  .check_assign = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dots_values_+3A_...">...</code></td>
<td>
<p>Arguments to evaluate and process splicing operators.</p>
</td></tr>
<tr><td><code id="dots_values_+3A_.ignore_empty">.ignore_empty</code></td>
<td>
<p>Whether to ignore empty arguments. Can be one
of <code>"trailing"</code>, <code>"none"</code>, <code>"all"</code>. If <code>"trailing"</code>, only the
last argument is ignored if it is empty.</p>
</td></tr>
<tr><td><code id="dots_values_+3A_.preserve_empty">.preserve_empty</code></td>
<td>
<p>Whether to preserve the empty arguments that
were not ignored. If <code>TRUE</code>, empty arguments are stored with
<code><a href="lazyeval.html#topic+missing_arg">missing_arg()</a></code> values. If <code>FALSE</code> (the default) an error is
thrown when an empty argument is detected.</p>
</td></tr>
<tr><td><code id="dots_values_+3A_.homonyms">.homonyms</code></td>
<td>
<p>How to treat arguments with the same name. The
default, <code>"keep"</code>, preserves these arguments. Set <code>.homonyms</code> to
<code>"first"</code> to only keep the first occurrences, to <code>"last"</code> to keep
the last occurrences, and to <code>"error"</code> to raise an informative
error and indicate what arguments have duplicated names.</p>
</td></tr>
<tr><td><code id="dots_values_+3A_.check_assign">.check_assign</code></td>
<td>
<p>Whether to check for <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> calls. When <code>TRUE</code> a
warning recommends users to use <code>=</code> if they meant to match a
function parameter or wrap the <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> call in curly braces otherwise.
This ensures assignments are explicit.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dots &lt;- dots_values(!!! list(1, 2), 3)
dots

# Flatten the objects marked as spliced:
flatten_if(dots, is_spliced)
</code></pre>

<hr>
<h2 id='duplicate'>Duplicate an R object</h2><span id='topic+duplicate'></span>

<h3>Description</h3>

<p><code>duplicate()</code> is an interface to the C-level <code>duplicate()</code> and
<code>shallow_duplicate()</code> functions. It is mostly meant for users of
the C API of R, e.g. for debugging, experimenting, or prototyping C
code in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicate(x, shallow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicate_+3A_x">x</code></td>
<td>
<p>An R object. Uncopyable objects like symbols and
environments are returned as is (just like with <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>).</p>
</td></tr>
<tr><td><code id="duplicate_+3A_shallow">shallow</code></td>
<td>
<p>Recursive data structures like lists, calls and
pairlists are duplicated in full by default. A shallow copy only
duplicates the top-level data structure.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>pairlist
</p>

<hr>
<h2 id='dyn-dots'>Dynamic dots features</h2><span id='topic+dyn-dots'></span><span id='topic+tidy-dots'></span><span id='topic+doc_dots_dynamic'></span><span id='topic++3A+3D'></span>

<h3>Description</h3>

<p>The base <code>...</code> syntax supports:
</p>

<ul>
<li> <p><strong>Forwarding</strong> arguments from function to function, matching them
along the way to arguments.
</p>
</li>
<li> <p><strong>Collecting</strong> arguments inside data structures, e.g. with <code><a href="base.html#topic+c">c()</a></code> or
<code><a href="base.html#topic+list">list()</a></code>.
</p>
</li></ul>

<p>Dynamic dots offer a few additional features,
<a href="rlang.html#topic+topic-inject">injection</a> in particular:
</p>

<ol>
<li><p> You can <strong>splice</strong> arguments saved in a list with the splice
operator <code><a href="rlang.html#topic+splice-operator">!!!</a></code>.
</p>
</li>
<li><p> You can <strong>inject</strong> names with <a href="rlang.html#topic+glue-operators">glue syntax</a> on
the left-hand side of <code style="white-space: pre;">&#8288;:=&#8288;</code>.
</p>
</li>
<li><p> Trailing commas are ignored, making it easier to copy and paste
lines of arguments.
</p>
</li></ol>



<h3>Add dynamic dots support in your functions</h3>

<p>If your function takes dots, adding support for dynamic features is
as easy as collecting the dots with <code><a href="rlang.html#topic+list2">list2()</a></code> instead of <code><a href="base.html#topic+list">list()</a></code>.
See also <code><a href="rlang.html#topic+dots_list">dots_list()</a></code>, which offers more control over the collection.
</p>
<p>In general, passing <code>...</code> to a function that supports dynamic dots
causes your function to inherit the dynamic behaviour.
</p>
<p>In packages, document dynamic dots with this standard tag:
</p>
<div class="sourceCode"><pre> @param ... &lt;[`dynamic-dots`][rlang::dyn-dots]&gt; What these dots do.
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(...) {
  out &lt;- list2(...)
  rev(out)
}

# Trailing commas are ignored
f(this = "that", )

# Splice lists of arguments with `!!!`
x &lt;- list(alpha = "first", omega = "last")
f(!!!x)

# Inject a name using glue syntax
if (is_installed("glue")) {
  nm &lt;- "key"
  f("{nm}" := "value")
  f("prefix_{nm}" := "value")
}
</code></pre>

<hr>
<h2 id='embrace-operator'>Embrace operator <code style="white-space: pre;">&#8288;{{&#8288;</code></h2><span id='topic+embrace-operator'></span><span id='topic+curly-curly'></span>

<h3>Description</h3>

<p>The embrace operator <code style="white-space: pre;">&#8288;{{&#8288;</code> is used to create functions that call
other <a href="rlang.html#topic+topic-data-mask">data-masking</a> functions. It transports a
data-masked argument (an argument that can refer to columns of a
data frame) from one function to another.
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  dplyr::summarise(data, mean = mean({{ var }}))
}
</pre></div>


<h3>Under the hood</h3>

<p><code style="white-space: pre;">&#8288;{{&#8288;</code> combines <code><a href="dplyr.html#topic+enquo">enquo()</a></code> and <code><a href="rlang.html#topic+injection-operator">!!</a></code> in one
step. The snippet above is equivalent to:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  var &lt;- enquo(var)
  dplyr::summarise(data, mean = mean(!!var))
}
</pre></div>


<h3>See Also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-data-mask">What is data-masking and why do I need {{?</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+topic-data-mask-programming">Data mask programming patterns</a>
</p>
</li></ul>


<hr>
<h2 id='empty_env'>Get the empty environment</h2><span id='topic+empty_env'></span>

<h3>Description</h3>

<p>The empty environment is the only one that does not have a parent.
It is always used as the tail of an environment chain such as the
search path (see <code><a href="rlang.html#topic+search_envs">search_envs()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_env()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'># Create environments with nothing in scope:
child_env(empty_env())
</code></pre>

<hr>
<h2 id='englue'>Defuse function arguments with glue</h2><span id='topic+englue'></span>

<h3>Description</h3>

<p><code>englue()</code> creates a string with the <a href="rlang.html#topic+glue-operators">glue operators</a> <code style="white-space: pre;">&#8288;{&#8288;</code> and <code style="white-space: pre;">&#8288;{{&#8288;</code>. These operators are
normally used to inject names within <a href="rlang.html#topic+dyn-dots">dynamic dots</a>.
<code>englue()</code> makes them available anywhere within a function.
</p>
<p><code>englue()</code> must be used inside a function. <code>englue("{{ var }}")</code>
<a href="rlang.html#topic+topic-defuse">defuses</a> the argument <code>var</code> and transforms it to a
string using the default name operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>englue(x, env = caller_env(), error_call = current_env(), error_arg = "x")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="englue_+3A_x">x</code></td>
<td>
<p>A string to interpolate with glue operators.</p>
</td></tr>
<tr><td><code id="englue_+3A_env">env</code></td>
<td>
<p>User environment where the interpolation data lives in
case you're wrapping <code>englue()</code> in another function.</p>
</td></tr>
<tr><td><code id="englue_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="englue_+3A_error_arg">error_arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>englue("{{ var }}")</code> is equivalent to <code>as_label(enquo(var))</code>. It
<a href="rlang.html#topic+topic-defuse">defuses</a> <code>arg</code> and transforms the expression to a
string with <code><a href="dplyr.html#topic+as_label">as_label()</a></code>.
</p>
<p>In dynamic dots, using only <code style="white-space: pre;">&#8288;{&#8288;</code> is allowed. In <code>englue()</code> you must
use <code style="white-space: pre;">&#8288;{{&#8288;</code> at least once. Use <code>glue::glue()</code> for simple
interpolation.
</p>
<p>Before using <code>englue()</code> in a package, first ensure that glue is
installed by adding it to your <code style="white-space: pre;">&#8288;Imports:&#8288;</code> section.
</p>
<div class="sourceCode r"><pre>usethis::use_package("glue", "Imports")
</pre></div>


<h3>Wrapping <code>englue()</code></h3>

<p>You can provide englue semantics to a user provided string by supplying <code>env</code>.
In this example we create a variant of <code>englue()</code> that supports a
special <code>.qux</code> pronoun by:
</p>

<ul>
<li><p> Creating an environment <code>masked_env</code> that inherits from the user
env, the one where their data lives.
</p>
</li>
<li><p> Overriding the <code>error_arg</code> and <code>error_call</code> arguments to point to
our own argument name and call environment. This pattern is
slightly different from usual error context passing because
<code>englue()</code> is a backend function that uses its own error context
by default (and not a checking function that uses <em>your</em> error
context by default).
</p>
</li></ul>

<div class="sourceCode r"><pre>my_englue &lt;- function(text) {
  masked_env &lt;- env(caller_env(), .qux = "QUX")

  englue(
    text,
    env = masked_env,
    error_arg = "text",
    error_call = current_env()
  )
}

# Users can then use your wrapper as they would use `englue()`:
fn &lt;- function(x) {
  foo &lt;- "FOO"
  my_englue("{{ x }}_{.qux}_{foo}")
}

fn(bar)
#&gt; [1] "bar_QUX_FOO"
</pre></div>
<p>If you are creating a low level package on top of englue(), you
should also consider exposing <code>env</code>, <code>error_arg</code> and <code>error_call</code>
in your <code>englue()</code> wrapper so users can wrap your wrapper.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-inject">Injecting with !!, !!!, and glue syntax</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- function(var) englue("{{ var }}")
g(cyl)
g(1 + 1)
g(!!letters)

# These are equivalent to
as_label(quote(cyl))
as_label(quote(1 + 1))
as_label(letters)

</code></pre>

<hr>
<h2 id='enquo'>Defuse function arguments</h2><span id='topic+enquo'></span><span id='topic+enquos'></span>

<h3>Description</h3>

<p><code>enquo()</code> and <code>enquos()</code> <a href="rlang.html#topic+topic-defuse">defuse</a> function arguments.
A defused expression can be examined, modified, and injected into
other expressions.
</p>
<p>Defusing function arguments is useful for:
</p>

<ul>
<li><p> Creating data-masking functions.
</p>
</li>
<li><p> Interfacing with another <a href="rlang.html#topic+topic-data-mask">data-masking</a> function
using the <a href="rlang.html#topic+topic-metaprogramming">defuse-and-inject</a> pattern.
</p>
</li></ul>

<p>These are advanced tools. Make sure to first learn about the embrace
operator <code><a href="rlang.html#topic+embrace-operator">{{</a></code> in <a href="rlang.html#topic+topic-data-mask-programming">Data mask programming patterns</a>.
<code style="white-space: pre;">&#8288;{{&#8288;</code> is easier to work with less theory, and it is sufficient
in most applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enquo(arg)

enquos(
  ...,
  .named = FALSE,
  .ignore_empty = c("trailing", "none", "all"),
  .ignore_null = c("none", "all"),
  .unquote_names = TRUE,
  .homonyms = c("keep", "first", "last", "error"),
  .check_assign = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enquo_+3A_arg">arg</code></td>
<td>
<p>An unquoted argument name. The expression
supplied to that argument is defused and returned.</p>
</td></tr>
<tr><td><code id="enquo_+3A_...">...</code></td>
<td>
<p>Names of arguments to defuse.</p>
</td></tr>
<tr><td><code id="enquo_+3A_.named">.named</code></td>
<td>
<p>If <code>TRUE</code>, unnamed inputs are automatically named
with <code><a href="dplyr.html#topic+as_label">as_label()</a></code>. This is equivalent to applying
<code><a href="rlang.html#topic+exprs_auto_name">exprs_auto_name()</a></code> on the result. If <code>FALSE</code>, unnamed elements
are left as is and, if fully unnamed, the list is given minimal
names (a vector of <code>""</code>). If <code>NULL</code>, fully unnamed results are
left with <code>NULL</code> names.</p>
</td></tr>
<tr><td><code id="enquo_+3A_.ignore_empty">.ignore_empty</code></td>
<td>
<p>Whether to ignore empty arguments. Can be one
of <code>"trailing"</code>, <code>"none"</code>, <code>"all"</code>. If <code>"trailing"</code>, only the
last argument is ignored if it is empty. Named arguments are not
considered empty.</p>
</td></tr>
<tr><td><code id="enquo_+3A_.ignore_null">.ignore_null</code></td>
<td>
<p>Whether to ignore unnamed null arguments. Can be
<code>"none"</code> or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="enquo_+3A_.unquote_names">.unquote_names</code></td>
<td>
<p>Whether to treat <code style="white-space: pre;">&#8288;:=&#8288;</code> as <code>=</code>. Unlike <code>=</code>, the
<code style="white-space: pre;">&#8288;:=&#8288;</code> syntax supports <a href="rlang.html#topic+glue-operators">names injection</a>.</p>
</td></tr>
<tr><td><code id="enquo_+3A_.homonyms">.homonyms</code></td>
<td>
<p>How to treat arguments with the same name. The
default, <code>"keep"</code>, preserves these arguments. Set <code>.homonyms</code> to
<code>"first"</code> to only keep the first occurrences, to <code>"last"</code> to keep
the last occurrences, and to <code>"error"</code> to raise an informative
error and indicate what arguments have duplicated names.</p>
</td></tr>
<tr><td><code id="enquo_+3A_.check_assign">.check_assign</code></td>
<td>
<p>Whether to check for <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> calls. When <code>TRUE</code> a
warning recommends users to use <code>=</code> if they meant to match a
function parameter or wrap the <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> call in curly braces otherwise.
This ensures assignments are explicit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>enquo()</code> returns a <a href="rlang.html#topic+topic-quosure">quosure</a> and <code>enquos()</code>
returns a list of quosures.
</p>


<h3>Implicit injection</h3>

<p>Arguments defused with <code>enquo()</code> and <code>enquos()</code> automatically gain
<a href="rlang.html#topic+topic-inject">injection</a> support.
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  var &lt;- enquo(var)
  dplyr::summarise(data, mean(!!var))
}

# Can now use `!!` and `{{`
my_mean(mtcars, !!sym("cyl"))
</pre></div>
<p>See <code><a href="rlang.html#topic+enquo0">enquo0()</a></code> and <code><a href="rlang.html#topic+enquos0">enquos0()</a></code> for variants that don't enable
injection.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-defuse">Defusing R expressions</a> for an overview.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+expr">expr()</a></code> to defuse your own local expressions.
</p>
</li>
<li> <p><a href="rlang.html#topic+defusing-advanced">Advanced defusal operators</a>.
</p>
</li>
<li> <p><code><a href="base.html#topic+eval">base::eval()</a></code> and <code><a href="rlang.html#topic+eval_bare">eval_bare()</a></code> for resuming evaluation
of a defused expression.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># `enquo()` defuses the expression supplied by your user
f &lt;- function(arg) {
  enquo(arg)
}

f(1 + 1)

# `enquos()` works with arguments and dots. It returns a list of
# expressions
f &lt;- function(...) {
  enquos(...)
}

f(1 + 1, 2 * 10)


# `enquo()` and `enquos()` enable _injection_ and _embracing_ for
# your users
g &lt;- function(arg) {
  f({{ arg }} * 2)
}
g(100)

column &lt;- sym("cyl")
g(!!column)

</code></pre>

<hr>
<h2 id='entrace'>Add backtrace from error handler</h2><span id='topic+entrace'></span><span id='topic+cnd_entrace'></span>

<h3>Description</h3>

<p><code>entrace()</code> is a low level function. See <code><a href="rlang.html#topic+global_entrace">global_entrace()</a></code> for a
user-friendly way of enriching errors and other conditions from
your RProfile.
</p>

<ul>
<li> <p><code>entrace()</code> is meant to be used as a global handler. It enriches
conditions with a backtrace. Errors are saved to <code><a href="rlang.html#topic+last_error">last_error()</a></code>
and rethrown immediately. Messages and warnings are recorded into
<code><a href="rlang.html#topic+last_messages">last_messages()</a></code> and <code><a href="rlang.html#topic+last_warnings">last_warnings()</a></code> and let through.
</p>
</li>
<li> <p><code>cnd_entrace()</code> adds a backtrace to a condition object, without
any other effect. It should be called from a condition handler.
</p>
</li></ul>

<p><code>entrace()</code> also works as an <code>option(error = )</code> handler for
compatibility with versions of R older than 4.0.
</p>
<p>When used as calling handler, rlang trims the handler invokation
context from the backtrace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entrace(cnd, ..., top = NULL, bottom = NULL)

cnd_entrace(cnd, ..., top = NULL, bottom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entrace_+3A_cnd">cnd</code></td>
<td>
<p>When <code>entrace()</code> is used as a calling handler, <code>cnd</code> is
the condition to handle.</p>
</td></tr>
<tr><td><code id="entrace_+3A_...">...</code></td>
<td>
<p>Unused. These dots are for future extensions.</p>
</td></tr>
<tr><td><code id="entrace_+3A_top">top</code></td>
<td>
<p>The first frame environment to be included in the
backtrace. This becomes the top of the backtrace tree and
represents the oldest call in the backtrace.
</p>
<p>This is needed in particular when you call <code>trace_back()</code>
indirectly or from a larger context, for example in tests or
inside an RMarkdown document where you don't want all of the
knitr evaluation mechanisms to appear in the backtrace.
</p>
<p>If not supplied, the <code>rlang_trace_top_env</code> global option is
consulted. This makes it possible to trim the embedding context
for all backtraces created while the option is set. If knitr is
in progress, the default value for this option is
<code>knitr::knit_global()</code> so that the knitr context is trimmed out
of backtraces.</p>
</td></tr>
<tr><td><code id="entrace_+3A_bottom">bottom</code></td>
<td>
<p>The last frame environment to be included in the
backtrace. This becomes the rightmost leaf of the backtrace tree
and represents the youngest call in the backtrace.
</p>
<p>Set this when you would like to capture a backtrace without the
capture context.
</p>
<p>Can also be an integer that will be passed to <code><a href="rlang.html#topic+caller_env">caller_env()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+global_entrace">global_entrace()</a></code> for configuring errors with
<code>entrace()</code>. <code><a href="rlang.html#topic+cnd_entrace">cnd_entrace()</a></code> to manually add a backtrace to a
condition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quote({  # Not run

# Set `entrace()` globally in your RProfile
globalCallingHandlers(error = rlang::entrace)

# On older R versions which don't feature `globalCallingHandlers`,
# set the error handler like this:
options(error = rlang::entrace)

})
</code></pre>

<hr>
<h2 id='env'>Create a new environment</h2><span id='topic+env'></span><span id='topic+new_environment'></span>

<h3>Description</h3>

<p>These functions create new environments.
</p>

<ul>
<li> <p><code>env()</code> creates a child of the current environment by default
and takes a variable number of named objects to populate it.
</p>
</li>
<li> <p><code>new_environment()</code> creates a child of the empty environment by
default and takes a named list of objects to populate it.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>env(...)

new_environment(data = list(), parent = empty_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_+3A_...">...</code>, <code id="env_+3A_data">data</code></td>
<td>
<p>&lt;<a href="rlang.html#topic+dyn-dots">dynamic</a>&gt; Named values. You can
supply one unnamed to specify a custom parent, otherwise it
defaults to the current environment.</p>
</td></tr>
<tr><td><code id="env_+3A_parent">parent</code></td>
<td>
<p>A parent environment.</p>
</td></tr>
</table>


<h3>Environments as objects</h3>

<p>Environments are containers of uniquely named objects. Their most
common use is to provide a scope for the evaluation of R
expressions. Not all languages have first class environments,
i.e. can manipulate scope as regular objects. Reification of scope
is one of the most powerful features of R as it allows you to change
what objects a function or expression sees when it is evaluated.
</p>
<p>Environments also constitute a data structure in their own
right. They are a collection of uniquely named objects, subsettable
by name and modifiable by reference. This latter property (see
section on reference semantics) is especially useful for creating
mutable OO systems (cf the <a href="https://github.com/r-lib/R6">R6 package</a>
and the <a href="https://ggplot2.tidyverse.org/articles/extending-ggplot2.html">ggproto system</a>
for extending ggplot2).
</p>


<h3>Inheritance</h3>

<p>All R environments (except the <a href="rlang.html#topic+empty_env">empty environment</a>) are
defined with a parent environment. An environment and its
grandparents thus form a linear hierarchy that is the basis for
<a href="https://en.wikipedia.org/wiki/Scope_(computer_science)">lexical scoping</a> in
R. When R evaluates an expression, it looks up symbols in a given
environment. If it cannot find these symbols there, it keeps
looking them up in parent environments. This way, objects defined
in child environments have precedence over objects defined in
parent environments.
</p>
<p>The ability of overriding specific definitions is used in the
tidyeval framework to create powerful domain-specific grammars. A
common use of masking is to put data frame columns in scope. See
for example <code><a href="rlang.html#topic+as_data_mask">as_data_mask()</a></code>.
</p>


<h3>Reference semantics</h3>

<p>Unlike regular objects such as vectors, environments are an
<a href="rlang.html#topic+is_copyable">uncopyable</a> object type. This means that if you
have multiple references to a given environment (by assigning the
environment to another symbol with <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> or passing the environment
as argument to a function), modifying the bindings of one of those
references changes all other references as well.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+env_has">env_has()</a></code>, <code><a href="rlang.html#topic+env_bind">env_bind()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># env() creates a new environment that inherits from the current
# environment by default
env &lt;- env(a = 1, b = "foo")
env$b
identical(env_parent(env), current_env())

# Supply one unnamed argument to inherit from another environment:
env &lt;- env(base_env(), a = 1, b = "foo")
identical(env_parent(env), base_env())


# Both env() and child_env() support tidy dots features:
objs &lt;- list(b = "foo", c = "bar")
env &lt;- env(a = 1, !!! objs)
env$c

# You can also unquote names with the definition operator `:=`
var &lt;- "a"
env &lt;- env(!!var := "A")
env$a


# Use new_environment() to create containers with the empty
# environment as parent:
env &lt;- new_environment()
env_parent(env)

# Like other new_ constructors, it takes an object rather than dots:
new_environment(list(a = "foo", b = "bar"))
</code></pre>

<hr>
<h2 id='env_bind'>Bind symbols to objects in an environment</h2><span id='topic+env_bind'></span><span id='topic+env_bind_lazy'></span><span id='topic+env_bind_active'></span><span id='topic++25+3C~+25'></span>

<h3>Description</h3>

<p>These functions create bindings in an environment. The bindings are
supplied through <code>...</code> as pairs of names and values or expressions.
<code>env_bind()</code> is equivalent to evaluating a <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> expression within
the given environment. This function should take care of the
majority of use cases but the other variants can be useful for
specific problems.
</p>

<ul>
<li> <p><code>env_bind()</code> takes named <em>values</em> which are bound in <code>.env</code>.
<code>env_bind()</code> is equivalent to <code><a href="base.html#topic+assign">base::assign()</a></code>.
</p>
</li>
<li> <p><code>env_bind_active()</code> takes named <em>functions</em> and creates active
bindings in <code>.env</code>. This is equivalent to
<code><a href="base.html#topic+bindenv">base::makeActiveBinding()</a></code>. An active binding executes a
function each time it is evaluated. The arguments are passed to
<code><a href="rlang.html#topic+as_function">as_function()</a></code> so you can supply formulas instead of functions.
</p>
<p>Remember that functions are scoped in their own environment.
These functions can thus refer to symbols from this enclosure
that are not actually in scope in the dynamic environment where
the active bindings are invoked. This allows creative solutions
to difficult problems (see the implementations of <code>dplyr::do()</code>
methods for an example).
</p>
</li>
<li> <p><code>env_bind_lazy()</code> takes named <em>expressions</em>. This is equivalent
to <code><a href="base.html#topic+delayedAssign">base::delayedAssign()</a></code>. The arguments are captured with
<code><a href="rlang.html#topic+exprs">exprs()</a></code> (and thus support call-splicing and unquoting) and
assigned to symbols in <code>.env</code>. These expressions are not
evaluated immediately but lazily. Once a symbol is evaluated, the
corresponding expression is evaluated in turn and its value is
bound to the symbol (the expressions are thus evaluated only
once, if at all).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;%&lt;~%&#8288;</code> is a shortcut for <code>env_bind_lazy()</code>. It works like <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>
but the RHS is evaluated lazily.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>env_bind(.env, ...)

env_bind_lazy(.env, ..., .eval_env = caller_env())

env_bind_active(.env, ...)

lhs %&lt;~% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_bind_+3A_.env">.env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_bind_+3A_...">...</code></td>
<td>
<p>&lt;<a href="rlang.html#topic+dyn-dots">dynamic</a>&gt; Named objects (<code>env_bind()</code>),
expressions <code>env_bind_lazy()</code>, or functions (<code>env_bind_active()</code>).
Use <code><a href="purrr.html#topic+zap">zap()</a></code> to remove bindings.</p>
</td></tr>
<tr><td><code id="env_bind_+3A_.eval_env">.eval_env</code></td>
<td>
<p>The environment where the expressions will be
evaluated when the symbols are forced.</p>
</td></tr>
<tr><td><code id="env_bind_+3A_lhs">lhs</code></td>
<td>
<p>The variable name to which <code>rhs</code> will be lazily assigned.</p>
</td></tr>
<tr><td><code id="env_bind_+3A_rhs">rhs</code></td>
<td>
<p>An expression lazily evaluated and assigned to <code>lhs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object <code>.env</code>, with its associated environment
modified in place, invisibly.
</p>


<h3>Side effects</h3>

<p>Since environments have reference semantics (see relevant section
in <code><a href="rlang.html#topic+env">env()</a></code> documentation), modifying the bindings of an environment
produces effects in all other references to that environment. In
other words, <code>env_bind()</code> and its variants have side effects.
</p>
<p>Like other side-effecty functions like <code>par()</code> and <code>options()</code>,
<code>env_bind()</code> and variants return the old values invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+env_poke">env_poke()</a></code> for binding a single element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># env_bind() is a programmatic way of assigning values to symbols
# with `&lt;-`. We can add bindings in the current environment:
env_bind(current_env(), foo = "bar")
foo

# Or modify those bindings:
bar &lt;- "bar"
env_bind(current_env(), bar = "BAR")
bar

# You can remove bindings by supplying zap sentinels:
env_bind(current_env(), foo = zap())
try(foo)

# Unquote-splice a named list of zaps
zaps &lt;- rep_named(c("foo", "bar"), list(zap()))
env_bind(current_env(), !!!zaps)
try(bar)

# It is most useful to change other environments:
my_env &lt;- env()
env_bind(my_env, foo = "foo")
my_env$foo

# A useful feature is to splice lists of named values:
vals &lt;- list(a = 10, b = 20)
env_bind(my_env, !!!vals, c = 30)
my_env$b
my_env$c

# You can also unquote a variable referring to a symbol or a string
# as binding name:
var &lt;- "baz"
env_bind(my_env, !!var := "BAZ")
my_env$baz


# The old values of the bindings are returned invisibly:
old &lt;- env_bind(my_env, a = 1, b = 2, baz = "baz")
old

# You can restore the original environment state by supplying the
# old values back:
env_bind(my_env, !!!old)

# env_bind_lazy() assigns expressions lazily:
env &lt;- env()
env_bind_lazy(env, name = { cat("forced!\n"); "value" })

# Referring to the binding will cause evaluation:
env$name

# But only once, subsequent references yield the final value:
env$name

# You can unquote expressions:
expr &lt;- quote(message("forced!"))
env_bind_lazy(env, name = !!expr)
env$name


# By default the expressions are evaluated in the current
# environment. For instance we can create a local binding and refer
# to it, even though the variable is bound in a different
# environment:
who &lt;- "mickey"
env_bind_lazy(env, name = paste(who, "mouse"))
env$name

# You can specify another evaluation environment with `.eval_env`:
eval_env &lt;- env(who = "minnie")
env_bind_lazy(env, name = paste(who, "mouse"), .eval_env = eval_env)
env$name

# Or by unquoting a quosure:
quo &lt;- local({
  who &lt;- "fievel"
  quo(paste(who, "mouse"))
})
env_bind_lazy(env, name = !!quo)
env$name

# You can create active bindings with env_bind_active(). Active
# bindings execute a function each time they are evaluated:
fn &lt;- function() {
  cat("I have been called\n")
  rnorm(1)
}

env &lt;- env()
env_bind_active(env, symbol = fn)

# `fn` is executed each time `symbol` is evaluated or retrieved:
env$symbol
env$symbol
eval_bare(quote(symbol), env)
eval_bare(quote(symbol), env)

# All arguments are passed to as_function() so you can use the
# formula shortcut:
env_bind_active(env, foo = ~ runif(1))
env$foo
env$foo
</code></pre>

<hr>
<h2 id='env_binding_are_active'>What kind of environment binding?</h2><span id='topic+env_binding_are_active'></span><span id='topic+env_binding_are_lazy'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_binding_are_active(env, nms = NULL)

env_binding_are_lazy(env, nms = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_binding_are_active_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_binding_are_active_+3A_nms">nms</code></td>
<td>
<p>Names of bindings. Defaults to all bindings in <code>env</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector as long as <code>nms</code> and named after it.
</p>

<hr>
<h2 id='env_binding_lock'>Lock or unlock environment bindings</h2><span id='topic+env_binding_lock'></span><span id='topic+env_binding_unlock'></span><span id='topic+env_binding_are_locked'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Locked environment bindings trigger an error when an attempt is
made to redefine the binding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_binding_lock(env, nms = NULL)

env_binding_unlock(env, nms = NULL)

env_binding_are_locked(env, nms = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_binding_lock_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_binding_lock_+3A_nms">nms</code></td>
<td>
<p>Names of bindings. Defaults to all bindings in <code>env</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>env_binding_are_unlocked()</code> returns a logical vector as
long as <code>nms</code> and named after it. <code>env_binding_lock()</code> and
<code>env_binding_unlock()</code> return the old value of
<code>env_binding_are_unlocked()</code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+env_lock">env_lock()</a></code> for locking an environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bindings are unlocked by default:
env &lt;- env(a = "A", b = "B")
env_binding_are_locked(env)

# But can optionally be locked:
env_binding_lock(env, "a")
env_binding_are_locked(env)

# If run, the following would now return an error because `a` is locked:
# env_bind(env, a = "foo")
# with_env(env, a &lt;- "bar")

# Let's unlock it. Note that the return value indicate which
# bindings were locked:
were_locked &lt;- env_binding_unlock(env)
were_locked

# Now that it is unlocked we can modify it again:
env_bind(env, a = "foo")
with_env(env, a &lt;- "bar")
env$a
</code></pre>

<hr>
<h2 id='env_browse'>Browse environments</h2><span id='topic+env_browse'></span><span id='topic+env_is_browsed'></span>

<h3>Description</h3>


<ul>
<li> <p><code>env_browse(env)</code> is equivalent to evaluating <code>browser()</code> in
<code>env</code>. It persistently sets the environment for step-debugging.
Supply <code>value = FALSE</code> to disable browsing.
</p>
</li>
<li> <p><code>env_is_browsed()</code> is a predicate that inspects whether an
environment is being browsed.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>env_browse(env, value = TRUE)

env_is_browsed(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_browse_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_browse_+3A_value">value</code></td>
<td>
<p>Whether to browse <code>env</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>env_browse()</code> returns the previous value of
<code>env_is_browsed()</code> (a logical), invisibly.
</p>

<hr>
<h2 id='env_bury'>Mask bindings by defining symbols deeper in a scope</h2><span id='topic+env_bury'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>This function is superseded. Please use <code><a href="rlang.html#topic+env">env()</a></code> (and possibly
<code><a href="rlang.html#topic+set_env">set_env()</a></code> if you're masking the bindings for another object like
a closure or a formula) instead.
</p>
<p><code>env_bury()</code> is like <code><a href="rlang.html#topic+env_bind">env_bind()</a></code> but it creates the bindings in a
new child environment. This makes sure the new bindings have
precedence over old ones, without altering existing environments.
Unlike <code>env_bind()</code>, this function does not have side effects and
returns a new environment (or object wrapping that environment).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_bury(.env, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_bury_+3A_.env">.env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_bury_+3A_...">...</code></td>
<td>
<p>&lt;<a href="rlang.html#topic+dyn-dots">dynamic</a>&gt; Named objects (<code>env_bind()</code>),
expressions <code>env_bind_lazy()</code>, or functions (<code>env_bind_active()</code>).
Use <code><a href="purrr.html#topic+zap">zap()</a></code> to remove bindings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>.env</code> enclosing the new environment containing
bindings to <code>...</code> arguments.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+env_bind">env_bind()</a></code>, <code><a href="rlang.html#topic+env_unbind">env_unbind()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig_env &lt;- env(a = 10)
fn &lt;- set_env(function() a, orig_env)

# fn() currently sees `a` as the value `10`:
fn()

# env_bury() will bury the current scope of fn() behind a new
# environment:
fn &lt;- env_bury(fn, a = 1000)
fn()

# Even though the symbol `a` is still defined deeper in the scope:
orig_env$a
</code></pre>

<hr>
<h2 id='env_cache'>Cache a value in an environment</h2><span id='topic+env_cache'></span>

<h3>Description</h3>

<p><code>env_cache()</code> is a wrapper around <code><a href="rlang.html#topic+env_get">env_get()</a></code> and <code><a href="rlang.html#topic+env_poke">env_poke()</a></code>
designed to retrieve a cached value from <code>env</code>.
</p>

<ul>
<li><p> If the <code>nm</code> binding exists, it returns its value.
</p>
</li>
<li><p> Otherwise, it stores the default value in <code>env</code> and returns that.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>env_cache(env, nm, default)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_cache_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_cache_+3A_nm">nm</code></td>
<td>
<p>Name of binding, a string.</p>
</td></tr>
<tr><td><code id="env_cache_+3A_default">default</code></td>
<td>
<p>The default value to store in <code>env</code> if <code>nm</code> does not
exist yet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the value of <code>nm</code> or <code>default</code> if it did not exist
yet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- env(a = "foo")

# Returns existing binding
env_cache(e, "a", "default")

# Creates a `b` binding and returns its default value
env_cache(e, "b", "default")

# Now `b` is defined
e$b
</code></pre>

<hr>
<h2 id='env_clone'>Clone or coalesce an environment</h2><span id='topic+env_clone'></span><span id='topic+env_coalesce'></span>

<h3>Description</h3>


<ul>
<li> <p><code>env_clone()</code> creates a new environment containing exactly the
same bindings as the input, optionally with a new parent.
</p>
</li>
<li> <p><code>env_coalesce()</code> copies binding from the RHS environment into the
LHS. If the RHS already contains bindings with the same name as
in the LHS, those are kept as is.
</p>
</li></ul>

<p>Both these functions preserve active bindings and promises (the
latter are only preserved on R &gt;= 4.0.0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_clone(env, parent = env_parent(env))

env_coalesce(env, from)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_clone_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_clone_+3A_parent">parent</code></td>
<td>
<p>The parent of the cloned environment.</p>
</td></tr>
<tr><td><code id="env_clone_+3A_from">from</code></td>
<td>
<p>Environment to copy bindings from.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A clone initially contains the same bindings as the original
# environment
env &lt;- env(a = 1, b = 2)
clone &lt;- env_clone(env)

env_print(clone)
env_print(env)

# But it can acquire new bindings or change existing ones without
# impacting the original environment
env_bind(clone, a = "foo", c = 3)

env_print(clone)
env_print(env)


# `env_coalesce()` copies bindings from one environment to another
lhs &lt;- env(a = 1)
rhs &lt;- env(a = "a", b = "b", c = "c")
env_coalesce(lhs, rhs)
env_print(lhs)

# To copy all the bindings from `rhs` into `lhs`, first delete the
# conflicting bindings from `rhs`
env_unbind(lhs, env_names(rhs))
env_coalesce(lhs, rhs)
env_print(lhs)
</code></pre>

<hr>
<h2 id='env_depth'>Depth of an environment chain</h2><span id='topic+env_depth'></span>

<h3>Description</h3>

<p>This function returns the number of environments between <code>env</code> and
the <a href="rlang.html#topic+empty_env">empty environment</a>, including <code>env</code>. The depth of
<code>env</code> is also the number of parents of <code>env</code> (since the empty
environment counts as a parent).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_depth(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_depth_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer.
</p>


<h3>See Also</h3>

<p>The section on inheritance in <code><a href="rlang.html#topic+env">env()</a></code> documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env_depth(empty_env())
env_depth(pkg_env("rlang"))
</code></pre>

<hr>
<h2 id='env_get'>Get an object in an environment</h2><span id='topic+env_get'></span><span id='topic+env_get_list'></span>

<h3>Description</h3>

<p><code>env_get()</code> extracts an object from an enviroment <code>env</code>. By
default, it does not look in the parent environments.
<code>env_get_list()</code> extracts multiple objects from an environment into
a named list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_get(env = caller_env(), nm, default, inherit = FALSE, last = empty_env())

env_get_list(
  env = caller_env(),
  nms,
  default,
  inherit = FALSE,
  last = empty_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_get_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_get_+3A_nm">nm</code></td>
<td>
<p>Name of binding, a string.</p>
</td></tr>
<tr><td><code id="env_get_+3A_default">default</code></td>
<td>
<p>A default value in case there is no binding for <code>nm</code>
in <code>env</code>.</p>
</td></tr>
<tr><td><code id="env_get_+3A_inherit">inherit</code></td>
<td>
<p>Whether to look for bindings in the parent
environments.</p>
</td></tr>
<tr><td><code id="env_get_+3A_last">last</code></td>
<td>
<p>Last environment inspected when <code>inherit</code> is <code>TRUE</code>.
Can be useful in conjunction with <code><a href="base.html#topic+ns-topenv">base::topenv()</a></code>.</p>
</td></tr>
<tr><td><code id="env_get_+3A_nms">nms</code></td>
<td>
<p>Names of bindings, a character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object if it exists. Otherwise, throws an error.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+env_cache">env_cache()</a></code> for a variant of <code>env_get()</code> designed to
cache a value in an environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent &lt;- child_env(NULL, foo = "foo")
env &lt;- child_env(parent, bar = "bar")

# This throws an error because `foo` is not directly defined in env:
# env_get(env, "foo")

# However `foo` can be fetched in the parent environment:
env_get(env, "foo", inherit = TRUE)

# You can also avoid an error by supplying a default value:
env_get(env, "foo", default = "FOO")
</code></pre>

<hr>
<h2 id='env_has'>Does an environment have or see bindings?</h2><span id='topic+env_has'></span>

<h3>Description</h3>

<p><code>env_has()</code> is a vectorised predicate that queries whether an
environment owns bindings personally (with <code>inherit</code> set to
<code>FALSE</code>, the default), or sees them in its own environment or in
any of its parents (with <code>inherit = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_has(env = caller_env(), nms, inherit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_has_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_has_+3A_nms">nms</code></td>
<td>
<p>A character vector of binding names for which to check
existence.</p>
</td></tr>
<tr><td><code id="env_has_+3A_inherit">inherit</code></td>
<td>
<p>Whether to look for bindings in the parent
environments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named logical vector as long as <code>nms</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent &lt;- child_env(NULL, foo = "foo")
env &lt;- child_env(parent, bar = "bar")

# env does not own `foo` but sees it in its parent environment:
env_has(env, "foo")
env_has(env, "foo", inherit = TRUE)
</code></pre>

<hr>
<h2 id='env_inherits'>Does environment inherit from another environment?</h2><span id='topic+env_inherits'></span>

<h3>Description</h3>

<p>This returns <code>TRUE</code> if <code>x</code> has <code>ancestor</code> among its parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_inherits(env, ancestor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_inherits_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_inherits_+3A_ancestor">ancestor</code></td>
<td>
<p>Another environment from which <code>x</code> might inherit.</p>
</td></tr>
</table>

<hr>
<h2 id='env_is_user_facing'>Is frame environment user facing?</h2><span id='topic+env_is_user_facing'></span>

<h3>Description</h3>

<p>Detects if <code>env</code> is user-facing, that is, whether it's an environment
that inherits from:
</p>

<ul>
<li><p> The global environment, as would happen when called interactively
</p>
</li>
<li><p> A package that is currently being tested
</p>
</li></ul>

<p>If either is true, we consider <code>env</code> to belong to an evaluation
frame that was called <em>directly</em> by the end user. This is by
contrast to <em>indirect</em> calls by third party functions which are not
user facing.
</p>
<p>For instance the <a href="https://lifecycle.r-lib.org/">lifecycle</a> package
uses <code>env_is_user_facing()</code> to figure out whether a deprecated function
was called directly or indirectly, and select an appropriate
verbosity level as a function of that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_is_user_facing(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_is_user_facing_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
</table>


<h3>Escape hatch</h3>

<p>You can override the return value of <code>env_is_user_facing()</code> by
setting the global option <code>"rlang_user_facing"</code> to:
</p>

<ul>
<li> <p><code>TRUE</code> or <code>FALSE</code>.
</p>
</li>
<li><p> A package name as a string. Then <code>env_is_user_facing(x)</code> returns
<code>TRUE</code> if <code>x</code> inherits from the namespace corresponding to that
package name.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- function() {
  env_is_user_facing(caller_env())
}

# Direct call of `fn()` from the global env
with(global_env(), fn())

# Indirect call of `fn()` from a package
with(ns_env("utils"), fn())
</code></pre>

<hr>
<h2 id='env_lock'>Lock an environment</h2><span id='topic+env_lock'></span><span id='topic+env_is_locked'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Locked environments cannot be modified. An important example is
namespace environments which are locked by R when loaded in a
session. Once an environment is locked it normally cannot be
unlocked.
</p>
<p>Note that only the environment as a container is locked, not the
individual bindings. You can't remove or add a binding but you can
still modify the values of existing bindings. See
<code><a href="rlang.html#topic+env_binding_lock">env_binding_lock()</a></code> for locking individual bindings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_lock(env)

env_is_locked(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_lock_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The old value of <code>env_is_locked()</code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+env_binding_lock">env_binding_lock()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># New environments are unlocked by default:
env &lt;- env(a = 1)
env_is_locked(env)

# Use env_lock() to lock them:
env_lock(env)
env_is_locked(env)

# Now that `env` is locked, it is no longer possible to remove or
# add bindings. If run, the following would fail:
# env_unbind(env, "a")
# env_bind(env, b = 2)

# Note that even though the environment as a container is locked,
# the individual bindings are still unlocked and can be modified:
env$a &lt;- 10
</code></pre>

<hr>
<h2 id='env_name'>Label of an environment</h2><span id='topic+env_name'></span><span id='topic+env_label'></span>

<h3>Description</h3>

<p>Special environments like the global environment have their own
names. <code>env_name()</code> returns:
</p>

<ul>
<li><p> &quot;global&quot; for the global environment.
</p>
</li>
<li><p> &quot;empty&quot; for the empty environment.
</p>
</li>
<li><p> &quot;base&quot; for the base package environment (the last environment on
the search path).
</p>
</li>
<li><p> &quot;namespace:pkg&quot; if <code>env</code> is the namespace of the package &quot;pkg&quot;.
</p>
</li>
<li><p> The <code>name</code> attribute of <code>env</code> if it exists. This is how the
<a href="rlang.html#topic+search_envs">package environments</a> and the <a href="rlang.html#topic+ns_imports_env">imports environments</a> store their names. The name of package
environments is typically &quot;package:pkg&quot;.
</p>
</li>
<li><p> The empty string <code>""</code> otherwise.
</p>
</li></ul>

<p><code>env_label()</code> is exactly like <code>env_name()</code> but returns the memory
address of anonymous environments as fallback.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_name(env)

env_label(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_name_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Some environments have specific names:
env_name(global_env())
env_name(ns_env("rlang"))

# Anonymous environments don't have names but are labelled by their
# address in memory:
env_name(env())
env_label(env())
</code></pre>

<hr>
<h2 id='env_names'>Names and numbers of symbols bound in an environment</h2><span id='topic+env_names'></span><span id='topic+env_length'></span>

<h3>Description</h3>

<p><code>env_names()</code> returns object names from an enviroment <code>env</code> as a
character vector. All names are returned, even those starting with
a dot. <code>env_length()</code> returns the number of bindings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_names(env)

env_length(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_names_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of object names.
</p>


<h3>Names of symbols and objects</h3>

<p>Technically, objects are bound to symbols rather than strings,
since the R interpreter evaluates symbols (see <code><a href="rlang.html#topic+is_expression">is_expression()</a></code> for a
discussion of symbolic objects versus literal objects). However it
is often more convenient to work with strings. In rlang
terminology, the string corresponding to a symbol is called the
<em>name</em> of the symbol (or by extension the name of an object bound
to a symbol).
</p>


<h3>Encoding</h3>

<p>There are deep encoding issues when you convert a string to symbol
and vice versa. Symbols are <em>always</em> in the native encoding. If
that encoding (let's say latin1) cannot support some characters,
these characters are serialised to ASCII. That's why you sometimes
see strings looking like <code style="white-space: pre;">&#8288;&lt;U+1234&gt;&#8288;</code>, especially if you're running
Windows (as R doesn't support UTF-8 as native encoding on that
platform).
</p>
<p>To alleviate some of the encoding pain, <code>env_names()</code> always
returns a UTF-8 character vector (which is fine even on Windows)
with ASCII unicode points translated back to UTF-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env &lt;- env(a = 1, b = 2)
env_names(env)
</code></pre>

<hr>
<h2 id='env_parent'>Get parent environments</h2><span id='topic+env_parent'></span><span id='topic+env_tail'></span><span id='topic+env_parents'></span>

<h3>Description</h3>


<ul>
<li> <p><code>env_parent()</code> returns the parent environment of <code>env</code> if called
with <code>n = 1</code>, the grandparent with <code>n = 2</code>, etc.
</p>
</li>
<li> <p><code>env_tail()</code> searches through the parents and returns the one
which has <code><a href="rlang.html#topic+empty_env">empty_env()</a></code> as parent.
</p>
</li>
<li> <p><code>env_parents()</code> returns the list of all parents, including the
empty environment. This list is named using <code><a href="rlang.html#topic+env_name">env_name()</a></code>.
</p>
</li></ul>

<p>See the section on <em>inheritance</em> in <code><a href="rlang.html#topic+env">env()</a></code>'s documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_parent(env = caller_env(), n = 1)

env_tail(env = caller_env(), last = global_env())

env_parents(env = caller_env(), last = global_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_parent_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_parent_+3A_n">n</code></td>
<td>
<p>The number of generations to go up.</p>
</td></tr>
<tr><td><code id="env_parent_+3A_last">last</code></td>
<td>
<p>The environment at which to stop. Defaults to the
global environment. The empty environment is always a stopping
condition so it is safe to leave the default even when taking the
tail or the parents of an environment on the search path.
</p>
<p><code>env_tail()</code> returns the environment which has <code>last</code> as parent
and <code>env_parents()</code> returns the list of environments up to <code>last</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment for <code>env_parent()</code> and <code>env_tail()</code>, a list
of environments for <code>env_parents()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the parent environment with env_parent():
env_parent(global_env())

# Or the tail environment with env_tail():
env_tail(global_env())

# By default, env_parent() returns the parent environment of the
# current evaluation frame. If called at top-level (the global
# frame), the following two expressions are equivalent:
env_parent()
env_parent(base_env())

# This default is more handy when called within a function. In this
# case, the enclosure environment of the function is returned
# (since it is the parent of the evaluation frame):
enclos_env &lt;- env()
fn &lt;- set_env(function() env_parent(), enclos_env)
identical(enclos_env, fn())
</code></pre>

<hr>
<h2 id='env_poke'>Poke an object in an environment</h2><span id='topic+env_poke'></span>

<h3>Description</h3>

<p><code>env_poke()</code> will assign or reassign a binding in <code>env</code> if <code>create</code>
is <code>TRUE</code>. If <code>create</code> is <code>FALSE</code> and a binding does not already
exists, an error is issued.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_poke(env = caller_env(), nm, value, inherit = FALSE, create = !inherit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_poke_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_poke_+3A_nm">nm</code></td>
<td>
<p>Name of binding, a string.</p>
</td></tr>
<tr><td><code id="env_poke_+3A_value">value</code></td>
<td>
<p>The value for a new binding.</p>
</td></tr>
<tr><td><code id="env_poke_+3A_inherit">inherit</code></td>
<td>
<p>Whether to look for bindings in the parent
environments.</p>
</td></tr>
<tr><td><code id="env_poke_+3A_create">create</code></td>
<td>
<p>Whether to create a binding if it does not already
exist in the environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>inherit</code> is <code>TRUE</code>, the parents environments are checked for
an existing binding to reassign. If not found and <code>create</code> is
<code>TRUE</code>, a new binding is created in <code>env</code>. The default value for
<code>create</code> is a function of <code>inherit</code>: <code>FALSE</code> when inheriting,
<code>TRUE</code> otherwise.
</p>
<p>This default makes sense because the inheriting case is mostly
for overriding an existing binding. If not found, something
probably went wrong and it is safer to issue an error. Note that
this is different to the base R operator <code style="white-space: pre;">&#8288;&lt;&lt;-&#8288;</code> which will create
a binding in the global environment instead of the current
environment when no existing binding is found in the parents.
</p>


<h3>Value</h3>

<p>The old value of <code>nm</code> or a <a href="purrr.html#topic+zap">zap sentinel</a> if the
binding did not exist yet.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+env_bind">env_bind()</a></code> for binding multiple elements. <code><a href="rlang.html#topic+env_cache">env_cache()</a></code>
for a variant of <code>env_poke()</code> designed to cache values.
</p>

<hr>
<h2 id='env_print'>Pretty-print an environment</h2><span id='topic+env_print'></span>

<h3>Description</h3>

<p>This prints:
</p>

<ul>
<li><p> The <a href="rlang.html#topic+env_label">label</a> and the parent label.
</p>
</li>
<li><p> Whether the environment is <a href="rlang.html#topic+env_lock">locked</a>.
</p>
</li>
<li><p> The bindings in the environment (up to 20 bindings). They are
printed succintly using <code>pillar::type_sum()</code> (if available,
otherwise uses an internal version of that generic). In addition
<a href="rlang.html#topic+env_bind_lazy">fancy bindings</a> (actives and promises) are
indicated as such.
</p>
</li>
<li><p> Locked bindings get a <code style="white-space: pre;">&#8288;[L]&#8288;</code> tag
</p>
</li></ul>

<p>Note that printing a package namespace (see <code><a href="pkgload.html#topic+ns_env">ns_env()</a></code>) with
<code>env_print()</code> will typically tag function bindings as <code style="white-space: pre;">&#8288;&lt;lazy&gt;&#8288;</code>
until they are evaluated the first time. This is because package
functions are lazily-loaded from disk to improve performance when
loading a package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_print(env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_print_+3A_env">env</code></td>
<td>
<p>An environment, or object that can be converted to an
environment by <code><a href="rlang.html#topic+get_env">get_env()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='env_unbind'>Remove bindings from an environment</h2><span id='topic+env_unbind'></span>

<h3>Description</h3>

<p><code>env_unbind()</code> is the complement of <code><a href="rlang.html#topic+env_bind">env_bind()</a></code>. Like <code>env_has()</code>,
it ignores the parent environments of <code>env</code> by default. Set
<code>inherit</code> to <code>TRUE</code> to track down bindings in parent environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_unbind(env = caller_env(), nms, inherit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_unbind_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env_unbind_+3A_nms">nms</code></td>
<td>
<p>A character vector of binding names to remove.</p>
</td></tr>
<tr><td><code id="env_unbind_+3A_inherit">inherit</code></td>
<td>
<p>Whether to look for bindings in the parent
environments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object <code>env</code> with its associated environment
modified in place, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env &lt;- env(foo = 1, bar = 2)
env_has(env, c("foo", "bar"))

# Remove bindings with `env_unbind()`
env_unbind(env, c("foo", "bar"))
env_has(env, c("foo", "bar"))

# With inherit = TRUE, it removes bindings in parent environments
# as well:
parent &lt;- env(empty_env(), foo = 1, bar = 2)
env &lt;- env(parent, foo = "b")

env_unbind(env, "foo", inherit = TRUE)
env_has(env, c("foo", "bar"))
env_has(env, c("foo", "bar"), inherit = TRUE)
</code></pre>

<hr>
<h2 id='env_unlock'>Unlock an environment</h2><span id='topic+env_unlock'></span>

<h3>Description</h3>

<p>This function should only be used in development tools or
interactively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_unlock(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_unlock_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Whether the environment has been unlocked.
</p>

<hr>
<h2 id='eval_bare'>Evaluate an expression in an environment</h2><span id='topic+eval_bare'></span>

<h3>Description</h3>

<p><code>eval_bare()</code> is a lower-level version of function <code><a href="base.html#topic+eval">base::eval()</a></code>.
Technically, it is a simple wrapper around the C function
<code>Rf_eval()</code>. You generally don't need to use <code>eval_bare()</code> instead
of <code>eval()</code>. Its main advantage is that it handles stack-sensitive
calls (such as <code>return()</code>, <code>on.exit()</code> or <code>parent.frame()</code>) more
consistently when you pass an enviroment of a frame on the call
stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_bare(expr, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_bare_+3A_expr">expr</code></td>
<td>
<p>An expression to evaluate.</p>
</td></tr>
<tr><td><code id="eval_bare_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate the expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These semantics are possible because <code>eval_bare()</code> creates only one
frame on the call stack whereas <code>eval()</code> creates two frames, the
second of which has the user-supplied environment as frame
environment. When you supply an existing frame environment to
<code>base::eval()</code> there will be two frames on the stack with the same
frame environment. Stack-sensitive functions only detect the
topmost of these frames. We call these evaluation semantics
&quot;stack inconsistent&quot;.
</p>
<p>Evaluating expressions in the actual frame environment has useful
practical implications for <code>eval_bare()</code>:
</p>

<ul>
<li> <p><code>return()</code> calls are evaluated in frame environments that might
be burried deep in the call stack. This causes a long return that
unwinds multiple frames (triggering the <code>on.exit()</code> event for
each frame). By contrast <code>eval()</code> only returns from the <code>eval()</code>
call, one level up.
</p>
</li>
<li> <p><code>on.exit()</code>, <code>parent.frame()</code>, <code>sys.call()</code>, and generally all
the stack inspection functions <code>sys.xxx()</code> are evaluated in the
correct frame environment. This is similar to how this type of
calls can be evaluated deep in the call stack because of lazy
evaluation, when you force an argument that has been passed
around several times.
</p>
</li></ul>

<p>The flip side of the semantics of <code>eval_bare()</code> is that it can't
evaluate <code>break</code> or <code>next</code> expressions even if called within a
loop.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code> for evaluation with data mask and quosure
support.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># eval_bare() works just like base::eval() but you have to create
# the evaluation environment yourself:
eval_bare(quote(foo), env(foo = "bar"))

# eval() has different evaluation semantics than eval_bare(). It
# can return from the supplied environment even if its an
# environment that is not on the call stack (i.e. because you've
# created it yourself). The following would trigger an error with
# eval_bare():
ret &lt;- quote(return("foo"))
eval(ret, env())
# eval_bare(ret, env())  # "no function to return from" error

# Another feature of eval() is that you can control surround loops:
bail &lt;- quote(break)
while (TRUE) {
  eval(bail)
  # eval_bare(bail)  # "no loop for break/next" error
}

# To explore the consequences of stack inconsistent semantics, let's
# create a function that evaluates `parent.frame()` deep in the call
# stack, in an environment corresponding to a frame in the middle of
# the stack. For consistency with R's lazy evaluation semantics, we'd
# expect to get the caller of that frame as result:
fn &lt;- function(eval_fn) {
  list(
    returned_env = middle(eval_fn),
    actual_env = current_env()
  )
}
middle &lt;- function(eval_fn) {
  deep(eval_fn, current_env())
}
deep &lt;- function(eval_fn, eval_env) {
  expr &lt;- quote(parent.frame())
  eval_fn(expr, eval_env)
}

# With eval_bare(), we do get the expected environment:
fn(rlang::eval_bare)

# But that's not the case with base::eval():
fn(base::eval)
</code></pre>

<hr>
<h2 id='eval_tidy'>Evaluate an expression with quosures and pronoun support</h2><span id='topic+eval_tidy'></span>

<h3>Description</h3>

<p><code>eval_tidy()</code> is a variant of <code><a href="base.html#topic+eval">base::eval()</a></code> that powers the tidy
evaluation framework. Like <code>eval()</code> it accepts user data as
argument. Whereas <code>eval()</code> simply transforms the data to an
environment, <code>eval_tidy()</code> transforms it to a <a href="rlang.html#topic+topic-data-mask">data mask</a> with <code><a href="rlang.html#topic+as_data_mask">as_data_mask()</a></code>. Evaluating in a data
mask enables the following features:
</p>

<ul>
<li> <p><a href="rlang.html#topic+topic-quosure">Quosures</a>. Quosures are expressions bundled with
an environment. If <code>data</code> is supplied, objects in the data mask
always have precedence over the quosure environment, i.e. the
data masks the environment.
</p>
</li>
<li> <p><a href="dplyr.html#topic+.data">Pronouns</a>. If <code>data</code> is supplied, the <code>.env</code> and <code>.data</code>
pronouns are installed in the data mask. <code>.env</code> is a reference to
the calling environment and <code>.data</code> refers to the <code>data</code>
argument. These pronouns are an escape hatch for the <a href="rlang.html#topic+topic-data-mask-ambiguity">data mask ambiguity</a> problem.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>eval_tidy(expr, data = NULL, env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_tidy_+3A_expr">expr</code></td>
<td>
<p>An <a href="rlang.html#topic+topic-defuse">expression</a> or
<a href="rlang.html#topic+topic-quosure">quosure</a> to evaluate.</p>
</td></tr>
<tr><td><code id="eval_tidy_+3A_data">data</code></td>
<td>
<p>A data frame, or named list or vector. Alternatively, a
data mask created with <code><a href="rlang.html#topic+as_data_mask">as_data_mask()</a></code> or
<code><a href="rlang.html#topic+new_data_mask">new_data_mask()</a></code>. Objects in <code>data</code> have priority over those in
<code>env</code>. See the section about data masking.</p>
</td></tr>
<tr><td><code id="eval_tidy_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate <code>expr</code>. This
environment is not applicable for quosures because they have
their own environments.</p>
</td></tr>
</table>


<h3>When should eval_tidy() be used instead of eval()?</h3>

<p><code>base::eval()</code> is sufficient for simple evaluation. Use
<code>eval_tidy()</code> when you'd like to support expressions referring to
the <code>.data</code> pronoun, or when you need to support quosures.
</p>
<p>If you're evaluating an expression captured with
<a href="rlang.html#topic+topic-inject">injection</a> support, it is recommended to use
<code>eval_tidy()</code> because users may inject quosures.
</p>
<p>Note that unwrapping a quosure with <code><a href="rlang.html#topic+quo_get_expr">quo_get_expr()</a></code> does not
guarantee that there is no quosures inside the expression. Quosures
might be unquoted anywhere in the expression tree. For instance,
the following does not work reliably in the presence of nested
quosures:
</p>
<div class="sourceCode"><pre>my_quoting_fn &lt;- function(x) {
  x &lt;- enquo(x)
  expr &lt;- quo_get_expr(x)
  env &lt;- quo_get_env(x)
  eval(expr, env)
}

# Works:
my_quoting_fn(toupper(letters))

# Fails because of a nested quosure:
my_quoting_fn(toupper(!!quo(letters)))
</pre></div>


<h3>Stack semantics of <code>eval_tidy()</code></h3>

<p><code>eval_tidy()</code> always evaluates in a data mask, even when <code>data</code> is
<code>NULL</code>. Because of this, it has different stack semantics than
<code><a href="base.html#topic+eval">base::eval()</a></code>:
</p>

<ul>
<li><p> Lexical side effects, such as assignment with <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>, occur in the
mask rather than <code>env</code>.
</p>
</li>
<li><p> Functions that require the evaluation environment to correspond
to a frame on the call stack do not work. This is why <code>return()</code>
called from a quosure does not work.
</p>
</li>
<li><p> The mask environment creates a new branch in the tree
representation of backtraces (which you can visualise in a
<code><a href="base.html#topic+browser">browser()</a></code> session with <code>lobstr::cst()</code>).
</p>
</li></ul>

<p>See also <code><a href="rlang.html#topic+eval_bare">eval_bare()</a></code> for more information about these differences.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-data-mask">What is data-masking and why do I need {{?</a>.
</p>
</li>
<li> <p><a href="rlang.html#topic+topic-quosure">What are quosures and when are they needed?</a>.
</p>
</li>
<li> <p><a href="rlang.html#topic+topic-defuse">Defusing R expressions</a>.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+new_data_mask">new_data_mask()</a></code> and <code><a href="rlang.html#topic+as_data_mask">as_data_mask()</a></code> for manually creating data masks.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# With simple defused expressions eval_tidy() works the same way as
# eval():
fruit &lt;- "apple"
vegetable &lt;- "potato"
expr &lt;- quote(paste(fruit, vegetable, sep = " or "))
expr

eval(expr)
eval_tidy(expr)

# Both accept a data mask as argument:
data &lt;- list(fruit = "banana", vegetable = "carrot")
eval(expr, data)
eval_tidy(expr, data)

# The main difference is that eval_tidy() supports quosures:
with_data &lt;- function(data, expr) {
  quo &lt;- enquo(expr)
  eval_tidy(quo, data)
}
with_data(NULL, fruit)
with_data(data, fruit)

# eval_tidy() installs the `.data` and `.env` pronouns to allow
# users to be explicit about variable references:
with_data(data, .data$fruit)
with_data(data, .env$fruit)
</code></pre>

<hr>
<h2 id='exec'>Execute a function</h2><span id='topic+exec'></span>

<h3>Description</h3>

<p>This function constructs and evaluates a call to <code>.fn</code>.
It has two primary uses:
</p>

<ul>
<li><p> To call a function with arguments stored in a list (if the
function doesn't support <a href="rlang.html#topic+dyn-dots">dynamic dots</a>). Splice the
list of arguments with <code style="white-space: pre;">&#8288;!!!&#8288;</code>.
</p>
</li>
<li><p> To call every function stored in a list (in conjunction with <code>map()</code>/
<code><a href="base.html#topic+lapply">lapply()</a></code>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>exec(.fn, ..., .env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exec_+3A_.fn">.fn</code></td>
<td>
<p>A function, or function name as a string.</p>
</td></tr>
<tr><td><code id="exec_+3A_...">...</code></td>
<td>
<p>&lt;<a href="rlang.html#topic+dyn-dots">dynamic</a>&gt; Arguments for <code>.fn</code>.</p>
</td></tr>
<tr><td><code id="exec_+3A_.env">.env</code></td>
<td>
<p>Environment in which to evaluate the call. This will be
most useful if <code>.fn</code> is a string, or the function has side-effects.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>args &lt;- list(x = c(1:10, 100, NA), na.rm = TRUE)
exec("mean", !!!args)
exec("mean", !!!args, trim = 0.2)

fs &lt;- list(a = function() "a", b = function() "b")
lapply(fs, exec)

# Compare to do.call it will not automatically inline expressions
# into the evaluated call.
x &lt;- 10
args &lt;- exprs(x1 = x + 1, x2 = x * 2)
exec(list, !!!args)
do.call(list, args)

# exec() is not designed to generate pretty function calls. This is
# most easily seen if you call a function that captures the call:
f &lt;- disp ~ cyl
exec("lm", f, data = mtcars)

# If you need finer control over the generated call, you'll need to
# construct it yourself. This may require creating a new environment
# with carefully constructed bindings
data_env &lt;- env(data = mtcars)
eval(expr(lm(!!f, data)), data_env)
</code></pre>

<hr>
<h2 id='expr'>Defuse an R expression</h2><span id='topic+expr'></span>

<h3>Description</h3>

<p><code>expr()</code> <a href="rlang.html#topic+topic-defuse">defuses</a> an R expression with
<a href="rlang.html#topic+injection-operator">injection</a> support.
</p>
<p>It is equivalent to <code><a href="base.html#topic+bquote">base::bquote()</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="expr_+3A_expr">expr</code></td>
<td>
<p>An expression to defuse.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-defuse">Defusing R expressions</a> for an overview.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+enquo">enquo()</a></code> to defuse non-local expressions from function
arguments.
</p>
</li>
<li> <p><a href="rlang.html#topic+defusing-advanced">Advanced defusal operators</a>.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+sym">sym()</a></code> and <code><a href="rlang.html#topic+call2">call2()</a></code> for building expressions (symbols and calls
respectively) programmatically.
</p>
</li>
<li> <p><code><a href="base.html#topic+eval">base::eval()</a></code> and <code><a href="rlang.html#topic+eval_bare">eval_bare()</a></code> for resuming evaluation
of a defused expression.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># R normally returns the result of an expression
1 + 1

# `expr()` defuses the expression that you have supplied and
# returns it instead of its value
expr(1 + 1)

expr(toupper(letters))

# It supports _injection_ with `!!` and `!!!`. This is a convenient
# way of modifying part of an expression by injecting other
# objects.
var &lt;- "cyl"
expr(with(mtcars, mean(!!sym(var))))

vars &lt;- c("cyl", "am")
expr(with(mtcars, c(!!!syms(vars))))

# Compare to the normal way of building expressions
call("with", call("mean", sym(var)))

call("with", call2("c", !!!syms(vars)))

</code></pre>

<hr>
<h2 id='expr_interp'>Process unquote operators in a captured expression</h2><span id='topic+expr_interp'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
<code>expr_interp()</code> is deprecated, please use <code><a href="rlang.html#topic+inject">inject()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expr_interp(x, env = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expr_interp_+3A_x">x</code>, <code id="expr_interp_+3A_env">env</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>

<hr>
<h2 id='expr_label'>Turn an expression to a label</h2><span id='topic+expr_label'></span><span id='topic+expr_name'></span><span id='topic+expr_text'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a>
</p>
<p><code>expr_text()</code> turns the expression into a single string, which
might be multi-line. <code>expr_name()</code> is suitable for formatting
names. It works best with symbols and scalar types, but also
accepts calls. <code>expr_label()</code> formats the expression nicely for use
in messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expr_label(expr)

expr_name(expr)

expr_text(expr, width = 60L, nlines = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expr_label_+3A_expr">expr</code></td>
<td>
<p>An expression to labellise.</p>
</td></tr>
<tr><td><code id="expr_label_+3A_width">width</code></td>
<td>
<p>Width of each line.</p>
</td></tr>
<tr><td><code id="expr_label_+3A_nlines">nlines</code></td>
<td>
<p>Maximum number of lines to extract.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># To labellise a function argument, first capture it with
# substitute():
fn &lt;- function(x) expr_label(substitute(x))
fn(x:y)

# Strings are encoded
expr_label("a\nb")

# Names and expressions are quoted with ``
expr_label(quote(x))
expr_label(quote(a + b + c))

# Long expressions are collapsed
expr_label(quote(foo({
  1 + 2
  print(x)
})))
</code></pre>

<hr>
<h2 id='expr_print'>Print an expression</h2><span id='topic+expr_print'></span><span id='topic+expr_deparse'></span>

<h3>Description</h3>

<p><code>expr_print()</code>, powered by <code>expr_deparse()</code>, is an alternative
printer for R expressions with a few improvements over the base R
printer.
</p>

<ul>
<li><p> It colourises <a href="rlang.html#topic+nse-defuse">quosures</a> according to their environment.
Quosures from the global environment are printed normally while
quosures from local environments are printed in unique colour (or
in italic when all colours are taken).
</p>
</li>
<li><p> It wraps inlined objects in angular brackets. For instance, an
integer vector unquoted in a function call (e.g.
<code>expr(foo(!!(1:3)))</code>) is printed like this: <code style="white-space: pre;">&#8288;foo(&lt;int: 1L, 2L, 3L&gt;)&#8288;</code> while by default R prints the code to create that vector:
<code>foo(1:3)</code> which is ambiguous.
</p>
</li>
<li><p> It respects the width boundary (from the global option <code>width</code>)
in more cases.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>expr_print(x, ...)

expr_deparse(x, ..., width = peek_option("width"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expr_print_+3A_x">x</code></td>
<td>
<p>An object or expression to print.</p>
</td></tr>
<tr><td><code id="expr_print_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>expr_deparse()</code>.</p>
</td></tr>
<tr><td><code id="expr_print_+3A_width">width</code></td>
<td>
<p>The width of the deparsed or printed expression.
Defaults to the global option <code>width</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>expr_deparse()</code> returns a character vector of lines.
<code>expr_print()</code> returns its input invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># It supports any object. Non-symbolic objects are always printed
# within angular brackets:
expr_print(1:3)
expr_print(function() NULL)

# Contrast this to how the code to create these objects is printed:
expr_print(quote(1:3))
expr_print(quote(function() NULL))

# The main cause of non-symbolic objects in expressions is
# quasiquotation:
expr_print(expr(foo(!!(1:3))))


# Quosures from the global environment are printed normally:
expr_print(quo(foo))
expr_print(quo(foo(!!quo(bar))))

# Quosures from local environments are colourised according to
# their environments (if you have crayon installed):
local_quo &lt;- local(quo(foo))
expr_print(local_quo)

wrapper_quo &lt;- local(quo(bar(!!local_quo, baz)))
expr_print(wrapper_quo)
</code></pre>

<hr>
<h2 id='exprs_auto_name'>Ensure that all elements of a list of expressions are named</h2><span id='topic+exprs_auto_name'></span><span id='topic+quos_auto_name'></span>

<h3>Description</h3>

<p>This gives default names to unnamed elements of a list of
expressions (or expression wrappers such as formulas or
quosures), deparsed with <code><a href="dplyr.html#topic+as_label">as_label()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exprs_auto_name(
  exprs,
  ...,
  repair_auto = c("minimal", "unique"),
  repair_quiet = FALSE
)

quos_auto_name(quos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exprs_auto_name_+3A_exprs">exprs</code></td>
<td>
<p>A list of expressions.</p>
</td></tr>
<tr><td><code id="exprs_auto_name_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="exprs_auto_name_+3A_repair_auto">repair_auto</code></td>
<td>
<p>Whether to repair the automatic names. By
default, minimal names are returned. See <code>?vctrs::vec_as_names</code>
for information about name repairing.</p>
</td></tr>
<tr><td><code id="exprs_auto_name_+3A_repair_quiet">repair_quiet</code></td>
<td>
<p>Whether to inform user about repaired names.</p>
</td></tr>
<tr><td><code id="exprs_auto_name_+3A_quos">quos</code></td>
<td>
<p>A list of quosures.</p>
</td></tr>
</table>

<hr>
<h2 id='f_rhs'>Get or set formula components</h2><span id='topic+f_rhs'></span><span id='topic+f_rhs+3C-'></span><span id='topic+f_lhs'></span><span id='topic+f_lhs+3C-'></span><span id='topic+f_env'></span><span id='topic+f_env+3C-'></span>

<h3>Description</h3>

<p><code>f_rhs</code> extracts the righthand side, <code>f_lhs</code> extracts the lefthand
side, and <code>f_env</code> extracts the environment. All functions throw an
error if <code>f</code> is not a formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_rhs(f)

f_rhs(x) &lt;- value

f_lhs(f)

f_lhs(x) &lt;- value

f_env(f)

f_env(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_rhs_+3A_f">f</code>, <code id="f_rhs_+3A_x">x</code></td>
<td>
<p>A formula</p>
</td></tr>
<tr><td><code id="f_rhs_+3A_value">value</code></td>
<td>
<p>The value to replace with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>f_rhs</code> and <code>f_lhs</code> return language objects (i.e.  atomic
vectors of length 1, a name, or a call). <code>f_env</code> returns an
environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f_rhs(~ 1 + 2 + 3)
f_rhs(~ x)
f_rhs(~ "A")
f_rhs(1 ~ 2)

f_lhs(~ y)
f_lhs(x ~ y)

f_env(~ x)
</code></pre>

<hr>
<h2 id='f_text'>Turn RHS of formula into a string or label</h2><span id='topic+f_text'></span><span id='topic+f_name'></span><span id='topic+f_label'></span>

<h3>Description</h3>

<p>Equivalent of <code><a href="lazyeval.html#topic+expr_text">expr_text()</a></code> and <code><a href="lazyeval.html#topic+expr_label">expr_label()</a></code> for formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_text(x, width = 60L, nlines = Inf)

f_name(x)

f_label(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_text_+3A_x">x</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="f_text_+3A_width">width</code></td>
<td>
<p>Width of each line.</p>
</td></tr>
<tr><td><code id="f_text_+3A_nlines">nlines</code></td>
<td>
<p>Maximum number of lines to extract.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- ~ a + b + bc
f_text(f)
f_label(f)

# Names a quoted with ``
f_label(~ x)
# Strings are encoded
f_label(~ "a\nb")
# Long expressions are collapsed
f_label(~ foo({
  1 + 2
  print(x)
}))
</code></pre>

<hr>
<h2 id='faq-options'>Global options for rlang</h2><span id='topic+faq-options'></span>

<h3>Description</h3>

<p>rlang has several options which may be set globally to control
behavior. A brief description of each is given here. If any functions
are referenced, refer to their documentation for additional details.
</p>

<ul>
<li> <p><code>rlang_interactive</code>: A logical value used by <code><a href="rlang.html#topic+is_interactive">is_interactive()</a></code>. This
can be set to <code>TRUE</code> to test interactive behavior in unit tests,
for example.
</p>
</li>
<li> <p><code>rlang_backtrace_on_error</code>: A character string which controls whether
backtraces are displayed with error messages, and the level of
detail they print. See <a href="rlang.html#topic+rlang_backtrace_on_error">rlang_backtrace_on_error</a> for the possible option values.
</p>
</li>
<li> <p><code>rlang_trace_format_srcrefs</code>: A logical value used to control whether
srcrefs are printed as part of the backtrace.
</p>
</li>
<li> <p><code>rlang_trace_top_env</code>: An environment which will be treated as the
top-level environment when printing traces. See <code><a href="rlang.html#topic+trace_back">trace_back()</a></code>
for examples.
</p>
</li></ul>


<hr>
<h2 id='ffi_standalone_types_check'>Internal API for standalone-types-check</h2><span id='topic+ffi_standalone_types_check'></span><span id='topic+ffi_standalone_is_bool_1.0.7'></span><span id='topic+ffi_standalone_check_number_1.0.7'></span>

<h3>Description</h3>

<p>Internal API for standalone-types-check
</p>

<hr>
<h2 id='flatten'>Flatten or squash a list of lists into a simpler vector</h2><span id='topic+flatten'></span><span id='topic+flatten_lgl'></span><span id='topic+flatten_int'></span><span id='topic+flatten_dbl'></span><span id='topic+flatten_cpl'></span><span id='topic+flatten_chr'></span><span id='topic+flatten_raw'></span><span id='topic+squash'></span><span id='topic+squash_lgl'></span><span id='topic+squash_int'></span><span id='topic+squash_dbl'></span><span id='topic+squash_cpl'></span><span id='topic+squash_chr'></span><span id='topic+squash_raw'></span><span id='topic+flatten_if'></span><span id='topic+squash_if'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions are deprecated in favour of <code>purrr::list_c()</code> and
<code>purrr::list_flatten()</code>.
</p>
<p><code>flatten()</code> removes one level hierarchy from a list, while
<code>squash()</code> removes all levels. These functions are similar to
<code><a href="base.html#topic+unlist">unlist()</a></code> but they are type-stable so you always know what the
type of the output is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten(x)

flatten_lgl(x)

flatten_int(x)

flatten_dbl(x)

flatten_cpl(x)

flatten_chr(x)

flatten_raw(x)

squash(x)

squash_lgl(x)

squash_int(x)

squash_dbl(x)

squash_cpl(x)

squash_chr(x)

squash_raw(x)

flatten_if(x, predicate = is_spliced)

squash_if(x, predicate = is_spliced)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_+3A_x">x</code></td>
<td>
<p>A list to flatten or squash. The contents of the list can
be anything for unsuffixed functions <code>flatten()</code> and <code>squash()</code>
(as a list is returned), but the contents must match the type for
the other functions.</p>
</td></tr>
<tr><td><code id="flatten_+3A_predicate">predicate</code></td>
<td>
<p>A function of one argument returning whether it
should be spliced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>flatten()</code> returns a list, <code>flatten_lgl()</code> a logical
vector, <code>flatten_int()</code> an integer vector, <code>flatten_dbl()</code> a
double vector, and <code>flatten_chr()</code> a character vector. Similarly
for <code>squash()</code> and the typed variants (<code>squash_lgl()</code> etc).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- replicate(2, sample(4), simplify = FALSE)
x

flatten(x)
flatten_int(x)

# With flatten(), only one level gets removed at a time:
deep &lt;- list(1, list(2, list(3)))
flatten(deep)
flatten(flatten(deep))

# But squash() removes all levels:
squash(deep)
squash_dbl(deep)

# The typed flatten functions remove one level and coerce to an atomic
# vector at the same time:
flatten_dbl(list(1, list(2)))

# Only bare lists are flattened, but you can splice S3 lists
# explicitly:
foo &lt;- set_attrs(list("bar"), class = "foo")
str(flatten(list(1, foo, list(100))))
str(flatten(list(1, splice(foo), list(100))))

# Instead of splicing manually, flatten_if() and squash_if() let
# you specify a predicate function:
is_foo &lt;- function(x) inherits(x, "foo") || is_bare_list(x)
str(flatten_if(list(1, foo, list(100)), is_foo))

# squash_if() does the same with deep lists:
deep_foo &lt;- list(1, list(foo, list(foo, 100)))
str(deep_foo)

str(squash(deep_foo))
str(squash_if(deep_foo, is_foo))
</code></pre>

<hr>
<h2 id='fn_body'>Get or set function body</h2><span id='topic+fn_body'></span><span id='topic+fn_body+3C-'></span>

<h3>Description</h3>

<p><code>fn_body()</code> is a simple wrapper around <code><a href="base.html#topic+body">base::body()</a></code>. It always
returns a <code style="white-space: pre;">&#8288;\{&#8288;</code> expression and throws an error when the input is a
primitive function (whereas <code>body()</code> returns <code>NULL</code>). The setter
version preserves attributes, unlike <code style="white-space: pre;">&#8288;body&lt;-&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fn_body(fn = caller_fn())

fn_body(fn) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fn_body_+3A_fn">fn</code></td>
<td>
<p>A function. It is looked up in the calling frame if not
supplied.</p>
</td></tr>
<tr><td><code id="fn_body_+3A_value">value</code></td>
<td>
<p>New formals or formals names for <code>fn</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># fn_body() is like body() but always returns a block:
fn &lt;- function() do()
body(fn)
fn_body(fn)

# It also throws an error when used on a primitive function:
try(fn_body(base::list))
</code></pre>

<hr>
<h2 id='fn_env'>Return the closure environment of a function</h2><span id='topic+fn_env'></span><span id='topic+fn_env+3C-'></span>

<h3>Description</h3>

<p>Closure environments define the scope of functions (see <code><a href="rlang.html#topic+env">env()</a></code>).
When a function call is evaluated, R creates an evaluation frame
that inherits from the closure environment. This makes all objects
defined in the closure environment and all its parents available to
code executed within the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fn_env(fn)

fn_env(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fn_env_+3A_fn">fn</code>, <code id="fn_env_+3A_x">x</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="fn_env_+3A_value">value</code></td>
<td>
<p>A new closure environment for the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fn_env()</code> returns the closure environment of <code>fn</code>. There is also
an assignment method to set a new closure environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env &lt;- child_env("base")
fn &lt;- with_env(env, function() NULL)
identical(fn_env(fn), env)

other_env &lt;- child_env("base")
fn_env(fn) &lt;- other_env
identical(fn_env(fn), other_env)
</code></pre>

<hr>
<h2 id='fn_fmls'>Extract arguments from a function</h2><span id='topic+fn_fmls'></span><span id='topic+fn_fmls_names'></span><span id='topic+fn_fmls_syms'></span><span id='topic+fn_fmls+3C-'></span><span id='topic+fn_fmls_names+3C-'></span>

<h3>Description</h3>

<p><code>fn_fmls()</code> returns a named list of formal arguments.
<code>fn_fmls_names()</code> returns the names of the arguments.
<code>fn_fmls_syms()</code> returns formals as a named list of symbols. This
is especially useful for forwarding arguments in <a href="rlang.html#topic+lang">constructed calls</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fn_fmls(fn = caller_fn())

fn_fmls_names(fn = caller_fn())

fn_fmls_syms(fn = caller_fn())

fn_fmls(fn) &lt;- value

fn_fmls_names(fn) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fn_fmls_+3A_fn">fn</code></td>
<td>
<p>A function. It is looked up in the calling frame if not
supplied.</p>
</td></tr>
<tr><td><code id="fn_fmls_+3A_value">value</code></td>
<td>
<p>New formals or formals names for <code>fn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code>formals()</code>, these helpers throw an error with primitive
functions instead of returning <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+call_args">call_args()</a></code> and <code><a href="rlang.html#topic+call_args_names">call_args_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extract from current call:
fn &lt;- function(a = 1, b = 2) fn_fmls()
fn()

# fn_fmls_syms() makes it easy to forward arguments:
call2("apply", !!! fn_fmls_syms(lapply))

# You can also change the formals:
fn_fmls(fn) &lt;- list(A = 10, B = 20)
fn()

fn_fmls_names(fn) &lt;- c("foo", "bar")
fn()
</code></pre>

<hr>
<h2 id='format_error_bullets'>Format bullets for error messages</h2><span id='topic+format_error_bullets'></span>

<h3>Description</h3>

<p><code>format_error_bullets()</code> takes a character vector and returns a single
string (or an empty vector if the input is empty). The elements of
the input vector are assembled as a list of bullets, depending on
their names:
</p>

<ul>
<li><p> Unnamed elements are unindented. They act as titles or subtitles.
</p>
</li>
<li><p> Elements named <code>"*"</code> are bulleted with a cyan &quot;bullet&quot; symbol.
</p>
</li>
<li><p> Elements named <code>"i"</code> are bulleted with a blue &quot;info&quot; symbol.
</p>
</li>
<li><p> Elements named <code>"x"</code> are bulleted with a red &quot;cross&quot; symbol.
</p>
</li>
<li><p> Elements named <code>"v"</code> are bulleted with a green &quot;tick&quot; symbol.
</p>
</li>
<li><p> Elements named <code>"!"</code> are bulleted with a yellow &quot;warning&quot; symbol.
</p>
</li>
<li><p> Elements named <code>"&gt;"</code> are bulleted with an &quot;arrow&quot; symbol.
</p>
</li>
<li><p> Elements named <code>" "</code> start with an indented line break.
</p>
</li></ul>

<p>For convenience, if the vector is fully unnamed, the elements are
formatted as &quot;*&quot; bullets.
</p>
<p>The bullet formatting for errors follows the idea that sentences in
error messages are best kept short and simple. The best way to
present the information is in the <code><a href="rlang.html#topic+cnd_body">cnd_body()</a></code> method of an error
conditon as a bullet list of simple sentences containing a single
clause. The info and cross symbols of the bullets provide hints on
how to interpret the bullet relative to the general error issue,
which should be supplied as <code><a href="rlang.html#topic+cnd_header">cnd_header()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_error_bullets(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_error_bullets_+3A_x">x</code></td>
<td>
<p>A named character vector of messages. Named elements are
prefixed with the corresponding bullet. Elements named with a
single space <code>" "</code> trigger a line break from the previous bullet.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># All bullets
writeLines(format_error_bullets(c("foo", "bar")))

# This is equivalent to
writeLines(format_error_bullets(set_names(c("foo", "bar"), "*")))

# Supply named elements to format info, cross, and tick bullets
writeLines(format_error_bullets(c(i = "foo", x = "bar", v = "baz", "*" = "quux")))

# An unnamed element breaks the line
writeLines(format_error_bullets(c(i = "foo\nbar")))

# A " " element breaks the line within a bullet (with indentation)
writeLines(format_error_bullets(c(i = "foo", " " = "bar")))
</code></pre>

<hr>
<h2 id='format_error_call'>Validate and format a function call for use in error messages</h2><span id='topic+format_error_call'></span><span id='topic+error_call'></span>

<h3>Description</h3>


<ul>
<li> <p><code>error_call()</code> takes either a frame environment or a call. If the
input is an environment, <code>error_call()</code> acts like <code><a href="rlang.html#topic+frame_call">frame_call()</a></code>
with some additional logic, e.g. for S3 methods and for frames
with a <code><a href="rlang.html#topic+local_error_call">local_error_call()</a></code>.
</p>
</li>
<li> <p><code>format_error_call()</code> simplifies its input to a simple call (see
section below) and formats the result as code (using cli if
available). Use this function to generate the &quot;in&quot; part of an
error message from a stack frame call.
</p>
<p><code>format_error_call()</code> first passes its input to <code>error_call()</code> to
fetch calls from frame environments.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>format_error_call(call)

error_call(call)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_error_call_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a string formatted as code or <code>NULL</code> if a simple
call could not be generated.
</p>


<h3>Details of formatting</h3>


<ul>
<li><p> The arguments of function calls are stripped.
</p>
</li>
<li><p> Complex function calls containing inlined objects return
<code>NULL</code>.
</p>
</li>
<li><p> Calls to <code>if</code> preserve the condition since it might be
informative. Branches are dropped.
</p>
</li>
<li><p> Calls to operators and other special syntax are formatted using
their names rather than the potentially confusing function form.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Arguments are stripped
writeLines(format_error_call(quote(foo(bar, baz))))

# Returns `NULL` with complex calls such as those that contain
# inlined functions
format_error_call(call2(list))

# Operators are formatted using their names rather than in
# function call form
writeLines(format_error_call(quote(1 + 2)))
</code></pre>

<hr>
<h2 id='friendly_type'>Format a type for error messages</h2><span id='topic+friendly_type'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>friendly_type()</code> is deprecated. Please use the
<code>standalone-friendly-type.R</code> file instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>friendly_type(type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="friendly_type_+3A_type">type</code></td>
<td>
<p>A type as returned by <code><a href="base.html#topic+typeof">typeof()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string of the prettified type, qualified with an
indefinite article.
</p>

<hr>
<h2 id='get_env'>Get or set the environment of an object</h2><span id='topic+get_env'></span><span id='topic+set_env'></span><span id='topic+env_poke_parent'></span>

<h3>Description</h3>

<p>These functions dispatch internally with methods for functions,
formulas and frames. If called with a missing argument, the
environment of the current evaluation frame is returned. If you
call <code>get_env()</code> with an environment, it acts as the identity
function and the environment is simply returned (this helps
simplifying code when writing generic functions for environments).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_env(env, default = NULL)

set_env(env, new_env = caller_env())

env_poke_parent(env, new_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_env_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="get_env_+3A_default">default</code></td>
<td>
<p>The default environment in case <code>env</code> does not wrap
an environment. If <code>NULL</code> and no environment could be extracted,
an error is issued.</p>
</td></tr>
<tr><td><code id="get_env_+3A_new_env">new_env</code></td>
<td>
<p>An environment to replace <code>env</code> with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While <code>set_env()</code> returns a modified copy and does not have side
effects, <code>env_poke_parent()</code> operates changes the environment by
side effect. This is because environments are
<a href="rlang.html#topic+is_copyable">uncopyable</a>. Be careful not to change environments
that you don't own, e.g. a parent environment of a function from a
package.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+quo_get_env">quo_get_env()</a></code> and <code><a href="rlang.html#topic+quo_set_env">quo_set_env()</a></code> for versions of
<code><a href="rlang.html#topic+get_env">get_env()</a></code> and <code><a href="rlang.html#topic+set_env">set_env()</a></code> that only work on quosures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Environment of closure functions:
fn &lt;- function() "foo"
get_env(fn)

# Or of quosures or formulas:
get_env(~foo)
get_env(quo(foo))


# Provide a default in case the object doesn't bundle an environment.
# Let's create an unevaluated formula:
f &lt;- quote(~foo)

# The following line would fail if run because unevaluated formulas
# don't bundle an environment (they didn't have the chance to
# record one yet):
# get_env(f)

# It is often useful to provide a default when you're writing
# functions accepting formulas as input:
default &lt;- env()
identical(get_env(f, default), default)

# set_env() can be used to set the enclosure of functions and
# formulas. Let's create a function with a particular environment:
env &lt;- child_env("base")
fn &lt;- set_env(function() NULL, env)

# That function now has `env` as enclosure:
identical(get_env(fn), env)
identical(get_env(fn), current_env())

# set_env() does not work by side effect. Setting a new environment
# for fn has no effect on the original function:
other_env &lt;- child_env(NULL)
set_env(fn, other_env)
identical(get_env(fn), other_env)

# Since set_env() returns a new function with a different
# environment, you'll need to reassign the result:
fn &lt;- set_env(fn, other_env)
identical(get_env(fn), other_env)
</code></pre>

<hr>
<h2 id='global_entrace'>Entrace unexpected errors</h2><span id='topic+global_entrace'></span>

<h3>Description</h3>

<p><code>global_entrace()</code> enriches base errors, warnings, and messages
with rlang features.
</p>

<ul>
<li><p> They are assigned a backtrace. You can configure whether to
display a backtrace on error with the <a href="rlang.html#topic+rlang_backtrace_on_error">rlang_backtrace_on_error</a>
global option.
</p>
</li>
<li><p> They are recorded in <code><a href="rlang.html#topic+last_error">last_error()</a></code>, <code><a href="rlang.html#topic+last_warnings">last_warnings()</a></code>, or
<code><a href="rlang.html#topic+last_messages">last_messages()</a></code>. You can inspect backtraces at any time by
calling these functions.
</p>
</li></ul>

<p>Set global entracing in your RProfile with:
</p>
<div class="sourceCode"><pre>rlang::global_entrace()
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>global_entrace(enable = TRUE, class = c("error", "warning", "message"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global_entrace_+3A_enable">enable</code></td>
<td>
<p>Whether to enable or disable global handling.</p>
</td></tr>
<tr><td><code id="global_entrace_+3A_class">class</code></td>
<td>
<p>A character vector of one or several classes of
conditions to be entraced.</p>
</td></tr>
</table>


<h3>Inside RMarkdown documents</h3>

<p>Call <code>global_entrace()</code> inside an RMarkdown document to cause
errors and warnings to be promoted to rlang conditions that include
a backtrace. This needs to be done in a separate setup chunk before
the first error or warning.
</p>
<p>This is useful in conjunction with
<code><a href="rlang.html#topic+rlang_backtrace_on_error_report">rlang_backtrace_on_error_report</a></code> and
<code><a href="rlang.html#topic+rlang_backtrace_on_warning_report">rlang_backtrace_on_warning_report</a></code>. To get full entracing in an
Rmd document, include this in a setup chunk before the first error
or warning is signalled.
</p>
<div class="sourceCode"><pre>```{r setup}
rlang::global_entrace()
options(rlang_backtrace_on_warning_report = "full")
options(rlang_backtrace_on_error_report = "full")
```
</pre></div>


<h3>Under the hood</h3>

<p>On R 4.0 and newer, <code>global_entrace()</code> installs a global handler
with <code>globalCallingHandlers()</code>. On older R versions, <code>entrace()</code> is
set as an <code>option(error = )</code> handler. The latter method has the
disadvantage that only one handler can be set at a time. This means
that you need to manually switch between <code>entrace()</code> and other
handlers like <code><a href="utils.html#topic+recover">recover()</a></code>. Also this causes a conflict with IDE
handlers (e.g. in RStudio).
</p>

<hr>
<h2 id='global_handle'>Register default global handlers</h2><span id='topic+global_handle'></span>

<h3>Description</h3>

<p><code>global_handle()</code> sets up a default configuration for error,
warning, and message handling. It calls:
</p>

<ul>
<li> <p><code><a href="rlang.html#topic+global_entrace">global_entrace()</a></code> to enable rlang errors and warnings globally.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+global_prompt_install">global_prompt_install()</a></code> to recover from <code>packageNotFoundError</code>s
with a user prompt to install the missing package. Note that at
the time of writing (R 4.1), there are only very limited
situations where this handler works.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>global_handle(entrace = TRUE, prompt_install = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global_handle_+3A_entrace">entrace</code></td>
<td>
<p>Passed as <code>enable</code> argument to <code><a href="rlang.html#topic+global_entrace">global_entrace()</a></code>.</p>
</td></tr>
<tr><td><code id="global_handle_+3A_prompt_install">prompt_install</code></td>
<td>
<p>Passed as <code>enable</code> argument to
<code><a href="rlang.html#topic+global_prompt_install">global_prompt_install()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='global_prompt_install'>Prompt user to install missing packages</h2><span id='topic+global_prompt_install'></span>

<h3>Description</h3>

<p>When enabled, <code>packageNotFoundError</code> thrown by <code><a href="base.html#topic+loadNamespace">loadNamespace()</a></code>
cause a user prompt to install the missing package and continue
without interrupting the current program.
</p>
<p>This is similar to how <code><a href="rlang.html#topic+check_installed">check_installed()</a></code> prompts users to install
required packages. It uses the same install strategy, using pak if
available and <code><a href="utils.html#topic+install.packages">install.packages()</a></code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_prompt_install(enable = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global_prompt_install_+3A_enable">enable</code></td>
<td>
<p>Whether to enable or disable global handling.</p>
</td></tr>
</table>

<hr>
<h2 id='glue-operators'>Name injection with <code>"{"</code> and <code>"{{"</code></h2><span id='topic+glue-operators'></span>

<h3>Description</h3>

<p><a href="rlang.html#topic+dyn-dots">Dynamic dots</a> (and <a href="rlang.html#topic+topic-data-mask">data-masked</a> dots which are dynamic by default) have built-in support for names interpolation with the <a href="https://glue.tidyverse.org/">glue package</a>.
</p>
<div class="sourceCode r"><pre>tibble::tibble(foo = 1)
#&gt; # A tibble: 1 x 1
#&gt;     foo
#&gt;   &lt;dbl&gt;
#&gt; 1     1

foo &lt;- "name"
tibble::tibble("{foo}" := 1)
#&gt; # A tibble: 1 x 1
#&gt;    name
#&gt;   &lt;dbl&gt;
#&gt; 1     1
</pre></div>
<p>Inside functions, embracing an argument with <code><a href="rlang.html#topic+embrace-operator">{{</a></code> inserts the expression supplied as argument in the string. This gives an indication on the variable or computation supplied as argument:
</p>
<div class="sourceCode r"><pre>tib &lt;- function(x) {
  tibble::tibble("var: {{ x }}" := x)
}

tib(1 + 1)
#&gt; # A tibble: 1 x 1
#&gt;   `var: 1 + 1`
#&gt;          &lt;dbl&gt;
#&gt; 1            2
</pre></div>
<p>See also <code><a href="rlang.html#topic+englue">englue()</a></code> to string-embrace outside of dynamic dots.
</p>
<div class="sourceCode r"><pre>g &lt;- function(x) {
  englue("var: {{ x }}")
}

g(1 + 1)
#&gt; [1] "var: 1 + 1"
</pre></div>
<p>Technically, <code style="white-space: pre;">&#8288;"{{"&#8288;</code> <a href="rlang.html#topic+topic-defuse">defuses</a> a function argument, calls <code><a href="dplyr.html#topic+as_label">as_label()</a></code> on the expression supplied as argument, and inserts the result in the string.
</p>


<h4><code style="white-space: pre;">&#8288;"{"&#8288;</code> and <code style="white-space: pre;">&#8288;"{{"&#8288;</code></h4>

<p>While <code>glue::glue()</code> only supports <code style="white-space: pre;">&#8288;"{"&#8288;</code>, dynamic dots support both <code style="white-space: pre;">&#8288;"{"&#8288;</code> and <code style="white-space: pre;">&#8288;"{{"&#8288;</code>. The double brace variant is similar to the embrace operator <code><a href="rlang.html#topic+embrace-operator">{{</a></code> available in <a href="rlang.html#topic+topic-data-mask">data-masked</a> arguments.
</p>
<p>In the following example, the embrace operator is used in a glue string to name the result with a default name that represents the expression supplied as argument:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  data %&gt;% dplyr::summarise("{{ var }}" := mean({{ var }}))
}

mtcars %&gt;% my_mean(cyl)
#&gt; # A tibble: 1 x 1
#&gt;     cyl
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19

mtcars %&gt;% my_mean(cyl * am)
#&gt; # A tibble: 1 x 1
#&gt;   `cyl * am`
#&gt;        &lt;dbl&gt;
#&gt; 1       2.06
</pre></div>
<p><code style="white-space: pre;">&#8288;"{{"&#8288;</code> is only meant for inserting an expression supplied as argument to a function. The result of the expression is not inspected or used. To interpolate a string stored in a variable, use the regular glue operator <code style="white-space: pre;">&#8288;"{"&#8288;</code> instead:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var, name = "mean") {
  data %&gt;% dplyr::summarise("{name}" := mean({{ var }}))
}

mtcars %&gt;% my_mean(cyl)
#&gt; # A tibble: 1 x 1
#&gt;    mean
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19

mtcars %&gt;% my_mean(cyl, name = "cyl")
#&gt; # A tibble: 1 x 1
#&gt;     cyl
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19
</pre></div>
<p>Using the wrong operator causes unexpected results:
</p>
<div class="sourceCode r"><pre>x &lt;- "name"

list2("{{ x }}" := 1)
#&gt; $`"name"`
#&gt; [1] 1

list2("{x}" := 1)
#&gt; $name
#&gt; [1] 1
</pre></div>
<p>Ideally, using <code style="white-space: pre;">&#8288;{{&#8288;</code> on regular objects would be an error. However for technical reasons it is not possible to make a distinction between function arguments and ordinary variables. See <a href="rlang.html#topic+topic-embrace-non-args">Does {{ work on regular objects?</a> for more information about this limitation.
</p>



<h4>Allow overriding default names</h4>

<p>The implementation of <code>my_mean()</code> in the previous section forces a default name onto the result. But what if the caller wants to give it a different name? In functions that take dots, it is possible to just supply a named expression to override the default. In a function like <code>my_mean()</code> that takes a named argument we need a different approach.
</p>
<p>This is where <code><a href="rlang.html#topic+englue">englue()</a></code> becomes useful. We can pull out the default name creation in another user-facing argument like this:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var, name = englue("{{ var }}")) {
  data %&gt;% dplyr::summarise("{name}" := mean({{ var }}))
}
</pre></div>
<p>Now the user may supply their own name if needed:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% my_mean(cyl * am)
#&gt; # A tibble: 1 x 1
#&gt;   `cyl * am`
#&gt;        &lt;dbl&gt;
#&gt; 1       2.06

mtcars %&gt;% my_mean(cyl * am, name = "mean_cyl_am")
#&gt; # A tibble: 1 x 1
#&gt;   mean_cyl_am
#&gt;         &lt;dbl&gt;
#&gt; 1        2.06
</pre></div>



<h4>What's the deal with <code style="white-space: pre;">&#8288;:=&#8288;</code>?</h4>

<p>Name injection in dynamic dots was originally implemented with <code style="white-space: pre;">&#8288;:=&#8288;</code> instead of <code>=</code> to allow complex expressions on the LHS:
</p>
<div class="sourceCode r"><pre>x &lt;- "name"
list2(!!x := 1)
#&gt; $name
#&gt; [1] 1
</pre></div>
<p>Name-injection with glue operations was an extension of this existing feature and so inherited the same interface. However, there is no technical barrier to using glue strings on the LHS of <code>=</code>.
</p>
<p>As we are now moving away from <code><a href="rlang.html#topic+injection-operator">!!</a></code> for common tasks, we are considering enabling glue strings with <code>=</code> and superseding <code style="white-space: pre;">&#8288;:=&#8288;</code> usage. Track the progress of this change in <a href="https://github.com/r-lib/rlang/issues/1296">issue 1296</a>.
</p>



<h4>Using glue syntax in packages</h4>

<p>Since rlang does not depend directly on glue, you will have to ensure that glue is installed by adding it to your <code style="white-space: pre;">&#8288;Imports:&#8288;</code> section.
</p>
<div class="sourceCode r"><pre>usethis::use_package("glue", "Imports")
</pre></div>


<hr>
<h2 id='has_length'>How long is an object?</h2><span id='topic+has_length'></span>

<h3>Description</h3>

<p>This is a function for the common task of testing the length of an
object. It checks the length of an object in a non-generic way:
<code><a href="base.html#topic+length">base::length()</a></code> methods are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_length(x, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_length_+3A_x">x</code></td>
<td>
<p>A R object.</p>
</td></tr>
<tr><td><code id="has_length_+3A_n">n</code></td>
<td>
<p>A specific length to test <code>x</code> with. If <code>NULL</code>,
<code>has_length()</code> returns <code>TRUE</code> if <code>x</code> has length greater than
zero, and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>has_length(list())
has_length(list(), 0)

has_length(letters)
has_length(letters, 20)
has_length(letters, 26)
</code></pre>

<hr>
<h2 id='has_name'>Does an object have an element with this name?</h2><span id='topic+has_name'></span>

<h3>Description</h3>

<p>This function returns a logical value that indicates if a data
frame or another named object contains an element with a specific
name. Note that <code>has_name()</code> only works with vectors. For instance,
environments need the specialised function <code><a href="rlang.html#topic+env_has">env_has()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_name(x, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_name_+3A_x">x</code></td>
<td>
<p>A data frame or another named object</p>
</td></tr>
<tr><td><code id="has_name_+3A_name">name</code></td>
<td>
<p>Element name(s) to check</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unnamed objects are treated as if all names are empty strings. <code>NA</code>
input gives <code>FALSE</code> as output.
</p>


<h3>Value</h3>

<p>A logical vector of the same length as <code>name</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>has_name(iris, "Species")
has_name(mtcars, "gears")
</code></pre>

<hr>
<h2 id='hash'>Hashing</h2><span id='topic+hash'></span><span id='topic+hash_file'></span>

<h3>Description</h3>


<ul>
<li> <p><code>hash()</code> hashes an arbitrary R object.
</p>
</li>
<li> <p><code>hash_file()</code> hashes the data contained in a file.
</p>
</li></ul>

<p>The generated hash is guaranteed to be reproducible across platforms that
have the same endianness and are using the same R version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hash(x)

hash_file(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hash_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="hash_+3A_path">path</code></td>
<td>
<p>A character vector of paths to the files to be hashed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These hashers use the XXH128 hash algorithm of the xxHash library, which
generates a 128-bit hash. Both are implemented as streaming hashes, which
generate the hash with minimal extra memory usage.
</p>
<p>For <code>hash()</code>, objects are converted to binary using R's native serialization
tools. On R &gt;= 3.5.0, serialization version 3 is used, otherwise version 2 is
used. See <code><a href="base.html#topic+serialize">serialize()</a></code> for more information about the serialization version.
</p>


<h3>Value</h3>


<ul>
<li><p> For <code>hash()</code>, a single character string containing the hash.
</p>
</li>
<li><p> For <code>hash_file()</code>, a character vector containing one hash per file.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>hash(c(1, 2, 3))
hash(mtcars)

authors &lt;- file.path(R.home("doc"), "AUTHORS")
copying &lt;- file.path(R.home("doc"), "COPYING")
hashes &lt;- hash_file(c(authors, copying))
hashes

# If you need a single hash for multiple files,
# hash the result of `hash_file()`
hash(hashes)
</code></pre>

<hr>
<h2 id='inherits_any'>Does an object inherit from a set of classes?</h2><span id='topic+inherits_any'></span><span id='topic+inherits_all'></span><span id='topic+inherits_only'></span>

<h3>Description</h3>


<ul>
<li> <p><code>inherits_any()</code> is like <code><a href="base.html#topic+class">base::inherits()</a></code> but is more explicit
about its behaviour with multiple classes. If <code>classes</code> contains
several elements and the object inherits from at least one of
them, <code>inherits_any()</code> returns <code>TRUE</code>.
</p>
</li>
<li> <p><code>inherits_all()</code> tests that an object inherits from all of the
classes in the supplied order. This is usually the best way to
test for inheritance of multiple classes.
</p>
</li>
<li> <p><code>inherits_only()</code> tests that the class vectors are identical. It
is a shortcut for <code>identical(class(x), class)</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>inherits_any(x, class)

inherits_all(x, class)

inherits_only(x, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inherits_any_+3A_x">x</code></td>
<td>
<p>An object to test for inheritance.</p>
</td></tr>
<tr><td><code id="inherits_any_+3A_class">class</code></td>
<td>
<p>A character vector of classes.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- structure(list(), class = c("foo", "bar", "baz"))

# With the _any variant only one class must match:
inherits_any(obj, c("foobar", "bazbaz"))
inherits_any(obj, c("foo", "bazbaz"))

# With the _all variant all classes must match:
inherits_all(obj, c("foo", "bazbaz"))
inherits_all(obj, c("foo", "baz"))

# The order of classes must match as well:
inherits_all(obj, c("baz", "foo"))

# inherits_only() checks that the class vectors are identical:
inherits_only(obj, c("foo", "baz"))
inherits_only(obj, c("foo", "bar", "baz"))
</code></pre>

<hr>
<h2 id='inject'>Inject objects in an R expression</h2><span id='topic+inject'></span>

<h3>Description</h3>

<p><code>inject()</code> evaluates an expression with <a href="rlang.html#topic+quasiquotation">injection</a>
support. There are three main usages:
</p>

<ul>
<li> <p><a href="rlang.html#topic++21+21+21">Splicing</a> lists of arguments in a function call.
</p>
</li>
<li><p> Inline objects or other expressions in an expression with <code style="white-space: pre;">&#8288;!!&#8288;</code>
and <code style="white-space: pre;">&#8288;!!!&#8288;</code>. For instance to create functions or formulas
programmatically.
</p>
</li>
<li><p> Pass arguments to NSE functions that <a href="rlang.html#topic+nse-defuse">defuse</a> their
arguments without injection support (see for instance
<code><a href="rlang.html#topic+enquo0">enquo0()</a></code>). You can use <code>{{ arg }}</code> with functions documented
to support quosures. Otherwise, use <code>!!enexpr(arg)</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>inject(expr, env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inject_+3A_expr">expr</code></td>
<td>
<p>An argument to evaluate. This argument is immediately
evaluated in <code>env</code> (the current environment by default) with
injected objects and expressions.</p>
</td></tr>
<tr><td><code id="inject_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate <code>expr</code>. Defaults to
the current environment. For expert use only.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># inject() simply evaluates its argument with injection
# support. These expressions are equivalent:
2 * 3
inject(2 * 3)
inject(!!2 * !!3)

# Injection with `!!` can be useful to insert objects or
# expressions within other expressions, like formulas:
lhs &lt;- sym("foo")
rhs &lt;- sym("bar")
inject(!!lhs ~ !!rhs + 10)

# Injection with `!!!` splices lists of arguments in function
# calls:
args &lt;- list(na.rm = TRUE, finite = 0.2)
inject(mean(1:10, !!!args))
</code></pre>

<hr>
<h2 id='injection-operator'>Injection operator <code style="white-space: pre;">&#8288;!!&#8288;</code></h2><span id='topic+injection-operator'></span><span id='topic+bang-bang'></span><span id='topic++21+21'></span>

<h3>Description</h3>

<p>The <a href="rlang.html#topic+topic-inject">injection</a> operator <code style="white-space: pre;">&#8288;!!&#8288;</code> injects a value or
expression inside another expression. In other words, it modifies a
piece of code before R evaluates it.
</p>
<p>There are two main cases for injection. You can inject constant
values to work around issues of <a href="rlang.html#topic+topic-data-mask-ambiguity">scoping ambiguity</a>, and you can inject <a href="rlang.html#topic+topic-defuse">defused expressions</a> like <a href="dplyr.html#topic+sym">symbolised</a> column names.
</p>


<h3>Where does <code style="white-space: pre;">&#8288;!!&#8288;</code> work?</h3>

<p><code style="white-space: pre;">&#8288;!!&#8288;</code> does not work everywhere, you can only use it within certain
special functions:
</p>

<ul>
<li><p> Functions taking <a href="rlang.html#topic+topic-defuse">defused</a> and
<a href="rlang.html#topic+topic-data-mask">data-masked</a> arguments.
</p>
<p>Technically, this means function arguments defused with
<code><a href="rlang.html#topic+embrace-operator">{{</a></code> or <code>en</code>-prefixed operators like
<code><a href="dplyr.html#topic+enquo">enquo()</a></code>, <code><a href="dplyr.html#topic+enexpr">enexpr()</a></code>, etc.
</p>
</li>
<li><p> Inside <code><a href="rlang.html#topic+inject">inject()</a></code>.
</p>
</li></ul>

<p>All data-masking verbs in the tidyverse support injection operators
out of the box. With base functions, you need to use <code><a href="rlang.html#topic+inject">inject()</a></code> to
enable <code style="white-space: pre;">&#8288;!!&#8288;</code>. Using <code style="white-space: pre;">&#8288;!!&#8288;</code> out of context may lead to incorrect
results, see <a href="rlang.html#topic+topic-inject-out-of-context">What happens if I use injection operators out of context?</a>.
</p>
<p>The examples below are built around the base function <code><a href="base.html#topic+with">with()</a></code>.
Since it's not a tidyverse function we will use <code><a href="rlang.html#topic+inject">inject()</a></code> to enable
<code style="white-space: pre;">&#8288;!!&#8288;</code> usage.
</p>


<h3>Injecting values</h3>

<p>Data-masking functions like <code><a href="base.html#topic+with">with()</a></code> are handy because you can
refer to column names in your computations. This comes at the price
of data mask ambiguity: if you have defined an env-variable of the
same name as a data-variable, you get a name collisions. This
collision is always resolved by giving precedence to the
data-variable (it masks the env-variable):
</p>
<div class="sourceCode r"><pre>cyl &lt;- c(100, 110)
with(mtcars, mean(cyl))
#&gt; [1] 6.1875
</pre></div>
<p>The injection operator offers one way of solving this. Use it to
inject the env-variable inside the data-masked expression:
</p>
<div class="sourceCode r"><pre>inject(
  with(mtcars, mean(!!cyl))
)
#&gt; [1] 105
</pre></div>
<p>Note that the <code><a href="igraph.html#topic+.env">.env</a></code> pronoun is a simpler way of solving the
ambiguity. See <a href="rlang.html#topic+topic-data-mask-ambiguity">The data mask ambiguity</a> for more about
this.
</p>


<h3>Injecting expressions</h3>

<p>Injection is also useful for modifying parts of a <a href="rlang.html#topic+topic-defuse">defused expression</a>. In the following example we use the
<a href="rlang.html#topic+topic-metaprogramming">symbolise-and-inject pattern</a> to
inject a column name inside a data-masked expression.
</p>
<div class="sourceCode r"><pre>var &lt;- sym("cyl")
inject(
  with(mtcars, mean(!!var))
)
#&gt; [1] 6.1875
</pre></div>
<p>Since <code><a href="base.html#topic+with">with()</a></code> is a base function, you can't inject
<a href="rlang.html#topic+topic-quosure">quosures</a>, only naked symbols and calls. This
isn't a problem here because we're injecting the name of a data
frame column. If the environment is important, try injecting a
pre-computed value instead.
</p>


<h3>When do I need <code style="white-space: pre;">&#8288;!!&#8288;</code>?</h3>

<p>With tidyverse APIs, injecting expressions with <code style="white-space: pre;">&#8288;!!&#8288;</code> is no longer a
common pattern. First, the <code><a href="igraph.html#topic+.env">.env</a></code> pronoun solves the
ambiguity problem in a more intuitive way:
</p>
<div class="sourceCode r"><pre>cyl &lt;- 100
mtcars %&gt;% dplyr::mutate(cyl = cyl * .env$cyl)
</pre></div>
<p>Second, the embrace operator <code><a href="rlang.html#topic+embrace-operator">{{</a></code> makes the
<a href="rlang.html#topic+topic-metaprogramming">defuse-and-inject pattern</a> easier to
learn and use.
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  data %&gt;% dplyr::summarise(mean({{ var }}))
}

# Equivalent to
my_mean &lt;- function(data, var) {
  data %&gt;% dplyr::summarise(mean(!!enquo(var)))
}
</pre></div>
<p><code style="white-space: pre;">&#8288;!!&#8288;</code> is a good tool to learn for advanced applications but our
hope is that it isn't needed for common data analysis cases.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-inject">Injecting with !!, !!!, and glue syntax</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+topic-metaprogramming">Metaprogramming patterns</a>
</p>
</li></ul>


<hr>
<h2 id='interrupt'>Simulate interrupt condition</h2><span id='topic+interrupt'></span>

<h3>Description</h3>

<p><code>interrupt()</code> simulates a user interrupt of the kind that is
signalled with <code>Ctrl-C</code>. It is currently not possible to create
custom interrupt condition objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interrupt()
</code></pre>

<hr>
<h2 id='invoke'>Invoke a function with a list of arguments</h2><span id='topic+invoke'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Deprecated in rlang 0.4.0 in favour of <code><a href="purrr.html#topic+exec">exec()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invoke(.fn, .args = list(), ..., .env = caller_env(), .bury = c(".fn", ""))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invoke_+3A_.fn">.fn</code>, <code id="invoke_+3A_args">args</code>, <code id="invoke_+3A_...">...</code>, <code id="invoke_+3A_.env">.env</code>, <code id="invoke_+3A_.bury">.bury</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>

<hr>
<h2 id='is_call'>Is object a call?</h2><span id='topic+is_call'></span>

<h3>Description</h3>

<p>This function tests if <code>x</code> is a <a href="rlang.html#topic+call2">call</a>. This is a
pattern-matching predicate that returns <code>FALSE</code> if <code>name</code> and <code>n</code>
are supplied and the call does not match these properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_call(x, name = NULL, n = NULL, ns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_call_+3A_x">x</code></td>
<td>
<p>An object to test. Formulas and quosures are treated
literally.</p>
</td></tr>
<tr><td><code id="is_call_+3A_name">name</code></td>
<td>
<p>An optional name that the call should match. It is
passed to <code><a href="dplyr.html#topic+sym">sym()</a></code> before matching. This argument is vectorised
and you can supply a vector of names to match. In this case,
<code>is_call()</code> returns <code>TRUE</code> if at least one name matches.</p>
</td></tr>
<tr><td><code id="is_call_+3A_n">n</code></td>
<td>
<p>An optional number of arguments that the call should
match.</p>
</td></tr>
<tr><td><code id="is_call_+3A_ns">ns</code></td>
<td>
<p>The namespace of the call. If <code>NULL</code>, the namespace
doesn't participate in the pattern-matching. If an empty string
<code>""</code> and <code>x</code> is a namespaced call, <code>is_call()</code> returns
<code>FALSE</code>. If any other string, <code>is_call()</code> checks that <code>x</code> is
namespaced within <code>ns</code>.
</p>
<p>Can be a character vector of namespaces, in which case the call
has to match at least one of them, otherwise <code>is_call()</code> returns
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+is_expression">is_expression()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_call(quote(foo(bar)))

# You can pattern-match the call with additional arguments:
is_call(quote(foo(bar)), "foo")
is_call(quote(foo(bar)), "bar")
is_call(quote(foo(bar)), quote(foo))

# Match the number of arguments with is_call():
is_call(quote(foo(bar)), "foo", 1)
is_call(quote(foo(bar)), "foo", 2)


# By default, namespaced calls are tested unqualified:
ns_expr &lt;- quote(base::list())
is_call(ns_expr, "list")

# You can also specify whether the call shouldn't be namespaced by
# supplying an empty string:
is_call(ns_expr, "list", ns = "")

# Or if it should have a namespace:
is_call(ns_expr, "list", ns = "utils")
is_call(ns_expr, "list", ns = "base")

# You can supply multiple namespaces:
is_call(ns_expr, "list", ns = c("utils", "base"))
is_call(ns_expr, "list", ns = c("utils", "stats"))

# If one of them is "", unnamespaced calls will match as well:
is_call(quote(list()), "list", ns = "base")
is_call(quote(list()), "list", ns = c("base", ""))
is_call(quote(base::list()), "list", ns = c("base", ""))


# The name argument is vectorised so you can supply a list of names
# to match with:
is_call(quote(foo(bar)), c("bar", "baz"))
is_call(quote(foo(bar)), c("bar", "foo"))
is_call(quote(base::list), c("::", ":::", "$", "@"))
</code></pre>

<hr>
<h2 id='is_callable'>Is an object callable?</h2><span id='topic+is_callable'></span>

<h3>Description</h3>

<p>A callable object is an object that can appear in the function
position of a call (as opposed to argument position). This includes
<a href="rlang.html#topic+is_symbolic">symbolic objects</a> that evaluate to a function or
literal functions embedded in the call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_callable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_callable_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that strings may look like callable objects because
expressions of the form <code>"list"()</code> are valid R code. However,
that's only because the R parser transforms strings to symbols. It
is not legal to manually set language heads to strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Symbolic objects and functions are callable:
is_callable(quote(foo))
is_callable(base::identity)

# node_poke_car() lets you modify calls without any checking:
lang &lt;- quote(foo(10))
node_poke_car(lang, current_env())

# Use is_callable() to check an input object is safe to put as CAR:
obj &lt;- base::identity

if (is_callable(obj)) {
  lang &lt;- node_poke_car(lang, obj)
} else {
  abort("`obj` must be callable")
}

eval_bare(lang)
</code></pre>

<hr>
<h2 id='is_condition'>Is object a condition?</h2><span id='topic+is_condition'></span><span id='topic+is_error'></span><span id='topic+is_warning'></span><span id='topic+is_message'></span>

<h3>Description</h3>

<p>Is object a condition?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_condition(x)

is_error(x)

is_warning(x)

is_message(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_condition_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>

<hr>
<h2 id='is_copyable'>Is an object copyable?</h2><span id='topic+is_copyable'></span>

<h3>Description</h3>

<p>When an object is modified, R generally copies it (sometimes
lazily) to enforce <a href="https://en.wikipedia.org/wiki/Value_semantics">value semantics</a>.
However, some internal types are uncopyable. If you try to copy
them, either with <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> or by argument passing, you actually create
references to the original object rather than actual
copies. Modifying these references can thus have far reaching side
effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_copyable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_copyable_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Let's add attributes with structure() to uncopyable types. Since
# they are not copied, the attributes are changed in place:
env &lt;- env()
structure(env, foo = "bar")
env

# These objects that can only be changed with side effect are not
# copyable:
is_copyable(env)

structure(base::list, foo = "bar")
str(base::list)
</code></pre>

<hr>
<h2 id='is_dictionaryish'>Is a vector uniquely named?</h2><span id='topic+is_dictionaryish'></span>

<h3>Description</h3>

<p>Like <code><a href="igraph.html#topic+is_named">is_named()</a></code> but also checks that names are unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dictionaryish(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_dictionaryish_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>

<hr>
<h2 id='is_empty'>Is object an empty vector or NULL?</h2><span id='topic+is_empty'></span>

<h3>Description</h3>

<p>Is object an empty vector or NULL?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_empty_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_empty(NULL)
is_empty(list())
is_empty(list(NULL))
</code></pre>

<hr>
<h2 id='is_environment'>Is object an environment?</h2><span id='topic+is_environment'></span><span id='topic+is_bare_environment'></span>

<h3>Description</h3>

<p><code>is_bare_environment()</code> tests whether <code>x</code> is an environment without a s3 or
s4 class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_environment(x)

is_bare_environment(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_environment_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
</table>

<hr>
<h2 id='is_expression'>Is an object an expression?</h2><span id='topic+is_expression'></span><span id='topic+is_syntactic_literal'></span><span id='topic+is_symbolic'></span>

<h3>Description</h3>

<p>In rlang, an <em>expression</em> is the return type of <code><a href="rlang.html#topic+parse_expr">parse_expr()</a></code>, the
set of objects that can be obtained from parsing R code. Under this
definition expressions include numbers, strings, <code>NULL</code>, symbols,
and function calls. These objects can be classified as:
</p>

<ul>
<li><p> Symbolic objects, i.e. symbols and function calls (for which
<code>is_symbolic()</code> returns <code>TRUE</code>)
</p>
</li>
<li><p> Syntactic literals, i.e. scalar atomic objects and <code>NULL</code>
(testable with <code>is_syntactic_literal()</code>)
</p>
</li></ul>

<p><code>is_expression()</code> returns <code>TRUE</code> if the input is either a symbolic
object or a syntactic literal. If a call, the elements of the call
must all be expressions as well. Unparsable calls are not
considered expressions in this narrow definition.
</p>
<p>Note that in base R, there exists <code><a href="base.html#topic+expression">expression()</a></code> vectors, a data
type similar to a list that supports special attributes created by
the parser called source references. This data type is not
supported in rlang.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_expression(x)

is_syntactic_literal(x)

is_symbolic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_expression_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_symbolic()</code> returns <code>TRUE</code> for symbols and calls (objects with
type <code>language</code>). Symbolic objects are replaced by their value
during evaluation. Literals are the complement of symbolic
objects. They are their own value and return themselves during
evaluation.
</p>
<p><code>is_syntactic_literal()</code> is a predicate that returns <code>TRUE</code> for the
subset of literals that are created by R when parsing text (see
<code><a href="rlang.html#topic+parse_expr">parse_expr()</a></code>): numbers, strings and <code>NULL</code>. Along with symbols,
these literals are the terminating nodes in an AST.
</p>
<p>Note that in the most general sense, a literal is any R object that
evaluates to itself and that can be evaluated in the empty
environment. For instance, <code>quote(c(1, 2))</code> is not a literal, it is
a call. However, the result of evaluating it in <code><a href="rlang.html#topic+base_env">base_env()</a></code> is a
literal(in this case an atomic vector).
</p>
<p>As the data structure for function arguments, pairlists are also a
kind of language objects. However, since they are mostly an
internal data structure and can't be returned as is by the parser,
<code>is_expression()</code> returns <code>FALSE</code> for pairlists.
</p>


<h3>See Also</h3>

<p><code><a href="lazyeval.html#topic+is_call">is_call()</a></code> for a call predicate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q1 &lt;- quote(1)
is_expression(q1)
is_syntactic_literal(q1)

q2 &lt;- quote(x)
is_expression(q2)
is_symbol(q2)

q3 &lt;- quote(x + 1)
is_expression(q3)
is_call(q3)


# Atomic expressions are the terminating nodes of a call tree:
# NULL or a scalar atomic vector:
is_syntactic_literal("string")
is_syntactic_literal(NULL)

is_syntactic_literal(letters)
is_syntactic_literal(quote(call()))

# Parsable literals have the property of being self-quoting:
identical("foo", quote("foo"))
identical(1L, quote(1L))
identical(NULL, quote(NULL))

# Like any literals, they can be evaluated within the empty
# environment:
eval_bare(quote(1L), empty_env())

# Whereas it would fail for symbolic expressions:
# eval_bare(quote(c(1L, 2L)), empty_env())


# Pairlists are also language objects representing argument lists.
# You will usually encounter them with extracted formals:
fmls &lt;- formals(is_expression)
typeof(fmls)

# Since they are mostly an internal data structure, is_expression()
# returns FALSE for pairlists, so you will have to check explicitly
# for them:
is_expression(fmls)
is_pairlist(fmls)
</code></pre>

<hr>
<h2 id='is_formula'>Is object a formula?</h2><span id='topic+is_formula'></span><span id='topic+is_bare_formula'></span>

<h3>Description</h3>

<p><code>is_formula()</code> tests whether <code>x</code> is a call to <code>~</code>. <code>is_bare_formula()</code>
tests in addition that <code>x</code> does not inherit from anything else than
<code>"formula"</code>.
</p>
<p><strong>Note</strong>: When we first implemented <code>is_formula()</code>, we thought it
best to treat unevaluated formulas as formulas by default (see
section below). Now we think this default introduces too many edge
cases in normal code. We recommend always supplying <code>scoped = TRUE</code>. Unevaluated formulas can be handled via a <code>is_call(x, "~")</code>
branch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_formula(x, scoped = NULL, lhs = NULL)

is_bare_formula(x, scoped = TRUE, lhs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_formula_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
<tr><td><code id="is_formula_+3A_scoped">scoped</code></td>
<td>
<p>A boolean indicating whether the quosure is scoped,
that is, has a valid environment attribute and inherits from
<code>"formula"</code>. If <code>NULL</code>, the scope is not inspected.</p>
</td></tr>
<tr><td><code id="is_formula_+3A_lhs">lhs</code></td>
<td>
<p>A boolean indicating whether the formula has a left-hand
side. If <code>NULL</code>, the LHS is not inspected and <code>is_formula()</code>
returns <code>TRUE</code> for both one- and two-sided formulas.</p>
</td></tr>
</table>


<h3>Dealing with unevaluated formulas</h3>

<p>At parse time, a formula is a simple call to <code>~</code> and it does not
have a class or an environment. Once evaluated, the <code>~</code> call
becomes a properly structured formula. Unevaluated formulas arise
by quotation, e.g. <code>~~foo</code>, <code>quote(~foo)</code>, or <code>substitute(arg)</code>
with <code>arg</code> being supplied a formula. Use the <code>scoped</code> argument to
check whether the formula carries an environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_formula(~10)
is_formula(10)

# If you don't supply `lhs`, both one-sided and two-sided formulas
# will return `TRUE`
is_formula(disp ~ am)
is_formula(~am)

# You can also specify whether you expect a LHS:
is_formula(disp ~ am, lhs = TRUE)
is_formula(disp ~ am, lhs = FALSE)
is_formula(~am, lhs = TRUE)
is_formula(~am, lhs = FALSE)

# Handling of unevaluated formulas is a bit tricky. These formulas
# are special because they don't inherit from `"formula"` and they
# don't carry an environment (they are not scoped):
f &lt;- quote(~foo)
f_env(f)

# By default unevaluated formulas are treated as formulas
is_formula(f)

# Supply `scoped = TRUE` to ensure you have an evaluated formula
is_formula(f, scoped = TRUE)

# By default unevaluated formulas not treated as bare formulas
is_bare_formula(f)

# If you supply `scoped = TRUE`, they will be considered bare
# formulas even though they don't inherit from `"formula"`
is_bare_formula(f, scoped = TRUE)
</code></pre>

<hr>
<h2 id='is_function'>Is object a function?</h2><span id='topic+is_function'></span><span id='topic+is_closure'></span><span id='topic+is_primitive'></span><span id='topic+is_primitive_eager'></span><span id='topic+is_primitive_lazy'></span>

<h3>Description</h3>

<p>The R language defines two different types of functions: primitive
functions, which are low-level, and closures, which are the regular
kind of functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_function(x)

is_closure(x)

is_primitive(x)

is_primitive_eager(x)

is_primitive_lazy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_function_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Closures are functions written in R, named after the way their
arguments are scoped within nested environments (see
<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">https://en.wikipedia.org/wiki/Closure_(computer_programming)</a>). The
root environment of the closure is called the closure
environment. When closures are evaluated, a new environment called
the evaluation frame is created with the closure environment as
parent. This is where the body of the closure is evaluated. These
closure frames appear on the evaluation stack, as opposed to
primitive functions which do not necessarily have their own
evaluation frame and never appear on the stack.
</p>
<p>Primitive functions are more efficient than closures for two
reasons. First, they are written entirely in fast low-level
code. Second, the mechanism by which they are passed arguments is
more efficient because they often do not need the full procedure of
argument matching (dealing with positional versus named arguments,
partial matching, etc). One practical consequence of the special
way in which primitives are passed arguments is that they
technically do not have formal arguments, and <code><a href="base.html#topic+formals">formals()</a></code> will
return <code>NULL</code> if called on a primitive function. Finally, primitive
functions can either take arguments lazily, like R closures do,
or evaluate them eagerly before being passed on to the C code.
The former kind of primitives are called &quot;special&quot; in R terminology,
while the latter is referred to as &quot;builtin&quot;. <code>is_primitive_eager()</code>
and <code>is_primitive_lazy()</code> allow you to check whether a primitive
function evaluates arguments eagerly or lazily.
</p>
<p>You will also encounter the distinction between primitive and
internal functions in technical documentation. Like primitive
functions, internal functions are defined at a low level and
written in C. However, internal functions have no representation in
the R language. Instead, they are called via a call to
<code><a href="base.html#topic+Internal">base::.Internal()</a></code> within a regular closure. This ensures that
they appear as normal R function objects: they obey all the usual
rules of argument passing, and they appear on the evaluation stack
as any other closures. As a result, <code><a href="rlang.html#topic+fn_fmls">fn_fmls()</a></code> does not need to
look in the <code>.ArgsEnv</code> environment to obtain a representation of
their arguments, and there is no way of querying from R whether
they are lazy ('special' in R terminology) or eager ('builtin').
</p>
<p>You can call primitive functions with <code><a href="base.html#topic+.Primitive">.Primitive()</a></code> and internal
functions with <code><a href="base.html#topic+.Internal">.Internal()</a></code>. However, calling internal functions
in a package is forbidden by CRAN's policy because they are
considered part of the private API. They often assume that they
have been called with correctly formed arguments, and may cause R
to crash if you call them with unexpected objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Primitive functions are not closures:
is_closure(base::c)
is_primitive(base::c)

# On the other hand, internal functions are wrapped in a closure
# and appear as such from the R side:
is_closure(base::eval)

# Both closures and primitives are functions:
is_function(base::c)
is_function(base::eval)

# Many primitive functions evaluate arguments eagerly:
is_primitive_eager(base::c)
is_primitive_eager(base::list)
is_primitive_eager(base::`+`)

# However, primitives that operate on expressions, like quote() or
# substitute(), are lazy:
is_primitive_lazy(base::quote)
is_primitive_lazy(base::substitute)
</code></pre>

<hr>
<h2 id='is_installed'>Are packages installed in any of the libraries?</h2><span id='topic+is_installed'></span><span id='topic+check_installed'></span>

<h3>Description</h3>

<p>These functions check that packages are installed with minimal side
effects. If installed, the packages will be loaded but not
attached.
</p>

<ul>
<li> <p><code>is_installed()</code> doesn't interact with the user. It simply
returns <code>TRUE</code> or <code>FALSE</code> depending on whether the packages are
installed.
</p>
</li>
<li><p> In interactive sessions, <code>check_installed()</code> asks the user
whether to install missing packages. If the user accepts, the
packages are installed with <code>pak::pkg_install()</code> if available, or
<code><a href="utils.html#topic+install.packages">utils::install.packages()</a></code> otherwise. If the session is non
interactive or if the user chooses not to install the packages,
the current evaluation is aborted.
</p>
</li></ul>

<p>You can disable the prompt by setting the
<code>rlib_restart_package_not_found</code> global option to <code>FALSE</code>. In that
case, missing packages always cause an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_installed(pkg, ..., version = NULL, compare = NULL)

check_installed(
  pkg,
  reason = NULL,
  ...,
  version = NULL,
  compare = NULL,
  action = NULL,
  call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_installed_+3A_pkg">pkg</code></td>
<td>
<p>The package names. Can include version requirements,
e.g. <code>"pkg (&gt;= 1.0.0)"</code>.</p>
</td></tr>
<tr><td><code id="is_installed_+3A_...">...</code></td>
<td>
<p>These dots must be empty.</p>
</td></tr>
<tr><td><code id="is_installed_+3A_version">version</code></td>
<td>
<p>Minimum versions for <code>pkg</code>. If supplied, must be the
same length as <code>pkg</code>. <code>NA</code> elements stand for any versions.</p>
</td></tr>
<tr><td><code id="is_installed_+3A_compare">compare</code></td>
<td>
<p>A character vector of comparison operators to use
for <code>version</code>. If supplied, must be the same length as
<code>version</code>. If <code>NULL</code>, <code>&gt;=</code> is used as default for all
elements. <code>NA</code> elements in <code>compare</code> are also set to <code>&gt;=</code> by
default.</p>
</td></tr>
<tr><td><code id="is_installed_+3A_reason">reason</code></td>
<td>
<p>Optional string indicating why is <code>pkg</code> needed.
Appears in error messages (if non-interactive) and user prompts
(if interactive).</p>
</td></tr>
<tr><td><code id="is_installed_+3A_action">action</code></td>
<td>
<p>An optional function taking <code>pkg</code> and <code>...</code>
arguments. It is called by <code>check_installed()</code> when the user
chooses to update outdated packages. The function is passed the
missing and outdated packages as a character vector of names.</p>
</td></tr>
<tr><td><code id="is_installed_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_installed()</code> returns <code>TRUE</code> if <em>all</em> package names
provided in <code>pkg</code> are installed, <code>FALSE</code>
otherwise. <code>check_installed()</code> either doesn't return or returns
<code>NULL</code>.
</p>


<h3>Handling package not found errors</h3>

<p><code>check_installed()</code> signals error conditions of class
<code>rlib_error_package_not_found</code>. The error includes <code>pkg</code> and
<code>version</code> fields. They are vectorised and may include several
packages.
</p>
<p>The error is signalled with a <code>rlib_restart_package_not_found</code>
restart on the stack to allow handlers to install the required
packages. To do so, add a <a href="base.html#topic+withCallingHandlers">calling handler</a>
for <code>rlib_error_package_not_found</code>, install the required packages,
and invoke the restart without arguments. This restarts the check
from scratch.
</p>
<p>The condition is not signalled in non-interactive sessions, in the
restarting case, or if the <code>rlib_restart_package_not_found</code> user
option is set to <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_installed("utils")
is_installed(c("base", "ggplot5"))
is_installed(c("base", "ggplot5"), version = c(NA, "5.1.0"))
</code></pre>

<hr>
<h2 id='is_integerish'>Is a vector integer-like?</h2><span id='topic+is_integerish'></span><span id='topic+is_bare_integerish'></span><span id='topic+is_scalar_integerish'></span>

<h3>Description</h3>

<p>These predicates check whether R considers a number vector to be
integer-like, according to its own tolerance check (which is in
fact delegated to the C library). This function is not adapted to
data analysis, see the help for <code><a href="base.html#topic+integer">base::is.integer()</a></code> for examples
of how to check for whole numbers.
</p>
<p>Things to consider when checking for integer-like doubles:
</p>

<ul>
<li><p> This check can be expensive because the whole double vector has
to be traversed and checked.
</p>
</li>
<li><p> Large double values may be integerish but may still not be
coercible to integer. This is because integers in R only support
values up to <code>2^31 - 1</code> while numbers stored as double can be
much larger.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_integerish(x, n = NULL, finite = NULL)

is_bare_integerish(x, n = NULL, finite = NULL)

is_scalar_integerish(x, finite = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_integerish_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
<tr><td><code id="is_integerish_+3A_n">n</code></td>
<td>
<p>Expected length of a vector.</p>
</td></tr>
<tr><td><code id="is_integerish_+3A_finite">finite</code></td>
<td>
<p>Whether all values of the vector are finite. The
non-finite values are <code>NA</code>, <code>Inf</code>, <code>-Inf</code> and <code>NaN</code>. Setting this
to something other than <code>NULL</code> can be expensive because the whole
vector needs to be traversed and checked.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+is_bare_numeric">is_bare_numeric()</a></code> for testing whether an object is a
base numeric type (a bare double or integer vector).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_integerish(10L)
is_integerish(10.0)
is_integerish(10.0, n = 2)
is_integerish(10.000001)
is_integerish(TRUE)
</code></pre>

<hr>
<h2 id='is_interactive'>Is R running interactively?</h2><span id='topic+is_interactive'></span><span id='topic+local_interactive'></span><span id='topic+with_interactive'></span>

<h3>Description</h3>

<p>Like <code><a href="base.html#topic+interactive">base::interactive()</a></code>, <code>is_interactive()</code> returns <code>TRUE</code> when
the function runs interactively and <code>FALSE</code> when it runs in batch
mode. It also checks, in this order:
</p>

<ul>
<li><p> The <code>rlang_interactive</code> global option. If set to a single <code>TRUE</code>
or <code>FALSE</code>, <code>is_interactive()</code> returns that value immediately. This
escape hatch is useful in unit tests or to manually turn on
interactive features in RMarkdown outputs.
</p>
</li>
<li><p> Whether knitr or testthat is in progress, in which case
<code>is_interactive()</code> returns <code>FALSE</code>.
</p>
</li></ul>

<p><code>with_interactive()</code> and <code>local_interactive()</code> set the global
option conveniently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_interactive()

local_interactive(value = TRUE, frame = caller_env())

with_interactive(expr, value = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_interactive_+3A_value">value</code></td>
<td>
<p>A single <code>TRUE</code> or <code>FALSE</code>. This overrides the return
value of <code>is_interactive()</code>.</p>
</td></tr>
<tr><td><code id="is_interactive_+3A_frame">frame</code></td>
<td>
<p>The environment of a running function which defines
the scope of the temporary options. When the function returns,
the options are reset to their original values.</p>
</td></tr>
<tr><td><code id="is_interactive_+3A_expr">expr</code></td>
<td>
<p>An expression to evaluate with interactivity set to
<code>value</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='is_lang'>Is object a call?</h2><span id='topic+is_lang'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
These functions are deprecated, please use <code><a href="lazyeval.html#topic+is_call">is_call()</a></code> and its <code>n</code>
argument instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_lang(x, name = NULL, n = NULL, ns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_lang_+3A_x">x</code></td>
<td>
<p>An object to test. Formulas and quosures are treated
literally.</p>
</td></tr>
<tr><td><code id="is_lang_+3A_name">name</code></td>
<td>
<p>An optional name that the call should match. It is
passed to <code><a href="dplyr.html#topic+sym">sym()</a></code> before matching. This argument is vectorised
and you can supply a vector of names to match. In this case,
<code>is_call()</code> returns <code>TRUE</code> if at least one name matches.</p>
</td></tr>
<tr><td><code id="is_lang_+3A_n">n</code></td>
<td>
<p>An optional number of arguments that the call should
match.</p>
</td></tr>
<tr><td><code id="is_lang_+3A_ns">ns</code></td>
<td>
<p>The namespace of the call. If <code>NULL</code>, the namespace
doesn't participate in the pattern-matching. If an empty string
<code>""</code> and <code>x</code> is a namespaced call, <code>is_call()</code> returns
<code>FALSE</code>. If any other string, <code>is_call()</code> checks that <code>x</code> is
namespaced within <code>ns</code>.
</p>
<p>Can be a character vector of namespaces, in which case the call
has to match at least one of them, otherwise <code>is_call()</code> returns
<code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='is_named'>Is object named?</h2><span id='topic+is_named'></span><span id='topic+is_named2'></span><span id='topic+have_name'></span>

<h3>Description</h3>


<ul>
<li> <p><code>is_named()</code> is a scalar predicate that checks that <code>x</code> has a
<code>names</code> attribute and that none of the names are missing or empty
(<code>NA</code> or <code>""</code>).
</p>
</li>
<li> <p><code>is_named2()</code> is like <code>is_named()</code> but always returns <code>TRUE</code> for
empty vectors, even those that don't have a <code>names</code> attribute.
In other words, it tests for the property that each element of a
vector is named. <code>is_named2()</code> composes well with <code><a href="rlang.html#topic+names2">names2()</a></code>
whereas <code>is_named()</code> composes with <code>names()</code>.
</p>
</li>
<li> <p><code>have_name()</code> is a vectorised variant.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_named(x)

is_named2(x)

have_name(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_named_+3A_x">x</code></td>
<td>
<p>A vector to test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_named()</code> always returns <code>TRUE</code> for empty vectors because
</p>


<h3>Value</h3>

<p><code>is_named()</code> and <code>is_named2()</code> are scalar predicates that
return <code>TRUE</code> or <code>FALSE</code>. <code>have_name()</code> is vectorised and returns
a logical vector as long as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># is_named() is a scalar predicate about the whole vector of names:
is_named(c(a = 1, b = 2))
is_named(c(a = 1, 2))

# Unlike is_named2(), is_named() returns `FALSE` for empty vectors
# that don't have a `names` attribute.
is_named(list())
is_named2(list())

# have_name() is a vectorised predicate
have_name(c(a = 1, b = 2))
have_name(c(a = 1, 2))

# Empty and missing names are treated as invalid:
invalid &lt;- set_names(letters[1:5])
names(invalid)[1] &lt;- ""
names(invalid)[3] &lt;- NA

is_named(invalid)
have_name(invalid)

# A data frame normally has valid, unique names
is_named(mtcars)
have_name(mtcars)

# A matrix usually doesn't because the names are stored in a
# different attribute
mat &lt;- matrix(1:4, 2)
colnames(mat) &lt;- c("a", "b")
is_named(mat)
names(mat)
</code></pre>

<hr>
<h2 id='is_namespace'>Is an object a namespace environment?</h2><span id='topic+is_namespace'></span>

<h3>Description</h3>

<p>Is an object a namespace environment?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_namespace(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_namespace_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>

<hr>
<h2 id='is_pairlist'>Is object a node or pairlist?</h2><span id='topic+is_pairlist'></span><span id='topic+is_node'></span><span id='topic+is_node_list'></span>

<h3>Description</h3>


<ul>
<li> <p><code>is_pairlist()</code> checks that <code>x</code> has type <code>pairlist</code>.
</p>
</li>
<li> <p><code>is_node()</code> checks that <code>x</code> has type <code>pairlist</code> or <code>language</code>.
It tests whether <code>x</code> is a node that has a CAR and a CDR,
including callable nodes (language objects).
</p>
</li>
<li> <p><code>is_node_list()</code> checks that <code>x</code> has type <code>pairlist</code> or <code>NULL</code>.
<code>NULL</code> is the empty node list.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_pairlist(x)

is_node(x)

is_node_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_pairlist_+3A_x">x</code></td>
<td>
<p>Object to test.</p>
</td></tr>
</table>


<h3>Life cycle</h3>

<p>These functions are experimental. We are still figuring out a good
naming convention to refer to the different lisp-like lists in R.
</p>


<h3>See Also</h3>

<p><code><a href="lazyeval.html#topic+is_call">is_call()</a></code> tests for language nodes.
</p>

<hr>
<h2 id='is_reference'>Is an object referencing another?</h2><span id='topic+is_reference'></span>

<h3>Description</h3>

<p>There are typically two situations where two symbols may refer to
the same object.
</p>

<ul>
<li><p> R objects usually have copy-on-write semantics. This is an
optimisation that ensures that objects are only copied if
needed. When you copy a vector, no memory is actually copied
until you modify either the original object or the copy is
modified.
</p>
<p>Note that the copy-on-write optimisation is an implementation
detail that is not guaranteed by the specification of the R
language.
</p>
</li>
<li><p> Assigning an <a href="rlang.html#topic+is_copyable">uncopyable</a> object (like an
environment) creates a reference. These objects are never copied
even if you modify one of the references.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_reference(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_reference_+3A_x">x</code>, <code id="is_reference_+3A_y">y</code></td>
<td>
<p>R objects.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Reassigning an uncopyable object such as an environment creates a
# reference:
env &lt;- env()
ref &lt;- env
is_reference(ref, env)

# Due to copy-on-write optimisation, a copied vector can
# temporarily reference the original vector:
vec &lt;- 1:10
copy &lt;- vec
is_reference(copy, vec)

# Once you modify on of them, the copy is triggered in the
# background and the objects cease to reference each other:
vec[[1]] &lt;- 100
is_reference(copy, vec)
</code></pre>

<hr>
<h2 id='is_symbol'>Is object a symbol?</h2><span id='topic+is_symbol'></span>

<h3>Description</h3>

<p>Is object a symbol?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_symbol(x, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_symbol_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
<tr><td><code id="is_symbol_+3A_name">name</code></td>
<td>
<p>An optional name or vector of names that the symbol
should match.</p>
</td></tr>
</table>

<hr>
<h2 id='is_true'>Is object identical to TRUE or FALSE?</h2><span id='topic+is_true'></span><span id='topic+is_false'></span>

<h3>Description</h3>

<p>These functions bypass R's automatic conversion rules and check
that <code>x</code> is literally <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_true(x)

is_false(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_true_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_true(TRUE)
is_true(1)

is_false(FALSE)
is_false(0)
</code></pre>

<hr>
<h2 id='is_weakref'>Is object a weak reference?</h2><span id='topic+is_weakref'></span>

<h3>Description</h3>

<p>Is object a weak reference?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_weakref(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_weakref_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>

<hr>
<h2 id='lang'>Create a call</h2><span id='topic+lang'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
These functions are deprecated, please use <code><a href="rlang.html#topic+call2">call2()</a></code> and
<code><a href="rlang.html#topic+new_call">new_call()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lang(.fn, ..., .ns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lang_+3A_.fn">.fn</code></td>
<td>
<p>Function to call. Must be a callable object: a string,
symbol, call, or a function.</p>
</td></tr>
<tr><td><code id="lang_+3A_...">...</code></td>
<td>
<p>&lt;<a href="rlang.html#topic+dyn-dots">dynamic</a>&gt; Arguments for the function
call. Empty arguments are preserved.</p>
</td></tr>
<tr><td><code id="lang_+3A_.ns">.ns</code></td>
<td>
<p>Namespace with which to prefix <code>.fn</code>. Must be a string
or symbol.</p>
</td></tr>
</table>

<hr>
<h2 id='last_error'>Last <code>abort()</code> error</h2><span id='topic+last_error'></span><span id='topic+last_trace'></span>

<h3>Description</h3>


<ul>
<li> <p><code>last_error()</code> returns the last error entraced by <code><a href="rlang.html#topic+abort">abort()</a></code> or
<code><a href="rlang.html#topic+global_entrace">global_entrace()</a></code>. The error is printed with a backtrace in
simplified form.
</p>
</li>
<li> <p><code>last_trace()</code> is a shortcut to return the backtrace stored in
the last error. This backtrace is printed in full form.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>last_error()

last_trace(drop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_error_+3A_drop">drop</code></td>
<td>
<p>Whether to drop technical calls. These are hidden from
users by default, set <code>drop</code> to <code>FALSE</code> to see the full backtrace.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="rlang.html#topic+rlang_backtrace_on_error">rlang_backtrace_on_error</a></code> to control what is displayed when an
error is thrown.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+global_entrace">global_entrace()</a></code> to enable <code>last_error()</code> logging for all errors.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+last_warnings">last_warnings()</a></code> and <code><a href="rlang.html#topic+last_messages">last_messages()</a></code>.
</p>
</li></ul>


<hr>
<h2 id='last_warnings'>Display last messages and warnings</h2><span id='topic+last_warnings'></span><span id='topic+last_messages'></span>

<h3>Description</h3>

<p><code>last_warnings()</code> and <code>last_messages()</code> return a list of all
warnings and messages that occurred during the last R command.
</p>
<p><code><a href="rlang.html#topic+global_entrace">global_entrace()</a></code> must be active in order to log the messages and
warnings.
</p>
<p>By default the warnings and messages are printed with a simplified
backtrace, like <code><a href="rlang.html#topic+last_error">last_error()</a></code>. Use <code>summary()</code> to print the
conditions with a full backtrace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_warnings(n = NULL)

last_messages(n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_warnings_+3A_n">n</code></td>
<td>
<p>How many warnings or messages to display. Defaults to all.</p>
</td></tr>
</table>


<h3>Examples</h3>

<p>Enable backtrace capture with <code>global_entrace()</code>:
</p>
<div class="sourceCode r"><pre>global_entrace()
</pre></div>
<p>Signal some warnings in nested functions. The warnings inform about
which function emitted a warning but they don't provide information
about the call stack:
</p>
<div class="sourceCode r"><pre>f &lt;- function() { warning("foo"); g() }
g &lt;- function() { warning("bar", immediate. = TRUE); h() }
h &lt;- function() warning("baz")

f()
#&gt; Warning in g() : bar
#&gt; Warning messages:
#&gt; 1: In f() : foo
#&gt; 2: In h() : baz
</pre></div>
<p>Call <code>last_warnings()</code> to see backtraces for each of these warnings:
</p>
<div class="sourceCode r"><pre>last_warnings()
#&gt; [[1]]
#&gt; &lt;warning/rlang_warning&gt;
#&gt; Warning in `f()`:
#&gt; foo
#&gt; Backtrace:
#&gt;     x
#&gt;  1. \-global f()
#&gt;
#&gt; [[2]]
#&gt; &lt;warning/rlang_warning&gt;
#&gt; Warning in `g()`:
#&gt; bar
#&gt; Backtrace:
#&gt;     x
#&gt;  1. \-global f()
#&gt;  2.   \-global g()
#&gt;
#&gt; [[3]]
#&gt; &lt;warning/rlang_warning&gt;
#&gt; Warning in `h()`:
#&gt; baz
#&gt; Backtrace:
#&gt;     x
#&gt;  1. \-global f()
#&gt;  2.   \-global g()
#&gt;  3.     \-global h()
</pre></div>
<p>This works similarly with messages:
</p>
<div class="sourceCode r"><pre>f &lt;- function() { inform("Hey!"); g() }
g &lt;- function() { inform("Hi!"); h() }
h &lt;- function() inform("Hello!")

f()
#&gt; Hey!
#&gt; Hi!
#&gt; Hello!

rlang::last_messages()
#&gt; [[1]]
#&gt; &lt;message/rlang_message&gt;
#&gt; Message:
#&gt; Hey!
#&gt; ---
#&gt; Backtrace:
#&gt;     x
#&gt;  1. \-global f()
#&gt;
#&gt; [[2]]
#&gt; &lt;message/rlang_message&gt;
#&gt; Message:
#&gt; Hi!
#&gt; ---
#&gt; Backtrace:
#&gt;     x
#&gt;  1. \-global f()
#&gt;  2.   \-global g()
#&gt;
#&gt; [[3]]
#&gt; &lt;message/rlang_message&gt;
#&gt; Message:
#&gt; Hello!
#&gt; ---
#&gt; Backtrace:
#&gt;     x
#&gt;  1. \-global f()
#&gt;  2.   \-global g()
#&gt;  3.     \-global h()
</pre></div>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+last_error">last_error()</a></code>
</p>

<hr>
<h2 id='list2'>Collect dynamic dots in a list</h2><span id='topic+list2'></span><span id='topic+ll'></span><span id='topic+dots_list'></span>

<h3>Description</h3>

<p><code>list2(...)</code> is equivalent to <code>list(...)</code> with a few additional
features, collectively called <a href="rlang.html#topic+dyn-dots">dynamic dots</a>. While
<code>list2()</code> hard-code these features, <code>dots_list()</code> is a lower-level
version that offers more control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2(...)

dots_list(
  ...,
  .named = FALSE,
  .ignore_empty = c("trailing", "none", "all"),
  .preserve_empty = FALSE,
  .homonyms = c("keep", "first", "last", "error"),
  .check_assign = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2_+3A_...">...</code></td>
<td>
<p>Arguments to collect in a list. These dots are
<a href="rlang.html#topic+dyn-dots">dynamic</a>.</p>
</td></tr>
<tr><td><code id="list2_+3A_.named">.named</code></td>
<td>
<p>If <code>TRUE</code>, unnamed inputs are automatically named
with <code><a href="dplyr.html#topic+as_label">as_label()</a></code>. This is equivalent to applying
<code><a href="rlang.html#topic+exprs_auto_name">exprs_auto_name()</a></code> on the result. If <code>FALSE</code>, unnamed elements
are left as is and, if fully unnamed, the list is given minimal
names (a vector of <code>""</code>). If <code>NULL</code>, fully unnamed results are
left with <code>NULL</code> names.</p>
</td></tr>
<tr><td><code id="list2_+3A_.ignore_empty">.ignore_empty</code></td>
<td>
<p>Whether to ignore empty arguments. Can be one
of <code>"trailing"</code>, <code>"none"</code>, <code>"all"</code>. If <code>"trailing"</code>, only the
last argument is ignored if it is empty.</p>
</td></tr>
<tr><td><code id="list2_+3A_.preserve_empty">.preserve_empty</code></td>
<td>
<p>Whether to preserve the empty arguments that
were not ignored. If <code>TRUE</code>, empty arguments are stored with
<code><a href="lazyeval.html#topic+missing_arg">missing_arg()</a></code> values. If <code>FALSE</code> (the default) an error is
thrown when an empty argument is detected.</p>
</td></tr>
<tr><td><code id="list2_+3A_.homonyms">.homonyms</code></td>
<td>
<p>How to treat arguments with the same name. The
default, <code>"keep"</code>, preserves these arguments. Set <code>.homonyms</code> to
<code>"first"</code> to only keep the first occurrences, to <code>"last"</code> to keep
the last occurrences, and to <code>"error"</code> to raise an informative
error and indicate what arguments have duplicated names.</p>
</td></tr>
<tr><td><code id="list2_+3A_.check_assign">.check_assign</code></td>
<td>
<p>Whether to check for <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> calls. When <code>TRUE</code> a
warning recommends users to use <code>=</code> if they meant to match a
function parameter or wrap the <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> call in curly braces otherwise.
This ensures assignments are explicit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For historical reasons, <code>dots_list()</code> creates a named list by
default. By comparison <code>list2()</code> implements the preferred behaviour
of only creating a names vector when a name is supplied.
</p>


<h3>Value</h3>

<p>A list containing the <code>...</code> inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let's create a function that takes a variable number of arguments:
numeric &lt;- function(...) {
  dots &lt;- list2(...)
  num &lt;- as.numeric(dots)
  set_names(num, names(dots))
}
numeric(1, 2, 3)

# The main difference with list(...) is that list2(...) enables
# the `!!!` syntax to splice lists:
x &lt;- list(2, 3)
numeric(1, !!! x, 4)

# As well as unquoting of names:
nm &lt;- "yup!"
numeric(!!nm := 1)


# One useful application of splicing is to work around exact and
# partial matching of arguments. Let's create a function taking
# named arguments and dots:
fn &lt;- function(data, ...) {
  list2(...)
}

# You normally cannot pass an argument named `data` through the dots
# as it will match `fn`'s `data` argument. The splicing syntax
# provides a workaround:
fn("wrong!", data = letters)  # exact matching of `data`
fn("wrong!", dat = letters)   # partial matching of `data`
fn(some_data, !!!list(data = letters))  # no matching

# Empty trailing arguments are allowed:
list2(1, )

# But non-trailing empty arguments cause an error:
try(list2(1, , ))

# Use the more configurable `dots_list()` function to preserve all
# empty arguments:
list3 &lt;- function(...) dots_list(..., .preserve_empty = TRUE)

# Note how the last empty argument is still ignored because
# `.ignore_empty` defaults to "trailing":
list3(1, , )

# The list with preserved empty arguments is equivalent to:
list(1, missing_arg())


# Arguments with duplicated names are kept by default:
list2(a = 1, a = 2, b = 3, b = 4, 5, 6)

# Use the `.homonyms` argument to keep only the first of these:
dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = "first")

# Or the last:
dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = "last")

# Or raise an informative error:
try(dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = "error"))


# dots_list() can be configured to warn when a `&lt;-` call is
# detected:
my_list &lt;- function(...) dots_list(..., .check_assign = TRUE)
my_list(a &lt;- 1)

# There is no warning if the assignment is wrapped in braces.
# This requires users to be explicit about their intent:
my_list({ a &lt;- 1 })
</code></pre>

<hr>
<h2 id='local_bindings'>Temporarily change bindings of an environment</h2><span id='topic+local_bindings'></span><span id='topic+with_bindings'></span>

<h3>Description</h3>


<ul>
<li> <p><code>local_bindings()</code> temporarily changes bindings in <code>.env</code> (which
is by default the caller environment). The bindings are reset to
their original values when the current frame (or an arbitrary one
if you specify <code>.frame</code>) goes out of scope.
</p>
</li>
<li> <p><code>with_bindings()</code> evaluates <code>expr</code> with temporary bindings. When
<code>with_bindings()</code> returns, bindings are reset to their original
values. It is a simple wrapper around <code>local_bindings()</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>local_bindings(..., .env = .frame, .frame = caller_env())

with_bindings(.expr, ..., .env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_bindings_+3A_...">...</code></td>
<td>
<p>Pairs of names and values. These dots support splicing
(with value semantics) and name unquoting.</p>
</td></tr>
<tr><td><code id="local_bindings_+3A_.env">.env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="local_bindings_+3A_.frame">.frame</code></td>
<td>
<p>The frame environment that determines the scope of
the temporary bindings. When that frame is popped from the call
stack, bindings are switched back to their original values.</p>
</td></tr>
<tr><td><code id="local_bindings_+3A_.expr">.expr</code></td>
<td>
<p>An expression to evaluate with temporary bindings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>local_bindings()</code> returns the values of old bindings
invisibly; <code>with_bindings()</code> returns the value of <code>expr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- "foo"
bar &lt;- "bar"

# `foo` will be temporarily rebinded while executing `expr`
with_bindings(paste(foo, bar), foo = "rebinded")
paste(foo, bar)
</code></pre>

<hr>
<h2 id='local_error_call'>Set local error call in an execution environment</h2><span id='topic+local_error_call'></span>

<h3>Description</h3>

<p><code>local_error_call()</code> is an alternative to explicitly passing a
<code>call</code> argument to <code><a href="rlang.html#topic+abort">abort()</a></code>. It sets the call (or a value that
indicates where to find the call, see below) in a local binding
that is automatically picked up by <code><a href="rlang.html#topic+abort">abort()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_error_call(call, frame = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_error_call_+3A_call">call</code></td>
<td>
<p>This can be:
</p>

<ul>
<li><p> A call to be used as context for an error thrown in that
execution environment.
</p>
</li>
<li><p> The <code>NULL</code> value to show no context.
</p>
</li>
<li><p> An execution environment, e.g. as returned by <code><a href="rlang.html#topic+caller_env">caller_env()</a></code>.
The <code><a href="base.html#topic+sys.call">sys.call()</a></code> for that environment is taken as context.
</p>
</li></ul>
</td></tr>
<tr><td><code id="local_error_call_+3A_frame">frame</code></td>
<td>
<p>The execution environment in which to set the local
error call.</p>
</td></tr>
</table>


<h3>Motivation for setting local error calls</h3>

<p>By default <code><a href="rlang.html#topic+abort">abort()</a></code> uses the function call of its caller as
context in error messages:
</p>
<div class="sourceCode"><pre>foo &lt;- function() abort("Uh oh.")
foo()
#&gt; Error in `foo()`: Uh oh.
</pre></div>
<p>This is not always appropriate. For example a function that checks
an input on the behalf of another function should reference the
latter, not the former:
</p>
<div class="sourceCode"><pre>arg_check &lt;- function(arg,
                      error_arg = as_string(substitute(arg))) {
  abort(cli::format_error("{.arg {error_arg}} is failing."))
}

foo &lt;- function(x) arg_check(x)
foo()
#&gt; Error in `arg_check()`: `x` is failing.
</pre></div>
<p>The mismatch is clear in the example above. <code>arg_check()</code> does not
have any <code>x</code> argument and so it is confusing to present
<code>arg_check()</code> as being the relevant context for the failure of the
<code>x</code> argument.
</p>
<p>One way around this is to take a <code>call</code> or <code>error_call</code> argument
and pass it to <code>abort()</code>. Here we name this argument <code>error_call</code>
for consistency with <code>error_arg</code> which is prefixed because there is
an existing <code>arg</code> argument. In other situations, taking <code>arg</code> and
<code>call</code> arguments might be appropriate.
</p>
<div class="sourceCode"><pre>arg_check &lt;- function(arg,
                      error_arg = as_string(substitute(arg)),
                      error_call = caller_env()) {
  abort(
    cli::format_error("{.arg {error_arg}} is failing."),
    call = error_call
  )
}

foo &lt;- function(x) arg_check(x)
foo()
#&gt; Error in `foo()`: `x` is failing.
</pre></div>
<p>This is the generally recommended pattern for argument checking
functions. If you mention an argument in an error message, provide
your callers a way to supply a different argument name and a
different error call. <code>abort()</code> stores the error call in the <code>call</code>
condition field which is then used to generate the &quot;in&quot; part of
error messages.
</p>
<p>In more complex cases it's often burdensome to pass the relevant
call around, for instance if your checking and throwing code is
structured into many different functions. In this case, use
<code>local_error_call()</code> to set the call locally or instruct <code>abort()</code>
to climb the call stack one level to find the relevant call. In the
following example, the complexity is not so important that sparing
the argument passing makes a big difference. However this
illustrates the pattern:
</p>
<div class="sourceCode"><pre>arg_check &lt;- function(arg,
                      error_arg = caller_arg(arg),
                      error_call = caller_env()) {
  # Set the local error call
  local_error_call(error_call)

  my_classed_stop(
    cli::format_error("{.arg {error_arg}} is failing.")
  )
}

my_classed_stop &lt;- function(message) {
  # Forward the local error call to the caller's
  local_error_call(caller_env())

  abort(message, class = "my_class")
}

foo &lt;- function(x) arg_check(x)
foo()
#&gt; Error in `foo()`: `x` is failing.
</pre></div>


<h3>Error call flags in performance-critical functions</h3>

<p>The <code>call</code> argument can also be the string <code>"caller"</code>. This is
equivalent to <code>caller_env()</code> or <code>parent.frame()</code> but has a lower
overhead because call stack introspection is only performed when an
error is triggered. Note that eagerly calling <code>caller_env()</code> is
fast enough in almost all cases.
</p>
<p>If your function needs to be really fast, assign the error call
flag directly instead of calling <code>local_error_call()</code>:
</p>
<div class="sourceCode"><pre>.__error_call__. &lt;- "caller"
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'># Set a context for error messages
function() {
  local_error_call(quote(foo()))
  local_error_call(sys.call())
}

# Disable the context
function() {
  local_error_call(NULL)
}

# Use the caller's context
function() {
  local_error_call(caller_env())
}
</code></pre>

<hr>
<h2 id='local_options'>Change global options</h2><span id='topic+local_options'></span><span id='topic+with_options'></span><span id='topic+push_options'></span><span id='topic+peek_options'></span><span id='topic+peek_option'></span>

<h3>Description</h3>


<ul>
<li> <p><code>local_options()</code> changes options for the duration of a stack
frame (by default the current one). Options are set back to their
old values when the frame returns.
</p>
</li>
<li> <p><code>with_options()</code> changes options while an expression is
evaluated. Options are restored when the expression returns.
</p>
</li>
<li> <p><code>push_options()</code> adds or changes options permanently.
</p>
</li>
<li> <p><code>peek_option()</code> and <code>peek_options()</code> return option values. The
former returns the option directly while the latter returns a
list.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>local_options(..., .frame = caller_env())

with_options(.expr, ...)

push_options(...)

peek_options(...)

peek_option(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_options_+3A_...">...</code></td>
<td>
<p>For <code>local_options()</code> and <code>push_options()</code>, named
values defining new option values. For <code>peek_options()</code>, strings
or character vectors of option names.</p>
</td></tr>
<tr><td><code id="local_options_+3A_.frame">.frame</code></td>
<td>
<p>The environment of a stack frame which defines the
scope of the temporary options. When the frame returns, the
options are set back to their original values.</p>
</td></tr>
<tr><td><code id="local_options_+3A_.expr">.expr</code></td>
<td>
<p>An expression to evaluate with temporary options.</p>
</td></tr>
<tr><td><code id="local_options_+3A_name">name</code></td>
<td>
<p>An option name as string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>local_options()</code> and <code>push_options()</code>, the old option
values. <code>peek_option()</code> returns the current value of an option
while the plural <code>peek_options()</code> returns a list of current
option values.
</p>


<h3>Life cycle</h3>

<p>These functions are experimental.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Store and retrieve a global option:
push_options(my_option = 10)
peek_option("my_option")

# Change the option temporarily:
with_options(my_option = 100, peek_option("my_option"))
peek_option("my_option")

# The scoped variant is useful within functions:
fn &lt;- function() {
  local_options(my_option = 100)
  peek_option("my_option")
}
fn()
peek_option("my_option")

# The plural peek returns a named list:
peek_options("my_option")
peek_options("my_option", "digits")
</code></pre>

<hr>
<h2 id='local_use_cli'>Use cli to format error messages</h2><span id='topic+local_use_cli'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>local_use_cli()</code> marks a package namespace or the environment of a
running function with a special flag that instructs <code><a href="rlang.html#topic+abort">abort()</a></code> to
use cli to format error messages. This formatting happens lazily,
at print-time, in various places:
</p>

<ul>
<li><p> When an unexpected error is displayed to the user.
</p>
</li>
<li><p> When a captured error is printed in the console, for instance via
<code><a href="rlang.html#topic+last_error">last_error()</a></code>.
</p>
</li>
<li><p> When <code><a href="base.html#topic+conditionMessage">conditionMessage()</a></code> is called.
</p>
</li></ul>

<p>cli formats messages and bullets with indentation and
width-wrapping to produce a polished display of messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_use_cli(..., format = TRUE, inline = FALSE, frame = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_use_cli_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="local_use_cli_+3A_format">format</code></td>
<td>
<p>Whether to use cli at print-time to format messages
and bullets.</p>
</td></tr>
<tr><td><code id="local_use_cli_+3A_inline">inline</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Whether to use
cli at throw-time to format the inline parts of a message. This
makes it possible to use cli interpolation and formatting with
<code>abort()</code>.</p>
</td></tr>
<tr><td><code id="local_use_cli_+3A_frame">frame</code></td>
<td>
<p>A package namespace or an environment of a running
function.</p>
</td></tr>
</table>


<h3>Usage</h3>

<p>To use cli formatting automatically in your package:
</p>

<ol>
<li><p> Make sure <code><a href="rlang.html#topic+run_on_load">run_on_load()</a></code> is called from your <code>.onLoad()</code> hook.
</p>
</li>
<li><p> Call <code>on_load(local_use_cli())</code> at the top level of your namespace.
</p>
</li></ol>

<p>It is also possible to call <code>local_use_cli()</code> inside a running
function, in which case the flag only applies within that function.
</p>

<hr>
<h2 id='missing'>Missing values</h2><span id='topic+missing'></span><span id='topic+na_lgl'></span><span id='topic+na_int'></span><span id='topic+na_dbl'></span><span id='topic+na_chr'></span><span id='topic+na_cpl'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a>
</p>
<p>Missing values are represented in R with the general symbol
<code>NA</code>. They can be inserted in almost all data containers: all
atomic vectors except raw vectors can contain missing values. To
achieve this, R automatically converts the general <code>NA</code> symbol to a
typed missing value appropriate for the target vector. The objects
provided here are aliases for those typed <code>NA</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_lgl

na_int

na_dbl

na_chr

na_cpl
</code></pre>


<h3>Format</h3>

<p>An object of class <code>logical</code> of length 1.
</p>
<p>An object of class <code>integer</code> of length 1.
</p>
<p>An object of class <code>numeric</code> of length 1.
</p>
<p>An object of class <code>character</code> of length 1.
</p>
<p>An object of class <code>complex</code> of length 1.
</p>


<h3>Details</h3>

<p>Typed missing values are necessary because R needs sentinel values
of the same type (i.e. the same machine representation of the data)
as the containers into which they are inserted. The official typed
missing values are <code>NA_integer_</code>, <code>NA_real_</code>, <code>NA_character_</code> and
<code>NA_complex_</code>. The missing value for logical vectors is simply the
default <code>NA</code>. The aliases provided in rlang are consistently named
and thus simpler to remember. Also, <code>na_lgl</code> is provided as an
alias to <code>NA</code> that makes intent clearer.
</p>
<p>Since <code>na_lgl</code> is the default <code>NA</code>, expressions such as <code>c(NA, NA)</code>
yield logical vectors as no data is available to give a clue of the
target type. In the same way, since lists and environments can
contain any types, expressions like <code>list(NA)</code> store a logical
<code>NA</code>.
</p>


<h3>Life cycle</h3>

<p>These shortcuts might be moved to the vctrs package at some
point. This is why they are marked as questioning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>typeof(NA)
typeof(na_lgl)
typeof(na_int)

# Note that while the base R missing symbols cannot be overwritten,
# that's not the case for rlang's aliases:
na_dbl &lt;- NA
typeof(na_dbl)
</code></pre>

<hr>
<h2 id='missing_arg'>Generate or handle a missing argument</h2><span id='topic+missing_arg'></span><span id='topic+is_missing'></span><span id='topic+maybe_missing'></span>

<h3>Description</h3>

<p>These functions help using the missing argument as a regular R
object.
</p>

<ul>
<li> <p><code>missing_arg()</code> generates a missing argument.
</p>
</li>
<li> <p><code>is_missing()</code> is like <code><a href="base.html#topic+missing">base::missing()</a></code> but also supports
testing for missing arguments contained in other objects like
lists. It is also more consistent with default arguments which
are never treated as missing (see section below).
</p>
</li>
<li> <p><code>maybe_missing()</code> is useful to pass down an input that might be
missing to another function, potentially substituting by a
default value. It avoids triggering an &quot;argument is missing&quot; error.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>missing_arg()

is_missing(x)

maybe_missing(x, default = missing_arg())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_arg_+3A_x">x</code></td>
<td>
<p>An object that might be the missing argument.</p>
</td></tr>
<tr><td><code id="missing_arg_+3A_default">default</code></td>
<td>
<p>The object to return if the input is missing,
defaults to <code>missing_arg()</code>.</p>
</td></tr>
</table>


<h3>Other ways to reify the missing argument</h3>


<ul>
<li> <p><code>base::quote(expr = )</code> is the canonical way to create a missing
argument object.
</p>
</li>
<li> <p><code>expr()</code> called without argument creates a missing argument.
</p>
</li>
<li> <p><code>quo()</code> called without argument creates an empty quosure, i.e. a
quosure containing the missing argument object.
</p>
</li></ul>



<h3><code>is_missing()</code> and default arguments</h3>

<p>The base function <code><a href="base.html#topic+missing">missing()</a></code> makes a distinction between default
values supplied explicitly and default values generated through a
missing argument:
</p>
<div class="sourceCode r"><pre>fn &lt;- function(x = 1) base::missing(x)

fn()
#&gt; [1] TRUE
fn(1)
#&gt; [1] FALSE
</pre></div>
<p>This only happens within a function. If the default value has been
generated in a calling function, it is never treated as missing:
</p>
<div class="sourceCode r"><pre>caller &lt;- function(x = 1) fn(x)
caller()
#&gt; [1] FALSE
</pre></div>
<p><code>rlang::is_missing()</code> simplifies these rules by never treating
default arguments as missing, even in internal contexts:
</p>
<div class="sourceCode r"><pre>fn &lt;- function(x = 1) rlang::is_missing(x)

fn()
#&gt; [1] FALSE
fn(1)
#&gt; [1] FALSE
</pre></div>
<p>This is a little less flexible because you can't specialise
behaviour based on implicitly supplied default values. However,
this makes the behaviour of <code>is_missing()</code> and functions using it
simpler to understand.
</p>


<h3>Fragility of the missing argument object</h3>

<p>The missing argument is an object that triggers an error if and
only if it is the result of evaluating a symbol. No error is
produced when a function call evaluates to the missing argument
object. For instance, it is possible to bind the missing argument
to a variable with an expression like <code>x[[1]] &lt;- missing_arg()</code>.
Likewise, <code>x[[1]]</code> is safe to use as argument, e.g. <code>list(x[[1]])</code>
even when the result is the missing object.
</p>
<p>However, as soon as the missing argument is passed down between
functions through a bare variable, it is likely to cause a missing
argument error:
</p>
<div class="sourceCode r"><pre>x &lt;- missing_arg()
list(x)
#&gt; Error:
#&gt; ! argument "x" is missing, with no default
</pre></div>
<p>To work around this, <code>is_missing()</code> and <code>maybe_missing(x)</code> use a
bit of magic to determine if the input is the missing argument
without triggering a missing error.
</p>
<div class="sourceCode r"><pre>x &lt;- missing_arg()
list(maybe_missing(x))
#&gt; [[1]]
#&gt;
</pre></div>
<p><code>maybe_missing()</code> is particularly useful for prototyping
meta-programming algorithms in R. The missing argument is a likely
input when computing on the language because it is a standard
object in formals lists. While C functions are always allowed to
return the missing argument and pass it to other C functions, this
is not the case on the R side. If you're implementing your
meta-programming algorithm in R, use <code>maybe_missing()</code> when an
input might be the missing argument object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The missing argument usually arises inside a function when the
# user omits an argument that does not have a default:
fn &lt;- function(x) is_missing(x)
fn()

# Creating a missing argument can also be useful to generate calls
args &lt;- list(1, missing_arg(), 3, missing_arg())
quo(fn(!!! args))

# Other ways to create that object include:
quote(expr = )
expr()

# It is perfectly valid to generate and assign the missing
# argument in a list.
x &lt;- missing_arg()
l &lt;- list(missing_arg())

# Just don't evaluate a symbol that contains the empty argument.
# Evaluating the object `x` that we created above would trigger an
# error.
# x  # Not run

# On the other hand accessing a missing argument contained in a
# list does not trigger an error because subsetting is a function
# call:
l[[1]]
is.null(l[[1]])

# In case you really need to access a symbol that might contain the
# empty argument object, use maybe_missing():
maybe_missing(x)
is.null(maybe_missing(x))
is_missing(maybe_missing(x))


# Note that base::missing() only works on symbols and does not
# support complex expressions. For this reason the following lines
# would throw an error:

#&gt; missing(missing_arg())
#&gt; missing(l[[1]])

# while is_missing() will work as expected:
is_missing(missing_arg())
is_missing(l[[1]])
</code></pre>

<hr>
<h2 id='names_inform_repair'>Inform about name repair</h2><span id='topic+names_inform_repair'></span>

<h3>Description</h3>

<p>Inform about name repair
</p>


<h3>Usage</h3>

<pre><code class='language-R'>names_inform_repair(old, new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names_inform_repair_+3A_old">old</code></td>
<td>
<p>Original names vector.</p>
</td></tr>
<tr><td><code id="names_inform_repair_+3A_new">new</code></td>
<td>
<p>Repaired names vector.</p>
</td></tr>
</table>


<h3>Muffling and silencing messages</h3>

<p>Name repair messages are signaled with <code><a href="rlang.html#topic+inform">inform()</a></code> and are given the class
<code>"rlib_message_name_repair"</code>. These messages can be muffled with
<code><a href="base.html#topic+message">base::suppressMessages()</a></code>.
</p>
<p>Name repair messages can also be silenced with the global option
<code>rlib_name_repair_verbosity</code>. This option takes the values:
</p>

<ul>
<li> <p><code>"verbose"</code>: Always verbose.
</p>
</li>
<li> <p><code>"quiet"</code>: Always quiet.
</p>
</li></ul>

<p>When set to quiet, the message is not displayed and the condition is not
signaled. This is particularly useful for silencing messages during testing
when combined with <code><a href="rlang.html#topic+local_options">local_options()</a></code>.
</p>

<hr>
<h2 id='names2'>Get names of a vector</h2><span id='topic+names2'></span><span id='topic+names2+3C-'></span>

<h3>Description</h3>

<p><code>names2()</code> always returns a character vector, even when an
object does not have a <code>names</code> attribute. In this case, it returns
a vector of empty names <code>""</code>. It also standardises missing names to
<code>""</code>.
</p>
<p>The replacement variant <code style="white-space: pre;">&#8288;names2&lt;-&#8288;</code> never adds <code>NA</code> names and
instead fills unnamed vectors with <code>""</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>names2(x)

names2(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names2_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="names2_+3A_value">value</code></td>
<td>
<p>New names.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>names2(letters)

# It also takes care of standardising missing names:
x &lt;- set_names(1:3, c("a", NA, "b"))
names2(x)

# Replacing names with the base `names&lt;-` function may introduce
# `NA` values when the vector is unnamed:
x &lt;- 1:3
names(x)[1:2] &lt;- "foo"
names(x)

# Use the `names2&lt;-` variant to avoid this
x &lt;- 1:3
names2(x)[1:2] &lt;- "foo"
names(x)

</code></pre>

<hr>
<h2 id='new_call'>Create a new call from components</h2><span id='topic+new_call'></span>

<h3>Description</h3>

<p>Create a new call from components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_call(car, cdr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_call_+3A_car">car</code></td>
<td>
<p>The head of the call. It should be a
<a href="rlang.html#topic+is_callable">callable</a> object: a symbol, call, or literal
function.</p>
</td></tr>
<tr><td><code id="new_call_+3A_cdr">cdr</code></td>
<td>
<p>The tail of the call, i.e. a <a href="rlang.html#topic+new_node">pairlist</a> of
arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='new_formula'>Create a formula</h2><span id='topic+new_formula'></span>

<h3>Description</h3>

<p>Create a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_formula(lhs, rhs, env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_formula_+3A_lhs">lhs</code>, <code id="new_formula_+3A_rhs">rhs</code></td>
<td>
<p>A call, name, or atomic vector.</p>
</td></tr>
<tr><td><code id="new_formula_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula object.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+new_quosure">new_quosure()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_formula(quote(a), quote(b))
new_formula(NULL, quote(b))
</code></pre>

<hr>
<h2 id='new_function'>Create a function</h2><span id='topic+new_function'></span>

<h3>Description</h3>

<p>This constructs a new function given its three components:
list of arguments, body code and parent environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_function(args, body, env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_function_+3A_args">args</code></td>
<td>
<p>A named list or pairlist of default arguments. Note
that if you want arguments that don't have defaults, you'll need
to use the special function <code><a href="rlang.html#topic+pairlist2">pairlist2()</a></code>. If you need quoted
defaults, use <code><a href="rlang.html#topic+exprs">exprs()</a></code>.</p>
</td></tr>
<tr><td><code id="new_function_+3A_body">body</code></td>
<td>
<p>A language object representing the code inside the
function. Usually this will be most easily generated with
<code><a href="base.html#topic+substitute">base::quote()</a></code></p>
</td></tr>
<tr><td><code id="new_function_+3A_env">env</code></td>
<td>
<p>The parent environment of the function, defaults to the
calling environment of <code>new_function()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function() letters
g &lt;- new_function(NULL, quote(letters))
identical(f, g)

# Pass a list or pairlist of named arguments to create a function
# with parameters. The name becomes the parameter name and the
# argument the default value for this parameter:
new_function(list(x = 10), quote(x))
new_function(pairlist2(x = 10), quote(x))

# Use `exprs()` to create quoted defaults. Compare:
new_function(pairlist2(x = 5 + 5), quote(x))
new_function(exprs(x = 5 + 5), quote(x))

# Pass empty arguments to omit defaults. `list()` doesn't allow
# empty arguments but `pairlist2()` does:
new_function(pairlist2(x = , y = 5 + 5), quote(x + y))
new_function(exprs(x = , y = 5 + 5), quote(x + y))
</code></pre>

<hr>
<h2 id='new_node'>Helpers for pairlist and language nodes</h2><span id='topic+new_node'></span><span id='topic+node_car'></span><span id='topic+node_cdr'></span><span id='topic+node_caar'></span><span id='topic+node_cadr'></span><span id='topic+node_cdar'></span><span id='topic+node_cddr'></span><span id='topic+node_poke_car'></span><span id='topic+node_poke_cdr'></span><span id='topic+node_poke_caar'></span><span id='topic+node_poke_cadr'></span><span id='topic+node_poke_cdar'></span><span id='topic+node_poke_cddr'></span><span id='topic+node_tag'></span><span id='topic+node_poke_tag'></span>

<h3>Description</h3>

<p><strong>Important</strong>: These functions are for expert R programmers only.
You should only use them if you feel comfortable manipulating low
level R data structures at the C level. We export them at the R level
in order to make it easy to prototype C code. They don't perform
any type checking and can crash R very easily (try to take the CAR
of an integer vector &mdash; save any important objects beforehand!).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_node(car, cdr = NULL)

node_car(x)

node_cdr(x)

node_caar(x)

node_cadr(x)

node_cdar(x)

node_cddr(x)

node_poke_car(x, newcar)

node_poke_cdr(x, newcdr)

node_poke_caar(x, newcar)

node_poke_cadr(x, newcar)

node_poke_cdar(x, newcdr)

node_poke_cddr(x, newcdr)

node_tag(x)

node_poke_tag(x, newtag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_node_+3A_car">car</code>, <code id="new_node_+3A_newcar">newcar</code>, <code id="new_node_+3A_cdr">cdr</code>, <code id="new_node_+3A_newcdr">newcdr</code></td>
<td>
<p>The new CAR or CDR for the node. These
can be any R objects.</p>
</td></tr>
<tr><td><code id="new_node_+3A_x">x</code></td>
<td>
<p>A language or pairlist node. Note that these functions are
barebones and do not perform any type checking.</p>
</td></tr>
<tr><td><code id="new_node_+3A_newtag">newtag</code></td>
<td>
<p>The new tag for the node. This should be a symbol.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Setters like <code>node_poke_car()</code> invisibly return <code>x</code> modified
in place. Getters return the requested node component.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+duplicate">duplicate()</a></code> for creating copy-safe objects and
<code><a href="base.html#topic+list">base::pairlist()</a></code> for an easier way of creating a linked list of
nodes.
</p>

<hr>
<h2 id='new_quosure'>Create a quosure from components</h2><span id='topic+new_quosure'></span><span id='topic+as_quosure'></span><span id='topic+is_quosure'></span>

<h3>Description</h3>


<ul>
<li> <p><code>new_quosure()</code> wraps any R object (including expressions,
formulas, or other quosures) into a <a href="rlang.html#topic+topic-quosure">quosure</a>.
</p>
</li>
<li> <p><code>as_quosure()</code> is similar but it does not rewrap formulas and
quosures.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>new_quosure(expr, env = caller_env())

as_quosure(x, env = NULL)

is_quosure(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_quosure_+3A_expr">expr</code></td>
<td>
<p>An expression to wrap in a quosure.</p>
</td></tr>
<tr><td><code id="new_quosure_+3A_env">env</code></td>
<td>
<p>The environment in which the expression should be
evaluated. Only used for symbols and calls. This should normally
be the environment in which the expression was created.</p>
</td></tr>
<tr><td><code id="new_quosure_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="dplyr.html#topic+enquo">enquo()</a></code> and <code><a href="dplyr.html#topic+quo">quo()</a></code> for creating a quosure by <a href="rlang.html#topic+topic-defuse">argument defusal</a>.
</p>
</li>
<li> <p><a href="rlang.html#topic+topic-quosure">What are quosures and when are they needed?</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># `new_quosure()` creates a quosure from its components. These are
# equivalent:
new_quosure(quote(foo), current_env())

quo(foo)

# `new_quosure()` always rewraps its input into a new quosure, even
# if the input is itself a quosure:
new_quosure(quo(foo))

# This is unlike `as_quosure()` which preserves its input if it's
# already a quosure:
as_quosure(quo(foo))


# `as_quosure()` uses the supplied environment with naked expressions:
env &lt;- env(var = "thing")
as_quosure(quote(var), env)

# If the expression already carries an environment, this
# environment is preserved. This is the case for formulas and
# quosures:
as_quosure(~foo, env)

as_quosure(~foo)

# An environment must be supplied when the input is a naked
# expression:
try(
  as_quosure(quote(var))
)
</code></pre>

<hr>
<h2 id='new_quosures'>Create a list of quosures</h2><span id='topic+new_quosures'></span><span id='topic+as_quosures'></span><span id='topic+is_quosures'></span>

<h3>Description</h3>

<p>This small S3 class provides methods for <code>[</code> and <code>c()</code> and ensures
the following invariants:
</p>

<ul>
<li><p> The list only contains quosures.
</p>
</li>
<li><p> It is always named, possibly with a vector of empty strings.
</p>
</li></ul>

<p><code>new_quosures()</code> takes a list of quosures and adds the <code>quosures</code>
class and a vector of empty names if needed. <code>as_quosures()</code> calls
<code><a href="rlang.html#topic+as_quosure">as_quosure()</a></code> on all elements before creating the <code>quosures</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_quosures(x)

as_quosures(x, env, named = FALSE)

is_quosures(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_quosures_+3A_x">x</code></td>
<td>
<p>A list of quosures or objects to coerce to quosures.</p>
</td></tr>
<tr><td><code id="new_quosures_+3A_env">env</code></td>
<td>
<p>The default environment for the new quosures.</p>
</td></tr>
<tr><td><code id="new_quosures_+3A_named">named</code></td>
<td>
<p>Whether to name the list with <code><a href="rlang.html#topic+quos_auto_name">quos_auto_name()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='new_weakref'>Create a weak reference</h2><span id='topic+new_weakref'></span>

<h3>Description</h3>

<p>A weak reference is a special R object which makes it possible to keep a
reference to an object without preventing garbage collection of that object.
It can also be used to keep data about an object without preventing GC of the
object, similar to WeakMaps in JavaScript.
</p>
<p>Objects in R are considered <em>reachable</em> if they can be accessed by following
a chain of references, starting from a <em>root node</em>; root nodes are
specially-designated R objects, and include the global environment and base
environment. As long as the key is reachable, the value will not be garbage
collected. This is true even if the weak reference object becomes
unreachable. The key effectively prevents the weak reference and its value
from being collected, according to the following chain of ownership:
<code>weakref &lt;- key -&gt; value</code>.
</p>
<p>When the key becomes unreachable, the key and value in the weak reference
object are replaced by <code>NULL</code>, and the finalizer is scheduled to execute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_weakref(key, value = NULL, finalizer = NULL, on_quit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_weakref_+3A_key">key</code></td>
<td>
<p>The key for the weak reference. Must be a reference object &ndash; that
is, an environment or external pointer.</p>
</td></tr>
<tr><td><code id="new_weakref_+3A_value">value</code></td>
<td>
<p>The value for the weak reference. This can be <code>NULL</code>, if you
want to use the weak reference like a weak pointer.</p>
</td></tr>
<tr><td><code id="new_weakref_+3A_finalizer">finalizer</code></td>
<td>
<p>A function that is run after the key becomes unreachable.</p>
</td></tr>
<tr><td><code id="new_weakref_+3A_on_quit">on_quit</code></td>
<td>
<p>Should the finalizer be run when R exits?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+is_weakref">is_weakref()</a></code>, <code><a href="rlang.html#topic+wref_key">wref_key()</a></code> and <code><a href="rlang.html#topic+wref_value">wref_value()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- env()

# Create a weak reference to e
w &lt;- new_weakref(e, finalizer = function(e) message("finalized"))

# Get the key object from the weak reference
identical(wref_key(w), e)

# When the regular reference (the `e` binding) is removed and a GC occurs,
# the weak reference will not keep the object alive.
rm(e)
gc()
identical(wref_key(w), NULL)


# A weak reference with a key and value. The value contains data about the
# key.
k &lt;- env()
v &lt;- list(1, 2, 3)
w &lt;- new_weakref(k, v)

identical(wref_key(w), k)
identical(wref_value(w), v)

# When v is removed, the weak ref keeps it alive because k is still reachable.
rm(v)
gc()
identical(wref_value(w), list(1, 2, 3))

# When k is removed, the weak ref does not keep k or v alive.
rm(k)
gc()
identical(wref_key(w), NULL)
identical(wref_value(w), NULL)
</code></pre>

<hr>
<h2 id='new-vector'>Create vectors matching a given length</h2><span id='topic+new-vector'></span><span id='topic+new_logical'></span><span id='topic+new_integer'></span><span id='topic+new_double'></span><span id='topic+new_character'></span><span id='topic+new_complex'></span><span id='topic+new_raw'></span><span id='topic+new_list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a>
</p>
<p>These functions construct vectors of a given length, with attributes
specified via dots. Except for <code>new_list()</code> and <code>new_raw()</code>, the
empty vectors are filled with typed <a href="base.html#topic+missing">missing</a> values. This is in
contrast to the base function <code><a href="base.html#topic+vector">base::vector()</a></code> which creates
zero-filled vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_logical(n, names = NULL)

new_integer(n, names = NULL)

new_double(n, names = NULL)

new_character(n, names = NULL)

new_complex(n, names = NULL)

new_raw(n, names = NULL)

new_list(n, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new-vector_+3A_n">n</code></td>
<td>
<p>The vector length.</p>
</td></tr>
<tr><td><code id="new-vector_+3A_names">names</code></td>
<td>
<p>Names for the new vector.</p>
</td></tr>
</table>


<h3>Lifecycle</h3>

<p>These functions are likely to be replaced by a vctrs equivalent in
the future. They are in the questioning lifecycle stage.
</p>


<h3>See Also</h3>

<p>rep_along
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_list(10)
new_logical(10)
</code></pre>

<hr>
<h2 id='ns_env'>Get the namespace of a package</h2><span id='topic+ns_env'></span><span id='topic+ns_imports_env'></span><span id='topic+ns_env_name'></span>

<h3>Description</h3>

<p>Namespaces are the environment where all the functions of a package
live. The parent environments of namespaces are the <code>imports</code>
environments, which contain all the functions imported from other
packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ns_env(x = caller_env())

ns_imports_env(x = caller_env())

ns_env_name(x = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ns_env_+3A_x">x</code></td>
<td>

<ul>
<li><p> For <code>ns_env()</code>, the name of a package or an environment as a
string.
</p>

<ul>
<li><p> An environment (the current environment by default).
</p>
</li>
<li><p> A function.
</p>
</li></ul>

<p>In the latter two cases, the environment ancestry is searched for
a namespace with <code><a href="base.html#topic+ns-topenv">base::topenv()</a></code>. If the environment doesn't
inherit from a namespace, this is an error.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="pkgload.html#topic+pkg_env">pkg_env()</a></code>
</p>

<hr>
<h2 id='ns_registry_env'>Return the namespace registry env</h2><span id='topic+ns_registry_env'></span>

<h3>Description</h3>

<p>Note that the namespace registry does not behave like a normal
environment because the parent is <code>NULL</code> instead of the empty
environment. This is exported for expert usage in development tools
only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ns_registry_env()
</code></pre>

<hr>
<h2 id='obj_address'>Address of an R object</h2><span id='topic+obj_address'></span>

<h3>Description</h3>

<p>Address of an R object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_address(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj_address_+3A_x">x</code></td>
<td>
<p>Any R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Its address in memory in a string.
</p>

<hr>
<h2 id='on_load'>Run expressions on load</h2><span id='topic+on_load'></span><span id='topic+run_on_load'></span><span id='topic+on_package_load'></span>

<h3>Description</h3>


<ul>
<li> <p><code>on_load()</code> registers expressions to be run on the user's machine
each time the package is loaded in memory. This is by contrast to
normal R package code which is run once at build time on the
packager's machine (e.g. CRAN).
</p>
<p><code>on_load()</code> expressions require <code>run_on_load()</code> to be called
inside <code><a href="base.html#topic+.onLoad">.onLoad()</a></code>.
</p>
</li>
<li> <p><code>on_package_load()</code> registers expressions to be run each time
another package is loaded.
</p>
</li></ul>

<p><code>on_load()</code> is for your own package and runs expressions when the
namespace is not <em>sealed</em> yet. This means you can modify existing
binding or create new ones. This is not the case with
<code>on_package_load()</code> which runs expressions after a foreign package
has finished loading, at which point its namespace is sealed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>on_load(expr, env = parent.frame(), ns = topenv(env))

run_on_load(ns = topenv(parent.frame()))

on_package_load(pkg, expr, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="on_load_+3A_expr">expr</code></td>
<td>
<p>An expression to run on load.</p>
</td></tr>
<tr><td><code id="on_load_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate <code>expr</code>. Defaults to
the current environment, which is your package namespace if you
run <code>on_load()</code> at top level.</p>
</td></tr>
<tr><td><code id="on_load_+3A_ns">ns</code></td>
<td>
<p>The namespace in which to hook <code>expr</code>.</p>
</td></tr>
<tr><td><code id="on_load_+3A_pkg">pkg</code></td>
<td>
<p>Package to hook expression into.</p>
</td></tr>
</table>


<h3>When should I run expressions on load?</h3>

<p>There are two main use cases for running expressions on load:
</p>

<ol>
<li><p> When a side effect, such as registering a method with
<code>s3_register()</code>, must occur in the user session rather than the
package builder session.
</p>
</li>
<li><p> To avoid hard-coding objects from other packages in your
namespace. If you assign <code>foo::bar</code> or the result of
<code>foo::baz()</code> in your package, they become constants. Any
upstream changes in the <code>foo</code> package will not be reflected in
the objects you've assigned in your namespace. This often breaks
assumptions made by the authors of <code>foo</code> and causes all sorts of
issues.
</p>
<p>Recreating the foreign objects each time your package is loaded
makes sure that any such changes will be taken into account. In
technical terms, running an expression on load introduces
<em>indirection</em>.
</p>
</li></ol>



<h3>Comparison with <code>.onLoad()</code></h3>

<p><code>on_load()</code> has the advantage that hooked expressions can appear in
any file, in context. This is unlike <code>.onLoad()</code> which gathers
disparate expressions in a single block.
</p>
<p><code>on_load()</code> is implemented via <code>.onLoad()</code> and requires
<code>run_on_load()</code> to be called from that hook.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quote({  # Not run

# First add `run_on_load()` to your `.onLoad()` hook,
# then use `on_load()` anywhere in your package
.onLoad &lt;- function(lib, pkg) {
  run_on_load()
}

# Register a method on load
on_load(s3_register("foo::bar", "my_class"))

# Assign an object on load
var &lt;- NULL
on_load(
  var &lt;- foo()
)

# To use `on_package_load()` at top level, wrap it in `on_load()`
on_load(on_package_load("foo", message("foo is loaded")))

# In functions it can be called directly
f &lt;- function() on_package_load("foo", message("foo is loaded"))

})
</code></pre>

<hr>
<h2 id='op-get-attr'>Infix attribute accessor and setter</h2><span id='topic+op-get-attr'></span><span id='topic++25+40+25'></span><span id='topic++25+40+25+3C-'></span>

<h3>Description</h3>

<p>This operator extracts or sets attributes for regular objects and
S4 fields for S4 objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %@% name

x %@% name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="op-get-attr_+3A_x">x</code></td>
<td>
<p>Object</p>
</td></tr>
<tr><td><code id="op-get-attr_+3A_name">name</code></td>
<td>
<p>Attribute name</p>
</td></tr>
<tr><td><code id="op-get-attr_+3A_value">value</code></td>
<td>
<p>New value for attribute <code>name</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Unlike `@`, this operator extracts attributes for any kind of
# objects:
factor(1:3) %@% "levels"
mtcars %@% class

mtcars %@% class &lt;- NULL
mtcars

# It also works on S4 objects:
.Person &lt;- setClass("Person", slots = c(name = "character", species = "character"))
fievel &lt;- .Person(name = "Fievel", species = "mouse")
fievel %@% name
</code></pre>

<hr>
<h2 id='op-na-default'>Replace missing values</h2><span id='topic+op-na-default'></span><span id='topic++25+7C+25'></span>

<h3>Description</h3>

<p><strong>Note</strong>: This operator is now out of scope for rlang. It will be
replaced by a vctrs-powered operator (probably in the <a href="https://github.com/tidyverse/funs">funs package</a>) at which point the
rlang version of <code style="white-space: pre;">&#8288;%|%&#8288;</code> will be deprecated.
</p>
<p>This infix function is similar to <code>%||%</code> but is vectorised
and provides a default value for missing elements. It is faster
than using <code><a href="base.html#topic+ifelse">base::ifelse()</a></code> and does not perform type conversions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %|% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="op-na-default_+3A_x">x</code></td>
<td>
<p>The original values.</p>
</td></tr>
<tr><td><code id="op-na-default_+3A_y">y</code></td>
<td>
<p>The replacement values. Must be of length 1 or the same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="rlang.html#topic+op-null-default">op-null-default</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c("a", "b", NA, "c") %|% "default"
c(1L, NA, 3L, NA, NA) %|% (6L:10L)
</code></pre>

<hr>
<h2 id='op-null-default'>Default value for <code>NULL</code></h2><span id='topic+op-null-default'></span><span id='topic++25+7C+7C+25'></span>

<h3>Description</h3>

<p>This infix function makes it easy to replace <code>NULL</code>s with a default
value. It's inspired by the way that Ruby's or operation (<code>||</code>)
works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %||% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="op-null-default_+3A_x">x</code>, <code id="op-null-default_+3A_y">y</code></td>
<td>
<p>If <code>x</code> is NULL, will return <code>y</code>; otherwise returns <code>x</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>1 %||% 2
NULL %||% 2
</code></pre>

<hr>
<h2 id='pairlist2'>Collect dynamic dots in a pairlist</h2><span id='topic+pairlist2'></span>

<h3>Description</h3>

<p>This pairlist constructor uses <a href="rlang.html#topic+dyn-dots">dynamic dots</a>. Use
it to manually create argument lists for calls or parameter lists
for functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairlist2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairlist2_+3A_...">...</code></td>
<td>
<p>&lt;<a href="rlang.html#topic+dyn-dots">dynamic</a>&gt; Arguments stored in the
pairlist. Empty arguments are preserved.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Unlike `exprs()`, `pairlist2()` evaluates its arguments.
new_function(pairlist2(x = 1, y = 3 * 6), quote(x * y))
new_function(exprs(x = 1, y = 3 * 6), quote(x * y))

# It preserves missing arguments, which is useful for creating
# parameters without defaults:
new_function(pairlist2(x = , y = 3 * 6), quote(x * y))
</code></pre>

<hr>
<h2 id='parse_expr'>Parse R code</h2><span id='topic+parse_expr'></span><span id='topic+parse_exprs'></span><span id='topic+parse_quo'></span><span id='topic+parse_quos'></span>

<h3>Description</h3>

<p>These functions parse and transform text into R expressions. This
is the first step to interpret or evaluate a piece of R code
written by a programmer.
</p>

<ul>
<li> <p><code>parse_expr()</code> returns one expression. If the text contains more
than one expression (separated by semicolons or new lines), an
error is issued. On the other hand <code>parse_exprs()</code> can handle
multiple expressions. It always returns a list of expressions
(compare to <code><a href="base.html#topic+parse">base::parse()</a></code> which returns a base::expression
vector). All functions also support R connections.
</p>
</li>
<li> <p><code>parse_expr()</code> concatenates <code>x</code> with <code style="white-space: pre;">&#8288;\\n&#8288;</code> separators prior to
parsing in order to support the roundtrip
<code>parse_expr(expr_deparse(x))</code> (deparsed expressions might be
multiline). On the other hand, <code>parse_exprs()</code> doesn't do any
concatenation because it's designed to support named inputs. The
names are matched to the expressions in the output, which is
useful when a single named string creates multiple expressions.
</p>
<p>In other words, <code>parse_expr()</code> supports vector of lines whereas
<code>parse_exprs()</code> expects vectors of complete deparsed expressions.
</p>
</li>
<li> <p><code>parse_quo()</code> and <code>parse_quos()</code> are variants that create a
<a href="dplyr.html#topic+quo">quosure</a>. Supply <code>env = current_env()</code> if you're parsing
code to be evaluated in your current context. Supply <code>env = global_env()</code> when you're parsing external user input to be
evaluated in user context.
</p>
<p>Unlike quosures created with <code><a href="dplyr.html#topic+enquo">enquo()</a></code>, <code><a href="dplyr.html#topic+enquos">enquos()</a></code>, or <code style="white-space: pre;">&#8288;{{&#8288;</code>, a
parsed quosure never contains injected quosures. It is thus safe
to evaluate them with <code>eval()</code> instead of <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code>, though
the latter is more convenient as you don't need to extract <code>expr</code>
and <code>env</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>parse_expr(x)

parse_exprs(x)

parse_quo(x, env)

parse_quos(x, env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_expr_+3A_x">x</code></td>
<td>
<p>Text containing expressions to parse_expr for
<code>parse_expr()</code> and <code>parse_exprs()</code>. Can also be an R connection,
for instance to a file. If the supplied connection is not open,
it will be automatically closed and destroyed.</p>
</td></tr>
<tr><td><code id="parse_expr_+3A_env">env</code></td>
<td>
<p>The environment for the quosures. The <a href="rlang.html#topic+global_env">global environment</a> (the default) may be the right choice
when you are parsing external user inputs. You might also want to
evaluate the R code in an isolated context (perhaps a child of
the global environment or of the <a href="rlang.html#topic+base_env">base environment</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code><a href="base.html#topic+parse">base::parse()</a></code>, these functions never retain source reference
information, as doing so is slow and rarely necessary.
</p>


<h3>Value</h3>

<p><code>parse_expr()</code> returns an <a href="rlang.html#topic+is_expression">expression</a>,
<code>parse_exprs()</code> returns a list of expressions. Note that for the
plural variants the length of the output may be greater than the
length of the input. This would happen is one of the strings
contain several expressions (such as <code>"foo; bar"</code>). The names of
<code>x</code> are preserved (and recycled in case of multiple expressions).
The <code style="white-space: pre;">&#8288;_quo&#8288;</code> suffixed variants return quosures.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+parse">base::parse()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parse_expr() can parse any R expression:
parse_expr("mtcars %&gt;% dplyr::mutate(cyl_prime = cyl / sd(cyl))")

# A string can contain several expressions separated by ; or \n
parse_exprs("NULL; list()\n foo(bar)")

# Use names to figure out which input produced an expression:
parse_exprs(c(foo = "1; 2", bar = "3"))

# You can also parse source files by passing a R connection. Let's
# create a file containing R code:
path &lt;- tempfile("my-file.R")
cat("1; 2; mtcars", file = path)

# We can now parse it by supplying a connection:
parse_exprs(file(path))
</code></pre>

<hr>
<h2 id='prim_name'>Name of a primitive function</h2><span id='topic+prim_name'></span>

<h3>Description</h3>

<p>Name of a primitive function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prim_name(prim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prim_name_+3A_prim">prim</code></td>
<td>
<p>A primitive function such as <code><a href="base.html#topic+c">base::c()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='qq_show'>Show injected expression</h2><span id='topic+qq_show'></span>

<h3>Description</h3>

<p><code>qq_show()</code> helps examining <a href="rlang.html#topic+topic-inject">injected expressions</a>
inside a function. This is useful for learning about injection and
for debugging injection code.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="qq_show_+3A_expr">expr</code></td>
<td>
<p>An expression involving <a href="rlang.html#topic+topic-inject">injection operators</a>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<p><code>qq_show()</code> shows the intermediary expression before it is
evaluated by R:
</p>
<div class="sourceCode r"><pre>list2(!!!1:3)
#&gt; [[1]]
#&gt; [1] 1
#&gt; 
#&gt; [[2]]
#&gt; [1] 2
#&gt; 
#&gt; [[3]]
#&gt; [1] 3

qq_show(list2(!!!1:3))
#&gt; list2(1L, 2L, 3L)
</pre></div>
<p>It is especially useful inside functions to reveal what an injected
expression looks like:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  qq_show(data %&gt;% dplyr::summarise(mean({{ var }})))
}

mtcars %&gt;% my_mean(cyl)
#&gt; data %&gt;% dplyr::summarise(mean(^cyl))
</pre></div>


<h3>See Also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-inject">Injecting with !!, !!!, and glue syntax</a>
</p>
</li></ul>


<hr>
<h2 id='quo_expr'>Squash a quosure</h2><span id='topic+quo_expr'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function is deprecated, please use <code><a href="rlang.html#topic+quo_squash">quo_squash()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quo_expr(quo, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quo_expr_+3A_quo">quo</code></td>
<td>
<p>A quosure or expression.</p>
</td></tr>
<tr><td><code id="quo_expr_+3A_warn">warn</code></td>
<td>
<p>Whether to warn if the quosure contains other quosures
(those will be collapsed). This is useful when you use
<code>quo_squash()</code> in order to make a non-tidyeval API compatible
with quosures. In that case, getting rid of the nested quosures
is likely to cause subtle bugs and it is good practice to warn
the user about it.</p>
</td></tr>
</table>

<hr>
<h2 id='quo_label'>Format quosures for printing or labelling</h2><span id='topic+quo_label'></span><span id='topic+quo_text'></span><span id='topic+quo_name'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><strong>Note:</strong> You should now use <code><a href="dplyr.html#topic+as_label">as_label()</a></code> or <code><a href="lazyeval.html#topic+as_name">as_name()</a></code> instead
of <code>quo_name()</code>. See life cycle section below.
</p>
<p>These functions take an arbitrary R object, typically an
<a href="rlang.html#topic+is_expression">expression</a>, and represent it as a string.
</p>

<ul>
<li> <p><code>quo_name()</code> returns an abbreviated representation of the object
as a single line string. It is suitable for default names.
</p>
</li>
<li> <p><code>quo_text()</code> returns a multiline string. For instance block
expressions like <code>{ foo; bar }</code> are represented on 4 lines (one
for each symbol, and the curly braces on their own lines).
</p>
</li></ul>

<p>These deparsers are only suitable for creating default names or
printing output at the console. The behaviour of your functions
should not depend on deparsed objects. If you are looking for a way
of transforming symbols to strings, use <code><a href="rlang.html#topic+as_string">as_string()</a></code> instead of
<code>quo_name()</code>. Unlike deparsing, the transformation between symbols
and strings is non-lossy and well defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quo_label(quo)

quo_text(quo, width = 60L, nlines = Inf)

quo_name(quo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quo_label_+3A_quo">quo</code></td>
<td>
<p>A quosure or expression.</p>
</td></tr>
<tr><td><code id="quo_label_+3A_width">width</code></td>
<td>
<p>Width of each line.</p>
</td></tr>
<tr><td><code id="quo_label_+3A_nlines">nlines</code></td>
<td>
<p>Maximum number of lines to extract.</p>
</td></tr>
</table>


<h3>Life cycle</h3>

<p>These functions are superseded.
</p>

<ul>
<li> <p><code><a href="dplyr.html#topic+as_label">as_label()</a></code> and <code><a href="lazyeval.html#topic+as_name">as_name()</a></code> should be used instead of
<code>quo_name()</code>. <code>as_label()</code> transforms any R object to a string
but should only be used to create a default name. Labelisation is
not a well defined operation and no assumption should be made
about the label. On the other hand, <code>as_name()</code> only works with
(possibly quosured) symbols, but is a well defined and
deterministic operation.
</p>
</li>
<li><p> We don't have a good replacement for <code>quo_text()</code> yet. See
<a href="https://github.com/r-lib/rlang/issues/636">https://github.com/r-lib/rlang/issues/636</a> to follow discussions
about a new deparsing API.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="lazyeval.html#topic+expr_label">expr_label()</a></code>, <code><a href="lazyeval.html#topic+f_label">f_label()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Quosures can contain nested quosures:
quo &lt;- quo(foo(!! quo(bar)))
quo

# quo_squash() unwraps all quosures and returns a raw expression:
quo_squash(quo)

# This is used by quo_text() and quo_label():
quo_text(quo)

# Compare to the unwrapped expression:
expr_text(quo)

# quo_name() is helpful when you need really short labels:
quo_name(quo(sym))
quo_name(quo(!! sym))
</code></pre>

<hr>
<h2 id='quo_squash'>Squash a quosure</h2><span id='topic+quo_squash'></span>

<h3>Description</h3>

<p><code>quo_squash()</code> flattens all nested quosures within an expression.
For example it transforms <code style="white-space: pre;">&#8288;^foo(^bar(), ^baz)&#8288;</code> to the bare
expression <code>foo(bar(), baz)</code>.
</p>
<p>This operation is safe if the squashed quosure is used for
labelling or printing (see <code><a href="dplyr.html#topic+as_label">as_label()</a></code>, but note that <code>as_label()</code>
squashes quosures automatically). However if the squashed quosure
is evaluated, all expressions of the flattened quosures are
resolved in a single environment. This is a source of bugs so it is
good practice to set <code>warn</code> to <code>TRUE</code> to let the user know about
the lossy squashing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quo_squash(quo, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quo_squash_+3A_quo">quo</code></td>
<td>
<p>A quosure or expression.</p>
</td></tr>
<tr><td><code id="quo_squash_+3A_warn">warn</code></td>
<td>
<p>Whether to warn if the quosure contains other quosures
(those will be collapsed). This is useful when you use
<code>quo_squash()</code> in order to make a non-tidyeval API compatible
with quosures. In that case, getting rid of the nested quosures
is likely to cause subtle bugs and it is good practice to warn
the user about it.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Quosures can contain nested quosures:
quo &lt;- quo(wrapper(!!quo(wrappee)))
quo

# quo_squash() flattens all the quosures and returns a simple expression:
quo_squash(quo)
</code></pre>

<hr>
<h2 id='quosure-tools'>Quosure getters, setters and predicates</h2><span id='topic+quosure-tools'></span><span id='topic+quosure'></span><span id='topic+quo_is_missing'></span><span id='topic+quo_is_symbol'></span><span id='topic+quo_is_call'></span><span id='topic+quo_is_symbolic'></span><span id='topic+quo_is_null'></span><span id='topic+quo_get_expr'></span><span id='topic+quo_get_env'></span><span id='topic+quo_set_expr'></span><span id='topic+quo_set_env'></span>

<h3>Description</h3>

<p>These tools inspect and modify <a href="rlang.html#topic+topic-quosure">quosures</a>, a type of
<a href="rlang.html#topic+topic-defuse">defused expression</a> that includes a reference to the
context where it was created. A quosure is guaranteed to evaluate
in its original environment and can refer to local objects safely.
</p>

<ul>
<li><p> You can access the quosure components with <code>quo_get_expr()</code> and
<code>quo_get_env()</code>.
</p>
</li>
<li><p> The <code>quo_</code> prefixed predicates test the expression of a quosure,
<code>quo_is_missing()</code>, <code>quo_is_symbol()</code>, etc.
</p>
</li></ul>

<p>All <code>quo_</code> prefixed functions expect a quosure and will fail if
supplied another type of object. Make sure the input is a quosure
with <code><a href="rlang.html#topic+is_quosure">is_quosure()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quo_is_missing(quo)

quo_is_symbol(quo, name = NULL)

quo_is_call(quo, name = NULL, n = NULL, ns = NULL)

quo_is_symbolic(quo)

quo_is_null(quo)

quo_get_expr(quo)

quo_get_env(quo)

quo_set_expr(quo, expr)

quo_set_env(quo, env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quosure-tools_+3A_quo">quo</code></td>
<td>
<p>A quosure to test.</p>
</td></tr>
<tr><td><code id="quosure-tools_+3A_name">name</code></td>
<td>
<p>The name of the symbol or function call. If <code>NULL</code> the
name is not tested.</p>
</td></tr>
<tr><td><code id="quosure-tools_+3A_n">n</code></td>
<td>
<p>An optional number of arguments that the call should
match.</p>
</td></tr>
<tr><td><code id="quosure-tools_+3A_ns">ns</code></td>
<td>
<p>The namespace of the call. If <code>NULL</code>, the namespace
doesn't participate in the pattern-matching. If an empty string
<code>""</code> and <code>x</code> is a namespaced call, <code>is_call()</code> returns
<code>FALSE</code>. If any other string, <code>is_call()</code> checks that <code>x</code> is
namespaced within <code>ns</code>.
</p>
<p>Can be a character vector of namespaces, in which case the call
has to match at least one of them, otherwise <code>is_call()</code> returns
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="quosure-tools_+3A_expr">expr</code></td>
<td>
<p>A new expression for the quosure.</p>
</td></tr>
<tr><td><code id="quosure-tools_+3A_env">env</code></td>
<td>
<p>A new environment for the quosure.</p>
</td></tr>
</table>


<h3>Empty quosures and missing arguments</h3>

<p>When missing arguments are captured as quosures, either through
<code><a href="dplyr.html#topic+enquo">enquo()</a></code> or <code><a href="dplyr.html#topic+quos">quos()</a></code>, they are returned as an empty quosure. These
quosures contain the <a href="lazyeval.html#topic+missing_arg">missing argument</a> and typically
have the <a href="rlang.html#topic+empty_env">empty environment</a> as enclosure.
</p>
<p>Use <code>quo_is_missing()</code> to test for a missing argument defused with
<code><a href="dplyr.html#topic+enquo">enquo()</a></code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="dplyr.html#topic+quo">quo()</a></code> for creating quosures by <a href="rlang.html#topic+topic-defuse">argument defusal</a>.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+new_quosure">new_quosure()</a></code> and <code><a href="rlang.html#topic+as_quosure">as_quosure()</a></code> for assembling quosures from
components.
</p>
</li>
<li> <p><a href="rlang.html#topic+topic-quosure">What are quosures and when are they needed?</a> for an overview.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>quo &lt;- quo(my_quosure)
quo


# Access and set the components of a quosure:
quo_get_expr(quo)
quo_get_env(quo)

quo &lt;- quo_set_expr(quo, quote(baz))
quo &lt;- quo_set_env(quo, empty_env())
quo

# Test wether an object is a quosure:
is_quosure(quo)

# If it is a quosure, you can use the specialised type predicates
# to check what is inside it:
quo_is_symbol(quo)
quo_is_call(quo)
quo_is_null(quo)

# quo_is_missing() checks for a special kind of quosure, the one
# that contains the missing argument:
quo()
quo_is_missing(quo())

fn &lt;- function(arg) enquo(arg)
fn()
quo_is_missing(fn())
</code></pre>

<hr>
<h2 id='raw_deparse_str'>Serialize a raw vector to a string</h2><span id='topic+raw_deparse_str'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This function converts a raw vector to a hexadecimal string,
optionally adding a prefix and a suffix.
It is roughly equivalent to
<code>paste0(prefix, paste(format(x), collapse = ""), suffix)</code>
and much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_deparse_str(x, prefix = NULL, suffix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_deparse_str_+3A_x">x</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
<tr><td><code id="raw_deparse_str_+3A_prefix">prefix</code>, <code id="raw_deparse_str_+3A_suffix">suffix</code></td>
<td>
<p>Prefix and suffix strings, or 'NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raw_deparse_str(raw())
raw_deparse_str(charToRaw("string"))
raw_deparse_str(raw(10), prefix = "'0x", suffix = "'")
</code></pre>

<hr>
<h2 id='rep_along'>Create vectors matching the length of a given vector</h2><span id='topic+rep_along'></span><span id='topic+rep_named'></span>

<h3>Description</h3>

<p>These functions take the idea of <code><a href="base.html#topic+seq_along">seq_along()</a></code> and apply it to
repeating values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep_along(along, x)

rep_named(names, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_along_+3A_along">along</code></td>
<td>
<p>Vector whose length determine how many times <code>x</code>
is repeated.</p>
</td></tr>
<tr><td><code id="rep_along_+3A_x">x</code></td>
<td>
<p>Values to repeat.</p>
</td></tr>
<tr><td><code id="rep_along_+3A_names">names</code></td>
<td>
<p>Names for the new vector. The length of <code>names</code>
determines how many times <code>x</code> is repeated.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>new-vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0:5
rep_along(x, 1:2)
rep_along(x, 1)

# Create fresh vectors by repeating missing values:
rep_along(x, na_int)
rep_along(x, na_chr)

# rep_named() repeats a value along a names vectors
rep_named(c("foo", "bar"), list(letters))
</code></pre>

<hr>
<h2 id='return_from'>Jump to or from a frame</h2><span id='topic+return_from'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a>
</p>
<p>While <code><a href="base.html#topic+function">base::return()</a></code> can only return from the current local
frame, <code>return_from()</code> will return from any frame on the
current evaluation stack, between the global and the currently
active context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_from(frame, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="return_from_+3A_frame">frame</code></td>
<td>
<p>An execution environment of a currently running
function.</p>
</td></tr>
<tr><td><code id="return_from_+3A_value">value</code></td>
<td>
<p>The return value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- function() {
  g(current_env())
  "ignored"
}
g &lt;- function(env) {
  h(env)
  "ignored"
}
h &lt;- function(env) {
  return_from(env, "early return")
  "ignored"
}

fn()
</code></pre>

<hr>
<h2 id='rlang_backtrace_on_error'>Display backtrace on error</h2><span id='topic+rlang_backtrace_on_error'></span><span id='topic+add_backtrace'></span><span id='topic+rlang_backtrace_on_error_report'></span><span id='topic+rlang_backtrace_on_warning_report'></span>

<h3>Description</h3>

<p>rlang errors carry a backtrace that can be inspected by calling
<code><a href="rlang.html#topic+last_error">last_error()</a></code>. You can also control the default display of the
backtrace by setting the option <code>rlang_backtrace_on_error</code> to one
of the following values:
</p>

<ul>
<li> <p><code>"none"</code> show nothing.
</p>
</li>
<li> <p><code>"reminder"</code>, the default in interactive sessions, displays a reminder that
you can see the backtrace with <code><a href="rlang.html#topic+last_error">last_error()</a></code>.
</p>
</li>
<li> <p><code>"branch"</code> displays a simplified backtrace.
</p>
</li>
<li> <p><code>"full"</code>, the default in non-interactive sessions, displays the full tree.
</p>
</li></ul>

<p>rlang errors are normally thrown with <code><a href="rlang.html#topic+abort">abort()</a></code>. If you promote
base errors to rlang errors with <code><a href="rlang.html#topic+global_entrace">global_entrace()</a></code>,
<code>rlang_backtrace_on_error</code> applies to all errors.
</p>


<h3>Promote base errors to rlang errors</h3>

<p>You can use <code>options(error = rlang::entrace)</code> to promote base errors to
rlang errors. This does two things:
</p>

<ul>
<li><p> It saves the base error as an rlang object so you can call <code><a href="rlang.html#topic+last_error">last_error()</a></code>
to print the backtrace or inspect its data.
</p>
</li>
<li><p> It prints the backtrace for the current error according to the
<code>rlang_backtrace_on_error</code> option.
</p>
</li></ul>



<h3>Warnings and errors in RMarkdown</h3>

<p>The display of errors depends on whether they're expected (i.e.
chunk option <code>error = TRUE</code>) or unexpected:
</p>

<ul>
<li><p> Expected errors are controlled by the global option
<code>"rlang_backtrace_on_error_report"</code> (note the <code style="white-space: pre;">&#8288;_report&#8288;</code> suffix).
The default is <code>"none"</code> so that your expected errors don't
include a reminder to run <code>rlang::last_error()</code>. Customise this
option if you want to demonstrate what the error backtrace will
look like.
</p>
<p>You can also use <code><a href="rlang.html#topic+last_error">last_error()</a></code> to display the trace like you
would in your session, but it currently only works in the next
chunk.
</p>
</li>
<li><p> Unexpected errors are controlled by the global option
<code>"rlang_backtrace_on_error"</code>. The default is <code>"branch"</code> so you'll
see a simplified backtrace in the knitr output to help you figure
out what went wrong.
</p>
</li></ul>

<p>When knitr is running (as determined by the <code>knitr.in.progress</code>
global option), the default top environment for backtraces is set
to the chunk environment <code>knitr::knit_global()</code>. This ensures that
the part of the call stack belonging to knitr does not end up in
backtraces. If needed, you can override this by setting the
<code>rlang_trace_top_env</code> global option.
</p>
<p>Similarly to <code>rlang_backtrace_on_error_report</code>, you can set
<code>rlang_backtrace_on_warning_report</code> inside RMarkdown documents to
tweak the display of warnings. This is useful in conjunction with
<code><a href="rlang.html#topic+global_entrace">global_entrace()</a></code>. Because of technical limitations, there is
currently no corresponding <code>rlang_backtrace_on_warning</code> option for
normal R sessions.
</p>
<p>To get full entracing in an Rmd document, include this in a setup
chunk before the first error or warning is signalled.
</p>
<div class="sourceCode"><pre>```{r setup}
rlang::global_entrace()
options(rlang_backtrace_on_warning_report = "full")
options(rlang_backtrace_on_error_report = "full")
```
</pre></div>


<h3>See Also</h3>

<p>rlang_backtrace_on_warning
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Display a simplified backtrace on error for both base and rlang
# errors:

# options(
#   rlang_backtrace_on_error = "branch",
#   error = rlang::entrace
# )
# stop("foo")
</code></pre>

<hr>
<h2 id='rlang_error'>Errors of class <code>rlang_error</code></h2><span id='topic+rlang_error'></span>

<h3>Description</h3>

<p><code><a href="rlang.html#topic+abort">abort()</a></code> and <code><a href="rlang.html#topic+error_cnd">error_cnd()</a></code> create errors of class <code>"rlang_error"</code>.
The differences with base errors are:
</p>

<ul>
<li><p> Implementing <code>conditionMessage()</code> methods for subclasses of
<code>"rlang_error"</code> is undefined behaviour. Instead, implement the
<code><a href="rlang.html#topic+cnd_header">cnd_header()</a></code> method (and possibly <code><a href="rlang.html#topic+cnd_body">cnd_body()</a></code> and
<code><a href="rlang.html#topic+cnd_footer">cnd_footer()</a></code>). These methods return character vectors which are
assembled by rlang when needed: when
<code><a href="base.html#topic+conditionMessage">conditionMessage.rlang_error()</a></code> is called
(e.g. via <code><a href="base.html#topic+try">try()</a></code>), when the error is displayed through <code><a href="base.html#topic+print">print()</a></code>
or <code><a href="base.html#topic+format">format()</a></code>, and of course when the error is displayed to the
user by <code><a href="rlang.html#topic+abort">abort()</a></code>.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+cnd_header">cnd_header()</a></code>, <code><a href="rlang.html#topic+cnd_body">cnd_body()</a></code>, and <code><a href="rlang.html#topic+cnd_footer">cnd_footer()</a></code> methods can be
overridden by storing closures in the <code>header</code>, <code>body</code>, and
<code>footer</code> fields of the condition. This is useful to lazily
generate messages based on state captured in the closure
environment.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> The <code>use_cli_format</code>
condition field instructs whether to use cli (or rlang's fallback
method if cli is not installed) to format the error message at
print time.
</p>
<p>In this case, the <code>message</code> field may be a character vector of
header and bullets. These are formatted at the last moment to
take the context into account (starting position on the screen
and indentation).
</p>
<p>See <code><a href="rlang.html#topic+local_use_cli">local_use_cli()</a></code> for automatically setting this field in
errors thrown with <code><a href="rlang.html#topic+abort">abort()</a></code> within your package.
</p>
</li></ul>


<hr>
<h2 id='rlang-package'>rlang: Functions for Base Types and Core R and 'Tidyverse' Features</h2><span id='topic+rlang'></span><span id='topic+rlang-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A toolbox for working with base types, core R features like the condition system, and core 'Tidyverse' features like tidy evaluation.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lionel Henry <a href="mailto:lionel@posit.co">lionel@posit.co</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> mikefc <a href="mailto:mikefc@coolbutuseless.com">mikefc@coolbutuseless.com</a> (Hash implementation based on Mike's xxhashlite) [copyright holder]
</p>
</li>
<li><p> Yann Collet (Author of the embedded xxHash library) [copyright holder]
</p>
</li>
<li><p> Posit, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://rlang.r-lib.org">https://rlang.r-lib.org</a>
</p>
</li>
<li> <p><a href="https://github.com/r-lib/rlang">https://github.com/r-lib/rlang</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/rlang/issues">https://github.com/r-lib/rlang/issues</a>
</p>
</li></ul>


<hr>
<h2 id='rlib_trace_spec'>Backtrace specification</h2><span id='topic+rlib_trace_spec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Structure</h3>

<p>An r-lib backtrace is a data frame that contains the following
columns:
</p>

<ul>
<li> <p><code>call</code>: List of calls. These may carry <code>srcref</code> objects.
</p>
</li>
<li> <p><code>visible</code>: Logical vector. If <code>FALSE</code>, the corresponding call
will be hidden from simplified backtraces.
</p>
</li>
<li> <p><code>parent</code>: Integer vector of parent references (see
<code><a href="base.html#topic+sys.parents">sys.parents()</a></code>) as row numbers. 0 is global.
</p>
</li>
<li> <p><code>namespace</code>: Character vector of namespaces. <code>NA</code> for global or
no namespace
</p>
</li>
<li> <p><code>scope</code>: Character vector of strings taking values <code>"::"</code>,
<code>":::"</code>, <code>"global"</code>, or <code>"local"</code>.
</p>
</li></ul>

<p>A backtrace data frame may contain extra columns. If you add
additional columns, make sure to prefix their names with the name
of your package or organisation to avoid potential conflicts with
future extensions of this spec, e.g. <code>"mypkg_column"</code>.
</p>


<h3>Operations</h3>


<ul>
<li> <p><strong>Length</strong>. The length of the backtrace is the number of rows of
the underlying data.
</p>
</li>
<li> <p><strong>Concatenation</strong>. Performed by row-binding two backtraces.  The
<code>parent</code> column of the RHS is shifted by <code>nrow(LHS)</code> so that the
last call of the LHS takes place of the global frame of the RHS.
</p>
</li>
<li> <p><strong>Subsetting</strong>. Performed by slicing the backtrace. After the
data frame is sliced, the <code>parent</code> column is adjusted to the new
row indices. Any <code>parent</code> value that no longer exists in the
sliced backtrace is set to 0 (the global frame).
</p>
</li></ul>


<hr>
<h2 id='scalar-type-predicates'>Scalar type predicates</h2><span id='topic+scalar-type-predicates'></span><span id='topic+is_scalar_list'></span><span id='topic+is_scalar_atomic'></span><span id='topic+is_scalar_vector'></span><span id='topic+is_scalar_integer'></span><span id='topic+is_scalar_double'></span><span id='topic+is_scalar_complex'></span><span id='topic+is_scalar_character'></span><span id='topic+is_scalar_logical'></span><span id='topic+is_scalar_raw'></span><span id='topic+is_string'></span><span id='topic+is_scalar_bytes'></span><span id='topic+is_bool'></span>

<h3>Description</h3>

<p>These predicates check for a given type and whether the vector is
&quot;scalar&quot;, that is, of length 1.
</p>
<p>In addition to the length check, <code>is_string()</code> and <code>is_bool()</code>
return <code>FALSE</code> if their input is missing. This is useful for
type-checking arguments, when your function expects a single string
or a single <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_scalar_list(x)

is_scalar_atomic(x)

is_scalar_vector(x)

is_scalar_integer(x)

is_scalar_double(x)

is_scalar_complex(x)

is_scalar_character(x)

is_scalar_logical(x)

is_scalar_raw(x)

is_string(x, string = NULL)

is_scalar_bytes(x)

is_bool(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalar-type-predicates_+3A_x">x</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
<tr><td><code id="scalar-type-predicates_+3A_string">string</code></td>
<td>
<p>A string to compare to <code>x</code>. If a character vector,
returns <code>TRUE</code> if at least one element is equal to <code>x</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="rlang.html#topic+type-predicates">type-predicates</a>, <a href="rlang.html#topic+bare-type-predicates">bare-type-predicates</a>
</p>

<hr>
<h2 id='scoped_env'>Deprecated <code>scoped</code> functions</h2><span id='topic+scoped_env'></span><span id='topic+is_scoped'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions are deprecated as of rlang 0.3.0. Please use
<code><a href="rlang.html#topic+is_attached">is_attached()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoped_env(nm)

is_scoped(nm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoped_env_+3A_nm">nm</code></td>
<td>
<p>The name of an environment attached to the search
path. Call <code><a href="base.html#topic+search">base::search()</a></code> to see what is currently on the path.</p>
</td></tr>
</table>

<hr>
<h2 id='scoped_interactive'>Deprecated <code>scoped_</code> functions</h2><span id='topic+scoped_interactive'></span><span id='topic+scoped_options'></span><span id='topic+scoped_bindings'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Deprecated as of rlang 0.4.2. Use <code><a href="rlang.html#topic+local_interactive">local_interactive()</a></code>,
<code><a href="rlang.html#topic+local_options">local_options()</a></code>, or <code><a href="rlang.html#topic+local_bindings">local_bindings()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoped_interactive(value = TRUE, frame = caller_env())

scoped_options(..., .frame = caller_env())

scoped_bindings(..., .env = .frame, .frame = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoped_interactive_+3A_value">value</code></td>
<td>
<p>A single <code>TRUE</code> or <code>FALSE</code>. This overrides the return
value of <code>is_interactive()</code>.</p>
</td></tr>
<tr><td><code id="scoped_interactive_+3A_frame">frame</code>, <code id="scoped_interactive_+3A_.frame">.frame</code></td>
<td>
<p>The environment of a running function which defines
the scope of the temporary options. When the function returns,
the options are reset to their original values.</p>
</td></tr>
<tr><td><code id="scoped_interactive_+3A_...">...</code></td>
<td>
<p>For <code>local_options()</code> and <code>push_options()</code>, named
values defining new option values. For <code>peek_options()</code>, strings
or character vectors of option names.</p>
</td></tr>
<tr><td><code id="scoped_interactive_+3A_.env">.env</code></td>
<td>
<p>An environment.</p>
</td></tr>
</table>

<hr>
<h2 id='search_envs'>Search path environments</h2><span id='topic+search_envs'></span><span id='topic+search_env'></span><span id='topic+pkg_env'></span><span id='topic+pkg_env_name'></span><span id='topic+is_attached'></span><span id='topic+base_env'></span><span id='topic+global_env'></span>

<h3>Description</h3>

<p>The search path is a chain of environments containing exported
functions of attached packages.
</p>
<p>The API includes:
</p>

<ul>
<li> <p><code><a href="base.html#topic+search">base::search()</a></code> to get the names of environments attached to the
search path.
</p>
</li>
<li> <p><code>search_envs()</code> returns the environments on the search path as a
list.
</p>
</li>
<li> <p><code>pkg_env_name()</code> takes a bare package name and prefixes it with
<code>"package:"</code>. Attached package environments have search names of
the form <code>package:name</code>.
</p>
</li>
<li> <p><code>pkg_env()</code> takes a bare package name and returns the scoped
environment of packages if they are attached to the search path,
and throws an error otherwise. It is a shortcut for
<code>search_env(pkg_env_name("pkgname"))</code>.
</p>
</li>
<li> <p><code>global_env()</code> and <code>base_env()</code> (simple aliases for <code><a href="base.html#topic+globalenv">globalenv()</a></code>
and <code><a href="base.html#topic+baseenv">baseenv()</a></code>). These are respectively the first and last
environments of the search path.
</p>
</li>
<li> <p><code>is_attached()</code> returns <code>TRUE</code> when its argument (a search name
or a package environment) is attached to the search path.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>search_envs()

search_env(name)

pkg_env(pkg)

pkg_env_name(pkg)

is_attached(x)

base_env()

global_env()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_envs_+3A_name">name</code></td>
<td>
<p>The name of an environment attached to the search
path. Call <code><a href="base.html#topic+search">base::search()</a></code> to get the names of environments
currently attached to the search path. Note that the search name
of a package environment is prefixed with <code>"package:"</code>.</p>
</td></tr>
<tr><td><code id="search_envs_+3A_pkg">pkg</code></td>
<td>
<p>The name of a package.</p>
</td></tr>
<tr><td><code id="search_envs_+3A_x">x</code></td>
<td>
<p>An environment or a search name.</p>
</td></tr>
</table>


<h3>The search path</h3>

<p>This chain of environments determines what objects are visible from
the global workspace. It contains the following elements:
</p>

<ul>
<li><p> The chain always starts with <code>global_env()</code> and finishes with
<code>base_env()</code> which inherits from the terminal environment
<code>empty_env()</code>.
</p>
</li>
<li><p> Each <code><a href="base.html#topic+library">base::library()</a></code> call attaches a new package environment to
the search path. Attached packages are associated with a <a href="rlang.html#topic+env_name">search name</a>.
</p>
</li>
<li><p> In addition, any list, data frame, or environment can be attached
to the search path with <code><a href="base.html#topic+attach">base::attach()</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># List the search names of environments attached to the search path:
search()

# Get the corresponding environments:
search_envs()

# The global environment and the base package are always first and
# last in the chain, respectively:
envs &lt;- search_envs()
envs[[1]]
envs[[length(envs)]]

# These two environments have their own shortcuts:
global_env()
base_env()

# Packages appear in the search path with a special name. Use
# pkg_env_name() to create that name:
pkg_env_name("rlang")
search_env(pkg_env_name("rlang"))

# Alternatively, get the scoped environment of a package with
# pkg_env():
pkg_env("utils")
</code></pre>

<hr>
<h2 id='seq2'>Increasing sequence of integers in an interval</h2><span id='topic+seq2'></span><span id='topic+seq2_along'></span>

<h3>Description</h3>

<p>These helpers take two endpoints and return the sequence of all
integers within that interval. For <code>seq2_along()</code>, the upper
endpoint is taken from the length of a vector. Unlike
<code>base::seq()</code>, they return an empty vector if the starting point is
a larger integer than the end point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq2(from, to)

seq2_along(from, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq2_+3A_from">from</code></td>
<td>
<p>The starting point of the sequence.</p>
</td></tr>
<tr><td><code id="seq2_+3A_to">to</code></td>
<td>
<p>The end point.</p>
</td></tr>
<tr><td><code id="seq2_+3A_x">x</code></td>
<td>
<p>A vector whose length is the end point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector containing a strictly increasing
sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq2(2, 10)
seq2(10, 2)
seq(10, 2)

seq2_along(10, letters)
</code></pre>

<hr>
<h2 id='set_attrs'>Add attributes to an object</h2><span id='topic+set_attrs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_attrs(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_attrs_+3A_.x">.x</code>, <code id="set_attrs_+3A_...">...</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>

<hr>
<h2 id='set_expr'>Set and get an expression</h2><span id='topic+set_expr'></span><span id='topic+get_expr'></span>

<h3>Description</h3>

<p>These helpers are useful to make your function work generically
with quosures and raw expressions. First call <code>get_expr()</code> to
extract an expression. Once you're done processing the expression,
call <code>set_expr()</code> on the original object to update the expression.
You can return the result of <code>set_expr()</code>, either a formula or an
expression depending on the input type. Note that <code>set_expr()</code> does
not change its input, it creates a new object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_expr(x, value)

get_expr(x, default = x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_expr_+3A_x">x</code></td>
<td>
<p>An expression, closure, or one-sided formula. In addition,
<code>set_expr()</code> accept frames.</p>
</td></tr>
<tr><td><code id="set_expr_+3A_value">value</code></td>
<td>
<p>An updated expression.</p>
</td></tr>
<tr><td><code id="set_expr_+3A_default">default</code></td>
<td>
<p>A default expression to return when <code>x</code> is not an
expression wrapper. Defaults to <code>x</code> itself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated original input for <code>set_expr()</code>. A raw
expression for <code>get_expr()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+quo_get_expr">quo_get_expr()</a></code> and <code><a href="rlang.html#topic+quo_set_expr">quo_set_expr()</a></code> for versions of
<code><a href="rlang.html#topic+get_expr">get_expr()</a></code> and <code><a href="rlang.html#topic+set_expr">set_expr()</a></code> that only work on quosures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- ~foo(bar)
e &lt;- quote(foo(bar))
frame &lt;- identity(identity(ctxt_frame()))

get_expr(f)
get_expr(e)
get_expr(frame)

set_expr(f, quote(baz))
set_expr(e, quote(baz))
</code></pre>

<hr>
<h2 id='set_names'>Set names of a vector</h2><span id='topic+set_names'></span>

<h3>Description</h3>

<p>This is equivalent to <code><a href="stats.html#topic+setNames">stats::setNames()</a></code>, with more features and
stricter argument checking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_names(x, nm = x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_names_+3A_x">x</code></td>
<td>
<p>Vector to name.</p>
</td></tr>
<tr><td><code id="set_names_+3A_nm">nm</code>, <code id="set_names_+3A_...">...</code></td>
<td>
<p>Vector of names, the same length as <code>x</code>. If length 1,
<code>nm</code> is recycled to the length of <code>x</code> following the recycling
rules of the tidyverse..
</p>
<p>You can specify names in the following ways:
</p>

<ul>
<li><p> If not supplied, <code>x</code> will be named to <code>as.character(x)</code>.
</p>
</li>
<li><p> If <code>x</code> already has names, you can provide a function or formula
to transform the existing names. In that case, <code>...</code> is passed
to the function.
</p>
</li>
<li><p> Otherwise if <code>...</code> is supplied, <code>x</code> is named to <code>c(nm, ...)</code>.
</p>
</li>
<li><p> If <code>nm</code> is <code>NULL</code>, the names are removed (if present).
</p>
</li></ul>
</td></tr>
</table>


<h3>Life cycle</h3>

<p><code>set_names()</code> is stable and exported in purrr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_names(1:4, c("a", "b", "c", "d"))
set_names(1:4, letters[1:4])
set_names(1:4, "a", "b", "c", "d")

# If the second argument is ommitted a vector is named with itself
set_names(letters[1:5])

# Alternatively you can supply a function
set_names(1:10, ~ letters[seq_along(.)])
set_names(head(mtcars), toupper)

# If the input vector is unnamed, it is first named after itself
# before the function is applied:
set_names(letters, toupper)

# `...` is passed to the function:
set_names(head(mtcars), paste0, "_foo")

# If length 1, the second argument is recycled to the length of the first:
set_names(1:3, "foo")
set_names(list(), "")
</code></pre>

<hr>
<h2 id='splice'>Splice values at dots collection time</h2><span id='topic+splice'></span><span id='topic+is_spliced'></span><span id='topic+is_spliced_bare'></span>

<h3>Description</h3>

<p>The splicing operator <code style="white-space: pre;">&#8288;!!!&#8288;</code> operates both in values contexts like
<code><a href="rlang.html#topic+list2">list2()</a></code> and <code><a href="rlang.html#topic+dots_list">dots_list()</a></code>, and in metaprogramming contexts like
<code><a href="dplyr.html#topic+expr">expr()</a></code>, <code><a href="dplyr.html#topic+enquos">enquos()</a></code>, or <code><a href="rlang.html#topic+inject">inject()</a></code>. While the end result looks the
same, the implementation is different and much more efficient in
the value cases. This difference in implementation may cause
performance issues for instance when going from:
</p>
<div class="sourceCode r"><pre>xs &lt;- list(2, 3)
list2(1, !!!xs, 4)
</pre></div>
<p>to:
</p>
<div class="sourceCode r"><pre>inject(list2(1, !!!xs, 4))
</pre></div>
<p>In the former case, the performant value-splicing is used. In the
latter case, the slow metaprogramming splicing is used.
</p>
<p>A common practical case where this may occur is when code is
wrapped inside a tidyeval context like <code>dplyr::mutate()</code>. In this
case, the metaprogramming operator <code style="white-space: pre;">&#8288;!!!&#8288;</code> will take over the
value-splicing operator, causing an unexpected slowdown.
</p>
<p>To avoid this in performance-critical code, use <code>splice()</code> instead
of <code style="white-space: pre;">&#8288;!!!&#8288;</code>:
</p>
<div class="sourceCode r"><pre># These both use the fast splicing:
list2(1, splice(xs), 4)
inject(list2(1, splice(xs), 4))
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>splice(x)

is_spliced(x)

is_spliced_bare(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splice_+3A_x">x</code></td>
<td>
<p>A list or vector to splice non-eagerly.</p>
</td></tr>
</table>

<hr>
<h2 id='splice-operator'>Splice operator <code style="white-space: pre;">&#8288;!!!&#8288;</code></h2><span id='topic+splice-operator'></span><span id='topic++21+21+21'></span>

<h3>Description</h3>

<p>The splice operator <code style="white-space: pre;">&#8288;!!!&#8288;</code> implemented in <a href="rlang.html#topic+dyn-dots">dynamic dots</a>
injects a list of arguments into a function call. It belongs to the
family of <a href="rlang.html#topic+topic-inject">injection</a> operators and provides the same
functionality as <code><a href="base.html#topic+do.call">do.call()</a></code>.
</p>
<p>The two main cases for splice injection are:
</p>

<ul>
<li><p> Turning a list of inputs into distinct arguments. This is
especially useful with functions that take data in <code>...</code>, such as
<code><a href="base.html#topic+cbind">base::rbind()</a></code>.
</p>
<div class="sourceCode r"><pre>dfs &lt;- list(mtcars, mtcars)
inject(rbind(!!!dfs))
</pre></div>
</li>
<li><p> Injecting <a href="rlang.html#topic+topic-defuse">defused expressions</a> like
<a href="dplyr.html#topic+sym">symbolised</a> column names.
</p>
<p>For tidyverse APIs, this second case is no longer as useful
since dplyr 1.0 and the <code>across()</code> operator.
</p>
</li></ul>



<h3>Where does <code style="white-space: pre;">&#8288;!!!&#8288;</code> work?</h3>

<p><code style="white-space: pre;">&#8288;!!!&#8288;</code> does not work everywhere, you can only use it within certain
special functions:
</p>

<ul>
<li><p> Functions taking <a href="rlang.html#topic+dyn-dots">dynamic dots</a> like <code><a href="rlang.html#topic+list2">list2()</a></code>.
</p>
</li>
<li><p> Functions taking <a href="rlang.html#topic+topic-defuse">defused</a> and
<a href="rlang.html#topic+topic-data-mask">data-masked</a> arguments, which are dynamic by
default.
</p>
</li>
<li><p> Inside <code><a href="rlang.html#topic+inject">inject()</a></code>.
</p>
</li></ul>

<p>Most tidyverse functions support <code style="white-space: pre;">&#8288;!!!&#8288;</code> out of the box. With base
functions you need to use <code><a href="rlang.html#topic+inject">inject()</a></code> to enable <code style="white-space: pre;">&#8288;!!!&#8288;</code>.
</p>
<p>Using the operator out of context may lead to incorrect results,
see <a href="rlang.html#topic+topic-inject-out-of-context">What happens if I use injection operators out of context?</a>.
</p>


<h3>Splicing a list of arguments</h3>

<p>Take a function like <code><a href="base.html#topic+cbind">base::rbind()</a></code> that takes data in <code>...</code>. This
sort of functions takes a variable number of arguments.
</p>
<div class="sourceCode r"><pre>df1 &lt;- data.frame(x = 1)
df2 &lt;- data.frame(x = 2)

rbind(df1, df2)
#&gt;   x
#&gt; 1 1
#&gt; 2 2
</pre></div>
<p>Passing individual arguments is only possible for a fixed amount of
arguments. When the arguments are in a list whose length is
variable (and potentially very large), we need a programmatic
approach like the splicing syntax <code style="white-space: pre;">&#8288;!!!&#8288;</code>:
</p>
<div class="sourceCode r"><pre>dfs &lt;- list(df1, df2)

inject(rbind(!!!dfs))
#&gt;   x
#&gt; 1 1
#&gt; 2 2
</pre></div>
<p>Because <code>rbind()</code> is a base function we used <code><a href="rlang.html#topic+inject">inject()</a></code> to
explicitly enable <code style="white-space: pre;">&#8288;!!!&#8288;</code>. However, many functions implement <a href="rlang.html#topic+list2">dynamic dots</a> with <code style="white-space: pre;">&#8288;!!!&#8288;</code> implicitly enabled out of the box.
</p>
<div class="sourceCode r"><pre>tidyr::expand_grid(x = 1:2, y = c("a", "b"))
#&gt; # A tibble: 4 x 2
#&gt;       x y    
#&gt;   &lt;int&gt; &lt;chr&gt;
#&gt; 1     1 a    
#&gt; 2     1 b    
#&gt; 3     2 a    
#&gt; 4     2 b

xs &lt;- list(x = 1:2, y = c("a", "b"))
tidyr::expand_grid(!!!xs)
#&gt; # A tibble: 4 x 2
#&gt;       x y    
#&gt;   &lt;int&gt; &lt;chr&gt;
#&gt; 1     1 a    
#&gt; 2     1 b    
#&gt; 3     2 a    
#&gt; 4     2 b
</pre></div>
<p>Note how the expanded grid has the right column names. That's
because we spliced a <em>named</em> list. Splicing causes each name of the
list to become an argument name.
</p>
<div class="sourceCode r"><pre>tidyr::expand_grid(!!!set_names(xs, toupper))
#&gt; # A tibble: 4 x 2
#&gt;       X Y    
#&gt;   &lt;int&gt; &lt;chr&gt;
#&gt; 1     1 a    
#&gt; 2     1 b    
#&gt; 3     2 a    
#&gt; 4     2 b
</pre></div>


<h3>Splicing a list of expressions</h3>

<p>Another usage for <code style="white-space: pre;">&#8288;!!!&#8288;</code> is to inject <a href="rlang.html#topic+topic-defuse">defused expressions</a> into <a href="rlang.html#topic+topic-data-mask">data-masked</a>
dots. However this usage is no longer a common pattern for
programming with tidyverse functions and we recommend using other
patterns if possible.
</p>
<p>First, instead of using the <a href="rlang.html#topic+topic-data-mask-programming">defuse-and-inject pattern</a> with <code>...</code>, you can simply pass
them on as you normally would. These two expressions are completely
equivalent:
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(.data, ...) {
  .data %&gt;% dplyr::group_by(!!!enquos(...))
}

# This equivalent syntax is preferred
my_group_by &lt;- function(.data, ...) {
  .data %&gt;% dplyr::group_by(...)
}
</pre></div>
<p>Second, more complex applications such as <a href="rlang.html#topic+topic-metaprogramming">transformation patterns</a> can be solved with the <code>across()</code>
operation introduced in dplyr 1.0. Say you want to take the
<code>mean()</code> of all expressions in <code>...</code>. Before <code>across()</code>, you had to
defuse the <code>...</code> expressions, wrap them in a call to <code>mean()</code>, and
inject them in <code>summarise()</code>.
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(.data, ...) {
  # Defuse dots and auto-name them
  exprs &lt;- enquos(..., .named = TRUE)

  # Wrap the expressions in a call to `mean()`
  exprs &lt;- purrr::map(exprs, ~ call("mean", .x, na.rm = TRUE))

  # Inject them
  .data %&gt;% dplyr::summarise(!!!exprs)
}
</pre></div>
<p>It is much easier to use <code>across()</code> instead:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(.data, ...) {
  .data %&gt;% dplyr::summarise(across(c(...), ~ mean(.x, na.rm = TRUE)))
}
</pre></div>


<h3>Performance of injected dots and dynamic dots</h3>

<p>Take this <a href="rlang.html#topic+dyn-dots">dynamic dots</a> function:
</p>
<div class="sourceCode r"><pre>n_args &lt;- function(...) {
  length(list2(...))
}
</pre></div>
<p>Because it takes dynamic dots you can splice with <code style="white-space: pre;">&#8288;!!!&#8288;</code> out of the
box.
</p>
<div class="sourceCode r"><pre>n_args(1, 2)
#&gt; [1] 2

n_args(!!!mtcars)
#&gt; [1] 11
</pre></div>
<p>Equivalently you could enable <code style="white-space: pre;">&#8288;!!!&#8288;</code> explicitly with <code><a href="rlang.html#topic+inject">inject()</a></code>.
</p>
<div class="sourceCode r"><pre>inject(n_args(!!!mtcars))
#&gt; [1] 11
</pre></div>
<p>While the result is the same, what is going on under the hood is
completely different. <code><a href="rlang.html#topic+list2">list2()</a></code> is a dots collector that
special-cases <code style="white-space: pre;">&#8288;!!!&#8288;</code> arguments. On the other hand, <code><a href="rlang.html#topic+inject">inject()</a></code>
operates on the language and creates a function call containing as
many arguments as there are elements in the spliced list. If you
supply a list of size 1e6, <code>inject()</code> is creating one million
arguments before evaluation. This can be much slower.
</p>
<div class="sourceCode r"><pre>xs &lt;- rep(list(1), 1e6)

system.time(
  n_args(!!!xs)
)
#&gt;    user  system elapsed
#&gt;   0.009   0.000   0.009

system.time(
  inject(n_args(!!!xs))
)
#&gt;    user  system elapsed
#&gt;   0.445   0.012   0.457
</pre></div>
<p>The same issue occurs when functions taking dynamic dots are called
inside a data-masking function like <code>dplyr::mutate()</code>. The
mechanism that enables <code style="white-space: pre;">&#8288;!!!&#8288;</code> injection in these arguments is the
same as in <code>inject()</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-inject">Injecting with !!, !!!, and glue syntax</a>
</p>
</li>
<li> <p><code><a href="rlang.html#topic+inject">inject()</a></code>
</p>
</li>
<li> <p><code><a href="purrr.html#topic+exec">exec()</a></code>
</p>
</li></ul>


<hr>
<h2 id='stack'>Get properties of the current or caller frame</h2><span id='topic+stack'></span><span id='topic+current_call'></span><span id='topic+current_fn'></span><span id='topic+current_env'></span><span id='topic+caller_call'></span><span id='topic+caller_fn'></span><span id='topic+caller_env'></span><span id='topic+frame_call'></span><span id='topic+frame_fn'></span>

<h3>Description</h3>

<p>These accessors retrieve properties of frames on the call stack.
The prefix indicates for which frame a property should be accessed:
</p>

<ul>
<li><p> From the current frame with <code>current_</code> accessors.
</p>
</li>
<li><p> From a calling frame with <code>caller_</code> accessors.
</p>
</li>
<li><p> From a matching frame with <code>frame_</code> accessors.
</p>
</li></ul>

<p>The suffix indicates which property to retrieve:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;_fn&#8288;</code> accessors return the function running in the frame.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_call&#8288;</code> accessors return the defused call with which the function
running in the frame was invoked.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_env&#8288;</code> accessors return the execution environment of the function
running in the frame.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>current_call()

current_fn()

current_env()

caller_call(n = 1)

caller_fn(n = 1)

caller_env(n = 1)

frame_call(frame = caller_env())

frame_fn(frame = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_+3A_n">n</code></td>
<td>
<p>The number of callers to go back.</p>
</td></tr>
<tr><td><code id="stack_+3A_frame">frame</code></td>
<td>
<p>A frame environment of a currently running function,
as returned by <code><a href="rlang.html#topic+caller_env">caller_env()</a></code>. <code>NULL</code> is returned if the
environment does not exist on the stack.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+caller_env">caller_env()</a></code> and <code><a href="rlang.html#topic+current_env">current_env()</a></code>
</p>

<hr>
<h2 id='stack-deprecated'>Call stack information</h2><span id='topic+stack-deprecated'></span><span id='topic+ctxt_frame'></span><span id='topic+global_frame'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Deprecated as of rlang 0.3.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctxt_frame(n = 1)

global_frame()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack-deprecated_+3A_n">n</code></td>
<td>
<p>The number of frames to go back in the stack.</p>
</td></tr>
</table>

<hr>
<h2 id='string'>Create a string</h2><span id='topic+string'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>These base-type constructors allow more control over the creation
of strings in R. They take character vectors or string-like objects
(integerish or raw vectors), and optionally set the encoding. The
string version checks that the input contains a scalar string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string(x, encoding = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_+3A_x">x</code></td>
<td>
<p>A character vector or a vector or list of string-like
objects.</p>
</td></tr>
<tr><td><code id="string_+3A_encoding">encoding</code></td>
<td>
<p>If non-null, set an encoding mark. This is only
declarative, no encoding conversion is performed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># As everywhere in R, you can specify a string with Unicode
# escapes. The characters corresponding to Unicode codepoints will
# be encoded in UTF-8, and the string will be marked as UTF-8
# automatically:
cafe &lt;- string("caf\uE9")
Encoding(cafe)
charToRaw(cafe)

# In addition, string() provides useful conversions to let
# programmers control how the string is represented in memory. For
# encodings other than UTF-8, you'll need to supply the bytes in
# hexadecimal form. If it is a latin1 encoding, you can mark the
# string explicitly:
cafe_latin1 &lt;- string(c(0x63, 0x61, 0x66, 0xE9), "latin1")
Encoding(cafe_latin1)
charToRaw(cafe_latin1)
</code></pre>

<hr>
<h2 id='switch_type'>Dispatch on base types</h2><span id='topic+switch_type'></span><span id='topic+coerce_type'></span><span id='topic+switch_class'></span><span id='topic+coerce_class'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>switch_type()</code> is equivalent to
<code><a href="base.html#topic+switch">switch</a>(<a href="rlang.html#topic+type_of">type_of</a>(x, ...))</code>, while
<code>switch_class()</code> switchpatches based on <code>class(x)</code>. The <code>coerce_</code>
versions are intended for type conversion and provide a standard
error message when conversion fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_type(.x, ...)

coerce_type(.x, .to, ...)

switch_class(.x, ...)

coerce_class(.x, .to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switch_type_+3A_.x">.x</code></td>
<td>
<p>An object from which to dispatch.</p>
</td></tr>
<tr><td><code id="switch_type_+3A_...">...</code></td>
<td>
<p>Named clauses. The names should be types as returned by
<code><a href="rlang.html#topic+type_of">type_of()</a></code>.</p>
</td></tr>
<tr><td><code id="switch_type_+3A_.to">.to</code></td>
<td>
<p>This is useful when you switchpatch within a coercing
function. If supplied, this should be a string indicating the
target type. A catch-all clause is then added to signal an error
stating the conversion failure. This type is prettified unless
<code>.to</code> inherits from the S3 class <code>"AsIs"</code> (see <code><a href="base.html#topic+AsIs">base::I()</a></code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>switch_type(3L,
  double = "foo",
  integer = "bar",
  "default"
)

# Use the coerce_ version to get standardised error handling when no
# type matches:
to_chr &lt;- function(x) {
  coerce_type(x, "a chr",
    integer = as.character(x),
    double = as.character(x)
  )
}
to_chr(3L)

# Strings have their own type:
switch_type("str",
  character = "foo",
  string = "bar",
  "default"
)

# Use a fallthrough clause if you need to dispatch on all character
# vectors, including strings:
switch_type("str",
  string = ,
  character = "foo",
  "default"
)

# special and builtin functions are treated as primitive, since
# there is usually no reason to treat them differently:
switch_type(base::list,
  primitive = "foo",
  "default"
)
switch_type(base::`$`,
  primitive = "foo",
  "default"
)

# closures are not primitives:
switch_type(rlang::switch_type,
  primitive = "foo",
  "default"
)
</code></pre>

<hr>
<h2 id='sym'>Create a symbol or list of symbols</h2><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+data_sym'></span><span id='topic+data_syms'></span>

<h3>Description</h3>

<p>Symbols are a kind of <a href="rlang.html#topic+topic-defuse">defused expression</a> that
represent objects in environments.
</p>

<ul>
<li> <p><code>sym()</code> and <code>syms()</code> take strings as input and turn them into
symbols.
</p>
</li>
<li> <p><code>data_sym()</code> and <code>data_syms()</code> create calls of the form
<code>.data$foo</code> instead of symbols. Subsetting the <code><a href="dplyr.html#topic+.data">.data</a></code> pronoun
is more robust when you expect a data-variable. See
<a href="rlang.html#topic+topic-data-mask-ambiguity">The data mask ambiguity</a>.
</p>
</li></ul>

<p>Only tidy eval APIs support the <code><a href="dplyr.html#topic+.data">.data</a></code> pronoun. With base R
functions, use simple symbols created with <code>sym()</code> or <code>syms()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sym(x)

syms(x)

data_sym(x)

data_syms(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sym_+3A_x">x</code></td>
<td>
<p>For <code>sym()</code> and <code>data_sym()</code>, a string. For <code>syms()</code> and
<code>data_syms()</code>, a list of strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>sym()</code> and <code>syms()</code>, a symbol or list of symbols. For
<code>data_sym()</code> and <code>data_syms()</code>, calls of the form <code>.data$foo</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-defuse">Defusing R expressions</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+topic-metaprogramming">Metaprogramming patterns</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create a symbol
sym("cyl")

# Create a list of symbols
syms(c("cyl", "am"))

# Symbolised names refer to variables
eval(sym("cyl"), mtcars)

# Beware of scoping issues
Cyl &lt;- "wrong"
eval(sym("Cyl"), mtcars)

# Data symbols are explicitly scoped in the data mask
try(eval_tidy(data_sym("Cyl"), mtcars))

# These can only be used with tidy eval functions
try(eval(data_sym("Cyl"), mtcars))

# The empty string returns the missing argument:
sym("")

# This way sym() and as_string() are inverse of each other:
as_string(missing_arg())
sym(as_string(missing_arg()))

</code></pre>

<hr>
<h2 id='topic-condition-customisation'>Customising condition messages</h2><span id='topic+topic-condition-customisation'></span>

<h3>Description</h3>

<p>Various aspects of the condition messages displayed by <code><a href="rlang.html#topic+abort">abort()</a></code>, <code><a href="rlang.html#topic+warn">warn()</a></code>, and <code><a href="rlang.html#topic+inform">inform()</a></code> can be customised using options from the <a href="https://cli.r-lib.org">cli</a> package.
</p>


<h3>Turning off unicode bullets</h3>

<p>By default, bulleted lists are prefixed with unicode symbols:
</p>
<div class="sourceCode r"><pre>rlang::abort(c(
  "The error message.",
  "*" = "Regular bullet.",
  "i" = "Informative bullet.",
  "x" = "Cross bullet.",
  "v" = "Victory bullet.",
  "&gt;" = "Arrow bullet."
))
#&gt; Error:
#&gt; ! The error message.
#&gt; • Regular bullet.
#&gt; ℹ Informative bullet.
#&gt; ✖ Cross bullet.
#&gt; ✔ Victory bullet.
#&gt; → Arrow bullet.
</pre></div>
<p>Set this option to use simple letters instead:
</p>
<div class="sourceCode r"><pre>options(cli.condition_unicode_bullets = FALSE)

rlang::abort(c(
  "The error message.",
  "*" = "Regular bullet.",
  "i" = "Informative bullet.",
  "x" = "Cross bullet.",
  "v" = "Victory bullet.",
  "&gt;" = "Arrow bullet."
))
#&gt; Error:
#&gt; ! The error message.
#&gt; * Regular bullet.
#&gt; i Informative bullet.
#&gt; x Cross bullet.
#&gt; v Victory bullet.
#&gt; &gt; Arrow bullet.
</pre></div>


<h3>Changing the bullet symbols</h3>

<p>You can specify what symbol to use for each type of bullet through your cli user theme. For instance, here is how to uniformly use <code>*</code> for all bullet kinds:
</p>
<div class="sourceCode r"><pre>options(cli.user_theme = list(
  ".cli_rlang .bullet-*" = list(before = "* "),
  ".cli_rlang .bullet-i" = list(before = "* "),
  ".cli_rlang .bullet-x" = list(before = "* "),
  ".cli_rlang .bullet-v" = list(before = "* "),
  ".cli_rlang .bullet-&gt;" = list(before = "* ")
))

rlang::abort(c(
  "The error message.",
  "*" = "Regular bullet.",
  "i" = "Informative bullet.",
  "x" = "Cross bullet.",
  "v" = "Victory bullet.",
  "&gt;" = "Arrow bullet."
))
#&gt; Error:
#&gt; ! The error message.
#&gt; * Regular bullet.
#&gt; * Informative bullet.
#&gt; * Cross bullet.
#&gt; * Victory bullet.
#&gt; * Arrow bullet.
</pre></div>
<p>If you want all the bullets to be the same, including the leading bullet, you can achieve this using the <code>bullet</code> class:
</p>
<div class="sourceCode r"><pre>options(cli.user_theme = list(
  ".cli_rlang .bullet" = list(before = "* ")
))

rlang::abort(c(
  "The error message.",
  "*" = "Regular bullet.",
  "i" = "Informative bullet.",
  "x" = "Cross bullet.",
  "v" = "Victory bullet.",
  "&gt;" = "Arrow bullet."
))
#&gt; Error:
#&gt; * The error message.
#&gt; * Regular bullet.
#&gt; * Informative bullet.
#&gt; * Cross bullet.
#&gt; * Victory bullet.
#&gt; * Arrow bullet.
</pre></div>


<h3>Changing the foreground and background colour of error calls</h3>

<p>When called inside a function, <code>abort()</code> displays the function call to help contextualise the error:
</p>
<div class="sourceCode r"><pre>splash &lt;- function() {
  abort("Can't splash without water.")
}

splash()
#&gt; Error in `splash()`:
#&gt; ! Can't splash without water.
</pre></div>
<p>The call is formatted with cli as a <code>code</code> element. This is not visible in the manual, but code text is formatted with a highlighted background colour by default. When this can be reliably detected, that background colour is different depending on whether you're using a light or dark theme.
</p>
<p>You can override the colour of code elements in your cli theme. Here is my personal configuration that fits well with the colour theme I currently use in my IDE:
</p>
<div class="sourceCode r"><pre>options(cli.user_theme = list(
  span.code = list(
    "background-color" = "#3B4252",
    color = "#E5E9F0"
  )
))
</pre></div>

<hr>
<h2 id='topic-condition-formatting'>Formatting messages with cli</h2><span id='topic+topic-condition-formatting'></span>

<h3>Description</h3>

<p>Condition formatting is a set of operations applied to raw inputs for error messages that includes:
</p>

<ul>
<li><p> Transforming a character vector of lines to a width-wrapped list of error bullets. This makes it easy to write messages in a list format where each bullet conveys a single important point.
</p>
<div class="sourceCode r"><pre>abort(c(
  "The error header",
  "*" = "An error bullet",
  "i" = "An info bullet",
  "x" = "A cross bullet"
))
#&gt; Error:
#&gt; ! The error header
#&gt; * An error bullet
#&gt; i An info bullet
#&gt; x A cross bullet
</pre></div>
<p>See the <a href="https://style.tidyverse.org/error-messages.html">tidyverse error style guide</a> for more about this style of error messaging.
</p>
</li>
<li><p> Applying style (emphasis, boldness, ...) and colours to message elements.
</p>
</li></ul>

<p>While the rlang package embeds rudimentary formatting routines, the main formatting engine is implemented in the <a href="https://cli.r-lib.org/">cli package</a>.
</p>


<h4>Formatting messages with cli</h4>

<p>By default, rlang uses an internal mechanism to format bullets. It is preferable to delegate formatting to the <a href="https://cli.r-lib.org/">cli package</a> by using <code><a href="cli.html#topic+cli_abort">cli::cli_abort()</a></code>, <code><a href="cli.html#topic+cli_abort">cli::cli_warn()</a></code>, and <code><a href="cli.html#topic+cli_abort">cli::cli_inform()</a></code> instead of the rlang versions. These wrappers enable cli formatting with sophisticated paragraph wrapping and bullet indenting that make long lines easier to read. In the following example, a long <code>!</code> bullet is broken with an indented newline:
</p>
<div class="sourceCode r"><pre>rlang::global_entrace(class = "errorr")
#&gt; Error in `rlang::global_entrace()`:
#&gt; ! `class` must be one of "error", "warning", or "message",
#&gt;   not "errorr".
#&gt; i Did you mean "error"?
</pre></div>
<p>The cli wrappers also add many features such as interpolation, semantic formatting of text elements, and pluralisation:
</p>
<div class="sourceCode r"><pre>inform_marbles &lt;- function(n_marbles) {
  cli::cli_inform(c(
    "i" = "I have {n_marbles} shiny marble{?s} in my bag.",
    "v" = "Way to go {.code cli::cli_inform()}!"
  ))
}

inform_marbles(1)
#&gt; i I have 1 shiny marble in my bag.
#&gt; v Way to go `cli::cli_inform()`!

inform_marbles(2)
#&gt; i I have 2 shiny marbles in my bag.
#&gt; v Way to go `cli::cli_inform()`!
</pre></div>



<h4>Transitioning from <code>abort()</code> to <code>cli_abort()</code></h4>

<p>If you plan to mass-rename calls from <code>abort()</code> to <code>cli::cli_abort()</code>, be careful if you assemble error messages from user inputs. If these individual pieces contain cli or glue syntax, this will result in hard-to-debug errors and possibly <a href="https://xkcd.com/327/">unexpected behaviour</a>.
</p>
<div class="sourceCode r"><pre>user_input &lt;- "{base::stop('Wrong message.', call. = FALSE)}"
cli::cli_abort(sprintf("Can't handle input `%s`.", user_input))
#&gt; Error:
#&gt; ! ! Could not evaluate cli `{}` expression: `base::stop('Wrong...`.
#&gt; Caused by error: 
#&gt; ! Wrong message.
</pre></div>
<p>To avoid this, protect your error messages by using cli to assemble the pieces:
</p>
<div class="sourceCode r"><pre>user_input &lt;- "{base::stop('Wrong message.', call. = FALSE)}"
cli::cli_abort("Can't handle input {.code {user_input}}.")
#&gt; Error:
#&gt; ! Can't handle input `{base::stop('Wrong message.', call. = FALSE)}`.
</pre></div>



<h4>Enabling cli formatting globally</h4>

<p>To enable cli formatting for all <code>abort()</code> calls in your namespace, call <code><a href="rlang.html#topic+local_use_cli">local_use_cli()</a></code> in the <code>onLoad</code> hook of your package. Using <code><a href="rlang.html#topic+on_load">on_load()</a></code> (make sure to call <code><a href="rlang.html#topic+run_on_load">run_on_load()</a></code> in your hook):
</p>
<div class="sourceCode r"><pre>on_load(local_use_cli())
</pre></div>
<p>Enabling cli formatting in <code>abort()</code> is useful for:
</p>

<ul>
<li><p> Transitioning from <code>abort()</code> to <code>cli::cli_abort()</code> progressively.
</p>
</li>
<li><p> Using <code>abort()</code> when you'd like to disable interpolation syntax.
</p>
</li>
<li><p> Creating error conditions with <code>error_cnd()</code>. These condition messages will be automatically formatted with cli as well.
</p>
</li></ul>



<hr>
<h2 id='topic-data-mask'>What is data-masking and why do I need <code style="white-space: pre;">&#8288;{{&#8288;</code>?</h2><span id='topic+topic-data-mask'></span>

<h3>Description</h3>

<p>Data-masking is a distinctive feature of R whereby programming is performed directly on a data set, with columns defined as normal objects.
</p>
<div class="sourceCode r"><pre># Unmasked programming
mean(mtcars$cyl + mtcars$am)
#&gt; [1] 6.59375

# Referring to columns is an error - Where is the data?
mean(cyl + am)
#&gt; Error:
#&gt; ! object 'cyl' not found

# Data-masking
with(mtcars, mean(cyl + am))
#&gt; [1] 6.59375
</pre></div>
<p>While data-masking makes it easy to program interactively with data frames, it makes it harder to create functions. Passing data-masked arguments to functions requires injection with the embracing operator <code><a href="rlang.html#topic+embrace-operator">{{</a></code> or, in more complex cases, the injection operator <code><a href="rlang.html#topic++21+21">!!</a></code>.
</p>


<h3>Why does data-masking require embracing and injection?</h3>

<p>Injection (also known as quasiquotation) is a metaprogramming feature that allows you to modify parts of a program. This is needed because under the hood data-masking works by <a href="rlang.html#topic+topic-defuse">defusing</a> R code to prevent its immediate evaluation. The defused code is resumed later on in a context where data frame columns are defined.
</p>
<p>Let's see what happens when we pass arguments to a data-masking function like <code>summarise()</code> in the normal way:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var1, var2) {
  dplyr::summarise(data, mean(var1 + var2))
}

my_mean(mtcars, cyl, am)
#&gt; Error in `dplyr::summarise()`:
#&gt; i In argument: `mean(var1 + var2)`.
#&gt; Caused by error:
#&gt; ! object 'cyl' not found
</pre></div>
<p>The problem here is that <code>summarise()</code> defuses the R code it was supplied, i.e. <code>mean(var1 + var2)</code>.  Instead we want it to see <code>mean(cyl + am)</code>. This is why we need injection, we need to modify that piece of code by injecting the code supplied to the function in place of <code>var1</code> and <code>var2</code>.
</p>
<p>To inject a function argument in data-masked context, just embrace it with <code style="white-space: pre;">&#8288;{{&#8288;</code>:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var1, var2) {
  dplyr::summarise(data, mean({{ var1 }} + {{ var2 }}))
}

my_mean(mtcars, cyl, am)
#&gt; # A tibble: 1 x 1
#&gt;   `mean(cyl + am)`
#&gt;              &lt;dbl&gt;
#&gt; 1             6.59
</pre></div>
<p>See <a href="rlang.html#topic+topic-data-mask-programming">Data mask programming patterns</a> to learn more about creating functions around data-masking functions.
</p>


<h3>What does &quot;masking&quot; mean?</h3>

<p>In normal R programming objects are defined in the current environment, for instance in the global environment or the environment of a function.
</p>
<div class="sourceCode r"><pre>factor &lt;- 1000

# Can now use `factor` in computations
mean(mtcars$cyl * factor)
#&gt; [1] 6187.5
</pre></div>
<p>This environment also contains all functions currently in scope. In a script this includes the functions attached with <code>library()</code> calls; in a package, the functions imported from other packages. If evaluation was performed only in the data frame, we'd lose track of these objects and functions necessary to perform computations.
</p>
<p>To keep these objects and functions in scope, the data frame is inserted at the bottom of the current chain of environments. It comes first and has precedence over the user environment. In other words, it <em>masks</em> the user environment.
</p>
<p>Since masking blends the data and the user environment by giving priority to the former, R can sometimes use a data frame column when you really intended to use a local object.
</p>
<div class="sourceCode r"><pre># Defining an env-variable
cyl &lt;- 1000

# Referring to a data-variable
dplyr::summarise(mtcars, mean(cyl))
#&gt; # A tibble: 1 x 1
#&gt;   `mean(cyl)`
#&gt;         &lt;dbl&gt;
#&gt; 1        6.19
</pre></div>
<p>The tidy eval framework provides <a href="dplyr.html#topic+.data">pronouns</a> to help disambiguate between the mask and user contexts. It is often a good idea to use these pronouns in production code.
</p>
<div class="sourceCode r"><pre>cyl &lt;- 1000

mtcars %&gt;%
  dplyr::summarise(
    mean_data = mean(.data$cyl),
    mean_env = mean(.env$cyl)
  )
#&gt; # A tibble: 1 x 2
#&gt;   mean_data mean_env
#&gt;       &lt;dbl&gt;    &lt;dbl&gt;
#&gt; 1      6.19     1000
</pre></div>
<p>Read more about this in <a href="rlang.html#topic+topic-data-mask-ambiguity">The data mask ambiguity</a>.
</p>


<h3>How does data-masking work?</h3>

<p>Data-masking relies on three language features:
</p>

<ul>
<li> <p><a href="rlang.html#topic+topic-defuse">Argument defusal</a> with <code><a href="base.html#topic+substitute">substitute()</a></code> (base R) or <code><a href="dplyr.html#topic+enquo">enquo()</a></code>, <code><a href="dplyr.html#topic+enquos">enquos()</a></code>, and <code><a href="rlang.html#topic+embrace-operator">{{</a></code> (rlang). R code is defused so it can be evaluated later on in a special environment enriched with data.
</p>
</li>
<li><p> First class environments. Environments are a special type of list-like object in which defused R code can be evaluated.  The named elements in an environment define objects. Lists and data frames can be transformed to environments:
</p>
<div class="sourceCode r"><pre>as.environment(mtcars)
#&gt; &lt;environment: 0x7febb17e3468&gt;
</pre></div>
</li>
<li><p> Explicit evaluation with <code><a href="base.html#topic+eval">eval()</a></code> (base) or <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code> (rlang). When R code is defused, evaluation is interrupted. It can be resumed later on with <code><a href="base.html#topic+eval">eval()</a></code>:
</p>
<div class="sourceCode r"><pre>expr(1 + 1)
#&gt; 1 + 1

eval(expr(1 + 1))
#&gt; [1] 2
</pre></div>
<p>By default <code>eval()</code> and <code>eval_tidy()</code> evaluate in the current environment.
</p>
<div class="sourceCode r"><pre>code &lt;- expr(mean(cyl + am))
eval(code)
#&gt; Error:
#&gt; ! object 'am' not found
</pre></div>
<p>You can supply an optional list or data frame that will be converted to an environment.
</p>
<div class="sourceCode r"><pre>eval(code, mtcars)
#&gt; [1] 6.59375
</pre></div>
<p>Evaluation of defused code then occurs in the context of a data mask.
</p>
</li></ul>



<h3>History</h3>

<p>The tidyverse embraced the data-masking approach in packages like ggplot2 and dplyr and eventually developed its own programming framework in the rlang package. None of this would have been possible without the following landmark developments from S and R authors.
</p>

<ul>
<li><p> The S language introduced data scopes with <code><a href="base.html#topic+attach">attach()</a></code> (Becker, Chambers and Wilks, The New S Language, 1988).
</p>
</li>
<li><p> The S language introduced data-masked formulas in modelling functions (Chambers and Hastie, 1993).
</p>
</li>
<li><p> Peter Dalgaard (R team) wrote the frametools package in 1997. It was later included in R as <code><a href="base.html#topic+transform">base::transform()</a></code> and <code><a href="base.html#topic+subset">base::subset()</a></code>. This API is an important source of inspiration for the dplyr package. It was also the first apparition of <em>selections</em>, a variant of data-masking extended and codified later on in the <a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect package</a>.
</p>
</li>
<li><p> In 2000 Luke Tierney (R team) <a href="https://github.com/wch/r-source/commit/a945ac8e">changed formulas</a> to keep track of their original environments. This change published in R 1.1.0 was a crucial step towards hygienic data masking, i.e. the proper resolution of symbols in their original environments. Quosures were inspired by the environment-tracking mechanism of formulas.
</p>
</li>
<li><p> Luke introduced <code><a href="base.html#topic+with">base::with()</a></code> in 2001.
</p>
</li>
<li><p> In 2006 the <a href="https://r-datatable.com">data.table package</a> included data-masking and selections in the <code>i</code> and <code>j</code> arguments of the <code>[</code> method of a data frame.
</p>
</li>
<li><p> The <a href="https://dplyr.tidyverse.org/">dplyr package</a> was published in 2014.
</p>
</li>
<li><p> The rlang package developed tidy eval in 2017 as the data-masking framework of the tidyverse. It introduced the notions of <a href="rlang.html#topic+topic-quosure">quosure</a>, <a href="rlang.html#topic+topic-inject">implicit injection</a> with <code style="white-space: pre;">&#8288;!!&#8288;</code>  and <code style="white-space: pre;">&#8288;!!!&#8288;</code>, and <a href="dplyr.html#topic+.data">data pronouns</a>.
</p>
</li>
<li><p> In 2019, injection with <code style="white-space: pre;">&#8288;{{&#8288;</code> was introduced in <a href="https://www.tidyverse.org/blog/2019/06/rlang-0-4-0/">rlang 0.4.0</a> to simplify the defuse-and-inject pattern. This operator allows R programmers to transport data-masked arguments across functions more intuitively and with minimal boilerplate.
</p>
</li></ul>



<h3>See also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-data-mask-programming">Data mask programming patterns</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+topic-defuse">Defusing R expressions</a>
</p>
</li></ul>


<hr>
<h2 id='topic-data-mask-ambiguity'>The data mask ambiguity</h2><span id='topic+topic-data-mask-ambiguity'></span>

<h3>Description</h3>

<p><a href="rlang.html#topic+topic-data-mask">Data masking</a> is an R feature that blends programming variables that live inside environments (env-variables) with statistical variables stored in data frames (data-variables). This mixture makes it easy to refer to data frame columns as well as objects defined in the current environment.
</p>
<div class="sourceCode r"><pre>x &lt;- 100
mtcars %&gt;% dplyr::summarise(mean(disp / x))
#&gt; # A tibble: 1 x 1
#&gt;   `mean(disp/x)`
#&gt;            &lt;dbl&gt;
#&gt; 1           2.31
</pre></div>
<p>However this convenience introduces an ambiguity between data-variables and env-variables which might cause <strong>collisions</strong>.
</p>


<h4>Column collisions</h4>

<p>In the following snippet, are we referring to the env-variable <code>x</code> or to the data-variable of the same name?
</p>
<div class="sourceCode r"><pre>df &lt;- data.frame(x = NA, y = 2)
x &lt;- 100

df %&gt;% dplyr::mutate(y = y / x)
#&gt;    x  y
#&gt; 1 NA NA
</pre></div>
<p>A column collision occurs when you want to use an object defined outside of the data frame, but a column of the same name happens to exist.
</p>



<h4>Object collisions</h4>

<p>The opposite problem occurs when there is a typo in a data-variable name and an env-variable of the same name exists:
</p>
<div class="sourceCode r"><pre>df &lt;- data.frame(foo = "right")
ffo &lt;- "wrong"

df %&gt;% dplyr::mutate(foo = toupper(ffo))
#&gt;     foo
#&gt; 1 WRONG
</pre></div>
<p>Instead of a typo, it might also be that you were expecting a column in the data frame which is unexpectedly missing. In both cases, if a variable can't be found in the data mask, R looks for variables in the surrounding environment. This isn't what we intended here and it would have been better to fail early with a &quot;Column not found&quot; error.
</p>



<h4>Preventing collisions</h4>

<p>In casual scripts or interactive programming, data mask ambiguity is not a huge deal compared to the payoff of iterating quickly while developing your analysis. However in production code and in package functions, the ambiguity might cause collision bugs in the long run.
</p>
<p>Fortunately it is easy to be explicit about the scoping of variables with a little more verbose code. This topic lists the solutions and workarounds that have been created to solve ambiguity issues in data masks.
</p>


<h5>The <code>.data</code> and <code>.env</code> pronouns</h5>

<p>The simplest solution is to use the <code><a href="dplyr.html#topic+.data">.data</a></code> and <code><a href="igraph.html#topic+.env">.env</a></code> pronouns to disambiguate between data-variables and env-variables.
</p>
<div class="sourceCode r"><pre>df &lt;- data.frame(x = 1, y = 2)
x &lt;- 100

df %&gt;% dplyr::mutate(y = .data$y / .env$x)
#&gt;   x    y
#&gt; 1 1 0.02
</pre></div>
<p>This is especially useful in functions because the data frame is not known in advance and potentially contain masking columns for any of the env-variables in scope in the function:
</p>
<div class="sourceCode r"><pre>my_rescale &lt;- function(data, var, factor = 10) {
  data %&gt;% dplyr::mutate("{{ var }}" := {{ var }} / factor)
}

# This works
data.frame(value = 1) %&gt;% my_rescale(value)
#&gt;   value
#&gt; 1   0.1

# Oh no!
data.frame(factor = 0, value = 1) %&gt;% my_rescale(value)
#&gt;   factor value
#&gt; 1      0   Inf
</pre></div>
<p>Subsetting function arguments with <code>.env</code> ensures we never hit a masking column:
</p>
<div class="sourceCode r"><pre>my_rescale &lt;- function(data, var, factor = 10) {
  data %&gt;% dplyr::mutate("{{ var }}" := {{ var }} / .env$factor)
}

# Yay!
data.frame(factor = 0, value = 1) %&gt;% my_rescale(value)
#&gt;   factor value
#&gt; 1      0   0.1
</pre></div>



<h5>Subsetting <code>.data</code> with env-variables</h5>

<p>The <code><a href="dplyr.html#topic+.data">.data</a></code> pronoun may be used as a name-to-data-mask pattern (see <a href="rlang.html#topic+topic-data-mask-programming">Data mask programming patterns</a>):
</p>
<div class="sourceCode r"><pre>var &lt;- "cyl"
mtcars %&gt;% dplyr::summarise(mean = mean(.data[[var]]))
#&gt; # A tibble: 1 x 1
#&gt;    mean
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19
</pre></div>
<p>In this example, the env-variable <code>var</code> is used inside the data mask to subset the <code>.data</code> pronoun. Does this mean that <code>var</code> is at risk of a column collision if the input data frame contains a column of the same name? Fortunately not:
</p>
<div class="sourceCode r"><pre>var &lt;- "cyl"

mtcars2 &lt;- mtcars
mtcars2$var &lt;- "wrong"

mtcars2 %&gt;% dplyr::summarise(mean = mean(.data[[var]]))
#&gt; # A tibble: 1 x 1
#&gt;    mean
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19
</pre></div>
<p>The evaluation of <code>.data[[var]]</code> is set up in such a way that there is no ambiguity. The <code>.data</code> pronoun can only be subsetted with env-variables, not data-variables. Technically, this is because <code>[[</code> behaves like an <em>injection operator</em> when applied to <code>.data</code>. It is evaluated very early before the data mask is even created. See the <code style="white-space: pre;">&#8288;!!&#8288;</code> section below.
</p>



<h5>Injecting env-variables with <code style="white-space: pre;">&#8288;!!&#8288;</code></h5>

<p><a href="rlang.html#topic+topic-inject">Injection operators</a> such as <code><a href="rlang.html#topic+injection-operator">!!</a></code> have interesting properties regarding the ambiguity problem. They modify a piece of code early on by injecting objects or other expressions before any data-masking logic comes into play. If you inject the <em>value</em> of a variable, it becomes inlined in the expression. R no longer needs to look up any variable to find the value.
</p>
<p>Taking the earlier division example, let's use <code style="white-space: pre;">&#8288;!!&#8288;</code> to inject the value of the env-variable <code>x</code> inside the division expression:
</p>
<div class="sourceCode r"><pre>df &lt;- data.frame(x = NA, y = 2)
x &lt;- 100

df %&gt;% dplyr::mutate(y = y / !!x)
#&gt;    x    y
#&gt; 1 NA 0.02
</pre></div>
<p>While injection solves issues of ambiguity, it is a bit heavy handed compared to using the <code><a href="igraph.html#topic+.env">.env</a></code> pronoun. Big objects inlined in expressions might cause issues in unexpected places, for instance they might make the calls in a <code><a href="base.html#topic+traceback">traceback()</a></code> less readable.
</p>




<h4>No ambiguity in tidy selections</h4>

<p><a href="https://tidyselect.r-lib.org/reference/language.html">Tidy selection</a> is a dialect of R that optimises column selection in tidyverse packages. Examples of functions that use tidy selections are <code>dplyr::select()</code> and <code>tidyr::pivot_longer()</code>.
</p>
<p>Unlike data masking, tidy selections do not suffer from ambiguity. The selection language is designed in such a way that evaluation of expressions is either scoped in the data mask only, or in the environment only. Take this example:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% dplyr::select(gear:ncol(mtcars))
</pre></div>
<p><code>gear</code> is a symbol supplied to a selection operator <code>:</code> and thus scoped in the data mask only. Any other kind of expression, such as <code>ncol(mtcars)</code>, is evaluated as normal R code outside of any data context. This is why there is no column collision here:
</p>
<div class="sourceCode r"><pre>data &lt;- data.frame(x = 1, data = 1:3)

data %&gt;% dplyr::select(data:ncol(data))
#&gt;   data
#&gt; 1    1
#&gt; 2    2
#&gt; 3    3
</pre></div>
<p>It is useful to introduce two new terms. Tidy selections distinguish data-expressions and env-expressions:
</p>

<ul>
<li> <p><code>data</code> is a data-expression that refers to the data-variable.
</p>
</li>
<li> <p><code>ncol(data)</code> is an env-expression that refers to the env-variable.
</p>
</li></ul>

<p>To learn more about the difference between the two kinds of expressions, see the <a href="https://tidyselect.r-lib.org/articles/syntax.html">technical description of the tidy selection syntax</a>.
</p>


<h5>Names pattern with <code>all_of()</code></h5>

<p><code>all_of()</code> is often used in functions as a <a href="rlang.html#topic+topic-data-mask-programming">programming pattern</a> that connects column names to a data mask, similarly to the <code><a href="dplyr.html#topic+.data">.data</a></code> pronoun. A simple example is:
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(data, vars) {
  data %&gt;% dplyr::group_by(across(all_of(vars)))
}
</pre></div>
<p>If tidy selections were affected by the data mask ambiguity, this function would be at risk of a column collision. It would break as soon as the user supplies a data frame containing a <code>vars</code> column. However, <code>all_of()</code> is an env-expression that is evaluated outside of the data mask, so there is no possibility of collisions.
</p>



<hr>
<h2 id='topic-data-mask-programming'>Data mask programming patterns</h2><span id='topic+topic-data-mask-programming'></span>

<h3>Description</h3>

<p><a href="rlang.html#topic+topic-data-mask">Data-masking</a> functions require special programming patterns when used inside other functions. In this topic we'll review and compare the different patterns that can be used to solve specific problems.
</p>
<p>If you are a beginner, you might want to start with one of these tutorials:
</p>

<ul>
<li> <p><a href="https://dplyr.tidyverse.org/articles/programming.html">Programming with dplyr</a>
</p>
</li>
<li> <p><a href="https://ggplot2.tidyverse.org/articles/ggplot2-in-packages.html">Using ggplot2 in packages</a>
</p>
</li></ul>

<p>If you'd like to go further and learn about defusing and injecting expressions, read the <a href="rlang.html#topic+topic-metaprogramming">metaprogramming patterns topic</a>.
</p>


<h3>Choosing a pattern</h3>

<p>Two main considerations determine which programming pattern you need to wrap a data-masking function:
</p>

<ol>
<li><p> What behaviour does the <em>wrapped</em> function implement?
</p>
</li>
<li><p> What behaviour should <em>your</em> function implement?
</p>
</li></ol>

<p>Depending on the answers to these questions, you can choose between these approaches:
</p>

<ul>
<li><p> The <strong>forwarding patterns</strong> with which your function inherits the behaviour of the function it interfaces with.
</p>
</li>
<li><p> The <strong>name patterns</strong> with which your function takes strings or character vectors of column names.
</p>
</li>
<li><p> The <strong>bridge patterns</strong> with which you change the behaviour of an argument instead of inheriting it.
</p>
</li></ul>

<p>You will also need to use different solutions for single named arguments than for multiple arguments in <code>...</code>.
</p>


<h3>Argument behaviours</h3>

<p>In a regular function, arguments can be defined in terms of a <em>type</em> of objects that they accept. An argument might accept a character vector, a data frame, a single logical value, etc. Data-masked arguments are more complex. Not only do they generally accept a specific type of objects (for instance <code>dplyr::mutate()</code> accepts vectors), they exhibit special computational behaviours.
</p>

<ul>
<li><p> Data-masked expressions (base): E.g. <code><a href="base.html#topic+transform">transform()</a></code>, <code><a href="base.html#topic+with">with()</a></code>.  Expressions may refer to the columns of the supplied data frame.
</p>
</li>
<li><p> Data-masked expressions (tidy eval): E.g. <code>dplyr::mutate()</code>, <code>ggplot2::aes()</code>. Same as base data-masking but with tidy eval features enabled. This includes <a href="rlang.html#topic+topic-inject">injection operators</a> such as <code><a href="rlang.html#topic+embrace-operator">{{</a></code> and <code><a href="rlang.html#topic+injection-operator">!!</a></code> and the <code><a href="dplyr.html#topic+.data">.data</a></code> and <code><a href="igraph.html#topic+.env">.env</a></code> pronouns.
</p>
</li>
<li><p> Data-masked symbols: Same as data-masked arguments but the supplied expressions must be simple column names. This often simplifies things, for instance this is an easy way of avoiding issues of <a href="rlang.html#topic+topic-double-evaluation">double evaluation</a>.
</p>
</li>
<li> <p><a href="https://tidyselect.r-lib.org/reference/language.html">Tidy selections</a>: E.g. <code>dplyr::select()</code>, <code>tidyr::pivot_longer()</code>. This is an alternative to data masking that supports selection helpers like <code>starts_with()</code> or <code>all_of()</code>, and implements special behaviour for operators like <code>c()</code>, <code>|</code> and <code>&amp;</code>.
</p>
<p>Unlike data masking, tidy selection is an interpreted dialect. There is in fact no masking at all. Expressions are either interpreted in the context of the data frame (e.g. <code>c(cyl, am)</code> which stands for the union of the columns <code>cyl</code> and <code>am</code>), or evaluated in the user environment (e.g. <code>all_of()</code>, <code>starts_with()</code>, and any other expressions). This has implications for inheritance of argument behaviour as we will see below.
</p>
</li>
<li> <p><a href="rlang.html#topic+doc_dots_dynamic">Dynamic dots</a>: These may be data-masked arguments, tidy selections, or just regular arguments. Dynamic dots support injection of multiple arguments with the <code><a href="rlang.html#topic+splice-operator">!!!</a></code> operator as well as name injection with <a href="rlang.html#topic+glue-operators">glue</a> operators.
</p>
</li></ul>

<p>To let users know about the capabilities of your function arguments, document them with the following tags, depending on which set of semantics they inherit from:
</p>
<div class="sourceCode"><pre>@param foo &lt;[`data-masked`][dplyr::dplyr_data_masking]&gt; What `foo` does.

@param bar &lt;[`tidy-select`][dplyr::dplyr_tidy_select]&gt; What `bar` does.

@param ... &lt;[`dynamic-dots`][rlang::dyn-dots]&gt; What these dots do.
</pre></div>


<h3>Forwarding patterns</h3>

<p>With the forwarding patterns, arguments inherit the behaviour of the data-masked arguments they are passed in.
</p>


<h4>Embrace with <code style="white-space: pre;">&#8288;{{&#8288;</code></h4>

<p>The embrace operator <code><a href="rlang.html#topic+embrace-operator">{{</a></code> is a forwarding syntax for single arguments. You can forward an argument in data-masked context:
</p>
<div class="sourceCode r"><pre>my_summarise &lt;- function(data, var) {
  data %&gt;% dplyr::summarise({{ var }})
}
</pre></div>
<p>Or in tidyselections:
</p>
<div class="sourceCode r"><pre>my_pivot_longer &lt;- function(data, var) {
  data %&gt;% tidyr::pivot_longer(cols = {{ var }})
}
</pre></div>
<p>The function automatically inherits the behaviour of the surrounding context. For instance arguments forwarded to a data-masked context may refer to columns or use the <code><a href="dplyr.html#topic+.data">.data</a></code> pronoun:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% my_summarise(mean(cyl))

x &lt;- "cyl"
mtcars %&gt;% my_summarise(mean(.data[[x]]))
</pre></div>
<p>And arguments forwarded to a tidy selection may use all tidyselect features:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% my_pivot_longer(cyl)
mtcars %&gt;% my_pivot_longer(vs:gear)
mtcars %&gt;% my_pivot_longer(starts_with("c"))

x &lt;- c("cyl", "am")
mtcars %&gt;% my_pivot_longer(all_of(x))
</pre></div>



<h4>Forward <code>...</code></h4>

<p>Simple forwarding of <code>...</code> arguments does not require any special syntax since dots are already a forwarding syntax. Just pass them to another function like you normally would. This works with data-masked arguments:
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(.data, ...) {
  .data %&gt;% dplyr::group_by(...)
}

mtcars %&gt;% my_group_by(cyl = cyl * 100, am)
</pre></div>
<p>As well as tidy selections:
</p>
<div class="sourceCode r"><pre>my_select &lt;- function(.data, ...) {
  .data %&gt;% dplyr::select(...)
}

mtcars %&gt;% my_select(starts_with("c"), vs:carb)
</pre></div>
<p>Some functions take a tidy selection in a single named argument. In that case, pass the <code>...</code> inside <code>c()</code>:
</p>
<div class="sourceCode r"><pre>my_pivot_longer &lt;- function(.data, ...) {
  .data %&gt;% tidyr::pivot_longer(c(...))
}

mtcars %&gt;% my_pivot_longer(starts_with("c"), vs:carb)
</pre></div>
<p>Inside a tidy selection, <code>c()</code> is not a vector concatenator but a selection combinator. This makes it handy to interface between functions that take <code>...</code> and functions that take a single argument.
</p>



<h3>Names patterns</h3>

<p>With the names patterns you refer to columns by name with strings or character vectors stored in env-variables. Whereas the forwarding patterns are exclusively used within a function to pass <em>arguments</em>, the names patterns can be used anywhere.
</p>

<ul>
<li><p> In a script, you can loop over a character vector with <code>for</code> or <code>lapply()</code> and use the <code><a href="dplyr.html#topic+.data">.data</a></code> pattern to connect a name to its data-variable. A vector can also be supplied all at once to the tidy select helper <code>all_of()</code>.
</p>
</li>
<li><p> In a function, using the names patterns on function arguments lets users supply regular data-variable names without any of the complications that come with data-masking.
</p>
</li></ul>



<h4>Subsetting the <code>.data</code> pronoun</h4>

<p>The <code><a href="dplyr.html#topic+.data">.data</a></code> pronoun is a tidy eval feature that is enabled in all data-masked arguments, just like <code><a href="rlang.html#topic+embrace-operator">{{</a></code>. The pronoun represents the data mask and can be subsetted with <code>[[</code> and <code>$</code>. These three statements are equivalent:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% dplyr::summarise(mean = mean(cyl))

mtcars %&gt;% dplyr::summarise(mean = mean(.data$cyl))

var &lt;- "cyl"
mtcars %&gt;% dplyr::summarise(mean = mean(.data[[var]]))
</pre></div>
<p>The <code>.data</code> pronoun can be subsetted in loops:
</p>
<div class="sourceCode r"><pre>vars &lt;- c("cyl", "am")

for (var in vars) print(dplyr::summarise(mtcars, mean = mean(.data[[var]])))
#&gt; # A tibble: 1 x 1
#&gt;    mean
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19
#&gt; # A tibble: 1 x 1
#&gt;    mean
#&gt;   &lt;dbl&gt;
#&gt; 1 0.406

purrr::map(vars, ~ dplyr::summarise(mtcars, mean =  mean(.data[[.x]])))
#&gt; [[1]]
#&gt; # A tibble: 1 x 1
#&gt;    mean
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19
#&gt; 
#&gt; [[2]]
#&gt; # A tibble: 1 x 1
#&gt;    mean
#&gt;   &lt;dbl&gt;
#&gt; 1 0.406
</pre></div>
<p>And it can be used to connect function arguments to a data-variable:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  data %&gt;% dplyr::summarise(mean = mean(.data[[var]]))
}

my_mean(mtcars, "cyl")
#&gt; # A tibble: 1 x 1
#&gt;    mean
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19
</pre></div>
<p>With this implementation, <code>my_mean()</code> is completely insulated from data-masking behaviour and is called like an ordinary function.
</p>
<div class="sourceCode r"><pre># No masking
am &lt;- "cyl"
my_mean(mtcars, am)
#&gt; # A tibble: 1 x 1
#&gt;    mean
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19

# Programmable
my_mean(mtcars, tolower("CYL"))
#&gt; # A tibble: 1 x 1
#&gt;    mean
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19
</pre></div>



<h4>Character vector of names</h4>

<p>The <code>.data</code> pronoun can only be subsetted with single column names. It doesn't support single-bracket indexing:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% dplyr::summarise(.data[c("cyl", "am")])
#&gt; Error in `dplyr::summarise()`:
#&gt; i In argument: `.data[c("cyl", "am")]`.
#&gt; Caused by error in `.data[c("cyl", "am")]`:
#&gt; ! `[` is not supported by the `.data` pronoun, use `[[` or $ instead.
</pre></div>
<p>There is no plural variant of <code>.data</code> built in tidy eval. Instead, we'll used the <code>all_of()</code> operator available in tidy selections to supply character vectors. This is straightforward in functions that take tidy selections, like <code>tidyr::pivot_longer()</code>:
</p>
<div class="sourceCode r"><pre>vars &lt;- c("cyl", "am")
mtcars %&gt;% tidyr::pivot_longer(all_of(vars))
#&gt; # A tibble: 64 x 11
#&gt;     mpg  disp    hp  drat    wt  qsec    vs  gear  carb name  value
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
#&gt; 1    21   160   110   3.9  2.62  16.5     0     4     4 cyl       6
#&gt; 2    21   160   110   3.9  2.62  16.5     0     4     4 am        1
#&gt; 3    21   160   110   3.9  2.88  17.0     0     4     4 cyl       6
#&gt; 4    21   160   110   3.9  2.88  17.0     0     4     4 am        1
#&gt; # i 60 more rows
</pre></div>
<p>If the function does not take a tidy selection, it might be possible to use a <em>bridge pattern</em>. This option is presented in the bridge section below. If a bridge is impossible or inconvenient, a little metaprogramming with the <a href="rlang.html#topic+topic-metaprogramming">symbolise-and-inject pattern</a> can help.
</p>



<h3>Bridge patterns</h3>

<p>Sometimes the function you are calling does not implement the behaviour you would like to give to the arguments of your function. To work around this may require a little thought since there is no systematic way of turning one behaviour into another. The general technique consists in forwarding the arguments inside a context that implements the behaviour that you want. Then, find a way to bridge the result to the target verb or function.
</p>


<h4><code>across()</code> as a selection to data-mask bridge</h4>

<p>dplyr 1.0 added support for tidy selections in all verbs via <code>across()</code>. This function is normally used for mapping over columns but can also be used to perform a simple selection. For instance, if you'd like to pass an argument to <code>group_by()</code> with a tidy-selection interface instead of a data-masked one, use <code>across()</code> as a bridge:
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(data, var) {
  data %&gt;% dplyr::group_by(across({{ var }}))
}

mtcars %&gt;% my_group_by(starts_with("c"))
</pre></div>
<p>Since <code>across()</code> takes selections in a single argument (unlike <code>select()</code> which takes multiple arguments), you can't directly pass <code>...</code>. Instead, take them within <code>c()</code>, which is the tidyselect way of supplying multiple selections within a single argument:
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(.data, ...) {
  .data %&gt;% dplyr::group_by(across(c(...)}))
}

mtcars %&gt;% my_group_by(starts_with("c"), vs:gear)
</pre></div>



<h4><code>across(all_of())</code> as a names to data mask bridge</h4>

<p>If instead of forwarding variables in <code>across()</code> you pass them to <code>all_of()</code>, you create a names to data mask bridge.
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(data, vars) {
  data %&gt;% dplyr::group_by(across(all_of(vars)))
}

mtcars %&gt;% my_group_by(c("cyl", "am"))
</pre></div>
<p>Use this bridge technique to connect vectors of names to a data-masked context.
</p>



<h4><code>transmute()</code> as a data-mask to selection bridge</h4>

<p>Passing data-masked arguments to a tidy selection is a little more tricky and requires a three step process.
</p>
<div class="sourceCode r"><pre>my_pivot_longer &lt;- function(data, ...) {
  # Forward `...` in data-mask context with `transmute()`
  # and save the inputs names
  inputs &lt;- dplyr::transmute(data, ...)
  names &lt;- names(inputs)
  
  # Update the data with the inputs
  data &lt;- dplyr::mutate(data, !!!inputs)

  # Select the inputs by name with `all_of()`
  tidyr::pivot_longer(data, cols = all_of(names))
}

mtcars %&gt;% my_pivot_longer(cyl, am = am * 100)
</pre></div>

<ol>
<li><p> In a first step we pass the <code>...</code> expressions to <code>transmute()</code>. Unlike <code>mutate()</code>, it creates a new data frame from the user inputs. The only goal of this step is to inspect the names in <code>...</code>, including the default names created for unnamed arguments.
</p>
</li>
<li><p> Once we have the names, we inject the arguments into <code>mutate()</code> to update the data frame.
</p>
</li>
<li><p> Finally, we pass the names to the tidy selection via <a href="https://tidyselect.r-lib.org/reference/all_of.html"><code>all_of()</code></a>.
</p>
</li></ol>




<h3>Transformation patterns</h3>



<h4>Named inputs versus <code>...</code></h4>

<p>In the case of a named argument, transformation is easy. We simply surround the embraced input in R code. For instance, the <code>my_summarise()</code> function is not exactly useful compared to just calling <code>summarise()</code>:
</p>
<div class="sourceCode r"><pre>my_summarise &lt;- function(data, var) {
  data %&gt;% dplyr::summarise({{ var }})
}
</pre></div>
<p>We can make it more useful by adding code around the variable:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  data %&gt;% dplyr::summarise(mean = mean({{ var }}, na.rm = TRUE))
}
</pre></div>
<p>For inputs in <code>...</code> however, this technique does not work. We would need some kind of templating syntax for dots that lets us specify R code with a placeholder for the dots elements. This isn't built in tidy eval but you can use operators like <code>dplyr::across()</code>, <code>dplyr::if_all()</code>, or <code>dplyr::if_any()</code>. When that isn't possible, you can template the expression manually.
</p>



<h4>Transforming inputs with <code>across()</code></h4>

<p>The <code>across()</code> operation in dplyr is a convenient way of mapping an expression across a set of inputs. We will create a variant of <code>my_mean()</code> that computes the <code>mean()</code> of all arguments supplied in <code>...</code>. The easiest way it to forward the dots to <code>across()</code> (which causes <code>...</code> to inherit its tidy selection behaviour):
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, ...) {
  data %&gt;% dplyr::summarise(across(c(...), ~ mean(.x, na.rm = TRUE)))
}

mtcars %&gt;% my_mean(cyl, carb)
#&gt; # A tibble: 1 x 2
#&gt;     cyl  carb
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1  6.19  2.81

mtcars %&gt;% my_mean(foo = cyl, bar = carb)
#&gt; # A tibble: 1 x 2
#&gt;     foo   bar
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1  6.19  2.81

mtcars %&gt;% my_mean(starts_with("c"), mpg:disp)
#&gt; # A tibble: 1 x 4
#&gt;     cyl  carb   mpg  disp
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1  6.19  2.81  20.1  231.
</pre></div>



<h4>Transforming inputs with <code>if_all()</code> and <code>if_any()</code></h4>

<p><code>dplyr::filter()</code> requires a different operation than <code>across()</code> because it needs to combine the logical expressions with <code>&amp;</code> or <code>|</code>. To solve this problem dplyr introduced the <code>if_all()</code> and <code>if_any()</code> variants of <code>across()</code>.
</p>
<p>In the following example, we filter all rows for which a set of variables are not equal to their minimum value:
</p>
<div class="sourceCode r"><pre>filter_non_baseline &lt;- function(.data, ...) {
  .data %&gt;% dplyr::filter(if_all(c(...), ~ .x != min(.x, na.rm = TRUE)))
}

mtcars %&gt;% filter_non_baseline(vs, am, gear)
</pre></div>


<hr>
<h2 id='topic-defuse'>Defusing R expressions</h2><span id='topic+topic-defuse'></span><span id='topic+quotation'></span><span id='topic+nse-defuse'></span>

<h3>Description</h3>

<p>When a piece of R code is defused, R doesn't return its value like it normally would. Instead it returns the expression in a special tree-like object that describes how to compute a value. These defused expressions can be thought of as blueprints or recipes for computing values.
</p>
<p>Using <code><a href="dplyr.html#topic+expr">expr()</a></code> we can observe the difference between computing an expression and defusing it:
</p>
<div class="sourceCode r"><pre># Return the result of `1 + 1`
1 + 1
#&gt; [1] 2

# Return the expression `1 + 1`
expr(1 + 1)
#&gt; 1 + 1
</pre></div>
<p>Evaluation of a defused expression can be resumed at any time with <code><a href="base.html#topic+eval">eval()</a></code> (see also <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code>).
</p>
<div class="sourceCode r"><pre># Return the expression `1 + 1`
e &lt;- expr(1 + 1)

# Return the result of `1 + 1`
eval(e)
#&gt; [1] 2
</pre></div>
<p>The most common use case for defusing expressions is to resume its evaluation in a <a href="rlang.html#topic+topic-data-mask">data mask</a>. This makes it possible for the expression to refer to columns of a data frame as if they were regular objects.
</p>
<div class="sourceCode r"><pre>e &lt;- expr(mean(cyl))
eval(e, mtcars)
#&gt; [1] 6.1875
</pre></div>


<h3>Do I need to know about defused expressions?</h3>

<p>As a tidyverse user you will rarely need to defuse expressions manually with <code>expr()</code>, and even more rarely need to resume evaluation with <code><a href="base.html#topic+eval">eval()</a></code> or <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code>. Instead, you call <a href="rlang.html#topic+topic-data-mask">data-masking</a> functions which take care of defusing your arguments and resuming them in the context of a data mask.
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% dplyr::summarise(
  mean(cyl)  # This is defused and data-masked
)
#&gt; # A tibble: 1 x 1
#&gt;   `mean(cyl)`
#&gt;         &lt;dbl&gt;
#&gt; 1        6.19
</pre></div>
<p>It is important to know that a function defuses its arguments because it requires slightly different methods when called from a function. The main thing is that arguments must be transported with the <a href="rlang.html#topic+embrace-operator">embrace operator</a> <code style="white-space: pre;">&#8288;{{&#8288;</code>. It allows the data-masking function to defuse the correct expression.
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  dplyr::summarise(data, mean = mean({{ var }}))
}
</pre></div>
<p>Read more about this in:
</p>

<ul>
<li> <p><a href="rlang.html#topic+topic-data-mask">What is data-masking and why do I need {{?</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+topic-data-mask-programming">Data mask programming patterns</a>
</p>
</li></ul>



<h3>The booby trap analogy</h3>

<p>The term &quot;defusing&quot; comes from an analogy to the evaluation model in R. As you may know, R uses lazy evaluation, which means that arguments are only evaluated when they are needed for a computation. Let's take two functions, <code>ignore()</code> which doesn't do anything with its argument, and <code>force()</code> which returns it:
</p>
<div class="sourceCode r"><pre>ignore &lt;- function(arg) NULL
force &lt;- function(arg) arg

ignore(warning("boom"))
#&gt; NULL

force(warning("boom"))
#&gt; Warning in force(warning("boom")): boom
</pre></div>
<p>A warning is only emitted when the function actually <em>triggers</em> evaluation of its argument. Evaluation of arguments can be chained by passing them to other functions. If one of the functions ignores its argument, it breaks the chain of evaluation.
</p>
<div class="sourceCode r"><pre>f &lt;- function(x) g(x)
g &lt;- function(y) h(y)
h &lt;- function(z) ignore(z)

f(warning("boom"))
#&gt; NULL
</pre></div>
<p>In a way, arguments are like <em>booby traps</em> which explode (evaluate) when touched. Defusing an argument can be seen as defusing the booby trap.
</p>
<div class="sourceCode r"><pre>expr(force(warning("boom")))
#&gt; force(warning("boom"))
</pre></div>


<h3>Types of defused expressions</h3>


<ul>
<li> <p><strong>Calls</strong>, like <code>f(1, 2, 3)</code> or <code>1 + 1</code> represent the action of calling a function to compute a new value, such as a vector.
</p>
</li>
<li> <p><strong>Symbols</strong>, like <code>x</code> or <code>df</code>, represent named objects. When the object pointed to by the symbol was defined in a function or in the global environment, we call it an environment-variable. When the object is a column in a data frame, we call it a data-variable.
</p>
</li>
<li> <p><strong>Constants</strong>, like <code>1</code> or <code>NULL</code>.
</p>
</li></ul>

<p>You can create new call or symbol objects by using the defusing function <code>expr()</code>:
</p>
<div class="sourceCode r"><pre># Create a symbol representing objects called `foo`
expr(foo)
#&gt; foo

# Create a call representing the computation of the mean of `foo`
expr(mean(foo, na.rm = TRUE))
#&gt; mean(foo, na.rm = TRUE)

# Return a constant
expr(1)
#&gt; [1] 1

expr(NULL)
#&gt; NULL
</pre></div>
<p>Defusing is not the only way to create defused expressions. You can also assemble them from data:
</p>
<div class="sourceCode r"><pre># Assemble a symbol from a string
var &lt;- "foo"
sym(var)

# Assemble a call from strings, symbols, and constants
call("mean", sym(var), na.rm = TRUE)
</pre></div>


<h3>Local expressions versus function arguments</h3>

<p>There are two main ways to defuse expressions, to which correspond two functions in rlang, <code><a href="dplyr.html#topic+expr">expr()</a></code> and <code><a href="dplyr.html#topic+enquo">enquo()</a></code>:
</p>

<ul>
<li><p> You can defuse your <em>own</em> R expressions with <code>expr()</code>.
</p>
</li>
<li><p> You can defuse the expressions supplied by <em>the user</em> of your function with the <code>en</code>-prefixed operators, such as <code>enquo()</code> and <code>enquos()</code>. These operators defuse function arguments.
</p>
</li></ul>



<h3>Defuse and inject</h3>

<p>One purpose for defusing evaluation of an expression is to interface with <a href="rlang.html#topic+topic-data-mask">data-masking</a> functions by injecting the expression back into another function with <code style="white-space: pre;">&#8288;!!&#8288;</code>. This is the <a href="rlang.html#topic+topic-metaprogramming">defuse-and-inject pattern</a>.
</p>
<div class="sourceCode r"><pre>my_summarise &lt;- function(data, arg) {
  # Defuse the user expression in `arg`
  arg &lt;- enquo(arg)

  # Inject the expression contained in `arg`
  # inside a `summarise()` argument
  data |&gt; dplyr::summarise(mean = mean(!!arg, na.rm = TRUE))
}
</pre></div>
<p>Defuse-and-inject is usually performed in a single step with the embrace operator <code><a href="rlang.html#topic+embrace-operator">{{</a></code>.
</p>
<div class="sourceCode r"><pre>my_summarise &lt;- function(data, arg) {
  # Defuse and inject in a single step with the embracing operator
  data |&gt; dplyr::summarise(mean = mean({{ arg }}, na.rm = TRUE))
}
</pre></div>
<p>Using <code>enquo()</code> and <code style="white-space: pre;">&#8288;!!&#8288;</code> separately is useful in more complex cases where you need access to the defused expression instead of just passing it on.
</p>


<h3>Defused arguments and quosures</h3>

<p>If you inspect the return values of <code>expr()</code> and <code>enquo()</code>, you'll notice that the latter doesn't return a raw expression like the former. Instead it returns a <a href="rlang.html#topic+quosure">quosure</a>, a wrapper containing an expression and an environment.
</p>
<div class="sourceCode r"><pre>expr(1 + 1)
#&gt; 1 + 1

my_function &lt;- function(arg) enquo(arg)
my_function(1 + 1)
#&gt; &lt;quosure&gt;
#&gt; expr: ^1 + 1
#&gt; env:  global
</pre></div>
<p>R needs information about the environment to properly evaluate argument expressions because they come from a different context than the current function. For instance when a function in your package calls <code>dplyr::mutate()</code>, the quosure environment indicates where all the private functions of your package are defined.
</p>
<p>Read more about the role of quosures in <a href="rlang.html#topic+topic-quosure">What are quosures and when are they needed?</a>.
</p>


<h3>Comparison with base R</h3>

<p>Defusing is known as <em>quoting</em> in other frameworks.
</p>

<ul>
<li><p> The equivalent of <code>expr()</code> is <code><a href="base.html#topic+bquote">base::bquote()</a></code>.
</p>
</li>
<li><p> The equivalent of <code>enquo()</code> is <code><a href="base.html#topic+substitute">base::substitute()</a></code>. The latter returns a naked expression instead of a quosure.
</p>
</li>
<li><p> There is no equivalent for <code>enquos(...)</code> but you can defuse dots as a list of naked expressions with <code>eval(substitute(alist(...)))</code>.
</p>
</li></ul>


<hr>
<h2 id='topic-double-evaluation'>The double evaluation problem</h2><span id='topic+topic-double-evaluation'></span>

<h3>Description</h3>

<p>One inherent risk to metaprogramming is to evaluate multiple times a piece of code that appears to be evaluated only once. Take this data-masking function which takes a single input and produces two summaries:
</p>
<div class="sourceCode r"><pre>summarise_stats &lt;- function(data, var) {
  data %&gt;%
    dplyr::summarise(
      mean = mean({{ var }}),
      sd = sd({{ var }})
    )
}

summarise_stats(mtcars, cyl)
#&gt; # A tibble: 1 x 2
#&gt;    mean    sd
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1  6.19  1.79
</pre></div>
<p>This function is perfectly fine if the user supplies simple column names. However, data-masked arguments may also include <em>computations</em>.
</p>
<div class="sourceCode r"><pre>summarise_stats(mtcars, cyl * 100)
#&gt; # A tibble: 1 x 2
#&gt;    mean    sd
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1  619.  179.
</pre></div>
<p>Computations may be slow and may produce side effects. For these
reasons, they should only be performed as many times as they appear in the code (unless explicitly documented, e.g. once per group with grouped data frames). Let's try again with a more complex computation:
</p>
<div class="sourceCode r"><pre>times100 &lt;- function(x) {
  message("Takes a long time...")
  Sys.sleep(0.1)

  message("And causes side effects such as messages!")
  x * 100
}

summarise_stats(mtcars, times100(cyl))
#&gt; Takes a long time...
#&gt; And causes side effects such as messages!
#&gt; Takes a long time...
#&gt; And causes side effects such as messages!
#&gt; # A tibble: 1 x 2
#&gt;    mean    sd
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1  619.  179.
</pre></div>
<p>Because of the side effects and the long running time, it is clear that <code>summarise_stats()</code> evaluates its input twice. This is because we've injected a defused expression in two different places. The data-masked expression created down the line looks like this (with caret signs representing <a href="rlang.html#topic+topic-quosure">quosure</a> boundaries):
</p>
<div class="sourceCode r"><pre>dplyr::summarise(
  mean = ^mean(^times100(cyl)),
  sd = ^sd(^times100(cyl))
)
</pre></div>
<p>The <code>times100(cyl)</code> expression is evaluated twice, even though it only appears once in the code. We have a double evaluation bug.
</p>
<p>One simple way to fix it is to assign the defused input to a constant. You can then refer to that constant in the remaining of the code.
</p>
<div class="sourceCode r"><pre>summarise_stats &lt;- function(data, var) {
  data %&gt;%
    dplyr::transmute(
      var = {{ var }},
    ) %&gt;%
    dplyr::summarise(
      mean = mean(var),
      sd = sd(var)
    )
}
</pre></div>
<p>The defused input is now evaluated only once because it is injected only once:
</p>
<div class="sourceCode r"><pre>summarise_stats(mtcars, times100(cyl))
#&gt; Takes a long time...
#&gt; And causes side effects such as messages!
#&gt; # A tibble: 1 x 2
#&gt;    mean    sd
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1  619.  179.
</pre></div>


<h3>What about glue strings?</h3>

<p><code style="white-space: pre;">&#8288;{{&#8288;</code> <a href="rlang.html#topic+glue-operators">embracing in glue strings</a> doesn't suffer from the double evaluation problem:
</p>
<div class="sourceCode r"><pre>summarise_stats &lt;- function(data, var) {
  data %&gt;%
    dplyr::transmute(
      var = {{ var }},
    ) %&gt;%
    dplyr::summarise(
      "mean_{{ var }}" := mean(var),
      "sd_{{ var }}" := sd(var)
    )
}

summarise_stats(mtcars, times100(cyl))
#&gt; Takes a long time...
#&gt; And causes side effects such as messages!
#&gt; # A tibble: 1 x 2
#&gt;   `mean_times100(cyl)` `sd_times100(cyl)`
#&gt;                  &lt;dbl&gt;              &lt;dbl&gt;
#&gt; 1                 619.               179.
</pre></div>
<p>Since a glue string doesn't need the result of an expression, only the original code converted (deparsed) to a string, it doesn't evaluate injected expressions.
</p>

<hr>
<h2 id='topic-embrace-constants'>Why are strings and other constants enquosed in the empty environment?</h2><span id='topic+topic-embrace-constants'></span>

<h3>Description</h3>

<p>Function arguments are <a href="rlang.html#topic+topic-defuse">defused</a> into <a href="rlang.html#topic+topic-quosure">quosures</a> that keep track of the environment of the defused expression.
</p>
<div class="sourceCode r"><pre>quo(1 + 1)
#&gt; &lt;quosure&gt;
#&gt; expr: ^1 + 1
#&gt; env:  global
</pre></div>
<p>You might have noticed that when constants are supplied, the quosure tracks the empty environment instead of the current environmnent.
</p>
<div class="sourceCode r"><pre>quos("foo", 1, NULL)
#&gt; &lt;list_of&lt;quosure&gt;&gt;
#&gt;
#&gt; [[1]]
#&gt; &lt;quosure&gt;
#&gt; expr: ^"foo"
#&gt; env:  empty
#&gt;
#&gt; [[2]]
#&gt; &lt;quosure&gt;
#&gt; expr: ^1
#&gt; env:  empty
#&gt;
#&gt; [[3]]
#&gt; &lt;quosure&gt;
#&gt; expr: ^NULL
#&gt; env:  empty
</pre></div>
<p>The reason for this has to do with compilation of R code which makes it impossible to consistently capture environments of constants from function arguments. Argument defusing relies on the <em>promise</em> mechanism of R for lazy evaluation of arguments. When functions are compiled and R notices that an argument is constant, it avoids creating a promise since they slow down function evaluation. Instead, the function is directly supplied a naked constant instead of constant wrapped in a promise.
</p>


<h3>Concrete case of promise unwrapping by compilation</h3>

<p>We can observe this optimisation by calling into the C-level <code>findVar()</code> function to capture promises.
</p>
<div class="sourceCode r"><pre># Return the object bound to `arg` without triggering evaluation of
# promises
f &lt;- function(arg) {
  rlang:::find_var(current_env(), sym("arg"))
}

# Call `f()` with a symbol or with a constant
g &lt;- function(symbolic) {
  if (symbolic) {
    f(letters)
  } else {
    f("foo")
  }
}

# Make sure these small functions are compiled
f &lt;- compiler::cmpfun(f)
g &lt;- compiler::cmpfun(g)
</pre></div>
<p>When <code>f()</code> is called with a symbolic argument, we get the promise object created by R.
</p>
<div class="sourceCode r"><pre>g(symbolic = TRUE)
#&gt; &lt;promise: 0x7ffd79bac130&gt;
</pre></div>
<p>However, supplying a constant to <code>"f"</code> returns the constant directly.
</p>
<div class="sourceCode r"><pre>g(symbolic = FALSE)
#&gt; [1] "foo"
</pre></div>
<p>Without a promise, there is no way to figure out the original environment of an argument.
</p>


<h3>Do we need environments for constants?</h3>

<p>Data-masking APIs in the tidyverse are intentionally designed so that they don't need an environment for constants.
</p>

<ul>
<li><p> Data-masking APIs should be able to interpret constants. These can arise from normal argument passing as we have seen, or by <a href="rlang.html#topic+topic-inject">injection</a> with <code style="white-space: pre;">&#8288;!!&#8288;</code>. There should be no difference between <code>dplyr::mutate(mtcars, var = cyl)</code> and <code>dplyr::mutate(mtcars, var = !!mtcars$cyl)</code>.
</p>
</li>
<li><p> Data-masking is an <em>evaluation</em> idiom, not an <em>introspective</em> one. The behaviour of data-masking function should not depend on the calling environment when a constant (or a symbol evaluating to a given value) is supplied.
</p>
</li></ul>


<hr>
<h2 id='topic-embrace-non-args'>Does <code style="white-space: pre;">&#8288;{{&#8288;</code> work on regular objects?</h2><span id='topic+topic-embrace-non-args'></span>

<h3>Description</h3>

<p>The embrace operator <code><a href="rlang.html#topic+embrace-operator">{{</a></code> should be used exclusively with function arguments:
</p>
<div class="sourceCode r"><pre>fn &lt;- function(arg) {
  quo(foo({{ arg }}))
}

fn(1 + 1)
#&gt; &lt;quosure&gt;
#&gt; expr: ^foo(^1 + 1)
#&gt; env:  0x7ffd89aac518
</pre></div>
<p>However you may have noticed that it also works on regular objects:
</p>
<div class="sourceCode r"><pre>fn &lt;- function(arg) {
  arg &lt;- force(arg)
  quo(foo({{ arg }}))
}

fn(1 + 1)
#&gt; &lt;quosure&gt;
#&gt; expr: ^foo(^2)
#&gt; env:  0x7ffd8a633398
</pre></div>
<p>In that case, <code style="white-space: pre;">&#8288;{{&#8288;</code> captures the <em>value</em> of the expression instead of a defused expression. That's because only function arguments can be defused.
</p>
<p>Note that this issue also applies to <code><a href="dplyr.html#topic+enquo">enquo()</a></code> (on which <code style="white-space: pre;">&#8288;{{&#8288;</code> is based).
</p>


<h3>Why is this not an error?</h3>

<p>Ideally we would have made <code style="white-space: pre;">&#8288;{{&#8288;</code> on regular objects an error.  However this is not possible because in compiled R code it is not always possible to distinguish a regular variable from a function argument. See <a href="rlang.html#topic+topic-embrace-constants">Why are strings and other constants enquosed in the empty environment?</a> for more about this.
</p>

<hr>
<h2 id='topic-error-call'>Including function calls in error messages</h2><span id='topic+topic-error-call'></span>

<h3>Description</h3>

<p>Starting with rlang 1.0, <code>abort()</code> includes the erroring function in the message by default:
</p>
<div class="sourceCode r"><pre>my_function &lt;- function() {
  abort("Can't do that.")
}

my_function()
#&gt; Error in `my_function()`:
#&gt; ! Can't do that.
</pre></div>
<p>This works well when <code>abort()</code> is called directly within the failing function. However, when the <code>abort()</code> call is exported to another function (which we call an &quot;error helper&quot;), we need to be explicit about which function <code>abort()</code> is throwing an error for.
</p>


<h3>Passing the user context</h3>

<p>There are two main kinds of error helpers:
</p>

<ul>
<li><p> Simple <code>abort()</code> wrappers. These often aim at adding classes and attributes to an error condition in a structured way:
</p>
<div class="sourceCode r"><pre>stop_my_class &lt;- function(message) {
  abort(message, class = "my_class")
}
</pre></div>
</li>
<li><p> Input checking functions. An input checker is typically passed an input and an argument name. It throws an error if the input doesn't conform to expectations:
</p>
<div class="sourceCode r"><pre>check_string &lt;- function(x, arg = "x") {
  if (!is_string(x)) {
    cli::cli_abort("{.arg {arg}} must be a string.")
  }
}
</pre></div>
</li></ul>

<p>In both cases, the default error call is not very helpful to the end user because it reflects an internal function rather than a user function:
</p>
<div class="sourceCode r"><pre>my_function &lt;- function(x) {
  check_string(x)
  stop_my_class("Unimplemented")
}
</pre></div>
<div class="sourceCode r"><pre>my_function(NA)
#&gt; Error in `check_string()`:
#&gt; ! `x` must be a string.
</pre></div>
<div class="sourceCode r"><pre>my_function("foo")
#&gt; Error in `stop_my_class()`:
#&gt; ! Unimplemented
</pre></div>
<p>To fix this, let <code>abort()</code> knows about the function that it is throwing the error for by passing the corresponding function environment as <code>call</code> argument:
</p>
<div class="sourceCode r"><pre>stop_my_class &lt;- function(message, call = caller_env()) {
  abort(message, class = "my_class", call = call)
}

check_string &lt;- function(x, arg = "x", call = caller_env()) {
  if (!is_string(x)) {
    cli::cli_abort("{.arg {arg}} must be a string.", call = call)
  }
}
</pre></div>
<div class="sourceCode r"><pre>my_function(NA)
#&gt; Error in `my_function()`:
#&gt; ! `x` must be a string.
</pre></div>
<div class="sourceCode r"><pre>my_function("foo")
#&gt; Error in `my_function()`:
#&gt; ! Unimplemented
</pre></div>


<h4>Input checkers and <code>caller_arg()</code></h4>

<p>The <code>caller_arg()</code> helper is useful in input checkers which check an input on the behalf of another function. Instead of hard-coding <code>arg = "x"</code>, and forcing the callers to supply it if <code>"x"</code> is not the name of the argument being checked, use <code>caller_arg()</code>.
</p>
<div class="sourceCode r"><pre>check_string &lt;- function(x,
                         arg = caller_arg(x),
                         call = caller_env()) {
  if (!is_string(x)) {
    cli::cli_abort("{.arg {arg}} must be a string.", call = call)
  }
}
</pre></div>
<p>It is a combination of <code>substitute()</code> and <code>rlang::as_label()</code> which provides a more generally applicable default:
</p>
<div class="sourceCode r"><pre>my_function &lt;- function(my_arg) {
  check_string(my_arg)
}

my_function(NA)
#&gt; Error in `my_function()`:
#&gt; ! `my_arg` must be a string.
</pre></div>



<h3>Side benefit: backtrace trimming</h3>

<p>Another benefit of passing <code>caller_env()</code> as <code>call</code> is that it allows <code>abort()</code> to automatically hide the error helpers
</p>
<div class="sourceCode r"><pre>my_function &lt;- function() {
  their_function()
}
their_function &lt;- function() {
  error_helper1()
}

error_helper1 &lt;- function(call = caller_env()) {
  error_helper2(call = call)
}
error_helper2 &lt;- function(call = caller_env()) {
  if (use_call) {
    abort("Can't do this", call = call)
  } else {
    abort("Can't do this")
  }
}
</pre></div>
<div class="sourceCode r"><pre>use_call &lt;- FALSE
their_function()
#&gt; Error in `error_helper2()`:
#&gt; ! Can't do this
</pre></div>
<div class="sourceCode r"><pre>rlang::last_error()
#&gt; &lt;error/rlang_error&gt;
#&gt; Error in `error_helper2()`:
#&gt; ! Can't do this
#&gt; ---
#&gt; Backtrace:
#&gt;     x
#&gt;  1. \-rlang (local) their_function()
#&gt;  2.   \-rlang (local) error_helper1()
#&gt;  3.     \-rlang (local) error_helper2(call = call)
#&gt; Run rlang::last_trace(drop = FALSE) to see 1 hidden frame.
</pre></div>
<p>With the correct <code>call</code>, the backtrace is much simpler and let the user focus on the part of the stack that is relevant to them:
</p>
<div class="sourceCode r"><pre>use_call &lt;- TRUE
their_function()
#&gt; Error in `their_function()`:
#&gt; ! Can't do this
</pre></div>
<div class="sourceCode r"><pre>rlang::last_error()
#&gt; &lt;error/rlang_error&gt;
#&gt; Error in `their_function()`:
#&gt; ! Can't do this
#&gt; ---
#&gt; Backtrace:
#&gt;     x
#&gt;  1. \-rlang (local) their_function()
#&gt; Run rlang::last_trace(drop = FALSE) to see 3 hidden frames.
</pre></div>


<h3>testthat workflow</h3>

<p>Error snapshots are the main way of checking that the correct error call is included in an error message. However you'll need to opt into a new testthat display for warning and error snapshots. With the new display, these are printed by rlang, including the <code>call</code> field. This makes it easy to monitor the full appearance of warning and error messages as they are displayed to users.
</p>
<p>This display is not applied to all packages yet. With testthat 3.1.2, depend explicitly on rlang &gt;= 1.0.0 to opt in. Starting from testthat 3.1.3, depending on rlang, no matter the version, is sufficient to opt in. In the future, the new display will be enabled for all packages.
</p>
<p>Once enabled, create error snapshots with:
</p>
<div class="sourceCode r"><pre>expect_snapshot(error = TRUE, {
  my_function()
})

expect_snapshot_error(my_function())
</pre></div>
<p>You'll have to make sure that the snapshot coverage for error messages is sufficient for your package.
</p>

<hr>
<h2 id='topic-error-chaining'>Including contextual information with error chains</h2><span id='topic+topic-error-chaining'></span>

<h3>Description</h3>

<p>Error chaining is a mechanism for providing contextual information when an error occurs. There are multiple situations in which you might be able to provide context that is helpful to quickly understand the cause or origin of an error:
</p>

<ul>
<li><p> Mentioning the <em>high level context</em> in which a low level error arised. E.g. chaining a low-level HTTP error to a high-level download error.
</p>
</li>
<li><p> Mentioning the <em>pipeline step</em> in which a user error occured. This is a major use-case for NSE interfaces in the tidyverse, e.g. in dplyr, tidymodels or ggplot2.
</p>
</li>
<li><p> Mentioning the <em>iteration context</em> in which a user error occurred. For instance, the input file when processing documents, or the iteration number or key when running user code in a loop.
</p>
</li></ul>

<p>Here is an example of a chained error from dplyr that shows the pipeline step (<code>mutate()</code>) and the iteration context (group ID) in which a function called by the user failed:
</p>
<div class="sourceCode r"><pre>add &lt;- function(x, y) x + y

mtcars |&gt;
  dplyr::group_by(cyl) |&gt;
  dplyr::mutate(new = add(disp, "foo"))
#&gt; Error in `dplyr::mutate()`:
#&gt; i In argument: `new = add(disp, "foo")`.
#&gt; i In group 1: `cyl = 4`.
#&gt; Caused by error in `x + y`:
#&gt; ! non-numeric argument to binary operator
</pre></div>
<p>In all these cases, there are two errors in play, chained together:
</p>

<ol>
<li><p> The <strong>causal error</strong>, which interrupted the current course of action.
</p>
</li>
<li><p> The <strong>contextual error</strong>, which expresses higher-level information when something goes wrong.
</p>
</li></ol>

<p>There may be more than one contextual error in an error chain, but there is always only one causal error.
</p>


<h3>Rethrowing errors</h3>

<p>To create an error chain, you must first capture causal errors when they occur. We recommend using <code>try_fetch()</code> instead of <code>tryCatch()</code> or <code>withCallingHandlers()</code>.
</p>

<ul>
<li><p> Compared to <code>tryCatch()</code>, <code>try_fetch()</code> fully preserves the context of the error. This is important for debugging because it ensures complete backtraces are reported to users (e.g. via <code>last_error()</code>) and allows <code>options(error = recover)</code> to reach into the deepest error context.
</p>
</li>
<li><p> Compared to <code>withCallingHandlers()</code>, which also preserves the error context, <code>try_fetch()</code> is able to catch stack overflow errors on R versions &gt;= 4.2.0.
</p>
</li></ul>

<p>In practice, <code>try_fetch()</code> works just like <code>tryCatch()</code>. It takes pairs of error class names and handling functions. To chain an error, simply rethrow it from an error handler by passing it as <code>parent</code> argument.
</p>
<p>In this example, we'll create a <code>with_</code> function. That is, a function that sets up some configuration (in this case, chained errors) before executing code supplied as input:
</p>
<div class="sourceCode r"><pre>with_chained_errors &lt;- function(expr) {
  try_fetch(
    expr,
    error = function(cnd) {
      abort("Problem during step.", parent = cnd)
    }
  )
}

with_chained_errors(1 + "")
#&gt; Error in `with_chained_errors()`:
#&gt; ! Problem during step.
#&gt; Caused by error in `1 + ""`:
#&gt; ! non-numeric argument to binary operator
</pre></div>
<p>Typically, you'll use this error helper from another user-facing function.
</p>
<div class="sourceCode r"><pre>my_verb &lt;- function(expr) {
  with_chained_errors(expr)
}

my_verb(add(1, ""))
#&gt; Error in `with_chained_errors()`:
#&gt; ! Problem during step.
#&gt; Caused by error in `x + y`:
#&gt; ! non-numeric argument to binary operator
</pre></div>
<p>Altough we have created a chained error, the error call of the contextual error is not quite right. It mentions the name of the error helper instead of the name of the user-facing function.
</p>
<p>If you've read <a href="rlang.html#topic+topic-error-call">Including function calls in error messages</a>, you may suspect that we need to pass a <code>call</code> argument to <code>abort()</code>. That's exactly what needs to happen to fix the call and backtrace issues:
</p>
<div class="sourceCode r"><pre>with_chained_errors &lt;- function(expr, call = caller_env()) {
  try_fetch(
    expr,
    error = function(cnd) {
      abort("Problem during step.", parent = cnd, call = call)
    }
  )
}
</pre></div>
<p>Now that we've passed the caller environment as <code>call</code> argument, <code>abort()</code> automatically picks up the correspondin function call from the execution frame:
</p>
<div class="sourceCode r"><pre>my_verb(add(1, ""))
#&gt; Error in `my_verb()`:
#&gt; ! Problem during step.
#&gt; Caused by error in `x + y`:
#&gt; ! non-numeric argument to binary operator
</pre></div>


<h4>Side note about missing arguments</h4>

<p><code>my_verb()</code> is implemented with a lazy evaluation pattern. The user input kept unevaluated until the error chain context is set up. A downside of this arrangement is that missing argument errors are reported in the wrong context:
</p>
<div class="sourceCode r"><pre>my_verb()
#&gt; Error in `my_verb()`:
#&gt; ! Problem during step.
#&gt; Caused by error in `my_verb()`:
#&gt; ! argument "expr" is missing, with no default
</pre></div>
<p>To fix this, simply require these arguments before setting up the chained error context, for instance with the <code>check_required()</code> input checker exported from rlang:
</p>
<div class="sourceCode r"><pre>my_verb &lt;- function(expr) {
  check_required(expr)
  with_chained_errors(expr)
}

my_verb()
#&gt; Error in `my_verb()`:
#&gt; ! `expr` is absent but must be supplied.
</pre></div>



<h3>Taking full ownership of a causal error</h3>

<p>It is also possible to completely take ownership of a causal error and rethrow it with a more user-friendly error message. In this case, the original error is completely hidden from the end user. Opting for his approach instead of chaining should be carefully considered because hiding the causal error may deprive users from precious debugging information.
</p>

<ul>
<li><p> In general, hiding <em>user errors</em> (e.g. dplyr inputs) in this way is likely a bad idea.
</p>
</li>
<li><p> It may be appropriate to hide low-level errors, e.g. replacing HTTP errors by a high-level download error. Similarly, tidyverse packages like dplyr are replacing low-level vctrs errors with higher level errors of their own crafting.
</p>
</li>
<li><p> Hiding causal errors indiscriminately should likely be avoided because it may suppress information about unexpected errors. In general, rethrowing an unchained errors should only be done with specific error classes.
</p>
</li></ul>

<p>To rethow an error without chaining it, and completely take over the causal error from the user point of view, fetch it with <code>try_fetch()</code> and throw a new error. The only difference with throwing a chained error is that the <code>parent</code> argument is set to <code>NA</code>. You could also omit the <code>parent</code> argument entirely, but passing <code>NA</code> lets <code>abort()</code> know it is rethrowing an error from a handler and that it should hide the corresponding error helpers in the backtrace.
</p>
<div class="sourceCode r"><pre>with_own_scalar_errors &lt;- function(expr, call = caller_env()) {
  try_fetch(
    expr,
    vctrs_error_scalar_type = function(cnd) {
      abort(
        "Must supply a vector.",
        parent = NA,
        error = cnd,
        call = call
      )
    }
  )
}

my_verb &lt;- function(expr) {
  check_required(expr)
  with_own_scalar_errors(
    vctrs::vec_assert(expr)
  )
}

my_verb(env())
#&gt; Error in `my_verb()`:
#&gt; ! Must supply a vector.
</pre></div>
<p>When a low-level error is overtaken, it is good practice to store it in the high-level error object, so that it can be inspected for debugging purposes. In the snippet above, we stored it in the <code>error</code> field. Here is one way of accessing the original error by subsetting the object returned by <code>last_error()</code>:
</p>
<div class="sourceCode r"><pre>rlang::last_error()$error
#&gt; &lt;error/vctrs_error_scalar_type&gt;
#&gt; Error in `my_verb()`:
#&gt; ! `expr` must be a vector, not an environment.
#&gt; ---
#&gt; Backtrace:
#&gt;     x
#&gt;  1. \-rlang (local) my_verb(env())
</pre></div>


<h3>Case study: Mapping with chained errors</h3>

<p>One good use case for chained errors is adding information about the iteration state when looping over a set of inputs. To illustrate this, we'll implement a version of <code>map()</code> / <code>lapply()</code> that chains an iteration error to any captured user error.
</p>
<p>Here is a minimal implementation of <code>map()</code>:
</p>
<div class="sourceCode r"><pre>my_map &lt;- function(.xs, .fn, ...) {
  out &lt;- new_list(length(.xs))

  for (i in seq_along(.xs)) {
    out[[i]] &lt;- .fn(.xs[[i]], ...)
  }

  out
}

list(1, 2) |&gt; my_map(add, 100)
#&gt; [[1]]
#&gt; [1] 101
#&gt; 
#&gt; [[2]]
#&gt; [1] 102
</pre></div>
<p>With this implementation, the user has no idea which iteration failed when an error occurs:
</p>
<div class="sourceCode r"><pre>list(1, "foo") |&gt; my_map(add, 100)
#&gt; Error in `x + y`:
#&gt; ! non-numeric argument to binary operator
</pre></div>


<h4>Rethrowing with iteration information</h4>

<p>To improve on this we'll wrap the loop in a <code>try_fetch()</code> call that rethrow errors with iteration information. Make sure to call <code>try_fetch()</code> on the outside of the loop to avoid a massive performance hit:
</p>
<div class="sourceCode r"><pre>my_map &lt;- function(.xs, .fn, ...) {
  out &lt;- new_list(length(.xs))
  i &lt;- 0L

  try_fetch(
    for (i in seq_along(.xs)) {
      out[[i]] &lt;- .fn(.xs[[i]], ...)
    },
    error = function(cnd) {
      abort(
        sprintf("Problem while mapping element %d.", i),
        parent = cnd
      )
    }
  )

  out
}
</pre></div>
<p>And that's it, the error chain created by the rethrowing handler now provides users with the number of the failing iteration:
</p>
<div class="sourceCode r"><pre>list(1, "foo") |&gt; my_map(add, 100)
#&gt; Error in `my_map()`:
#&gt; ! Problem while mapping element 2.
#&gt; Caused by error in `x + y`:
#&gt; ! non-numeric argument to binary operator
</pre></div>



<h4>Dealing with errors thrown from the mapped function</h4>

<p>One problem though, is that the user error call is not very informative when the error occurs immediately in the function supplied to <code>my_map()</code>:
</p>
<div class="sourceCode r"><pre>my_function &lt;- function(x) {
  if (!is_string(x)) {
    abort("`x` must be a string.")
  }
}

list(1, "foo") |&gt; my_map(my_function)
#&gt; Error in `my_map()`:
#&gt; ! Problem while mapping element 1.
#&gt; Caused by error in `.fn()`:
#&gt; ! `x` must be a string.
</pre></div>
<p>Functions have no names by themselves. Only the variable that refers to the function has a name. In this case, the mapped function is passed by argument to the variable <code>.fn</code>. So, when an error happens, this is the name that is reported to users.
</p>
<p>One approach to fix this is to inspect the <code>call</code> field of the error. When we detect a <code>.fn</code> call, we replace it by the defused code supplied as <code>.fn</code> argument:
</p>
<div class="sourceCode r"><pre>my_map &lt;- function(.xs, .fn, ...) {
  # Capture the defused code supplied as `.fn`
  fn_code &lt;- substitute(.fn)

  out &lt;- new_list(length(.xs))

  for (i in seq_along(.xs)) {
    try_fetch(
      out[[i]] &lt;- .fn(.xs[[i]], ...),
      error = function(cnd) {
        # Inspect the `call` field to detect `.fn` calls
        if (is_call(cnd$call, ".fn")) {
          # Replace `.fn` by the defused code.
          # Keep existing arguments.
          cnd$call[[1]] &lt;- fn_code
        }
        abort(
          sprintf("Problem while mapping element %s.", i),
          parent = cnd
        )
      }
    )
  }

  out
}
</pre></div>
<p>And voilà!
</p>
<div class="sourceCode r"><pre>list(1, "foo") |&gt; my_map(my_function)
#&gt; Error in `my_map()`:
#&gt; ! Problem while mapping element 1.
#&gt; Caused by error in `my_function()`:
#&gt; ! `x` must be a string.
</pre></div>


<hr>
<h2 id='topic-inject'>Injecting with <code style="white-space: pre;">&#8288;!!&#8288;</code>, <code style="white-space: pre;">&#8288;!!!&#8288;</code>, and glue syntax</h2><span id='topic+topic-inject'></span><span id='topic+quasiquotation'></span><span id='topic+nse-force'></span><span id='topic+nse-inject'></span>

<h3>Description</h3>

<p>The injection operators are extensions of R implemented by rlang to modify a piece of code before R processes it. There are two main families:
</p>

<ul>
<li><p> The <a href="rlang.html#topic+dyn-dots">dynamic dots</a> operators, <code><a href="rlang.html#topic++21+21+21">!!!</a></code> and <code><a href="rlang.html#topic+glue-operators">&quot;{&quot;</a></code>.
</p>
</li>
<li><p> The <a href="rlang.html#topic+topic-metaprogramming">metaprogramming operators</a> <code><a href="rlang.html#topic++21+21">!!</a></code>, <code><a href="rlang.html#topic+embrace-operator">{{</a></code>, and <code><a href="rlang.html#topic+glue-operators">&quot;{{&quot;</a></code>. Splicing with <code><a href="rlang.html#topic++21+21+21">!!!</a></code> can also be done in metaprogramming context.
</p>
</li></ul>



<h3>Dots injection</h3>

<p>Unlike regular <code>...</code>, <a href="rlang.html#topic+dyn-dots">dynamic dots</a> are programmable with injection operators.
</p>


<h4>Splicing with <code style="white-space: pre;">&#8288;!!!&#8288;</code></h4>

<p>For instance, take a function like <code>rbind()</code> which takes data in <code>...</code>. To bind rows, you supply them as separate arguments:
</p>
<div class="sourceCode r"><pre>rbind(a = 1:2, b = 3:4)
#&gt;   [,1] [,2]
#&gt; a    1    2
#&gt; b    3    4
</pre></div>
<p>But how do you bind a variable number of rows stored in a list? The base R solution is to invoke <code>rbind()</code> with <code>do.call()</code>:
</p>
<div class="sourceCode r"><pre>rows &lt;- list(a = 1:2, b = 3:4)

do.call("rbind", rows)
#&gt;   [,1] [,2]
#&gt; a    1    2
#&gt; b    3    4
</pre></div>
<p>Functions that implement dynamic dots include a built-in way of folding a list of arguments in <code>...</code>. To illustrate this, we'll create a variant of <code>rbind()</code> that takes dynamic dots by collecting <code>...</code> with <code><a href="rlang.html#topic+list2">list2()</a></code>:
</p>
<div class="sourceCode r"><pre>rbind2 &lt;- function(...) {
  do.call("rbind", list2(...))
}
</pre></div>
<p>It can be used just like <code>rbind()</code>:
</p>
<div class="sourceCode r"><pre>rbind2(a = 1:2, b = 3:4)
#&gt;   [,1] [,2]
#&gt; a    1    2
#&gt; b    3    4
</pre></div>
<p>And a list of arguments can be supplied by <em>splicing</em> the list with <code><a href="rlang.html#topic++21+21+21">!!!</a></code>:
</p>
<div class="sourceCode r"><pre>rbind2(!!!rows, c = 5:6)
#&gt;   [,1] [,2]
#&gt; a    1    2
#&gt; b    3    4
#&gt; c    5    6
</pre></div>



<h4>Injecting names with <code style="white-space: pre;">&#8288;"{"&#8288;</code></h4>

<p>A related problem comes up when an argument name is stored in a variable. With dynamic dots, you can inject the name using <a href="https://glue.tidyverse.org/">glue syntax</a> with <code><a href="rlang.html#topic+glue-operators">&quot;{&quot;</a></code>:
</p>
<div class="sourceCode r"><pre>name &lt;- "foo"

rbind2("{name}" := 1:2, bar = 3:4)
#&gt;     [,1] [,2]
#&gt; foo    1    2
#&gt; bar    3    4

rbind2("prefix_{name}" := 1:2, bar = 3:4)
#&gt;            [,1] [,2]
#&gt; prefix_foo    1    2
#&gt; bar           3    4
</pre></div>



<h3>Metaprogramming injection</h3>

<p><a href="rlang.html#topic+topic-data-mask">Data-masked</a> arguments support the following injection operators. They can also be explicitly enabled with <code><a href="rlang.html#topic+inject">inject()</a></code>.
</p>


<h4>Embracing with <code style="white-space: pre;">&#8288;{{&#8288;</code></h4>

<p>The embracing operator <code><a href="rlang.html#topic+embrace-operator">{{</a></code> is made specially for function arguments. It <a href="rlang.html#topic+topic-defuse">defuses</a> the expression supplied as argument and immediately injects it in place. The injected argument is then evaluated in another context such as a <a href="rlang.html#topic+topic-data-mask">data mask</a>.
</p>
<div class="sourceCode r"><pre># Inject function arguments that might contain
# data-variables by embracing them with {{ }}
mean_by &lt;- function(data, by, var) {
  data %&gt;%
    dplyr::group_by({{ by }}) %&gt;%
    dplyr::summarise(avg = mean({{ var }}, na.rm = TRUE))
}

# The data-variables `cyl` and `disp` inside the
# env-variables `by` and `var` are injected inside `group_by()`
# and `summarise()`
mtcars %&gt;% mean_by(by = cyl, var = disp)
#&gt; # A tibble: 3 x 2
#&gt;     cyl   avg
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     4  105.
#&gt; 2     6  183.
#&gt; 3     8  353.
</pre></div>
<p>Learn more about this pattern in <a href="rlang.html#topic+topic-data-mask-programming">Data mask programming patterns</a>.
</p>



<h4>Injecting with <code style="white-space: pre;">&#8288;!!&#8288;</code></h4>

<p>Unlike <code><a href="rlang.html#topic++21+21+21">!!!</a></code> which injects a list of arguments, the injection operator <code><a href="rlang.html#topic++21+21">!!</a></code> (pronounced &quot;bang-bang&quot;) injects a <em>single</em> object. One use case for <code style="white-space: pre;">&#8288;!!&#8288;</code>  is to substitute an environment-variable (created with <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>) with a data-variable (inside a data frame).
</p>
<div class="sourceCode r"><pre># The env-variable `var` contains a data-symbol object, in this
# case a reference to the data-variable `height`
var &lt;- data_sym("disp")

# We inject the data-variable contained in `var` inside `summarise()` 
mtcars %&gt;%
  dplyr::summarise(avg = mean(!!var, na.rm = TRUE))
#&gt; # A tibble: 1 x 1
#&gt;     avg
#&gt;   &lt;dbl&gt;
#&gt; 1  231.
</pre></div>
<p>Another use case is to inject a variable by value to avoid <a href="rlang.html#topic+topic-data-mask-ambiguity">name collisions</a>.
</p>
<div class="sourceCode r"><pre>df &lt;- data.frame(x = 1)

# This name conflicts with a column in `df`
x &lt;- 100

# Inject the env-variable
df %&gt;%
  dplyr::mutate(x = x / !!x)
#&gt;      x
#&gt; 1 0.01
</pre></div>
<p>Note that in most cases you don't need injection with <code style="white-space: pre;">&#8288;!!&#8288;</code>. For instance, the <code><a href="dplyr.html#topic+.data">.data</a></code> and <code><a href="igraph.html#topic+.env">.env</a></code> pronouns provide more intuitive alternatives to injecting a column name and injecting a value.
</p>



<h4>Splicing with <code style="white-space: pre;">&#8288;!!!&#8288;</code></h4>

<p>The splice operator <code><a href="rlang.html#topic++21+21+21">!!!</a></code> of dynamic dots can also be used in metaprogramming context (inside <a href="rlang.html#topic+topic-data-mask">data-masked</a> arguments and inside <code><a href="rlang.html#topic+inject">inject()</a></code>). For instance, we could reimplement the <code>rbind2()</code> function presented above using <code>inject()</code> instead of <code>do.call()</code>:
</p>
<div class="sourceCode r"><pre>rbind2 &lt;- function(...) {
  inject(rbind(!!!list2(...)))
}
</pre></div>
<p>There are two things going on here. We collect <code>...</code> with <code><a href="rlang.html#topic+list2">list2()</a></code> so that the callers of <code>rbind2()</code> may use <code style="white-space: pre;">&#8288;!!!&#8288;</code>. And we use <code>inject()</code> so that <code>rbind2()</code> itself may use <code style="white-space: pre;">&#8288;!!!&#8288;</code> to splice the list of arguments passed to <code>rbind2()</code>.
</p>



<h3>Injection in other languages</h3>

<p>Injection is known as <strong>quasiquotation</strong> in other programming languages and in computer science. <code>expr()</code> is similar to a quasiquotation operator and <code style="white-space: pre;">&#8288;!!&#8288;</code> is the unquote operator. These terms have a rich history in Lisp languages, and live on in modern languages like <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">Julia</a> and <a href="https://docs.racket-lang.org/reference/quasiquote.html">Racket</a>. In base R, quasiquotation is performed with <code><a href="base.html#topic+bquote">bquote()</a></code>.
</p>
<p>The main difference between rlang and other languages is that quasiquotation is often implicit instead of explicit. You can use injection operators in any defusing / quoting function (unless that function defuses its argument with a special operator like <code><a href="rlang.html#topic+enquo0">enquo0()</a></code>). This is not the case in lisp languages for example where injection / unquoting is explicit and only enabled within a backquote.
</p>


<h3>See also</h3>


<ul>
<li> <p><a href="rlang.html#topic+topic-inject-out-of-context">What happens if I use injection operators out of context?</a>
</p>
</li></ul>


<hr>
<h2 id='topic-inject-out-of-context'>What happens if I use injection operators out of context?</h2><span id='topic+topic-inject-out-of-context'></span>

<h3>Description</h3>

<p>The <a href="rlang.html#topic+topic-inject">injection operators</a> <code><a href="rlang.html#topic+embrace-operator">{{</a></code>, <code><a href="rlang.html#topic+injection-operator">!!</a></code>, and <code><a href="rlang.html#topic+splice-operator">!!!</a></code> are an extension of the R syntax developed for tidyverse packages. Because they are not part of base R, they suffer from some limitations. In particular no specific error is thrown when they are used in unexpected places.
</p>


<h4>Using <code style="white-space: pre;">&#8288;{{&#8288;</code> out of context</h4>

<p>The embrace operator <code><a href="rlang.html#topic+embrace-operator">{{</a></code> is a feature available in <a href="rlang.html#topic+topic-data-mask">data-masked</a> arguments powered by tidy eval. If you use it elsewhere, it is interpreted as a double <code style="white-space: pre;">&#8288;{&#8288;</code> wrapping.
</p>
<p>In the R language, <code style="white-space: pre;">&#8288;{&#8288;</code> is like <code>(</code> but takes multiple expressions instead of one:
</p>
<div class="sourceCode r"><pre>{
  1 # Discarded
  2
}
#&gt; [1] 2

list(
  { message("foo"); 2 }
)
#&gt; foo
#&gt; [[1]]
#&gt; [1] 2
</pre></div>
<p>Just like you can wrap an expression in as many parentheses as you'd like, you can wrap multiple times with braces:
</p>
<div class="sourceCode r"><pre>((1))
#&gt; [1] 1

{{ 2 }}
#&gt; [1] 2
</pre></div>
<p>So nothing prevents you from embracing a function argument in a context where this operation is not implemented. R will just treat the braces like a set of parentheses and silently return the result:
</p>
<div class="sourceCode r"><pre>f &lt;- function(arg) list({{ arg }})
f(1)
#&gt; [[1]]
#&gt; [1] 1
</pre></div>
<p>This sort of no-effect embracing should be avoided in real code because it falsely suggests that the function supports the tidy eval operator and that something special is happening.
</p>
<p>However in many cases embracing is done to implement <a href="rlang.html#topic+topic-data-mask">data masking</a>. It is likely that the function will be called with data-variables references which R won't be able to resolve properly:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  with(data, mean({{ var }}))
}

my_mean(mtcars, cyl)
#&gt; Error:
#&gt; ! object 'cyl' not found
</pre></div>
<p>Since <code><a href="base.html#topic+with">with()</a></code> is a base data-masking function that doesn't support tidy eval operators, the embrace operator does not work and we get an object not found error.
</p>



<h4>Using <code style="white-space: pre;">&#8288;!!&#8288;</code> and <code style="white-space: pre;">&#8288;!!!&#8288;</code> out of context</h4>

<p>The injection operators <code><a href="rlang.html#topic++21+21">!!</a></code> and <code><a href="rlang.html#topic++21+21+21">!!!</a></code> are implemented in <a href="rlang.html#topic+topic-data-mask">data-masked</a> arguments, <a href="rlang.html#topic+dyn-dots">dynamic dots</a>, and within <code><a href="rlang.html#topic+inject">inject()</a></code>. When used in other contexts, they are interpreted by R as double and triple <em>negations</em>.
</p>
<p>Double negation can be used in ordinary code to convert an input to logical:
</p>
<div class="sourceCode r"><pre>!!10
#&gt; [1] TRUE

!!0
#&gt; [1] FALSE
</pre></div>
<p>Triple negation is essentially the same as simple negation:
</p>
<div class="sourceCode r"><pre>!10
#&gt; [1] FALSE

!!!10
#&gt; [1] FALSE
</pre></div>
<p>This means that when injection operators are used in the wrong place, they will be interpreted as negation. In the best case scenario you will get a type error:
</p>
<div class="sourceCode r"><pre>!"foo"
#&gt; Error in `!"foo"`:
#&gt; ! invalid argument type

!quote(foo)
#&gt; Error in `!quote(foo)`:
#&gt; ! invalid argument type

!quote(foo())
#&gt; Error in `!quote(foo())`:
#&gt; ! invalid argument type
</pre></div>
<p>In the worst case, R will silently convert the input to logical. Unfortunately there is no systematic way of checking for these errors.
</p>


<hr>
<h2 id='topic-metaprogramming'>Metaprogramming patterns</h2><span id='topic+topic-metaprogramming'></span>

<h3>Description</h3>

<p>The patterns covered in this article rely on <em>metaprogramming</em>, the ability to defuse, create, expand, and inject R expressions. A good place to start if you're new to programming on the language is the <a href="https://adv-r.hadley.nz/metaprogramming.html">Metaprogramming chapter</a> of the <a href="https://adv-r.hadley.nz">Advanced R</a> book.
</p>
<p>If you haven't already, read <a href="rlang.html#topic+topic-data-mask-programming">Data mask programming patterns</a> which covers simpler patterns that do not require as much theory to get up to speed. It covers concepts like argument behaviours and the various patterns you can add to your toolbox (forwarding, names, bridge, and transformative patterns).
</p>


<h3>Forwarding patterns</h3>



<h4>Defuse and inject</h4>

<p><code><a href="rlang.html#topic+embrace-operator">{{</a></code> and <code>...</code> are sufficient for most purposes. Sometimes however, it is necessary to decompose the forwarding action into its two constitutive steps, <a href="rlang.html#topic+topic-defuse">defusing</a> and <a href="rlang.html#topic+topic-inject">injecting</a>.
</p>
<p><code style="white-space: pre;">&#8288;{{&#8288;</code> is the combination of <code><a href="dplyr.html#topic+enquo">enquo()</a></code> and <code><a href="rlang.html#topic+injection-operator">!!</a></code>. These functions are completely equivalent:
</p>
<div class="sourceCode r"><pre>my_summarise &lt;- function(data, var) {
  data %&gt;% dplyr::summarise({{ var }})
}
my_summarise &lt;- function(data, var) {
  data %&gt;% dplyr::summarise(!!enquo(var))
}
</pre></div>
<p>Passing <code>...</code> is equivalent to the combination of <code><a href="dplyr.html#topic+enquos">enquos()</a></code> and <code><a href="rlang.html#topic+splice-operator">!!!</a></code>:
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(.data, ...) {
  .data %&gt;% dplyr::group_by(...)
}
my_group_by &lt;- function(.data, ...) {
  .data %&gt;% dplyr::group_by(!!!enquos(...))
}
</pre></div>
<p>The advantage of decomposing the steps is that you gain access to the <a href="rlang.html#topic+topic-defuse">defused expressions</a>. Once defused, you can inspect or modify the expressions before injecting them in their target context.
</p>



<h4>Inspecting input labels</h4>

<p>For instance, here is how to create an automatic name for a defused argument using <code><a href="dplyr.html#topic+as_label">as_label()</a></code>:
</p>
<div class="sourceCode r"><pre>f &lt;- function(var) {
  var &lt;- enquo(var)
  as_label(var)
}

f(cyl)
#&gt; [1] "cyl"

f(1 + 1)
#&gt; [1] "1 + 1"
</pre></div>
<p>This is essentially equivalent to formatting an argument using <code><a href="rlang.html#topic+englue">englue()</a></code>:
</p>
<div class="sourceCode r"><pre>f2 &lt;- function(var) {
  englue("{{ var }}")
}

f2(1 + 1)
#&gt; [1] "1 + 1"
</pre></div>
<p>With multiple arguments, use the plural variant <code><a href="dplyr.html#topic+enquos">enquos()</a></code>. Set <code>.named</code> to <code>TRUE</code> to automatically call <code><a href="dplyr.html#topic+as_label">as_label()</a></code> on the inputs for which the user has not provided a name (the same behaviour as in most dplyr verbs):
</p>
<div class="sourceCode r"><pre>g &lt;- function(...) {
  vars &lt;- enquos(..., .named = TRUE)
  names(vars)
}

g(cyl, 1 + 1)
#&gt; [1] "cyl"   "1 + 1"
</pre></div>
<p>Just like with <code>dplyr::mutate()</code>, the user can override automatic names by supplying explicit names:
</p>
<div class="sourceCode r"><pre>g(foo = cyl, bar = 1 + 1)
#&gt; [1] "foo" "bar"
</pre></div>
<p>Defuse-and-inject patterns are most useful for transforming inputs. Some applications are explored in the Transformation patterns section.
</p>



<h3>Names patterns</h3>



<h4>Symbolise and inject</h4>

<p>The symbolise-and-inject pattern is a <em>names pattern</em> that you can use when <code>across(all_of())</code> is not supported. It consists in creating <a href="rlang.html#topic+topic-defuse">defused expressions</a> that refer to the data-variables represented in the names vector. These are then injected in the data mask context.
</p>
<p>Symbolise a single string with <code><a href="dplyr.html#topic+sym">sym()</a></code> or <code><a href="rlang.html#topic+data_sym">data_sym()</a></code>:
</p>
<div class="sourceCode r"><pre>var &lt;- "cyl"

sym(var)
#&gt; cyl

data_sym(var)
#&gt; .data$cyl
</pre></div>
<p>Symbolise a character vector with <code><a href="dplyr.html#topic+syms">syms()</a></code> or <code><a href="rlang.html#topic+data_syms">data_syms()</a></code>.
</p>
<div class="sourceCode r"><pre>vars &lt;- c("cyl", "am")

syms(vars)
#&gt; [[1]]
#&gt; cyl
#&gt; 
#&gt; [[2]]
#&gt; am

data_syms(vars)
#&gt; [[1]]
#&gt; .data$cyl
#&gt; 
#&gt; [[2]]
#&gt; .data$am
</pre></div>
<p>Simple symbols returned by <code>sym()</code> and <code>syms()</code> work in a wider variety of cases (with base functions in particular) but we'll use mostly use <code>data_sym()</code> and <code>data_syms()</code> because they are more robust (see <a href="rlang.html#topic+topic-data-mask-ambiguity">The data mask ambiguity</a>). Note that these do not return <em>symbols</em> per se, instead they create <em>calls</em> to <code>$</code> that subset the <code><a href="dplyr.html#topic+.data">.data</a></code> pronoun.
</p>
<p>Since the <code>.data</code> pronoun is a tidy eval feature, you can't use it in base functions. As a rule, prefer the <code>data_</code>-prefixed variants when you're injecting in tidy eval functions and the unprefixed functions for base functions.
</p>
<p>A list of symbols can be injected in data-masked dots with the splice operator <code><a href="rlang.html#topic+splice-operator">!!!</a></code>, which injects each element of the list as a separate argument. For instance, to implement a <code>group_by()</code> variant that takes a character vector of column names, you might write:
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(data, vars) {
  data %&gt;% dplyr::group_by(!!!data_syms(vars))
}

my_group_by(vars)
</pre></div>
<p>In more complex case, you might want to add R code around the symbols. This requires <em>transformation</em> patterns, see the section below.
</p>



<h3>Bridge patterns</h3>



<h4><code>mutate()</code> as a data-mask to selection bridge</h4>

<p>This is a variant of the <code>transmute()</code> bridge pattern described in <a href="rlang.html#topic+topic-data-mask-programming">Data mask programming patterns</a> that does not materialise <code>...</code> in the intermediate step. Instead, the <code>...</code> expressions are defused and inspected. Then the expressions, rather than the columns, are spliced in <code>mutate()</code>.
</p>
<div class="sourceCode r"><pre>my_pivot_longer &lt;- function(data, ...) {
  # Defuse the dots and inspect the names
  dots &lt;- enquos(..., .named = TRUE)
  names &lt;- names(dots)

  # Pass the inputs to `mutate()`
  data &lt;- data %&gt;% dplyr::mutate(!!!dots)

  # Select `...` inputs by name with `all_of()`
  data %&gt;%
    tidyr::pivot_longer(cols = all_of(names))
}

mtcars %&gt;% my_pivot_longer(cyl, am = am * 100)
</pre></div>

<ol>
<li><p> Defuse the <code>...</code> expressions. The <code>.named</code> argument ensures unnamed inputs get a default name, just like they would if passed to <code>mutate()</code>. Take the names of the list of inputs.
</p>
</li>
<li><p> Once we have the names, inject the argument expressions into <code>mutate()</code> to update the data frame.
</p>
</li>
<li><p> Finally, pass the names to the tidy selection via <a href="https://tidyselect.r-lib.org/reference/all_of.html"><code>all_of()</code></a>.
</p>
</li></ol>




<h3>Transformation patterns</h3>



<h4>Transforming inputs manually</h4>

<p>If <code>across()</code> and variants are not available, you will need to transform the inputs yourself using metaprogramming techniques. To illustrate the technique we'll reimplement <code>my_mean()</code> and without using <code>across()</code>. The pattern consists in defusing the input expression, building larger calls around them, and finally inject the modified expressions inside the data-masking functions.
</p>
<p>We'll start with a single named argument for simplicity:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  # Defuse the expression
  var &lt;- enquo(var)

  # Wrap it in a call to `mean()`
  var &lt;- expr(mean(!!var, na.rm = TRUE))

  # Inject the expanded expression
  data %&gt;% dplyr::summarise(mean = !!var)
}

mtcars %&gt;% my_mean(cyl)
#&gt; # A tibble: 1 x 1
#&gt;    mean
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19
</pre></div>
<p>With <code>...</code> the technique is similar, though a little more involved. We'll use the plural variants <code>enquos()</code> and <code><a href="rlang.html#topic++21+21+21">!!!</a></code>. We'll also loop over the variable number of inputs using <code>purrr::map()</code>. But the pattern is otherwise basically the same:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(.data, ...) {
  # Defuse the dots. Make sure they are automatically named.
  vars &lt;- enquos(..., .named = TRUE)

  # Map over each defused expression and wrap it in a call to `mean()`
  vars &lt;- purrr::map(vars, ~ expr(mean(!!.x, na.rm = TRUE)))

  # Inject the expressions
  .data %&gt;% dplyr::summarise(!!!vars)
}

mtcars %&gt;% my_mean(cyl)
#&gt; # A tibble: 1 x 1
#&gt;     cyl
#&gt;   &lt;dbl&gt;
#&gt; 1  6.19
</pre></div>
<p>Note that we are inheriting the data-masking behaviour of <code>summarise()</code> because we have effectively forwarded <code>...</code> inside that verb. This is different than transformation patterns based on <code>across()</code> which inherit tidy selection behaviour. In practice, this means the function doesn't support selection helpers and syntax. Instead, it gains the ability to create new vectors on the fly:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% my_mean(cyl = cyl * 100)
#&gt; # A tibble: 1 x 1
#&gt;     cyl
#&gt;   &lt;dbl&gt;
#&gt; 1  619.
</pre></div>



<h3>Base patterns</h3>

<p>In this section, we review patterns for programming with <em>base</em> data-masking functions. They essentially consist in building and evaluating expressions in the data mask. We review these patterns and compare them to rlang idioms.
</p>


<h4>Data-masked <code>get()</code></h4>

<p>In the simplest version of this pattern, <code>get()</code> is called with a variable name to retrieve objects from the data mask:
</p>
<div class="sourceCode r"><pre>var &lt;- "cyl"

with(mtcars, mean(get(var)))
#&gt; [1] 6.1875
</pre></div>
<p>This sort of pattern is susceptible to <a href="rlang.html#topic+topic-data-mask-ambiguity">names collisions</a>. For instance, the input data frame might contain a variable called <code>var</code>:
</p>
<div class="sourceCode r"><pre>df &lt;- data.frame(var = "wrong")

with(df, mean(get(var)))
#&gt; Error in `get()`:
#&gt; ! object 'wrong' not found
</pre></div>
<p>In general, prefer symbol injection over <code>get()</code> to prevent this sort of collisions. With base functions you will need to enable injection operators explicitly using <code><a href="rlang.html#topic+inject">inject()</a></code>:
</p>
<div class="sourceCode r"><pre>inject(
  with(mtcars, mean(!!sym(var)))
)
#&gt; [1] 6.1875
</pre></div>
<p>See <a href="rlang.html#topic+topic-data-mask-ambiguity">The data mask ambiguity</a> for more information about names collisions.
</p>



<h4>Data-masked <code>parse()</code> and <code>eval()</code></h4>

<p>A more involved pattern consists in building R code in a string and evaluating it in the mask:
</p>
<div class="sourceCode r"><pre>var1 &lt;- "am"
var2 &lt;- "vs"

code &lt;- paste(var1, "==", var2)
with(mtcars, mean(eval(parse(text = code))))
#&gt; [1] 0.59375
</pre></div>
<p>As before, the <code>code</code> variable is vulnerable to <a href="rlang.html#topic+topic-data-mask-ambiguity">names collisions</a>. More importantly, if <code>var1</code> and <code>var2</code> are user inputs, they could contain <a href="https://xkcd.com/327/">adversarial code</a>. Evaluating code assembled from strings is always a risky business:
</p>
<div class="sourceCode r"><pre>var1 &lt;- "(function() {
  Sys.sleep(Inf)  # Could be a coin mining routine
})()"
var2 &lt;- "vs"

code &lt;- paste(var1, "==", var2)
with(mtcars, mean(eval(parse(text = code))))
</pre></div>
<p>This is not a big deal if your code is only used internally. However, this code could be part of a public Shiny app which Internet users could exploit. But even internally, parsing is a source of bugs when variable names contain syntactic symbols like <code>-</code> or <code>:</code>.
</p>
<div class="sourceCode r"><pre>var1 &lt;- ":var:"
var2 &lt;- "vs"

code &lt;- paste(var1, "==", var2)
with(mtcars, mean(eval(parse(text = code))))
#&gt; Error in `parse()`:
#&gt; ! &lt;text&gt;:1:1: unexpected ':'
#&gt; 1: :
#&gt;     ^
</pre></div>
<p>For these reasons, always prefer to <em>build</em> code instead of parsing code. Building variable names with <code><a href="dplyr.html#topic+sym">sym()</a></code> is a way of sanitising inputs.
</p>
<div class="sourceCode r"><pre>var1 &lt;- "(function() {
  Sys.sleep(Inf)  # Could be a coin mining routine
})()"
var2 &lt;- "vs"

code &lt;- call("==", sym(var1), sym(var2))

code
#&gt; `(function() {\n  Sys.sleep(Inf)  # Could be a coin mining routine\n})()` == 
#&gt;     vs
</pre></div>
<p>The adversarial input now produces an error:
</p>
<div class="sourceCode r"><pre>with(mtcars, mean(eval(code)))
#&gt; Error:
#&gt; ! object '(function() {\n  Sys.sleep(Inf)  # Could be a coin mining routine\n})()' not found
</pre></div>
<p>Finally, it is recommended to inject the code instead of evaluating it to avoid names collisions:
</p>
<div class="sourceCode r"><pre>var1 &lt;- "am"
var2 &lt;- "vs"

code &lt;- call("==", sym(var1), sym(var2))
inject(
  with(mtcars, mean(!!code))
)
#&gt; [1] 0.59375
</pre></div>


<hr>
<h2 id='topic-multiple-columns'>Taking multiple columns without <code>...</code></h2><span id='topic+topic-multiple-columns'></span>

<h3>Description</h3>

<p>In this guide we compare ways of taking multiple columns in a single function argument.
</p>
<p>As a refresher (see the <a href="rlang.html#topic+topic-data-mask-programming">programming patterns</a> article), there are two common ways of passing arguments to <a href="rlang.html#topic+topic-data-mask">data-masking</a> functions. For single arguments, embrace with <code><a href="rlang.html#topic+embrace-operator">{{</a></code>:
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(data, var) {
  data %&gt;% dplyr::group_by({{ var }})
}

my_pivot_longer &lt;- function(data, var) {
  data %&gt;% tidyr::pivot_longer({{ var }})
}
</pre></div>
<p>For multiple arguments in <code>...</code>, pass them on to functions that also take <code>...</code> like <code>group_by()</code>, or pass them within <code>c()</code> for functions taking tidy selection in a single argument like <code>pivot_longer()</code>:
</p>
<div class="sourceCode r"><pre># Pass dots through
my_group_by &lt;- function(.data, ...) {
  .data %&gt;% dplyr::group_by(...)
}

my_pivot_longer &lt;- function(.data, ...) {
  .data %&gt;% tidyr::pivot_longer(c(...))
}
</pre></div>
<p>But what if you want to take multiple columns in a single named argument rather than in <code>...</code>?
</p>


<h3>Using tidy selections</h3>

<p>The idiomatic tidyverse way of taking multiple columns in a single argument is to take a <em>tidy selection</em> (see the <a href="rlang.html#topic+topic-data-mask-programming">Argument behaviours</a> section). In tidy selections, the syntax for passing multiple columns in a single argument is <code>c()</code>:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% tidyr::pivot_longer(c(am, cyl, vs))
</pre></div>
<p>Since <code style="white-space: pre;">&#8288;{{&#8288;</code> inherits behaviour, this implementation of <code>my_pivot_longer()</code> automatically allows multiple columns passing:
</p>
<div class="sourceCode r"><pre>my_pivot_longer &lt;- function(data, var) {
  data %&gt;% tidyr::pivot_longer({{ var }})
}

mtcars %&gt;% my_pivot_longer(c(am, cyl, vs))
</pre></div>
<p>For <code>group_by()</code>, which takes data-masked arguments, we'll use <code>across()</code> as a <em>bridge</em> (see <a href="rlang.html#topic+topic-data-mask-programming">Bridge patterns</a>).
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(data, var) {
  data %&gt;% dplyr::group_by(across({{ var }}))
}

mtcars %&gt;% my_group_by(c(am, cyl, vs))
</pre></div>
<p>When embracing in tidyselect context or using <code>across()</code> is not possible, you might have to implement tidyselect behaviour manually with <code>tidyselect::eval_select()</code>.
</p>


<h3>Using external defusal</h3>

<p>To implement an argument with tidyselect behaviour, it is necessary to <a href="rlang.html#topic+topic-defuse">defuse</a> the argument. However defusing an argument which had historically behaved like a regular argument is a rather disruptive breaking change. This is why we could not implement tidy selections in ggplot2 facetting functions like <code>facet_grid()</code> and <code>facet_wrap()</code>.
</p>
<p>An alternative is to use external defusal of arguments. This is what formula interfaces do for instance. A modelling function takes a formula in a regular argument and the formula defuses the user code:
</p>
<div class="sourceCode r"><pre>my_lm &lt;- function(data, f, ...) {
  lm(f, data, ...)
}

mtcars %&gt;% my_lm(disp ~ drat)
</pre></div>
<p>Once created, the defused expressions contained in the formula are passed around like a normal argument. A similar approach was taken to update <code>facet_</code> functions to tidy eval. The <code>vars()</code> function (a simple alias to <code><a href="dplyr.html#topic+quos">quos()</a></code>) is provided so that users can defuse their arguments externally.
</p>
<div class="sourceCode r"><pre>ggplot2::facet_grid(
  ggplot2::vars(cyl),
  ggplot2::vars(am, vs)
)
</pre></div>
<p>You can implement this approach by simply taking a list of defused expressions as argument. This list can be passed the usual way to other functions taking such lists:
</p>
<div class="sourceCode r"><pre>my_facet_grid &lt;- function(rows, cols, ...) {
  ggplot2::facet_grid(rows, cols, ...)
}
</pre></div>
<p>Or it can be spliced with <code><a href="rlang.html#topic++21+21+21">!!!</a></code>:
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(data, vars) {
  stopifnot(is_quosures(vars))
  data %&gt;% dplyr::group_by(!!!vars)
}

mtcars %&gt;% my_group_by(dplyr::vars(cyl, am))
</pre></div>


<h3>A non-approach: Parsing lists</h3>

<p>Intuitively, many programmers who want to take a list of expressions in a single argument try to defuse an argument and parse it. The user is expected to supply multiple arguments within a <code>list()</code> expression. When such a call is detected, the arguments are retrieved and spliced with <code style="white-space: pre;">&#8288;!!!&#8288;</code>. Otherwise, the user is assumed to have supplied a single argument which is injected with <code style="white-space: pre;">&#8288;!!&#8288;</code>. An implementation along these lines might look like this:
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(data, vars) {
  vars &lt;- enquo(vars)

  if (quo_is_call(vars, "list")) {
    expr &lt;- quo_get_expr(vars)
    env &lt;- quo_get_env(vars)
    args &lt;- as_quosures(call_args(expr), env = env)
    data %&gt;% dplyr::group_by(!!!args)
  } else {
    data %&gt;% dplyr::group_by(!!vars)
  }
}
</pre></div>
<p>This does work in simple cases:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% my_group_by(cyl) %&gt;% dplyr::group_vars()
#&gt; [1] "cyl"

mtcars %&gt;% my_group_by(list(cyl, am)) %&gt;% dplyr::group_vars()
#&gt; [1] "cyl" "am"
</pre></div>
<p>However this parsing approach quickly shows limits:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% my_group_by(list2(cyl, am))
#&gt; Error in `group_by()`: Can't add columns.
#&gt; i `..1 = list2(cyl, am)`.
#&gt; i `..1` must be size 32 or 1, not 2.
</pre></div>
<p>Also, it would be better for overall consistency of interfaces to use the tidyselect syntax <code>c()</code> for passing multiple columns. In general, we recommend to use either the tidyselect or the external defusal approaches.
</p>

<hr>
<h2 id='topic-quosure'>What are quosures and when are they needed?</h2><span id='topic+topic-quosure'></span>

<h3>Description</h3>

<p>A quosure is a special type of <a href="rlang.html#topic+topic-defuse">defused expression</a> that keeps track of the original context the expression was written in. The tracking capabilities of quosures is important when interfacing <a href="rlang.html#topic+topic-data-mask">data-masking</a> functions together because the functions might come from two unrelated environments, like two different packages.
</p>


<h3>Blending environments</h3>

<p>Let's take an example where the R user calls the function <code>summarise_bmi()</code> from the foo package to summarise a data frame with statistics of a BMI value. Because the <code>height</code> variable of their data frame is not in metres, they use a custom function <code>div100()</code> to rescale the column.
</p>
<div class="sourceCode r"><pre># Global environment of user

div100 &lt;- function(x) {
  x / 100
}

dplyr::starwars %&gt;%
  foo::summarise_bmi(mass, div100(height))
</pre></div>
<p>The <code>summarise_bmi()</code> function is a data-masking function defined in the namespace of the foo package which looks like this:
</p>
<div class="sourceCode r"><pre># Namespace of package foo

bmi &lt;- function(mass, height) {
  mass / height^2
}

summarise_bmi &lt;- function(data, mass, height) {
  data %&gt;%
    bar::summarise_stats(bmi({{ mass }}, {{ height }}))
}
</pre></div>
<p>The foo package uses the custom function <code>bmi()</code> to perform a computation on two vectors. It interfaces with <code>summarise_stats()</code> defined in bar, another package whose namespace looks like this:
</p>
<div class="sourceCode r"><pre># Namespace of package bar

check_numeric &lt;- function(x) {
  stopifnot(is.numeric(x))
  x
}

summarise_stats &lt;- function(data, var) {
  data %&gt;%
    dplyr::transmute(
      var = check_numeric({{ var }})
    ) %&gt;%
    dplyr::summarise(
      mean = mean(var, na.rm = TRUE),
      sd = sd(var, na.rm = TRUE)
    )
}
</pre></div>
<p>Again the package bar uses a custom function, <code>check_numeric()</code>, to validate its input. It also interfaces with data-masking functions from dplyr (using the <a href="rlang.html#topic+topic-double-evaluation">define-a-constant</a> trick to avoid issues of double evaluation).
</p>
<p>There are three data-masking functions simultaneously interfacing in this snippet:
</p>

<ul>
<li><p> At the bottom, <code>dplyr::transmute()</code> takes a data-masked input, and creates a data frame of a single column named <code>var</code>.
</p>
</li>
<li><p> Before this, <code>bar::summarise_stats()</code> takes a data-masked input inside <code>dplyr::transmute()</code> and checks it is numeric.
</p>
</li>
<li><p> And first of all, <code>foo::summarise_bmi()</code> takes two data-masked inputs inside <code>bar::summarise_stats()</code> and transforms them to a single BMI value.
</p>
</li></ul>

<p>There is a fourth context, the global environment where <code>summarise_bmi()</code> is called with two columns defined in a data frame, one of which is transformed on the fly with the user function <code>div100()</code>.
</p>
<p>All of these contexts (except to some extent the global environment) contain functions that are private and invisible to foreign functions. Yet, the final expanded data-masked expression that is evaluated down the line looks like this (with caret characters indicating the quosure boundaries):
</p>
<div class="sourceCode r"><pre>dplyr::transmute(
  var = ^check_numeric(^bmi(^mass, ^div100(height)))
)
</pre></div>
<p>The role of quosures is to let R know that <code>check_numeric()</code> should be found in the bar package, <code>bmi()</code> in the foo package, and <code>div100()</code> in the global environment.
</p>


<h3>When should I create quosures?</h3>

<p>As a tidyverse user you generally don't need to worry about quosures because <code style="white-space: pre;">&#8288;{{&#8288;</code> and <code>...</code> will create them for you. Introductory texts like <a href="https://dplyr.tidyverse.org/articles/programming.html">Programming with dplyr</a> or the <a href="rlang.html#topic+topic-data-mask-programming">standard data-mask programming patterns</a> don't even mention the term. In more complex cases you might need to create quosures with <code><a href="dplyr.html#topic+enquo">enquo()</a></code> or <code><a href="dplyr.html#topic+enquos">enquos()</a></code> (even though you generally don't need to know or care that these functions return quosures). In this section, we explore when quosures are necessary in these more advanced applications.
</p>


<h4>Foreign and local expressions</h4>

<p>As a rule of thumb, quosures are only needed for arguments defused with <code><a href="dplyr.html#topic+enquo">enquo()</a></code> or <code><a href="dplyr.html#topic+enquos">enquos()</a></code> (or with <code><a href="rlang.html#topic+embrace-operator">{{</a></code> which calls <code>enquo()</code> implicitly):
</p>
<div class="sourceCode r"><pre>my_function &lt;- function(var) {
  var &lt;- enquo(var)
  their_function(!!var)
}

# Equivalently
my_function &lt;- function(var) {
  their_function({{ var }})
}
</pre></div>
<p>Wrapping defused arguments in quosures is needed because expressions supplied as argument comes from a different environment, the environment of your user. For local expressions created in your function, you generally don't need to create quosures:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  # `expr()` is sufficient, no need for `quo()`
  expr &lt;- expr(mean({{ var }}))
  dplyr::summarise(data, !!expr)
}

my_mean(mtcars, cyl)
#&gt; # A tibble: 1 x 1
#&gt;   `mean(cyl)`
#&gt;         &lt;dbl&gt;
#&gt; 1        6.19
</pre></div>
<p>Using <code><a href="dplyr.html#topic+quo">quo()</a></code> instead of <code><a href="dplyr.html#topic+expr">expr()</a></code> would have worked too but it is superfluous because <code>dplyr::summarise()</code>, which uses <code><a href="dplyr.html#topic+enquos">enquos()</a></code>, is already in charge of wrapping your expression within a quosure scoped in your environment.
</p>
<p>The same applies if you evaluate manually. By default, <code><a href="base.html#topic+eval">eval()</a></code> and <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code> capture your environment:
</p>
<div class="sourceCode r"><pre>my_mean &lt;- function(data, var) {
  expr &lt;- expr(mean({{ var }}))
  eval_tidy(expr, data)
}

my_mean(mtcars, cyl)
#&gt; [1] 6.1875
</pre></div>



<h4>External defusing</h4>

<p>An exception to this rule of thumb (wrap foreign expressions in quosures, not your own expressions) arises when your function takes multiple expressions in a list instead of <code>...</code>. The preferred approach in that case is to take a tidy selection so that users can combine multiple columns using <code>c()</code>. If that is not possible, you can take a list of externally defused expressions:
</p>
<div class="sourceCode r"><pre>my_group_by &lt;- function(data, vars) {
  stopifnot(is_quosures(vars))
  data %&gt;% dplyr::group_by(!!!vars)
}

mtcars %&gt;% my_group_by(dplyr::vars(cyl, am))
</pre></div>
<p>In this pattern, <code>dplyr::vars()</code> defuses expressions externally. It creates a list of quosures because the expressions are passed around from function to function like regular arguments. In fact, <code>dplyr::vars()</code> and <code>ggplot2::vars()</code> are simple aliases of <code><a href="dplyr.html#topic+quos">quos()</a></code>.
</p>
<div class="sourceCode r"><pre>dplyr::vars(cyl, am)
#&gt; &lt;list_of&lt;quosure&gt;&gt;
#&gt; 
#&gt; [[1]]
#&gt; &lt;quosure&gt;
#&gt; expr: ^cyl
#&gt; env:  global
#&gt; 
#&gt; [[2]]
#&gt; &lt;quosure&gt;
#&gt; expr: ^am
#&gt; env:  global
</pre></div>
<p>For more information about external defusing, see <a href="rlang.html#topic+topic-multiple-columns">Taking multiple columns without ...</a>.
</p>



<h3>Technical description of quosures</h3>

<p>A quosure carries two things:
</p>

<ul>
<li><p> An expression (get it with <code><a href="rlang.html#topic+quo_get_expr">quo_get_expr()</a></code>).
</p>
</li>
<li><p> An environment (get it with <code><a href="rlang.html#topic+quo_get_env">quo_get_env()</a></code>).
</p>
</li></ul>

<p>And implements these behaviours:
</p>

<ul>
<li><p> It is <em>callable</em>. Evaluation produces a result.
</p>
<p>For historical reasons, <code><a href="base.html#topic+eval">base::eval()</a></code> doesn't support quosure evaluation. Quosures currently require <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code>. We would like to fix this limitation in the future.
</p>
</li>
<li><p> It is <em>hygienic</em>. It evaluates in the tracked environment.
</p>
</li>
<li><p> It is <em>maskable</em>. If evaluated in a data mask (currently only masks created with <code><a href="rlang.html#topic+eval_tidy">eval_tidy()</a></code> or <code><a href="rlang.html#topic+new_data_mask">new_data_mask()</a></code>), the mask comes first in scope before the quosure environment.
</p>
<p>Conceptually, a quosure inherits from two chains of environments, the data mask and the user environment. In practice rlang implements this special scoping by rechaining the top of the data mask to the quosure environment currently under evaluation.
</p>
</li></ul>

<p>There are similarities between promises (the ones R uses to implement lazy evaluation, not the async expressions from the promises package) and quosures. One important difference is that promises are only evaluated once and cache the result for subsequent evaluation. Quosures behave more like calls and can be evaluated repeatedly, potentially in a different data mask. This property is useful to implement split-apply-combine evaluations.
</p>


<h3>See also</h3>


<ul>
<li> <p><code><a href="dplyr.html#topic+enquo">enquo()</a></code> and <code><a href="dplyr.html#topic+enquos">enquos()</a></code> to defuse function arguments as quosures. This is the main way quosures are created.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+quo">quo()</a></code> which is like <code><a href="dplyr.html#topic+expr">expr()</a></code> but wraps in a quosure. Usually it is not needed to wrap local expressions yourself.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+quo_get_expr">quo_get_expr()</a></code> and <code><a href="rlang.html#topic+quo_get_env">quo_get_env()</a></code> to access quosure components.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+new_quosure">new_quosure()</a></code> and <code><a href="rlang.html#topic+as_quosure">as_quosure()</a></code> to assemble a quosure from components.
</p>
</li></ul>


<hr>
<h2 id='trace_back'>Capture a backtrace</h2><span id='topic+trace_back'></span><span id='topic+trace_length'></span>

<h3>Description</h3>

<p>A backtrace captures the sequence of calls that lead to the current
function (sometimes called the call stack). Because of lazy
evaluation, the call stack in R is actually a tree, which the
<code>print()</code> method for this object will reveal.
</p>
<p>Users rarely need to call <code>trace_back()</code> manually. Instead,
signalling an error with <code><a href="rlang.html#topic+abort">abort()</a></code> or setting up <code><a href="rlang.html#topic+global_entrace">global_entrace()</a></code>
is the most common way to create backtraces when an error is
thrown. Inspect the backtrace created for the most recent error
with <code><a href="rlang.html#topic+last_error">last_error()</a></code>.
</p>
<p><code>trace_length()</code> returns the number of frames in a backtrace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_back(top = NULL, bottom = NULL)

trace_length(trace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trace_back_+3A_top">top</code></td>
<td>
<p>The first frame environment to be included in the
backtrace. This becomes the top of the backtrace tree and
represents the oldest call in the backtrace.
</p>
<p>This is needed in particular when you call <code>trace_back()</code>
indirectly or from a larger context, for example in tests or
inside an RMarkdown document where you don't want all of the
knitr evaluation mechanisms to appear in the backtrace.
</p>
<p>If not supplied, the <code>rlang_trace_top_env</code> global option is
consulted. This makes it possible to trim the embedding context
for all backtraces created while the option is set. If knitr is
in progress, the default value for this option is
<code>knitr::knit_global()</code> so that the knitr context is trimmed out
of backtraces.</p>
</td></tr>
<tr><td><code id="trace_back_+3A_bottom">bottom</code></td>
<td>
<p>The last frame environment to be included in the
backtrace. This becomes the rightmost leaf of the backtrace tree
and represents the youngest call in the backtrace.
</p>
<p>Set this when you would like to capture a backtrace without the
capture context.
</p>
<p>Can also be an integer that will be passed to <code><a href="rlang.html#topic+caller_env">caller_env()</a></code>.</p>
</td></tr>
<tr><td><code id="trace_back_+3A_trace">trace</code></td>
<td>
<p>A backtrace created by <code>trace_back()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Trim backtraces automatically (this improves the generated
# documentation for the rlang website and the same trick can be
# useful within knitr documents):
options(rlang_trace_top_env = current_env())

f &lt;- function() g()
g &lt;- function() h()
h &lt;- function() trace_back()

# When no lazy evaluation is involved the backtrace is linear
# (i.e. every call has only one child)
f()

# Lazy evaluation introduces a tree like structure
identity(identity(f()))
identity(try(f()))
try(identity(f()))

# When printing, you can request to simplify this tree to only show
# the direct sequence of calls that lead to `trace_back()`
x &lt;- try(identity(f()))
x
print(x, simplify = "branch")

# With a little cunning you can also use it to capture the
# tree from within a base NSE function
x &lt;- NULL
with(mtcars, {x &lt;&lt;- f(); 10})
x


# Restore default top env for next example
options(rlang_trace_top_env = NULL)

# When code is executed indirectly, i.e. via source or within an
# RMarkdown document, you'll tend to get a lot of guff at the beginning
# related to the execution environment:
conn &lt;- textConnection("summary(f())")
source(conn, echo = TRUE, local = TRUE)
close(conn)

# To automatically strip this off, specify which frame should be
# the top of the backtrace. This will automatically trim off calls
# prior to that frame:
top &lt;- current_env()
h &lt;- function() trace_back(top)

conn &lt;- textConnection("summary(f())")
source(conn, echo = TRUE, local = TRUE)
close(conn)
</code></pre>

<hr>
<h2 id='try_fetch'>Try an expression with condition handlers</h2><span id='topic+try_fetch'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>try_fetch()</code> establishes handlers for conditions of a given class
(<code>"error"</code>, <code>"warning"</code>, <code>"message"</code>, ...). Handlers are functions
that take a condition object as argument and are called when the
corresponding condition class has been signalled.
</p>
<p>A condition handler can:
</p>

<ul>
<li> <p><strong>Recover from conditions</strong> with a value. In this case the computation of
<code>expr</code> is aborted and the recovery value is returned from
<code>try_fetch()</code>. Error recovery is useful when you don't want
errors to abruptly interrupt your program but resume at the
catching site instead.
</p>
<div class="sourceCode"><pre># Recover with the value 0
try_fetch(1 + "", error = function(cnd) 0)
</pre></div>
</li>
<li> <p><strong>Rethrow conditions</strong>, e.g. using <code>abort(msg, parent = cnd)</code>.
See the <code>parent</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code>. This is typically done to
add information to low-level errors about the high-level context
in which they occurred.
</p>
<div class="sourceCode"><pre>try_fetch(1 + "", error = function(cnd) abort("Failed.", parent = cnd))
</pre></div>
</li>
<li> <p><strong>Inspect conditions</strong>, for instance to log data about warnings
or errors. In this case, the handler must return the <code><a href="purrr.html#topic+zap">zap()</a></code>
sentinel to instruct <code>try_fetch()</code> to ignore (or zap) that
particular handler. The next matching handler is called if any,
and errors bubble up to the user if no handler remains.
</p>
<div class="sourceCode"><pre>log &lt;- NULL
try_fetch(1 + "", error = function(cnd) {
  log &lt;&lt;- cnd
  zap()
})
</pre></div>
</li></ul>

<p>Whereas <code>tryCatch()</code> catches conditions (discarding any running
code along the way) and then calls the handler, <code>try_fetch()</code> first
calls the handler with the condition on top of the currently
running code (fetches it where it stands) and then catches the
return value. This is a subtle difference that has implications
for the debuggability of your functions. See the comparison with
<code>tryCatch()</code> section below.
</p>
<p>Another difference between <code>try_fetch()</code> and the base equivalent is
that errors are matched across chains, see the <code>parent</code> argument of
<code><a href="rlang.html#topic+abort">abort()</a></code>. This is a useful property that makes <code>try_fetch()</code>
insensitive to changes of implementation or context of evaluation
that cause a classed error to suddenly get chained to a contextual
error. Note that some chained conditions are not inherited, see the
<code>.inherit</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> or <code><a href="rlang.html#topic+warn">warn()</a></code>. In particular,
downgraded conditions (e.g. from error to warning or from warning
to message) are not matched across parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_fetch(expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_fetch_+3A_expr">expr</code></td>
<td>
<p>An R expression.</p>
</td></tr>
<tr><td><code id="try_fetch_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Named condition
handlers. The names specify the condition class for which a
handler will be called.</p>
</td></tr>
</table>


<h3>Stack overflows</h3>

<p>A stack overflow occurs when a program keeps adding to itself until
the stack memory (whose size is very limited unlike heap memory) is
exhausted.
</p>
<div class="sourceCode"><pre># A function that calls itself indefinitely causes stack overflows
f &lt;- function() f()
f()
#&gt; Error: C stack usage  9525680 is too close to the limit
</pre></div>
<p>Because memory is very limited when these errors happen, it is not
possible to call the handlers on the existing program stack.
Instead, error conditions are first caught by <code>try_fetch()</code> and only
then error handlers are called. Catching the error interrupts the
program up to the <code>try_fetch()</code> context, which allows R to reclaim
stack memory.
</p>
<p>The practical implication is that error handlers should never
assume that the whole call stack is preserved. For instance a
<code><a href="rlang.html#topic+trace_back">trace_back()</a></code> capture might miss frames.
</p>
<p>Note that error handlers are only run for stack overflows on R &gt;=
4.2. On older versions of R the handlers are simply not run. This
is because these errors do not inherit from the class
<code>stackOverflowError</code> before R 4.2. Consider using <code><a href="base.html#topic+tryCatch">tryCatch()</a></code>
instead with critical error handlers that need to capture all
errors on old versions of R.
</p>


<h3>Comparison with <code>tryCatch()</code></h3>

<p><code>try_fetch()</code> generalises <code>tryCatch()</code> and <code>withCallingHandlers()</code>
in a single function. It reproduces the behaviour of both calling
and exiting handlers depending the on the return value of the
handler. If the handler returns the <code><a href="purrr.html#topic+zap">zap()</a></code> sentinel, it is taken
as a calling handler that declines to recover from a condition.
Otherwise, it is taken as an exiting handler which returns a value
from the catching site.
</p>
<p>The important difference between <code>tryCatch()</code> and <code>try_fetch()</code> is
that the program in <code>expr</code> is still fully running when an error
handler is called. Because the call stack is preserved, this makes
it possible to capture a full backtrace from within the handler,
e.g. when rethrowing the error with <code>abort(parent = cnd)</code>.
Technically, <code>try_fetch()</code> is more similar to (and implemented on
top of) <code><a href="base.html#topic+conditions">base::withCallingHandlers()</a></code> than <code style="white-space: pre;">&#8288;tryCatch().&#8288;</code>
</p>

<hr>
<h2 id='type_of'>Base type of an object</h2><span id='topic+type_of'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This is equivalent to <code><a href="base.html#topic+typeof">base::typeof()</a></code> with a few differences that
make dispatching easier:
</p>

<ul>
<li><p> The type of one-sided formulas is &quot;quote&quot;.
</p>
</li>
<li><p> The type of character vectors of length 1 is &quot;string&quot;.
</p>
</li>
<li><p> The type of special and builtin functions is &quot;primitive&quot;.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>type_of(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type_of_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>type_of(10L)

# Quosures are treated as a new base type but not formulas:
type_of(quo(10L))
type_of(~10L)

# Compare to base::typeof():
typeof(quo(10L))

# Strings are treated as a new base type:
type_of(letters)
type_of(letters[[1]])

# This is a bit inconsistent with the core language tenet that data
# types are vectors. However, treating strings as a different
# scalar type is quite helpful for switching on function inputs
# since so many arguments expect strings:
switch_type("foo", character = abort("vector!"), string = "result")

# Special and builtin primitives are both treated as primitives.
# That's because it is often irrelevant which type of primitive an
# input is:
typeof(list)
typeof(`$`)
type_of(list)
type_of(`$`)
</code></pre>

<hr>
<h2 id='type-predicates'>Type predicates</h2><span id='topic+type-predicates'></span><span id='topic+is_list'></span><span id='topic+is_atomic'></span><span id='topic+is_vector'></span><span id='topic+is_integer'></span><span id='topic+is_double'></span><span id='topic+is_complex'></span><span id='topic+is_character'></span><span id='topic+is_logical'></span><span id='topic+is_raw'></span><span id='topic+is_bytes'></span><span id='topic+is_null'></span>

<h3>Description</h3>

<p>These type predicates aim to make type testing in R more
consistent. They are wrappers around <code><a href="base.html#topic+typeof">base::typeof()</a></code>, so operate
at a level beneath S3/S4 etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_list(x, n = NULL)

is_atomic(x, n = NULL)

is_vector(x, n = NULL)

is_integer(x, n = NULL)

is_double(x, n = NULL, finite = NULL)

is_complex(x, n = NULL, finite = NULL)

is_character(x, n = NULL)

is_logical(x, n = NULL)

is_raw(x, n = NULL)

is_bytes(x, n = NULL)

is_null(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type-predicates_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
<tr><td><code id="type-predicates_+3A_n">n</code></td>
<td>
<p>Expected length of a vector.</p>
</td></tr>
<tr><td><code id="type-predicates_+3A_finite">finite</code></td>
<td>
<p>Whether all values of the vector are finite. The
non-finite values are <code>NA</code>, <code>Inf</code>, <code>-Inf</code> and <code>NaN</code>. Setting this
to something other than <code>NULL</code> can be expensive because the whole
vector needs to be traversed and checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compared to base R functions:
</p>

<ul>
<li><p> The predicates for vectors include the <code>n</code> argument for
pattern-matching on the vector length.
</p>
</li>
<li><p> Unlike <code>is.atomic()</code>, <code>is_atomic()</code> does not return <code>TRUE</code> for
<code>NULL</code>.
</p>
</li>
<li><p> Unlike <code>is.vector()</code>, <code>is_vector()</code> tests if an object is an
atomic vector or a list. <code>is.vector</code> checks for the presence of
attributes (other than name).
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="rlang.html#topic+bare-type-predicates">bare-type-predicates</a> <a href="rlang.html#topic+scalar-type-predicates">scalar-type-predicates</a>
</p>

<hr>
<h2 id='UQ'>Deprecated <code>UQ()</code> and <code>UQS()</code> operators</h2><span id='topic+UQ'></span><span id='topic+UQS'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
These operators are deprecated in favour of
<code><a href="rlang.html#topic+injection-operator">!!</a></code> and <code><a href="rlang.html#topic+splice-operator">!!!</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UQ(x)

UQS(x)
</code></pre>

<hr>
<h2 id='vec_poke_n'>Poke values into a vector</h2><span id='topic+vec_poke_n'></span><span id='topic+vec_poke_range'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>These tools are for R experts only. They copy elements from <code>y</code>
into <code>x</code> by mutation. You should only do this if you own <code>x</code>,
i.e. if you have created it or if you are certain that it doesn't
exist in any other context. Otherwise you might create unintended
side effects that have undefined consequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_poke_n(x, start, y, from = 1L, n = length(y))

vec_poke_range(x, start, y, from = 1L, to = length(y) - from + 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_poke_n_+3A_x">x</code></td>
<td>
<p>The destination vector.</p>
</td></tr>
<tr><td><code id="vec_poke_n_+3A_start">start</code></td>
<td>
<p>The index indicating where to start modifying <code>x</code>.</p>
</td></tr>
<tr><td><code id="vec_poke_n_+3A_y">y</code></td>
<td>
<p>The source vector.</p>
</td></tr>
<tr><td><code id="vec_poke_n_+3A_from">from</code></td>
<td>
<p>The index indicating where to start copying from <code>y</code>.</p>
</td></tr>
<tr><td><code id="vec_poke_n_+3A_n">n</code></td>
<td>
<p>How many elements should be copied from <code>y</code> to <code>x</code>.</p>
</td></tr>
<tr><td><code id="vec_poke_n_+3A_to">to</code></td>
<td>
<p>The index indicating the end of the range to copy from <code>y</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='vector-coercion'>Coerce an object to a base type</h2><span id='topic+vector-coercion'></span><span id='topic+as_logical'></span><span id='topic+as_integer'></span><span id='topic+as_double'></span><span id='topic+as_complex'></span><span id='topic+as_character'></span><span id='topic+as_list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These are equivalent to the base functions (e.g. <code><a href="base.html#topic+as.logical">as.logical()</a></code>,
<code><a href="base.html#topic+as.list">as.list()</a></code>, etc), but perform coercion rather than conversion.
This means they are not generic and will not call S3 conversion
methods. They only attempt to coerce the base type of their
input. In addition, they have stricter implicit coercion rules and
will never attempt any kind of parsing. E.g. they will not try to
figure out if a character vector represents integers or booleans.
Finally, they treat attributes consistently, unlike the base R
functions: all attributes except names are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_logical(x)

as_integer(x)

as_double(x)

as_complex(x)

as_character(x, encoding = NULL)

as_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector-coercion_+3A_x">x</code></td>
<td>
<p>An object to coerce to a base type.</p>
</td></tr>
<tr><td><code id="vector-coercion_+3A_encoding">encoding</code></td>
<td>
<p>If non-null, set an encoding mark. This is only
declarative, no encoding conversion is performed.</p>
</td></tr>
</table>


<h3>Lifecycle</h3>

<p>These functions are deprecated in favour of <code>vctrs::vec_cast()</code>.
</p>


<h3>Coercion to logical and numeric atomic vectors</h3>


<ul>
<li><p> To logical vectors: Integer and integerish double vectors. See
<code><a href="rlang.html#topic+is_integerish">is_integerish()</a></code>.
</p>
</li>
<li><p> To integer vectors: Logical and integerish double vectors.
</p>
</li>
<li><p> To double vectors: Logical and integer vectors.
</p>
</li>
<li><p> To complex vectors: Logical, integer and double vectors.
</p>
</li></ul>



<h3>Coercion to character vectors</h3>

<p><code>as_character()</code> and <code>as_string()</code> have an optional <code>encoding</code>
argument to specify the encoding. R uses this information for
internal handling of strings and character vectors. Note that this
is only declarative, no encoding conversion is attempted.
</p>
<p>Note that only <code>as_string()</code> can coerce symbols to a scalar
character vector. This makes the code more explicit and adds an
extra type check.
</p>


<h3>Coercion to lists</h3>

<p><code>as_list()</code> only coerces vector and dictionary types (environments
are an example of dictionary type). Unlike <code><a href="base.html#topic+list">base::as.list()</a></code>,
<code>as_list()</code> removes all attributes except names.
</p>


<h3>Effects of removing attributes</h3>

<p>A technical side-effect of removing the attributes of the input is
that the underlying objects has to be copied. This has no
performance implications in the case of lists because this is a
shallow copy: only the list structure is copied, not the contents
(see <code><a href="rlang.html#topic+duplicate">duplicate()</a></code>). However, be aware that atomic vectors
containing large amounts of data will have to be copied.
</p>
<p>In general, any attribute modification creates a copy, which is why
it is better to avoid using attributes with heavy atomic vectors.
Uncopyable objects like environments and symbols are an exception
to this rule: in this case, attributes modification happens in
place and has side-effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Coercing atomic vectors removes attributes with both base R and rlang:
x &lt;- structure(TRUE, class = "foo", bar = "baz")
as.logical(x)

# But coercing lists preserves attributes in base R but not rlang:
l &lt;- structure(list(TRUE), class = "foo", bar = "baz")
as.list(l)
as_list(l)

# Implicit conversions are performed in base R but not rlang:
as.logical(l)
## Not run: 
as_logical(l)

## End(Not run)

# Conversion methods are bypassed, making the result of the
# coercion more predictable:
as.list.foo &lt;- function(x) "wrong"
as.list(l)
as_list(l)

# The input is never parsed. E.g. character vectors of numbers are
# not converted to numeric types:
as.integer("33")
## Not run: 
as_integer("33")

## End(Not run)


# With base R tools there is no way to convert an environment to a
# list without either triggering method dispatch, or changing the
# original environment. as_list() makes it easy:
x &lt;- structure(as_environment(mtcars[1:2]), class = "foobar")
as.list.foobar &lt;- function(x) abort("dont call me")
as_list(x)
</code></pre>

<hr>
<h2 id='vector-construction'>Create vectors</h2><span id='topic+vector-construction'></span><span id='topic+lgl'></span><span id='topic+int'></span><span id='topic+dbl'></span><span id='topic+cpl'></span><span id='topic+chr'></span><span id='topic+bytes'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a>
</p>
<p>The atomic vector constructors are equivalent to <code><a href="base.html#topic+c">c()</a></code> but:
</p>

<ul>
<li><p> They allow you to be more explicit about the output
type. Implicit coercions (e.g. from integer to logical) follow
the rules described in <a href="rlang.html#topic+vector-coercion">vector-coercion</a>.
</p>
</li>
<li><p> They use <a href="rlang.html#topic+dyn-dots">dynamic dots</a>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>lgl(...)

int(...)

dbl(...)

cpl(...)

chr(...)

bytes(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector-construction_+3A_...">...</code></td>
<td>
<p>Components of the new vector. Bare lists and explicitly
spliced lists are spliced.</p>
</td></tr>
</table>


<h3>Life cycle</h3>


<ul>
<li><p> All the abbreviated constructors such as <code>lgl()</code> will probably be
moved to the vctrs package at some point. This is why they are
marked as questioning.
</p>
</li>
<li><p> Automatic splicing is soft-deprecated and will trigger a warning
in a future version. Please splice explicitly with <code style="white-space: pre;">&#8288;!!!&#8288;</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># These constructors are like a typed version of c():
c(TRUE, FALSE)
lgl(TRUE, FALSE)

# They follow a restricted set of coercion rules:
int(TRUE, FALSE, 20)

# Lists can be spliced:
dbl(10, !!! list(1, 2L), TRUE)


# They splice names a bit differently than c(). The latter
# automatically composes inner and outer names:
c(a = c(A = 10), b = c(B = 20, C = 30))

# On the other hand, rlang's constructors use the inner names and issue a
# warning to inform the user that the outer names are ignored:
dbl(a = c(A = 10), b = c(B = 20, C = 30))
dbl(a = c(1, 2))

# As an exception, it is allowed to provide an outer name when the
# inner vector is an unnamed scalar atomic:
dbl(a = 1)

# Spliced lists behave the same way:
dbl(!!! list(a = 1))
dbl(!!! list(a = c(A = 1)))

# bytes() accepts integerish inputs
bytes(1:10)
bytes(0x01, 0xff, c(0x03, 0x05), list(10, 20, 30L))
</code></pre>

<hr>
<h2 id='with_env'>Evaluate an expression within a given environment</h2><span id='topic+with_env'></span><span id='topic+locally'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions evaluate <code>expr</code> within a given environment (<code>env</code>
for <code>with_env()</code>, or the child of the current environment for
<code>locally</code>). They rely on <code><a href="rlang.html#topic+eval_bare">eval_bare()</a></code> which features a lighter
evaluation mechanism than base R <code><a href="base.html#topic+eval">base::eval()</a></code>, and which also has
some subtle implications when evaluting stack sensitive functions
(see help for <code><a href="rlang.html#topic+eval_bare">eval_bare()</a></code>).
</p>
<p><code>locally()</code> is equivalent to the base function
<code><a href="base.html#topic+eval">base::local()</a></code> but it produces a much cleaner
evaluation stack, and has stack-consistent semantics. It is thus
more suited for experimenting with the R language.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_env(env, expr)

locally(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_env_+3A_env">env</code></td>
<td>
<p>An environment within which to evaluate <code>expr</code>. Can be
an object with a <code><a href="rlang.html#topic+get_env">get_env()</a></code> method.</p>
</td></tr>
<tr><td><code id="with_env_+3A_expr">expr</code></td>
<td>
<p>An expression to evaluate.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># with_env() is handy to create formulas with a given environment:
env &lt;- child_env("rlang")
f &lt;- with_env(env, ~new_formula())
identical(f_env(f), env)

# Or functions with a given enclosure:
fn &lt;- with_env(env, function() NULL)
identical(get_env(fn), env)


# Unlike eval() it doesn't create duplicates on the evaluation
# stack. You can thus use it e.g. to create non-local returns:
fn &lt;- function() {
  g(current_env())
  "normal return"
}
g &lt;- function(env) {
  with_env(env, return("early return"))
}
fn()


# Since env is passed to as_environment(), it can be any object with an
# as_environment() method. For strings, the pkg_env() is returned:
with_env("base", ~mtcars)

# This can be handy to put dictionaries in scope:
with_env(mtcars, cyl)
</code></pre>

<hr>
<h2 id='with_handlers'>Establish handlers on the stack</h2><span id='topic+with_handlers'></span><span id='topic+calling'></span><span id='topic+exiting'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>As of rlang 1.0.0, <code>with_handlers()</code> is deprecated. Use the base
functions or the experimental <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code> function instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_handlers(.expr, ...)

calling(handler)

exiting(handler)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_handlers_+3A_.expr">.expr</code>, <code id="with_handlers_+3A_...">...</code>, <code id="with_handlers_+3A_handler">handler</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>

<hr>
<h2 id='wref_key'>Get key/value from a weak reference object</h2><span id='topic+wref_key'></span><span id='topic+wref_value'></span>

<h3>Description</h3>

<p>Get key/value from a weak reference object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wref_key(x)

wref_value(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wref_key_+3A_x">x</code></td>
<td>
<p>A weak reference object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+is_weakref">is_weakref()</a></code> and <code><a href="rlang.html#topic+new_weakref">new_weakref()</a></code>.
</p>

<hr>
<h2 id='zap'>Create zap objects</h2><span id='topic+zap'></span><span id='topic+is_zap'></span>

<h3>Description</h3>

<p><code>zap()</code> creates a sentinel object that indicates that an object
should be removed. For instance, named zaps instruct <code><a href="rlang.html#topic+env_bind">env_bind()</a></code>
and <code><a href="lazyeval.html#topic+call_modify">call_modify()</a></code> to remove those objects from the environment or
the call.
</p>
<p>The advantage of zap objects is that they unambiguously signal the
intent of removing an object. Sentinels like <code>NULL</code> or
<code><a href="lazyeval.html#topic+missing_arg">missing_arg()</a></code> are ambiguous because they represent valid R
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zap()

is_zap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zap_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Create one zap object:
zap()

# Create a list of zaps:
rep(list(zap()), 3)
rep_named(c("foo", "bar"), list(zap()))
</code></pre>

<hr>
<h2 id='zap_srcref'>Zap source references</h2><span id='topic+zap_srcref'></span>

<h3>Description</h3>

<p>There are a number of situations where R creates source references:
</p>

<ul>
<li><p> Reading R code from a file with <code>source()</code> and <code>parse()</code> might save
source references inside calls to <code>function</code> and <code style="white-space: pre;">&#8288;{&#8288;</code>.
</p>
</li>
<li> <p><code><a href="base.html#topic+sys.call">sys.call()</a></code> includes a source reference if possible.
</p>
</li>
<li><p> Creating a closure stores the source reference from the call to
<code>function</code>, if any.
</p>
</li></ul>

<p>These source references take up space and might cause a number of
issues. <code>zap_srcref()</code> recursively walks through expressions and
functions to remove all source references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zap_srcref(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zap_srcref_+3A_x">x</code></td>
<td>
<p>An R object. Functions and calls are walked recursively.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
