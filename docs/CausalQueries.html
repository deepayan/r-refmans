<!DOCTYPE html><html lang="en"><head><title>Help for package CausalQueries</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CausalQueries}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CausalQueries'><p>'CausalQueries'</p></a></li>
<li><a href='#add_dots'><p>Helper to fill in missing do operators in causal expression</p></a></li>
<li><a href='#CausalQueries_internal_inherit_params'><p>Create parameter documentation to inherit</p></a></li>
<li><a href='#clean_statement'><p>Helper to clean and check the validity of causal statements specifying a DAG.</p>
This function isolates nodes and edges specified in a causal statements and
makes them processable by <code>make_dag</code></a></li>
<li><a href='#construct_commands_alter_at'><p>make_par_values</p></a></li>
<li><a href='#construct_commands_other_args'><p>make_par_values</p></a></li>
<li><a href='#construct_commands_param_names'><p>make_par_values</p></a></li>
<li><a href='#data_helpers'><p>Data helpers</p></a></li>
<li><a href='#democracy_data'><p>Development and Democratization: Data for replication of analysis in</p>
*Integrated Inferences*</a></li>
<li><a href='#draw_causal_type'><p>Draw a single causal type given a parameter vector</p></a></li>
<li><a href='#expand_nodal_expression'><p>Helper to expand nodal expression</p></a></li>
<li><a href='#get_all_data_types'><p>Get all data types</p></a></li>
<li><a href='#get_estimands'><p>helper to get estimands</p></a></li>
<li><a href='#get_event_probabilities'><p>Draw event probabilities</p></a></li>
<li><a href='#get_parameter_matrix'><p>Get parameter matrix</p></a></li>
<li><a href='#get_query_types'><p>Look up query types</p></a></li>
<li><a href='#get_type_posteriors'><p>helper to get type distributions</p></a></li>
<li><a href='#inspection'><p>Helpers for inspecting causal models</p></a></li>
<li><a href='#institutions_data'><p>Institutions and growth: Data for replication of analysis in</p>
*Integrated Inferences*</a></li>
<li><a href='#interpret_type'><p>Interpret or find position in nodal type</p></a></li>
<li><a href='#lipids_data'><p>Lipids: Data for Chickering and Pearl replication</p></a></li>
<li><a href='#list_non_parents'><p>Returns a list with the nodes that are not directly pointing into a node</p></a></li>
<li><a href='#make_dag'><p>Helper to run a causal statement specifying a DAG into a <code>data.frame</code> of</p>
pairwise parent child relations between nodes specified by a respective edge.</a></li>
<li><a href='#make_data_single'><p>Generate full dataset</p></a></li>
<li><a href='#make_model'><p>Make a model</p></a></li>
<li><a href='#make_par_values'><p>make_par_values</p></a></li>
<li><a href='#make_par_values_stops'><p>make_par_values_stops</p></a></li>
<li><a href='#make_parameters_df'><p>function to make a parameters_df from nodal types</p></a></li>
<li><a href='#make_prior_distribution'><p>Make a prior distribution from priors</p></a></li>
<li><a href='#observe_data'><p>Observe data, given a strategy</p></a></li>
<li><a href='#parameter_setting'><p>Setting parameters</p></a></li>
<li><a href='#parents_to_int'><p>Helper to turn parents_list into a list of data_realizations column positions</p></a></li>
<li><a href='#perm'><p>Produces the possible permutations of a set of nodes</p></a></li>
<li><a href='#plot_model'><p>Plots a DAG in ggplot style using a causal model input</p></a></li>
<li><a href='#prep_stan_data'><p>Prepare data for 'stan'</p></a></li>
<li><a href='#print.causal_model'><p>Print a short summary for a causal model</p></a></li>
<li><a href='#print.model_query'><p>Print a tightened summary of model queries</p></a></li>
<li><a href='#prior_setting'><p>Setting priors</p></a></li>
<li><a href='#query_distribution'><p>Calculate query distribution</p></a></li>
<li><a href='#query_helpers'><p>Query helpers</p></a></li>
<li><a href='#query_model'><p>Generate data frame for batches of causal queries</p></a></li>
<li><a href='#query_to_expression'><p>Helper to turn query into a data expression</p></a></li>
<li><a href='#realise_outcomes'><p>Realise outcomes</p></a></li>
<li><a href='#reveal_outcomes'><p>Reveal outcomes</p></a></li>
<li><a href='#set_confound'><p>Set confound</p></a></li>
<li><a href='#set_parameter_matrix'><p>Set parameter matrix</p></a></li>
<li><a href='#set_prior_distribution'><p>Add prior distribution draws</p></a></li>
<li><a href='#set_restrictions'><p>Restrict a model</p></a></li>
<li><a href='#summary.causal_model'><p>Summarizing causal models</p></a></li>
<li><a href='#summary.model_query'><p>Summarizing model queries</p></a></li>
<li><a href='#update_model'><p>Fit causal model using 'stan'</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Make, Update, and Query Binary Causal Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Users can declare causal models over binary nodes, update beliefs about causal types given data, and calculate arbitrary queries.  Updating is implemented in 'stan'. See Humphreys and Jacobs, 2023, Integrated Inferences (&lt;<a href="https://doi.org/10.1017%2F9781316718636">doi:10.1017/9781316718636</a>&gt;) and Pearl, 2009 Causality (&lt;<a href="https://doi.org/10.1017%2FCBO9780511803161">doi:10.1017/CBO9780511803161</a>&gt;).</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/integrated-inferences/CausalQueries/issues">https://github.com/integrated-inferences/CausalQueries/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, dirmult (&ge; 0.1.3-4), stats (&ge; 4.1.1), rlang (&ge;
0.2.0), rstan (&ge; 2.26.0), rstantools (&ge; 2.0.0), stringr (&ge;
1.4.0), latex2exp (&ge; 0.9.4), knitr (&ge; 1.45), ggplot2 (&ge;
3.3.5), lifecycle (&ge; 1.0.1), ggraph (&ge; 2.2.0), Rcpp (&ge;
0.12.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.0), BH (&ge; 1.66.0), RcppArmadillo, RcppEigen
(&ge; 0.3.3.3.0), rstan (&ge; 2.26.0), StanHeaders (&ge; 2.26.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, rmarkdown, DeclareDesign, fabricatr, estimatr,
bayesplot, covr, curl</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://integrated-inferences.github.io/CausalQueries/">https://integrated-inferences.github.io/CausalQueries/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-22 10:56:57 UTC; tilltietz</td>
</tr>
<tr>
<td>Author:</td>
<td>Clara Bicalho [ctb],
  Jasper Cooper [ctb],
  Macartan Humphreys
    <a href="https://orcid.org/0000-0001-7029-2326"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Till Tietz <a href="https://orcid.org/0000-0002-2916-9059"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Alan Jacobs [aut],
  Merlin Heidemanns [ctb],
  Lily Medina <a href="https://orcid.org/0009-0004-2423-524X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Julio Solis [ctb],
  Georgiy Syunyaev <a href="https://orcid.org/0000-0002-4391-6313"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Till Tietz &lt;ttietz2014@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-22 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CausalQueries'>'CausalQueries'</h2><span id='topic+CausalQueries-package'></span><span id='topic+CausalQueries'></span>

<h3>Description</h3>

<p>'CausalQueries' is a package that lets users generate binary causal models,
update over models given data, and calculate arbitrary causal queries.
Model definition makes use of dagitty type syntax.
Updating is implemented in 'stan'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Till Tietz <a href="mailto:ttietz2014@gmail.com">ttietz2014@gmail.com</a> (<a href="https://orcid.org/0000-0002-2916-9059">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Macartan Humphreys <a href="mailto:macartan@gmail.com">macartan@gmail.com</a> (<a href="https://orcid.org/0000-0001-7029-2326">ORCID</a>)
</p>
</li>
<li><p> Alan Jacobs <a href="mailto:alan.jacobs@ubc.ca">alan.jacobs@ubc.ca</a>
</p>
</li>
<li><p> Lily Medina <a href="mailto:lilymiru@gmail.com">lilymiru@gmail.com</a> (<a href="https://orcid.org/0009-0004-2423-524X">ORCID</a>)
</p>
</li>
<li><p> Georgiy Syunyaev <a href="mailto:georgiy.syunyaev@vanderbilt.edu">georgiy.syunyaev@vanderbilt.edu</a> (<a href="https://orcid.org/0000-0002-4391-6313">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Clara Bicalho <a href="mailto:clarabmcorreia@gmail.com">clarabmcorreia@gmail.com</a> [contributor]
</p>
</li>
<li><p> Jasper Cooper <a href="mailto:jjc2247@columbia.edu">jjc2247@columbia.edu</a> [contributor]
</p>
</li>
<li><p> Merlin Heidemanns <a href="mailto:mnh2123@columbia.edu">mnh2123@columbia.edu</a> [contributor]
</p>
</li>
<li><p> Julio Solis <a href="mailto:juliosolisar@gmail.com">juliosolisar@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://integrated-inferences.github.io/CausalQueries/">https://integrated-inferences.github.io/CausalQueries/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/integrated-inferences/CausalQueries/issues">https://github.com/integrated-inferences/CausalQueries/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_dots'>Helper to fill in missing do operators in causal expression</h2><span id='topic+add_dots'></span>

<h3>Description</h3>

<p>Helper to fill in missing do operators in causal expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dots(q, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_dots_+3A_q">q</code></td>
<td>
<p>A character string. Causal query with at least one parent node
missing their do operator.</p>
</td></tr>
<tr><td><code id="add_dots_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A causal query expression with all parents nodes set to
either 0, 1 or wildcard '.'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; Y &lt;- M')
CausalQueries:::add_dots('Y[X=1]', model)
CausalQueries:::add_dots('Y[]', model)

</code></pre>

<hr>
<h2 id='CausalQueries_internal_inherit_params'>Create parameter documentation to inherit</h2><span id='topic+CausalQueries_internal_inherit_params'></span>

<h3>Description</h3>

<p>Create parameter documentation to inherit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CausalQueries_internal_inherit_params(
  model,
  query,
  join_by,
  parameters,
  P,
  A,
  data,
  data_events,
  node,
  statement,
  using,
  n_draws
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_query">query</code></td>
<td>
<p>A character string. An expression defining nodal types to
interrogate. An expression of the form
&quot;Y[X=1]&quot; asks for the value of Y when X is set to 1</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_join_by">join_by</code></td>
<td>
<p>A logical operator. Used to connect causal statements:
<em>AND</em> ('&amp;') or <em>OR</em> ('|'). Defaults to '|'.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from the parameters dataframe.
See <code>inspect(model, "parameters_df")</code>.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations. See <code>inspect(model, "parameter_matrix")</code>.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_a">A</code></td>
<td>
<p>A <code>data.frame</code>. Ambiguities matrix. Not required but may be
provided to avoid repeated computation for simulations. <code>inspect(model, "ambiguities_matrix")</code></p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.  Data of nodes that can take three values:
0, 1, and NA. In long form as generated by <code><a href="#topic+make_events">make_events</a></code></p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_data_events">data_events</code></td>
<td>
<p>A 'compact' <code>data.frame</code> with one row per data type. Must be compatible with nodes in
<code>model</code>. The default columns are
<code>event</code>, <code>strategy</code> and <code>count</code>.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_node">node</code></td>
<td>
<p>A character string. The quoted name of a node.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_statement">statement</code></td>
<td>
<p>A character string. A quoted causal statement.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_using">using</code></td>
<td>
<p>A character string. Indicates whether to
use 'priors', 'posteriors' or 'parameters'.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_n_draws">n_draws</code></td>
<td>
<p>An integer. If no prior distribution is provided,
generate prior distribution with <code>n_draws</code> number of draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything. It is used to
inherit roxygen documentation
</p>

<hr>
<h2 id='clean_statement'>Helper to clean and check the validity of causal statements specifying a DAG.
This function isolates nodes and edges specified in a causal statements and
makes them processable by <code>make_dag</code></h2><span id='topic+clean_statement'></span>

<h3>Description</h3>

<p>Helper to clean and check the validity of causal statements specifying a DAG.
This function isolates nodes and edges specified in a causal statements and
makes them processable by <code>make_dag</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_statement(statement)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_statement_+3A_statement">statement</code></td>
<td>
<p>character string. Statement describing causal
relations between nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of nodes and edges specified in the input statement
</p>

<hr>
<h2 id='construct_commands_alter_at'>make_par_values</h2><span id='topic+construct_commands_alter_at'></span>

<h3>Description</h3>

<p>helper to generate filter commands specifying rows of parameters_df that
should be altered given an alter_at statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_commands_alter_at(alter_at)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_commands_alter_at_+3A_alter_at">alter_at</code></td>
<td>
<p>string specifying filtering operations to be applied to
parameters_df, yielding a logical vector indicating parameters for which
values should be altered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string specifying a filter command
</p>

<hr>
<h2 id='construct_commands_other_args'>make_par_values</h2><span id='topic+construct_commands_other_args'></span>

<h3>Description</h3>

<p>helper to generate filter commands specifying rows of parameters_df that
should be altered given combinations of nodes, nodal_types, param_sets,
givens and statements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_commands_other_args(
  node,
  nodal_type,
  param_set,
  given,
  statement,
  model,
  join_by
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_commands_other_args_+3A_node">node</code></td>
<td>
<p>string indicating nodes which are to be altered</p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_nodal_type">nodal_type</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_param_set">param_set</code></td>
<td>
<p>string indicating  the name of the set of parameters
to be altered</p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_given">given</code></td>
<td>
<p>string indicates the node on which the parameter
to be altered depends</p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_statement">statement</code></td>
<td>
<p>causal query that determines nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_model">model</code></td>
<td>
<p>model created with <code>make_model</code></p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_join_by">join_by</code></td>
<td>
<p>string specifying the logical operator joining expanded
types when <code>statement</code> contains wildcards.
Can take values <code>'&amp;'</code> (logical AND) or <code>'|'</code> (logical OR).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string specifying a filter command
</p>

<hr>
<h2 id='construct_commands_param_names'>make_par_values</h2><span id='topic+construct_commands_param_names'></span>

<h3>Description</h3>

<p>helper to generate filter commands specifying rows of parameters_df that
should be altered given an a vector of parameter names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_commands_param_names(param_names, model_param_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_commands_param_names_+3A_param_names">param_names</code></td>
<td>
<p>vector of strings. The name of specific parameter in
the form of, for example, 'X.1', 'Y.01'</p>
</td></tr>
<tr><td><code id="construct_commands_param_names_+3A_model_param_names">model_param_names</code></td>
<td>
<p>vector of strings. Parameter names found
in the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string specifying a filter command
</p>

<hr>
<h2 id='data_helpers'>Data helpers</h2><span id='topic+data_helpers'></span><span id='topic+collapse_data'></span><span id='topic+expand_data'></span><span id='topic+make_data'></span><span id='topic+make_events'></span>

<h3>Description</h3>

<p>Various helpers to simulate data and to manipulate data types between compact and long forms.
</p>
<p><code>collapse_data</code> can be used to convert long form data to compact form data,
</p>
<p><code>expand_data</code> can be used to convert compact form data (one row per data type) to long form data (one row per observation).
</p>
<p><code>make_data</code> generates a dataset with one row per observation.
</p>
<p><code>make_events</code> generates a dataset with one row for each data type.
Draws full data only. To generate various types of incomplete data see
<code><a href="#topic+make_data">make_data</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_data(
  data,
  model,
  drop_NA = TRUE,
  drop_family = FALSE,
  summary = FALSE
)

expand_data(data_events = NULL, model)

make_data(
  model,
  n = NULL,
  parameters = NULL,
  param_type = NULL,
  nodes = NULL,
  n_steps = NULL,
  probs = NULL,
  subsets = TRUE,
  complete_data = NULL,
  given = NULL,
  verbose = FALSE,
  ...
)

make_events(
  model,
  n = 1,
  w = NULL,
  P = NULL,
  A = NULL,
  parameters = NULL,
  param_type = NULL,
  include_strategy = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_helpers_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.  Data of nodes that can take three values:
0, 1, and NA. In long form as generated by <code><a href="#topic+make_events">make_events</a></code></p>
</td></tr>
<tr><td><code id="data_helpers_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_drop_na">drop_NA</code></td>
<td>
<p>Logical. Whether to exclude strategy families that contain
no observed data. Exceptionally if no data is provided, minimal data on
data on first node is returned. Defaults to 'TRUE'</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_drop_family">drop_family</code></td>
<td>
<p>Logical. Whether to remove column <code>strategy</code> from
the output. Defaults to 'FALSE'.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_summary">summary</code></td>
<td>
<p>Logical. Whether to return summary of the data. See details.
Defaults to 'FALSE'.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_data_events">data_events</code></td>
<td>
<p>A 'compact' <code>data.frame</code> with one row per data type. Must be compatible with nodes in
<code>model</code>. The default columns are
<code>event</code>, <code>strategy</code> and <code>count</code>.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_n">n</code></td>
<td>
<p>An integer. Number of observations.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from the parameters dataframe.
See <code>inspect(model, "parameters_df")</code>.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_param_type">param_type</code></td>
<td>
<p>A character. String specifying type of parameters to make
'flat', 'prior_mean', 'posterior_mean', 'prior_draw', 'posterior_draw',
'define. With param_type set to <code>define</code> use arguments to be passed
to <code>make_priors</code>; otherwise <code>flat</code> sets equal probabilities on
each nodal type in each parameter set; <code>prior_mean</code>,
<code>prior_draw</code>, <code>posterior_mean</code>, <code>posterior_draw</code> take
parameters as the means or as draws from the prior or posterior.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_nodes">nodes</code></td>
<td>
<p>A <code>list</code>. Which nodes to be observed at each step.
If NULL all nodes are observed.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_n_steps">n_steps</code></td>
<td>
<p>A <code>list</code>. Number of observations to be
observed at each step</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_probs">probs</code></td>
<td>
<p>A <code>list</code>. Observation probabilities at each step</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_subsets">subsets</code></td>
<td>
<p>A <code>list</code>. Strata within which observations are to be
observed at each step. TRUE for all, otherwise an expression that
evaluates to a logical condition.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_complete_data">complete_data</code></td>
<td>
<p>A <code>data.frame</code>. Dataset with complete
observations. Optional.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_given">given</code></td>
<td>
<p>A string specifying known values on nodes, e.g. &quot;X==1 &amp; Y==1&quot;</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE prints step schedule.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to make_priors if
param_type == <code>define</code></p>
</td></tr>
<tr><td><code id="data_helpers_+3A_w">w</code></td>
<td>
<p>A numeric matrix. A 'n_parameters x 1' matrix of event
probabilities with named rows.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations. See <code>inspect(model, "parameter_matrix")</code>.</p>
</td></tr>
<tr><td><code id="data_helpers_+3A_a">A</code></td>
<td>
<p>A <code>data.frame</code>. Ambiguities matrix. Not required but may be
provided to avoid repeated computation for simulations. <code>inspect(model, "ambiguities_matrix")</code></p>
</td></tr>
<tr><td><code id="data_helpers_+3A_include_strategy">include_strategy</code></td>
<td>
<p>Logical. Whether to include a 'strategy' vector.
Defaults to FALSE. Strategy vector does not vary with full data but
expected by some functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that default behavior is not to take account of whether a node has
already been observed when determining whether to select or not. One can
however specifically request observation of nodes that have not been
previously observed.
</p>


<h3>Value</h3>

<p>A vector of data events
</p>
<p>If <code>summary = TRUE</code> 'collapse_data' returns a list containing the
following components:
</p>
<table role = "presentation">
<tr><td><code>data_events</code></td>
<td>
<p>A compact data.frame of event types and strategies.</p>
</td></tr>
<tr><td><code>observed_events</code></td>
<td>
<p>A vector of character strings specifying the events
observed in the data</p>
</td></tr>
<tr><td><code>unobserved_events</code></td>
<td>
<p>A vector of character strings specifying the
events not observed in the data</p>
</td></tr>
</table>
<p>A <code>data.frame</code> with rows as data observation
</p>
<p>A <code>data.frame</code> with simulated data.
</p>
<p>A <code>data.frame</code> of events
</p>


<h3>See Also</h3>

<p>Other data_generation: 
<code><a href="#topic+get_all_data_types">get_all_data_types</a>()</code>,
<code><a href="#topic+make_data_single">make_data_single</a>()</code>,
<code><a href="#topic+observe_data">observe_data</a>()</code>
</p>
<p>Other data_generation: 
<code><a href="#topic+get_all_data_types">get_all_data_types</a>()</code>,
<code><a href="#topic+make_data_single">make_data_single</a>()</code>,
<code><a href="#topic+observe_data">observe_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

model &lt;- make_model('X -&gt; Y')

df &lt;- data.frame(X = c(0,1,NA), Y = c(0,0,1))

df |&gt; collapse_data(model)

# Illustrating options

df |&gt; collapse_data(model, drop_NA = FALSE)

df |&gt; collapse_data(model, drop_family = TRUE)

df |&gt; collapse_data(model, summary = TRUE)

# Appropriate behavior given restricted models

model &lt;- make_model('X -&gt; Y') |&gt;
  set_restrictions('X[]==1')
df &lt;- make_data(model, n = 10)
df[1,1] &lt;- ''
df |&gt; collapse_data(model)

df &lt;- data.frame(X = 0:1)
df |&gt; collapse_data(model)




model &lt;- make_model('X-&gt;M-&gt;Y')
make_events(model, n = 5) |&gt;
  expand_data(model)
make_events(model, n = 0) |&gt;
  expand_data(model)
 


# Simple draws
model &lt;- make_model("X -&gt; M -&gt; Y")
make_data(model)
make_data(model, n = 3, nodes = c("X","Y"))
make_data(model, n = 3, param_type = "prior_draw")
make_data(model, n = 10, param_type = "define", parameters =  0:9)

# Data Strategies
# A strategy in which X, Y are observed for sure and M is observed
# with 50% probability for X=1, Y=0 cases

model &lt;- make_model("X -&gt; M -&gt; Y")
make_data(
  model,
  n = 8,
  nodes = list(c("X", "Y"), "M"),
  probs = list(1, .5),
  subsets = list(TRUE, "X==1 &amp; Y==0"))

# n not provided but inferred from largest n_step (not from sum of n_steps)
make_data(
  model,
  nodes = list(c("X", "Y"), "M"),
  n_steps = list(5, 2))

# Wide then deep
  make_data(
  model,
  n = 8,
  nodes = list(c("X", "Y"), "M"),
  subsets = list(TRUE, "!is.na(X) &amp; !is.na(Y)"),
  n_steps = list(6, 2))


make_data(
  model,
  n = 8,
  nodes = list(c("X", "Y"), c("X", "M")),
  subsets = list(TRUE, "is.na(X)"),
  n_steps = list(3, 2))

# Example with probabilities at each step

make_data(
  model,
  n = 8,
  nodes = list(c("X", "Y"), c("X", "M")),
  subsets = list(TRUE, "is.na(X)"),
  probs = list(.5, .2))

# Example with given data
make_data(model, given = "X==1 &amp; Y==1", n = 5)

model &lt;- make_model('X -&gt; Y')
make_events(model = model)
make_events(model = model, param_type = 'prior_draw')
make_events(model = model, include_strategy = TRUE)


</code></pre>

<hr>
<h2 id='democracy_data'>Development and Democratization: Data for replication of analysis in
*Integrated Inferences*</h2><span id='topic+democracy_data'></span>

<h3>Description</h3>

<p>A dataset containing information on inequality, democracy, mobilization,
and international pressure.
Made by <code>devtools::use_data(democracy_data, CausalQueries)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>democracy_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 84 rows and 5 nodes:
</p>

<dl>
<dt>Case</dt><dd><p>Case</p>
</dd>
<dt>D</dt><dd><p>Democracy</p>
</dd>
<dt>I</dt><dd><p>Inequality</p>
</dd>
<dt>P</dt><dd><p>International Pressure</p>
</dd>
<dt>M</dt><dd><p>Mobilization</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.cambridge.org/core/journals/american-political-science-review/article/inequality-and-regime-change-democratic-transitions-and-the-stability-of-democratic-rule/C39AAF4CF274445555FF41F7CC896AE3#fndtn-supplementary-materials/">https://www.cambridge.org/core/journals/american-political-science-review/article/inequality-and-regime-change-democratic-transitions-and-the-stability-of-democratic-rule/C39AAF4CF274445555FF41F7CC896AE3#fndtn-supplementary-materials/</a>
</p>

<hr>
<h2 id='draw_causal_type'>Draw a single causal type given a parameter vector</h2><span id='topic+draw_causal_type'></span>

<h3>Description</h3>

<p>Output is a parameter data frame recording both parameters
(case level priors) and
the case level causal type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_causal_type(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_causal_type_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="draw_causal_type_+3A_...">...</code></td>
<td>
<p>Arguments passed to  'set_parameters'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple draw using model's parameter vector
make_model("X -&gt; M -&gt; Y") |&gt;
draw_causal_type()

# Draw parameters from priors and draw type from parameters
make_model("X -&gt; M -&gt; Y") |&gt;
draw_causal_type(, param_type = "prior_draw")

# Draw type given specified parameters
make_model("X -&gt; M -&gt; Y") |&gt;
draw_causal_type(parameters = 1:10)

</code></pre>

<hr>
<h2 id='expand_nodal_expression'>Helper to expand nodal expression</h2><span id='topic+expand_nodal_expression'></span>

<h3>Description</h3>

<p>Helper to expand nodal expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_nodal_expression(model, query, node, join_by = "|")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_nodal_expression_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="expand_nodal_expression_+3A_query">query</code></td>
<td>
<p>A character string. An expression defining nodal types to
interrogate. An expression of the form
&quot;Y[X=1]&quot; asks for the value of Y when X is set to 1</p>
</td></tr>
<tr><td><code id="expand_nodal_expression_+3A_node">node</code></td>
<td>
<p>A character string. The quoted name of a node.</p>
</td></tr>
<tr><td><code id="expand_nodal_expression_+3A_join_by">join_by</code></td>
<td>
<p>A logical operator. Used to connect causal statements:
<em>AND</em> ('&amp;') or <em>OR</em> ('|'). Defaults to '|'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nodal expression with no missing parents
</p>

<hr>
<h2 id='get_all_data_types'>Get all data types</h2><span id='topic+get_all_data_types'></span>

<h3>Description</h3>

<p>Creates data frame with all data types (including NA types)
that are possible from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_data_types(
  model,
  complete_data = FALSE,
  possible_data = FALSE,
  given = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_all_data_types_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_all_data_types_+3A_complete_data">complete_data</code></td>
<td>
<p>Logical. If 'TRUE' returns only complete data types
(no NAs). Defaults to 'FALSE'.</p>
</td></tr>
<tr><td><code id="get_all_data_types_+3A_possible_data">possible_data</code></td>
<td>
<p>Logical. If 'TRUE' returns only complete data types
(no NAs) that are *possible* given model restrictions. Note that in
principle an intervention could make observationally impossible data types
arise. Defaults to 'FALSE'.</p>
</td></tr>
<tr><td><code id="get_all_data_types_+3A_given">given</code></td>
<td>
<p>A character.  A quoted statement that evaluates to logical.
Data conditional on specific values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with all data types (including NA types)
that are possible from a model.
</p>


<h3>See Also</h3>

<p>Other data_generation: 
<code><a href="#topic+data_helpers">data_helpers</a></code>,
<code><a href="#topic+make_data_single">make_data_single</a>()</code>,
<code><a href="#topic+observe_data">observe_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
make_model('X -&gt; Y') |&gt; get_all_data_types()
model &lt;- make_model('X -&gt; Y') |&gt;
  set_restrictions(labels = list(Y = '00'), keep = TRUE)
  get_all_data_types(model)
  get_all_data_types(model, complete_data = TRUE)
  get_all_data_types(model, possible_data = TRUE)
  get_all_data_types(model, given  = 'X==1')
  get_all_data_types(model, given  = 'X==1 &amp; Y==1')

</code></pre>

<hr>
<h2 id='get_estimands'>helper to get estimands</h2><span id='topic+get_estimands'></span>

<h3>Description</h3>

<p>helper to get estimands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_estimands(jobs, given_types, query_types, type_posteriors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_estimands_+3A_jobs">jobs</code></td>
<td>
<p>a data frame of argument combinations</p>
</td></tr>
<tr><td><code id="get_estimands_+3A_given_types">given_types</code></td>
<td>
<p>output from <code>queries_to_types</code></p>
</td></tr>
<tr><td><code id="get_estimands_+3A_query_types">query_types</code></td>
<td>
<p>output from <code>queries_to_types</code></p>
</td></tr>
<tr><td><code id="get_estimands_+3A_type_posteriors">type_posteriors</code></td>
<td>
<p>output from <code>get_type_posteriors</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of estimands
</p>

<hr>
<h2 id='get_event_probabilities'>Draw event probabilities</h2><span id='topic+get_event_probabilities'></span>

<h3>Description</h3>

<p>'get_event_probabilities' draws event probability vector 'w' given a single
realization of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_event_probabilities(
  model,
  parameters = NULL,
  A = NULL,
  P = NULL,
  given = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_event_probabilities_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_event_probabilities_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from the parameters dataframe.
See <code>inspect(model, "parameters_df")</code>.</p>
</td></tr>
<tr><td><code id="get_event_probabilities_+3A_a">A</code></td>
<td>
<p>A <code>data.frame</code>. Ambiguities matrix. Not required but may be
provided to avoid repeated computation for simulations. <code>inspect(model, "ambiguities_matrix")</code></p>
</td></tr>
<tr><td><code id="get_event_probabilities_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations. See <code>inspect(model, "parameter_matrix")</code>.</p>
</td></tr>
<tr><td><code id="get_event_probabilities_+3A_given">given</code></td>
<td>
<p>A string specifying known values on nodes, e.g. &quot;X==1 &amp; Y==1&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of event probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; Y')
get_event_probabilities(model = model)
get_event_probabilities(model = model, given = "X==1")
get_event_probabilities(model = model, parameters = rep(1, 6))
get_event_probabilities(model = model, parameters = 1:6)


</code></pre>

<hr>
<h2 id='get_parameter_matrix'>Get parameter matrix</h2><span id='topic+get_parameter_matrix'></span>

<h3>Description</h3>

<p>Return parameter matrix if it exists; otherwise calculate it assuming no
confounding. The parameter matrix  maps from parameters into causal types.
In models without confounding parameters correspond to nodal types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parameter_matrix(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_parameter_matrix_+3A_model">model</code></td>
<td>
<p>A model created by <code>make_model()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, the parameter matrix, mapping from
parameters to causal types
</p>

<hr>
<h2 id='get_query_types'>Look up query types</h2><span id='topic+get_query_types'></span>

<h3>Description</h3>

<p>Find which nodal or causal types are satisfied by a query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_query_types(model, query, map = "causal_type", join_by = "|")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_query_types_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_query_types_+3A_query">query</code></td>
<td>
<p>A character string. An expression defining nodal types to
interrogate. An expression of the form
&quot;Y[X=1]&quot; asks for the value of Y when X is set to 1</p>
</td></tr>
<tr><td><code id="get_query_types_+3A_map">map</code></td>
<td>
<p>Types in query. Either <code>nodal_type</code> or <code>causal_type</code>.
Default is <code>causal_type</code>.</p>
</td></tr>
<tr><td><code id="get_query_types_+3A_join_by">join_by</code></td>
<td>
<p>A logical operator. Used to connect causal statements:
<em>AND</em> ('&amp;') or <em>OR</em> ('|'). Defaults to '|'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing some of the following elements
</p>
<table role = "presentation">
<tr><td><code>types</code></td>
<td>
<p>A named vector with logical values indicating whether a
<code>nodal_type</code> or a <code>causal_type</code> satisfy 'query'</p>
</td></tr>
<tr><td><code>query</code></td>
<td>
<p>A character string as specified by the user</p>
</td></tr>
<tr><td><code>expanded_query</code></td>
<td>
<p>A character string with the expanded query.
Only differs from &lsquo;query' if this contains wildcard &rsquo;.'</p>
</td></tr>
<tr><td><code>evaluated_nodes</code></td>
<td>
<p>Value that the nodes take given a query</p>
</td></tr>
<tr><td><code>node</code></td>
<td>
<p>A character string of the node whose
nodal types are being queried</p>
</td></tr>
<tr><td><code>type_list</code></td>
<td>
<p>List of causal types satisfied by a query</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; M -&gt; Y; X-&gt;Y')
query &lt;- '(Y[X=0] &gt; Y[X=1])'

get_query_types(model, query, map="nodal_type")
get_query_types(model, query, map="causal_type")
get_query_types(model, query)

# Examples with map = "nodal_type"

query &lt;- '(Y[X=0, M = .] &gt; Y[X=1, M = 0])'
get_query_types(model, query, map="nodal_type")

query &lt;- '(Y[] == 1)'
get_query_types(model, query, map="nodal_type")
get_query_types(model, query, map="nodal_type", join_by = '&amp;')

# Root nodes specified with []
get_query_types(model, '(X[] == 1)', map="nodal_type")

query &lt;- '(M[X=1] == M[X=0])'
get_query_types(model, query, map="nodal_type")

# Nested do operations
get_query_types(
 model = make_model('A -&gt; B -&gt; C -&gt; D'),
 query = '(D[C=C[B=B[A=1]], A=0] &gt; D[C=C[B=B[A=0]], A=0])')

# Helpers
model &lt;- make_model('M-&gt;Y; X-&gt;Y')
query &lt;- complements('X', 'M', 'Y')
get_query_types(model, query, map="nodal_type")

# Examples with map = "causal_type"

model &lt;- make_model('X -&gt; M -&gt; Y; X-&gt;Y')
query &lt;- 'Y[M=M[X=0], X=1]==1'
get_query_types(model, query, map= "causal_type")

query &lt;- '(Y[X = 1, M = 1] &gt;  Y[X = 0, M = 1]) &amp;
          (Y[X = 1, M = 0] &gt;  Y[X = 0, M = 0])'
get_query_types(model, query, "causal_type")

query &lt;- 'Y[X=1] == Y[X=0]'
get_query_types(model, query, "causal_type")

query &lt;- '(X == 1) &amp; (M==1) &amp; (Y ==1) &amp; (Y[X=0] ==1)'
get_query_types(model, query, "causal_type")

query &lt;- '(Y[X = .]==1)'
get_query_types(model, query, "causal_type")

</code></pre>

<hr>
<h2 id='get_type_posteriors'>helper to get type distributions</h2><span id='topic+get_type_posteriors'></span>

<h3>Description</h3>

<p>helper to get type distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_type_posteriors(jobs, model, n_draws, parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_type_posteriors_+3A_jobs">jobs</code></td>
<td>
<p>data frame of argument combinations</p>
</td></tr>
<tr><td><code id="get_type_posteriors_+3A_model">model</code></td>
<td>
<p>a list of models</p>
</td></tr>
<tr><td><code id="get_type_posteriors_+3A_n_draws">n_draws</code></td>
<td>
<p>integer specifying number of draws from prior distribution</p>
</td></tr>
<tr><td><code id="get_type_posteriors_+3A_parameters">parameters</code></td>
<td>
<p>optional list of parameter vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>jobs data frame with a nested column of type distributions
</p>

<hr>
<h2 id='inspection'>Helpers for inspecting causal models</h2><span id='topic+inspection'></span><span id='topic+inspect'></span><span id='topic+grab'></span>

<h3>Description</h3>

<p>Various helpers to inspect or access internal objects generated or used by Causal Models
</p>
<p>Returns specified elements from a <code>causal_model</code> and prints summary.
Users can use <code>inspect</code> to extract model's components or objects implied by
the model structure including nodal types, causal types, parameter priors,
parameter posteriors, type priors, type posteriors, and other relevant elements.
See argument <code>what</code> for other options.
</p>
<p>Returns specified elements from a <code>causal_model</code>.
Users can use <code>inspect</code> to extract model's components or objects implied by
the model structure including nodal types, causal types, parameter priors,
parameter posteriors, type priors, type posteriors, and other relevant elements.
See argument <code>what</code> for other options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect(model, what = NULL, ...)

grab(model, what = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inspection_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="inspection_+3A_what">what</code></td>
<td>
<p>A character string specifying the component to retrieve.
Available options are:
</p>

<ul>
<li><p> &quot;<code>statement</code>&quot; a character string describing causal relations using dagitty syntax,
</p>
</li>
<li><p> &quot;<code>nodes</code>&quot; A list containing the nodes in the model,
</p>
</li>
<li><p> &quot;<code>parents_df</code>&quot; A table listing nodes, whether they are root nodes or not, and the number and names of parents they have,
</p>
</li>
<li><p> &quot;<code>parameters</code>&quot; A vector of 'true' parameters,
</p>
</li>
<li><p> &quot;<code>parameter_names</code>&quot; A vector of names of parameters,
</p>
</li>
<li><p> &quot;<code>parameter_mapping</code>&quot; A matrix mapping from parameters into data types,
</p>
</li>
<li><p> &quot;<code>parameter_matrix</code>&quot; A matrix mapping from parameters into causal types,
</p>
</li>
<li><p> &quot;<code>parameters_df</code>&quot; A data frame containing parameter information,
</p>
</li>
<li><p> &quot;<code>causal_types</code>&quot; A data frame listing causal types and the nodal types that produce them,
</p>
</li>
<li><p> &quot;<code>nodal_types</code>&quot; A list with the nodal types of the model,
</p>
</li>
<li><p> &quot;<code>data_types</code>&quot; A list with all data types consistent with the model; for options see <code>?get_all_data_types</code>,
</p>
</li>
<li><p> &quot;<code>ambiguities_matrix</code>&quot; A matrix mapping from causal types into data types,
</p>
</li>
<li><p> &quot;<code>prior_hyperparameters</code>&quot; A vector of alpha values used to parameterize Dirichlet prior distributions; optionally provide node names to reduce output, e.g., <code>inspect(prior_hyperparameters, nodes = c('M', 'Y'))</code>,
</p>
</li>
<li><p> &quot;<code>prior_distribution</code>&quot; A data frame of the parameter prior distribution,
</p>
</li>
<li><p> &quot;<code>posterior_distribution</code>&quot; A data frame of the parameter posterior distribution,
</p>
</li>
<li><p> &quot;<code>type_prior</code>&quot; A matrix of type probabilities using priors,
</p>
</li>
<li><p> &quot;<code>type_posterior</code>&quot; A matrix of type probabilities using posteriors,
</p>
</li>
<li><p> &quot;<code>prior_event_probabilities</code>&quot; A vector of data (event) probabilities given a single realization of parameters; for options see <code>?get_event_probabilities</code>,
</p>
</li>
<li><p> &quot;<code>posterior_event_probabilities</code>&quot; A sample of data (event) probabilities from the posterior,
</p>
</li>
<li><p> &quot;<code>data</code>&quot; A data frame with data that was provided to update the model,
</p>
</li>
<li>  <p><code>stan_summary</code>&quot; A 'stanfit' summary with processed parameter names,
</p>
</li>
<li><p> &quot;<code>stanfit</code>&quot; An (unprocessed) <code>stanfit</code> object as generated by Stan, with raw parameter names,
</p>
</li>
<li><p> &quot;<code>stan_warnings</code>&quot; Messages generated during the generation of a <code>stanfit</code> object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inspection_+3A_...">...</code></td>
<td>
<p>Other arguments passed to helper <code>"get_*"</code> functions: get_all_data_types, get_event_probabilities,  get_priors, Any such additional arguments must be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Objects  that can be derived from a <code>causal_model</code>, with summary.
</p>
<p>Quiet return of objects that can be derived from a <code>causal_model</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

model &lt;- make_model("X -&gt; Y")
data &lt;- make_data(model, n = 4)

inspect(model, what = "statement")
inspect(model, what = "parameters")
inspect(model, what = "nodes")
inspect(model, what = "parents_df")
inspect(model, what = "parameters_df")
inspect(model, what = "causal_types")
inspect(model, what = "prior_distribution")
inspect(model, what = "prior_hyperparameters", nodes = "Y")
inspect(model, what = "prior_event_probabilities", parameters = c(.1, .9, .25, .25, 0, .5))
inspect(model, what = "prior_event_probabilities", given = "Y==1")
inspect(model, what = "data_types", complete_data = TRUE)
inspect(model, what = "data_types", complete_data = FALSE)


model &lt;- update_model(model,
  data = data,
  keep_fit = TRUE,
  keep_event_probabilities = TRUE)

inspect(model, what = "posterior_distribution")
inspect(model, what = "posterior_event_probabilities")
inspect(model, what = "type_posterior")
inspect(model, what = "data")
inspect(model, what = "stan_warnings")
inspect(model, what = "stanfit")


model &lt;- make_model("X -&gt; Y")

x &lt;- grab(model, what = "statement")
x
</code></pre>

<hr>
<h2 id='institutions_data'>Institutions and growth: Data for replication of analysis in
*Integrated Inferences*</h2><span id='topic+institutions_data'></span>

<h3>Description</h3>

<p>A  dataset containing dichotomized versions of variables in
Rodrik, Subramanian, and Trebbi (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>institutions_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 79 rows and 5 columns:
</p>

<dl>
<dt>Y</dt><dd><p>Income (GDP PPP 1995), dichotomized</p>
</dd>
<dt>R</dt><dd><p>Institutions, (based on  Kaufmann, Kraay, and Zoido-Lobaton (2002)) dichotomized</p>
</dd>
<dt>D</dt><dd><p>Distance from the equator (in degrees), dichotomized</p>
</dd>
<dt>M</dt><dd><p>Settler mortality (from Acemoglu, Johnson, and Robinson), dichotomized</p>
</dd>
<dt>country</dt><dd><p>Country</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://drodrik.scholar.harvard.edu/publications/institutions-rule-primacy-institutions-over-geography-and-integration">https://drodrik.scholar.harvard.edu/publications/institutions-rule-primacy-institutions-over-geography-and-integration</a>
</p>

<hr>
<h2 id='interpret_type'>Interpret or find position in nodal type</h2><span id='topic+interpret_type'></span>

<h3>Description</h3>

<p>Interprets the position of one or more digits (specified by <code>position</code>)
in a nodal type. Alternatively returns nodal type digit positions that
correspond to one or more given <code>condition</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpret_type(model, condition = NULL, position = NULL, nodes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpret_type_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="interpret_type_+3A_condition">condition</code></td>
<td>
<p>A vector of characters. Strings specifying the child node,
followed by '|' (given) and the values of its parent nodes in <code>model</code>.</p>
</td></tr>
<tr><td><code id="interpret_type_+3A_position">position</code></td>
<td>
<p>A named list of integers. The name is the name of the child
node in <code>model</code>, and its value a vector of digit positions in that
node's nodal type to be interpreted. See 'Details'.</p>
</td></tr>
<tr><td><code id="interpret_type_+3A_nodes">nodes</code></td>
<td>
<p>A vector of names of nodes. Can be used to limit interpretation to selected nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A node for a child node X with <code>k</code> parents has a nodal type
represented by X followed by <code>2^k</code> digits. Argument <code>position</code>
allows user to interpret the meaning of one or more digit positions in any
nodal type. For example <code>position = list(X = 1:3)</code> will return the
interpretation of the first three digits in causal types for X.
Argument <code>condition</code> allows users to query the digit position in the
nodal type by providing instead the values of the parent nodes of a given
child. For example, <code>condition = 'X | Z=0 &amp; R=1'</code> returns the digit
position that corresponds to values X takes when Z = 0 and R = 1.
</p>


<h3>Value</h3>

<p>A named <code>list</code> with interpretation of positions of
the digits in a nodal type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('R -&gt; X; Z -&gt; X; X -&gt; Y')
#Return interpretation of all digit positions of all nodes
interpret_type(model)
#Example using digit position
interpret_type(model, position = list(X = c(3,4), Y = 1))
interpret_type(model, position = list(R = 1))
#Example using condition
interpret_type(model, condition = c('X | Z=0 &amp; R=1', 'X | Z=0 &amp; R=0'))
# Example using node names
interpret_type(model, nodes = c("Y", "R"))
</code></pre>

<hr>
<h2 id='lipids_data'>Lipids: Data for Chickering and Pearl replication</h2><span id='topic+lipids_data'></span>

<h3>Description</h3>

<p>A compact dataset containing information on an encouragement,
(Z, cholestyramine prescription), a treatment (X, usage), and
an outcome (Y, cholesterol).
From David Maxwell Chickering and Judea Pearl: &quot;A Clinician’s Tool for
Analyzing Non-compliance&quot;, AAAI-96 Proceedings. Chickering and Pearl in turn
draw the data from Efron, Bradley, and David Feldman.
&quot;Compliance as an explanatory variable in clinical trials.&quot;
Journal of the American Statistical Association 86.413 (1991): 9-17.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lipids_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 8 rows and 3 columns:
</p>

<dl>
<dt>event</dt><dd><p>The data type</p>
</dd>
<dt>strategy</dt><dd><p>For which nodes is data available</p>
</dd>
<dt>count</dt><dd><p>Number of units with this data type</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://cdn.aaai.org/AAAI/1996/AAAI96-188.pdf">https://cdn.aaai.org/AAAI/1996/AAAI96-188.pdf</a>
</p>

<hr>
<h2 id='list_non_parents'>Returns a list with the nodes that are not directly pointing into a node</h2><span id='topic+list_non_parents'></span>

<h3>Description</h3>

<p>Returns a list with the nodes that are not directly pointing into a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_non_parents(model, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_non_parents_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="list_non_parents_+3A_node">node</code></td>
<td>
<p>A character string. The quoted name of a node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the nodes that are not directly
pointing into a node
</p>

<hr>
<h2 id='make_dag'>Helper to run a causal statement specifying a DAG into a <code>data.frame</code> of
pairwise parent child relations between nodes specified by a respective edge.</h2><span id='topic+make_dag'></span>

<h3>Description</h3>

<p>Helper to run a causal statement specifying a DAG into a <code>data.frame</code> of
pairwise parent child relations between nodes specified by a respective edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_dag(statement)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_dag_+3A_statement">statement</code></td>
<td>
<p>character string. Statement describing causal
relations between nodes. Only directed relations are
permitted. For instance &quot;X -&gt; Y&quot; or  &quot;X1 -&gt; Y &lt;- X2; X1 -&gt; X2&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns v, w, e specifying parent, child and
edge respectively
</p>

<hr>
<h2 id='make_data_single'>Generate full dataset</h2><span id='topic+make_data_single'></span>

<h3>Description</h3>

<p>Generate full dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_data_single(
  model,
  n = 1,
  parameters = NULL,
  param_type = NULL,
  given = NULL,
  w = NULL,
  P = NULL,
  A = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_data_single_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_n">n</code></td>
<td>
<p>An integer. Number of observations.</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_parameters">parameters</code></td>
<td>
<p>A numeric vector. Values of parameters may be specified.
By default, parameters is drawn from priors.</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_param_type">param_type</code></td>
<td>
<p>A character. String specifying type of parameters to make
(&quot;flat&quot;, &quot;prior_mean&quot;, &quot;posterior_mean&quot;, &quot;prior_draw&quot;,
&quot;posterior_draw&quot;, &quot;define). With param_type set to <code>define</code> use
arguments to be passed to <code>make_priors</code>; otherwise <code>flat</code> sets
equal probabilities on each nodal type in each parameter set;
<code>prior_mean</code>, <code>prior_draw</code>, <code>posterior_mean</code>,
<code>posterior_draw</code> take parameters as the means or as draws
from the prior or posterior.</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_given">given</code></td>
<td>
<p>A string specifying known values on nodes, e.g. &quot;X==1 &amp; Y==1&quot;</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_w">w</code></td>
<td>
<p>Vector of event probabilities can be provided directly.
This is useful for speed for repeated data draws.</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_p">P</code></td>
<td>
<p>A <code>matrix</code>. Parameter matrix that can be used to
generate w if w is not provided</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_a">A</code></td>
<td>
<p>A <code>matrix</code>. Ambiguity matrix that can be used
to generate w if w is not provided</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of simulated data.
</p>


<h3>See Also</h3>

<p>Other data_generation: 
<code><a href="#topic+data_helpers">data_helpers</a></code>,
<code><a href="#topic+get_all_data_types">get_all_data_types</a>()</code>,
<code><a href="#topic+observe_data">observe_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model("X -&gt; Y")

# Simplest behavior uses by default the parameter vector contained in model
CausalQueries:::make_data_single(model, n = 5)

CausalQueries:::make_data_single(model, n = 5, param_type = "prior_draw")

# Simulate multiple datasets. This is fastest if
# event probabilities (w) are  provided
w &lt;- get_event_probabilities(model)
replicate(5, CausalQueries:::make_data_single(model, n = 5, w = w))

</code></pre>

<hr>
<h2 id='make_model'>Make a model</h2><span id='topic+make_model'></span>

<h3>Description</h3>

<p><code>make_model</code> uses causal statements encoded as strings to specify
the nodes and edges of a graph. Implied causal types are calculated
and default priors are provided under the assumption of no confounding.
Models can be updated with specification of a parameter matrix, <code>P</code>, by
providing restrictions on causal types, and/or by providing informative
priors on parameters. The default setting for a causal model have flat
(uniform) priors and parameters putting equal weight on each parameter
within each parameter set. These can be adjust with <code>set_priors</code>
and <code>set_parameters</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_model(statement = "X -&gt; Y", add_causal_types = TRUE, nodal_types = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_model_+3A_statement">statement</code></td>
<td>
<p>character string. Statement describing causal
relations between nodes. Only directed relations are
permitted. For instance &quot;X -&gt; Y&quot; or  &quot;X1 -&gt; Y &lt;- X2; X1 -&gt; X2&quot;.</p>
</td></tr>
<tr><td><code id="make_model_+3A_add_causal_types">add_causal_types</code></td>
<td>
<p>Logical. Whether to create and attach causal
types to <code>model</code>. Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="make_model_+3A_nodal_types">nodal_types</code></td>
<td>
<p>List of nodal types associated with model nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>causal_model</code>.
</p>
<p>An object of class <code>"causal_model"</code> is a list containing at least the
following components:
</p>
<table role = "presentation">
<tr><td><code>statement</code></td>
<td>
<p>A character vector of the statement that defines the model</p>
</td></tr>
<tr><td><code>dag</code></td>
<td>
<p>A <code>data.frame</code> with columns 'parent'and 'children'
indicating how nodes relate to each other.</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>A named <code>list</code> with the nodes in the model</p>
</td></tr>
<tr><td><code>parents_df</code></td>
<td>
<p>A <code>data.frame</code> listing nodes, whether they are
root nodes or not, and the number of parents they have</p>
</td></tr>
<tr><td><code>nodal_types</code></td>
<td>
<p>Optional: A named <code>list</code> with the nodal types in
the model. List should be ordered according to the causal ordering of
nodes. If NULL nodal types are generated. If FALSE, a parameters data
frame is not generated.</p>
</td></tr>
<tr><td><code>parameters_df</code></td>
<td>
<p>A <code>data.frame</code> with descriptive information
of the parameters in the model</p>
</td></tr>
<tr><td><code>causal_types</code></td>
<td>
<p>A <code>data.frame</code> listing causal types and the
nodal types that produce them</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.causal_model">summary.causal_model</a></code> provides summary method for
output objects of class <code>causal_model</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_model(statement = "X -&gt; Y")
modelXKY &lt;- make_model("X -&gt; K -&gt; Y; X -&gt; Y")

# Example where cyclicaly dag attempted
## Not run: 
 modelXKX &lt;- make_model("X -&gt; K -&gt; X")

## End(Not run)

# Examples with confounding
model &lt;- make_model("X-&gt;Y; X &lt;-&gt; Y")
inspect(model, "parameter_matrix")
model &lt;- make_model("Y2 &lt;- X -&gt; Y1; X &lt;-&gt; Y1; X &lt;-&gt; Y2")
dim(inspect(model, "parameter_matrix"))
inspect(model, "parameter_matrix")
model &lt;- make_model("X1 -&gt; Y &lt;- X2; X1 &lt;-&gt; Y; X2 &lt;-&gt; Y")
dim(inspect(model, "parameter_matrix"))
inspect(model, "parameters_df")

# A single node graph is also possible
model &lt;- make_model("X")

# Unconnected nodes not allowed
## Not run: 
 model &lt;- make_model("X &lt;-&gt; Y")

## End(Not run)

nodal_types &lt;-
  list(
    A = c("0","1"),
    B = c("0","1"),
    C = c("0","1"),
    D = c("0","1"),
    E = c("0","1"),
    Y = c(
      "00000000000000000000000000000000",
      "01010101010101010101010101010101",
      "00110011001100110011001100110011",
      "00001111000011110000111100001111",
      "00000000111111110000000011111111",
      "00000000000000001111111111111111",
      "11111111111111111111111111111111" ))

make_model("A -&gt; Y; B -&gt;Y; C-&gt;Y; D-&gt;Y; E-&gt;Y",
          nodal_types = nodal_types) |&gt;
 inspect("parameters_df")

nodal_types = list(Y = c("01", "10"), Z = c("0", "1"))
make_model("Z -&gt; Y", nodal_types = nodal_types) |&gt;
 inspect("parameters_df")
</code></pre>

<hr>
<h2 id='make_par_values'>make_par_values</h2><span id='topic+make_par_values'></span>

<h3>Description</h3>

<p>This is the one step function for make_priors and make_parameters.
See <code>make_priors</code> for more help.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_par_values(
  model,
  alter = "priors",
  x = NA,
  alter_at = NA,
  node = NA,
  label = NA,
  nodal_type = NA,
  param_set = NA,
  given = NA,
  statement = NA,
  join_by = "|",
  param_names = NA,
  distribution = NA,
  normalize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_par_values_+3A_model">model</code></td>
<td>
<p>model created with <code>make_model</code></p>
</td></tr>
<tr><td><code id="make_par_values_+3A_alter">alter</code></td>
<td>
<p>character vector with one of &quot;priors&quot; or &quot;param_value&quot;
specifying what to alter</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_x">x</code></td>
<td>
<p>vector of real non negative values to be substituted into
&quot;priors&quot; or &quot;param_value&quot;</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_alter_at">alter_at</code></td>
<td>
<p>string specifying filtering operations to be applied to
parameters_df, yielding a logical vector indicating parameters for which
values should be altered. (see examples)</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_node">node</code></td>
<td>
<p>string indicating nodes which are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_label">label</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for which
values are to be altered. Equivalent to nodal_type.</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_nodal_type">nodal_type</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_param_set">param_set</code></td>
<td>
<p>string indicating  the name of the set of parameters
to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_given">given</code></td>
<td>
<p>string indicates the node on which the parameter
to be altered depends</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_statement">statement</code></td>
<td>
<p>causal query that determines nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_join_by">join_by</code></td>
<td>
<p>string specifying the logical operator joining expanded
types when <code>statement</code> contains wildcards.
Can take values <code>'&amp;'</code> (logical AND) or <code>'|'</code> (logical OR).</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_param_names">param_names</code></td>
<td>
<p>vector of strings. The name of specific parameter in
the form of, for example, 'X.1', 'Y.01'</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_distribution">distribution</code></td>
<td>
<p>string indicating a common prior distribution
(uniform, jeffreys or certainty)</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_normalize">normalize</code></td>
<td>
<p>logical. If TRUE normalizes such that param
set probabilities sum to 1.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# the below methods can be applied to either priors or
# param_values by specifying the desired option in \code{alter}

model &lt;- CausalQueries::make_model("X -&gt; M -&gt; Y; X &lt;-&gt; Y")

#altering values using \code{alter_at}
CausalQueries:::make_par_values(model = model,
                                x = c(0.5,0.25),
                                alter_at = paste(
                                  "node == 'Y' &amp;",
                                  "nodal_type %in% c('00','01') &amp;",
                                  "given == 'X.0'"))

#altering values using \code{param_names}
CausalQueries:::make_par_values(model = model,
                                x = c(0.5,0.25),
                                param_names = c("Y.10_X.0","Y.10_X.1"))

#altering values using \code{statement}
CausalQueries:::make_par_values(model = model,
                                x = c(0.5,0.25),
                                statement = "Y[M=1] &gt; Y[M=0]")

#altering values using a combination of other arguments
CausalQueries:::make_par_values(model = model,
x = c(0.5,0.25), node = "Y", nodal_type = c("00","01"), given = "X.0")
</code></pre>

<hr>
<h2 id='make_par_values_stops'>make_par_values_stops</h2><span id='topic+make_par_values_stops'></span>

<h3>Description</h3>

<p>helper to remove stops and reduce complexity of make_par_values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_par_values_stops(
  model,
  alter = "priors",
  x = NA,
  alter_at = NA,
  node = NA,
  label = NA,
  nodal_type = NA,
  param_set = NA,
  given = NA,
  statement = NA,
  join_by = "|",
  param_names = NA,
  distribution = NA,
  normalize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_par_values_stops_+3A_model">model</code></td>
<td>
<p>model created with <code>make_model</code></p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_alter">alter</code></td>
<td>
<p>character vector with one of &quot;priors&quot; or &quot;param_value&quot;
specifying what to alter</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_x">x</code></td>
<td>
<p>vector of real non negative values to be substituted into
&quot;priors&quot; or &quot;param_value&quot;</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_alter_at">alter_at</code></td>
<td>
<p>string specifying filtering operations to be applied to
parameters_df, yielding a logical vector indicating parameters for which
values should be altered. (see examples)</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_node">node</code></td>
<td>
<p>string indicating nodes which are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_label">label</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for which
values are to be altered. Equivalent to nodal_type.</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_nodal_type">nodal_type</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_param_set">param_set</code></td>
<td>
<p>string indicating  the name of the set of parameters
to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_given">given</code></td>
<td>
<p>string indicates the node on which the parameter
to be altered depends</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_statement">statement</code></td>
<td>
<p>causal query that determines nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_join_by">join_by</code></td>
<td>
<p>string specifying the logical operator joining expanded
types when <code>statement</code> contains wildcards.
Can take values <code>'&amp;'</code> (logical AND) or <code>'|'</code> (logical OR).</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_param_names">param_names</code></td>
<td>
<p>vector of strings. The name of specific parameter in
the form of, for example, 'X.1', 'Y.01'</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_distribution">distribution</code></td>
<td>
<p>string indicating a common prior distribution
(uniform, jeffreys or certainty)</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_normalize">normalize</code></td>
<td>
<p>logical. If TRUE normalizes such that param
set probabilities sum to 1.</p>
</td></tr>
</table>

<hr>
<h2 id='make_parameters_df'>function to make a parameters_df from nodal types</h2><span id='topic+make_parameters_df'></span>

<h3>Description</h3>

<p>function to make a parameters_df from nodal types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_parameters_df(nodal_types)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_parameters_df_+3A_nodal_types">nodal_types</code></td>
<td>
<p>a list of nodal types</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
CausalQueries:::make_parameters_df(list(X = "1", Y = c("01", "10")))
</code></pre>

<hr>
<h2 id='make_prior_distribution'>Make a prior distribution from priors</h2><span id='topic+make_prior_distribution'></span>

<h3>Description</h3>

<p>Create a 'n_param'x 'n_draws' database of possible lambda draws to be
attached to the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_prior_distribution(model, n_draws = 4000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_prior_distribution_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="make_prior_distribution_+3A_n_draws">n_draws</code></td>
<td>
<p>A scalar. Number of draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.frame' with dimension 'n_param'x 'n_draws' of possible
lambda draws
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_model('X -&gt; Y') |&gt;
  CausalQueries:::make_prior_distribution(n_draws = 5)

</code></pre>

<hr>
<h2 id='observe_data'>Observe data, given a strategy</h2><span id='topic+observe_data'></span>

<h3>Description</h3>

<p>Observe data, given a strategy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observe_data(
  complete_data,
  observed = NULL,
  nodes_to_observe = NULL,
  prob = 1,
  m = NULL,
  subset = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="observe_data_+3A_complete_data">complete_data</code></td>
<td>
<p>A <code>data.frame</code>. Data observed and unobserved.</p>
</td></tr>
<tr><td><code id="observe_data_+3A_observed">observed</code></td>
<td>
<p>A <code>data.frame</code>. Data observed.</p>
</td></tr>
<tr><td><code id="observe_data_+3A_nodes_to_observe">nodes_to_observe</code></td>
<td>
<p>A list. Nodes to observe.</p>
</td></tr>
<tr><td><code id="observe_data_+3A_prob">prob</code></td>
<td>
<p>A scalar. Observation probability.</p>
</td></tr>
<tr><td><code id="observe_data_+3A_m">m</code></td>
<td>
<p>A integer. Number of units to observe; if specified, <code>m</code>
overrides <code>prob</code>.</p>
</td></tr>
<tr><td><code id="observe_data_+3A_subset">subset</code></td>
<td>
<p>A character.  Logical statement that can be applied to rows
of complete data. For instance observation for some nodes might depend on
observed values of other nodes; or observation may only be sought if
data not already observed!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with logical values indicating which nodes
to observe in each row of 'complete_data'.
</p>


<h3>See Also</h3>

<p>Other data_generation: 
<code><a href="#topic+data_helpers">data_helpers</a></code>,
<code><a href="#topic+get_all_data_types">get_all_data_types</a>()</code>,
<code><a href="#topic+make_data_single">make_data_single</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model("X -&gt; Y")
df &lt;- make_data(model, n = 8)
# Observe X values only
CausalQueries:::observe_data(complete_data = df, nodes_to_observe = "X")
# Observe half the Y values for cases with observed X = 1
CausalQueries:::observe_data(complete_data = df,
     observed = CausalQueries:::observe_data(complete_data = df, nodes_to_observe = "X"),
     nodes_to_observe = "Y", prob = .5,
     subset = "X==1")
</code></pre>

<hr>
<h2 id='parameter_setting'>Setting parameters</h2><span id='topic+parameter_setting'></span><span id='topic+make_parameters'></span><span id='topic+set_parameters'></span><span id='topic+get_parameters'></span>

<h3>Description</h3>

<p>Functionality for altering parameters:
</p>
<p>A vector of 'true' parameters; possibly drawn from prior or posterior.
</p>
<p>Add a true parameter vector to a model. Parameters can be created using
arguments passed to <code><a href="#topic+make_parameters">make_parameters</a></code> and
<code><a href="#topic+make_priors">make_priors</a></code>.
</p>
<p>Extracts parameters as a named vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_parameters(
  model,
  parameters = NULL,
  param_type = NULL,
  warning = TRUE,
  normalize = TRUE,
  ...
)

set_parameters(
  model,
  parameters = NULL,
  param_type = NULL,
  warning = FALSE,
  ...
)

get_parameters(model, param_type = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameter_setting_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="parameter_setting_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from the parameters dataframe.
See <code>inspect(model, "parameters_df")</code>.</p>
</td></tr>
<tr><td><code id="parameter_setting_+3A_param_type">param_type</code></td>
<td>
<p>A character. String specifying type of parameters to make
&quot;flat&quot;, &quot;prior_mean&quot;, &quot;posterior_mean&quot;, &quot;prior_draw&quot;,
&quot;posterior_draw&quot;, &quot;define&quot;. With param_type set to <code>define</code> use
arguments to be passed to <code>make_priors</code>; otherwise <code>flat</code> sets
equal probabilities on each nodal type in each parameter set;
<code>prior_mean</code>, <code>prior_draw</code>, <code>posterior_mean</code>,
<code>posterior_draw</code> take parameters as the means or as draws
from the prior or posterior.</p>
</td></tr>
<tr><td><code id="parameter_setting_+3A_warning">warning</code></td>
<td>
<p>Logical. Whether to warn about parameter renormalization.</p>
</td></tr>
<tr><td><code id="parameter_setting_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If parameter given for a subset of a family the
residual elements are normalized so that parameters in param_set sum
to 1 and provided params are unaltered.</p>
</td></tr>
<tr><td><code id="parameter_setting_+3A_...">...</code></td>
<td>
<p>Options passed onto <code><a href="#topic+make_priors">make_priors</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of draws from the prior or distribution of parameters
</p>
<p>An object of class <code>causal_model</code>. It essentially returns a
list containing the elements comprising a model
(e.g. 'statement', 'nodal_types' and 'DAG') with true vector of
parameters attached to it.
</p>
<p>A vector of draws from the prior or distribution of parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# make_parameters examples:

# Simple examples
model &lt;- make_model('X -&gt; Y')
data  &lt;- make_data(model, n = 2)
model &lt;- update_model(model, data)
make_parameters(model, parameters = c(.25, .75, 1.25,.25, .25, .25))
make_parameters(model, param_type = 'flat')
make_parameters(model, param_type = 'prior_draw')
make_parameters(model, param_type = 'prior_mean')
make_parameters(model, param_type = 'posterior_draw')
make_parameters(model, param_type = 'posterior_mean')




#altering values using \code{alter_at}
make_model("X -&gt; Y") |&gt; make_parameters(parameters = c(0.5,0.25),
alter_at = "node == 'Y' &amp; nodal_type %in% c('00','01')")

#altering values using \code{param_names}
make_model("X -&gt; Y") |&gt; make_parameters(parameters = c(0.5,0.25),
param_names = c("Y.10","Y.01"))

#altering values using \code{statement}
make_model("X -&gt; Y") |&gt; make_parameters(parameters = c(0.5),
statement = "Y[X=1] &gt; Y[X=0]")

#altering values using a combination of other arguments
make_model("X -&gt; Y") |&gt; make_parameters(parameters = c(0.5,0.25),
node = "Y", nodal_type = c("00","01"))

# Normalize renormalizes values not set so that value set is not renomalized
make_parameters(make_model('X -&gt; Y'),
               statement = 'Y[X=1]&gt;Y[X=0]', parameters = .5)
make_parameters(make_model('X -&gt; Y'),
               statement = 'Y[X=1]&gt;Y[X=0]', parameters = .5,
               normalize = FALSE)

  

# set_parameters examples:

make_model('X-&gt;Y') |&gt;  set_parameters(1:6) |&gt;  inspect("parameters")

# Simple examples
model &lt;- make_model('X -&gt; Y')
data  &lt;- make_data(model, n = 2)
model &lt;- update_model(model, data)
set_parameters(model, parameters = c(.25, .75, 1.25,.25, .25, .25))
set_parameters(model, param_type = 'flat')
set_parameters(model, param_type = 'prior_draw')
set_parameters(model, param_type = 'prior_mean')
set_parameters(model, param_type = 'posterior_draw')
set_parameters(model, param_type = 'posterior_mean')




#altering values using \code{alter_at}
make_model("X -&gt; Y") |&gt; set_parameters(parameters = c(0.5,0.25),
alter_at = "node == 'Y' &amp; nodal_type %in% c('00','01')")

#altering values using \code{param_names}
make_model("X -&gt; Y") |&gt; set_parameters(parameters = c(0.5,0.25),
param_names = c("Y.10","Y.01"))

#altering values using \code{statement}
make_model("X -&gt; Y") |&gt; set_parameters(parameters = c(0.5),
statement = "Y[X=1] &gt; Y[X=0]")

#altering values using a combination of other arguments
make_model("X -&gt; Y") |&gt; set_parameters(parameters = c(0.5,0.25),
node = "Y", nodal_type = c("00","01"))


  
</code></pre>

<hr>
<h2 id='parents_to_int'>Helper to turn parents_list into a list of data_realizations column positions</h2><span id='topic+parents_to_int'></span>

<h3>Description</h3>

<p>Helper to turn parents_list into a list of data_realizations column positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parents_to_int(parents_list, position_set)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parents_to_int_+3A_parents_list">parents_list</code></td>
<td>
<p>a named list of character vectors specifying all
nodes in the DAG and their respective parents</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of column positions
</p>

<hr>
<h2 id='perm'>Produces the possible permutations of a set of nodes</h2><span id='topic+perm'></span>

<h3>Description</h3>

<p>Produces the possible permutations of a set of nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm(max = rep(1, 2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perm_+3A_max">max</code></td>
<td>
<p>A vector of integers. The maximum value of an integer value
starting at 0. Defaults to 1. The number of permutation is defined
by <code>max</code>'s length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of permutations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CausalQueries:::perm(3)

</code></pre>

<hr>
<h2 id='plot_model'>Plots a DAG in ggplot style using a causal model input</h2><span id='topic+plot_model'></span>

<h3>Description</h3>

<p>Creates a plot of a DAG using ggplot functionality and a Sugiyama layout from igraph.  Unmeasured confounds  (&lt;-&gt;) are indicated
then these are represented as curved dotted lines.  Users can control node sizes and colors as well as coordinates and label behavior. Other modifications can be made by adding additional ggplot layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_model(
  model = NULL,
  x_coord = NULL,
  y_coord = NULL,
  labels = NULL,
  title = "",
  textcol = "white",
  textsize = 3.88,
  shape = 16,
  nodecol = "black",
  nodesize = 12,
  strength = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_model_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code> object generated from <code>make_model</code></p>
</td></tr>
<tr><td><code id="plot_model_+3A_x_coord">x_coord</code></td>
<td>
<p>A vector of x coordinates for DAG nodes.
If left empty, coordinates are randomly generated</p>
</td></tr>
<tr><td><code id="plot_model_+3A_y_coord">y_coord</code></td>
<td>
<p>A vector of y coordinates for DAG nodes.
If left empty, coordinates are randomly generated</p>
</td></tr>
<tr><td><code id="plot_model_+3A_labels">labels</code></td>
<td>
<p>Optional labels for nodes</p>
</td></tr>
<tr><td><code id="plot_model_+3A_title">title</code></td>
<td>
<p>String specifying title of graph</p>
</td></tr>
<tr><td><code id="plot_model_+3A_textcol">textcol</code></td>
<td>
<p>String specifying color of text labels</p>
</td></tr>
<tr><td><code id="plot_model_+3A_textsize">textsize</code></td>
<td>
<p>Numeric, size of text labels</p>
</td></tr>
<tr><td><code id="plot_model_+3A_shape">shape</code></td>
<td>
<p>Indicates shape of node. Defaults to circular node.</p>
</td></tr>
<tr><td><code id="plot_model_+3A_nodecol">nodecol</code></td>
<td>
<p>String indicating color of node that is accepted by
ggplot's default palette</p>
</td></tr>
<tr><td><code id="plot_model_+3A_nodesize">nodesize</code></td>
<td>
<p>Size of node.</p>
</td></tr>
<tr><td><code id="plot_model_+3A_strength">strength</code></td>
<td>
<p>Degree of curvature of curved arcs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
model &lt;- make_model('X -&gt; K -&gt; Y')

# Simple plot
model |&gt; plot_model()

# Adding additional layers
model |&gt; plot_model() +
  ggplot2::coord_flip()

# Adding labels
model |&gt;
  plot_model(
    labels = c("A long name for a \n node", "This", "That"),
    nodecol = "white",
    textcol = "black")

# Controlling  positions and using math labels
model |&gt; plot_model(
    x_coord = 0:2,
    y_coord = 0:2,
    title = "Mixed text and math: $\\alpha^2 + \\Gamma$")

## End(Not run)

# DAG with unobserved confounding and shapes
make_model('Z -&gt; X -&gt; Y; X &lt;-&gt; Y') |&gt;
  plot(x_coord = 1:3, y_coord = 1:3, shape = c(15, 16, 16))

</code></pre>

<hr>
<h2 id='prep_stan_data'>Prepare data for 'stan'</h2><span id='topic+prep_stan_data'></span>

<h3>Description</h3>

<p>Create a list containing the data to be passed to 'stan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_stan_data(
  model,
  data,
  keep_type_distribution = TRUE,
  censored_types = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_stan_data_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="prep_stan_data_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.  Data of nodes that can take three values:
0, 1, and NA. In long form as generated by <code><a href="#topic+make_events">make_events</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing data to be passed to 'stan'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X-&gt;Y')
data  &lt;-  collapse_data(make_data(model, n = 6), model)
CausalQueries:::prep_stan_data(model, data)


</code></pre>

<hr>
<h2 id='print.causal_model'>Print a short summary for a causal model</h2><span id='topic+print.causal_model'></span>

<h3>Description</h3>

<p>print method for class &quot;<code>causal_model</code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'causal_model'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.causal_model_+3A_x">x</code></td>
<td>
<p>An object of <code>causal_model</code> class, usually a result of
a call to <code>make_model</code> or <code>update_model</code>.</p>
</td></tr>
<tr><td><code id="print.causal_model_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information regarding the causal model includes the statement describing
causal relations using <code>dagitty</code> syntax,
number of nodal types per parent in a DAG, and number of causal types.
</p>

<hr>
<h2 id='print.model_query'>Print a tightened summary of model queries</h2><span id='topic+print.model_query'></span>

<h3>Description</h3>

<p>print method for class <code>model_query</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model_query'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.model_query_+3A_x">x</code></td>
<td>
<p>An object of <code>model_query</code> class.</p>
</td></tr>
<tr><td><code id="print.model_query_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='prior_setting'>Setting priors</h2><span id='topic+prior_setting'></span><span id='topic+make_priors'></span><span id='topic+set_priors'></span><span id='topic+get_priors'></span>

<h3>Description</h3>

<p>Functionality for altering priors:
</p>
<p><code>make_priors</code> Generates priors for a model.
</p>
<p><code>set_priors</code>  Adds priors to a model.
</p>
<p>Extracts priors as a named vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_priors(
  model,
  alphas = NA,
  distribution = NA,
  alter_at = NA,
  node = NA,
  nodal_type = NA,
  label = NA,
  param_set = NA,
  given = NA,
  statement = NA,
  join_by = "|",
  param_names = NA
)

set_priors(
  model,
  alphas = NA,
  distribution = NA,
  alter_at = NA,
  node = NA,
  nodal_type = NA,
  label = NA,
  param_set = NA,
  given = NA,
  statement = NA,
  join_by = "|",
  param_names = NA
)

get_priors(model, nodes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_setting_+3A_model">model</code></td>
<td>
<p>A model object generated by make_model().</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_alphas">alphas</code></td>
<td>
<p>Real positive numbers giving hyperparameters of
the Dirichlet distribution</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_distribution">distribution</code></td>
<td>
<p>string indicating a common prior distribution
(uniform, jeffreys or certainty)</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_alter_at">alter_at</code></td>
<td>
<p>string specifying filtering operations to be applied to
parameters_df, yielding a logical vector indicating parameters for which
values should be altered. (see examples)</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_node">node</code></td>
<td>
<p>string indicating nodes which are to be altered</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_nodal_type">nodal_type</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_label">label</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for which
values are to be altered. Equivalent to nodal_type.</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_param_set">param_set</code></td>
<td>
<p>string indicating  the name of the set of parameters
to be altered</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_given">given</code></td>
<td>
<p>string indicates the node on which the parameter
to be altered depends</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_statement">statement</code></td>
<td>
<p>causal query that determines nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_join_by">join_by</code></td>
<td>
<p>string specifying the logical operator joining expanded
types when <code>statement</code> contains wildcards.
Can take values <code>'&amp;'</code> (logical AND) or <code>'|'</code> (logical OR).</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_param_names">param_names</code></td>
<td>
<p>vector of strings. The name of specific parameter in
the form of, for example, 'X.1', 'Y.01'</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_nodes">nodes</code></td>
<td>
<p>a vector of nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Seven arguments govern which parameters should be altered. The default is
'all' but this can be reduced by specifying
</p>
<p>* <code>alter_at</code> String specifying filtering operations to be applied to
parameters_df, yielding a logical vector indicating parameters for which
values should be altered. &quot;node == 'X' &amp; nodal_type 
</p>
<p>* <code>node</code>, which restricts for example to parameters associated with node
'X'
</p>
<p>* <code>label</code> or <code>nodal_type</code> The label of a particular nodal type,
written either in the form Y0000 or Y.Y0000
</p>
<p>* <code>param_set</code> The param_set of a parameter.
</p>
<p>* <code>given</code> Given parameter set of a parameter.
</p>
<p>* <code>statement</code>, which restricts for example to nodal types that satisfy
the statement 'Y[X=1] &gt; Y[X=0]'
</p>
<p>* <code>param_set</code>, <code>given</code>, which are useful when setting confound
statements that produce several sets of parameters
</p>
<p>Two arguments govern what values to apply:
</p>
<p>* <code>alphas</code> is one or more non-negative numbers and
</p>
<p>* <code>distribution</code> indicates one of a common class: uniform, Jeffreys, or
'certain'
</p>
<p>Forbidden statements include:
</p>

<ul>
<li><p> Setting <code>distribution</code> and <code>values</code> at the same time.
</p>
</li>
<li><p> Setting a <code>distribution</code> other than uniform, Jeffreys, or
certainty.
</p>
</li>
<li><p> Setting negative values.
</p>
</li>
<li><p> specifying <code>alter_at</code> with any of <code>node</code>,
<code>nodal_type</code>, <code>param_set</code>, <code>given</code>, <code>statement</code>, or
<code>param_names</code>
</p>
</li>
<li><p> specifying <code>param_names</code> with any of <code>node</code>,
<code>nodal_type</code>, <code>param_set</code>, <code>given</code>, <code>statement</code>, or
<code>alter_at</code>
</p>
</li>
<li><p> specifying <code>statement</code> with any of <code>node</code> or
<code>nodal_type</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A vector indicating the parameters of the prior distribution
of the nodal types (&quot;hyperparameters&quot;).
</p>
<p>An object of class <code>causal_model</code>. It essentially returns a
list containing the elements comprising a model
(e.g. 'statement', 'nodal_types' and 'DAG') with the 'priors' attached
to it.
</p>
<p>A vector indicating the hyperparameters of the prior distribution
of the nodal types.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# make_priors examples:

# Pass all nodal types
model &lt;- make_model("Y &lt;- X")
make_priors(model, alphas = .4)
make_priors(model, distribution = "jeffreys")

model &lt;- CausalQueries::make_model("X -&gt; M -&gt; Y; X &lt;-&gt; Y")

#altering values using \code{alter_at}
make_priors(model = model, alphas = c(0.5,0.25),
alter_at = "node == 'Y' &amp; nodal_type %in% c('00','01') &amp; given == 'X.0'")

#altering values using \code{param_names}
make_priors(model = model, alphas = c(0.5,0.25),
param_names = c("Y.10_X.0","Y.10_X.1"))

#altering values using \code{statement}
make_priors(model = model, alphas = c(0.5,0.25),
statement = "Y[M=1] &gt; Y[M=0]")

#altering values using a combination of other arguments
make_priors(model = model, alphas = c(0.5,0.25),
node = "Y", nodal_type = c("00","01"), given = "X.0")

# set_priors examples:

# Pass all nodal types
model &lt;- make_model("Y &lt;- X")
set_priors(model, alphas = .4)
set_priors(model, distribution = "jeffreys")

model &lt;- CausalQueries::make_model("X -&gt; M -&gt; Y; X &lt;-&gt; Y")

#altering values using \code{alter_at}
set_priors(model = model, alphas = c(0.5,0.25),
alter_at = "node == 'Y' &amp; nodal_type %in% c('00','01') &amp; given == 'X.0'")

#altering values using \code{param_names}
set_priors(model = model, alphas = c(0.5,0.25),
param_names = c("Y.10_X.0","Y.10_X.1"))

#altering values using \code{statement}
set_priors(model = model, alphas = c(0.5,0.25),
statement = "Y[M=1] &gt; Y[M=0]")

#altering values using a combination of other arguments
set_priors(model = model, alphas = c(0.5,0.25), node = "Y",
nodal_type = c("00","01"), given = "X.0")
</code></pre>

<hr>
<h2 id='query_distribution'>Calculate query distribution</h2><span id='topic+query_distribution'></span>

<h3>Description</h3>

<p>Calculated distribution of a query from a prior or
posterior distribution of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_distribution(
  model,
  queries = NULL,
  given = NULL,
  using = "parameters",
  parameters = NULL,
  n_draws = 4000,
  join_by = "|",
  case_level = FALSE,
  query = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="query_distribution_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_queries">queries</code></td>
<td>
<p>A vector of strings or list of strings specifying queries
on potential outcomes such as &quot;Y[X=1] - Y[X=0]&quot;.
Queries can also indicate conditioning sets by placing second queries after a colon:
&quot;Y[X=1] - Y[X=0] :|: X == 1 &amp; Y == 1&quot;. Note a ':|:' is used rather than the traditional
conditioning marker '|' to avoid confusion with logical operators.</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_given">given</code></td>
<td>
<p>A character vector specifying given conditions for each query.
A 'given' is a quoted expression that evaluates to logical statement.
<code>given</code> allows the query to be conditioned on either observed
or counterfactural distributions. A value of TRUE is interpreted as no conditioning.
A given statement can alternatively be provided after a colon in the query statement.</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_using">using</code></td>
<td>
<p>A character. Whether to use priors, posteriors or parameters</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_parameters">parameters</code></td>
<td>
<p>A vector or list of vectors of real numbers in [0,1].
A true parameter vector to be used instead of parameters attached to
the model in case  <code>using</code> specifies <code>parameters</code></p>
</td></tr>
<tr><td><code id="query_distribution_+3A_n_draws">n_draws</code></td>
<td>
<p>An integer. Number of draws.rm</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_join_by">join_by</code></td>
<td>
<p>A character. The logical operator joining expanded types
when <code>query</code> contains wildcard (<code>.</code>). Can take values
<code>"&amp;"</code> (logical AND) or <code>"|"</code> (logical OR). When restriction
contains wildcard (<code>.</code>) and <code>join_by</code> is not specified, it
defaults to <code>"|"</code>, otherwise it defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_case_level">case_level</code></td>
<td>
<p>Logical. If TRUE estimates the probability of
the query for a case.</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_query">query</code></td>
<td>
<p>alias for queries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where columns contain draws from the distribution
of the potential outcomes specified in <code>query</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model("X -&gt; Y") |&gt;
         set_parameters(c(.5, .5, .1, .2, .3, .4))
 
 # simple  queries
 query_distribution(model, query = "(Y[X=1] &gt; Y[X=0])", using = "priors") |&gt;
   head()

 # multiple  queries
 query_distribution(model,
     query = list(PE = "(Y[X=1] &gt; Y[X=0])", NE = "(Y[X=1] &lt; Y[X=0])"),
     using = "priors")|&gt;
   head()

 # multiple queries and givens, with ':' to identify conditioning distributions
 query_distribution(model,
   query = list(POC = "(Y[X=1] &gt; Y[X=0]) :|: X == 1 &amp; Y == 1",
                Q = "(Y[X=1] &lt; Y[X=0]) :|: (Y[X=1] &lt;= Y[X=0])"),
   using = "priors")|&gt;
   head()

 # multiple queries and givens, using 'given' argument
 query_distribution(model,
   query = list("(Y[X=1] &gt; Y[X=0])", "(Y[X=1] &lt; Y[X=0])"),
   given = list("Y==1", "(Y[X=1] &lt;= Y[X=0])"),
   using = "priors")|&gt;
   head()

 # linear queries
 query_distribution(model, query = "(Y[X=1] - Y[X=0])")


 # Linear query conditional on potential outcomes
 query_distribution(model, query = "(Y[X=1] - Y[X=0]) :|: Y[X=1]==0")

 # Use join_by to amend query interpretation
 query_distribution(model, query = "(Y[X=.] == 1)", join_by = "&amp;")

 # Probability of causation query
 query_distribution(model,
    query = "(Y[X=1] &gt; Y[X=0])",
    given = "X==1 &amp; Y==1",
    using = "priors")  |&gt; head()

 # Case level probability of causation query
 query_distribution(model,
    query = "(Y[X=1] &gt; Y[X=0])",
    given = "X==1 &amp; Y==1",
    case_level = TRUE,
    using = "priors")

 # Query posterior
 update_model(model, make_data(model, n = 3)) |&gt;
 query_distribution(query = "(Y[X=1] - Y[X=0])", using = "posteriors") |&gt;
 head()

 # Case level queries provide the inference for a case, which is a scalar
 # The case level query *updates* on the given information
 # For instance, here we have a model for which we are quite sure that X
 # causes Y but we do not know whether it works through two positive effects
 # or two negative effects. Thus we do not know if M=0 would suggest an
 # effect or no effect

 set.seed(1)
 model &lt;-
   make_model("X -&gt; M -&gt; Y") |&gt;
   update_model(data.frame(X = rep(0:1, 8), Y = rep(0:1, 8)), iter = 10000)

 Q &lt;- "Y[X=1] &gt; Y[X=0]"
 G &lt;- "X==1 &amp; Y==1 &amp; M==1"
 QG &lt;- "(Y[X=1] &gt; Y[X=0]) &amp; (X==1 &amp; Y==1 &amp; M==1)"

 # In this case these are very different:
 query_distribution(model, Q, given = G, using = "posteriors")[[1]] |&gt; mean()
 query_distribution(model, Q, given = G, using = "posteriors",
   case_level = TRUE)

 # These are equivalent:
 # 1. Case level query via function
 query_distribution(model, Q, given = G,
    using = "posteriors", case_level = TRUE)

 # 2. Case level query by hand using Bayes' rule
 query_distribution(
     model,
     list(QG = QG, G = G),
     using = "posteriors") |&gt;
    dplyr::summarize(mean(QG)/mean(G))



</code></pre>

<hr>
<h2 id='query_helpers'>Query helpers</h2><span id='topic+query_helpers'></span><span id='topic+increasing'></span><span id='topic+non_decreasing'></span><span id='topic+decreasing'></span><span id='topic+non_increasing'></span><span id='topic+interacts'></span><span id='topic+complements'></span><span id='topic+substitutes'></span><span id='topic+te'></span>

<h3>Description</h3>

<p>Various helpers to describe queries or parts of queries in natural language.
</p>
<p>Generate a statement for Y monotonic (increasing) in X
</p>
<p>Generate a statement for Y weakly monotonic (increasing) in X
</p>
<p>Generate a statement for Y monotonic (decreasing) in X
</p>
<p>Generate a statement for Y weakly monotonic (not increasing) in X
</p>
<p>Generate a statement for X1, X1 interact in the production of Y
</p>
<p>Generate a statement for X1, X1 complement each other in the production of Y
</p>
<p>Generate a statement for X1, X1 substitute for each other
in the production of Y
</p>
<p>Generate a statement for (Y(1) - Y(0)). This statement when applied to
a model returns an element in (1,0,-1) and not a set of cases.
This is useful for some purposes such as querying a model, but not for
uses that require a list of types, such as <code>set_restrictions</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>increasing(X, Y)

non_decreasing(X, Y)

decreasing(X, Y)

non_increasing(X, Y)

interacts(X1, X2, Y)

complements(X1, X2, Y)

substitutes(X1, X2, Y)

te(X, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="query_helpers_+3A_x">X</code></td>
<td>
<p>A character. The quoted name of the input node</p>
</td></tr>
<tr><td><code id="query_helpers_+3A_y">Y</code></td>
<td>
<p>A character. The quoted name of the outcome node</p>
</td></tr>
<tr><td><code id="query_helpers_+3A_x1">X1</code></td>
<td>
<p>A character. The quoted name of the input node 1.</p>
</td></tr>
<tr><td><code id="query_helpers_+3A_x2">X2</code></td>
<td>
<p>A character. The quoted name of the input node 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character statement of class <code>statement</code>
</p>
<p>A character statement of class <code>statement</code>
</p>
<p>A character statement of class <code>statement</code>
</p>
<p>A character statement of class <code>statement</code>
</p>
<p>A character statement of class <code>statement</code>
</p>
<p>A character statement of class <code>statement</code>
</p>
<p>A character statement of class <code>statement</code>
</p>
<p>A character statement of class <code>statement</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
increasing('A', 'B')


non_decreasing('A', 'B')


decreasing('A', 'B')


non_increasing('A', 'B')


interacts('A', 'B', 'W')
get_query_types(model = make_model('X-&gt; Y &lt;- W'),
         query = interacts('X', 'W', 'Y'), map = "causal_type")


complements('A', 'B', 'W')


get_query_types(model = make_model('A -&gt; B &lt;- C'),
         query = substitutes('A', 'C', 'B'),map = "causal_type")

query_model(model = make_model('A -&gt; B &lt;- C'),
         queries = substitutes('A', 'C', 'B'),
         using = 'parameters')


te('A', 'B')

model &lt;- make_model('X-&gt;Y') |&gt; set_restrictions(increasing('X', 'Y'))
query_model(model, list(ate = te('X', 'Y')),  using = 'parameters')

# set_restrictions  breaks with te because it requires a listing
# of causal types, not numeric output.

## Not run: 
model &lt;- make_model('X-&gt;Y') |&gt; set_restrictions(te('X', 'Y'))

## End(Not run)

</code></pre>

<hr>
<h2 id='query_model'>Generate data frame for batches of causal queries</h2><span id='topic+query_model'></span>

<h3>Description</h3>

<p>Calculated from a parameter vector, from a prior or
from a posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_model(
  model,
  queries = NULL,
  given = NULL,
  using = list("parameters"),
  parameters = NULL,
  stats = NULL,
  n_draws = 4000,
  expand_grid = NULL,
  case_level = FALSE,
  query = NULL,
  cred = 95,
  labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="query_model_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="query_model_+3A_queries">queries</code></td>
<td>
<p>A vector of strings or list of strings specifying queries
on potential outcomes such as &quot;Y[X=1] - Y[X=0]&quot;.
Queries can also indicate conditioning sets by placing second queries after a colon:
&quot;Y[X=1] - Y[X=0] :|: X == 1 &amp; Y == 1&quot;. Note a colon, ':|:' is used rather than the traditional
conditioning marker '|' to avoid confusion with logical operators.</p>
</td></tr>
<tr><td><code id="query_model_+3A_given">given</code></td>
<td>
<p>A character vector specifying given conditions for each query.
A 'given' is a quoted expression that evaluates to logical statement.
<code>given</code> allows the query to be conditioned on either observed
or counterfactural distributions. A value of TRUE is interpreted as no conditioning.
A given statement can alternatively be provided after a colon in the query statement.</p>
</td></tr>
<tr><td><code id="query_model_+3A_using">using</code></td>
<td>
<p>A vector or list of strings. Whether to use priors,
posteriors or parameters.</p>
</td></tr>
<tr><td><code id="query_model_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from the parameters dataframe.
See <code>inspect(model, "parameters_df")</code>.</p>
</td></tr>
<tr><td><code id="query_model_+3A_stats">stats</code></td>
<td>
<p>Functions to be applied to the query distribution.
If NULL, defaults to mean, standard deviation,
and 95% confidence interval. Functions should return a single numeric
value.</p>
</td></tr>
<tr><td><code id="query_model_+3A_n_draws">n_draws</code></td>
<td>
<p>An integer. Number of draws.</p>
</td></tr>
<tr><td><code id="query_model_+3A_expand_grid">expand_grid</code></td>
<td>
<p>Logical. If <code>TRUE</code> then all combinations of
provided lists are examined. If not then each list is cycled through
separately. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="query_model_+3A_case_level">case_level</code></td>
<td>
<p>Logical. If TRUE estimates the probability of the
query for a case.</p>
</td></tr>
<tr><td><code id="query_model_+3A_query">query</code></td>
<td>
<p>alias for queries</p>
</td></tr>
<tr><td><code id="query_model_+3A_cred">cred</code></td>
<td>
<p>size of the credible interval ranging between 0 and 100</p>
</td></tr>
<tr><td><code id="query_model_+3A_labels">labels</code></td>
<td>
<p>labels for queries: if provided labels should have
the length of the combinations of requests</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Queries can condition on observed or counterfactual quantities.
Nested or &quot;complex&quot; counterfactual queries of the form
<code>Y[X=1, M[X=0]]</code> are allowed.
</p>


<h3>Value</h3>

<p>An object of class <code>model_query</code>. A data frame with possible
columns: model, query, given, using, case_level, mean, sd, cred.low, cred.high.
Further columns are generated as specified in <code>stats</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model("X -&gt; Y")
query_model(model, "Y[X=1] - Y[X = 0]", using = "priors")
query_model(model, "Y[X=1] - Y[X = 0] :|: X==1 &amp; Y==1", using = "priors")
query_model(model,
  list("Y[X=1] - Y[X = 0]",
       "Y[X=1] - Y[X = 0] :|: X==1 &amp; Y==1"),
  using = "priors")
query_model(model, "Y[X=1] &gt; Y[X = 0]", using = "parameters")
query_model(model, "Y[X=1] &gt; Y[X = 0]", using = c("priors", "parameters"))


# `expand_grid= TRUE` requests the Cartesian product of arguments

models &lt;- list(
 M1 = make_model("X -&gt; Y"),
 M2 = make_model("X -&gt; Y") |&gt;
   set_restrictions("Y[X=1] &lt; Y[X=0]")
 )

# No expansion: lists should be equal length
query_model(
  models,
  query = list(ATE = "Y[X=1] - Y[X=0]",
               Share_positive = "Y[X=1] &gt; Y[X=0]"),
  given = c(TRUE,  "Y==1 &amp; X==1"),
  using = c("parameters", "priors"),
  expand_grid = FALSE)

# Expansion when query and given arguments coupled
query_model(
  models,
  query = list(ATE = "Y[X=1] - Y[X=0]",
               Share_positive = "Y[X=1] &gt; Y[X=0] :|: Y==1 &amp; X==1"),
  using = c("parameters", "priors"),
  expand_grid = TRUE)

# Expands over query and given argument when these are not coupled
query_model(
  models,
  query = list(ATE = "Y[X=1] - Y[X=0]",
               Share_positive = "Y[X=1] &gt; Y[X=0]"),
  given = c(TRUE,  "Y==1 &amp; X==1"),
  using = c("parameters", "priors"),
  expand_grid = TRUE)

# An example of a custom statistic: uncertainty of token causation
f &lt;- function(x) mean(x)*(1-mean(x))

query_model(
  model,
  using = list( "parameters", "priors"),
  query = "Y[X=1] &gt; Y[X=0]",
  stats = c(mean = mean, sd = sd, token_variance = f))

</code></pre>

<hr>
<h2 id='query_to_expression'>Helper to turn query into a data expression</h2><span id='topic+query_to_expression'></span>

<h3>Description</h3>

<p>Helper to turn query into a data expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_to_expression(query, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="query_to_expression_+3A_query">query</code></td>
<td>
<p>A character string. An expression defining nodal types to
interrogate. An expression of the form
&quot;Y[X=1]&quot; asks for the value of Y when X is set to 1</p>
</td></tr>
<tr><td><code id="query_to_expression_+3A_node">node</code></td>
<td>
<p>A character string. The quoted name of a node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cleaned query expression
</p>

<hr>
<h2 id='realise_outcomes'>Realise outcomes</h2><span id='topic+realise_outcomes'></span>

<h3>Description</h3>

<p>Realise outcomes for all causal types. Calculated by sequentially
calculating endogenous nodes. If a do operator is applied to any node then
it takes the given value and all its descendants are generated accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>realise_outcomes(model, dos = NULL, node = NULL, add_rownames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="realise_outcomes_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="realise_outcomes_+3A_dos">dos</code></td>
<td>
<p>A named <code>list</code>. Do actions defining node values,
e.g., <code>list(X = 0, M = 1)</code>.</p>
</td></tr>
<tr><td><code id="realise_outcomes_+3A_node">node</code></td>
<td>
<p>A character. An optional quoted name of the node whose
outcome should be revealed. If specified all values of parents need
to be specified via <code>dos</code>.</p>
</td></tr>
<tr><td><code id="realise_outcomes_+3A_add_rownames">add_rownames</code></td>
<td>
<p>logical indicating whether to add causal types
as rownames to the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a node is not specified all outcomes are realised for all possible
causal types consistent with the model. If a node is specified then outcomes
of Y are returned conditional on different values of parents, whether or
not these values of the parents obtain given restrictions under the model.
</p>
<p><code>realise_outcomes</code> starts off by creating types
(via <code>get_nodal_types</code>). It then takes types of endogenous
and reveals their outcome based on the value that their parents took.
Exogenous nodes outcomes correspond to their type.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> object of revealed data for each node (columns)
given causal / nodal type (rows).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

make_model("X -&gt; Y") |&gt;
  realise_outcomes()

make_model("X -&gt; Y &lt;- W") |&gt;
set_restrictions(labels = list(X = "1", Y="0010"),
                 keep = TRUE) |&gt;
 realise_outcomes()

make_model("X1-&gt;Y; X2-&gt;M; M-&gt;Y") |&gt;
realise_outcomes(dos = list(X1 = 1, M = 0))

# With node specified
make_model("X-&gt;M-&gt;Y") |&gt;
realise_outcomes(node = "Y")

make_model("X-&gt;M-&gt;Y") |&gt;
realise_outcomes(dos = list(M = 1), node = "Y")

</code></pre>

<hr>
<h2 id='reveal_outcomes'>Reveal outcomes</h2><span id='topic+reveal_outcomes'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
</p>
<p>This function was deprecated because the name causes clashes with
DeclareDesign. Use realise_outcomes instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal_outcomes(model, dos = NULL, node = NULL)
</code></pre>

<hr>
<h2 id='set_confound'>Set confound</h2><span id='topic+set_confound'></span>

<h3>Description</h3>

<p>Adjust parameter matrix to allow confounding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_confound(model, confound = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_confound_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="set_confound_+3A_confound">confound</code></td>
<td>
<p>A <code>list</code> of statements indicating pairs of nodes whose
types are jointly distributed (e.g. list(&quot;A &lt;-&gt; B&quot;, &quot;C &lt;-&gt; D&quot;)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confounding between X and Y arises when the nodal types for X and Y are not
independently distributed. In the X -&gt; Y graph, for instance, there are 2
nodal types for X and 4 for Y. There are thus 8 joint nodal types:
</p>
<pre>
|          | t^X                |                    |           |
|-----|----|--------------------|--------------------|-----------|
|     |    | 0                  | 1                  | Sum       |
|-----|----|--------------------|--------------------|-----------|
| t^Y | 00 | Pr(t^X=0 &amp; t^Y=00) | Pr(t^X=1 &amp; t^Y=00) | Pr(t^Y=00)|
|     | 10 | .                  | .                  | .         |
|     | 01 | .                  | .                  | .         |
|     | 11 | .                  | .                  | .         |
|-----|----|--------------------|--------------------|-----------|
|     |Sum | Pr(t^X=0)          | Pr(t^X=1)          | 1         |
</pre>
<p>This table has 8 interior elements and so an unconstrained joint
distribution would have 7 degrees of freedom. A no confounding assumption
means that Pr(t^X | t^Y) = Pr(t^X), or  Pr(t^X, t^Y) = Pr(t^X)Pr(t^Y).
In this case there would be 3 degrees of freedom for Y and 1 for X,
totaling 4 rather than 7.
</p>
<p><code>set_confound</code> lets you relax this assumption by increasing the
number of parameters characterizing the joint distribution. Using the fact
that P(A,B) = P(A)P(B|A) new parameters are introduced to capture P(B|A=a)
rather than simply P(B). For instance here two parameters
(and one degree of freedom) govern the distribution of types X  and four
parameters (with 3 degrees of freedom) govern  the types for Y given the
type of X for a total of 1+3+3 = 7 degrees of freedom.
</p>


<h3>Value</h3>

<p>An object of class <code>causal_model</code> with updated parameters_df
and parameter matrix.
</p>


<h3>See Also</h3>

<p>Other set: 
<code><a href="#topic+set_prior_distribution">set_prior_distribution</a>()</code>,
<code><a href="#topic+set_restrictions">set_restrictions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
make_model('X -&gt; Y; X &lt;-&gt; Y') |&gt;
inspect("parameters")

make_model('X -&gt; M -&gt; Y; X &lt;-&gt; Y') |&gt;
inspect("parameters")

model &lt;- make_model('X -&gt; M -&gt; Y; X &lt;-&gt; Y; M &lt;-&gt; Y')
inspect(model, "parameters_df")

# Example where set_confound is implemented after restrictions
make_model("A -&gt; B -&gt; C") |&gt;
set_restrictions(increasing("A", "B")) |&gt;
set_confound("B &lt;-&gt; C") |&gt;
inspect("parameters")

# Example where two parents are confounded
make_model('A -&gt; B &lt;- C; A &lt;-&gt; C') |&gt;
  set_parameters(node = "C", c(0.05, .95, .95, 0.05)) |&gt;
  make_data(n = 50) |&gt;
  cor()

 # Example with two confounds, added sequentially
model &lt;- make_model('A -&gt; B -&gt; C') |&gt;
  set_confound(list("A &lt;-&gt; B", "B &lt;-&gt; C"))
inspect(model, "statement")
# plot(model)
</code></pre>

<hr>
<h2 id='set_parameter_matrix'>Set parameter matrix</h2><span id='topic+set_parameter_matrix'></span>

<h3>Description</h3>

<p>Add a parameter matrix to a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_parameter_matrix(model, P = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_parameter_matrix_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="set_parameter_matrix_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations. See <code>inspect(model, "parameter_matrix")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>causal_model</code>. It essentially returns a
list containing the elements comprising a model
(e.g. 'statement', 'nodal_types' and 'DAG') with the parameter matrix
attached to it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; Y')
P &lt;- diag(8)
colnames(P) &lt;- inspect(model, "causal_types") |&gt; rownames()
model &lt;- set_parameter_matrix(model, P = P)
</code></pre>

<hr>
<h2 id='set_prior_distribution'>Add prior distribution draws</h2><span id='topic+set_prior_distribution'></span>

<h3>Description</h3>

<p>Add 'n_param x n_draws' database of possible parameter draws to the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_prior_distribution(model, n_draws = 4000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_prior_distribution_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="set_prior_distribution_+3A_n_draws">n_draws</code></td>
<td>
<p>A scalar. Number of draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>causal_model</code> with the 'prior_distribution'
attached to it.
</p>


<h3>See Also</h3>

<p>Other set: 
<code><a href="#topic+set_confound">set_confound</a>()</code>,
<code><a href="#topic+set_restrictions">set_restrictions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_model('X -&gt; Y') |&gt;
  set_prior_distribution(n_draws = 5) |&gt;
  inspect("prior_distribution")

</code></pre>

<hr>
<h2 id='set_restrictions'>Restrict a model</h2><span id='topic+set_restrictions'></span>

<h3>Description</h3>

<p>Restrict a model's parameter space. This reduces the number of nodal types
and in consequence the number of unit causal types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_restrictions(
  model,
  statement = NULL,
  join_by = "|",
  labels = NULL,
  param_names = NULL,
  given = NULL,
  keep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_restrictions_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_statement">statement</code></td>
<td>
<p>A quoted expressions defining the restriction.
If values for some parents are not specified, statements should be
surrounded by parentheses, for instance <code>(Y[A = 1] &gt; Y[A=0])</code> will
be interpreted for all combinations of other parents of Y set at possible
levels they might take.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_join_by">join_by</code></td>
<td>
<p>A string. The logical operator joining expanded types when
<code>statement</code> contains wildcard (<code>.</code>). Can take values
<code>'&amp;'</code> (logical AND) or <code>'|'</code> (logical OR). When restriction
contains wildcard (<code>.</code>) and <code>join_by</code> is not specified, it
defaults to <code>'|'</code>, otherwise it defaults to <code>NULL</code>. Note that
join_by joins within statements, not across statements.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_labels">labels</code></td>
<td>
<p>A list of character vectors specifying nodal types to be kept
or removed from the model. Use <code>get_nodal_types</code> to see syntax.
Note that <code>labels</code> gets overwritten by <code>statement</code> if
<code>statement</code> is not NULL.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_param_names">param_names</code></td>
<td>
<p>A character vector of names of parameters to restrict on.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_given">given</code></td>
<td>
<p>A character vector or list of character vectors specifying
nodes on which the parameter set to be restricted depends.
When restricting by <code>statement</code>, <code>given</code> must either be
<code>NULL</code> or of the same length as <code>statement</code>. When mixing
statements that are further restricted by <code>given</code> and ones that are
not, statements without <code>given</code> restrictions should have <code>given</code>
specified as one of <code>NULL</code>, <code>NA</code>, <code>""</code> or <code>" "</code>.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_keep">keep</code></td>
<td>
<p>Logical. If 'FALSE', removes and if 'TRUE' keeps only causal
types specified by <code>statement</code> or <code>labels</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Restrictions are made to nodal types, not to unit causal types.
Thus for instance in a model <code>X -&gt; M -&gt; Y</code>, one cannot apply a simple
restriction so that <code>Y</code> is nondecreasing in  <code>X</code>, however one can
restrict so that <code>M</code> is nondecreasing in <code>X</code> and <code>Y</code>
nondecreasing in <code>M</code>. To have a restriction that <code>Y</code> be
nondecreasing in <code>X</code> would otherwise require restrictions on
causal types, not nodal types, which implies a form of undeclared
confounding (i.e. that in cases in which <code>M</code> is decreasing in <code>X</code>,
<code>Y</code> is decreasing in <code>M</code>).
</p>
<p>Since restrictions are to nodal types, all parents of a node are
implicitly fixed.  Thus for model <code>make_model(`X -&gt; Y &lt;- W`)</code> the
request <code>set_restrictions(`(Y[X=1] == 0)`)</code> is interpreted as
<code>set_restrictions(`(Y[X=1, W=0] == 0 | Y[X=1, W=1] == 0)`)</code>.
</p>
<p>Statements with implicitly controlled nodes should be surrounded by
parentheses, as in these examples.
</p>
<p>Note that prior probabilities are redistributed over remaining types.
</p>


<h3>Value</h3>

<p>An object of class <code>model</code>. The causal types and nodal types
in the model are reduced according to the stated restriction.
</p>


<h3>See Also</h3>

<p>Other set: 
<code><a href="#topic+set_confound">set_confound</a>()</code>,
<code><a href="#topic+set_prior_distribution">set_prior_distribution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1. Restrict parameter space using statements
model &lt;- make_model('X-&gt;Y') |&gt;
  set_restrictions(statement = c('X[] == 0'))

model &lt;- make_model('X-&gt;Y') |&gt;
  set_restrictions(non_increasing('X', 'Y'))

model &lt;- make_model('X -&gt; Y &lt;- W') |&gt;
  set_restrictions(c(decreasing('X', 'Y'), substitutes('X', 'W', 'Y')))

inspect(model, "parameters_df")

model &lt;- make_model('X-&gt; Y &lt;- W') |&gt;
  set_restrictions(statement = decreasing('X', 'Y'))
inspect(model, "parameters_df")

model &lt;- make_model('X-&gt;Y') |&gt;
  set_restrictions(decreasing('X', 'Y'))
inspect(model, "parameters_df")

model &lt;- make_model('X-&gt;Y') |&gt;
  set_restrictions(c(increasing('X', 'Y'), decreasing('X', 'Y')))
inspect(model, "parameters_df")

# Restrict to define a model with monotonicity
model &lt;- make_model('X-&gt;Y') |&gt;
set_restrictions(statement = c('Y[X=1] &lt; Y[X=0]'))
inspect(model, "parameter_matrix")

# Restrict to a single type in endogenous node
model &lt;- make_model('X-&gt;Y') |&gt;
set_restrictions(statement =  '(Y[X = 1] == 1)', join_by = '&amp;', keep = TRUE)
inspect(model, "parameter_matrix")

#  Use of | and &amp;
# Keep node if *for some value of B* Y[A = 1] == 1
model &lt;- make_model('A-&gt;Y&lt;-B') |&gt;
set_restrictions(statement =  '(Y[A = 1] == 1)', join_by = '|', keep = TRUE)
dim(inspect(model ,"parameter_matrix"))


# Keep node if *for all values of B* Y[A = 1] == 1
model &lt;- make_model('A-&gt;Y&lt;-B') |&gt;
set_restrictions(statement =  '(Y[A = 1] == 1)', join_by = '&amp;', keep = TRUE)
dim(inspect(model, "parameter_matrix"))

# Restrict multiple nodes
model &lt;- make_model('X-&gt;Y&lt;-M; X -&gt; M' ) |&gt;
set_restrictions(statement =  c('(Y[X = 1] == 1)', '(M[X = 1] == 1)'),
                 join_by = '&amp;', keep = TRUE)
inspect(model, "parameter_matrix")

# Restrict using statements and given:
model &lt;- make_model("X -&gt; Y -&gt; Z; X &lt;-&gt; Z") |&gt;
 set_restrictions(list(decreasing('X','Y'), decreasing('Y','Z')),
                  given = c(NA,'X.0'))
inspect(model, "parameter_matrix")

# Restrictions on levels for endogenous nodes aren't allowed
## Not run: 
model &lt;- make_model('X-&gt;Y') |&gt;
set_restrictions(statement =  '(Y == 1)')

## End(Not run)

# 2. Restrict parameter space Using labels:
model &lt;- make_model('X-&gt;Y') |&gt;
set_restrictions(labels = list(X = '0', Y = '00'))

# Restrictions can be  with wildcards
model &lt;- make_model('X-&gt;Y') |&gt;
set_restrictions(labels = list(Y = '?0'))
inspect(model, "parameter_matrix")

# Deterministic model
model &lt;- make_model('S -&gt; C -&gt; Y &lt;- R &lt;- X; X -&gt; C -&gt; R') |&gt;
set_restrictions(labels = list(C = '1000', R = '0001', Y = '0001'),
                 keep = TRUE)
inspect(model, "parameter_matrix")

# Restrict using labels and given:
model &lt;- make_model("X -&gt; Y -&gt; Z; X &lt;-&gt; Z") |&gt;
 set_restrictions(labels = list(X = '0', Z = '00'), given = c(NA,'X.0'))
inspect(model, "parameter_matrix")

</code></pre>

<hr>
<h2 id='summary.causal_model'>Summarizing causal models</h2><span id='topic+summary.causal_model'></span><span id='topic+print.summary.causal_model'></span>

<h3>Description</h3>

<p>summary method for class &quot;<code>causal_model</code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'causal_model'
summary(object, include = NULL, ...)

## S3 method for class 'summary.causal_model'
print(x, what = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.causal_model_+3A_object">object</code></td>
<td>
<p>An object of <code>causal_model</code> class produced using
<code>make_model</code> or <code>update_model</code>.</p>
</td></tr>
<tr><td><code id="summary.causal_model_+3A_include">include</code></td>
<td>
<p>A character string specifying the additional objects to include in summary. Defaults to <code>NULL</code>. See details for full list of available values.</p>
</td></tr>
<tr><td><code id="summary.causal_model_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.causal_model_+3A_x">x</code></td>
<td>
<p>An object of <code>summary.causal_model</code> class, produced using <code>summary.causal_model</code>.</p>
</td></tr>
<tr><td><code id="summary.causal_model_+3A_what">what</code></td>
<td>
<p>A character string specifying the objects summaries to print. Defaults to <code>NULL</code> printing causal statement, specification of nodal types and summary of model restrictions. See details for full list of available values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the default objects included in 'summary.causal_model' users can request additional objects via 'include' argument. Note that these additional objects can be large for complex models and can increase computing time. The 'include' argument can be a vector of any of the following additional objects:
</p>

<ul>
<li> <p><code>"parameter_matrix"</code> A matrix mapping from parameters into causal types,
</p>
</li>
<li> <p><code>"parameter_mapping"</code> a matrix mapping from parameters into data types,
</p>
</li>
<li> <p><code>"causal_types"</code> A data frame listing causal types and the nodal types that produce them,
</p>
</li>
<li> <p><code>"prior_distribution"</code> A data frame of the parameter prior distribution,
</p>
</li>
<li> <p><code>"ambiguities_matrix"</code> A matrix mapping from causal types into data types,
</p>
</li>
<li> <p><code>"type_prior"</code> A matrix of type probabilities using priors.
</p>
</li></ul>

<p><code>print.summary.causal_model</code> reports causal statement, full specification of nodal types and summary of model restrictions. By specifying 'what' argument users can instead print a custom summary of any set of the following objects contained in the 'summary.causal_model':
</p>

<ul>
<li> <p><code>"statement"</code> A character string giving the causal statement,
</p>
</li>
<li> <p><code>"nodes"</code> A list containing the nodes in the model,
</p>
</li>
<li> <p><code>"parents"</code> A list of parents of all nodes in a model,
</p>
</li>
<li> <p><code>"parents_df"</code> A data frame listing nodes, whether they are root nodes or not, and the number and names of parents they have,
</p>
</li>
<li> <p><code>"parameters"</code> A vector of 'true' parameters,
</p>
</li>
<li> <p><code>"parameters_df"</code> A data frame containing parameter information,
</p>
</li>
<li> <p><code>"parameter_names"</code> A vector of names of parameters,
</p>
</li>
<li> <p><code>"parameter_mapping"</code> A matrix mapping from parameters into data types,
</p>
</li>
<li> <p><code>"parameter_matrix"</code> A matrix mapping from parameters into causal types,
</p>
</li>
<li> <p><code>"causal_types"</code> A data frame listing causal types and the nodal types that produce them,
</p>
</li>
<li> <p><code>"nodal_types"</code> A list with the nodal types of the model,
</p>
</li>
<li> <p><code>"data_types"</code> A list with the all data types consistent with the model; for options see '&quot;?get_all_data_types&quot;',
</p>
</li>
<li> <p><code>"prior_hyperparameters"</code> A vector of alpha values used to parameterize Dirichlet prior distributions; optionally provide node names to reduce output &lsquo;inspect(prior_hyperparameters, c(&rsquo;M', 'Y'))'
</p>
</li>
<li> <p><code>"prior_distribution"</code> A data frame of the parameter prior distribution,
</p>
</li>
<li> <p><code>"prior_event_probabilities"</code> A vector of data (event) probabilities given a single (sepcified) parameter vector; for options see '&quot;?get_event_probabilities&quot;',
</p>
</li>
<li> <p><code>"ambiguities_matrix"</code> A matrix mapping from causal types into data types,
</p>
</li>
<li> <p><code>"type_prior"</code> A matrix of type probabilities using priors,
</p>
</li>
<li> <p><code>"type_posterior"</code> A matrix of type probabilities using posteriors,
</p>
</li>
<li> <p><code>"posterior_distribution"</code> A data frame of the parameter posterior distribution,
</p>
</li>
<li> <p><code>"posterior_event_probabilities"</code> A sample of data (event) probabilities from the posterior,
</p>
</li>
<li> <p><code>"data"</code> A data frame with data that was used to update model,
</p>
</li>
<li> <p><code>"stanfit"</code> A 'stanfit' object generated by Stan,
</p>
</li>
<li> <p><code>"stan_summary"</code> A 'stanfit' summary with updated parameter names.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns the object of class <code>summary.causal_model</code> that preserves the list structure of <code>causal_model</code> class and adds the following additional objects:
</p>

<ul>
<li> <p><code>"parents"</code> a list of parents of all nodes in a model,
</p>
</li>
<li> <p><code>"parameters"</code> a vector of 'true' parameters,
</p>
</li>
<li> <p><code>"parameter_names"</code> a vector of names of parameters,
</p>
</li>
<li> <p><code>"data_types"</code> a list with the all data  types consistent with the model; for options see <code>"?get_all_data_types"</code>,
</p>
</li>
<li> <p><code>"prior_event_probabilities"</code> a vector of prior data (event) probabilities given a parameter vector; for options see <code>"?get_event_probabilities"</code>,
</p>
</li>
<li> <p><code>"prior_hyperparameters"</code> a vector of alpha values used to parameterize Dirichlet prior distributions; optionally provide node names to reduce output <code>"inspect(prior_hyperparameters, c('M', 'Y'))"</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;-
  make_model("X -&gt; Y")

model |&gt;
  update_model(
    keep_event_probabilities = TRUE,
    keep_fit = TRUE,
    data = make_data(model, n = 100)
  ) |&gt;
  summary()



model &lt;-
  make_model("X -&gt; Y")

model &lt;-
  model |&gt;
  update_model(
    keep_event_probabilities = TRUE,
    keep_fit = TRUE,
    data = make_data(model, n = 100)
  )

print(summary(model), what = "type_posterior")
print(summary(model), what = "posterior_distribution")
print(summary(model), what = "posterior_event_probabilities")
print(summary(model), what = "data_types")
print(summary(model), what = "prior_hyperparameters")
print(summary(model), what = c("statement", "nodes"))
print(summary(model), what = "parameters_df")
print(summary(model), what = "posterior_event_probabilities")
print(summary(model), what = "posterior_distribution")
print(summary(model), what = "data")
print(summary(model), what = "stanfit")
print(summary(model), what = "type_posterior")

# Large objects have to be added to the summary before printing
print(summary(model, include = "ambiguities_matrix"),
  what = "ambiguities_matrix")


</code></pre>

<hr>
<h2 id='summary.model_query'>Summarizing model queries</h2><span id='topic+summary.model_query'></span><span id='topic+print.summary.model_query'></span>

<h3>Description</h3>

<p>summary method for class &quot;<code>model_query</code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model_query'
summary(object, ...)

## S3 method for class 'summary.model_query'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.model_query_+3A_object">object</code></td>
<td>
<p>An object of <code>model_query</code> class produced using
<code>query_model</code></p>
</td></tr>
<tr><td><code id="summary.model_query_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.model_query_+3A_x">x</code></td>
<td>
<p>an object of <code>model_query</code> class produced using
<code>query_model</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the object of class <code>summary.model_query</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;-
  make_model("X -&gt; Y") |&gt;
  query_model("Y[X=1] &gt; Y[X=1]")  |&gt;
  summary()


</code></pre>

<hr>
<h2 id='update_model'>Fit causal model using 'stan'</h2><span id='topic+update_model'></span>

<h3>Description</h3>

<p>Takes a model and data and returns a model object with data
attached and a posterior model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_model(
  model,
  data = NULL,
  data_type = NULL,
  keep_type_distribution = TRUE,
  keep_event_probabilities = FALSE,
  keep_fit = FALSE,
  censored_types = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_model_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="update_model_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.  Data of nodes that can take three values:
0, 1, and NA. In long form as generated by <code><a href="#topic+make_events">make_events</a></code></p>
</td></tr>
<tr><td><code id="update_model_+3A_data_type">data_type</code></td>
<td>
<p>Either 'long' (as made by <code><a href="#topic+make_data">make_data</a></code>) or
'compact' (as made by <code><a href="#topic+collapse_data">collapse_data</a></code>). Compact data must
have entries for each member of each strategy family to produce a
valid simplex. When long form data is provided with missingness, missing
data is assumed to be missing at random.</p>
</td></tr>
<tr><td><code id="update_model_+3A_keep_type_distribution">keep_type_distribution</code></td>
<td>
<p>Logical. Whether to keep the (transformed) distribution
of the causal types.  Defaults to 'TRUE'</p>
</td></tr>
<tr><td><code id="update_model_+3A_keep_event_probabilities">keep_event_probabilities</code></td>
<td>
<p>Logical. Whether to keep the (transformed) distribution
of event probabilities. Defaults to 'FALSE'</p>
</td></tr>
<tr><td><code id="update_model_+3A_keep_fit">keep_fit</code></td>
<td>
<p>Logical. Whether to keep the <code>stanfit</code> object produced
by <a href="rstan.html#topic+sampling">sampling</a> for further inspection.
See <code>?stanfit</code> for more details. Defaults to 'FALSE'. Note the  <code>stanfit</code>
object has internal names for parameters (lambda), event probabilities (w), and the
type distribution (types)</p>
</td></tr>
<tr><td><code id="update_model_+3A_censored_types">censored_types</code></td>
<td>
<p>vector of data types that are selected out of
the data, e.g. <code>c("X0Y0")</code></p>
</td></tr>
<tr><td><code id="update_model_+3A_...">...</code></td>
<td>
<p>Options passed onto <a href="rstan.html#topic+sampling">sampling</a> call. For
details see <code>?rstan::sampling</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>causal_model</code> with posterior distribution on
parameters and other elements generated by updating; all elements accessible
via <code>get</code> and <code>inspect</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_model">make_model</a></code> to create a new model,
<code><a href="#topic+summary.causal_model">summary.causal_model</a></code> provides a summary method for
output objects of class <code>causal_model</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> model &lt;- make_model('X-&gt;Y')
 data_long   &lt;- make_data(model, n = 4)
 data_short  &lt;- collapse_data(data_long, model)
 model &lt;-  update_model(model, data_long)
 model &lt;-  update_model(model, data_short)

   # It is possible to implement updating without data, in which
   # case the posterior is a stan object that reflects the prior

   update_model(model)

 ## Not run: 

   # Censored data types illustrations
   # Here we update less than we might because we are aware of filtered data

   data &lt;- data.frame(X=rep(0:1, 10), Y=rep(0:1,10))
   uncensored &lt;-
     make_model("X-&gt;Y") |&gt;
     update_model(data) |&gt;
     query_model(te("X", "Y"), using = "posteriors")

   censored &lt;-
     make_model("X-&gt;Y") |&gt;
     update_model(
       data,
       censored_types = c("X1Y0")) |&gt;
     query_model(te("X", "Y"), using = "posteriors")


   # Censored data: We learn nothing because the data
   # we see is the only data we could ever see
   make_model("X-&gt;Y") |&gt;
     update_model(
       data,
       censored_types = c("X1Y0", "X0Y0", "X0Y1")) |&gt;
     query_model(te("X", "Y"), using = "posteriors")
 
## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
