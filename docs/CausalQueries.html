<!DOCTYPE html><html><head><title>Help for package CausalQueries</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CausalQueries}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CausalQueries-package'><p>'CausalQueries'</p></a></li>
<li><a href='#add_dots'><p>Helper to fill in missing do operators in causal expression</p></a></li>
<li><a href='#add_wildcard'><p>Adds a wildcard for every missing parent</p></a></li>
<li><a href='#all_data_types'><p>All data types</p></a></li>
<li><a href='#causal_type_names'><p>Names for causal types</p></a></li>
<li><a href='#CausalQueries_internal_inherit_params'><p>Create parameter documentation to inherit</p></a></li>
<li><a href='#check_args'><p>helper to check arguments</p></a></li>
<li><a href='#check_query'><p>Warn about improper query specification and apply fixes</p></a></li>
<li><a href='#check_string_input'><p>Check string_input</p></a></li>
<li><a href='#clean_condition'><p>Clean condition</p></a></li>
<li><a href='#clean_param_vector'><p>Clean parameter vector</p></a></li>
<li><a href='#clean_params'><p>Check parameters sum to 1 in param_set; normalize if needed; add</p>
names if needed</a></li>
<li><a href='#collapse_data'><p>Make compact data with data strategies</p></a></li>
<li><a href='#collapse_nodal_types'><p>collapse nodal types</p></a></li>
<li><a href='#complements'><p>Make statement for complements</p></a></li>
<li><a href='#construct_commands_alter_at'><p>make_par_values</p></a></li>
<li><a href='#construct_commands_other_args'><p>make_par_values</p></a></li>
<li><a href='#construct_commands_param_names'><p>make_par_values</p></a></li>
<li><a href='#data_to_data'><p>helper to generate a matrix mapping from names of M to names of A</p></a></li>
<li><a href='#data_type_names'><p>Data type names</p></a></li>
<li><a href='#decreasing'><p>Make monotonicity statement (negative)</p></a></li>
<li><a href='#default_stan_control'><p>default_stan_control</p></a></li>
<li><a href='#democracy_data'><p>Development and Democratization: Data for replication of analysis in</p>
*Integrated Inferences*</a></li>
<li><a href='#draw_causal_type'><p>Draw a single causal type given a parameter vector</p></a></li>
<li><a href='#drop_empty_families'><p>Drop empty families</p></a></li>
<li><a href='#expand_data'><p>Expand compact data object to data frame</p></a></li>
<li><a href='#expand_nodal_expression'><p>Helper to expand nodal expression</p></a></li>
<li><a href='#expand_wildcard'><p>Expand wildcard</p></a></li>
<li><a href='#get_ambiguities_matrix'><p>Get ambiguities matrix</p></a></li>
<li><a href='#get_causal_types'><p>Get causal types</p></a></li>
<li><a href='#get_data_families'><p>get_data_families</p></a></li>
<li><a href='#get_estimands'><p>helper to get estimands</p></a></li>
<li><a href='#get_event_prob'><p>Draw event probabilities</p></a></li>
<li><a href='#get_nodal_types'><p>Get list of types for nodes in a DAG</p></a></li>
<li><a href='#get_param_dist'><p>Get a distribution of model parameters</p></a></li>
<li><a href='#get_parameter_matrix'><p>Get parameter matrix</p></a></li>
<li><a href='#get_parameter_names'><p>Get parameter names</p></a></li>
<li><a href='#get_parents'><p>Get list of parents of all nodes in a model</p></a></li>
<li><a href='#get_parmap'><p>Get parmap: a matrix mapping from parameters to data types</p></a></li>
<li><a href='#get_prior_distribution'><p>Get a prior distribution from priors</p></a></li>
<li><a href='#get_query_types'><p>Look up query types</p></a></li>
<li><a href='#get_type_distributions'><p>helper to get type distributions</p></a></li>
<li><a href='#get_type_names'><p>Get type names</p></a></li>
<li><a href='#get_type_prob'><p>Get type probabilities</p></a></li>
<li><a href='#get_type_prob_c'><p>generates one draw from type probability distribution for each type in P</p></a></li>
<li><a href='#get_type_prob_multiple'><p>Draw matrix of type probabilities, before or after estimation</p></a></li>
<li><a href='#get_type_prob_multiple_c'><p>generates n draws from type probability distribution for each type in P</p></a></li>
<li><a href='#gsub_many'><p>Recursive substitution</p></a></li>
<li><a href='#increasing'><p>Make monotonicity statement (positive)</p></a></li>
<li><a href='#institutions_data'><p>Institutions and growth: Data for replication of analysis in</p>
*Integrated Inferences*</a></li>
<li><a href='#interacts'><p>Make statement for any interaction</p></a></li>
<li><a href='#interpret_type'><p>Interpret or find position in nodal type</p></a></li>
<li><a href='#is_a_model'><p>Check whether argument is a model</p></a></li>
<li><a href='#lipids_data'><p>Lipids: Data for Chickering and Pearl replication</p></a></li>
<li><a href='#list_non_parents'><p>Returns a list with the nodes that are not directly pointing into a node</p></a></li>
<li><a href='#make_ambiguities_matrix'><p>Make ambiguities matrix</p></a></li>
<li><a href='#make_data'><p>Make data</p></a></li>
<li><a href='#make_data_single'><p>Generate full dataset</p></a></li>
<li><a href='#make_events'><p>Make data in compact form</p></a></li>
<li><a href='#make_model'><p>Make a model</p></a></li>
<li><a href='#make_nodal_types'><p>Make nodal types</p></a></li>
<li><a href='#make_par_values'><p>make_par_values</p></a></li>
<li><a href='#make_par_values_stops'><p>make_par_values_stops</p></a></li>
<li><a href='#make_parameter_matrix'><p>Make parameter matrix</p></a></li>
<li><a href='#make_parameters_df'><p>function to make a parameters_df from nodal types</p></a></li>
<li><a href='#make_parmap'><p>Make parmap: a matrix mapping from parameters to data types</p></a></li>
<li><a href='#make_prior_distribution'><p>Make a prior distribution from priors</p></a></li>
<li><a href='#minimal_data'><p>Creates a data frame for case with no data</p></a></li>
<li><a href='#minimal_event_data'><p>Creates a compact data frame for case with no data</p></a></li>
<li><a href='#n_check'><p>n_check</p></a></li>
<li><a href='#nodes_in_statement'><p>Identify nodes in a statement</p></a></li>
<li><a href='#non_decreasing'><p>Make monotonicity statement (non negative)</p></a></li>
<li><a href='#non_increasing'><p>Make monotonicity statement (non positive)</p></a></li>
<li><a href='#observe_data'><p>Observe data, given a strategy</p></a></li>
<li><a href='#parameter_setting'><p>Setting parameters</p></a></li>
<li><a href='#parents_to_int'><p>Helper to turn parents_list into a list of data_realizations column positions</p></a></li>
<li><a href='#perm'><p>Produces the possible permutations of a set of nodes</p></a></li>
<li><a href='#plot_dag'><p>Plots a DAG in ggplot style using a causal model input</p></a></li>
<li><a href='#prep_stan_data'><p>Prepare data for 'stan'</p></a></li>
<li><a href='#prior_setting'><p>Setting priors</p></a></li>
<li><a href='#queries_to_types'><p>helper to get types from queries</p></a></li>
<li><a href='#query_distribution'><p>Calculate query distribution</p></a></li>
<li><a href='#query_model'><p>Generate estimands dataframe</p></a></li>
<li><a href='#query_to_expression'><p>Helper to turn query into a data expression</p></a></li>
<li><a href='#realise_outcomes'><p>Realise outcomes</p></a></li>
<li><a href='#restrict_by_labels'><p>Reduce nodal types using labels</p></a></li>
<li><a href='#restrict_by_query'><p>Reduce nodal types using statement</p></a></li>
<li><a href='#reveal_outcomes'><p>Reveal outcomes</p></a></li>
<li><a href='#set_ambiguities_matrix'><p>Set ambiguity matrix</p></a></li>
<li><a href='#set_confound'><p>Set confound</p></a></li>
<li><a href='#set_parameter_matrix'><p>Set parameter matrix</p></a></li>
<li><a href='#set_parmap'><p>Set parmap: a matrix mapping from parameters to data types</p></a></li>
<li><a href='#set_prior_distribution'><p>Add prior distribution draws</p></a></li>
<li><a href='#set_restrictions'><p>Restrict a model</p></a></li>
<li><a href='#set_sampling_args'><p>set_sampling_args</p>
From 'rstanarm' (November 1st, 2019)</a></li>
<li><a href='#simulate_data'><p>simulate_data is an alias for make_data</p></a></li>
<li><a href='#st_within'><p>Get string between two regular expression patterns</p></a></li>
<li><a href='#substitutes'><p>Make statement for substitutes</p></a></li>
<li><a href='#te'><p>Make treatment effect statement (positive)</p></a></li>
<li><a href='#type_matrix'><p>Generate type matrix</p></a></li>
<li><a href='#uncollapse_nodal_types'><p>uncollapse nodal types</p></a></li>
<li><a href='#unpack_wildcard'><p>Unpack a wild card</p></a></li>
<li><a href='#update_causal_types'><p>Update causal types based on nodal types</p></a></li>
<li><a href='#update_model'><p>Fit causal model using 'stan'</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Make, Update, and Query Binary Causal Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Users can declare binary causal models, update beliefs about causal types given data and calculate arbitrary estimands.  Model definition makes use of 'dagitty' functionality. Updating is implemented in 'stan'. The approach used in 'CausalQueries' is a generalization of the 'biqq' models described in "Mixing Methods: A Bayesian Approach" (Humphreys and Jacobs, 2015, &lt;<a href="https://doi.org/10.1017%2FS0003055415000453">doi:10.1017/S0003055415000453</a>&gt;). The conceptual extension makes use of work on probabilistic causal models described in Pearl's Causality (Pearl, 2009, &lt;<a href="https://doi.org/10.1017%2FCBO9780511803161">doi:10.1017/CBO9780511803161</a>&gt;).</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/integrated-inferences/CausalQueries/issues">https://github.com/integrated-inferences/CausalQueries/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>dplyr, methods, R (&ge; 3.4.0), Rcpp (&ge; 0.12.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dagitty (&ge; 0.3-1), dirmult (&ge; 0.1.3-4), stats (&ge; 4.1.1),
rlang (&ge; 0.2.0), rstan (&ge; 2.26.0), rstantools (&ge; 2.0.0),
stringr (&ge; 1.4.0), ggdag (&ge; 0.2.4), latex2exp (&ge; 0.9.4),
ggplot2 (&ge; 3.3.5), lifecycle (&ge; 1.0.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppArmadillo, RcppEigen
(&ge; 0.3.3.3.0), rstan (&ge; 2.26.0), StanHeaders (&ge; 2.26.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, rmarkdown, knitr, DeclareDesign, fabricatr, covr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-15 20:50:49 UTC; tilltietz</td>
</tr>
<tr>
<td>Author:</td>
<td>Clara Bicalho [ctb],
  Jasper Cooper [ctb],
  Macartan Humphreys
    <a href="https://orcid.org/0000-0001-7029-2326"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Till Tietz <a href="https://orcid.org/0000-0002-2916-9059"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Alan Jacobs [aut],
  Merlin Heidemanns [ctb],
  Lily Medina <a href="https://orcid.org/0009-0004-2423-524X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Julio Solis [ctb],
  Georgiy Syunyaev <a href="https://orcid.org/0000-0002-4391-6313"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Till Tietz &lt;ttietz2014@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-15 21:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CausalQueries-package'>'CausalQueries'</h2><span id='topic+CausalQueries-package'></span>

<h3>Description</h3>

<p>'CausalQueries' is a package that lets you generate binary causal models,
update over models given data and calculate arbitrary causal queries.
Model definition makes use of dagitty syntax.
Updating is implemented in 'stan'.
</p>

<hr>
<h2 id='add_dots'>Helper to fill in missing do operators in causal expression</h2><span id='topic+add_dots'></span>

<h3>Description</h3>

<p>Helper to fill in missing do operators in causal expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dots(q, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_dots_+3A_q">q</code></td>
<td>
<p>A character string. Causal query with at least one parent node
missing their do operator.</p>
</td></tr>
<tr><td><code id="add_dots_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A causal query expression with all parents nodes set to
either 0, 1 or wildcard '.'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; Y &lt;- M')
CausalQueries:::add_dots('Y[X=1]', model)
CausalQueries:::add_dots('Y[]', model)

</code></pre>

<hr>
<h2 id='add_wildcard'>Adds a wildcard for every missing parent</h2><span id='topic+add_wildcard'></span>

<h3>Description</h3>

<p>Adds a wildcard for every missing parent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_wildcard(node, statement, parents, missing_parents)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_wildcard_+3A_node">node</code></td>
<td>
<p>A character string. The quoted name of a node.</p>
</td></tr>
<tr><td><code id="add_wildcard_+3A_statement">statement</code></td>
<td>
<p>A character string. A quoted causal statement.</p>
</td></tr>
<tr><td><code id="add_wildcard_+3A_parents">parents</code></td>
<td>
<p>A vector of characters. The <code>node</code>'s parents</p>
</td></tr>
<tr><td><code id="add_wildcard_+3A_missing_parents">missing_parents</code></td>
<td>
<p>A vector of characters.  The <code>node</code>'s
missing parents</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A causal query expression with all parents nodes set to
either 0, 1 or wildcard '.'
</p>

<hr>
<h2 id='all_data_types'>All data types</h2><span id='topic+all_data_types'></span>

<h3>Description</h3>

<p>Creates dataframe with all data types (including NA types)
that are possible from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_data_types(
  model,
  complete_data = FALSE,
  possible_data = FALSE,
  given = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_data_types_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="all_data_types_+3A_complete_data">complete_data</code></td>
<td>
<p>Logical. If 'TRUE' returns only complete data types
(no NAs). Defaults to 'FALSE'.</p>
</td></tr>
<tr><td><code id="all_data_types_+3A_possible_data">possible_data</code></td>
<td>
<p>Logical. If 'TRUE' returns only complete data types
(no NAs) that are *possible* given model restrictions. Note that in
principle an intervention could make observationally impossible data types
arise. Defaults to 'FALSE'.</p>
</td></tr>
<tr><td><code id="all_data_types_+3A_given">given</code></td>
<td>
<p>A character.  A quoted statement that evaluates to logical.
Data conditional on specific values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with all data types (including NA types)
that are possible from a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
all_data_types(make_model('X -&gt; Y'))
model &lt;- make_model('X -&gt; Y') %&gt;%
  set_restrictions(labels = list(Y = '00'), keep = TRUE)
  all_data_types(model)
  all_data_types(model, complete_data = TRUE)
  all_data_types(model, possible_data = TRUE)
  all_data_types(model, given  = 'X==1')
  all_data_types(model, given  = 'X==1 &amp; Y==1')

</code></pre>

<hr>
<h2 id='causal_type_names'>Names for causal types</h2><span id='topic+causal_type_names'></span>

<h3>Description</h3>

<p>Names for causal types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>causal_type_names(causal_types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="causal_type_names_+3A_causal_types">causal_types</code></td>
<td>
<p>A <code>data.frame</code> whose rows containing the 0-1 digits
that conform the causal types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> whose rows contain the character values that
conform each causal type in a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; Y')
possible_types &lt;- get_nodal_types(model)
df &lt;- data.frame(expand.grid(possible_types, stringsAsFactors = FALSE))
CausalQueries:::causal_type_names(df)

</code></pre>

<hr>
<h2 id='CausalQueries_internal_inherit_params'>Create parameter documentation to inherit</h2><span id='topic+CausalQueries_internal_inherit_params'></span>

<h3>Description</h3>

<p>Create parameter documentation to inherit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CausalQueries_internal_inherit_params(
  model,
  query,
  join_by,
  parameters,
  P,
  A,
  data,
  data_events,
  node,
  statement,
  using,
  n_draws
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_query">query</code></td>
<td>
<p>A character string. An expression defining nodal types to
interrogate <code><a href="#topic+realise_outcomes">realise_outcomes</a></code>. An expression of the form
&quot;Y[X=1]&quot; asks for the value of Y when X is set to 1</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_join_by">join_by</code></td>
<td>
<p>A logical operator. Used to connect causal statements:
<em>AND</em> ('&amp;') or <em>OR</em> ('|'). Defaults to '|'.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from
<code>model$parameters_df</code>.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_a">A</code></td>
<td>
<p>A <code>data.frame</code>. Ambiguity matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.  Data of nodes that can take three values:
0, 1, and NA. In long form as generated by <code><a href="#topic+make_events">make_events</a></code></p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_data_events">data_events</code></td>
<td>
<p>A <code>data.frame</code>. It must be compatible with nodes in
<code>model</code>. The default columns are
<code>event</code>, <code>strategy</code> and <code>count</code>.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_node">node</code></td>
<td>
<p>A character string. The quoted name of a node.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_statement">statement</code></td>
<td>
<p>A character string. A quoted causal statement.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_using">using</code></td>
<td>
<p>A character string. Indicates whether to
use 'priors', 'posteriors' or 'parameters'.</p>
</td></tr>
<tr><td><code id="CausalQueries_internal_inherit_params_+3A_n_draws">n_draws</code></td>
<td>
<p>An integer. If no prior distribution is provided,
generate prior distribution with <code>n_draws</code> number of draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything. It is used to
inherit roxygen documentation
</p>

<hr>
<h2 id='check_args'>helper to check arguments</h2><span id='topic+check_args'></span>

<h3>Description</h3>

<p>helper to check arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_args(model, using, given, queries, case_level, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_args_+3A_model">model</code></td>
<td>
<p>passed from parent function</p>
</td></tr>
<tr><td><code id="check_args_+3A_using">using</code></td>
<td>
<p>passed from parent function</p>
</td></tr>
<tr><td><code id="check_args_+3A_given">given</code></td>
<td>
<p>passed from parent function</p>
</td></tr>
<tr><td><code id="check_args_+3A_queries">queries</code></td>
<td>
<p>passed from parent function</p>
</td></tr>
<tr><td><code id="check_args_+3A_fun">fun</code></td>
<td>
<p>string specifying the name of the parent function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of altered arguments
</p>

<hr>
<h2 id='check_query'>Warn about improper query specification and apply fixes</h2><span id='topic+check_query'></span>

<h3>Description</h3>

<p>Warn about improper query specification and apply fixes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_query(query)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_query_+3A_query">query</code></td>
<td>
<p>a string specifying a query</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fixed query as string
</p>

<hr>
<h2 id='check_string_input'>Check string_input</h2><span id='topic+check_string_input'></span>

<h3>Description</h3>

<p>Check string_input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_string_input(param_list = list(), call_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_string_input_+3A_param_list">param_list</code></td>
<td>
<p>List of parameters</p>
</td></tr>
<tr><td><code id="check_string_input_+3A_call_name">call_name</code></td>
<td>
<p>Name of the call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If appropriate, it returns error message.
</p>

<hr>
<h2 id='clean_condition'>Clean condition</h2><span id='topic+clean_condition'></span>

<h3>Description</h3>

<p>Takes a string specifying condition and returns properly spaced string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_condition(condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_condition_+3A_condition">condition</code></td>
<td>
<p>A character string. Condition that refers to a unique
position (possible outcome) in a nodal type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A properly spaced string.
</p>

<hr>
<h2 id='clean_param_vector'>Clean parameter vector</h2><span id='topic+clean_param_vector'></span>

<h3>Description</h3>

<p>Clean parameter vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_param_vector(model, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_param_vector_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="clean_param_vector_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from
<code>model$parameters_df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of named parameters summing to 1.
</p>

<hr>
<h2 id='clean_params'>Check parameters sum to 1 in param_set; normalize if needed; add
names if needed</h2><span id='topic+clean_params'></span>

<h3>Description</h3>

<p>Check parameters sum to 1 in param_set; normalize if needed; add
names if needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_params(parameters_df, warning = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_params_+3A_parameters_df">parameters_df</code></td>
<td>
<p>A <code>data.frame</code>. This object is first generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="clean_params_+3A_warning">warning</code></td>
<td>
<p>Logical. Whether to print warning (if any) in console.
Defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parameters <code>data.frame</code>  with names and where parameters
sum to 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X-&gt;Y')
model$parameters_df$param_value &lt;- 1:6
CausalQueries:::clean_params(model$parameters_df, warning = TRUE)

</code></pre>

<hr>
<h2 id='collapse_data'>Make compact data with data strategies</h2><span id='topic+collapse_data'></span>

<h3>Description</h3>

<p>Take a 'data.frame' and return compact 'data.frame'
of event types and strategies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_data(
  data,
  model,
  drop_NA = TRUE,
  drop_family = FALSE,
  summary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_data_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.  Data of nodes that can take three values:
0, 1, and NA. In long form as generated by <code><a href="#topic+make_events">make_events</a></code></p>
</td></tr>
<tr><td><code id="collapse_data_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="collapse_data_+3A_drop_na">drop_NA</code></td>
<td>
<p>Logical. Whether to exclude strategy families that contain
no observed data. Exceptionally if no data is provided, minimal data on
data on first node is returned. Defaults to 'TRUE'</p>
</td></tr>
<tr><td><code id="collapse_data_+3A_drop_family">drop_family</code></td>
<td>
<p>Logical. Whether to remove column <code>strategy</code> from
the output. Defaults to 'FALSE'.</p>
</td></tr>
<tr><td><code id="collapse_data_+3A_summary">summary</code></td>
<td>
<p>Logical. Whether to return summary of the data. See details.
Defaults to 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of data events
</p>
<p>If <code>summary = TRUE</code> 'collapse_data' returns a list containing the
following components:
</p>
<table>
<tr><td><code>data_events</code></td>
<td>
<p>A compact data.frame of event types and strategies.</p>
</td></tr>
<tr><td><code>observed_events</code></td>
<td>
<p>A vector of character strings specifying the events
observed in the data</p>
</td></tr>
<tr><td><code>unobserved_events</code></td>
<td>
<p>A vector of character strings specifying the
events not observed in the data</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

model &lt;- make_model('X -&gt; Y')

df &lt;- data.frame(X = c(0,1,NA), Y = c(0,0,1))

df %&gt;% collapse_data(model)


collapse_data(df, model, drop_NA = FALSE)

collapse_data(df, model, drop_family = TRUE)

collapse_data(df, model, summary = TRUE)

data &lt;- make_data(model, n = 0)
collapse_data(data, model)

model &lt;- make_model('X -&gt; Y') %&gt;% set_restrictions('X[]==1')
df &lt;- make_data(model, n = 10)
df[1,1] &lt;- ''
collapse_data(df, model)
data &lt;- data.frame(X= 0:1)
collapse_data(data, model)



</code></pre>

<hr>
<h2 id='collapse_nodal_types'>collapse nodal types</h2><span id='topic+collapse_nodal_types'></span>

<h3>Description</h3>

<p>collapse nodal types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_nodal_types(nodal_types, include_node_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_nodal_types_+3A_nodal_types">nodal_types</code></td>
<td>
<p>A list of nodal types.</p>
</td></tr>
<tr><td><code id="collapse_nodal_types_+3A_include_node_names">include_node_names</code></td>
<td>
<p>Logical, if TRUE returns names X0, X1;
otherwise returns 0, 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing nodes with nodal types in a vector form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; K -&gt; Y')
(nodal_types &lt;- get_nodal_types(model , collapse = FALSE))
CausalQueries:::collapse_nodal_types(nodal_types )
</code></pre>

<hr>
<h2 id='complements'>Make statement for complements</h2><span id='topic+complements'></span>

<h3>Description</h3>

<p>Generate a statement for X1, X1 complement each other in the production of Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complements(X1, X2, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complements_+3A_x1">X1</code></td>
<td>
<p>A character. The quoted name of the input node 1.</p>
</td></tr>
<tr><td><code id="complements_+3A_x2">X2</code></td>
<td>
<p>A character. The quoted name of the input node 2.</p>
</td></tr>
<tr><td><code id="complements_+3A_y">Y</code></td>
<td>
<p>A character. The quoted name of the outcome node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character statement of class <code>statement</code>
</p>


<h3>See Also</h3>

<p>Other statements: 
<code><a href="#topic+decreasing">decreasing</a>()</code>,
<code><a href="#topic+increasing">increasing</a>()</code>,
<code><a href="#topic+interacts">interacts</a>()</code>,
<code><a href="#topic+non_decreasing">non_decreasing</a>()</code>,
<code><a href="#topic+non_increasing">non_increasing</a>()</code>,
<code><a href="#topic+substitutes">substitutes</a>()</code>,
<code><a href="#topic+te">te</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
complements('A', 'B', 'W')

</code></pre>

<hr>
<h2 id='construct_commands_alter_at'>make_par_values</h2><span id='topic+construct_commands_alter_at'></span>

<h3>Description</h3>

<p>helper to generate filter commands specifying rows of parameters_df that
should be altered given an alter_at statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_commands_alter_at(alter_at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_commands_alter_at_+3A_alter_at">alter_at</code></td>
<td>
<p>string specifying filtering operations to be applied to
parameters_df, yielding a logical vector indicating parameters for which
values should be altered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string specifying a filter command
</p>

<hr>
<h2 id='construct_commands_other_args'>make_par_values</h2><span id='topic+construct_commands_other_args'></span>

<h3>Description</h3>

<p>helper to generate filter commands specifying rows of parameters_df that
should be altered given combinations of nodes, nodal_types, param_sets,
givens and statements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_commands_other_args(
  node,
  nodal_type,
  param_set,
  given,
  statement,
  model,
  join_by
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_commands_other_args_+3A_node">node</code></td>
<td>
<p>string indicating nodes which are to be altered</p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_nodal_type">nodal_type</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_param_set">param_set</code></td>
<td>
<p>string indicating  the name of the set of parameters
to be altered</p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_given">given</code></td>
<td>
<p>string indicates the node on which the parameter
to be altered depends</p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_statement">statement</code></td>
<td>
<p>causal query that determines nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_model">model</code></td>
<td>
<p>model created with <code>make_model</code></p>
</td></tr>
<tr><td><code id="construct_commands_other_args_+3A_join_by">join_by</code></td>
<td>
<p>string specifying the logical operator joining expanded
types when <code>statement</code> contains wildcards.
Can take values <code>'&amp;'</code> (logical AND) or <code>'|'</code> (logical OR).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string specifying a filter command
</p>

<hr>
<h2 id='construct_commands_param_names'>make_par_values</h2><span id='topic+construct_commands_param_names'></span>

<h3>Description</h3>

<p>helper to generate filter commands specifying rows of parameters_df that
should be altered given an a vector of parameter names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_commands_param_names(param_names, model_param_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_commands_param_names_+3A_param_names">param_names</code></td>
<td>
<p>vector of strings. The name of specific parameter in
the form of, for example, 'X.1', 'Y.01'</p>
</td></tr>
<tr><td><code id="construct_commands_param_names_+3A_model_param_names">model_param_names</code></td>
<td>
<p>vector of strings. Parameter names found
in the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string specifying a filter command
</p>

<hr>
<h2 id='data_to_data'>helper to generate a matrix mapping from names of M to names of A</h2><span id='topic+data_to_data'></span>

<h3>Description</h3>

<p>helper to generate a matrix mapping from names of M to names of A
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_to_data(M, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_to_data_+3A_m">M</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="data_to_data_+3A_a">A</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='data_type_names'>Data type names</h2><span id='topic+data_type_names'></span>

<h3>Description</h3>

<p>Provides names to data types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_type_names(model, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_type_names_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="data_type_names_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.  Data of nodes that can take three values:
0, 1, and NA. In long form as generated by <code><a href="#topic+make_events">make_events</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of strings of data types
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; Y')
data &lt;- make_data(model, n = 2)
data_type_names(model, data)
</code></pre>

<hr>
<h2 id='decreasing'>Make monotonicity statement (negative)</h2><span id='topic+decreasing'></span>

<h3>Description</h3>

<p>Generate a statement for Y monotonic (decreasing) in X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decreasing(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decreasing_+3A_x">X</code></td>
<td>
<p>A character. The quoted name of the input node</p>
</td></tr>
<tr><td><code id="decreasing_+3A_y">Y</code></td>
<td>
<p>A character. The quoted name of the outcome node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character statement of class <code>statement</code>
</p>


<h3>See Also</h3>

<p>Other statements: 
<code><a href="#topic+complements">complements</a>()</code>,
<code><a href="#topic+increasing">increasing</a>()</code>,
<code><a href="#topic+interacts">interacts</a>()</code>,
<code><a href="#topic+non_decreasing">non_decreasing</a>()</code>,
<code><a href="#topic+non_increasing">non_increasing</a>()</code>,
<code><a href="#topic+substitutes">substitutes</a>()</code>,
<code><a href="#topic+te">te</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
decreasing('A', 'B')

</code></pre>

<hr>
<h2 id='default_stan_control'>default_stan_control</h2><span id='topic+default_stan_control'></span>

<h3>Description</h3>

<p>default_stan_control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_stan_control(adapt_delta = NULL, max_treedepth = 15L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_stan_control_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>A double between 0 and 1. It determines
<code>adapt_delta</code></p>
</td></tr>
<tr><td><code id="default_stan_control_+3A_max_treedepth">max_treedepth</code></td>
<td>
<p>A positive integer. It determines
<code>maximum_tree_depth</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sets controls to default unless otherwise specified.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing arguments to be passed to <code>stan</code>
</p>

<hr>
<h2 id='democracy_data'>Development and Democratization: Data for replication of analysis in
*Integrated Inferences*</h2><span id='topic+democracy_data'></span>

<h3>Description</h3>

<p>A dataset containing information on inequality, democracy, mobilization,
and international pressure.
Made by <code>devtools::use_data(democracy_data, CausalQueries)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>democracy_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 84 rows and 5 nodes:
</p>

<dl>
<dt>Case</dt><dd><p>Case</p>
</dd>
<dt>D</dt><dd><p>Democracy</p>
</dd>
<dt>I</dt><dd><p>Inequality</p>
</dd>
<dt>P</dt><dd><p>International Pressure</p>
</dd>
<dt>M</dt><dd><p>Mobilization</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.cambridge.org/core/journals/american-political-science-review/article/inequality-and-regime-change-democratic-transitions-and-the-stability-of-democratic-rule/C39AAF4CF274445555FF41F7CC896AE3#fndtn-supplementary-materials/">https://www.cambridge.org/core/journals/american-political-science-review/article/inequality-and-regime-change-democratic-transitions-and-the-stability-of-democratic-rule/C39AAF4CF274445555FF41F7CC896AE3#fndtn-supplementary-materials/</a>
</p>

<hr>
<h2 id='draw_causal_type'>Draw a single causal type given a parameter vector</h2><span id='topic+draw_causal_type'></span>

<h3>Description</h3>

<p>Output is a parameter dataframe recording both parameters
(case level priors) and
the case level causal type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_causal_type(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_causal_type_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="draw_causal_type_+3A_...">...</code></td>
<td>
<p>Arguments passed to  'set_parameters'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple draw using model's parameter vector
make_model("X -&gt; M -&gt; Y") %&gt;%
draw_causal_type(.)

# Draw parameters from priors and draw type from parameters
make_model("X -&gt; M -&gt; Y") %&gt;%
draw_causal_type(., param_type = "prior_draw")

# Draw type given specified parameters
make_model("X -&gt; M -&gt; Y") %&gt;%
draw_causal_type(., parameters = 1:10)

# Define a causal type and reveal data
model &lt;- make_model("X -&gt; Y; X &lt;-&gt; Y")
type &lt;- model %&gt;% draw_causal_type()
make_data(model, parameters = type$causal_type)
</code></pre>

<hr>
<h2 id='drop_empty_families'>Drop empty families</h2><span id='topic+drop_empty_families'></span>

<h3>Description</h3>

<p>Drop empty families
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_empty_families(data_events)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_empty_families_+3A_data_events">data_events</code></td>
<td>
<p>A <code>data.frame</code>. It must be compatible with nodes in
<code>model</code>. The default columns are
<code>event</code>, <code>strategy</code> and <code>count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data events with strategies (excluding  strategy families
that contain no observed data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_events &lt;- data.frame(event = c('X0Y0', 'Y0'),
                          strategy = c('XY', 'Y'),
                          count = 1:0)
CausalQueries:::drop_empty_families(data_events)


</code></pre>

<hr>
<h2 id='expand_data'>Expand compact data object to data frame</h2><span id='topic+expand_data'></span>

<h3>Description</h3>

<p>Expand compact data object to data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_data(data_events = NULL, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_data_+3A_data_events">data_events</code></td>
<td>
<p>A <code>data.frame</code>. It must be compatible with nodes in
<code>model</code>. The default columns are
<code>event</code>, <code>strategy</code> and <code>count</code>.</p>
</td></tr>
<tr><td><code id="expand_data_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with rows as data observation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X-&gt;M-&gt;Y')
make_events(model, n = 5) %&gt;%
  expand_data(model)
make_events(model, n = 0) %&gt;%
  expand_data(model)
 

</code></pre>

<hr>
<h2 id='expand_nodal_expression'>Helper to expand nodal expression</h2><span id='topic+expand_nodal_expression'></span>

<h3>Description</h3>

<p>Helper to expand nodal expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_nodal_expression(model, query, node, join_by = "|")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_nodal_expression_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="expand_nodal_expression_+3A_query">query</code></td>
<td>
<p>A character string. An expression defining nodal types to
interrogate <code><a href="#topic+realise_outcomes">realise_outcomes</a></code>. An expression of the form
&quot;Y[X=1]&quot; asks for the value of Y when X is set to 1</p>
</td></tr>
<tr><td><code id="expand_nodal_expression_+3A_node">node</code></td>
<td>
<p>A character string. The quoted name of a node.</p>
</td></tr>
<tr><td><code id="expand_nodal_expression_+3A_join_by">join_by</code></td>
<td>
<p>A logical operator. Used to connect causal statements:
<em>AND</em> ('&amp;') or <em>OR</em> ('|'). Defaults to '|'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nodal expression with no missing parents
</p>

<hr>
<h2 id='expand_wildcard'>Expand wildcard</h2><span id='topic+expand_wildcard'></span>

<h3>Description</h3>

<p>Expand statement containing wildcard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_wildcard(to_expand, join_by = "|", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_wildcard_+3A_to_expand">to_expand</code></td>
<td>
<p>A character vector of length 1L.</p>
</td></tr>
<tr><td><code id="expand_wildcard_+3A_join_by">join_by</code></td>
<td>
<p>A logical operator. Used to connect causal statements:
<em>AND</em> ('&amp;') or <em>OR</em> ('|'). Defaults to '|'.</p>
</td></tr>
<tr><td><code id="expand_wildcard_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to print expanded query on the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with the expanded expression.
Wildcard '.' is replaced by 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Position of parentheses matters for type of expansion
# In the "global expansion" versions of the entire statement are joined
expand_wildcard('(Y[X=1, M=.] &gt; Y[X=1, M=.])')
# In the "local expansion" versions of indicated parts are joined
expand_wildcard('(Y[X=1, M=.]) &gt; (Y[X=1, M=.])')

# If parentheses are missing global expansion used.
expand_wildcard('Y[X=1, M=.] &gt; Y[X=1, M=.]')

# Expressions not requiring expansion are allowed
expand_wildcard('(Y[X=1])')
</code></pre>

<hr>
<h2 id='get_ambiguities_matrix'>Get ambiguities matrix</h2><span id='topic+get_ambiguities_matrix'></span>

<h3>Description</h3>

<p>Return ambiguities matrix if it exists; otherwise calculate
it assuming no confounding.The ambiguities matrix maps from causal types
into data types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ambiguities_matrix(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ambiguities_matrix_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>. Causal types (rows) corresponding to
possible data realizations (columns).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; Y')
get_ambiguities_matrix(model = model)

</code></pre>

<hr>
<h2 id='get_causal_types'>Get causal types</h2><span id='topic+get_causal_types'></span>

<h3>Description</h3>

<p>Return data frame with types produced from all combinations of possible
data produced by a DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_causal_types(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_causal_types_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> indicating causal types of a <code>model</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_causal_types(make_model('X -&gt; Y'))

</code></pre>

<hr>
<h2 id='get_data_families'>get_data_families</h2><span id='topic+get_data_families'></span>

<h3>Description</h3>

<p>Get possible data types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data_families(
  model,
  drop_impossible = TRUE,
  drop_all_NA = TRUE,
  mapping_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_families_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_data_families_+3A_drop_impossible">drop_impossible</code></td>
<td>
<p>Logical. Whether to drop data that is impossible given
model restrictions. Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="get_data_families_+3A_drop_all_na">drop_all_NA</code></td>
<td>
<p>Logical. Whether to drop row of all 'NA's.
Defaults to 'TRUE'</p>
</td></tr>
<tr><td><code id="get_data_families_+3A_mapping_only">mapping_only</code></td>
<td>
<p>Logical. Whether to return data mapping matrix only.
Defaults to 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns indices and ambiguity matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CausalQueries:::get_data_families(model = make_model('X-&gt;Y'))
CausalQueries:::get_data_families(model = make_model('X-&gt;Y'),
                                  mapping_only = TRUE)
CausalQueries:::get_data_families(model = make_model('X-&gt; M -&gt; Y'))


</code></pre>

<hr>
<h2 id='get_estimands'>helper to get estimands</h2><span id='topic+get_estimands'></span>

<h3>Description</h3>

<p>helper to get estimands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_estimands(jobs, given_types, query_types, type_distributions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_estimands_+3A_jobs">jobs</code></td>
<td>
<p><code>DataFrame</code> of argument combinations</p>
</td></tr>
<tr><td><code id="get_estimands_+3A_given_types">given_types</code></td>
<td>
<p>output from <code>queries_to_types</code></p>
</td></tr>
<tr><td><code id="get_estimands_+3A_query_types">query_types</code></td>
<td>
<p>output from <code>queries_to_types</code></p>
</td></tr>
<tr><td><code id="get_estimands_+3A_type_distributions">type_distributions</code></td>
<td>
<p>output from <code>get_type_distributions</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of estimands
</p>

<hr>
<h2 id='get_event_prob'>Draw event probabilities</h2><span id='topic+get_event_prob'></span>

<h3>Description</h3>

<p>'get_event_prob' draws event probability vector 'w' given a single
realization of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_event_prob(model, parameters = NULL, A = NULL, P = NULL, given = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_event_prob_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_event_prob_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from
<code>model$parameters_df</code>.</p>
</td></tr>
<tr><td><code id="get_event_prob_+3A_a">A</code></td>
<td>
<p>A <code>data.frame</code>. Ambiguity matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
<tr><td><code id="get_event_prob_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
<tr><td><code id="get_event_prob_+3A_given">given</code></td>
<td>
<p>A string specifying known values on nodes, e.g. &quot;X==1 &amp; Y==1&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of event probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; Y')
get_event_prob(model = model)
get_event_prob(model = model, given = "X==1")
get_event_prob(model = model, parameters = rep(1, 6))
get_event_prob(model = model, parameters = 1:6)


</code></pre>

<hr>
<h2 id='get_nodal_types'>Get list of types for nodes in a DAG</h2><span id='topic+get_nodal_types'></span>

<h3>Description</h3>

<p>As type labels are hard to interpret for large models, the type list
includes an attribute to help interpret them.
See  <code>attr(types, interpret)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nodal_types(model, collapse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nodal_types_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_nodal_types_+3A_collapse">collapse</code></td>
<td>
<p>Logical. If 'TRUE', shows unique nodal types for each node.
If 'FALSE', shows for each node a matrix with nodal types as rows and
parent types as columns, if applicable. Defaults to 'TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> of nodal types for each parent in a DAG
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; K -&gt; Y')
get_nodal_types(model)

model &lt;- make_model('X -&gt; K -&gt; Y') %&gt;%
   set_restrictions(statement = 'K[X=1]&gt;K[X=0]') %&gt;%
   set_confound(list(K = 'Y[K=1]&gt;Y[K=0]'))
get_nodal_types(model)


</code></pre>

<hr>
<h2 id='get_param_dist'>Get a distribution of model parameters</h2><span id='topic+get_param_dist'></span>

<h3>Description</h3>

<p>Using parameters, priors, or posteriors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_param_dist(model, using, n_draws = 4000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_param_dist_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_param_dist_+3A_using">using</code></td>
<td>
<p>A character string. Indicates whether to
use 'priors', 'posteriors' or 'parameters'.</p>
</td></tr>
<tr><td><code id="get_param_dist_+3A_n_draws">n_draws</code></td>
<td>
<p>An integer. If no prior distribution is provided,
generate prior distribution with <code>n_draws</code> number of draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the distribution of the parameters in the model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_param_dist(model = make_model('X-&gt;Y'), using = 'priors', n_draws = 4)
get_param_dist(model = make_model('X-&gt;Y'), using = 'parameters')
</code></pre>

<hr>
<h2 id='get_parameter_matrix'>Get parameter matrix</h2><span id='topic+get_parameter_matrix'></span>

<h3>Description</h3>

<p>Return parameter matrix if it exists; otherwise calculate it assuming no
confounding. The parameter matrix  maps from parameters into causal types.
In models without confounding parameters correspond to nodal types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parameter_matrix(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameter_matrix_+3A_model">model</code></td>
<td>
<p>A model created by <code>make_model()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, the parameter matrix, mapping from
parameters to causal types
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; Y')
get_parameter_matrix(model)
</code></pre>

<hr>
<h2 id='get_parameter_names'>Get parameter names</h2><span id='topic+get_parameter_names'></span>

<h3>Description</h3>

<p>Parameter names taken from <code>P</code> matrix or model if no
<code>P</code>  matrix provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parameter_names(model, include_paramset = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameter_names_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_parameter_names_+3A_include_paramset">include_paramset</code></td>
<td>
<p>Logical. Whether to include the param set
prefix as part of the name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the names of the parameters in the model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
get_parameter_names(make_model('X-&gt;Y'))
</code></pre>

<hr>
<h2 id='get_parents'>Get list of parents of all nodes in a model</h2><span id='topic+get_parents'></span>

<h3>Description</h3>

<p>Get list of parents of all nodes in a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parents(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parents_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of parents in a DAG
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; K -&gt; Y')
get_parents(model)
</code></pre>

<hr>
<h2 id='get_parmap'>Get parmap: a matrix mapping from parameters to data types</h2><span id='topic+get_parmap'></span>

<h3>Description</h3>

<p>Gets parmap from a model, or generates if not available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parmap(model, A = NULL, P = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parmap_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_parmap_+3A_a">A</code></td>
<td>
<p>A <code>data.frame</code>. Ambiguity matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
<tr><td><code id="get_parmap_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_parmap(model = make_model('X-&gt;Y'))

</code></pre>

<hr>
<h2 id='get_prior_distribution'>Get a prior distribution from priors</h2><span id='topic+get_prior_distribution'></span>

<h3>Description</h3>

<p>Add to the model a 'n_draws x n_param' matrix of possible parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_prior_distribution(model, n_draws = 4000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_prior_distribution_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_prior_distribution_+3A_n_draws">n_draws</code></td>
<td>
<p>A scalar. Number of draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.frame' with dimension 'n_param'x 'n_draws' of possible
lambda draws
</p>


<h3>See Also</h3>

<p>Other prior_distribution: 
<code><a href="#topic+make_prior_distribution">make_prior_distribution</a>()</code>,
<code><a href="#topic+set_prior_distribution">set_prior_distribution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_model('X -&gt; Y') %&gt;%
  set_prior_distribution(n_draws = 5) %&gt;%
  get_prior_distribution()
make_model('X -&gt; Y') %&gt;%
  get_prior_distribution(3)

</code></pre>

<hr>
<h2 id='get_query_types'>Look up query types</h2><span id='topic+get_query_types'></span>

<h3>Description</h3>

<p>Find which nodal or causal types are satisfied by a query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_query_types(model, query, map = "causal_type", join_by = "|")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_query_types_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_query_types_+3A_query">query</code></td>
<td>
<p>A character string. An expression defining nodal types to
interrogate <code><a href="#topic+realise_outcomes">realise_outcomes</a></code>. An expression of the form
&quot;Y[X=1]&quot; asks for the value of Y when X is set to 1</p>
</td></tr>
<tr><td><code id="get_query_types_+3A_map">map</code></td>
<td>
<p>Types in query. Either <code>nodal_type</code> or <code>causal_type</code>.
Default is <code>causal_type</code>.</p>
</td></tr>
<tr><td><code id="get_query_types_+3A_join_by">join_by</code></td>
<td>
<p>A logical operator. Used to connect causal statements:
<em>AND</em> ('&amp;') or <em>OR</em> ('|'). Defaults to '|'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing some of the following elements
</p>
<table>
<tr><td><code>types</code></td>
<td>
<p>A named vector with logical values indicating whether a
<code>nodal_type</code> or a <code>causal_type</code> satisfy 'query'</p>
</td></tr>
<tr><td><code>query</code></td>
<td>
<p>A character string as specified by the user</p>
</td></tr>
<tr><td><code>expanded_query</code></td>
<td>
<p>A character string with the expanded query.
Only differs from &lsquo;query' if this contains wildcard &rsquo;.'</p>
</td></tr>
<tr><td><code>evaluated_nodes</code></td>
<td>
<p>Value that the nodes take given a query</p>
</td></tr>
<tr><td><code>node</code></td>
<td>
<p>A character string of the node whose
nodal types are being queried</p>
</td></tr>
<tr><td><code>type_list</code></td>
<td>
<p>List of causal types satisfied by a query</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; M -&gt; Y; X-&gt;Y')
query &lt;- '(Y[X=0] &gt; Y[X=1])'

get_query_types(model, query, map="nodal_type")
get_query_types(model, query, map="causal_type")
get_query_types(model, query)

# Examples with map = "nodal_type"

query &lt;- '(Y[X=0, M = .] &gt; Y[X=1, M = 0])'
get_query_types(model, query, map="nodal_type")

query &lt;- '(Y[] == 1)'
get_query_types(model, query, map="nodal_type")
get_query_types(model, query, map="nodal_type", join_by = '&amp;')

# Root nodes specified with []
get_query_types(model, '(X[] == 1)', map="nodal_type")

query &lt;- '(M[X=1] == M[X=0])'
get_query_types(model, query, map="nodal_type")

# Nested do operations
get_query_types(
 model = make_model('A -&gt; B -&gt; C -&gt; D'),
 query = '(D[C=C[B=B[A=1]], A=0] &gt; D[C=C[B=B[A=0]], A=0])')

# Helpers
model &lt;- make_model('M-&gt;Y; X-&gt;Y')
query &lt;- complements('X', 'M', 'Y')
get_query_types(model, query, map="nodal_type")

# Examples with map = "causal_type"

model &lt;- make_model('X -&gt; M -&gt; Y; X-&gt;Y')
query &lt;- 'Y[M=M[X=0], X=1]==1'
get_query_types(model, query, map= "causal_type")

query &lt;- '(Y[X = 1, M = 1] &gt;  Y[X = 0, M = 1]) &amp;
          (Y[X = 1, M = 0] &gt;  Y[X = 0, M = 0])'
get_query_types(model, query, "causal_type")

query &lt;- 'Y[X=1] == Y[X=0]'
get_query_types(model, query, "causal_type")

query &lt;- '(X == 1) &amp; (M==1) &amp; (Y ==1) &amp; (Y[X=0] ==1)'
get_query_types(model, query, "causal_type")

query &lt;- '(Y[X = .]==1)'
get_query_types(model, query, "causal_type")

</code></pre>

<hr>
<h2 id='get_type_distributions'>helper to get type distributions</h2><span id='topic+get_type_distributions'></span>

<h3>Description</h3>

<p>helper to get type distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_type_distributions(jobs, model, n_draws, parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_type_distributions_+3A_jobs">jobs</code></td>
<td>
<p><code>DataFrame</code> of argument combinations</p>
</td></tr>
<tr><td><code id="get_type_distributions_+3A_model">model</code></td>
<td>
<p>a list of models</p>
</td></tr>
<tr><td><code id="get_type_distributions_+3A_n_draws">n_draws</code></td>
<td>
<p>integer specifying number of draws from prior distribution</p>
</td></tr>
<tr><td><code id="get_type_distributions_+3A_parameters">parameters</code></td>
<td>
<p>optional list of parameter vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>jobs <code>DataFrame</code> with a nested column of type distributions
</p>

<hr>
<h2 id='get_type_names'>Get type names</h2><span id='topic+get_type_names'></span>

<h3>Description</h3>

<p>Get type names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_type_names(nodal_types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_type_names_+3A_nodal_types">nodal_types</code></td>
<td>
<p>Nodal types of a model. See <code><a href="#topic+get_nodal_types">get_nodal_types</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing causal type names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('A-&gt;Y&lt;-B')
CausalQueries:::get_type_names(model$nodal_types)
</code></pre>

<hr>
<h2 id='get_type_prob'>Get type probabilities</h2><span id='topic+get_type_prob'></span>

<h3>Description</h3>

<p>Gets probability of vector of causal types given a single
realization of parameters, possibly drawn from model priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_type_prob(model, P = NULL, parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_type_prob_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_type_prob_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
<tr><td><code id="get_type_prob_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from
<code>model$parameters_df</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, parameters is drawn from 'using' argument
(either from priors, posteriors, or from model$parameters)
</p>


<h3>Value</h3>

<p>A vector with probabilities of vector of causal types
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_type_prob(model = make_model('X-&gt;Y'))
get_type_prob(model = make_model('X-&gt;Y'), parameters = 1:6)

</code></pre>

<hr>
<h2 id='get_type_prob_c'>generates one draw from type probability distribution for each type in P</h2><span id='topic+get_type_prob_c'></span>

<h3>Description</h3>

<p>generates one draw from type probability distribution for each type in P
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_type_prob_c(P, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_type_prob_c_+3A_p">P</code></td>
<td>
<p>parameter_matrix of parameters and causal types</p>
</td></tr>
<tr><td><code id="get_type_prob_c_+3A_parameters">parameters</code></td>
<td>
<p>priors or posteriors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>draw from type distribution for each type in P
</p>

<hr>
<h2 id='get_type_prob_multiple'>Draw matrix of type probabilities, before or after estimation</h2><span id='topic+get_type_prob_multiple'></span>

<h3>Description</h3>

<p>Draw matrix of type probabilities, before or after estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_type_prob_multiple(
  model,
  using = "priors",
  parameters = NULL,
  n_draws = 4000,
  param_dist = NULL,
  P = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_type_prob_multiple_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="get_type_prob_multiple_+3A_using">using</code></td>
<td>
<p>A character. It indicates whether to use
'priors', 'posteriors' or 'parameters'.</p>
</td></tr>
<tr><td><code id="get_type_prob_multiple_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from
<code>model$parameters_df</code>.</p>
</td></tr>
<tr><td><code id="get_type_prob_multiple_+3A_n_draws">n_draws</code></td>
<td>
<p>An integer. If no prior distribution is provided, generate
prior distribution with <code>n_draws</code> number of draws.</p>
</td></tr>
<tr><td><code id="get_type_prob_multiple_+3A_param_dist">param_dist</code></td>
<td>
<p>A <code>matrix</code>.  Distribution of parameters.
Optional for speed.</p>
</td></tr>
<tr><td><code id="get_type_prob_multiple_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of type probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; Y')
get_type_prob_multiple(model, using = 'priors', n_draws = 3)
get_type_prob_multiple(model, using = 'parameters', n_draws = 3)
</code></pre>

<hr>
<h2 id='get_type_prob_multiple_c'>generates n draws from type probability distribution for each type in P</h2><span id='topic+get_type_prob_multiple_c'></span>

<h3>Description</h3>

<p>generates n draws from type probability distribution for each type in P
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_type_prob_multiple_c(params, P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_type_prob_multiple_c_+3A_params">params</code></td>
<td>
<p>parameters, priors or posteriors</p>
</td></tr>
<tr><td><code id="get_type_prob_multiple_c_+3A_p">P</code></td>
<td>
<p>parameter_matrix of parameters and causal types</p>
</td></tr>
</table>


<h3>Value</h3>

<p>draws from type distribution for each type in P
</p>

<hr>
<h2 id='gsub_many'>Recursive substitution</h2><span id='topic+gsub_many'></span>

<h3>Description</h3>

<p>Applies <code>gsub()</code> from multiple patterns to multiple
replacements with 1:1 mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsub_many(x, pattern_vector, replacement_vector, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsub_many_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="gsub_many_+3A_pattern_vector">pattern_vector</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="gsub_many_+3A_replacement_vector">replacement_vector</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="gsub_many_+3A_...">...</code></td>
<td>
<p>Options passed onto <code>gsub()</code> call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns multiple expression with substituted elements
</p>

<hr>
<h2 id='increasing'>Make monotonicity statement (positive)</h2><span id='topic+increasing'></span>

<h3>Description</h3>

<p>Generate a statement for Y monotonic (increasing) in X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>increasing(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="increasing_+3A_x">X</code></td>
<td>
<p>A character. The quoted name of the input node</p>
</td></tr>
<tr><td><code id="increasing_+3A_y">Y</code></td>
<td>
<p>A character. The quoted name of the outcome node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character statement of class <code>statement</code>
</p>


<h3>See Also</h3>

<p>Other statements: 
<code><a href="#topic+complements">complements</a>()</code>,
<code><a href="#topic+decreasing">decreasing</a>()</code>,
<code><a href="#topic+interacts">interacts</a>()</code>,
<code><a href="#topic+non_decreasing">non_decreasing</a>()</code>,
<code><a href="#topic+non_increasing">non_increasing</a>()</code>,
<code><a href="#topic+substitutes">substitutes</a>()</code>,
<code><a href="#topic+te">te</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
increasing('A', 'B')

</code></pre>

<hr>
<h2 id='institutions_data'>Institutions and growth: Data for replication of analysis in
*Integrated Inferences*</h2><span id='topic+institutions_data'></span>

<h3>Description</h3>

<p>A  dataset containing dichotomized versions of variables in
Rodrik, Subramanian, and Trebbi (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>institutions_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 79 rows and 5 columns:
</p>

<dl>
<dt>Y</dt><dd><p>Income (GDP PPP 1995), dichotomized</p>
</dd>
<dt>R</dt><dd><p>Institutions, (based on  Kaufmann, Kraay, and Zoido-Lobaton (2002)) dichotomized</p>
</dd>
<dt>D</dt><dd><p>Distance from the equator (in degrees), dichotomized</p>
</dd>
<dt>M</dt><dd><p>Settler mortality (from Acemoglu, Johnson, and Robinson), dichotomized</p>
</dd>
<dt>country</dt><dd><p>Country</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://drodrik.scholar.harvard.edu/publications/institutions-rule-primacy-institutions-over-geography-and-integration">https://drodrik.scholar.harvard.edu/publications/institutions-rule-primacy-institutions-over-geography-and-integration</a>
</p>

<hr>
<h2 id='interacts'>Make statement for any interaction</h2><span id='topic+interacts'></span>

<h3>Description</h3>

<p>Generate a statement for X1, X1 interact in the production of Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interacts(X1, X2, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interacts_+3A_x1">X1</code></td>
<td>
<p>A character. The quoted name of the input node 1.</p>
</td></tr>
<tr><td><code id="interacts_+3A_x2">X2</code></td>
<td>
<p>A character. The quoted name of the input node 2.</p>
</td></tr>
<tr><td><code id="interacts_+3A_y">Y</code></td>
<td>
<p>A character. The quoted name of the outcome node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character statement of class <code>statement</code>
</p>


<h3>See Also</h3>

<p>Other statements: 
<code><a href="#topic+complements">complements</a>()</code>,
<code><a href="#topic+decreasing">decreasing</a>()</code>,
<code><a href="#topic+increasing">increasing</a>()</code>,
<code><a href="#topic+non_decreasing">non_decreasing</a>()</code>,
<code><a href="#topic+non_increasing">non_increasing</a>()</code>,
<code><a href="#topic+substitutes">substitutes</a>()</code>,
<code><a href="#topic+te">te</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
interacts('A', 'B', 'W')
get_query_types(model = make_model('X-&gt; Y &lt;- W'),
         query = interacts('X', 'W', 'Y'), map = "causal_type")

</code></pre>

<hr>
<h2 id='interpret_type'>Interpret or find position in nodal type</h2><span id='topic+interpret_type'></span>

<h3>Description</h3>

<p>Interprets the position of one or more digits (specified by <code>position</code>)
in a nodal type. Alternatively returns nodal type digit positions that
correspond to one or more given <code>condition</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpret_type(model, condition = NULL, position = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpret_type_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="interpret_type_+3A_condition">condition</code></td>
<td>
<p>A vector of characters. Strings specifying the child node,
followed by '|' (given) and the values of its parent nodes in <code>model</code>.</p>
</td></tr>
<tr><td><code id="interpret_type_+3A_position">position</code></td>
<td>
<p>A named list of integers. The name is the name of the child
node in <code>model</code>, and its value a vector of digit positions in that
node's nodal type to be interpreted. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A node for a child node X with <code>k</code> parents has a nodal type
represented by X followed by <code>2^k</code> digits. Argument <code>position</code>
allows user to interpret the meaning of one or more digit positions in any
nodal type. For example <code>position = list(X = 1:3)</code> will return the
interpretation of the first three digits in causal types for X.
Argument <code>condition</code> allows users to query the digit position in the
nodal type by providing instead the values of the parent nodes of a given
child. For example, <code>condition = 'X | Z=0 &amp; R=1'</code> returns the digit
position that corresponds to values X takes when Z = 0 and R = 1.
</p>


<h3>Value</h3>

<p>A named <code>list</code> with interpretation of positions of
the digits in a nodal type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('R -&gt; X; Z -&gt; X; X -&gt; Y')
#Example using digit position
interpret_type(model, position = list(X = c(3,4), Y = 1))
#Example using condition
interpret_type(model, condition = c('X | Z=0 &amp; R=1', 'X | Z=0 &amp; R=0'))
#Return interpretation of all digit positions of all nodes
interpret_type(model)
</code></pre>

<hr>
<h2 id='is_a_model'>Check whether argument is a model</h2><span id='topic+is_a_model'></span>

<h3>Description</h3>

<p>Check whether argument is a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_a_model(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_a_model_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error message if argument is not a model.
</p>

<hr>
<h2 id='lipids_data'>Lipids: Data for Chickering and Pearl replication</h2><span id='topic+lipids_data'></span>

<h3>Description</h3>

<p>A compact dataset containing information on an encouragement,
(Z, cholestyramine prescription), a treatment (X, usage), and
an outcome (Y, cholesterol).
From David Maxwell Chickering and Judea Pearl: &quot;A Clinician’s Tool for
Analyzing Non-compliance&quot;, AAAI-96 Proceedings. Chickering and Pearl in turn
draw the data from Efron, Bradley, and David Feldman.
&quot;Compliance as an explanatory variable in clinical trials.&quot;
Journal of the American Statistical Association 86.413 (1991): 9-17.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lipids_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 8 rows and 3 columns:
</p>

<dl>
<dt>event</dt><dd><p>The data type</p>
</dd>
<dt>strategy</dt><dd><p>For which nodes is data available</p>
</dd>
<dt>count</dt><dd><p>Number of units with this data type</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://cdn.aaai.org/AAAI/1996/AAAI96-188.pdf">https://cdn.aaai.org/AAAI/1996/AAAI96-188.pdf</a>
</p>

<hr>
<h2 id='list_non_parents'>Returns a list with the nodes that are not directly pointing into a node</h2><span id='topic+list_non_parents'></span>

<h3>Description</h3>

<p>Returns a list with the nodes that are not directly pointing into a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_non_parents(model, node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_non_parents_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="list_non_parents_+3A_node">node</code></td>
<td>
<p>A character string. The quoted name of a node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the nodes that are not directly
pointing into a node
</p>

<hr>
<h2 id='make_ambiguities_matrix'>Make ambiguities matrix</h2><span id='topic+make_ambiguities_matrix'></span>

<h3>Description</h3>

<p>Make ambiguities matrix. The ambiguities matrix maps from
causal types into data types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ambiguities_matrix(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ambiguities_matrix_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>. Types (rows) corresponding to possible
data realizations (columns).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; Y')
CausalQueries:::make_ambiguities_matrix(model = model)

</code></pre>

<hr>
<h2 id='make_data'>Make data</h2><span id='topic+make_data'></span>

<h3>Description</h3>

<p>Make data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_data(
  model,
  n = NULL,
  parameters = NULL,
  param_type = NULL,
  nodes = NULL,
  n_steps = NULL,
  probs = NULL,
  subsets = TRUE,
  complete_data = NULL,
  given = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_data_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="make_data_+3A_n">n</code></td>
<td>
<p>Non negative integer. Number of observations.
If not provided it is inferred from the  largest n_step.</p>
</td></tr>
<tr><td><code id="make_data_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from
<code>model$parameters_df</code>.</p>
</td></tr>
<tr><td><code id="make_data_+3A_param_type">param_type</code></td>
<td>
<p>A character. String specifying type of parameters to
make (&quot;flat&quot;, &quot;prior_mean&quot;, &quot;posterior_mean&quot;, &quot;prior_draw&quot;,
&quot;posterior_draw&quot;, &quot;define&quot;). With param_type set to <code>define</code> use
arguments to be passed to <code>make_priors</code>; otherwise <code>flat</code> sets
equal probabilities on each nodal type in each parameter set;
<code>prior_mean</code>, <code>prior_draw</code>, <code>posterior_mean</code>,
<code>posterior_draw</code> take parameters as the means or as draws
from the prior or posterior.</p>
</td></tr>
<tr><td><code id="make_data_+3A_nodes">nodes</code></td>
<td>
<p>A <code>list</code>. Which nodes to be observed at each step.
If NULL all nodes are observed.</p>
</td></tr>
<tr><td><code id="make_data_+3A_n_steps">n_steps</code></td>
<td>
<p>A <code>list</code>. Number of observations to be
observed at each step</p>
</td></tr>
<tr><td><code id="make_data_+3A_probs">probs</code></td>
<td>
<p>A <code>list</code>. Observation probabilities at each step</p>
</td></tr>
<tr><td><code id="make_data_+3A_subsets">subsets</code></td>
<td>
<p>A <code>list</code>. Strata within which observations are to be
observed at each step. TRUE for all, otherwise an expression that
evaluates to a logical condition.</p>
</td></tr>
<tr><td><code id="make_data_+3A_complete_data">complete_data</code></td>
<td>
<p>A <code>data.frame</code>. Dataset with complete
observations. Optional.</p>
</td></tr>
<tr><td><code id="make_data_+3A_given">given</code></td>
<td>
<p>A string specifying known values on nodes, e.g. &quot;X==1 &amp; Y==1&quot;</p>
</td></tr>
<tr><td><code id="make_data_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE prints step schedule.</p>
</td></tr>
<tr><td><code id="make_data_+3A_...">...</code></td>
<td>
<p>additional arguments that can be passed to
<code>link{make_parameters}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that default behavior is not to take account of whether a node has
already been observed when determining whether to select or not. One can
however specifically request observation of nodes that have not been
previously observed.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with simulated data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple draws
model &lt;- make_model("X -&gt; M -&gt; Y")
make_data(model)
make_data(model, n = 3, nodes = c("X","Y"))
make_data(model, n = 3, param_type = "prior_draw")
make_data(model, n = 10, param_type = "define", parameters =  0:9)

# Data Strategies
# A strategy in which X, Y are observed for sure and M is observed
# with 50% probability for X=1, Y=0 cases

model &lt;- make_model("X -&gt; M -&gt; Y")
make_data(
  model,
  n = 8,
  nodes = list(c("X", "Y"), "M"),
  probs = list(1, .5),
  subsets = list(TRUE, "X==1 &amp; Y==0"))

# n not provided but inferred from largest n_step (not from sum of n_steps)
make_data(
  model,
  nodes = list(c("X", "Y"), "M"),
  n_steps = list(5, 2))

# Wide then deep
  make_data(
  model,
  n = 8,
  nodes = list(c("X", "Y"), "M"),
  subsets = list(TRUE, "!is.na(X) &amp; !is.na(Y)"),
  n_steps = list(6, 2))


make_data(
  model,
  n = 8,
  nodes = list(c("X", "Y"), c("X", "M")),
  subsets = list(TRUE, "is.na(X)"),
  n_steps = list(3, 2))

# Example with probabilities at each step

make_data(
  model,
  n = 8,
  nodes = list(c("X", "Y"), c("X", "M")),
  subsets = list(TRUE, "is.na(X)"),
  probs = list(.5, .2))

# Example with given data
make_data(model, given = "X==1 &amp; Y==1", n = 5)
</code></pre>

<hr>
<h2 id='make_data_single'>Generate full dataset</h2><span id='topic+make_data_single'></span>

<h3>Description</h3>

<p>Generate full dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_data_single(
  model,
  n = 1,
  parameters = NULL,
  param_type = NULL,
  given = NULL,
  w = NULL,
  P = NULL,
  A = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_data_single_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_n">n</code></td>
<td>
<p>An integer. Number of observations.</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_parameters">parameters</code></td>
<td>
<p>A numeric vector. Values of parameters may be specified.
By default, parameters is drawn from priors.</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_param_type">param_type</code></td>
<td>
<p>A character. String specifying type of parameters to make
(&quot;flat&quot;, &quot;prior_mean&quot;, &quot;posterior_mean&quot;, &quot;prior_draw&quot;,
&quot;posterior_draw&quot;, &quot;define). With param_type set to <code>define</code> use
arguments to be passed to <code>make_priors</code>; otherwise <code>flat</code> sets
equal probabilities on each nodal type in each parameter set;
<code>prior_mean</code>, <code>prior_draw</code>, <code>posterior_mean</code>,
<code>posterior_draw</code> take parameters as the means or as draws
from the prior or posterior.</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_given">given</code></td>
<td>
<p>A string specifying known values on nodes, e.g. &quot;X==1 &amp; Y==1&quot;</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_w">w</code></td>
<td>
<p>Vector of event probabilities can be provided directly.
This is useful for speed for repeated data draws.</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_p">P</code></td>
<td>
<p>A <code>matrix</code>. Parameter matrix that can be used to
generate w if w is not provided</p>
</td></tr>
<tr><td><code id="make_data_single_+3A_a">A</code></td>
<td>
<p>A <code>matrix</code>. Ambiguity matrix that can be used
to generate w if w is not provided</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of simulated data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model("X -&gt; Y")

# Simplest behavior uses by default the parameter vector contained in model
CausalQueries:::make_data_single(model, n = 5)

CausalQueries:::make_data_single(model, n = 5, param_type = "prior_draw")

# Simulate multiple datasets. This is fastest if
# event probabilities (w) are  provided
w &lt;- get_event_prob(model)
replicate(5, CausalQueries:::make_data_single(model, n = 5, w = w))

</code></pre>

<hr>
<h2 id='make_events'>Make data in compact form</h2><span id='topic+make_events'></span>

<h3>Description</h3>

<p>Draw <code>n</code> events given event probabilities.
Draws full data only. For incomplete data see
<code><a href="#topic+make_data">make_data</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_events(
  model,
  n = 1,
  w = NULL,
  P = NULL,
  A = NULL,
  parameters = NULL,
  param_type = NULL,
  include_strategy = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_events_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="make_events_+3A_n">n</code></td>
<td>
<p>An integer. Number of observations.</p>
</td></tr>
<tr><td><code id="make_events_+3A_w">w</code></td>
<td>
<p>A numeric matrix. A 'n_parameters x 1' matrix of event
probabilities with named rows.</p>
</td></tr>
<tr><td><code id="make_events_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
<tr><td><code id="make_events_+3A_a">A</code></td>
<td>
<p>A <code>data.frame</code>. Ambiguity matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
<tr><td><code id="make_events_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from
<code>model$parameters_df</code>.</p>
</td></tr>
<tr><td><code id="make_events_+3A_param_type">param_type</code></td>
<td>
<p>A character. String specifying type of parameters to make
'flat', 'prior_mean', 'posterior_mean', 'prior_draw', 'posterior_draw',
'define. With param_type set to <code>define</code> use arguments to be passed
to <code>make_priors</code>; otherwise <code>flat</code> sets equal probabilities on
each nodal type in each parameter set; <code>prior_mean</code>,
<code>prior_draw</code>, <code>posterior_mean</code>, <code>posterior_draw</code> take
parameters as the means or as draws from the prior or posterior.</p>
</td></tr>
<tr><td><code id="make_events_+3A_include_strategy">include_strategy</code></td>
<td>
<p>Logical. Whether to include a 'strategy' vector.
Defaults to FALSE. Strategy vector does not vary with full data but
expected by some functions.</p>
</td></tr>
<tr><td><code id="make_events_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to make_priors if
param_type == <code>define</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of events
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; Y')
make_events(model = model)
make_events(model = model, param_type = 'prior_draw')
make_events(model = model, include_strategy = TRUE)


</code></pre>

<hr>
<h2 id='make_model'>Make a model</h2><span id='topic+make_model'></span>

<h3>Description</h3>

<p><code>make_model</code> uses <a href="dagitty.html#topic+dagitty">dagitty</a> syntax and functionality to
specify nodes and edges of a graph. Implied causal types are calculated
and default priors are provided under the assumption of no confounding.
Models can be updated with specification of a parameter matrix, <code>P</code>, by
providing restrictions on causal types, and/or by providing informative
priors on parameters. The default setting for a causal model have flat
(uniform) priors and parameters putting equal weight on each parameter
within each parameter set. These can be adjust with <code>set_priors</code>
and <code>set_parameters</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_model(statement, add_causal_types = TRUE, nodal_types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_model_+3A_statement">statement</code></td>
<td>
<p>A character. Statement describing causal
relations using <a href="dagitty.html#topic+dagitty">dagitty</a> syntax. Only directed relations are
permitted. For instance &quot;X -&gt; Y&quot; or  &quot;X1 -&gt; Y &lt;- X2; X1 -&gt; X2&quot;.</p>
</td></tr>
<tr><td><code id="make_model_+3A_add_causal_types">add_causal_types</code></td>
<td>
<p>Logical. Whether to create and attach causal
types to <code>model</code>. Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="make_model_+3A_nodal_types">nodal_types</code></td>
<td>
<p>List of nodal types associated with model nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>causal_model</code>.
</p>
<p>An object of class <code>"causal_model"</code> is a list containing at least the
following components:
</p>
<table>
<tr><td><code>statement</code></td>
<td>
<p>A character vector of the statement that defines the model</p>
</td></tr>
<tr><td><code>dag</code></td>
<td>
<p>A <code>data.frame</code> with columns 'parent'and 'children'
indicating how nodes relate to each other.</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>A named <code>list</code> with the nodes in the model</p>
</td></tr>
<tr><td><code>parents_df</code></td>
<td>
<p>A <code>data.frame</code> listing nodes, whether they are
root nodes or not, and the number of parents they have</p>
</td></tr>
<tr><td><code>nodal_types</code></td>
<td>
<p>Optional: A named <code>list</code> with the nodal types in
the model. List should be ordered according to the causal ordering of
nodes. If NULL nodal types are generated. If FALSE, a parameters data
frame is not generated.</p>
</td></tr>
<tr><td><code>parameters_df</code></td>
<td>
<p>A <code>data.frame</code> with descriptive information
of the parameters in the model</p>
</td></tr>
<tr><td><code>causal_types</code></td>
<td>
<p>A <code>data.frame</code> listing causal types and the
nodal types that produce them</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>make_model(statement = "X -&gt; Y")
modelXKY &lt;- make_model("X -&gt; K -&gt; Y; X -&gt; Y")

# Example where cyclicaly dag attempted
## Not run: 
 modelXKX &lt;- make_model("X -&gt; K -&gt; X")

## End(Not run)

# Examples with confounding
model &lt;- make_model("X-&gt;Y; X &lt;-&gt; Y")
model$P
model &lt;- make_model("Y2 &lt;- X -&gt; Y1; X &lt;-&gt; Y1; X &lt;-&gt; Y2")
dim(model$P)
model$P
model &lt;- make_model("X1 -&gt; Y &lt;- X2; X1 &lt;-&gt; Y; X2 &lt;-&gt; Y")
dim(model$P)
model$parameters_df

# A single node graph is also possible
model &lt;- make_model("X")

# Unconnected nodes not allowed
## Not run: 
 model &lt;- make_model("X &lt;-&gt; Y")

## End(Not run)

nodal_types &lt;-
  list(
    A = c("0","1"),
    B = c("0","1"),
    C = c("0","1"),
    D = c("0","1"),
    E = c("0","1"),
    Y = c(
      "00000000000000000000000000000000",
      "01010101010101010101010101010101",
      "00110011001100110011001100110011",
      "00001111000011110000111100001111",
      "00000000111111110000000011111111",
      "00000000000000001111111111111111",
      "11111111111111111111111111111111" ))

make_model("A -&gt; Y; B -&gt;Y; C-&gt;Y; D-&gt;Y; E-&gt;Y",
          nodal_types = nodal_types)$parameters_df

nodal_types = list(Y = c("01", "10"), Z = c("0", "1"))
make_model("Z -&gt; Y", nodal_types = nodal_types)$parameters_df
make_model("Z -&gt; Y", nodal_types = FALSE)$parents_df
</code></pre>

<hr>
<h2 id='make_nodal_types'>Make nodal types</h2><span id='topic+make_nodal_types'></span>

<h3>Description</h3>

<p>Make nodal types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_nodal_types(model, include_node_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_nodal_types_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="make_nodal_types_+3A_include_node_names">include_node_names</code></td>
<td>
<p>Logical. If 'TRUE' returns names of form X0, X1;
otherwise returns 0, 1. Defaults to 'FALSE'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing nodal types for each node
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; K -&gt; Y')
CausalQueries:::make_nodal_types(model)

</code></pre>

<hr>
<h2 id='make_par_values'>make_par_values</h2><span id='topic+make_par_values'></span>

<h3>Description</h3>

<p>This is the one step function for make_priors and make_parameters.
See <code>make_priors</code> for more help.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_par_values(
  model,
  alter = "priors",
  x = NA,
  alter_at = NA,
  node = NA,
  label = NA,
  nodal_type = NA,
  param_set = NA,
  given = NA,
  statement = NA,
  join_by = "|",
  param_names = NA,
  distribution = NA,
  normalize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_par_values_+3A_model">model</code></td>
<td>
<p>model created with <code>make_model</code></p>
</td></tr>
<tr><td><code id="make_par_values_+3A_alter">alter</code></td>
<td>
<p>character vector with one of &quot;priors&quot; or &quot;param_value&quot;
specifying what to alter</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_x">x</code></td>
<td>
<p>vector of real non negative values to be substituted into
&quot;priors&quot; or &quot;param_value&quot;</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_alter_at">alter_at</code></td>
<td>
<p>string specifying filtering operations to be applied to
parameters_df, yielding a logical vector indicating parameters for which
values should be altered. (see examples)</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_node">node</code></td>
<td>
<p>string indicating nodes which are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_label">label</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for which
values are to be altered. Equivalent to nodal_type.</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_nodal_type">nodal_type</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_param_set">param_set</code></td>
<td>
<p>string indicating  the name of the set of parameters
to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_given">given</code></td>
<td>
<p>string indicates the node on which the parameter
to be altered depends</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_statement">statement</code></td>
<td>
<p>causal query that determines nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_join_by">join_by</code></td>
<td>
<p>string specifying the logical operator joining expanded
types when <code>statement</code> contains wildcards.
Can take values <code>'&amp;'</code> (logical AND) or <code>'|'</code> (logical OR).</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_param_names">param_names</code></td>
<td>
<p>vector of strings. The name of specific parameter in
the form of, for example, 'X.1', 'Y.01'</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_distribution">distribution</code></td>
<td>
<p>string indicating a common prior distribution
(uniform, jeffreys or certainty)</p>
</td></tr>
<tr><td><code id="make_par_values_+3A_normalize">normalize</code></td>
<td>
<p>logical. If TRUE normalizes such that param
set probabilities sum to 1.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# the below methods can be applied to either priors or
# param_values by specifying the desired option in \code{alter}

model &lt;- CausalQueries::make_model("X -&gt; M -&gt; Y; X &lt;-&gt; Y")

#altering values using \code{alter_at}
CausalQueries:::make_par_values(model = model,
                                x = c(0.5,0.25),
                                alter_at = paste(
                                  "node == 'Y' &amp;",
                                  "nodal_type %in% c('00','01') &amp;",
                                  "given == 'X.0'"))

#altering values using \code{param_names}
CausalQueries:::make_par_values(model = model,
                                x = c(0.5,0.25),
                                param_names = c("Y.10_X.0","Y.10_X.1"))

#altering values using \code{statement}
CausalQueries:::make_par_values(model = model,
                                x = c(0.5,0.25),
                                statement = "Y[M=1] &gt; Y[M=0]")

#altering values using a combination of other arguments
CausalQueries:::make_par_values(model = model,
x = c(0.5,0.25), node = "Y", nodal_type = c("00","01"), given = "X.0")
</code></pre>

<hr>
<h2 id='make_par_values_stops'>make_par_values_stops</h2><span id='topic+make_par_values_stops'></span>

<h3>Description</h3>

<p>helper to remove stops and reduce complexity of make_par_values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_par_values_stops(
  model,
  alter = "priors",
  x = NA,
  alter_at = NA,
  node = NA,
  label = NA,
  nodal_type = NA,
  param_set = NA,
  given = NA,
  statement = NA,
  join_by = "|",
  param_names = NA,
  distribution = NA,
  normalize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_par_values_stops_+3A_model">model</code></td>
<td>
<p>model created with <code>make_model</code></p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_alter">alter</code></td>
<td>
<p>character vector with one of &quot;priors&quot; or &quot;param_value&quot;
specifying what to alter</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_x">x</code></td>
<td>
<p>vector of real non negative values to be substituted into
&quot;priors&quot; or &quot;param_value&quot;</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_alter_at">alter_at</code></td>
<td>
<p>string specifying filtering operations to be applied to
parameters_df, yielding a logical vector indicating parameters for which
values should be altered. (see examples)</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_node">node</code></td>
<td>
<p>string indicating nodes which are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_label">label</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for which
values are to be altered. Equivalent to nodal_type.</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_nodal_type">nodal_type</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_param_set">param_set</code></td>
<td>
<p>string indicating  the name of the set of parameters
to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_given">given</code></td>
<td>
<p>string indicates the node on which the parameter
to be altered depends</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_statement">statement</code></td>
<td>
<p>causal query that determines nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_join_by">join_by</code></td>
<td>
<p>string specifying the logical operator joining expanded
types when <code>statement</code> contains wildcards.
Can take values <code>'&amp;'</code> (logical AND) or <code>'|'</code> (logical OR).</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_param_names">param_names</code></td>
<td>
<p>vector of strings. The name of specific parameter in
the form of, for example, 'X.1', 'Y.01'</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_distribution">distribution</code></td>
<td>
<p>string indicating a common prior distribution
(uniform, jeffreys or certainty)</p>
</td></tr>
<tr><td><code id="make_par_values_stops_+3A_normalize">normalize</code></td>
<td>
<p>logical. If TRUE normalizes such that param
set probabilities sum to 1.</p>
</td></tr>
</table>

<hr>
<h2 id='make_parameter_matrix'>Make parameter matrix</h2><span id='topic+make_parameter_matrix'></span>

<h3>Description</h3>

<p>Calculate parameter matrix assuming no confounding. The parameter matrix
maps from parameters into causal types. In models without confounding
parameters correspond to nodal types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_parameter_matrix(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_parameter_matrix_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, the parameter matrix, mapping from parameters
to causal types
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; Y')
make_parameter_matrix(model)
</code></pre>

<hr>
<h2 id='make_parameters_df'>function to make a parameters_df from nodal types</h2><span id='topic+make_parameters_df'></span>

<h3>Description</h3>

<p>function to make a parameters_df from nodal types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_parameters_df(nodal_types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_parameters_df_+3A_nodal_types">nodal_types</code></td>
<td>
<p>a list of nodal types</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
make_parameters_df(list(X = "1", Y = c("01", "10")))
</code></pre>

<hr>
<h2 id='make_parmap'>Make parmap: a matrix mapping from parameters to data types</h2><span id='topic+make_parmap'></span>

<h3>Description</h3>

<p>Generates a matrix with a row per parameter and a column per data type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_parmap(model, A = NULL, P = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_parmap_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="make_parmap_+3A_a">A</code></td>
<td>
<p>A <code>data.frame</code>. Ambiguity matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
<tr><td><code id="make_parmap_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_parmap(model = make_model('X-&gt;Y'))
make_parmap(model = make_model('X-&gt;Y; X&lt;-&gt;Y'))
make_parmap(model = make_model('X-&gt;Y; X&lt;-&gt;Y')) |&gt; attr("map")
make_parmap(model = make_model('X -&gt; M -&gt; Y; X &lt;-&gt; Y'))
make_parmap(model = make_model('X -&gt; M -&gt; Y; M &lt;-&gt; Y'))
model &lt;- make_model('X -&gt; M -&gt; Y; M &lt;-&gt; Y; X &lt;-&gt; M')
make_parmap(model)
make_parmap(model) |&gt; attr("map")
# Any ways (without paths splits)
make_parmap(model) %*% (make_parmap(model) |&gt; attr("map"))

## Not run: 
# X1 and X2 are confounded and jointly determine Y1, Y2.
# For instance for models in which X and Y take on four values rather than 2.
model &lt;- make_model("Y2 &lt;- X1 -&gt; Y1; Y2 &lt;- X2 -&gt;Y1; X1 &lt;-&gt; X2; Y1 &lt;-&gt; Y2")
parmap &lt;- make_parmap(model)
parmap |&gt; dim()

CausalQueries:::prep_stan_data(
  model,
  CausalQueries:::minimal_event_data(model))$n_params

## End(Not run)
</code></pre>

<hr>
<h2 id='make_prior_distribution'>Make a prior distribution from priors</h2><span id='topic+make_prior_distribution'></span>

<h3>Description</h3>

<p>Create a 'n_param'x 'n_draws' database of possible lambda draws to be
attached to the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_prior_distribution(model, n_draws = 4000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_prior_distribution_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="make_prior_distribution_+3A_n_draws">n_draws</code></td>
<td>
<p>A scalar. Number of draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.frame' with dimension 'n_param'x 'n_draws' of possible
lambda draws
</p>


<h3>See Also</h3>

<p>Other prior_distribution: 
<code><a href="#topic+get_prior_distribution">get_prior_distribution</a>()</code>,
<code><a href="#topic+set_prior_distribution">set_prior_distribution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_model('X -&gt; Y') %&gt;% make_prior_distribution(n_draws = 5)

</code></pre>

<hr>
<h2 id='minimal_data'>Creates a data frame for case with no data</h2><span id='topic+minimal_data'></span>

<h3>Description</h3>

<p>Creates a data frame for case with no data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimal_data(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimal_data_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row of NAs and columns named according
to nodes in a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; K -&gt; Y')
CausalQueries:::minimal_data(model)

</code></pre>

<hr>
<h2 id='minimal_event_data'>Creates a compact data frame for case with no data</h2><span id='topic+minimal_event_data'></span>

<h3>Description</h3>

<p>Creates a compact data frame for case with no data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimal_event_data(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimal_event_data_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A compact data frame where each row represents an element from the
exhaustive set of events of a model. The count for each event is
set to zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; K -&gt; Y')
CausalQueries:::minimal_event_data(model)

</code></pre>

<hr>
<h2 id='n_check'>n_check</h2><span id='topic+n_check'></span>

<h3>Description</h3>

<p>n_check
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_check(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_check_+3A_n">n</code></td>
<td>
<p>An integer. Sample size argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks whether the input is an integer greater than 0.
</p>


<h3>Value</h3>

<p>An error message if <code>n</code> is not an integer or is less than 0.
</p>

<hr>
<h2 id='nodes_in_statement'>Identify nodes in a statement</h2><span id='topic+nodes_in_statement'></span>

<h3>Description</h3>

<p>Identify nodes in a statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodes_in_statement(nodes, statement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes_in_statement_+3A_nodes">nodes</code></td>
<td>
<p>A vector of characters. It should contain quoted names of
the nodes in <code>model</code></p>
</td></tr>
<tr><td><code id="nodes_in_statement_+3A_statement">statement</code></td>
<td>
<p>A character. A quoted causal statement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns name of nodes present in a statement
</p>

<hr>
<h2 id='non_decreasing'>Make monotonicity statement (non negative)</h2><span id='topic+non_decreasing'></span>

<h3>Description</h3>

<p>Generate a statement for Y weakly monotonic (increasing) in X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>non_decreasing(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="non_decreasing_+3A_x">X</code></td>
<td>
<p>A character. The quoted name of the input node</p>
</td></tr>
<tr><td><code id="non_decreasing_+3A_y">Y</code></td>
<td>
<p>A character. The quoted name of the outcome node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character statement of class <code>statement</code>
</p>


<h3>See Also</h3>

<p>Other statements: 
<code><a href="#topic+complements">complements</a>()</code>,
<code><a href="#topic+decreasing">decreasing</a>()</code>,
<code><a href="#topic+increasing">increasing</a>()</code>,
<code><a href="#topic+interacts">interacts</a>()</code>,
<code><a href="#topic+non_increasing">non_increasing</a>()</code>,
<code><a href="#topic+substitutes">substitutes</a>()</code>,
<code><a href="#topic+te">te</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
non_decreasing('A', 'B')

</code></pre>

<hr>
<h2 id='non_increasing'>Make monotonicity statement (non positive)</h2><span id='topic+non_increasing'></span>

<h3>Description</h3>

<p>Generate a statement for Y weakly monotonic (not increasing) in X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>non_increasing(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="non_increasing_+3A_x">X</code></td>
<td>
<p>A character. The quoted name of the input node</p>
</td></tr>
<tr><td><code id="non_increasing_+3A_y">Y</code></td>
<td>
<p>A character. The quoted name of the outcome node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character statement of class <code>statement</code>
</p>


<h3>See Also</h3>

<p>Other statements: 
<code><a href="#topic+complements">complements</a>()</code>,
<code><a href="#topic+decreasing">decreasing</a>()</code>,
<code><a href="#topic+increasing">increasing</a>()</code>,
<code><a href="#topic+interacts">interacts</a>()</code>,
<code><a href="#topic+non_decreasing">non_decreasing</a>()</code>,
<code><a href="#topic+substitutes">substitutes</a>()</code>,
<code><a href="#topic+te">te</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
non_increasing('A', 'B')

</code></pre>

<hr>
<h2 id='observe_data'>Observe data, given a strategy</h2><span id='topic+observe_data'></span>

<h3>Description</h3>

<p>Observe data, given a strategy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observe_data(
  complete_data,
  observed = NULL,
  nodes_to_observe = NULL,
  prob = 1,
  m = NULL,
  subset = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="observe_data_+3A_complete_data">complete_data</code></td>
<td>
<p>A <code>data.frame</code>. Data observed and unobserved.</p>
</td></tr>
<tr><td><code id="observe_data_+3A_observed">observed</code></td>
<td>
<p>A <code>data.frame</code>. Data observed.</p>
</td></tr>
<tr><td><code id="observe_data_+3A_nodes_to_observe">nodes_to_observe</code></td>
<td>
<p>A list. Nodes to observe.</p>
</td></tr>
<tr><td><code id="observe_data_+3A_prob">prob</code></td>
<td>
<p>A scalar. Observation probability.</p>
</td></tr>
<tr><td><code id="observe_data_+3A_m">m</code></td>
<td>
<p>A integer. Number of units to observe; if specified, <code>m</code>
overrides <code>prob</code>.</p>
</td></tr>
<tr><td><code id="observe_data_+3A_subset">subset</code></td>
<td>
<p>A character.  Logical statement that can be applied to rows
of complete data. For instance observation for some nodes might depend on
observed values of other nodes; or observation may only be sought if
data not already observed!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with logical values indicating which nodes
to observe in each row of 'complete_data'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model("X -&gt; Y")
df &lt;- make_data(model, n = 8)
# Observe X values only
observe_data(complete_data = df, nodes_to_observe = "X")
# Observe half the Y values for cases with observed X = 1
observe_data(complete_data = df,
     observed = observe_data(complete_data = df, nodes_to_observe = "X"),
     nodes_to_observe = "Y", prob = .5,
     subset = "X==1")
</code></pre>

<hr>
<h2 id='parameter_setting'>Setting parameters</h2><span id='topic+parameter_setting'></span><span id='topic+make_parameters'></span><span id='topic+set_parameters'></span><span id='topic+get_parameters'></span>

<h3>Description</h3>

<p>Functionality for altering parameters:
</p>
<p>A vector of 'true' parameters; possibly drawn from prior or posterior.
</p>
<p>Add a true parameter vector to a model. Parameters can be created using
arguments passed to <code><a href="#topic+make_parameters">make_parameters</a></code> and
<code><a href="#topic+make_priors">make_priors</a></code>.
</p>
<p>Extracts parameters as a named vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_parameters(
  model,
  parameters = NULL,
  param_type = NULL,
  warning = TRUE,
  normalize = TRUE,
  ...
)

set_parameters(
  model,
  parameters = NULL,
  param_type = NULL,
  warning = FALSE,
  ...
)

get_parameters(model, param_type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameter_setting_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="parameter_setting_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from
<code>model$parameters_df</code>.</p>
</td></tr>
<tr><td><code id="parameter_setting_+3A_param_type">param_type</code></td>
<td>
<p>A character. String specifying type of parameters to make
&quot;flat&quot;, &quot;prior_mean&quot;, &quot;posterior_mean&quot;, &quot;prior_draw&quot;,
&quot;posterior_draw&quot;, &quot;define. With param_type set to <code>define</code> use
arguments to be passed to <code>make_priors</code>; otherwise <code>flat</code> sets
equal probabilities on each nodal type in each parameter set;
<code>prior_mean</code>, <code>prior_draw</code>, <code>posterior_mean</code>,
<code>posterior_draw</code> take parameters as the means or as draws
from the prior or posterior.</p>
</td></tr>
<tr><td><code id="parameter_setting_+3A_warning">warning</code></td>
<td>
<p>Logical. Whether to warn about parameter renormalization.</p>
</td></tr>
<tr><td><code id="parameter_setting_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If parameter given for a subset of a family the
residual elements are normalized so that parameters in param_set sum
to 1 and provided params are unaltered.</p>
</td></tr>
<tr><td><code id="parameter_setting_+3A_...">...</code></td>
<td>
<p>Options passed onto <code><a href="#topic+make_priors">make_priors</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of draws from the prior or distribution of parameters
</p>
<p>An object of class <code>causal_model</code>. It essentially returns a
list containing the elements comprising a model
(e.g. 'statement', 'nodal_types' and 'DAG') with true vector of
parameters attached to it.
</p>
<p>A vector of draws from the prior or distribution of parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# make_parameters examples:

# Simple examples
model &lt;- make_model('X -&gt; Y')
data  &lt;- make_data(model, n = 2)
model &lt;- update_model(model, data)
make_parameters(model, parameters = c(.25, .75, 1.25,.25, .25, .25))
make_parameters(model, param_type = 'flat')
make_parameters(model, param_type = 'prior_draw')
make_parameters(model, param_type = 'prior_mean')
make_parameters(model, param_type = 'posterior_draw')
make_parameters(model, param_type = 'posterior_mean')




#altering values using \code{alter_at}
make_model("X -&gt; Y") %&gt;% make_parameters(parameters = c(0.5,0.25),
alter_at = "node == 'Y' &amp; nodal_type %in% c('00','01')")

#altering values using \code{param_names}
make_model("X -&gt; Y") %&gt;% make_parameters(parameters = c(0.5,0.25),
param_names = c("Y.10","Y.01"))

#altering values using \code{statement}
make_model("X -&gt; Y") %&gt;% make_parameters(parameters = c(0.5),
statement = "Y[X=1] &gt; Y[X=0]")

#altering values using a combination of other arguments
make_model("X -&gt; Y") %&gt;% make_parameters(parameters = c(0.5,0.25),
node = "Y", nodal_type = c("00","01"))

# Normalize renormalizes values not set so that value set is not renomalized
make_parameters(make_model('X -&gt; Y'),
               statement = 'Y[X=1]&gt;Y[X=0]', parameters = .5)
make_parameters(make_model('X -&gt; Y'),
               statement = 'Y[X=1]&gt;Y[X=0]', parameters = .5,
               normalize = FALSE)

  

# set_parameters examples:

make_model('X-&gt;Y') %&gt;% set_parameters(1:6) %&gt;% get_parameters()

# Simple examples
model &lt;- make_model('X -&gt; Y')
data  &lt;- make_data(model, n = 2)
model &lt;- update_model(model, data)
set_parameters(model, parameters = c(.25, .75, 1.25,.25, .25, .25))
set_parameters(model, param_type = 'flat')
set_parameters(model, param_type = 'prior_draw')
set_parameters(model, param_type = 'prior_mean')
set_parameters(model, param_type = 'posterior_draw')
set_parameters(model, param_type = 'posterior_mean')




#altering values using \code{alter_at}
make_model("X -&gt; Y") %&gt;% set_parameters(parameters = c(0.5,0.25),
alter_at = "node == 'Y' &amp; nodal_type %in% c('00','01')")

#altering values using \code{param_names}
make_model("X -&gt; Y") %&gt;% set_parameters(parameters = c(0.5,0.25),
param_names = c("Y.10","Y.01"))

#altering values using \code{statement}
make_model("X -&gt; Y") %&gt;% set_parameters(parameters = c(0.5),
statement = "Y[X=1] &gt; Y[X=0]")

#altering values using a combination of other arguments
make_model("X -&gt; Y") %&gt;% set_parameters(parameters = c(0.5,0.25),
node = "Y", nodal_type = c("00","01"))


  

# get_parameters examples:

make_model('X -&gt; Y') |&gt; get_parameters()
</code></pre>

<hr>
<h2 id='parents_to_int'>Helper to turn parents_list into a list of data_realizations column positions</h2><span id='topic+parents_to_int'></span>

<h3>Description</h3>

<p>Helper to turn parents_list into a list of data_realizations column positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parents_to_int(parents_list, position_set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parents_to_int_+3A_parents_list">parents_list</code></td>
<td>
<p>a named list of character vectors specifying all
nodes in the DAG and their respective parents</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of column positions
</p>

<hr>
<h2 id='perm'>Produces the possible permutations of a set of nodes</h2><span id='topic+perm'></span>

<h3>Description</h3>

<p>Produces the possible permutations of a set of nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm(max = rep(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perm_+3A_max">max</code></td>
<td>
<p>A vector of integers. The maximum value of an integer value
starting at 0. Defaults to 1. The number of permutation is defined
by <code>max</code>'s length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of permutations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CausalQueries:::perm(3)

</code></pre>

<hr>
<h2 id='plot_dag'>Plots a DAG in ggplot style using a causal model input</h2><span id='topic+plot_dag'></span>

<h3>Description</h3>

<p>If confounds are indicated (provided in <code>attr(model$P, 'confounds')</code>),
then these are represented as bidirectional arcs. Builds on functionality
from ggdag and dagitty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dag(
  model = NULL,
  x_coord = NULL,
  y_coord = NULL,
  title = "",
  textcol = "white",
  textsize = 3.88,
  shape = 16,
  nodecol = "black",
  nodesize = 16
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dag_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code> object generated from <code>make_model</code></p>
</td></tr>
<tr><td><code id="plot_dag_+3A_x_coord">x_coord</code></td>
<td>
<p>A vector of x coordinates for DAG nodes.
If left empty, coordinates are randomly generated</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_y_coord">y_coord</code></td>
<td>
<p>A vector of y coordinates for DAG nodes.
If left empty, coordinates are randomly generated</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_title">title</code></td>
<td>
<p>String specifying title of graph</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_textcol">textcol</code></td>
<td>
<p>String specifying color of text labels</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_textsize">textsize</code></td>
<td>
<p>Numeric, size of text labels</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_shape">shape</code></td>
<td>
<p>Indicates shape of node. Defaults to circular node.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_nodecol">nodecol</code></td>
<td>
<p>String indicating color of node that is accepted by
ggplot's default palette</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_nodesize">nodesize</code></td>
<td>
<p>Size of node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DAG plot in ggplot style.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
model &lt;- make_model('X -&gt; K -&gt; Y; X &lt;-&gt; Y')

model |&gt;
  CausalQueries:::plot_dag()
model |&gt;
  CausalQueries:::plot_dag(
    x_coord = 1:3,
    y_coord = 1:3,
    title = "Mixed text and math: $\\alpha^2 + \\Gamma$")

## End(Not run)

</code></pre>

<hr>
<h2 id='prep_stan_data'>Prepare data for 'stan'</h2><span id='topic+prep_stan_data'></span>

<h3>Description</h3>

<p>Create a list containing the data to be passed to 'stan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_stan_data(model, data, keep_transformed = TRUE, censored_types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_stan_data_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="prep_stan_data_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.  Data of nodes that can take three values:
0, 1, and NA. In long form as generated by <code><a href="#topic+make_events">make_events</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing data to be passed to 'stan'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X-&gt;Y')
data  &lt;-  collapse_data(make_data(model, n = 6), model)
CausalQueries:::prep_stan_data(model, data)

model &lt;- make_model('X-&gt;Y') |&gt;
  set_confound(list(X = 'Y[X=1]&gt;Y[X=0]'))
data  &lt;-  collapse_data(make_data(model, n = 6), model)
CausalQueries:::prep_stan_data(model, data)


</code></pre>

<hr>
<h2 id='prior_setting'>Setting priors</h2><span id='topic+prior_setting'></span><span id='topic+make_priors'></span><span id='topic+set_priors'></span><span id='topic+get_priors'></span>

<h3>Description</h3>

<p>Functionality for altering priors:
</p>
<p><code>make_priors</code> Generates priors for a model.
</p>
<p><code>set_priors</code>  Adds priors to a model.
</p>
<p>Extracts priors as a named vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_priors(
  model,
  alphas = NA,
  distribution = NA,
  alter_at = NA,
  node = NA,
  nodal_type = NA,
  label = NA,
  param_set = NA,
  given = NA,
  statement = NA,
  join_by = "|",
  param_names = NA
)

set_priors(
  model,
  alphas = NA,
  distribution = NA,
  alter_at = NA,
  node = NA,
  nodal_type = NA,
  label = NA,
  param_set = NA,
  given = NA,
  statement = NA,
  join_by = "|",
  param_names = NA
)

get_priors(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_setting_+3A_model">model</code></td>
<td>
<p>A model object generated by make_model().</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_alphas">alphas</code></td>
<td>
<p>Real positive numbers giving hyperparameters of
the Dirichlet distribution</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_distribution">distribution</code></td>
<td>
<p>string indicating a common prior distribution
(uniform, jeffreys or certainty)</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_alter_at">alter_at</code></td>
<td>
<p>string specifying filtering operations to be applied to
parameters_df, yielding a logical vector indicating parameters for which
values should be altered. (see examples)</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_node">node</code></td>
<td>
<p>string indicating nodes which are to be altered</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_nodal_type">nodal_type</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_label">label</code></td>
<td>
<p>string. Label for nodal type indicating nodal types for which
values are to be altered. Equivalent to nodal_type.</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_param_set">param_set</code></td>
<td>
<p>string indicating  the name of the set of parameters
to be altered</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_given">given</code></td>
<td>
<p>string indicates the node on which the parameter
to be altered depends</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_statement">statement</code></td>
<td>
<p>causal query that determines nodal types for
which values are to be altered</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_join_by">join_by</code></td>
<td>
<p>string specifying the logical operator joining expanded
types when <code>statement</code> contains wildcards.
Can take values <code>'&amp;'</code> (logical AND) or <code>'|'</code> (logical OR).</p>
</td></tr>
<tr><td><code id="prior_setting_+3A_param_names">param_names</code></td>
<td>
<p>vector of strings. The name of specific parameter in
the form of, for example, 'X.1', 'Y.01'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Seven arguments govern which parameters should be altered. The default is
'all' but this can be reduced by specifying
</p>
<p>* <code>alter_at</code> String specifying filtering operations to be applied to
parameters_df, yielding a logical vector indicating parameters for which
values should be altered. &quot;node == 'X' &amp; nodal_type 
</p>
<p>* <code>node</code>, which restricts for example to parameters associated with node
'X'
</p>
<p>* <code>label</code> or <code>nodal_type</code> The label of a particular nodal type,
written either in the form Y0000 or Y.Y0000
</p>
<p>* <code>param_set</code> The param_set of a parameter.
</p>
<p>* <code>given</code> Given parameter set of a parameter.
</p>
<p>* <code>statement</code>, which restricts for example to nodal types that satisfy
the statement 'Y[X=1] &gt; Y[X=0]'
</p>
<p>* <code>param_set</code>, <code>given</code>, which are useful when setting confound
statements that produce several sets of parameters
</p>
<p>Two arguments govern what values to apply:
</p>
<p>* <code>alphas</code> is one or more non-negative numbers and
</p>
<p>* <code>distribution</code> indicates one of a common class: uniform, Jeffreys, or
'certain'
</p>
<p>Forbidden statements include:
</p>

<ul>
<li><p> Setting <code>distribution</code> and <code>values</code> at the same time.
</p>
</li>
<li><p> Setting a <code>distribution</code> other than uniform, Jeffreys, or
certainty.
</p>
</li>
<li><p> Setting negative values.
</p>
</li>
<li><p> specifying <code>alter_at</code> with any of <code>node</code>,
<code>nodal_type</code>, <code>param_set</code>, <code>given</code>, <code>statement</code>, or
<code>param_names</code>
</p>
</li>
<li><p> specifying <code>param_names</code> with any of <code>node</code>,
<code>nodal_type</code>, <code>param_set</code>, <code>given</code>, <code>statement</code>, or
<code>alter_at</code>
</p>
</li>
<li><p> specifying <code>statement</code> with any of <code>node</code> or
<code>nodal_type</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A vector indicating the parameters of the prior distribution
of the nodal types (&quot;hyperparameters&quot;).
</p>
<p>An object of class <code>causal_model</code>. It essentially returns a
list containing the elements comprising a model
(e.g. 'statement', 'nodal_types' and 'DAG') with the 'priors' attached
to it.
</p>
<p>A vector indicating the hyperparameters of the prior distribution
of the nodal types.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# make_priors examples:

# Pass all nodal types
model &lt;- make_model("Y &lt;- X")
make_priors(model, alphas = .4)
make_priors(model, distribution = "jeffreys")

model &lt;- CausalQueries::make_model("X -&gt; M -&gt; Y; X &lt;-&gt; Y")

#altering values using \code{alter_at}
make_priors(model = model, alphas = c(0.5,0.25),
alter_at = "node == 'Y' &amp; nodal_type %in% c('00','01') &amp; given == 'X.0'")

#altering values using \code{param_names}
make_priors(model = model, alphas = c(0.5,0.25),
param_names = c("Y.10_X.0","Y.10_X.1"))

#altering values using \code{statement}
make_priors(model = model, alphas = c(0.5,0.25),
statement = "Y[M=1] &gt; Y[M=0]")

#altering values using a combination of other arguments
make_priors(model = model, alphas = c(0.5,0.25),
node = "Y", nodal_type = c("00","01"), given = "X.0")

# set_priors examples:

# Pass all nodal types
model &lt;- make_model("Y &lt;- X")
set_priors(model, alphas = .4)
set_priors(model, distribution = "jeffreys")

model &lt;- CausalQueries::make_model("X -&gt; M -&gt; Y; X &lt;-&gt; Y")

#altering values using \code{alter_at}
set_priors(model = model, alphas = c(0.5,0.25),
alter_at = "node == 'Y' &amp; nodal_type %in% c('00','01') &amp; given == 'X.0'")

#altering values using \code{param_names}
set_priors(model = model, alphas = c(0.5,0.25),
param_names = c("Y.10_X.0","Y.10_X.1"))

#altering values using \code{statement}
set_priors(model = model, alphas = c(0.5,0.25),
statement = "Y[M=1] &gt; Y[M=0]")

#altering values using a combination of other arguments
set_priors(model = model, alphas = c(0.5,0.25), node = "Y",
nodal_type = c("00","01"), given = "X.0")

# get_priors examples:

get_priors(make_model('X -&gt; Y'))
</code></pre>

<hr>
<h2 id='queries_to_types'>helper to get types from queries</h2><span id='topic+queries_to_types'></span>

<h3>Description</h3>

<p>helper to get types from queries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queries_to_types(jobs, model, query_col, realisations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="queries_to_types_+3A_jobs">jobs</code></td>
<td>
<p><code>DataFrame</code> of argument combinations</p>
</td></tr>
<tr><td><code id="queries_to_types_+3A_model">model</code></td>
<td>
<p>a list of models</p>
</td></tr>
<tr><td><code id="queries_to_types_+3A_query_col">query_col</code></td>
<td>
<p>string specifying the name of the column in jobs
holding queries to be evaluated</p>
</td></tr>
<tr><td><code id="queries_to_types_+3A_realisations">realisations</code></td>
<td>
<p>list of <code>DataFrame</code> outputs from calls
to <code>realise_outcomes</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>jobs <code>DataFrame</code> with a nested column of
<code>map_query_to_nodal_type</code> outputs
</p>

<hr>
<h2 id='query_distribution'>Calculate query distribution</h2><span id='topic+query_distribution'></span>

<h3>Description</h3>

<p>Calculated distribution of a query from a prior or
posterior distribution of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_distribution(
  model,
  queries,
  given = NULL,
  using = "parameters",
  parameters = NULL,
  n_draws = 4000,
  join_by = "|",
  case_level = FALSE,
  query = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_distribution_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_queries">queries</code></td>
<td>
<p>A character vector or list of character vectors specifying
queries on potential outcomes such as &quot;Y[X=1] - Y[X=0]&quot;</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_given">given</code></td>
<td>
<p>A character vector specifying givens for each query.
A given is a quoted expression that evaluates to logical statement.
<code>given</code> allows the query to be conditioned on *observational*
distribution. A value of TRUE is interpreted as no conditioning.</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_using">using</code></td>
<td>
<p>A character. Whether to use priors, posteriors or parameters</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_parameters">parameters</code></td>
<td>
<p>A vector or list of vectors of real numbers in [0,1].
A true parameter vector to be used instead of parameters attached to
the model in case  <code>using</code> specifies <code>parameters</code></p>
</td></tr>
<tr><td><code id="query_distribution_+3A_n_draws">n_draws</code></td>
<td>
<p>An integer. Number of draws.rm</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_join_by">join_by</code></td>
<td>
<p>A character. The logical operator joining expanded types
when <code>query</code> contains wildcard (<code>.</code>). Can take values
<code>"&amp;"</code> (logical AND) or <code>"|"</code> (logical OR). When restriction
contains wildcard (<code>.</code>) and <code>join_by</code> is not specified, it
defaults to <code>"|"</code>, otherwise it defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_case_level">case_level</code></td>
<td>
<p>Logical. If TRUE estimates the probability of
the query for a case.</p>
</td></tr>
<tr><td><code id="query_distribution_+3A_query">query</code></td>
<td>
<p>alias for queries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>DataFrame</code> where columns contain draws from the distribution
of the potential outcomes specified in <code>query</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model("X -&gt; Y") %&gt;%
         set_parameters(c(.5, .5, .1, .2, .3, .4))
 
 # simple  queries
 query_distribution(model, query = "(Y[X=1] &gt; Y[X=0])",
                    using = "priors") |&gt;
   head()

 # multiple  queries
 query_distribution(model,
     query = list("(Y[X=1] &gt; Y[X=0])",
                  "(Y[X=1] &lt; Y[X=0])"),
     using = "priors")|&gt;
   head()

 # multiple queries and givens
 query_distribution(model,
   query = list("(Y[X=1] &gt; Y[X=0])", "(Y[X=1] &lt; Y[X=0])"),
   given = list("Y==1", "(Y[X=1] &lt;= Y[X=0])"),
   using = "priors")|&gt;
   head()

 # linear queries
 query_distribution(model, query = "(Y[X=1] - Y[X=0])")

 # queries conditional on observables
 query_distribution(model, query = "(Y[X=1] &gt; Y[X=0])",
                    given = "X==1 &amp; Y ==1")

 # Linear query conditional on potential outcomes
 query_distribution(model, query = "(Y[X=1] - Y[X=0])",
                    given = "Y[X=1]==0")

 # Use join_by to amend query interpretation
 query_distribution(model, query = "(Y[X=.] == 1)", join_by = "&amp;")

 # Probability of causation query
 query_distribution(model,
    query = "(Y[X=1] &gt; Y[X=0])",
    given = "X==1 &amp; Y==1",
    using = "priors")  |&gt; head()

 # Case level probability of causation query
 query_distribution(model,
    query = "(Y[X=1] &gt; Y[X=0])",
    given = "X==1 &amp; Y==1",
    case_level = TRUE,
    using = "priors")

 # Query posterior
 update_model(model, make_data(model, n = 3)) |&gt;
 query_distribution(query = "(Y[X=1] - Y[X=0])", using = "posteriors") |&gt;
 head()

 # Case level queries provide the inference for a case, which is a scalar
 # The case level query *updates* on the given information
 # For instance, here we have a model for which we are quite sure that X
 # causes Y but we do not know whether it works through two positive effects
 # or two negative effects. Thus we do not know if M=0 would suggest an
 # effect or no effect

 set.seed(1)
 model &lt;-
   make_model("X -&gt; M -&gt; Y") |&gt;
   update_model(data.frame(X = rep(0:1, 8), Y = rep(0:1, 8)), iter = 10000)

 Q &lt;- "Y[X=1] &gt; Y[X=0]"
 G &lt;- "X==1 &amp; Y==1 &amp; M==1"
 QG &lt;- "(Y[X=1] &gt; Y[X=0]) &amp; (X==1 &amp; Y==1 &amp; M==1)"

 # In this case these are very different:
 query_distribution(model, Q, given = G, using = "posteriors")[[1]] |&gt; mean()
 query_distribution(model, Q, given = G, using = "posteriors",
   case_level = TRUE)

 # These are equivalent:
 # 1. Case level query via function
 query_distribution(model, Q, given = G,
    using = "posteriors", case_level = TRUE)

 # 2. Case level query by hand using Bayes
 distribution &lt;- query_distribution(
    model, list(QG = QG, G = G), using = "posteriors")

 mean(distribution$QG)/mean(distribution$G)


</code></pre>

<hr>
<h2 id='query_model'>Generate estimands dataframe</h2><span id='topic+query_model'></span>

<h3>Description</h3>

<p>Calculated from a parameter vector, from a prior or
from a posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_model(
  model,
  queries = NULL,
  given = NULL,
  using = list("parameters"),
  parameters = NULL,
  stats = NULL,
  n_draws = 4000,
  expand_grid = FALSE,
  case_level = FALSE,
  query = NULL,
  cred = 95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_model_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="query_model_+3A_queries">queries</code></td>
<td>
<p>A vector of strings or list of strings specifying queries
on potential outcomes such as &quot;Y[X=1] - Y[X=0]&quot;.</p>
</td></tr>
<tr><td><code id="query_model_+3A_given">given</code></td>
<td>
<p>A vector or list of strings specifying givens. A given is
a quoted expression that evaluates to a logical statement. Allows estimand
to be conditioned on *observational* (or counterfactual) distribution.</p>
</td></tr>
<tr><td><code id="query_model_+3A_using">using</code></td>
<td>
<p>A vector or list of strings. Whether to use priors,
posteriors or parameters.</p>
</td></tr>
<tr><td><code id="query_model_+3A_parameters">parameters</code></td>
<td>
<p>A vector of real numbers in [0,1]. Values of parameters to
specify (optional). By default, parameters is drawn from
<code>model$parameters_df</code>.</p>
</td></tr>
<tr><td><code id="query_model_+3A_stats">stats</code></td>
<td>
<p>Functions to be applied to estimand distribution.
If NULL, defaults to mean, standard deviation,
and 95% confidence interval. Functions should return a single numeric
value.</p>
</td></tr>
<tr><td><code id="query_model_+3A_n_draws">n_draws</code></td>
<td>
<p>An integer. Number of draws.</p>
</td></tr>
<tr><td><code id="query_model_+3A_expand_grid">expand_grid</code></td>
<td>
<p>Logical. If <code>TRUE</code> then all combinations of
provided lists are examined. If not then each list is cycled through
separately. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="query_model_+3A_case_level">case_level</code></td>
<td>
<p>Logical. If TRUE estimates the probability of the
query for a case.</p>
</td></tr>
<tr><td><code id="query_model_+3A_query">query</code></td>
<td>
<p>alias for queries</p>
</td></tr>
<tr><td><code id="query_model_+3A_cred">cred</code></td>
<td>
<p>size of the credible interval ranging between 0 and 100</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Queries can condition on observed or counterfactual quantities.
Nested or &quot;complex&quot; counterfactual queries of the form
<code>Y[X=1, M[X=0]]</code> are allowed.
</p>


<h3>Value</h3>

<p>A <code>DataFrame</code> with columns Model, Query, Given and Using
defined by corresponding input values. Further columns are generated
as specified in <code>stats</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model("X -&gt; Y") %&gt;% set_prior_distribution(n_draws = 10000)



# `expand_grid= TRUE` requests the Cartesian product of arguments

models &lt;- list(
 M1 = make_model("X -&gt; Y"),
 M2 = make_model("X -&gt; Y") |&gt; set_restrictions("Y[X=1] &lt; Y[X=0]")
 )


query_model(
  models,
  query = list(ATE = "Y[X=1] - Y[X=0]",
               Share_positive = "Y[X=1] &gt; Y[X=0]"),
  given = c(TRUE,  "Y==1 &amp; X==1"),
  using = c("parameters", "priors"),
  expand_grid = FALSE)

query_model(
  models,
  query = list(ATE = "Y[X=1] - Y[X=0]",
               Share_positive = "Y[X=1] &gt; Y[X=0]"),
  given = c(TRUE,  "Y==1 &amp; X==1"),
  using = c("parameters", "priors"),
  expand_grid = TRUE)

# An example of a custom statistic: uncertainty of token causation
f &lt;- function(x) mean(x)*(1-mean(x))

query_model(
  model,
  using = list( "parameters", "priors"),
  query = "Y[X=1] &gt; Y[X=0]",
  stats = c(mean = mean, sd = sd, token_variance = f))

</code></pre>

<hr>
<h2 id='query_to_expression'>Helper to turn query into a data expression</h2><span id='topic+query_to_expression'></span>

<h3>Description</h3>

<p>Helper to turn query into a data expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_to_expression(query, node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_to_expression_+3A_query">query</code></td>
<td>
<p>A character string. An expression defining nodal types to
interrogate <code><a href="#topic+realise_outcomes">realise_outcomes</a></code>. An expression of the form
&quot;Y[X=1]&quot; asks for the value of Y when X is set to 1</p>
</td></tr>
<tr><td><code id="query_to_expression_+3A_node">node</code></td>
<td>
<p>A character string. The quoted name of a node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cleaned query expression
</p>

<hr>
<h2 id='realise_outcomes'>Realise outcomes</h2><span id='topic+realise_outcomes'></span>

<h3>Description</h3>

<p>Realise outcomes for all causal types. Calculated by sequentially
calculating endogenous nodes. If a do operator is applied to any node then
it takes the given value and all its descendants are generated accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>realise_outcomes(model, dos = NULL, node = NULL, add_rownames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="realise_outcomes_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="realise_outcomes_+3A_dos">dos</code></td>
<td>
<p>A named <code>list</code>. Do actions defining node values,
e.g., <code>list(X = 0, M = 1)</code>.</p>
</td></tr>
<tr><td><code id="realise_outcomes_+3A_node">node</code></td>
<td>
<p>A character. An optional quoted name of the node whose
outcome should be revealed. If specified all values of parents need
to be specified via <code>dos</code>.</p>
</td></tr>
<tr><td><code id="realise_outcomes_+3A_add_rownames">add_rownames</code></td>
<td>
<p>logical indicating whether to add causal types
as rownames to the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a node is not specified all outcomes are realised for all possible
causal types consistent with the model. If a node is specified then outcomes
of Y are returned conditional on different values of parents, whether or
not these values of the parents obtain given restrictions under the model.
</p>
<p><code>realise_outcomes</code> starts off by creating types
(via <code><a href="#topic+get_nodal_types">get_nodal_types</a></code>). It then takes types of endogenous
and reveals their outcome based on the value that their parents took.
Exogenous nodes outcomes correspond to their type.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> object of revealed data for each node (columns)
given causal / nodal type (rows) .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
make_model("X -&gt; Y") |&gt;
  realise_outcomes()

make_model("X -&gt; Y &lt;- W") |&gt;
set_restrictions(labels = list(X = "1", Y="0010"), keep = TRUE) |&gt;
 realise_outcomes()

make_model("X1-&gt;Y; X2-&gt;M; M-&gt;Y") |&gt;
realise_outcomes(dos = list(X1 = 1, M = 0))

# With node specified
make_model("X-&gt;M-&gt;Y") |&gt;
realise_outcomes(node = "Y")

make_model("X-&gt;M-&gt;Y") |&gt;
realise_outcomes(dos = list(M = 1), node = "Y")

</code></pre>

<hr>
<h2 id='restrict_by_labels'>Reduce nodal types using labels</h2><span id='topic+restrict_by_labels'></span>

<h3>Description</h3>

<p>Reduce nodal types using labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict_by_labels(model, labels, given = NULL, keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrict_by_labels_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="restrict_by_labels_+3A_labels">labels</code></td>
<td>
<p>A list of character vectors specifying nodal types to be
kept or removed from the model.</p>
</td></tr>
<tr><td><code id="restrict_by_labels_+3A_given">given</code></td>
<td>
<p>A character vector or list of character vectors specifying
nodes on which the parameter set to be restricted depends. When mixing
labels that are further restricted by <code>given</code> and ones that are not,
labels without <code>given</code> restrictions should have <code>given</code>
specified as one of <code>NULL</code>, <code>NA</code>, <code>""</code> or <code>" "</code>.</p>
</td></tr>
<tr><td><code id="restrict_by_labels_+3A_keep">keep</code></td>
<td>
<p>Logical. If 'FALSE', removes and if 'TRUE' keeps only causal
types specified by <code>restriction</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components: 1. a vector with parameters names of
parameters implicated by the restrictions, 2. a vector of subsetting
instructions used to identify implicated causal types
</p>


<h3>See Also</h3>

<p>Other restrictions: 
<code><a href="#topic+restrict_by_query">restrict_by_query</a>()</code>,
<code><a href="#topic+set_restrictions">set_restrictions</a>()</code>
</p>

<hr>
<h2 id='restrict_by_query'>Reduce nodal types using statement</h2><span id='topic+restrict_by_query'></span>

<h3>Description</h3>

<p>Reduce nodal types using statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict_by_query(model, statement, join_by = "|", given = NULL, keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrict_by_query_+3A_model">model</code></td>
<td>
<p>a model created by make_model()</p>
</td></tr>
<tr><td><code id="restrict_by_query_+3A_statement">statement</code></td>
<td>
<p>a list of character vectors specifying nodal types to be
removed from the model. Use <code>get_nodal_types</code> to see syntax.</p>
</td></tr>
<tr><td><code id="restrict_by_query_+3A_join_by">join_by</code></td>
<td>
<p>A string or a list of strings. The logical operator joining
expanded types when <code>statement</code> contains wildcard (<code>.</code>).
Can take values <code>'&amp;'</code> (logical AND) or <code>'|'</code> (logical OR).
When restriction contains wildcard (<code>.</code>) and <code>join_by</code> is not
specified, it defaults to <code>'|'</code>, otherwise it defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="restrict_by_query_+3A_given">given</code></td>
<td>
<p>A character vector or list of character vectors specifying
nodes on which the parameter set to be restricted depends. <code>given</code>
must either be NULL or of the same length as <code>statement</code>. When mixing
statements that are further restricted by <code>given</code> and ones that are
not, statements without <code>given</code> restrictions should have <code>given</code>
specified as one of <code>NULL</code>, <code>NA</code>, <code>""</code> or <code>" "</code>.</p>
</td></tr>
<tr><td><code id="restrict_by_query_+3A_keep">keep</code></td>
<td>
<p>Logical. If 'FALSE', removes and if 'TRUE' keeps only
causal types specified by <code>restriction</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components: 1. a vector with parameters names of
parameters implicated by the restrictions, 2. a vector of subsetting
instructions used to identify implicated causal types
</p>


<h3>See Also</h3>

<p>Other restrictions: 
<code><a href="#topic+restrict_by_labels">restrict_by_labels</a>()</code>,
<code><a href="#topic+set_restrictions">set_restrictions</a>()</code>
</p>

<hr>
<h2 id='reveal_outcomes'>Reveal outcomes</h2><span id='topic+reveal_outcomes'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
</p>
<p>This function was deprecated because the name causes clashes with
DeclareDesign. Use realise_outcomes instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal_outcomes(model, dos = NULL, node = NULL)
</code></pre>

<hr>
<h2 id='set_ambiguities_matrix'>Set ambiguity matrix</h2><span id='topic+set_ambiguities_matrix'></span>

<h3>Description</h3>

<p>Add an ambiguities matrix to a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_ambiguities_matrix(model, A = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_ambiguities_matrix_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="set_ambiguities_matrix_+3A_a">A</code></td>
<td>
<p>A <code>data.frame</code>. Ambiguity matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>causal_model</code> with the
ambiguities matrix attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; Y') %&gt;%
         set_ambiguities_matrix()
model$A
</code></pre>

<hr>
<h2 id='set_confound'>Set confound</h2><span id='topic+set_confound'></span>

<h3>Description</h3>

<p>Adjust parameter matrix to allow confounding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_confound(model, confound = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_confound_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="set_confound_+3A_confound">confound</code></td>
<td>
<p>A <code>list</code> of statements indicating pairs of nodes whose
types are jointly distributed (e.g. list(&quot;A &lt;-&gt; B&quot;, &quot;C &lt;-&gt; D&quot;)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confounding between X and Y arises when the nodal types for X and Y are not
independently distributed. In the X -&gt; Y graph, for instance, there are 2
nodal types for X and 4 for Y. There are thus 8 joint nodal types:
</p>
<pre>
|          | t^X                |                    |           |
|-----|----|--------------------|--------------------|-----------|
|     |    | 0                  | 1                  | Sum       |
|-----|----|--------------------|--------------------|-----------|
| t^Y | 00 | Pr(t^X=0 &amp; t^Y=00) | Pr(t^X=1 &amp; t^Y=00) | Pr(t^Y=00)|
|     | 10 | .                  | .                  | .         |
|     | 01 | .                  | .                  | .         |
|     | 11 | .                  | .                  | .         |
|-----|----|--------------------|--------------------|-----------|
|     |Sum | Pr(t^X=0)          | Pr(t^X=1)          | 1         |
</pre>
<p>This table has 8 interior elements and so an unconstrained joint
distribution would have 7 degrees of freedom. A no confounding assumption
means that Pr(t^X | t^Y) = Pr(t^X), or  Pr(t^X, t^Y) = Pr(t^X)Pr(t^Y).
In this case there would be 3 degrees of freedom for Y and 1 for X,
totaling 4 rather than 7.
</p>
<p><code>set_confound</code> lets you relax this assumption by increasing the
number of parameters characterizing the joint distribution. Using the fact
that P(A,B) = P(A)P(B|A) new parameters are introduced to capture P(B|A=a)
rather than simply P(B). For instance here two parameters
(and one degree of freedom) govern the distribution of types X  and four
parameters (with 3 degrees of freedom) govern  the types for Y given the
type of X for a total of 1+3+3 = 7 degrees of freedom.
</p>


<h3>Value</h3>

<p>An object of class <code>causal_model</code> with updated parameters_df
and parameter matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
make_model('X -&gt; Y; X &lt;-&gt; Y') |&gt;
get_parameters()

make_model('X -&gt; M -&gt; Y; X &lt;-&gt; Y') |&gt;
get_parameters()

model &lt;- make_model('X -&gt; M -&gt; Y; X &lt;-&gt; Y; M &lt;-&gt; Y')
model$parameters_df

# Example where set_confound is implemented after restrictions
make_model("A -&gt; B -&gt; C") |&gt;
set_restrictions(increasing("A", "B")) |&gt;
set_confound("B &lt;-&gt; C") |&gt;
get_parameters()

# Example where two parents are confounded
make_model('A -&gt; B &lt;- C; A &lt;-&gt; C') |&gt;
  set_parameters(node = "C", c(0.05, .95, .95, 0.05)) |&gt;
  make_data(n = 50) |&gt;
  cor()

 # Example with two confounds, added sequentially
model &lt;- make_model('A -&gt; B -&gt; C') |&gt;
  set_confound(list("A &lt;-&gt; B", "B &lt;-&gt; C"))
model$statement
# plot(model)
</code></pre>

<hr>
<h2 id='set_parameter_matrix'>Set parameter matrix</h2><span id='topic+set_parameter_matrix'></span>

<h3>Description</h3>

<p>Add a parameter matrix to a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_parameter_matrix(model, P = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_parameter_matrix_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="set_parameter_matrix_+3A_p">P</code></td>
<td>
<p>A <code>data.frame</code>. Parameter matrix. Not required but may be
provided to avoid repeated computation for simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>causal_model</code>. It essentially returns a
list containing the elements comprising a model
(e.g. 'statement', 'nodal_types' and 'DAG') with the parameter matrix
attached to it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X -&gt; Y')
P &lt;- diag(8)
colnames(P) &lt;- rownames(model$causal_types)
model &lt;- set_parameter_matrix(model, P = P)
</code></pre>

<hr>
<h2 id='set_parmap'>Set parmap: a matrix mapping from parameters to data types</h2><span id='topic+set_parmap'></span>

<h3>Description</h3>

<p>Generates and adds parmap to a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_parmap(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_parmap_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_parmap(model = make_model('X-&gt;Y'))

</code></pre>

<hr>
<h2 id='set_prior_distribution'>Add prior distribution draws</h2><span id='topic+set_prior_distribution'></span>

<h3>Description</h3>

<p>Add 'n_param x n_draws' database of possible lambda draws to the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_prior_distribution(model, n_draws = 4000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_prior_distribution_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="set_prior_distribution_+3A_n_draws">n_draws</code></td>
<td>
<p>A scalar. Number of draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>causal_model</code>. It essentially returns a
list containing the elements comprising a model
(e.g. 'statement', 'nodal_types' and 'DAG') with the 'prior_distribution'
attached to it.
</p>


<h3>See Also</h3>

<p>Other prior_distribution: 
<code><a href="#topic+get_prior_distribution">get_prior_distribution</a>()</code>,
<code><a href="#topic+make_prior_distribution">make_prior_distribution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_model('X -&gt; Y') %&gt;%
  set_prior_distribution(n_draws = 5) %&gt;%
  get_prior_distribution()

</code></pre>

<hr>
<h2 id='set_restrictions'>Restrict a model</h2><span id='topic+set_restrictions'></span>

<h3>Description</h3>

<p>Restrict a model's parameter space. This reduces the number of nodal types
and in consequence the number of unit causal types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_restrictions(
  model,
  statement = NULL,
  join_by = "|",
  labels = NULL,
  param_names = NULL,
  given = NULL,
  keep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_restrictions_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_statement">statement</code></td>
<td>
<p>A quoted expressions defining the restriction.
If values for some parents are not specified, statements should be
surrounded by parentheses, for instance <code>(Y[A = 1] &gt; Y[A=0])</code> will
be interpreted for all combinations of other parents of Y set at possible
levels they might take.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_join_by">join_by</code></td>
<td>
<p>A string. The logical operator joining expanded types when
<code>statement</code> contains wildcard (<code>.</code>). Can take values
<code>'&amp;'</code> (logical AND) or <code>'|'</code> (logical OR). When restriction
contains wildcard (<code>.</code>) and <code>join_by</code> is not specified, it
defaults to <code>'|'</code>, otherwise it defaults to <code>NULL</code>. Note that
join_by joins within statements, not across statements.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_labels">labels</code></td>
<td>
<p>A list of character vectors specifying nodal types to be kept
or removed from the model. Use <code>get_nodal_types</code> to see syntax.
Note that <code>labels</code> gets overwritten by <code>statement</code> if
<code>statement</code> is not NULL.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_param_names">param_names</code></td>
<td>
<p>A character vector of names of parameters to restrict on.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_given">given</code></td>
<td>
<p>A character vector or list of character vectors specifying
nodes on which the parameter set to be restricted depends.
When restricting by <code>statement</code>, <code>given</code> must either be
<code>NULL</code> or of the same length as <code>statement</code>. When mixing
statements that are further restricted by <code>given</code> and ones that are
not, statements without <code>given</code> restrictions should have <code>given</code>
specified as one of <code>NULL</code>, <code>NA</code>, <code>""</code> or <code>" "</code>.</p>
</td></tr>
<tr><td><code id="set_restrictions_+3A_keep">keep</code></td>
<td>
<p>Logical. If 'FALSE', removes and if 'TRUE' keeps only causal
types specified by <code>statement</code> or <code>labels</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Restrictions are made to nodal types, not to unit causal types.
Thus for instance in a model <code>X -&gt; M -&gt; Y</code>, one cannot apply a simple
restriction so that <code>Y</code> is nondecreasing in  <code>X</code>, however one can
restrict so that <code>M</code> is nondecreasing in <code>X</code> and <code>Y</code>
nondecreasing in <code>M</code>. To have a restriction that <code>Y</code> be
nondecreasing in <code>X</code> would otherwise require restrictions on
causal types, not nodal types, which implies a form of undeclared
confounding (i.e. that in cases in which <code>M</code> is decreasing in <code>X</code>,
<code>Y</code> is decreasing in <code>M</code>).
</p>
<p>Since restrictions are to nodal types, all parents of a node are
implicitly fixed.  Thus for model <code>make_model(`X -&gt; Y &lt;- W`)</code> the
request <code>set_restrictions(`(Y[X=1] == 0)`)</code> is interpreted as
<code>set_restrictions(`(Y[X=1, W=0] == 0 | Y[X=1, W=1] == 0)`)</code>.
</p>
<p>Statements with implicitly controlled nodes should be surrounded by
parentheses, as in these examples.
</p>
<p>Note that prior probabilities are redistributed over remaining types.
</p>


<h3>Value</h3>

<p>An object of class <code>model</code>. The causal types and nodal types
in the model are reduced according to the stated restriction.
</p>


<h3>See Also</h3>

<p>Other restrictions: 
<code><a href="#topic+restrict_by_labels">restrict_by_labels</a>()</code>,
<code><a href="#topic+restrict_by_query">restrict_by_query</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1. Restrict parameter space using statements
model &lt;- make_model('X-&gt;Y') %&gt;%
  set_restrictions(statement = c('X[] == 0'))

model &lt;- make_model('X-&gt;Y') %&gt;%
  set_restrictions(non_increasing('X', 'Y'))

model &lt;- make_model('X -&gt; Y &lt;- W') %&gt;%
  set_restrictions(c(decreasing('X', 'Y'), substitutes('X', 'W', 'Y')))

model$parameters_df

model &lt;- make_model('X-&gt; Y &lt;- W') %&gt;%
  set_restrictions(statement = decreasing('X', 'Y'))
model$parameters_df

model &lt;- make_model('X-&gt;Y') %&gt;%
  set_restrictions(decreasing('X', 'Y'))
model$parameters_df

model &lt;- make_model('X-&gt;Y') %&gt;%
  set_restrictions(c(increasing('X', 'Y'), decreasing('X', 'Y')))
model$parameters_df

# Restrict to define a model with monotonicity
model &lt;- make_model('X-&gt;Y') %&gt;%
set_restrictions(statement = c('Y[X=1] &lt; Y[X=0]'))
get_parameter_matrix(model)

# Restrict to a single type in endogenous node
model &lt;- make_model('X-&gt;Y') %&gt;%
set_restrictions(statement =  '(Y[X = 1] == 1)', join_by = '&amp;', keep = TRUE)
get_parameter_matrix(model)

#  Use of | and &amp;
# Keep node if *for some value of B* Y[A = 1] == 1
model &lt;- make_model('A-&gt;Y&lt;-B') %&gt;%
set_restrictions(statement =  '(Y[A = 1] == 1)', join_by = '|', keep = TRUE)
dim(get_parameter_matrix(model))


# Keep node if *for all values of B* Y[A = 1] == 1
model &lt;- make_model('A-&gt;Y&lt;-B') %&gt;%
set_restrictions(statement =  '(Y[A = 1] == 1)', join_by = '&amp;', keep = TRUE)
dim(get_parameter_matrix(model))

# Restrict multiple nodes
model &lt;- make_model('X-&gt;Y&lt;-M; X -&gt; M' ) %&gt;%
set_restrictions(statement =  c('(Y[X = 1] == 1)', '(M[X = 1] == 1)'),
                 join_by = '&amp;', keep = TRUE)
get_parameter_matrix(model)

# Restrict using statements and given:
model &lt;- make_model("X -&gt; Y -&gt; Z; X &lt;-&gt; Z") %&gt;%
 set_restrictions(list(decreasing('X','Y'), decreasing('Y','Z')),
                  given = c(NA,'X.0'))
get_parameter_matrix(model)

# Restrictions on levels for endogenous nodes aren't allowed
## Not run: 
model &lt;- make_model('X-&gt;Y') %&gt;%
set_restrictions(statement =  '(Y == 1)')

## End(Not run)

# 2. Restrict parameter space Using labels:
model &lt;- make_model('X-&gt;Y') %&gt;%
set_restrictions(labels = list(X = '0', Y = '00'))

# Restrictions can be  with wildcards
model &lt;- make_model('X-&gt;Y') %&gt;%
set_restrictions(labels = list(Y = '?0'))
get_parameter_matrix(model)

# Deterministic model
model &lt;- make_model('S -&gt; C -&gt; Y &lt;- R &lt;- X; X -&gt; C -&gt; R') %&gt;%
set_restrictions(labels = list(C = '1000', R = '0001', Y = '0001'),
                 keep = TRUE)
get_parameter_matrix(model)

# Restrict using labels and given:
model &lt;- make_model("X -&gt; Y -&gt; Z; X &lt;-&gt; Z") %&gt;%
 set_restrictions(labels = list(X = '0', Z = '00'), given = c(NA,'X.0'))
get_parameter_matrix(model)

</code></pre>

<hr>
<h2 id='set_sampling_args'>set_sampling_args
From 'rstanarm' (November 1st, 2019)</h2><span id='topic+set_sampling_args'></span>

<h3>Description</h3>

<p>set_sampling_args
From 'rstanarm' (November 1st, 2019)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_sampling_args(object, user_dots = list(), user_adapt_delta = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_sampling_args_+3A_object">object</code></td>
<td>
<p>A <code>stanfit</code> object.</p>
</td></tr>
<tr><td><code id="set_sampling_args_+3A_user_dots">user_dots</code></td>
<td>
<p>A list. User commands.</p>
</td></tr>
<tr><td><code id="set_sampling_args_+3A_user_adapt_delta">user_adapt_delta</code></td>
<td>
<p>A double between 0 and 1.
Adapt delta passed by the user</p>
</td></tr>
<tr><td><code id="set_sampling_args_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to 'stan'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Set the sampling arguments
</p>


<h3>Value</h3>

<p>A <code>list</code> with arguments to be passed to <code>stan</code>
</p>

<hr>
<h2 id='simulate_data'>simulate_data is an alias for make_data</h2><span id='topic+simulate_data'></span>

<h3>Description</h3>

<p>simulate_data is an alias for make_data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_data(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_data_+3A_...">...</code></td>
<td>
<p>arguments for <code><a href="#topic+make_model">make_model</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with simulated data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulate_data(make_model("X-&gt;Y"))
</code></pre>

<hr>
<h2 id='st_within'>Get string between two regular expression patterns</h2><span id='topic+st_within'></span>

<h3>Description</h3>

<p>Returns a substring enclosed by two regular expression patterns.
By default returns the name of the arguments being indexed by
squared brackets (<code>[]</code>) in a string containing an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_within(
  x,
  left = "[^_[:^punct:]]|\\b",
  right = "\\[",
  rm_left = 0,
  rm_right = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_within_+3A_x">x</code></td>
<td>
<p>A character string.</p>
</td></tr>
<tr><td><code id="st_within_+3A_left">left</code></td>
<td>
<p>A character string. Regular expression to serve as look ahead.</p>
</td></tr>
<tr><td><code id="st_within_+3A_right">right</code></td>
<td>
<p>A character string. Regular expression to
serve as a look behind.</p>
</td></tr>
<tr><td><code id="st_within_+3A_rm_left">rm_left</code></td>
<td>
<p>An integer. Number of bites after left-side match to remove
from result. Defaults to -1.</p>
</td></tr>
<tr><td><code id="st_within_+3A_rm_right">rm_right</code></td>
<td>
<p>An integer. Number of bites after right-side match to remove
from result. Defaults to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- '(XX[Y=0] == 1) &gt; (XX[Y=1] == 0)'
CausalQueries:::st_within(a)
b &lt;- '(XXX[[Y=0]] == 1 + XXX[[Y=1]] == 0)'
CausalQueries:::st_within(b)
</code></pre>

<hr>
<h2 id='substitutes'>Make statement for substitutes</h2><span id='topic+substitutes'></span>

<h3>Description</h3>

<p>Generate a statement for X1, X1 substitute for each other
in the production of Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substitutes(X1, X2, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="substitutes_+3A_x1">X1</code></td>
<td>
<p>A character. The quoted name of the input node 1.</p>
</td></tr>
<tr><td><code id="substitutes_+3A_x2">X2</code></td>
<td>
<p>A character. The quoted name of the input node 2.</p>
</td></tr>
<tr><td><code id="substitutes_+3A_y">Y</code></td>
<td>
<p>A character. The quoted name of the outcome node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character statement of class <code>statement</code>
</p>


<h3>See Also</h3>

<p>Other statements: 
<code><a href="#topic+complements">complements</a>()</code>,
<code><a href="#topic+decreasing">decreasing</a>()</code>,
<code><a href="#topic+increasing">increasing</a>()</code>,
<code><a href="#topic+interacts">interacts</a>()</code>,
<code><a href="#topic+non_decreasing">non_decreasing</a>()</code>,
<code><a href="#topic+non_increasing">non_increasing</a>()</code>,
<code><a href="#topic+te">te</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
get_query_types(model = make_model('A -&gt; B &lt;- C'),
         query = substitutes('A', 'C', 'B'),map = "causal_type")

query_model(model = make_model('A -&gt; B &lt;- C'),
         queries = substitutes('A', 'C', 'B'),
         using = 'parameters')

</code></pre>

<hr>
<h2 id='te'>Make treatment effect statement (positive)</h2><span id='topic+te'></span>

<h3>Description</h3>

<p>Generate a statement for (Y(1) - Y(0)). This statement when applied to
a model returns an element in (1,0,-1) and not a set of cases.
This is useful for some purposes such as querying a model, but not for
uses that require a list of types, such as <code>set_restrictions</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>te(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="te_+3A_x">X</code></td>
<td>
<p>A character. The quoted name of the input node</p>
</td></tr>
<tr><td><code id="te_+3A_y">Y</code></td>
<td>
<p>A character. The quoted name of the outcome node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character statement of class <code>statement</code>
</p>


<h3>See Also</h3>

<p>Other statements: 
<code><a href="#topic+complements">complements</a>()</code>,
<code><a href="#topic+decreasing">decreasing</a>()</code>,
<code><a href="#topic+increasing">increasing</a>()</code>,
<code><a href="#topic+interacts">interacts</a>()</code>,
<code><a href="#topic+non_decreasing">non_decreasing</a>()</code>,
<code><a href="#topic+non_increasing">non_increasing</a>()</code>,
<code><a href="#topic+substitutes">substitutes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
te('A', 'B')

model &lt;- make_model('X-&gt;Y') %&gt;% set_restrictions(increasing('X', 'Y'))
query_model(model, list(ate = te('X', 'Y')),  using = 'parameters')

# set_restrictions  breaks with te because it requires a listing
# of causal types, not numeric output.

## Not run: 
model &lt;- make_model('X-&gt;Y') %&gt;% set_restrictions(te('X', 'Y'))

## End(Not run)

</code></pre>

<hr>
<h2 id='type_matrix'>Generate type matrix</h2><span id='topic+type_matrix'></span>

<h3>Description</h3>

<p>Generate type matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_matrix(parent_n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type_matrix_+3A_parent_n">parent_n</code></td>
<td>
<p>An integer. Number of parents of a given child.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> whose rows contain digits of
each causal types in a model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CausalQueries:::type_matrix(2)

</code></pre>

<hr>
<h2 id='uncollapse_nodal_types'>uncollapse nodal types</h2><span id='topic+uncollapse_nodal_types'></span>

<h3>Description</h3>

<p>uncollapse nodal types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncollapse_nodal_types(nodal_types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncollapse_nodal_types_+3A_nodal_types">nodal_types</code></td>
<td>
<p>A list of nodal types in collapsed form ('01', '11') etc..</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing nodes with nodal types in data.frame form
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- make_model('X -&gt; K -&gt; Y')
(nodal_types &lt;- get_nodal_types(model , collapse = TRUE))
CausalQueries:::uncollapse_nodal_types(nodal_types)
</code></pre>

<hr>
<h2 id='unpack_wildcard'>Unpack a wild card</h2><span id='topic+unpack_wildcard'></span>

<h3>Description</h3>

<p>Unpack a wild card
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_wildcard(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_wildcard_+3A_x">x</code></td>
<td>
<p>A character. A nodal type containing one or more wildcard
characters '?' to be unpacked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A type label with wildcard characters '?' substituted by 0 and 1.
</p>

<hr>
<h2 id='update_causal_types'>Update causal types based on nodal types</h2><span id='topic+update_causal_types'></span>

<h3>Description</h3>

<p>Update causal types based on nodal types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_causal_types(model, restrict_given = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_causal_types_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="update_causal_types_+3A_restrict_given">restrict_given</code></td>
<td>
<p>a character vector of subsetting instructions for
rows to be dropped from causal types data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing updated causal types in a model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CausalQueries:::update_causal_types(make_model('X-&gt;Y'))
</code></pre>

<hr>
<h2 id='update_model'>Fit causal model using 'stan'</h2><span id='topic+update_model'></span>

<h3>Description</h3>

<p>Takes a model and data and returns a model object with data
attached and a posterior model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_model(
  model,
  data = NULL,
  data_type = NULL,
  keep_fit = FALSE,
  keep_transformed = TRUE,
  keep_event_probabilities = FALSE,
  censored_types = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_model_+3A_model">model</code></td>
<td>
<p>A <code>causal_model</code>. A model object generated by
<code><a href="#topic+make_model">make_model</a></code>.</p>
</td></tr>
<tr><td><code id="update_model_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.  Data of nodes that can take three values:
0, 1, and NA. In long form as generated by <code><a href="#topic+make_events">make_events</a></code></p>
</td></tr>
<tr><td><code id="update_model_+3A_data_type">data_type</code></td>
<td>
<p>Either 'long' (as made by <code><a href="#topic+make_data">make_data</a></code>) or
'compact' (as made by <code><a href="#topic+collapse_data">collapse_data</a></code>). Compact data must
have entries for each member of each strategy family to produce a
valid simplex. When long form data is provided with missingness, missing
data is assumed to be missing at random.</p>
</td></tr>
<tr><td><code id="update_model_+3A_keep_fit">keep_fit</code></td>
<td>
<p>Logical. Whether to append the
<a href="rstan.html#topic+stanfit">stanfit</a> object to the model. Defaults to 'FALSE'. See
<code>`?rstan::stanfit`</code> for details of output.</p>
</td></tr>
<tr><td><code id="update_model_+3A_keep_transformed">keep_transformed</code></td>
<td>
<p>Logical. Whether to keep transformed parameters,
prob_of_types, P_lambdas, w, w_full</p>
</td></tr>
<tr><td><code id="update_model_+3A_keep_event_probabilities">keep_event_probabilities</code></td>
<td>
<p>Logical. Whether to keep the distribution
of event probabilities. Defaults to 'FALSE'</p>
</td></tr>
<tr><td><code id="update_model_+3A_censored_types">censored_types</code></td>
<td>
<p>vector of data types that are selected out of
the data, e.g. <code>c("X0Y0")</code></p>
</td></tr>
<tr><td><code id="update_model_+3A_...">...</code></td>
<td>
<p>Options passed onto <a href="rstan.html#topic+sampling">sampling</a> call. For
details see <code>?rstan::sampling</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>causal_model</code>. The returned model is a
list containing the elements comprising a model
(e.g. 'statement', 'nodal_types' and 'DAG') with the
<code>posterior_distribution</code> returned by <a href="rstan.html#topic+stan">stan</a>
attached to it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- make_model('X-&gt;Y')
data_long   &lt;- simulate_data(model, n = 4)
data_short  &lt;- collapse_data(data_long, model)

model_1 &lt;- update_model(model, data_long)


model_2 &lt;- update_model(model, data_long, keep_transformed = FALSE)

## Not run: 
# Throws error unless compact data indicated:

model_3 &lt;- update_model(model, data_short)
model_4 &lt;- update_model(model, data_short, data_type = 'compact')

# It is possible to implement updating without data, in which
# case the posterior is a stan object that reflects the prior
model_5 &lt;- update_model(model)


# Censored data types
# We update less than we might because we are aware of filtered data
uncensored &lt;-  make_model("X-&gt;Y") %&gt;%
  update_model(data.frame(X=rep(0:1, 10), Y=rep(0:1,10))) |&gt;
  query_model(te("X", "Y"), using = "posteriors")

censored &lt;- make_model("X-&gt;Y") %&gt;%
  update_model(data.frame(X=rep(0:1, 10), Y=rep(0:1,10)),
  censored_types = c("X1Y0")) %&gt;%
  query_model(te("X", "Y"), using = "posteriors")

# Censored data: We learning nothing because the data
# we see is the only data we could ever see
make_model("X-&gt;Y") %&gt;%
  update_model(data.frame(X=rep(1,5), Y=rep(1,5)),
  censored_types = c("X1Y0", "X0Y0", "X0Y1")) %&gt;%
  query_model(te("X", "Y"), using = "posteriors")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
