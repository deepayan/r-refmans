<!DOCTYPE html><html lang="en"><head><title>Help for package viking</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {viking}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#expectation_maximization'><p>Expectation-Maximization</p></a></li>
<li><a href='#iterative_grid_search'><p>Iterative Grid Search</p></a></li>
<li><a href='#kalman_filtering'><p>Kalman Filtering</p></a></li>
<li><a href='#kalman_smoothing'><p>Kalman Smoothing</p></a></li>
<li><a href='#loglik'><p>Log-likelihood</p></a></li>
<li><a href='#plot.statespace'><p>Plot a statespace object</p></a></li>
<li><a href='#predict.statespace'><p>Predict using a statespace object</p></a></li>
<li><a href='#select_Kalman_variances'><p>Select time-invariant variances of a State-Space Model</p></a></li>
<li><a href='#statespace'><p>Design a State-Space Model</p></a></li>
<li><a href='#viking'><p>Viking: Variational bayesIan variance tracKING</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>State-Space Models Inference by Kalman or Viking</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph de Vilmarest [aut, cre]
    (&lt;https://orcid.org/0000-0002-0634-8484&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joseph de Vilmarest &lt;joseph.de-vilmarest@vikingconseil.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Inference methods for state-space models, relying on the Kalman Filter or on Viking (Variational Bayesian VarIance tracKING). See J. de Vilmarest (2022) <a href="https://theses.hal.science/tel-03716104/">https://theses.hal.science/tel-03716104/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>RColorBrewer, mvtnorm</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-06 12:11:45 UTC; josephdevilmarest</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-06 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='expectation_maximization'>Expectation-Maximization</h2><span id='topic+expectation_maximization'></span>

<h3>Description</h3>

<p><code>expectation_maximization</code> is a method to choose hyper-parameters of the
linear Gaussian State-Space Model with time-invariant variances relying on the
Expectation-Maximization algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectation_maximization(
  X,
  y,
  n_iter,
  Q_init,
  sig_init = 1,
  verbose = 1000,
  lambda = 10^-9,
  mode_diag = FALSE,
  p1 = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expectation_maximization_+3A_x">X</code></td>
<td>
<p>explanatory variables</p>
</td></tr>
<tr><td><code id="expectation_maximization_+3A_y">y</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="expectation_maximization_+3A_n_iter">n_iter</code></td>
<td>
<p>number of iterations of the EM algorithm</p>
</td></tr>
<tr><td><code id="expectation_maximization_+3A_q_init">Q_init</code></td>
<td>
<p>initial covariance matrix on the state noise</p>
</td></tr>
<tr><td><code id="expectation_maximization_+3A_sig_init">sig_init</code></td>
<td>
<p>(optional, default <code>1</code>) initial value of the standard deviation
of the observation noise</p>
</td></tr>
<tr><td><code id="expectation_maximization_+3A_verbose">verbose</code></td>
<td>
<p>(optional, default <code>1000</code>) frequency for prints</p>
</td></tr>
<tr><td><code id="expectation_maximization_+3A_lambda">lambda</code></td>
<td>
<p>(optional, default <code>10^-9</code>) regularization parameter to avoid singularity</p>
</td></tr>
<tr><td><code id="expectation_maximization_+3A_mode_diag">mode_diag</code></td>
<td>
<p>(optional, default <code>FALSE</code>) if <code>TRUE</code> then we restrict the
search to diagonal matrices for <code>Q</code></p>
</td></tr>
<tr><td><code id="expectation_maximization_+3A_p1">p1</code></td>
<td>
<p>(optional, default <code>0</code>) deterministic value of <code>P1 = p1 I</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>E-step is realized through recursive Kalman formulae (filtering then smoothing).<br />
M-step is the maximization of the expected complete likelihood with respect to the
hyper-parameters.<br />
We only have the guarantee of convergence to a LOCAL optimum.
We fix P1 = p1 I (by default p1 = 0). We optimize theta1, sig, Q.
</p>


<h3>Value</h3>

<p>a list containing values for <code>P,theta,sig,Q</code>, and two vectors
<code>DIFF, LOGLIK</code> assessing the convergence of the algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
### Simulate data
n &lt;- 100
d &lt;- 5
Q &lt;- diag(c(0,0,0.25,0.25,0.25))
sig &lt;- 1

X &lt;- cbind(matrix(rnorm((d-1)*n,sd=1),n,d-1),1)
theta &lt;- matrix(rnorm(d), d, 1)
theta_arr &lt;- matrix(0, n, d)
for (t in 1:n) {
  theta_arr[t,] &lt;- theta
  theta &lt;- theta + matrix(mvtnorm::rmvnorm(1,matrix(0,d,1),Q),d,1)
}
y &lt;- rowSums(X * theta_arr) + rnorm(n, sd=sig)

l &lt;- viking::expectation_maximization(X, y, 50, diag(d), verbose=10)
print(l$Q)
print(l$sig)
</code></pre>

<hr>
<h2 id='iterative_grid_search'>Iterative Grid Search</h2><span id='topic+iterative_grid_search'></span>

<h3>Description</h3>

<p><code>iterative_grid_search</code> is an iterative method to choose hyper-parameters of
the linear Gaussian State-Space Model with time-invariant variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterative_grid_search(
  X,
  y,
  q_list,
  Q_init = NULL,
  max_iter = 0,
  delay = 1,
  use = NULL,
  restrict = NULL,
  mode = "gaussian",
  p1 = 0,
  ncores = 1,
  train_theta1 = NULL,
  train_Q = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iterative_grid_search_+3A_x">X</code></td>
<td>
<p>the explanatory variables</p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_y">y</code></td>
<td>
<p>the observations</p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_q_list">q_list</code></td>
<td>
<p>the possible values of <code>diag(Q) / sig^2</code></p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_q_init">Q_init</code></td>
<td>
<p>(default <code>NULL</code>) initial value of <code>Q / sig^2</code>,
if <code>NULL</code> it is set to 0</p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_max_iter">max_iter</code></td>
<td>
<p>(optional 0) maximal number of iterations. If 0 then optimization is
done as long as we can improve the log-likelihood</p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_delay">delay</code></td>
<td>
<p>(optional, default 1) to predict <code>y[t]</code> we have access to <code>y[t-delay]</code></p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_use">use</code></td>
<td>
<p>(optional, default <code>NULL</code>) the availability variable</p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_restrict">restrict</code></td>
<td>
<p>(optional, default <code>NULL</code>) if not <code>NULL</code> it allows to specify the
indices of the diagonal coefficient to optimize</p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_mode">mode</code></td>
<td>
<p>(optional, default <code>gaussian</code>)</p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_p1">p1</code></td>
<td>
<p>(optional, default <code>0</code>) coefficient for <code>P1/sig^2 = p1 I</code></p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_ncores">ncores</code></td>
<td>
<p>(optional, default <code>1</code>) number of available cores for computation</p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_train_theta1">train_theta1</code></td>
<td>
<p>(optional, default <code>NULL</code>) training set for estimation of <code>theta1</code></p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_train_q">train_Q</code></td>
<td>
<p>(optional, default <code>NULL</code>) time steps on which the log-likelihood is computed</p>
</td></tr>
<tr><td><code id="iterative_grid_search_+3A_verbose">verbose</code></td>
<td>
<p>(optional, default <code>TRUE</code>) whether to print intermediate progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We restrict ourselves to a diagonal matrix <code>Q</code> and we optimize <code>Q / sig^2</code> on
a grid. Each diagonal coefficient is assumed to belong to a pre-defined <code>q_list</code>.<br />
We maximize the log-likelihood on that region of search in an iterative fashion.
At each step, we change the diagonal coefficient improving the most the log-likelihood.
We stop when there is no possible improvement. This doesn't guarantee an optimal point
on the grid, but the computational time is much lower.
</p>


<h3>Value</h3>

<p>a list containing values for <code>P,theta,sig,Q</code>, as well as <code>LOGLIK</code>,
the evolution of the log-likelihood during the search.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
### Simulate data
n &lt;- 100
d &lt;- 5
Q &lt;- diag(c(0,0,0.25,0.25,0.25))
sig &lt;- 1

X &lt;- cbind(matrix(rnorm((d-1)*n,sd=1),n,d-1),1)
theta &lt;- matrix(rnorm(d), d, 1)
theta_arr &lt;- matrix(0, n, d)
for (t in 1:n) {
  theta_arr[t,] &lt;- theta
  theta &lt;- theta + matrix(mvtnorm::rmvnorm(1,matrix(0,d,1),Q),d,1)
}
y &lt;- rowSums(X * theta_arr) + rnorm(n, sd=sig)

l &lt;- viking::iterative_grid_search(X, y, seq(0,1,0.25))
print(l$Q)
print(l$sig)
</code></pre>

<hr>
<h2 id='kalman_filtering'>Kalman Filtering</h2><span id='topic+kalman_filtering'></span>

<h3>Description</h3>

<p>Compute the filtered estimation of the parameters <code>theta</code> and <code>P</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kalman_filtering(X, y, theta1, P1, Q = 0, sig = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kalman_filtering_+3A_x">X</code></td>
<td>
<p>the explanatory variables</p>
</td></tr>
<tr><td><code id="kalman_filtering_+3A_y">y</code></td>
<td>
<p>the time series</p>
</td></tr>
<tr><td><code id="kalman_filtering_+3A_theta1">theta1</code></td>
<td>
<p>initial <code>theta</code></p>
</td></tr>
<tr><td><code id="kalman_filtering_+3A_p1">P1</code></td>
<td>
<p>initial <code>P</code></p>
</td></tr>
<tr><td><code id="kalman_filtering_+3A_q">Q</code></td>
<td>
<p>(optional, default <code>0</code>) covariance matrix of the state noise</p>
</td></tr>
<tr><td><code id="kalman_filtering_+3A_sig">sig</code></td>
<td>
<p>(optional, default <code>1</code>) variance of the spate noise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing <code>theta_arr</code> and <code>P_arr</code>, the filtered estimation of
the parameters <code>theta</code> and <code>P</code>.
</p>

<hr>
<h2 id='kalman_smoothing'>Kalman Smoothing</h2><span id='topic+kalman_smoothing'></span>

<h3>Description</h3>

<p>Compute the smoothed estimation of the parameters <code>theta</code> and <code>P</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kalman_smoothing(X, y, theta1, P1, Q = 0, sig = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kalman_smoothing_+3A_x">X</code></td>
<td>
<p>the explanatory variables</p>
</td></tr>
<tr><td><code id="kalman_smoothing_+3A_y">y</code></td>
<td>
<p>the time series</p>
</td></tr>
<tr><td><code id="kalman_smoothing_+3A_theta1">theta1</code></td>
<td>
<p>initial <code>theta</code></p>
</td></tr>
<tr><td><code id="kalman_smoothing_+3A_p1">P1</code></td>
<td>
<p>initial <code>P</code></p>
</td></tr>
<tr><td><code id="kalman_smoothing_+3A_q">Q</code></td>
<td>
<p>(optional, default <code>0</code>) covariance matrix of the state noise</p>
</td></tr>
<tr><td><code id="kalman_smoothing_+3A_sig">sig</code></td>
<td>
<p>(optional, default <code>1</code>) variance of the spate noise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing <code>theta_arr</code> and <code>P_arr</code>, the smoothed estimation of
the parameters <code>theta</code> and <code>P</code>.
</p>

<hr>
<h2 id='loglik'>Log-likelihood</h2><span id='topic+loglik'></span>

<h3>Description</h3>

<p><code>loglik</code> computes the log-likelihood of a state-space model of specified
<code>Q/sig^2, P1/sig^2, theta1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik(X, y, Qstar, use, p1, train_theta1, train_Q, mode = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik_+3A_x">X</code></td>
<td>
<p>explanatory variables</p>
</td></tr>
<tr><td><code id="loglik_+3A_y">y</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="loglik_+3A_qstar">Qstar</code></td>
<td>
<p>the ratio <code>Q/sig^2</code></p>
</td></tr>
<tr><td><code id="loglik_+3A_use">use</code></td>
<td>
<p>the availability variable</p>
</td></tr>
<tr><td><code id="loglik_+3A_p1">p1</code></td>
<td>
<p>coefficient for <code>P1/sig^2 = p1 I</code></p>
</td></tr>
<tr><td><code id="loglik_+3A_train_theta1">train_theta1</code></td>
<td>
<p>training set for estimation of <code>theta1</code></p>
</td></tr>
<tr><td><code id="loglik_+3A_train_q">train_Q</code></td>
<td>
<p>time steps on which the log-likelihood is computed</p>
</td></tr>
<tr><td><code id="loglik_+3A_mode">mode</code></td>
<td>
<p>(optional, default <code>gaussian</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value for the log-likelihood.
</p>

<hr>
<h2 id='plot.statespace'>Plot a statespace object</h2><span id='topic+plot.statespace'></span>

<h3>Description</h3>

<p><code>plot.statespace</code> displays different graphs expressing the behavior of the state-space
model:<br />
1. Evolution of the Bias: rolling version of the error of the model.<br />
2. Evolution of the RMSE: root-mean-square-error computed on a rolling window.<br />
3. State Evolution: time-varying state coefficients, subtracted of the initial state vector.<br />
4. Normal Q-Q Plot: we check if the observation follows the Gaussian distribution of estimated
mean and variance. To that end, we display a Q-Q plot of the residual divided by the estimated
standard deviation, against the standard normal distribution.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'statespace'
plot(x, pause = FALSE, window_size = 7, date = NULL, sel = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.statespace_+3A_x">x</code></td>
<td>
<p>the statespace object.</p>
</td></tr>
<tr><td><code id="plot.statespace_+3A_pause">pause</code></td>
<td>
<p>(default <code>FALSE</code>) if set to <code>FALSE</code> then the plots are displayed on a single
page, otherwise a new page is created for each plot.</p>
</td></tr>
<tr><td><code id="plot.statespace_+3A_window_size">window_size</code></td>
<td>
<p>(default <code>7</code>) the window size of the rolling mean computed on the
error to display the bias, and on the mean squared error to display a rolling RMSE.</p>
</td></tr>
<tr><td><code id="plot.statespace_+3A_date">date</code></td>
<td>
<p>(default <code>NULL</code>) defines the values for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.statespace_+3A_sel">sel</code></td>
<td>
<p>(default <code>NULL</code>) defines a subset of the data on which we zoom.
For instance one can display the evolution of the SSM on a test set and not the whole data set.</p>
</td></tr>
<tr><td><code id="plot.statespace_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to display plots.
</p>

<hr>
<h2 id='predict.statespace'>Predict using a statespace object</h2><span id='topic+predict.statespace'></span>

<h3>Description</h3>

<p><code>predict.statespace</code> makes a prediction for a statespace object, in the offline or online
setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'statespace'
predict(
  object,
  newX,
  newy = NULL,
  online = TRUE,
  compute_smooth = FALSE,
  type = c("mean", "proba", "model"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.statespace_+3A_object">object</code></td>
<td>
<p>the statespace object</p>
</td></tr>
<tr><td><code id="predict.statespace_+3A_newx">newX</code></td>
<td>
<p>the design matrix in the prediction set</p>
</td></tr>
<tr><td><code id="predict.statespace_+3A_newy">newy</code></td>
<td>
<p>(default <code>NULL</code>) the variable of interest in the prediction set. If specified
it allows to use the state-space model in the online setting. Otherwise the prediction is
offline.</p>
</td></tr>
<tr><td><code id="predict.statespace_+3A_online">online</code></td>
<td>
<p>(default <code>TRUE</code>) specifies if the prediction is made online, that is if
the observation at time t-1 is used to update the model before predicting at time t.</p>
</td></tr>
<tr><td><code id="predict.statespace_+3A_compute_smooth">compute_smooth</code></td>
<td>
<p>(default <code>FALSE</code>) specifies if Kalman Smoothing is also computed.</p>
</td></tr>
<tr><td><code id="predict.statespace_+3A_type">type</code></td>
<td>
<p>type of prediction. Can be either
</p>

<dl>
<dt>mean</dt><dd><p>return the mean forecast.</p>
</dd>
<dt>proba</dt><dd><p>return a probabilistic forecast (list containing estimation of the mean and
standard deviation).</p>
</dd>
<dt>model</dt><dd><p>return the updated statespace object (containing also the forecasts).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="predict.statespace_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the type specified, the result is <br />
- a vector of mean forecast if <code>type='mean'</code>
- a list of two vectors, mean forecast and standard deviations if <code>type='proba'</code>
- a statespace object if <code>type='model'</code>
</p>

<hr>
<h2 id='select_Kalman_variances'>Select time-invariant variances of a State-Space Model</h2><span id='topic+select_Kalman_variances'></span>

<h3>Description</h3>

<p><code>select_Kalman_variances</code> is a function to choose hyper-parameters of the
linear Gaussian State-Space Model with time-invariant variances. It relies on the
functions <code>iterative_grid_search</code> and <code>expectation_maximization</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_Kalman_variances(ssm, X, y, method = "igd", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_Kalman_variances_+3A_ssm">ssm</code></td>
<td>
<p>the statespace object</p>
</td></tr>
<tr><td><code id="select_Kalman_variances_+3A_x">X</code></td>
<td>
<p>explanatory variables</p>
</td></tr>
<tr><td><code id="select_Kalman_variances_+3A_y">y</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="select_Kalman_variances_+3A_method">method</code></td>
<td>
<p>(optional, default <code>'igd'</code>) it can be either
</p>

<dl>
<dt><code>'igd'</code></dt><dd><p><code>iterative_grid_search</code> is called</p>
</dd>
<dt><code>'em'</code></dt><dd><p><code>expectation_maximization</code> is called</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="select_Kalman_variances_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new statespace object with new values in <code>kalman_params</code>
</p>

<hr>
<h2 id='statespace'>Design a State-Space Model</h2><span id='topic+statespace'></span>

<h3>Description</h3>

<p>The function <code>statespace</code> builds a state-space model, with known or unknown variances.
By default, this function builds a state-space model in the static setting, with a constant
state (zero state noise covariance matrix) and constant observation noise variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statespace(X, y, kalman_params = NULL, viking_params = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="statespace_+3A_x">X</code></td>
<td>
<p>design matrix.</p>
</td></tr>
<tr><td><code id="statespace_+3A_y">y</code></td>
<td>
<p>variable of interest.</p>
</td></tr>
<tr><td><code id="statespace_+3A_kalman_params">kalman_params</code></td>
<td>
<p>(default <code>NULL</code>) list containing initial values for <code>theta,P</code>
as well as the variances (<code>Q,sig</code>). If it is not specified, the state-space model is
constructed in the static setting (<code>theta=0, P=I, Q=0, sig=1</code>).</p>
</td></tr>
<tr><td><code id="statespace_+3A_viking_params">viking_params</code></td>
<td>
<p>(default <code>NULL</code>) list of parameters for the Viking algorithm.</p>
</td></tr>
<tr><td><code id="statespace_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a statespace object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
### Simulate data
n &lt;- 1000
d &lt;- 5
Q &lt;- diag(c(0,0,0.25,0.25,0.25))
sig &lt;- 1

X &lt;- cbind(matrix(rnorm((d-1)*n,sd=1),n,d-1),1)
theta &lt;- matrix(rnorm(d), d, 1)
theta_arr &lt;- matrix(0, n, d)
for (t in 1:n) {
  theta_arr[t,] &lt;- theta
  theta &lt;- theta + matrix(mvtnorm::rmvnorm(1,matrix(0,d,1),Q),d,1)
}
y &lt;- rowSums(X * theta_arr) + rnorm(n, sd=sig)

####################
### Kalman Filter
# Default Static Setting
ssm &lt;- viking::statespace(X, y)
plot(ssm)

# Known variances
ssm &lt;- viking::statespace(X, y, kalman_params = list(Q=Q, sig=sig))
plot(ssm)

</code></pre>

<hr>
<h2 id='viking'>Viking: Variational bayesIan variance tracKING</h2><span id='topic+viking'></span>

<h3>Description</h3>

<p><code>viking</code> is the state-space estimation realized by Viking,
generalizing the Kalman Filter to variance uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viking(
  X,
  y,
  theta0,
  P0,
  hata0,
  s0,
  hatb0,
  Sigma0,
  n_iter = 2,
  mc = 10,
  rho_a = 0,
  rho_b = 0,
  learn_sigma = TRUE,
  learn_Q = TRUE,
  K = NULL,
  mode = "diagonal",
  thresh = TRUE,
  phi = logt,
  phi1 = logt1,
  phi2 = logt2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viking_+3A_x">X</code></td>
<td>
<p>the explanatory variables</p>
</td></tr>
<tr><td><code id="viking_+3A_y">y</code></td>
<td>
<p>the time series</p>
</td></tr>
<tr><td><code id="viking_+3A_theta0">theta0</code></td>
<td>
<p>initial <code>theta</code></p>
</td></tr>
<tr><td><code id="viking_+3A_p0">P0</code></td>
<td>
<p>initial <code>P</code></p>
</td></tr>
<tr><td><code id="viking_+3A_hata0">hata0</code></td>
<td>
<p>initial <code>hata</code></p>
</td></tr>
<tr><td><code id="viking_+3A_s0">s0</code></td>
<td>
<p>initial <code>s</code></p>
</td></tr>
<tr><td><code id="viking_+3A_hatb0">hatb0</code></td>
<td>
<p>initial <code>hatb</code></p>
</td></tr>
<tr><td><code id="viking_+3A_sigma0">Sigma0</code></td>
<td>
<p>initial <code>Sigma</code></p>
</td></tr>
<tr><td><code id="viking_+3A_n_iter">n_iter</code></td>
<td>
<p>(optional, default <code>2</code>) number of alternate steps</p>
</td></tr>
<tr><td><code id="viking_+3A_mc">mc</code></td>
<td>
<p>(optional, default <code>10</code>) number of Monte-Carlo samples</p>
</td></tr>
<tr><td><code id="viking_+3A_rho_a">rho_a</code></td>
<td>
<p>(optional, default <code>0</code>) learning rate of <code>a</code></p>
</td></tr>
<tr><td><code id="viking_+3A_rho_b">rho_b</code></td>
<td>
<p>(optional, default <code>0</code>) learning rate of <code>b</code></p>
</td></tr>
<tr><td><code id="viking_+3A_learn_sigma">learn_sigma</code></td>
<td>
<p>(optional, default <code>TRUE</code>) asserts the estimation of <code>a</code></p>
</td></tr>
<tr><td><code id="viking_+3A_learn_q">learn_Q</code></td>
<td>
<p>(optional, default <code>TRUE</code>) asserts the estimation of <code>b</code></p>
</td></tr>
<tr><td><code id="viking_+3A_k">K</code></td>
<td>
<p>(optional, default <code>NULL</code>) if not <code>NULL</code> then it is a multiplicative
factor of the state in the state update</p>
</td></tr>
<tr><td><code id="viking_+3A_mode">mode</code></td>
<td>
<p>(optional, default <code>'diagonal'</code>)</p>
</td></tr>
<tr><td><code id="viking_+3A_thresh">thresh</code></td>
<td>
<p>(optional, default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="viking_+3A_phi">phi</code></td>
<td>
<p>(optional, default <code>logt</code>)</p>
</td></tr>
<tr><td><code id="viking_+3A_phi1">phi1</code></td>
<td>
<p>(optional, default <code>logt1</code>)</p>
</td></tr>
<tr><td><code id="viking_+3A_phi2">phi2</code></td>
<td>
<p>(optional, default <code>logt2</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list composed of the evolving value of all the parameters:
<code>theta_arr, P_arr, q_arr, hata_arr, s_arr, hatb_arr, Sigma_arr</code>
</p>


<h3>References</h3>

<p>J. de Vilmarest, O. Wintenberger (2021), Viking: Variational Bayesian Variance
Tracking. &lt;arXiv:2104.10777&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
