<!DOCTYPE html><html lang="en-US"><head><title>Help for package weibulltools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {weibulltools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#weibulltools-package'><p>weibulltools</p></a></li>
<li><a href='#alloy'><p>Fatigue Life for Alloy T7989 Specimens</p></a></li>
<li><a href='#calculate_ranks'><p>Computation of Johnson Ranks</p></a></li>
<li><a href='#confint_betabinom'><p>Beta Binomial Confidence Bounds for Quantiles and Probabilities</p></a></li>
<li><a href='#confint_betabinom.default'><p>Beta Binomial Confidence Bounds for Quantiles and Probabilities</p></a></li>
<li><a href='#confint_fisher'><p>Fisher's Confidence Bounds for Quantiles and Probabilities</p></a></li>
<li><a href='#confint_fisher.default'><p>Fisher's Confidence Bounds for Quantiles and Probabilities</p></a></li>
<li><a href='#delta_method'><p>Delta Method for Parametric Lifetime Distributions</p></a></li>
<li><a href='#dist_delay'><p>Parameter Estimation of a Delay Distribution</p></a></li>
<li><a href='#dist_delay_register'><p>Parameter Estimation of the Delay in Registration Distribution</p></a></li>
<li><a href='#dist_delay_report'><p>Parameter Estimation of the Delay in Report Distribution</p></a></li>
<li><a href='#dist_delay.default'><p>Parameter Estimation of a Delay Distribution</p></a></li>
<li><a href='#dist_mileage'><p>Parameter Estimation of an Annual Mileage Distribution</p></a></li>
<li><a href='#dist_mileage.default'><p>Parameter Estimation of an Annual Mileage Distribution</p></a></li>
<li><a href='#estimate_cdf'><p>Estimation of Failure Probabilities</p></a></li>
<li><a href='#estimate_cdf.default'><p>Estimation of Failure Probabilities</p></a></li>
<li><a href='#field_data'><p>Field Data</p></a></li>
<li><a href='#johnson_method'><p>Estimation of Failure Probabilities using Johnson's Method</p></a></li>
<li><a href='#kaplan_method'><p>Estimation of Failure Probabilities using the Kaplan-Meier Estimator</p></a></li>
<li><a href='#loglik_function'><p>Log-Likelihood Function for Parametric Lifetime Distributions</p></a></li>
<li><a href='#loglik_function.default'><p>Log-Likelihood Function for Parametric Lifetime Distributions</p></a></li>
<li><a href='#loglik_profiling'><p>Log-Likelihood Profile Function for Parametric Lifetime Distributions with Threshold</p></a></li>
<li><a href='#loglik_profiling.default'><p>Log-Likelihood Profile Function for Parametric Lifetime Distributions with Threshold</p></a></li>
<li><a href='#mcs_delay'><p>Adjustment of Operating Times by Delays using a Monte Carlo Approach</p></a></li>
<li><a href='#mcs_delay_data'><p>MCS Delay Data</p></a></li>
<li><a href='#mcs_delay_register'><p>Adjustment of Operating Times by Delays in Registration using a Monte Carlo</p>
Approach</a></li>
<li><a href='#mcs_delay_report'><p>Adjustment of Operating Times by Delays in Report using a Monte Carlo Approach</p></a></li>
<li><a href='#mcs_delay.default'><p>Adjustment of Operating Times by Delays using a Monte Carlo Approach</p></a></li>
<li><a href='#mcs_delays'><p>Adjustment of Operating Times by Delays using a Monte Carlo Approach</p></a></li>
<li><a href='#mcs_mileage'><p>Simulation of Unknown Covered Distances using a Monte Carlo Approach</p></a></li>
<li><a href='#mcs_mileage_data'><p>MCS Mileage Data</p></a></li>
<li><a href='#mcs_mileage.default'><p>Simulation of Unknown Covered Distances using a Monte Carlo Approach</p></a></li>
<li><a href='#mixmod_em'><p>Weibull Mixture Model Estimation using EM-Algorithm</p></a></li>
<li><a href='#mixmod_em.default'><p>Weibull Mixture Model Estimation using EM-Algorithm</p></a></li>
<li><a href='#mixmod_regression'><p>Mixture Model Identification using Segmented Regression</p></a></li>
<li><a href='#mixmod_regression.default'><p>Mixture Model Identification using Segmented Regression</p></a></li>
<li><a href='#mixture_em_cpp'><p>EM-Algorithm using Newton-Raphson Method</p></a></li>
<li><a href='#ml_estimation'><p>ML Estimation for Parametric Lifetime Distributions</p></a></li>
<li><a href='#ml_estimation.default'><p>ML Estimation for Parametric Lifetime Distributions</p></a></li>
<li><a href='#mr_method'><p>Estimation of Failure Probabilities using Median Ranks</p></a></li>
<li><a href='#nelson_method'><p>Estimation of Failure Probabilities using the Nelson-Aalen Estimator</p></a></li>
<li><a href='#plot_conf'><p>Add Confidence Region(s) for Quantiles and Probabilities</p></a></li>
<li><a href='#plot_conf.default'><p>Add Confidence Region(s) for Quantiles and Probabilities</p></a></li>
<li><a href='#plot_layout'><p>Layout of the Probability Plot</p></a></li>
<li><a href='#plot_mod'><p>Add Estimated Population Line(s) to a Probability Plot</p></a></li>
<li><a href='#plot_mod_mix'><p>Add Estimated Population Lines of a Separated Mixture Model to a</p>
Probability Plot</a></li>
<li><a href='#plot_mod.default'><p>Add Estimated Population Line to a Probability Plot</p></a></li>
<li><a href='#plot_pop'><p>Add Population Line(s) to an Existing Grid</p></a></li>
<li><a href='#plot_prob'><p>Probability Plotting Method for Univariate Lifetime Distributions</p></a></li>
<li><a href='#plot_prob_mix'><p>Probability Plot for Separated Mixture Models</p></a></li>
<li><a href='#plot_prob.default'><p>Probability Plotting Method for Univariate Lifetime Distributions</p></a></li>
<li><a href='#predict_prob'><p>Prediction of Failure Probabilities for Parametric Lifetime Distributions</p></a></li>
<li><a href='#predict_quantile'><p>Prediction of Quantiles for Parametric Lifetime Distributions</p></a></li>
<li><a href='#r_squared_profiling'><p>R-Squared-Profile Function for Parametric Lifetime Distributions with Threshold</p></a></li>
<li><a href='#r_squared_profiling.default'><p>R-Squared-Profile Function for Parametric Lifetime Distributions with Threshold</p></a></li>
<li><a href='#rank_regression'><p>Rank Regression for Parametric Lifetime Distributions</p></a></li>
<li><a href='#rank_regression.default'><p>Rank Regression for Parametric Lifetime Distributions</p></a></li>
<li><a href='#reliability_data'><p>Reliability Data</p></a></li>
<li><a href='#shock'><p>Distance to Failure for Vehicle Shock Absorbers</p></a></li>
<li><a href='#voltage'><p>High Voltage Stress Test for the Dielectric Insulation of Generator armature bars</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Methods for Life Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides statistical methods and visualizations that are often 
             used in reliability engineering. Comprises a compact and easily 
             accessible set of methods and visualization tools that make the 
             examination and adjustment as well as the analysis and interpretation 
             of field data (and bench tests) as simple as possible.
             Non-parametric estimators like Median Ranks, 
             Kaplan-Meier (Abernethy, 2006, &lt;ISBN:978-0-9653062-3-2&gt;), 
             Johnson (Johnson, 1964, &lt;ISBN:978-0444403223&gt;), and Nelson-Aalen 
             for failure probability estimation within samples that contain 
             failures as well as censored data are included.   
             The package supports methods like Maximum Likelihood and Rank Regression, 
             (Genschel and Meeker, 2010, &lt;<a href="https://doi.org/10.1080%2F08982112.2010.503447">doi:10.1080/08982112.2010.503447</a>&gt;) 
             for the estimation of multiple parametric lifetime distributions,  
             as well as the computation of confidence intervals of quantiles and 
             probabilities using the delta method related to Fisher's confidence 
             intervals (Meeker and Escobar, 1998, &lt;ISBN:9780471673279&gt;) and the 
             beta-binomial confidence bounds. 
             If desired, mixture model analysis can be done with segmented regression
             and the EM algorithm.
             Besides the well-known Weibull analysis, the package also contains 
             Monte Carlo methods for the correction and completion of imprecisely 
             recorded or unknown lifetime characteristics.
             (Verband der Automobilindustrie e.V. (VDA), 2016, &lt;ISSN:0943-9412&gt;). 
             Plots are created statically ('ggplot2') or interactively ('plotly') and 
             can be customized with functions of the respective visualization package.
             The graphical technique of probability plotting as well as the addition 
             of regression lines and confidence bounds to existing plots are 
             supported. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tim-tu.github.io/weibulltools/">https://tim-tu.github.io/weibulltools/</a>,
<a href="https://github.com/Tim-TU/weibulltools">https://github.com/Tim-TU/weibulltools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Tim-TU/weibulltools/issues">https://github.com/Tim-TU/weibulltools/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, lifecycle (&ge; 1.0.0), magrittr, plotly, purrr,
Rcpp, sandwich, segmented, tibble</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.18), RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, pillar (&ge; 1.9.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-04 20:48:00 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim-Gunnar Hensel [aut, cre],
  David Barkemeyer [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim-Gunnar Hensel &lt;tim-gunnar.hensel@tu-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-05 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='weibulltools-package'>weibulltools</h2><span id='topic+weibulltools-package'></span><span id='topic+weibulltools'></span>

<h3>Description</h3>

<p>Provides statistical methods and visualizations that are often used in
reliability engineering. Comprises a compact and easily accessible set of
methods and visualization tools that make the examination and adjustment as
well as the analysis and interpretation of field data (and bench tests) as
simple as possible.
</p>
<p>Besides the well-known Weibull analysis, the package supports multiple
lifetime distributions and also contains Monte Carlo methods for the
correction and completion of imprecisely recorded or unknown lifetime
characteristics.
</p>
<p>Plots are created statically
(<code><a href="ggplot2.html#topic+ggplot2-package">ggplot2</a></code>) or
interactively (<code><a href="plotly.html#topic+plot_ly">plotly</a></code>) and can be
customized with functions of the respective visualization package.
</p>

<hr>
<h2 id='alloy'>Fatigue Life for Alloy T7989 Specimens</h2><span id='topic+alloy'></span>

<h3>Description</h3>

<p>A dataset containing the number of cycles of fatigue life for Alloy T7987
specimens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alloy
</code></pre>


<h3>Format</h3>

<p>A tibble with 72 rows and 2 variables:
</p>

<dl>
<dt>cycles</dt><dd><p>Number of cycles (in thousands).</p>
</dd>
<dt>status</dt><dd><p>If specimen failed before 300 thousand cycles <code>1</code> else <code>0</code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical Methods for
Reliability Data, New York: Wiley series in probability and statistics
(1998, p.131)
</p>

<hr>
<h2 id='calculate_ranks'>Computation of Johnson Ranks</h2><span id='topic+calculate_ranks'></span>

<h3>Description</h3>

<p>This function calculates the Johnson ranks which are used to estimate the
failure probabilities in case of (multiple) right censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_ranks(f, n_out, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_ranks_+3A_f">f</code></td>
<td>
<p>a numeric vector indicating the number of failed units for a
specific realization of the lifetime characteristic.</p>
</td></tr>
<tr><td><code id="calculate_ranks_+3A_n_out">n_out</code></td>
<td>
<p>a numeric vector indicating the number of failed and censored
units that have a shorter realization of lifetime characteristic as unit
<em>i</em>.</p>
</td></tr>
<tr><td><code id="calculate_ranks_+3A_n">n</code></td>
<td>
<p>an integer value indicating the sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the computed Johnson ranks.
</p>

<hr>
<h2 id='confint_betabinom'>Beta Binomial Confidence Bounds for Quantiles and Probabilities</h2><span id='topic+confint_betabinom'></span><span id='topic+confint_betabinom.wt_model'></span>

<h3>Description</h3>

<p>This function computes the non-parametric beta binomial confidence bounds (BB)
for quantiles and failure probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confint_betabinom(x, ...)

## S3 method for class 'wt_model'
confint_betabinom(
  x,
  b_lives = c(0.01, 0.1, 0.5),
  bounds = c("two_sided", "lower", "upper"),
  conf_level = 0.95,
  direction = c("y", "x"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint_betabinom_+3A_x">x</code></td>
<td>
<p>A list with class <code>wt_model</code> (and further classes) returned by
<a href="#topic+rank_regression">rank_regression</a>.</p>
</td></tr>
<tr><td><code id="confint_betabinom_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="confint_betabinom_+3A_b_lives">b_lives</code></td>
<td>
<p>A numeric vector indicating the probabilities <code class="reqn">p</code> of the
<code class="reqn">B_p</code>-lives (quantiles) to be considered.</p>
</td></tr>
<tr><td><code id="confint_betabinom_+3A_bounds">bounds</code></td>
<td>
<p>A character string specifying the bound(s) to be computed.</p>
</td></tr>
<tr><td><code id="confint_betabinom_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level of the interval.</p>
</td></tr>
<tr><td><code id="confint_betabinom_+3A_direction">direction</code></td>
<td>
<p>A character string specifying the direction of the confidence
interval. <code>"y"</code> for failure probabilities or <code>"x"</code> for quantiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure is similar to the <em>Median Ranks</em> method but with the
difference that instead of finding the probability for the <em>j</em>-th rank at the
50% level the probability (probabilities) has (have) to be found at the given
confidence level.
</p>


<h3>Value</h3>

<p>A tibble with class <code>wt_confint</code> containing the following columns:
</p>

<ul>
<li> <p><code>x</code> : An ordered sequence of the lifetime characteristic regarding the
failed units, starting at <code>min(x)</code> and ending up at <code>max(x)</code>. With
<code>b_lives = c(0.01, 0.1, 0.5)</code> the 1%, 10% and 50% quantiles are additionally
included in <code>x</code>, but only if the specified probabilities are in the range of
the estimated probabilities.
</p>
</li>
<li> <p><code>rank</code> : Interpolated ranks as a function of probabilities, computed with
the converted approximation formula of <em>Benard</em>.
</p>
</li>
<li> <p><code>prob</code> : An ordered sequence of probabilities with specified <code>b_lives</code>
included.
</p>
</li>
<li> <p><code>lower_bound</code> : Provided, if <code>bounds</code> is one of <code>"two_sided"</code> or <code>"lower"</code>.
Lower confidence limits with respect to <code>direction</code>, i.e. limits for
quantiles or probabilities.
</p>
</li>
<li> <p><code>upper_bound</code> : Provided, if <code>bounds</code> is one of <code>"two_sided"</code> or <code>"upper"</code>.
Upper confidence limits with respect to <code>direction</code>, i.e. limits for
quantiles or probabilities.
</p>
</li>
<li> <p><code>cdf_estimation_method</code> : Method for the estimation of failure probabilities which was specified in <a href="#topic+estimate_cdf">estimate_cdf</a>.
</p>
</li></ul>

<p>Further information is stored in the attributes of this tibble:
</p>

<ul>
<li> <p><code>distribution</code> : Distribution which was specified in <a href="#topic+rank_regression">rank_regression</a>.
</p>
</li>
<li> <p><code>bounds</code> : Specified bound(s).
</p>
</li>
<li> <p><code>direction</code> : Specified direction.
</p>
</li>
<li> <p><code>model_estimation</code> : Input list with class <code>wt_model</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Reliability data preparation:
## Data for two-parametric model:
data_2p &lt;- reliability_data(
  shock,
  x = distance,
  status = status
)

## Data for three-parametric model:
data_3p &lt;- reliability_data(
  alloy,
  x = cycles,
  status = status
)

# Probability estimation:
prob_tbl_2p &lt;- estimate_cdf(
  data_2p,
  methods = "johnson"
)

prob_tbl_3p &lt;- estimate_cdf(
  data_3p,
  methods = "johnson"
)

prob_tbl_mult &lt;- estimate_cdf(
  data_3p,
  methods = c("johnson", "mr")
)

# Model estimation with rank_regression():
rr_2p &lt;- rank_regression(
  prob_tbl_2p,
  distribution = "weibull"
)

rr_3p &lt;- rank_regression(
  prob_tbl_3p,
  distribution = "lognormal3",
  conf_level = 0.90
)

rr_lists &lt;- rank_regression(
  prob_tbl_mult,
  distribution = "loglogistic3",
  conf_level = 0.90
)

# Example 1 - Two-sided 95% confidence interval for probabilities ('y'):
conf_betabin_1 &lt;- confint_betabinom(
  x = rr_2p,
  bounds = "two_sided",
  conf_level = 0.95,
  direction = "y"
)

# Example 2 - One-sided lower/upper 90% confidence interval for quantiles ('x'):
conf_betabin_2_1 &lt;- confint_betabinom(
  x = rr_2p,
  bounds = "lower",
  conf_level = 0.90,
  direction = "x"
)

conf_betabin_2_2 &lt;- confint_betabinom(
  x = rr_2p,
  bounds = "upper",
  conf_level = 0.90,
  direction = "x"
)

# Example 3 - Two-sided 90% confidence intervals for both directions using
# a three-parametric model:
conf_betabin_3_1 &lt;- confint_betabinom(
  x = rr_3p,
  bounds = "two_sided",
  conf_level = 0.90,
  direction = "y"
)

conf_betabin_3_2 &lt;- confint_betabinom(
  x = rr_3p,
  bounds = "two_sided",
  conf_level = 0.90,
  direction = "x"
)

# Example 4 - Confidence intervals if multiple methods in estimate_cdf, i.e.
# "johnson" and "mr", were specified:

conf_betabin_4 &lt;- confint_betabinom(
  x = rr_lists,
  bounds = "two_sided",
  conf_level = 0.99,
  direction = "y"
)

</code></pre>

<hr>
<h2 id='confint_betabinom.default'>Beta Binomial Confidence Bounds for Quantiles and Probabilities</h2><span id='topic+confint_betabinom.default'></span>

<h3>Description</h3>

<p>This function computes the non-parametric beta binomial confidence bounds (BB)
for quantiles and failure probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
confint_betabinom(
  x,
  status,
  dist_params,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2"),
  b_lives = c(0.01, 0.1, 0.5),
  bounds = c("two_sided", "lower", "upper"),
  conf_level = 0.95,
  direction = c("y", "x"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint_betabinom.default_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime data
could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="confint_betabinom.default_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="confint_betabinom.default_+3A_dist_params">dist_params</code></td>
<td>
<p>The parameters (<code>coefficients</code>) returned by <a href="#topic+rank_regression">rank_regression</a>.</p>
</td></tr>
<tr><td><code id="confint_betabinom.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable. Has to be in
line with the specification made in <a href="#topic+rank_regression">rank_regression</a>.</p>
</td></tr>
<tr><td><code id="confint_betabinom.default_+3A_b_lives">b_lives</code></td>
<td>
<p>A numeric vector indicating the probabilities <code class="reqn">p</code> of the
<code class="reqn">B_p</code>-lives (quantiles) to be considered.</p>
</td></tr>
<tr><td><code id="confint_betabinom.default_+3A_bounds">bounds</code></td>
<td>
<p>A character string specifying the bound(s) to be computed.</p>
</td></tr>
<tr><td><code id="confint_betabinom.default_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level of the interval.</p>
</td></tr>
<tr><td><code id="confint_betabinom.default_+3A_direction">direction</code></td>
<td>
<p>A character string specifying the direction of the confidence
interval. <code>"y"</code> for failure probabilities or <code>"x"</code> for quantiles.</p>
</td></tr>
<tr><td><code id="confint_betabinom.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure is similar to the <em>Median Ranks</em> method but with the
difference that instead of finding the probability for the <em>j</em>-th rank at the
50% level the probability (probabilities) has (have) to be found at the given
confidence level.
</p>


<h3>Value</h3>

<p>A tibble with class <code>wt_confint</code> containing the following columns:
</p>

<ul>
<li> <p><code>x</code> : An ordered sequence of the lifetime characteristic regarding the
failed units, starting at <code>min(x)</code> and ending up at <code>max(x)</code>. With
<code>b_lives = c(0.01, 0.1, 0.5)</code> the 1%, 10% and 50% quantiles are additionally
included in <code>x</code>, but only if the specified probabilities are in the range of
the estimated probabilities.
</p>
</li>
<li> <p><code>rank</code> : Interpolated ranks as a function of probabilities, computed with
the converted approximation formula of <em>Benard</em>.
</p>
</li>
<li> <p><code>prob</code> : An ordered sequence of probabilities with specified <code>b_lives</code>
included.
</p>
</li>
<li> <p><code>lower_bound</code> : Provided, if <code>bounds</code> is one of <code>"two_sided"</code> or <code>"lower"</code>.
Lower confidence limits with respect to <code>direction</code>, i.e. limits for
quantiles or probabilities.
</p>
</li>
<li> <p><code>upper_bound</code> : Provided, if <code>bounds</code> is one of <code>"two_sided"</code> or <code>"upper"</code>.
Upper confidence limits with respect to <code>direction</code>, i.e. limits for
quantiles or probabilities.
</p>
</li>
<li> <p><code>cdf_estimation_method</code> : A character that is always <code>NA_character</code>. Only needed for internal use.
</p>
</li></ul>

<p>Further information is stored in the attributes of this tibble:
</p>

<ul>
<li> <p><code>distribution</code> : Distribution which was specified in <a href="#topic+rank_regression">rank_regression</a>.
</p>
</li>
<li> <p><code>bounds</code> : Specified bound(s).
</p>
</li>
<li> <p><code>direction</code> : Specified direction.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+confint_betabinom">confint_betabinom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
obs &lt;- seq(10000, 100000, 10000)
status_1 &lt;- c(0, 1, 1, 0, 0, 0, 1, 0, 1, 0)

cycles &lt;- alloy$cycles
status_2 &lt;- alloy$status

# Probability estimation:
prob_tbl &lt;- estimate_cdf(
  x = obs,
  status = status_1,
  method = "johnson"
)

prob_tbl_2 &lt;- estimate_cdf(
  x = cycles,
  status = status_2,
  method = "johnson"
)

# Model estimation with rank_regression():
rr &lt;- rank_regression(
  x = prob_tbl$x,
  y = prob_tbl$prob,
  status = prob_tbl$status,
  distribution = "weibull",
  conf_level = 0.9
)

rr_2 &lt;- rank_regression(
  x = prob_tbl_2$x,
  y = prob_tbl_2$prob,
  status = prob_tbl_2$status,
  distribution = "lognormal3"
)

# Example 1 - Two-sided 95% confidence interval for probabilities ('y'):
conf_betabin_1 &lt;- confint_betabinom(
  x = prob_tbl$x,
  status = prob_tbl$status,
  dist_params = rr$coefficients,
  distribution = "weibull",
  bounds = "two_sided",
  conf_level = 0.95,
  direction = "y"
)

# Example 2 - One-sided lower/upper 90% confidence interval for quantiles ('x'):
conf_betabin_2_1 &lt;- confint_betabinom(
  x = prob_tbl$x,
  status = prob_tbl$status,
  dist_params = rr$coefficients,
  distribution = "weibull",
  bounds = "lower",
  conf_level = 0.9,
  direction = "x"
)

conf_betabin_2_2 &lt;- confint_betabinom(
  x = prob_tbl$x,
  status = prob_tbl$status,
  dist_params = rr$coefficients,
  distribution = "weibull",
  bounds = "upper",
  conf_level = 0.9,
  direction = "x"
)

# Example 3 - Two-sided 90% confidence intervals for both directions using
# a three-parametric model:

conf_betabin_3_1 &lt;- confint_betabinom(
  x = prob_tbl_2$x,
  status = prob_tbl_2$status,
  dist_params = rr_2$coefficients,
  distribution = "lognormal3",
  bounds = "two_sided",
  conf_level = 0.9,
  direction = "y"
)

conf_betabin_3_2 &lt;- confint_betabinom(
  x = prob_tbl_2$x,
  status = prob_tbl_2$status,
  dist_params = rr_2$coefficients,
  distribution = "lognormal3",
  bounds = "two_sided",
  conf_level = 0.9,
  direction = "x"
)

</code></pre>

<hr>
<h2 id='confint_fisher'>Fisher's Confidence Bounds for Quantiles and Probabilities</h2><span id='topic+confint_fisher'></span><span id='topic+confint_fisher.wt_model'></span>

<h3>Description</h3>

<p>This function computes normal-approximation confidence intervals for quantiles
and failure probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confint_fisher(x, ...)

## S3 method for class 'wt_model'
confint_fisher(
  x,
  b_lives = c(0.01, 0.1, 0.5),
  bounds = c("two_sided", "lower", "upper"),
  conf_level = 0.95,
  direction = c("y", "x"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint_fisher_+3A_x">x</code></td>
<td>
<p>A list with classes <code>wt_model</code> and <code>wt_ml_estimation</code> returned by
<a href="#topic+ml_estimation">ml_estimation</a>.</p>
</td></tr>
<tr><td><code id="confint_fisher_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="confint_fisher_+3A_b_lives">b_lives</code></td>
<td>
<p>A numeric vector indicating the probabilities <code class="reqn">p</code> of the
<code class="reqn">B_p</code>-lives (quantiles) to be considered.</p>
</td></tr>
<tr><td><code id="confint_fisher_+3A_bounds">bounds</code></td>
<td>
<p>A character string specifying the bound(s) to be computed.</p>
</td></tr>
<tr><td><code id="confint_fisher_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level of the interval.</p>
</td></tr>
<tr><td><code id="confint_fisher_+3A_direction">direction</code></td>
<td>
<p>A character string specifying the direction of the confidence
interval. <code>"y"</code> for failure probabilities or <code>"x"</code> for quantiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basis for the calculation of these confidence bounds are the standard errors
obtained by the <a href="#topic+delta_method">delta method</a>.
</p>
<p>The bounds on the probability are determined by the <em>z-procedure</em>. See
'References' for more information on this approach.
</p>


<h3>Value</h3>

<p>A tibble with class <code>wt_confint</code> containing the following columns:
</p>

<ul>
<li> <p><code>x</code> : An ordered sequence of the lifetime characteristic regarding the
failed units, starting at <code>min(x)</code> and ending up at <code>max(x)</code>. With
<code>b_lives = c(0.01, 0.1, 0.5)</code> the 1%, 10% and 50% quantiles are additionally
included in <code>x</code>, but only if the specified probabilities are in the range of
the estimated probabilities.
</p>
</li>
<li> <p><code>prob</code> : An ordered sequence of probabilities with specified <code>b_lives</code>
included.
</p>
</li>
<li> <p><code>std_err</code> : Estimated standard errors with respect to <code>direction</code>.
</p>
</li>
<li> <p><code>lower_bound</code> : Provided, if <code>bounds</code> is one of <code>"two_sided"</code> or <code>"lower"</code>.
Lower confidence limits with respect to <code>direction</code>, i.e. limits for
quantiles or probabilities.
</p>
</li>
<li> <p><code>upper_bound</code> : Provided, if <code>bounds</code> is one of <code>"two_sided"</code> or <code>"upper"</code>.
Upper confidence limits with respect to <code>direction</code>, i.e. limits for
quantiles or probabilities.
</p>
</li>
<li> <p><code>cdf_estimation_method</code> : A character that is always <code>NA_character</code>. Only
needed for internal use.
</p>
</li></ul>

<p>Further information is stored in the attributes of this tibble:
</p>

<ul>
<li> <p><code>distribution</code> : Distribution which was specified in <a href="#topic+ml_estimation">ml_estimation</a>.
</p>
</li>
<li> <p><code>bounds</code> : Specified bound(s).
</p>
</li>
<li> <p><code>direction</code> : Specified direction.
</p>
</li>
<li> <p><code>model_estimation</code> : Input list with classes <code>wt_model</code> and <code>wt_ml_estimation</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reliability data preparation:
## Data for two-parametric model:
data_2p &lt;- reliability_data(
  shock,
  x = distance,
  status = status
)

## Data for three-parametric model:
data_3p &lt;- reliability_data(
  alloy,
  x = cycles,
  status = status
)

# Model estimation with ml_estimation():
ml_2p &lt;- ml_estimation(
  data_2p,
  distribution = "weibull"
)

ml_3p &lt;- ml_estimation(
  data_3p,
  distribution = "lognormal3",
  conf_level = 0.90
)


# Example 1 - Two-sided 95% confidence interval for probabilities ('y'):
conf_fisher_1 &lt;- confint_fisher(
  x = ml_2p,
  bounds = "two_sided",
  conf_level = 0.95,
  direction = "y"
)

# Example 2 - One-sided lower/upper 90% confidence interval for quantiles ('x'):
conf_fisher_2_1 &lt;- confint_fisher(
  x = ml_2p,
  bounds = "lower",
  conf_level = 0.90,
  direction = "x"
)

conf_fisher_2_2 &lt;- confint_fisher(
  x = ml_2p,
  bounds = "upper",
  conf_level = 0.90,
  direction = "x"
)

# Example 3 - Two-sided 90% confidence intervals for both directions using
# a three-parametric model:

conf_fisher_3_1 &lt;- confint_fisher(
  x = ml_3p,
  bounds = "two_sided",
  conf_level = 0.90,
  direction = "y"
)

conf_fisher_3_2 &lt;- confint_fisher(
  x = ml_3p,
  bounds = "two_sided",
  conf_level = 0.90,
  direction = "x"
)

</code></pre>

<hr>
<h2 id='confint_fisher.default'>Fisher's Confidence Bounds for Quantiles and Probabilities</h2><span id='topic+confint_fisher.default'></span>

<h3>Description</h3>

<p>This function computes normal-approximation confidence intervals for quantiles
and failure probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
confint_fisher(
  x,
  status,
  dist_params,
  dist_varcov,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2"),
  b_lives = c(0.01, 0.1, 0.5),
  bounds = c("two_sided", "lower", "upper"),
  conf_level = 0.95,
  direction = c("y", "x"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint_fisher.default_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime data
could be every characteristic influencing the reliability of a product, e.g.
operating time (days/months in service), mileage (km, miles), load cycles.</p>
</td></tr>
<tr><td><code id="confint_fisher.default_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="confint_fisher.default_+3A_dist_params">dist_params</code></td>
<td>
<p>The parameters (<code>coefficients</code>) returned by <a href="#topic+ml_estimation">ml_estimation</a>.</p>
</td></tr>
<tr><td><code id="confint_fisher.default_+3A_dist_varcov">dist_varcov</code></td>
<td>
<p>The variance-covariance-matrix (<code>varcov</code>) returned by
<a href="#topic+ml_estimation">ml_estimation</a>.</p>
</td></tr>
<tr><td><code id="confint_fisher.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable. Has to be in
line with the specification made in <a href="#topic+ml_estimation">ml_estimation</a>.</p>
</td></tr>
<tr><td><code id="confint_fisher.default_+3A_b_lives">b_lives</code></td>
<td>
<p>A numeric vector indicating the probabilities <code class="reqn">p</code> of the
<code class="reqn">B_p</code>-lives (quantiles) to be considered.</p>
</td></tr>
<tr><td><code id="confint_fisher.default_+3A_bounds">bounds</code></td>
<td>
<p>A character string specifying the bound(s) to be computed.</p>
</td></tr>
<tr><td><code id="confint_fisher.default_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level of the interval.</p>
</td></tr>
<tr><td><code id="confint_fisher.default_+3A_direction">direction</code></td>
<td>
<p>A character string specifying the direction of the confidence
interval. <code>"y"</code> for failure probabilities or <code>"x"</code> for quantiles.</p>
</td></tr>
<tr><td><code id="confint_fisher.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basis for the calculation of these confidence bounds are the standard errors
obtained by the <a href="#topic+delta_method">delta method</a>.
</p>
<p>The bounds on the probability are determined by the <em>z-procedure</em>. See
'References' for more information on this approach.
</p>


<h3>Value</h3>

<p>A tibble with class <code>wt_confint</code> containing the following columns:
</p>

<ul>
<li> <p><code>x</code> : An ordered sequence of the lifetime characteristic regarding the
failed units, starting at <code>min(x)</code> and ending up at <code>max(x)</code>. With
<code>b_lives = c(0.01, 0.1, 0.5)</code> the 1%, 10% and 50% quantiles are additionally
included in <code>x</code>, but only if the specified probabilities are in the range of
the estimated probabilities.
</p>
</li>
<li> <p><code>prob</code> : An ordered sequence of probabilities with specified <code>b_lives</code>
included.
</p>
</li>
<li> <p><code>std_err</code> : Estimated standard errors with respect to <code>direction</code>.
</p>
</li>
<li> <p><code>lower_bound</code> : Provided, if <code>bounds</code> is one of <code>"two_sided"</code> or <code>"lower"</code>.
Lower confidence limits with respect to <code>direction</code>, i.e. limits for
quantiles or probabilities.
</p>
</li>
<li> <p><code>upper_bound</code> : Provided, if <code>bounds</code> is one of <code>"two_sided"</code> or <code>"upper"</code>.
Upper confidence limits with respect to <code>direction</code>, i.e. limits for
quantiles or probabilities.
</p>
</li>
<li> <p><code>cdf_estimation_method</code> : A character that is always <code>NA_character</code>. Only
needed for internal use.
</p>
</li></ul>

<p>Further information is stored in the attributes of this tibble:
</p>

<ul>
<li> <p><code>distribution</code> : Distribution which was specified in <a href="#topic+ml_estimation">ml_estimation</a>.
</p>
</li>
<li> <p><code>bounds</code> : Specified bound(s).
</p>
</li>
<li> <p><code>direction</code> : Specified direction.
</p>
</li></ul>



<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>See Also</h3>

<p><a href="#topic+confint_fisher">confint_fisher</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
obs &lt;- seq(10000, 100000, 10000)
status_1 &lt;- c(0, 1, 1, 0, 0, 0, 1, 0, 1, 0)

cycles &lt;- alloy$cycles
status_2 &lt;- alloy$status


# Model estimation with ml_estimation():
ml &lt;- ml_estimation(
  x = obs,
  status = status_1,
  distribution = "weibull",
  conf_level = 0.90
)

ml_2 &lt;- ml_estimation(
  x = cycles,
  status = status_2,
  distribution = "lognormal3"
)

# Example 1 - Two-sided 95% confidence interval for probabilities ('y'):
conf_fisher_1 &lt;- confint_fisher(
  x = obs,
  status = status_1,
  dist_params = ml$coefficients,
  dist_varcov = ml$varcov,
  distribution = "weibull",
  bounds = "two_sided",
  conf_level = 0.95,
  direction = "y"
)

# Example 2 - One-sided lower/upper 90% confidence interval for quantiles ('x'):
conf_fisher_2_1 &lt;- confint_fisher(
  x = obs,
  status = status_1,
  dist_params = ml$coefficients,
  dist_varcov = ml$varcov,
  distribution = "weibull",
  bounds = "lower",
  conf_level = 0.90,
  direction = "x"
)

conf_fisher_2_2 &lt;- confint_fisher(
  x = obs,
  status = status_1,
  dist_params = ml$coefficients,
  dist_varcov = ml$varcov,
  distribution = "weibull",
  bounds = "upper",
  conf_level = 0.90,
  direction = "x"
)

# Example 3 - Two-sided 90% confidence intervals for both directions using
# a three-parametric model:

conf_fisher_3_1 &lt;- confint_fisher(
  x = cycles,
  status = status_2,
  dist_params = ml_2$coefficients,
  dist_varcov = ml_2$varcov,
  distribution = "lognormal3",
  bounds = "two_sided",
  conf_level = 0.90,
  direction = "y"
)

conf_fisher_3_2 &lt;- confint_fisher(
  x = cycles,
  status = status_2,
  dist_params = ml_2$coefficients,
  dist_varcov = ml_2$varcov,
  distribution = "lognormal3",
  bounds = "two_sided",
  conf_level = 0.90,
  direction = "x"
)

</code></pre>

<hr>
<h2 id='delta_method'>Delta Method for Parametric Lifetime Distributions</h2><span id='topic+delta_method'></span>

<h3>Description</h3>

<p>This function applies the <em>delta method</em> to a parametric lifetime distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_method(
  x,
  dist_params,
  dist_varcov,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2"),
  direction = c("y", "x"),
  p = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta_method_+3A_x">x</code></td>
<td>
<p>A numeric vector of probabilities or quantiles. If the standard errors
of quantiles should be determined the corresponding probabilities have to be
specified, and if the standard errors of standardized quantiles (z-values)
should be computed corresponding quantiles are required.</p>
</td></tr>
<tr><td><code id="delta_method_+3A_dist_params">dist_params</code></td>
<td>
<p>The parameters (<code>coefficients</code>) returned by <a href="#topic+ml_estimation">ml_estimation</a>.</p>
</td></tr>
<tr><td><code id="delta_method_+3A_dist_varcov">dist_varcov</code></td>
<td>
<p>The variance-covariance-matrix (<code>varcov</code>) returned by
<a href="#topic+ml_estimation">ml_estimation</a>.</p>
</td></tr>
<tr><td><code id="delta_method_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable. Has to be in
line with the specification made in <a href="#topic+ml_estimation">ml_estimation</a>.</p>
</td></tr>
<tr><td><code id="delta_method_+3A_direction">direction</code></td>
<td>
<p>A character string specifying for which quantity the standard
errors are calculated. <code>"y"</code> if <code>x</code> are quantiles or <code>"x"</code> if <code>x</code> are probabilities.</p>
</td></tr>
<tr><td><code id="delta_method_+3A_p">p</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>: Use <code>x</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delta method estimates the standard errors for quantities that can be
written as non-linear functions of ML estimators. Hence, the parameters as
well as the variance-covariance matrix of these quantities have to be estimated
with <a href="#topic+ml_estimation">maximum likelihood</a>.
</p>
<p>The estimated standard errors are used to calculate Fisher's (normal
approximation) confidence intervals. For confidence bounds on the probability,
standard errors of the standardized quantiles (<code>direction = "y"</code>) have to be
computed (<em>z-procedure</em>) and for bounds on quantiles, standard errors of
quantiles (<code>direction = "x"</code>) are required. For more information see
<a href="#topic+confint_fisher">confint_fisher</a>.
</p>


<h3>Value</h3>

<p>A numeric vector of estimated standard errors for quantiles or
standardized quantiles (<em>z-values</em>).
</p>


<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reliability data preparation:
data &lt;- reliability_data(
  shock,
  x = distance,
  status = status
)

# Parameter estimation using maximum likelihood:
mle &lt;- ml_estimation(
  data,
  distribution = "weibull",
  conf_level = 0.95
)

# Example 1 - Standard errors of standardized quantiles:
delta_y &lt;- delta_method(
  x = shock$distance,
  dist_params = mle$coefficients,
  dist_varcov = mle$varcov,
  distribution = "weibull",
  direction = "y"
)

# Example 2 - Standard errors of quantiles:
delta_x &lt;- delta_method(
  x = seq(0.01, 0.99, 0.01),
  dist_params = mle$coefficients,
  dist_varcov = mle$varcov,
  distribution = "weibull",
  direction = "x"
)

</code></pre>

<hr>
<h2 id='dist_delay'>Parameter Estimation of a Delay Distribution</h2><span id='topic+dist_delay'></span><span id='topic+dist_delay.wt_mcs_delay_data'></span>

<h3>Description</h3>

<p>This function models a delay (in days) random variable (e.g. in logistic,
registration, report) using a supposed continuous distribution. First, the
row-wise differences in days of the related date columns are calculated and then
the parameter(s) of the assumed distribution is (are) estimated with maximum
likelihood. See 'Details' for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_delay(...)

## S3 method for class 'wt_mcs_delay_data'
dist_delay(..., x, distribution = c("lognormal", "exponential"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_delay_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="dist_delay_+3A_x">x</code></td>
<td>
<p>A <code>tibble</code> with class <code>wt_mcs_delay_data</code> returned by <a href="#topic+mcs_delay_data">mcs_delay_data</a>.</p>
</td></tr>
<tr><td><code id="dist_delay_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the respective delay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution parameter(s) is (are) determined on the basis of complete
cases, i.e. there is no <code>NA</code> (row-wise) in one of the related date columns.
Time differences less than or equal to zero are not considered as well.
</p>


<h3>Value</h3>

<p>A list with class <code>wt_delay_estimation</code> which contains:
</p>

<ul>
<li> <p><code>coefficients</code> : A named vector of estimated parameter(s).
</p>
</li>
<li> <p><code>delay</code> : A numeric vector of element-wise computed differences in days.
</p>
</li>
<li> <p><code>distribution</code> : Specified distribution.
</p>
</li></ul>

<p>If more than one delay was considered in <a href="#topic+mcs_delay_data">mcs_delay_data</a>, the resulting output
is a list with class <code>wt_delay_estimation_list</code>. In this case each list element
has class <code>wt_delay_estimation</code> and the items listed above, are included.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MCS data preparation:
## Data for delay in registration:
mcs_tbl_1 &lt;- mcs_delay_data(
  field_data,
  date_1 = production_date,
  date_2 = registration_date,
  time = dis,
  status = status,
  id = vin
)

## Data for delay in report:
mcs_tbl_2 &lt;- mcs_delay_data(
  field_data,
  date_1 = repair_date,
  date_2 = report_date,
  time = dis,
  status = status,
  id = vin
)

## Data for both delays:
mcs_tbl_both &lt;- mcs_delay_data(
  field_data,
  date_1 = c(production_date, repair_date),
  date_2 = c(registration_date, report_date),
  time = dis,
  status = status,
  id = vin
)

# Example 1 - Delay in registration:
params_delay_regist  &lt;- dist_delay(
  x = mcs_tbl_1,
  distribution = "lognormal"
)

# Example 2 - Delay in report:
params_delay_report  &lt;- dist_delay(
  x = mcs_tbl_2,
  distribution = "exponential"
)

# Example 3 - Delays in registration and report with same distribution:
params_delays  &lt;- dist_delay(
  x = mcs_tbl_both,
  distribution = "lognormal"
)

# Example 4 - Delays in registration and report with different distributions:
params_delays_2  &lt;- dist_delay(
  x = mcs_tbl_both,
  distribution = c("lognormal", "exponential")
)

</code></pre>

<hr>
<h2 id='dist_delay_register'>Parameter Estimation of the Delay in Registration Distribution</h2><span id='topic+dist_delay_register'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><code>dist_delay_register()</code> is no longer under active development, switching to
<a href="#topic+dist_delay">dist_delay</a> is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_delay_register(date_prod, date_register, distribution = "lognormal")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_delay_register_+3A_date_prod">date_prod</code></td>
<td>
<p>A vector of class <code>character</code> or <code>Date</code>, in the
format &quot;yyyy-mm-dd&quot;, indicating the date of production of a unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="dist_delay_register_+3A_date_register">date_register</code></td>
<td>
<p>A vector of class <code>character</code> or <code>Date</code>, in
the format &quot;yyyy-mm-dd&quot;, indicating the date of registration of a unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="dist_delay_register_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable. Only
<code>"lognormal"</code>is implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function introduces a delay random variable by calculating the time
difference between the registration and production date for the sample units
and afterwards estimates the parameter(s) of a supposed distribution,
using maximum likelihood.
</p>


<h3>Value</h3>

<p>A named vector of estimated parameters for the specified
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date_of_production   &lt;- c("2014-07-28", "2014-02-17", "2014-07-14",
                          "2014-06-26", "2014-03-10", "2014-05-14",
                          "2014-05-06", "2014-03-07", "2014-03-09",
                          "2014-04-13", "2014-05-20", "2014-07-07",
                          "2014-01-27", "2014-01-30", "2014-03-17",
                          "2014-02-09", "2014-04-14", "2014-04-20",
                          "2014-03-13", "2014-02-23", "2014-04-03",
                          "2014-01-08", "2014-01-08")
date_of_registration &lt;- c(NA, "2014-03-29", "2014-12-06", "2014-09-09",
                          NA, NA, "2014-06-16", NA, "2014-05-23",
                          "2014-05-09", "2014-05-31", NA, "2014-04-13",
                          NA, NA, "2014-03-12", NA, "2014-06-02",
                          NA, "2014-03-21", "2014-06-19", NA, NA)

params_delay_regist  &lt;- dist_delay_register(
  date_prod = date_of_production,
  date_register = date_of_registration,
  distribution = "lognormal"
)

</code></pre>

<hr>
<h2 id='dist_delay_report'>Parameter Estimation of the Delay in Report Distribution</h2><span id='topic+dist_delay_report'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><code>dist_delay_report()</code>is no longer under active development, switching to
<a href="#topic+dist_delay">dist_delay</a> is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_delay_report(date_repair, date_report, distribution = "lognormal")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_delay_report_+3A_date_repair">date_repair</code></td>
<td>
<p>a vector of class <code>character</code> or <code>Date</code>, in the
format &quot;yyyy-mm-dd&quot;, indicating the date of repair of a failed unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="dist_delay_report_+3A_date_report">date_report</code></td>
<td>
<p>a vector of class <code>character</code> or <code>Date</code>, in the
format &quot;yyyy-mm-dd&quot;, indicating the date of report of a failed unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="dist_delay_report_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable. Only
<code>"lognormal"</code>is implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function introduces a delay random variable by calculating the time
difference between the report and repair date for the sample units
and afterwards estimates the parameter(s) of a supposed distribution,
using maximum likelihood.
</p>


<h3>Value</h3>

<p>A named vector of estimated parameters for the specified
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date_of_repair &lt;- c(NA, "2014-09-15", "2015-07-04", "2015-04-10", NA,
                    NA, "2015-04-24", NA, "2015-04-25", "2015-04-24",
                    "2015-06-12", NA, "2015-05-04", NA, NA,
                    "2015-05-22", NA, "2015-09-17", NA, "2015-08-15",
                    "2015-11-26", NA, NA)

date_of_report &lt;- c(NA, "2014-10-09", "2015-08-28", "2015-04-15", NA,
                    NA, "2015-05-16", NA, "2015-05-28", "2015-05-15",
                    "2015-07-11", NA, "2015-08-14", NA, NA,
                    "2015-06-05", NA, "2015-10-17", NA, "2015-08-21",
                    "2015-12-02", NA, NA)

params_delay_report  &lt;- dist_delay_report(
  date_repair = date_of_repair,
  date_report = date_of_report,
  distribution = "lognormal"
)

</code></pre>

<hr>
<h2 id='dist_delay.default'>Parameter Estimation of a Delay Distribution</h2><span id='topic+dist_delay.default'></span>

<h3>Description</h3>

<p>This function models a delay (in days) random variable (e.g. in logistic,
registration, report) using a supposed continuous distribution. First, the
element-wise differences in days of both vectors <code>date_1</code> and <code>date_2</code> are
calculated and then the parameter(s) of the assumed
distribution is (are) estimated with maximum likelihood. See 'Details' for
more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
dist_delay(..., date_1, date_2, distribution = c("lognormal", "exponential"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_delay.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="dist_delay.default_+3A_date_1">date_1</code></td>
<td>
<p>A vector of class <code>character</code> or <code>Date</code>, in the format &quot;yyyy-mm-dd&quot;,
representing the earlier of the two dates belonging to a particular delay.
Use <code>NA</code> for missing elements.
</p>
<p>If more than one delay is to be considered, use a list where the first element
is the earlier date of the first delay, the second element is the earlier date
of the second delay, and so forth (see 'Examples').</p>
</td></tr>
<tr><td><code id="dist_delay.default_+3A_date_2">date_2</code></td>
<td>
<p>A vector of class <code>character</code> or <code>Date</code> in the format &quot;yyyy-mm-dd&quot;.
<code>date_2</code> is the counterpart of <code>date_1</code> and is used the same as <code>date_1</code>, just with
the later date(s) of the particular delay(s). Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="dist_delay.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the respective delay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution parameter(s) is (are) determined on the basis of complete
cases, i.e. there is no <code>NA</code> in one of the related vector elements
<code>c(date_1[i], date_2[i])</code>. Time differences less than or equal to zero are
not considered as well.
</p>


<h3>Value</h3>

<p>A list with class <code>wt_delay_estimation</code> which contains:
</p>

<ul>
<li> <p><code>coefficients</code> : A named vector of estimated parameter(s).
</p>
</li>
<li> <p><code>delay</code> : A numeric vector of element-wise computed differences in days.
</p>
</li>
<li> <p><code>distribution</code> : Specified distribution.
</p>
</li></ul>

<p>If more than one delay was considered, the resulting output is a list with class
<code>wt_delay_estimation_list</code>. In this case each list element has class
<code>wt_delay_estimation</code> and the items listed above, are included.
</p>


<h3>See Also</h3>

<p><a href="#topic+dist_delay">dist_delay</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 - Delay in registration:
params_delay_regist  &lt;- dist_delay(
  date_1 = field_data$production_date,
  date_2 = field_data$registration_date,
  distribution = "lognormal"
)

# Example 2 - Delay in report:
params_delay_report  &lt;- dist_delay(
  date_1 = field_data$repair_date,
  date_2 = field_data$report_date,
  distribution = "exponential"
)

# Example 3 - Delays in registration and report with same distribution:
params_delays  &lt;- dist_delay(
  date_1 = list(field_data$production_date, field_data$repair_date),
  date_2 = list(field_data$registration_date, field_data$report_date),
  distribution = "lognormal"
)

# Example 4 - Delays in registration and report with different distributions:
params_delays_2  &lt;- dist_delay(
  date_1 = list(field_data$production_date, field_data$repair_date),
  date_2 = list(field_data$registration_date, field_data$report_date),
  distribution = c("lognormal", "exponential")
)

</code></pre>

<hr>
<h2 id='dist_mileage'>Parameter Estimation of an Annual Mileage Distribution</h2><span id='topic+dist_mileage'></span><span id='topic+dist_mileage.wt_mcs_mileage_data'></span>

<h3>Description</h3>

<p>This function models a mileage random variable on an annual basis with respect
to a supposed continuous distribution. First, the distances are calculated for
one year (365 days) using a linear relationship between the distance and
operating time. Second, the parameter(s) of the assumed distribution are
estimated with maximum likelihood. See 'Details' for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_mileage(x, ...)

## S3 method for class 'wt_mcs_mileage_data'
dist_mileage(x, distribution = c("lognormal", "exponential"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_mileage_+3A_x">x</code></td>
<td>
<p>A <code>tibble</code> of class <code>wt_mcs_mileage_data</code> returned by <a href="#topic+mcs_mileage_data">mcs_mileage_data</a>.</p>
</td></tr>
<tr><td><code id="dist_mileage_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="dist_mileage_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the annual mileage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution parameter(s) is (are) determined on the basis of complete
cases, i.e. there is no <code>NA</code> (row-wise) in one of the related columns <code>mileage</code>
and <code>time</code>. Distances and operating times less than or equal to zero are not
considered as well.
</p>
<p><strong>Assumption of linear relationship</strong>: Imagine a component in a vehicle
has endured a distance of 25000 kilometers (km) in 500 days (d), the annual
distance of this unit is </p>
<p style="text-align: center;"><code class="reqn">25000 km \cdot (\frac{365 d} {500 d}) = 18250 km</code>
</p>



<h3>Value</h3>

<p>A list with class <code>wt_mileage_estimation</code> which contains:
</p>

<ul>
<li> <p><code>coefficients</code> : A named vector of estimated parameter(s).
</p>
</li>
<li> <p><code>miles_annual</code> : A numeric vector of element-wise computed annual distances
using the linear relationship described in 'Details'.
</p>
</li>
<li> <p><code>distribution</code> : Specified distribution.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># MCS data preparation:
mcs_tbl &lt;- mcs_mileage_data(
  field_data,
  mileage = mileage,
  time = dis,
  status = status,
  id = vin
)

# Example 1 - Assuming lognormal annual mileage distribution:
params_mileage_annual &lt;- dist_mileage(
  x = mcs_tbl,
  distribution = "lognormal"
)

# Example 2 - Assuming exponential annual mileage distribution:
params_mileage_annual_2 &lt;- dist_mileage(
  x = mcs_tbl,
  distribution = "exponential"
)

</code></pre>

<hr>
<h2 id='dist_mileage.default'>Parameter Estimation of an Annual Mileage Distribution</h2><span id='topic+dist_mileage.default'></span>

<h3>Description</h3>

<p>This function models a mileage random variable on an annual basis with respect
to a supposed continuous distribution. First, the distances are calculated for
one year (365 days) using a linear relationship between the distance and
operating time. Second, the parameter(s) of the assumed distribution are
estimated with maximum likelihood. See 'Details' for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
dist_mileage(x, time, distribution = c("lognormal", "exponential"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_mileage.default_+3A_x">x</code></td>
<td>
<p>A numeric vector of distances covered. Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="dist_mileage.default_+3A_time">time</code></td>
<td>
<p>A numeric vector of operating times. Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="dist_mileage.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the annual mileage.</p>
</td></tr>
<tr><td><code id="dist_mileage.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution parameter(s) is (are) determined on the basis of complete cases,
i.e. there is no <code>NA</code> in one of the related vector elements
<code>c(mileage[i], time[i])</code>. Distances and operating times less than or equal
to zero are not considered as well.
</p>
<p><strong>Assumption of linear relationship</strong>: Imagine a component in a vehicle
has endured a distance of 25000 kilometers (km) in 500 days (d), the annual
distance of this unit is </p>
<p style="text-align: center;"><code class="reqn">25000 km \cdot (\frac{365 d} {500 d}) = 18250 km</code>
</p>



<h3>Value</h3>

<p>A list with class <code>wt_mileage_estimation</code> which contains:
</p>

<ul>
<li> <p><code>coefficients</code> : A named vector of estimated parameter(s).
</p>
</li>
<li> <p><code>miles_annual</code> : A numeric vector of element-wise computed annual distances
using the linear relationship described in 'Details'.
</p>
</li>
<li> <p><code>distribution</code> : Specified distribution.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+dist_mileage">dist_mileage</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 - Assuming lognormal annual mileage distribution:
params_mileage_annual &lt;- dist_mileage(
  x = field_data$mileage,
  time = field_data$dis,
  distribution = "lognormal"
)

# Example 2 - Assuming exponential annual mileage distribution:
params_mileage_annual_2 &lt;- dist_mileage(
  x = field_data$mileage,
  time = field_data$dis,
  distribution = "exponential"
)

</code></pre>

<hr>
<h2 id='estimate_cdf'>Estimation of Failure Probabilities</h2><span id='topic+estimate_cdf'></span><span id='topic+estimate_cdf.wt_reliability_data'></span>

<h3>Description</h3>

<p>This function applies a non-parametric method to estimate the failure
probabilities of complete data taking (multiple) right-censored observations
into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_cdf(x, ...)

## S3 method for class 'wt_reliability_data'
estimate_cdf(
  x,
  methods = c("mr", "johnson", "kaplan", "nelson"),
  options = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_cdf_+3A_x">x</code></td>
<td>
<p>A tibble with class <code>wt_reliability_data</code> returned by <a href="#topic+reliability_data">reliability_data</a>.</p>
</td></tr>
<tr><td><code id="estimate_cdf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="estimate_cdf_+3A_methods">methods</code></td>
<td>
<p>One or multiple methods of <code>"mr"</code>, <code>"johnson"</code>, <code>"kaplan"</code> or
<code>"nelson"</code> used for the estimation of failure probabilities. See 'Details'.</p>
</td></tr>
<tr><td><code id="estimate_cdf_+3A_options">options</code></td>
<td>
<p>A list of named options. See 'Options'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One or multiple techniques can be used for the <code>methods</code> argument:
</p>

<ul>
<li> <p><code>"mr"</code> : Method <em>Median Ranks</em> is used to estimate the failure probabilities
of failed units without considering censored items. Tied observations can be
handled in three ways (See 'Options'):
</p>

<ul>
<li> <p><code>"max"</code> : Highest observed rank is assigned to tied observations.
</p>
</li>
<li> <p><code>"min"</code> : Lowest observed rank is assigned to tied observations.
</p>
</li>
<li> <p><code>"average"</code> : Mean rank is assigned to tied observations.
</p>
</li></ul>

<p>Two formulas can be used to determine cumulative failure probabilities
<em>F(t)</em> (See 'Options'):
</p>

<ul>
<li> <p><code>"benard"</code> : Benard's approximation for Median Ranks.
</p>
</li>
<li> <p><code>"invbeta"</code> : Exact Median Ranks using the inverse beta distribution.
</p>
</li></ul>

</li>
<li> <p><code>"johnson"</code> : The <em>Johnson</em> method is used to estimate the failure
probabilities of failed units, taking censored units into account. Compared
to complete data, correction of probabilities is done by the computation of
adjusted ranks. Two formulas can be used to determine cumulative failure
probabilities <em>F(t)</em> (See 'Options'):
</p>

<ul>
<li> <p><code>"benard"</code> : Benard's approximation for Median Ranks.
</p>
</li>
<li> <p><code>"invbeta"</code> : Exact Median Ranks using the inverse beta distribution.
</p>
</li></ul>

</li>
<li> <p><code>"kaplan"</code> : The method of <em>Kaplan</em> and <em>Meier</em> is used to estimate the
survival function <em>S(t)</em> with respect to (multiple) right censored data.
The complement of <em>S(t)</em>, i.e. <em>F(t)</em>, is returned. In contrast to the
original <em>Kaplan-Meier</em> estimator, one modification is made (see 'References').
</p>
</li>
<li> <p><code>"nelson"</code> : The <em>Nelson-Aalen</em> estimator models the cumulative hazard rate
function in case of (multiple) right censored data. Equating the formal
definition of the hazard rate with that according to <em>Nelson-Aalen</em> results
in a formula for the calculation of failure probabilities.
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble with class <code>wt_cdf_estimation</code> containing the following columns:
</p>

<ul>
<li> <p><code>id</code> : Identification for every unit.
</p>
</li>
<li> <p><code>x</code> : Lifetime characteristic.
</p>
</li>
<li> <p><code>status</code> : Binary data (0 or 1) indicating whether a unit is a right
censored observation (= 0) or a failure (= 1).
</p>
</li>
<li> <p><code>rank</code> : The (computed) ranks. Determined for methods <code>"mr"</code> and <code>"johnson"</code>,
filled with <code>NA</code> for other methods or if <code>status = 0</code>.
</p>
</li>
<li> <p><code>prob</code> : Estimated failure probabilities, <code>NA</code> if <code>status = 0</code>.
</p>
</li>
<li> <p><code>cdf_estimation_method</code> : Specified method for the estimation of failure
probabilities.
</p>
</li></ul>



<h3>Options</h3>

<p>Argument <code>options</code> is a named list of options:</p>

<table>
<tr>
 <td style="text-align: left;">
   Method </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Value </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mr</code> </td><td style="text-align: left;"> <code>mr_method</code> </td><td style="text-align: left;"> <code>"benard"</code> (default) or <code>"invbeta"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mr</code> </td><td style="text-align: left;"> <code>mr_ties.method</code> </td><td style="text-align: left;"> <code>"max"</code> (default), <code>"min"</code> or <code>"average"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>johnson</code> </td><td style="text-align: left;"> <code>johnson_method</code> </td><td style="text-align: left;"> <code>"benard"</code> (default) or <code>"invbeta"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p><em>NIST/SEMATECH e-Handbook of Statistical Methods</em>,
<em>8.2.1.5. Empirical model fitting - distribution free (Kaplan-Meier) approach</em>,
<a href="https://www.itl.nist.gov/div898/handbook/apr/section2/apr215.htm">NIST SEMATECH</a>,
December 3, 2020
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reliability data:
data &lt;- reliability_data(
  alloy,
  x = cycles,
  status = status
)

# Example 1 - Johnson method:
prob_tbl &lt;- estimate_cdf(
  x = data,
  methods = "johnson"
)

# Example 2 - Multiple methods:
prob_tbl_2 &lt;- estimate_cdf(
  x = data,
  methods = c("johnson", "kaplan", "nelson")
)

# Example 3 - Method 'mr' with options:
prob_tbl_3 &lt;- estimate_cdf(
  x = data,
  methods = "mr",
  options = list(
    mr_method = "invbeta",
    mr_ties.method = "average"
  )
)

# Example 4 - Multiple methods and options:
prob_tbl_4 &lt;- estimate_cdf(
  x = data,
  methods = c("mr", "johnson"),
  options = list(
    mr_ties.method = "max",
    johnson_method = "invbeta"
  )
)

</code></pre>

<hr>
<h2 id='estimate_cdf.default'>Estimation of Failure Probabilities</h2><span id='topic+estimate_cdf.default'></span>

<h3>Description</h3>

<p>This function applies a non-parametric method to estimate the failure
probabilities of complete data taking (multiple) right-censored observations
into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
estimate_cdf(
  x,
  status,
  id = NULL,
  method = c("mr", "johnson", "kaplan", "nelson"),
  options = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_cdf.default_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime
data could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="estimate_cdf.default_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether unit <em>i</em>
is a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="estimate_cdf.default_+3A_id">id</code></td>
<td>
<p>A vector for the identification of every unit. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="estimate_cdf.default_+3A_method">method</code></td>
<td>
<p>Method used for the estimation of failure probabilities. See
'Details'.</p>
</td></tr>
<tr><td><code id="estimate_cdf.default_+3A_options">options</code></td>
<td>
<p>A list of named options. See 'Options'.</p>
</td></tr>
<tr><td><code id="estimate_cdf.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following techniques can be used for the <code>method</code> argument:
</p>

<ul>
<li> <p><code>"mr"</code> : Method <em>Median Ranks</em> is used to estimate the failure probabilities
of failed units without considering censored items. Tied observations can be
handled in three ways (See 'Options'):
</p>

<ul>
<li> <p><code>"max"</code> : Highest observed rank is assigned to tied observations.
</p>
</li>
<li> <p><code>"min"</code> : Lowest observed rank is assigned to tied observations.
</p>
</li>
<li> <p><code>"average"</code> : Mean rank is assigned to tied observations.
</p>
</li></ul>

<p>Two formulas can be used to determine cumulative failure probabilities
<em>F(t)</em> (See 'Options'):
</p>

<ul>
<li> <p><code>"benard"</code> : Benard's approximation for Median Ranks.
</p>
</li>
<li> <p><code>"invbeta"</code> : Exact Median Ranks using the inverse beta distribution.
</p>
</li></ul>

</li>
<li> <p><code>"johnson"</code> : The <em>Johnson</em> method is used to estimate the failure
probabilities of failed units, taking censored units into account. Compared
to complete data, correction of probabilities is done by the computation of
adjusted ranks. Two formulas can be used to determine cumulative failure
probabilities <em>F(t)</em> (See 'Options'):
</p>

<ul>
<li> <p><code>"benard"</code> : Benard's approximation for Median Ranks.
</p>
</li>
<li> <p><code>"invbeta"</code> : Exact Median Ranks using the inverse beta distribution.
</p>
</li></ul>

</li>
<li> <p><code>"kaplan"</code> : The method of <em>Kaplan</em> and <em>Meier</em> is used to estimate the
survival function <em>S(t)</em> with respect to (multiple) right censored data.
The complement of <em>S(t)</em>, i.e. <em>F(t)</em>, is returned. In contrast to the
original <em>Kaplan-Meier</em> estimator, one modification is made (see 'References').
</p>
</li>
<li> <p><code>"nelson"</code> : The <em>Nelson-Aalen</em> estimator models the cumulative hazard rate
function in case of (multiple) right censored data. Equating the formal
definition of the hazard rate with that according to <em>Nelson-Aalen</em> results
in a formula for the calculation of failure probabilities.
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble with class <code>wt_cdf_estimation</code> containing the following columns:
</p>

<ul>
<li> <p><code>id</code> : Identification for every unit.
</p>
</li>
<li> <p><code>x</code> : Lifetime characteristic.
</p>
</li>
<li> <p><code>status</code> : Binary data (0 or 1) indicating whether a unit is a right
censored observation (= 0) or a failure (= 1).
</p>
</li>
<li> <p><code>rank</code> : The (computed) ranks. Determined for methods <code>"mr"</code> and <code>"johnson"</code>,
filled with <code>NA</code> for other methods or if <code>status = 0</code>.
</p>
</li>
<li> <p><code>prob</code> : Estimated failure probabilities, <code>NA</code> if <code>status = 0</code>.
</p>
</li>
<li> <p><code>cdf_estimation_method</code> : Specified method for the estimation of failure
probabilities.
</p>
</li></ul>



<h3>Options</h3>

<p>Argument <code>options</code> is a named list of options:</p>

<table>
<tr>
 <td style="text-align: left;">
   Method </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Value </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mr</code> </td><td style="text-align: left;"> <code>mr_method</code> </td><td style="text-align: left;"> <code>"benard"</code> (default) or <code>"invbeta"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mr</code> </td><td style="text-align: left;"> <code>mr_ties.method</code> </td><td style="text-align: left;"> <code>"max"</code> (default), <code>"min"</code> or <code>"average"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>johnson</code> </td><td style="text-align: left;"> <code>johnson_method</code> </td><td style="text-align: left;"> <code>"benard"</code> (default) or <code>"invbeta"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p><em>NIST/SEMATECH e-Handbook of Statistical Methods</em>,
<em>8.2.1.5. Empirical model fitting - distribution free (Kaplan-Meier) approach</em>,
<a href="https://www.itl.nist.gov/div898/handbook/apr/section2/apr215.htm">NIST SEMATECH</a>,
December 3, 2020
</p>


<h3>See Also</h3>

<p><a href="#topic+estimate_cdf">estimate_cdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
cycles &lt;- alloy$cycles
status &lt;- alloy$status

# Example 1 - Johnson method:
prob_tbl &lt;- estimate_cdf(
  x = cycles,
  status = status,
  method = "johnson"
)


# Example 2 - Method 'mr' with options:
prob_tbl_2 &lt;- estimate_cdf(
  x = cycles,
  status = status,
  method = "mr",
  options = list(
    mr_method = "invbeta",
    mr_ties.method = "average"
  )
)

</code></pre>

<hr>
<h2 id='field_data'>Field Data</h2><span id='topic+field_data'></span>

<h3>Description</h3>

<p>An illustrative field dataset that contains a variety of variables commonly
collected in the automotive sector.
</p>
<p>The dataset has complete information about failed and incomplete information
about intact vehicles. See 'Format' and 'Details' for further insights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>field_data
</code></pre>


<h3>Format</h3>

<p>A tibble with 10,684 rows and 20 variables:
</p>

<dl>
<dt>vin</dt><dd><p>Vehicle identification number.</p>
</dd>
<dt>dis</dt><dd><p>Days in service.</p>
</dd>
<dt>mileage</dt><dd><p>Distances covered, which are unknown for censored units.</p>
</dd>
<dt>status</dt><dd><p><code>1</code> for failed and <code>0</code> for censored units.</p>
</dd>
<dt>production_date</dt><dd><p>Date of production.</p>
</dd>
<dt>registration_date</dt><dd><p>Date of registration. Known for all failed units and
for a few intact units.</p>
</dd>
<dt>repair_date</dt><dd><p>The date on which the failure was repaired. It is assumed
that the repair date is equal to the date of failure occurrence.</p>
</dd>
<dt>report_date</dt><dd><p>The date on which lifetime information about the failure
were available.</p>
</dd>
<dt>country</dt><dd><p>Delivering country.</p>
</dd>
<dt>region</dt><dd><p>The region within the country of delivery. Known for registered
vehicles, <code>NA</code> for units with a missing <code>registration_date</code>.</p>
</dd>
<dt>climatic_zone</dt><dd><p>Climatic zone based on &quot;Köppen-Geiger&quot; climate classification.
Known for registered vehicles, <code>NA</code> for units with a missing <code>registration_date</code>.</p>
</dd>
<dt>climatic_subzone</dt><dd><p>Climatic subzone based on &quot;Köppen-Geiger&quot; climate classification.
Known for registered vehicles, <code>NA</code> for units with a <code>registration_date</code>.</p>
</dd>
<dt>brand</dt><dd><p>Brand of the vehicle.</p>
</dd>
<dt>vehicle_model</dt><dd><p>Model of the vehicle.</p>
</dd>
<dt>engine_type</dt><dd><p>Type of the engine.</p>
</dd>
<dt>engine_date</dt><dd><p>Date where the engine was installed.</p>
</dd>
<dt>gear_type</dt><dd><p>Type of the gear.</p>
</dd>
<dt>gear_date</dt><dd><p>Date where the gear was installed.</p>
</dd>
<dt>transmission</dt><dd><p>Transmission of the vehicle.</p>
</dd>
<dt>fuel</dt><dd><p>Vehicle fuel.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All vehicles were produced in 2014 and an analysis of the field data was
made at the end of 2015. At the date of analysis, there were 684 failed and
10,000 intact vehicles.
</p>
<p><strong>Censored vehicles</strong>:
</p>
<p>For censored units the service time (<code>dis</code>) was computed as the difference
of the date of analysis <code>"2015-12-31"</code> and the <code>registration_date</code>.
</p>
<p>For many units the latter date is unknown. For these, the difference of the
analysis date and <code>production_date</code> was used to get a rough estimation of
the real service time. This uncertainty has to be considered in the subsequent
analysis (see <strong>delay in registration</strong> in the section 'Details' of
<code><a href="#topic+mcs_delay">mcs_delay</a></code>).
</p>
<p>Furthermore, due to the delay in report, the computed service time could also
be inaccurate. This uncertainty should be considered as well (see
<strong>delay in report</strong> in the section 'Details' of <code><a href="#topic+mcs_delay">mcs_delay</a></code>).
</p>
<p>The lifetime characteristic <code>mileage</code> is unknown for all censored units.
If an analysis is to be made for this lifetime characteristic, covered distances
for these units have to be estimated (see <code><a href="#topic+mcs_mileage">mcs_mileage</a></code>).
</p>
<p><strong>Failed vehicles</strong>:
For failed units the service time (<code>dis</code>) is computed as the difference
of <code>repair_date</code> and <code>registration_date</code>, which are known for all of them.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcs_mileage_data">mcs_mileage_data</a></code>
</p>

<hr>
<h2 id='johnson_method'>Estimation of Failure Probabilities using Johnson's Method</h2><span id='topic+johnson_method'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><code>johnson_method()</code> is no longer under active development, switching to
<a href="#topic+estimate_cdf">estimate_cdf</a> is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>johnson_method(x, status, id = NULL, method = c("benard", "invbeta"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="johnson_method_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime
data could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="johnson_method_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="johnson_method_+3A_id">id</code></td>
<td>
<p>A vector for the identification of every unit. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="johnson_method_+3A_method">method</code></td>
<td>
<p>Method for the estimation of the cdf. Can be <code>"benard"</code> (default)
or <code>"invbeta"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This non-parametric approach is used to estimate the failure probabilities in
terms of uncensored or (multiple) right censored data. Compared to complete
data the correction is done by calculating adjusted ranks which takes
non-defective units into account.
</p>


<h3>Value</h3>

<p>A tibble containing the following columns:
</p>

<ul>
<li> <p><code>id</code> : Identification for every unit.
</p>
</li>
<li> <p><code>x</code> : Lifetime characteristic.
</p>
</li>
<li> <p><code>status</code> : Binary data (0 or 1) indicating whether a unit is a right
censored observation (= 0) or a failure (= 1).
</p>
</li>
<li> <p><code>rank</code> : Adjusted ranks, <code>NA</code> if <code>status = 0</code>.
</p>
</li>
<li> <p><code>prob</code> : Estimated failure probabilities, <code>NA</code> if <code>status = 0</code>.
</p>
</li>
<li> <p><code>cdf_estimation_method</code> : Specified method for the estimation of failure
probabilities (always 'johnson').
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
obs   &lt;- seq(10000, 100000, 10000)
state &lt;- c(0, 1, 1, 0, 0, 0, 1, 0, 1, 0)
uic   &lt;- c("3435", "1203", "958X", "XX71", "abcd", "tz46",
           "fl29", "AX23", "Uy12", "kl1a")

# Example 1 - Johnson method for intact and failed units:
tbl_john &lt;- johnson_method(
  x = obs,
  status = state,
  id = uic
)

# Example 2 - Johnson's method works also if only defective units are considered:
tbl_john_2 &lt;- johnson_method(
  x = obs,
  status = rep(1, length(obs))
)

</code></pre>

<hr>
<h2 id='kaplan_method'>Estimation of Failure Probabilities using the Kaplan-Meier Estimator</h2><span id='topic+kaplan_method'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><code>kaplan_method()</code> is no longer under active development, switching to
<a href="#topic+estimate_cdf">estimate_cdf</a> is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kaplan_method(x, status, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kaplan_method_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime
data could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="kaplan_method_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="kaplan_method_+3A_id">id</code></td>
<td>
<p>A vector for the identification of every unit. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whereas the non-parametric Kaplan-Meier estimator is used to estimate the
survival function <em>S(t)</em> in terms of (multiple) right censored data, the
complement is an estimate of the cumulative distribution function <em>F(t)</em>.
One modification is made in contrast to the original Kaplan-Meier estimator
(see 'References').
</p>


<h3>Value</h3>

<p>A tibble containing the following columns:
</p>

<ul>
<li> <p><code>id</code> : Identification for every unit.
</p>
</li>
<li> <p><code>x</code> : Lifetime characteristic.
</p>
</li>
<li> <p><code>status</code> : Binary data (0 or 1) indicating whether a unit is a right
censored observation (= 0) or a failure (= 1).
</p>
</li>
<li> <p><code>rank</code> : Filled with <code>NA</code>.
</p>
</li>
<li> <p><code>prob</code> : Estimated failure probabilities, <code>NA</code> if <code>status = 0</code>.
</p>
</li>
<li> <p><code>cdf_estimation_method</code> : Specified method for the estimation of failure
probabilities (always 'kaplan').
</p>
</li></ul>



<h3>References</h3>

<p><em>NIST/SEMATECH e-Handbook of Statistical Methods</em>,
<em>8.2.1.5. Empirical model fitting - distribution free (Kaplan-Meier) approach</em>,
<a href="https://www.itl.nist.gov/div898/handbook/apr/section2/apr215.htm">NIST SEMATECH</a>,
December 3, 2020
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
obs   &lt;- seq(10000, 100000, 10000)
state &lt;- c(0, 1, 1, 0, 0, 0, 1, 0, 1, 0)
state_2 &lt;- c(0, 1, 1, 0, 0, 0, 1, 0, 0, 1)
uic   &lt;- c("3435", "1203", "958X", "XX71", "abcd", "tz46",
           "fl29", "AX23","Uy12", "kl1a")

# Example 1 - Observation with highest characteristic is an intact unit:
tbl_kap &lt;- kaplan_method(
  x = obs,
  status = state,
  id = uic
)

# Example 2 - Observation with highest characteristic is a defective unit:
tbl_kap_2 &lt;- kaplan_method(
  x = obs,
  status = state_2
)

</code></pre>

<hr>
<h2 id='loglik_function'>Log-Likelihood Function for Parametric Lifetime Distributions</h2><span id='topic+loglik_function'></span><span id='topic+loglik_function.wt_reliability_data'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood value with respect to a given set
of parameters. In terms of <em>Maximum Likelihood Estimation</em> this function can
be optimized (<a href="stats.html#topic+optim">optim</a>) to estimate the parameters and
variance-covariance matrix of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik_function(x, ...)

## S3 method for class 'wt_reliability_data'
loglik_function(
  x,
  wts = rep(1, nrow(x)),
  dist_params,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik_function_+3A_x">x</code></td>
<td>
<p>A <code>tibble</code> with class <code>wt_reliability_data</code> returned by <a href="#topic+reliability_data">reliability_data</a>.</p>
</td></tr>
<tr><td><code id="loglik_function_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="loglik_function_+3A_wts">wts</code></td>
<td>
<p>Optional vector of case weights. The length of <code>wts</code> must be equal
to the number of observations in <code>x</code>.</p>
</td></tr>
<tr><td><code id="loglik_function_+3A_dist_params">dist_params</code></td>
<td>
<p>A vector of parameters. An overview of the
distribution-specific parameters can be found in section 'Distributions'.</p>
</td></tr>
<tr><td><code id="loglik_function_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the log-likelihood value for the parameters in <code>dist_params</code> given
the data.
</p>


<h3>Distributions</h3>

<p>The following table summarizes the available distributions and their parameters
</p>

<ul>
<li> <p><em>location parameter</em> <code class="reqn">\mu</code>,
</p>
</li>
<li> <p><em>scale parameter</em> <code class="reqn">\sigma</code> or <code class="reqn">\theta</code> and
</p>
</li>
<li> <p><em>threshold parameter</em> <code class="reqn">\gamma</code>.
</p>
</li></ul>

<p>The order within <code>dist_params</code> is given in the table header.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong><code>distribution</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[1]</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[2]</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[3]</code></strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"sev"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"weibull"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"weibull3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"normal"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"lognormal"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"lognormal3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"logistic"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"loglogistic"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"loglogistic3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"exponential"</code> </td><td style="text-align: center;"> <code class="reqn">\theta</code> </td><td style="text-align: center;"> - </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"exponential2"</code> </td><td style="text-align: center;"> <code class="reqn">\theta</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reliability data preparation:
data &lt;- reliability_data(
  alloy,
  x = cycles,
  status = status
)

# Example 1 - Evaluating Log-Likelihood function of two-parametric weibull:
loglik_weib &lt;- loglik_function(
  x = data,
  dist_params = c(5.29, 0.33),
  distribution = "weibull"
)

# Example 2 - Evaluating Log-Likelihood function of three-parametric weibull:
loglik_weib3 &lt;- loglik_function(
  x = data,
  dist_params = c(4.54, 0.76, 92.99),
  distribution = "weibull3"
)

</code></pre>

<hr>
<h2 id='loglik_function.default'>Log-Likelihood Function for Parametric Lifetime Distributions</h2><span id='topic+loglik_function.default'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood value with respect to a given set
of parameters. In terms of <em>Maximum Likelihood Estimation</em> this function can
be optimized (<a href="stats.html#topic+optim">optim</a>) to estimate the parameters and
variance-covariance matrix of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
loglik_function(
  x,
  status,
  wts = rep(1, length(x)),
  dist_params,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik_function.default_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime data
could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="loglik_function.default_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="loglik_function.default_+3A_wts">wts</code></td>
<td>
<p>Optional vector of case weights. The length of <code>wts</code> must be equal
to the number of observations in <code>x</code>.</p>
</td></tr>
<tr><td><code id="loglik_function.default_+3A_dist_params">dist_params</code></td>
<td>
<p>A vector of parameters. An overview of the
distribution-specific parameters can be found in section 'Distributions'.</p>
</td></tr>
<tr><td><code id="loglik_function.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="loglik_function.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the log-likelihood value for the parameters in <code>dist_params</code> given
the data.
</p>


<h3>Distributions</h3>

<p>The following table summarizes the available distributions and their parameters
</p>

<ul>
<li> <p><em>location parameter</em> <code class="reqn">\mu</code>,
</p>
</li>
<li> <p><em>scale parameter</em> <code class="reqn">\sigma</code> or <code class="reqn">\theta</code> and
</p>
</li>
<li> <p><em>threshold parameter</em> <code class="reqn">\gamma</code>.
</p>
</li></ul>

<p>The order within <code>dist_params</code> is given in the table header.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong><code>distribution</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[1]</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[2]</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[3]</code></strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"sev"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"weibull"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"weibull3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"normal"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"lognormal"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"lognormal3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"logistic"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"loglogistic"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"loglogistic3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"exponential"</code> </td><td style="text-align: center;"> <code class="reqn">\theta</code> </td><td style="text-align: center;"> - </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"exponential2"</code> </td><td style="text-align: center;"> <code class="reqn">\theta</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>See Also</h3>

<p><a href="#topic+loglik_function">loglik_function</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
cycles &lt;- alloy$cycles
status &lt;- alloy$status

# Example 1 - Evaluating Log-Likelihood function of two-parametric weibull:
loglik_weib &lt;- loglik_function(
  x = cycles,
  status = status,
  dist_params = c(5.29, 0.33),
  distribution = "weibull"
)

# Example 2 - Evaluating Log-Likelihood function of three-parametric weibull:
loglik_weib3 &lt;- loglik_function(
  x = cycles,
  status = status,
  dist_params = c(4.54, 0.76, 92.99),
  distribution = "weibull3"
)

</code></pre>

<hr>
<h2 id='loglik_profiling'>Log-Likelihood Profile Function for Parametric Lifetime Distributions with Threshold</h2><span id='topic+loglik_profiling'></span><span id='topic+loglik_profiling.wt_reliability_data'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood with respect to a given threshold
parameter of a parametric lifetime distribution. In terms of
<em>Maximum Likelihood Estimation</em> this function can be optimized
(<a href="stats.html#topic+optim">optim</a>) to estimate the threshold parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik_profiling(x, ...)

## S3 method for class 'wt_reliability_data'
loglik_profiling(
  x,
  wts = rep(1, nrow(x)),
  thres,
  distribution = c("weibull3", "lognormal3", "loglogistic3", "exponential2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik_profiling_+3A_x">x</code></td>
<td>
<p>A <code>tibble</code> with class <code>wt_reliability_data</code> returned by <a href="#topic+reliability_data">reliability_data</a>.</p>
</td></tr>
<tr><td><code id="loglik_profiling_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="loglik_profiling_+3A_wts">wts</code></td>
<td>
<p>Optional vector of case weights. The length of <code>wts</code> must be equal
to the number of observations in <code>x</code>.</p>
</td></tr>
<tr><td><code id="loglik_profiling_+3A_thres">thres</code></td>
<td>
<p>A numeric value for the threshold parameter.</p>
</td></tr>
<tr><td><code id="loglik_profiling_+3A_distribution">distribution</code></td>
<td>
<p>Supposed parametric distribution of the random variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the log-likelihood value for the threshold parameter <code>thres</code> given
the data.
</p>


<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reliability data preparation:
data &lt;- reliability_data(
  alloy,
  x = cycles,
  status = status
)

# Determining the optimal loglikelihood value:
## Range of threshold parameter must be smaller than the first failure:
threshold &lt;- seq(
  0,
  min(data$x[data$status == 1]) - 0.1,
  length.out = 50
)

## loglikelihood value with respect to threshold values:
profile_logL &lt;- loglik_profiling(
  x = data,
  thres = threshold,
  distribution = "weibull3"
)

## Threshold value (among the candidates) that maximizes the
## loglikelihood:
threshold[which.max(profile_logL)]

## plot:
plot(
  threshold,
  profile_logL,
  type = "l"
)
abline(
  v = threshold[which.max(profile_logL)],
  h = max(profile_logL),
  col = "red"
)

</code></pre>

<hr>
<h2 id='loglik_profiling.default'>Log-Likelihood Profile Function for Parametric Lifetime Distributions with Threshold</h2><span id='topic+loglik_profiling.default'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood with respect to a given threshold
parameter of a parametric lifetime distribution. In terms of
<em>Maximum Likelihood Estimation</em> this function can be optimized
(<a href="stats.html#topic+optim">optim</a>) to estimate the threshold parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
loglik_profiling(
  x,
  status,
  wts = rep(1, length(x)),
  thres,
  distribution = c("weibull3", "lognormal3", "loglogistic3", "exponential2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik_profiling.default_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime data
could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="loglik_profiling.default_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="loglik_profiling.default_+3A_wts">wts</code></td>
<td>
<p>Optional vector of case weights. The length of <code>wts</code> must be equal
to the number of observations in <code>x</code>.</p>
</td></tr>
<tr><td><code id="loglik_profiling.default_+3A_thres">thres</code></td>
<td>
<p>A numeric value for the threshold parameter.</p>
</td></tr>
<tr><td><code id="loglik_profiling.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed parametric distribution of the random variable.</p>
</td></tr>
<tr><td><code id="loglik_profiling.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the log-likelihood value for the threshold parameter <code>thres</code> given
the data.
</p>


<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>See Also</h3>

<p><a href="#topic+loglik_profiling">loglik_profiling</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
cycles &lt;- alloy$cycles
status &lt;- alloy$status

# Determining the optimal loglikelihood value:
## Range of threshold parameter must be smaller than the first failure:
threshold &lt;- seq(
  0,
  min(cycles[status == 1]) - 0.1,
  length.out = 50
)

## loglikelihood value with respect to threshold values:
profile_logL &lt;- loglik_profiling(
  x = cycles,
  status = status,
  thres = threshold,
  distribution = "weibull3"
)

## Threshold value (among the candidates) that maximizes the
## loglikelihood:
threshold[which.max(profile_logL)]

## plot:
plot(
  threshold,
  profile_logL,
  type = "l"
)
abline(
  v = threshold[which.max(profile_logL)],
  h = max(profile_logL),
  col = "red"
)

</code></pre>

<hr>
<h2 id='mcs_delay'>Adjustment of Operating Times by Delays using a Monte Carlo Approach</h2><span id='topic+mcs_delay'></span><span id='topic+mcs_delay.wt_mcs_delay_data'></span>

<h3>Description</h3>

<p>In general, the amount of available information about units in the field is very
different. During the warranty period, there are only a few cases with complete
data (mainly <em>failed units</em>) but lots of cases with incomplete data (usually
<em>censored units</em>). As a result, the operating time of units with incomplete
information is often inaccurate and must be adjusted by delays.
</p>
<p>This function reduces the operating times of incomplete observations by simulated
delays (in days). A unit is considered as incomplete if the later of the
related dates is unknown. See 'Details' for some practical examples.
</p>
<p>Random delay numbers are drawn from the distribution determined by complete cases
(described in 'Details' of <a href="#topic+dist_delay">dist_delay</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcs_delay(...)

## S3 method for class 'wt_mcs_delay_data'
mcs_delay(..., x, distribution = c("lognormal", "exponential"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcs_delay_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="mcs_delay_+3A_x">x</code></td>
<td>
<p>A <code>tibble</code> with class <code>wt_mcs_delay_data</code> returned by <a href="#topic+mcs_delay_data">mcs_delay_data</a>.</p>
</td></tr>
<tr><td><code id="mcs_delay_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the respective delay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In field data analysis time-dependent characteristics (e.g. <em>time in service</em>)
are often imprecisely recorded. These inaccuracies are caused by unconsidered delays.
</p>
<p>For a better understanding of the MCS application in the context of field data,
two cases are described below.
</p>

<ul>
<li> <p><strong>Delay in registration</strong>: It is common that a supplier, which provides
parts to the manufacturing industry does not know when the unit, in which
its parts are installed, were put in service (due to unknown registration or
sales date (<code>date_2</code>)). Without taking the described delay into account, the
time in service of the failed units would be the difference between the
repair date and the production date (<code>date_1</code>) and for intact units the
difference between the present date and the production date. But the real
operating times are (much) shorter, since the stress on the components have
not started until the whole systems were put in service. Hence, units with
incomplete data (missing <code>date_2</code>) must be reduced by the delays.
</p>
</li>
<li> <p><strong>Delay in report</strong>:: Authorized repairers often do not immediately
notify the manufacturer or OEM of repairs that were made during the warranty
period, but instead pass the information about these repairs in collected
forms e.g. weekly, monthly or quarterly. The resulting time difference between
the reporting (<code>date_2</code>) of the repair in the guarantee database and the
actual repair date (<code>date_1</code>), which is often assumed to be the failure
date, is called the reporting delay. For a given date where the analysis
is made there could be units which had a failure but the failure isn't
reported and therefore they are treated as censored units. In order to take
this into account and according to the principle of equal opportunities, the
lifetime of units with missing report date (<code>date_2[i] = NA</code>) is reduced by
simulated reporting delays.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with class <code>wt_mcs_delay</code> containing the following elements:
</p>

<ul>
<li> <p><code>data</code> : A <code>tibble</code> returned by <a href="#topic+mcs_delay_data">mcs_delay_data</a> where two modifications
has been made:
</p>

<ul>
<li><p> If the column <code>status</code> exists, the <code>tibble</code> has additional classes
<code>wt_mcs_data</code> and <code>wt_reliability_data</code>. Otherwise, the <code>tibble</code> only has
the additional class <code>wt_mcs_data</code> (which is not supported by <a href="#topic+estimate_cdf">estimate_cdf</a>).
</p>
</li>
<li><p> The column <code>time</code> is renamed to <code>x</code> (to be in accordance with
<a href="#topic+reliability_data">reliability_data</a>) and contains the adjusted operating times for incomplete
observations and input operating times for the complete observations.
</p>
</li></ul>

</li>
<li> <p><code>sim_data</code> : A <code>tibble</code> with column <code>sim_delay</code> that holds the simulated
delay-specific numbers for incomplete cases and <code>0</code> for complete cases.
If more than one delay was considered multiple columns with names <code>sim_delay_1</code>,
<code>sim_delay_2</code>, ..., <code>sim_delay_i</code> and corresponding delay-specific random
numbers are presented.
</p>
</li>
<li> <p><code>model_estimation</code> : A list returned by <a href="#topic+dist_delay">dist_delay</a>.
</p>
</li></ul>



<h3>References</h3>

<p>Verband der Automobilindustrie e.V. (VDA); Qualitätsmanagement in
der Automobilindustrie. Zuverlässigkeitssicherung bei Automobilherstellern
und Lieferanten. Zuverlässigkeits-Methoden und -Hilfsmittel.; 4th Edition, 2016,
ISSN:0943-9412
</p>


<h3>See Also</h3>

<p><a href="#topic+dist_delay">dist_delay</a> for the determination of a parametric delay distribution
and <a href="#topic+estimate_cdf">estimate_cdf</a> for the estimation of failure probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MCS data preparation:
## Data for delay in registration:
mcs_tbl_1 &lt;- mcs_delay_data(
  field_data,
  date_1 = production_date,
  date_2 = registration_date,
  time = dis,
  status = status,
  id = vin
)

## Data for delay in report:
mcs_tbl_2 &lt;- mcs_delay_data(
  field_data,
  date_1 = repair_date,
  date_2 = report_date,
  time = dis,
  status = status,
  id = vin
)

## Data for both delays:
mcs_tbl_both &lt;- mcs_delay_data(
  field_data,
  date_1 = c(production_date, repair_date),
  date_2 = c(registration_date, report_date),
  time = dis,
  status = status,
  id = vin
)

# Example 1 - MCS for delay in registration:
mcs_regist &lt;- mcs_delay(
  x = mcs_tbl_1,
  distribution = "lognormal"
)

# Example 2 - MCS for delay in report:
mcs_report &lt;- mcs_delay(
  x = mcs_tbl_2,
  distribution = "exponential"
)

# Example 3 - Reproducibility of random numbers:
set.seed(1234)
mcs_report_reproduce &lt;- mcs_delay(
  x = mcs_tbl_2,
  distribution = "exponential"
)

# Example 4 - MCS for delays in registration and report with same distribution:
mcs_delays &lt;- mcs_delay(
  x = mcs_tbl_both,
  distribution = "lognormal"
)

# Example 5 - MCS for delays in registration and report with different distributions:
## Assuming lognormal registration and exponential reporting delays.
mcs_delays_2 &lt;- mcs_delay(
  x = mcs_tbl_both,
  distribution = c("lognormal", "exponential")
)

</code></pre>

<hr>
<h2 id='mcs_delay_data'>MCS Delay Data</h2><span id='topic+mcs_delay_data'></span>

<h3>Description</h3>

<p>Create consistent <code>mcs_delay_data</code> based on an existing <code>data.frame</code> (preferred)
or on multiple equal length vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcs_delay_data(
  data = NULL,
  date_1,
  date_2,
  time,
  status = NULL,
  id = NULL,
  .keep_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcs_delay_data_+3A_data">data</code></td>
<td>
<p>Either <code>NULL</code> or a <code>data.frame</code>. If data is <code>NULL</code>, <code>date_1</code>, <code>date_2</code>,
<code>time</code>, <code>status</code> and <code>id</code> must be vectors containing the data. Otherwise <code>date_1</code>,
<code>date_2</code>, <code>time</code>, <code>status</code> and <code>id</code> can be either column names or column positions.</p>
</td></tr>
<tr><td><code id="mcs_delay_data_+3A_date_1">date_1</code></td>
<td>
<p>A date of class <code>character</code> or <code>Date</code> in the format &quot;yyyy-mm-dd&quot;,
representing the earlier of the two dates belonging to a particular delay.
Use <code>NA</code> for missing elements.
</p>
<p>If more than one delay is to be considered, use a list for the vector-based
approach and a vector of column names or positions for the data-based approach.
The first element is the earlier date of the first delay, the second element is the
earlier date of the second delay, and so forth (see 'Examples').</p>
</td></tr>
<tr><td><code id="mcs_delay_data_+3A_date_2">date_2</code></td>
<td>
<p>A date of class <code>character</code> or <code>Date</code> in the format &quot;yyyy-mm-dd&quot;.
<code>date_2</code> is the counterpart of <code>date_1</code> and is used the same as <code>date_1</code>, just with
the later date(s) of the particular delay(s). Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delay_data_+3A_time">time</code></td>
<td>
<p>Operating times. Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delay_data_+3A_status">status</code></td>
<td>
<p>Optional argument. If used, it must contain binary data
(0 or 1) indicating whether a unit is a right censored observation (= 0) or a
failure (= 1).
</p>
<p>If <code>status</code> is provided, class <code>wt_reliability_data</code> is assigned to the
output of <a href="#topic+mcs_delay">mcs_delay</a>, which enables the direct application of <a href="#topic+estimate_cdf">estimate_cdf</a>
on operating times.</p>
</td></tr>
<tr><td><code id="mcs_delay_data_+3A_id">id</code></td>
<td>
<p>Identification of every unit.</p>
</td></tr>
<tr><td><code id="mcs_delay_data_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code> keep remaining variables in <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with class <code>wt_mcs_delay_data</code> that is formed for the downstream
Monte Carlo method <a href="#topic+mcs_delay">mcs_delay</a>.
It contains the following columns (if <code>.keep_all = FALSE</code>):
</p>

<ul>
<li><p> Column(s) preserving the input of <code>date_1</code>. For the vector-based approach
with unnamed input, column name(s) is (are) <code>date_1</code>
(<code>date_1.1</code>, <code>date_1.2</code>, <code>...</code>, <code>date_1.i</code>).
</p>
</li>
<li><p> Column(s) preserving the input of <code>date_2</code>. For the vector-based approach
with unnamed input, column name(s) is (are) <code>date_2</code>
(<code>date_2.1</code>, <code>date_2.2</code>, <code>...</code>, <code>date_2.i</code>).
</p>
</li>
<li> <p><code>time</code> : Input operating times.
</p>
</li>
<li> <p><code>status</code> (<strong>optional</strong>) :
</p>

<ul>
<li><p> If <code>is.null(status)</code> column <code>status</code> does not exist.
</p>
</li>
<li><p> If <code>status</code> is provided the column contains the entered binary
data (0 or 1).
</p>
</li></ul>

</li>
<li> <p><code>id</code> : Identification for every unit.
</p>
</li></ul>

<p>If <code>.keep_all = TRUE</code>, the remaining columns of <code>data</code> are also preserved.
</p>
<p>The attributes <code>mcs_start_dates</code> and <code>mcs_end_dates</code> hold the name(s) of the
column(s) that preserve the input of <code>date_1</code> and <code>date_2</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+dist_delay">dist_delay</a> for the determination of a parametric delay distribution
and <a href="#topic+mcs_delay">mcs_delay</a> for the Monte Carlo method with respect to delays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 -  Based on an existing data.frame/tibble and column names:
mcs_tbl &lt;- mcs_delay_data(
  data = field_data,
  date_1 = production_date,
  date_2 = registration_date,
  time = dis,
  status = status
)

# Example 2 - Based on an existing data.frame/tibble and column positions:
mcs_tbl_2 &lt;- mcs_delay_data(
  data = field_data,
  date_1 = 7,
  date_2 = 8,
  time = 2,
  id = 1
)

# Example 3 - Keep all variables of the tibble/data.frame entered to argument data:
mcs_tbl_3 &lt;- mcs_delay_data(
  data = field_data,
  date_1 = production_date,
  date_2 = registration_date,
  time = dis,
  status = status,
  id = vin,
  .keep_all = TRUE
)

# Example 4 - For multiple delays (data-based):
mcs_tbl_4 &lt;- mcs_delay_data(
  data = field_data,
  date_1 = c(production_date, repair_date),
  date_2 = c(registration_date, report_date),
  time = dis,
  status = status
)

# Example 5 - Based on vectors:
mcs_tbl_5 &lt;- mcs_delay_data(
  date_1 = field_data$production_date,
  date_2 = field_data$registration_date,
  time = field_data$dis,
  status = field_data$status,
  id = field_data$vin
)

# Example 6 - For multiple delays (vector-based):
mcs_tbl_6 &lt;- mcs_delay_data(
  date_1 = list(field_data$production_date, field_data$repair_date),
  date_2 = list(field_data$registration_date, field_data$report_date),
  time = field_data$dis,
  status = field_data$status,
  id = field_data$vin
)

# Example 7 - For multiple delays (vector-based with named dates):
mcs_tbl_7 &lt;- mcs_delay_data(
  date_1 = list(d11 = field_data$production_date, d12 = field_data$repair_date),
  date_2 = list(d21 = field_data$registration_date, d22 = field_data$report_date),
  time = field_data$dis,
  status = field_data$status,
  id = field_data$vin
)

</code></pre>

<hr>
<h2 id='mcs_delay_register'>Adjustment of Operating Times by Delays in Registration using a Monte Carlo
Approach</h2><span id='topic+mcs_delay_register'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><code>mcs_delay_register()</code> is no longer under active development, switching
to <a href="#topic+mcs_delay">mcs_delay</a> is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcs_delay_register(
  date_prod,
  date_register,
  time,
  status,
  distribution = "lognormal",
  details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcs_delay_register_+3A_date_prod">date_prod</code></td>
<td>
<p>A vector of class <code>character</code> or <code>Date</code>, in the
format &quot;yyyy-mm-dd&quot;, indicating the date of production of a unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delay_register_+3A_date_register">date_register</code></td>
<td>
<p>A vector of class <code>character</code> or <code>Date</code>, in
the format &quot;yyyy-mm-dd&quot;, indicating the date of registration of a unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delay_register_+3A_time">time</code></td>
<td>
<p>A numeric vector of operating times.</p>
</td></tr>
<tr><td><code id="mcs_delay_register_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether unit <em>i</em> is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="mcs_delay_register_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable. Only
<code>"lognormal"</code> is implemented.</p>
</td></tr>
<tr><td><code id="mcs_delay_register_+3A_details">details</code></td>
<td>
<p>A logical. If <code>FALSE</code> the output consists of a vector with
corrected operating times for the censored units and the input operating
times for the failed units. If <code>TRUE</code> the output consists of a detailed
list, i.e the same vector as described before, simulated random numbers and
estimated distribution parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general the amount of information about units in the field, that have not
failed yet, are rare. For example it is common that a supplier, who provides
parts to the automotive industry does not know when a vehicle was put in
service and therefore does not know the exact operating time of the supplied
parts. This function uses a Monte Carlo approach for simulating the operating
times of (multiple) right censored observations, taking account of registering
delays. The simulation is based on the distribution of operating times that were
calculated from complete data (see <a href="#topic+dist_delay_register">dist_delay_register</a>).
</p>


<h3>Value</h3>

<p>A numeric vector of corrected operating times for the censored units
and the input operating times for the failed units if <code>details = FALSE</code>.
If <code>details = TRUE</code> the output is a list which consists of the following elements:
</p>

<ul>
<li> <p><code>time</code> : Numeric vector of corrected operating times for the censored
observations and input operating times for failed units.
</p>
</li>
<li> <p><code>x_sim</code> : Simulated random numbers of specified distribution with estimated
parameters. The length of <code>x_sim</code> is equal to the number of censored observations.
</p>
</li>
<li> <p><code>coefficients</code> : Estimated coefficients of supposed distribution.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>date_of_production   &lt;- c("2014-07-28", "2014-02-17", "2014-07-14",
                          "2014-06-26", "2014-03-10", "2014-05-14",
                          "2014-05-06", "2014-03-07", "2014-03-09",
                          "2014-04-13", "2014-05-20", "2014-07-07",
                          "2014-01-27", "2014-01-30", "2014-03-17",
                          "2014-02-09", "2014-04-14", "2014-04-20",
                          "2014-03-13", "2014-02-23", "2014-04-03",
                          "2014-01-08", "2014-01-08")
date_of_registration &lt;- c(NA, "2014-03-29", "2014-12-06", "2014-09-09",
                          NA, NA, "2014-06-16", NA, "2014-05-23",
                          "2014-05-09", "2014-05-31", NA, "2014-04-13",
                          NA, NA, "2014-03-12", NA, "2014-06-02",
                          NA, "2014-03-21", "2014-06-19", NA, NA)

op_time &lt;- rep(1000, length(date_of_production))
status &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0)

# Example 1 - Simplified vector output:
x_corrected &lt;- mcs_delay_register(
  date_prod = date_of_production,
  date_register = date_of_registration,
  time = op_time,
  status = status,
  distribution = "lognormal",
  details = FALSE
)

# Example 2 - Detailed list output:
list_detail &lt;- mcs_delay_register(
  date_prod = date_of_production,
  date_register = date_of_registration,
  time = op_time,
  status = status,
  distribution = "lognormal",
  details = TRUE
)

</code></pre>

<hr>
<h2 id='mcs_delay_report'>Adjustment of Operating Times by Delays in Report using a Monte Carlo Approach</h2><span id='topic+mcs_delay_report'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><code>mcs_delay_report()</code> is no longer under active development, switching to
<a href="#topic+mcs_delay">mcs_delay</a> is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcs_delay_report(
  date_repair,
  date_report,
  time,
  status,
  distribution = "lognormal",
  details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcs_delay_report_+3A_date_repair">date_repair</code></td>
<td>
<p>a vector of class <code>character</code> or <code>Date</code>, in the
format &quot;yyyy-mm-dd&quot;, indicating the date of repair of a failed unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delay_report_+3A_date_report">date_report</code></td>
<td>
<p>a vector of class <code>character</code> or <code>Date</code>, in the
format &quot;yyyy-mm-dd&quot;, indicating the date of report of a failed unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delay_report_+3A_time">time</code></td>
<td>
<p>A numeric vector of operating times.</p>
</td></tr>
<tr><td><code id="mcs_delay_report_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether unit <em>i</em> is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="mcs_delay_report_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable. Only
<code>"lognormal"</code>is implemented.</p>
</td></tr>
<tr><td><code id="mcs_delay_report_+3A_details">details</code></td>
<td>
<p>A logical. If <code>FALSE</code> the output consists of a vector with
corrected operating times for the censored units and the input operating
times for the failed units. If <code>TRUE</code> the output consists of a detailed
list, i.e the same vector as described before, simulated random numbers and
estimated distribution parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delay in report describes the time between the occurrence of a damage and
the registration in the warranty database. For a given date where the analysis
is made there could be units which had a failure but are not registered in the
database and therefore treated as censored units. To overcome this problem
this function uses a Monte Carlo approach for simulating the operating
times of (multiple) right censored observations, taking account of reporting
delays. The simulation is based on the distribution of operating times that were
calculated from complete data, i.e. failed items (see <a href="#topic+dist_delay_report">dist_delay_report</a>).
</p>


<h3>Value</h3>

<p>A numeric vector of corrected operating times for the censored units
and the input operating times for the failed units if <code>details = FALSE</code>.
If <code>details = TRUE</code> the output is a list which consists of the following
elements:
</p>

<ul>
<li> <p><code>time</code> : Numeric vector of corrected operating times for the censored
observations and input operating times for failed units.
</p>
</li>
<li> <p><code>x_sim</code> : Simulated random numbers of specified distribution with
estimated parameters. The length of <code>x_sim</code> is equal to the number of
censored observations.
</p>
</li>
<li> <p><code>coefficients</code> : Estimated coefficients of supposed distribution.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>date_of_repair &lt;- c(NA, "2014-09-15", "2015-07-04", "2015-04-10", NA,
                   NA, "2015-04-24", NA, "2015-04-25", "2015-04-24",
                    "2015-06-12", NA, "2015-05-04", NA, NA,
                    "2015-05-22", NA, "2015-09-17", NA, "2015-08-15",
                    "2015-11-26", NA, NA)

date_of_report &lt;- c(NA, "2014-10-09", "2015-08-28", "2015-04-15", NA,
                    NA, "2015-05-16", NA, "2015-05-28", "2015-05-15",
                    "2015-07-11", NA, "2015-08-14", NA, NA,
                    "2015-06-05", NA, "2015-10-17", NA, "2015-08-21",
                    "2015-12-02", NA, NA)

op_time &lt;- rep(1000, length(date_of_repair))
status &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0)

# Example 1 - Simplified vector output:
x_corrected &lt;- mcs_delay_report(
  date_repair = date_of_repair,
  date_report = date_of_report,
  time = op_time,
  status = status,
  distribution = "lognormal",
  details = FALSE
)

# Example 2 - Detailed list output:
list_detail &lt;- mcs_delay_report(
  date_repair = date_of_repair,
  date_report = date_of_report,
  time = op_time,
  status = status,
  distribution = "lognormal",
  details = TRUE
)

</code></pre>

<hr>
<h2 id='mcs_delay.default'>Adjustment of Operating Times by Delays using a Monte Carlo Approach</h2><span id='topic+mcs_delay.default'></span>

<h3>Description</h3>

<p>In general, the amount of available information about units in the field is very
different. During the warranty period, there are only a few cases with complete
data (mainly <em>failed units</em>) but lots of cases with incomplete data (usually
<em>censored units</em>). As a result, the operating time of units with incomplete
information is often inaccurate and must be adjusted by delays.
</p>
<p>This function reduces the operating times of incomplete observations by simulated
delays (in days). A unit is considered as incomplete if the later of the
related dates is unknown. See 'Details' for some practical examples.
</p>
<p>Random delay numbers are drawn from the distribution determined by complete cases
(described in 'Details' of <a href="#topic+dist_delay">dist_delay</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
mcs_delay(
  ...,
  date_1,
  date_2,
  time,
  status = NULL,
  id = paste0("ID", seq_len(length(time))),
  distribution = c("lognormal", "exponential")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcs_delay.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="mcs_delay.default_+3A_date_1">date_1</code></td>
<td>
<p>A vector of class <code>character</code> or <code>Date</code>, in the format &quot;yyyy-mm-dd&quot;,
representing the earlier of the two dates belonging to a particular delay.
Use <code>NA</code> for missing elements.
</p>
<p>If more than one delay is to be considered, use a list where the first element
is the earlier date of the first delay, the second element is the earlier date
of the second delay, and so forth (see 'Examples').</p>
</td></tr>
<tr><td><code id="mcs_delay.default_+3A_date_2">date_2</code></td>
<td>
<p>A vector of class <code>character</code> or <code>Date</code> in the format &quot;yyyy-mm-dd&quot;.
<code>date_2</code> is the counterpart of <code>date_1</code> and is used the same as <code>date_1</code>, just with
the later date(s) of the particular delay(s). Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delay.default_+3A_time">time</code></td>
<td>
<p>Operating times. Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delay.default_+3A_status">status</code></td>
<td>
<p>Optional argument. If used, it must contain binary data
(0 or 1) indicating whether a unit is a right censored observation (= 0) or a
failure (= 1).
</p>
<p>If <code>status</code> is provided, class <code>wt_reliability_data</code> is assigned to the
output of <a href="#topic+mcs_delay">mcs_delay</a>, which enables the direct application of <a href="#topic+estimate_cdf">estimate_cdf</a>
on operating times.</p>
</td></tr>
<tr><td><code id="mcs_delay.default_+3A_id">id</code></td>
<td>
<p>Identification of every unit.</p>
</td></tr>
<tr><td><code id="mcs_delay.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the respective delay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In field data analysis time-dependent characteristics (e.g. <em>time in service</em>)
are often imprecisely recorded. These inaccuracies are caused by unconsidered delays.
</p>
<p>For a better understanding of the MCS application in the context of field data,
two cases are described below.
</p>

<ul>
<li> <p><strong>Delay in registration</strong>: It is common that a supplier, which provides
parts to the manufacturing industry does not know when the unit, in which
its parts are installed, were put in service (due to unknown registration or
sales date (<code>date_2</code>)). Without taking the described delay into account, the
time in service of the failed units would be the difference between the
repair date and the production date (<code>date_1</code>) and for intact units the
difference between the present date and the production date. But the real
operating times are (much) shorter, since the stress on the components have
not started until the whole systems were put in service. Hence, units with
incomplete data (missing <code>date_2</code>) must be reduced by the delays.
</p>
</li>
<li> <p><strong>Delay in report</strong>:: Authorized repairers often do not immediately
notify the manufacturer or OEM of repairs that were made during the warranty
period, but instead pass the information about these repairs in collected
forms e.g. weekly, monthly or quarterly. The resulting time difference between
the reporting (<code>date_2</code>) of the repair in the guarantee database and the
actual repair date (<code>date_1</code>), which is often assumed to be the failure
date, is called the reporting delay. For a given date where the analysis
is made there could be units which had a failure but the failure isn't
reported and therefore they are treated as censored units. In order to take
this into account and according to the principle of equal opportunities, the
lifetime of units with missing report date (<code>date_2[i] = NA</code>) is reduced by
simulated reporting delays.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with class <code>wt_mcs_delay</code> containing the following elements:
</p>

<ul>
<li> <p><code>data</code> : A <code>tibble</code> returned by <a href="#topic+mcs_delay_data">mcs_delay_data</a> where two modifications
has been made:
</p>

<ul>
<li><p> If the column <code>status</code> exists, the <code>tibble</code> has additional classes
<code>wt_mcs_data</code> and <code>wt_reliability_data</code>. Otherwise, the <code>tibble</code> only has
the additional class <code>wt_mcs_data</code> (which is not supported by <a href="#topic+estimate_cdf">estimate_cdf</a>).
</p>
</li>
<li><p> The column <code>time</code> is renamed to <code>x</code> (to be in accordance with
<a href="#topic+reliability_data">reliability_data</a>) and contains the adjusted operating times for incomplete
observations and input operating times for the complete observations.
</p>
</li></ul>

</li>
<li> <p><code>sim_data</code> : A <code>tibble</code> with column <code>sim_delay</code> that holds the simulated
delay-specific numbers for incomplete cases and <code>0</code> for complete cases.
If more than one delay was considered multiple columns with names <code>sim_delay_1</code>,
<code>sim_delay_2</code>, ..., <code>sim_delay_i</code> and corresponding delay-specific random
numbers are presented.
</p>
</li>
<li> <p><code>model_estimation</code> : A list returned by <a href="#topic+dist_delay">dist_delay</a>.
</p>
</li></ul>



<h3>References</h3>

<p>Verband der Automobilindustrie e.V. (VDA); Qualitätsmanagement in
der Automobilindustrie. Zuverlässigkeitssicherung bei Automobilherstellern
und Lieferanten. Zuverlässigkeits-Methoden und -Hilfsmittel.; 4th Edition, 2016,
ISSN:0943-9412
</p>


<h3>See Also</h3>

<p><a href="#topic+dist_delay">dist_delay</a> for the determination of a parametric delay distribution
and <a href="#topic+estimate_cdf">estimate_cdf</a> for the estimation of failure probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 - MCS for delay in registration:
mcs_regist &lt;- mcs_delay(
  date_1 = field_data$production_date,
  date_2 = field_data$registration_date,
  time = field_data$dis,
  status = field_data$status,
  distribution = "lognormal"
)

# Example 2 - MCS for delay in report:
mcs_report &lt;- mcs_delay(
  date_1 = field_data$repair_date,
  date_2 = field_data$report_date,
  time = field_data$dis,
  status = field_data$status,
  distribution = "exponential"
)

# Example 3 - Reproducibility of random numbers:
set.seed(1234)
mcs_report_reproduce &lt;- mcs_delay(
  date_1 = field_data$repair_date,
  date_2 = field_data$report_date,
  time = field_data$dis,
  status = field_data$status,
  distribution = "exponential"
)

# Example 4 - MCS for delays in registration and report with same distribution:
mcs_delays &lt;- mcs_delay(
  date_1 = list(field_data$production_date, field_data$repair_date),
  date_2 = list(field_data$registration_date, field_data$report_date),
  time = field_data$dis,
  status = field_data$status,
  distribution = "lognormal"
)

# Example 5 - MCS for delays in registration and report with different distributions:
## Assuming lognormal registration and exponential reporting delays.
mcs_delays_2 &lt;- mcs_delay(
  date_1 = list(field_data$production_date, field_data$repair_date),
  date_2 = list(field_data$registration_date, field_data$report_date),
  time = field_data$dis,
  status = field_data$status,
  distribution = c("lognormal", "exponential")
)

</code></pre>

<hr>
<h2 id='mcs_delays'>Adjustment of Operating Times by Delays using a Monte Carlo Approach</h2><span id='topic+mcs_delays'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><code>mcs_delays()</code> is no longer under active development, switching to <a href="#topic+mcs_delay">mcs_delay</a>
is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcs_delays(
  date_prod,
  date_register,
  date_repair,
  date_report,
  time,
  status,
  distribution = "lognormal",
  details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcs_delays_+3A_date_prod">date_prod</code></td>
<td>
<p>A vector of class <code>character</code> or <code>Date</code>, in the
format &quot;yyyy-mm-dd&quot;, indicating the date of production of a unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delays_+3A_date_register">date_register</code></td>
<td>
<p>A vector of class <code>character</code> or <code>Date</code>, in
the format &quot;yyyy-mm-dd&quot;, indicating the date of registration of a unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delays_+3A_date_repair">date_repair</code></td>
<td>
<p>a vector of class <code>character</code> or <code>Date</code>, in the
format &quot;yyyy-mm-dd&quot;, indicating the date of repair of a failed unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delays_+3A_date_report">date_report</code></td>
<td>
<p>a vector of class <code>character</code> or <code>Date</code>, in the
format &quot;yyyy-mm-dd&quot;, indicating the date of report of a failed unit.
Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_delays_+3A_time">time</code></td>
<td>
<p>A numeric vector of operating times.</p>
</td></tr>
<tr><td><code id="mcs_delays_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether unit <em>i</em> is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="mcs_delays_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable. Only
<code>"lognormal"</code> is implemented.</p>
</td></tr>
<tr><td><code id="mcs_delays_+3A_details">details</code></td>
<td>
<p>A logical. If <code>FALSE</code> the output consists of a vector with
corrected operating times for the censored units and the input operating
times for the failed units. If <code>TRUE</code> the output consists of a detailed
list, i.e the same vector as described before, simulated random numbers and
estimated distribution parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper that combines both, <a href="#topic+mcs_delay_register">mcs_delay_register</a> and
<a href="#topic+mcs_delay_report">mcs_delay_report</a> functions for the adjustment of operating times of censored units.
</p>


<h3>Value</h3>

<p>A numerical vector of corrected operating times for the censored units
and the input operating times for the failed units if
<code>details = FALSE</code>. If <code>details = TRUE</code> the output is a list which
consists of the following elements:
</p>

<ul>
<li> <p><code>time</code> : A numeric vector of corrected operating times for the censored
observations and input operating times for failed units.
</p>
</li>
<li> <p><code>x_sim_regist</code> : Simulated random numbers of specified distribution with
estimated parameters for delay in registration. The length of <code>x_sim_regist</code>
is equal to the number of censored observations.
</p>
</li>
<li> <p><code>x_sim_report</code> : Simulated random numbers of specified distribution with
estimated parameters for delay in report. The length of <code>x_sim_report</code> is
equal to the number of censored observations.
</p>
</li>
<li> <p><code>coefficients_regist</code> : Estimated coefficients of supposed distribution for
delay in registration.
</p>
</li>
<li> <p><code>coefficients_report</code> : Estimated coefficients of supposed distribution for
delay in report
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>date_of_production   &lt;- c("2014-07-28", "2014-02-17", "2014-07-14",
                          "2014-06-26", "2014-03-10", "2014-05-14",
                          "2014-05-06", "2014-03-07", "2014-03-09",
                          "2014-04-13", "2014-05-20", "2014-07-07",
                          "2014-01-27", "2014-01-30", "2014-03-17",
                          "2014-02-09", "2014-04-14", "2014-04-20",
                          "2014-03-13", "2014-02-23", "2014-04-03",
                          "2014-01-08", "2014-01-08")
date_of_registration &lt;- c("2014-08-17", "2014-03-29", "2014-12-06",
                          "2014-09-09", "2014-05-14", "2014-07-01",
                          "2014-06-16", "2014-04-03", "2014-05-23",
                          "2014-05-09", "2014-05-31", "2014-08-12",
                          "2014-04-13", "2014-02-15", "2014-07-07",
                          "2014-03-12", "2014-05-27", "2014-06-02",
                          "2014-05-20", "2014-03-21", "2014-06-19",
                          "2014-02-12", "2014-03-27")
date_of_repair &lt;- c(NA, "2014-09-15", "2015-07-04", "2015-04-10", NA,
                   NA, "2015-04-24", NA, "2015-04-25", "2015-04-24",
                    "2015-06-12", NA, "2015-05-04", NA, NA,
                    "2015-05-22", NA, "2015-09-17", NA, "2015-08-15",
                    "2015-11-26", NA, NA)

date_of_report &lt;- c(NA, "2014-10-09", "2015-08-28", "2015-04-15", NA,
                    NA, "2015-05-16", NA, "2015-05-28", "2015-05-15",
                    "2015-07-11", NA, "2015-08-14", NA, NA,
                    "2015-06-05", NA, "2015-10-17", NA, "2015-08-21",
                    "2015-12-02", NA, NA)

op_time &lt;- rep(1000, length(date_of_repair))
status &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0)

# Example 1 - Simplified vector output:
x_corrected &lt;- mcs_delays(
  date_prod = date_of_production,
  date_register = date_of_registration,
  date_repair = date_of_repair,
  date_report = date_of_report,
  time = op_time,
  status = status,
  distribution = "lognormal",
  details = FALSE
)

# Example 2 - Detailed list output:
list_detail &lt;- mcs_delays(
  date_prod = date_of_production,
  date_register = date_of_registration,
  date_repair = date_of_repair,
  date_report = date_of_report,
  time = op_time,
  status = status,
  distribution = "lognormal",
  details = TRUE
)

</code></pre>

<hr>
<h2 id='mcs_mileage'>Simulation of Unknown Covered Distances using a Monte Carlo Approach</h2><span id='topic+mcs_mileage'></span><span id='topic+mcs_mileage.wt_mcs_mileage_data'></span>

<h3>Description</h3>

<p>This function simulates distances for units where these are unknown.
</p>
<p>First, random numbers of the annual mileage distribution, estimated by
<a href="#topic+dist_mileage">dist_mileage</a>, are drawn. Second, the drawn annual distances are
converted with respect to the actual operating times (in days) using a linear
relationship. See 'Details'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcs_mileage(x, ...)

## S3 method for class 'wt_mcs_mileage_data'
mcs_mileage(x, distribution = c("lognormal", "exponential"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcs_mileage_+3A_x">x</code></td>
<td>
<p>A <code>tibble</code> of class <code>wt_mcs_mileage_data</code> returned by <a href="#topic+mcs_mileage_data">mcs_mileage_data</a>.</p>
</td></tr>
<tr><td><code id="mcs_mileage_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="mcs_mileage_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the annual mileage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Assumption of linear relationship</strong>: Imagine the distance of the vehicle
is unknown. A distance of 3500.25 kilometers (km) was drawn from the annual
distribution and the known operating time is 200 days (d). So the resulting
distance of this vehicle is
</p>
<p style="text-align: center;"><code class="reqn">3500.25 km \cdot (\frac{200 d} {365 d}) = 1917.945 km</code>
</p>



<h3>Value</h3>

<p>A list with class <code>wt_mcs_mileage</code> containing the following elements:
</p>

<ul>
<li> <p><code>data</code> : A <code>tibble</code> returned by <a href="#topic+mcs_mileage_data">mcs_mileage_data</a> where two modifications
has been made:
</p>

<ul>
<li><p> If the column <code>status</code> exists, the <code>tibble</code> has additional classes
<code>wt_mcs_data</code> and <code>wt_reliability_data</code>. Otherwise, the <code>tibble</code> only has
the additional class <code>wt_mcs_data</code> (which is not supported by <a href="#topic+estimate_cdf">estimate_cdf</a>).
</p>
</li>
<li><p> The column <code>mileage</code> is renamed to <code>x</code> (to be in accordance with
<a href="#topic+reliability_data">reliability_data</a>) and contains simulated distances for incomplete
observations and input distances for the complete observations.
</p>
</li></ul>

</li>
<li> <p><code>sim_data</code> : A <code>tibble</code> with column <code>sim_mileage</code> that holds the simulated
distances for incomplete cases and <code>0</code> for complete cases.
</p>
</li>
<li> <p><code>model_estimation</code> : A list returned by <a href="#topic+dist_mileage">dist_mileage</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+dist_mileage">dist_mileage</a> for the determination of a parametric annual mileage
distribution and <a href="#topic+estimate_cdf">estimate_cdf</a> for the estimation of failure probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MCS data preparation:
mcs_tbl &lt;- mcs_mileage_data(
  field_data,
  mileage = mileage,
  time = dis,
  status = status,
  id = vin
)

# Example 1 - Reproducibility of drawn random numbers:
set.seed(1234)
mcs_distances &lt;- mcs_mileage(
  x = mcs_tbl,
  distribution = "lognormal"
)

# Example 2 - MCS for distances with exponential annual mileage distribution:
mcs_distances_2 &lt;- mcs_mileage(
  x = mcs_tbl,
  distribution = "exponential"
)

# Example 3 - MCS for distances with downstream probability estimation:
## Apply 'estimate_cdf()' to *$data:
prob_estimation &lt;- estimate_cdf(
  x = mcs_distances$data,
  methods = "kaplan"
)

## Apply 'plot_prob()':
plot_prob_estimation &lt;- plot_prob(prob_estimation)

</code></pre>

<hr>
<h2 id='mcs_mileage_data'>MCS Mileage Data</h2><span id='topic+mcs_mileage_data'></span>

<h3>Description</h3>

<p>Create consistent <code>mcs_mileage_data</code> based on an existing <code>data.frame</code> (preferred)
or on multiple equal length vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcs_mileage_data(
  data = NULL,
  mileage,
  time,
  status = NULL,
  id = NULL,
  .keep_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcs_mileage_data_+3A_data">data</code></td>
<td>
<p>Either <code>NULL</code> or a <code>data.frame</code>. If data is <code>NULL</code>, <code>mileage</code>, <code>time</code>,
<code>status</code> and <code>id</code> must be vectors containing the data. Otherwise <code>mileage</code>, <code>time</code>,
<code>status</code> and <code>id</code> can be either column names or column positions.</p>
</td></tr>
<tr><td><code id="mcs_mileage_data_+3A_mileage">mileage</code></td>
<td>
<p>Covered distances. Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_mileage_data_+3A_time">time</code></td>
<td>
<p>Operating times. Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_mileage_data_+3A_status">status</code></td>
<td>
<p>Optional argument. If used, it must contain binary data
(0 or 1) indicating whether a unit is a right censored observation (= 0) or a
failure (= 1).
</p>
<p>If <code>status</code> is provided, class <code>wt_reliability_data</code> is assigned to the
output of <a href="#topic+mcs_mileage">mcs_mileage</a>, which enables the direct application of <a href="#topic+estimate_cdf">estimate_cdf</a>
on distances.</p>
</td></tr>
<tr><td><code id="mcs_mileage_data_+3A_id">id</code></td>
<td>
<p>Identification of every unit.</p>
</td></tr>
<tr><td><code id="mcs_mileage_data_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code> keep remaining variables in <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with class <code>wt_mcs_mileage_data</code> that is formed for the downstream
Monte Carlo method <a href="#topic+mcs_mileage">mcs_mileage</a>.
It contains the following columns (if <code>.keep_all = FALSE</code>):
</p>

<ul>
<li> <p><code>mileage</code> : Input mileages.
</p>
</li>
<li> <p><code>time</code> : Input operating times.
</p>
</li>
<li> <p><code>status</code> (<strong>optional</strong>) :
</p>

<ul>
<li><p> If <code>is.null(status)</code> column <code>status</code> does not exist.
</p>
</li>
<li><p> If <code>status</code> is provided the column contains the entered binary
data (0 or 1).
</p>
</li></ul>

</li>
<li> <p><code>id</code> : Identification for every unit.
</p>
</li></ul>

<p>If <code>.keep_all = TRUE</code>, the remaining columns of <code>data</code> are also preserved.
</p>
<p>The attribute <code>mcs_characteristic</code> is set to <code>"mileage"</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+dist_mileage">dist_mileage</a> for the determination of a parametric annual mileage
distribution and <a href="#topic+mcs_mileage">mcs_mileage</a> for the Monte Carlo method with respect to
unknown distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 -  Based on an existing data.frame/tibble and column names:
mcs_tbl &lt;- mcs_mileage_data(
  data = field_data,
  mileage = mileage,
  time = dis,
  status = status
)

# Example 2 - Based on an existing data.frame/tibble and column positions:
mcs_tbl_2 &lt;- mcs_mileage_data(
  data = field_data,
  mileage = 3,
  time = 2,
  id = 1
)

# Example 3 - Keep all variables of the tibble/data.frame entered to argument data:
mcs_tbl_3 &lt;- mcs_mileage_data(
  data = field_data,
  mileage = mileage,
  time = dis,
  status = status,
  id = vin,
  .keep_all = TRUE
)

# Example 4 - Based on vectors:
mcs_tbl_4 &lt;- mcs_mileage_data(
  mileage = field_data$mileage,
  time = field_data$dis,
  status = field_data$status,
  id = field_data$vin
)

</code></pre>

<hr>
<h2 id='mcs_mileage.default'>Simulation of Unknown Covered Distances using a Monte Carlo Approach</h2><span id='topic+mcs_mileage.default'></span>

<h3>Description</h3>

<p>This function simulates distances for units where these are unknown.
</p>
<p>First, random numbers of the annual mileage distribution, estimated by
<a href="#topic+dist_mileage">dist_mileage</a>, are drawn. Second, the drawn annual distances are
converted with respect to the actual operating times (in days) using a linear
relationship. See 'Details'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
mcs_mileage(
  x,
  time,
  status = NULL,
  id = paste0("ID", seq_len(length(time))),
  distribution = c("lognormal", "exponential"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcs_mileage.default_+3A_x">x</code></td>
<td>
<p>A numeric vector of distances covered. Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_mileage.default_+3A_time">time</code></td>
<td>
<p>A numeric vector of operating times. Use <code>NA</code> for missing elements.</p>
</td></tr>
<tr><td><code id="mcs_mileage.default_+3A_status">status</code></td>
<td>
<p>Optional argument. If used, it must contain binary data
(0 or 1) indicating whether a unit is a right censored observation (= 0) or a
failure (= 1).
</p>
<p>If <code>status</code> is provided, class <code>wt_reliability_data</code> is assigned to the
output of <a href="#topic+mcs_mileage">mcs_mileage</a>, which enables the direct application of <a href="#topic+estimate_cdf">estimate_cdf</a>
on distances.</p>
</td></tr>
<tr><td><code id="mcs_mileage.default_+3A_id">id</code></td>
<td>
<p>Identification of every unit.</p>
</td></tr>
<tr><td><code id="mcs_mileage.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the annual mileage.</p>
</td></tr>
<tr><td><code id="mcs_mileage.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Assumption of linear relationship</strong>: Imagine the distance of the vehicle
is unknown. A distance of 3500.25 kilometers (km) was drawn from the annual
distribution and the known operating time is 200 days (d). So the resulting
distance of this vehicle is
</p>
<p style="text-align: center;"><code class="reqn">3500.25 km \cdot (\frac{200 d} {365 d}) = 1917.945 km</code>
</p>



<h3>Value</h3>

<p>A list with class <code>wt_mcs_mileage</code> containing the following elements:
</p>

<ul>
<li> <p><code>data</code> : A <code>tibble</code> returned by <a href="#topic+mcs_mileage_data">mcs_mileage_data</a> where two modifications
has been made:
</p>

<ul>
<li><p> If the column <code>status</code> exists, the <code>tibble</code> has additional classes
<code>wt_mcs_data</code> and <code>wt_reliability_data</code>. Otherwise, the <code>tibble</code> only has
the additional class <code>wt_mcs_data</code> (which is not supported by <a href="#topic+estimate_cdf">estimate_cdf</a>).
</p>
</li>
<li><p> The column <code>mileage</code> is renamed to <code>x</code> (to be in accordance with
<a href="#topic+reliability_data">reliability_data</a>) and contains simulated distances for incomplete
observations and input distances for the complete observations.
</p>
</li></ul>

</li>
<li> <p><code>sim_data</code> : A <code>tibble</code> with column <code>sim_mileage</code> that holds the simulated
distances for incomplete cases and <code>0</code> for complete cases.
</p>
</li>
<li> <p><code>model_estimation</code> : A list returned by <a href="#topic+dist_mileage">dist_mileage</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+dist_mileage">dist_mileage</a> for the determination of a parametric annual mileage
distribution and <a href="#topic+estimate_cdf">estimate_cdf</a> for the estimation of failure probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 - Reproducibility of drawn random numbers:
set.seed(1234)
mcs_distances &lt;- mcs_mileage(
  x = field_data$mileage,
  time = field_data$dis,
  status = field_data$status,
  id = field_data$vin,
  distribution = "lognormal"
)

# Example 2 - MCS for distances with exponential annual mileage distribution:
mcs_distances_2 &lt;- mcs_mileage(
  x = field_data$mileage,
  time = field_data$dis,
  status = field_data$status,
  id = field_data$vin,
  distribution = "exponential"
)

# Example 3 - MCS for distances with downstream probability estimation:
## Apply 'estimate_cdf()' to *$data:
prob_estimation &lt;- estimate_cdf(
  x = mcs_distances$data,
  methods = "kaplan"
)

## Apply 'plot_prob()':
plot_prob_estimation &lt;- plot_prob(prob_estimation)

</code></pre>

<hr>
<h2 id='mixmod_em'>Weibull Mixture Model Estimation using EM-Algorithm</h2><span id='topic+mixmod_em'></span><span id='topic+mixmod_em.wt_reliability_data'></span>

<h3>Description</h3>

<p>This method applies the expectation-maximization (EM) algorithm to estimate the
parameters of a univariate Weibull mixture model. See 'Details'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixmod_em(x, ...)

## S3 method for class 'wt_reliability_data'
mixmod_em(
  x,
  distribution = "weibull",
  conf_level = 0.95,
  k = 2,
  method = "EM",
  n_iter = 100L,
  conv_limit = 1e-06,
  diff_loglik = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixmod_em_+3A_x">x</code></td>
<td>
<p>A tibble with class <code>wt_reliability_data</code> returned by <a href="#topic+reliability_data">reliability_data</a>.</p>
</td></tr>
<tr><td><code id="mixmod_em_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="mixmod_em_+3A_distribution">distribution</code></td>
<td>
<p><code>"weibull"</code> until further distributions are implemented.</p>
</td></tr>
<tr><td><code id="mixmod_em_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level for the intervals of the Weibull parameters
of every component <code>k</code>.</p>
</td></tr>
<tr><td><code id="mixmod_em_+3A_k">k</code></td>
<td>
<p>Number of mixture components.</p>
</td></tr>
<tr><td><code id="mixmod_em_+3A_method">method</code></td>
<td>
<p><code>"EM"</code> until other methods are implemented.</p>
</td></tr>
<tr><td><code id="mixmod_em_+3A_n_iter">n_iter</code></td>
<td>
<p>Integer defining the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="mixmod_em_+3A_conv_limit">conv_limit</code></td>
<td>
<p>Numeric value defining the convergence limit.</p>
</td></tr>
<tr><td><code id="mixmod_em_+3A_diff_loglik">diff_loglik</code></td>
<td>
<p>Numeric value defining the maximum difference between
log-likelihood values, which seems permissible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EM algorithm is an iterative algorithm for which starting values must be
defined. Starting values can be provided for the unknown parameter vector as
well as for the posterior probabilities. This implementation employs initial
values for the posterior probabilities. These are assigned randomly
by using the Dirichlet distribution, the conjugate prior of a multinomial
distribution (see Mr. Gelissen's blog post listed under <em>references</em>).
</p>
<p><strong>M-Step</strong> : On the basis of the initial posterior probabilities, the
parameter vector is estimated with <em>Newton-Raphson</em>.
</p>
<p><strong>E-Step</strong> : The actual estimated parameter vector is used to perform an
update of the posterior probabilities.
</p>
<p>This procedure is repeated until the complete log-likelihood has converged.
</p>


<h3>Value</h3>

<p>A list with classes <code>wt_model</code> and <code>wt_mixmod_em</code>. The length of the
list depends on the number of specified subgroups <code>k</code>. The first <code>k</code> lists
contain information provided by <a href="#topic+ml_estimation">ml_estimation</a>. The values of <code>logL</code>, <code>aic</code>
and <code>bic</code> are the results of a weighted log-likelihood, where the weights are
the posterior probabilities determined by the algorithm. The last list summarizes
further results of the EM algorithm and is therefore called <code>em_results</code>. It
contains the following elements:
</p>

<ul>
<li> <p><code>a_priori</code> : A vector with estimated prior probabilities.
</p>
</li>
<li> <p><code>a_posteriori</code> : A matrix with estimated posterior probabilities.
</p>
</li>
<li> <p><code>groups</code> : Numeric vector specifying the group membership of every observation.
</p>
</li>
<li> <p><code>logL</code> : The value of the complete log-likelihood.
</p>
</li>
<li> <p><code>aic</code> : Akaike Information Criterion.
</p>
</li>
<li> <p><code>bic</code> : Bayesian Information Criterion.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Doganaksoy, N.; Hahn, G.; Meeker, W. Q., Reliability Analysis by Failure Mode,
Quality Progress, 35(6), 47-52, 2002
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Reliability data preparation:
## Data for mixture model:
data_mix &lt;- reliability_data(
  voltage,
  x = hours,
  status = status
)

# Example 1 - EM algorithm with k = 2:
mix_mod_em &lt;- mixmod_em(
  x = data_mix,
  conf_level = 0.95,
  k = 2,
  n_iter = 150
)

# Example 2 - Maximum likelihood is applied when k = 1:
mix_mod_em_2 &lt;- mixmod_em(
  x = data_mix,
  conf_level = 0.95,
  k = 1,
  n_iter = 150
)

</code></pre>

<hr>
<h2 id='mixmod_em.default'>Weibull Mixture Model Estimation using EM-Algorithm</h2><span id='topic+mixmod_em.default'></span>

<h3>Description</h3>

<p>This method applies the expectation-maximization (EM) algorithm to estimate the
parameters of a univariate Weibull mixture model. See 'Details'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
mixmod_em(
  x,
  status,
  distribution = "weibull",
  conf_level = 0.95,
  k = 2,
  method = "EM",
  n_iter = 100L,
  conv_limit = 1e-06,
  diff_loglik = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixmod_em.default_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime data
could be every characteristic influencing the reliability of a product, e.g.
operating time (days/months in service), mileage (km, miles), load cycles.</p>
</td></tr>
<tr><td><code id="mixmod_em.default_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is a
right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="mixmod_em.default_+3A_distribution">distribution</code></td>
<td>
<p><code>"weibull"</code> until further distributions are implemented.</p>
</td></tr>
<tr><td><code id="mixmod_em.default_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level for the intervals of the Weibull parameters
of every component <code>k</code>.</p>
</td></tr>
<tr><td><code id="mixmod_em.default_+3A_k">k</code></td>
<td>
<p>Number of mixture components.</p>
</td></tr>
<tr><td><code id="mixmod_em.default_+3A_method">method</code></td>
<td>
<p><code>"EM"</code> until other methods are implemented.</p>
</td></tr>
<tr><td><code id="mixmod_em.default_+3A_n_iter">n_iter</code></td>
<td>
<p>Integer defining the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="mixmod_em.default_+3A_conv_limit">conv_limit</code></td>
<td>
<p>Numeric value defining the convergence limit.</p>
</td></tr>
<tr><td><code id="mixmod_em.default_+3A_diff_loglik">diff_loglik</code></td>
<td>
<p>Numeric value defining the maximum difference between
log-likelihood values, which seems permissible.</p>
</td></tr>
<tr><td><code id="mixmod_em.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EM algorithm is an iterative algorithm for which starting values must be
defined. Starting values can be provided for the unknown parameter vector as
well as for the posterior probabilities. This implementation employs initial
values for the posterior probabilities. These are assigned randomly
by using the Dirichlet distribution, the conjugate prior of a multinomial
distribution (see Mr. Gelissen's blog post listed under <em>references</em>).
</p>
<p><strong>M-Step</strong> : On the basis of the initial posterior probabilities, the
parameter vector is estimated with <em>Newton-Raphson</em>.
</p>
<p><strong>E-Step</strong> : The actual estimated parameter vector is used to perform an
update of the posterior probabilities.
</p>
<p>This procedure is repeated until the complete log-likelihood has converged.
</p>


<h3>Value</h3>

<p>A list with classes <code>wt_model</code> and <code>wt_mixmod_em</code>. The length of the
list depends on the number of specified subgroups <code>k</code>. The first <code>k</code> lists
contain information provided by <a href="#topic+ml_estimation">ml_estimation</a>. The values of <code>logL</code>, <code>aic</code>
and <code>bic</code> are the results of a weighted log-likelihood, where the weights are
the posterior probabilities determined by the algorithm. The last list summarizes
further results of the EM algorithm and is therefore called <code>em_results</code>. It
contains the following elements:
</p>

<ul>
<li> <p><code>a_priori</code> : A vector with estimated prior probabilities.
</p>
</li>
<li> <p><code>a_posteriori</code> : A matrix with estimated posterior probabilities.
</p>
</li>
<li> <p><code>groups</code> : Numeric vector specifying the group membership of every observation.
</p>
</li>
<li> <p><code>logL</code> : The value of the complete log-likelihood.
</p>
</li>
<li> <p><code>aic</code> : Akaike Information Criterion.
</p>
</li>
<li> <p><code>bic</code> : Bayesian Information Criterion.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Doganaksoy, N.; Hahn, G.; Meeker, W. Q., Reliability Analysis by Failure Mode,
Quality Progress, 35(6), 47-52, 2002
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+mixmod_em">mixmod_em</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
hours &lt;- voltage$hours
status &lt;- voltage$status

# Example 1 - EM algorithm with k = 2:
mix_mod_em &lt;- mixmod_em(
  x = hours,
  status = status,
  distribution = "weibull",
  conf_level = 0.95,
  k = 2,
  n_iter = 150
)

#' # Example 2 - Maximum likelihood is applied when k = 1:
mix_mod_em_2 &lt;- mixmod_em(
  x = hours,
  status = status,
  distribution = "weibull",
  conf_level = 0.95,
  k = 1,
  method = "EM",
  n_iter = 150
)

</code></pre>

<hr>
<h2 id='mixmod_regression'>Mixture Model Identification using Segmented Regression</h2><span id='topic+mixmod_regression'></span><span id='topic+mixmod_regression.wt_cdf_estimation'></span>

<h3>Description</h3>

<p>This function uses piecewise linear regression to divide the data into
subgroups. See 'Details'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixmod_regression(x, ...)

## S3 method for class 'wt_cdf_estimation'
mixmod_regression(
  x,
  distribution = c("weibull", "lognormal", "loglogistic"),
  conf_level = 0.95,
  k = 2,
  control = segmented::seg.control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixmod_regression_+3A_x">x</code></td>
<td>
<p>A <code>tibble</code> with class <code>wt_cdf_estimation</code> returned by <a href="#topic+estimate_cdf">estimate_cdf</a>.</p>
</td></tr>
<tr><td><code id="mixmod_regression_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="mixmod_regression_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="mixmod_regression_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level of the interval.</p>
</td></tr>
<tr><td><code id="mixmod_regression_+3A_k">k</code></td>
<td>
<p>Number of mixture components. If the data should be split in an
automated fashion, <code>k</code> must be set to <code>NULL</code>. The argument <code>fix.psi</code> of
<code>control</code> is then set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mixmod_regression_+3A_control">control</code></td>
<td>
<p>Output of the call to <a href="segmented.html#topic+seg.control">seg.control</a>,
which is passed to <a href="segmented.html#topic+segmented">segmented.lm</a>. See 'Examples' for usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The segmentation process is based on the lifetime realizations of failed
units and their corresponding estimated failure probabilities for which intact
items are taken into account. It is performed with the support of
<a href="segmented.html#topic+segmented">segmented.lm</a>.
</p>
<p>Segmentation can be done with a specified number of subgroups or in an automated
fashion (see argument <code>k</code>). The algorithm tends to overestimate the number of
breakpoints when the separation is done automatically (see 'Warning' in
<a href="segmented.html#topic+segmented">segmented.lm</a>).
</p>
<p>In the context of reliability analysis it is important that the main types of
failures can be identified and analyzed separately. These are
</p>

<ul>
<li><p> early failures,
</p>
</li>
<li><p> random failures and
</p>
</li>
<li><p> wear-out failures.
</p>
</li></ul>

<p>In order to reduce the risk of overestimation as well as being able to consider
the main types of failures, a maximum of three subgroups (<code>k = 3</code>) is recommended.
</p>


<h3>Value</h3>

<p>A list with classes <code>wt_model</code> and <code>wt_rank_regression</code> if no breakpoint
was detected. See <a href="#topic+rank_regression">rank_regression</a>.
</p>
<p>A list with classes <code>wt_model</code> and <code>wt_mixmod_regression</code> if at least one
breakpoint was determined. The length of the list depends on the number of
identified subgroups. Each list element contains the information provided by
<a href="#topic+rank_regression">rank_regression</a>. In addition, the returned tibble <code>data</code> of each list element
only retains information on the failed units and has two more columns:
</p>

<ul>
<li> <p><code>q</code> : Quantiles of the standard distribution calculated from column <code>prob</code>.
</p>
</li>
<li> <p><code>group</code> : Membership to the respective segment.
</p>
</li></ul>

<p>If more than one method was specified in <a href="#topic+estimate_cdf">estimate_cdf</a>, the resulting output
is a list with classes <code>wt_model</code> and <code>wt_mixmod_regression_list</code> where each
list element has classes <code>wt_model</code> and <code>wt_mixmod_regression</code>.
</p>


<h3>References</h3>

<p>Doganaksoy, N.; Hahn, G.; Meeker, W. Q., Reliability Analysis by
Failure Mode, Quality Progress, 35(6), 47-52, 2002
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reliability data preparation:
## Data for mixture model:
data_mix &lt;- reliability_data(
  voltage,
  x = hours,
  status = status
)

## Data for simple unimodal distribution:
data &lt;- reliability_data(
  shock,
  x = distance,
  status = status
)

# Probability estimation with one method:
prob_mix &lt;- estimate_cdf(
  data_mix,
  methods = "johnson"
)

prob &lt;- estimate_cdf(
  data,
  methods = "johnson"
)

# Probability estimation for multiple methods:
prob_mix_mult &lt;- estimate_cdf(
  data_mix,
  methods = c("johnson", "kaplan", "nelson")
)

# Example 1 - Mixture identification using k = 2 two-parametric Weibull models:
mix_mod_weibull &lt;- mixmod_regression(
  x = prob_mix,
  distribution = "weibull",
  conf_level = 0.99,
  k = 2
)

# Example 2 - Mixture identification using k = 3 two-parametric lognormal models:
mix_mod_lognorm &lt;- mixmod_regression(
  x = prob_mix,
  distribution = "lognormal",
  k = 3
)

# Example 3 - Mixture identification for multiple methods specified in estimate_cdf:
mix_mod_mult &lt;- mixmod_regression(
  x = prob_mix_mult,
  distribution = "loglogistic"
)

# Example 4 - Mixture identification using control argument:
mix_mod_control &lt;- mixmod_regression(
  x = prob_mix,
  distribution = "weibull",
  control = segmented::seg.control(display = TRUE)
)

# Example 5 - Mixture identification performs rank_regression for k = 1:
mod &lt;- mixmod_regression(
  x = prob,
  distribution = "weibull",
  k = 1
)

</code></pre>

<hr>
<h2 id='mixmod_regression.default'>Mixture Model Identification using Segmented Regression</h2><span id='topic+mixmod_regression.default'></span>

<h3>Description</h3>

<p>This function uses piecewise linear regression to divide the data into
subgroups. See 'Details'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
mixmod_regression(
  x,
  y,
  status,
  distribution = c("weibull", "lognormal", "loglogistic"),
  conf_level = 0.95,
  k = 2,
  control = segmented::seg.control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixmod_regression.default_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime data
could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="mixmod_regression.default_+3A_y">y</code></td>
<td>
<p>A numeric vector which consists of estimated failure probabilities
regarding the lifetime data in <code>x</code>.</p>
</td></tr>
<tr><td><code id="mixmod_regression.default_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="mixmod_regression.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="mixmod_regression.default_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level of the interval.</p>
</td></tr>
<tr><td><code id="mixmod_regression.default_+3A_k">k</code></td>
<td>
<p>Number of mixture components. If the data should be split in an
automated fashion, <code>k</code> must be set to <code>NULL</code>. The argument <code>fix.psi</code> of
<code>control</code> is then set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mixmod_regression.default_+3A_control">control</code></td>
<td>
<p>Output of the call to <a href="segmented.html#topic+seg.control">seg.control</a>,
which is passed to <a href="segmented.html#topic+segmented">segmented.lm</a>. See 'Examples' for usage.</p>
</td></tr>
<tr><td><code id="mixmod_regression.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The segmentation process is based on the lifetime realizations of failed
units and their corresponding estimated failure probabilities for which intact
items are taken into account. It is performed with the support of
<a href="segmented.html#topic+segmented">segmented.lm</a>.
</p>
<p>Segmentation can be done with a specified number of subgroups or in an automated
fashion (see argument <code>k</code>). The algorithm tends to overestimate the number of
breakpoints when the separation is done automatically (see 'Warning' in
<a href="segmented.html#topic+segmented">segmented.lm</a>).
</p>
<p>In the context of reliability analysis it is important that the main types of
failures can be identified and analyzed separately. These are
</p>

<ul>
<li><p> early failures,
</p>
</li>
<li><p> random failures and
</p>
</li>
<li><p> wear-out failures.
</p>
</li></ul>

<p>In order to reduce the risk of overestimation as well as being able to consider
the main types of failures, a maximum of three subgroups (<code>k = 3</code>) is recommended.
</p>


<h3>Value</h3>

<p>A list with classes <code>wt_model</code> and <code>wt_rank_regression</code> if no breakpoint
was detected. See <a href="#topic+rank_regression">rank_regression</a>. The returned tibble <code>data</code> is of class
<code>wt_cdf_estimation</code> and contains the dummy columns <code>cdf_estimation_method</code> and
<code>id</code>. The former is filled with <code>NA_character</code>, due to internal usage and the
latter is filled with <code>"XXXXXX"</code> to point out that unit identification is not
possible when using the vector-based approach.
</p>
<p>A list with classes <code>wt_model</code> and <code>wt_mixmod_regression</code> if at least one
breakpoint was determined. The length of the list depends on the number of
identified subgroups. Each list contains the information provided by
<a href="#topic+rank_regression">rank_regression</a>. The returned tibble <code>data</code> of each list element only retains
information on the failed units and has modified and additional columns:
</p>

<ul>
<li> <p><code>id</code> : Modified id, overwritten with <code>"XXXXXX"</code> to point out that unit
identification is not possible when using the vector-based approach.
</p>
</li>
<li> <p><code>cdf_estimation_method</code> : A character that is always <code>NA_character</code>. Only
needed for internal use.
</p>
</li>
<li> <p><code>q</code> : Quantiles of the standard distribution calculated from column <code>prob</code>.
</p>
</li>
<li> <p><code>group</code> : Membership to the respective segment.
</p>
</li></ul>



<h3>References</h3>

<p>Doganaksoy, N.; Hahn, G.; Meeker, W. Q., Reliability Analysis by
Failure Mode, Quality Progress, 35(6), 47-52, 2002
</p>


<h3>See Also</h3>

<p><a href="#topic+mixmod_regression">mixmod_regression</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
## Data for mixture model:
hours &lt;- voltage$hours
status &lt;- voltage$status

## Data for simple unimodal distribution:
distance &lt;- shock$distance
status_2 &lt;- shock$status

# Probability estimation with one method:
prob_mix &lt;- estimate_cdf(
  x = hours,
  status = status,
  method = "johnson"
)

prob &lt;- estimate_cdf(
  x = distance,
  status = status_2,
  method = "johnson"
)

 # Example 1 - Mixture identification using k = 2 two-parametric Weibull models:
mix_mod_weibull &lt;- mixmod_regression(
   x = prob_mix$x,
   y = prob_mix$prob,
   status = prob_mix$status,
   distribution = "weibull",
   conf_level = 0.99,
   k = 2
)

# Example 2 - Mixture identification using k = 3 two-parametric lognormal models:
mix_mod_lognorm &lt;- mixmod_regression(
   x = prob_mix$x,
   y = prob_mix$prob,
   status = prob_mix$status,
   distribution = "lognormal",
   k = 3
)

# Example 3 - Mixture identification using control argument:
mix_mod_control &lt;- mixmod_regression(
  x = prob_mix$x,
  y = prob_mix$prob,
  status = prob_mix$status,
  distribution = "weibull",
  k = 2,
  control = segmented::seg.control(display = TRUE)
)

# Example 4 - Mixture identification performs rank_regression for k = 1:
mod &lt;- mixmod_regression(
  x = prob$x,
  y = prob$prob,
  status = prob$status,
  distribution = "weibull",
  k = 1
)

</code></pre>

<hr>
<h2 id='mixture_em_cpp'>EM-Algorithm using Newton-Raphson Method</h2><span id='topic+mixture_em_cpp'></span>

<h3>Description</h3>

<p>This method uses the EM-Algorithm to estimate the parameters of a univariate
mixture model. Until now, the mixture model can consist of k two-parametric
Weibull distributions. The Weibull distributions are parameterized with scale
<code class="reqn">\eta</code> and shape <code class="reqn">\beta</code>. In M-step these parameters are estimated using
Newton-Raphson. This function is implemented in c++ and is called in function
<code><a href="#topic+mixmod_em">mixmod_em</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixture_em_cpp(
  x,
  status,
  post,
  distribution = "weibull",
  k = 2L,
  method = "EM",
  n_iter = 100L,
  conv_limit = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixture_em_cpp_+3A_x">x</code></td>
<td>
<p>a numeric vector which consists of lifetime data. Lifetime
data could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="mixture_em_cpp_+3A_status">status</code></td>
<td>
<p>a vector of binary data (0 or 1) indicating whether unit <em>i</em>
is a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="mixture_em_cpp_+3A_post">post</code></td>
<td>
<p>a numeric matrix specifying initial a-posteriori probabilities.
The number of rows have to be in line with observations <code>x</code> and the
number of columns must equal the mixture components <code>k</code>.</p>
</td></tr>
<tr><td><code id="mixture_em_cpp_+3A_distribution">distribution</code></td>
<td>
<p>supposed distribution of mixture model components.
The value must be <code>"weibull"</code>. Other distributions have not been
implemented yet.</p>
</td></tr>
<tr><td><code id="mixture_em_cpp_+3A_k">k</code></td>
<td>
<p>integer of mixture components, default is 2.</p>
</td></tr>
<tr><td><code id="mixture_em_cpp_+3A_method">method</code></td>
<td>
<p>default method is <code>"EM"</code>. Other methods have not been
implemented yet.</p>
</td></tr>
<tr><td><code id="mixture_em_cpp_+3A_n_iter">n_iter</code></td>
<td>
<p>integer defining the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="mixture_em_cpp_+3A_conv_limit">conv_limit</code></td>
<td>
<p>numeric value defining the convergence limit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>

<ul>
<li> <p><code>coefficients</code> : A matrix with estimated Weibull parameters. In the
first row the estimated scale parameters <code class="reqn">\eta</code> and in the second the
estimated shape parameters <code class="reqn">\beta</code> are provided. The first column belongs
to the first mixture component and so forth.
</p>
</li>
<li> <p><code>posteriori</code> : A matrix with estimated a-posteriori probabilities.
</p>
</li>
<li> <p><code>priori</code> : A vector with estimated a-priori probabilities.
</p>
</li>
<li> <p><code>logL</code> : The value of the complete log-likelihood.</p>
</li></ul>



<h3>References</h3>

<p>Doganaksoy, N.; Hahn, G.; Meeker, W. Q., Reliability Analysis by
Failure Mode, Quality Progress, 35(6), 47-52, 2002
</p>

<hr>
<h2 id='ml_estimation'>ML Estimation for Parametric Lifetime Distributions</h2><span id='topic+ml_estimation'></span><span id='topic+ml_estimation.wt_reliability_data'></span>

<h3>Description</h3>

<p>This function estimates the parameters of a parametric lifetime distribution
for complete and (multiple) right-censored data. The parameters
are determined in the frequently used (log-)location-scale parameterization.
</p>
<p>For the Weibull, estimates are additionally transformed such that they are in
line with the parameterization provided by the <em>stats</em> package
(see <a href="stats.html#topic+Weibull">Weibull</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ml_estimation(x, ...)

## S3 method for class 'wt_reliability_data'
ml_estimation(
  x,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2"),
  wts = rep(1, nrow(x)),
  conf_level = 0.95,
  start_dist_params = NULL,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ml_estimation_+3A_x">x</code></td>
<td>
<p>A <code>tibble</code> with class <code>wt_reliability_data</code> returned by <a href="#topic+reliability_data">reliability_data</a>.</p>
</td></tr>
<tr><td><code id="ml_estimation_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="ml_estimation_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="ml_estimation_+3A_wts">wts</code></td>
<td>
<p>Optional vector of case weights. The length of <code>wts</code> must be equal
to the number of observations in <code>x</code>.</p>
</td></tr>
<tr><td><code id="ml_estimation_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level of the interval.</p>
</td></tr>
<tr><td><code id="ml_estimation_+3A_start_dist_params">start_dist_params</code></td>
<td>
<p>Optional vector with initial values of the
(log-)location-scale parameters.</p>
</td></tr>
<tr><td><code id="ml_estimation_+3A_control">control</code></td>
<td>
<p>A list of control parameters (see 'Details' and
<a href="stats.html#topic+optim">optim</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within <code>ml_estimation</code>, <a href="stats.html#topic+optim">optim</a> is called with <code>method = "BFGS"</code>
and <code>control$fnscale = -1</code> to estimate the parameters that maximize the
log-likelihood (see <a href="#topic+loglik_function">loglik_function</a>). For threshold models, the profile
log-likelihood is maximized in advance (see <a href="#topic+loglik_profiling">loglik_profiling</a>). Once the
threshold parameter is determined, the threshold model is treated like a
distribution without threshold (lifetime is reduced by threshold estimate)
and the general optimization routine is applied.
</p>
<p>Normal approximation confidence intervals for the parameters are computed as well.
</p>


<h3>Value</h3>

<p>A list with classes <code>wt_model</code>, <code>wt_ml_estimation</code> and <code>wt_model_estimation</code>
which contains:
</p>

<ul>
<li> <p><code>coefficients</code> : A named vector of estimated coefficients (parameters of the
assumed distribution). <strong>Note</strong>: The parameters are given in the
(log-)location-scale-parameterization.
</p>
</li>
<li> <p><code>confint</code> : Confidence intervals for the (log-)location-scale parameters.
</p>
</li>
<li> <p><code>shape_scale_coefficients</code> : Only included if <code>distribution</code> is <code>"weibull"</code>
or <code>"weibull3"</code> (parameterization used in <a href="stats.html#topic+Weibull">Weibull</a>).
</p>
</li>
<li> <p><code>shape_scale_confint</code> : Only included if <code>distribution</code> is <code>"weibull"</code>
or <code>"weibull3"</code>. Confidence intervals for scale <code class="reqn">\eta</code> and shape <code class="reqn">\beta</code>
(and threshold <code class="reqn">\gamma</code> if <code>distribution = "weibull3"</code>).
</p>
</li>
<li> <p><code>varcov</code> : Estimated variance-covariance matrix of (log-)location-scale parameters.
</p>
</li>
<li> <p><code>logL</code> : The log-likelihood value.
</p>
</li>
<li> <p><code>aic</code> : Akaike Information Criterion.
</p>
</li>
<li> <p><code>bic</code> : Bayesian Information Criterion.
</p>
</li>
<li> <p><code>data</code> : A <code>tibble</code> with class <code>wt_reliability_data</code> returned by
</p>
</li>
<li> <p><code>distribution</code> : Specified distribution.
</p>
</li></ul>



<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reliability data preparation:
## Data for two-parametric model:
data_2p &lt;- reliability_data(
  shock,
  x = distance,
  status = status
)

## Data for three-parametric model:
data_3p &lt;- reliability_data(
  alloy,
  x = cycles,
  status = status
)

# Example 1 - Fitting a two-parametric weibull distribution:
ml_2p &lt;- ml_estimation(
  data_2p,
  distribution = "weibull"
)

# Example 2 - Fitting a three-parametric lognormal distribution:
ml_3p &lt;- ml_estimation(
  data_3p,
  distribution = "lognormal3",
  conf_level = 0.99
)

</code></pre>

<hr>
<h2 id='ml_estimation.default'>ML Estimation for Parametric Lifetime Distributions</h2><span id='topic+ml_estimation.default'></span>

<h3>Description</h3>

<p>This function estimates the parameters of a parametric lifetime distribution
for complete and (multiple) right-censored data. The parameters
are determined in the frequently used (log-)location-scale parameterization.
</p>
<p>For the Weibull, estimates are additionally transformed such that they are in
line with the parameterization provided by the <em>stats</em> package
(see <a href="stats.html#topic+Weibull">Weibull</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
ml_estimation(
  x,
  status,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2"),
  wts = rep(1, length(x)),
  conf_level = 0.95,
  start_dist_params = NULL,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ml_estimation.default_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime data
could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="ml_estimation.default_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="ml_estimation.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="ml_estimation.default_+3A_wts">wts</code></td>
<td>
<p>Optional vector of case weights. The length of <code>wts</code> must be equal
to the number of observations in <code>x</code>.</p>
</td></tr>
<tr><td><code id="ml_estimation.default_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level of the interval.</p>
</td></tr>
<tr><td><code id="ml_estimation.default_+3A_start_dist_params">start_dist_params</code></td>
<td>
<p>Optional vector with initial values of the
(log-)location-scale parameters.</p>
</td></tr>
<tr><td><code id="ml_estimation.default_+3A_control">control</code></td>
<td>
<p>A list of control parameters (see 'Details' and
<a href="stats.html#topic+optim">optim</a>).</p>
</td></tr>
<tr><td><code id="ml_estimation.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within <code>ml_estimation</code>, <a href="stats.html#topic+optim">optim</a> is called with <code>method = "BFGS"</code>
and <code>control$fnscale = -1</code> to estimate the parameters that maximize the
log-likelihood (see <a href="#topic+loglik_function">loglik_function</a>). For threshold models, the profile
log-likelihood is maximized in advance (see <a href="#topic+loglik_profiling">loglik_profiling</a>). Once the
threshold parameter is determined, the threshold model is treated like a
distribution without threshold (lifetime is reduced by threshold estimate)
and the general optimization routine is applied.
</p>
<p>Normal approximation confidence intervals for the parameters are computed as well.
</p>


<h3>Value</h3>

<p>A list with classes <code>wt_model</code>, <code>wt_ml_estimation</code> and <code>wt_model_estimation</code>
which contains:
</p>

<ul>
<li> <p><code>coefficients</code> : A named vector of estimated coefficients (parameters of the
assumed distribution). <strong>Note</strong>: The parameters are given in the
(log-)location-scale-parameterization.
</p>
</li>
<li> <p><code>confint</code> : Confidence intervals for the (log-)location-scale parameters.
</p>
</li>
<li> <p><code>shape_scale_coefficients</code> : Only included if <code>distribution</code> is <code>"weibull"</code>
or <code>"weibull3"</code> (parameterization used in <a href="stats.html#topic+Weibull">Weibull</a>).
</p>
</li>
<li> <p><code>shape_scale_confint</code> : Only included if <code>distribution</code> is <code>"weibull"</code>
or <code>"weibull3"</code>. Confidence intervals for scale <code class="reqn">\eta</code> and shape <code class="reqn">\beta</code>
(and threshold <code class="reqn">\gamma</code> if <code>distribution = "weibull3"</code>).
</p>
</li>
<li> <p><code>varcov</code> : Estimated variance-covariance matrix of (log-)location-scale parameters.
</p>
</li>
<li> <p><code>logL</code> : The log-likelihood value.
</p>
</li>
<li> <p><code>aic</code> : Akaike Information Criterion.
</p>
</li>
<li> <p><code>bic</code> : Bayesian Information Criterion.
</p>
</li>
<li> <p><code>data</code> : A <code>tibble</code> with columns <code>x</code> and <code>status</code>.
</p>
</li>
<li> <p><code>distribution</code> : Specified distribution.
</p>
</li></ul>



<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>See Also</h3>

<p><a href="#topic+ml_estimation">ml_estimation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
obs &lt;- seq(10000, 100000, 10000)
status_1 &lt;- c(0, 1, 1, 0, 0, 0, 1, 0, 1, 0)

cycles &lt;- alloy$cycles
status_2 &lt;- alloy$status

# Example 1 - Fitting a two-parametric weibull distribution:
ml &lt;- ml_estimation(
  x = obs,
  status = status_1,
  distribution = "weibull",
  conf_level = 0.90
)

# Example 2 - Fitting a three-parametric lognormal distribution:
ml_2 &lt;- ml_estimation(
  x = cycles,
  status = status_2,
  distribution = "lognormal3"
)

</code></pre>

<hr>
<h2 id='mr_method'>Estimation of Failure Probabilities using Median Ranks</h2><span id='topic+mr_method'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><code>mr_method()</code> is no longer under active development, switching to <a href="#topic+estimate_cdf">estimate_cdf</a>
is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mr_method(
  x,
  status = rep(1, length(x)),
  id = NULL,
  method = c("benard", "invbeta"),
  ties.method = c("max", "min", "average")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mr_method_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime
data could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="mr_method_+3A_status">status</code></td>
<td>
<p>A vector of ones indicating that every unit has failed.</p>
</td></tr>
<tr><td><code id="mr_method_+3A_id">id</code></td>
<td>
<p>A vector for the identification of every unit. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mr_method_+3A_method">method</code></td>
<td>
<p>Method for the estimation of the cdf. Can be <code>"benard"</code> (default)
or <code>"invbeta"</code>.</p>
</td></tr>
<tr><td><code id="mr_method_+3A_ties.method">ties.method</code></td>
<td>
<p>A character string specifying how ties are treated,
default is <code>"max"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This non-parametric approach (<em>Median Ranks</em>) is used to estimate the
failure probabilities in terms of complete data. Two methods are available to
estimate the cumulative distribution function <em>F(t)</em>:
</p>

<ul>
<li> <p><code>"benard"</code> : Benard's approximation for Median Ranks.
</p>
</li>
<li> <p><code>"invbeta"</code> : Exact Median Ranks using the inverse beta distribution.
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble with only failed units containing the following columns:
</p>

<ul>
<li> <p><code>id</code> : Identification for every unit.
</p>
</li>
<li> <p><code>x</code> : Lifetime characteristic.
</p>
</li>
<li> <p><code>status</code> : Status of failed units (always 1).
</p>
</li>
<li> <p><code>rank</code> : Assigned ranks.
</p>
</li>
<li> <p><code>prob</code> : Estimated failure probabilities.
</p>
</li>
<li> <p><code>cdf_estimation_method</code> : Specified method for the estimation of failure
probabilities (always 'mr').
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
obs   &lt;- seq(10000, 100000, 10000)
state &lt;- rep(1, length(obs))
uic   &lt;- c("3435", "1203", "958X", "XX71", "abcd", "tz46",
           "fl29", "AX23", "Uy12", "kl1a")

# Example 1 - Benard's approximation:
tbl_mr &lt;- mr_method(
  x = obs,
  status = state,
  id = uic,
  method = "benard"
)

# Example 2 - Inverse beta distribution:
tbl_mr_invbeta &lt;- mr_method(
  x = obs,
  status = state,
  method = "invbeta"
)

</code></pre>

<hr>
<h2 id='nelson_method'>Estimation of Failure Probabilities using the Nelson-Aalen Estimator</h2><span id='topic+nelson_method'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><code>nelson_method()</code> is no longer under active development, switching to
<a href="#topic+estimate_cdf">estimate_cdf</a> is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nelson_method(x, status, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nelson_method_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime
data could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="nelson_method_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="nelson_method_+3A_id">id</code></td>
<td>
<p>A vector for the identification of every unit. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This non-parametric approach estimates the cumulative hazard rate in
terms of (multiple) right censored data. By equating the definition of the
hazard rate with the hazard rate according to Nelson-Aalen one can calculate
the failure probabilities.
</p>


<h3>Value</h3>

<p>A tibble containing the following columns:
</p>

<ul>
<li> <p><code>id</code> : Identification for every unit.
</p>
</li>
<li> <p><code>x</code> : Lifetime characteristic.
</p>
</li>
<li> <p><code>status</code> : Binary data (0 or 1) indicating whether a unit is a right
censored observation (= 0) or a failure (= 1).
</p>
</li>
<li> <p><code>rank</code> : Filled with <code>NA</code>.
</p>
</li>
<li> <p><code>prob</code> : Estimated failure probabilities, <code>NA</code> if <code>status = 0</code>.
</p>
</li>
<li> <p><code>cdf_estimation_method</code> : Specified method for the estimation of failure
probabilities (always 'nelson').
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
obs   &lt;- seq(10000, 100000, 10000)
state &lt;- c(0, 1, 1, 0, 0, 0, 1, 0, 1, 0)
uic   &lt;- c("3435", "1203", "958X", "XX71", "abcd", "tz46",
           "fl29", "AX23","Uy12", "kl1a")

# Example - Nelson-Aalen estimator applied to intact and failed units:
tbl_nel &lt;- nelson_method(
  x = obs,
  status = state,
  id = uic
)

</code></pre>

<hr>
<h2 id='plot_conf'>Add Confidence Region(s) for Quantiles and Probabilities</h2><span id='topic+plot_conf'></span><span id='topic+plot_conf.wt_confint'></span>

<h3>Description</h3>

<p>This function is used to add estimated confidence region(s) to an existing
probability plot. Since confidence regions are related to the estimated
regression line, the latter is provided as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_conf(p_obj, x, ...)

## S3 method for class 'wt_confint'
plot_conf(
  p_obj,
  x,
  title_trace_mod = "Fit",
  title_trace_conf = "Confidence Limit",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_conf_+3A_p_obj">p_obj</code></td>
<td>
<p>A plot object returned by <a href="#topic+plot_prob">plot_prob</a>.</p>
</td></tr>
<tr><td><code id="plot_conf_+3A_x">x</code></td>
<td>
<p>A tibble with class <code>wt_confint</code> returned by <a href="#topic+confint_betabinom">confint_betabinom</a> or
<a href="#topic+confint_fisher">confint_fisher</a>.</p>
</td></tr>
<tr><td><code id="plot_conf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="plot_conf_+3A_title_trace_mod">title_trace_mod</code></td>
<td>
<p>A character string which is assigned to the model trace
in the legend.</p>
</td></tr>
<tr><td><code id="plot_conf_+3A_title_trace_conf">title_trace_conf</code></td>
<td>
<p>A character string which is assigned to the confidence
trace in the legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object containing the probability plot with plotting positions,
the estimated regression line and the estimated confidence region(s).
</p>


<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reliability data:
data &lt;- reliability_data(data = alloy, x = cycles, status = status)

# Probability estimation:
prob_tbl &lt;- estimate_cdf(data, methods = "johnson")

# Example 1 - Probability Plot, Regression Line and Confidence Bounds for Three-Parameter-Weibull:
rr &lt;- rank_regression(prob_tbl, distribution = "weibull3")

conf_betabin &lt;- confint_betabinom(rr)

plot_weibull &lt;- plot_prob(prob_tbl, distribution = "weibull")

plot_conf_beta &lt;- plot_conf(
  p_obj = plot_weibull,
  x = conf_betabin
)

# Example 2 - Probability Plot, Regression Line and Confidence Bounds for Three-Parameter-Lognormal:
rr_ln &lt;- rank_regression(
  prob_tbl,
  distribution = "lognormal3",
  conf_level = 0.9
)

conf_betabin_ln &lt;- confint_betabinom(
  rr_ln,
  bounds = "two_sided",
  conf_level = 0.9,
  direction = "y"
)

plot_lognormal &lt;- plot_prob(prob_tbl, distribution = "lognormal")

plot_conf_beta_ln &lt;- plot_conf(
  p_obj = plot_lognormal,
  x = conf_betabin_ln
)

# Example 3 - Probability Plot, Regression Line and Confidence Bounds for MLE
ml &lt;- ml_estimation(data, distribution = "weibull")

conf_fisher &lt;- confint_fisher(ml)

plot_weibull &lt;- plot_prob(prob_tbl, distribution = "weibull")

plot_conf_fisher_weibull &lt;- plot_conf(
  p_obj = plot_weibull,
  x = conf_fisher
)

</code></pre>

<hr>
<h2 id='plot_conf.default'>Add Confidence Region(s) for Quantiles and Probabilities</h2><span id='topic+plot_conf.default'></span>

<h3>Description</h3>

<p>This function is used to add estimated confidence region(s) to an existing
probability plot which also includes the estimated regression line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
plot_conf(
  p_obj,
  x,
  y,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2"),
  direction = c("y", "x"),
  title_trace = "Confidence Limit",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_conf.default_+3A_p_obj">p_obj</code></td>
<td>
<p>A plot object returned by <a href="#topic+plot_mod">plot_mod</a>.</p>
</td></tr>
<tr><td><code id="plot_conf.default_+3A_x">x</code></td>
<td>
<p>A list containing the x-coordinates of the confidence region(s). The
list can be of length 1 or 2. For more information see <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="plot_conf.default_+3A_y">y</code></td>
<td>
<p>A list containing the y-coordinates of the Confidence Region(s).
The list can be of length 1 or 2. For more information see <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="plot_conf.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="plot_conf.default_+3A_direction">direction</code></td>
<td>
<p>A character string specifying the direction of the plotted
interval(s). <code>"y"</code> for failure probabilities or <code>"x"</code> for quantiles.</p>
</td></tr>
<tr><td><code id="plot_conf.default_+3A_title_trace">title_trace</code></td>
<td>
<p>A character string which is assigned to the legend trace.</p>
</td></tr>
<tr><td><code id="plot_conf.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is important that the length of the vectors provided as lists in <code>x</code> and
<code>y</code> match with the length of the vectors <code>x</code> and <code>y</code> in the function <a href="#topic+plot_mod">plot_mod</a>.
For this reason the following procedure is recommended:
</p>

<ul>
<li><p> Calculate confidence intervals with the function <a href="#topic+confint_betabinom">confint_betabinom</a> or
<a href="#topic+confint_fisher">confint_fisher</a> and store it in a <code>data.frame</code>. For instance call it df.
</p>
</li>
<li><p> Inside <a href="#topic+plot_mod">plot_mod</a> use the output <code>df$x</code> for <code>x</code> and <code>df$prob</code> for <code>y</code> of
the function(s) named before.
</p>
</li>
<li><p> In <strong>Examples</strong> the described approach is shown with code.
</p>
</li></ul>



<h3>Value</h3>

<p>A plot object containing the probability plot with plotting positions,
the estimated regression line and the estimated confidence region(s).
</p>


<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_conf">plot_conf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
cycles &lt;- alloy$cycles
status &lt;- alloy$status

prob_tbl &lt;- estimate_cdf(x = cycles, status = status, method = "johnson")

# Example 1 - Probability Plot, Regression Line and Confidence Bounds for Three-Parameter-Weibull:
rr &lt;- rank_regression(
  x = prob_tbl$x,
  y = prob_tbl$prob,
  status = prob_tbl$status,
  distribution = "weibull3"
)

conf_betabin &lt;- confint_betabinom(
  x = prob_tbl$x,
  status = prob_tbl$status,
  dist_params = rr$coefficients,
  distribution = "weibull3"
)

plot_weibull &lt;- plot_prob(
  x = prob_tbl$x,
  y = prob_tbl$prob,
  status = prob_tbl$status,
  id = prob_tbl$id,
  distribution = "weibull"
)

plot_reg_weibull &lt;- plot_mod(
  p_obj = plot_weibull,
  x = conf_betabin$x,
  y = conf_betabin$prob,
  dist_params = rr$coefficients,
  distribution = "weibull3"
)

plot_conf_beta &lt;- plot_conf(
  p_obj = plot_reg_weibull,
  x = list(conf_betabin$x),
  y = list(conf_betabin$lower_bound, conf_betabin$upper_bound),
  direction = "y",
  distribution = "weibull3"
)

# Example 2 - Probability Plot, Regression Line and Confidence Bounds for Three-Parameter-Lognormal:
rr_ln &lt;- rank_regression(
  x = prob_tbl$x,
  y = prob_tbl$prob,
  status = prob_tbl$status,
  distribution = "lognormal3"
)

conf_betabin_ln &lt;- confint_betabinom(
  x = prob_tbl$x,
  status = prob_tbl$status,
  dist_params = rr_ln$coefficients,
  distribution = "lognormal3"
)

plot_lognormal &lt;- plot_prob(
  x = prob_tbl$x,
  y = prob_tbl$prob,
  status = prob_tbl$status,
  id = prob_tbl$id,
  distribution = "lognormal"
)

plot_reg_lognormal &lt;- plot_mod(
  p_obj = plot_lognormal,
  x = conf_betabin_ln$x,
  y = conf_betabin_ln$prob,
  dist_params = rr_ln$coefficients,
  distribution = "lognormal3"
)

plot_conf_beta_ln &lt;- plot_conf(
  p_obj = plot_reg_lognormal,
  x = list(conf_betabin_ln$x),
  y = list(conf_betabin_ln$lower_bound, conf_betabin_ln$upper_bound),
  direction = "y",
  distribution = "lognormal3"
)

</code></pre>

<hr>
<h2 id='plot_layout'>Layout of the Probability Plot</h2><span id='topic+plot_layout'></span>

<h3>Description</h3>

<p>This function is used to create the layout of a probability plot. It is
called inside of <a href="#topic+plot_prob">plot_prob</a> to determine the appearance of the grid with
respect to the given characteristic <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_layout(
  x,
  y = NULL,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "exponential"),
  title_main = "Probability Plot",
  title_x = "Characteristic",
  title_y = "Unreliability",
  plot_method = c("plotly", "ggplot2")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_layout_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. <code>x</code> is used to
specify the grid of the plot.</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_y">y</code></td>
<td>
<p>Optional argument. If used, it is a numeric vector which consists of
failure probabilities with respect to <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_title_main">title_main</code></td>
<td>
<p>A character string which is assigned to the main title.</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_title_x">title_x</code></td>
<td>
<p>A character string which is assigned to the title of the x axis.</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_title_y">title_y</code></td>
<td>
<p>A character string which is assigned to the title of the y axis.</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_plot_method">plot_method</code></td>
<td>
<p>Package, which is used for generating the plot output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object containing the layout of the probability plot.
</p>

<hr>
<h2 id='plot_mod'>Add Estimated Population Line(s) to a Probability Plot</h2><span id='topic+plot_mod'></span><span id='topic+plot_mod.wt_model'></span>

<h3>Description</h3>

<p>This function adds one or multiple estimated regression lines to an existing
probability plot (<a href="#topic+plot_prob">plot_prob</a>). Depending on the output of the functions
<a href="#topic+rank_regression">rank_regression</a>, <a href="#topic+ml_estimation">ml_estimation</a>, <a href="#topic+mixmod_regression">mixmod_regression</a> or <a href="#topic+mixmod_em">mixmod_em</a> one or
multiple lines are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mod(p_obj, x, ...)

## S3 method for class 'wt_model'
plot_mod(p_obj, x, title_trace = "Fit", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mod_+3A_p_obj">p_obj</code></td>
<td>
<p>A plot object returned by <a href="#topic+plot_prob">plot_prob</a>.</p>
</td></tr>
<tr><td><code id="plot_mod_+3A_x">x</code></td>
<td>
<p>A list with class <code>wt_model</code> returned by <a href="#topic+rank_regression">rank_regression</a>,
<a href="#topic+ml_estimation">ml_estimation</a>, <a href="#topic+mixmod_regression">mixmod_regression</a> or <a href="#topic+mixmod_em">mixmod_em</a>.</p>
</td></tr>
<tr><td><code id="plot_mod_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="plot_mod_+3A_title_trace">title_trace</code></td>
<td>
<p>A character string which is assigned to the legend trace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name of the legend entry is a combination of the <code>title_trace</code> and the
number of determined subgroups from <a href="#topic+mixmod_regression">mixmod_regression</a> or <a href="#topic+mixmod_em">mixmod_em</a>. If
<code>title_trace = "Line"</code> and the data could be split in two groups, the legend
entries would be &quot;Line: 1&quot; and &quot;Line: 2&quot;.
</p>


<h3>Value</h3>

<p>A plot object containing the probability plot with plotting positions
and the estimated regression line(s).
</p>


<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reliability data:
data &lt;- reliability_data(data = alloy, x = cycles, status = status)

# Probability estimation:
prob_tbl &lt;- estimate_cdf(data, methods = c("johnson", "kaplan"))


## Rank Regression
# Example 1 - Probability Plot and Regression Line Three-Parameter-Weibull:
plot_weibull &lt;- plot_prob(prob_tbl, distribution = "weibull")
rr_weibull &lt;- rank_regression(prob_tbl, distribution = "weibull3")

plot_reg_weibull &lt;- plot_mod(p_obj = plot_weibull, x = rr_weibull)

# Example 2 - Probability Plot and Regression Line Three-Parameter-Lognormal:
plot_lognormal &lt;- plot_prob(prob_tbl, distribution = "lognormal")
rr_lognormal &lt;- rank_regression(prob_tbl, distribution = "lognormal3")

plot_reg_lognormal &lt;- plot_mod(p_obj = plot_lognormal, x = rr_lognormal)


## ML Estimation
# Example 3 - Probability Plot and Regression Line Two-Parameter-Weibull:
plot_weibull &lt;- plot_prob(prob_tbl, distribution = "weibull")
ml_weibull_2 &lt;- ml_estimation(data, distribution = "weibull")

plot_reg_weibull_2 &lt;- plot_mod(p_obj = plot_weibull, ml_weibull_2)


## Mixture Identification
# Reliability data:
data_mix &lt;- reliability_data(voltage, x = hours, status = status)

# Probability estimation:
prob_mix &lt;- estimate_cdf(
  data_mix,
  methods = c("johnson", "kaplan", "nelson")
)

# Example 4 - Probability Plot and Regression Line Mixmod Regression:
mix_mod_rr &lt;- mixmod_regression(prob_mix, distribution = "weibull")
plot_weibull &lt;- plot_prob(mix_mod_rr)

plot_reg_mix_mod_rr &lt;- plot_mod(p_obj = plot_weibull, x = mix_mod_rr)

# Example 5 - Probability Plot and Regression Line Mixmod EM:
mix_mod_em &lt;- mixmod_em(data_mix)
plot_weibull &lt;- plot_prob(mix_mod_em)

plot_reg_mix_mod_em &lt;- plot_mod(p_obj = plot_weibull, x = mix_mod_em)

</code></pre>

<hr>
<h2 id='plot_mod_mix'>Add Estimated Population Lines of a Separated Mixture Model to a
Probability Plot</h2><span id='topic+plot_mod_mix'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><code>plot_mod_mix()</code> is no longer under active development, switching to
<a href="#topic+plot_mod">plot_mod</a> is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mod_mix(
  p_obj,
  x,
  status,
  mix_output,
  distribution = c("weibull", "lognormal", "loglogistic"),
  title_trace = "Fit",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mod_mix_+3A_p_obj">p_obj</code></td>
<td>
<p>A plot object returned by <a href="#topic+plot_prob_mix">plot_prob_mix</a>.</p>
</td></tr>
<tr><td><code id="plot_mod_mix_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the x-coordinates of the respective
regression line.</p>
</td></tr>
<tr><td><code id="plot_mod_mix_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is a
right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="plot_mod_mix_+3A_mix_output">mix_output</code></td>
<td>
<p>A list returned by <a href="#topic+mixmod_regression">mixmod_regression</a> or <a href="#topic+mixmod_em">mixmod_em</a>,
which consists of elements necessary to visualize the regression lines.</p>
</td></tr>
<tr><td><code id="plot_mod_mix_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="plot_mod_mix_+3A_title_trace">title_trace</code></td>
<td>
<p>A character string which is assigned to the legend trace.</p>
</td></tr>
<tr><td><code id="plot_mod_mix_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds one or multiple estimated regression lines to an existing
probability plot <a href="#topic+plot_prob">plot_prob</a>). Depending on the output of the function
<a href="#topic+mixmod_regression">mixmod_regression</a> or <a href="#topic+mixmod_em">mixmod_em</a> one or multiple lines are plotted.
</p>
<p>The name of the legend entry is a combination of the <code>title_trace</code> and the
number of determined subgroups. If <code>title_trace = "Line"</code> and the data has
been split in two groups, the legend entries would be <code>"Line: 1"</code> and
<code>"Line: 2"</code>.
</p>


<h3>Value</h3>

<p>A plot object containing the probability plot with plotting positions
and estimated regression line(s).
</p>


<h3>References</h3>

<p>Doganaksoy, N.; Hahn, G.; Meeker, W. Q., Reliability Analysis by
Failure Mode, Quality Progress, 35(6), 47-52, 2002
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
hours &lt;- voltage$hours
status &lt;- voltage$status

# Example 1 - Using result of mixmod_em in mix_output:
mix_mod_em &lt;- mixmod_em(
  x = hours,
  status = status,
  distribution = "weibull",
  conf_level = 0.95,
  k = 2,
  method = "EM",
  n_iter = 150
)

plot_weibull_em &lt;- plot_prob_mix(
  x = hours,
  status = status,
  id = id,
  distribution = "weibull",
  mix_output = mix_mod_em
)

plot_weibull_emlines &lt;- plot_mod_mix(
  p_obj = plot_weibull_em,
  x = hours,
  status = status,
  mix_output = mix_mod_em,
  distribution = "weibull"
)

# Example 2 - Using result of mixmod_regression in mix_output:
john &lt;- johnson_method(x = hours, status = status)
mix_mod_reg &lt;- mixmod_regression(
  x = john$x,
  y = john$prob,
  status = john$status,
  distribution = "weibull"
)

plot_weibull_reg &lt;- plot_prob_mix(
  x = john$x,
  status = john$status,
  id = john$id,
  distribution = "weibull",
  mix_output = mix_mod_reg,
)

plot_weibull_reglines &lt;- plot_mod_mix(
  p_obj = plot_weibull_reg,
  x = john$x,
  status = john$status,
  mix_output = mix_mod_reg,
  distribution = "weibull"
)

</code></pre>

<hr>
<h2 id='plot_mod.default'>Add Estimated Population Line to a Probability Plot</h2><span id='topic+plot_mod.default'></span>

<h3>Description</h3>

<p>This function adds an estimated regression line to an existing probability
plot (<a href="#topic+plot_prob">plot_prob</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
plot_mod(
  p_obj,
  x,
  dist_params,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2"),
  title_trace = "Fit",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mod.default_+3A_p_obj">p_obj</code></td>
<td>
<p>A plot object returned by <a href="#topic+plot_prob">plot_prob</a>.</p>
</td></tr>
<tr><td><code id="plot_mod.default_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the x-coordinates of the respective
regression line.</p>
</td></tr>
<tr><td><code id="plot_mod.default_+3A_dist_params">dist_params</code></td>
<td>
<p>A (named) numeric vector of estimated location and scale
parameters for a specified distribution. The order of elements is important.
First entry needs to be the location parameter <code class="reqn">\mu</code> and the second
element needs to be the scale parameter <code class="reqn">\sigma</code>. If a three-parametric
model is used the third element is the threshold parameter <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code id="plot_mod.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="plot_mod.default_+3A_title_trace">title_trace</code></td>
<td>
<p>A character string which is assigned to the legend trace.</p>
</td></tr>
<tr><td><code id="plot_mod.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object containing the probability plot with plotting positions
and the estimated regression line.
</p>


<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_mod">plot_mod</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
cycles &lt;- alloy$cycles
status &lt;- alloy$status

# Probability estimation
prob_tbl &lt;- estimate_cdf(x = cycles, status = status, method = "johnson")

# Example 1: Probability Plot and Regression Line Three-Parameter-Weibull:
plot_weibull &lt;- plot_prob(
  x = prob_tbl$x,
  y = prob_tbl$prob,
  status = prob_tbl$status,
  id = prob_tbl$id,
  distribution = "weibull"
)

rr &lt;- rank_regression(
  x = prob_tbl$x,
  y = prob_tbl$prob,
  status = prob_tbl$status,
  distribution = "weibull3"
)

plot_reg_weibull &lt;- plot_mod(
  p_obj = plot_weibull,
  x = prob_tbl$x,
  dist_params = rr$coefficients,
  distribution = "weibull3"
)



# Example 2: Probability Plot and Regression Line Three-Parameter-Lognormal:
plot_lognormal &lt;- plot_prob(
  x = prob_tbl$x,
  y = prob_tbl$prob,
  status = prob_tbl$status,
  id = prob_tbl$id,
  distribution = "lognormal"
)

rr_ln &lt;- rank_regression(
  x = prob_tbl$x,
  y = prob_tbl$prob,
  status = prob_tbl$status,
  distribution = "lognormal3"
)

plot_reg_lognormal &lt;- plot_mod(
  p_obj = plot_lognormal,
  x = prob_tbl$x,
  dist_params = rr_ln$coefficients,
  distribution = "lognormal3"
)

## Mixture Identification
# Vectors:
hours &lt;- voltage$hours
status &lt;- voltage$status

# Probability estimation:
prob_mix &lt;- estimate_cdf(
  x = hours,
  status = status,
  method = "johnson"
)

</code></pre>

<hr>
<h2 id='plot_pop'>Add Population Line(s) to an Existing Grid</h2><span id='topic+plot_pop'></span>

<h3>Description</h3>

<p>This function adds one (or multiple) linearized CDF(s) to an existing plot grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pop(
  p_obj = NULL,
  x,
  dist_params_tbl,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "exponential"),
  tol = 1e-06,
  title_trace = "Population",
  plot_method = c("plotly", "ggplot2")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_pop_+3A_p_obj">p_obj</code></td>
<td>
<p>A plot object to which the population line(s) is (are) added or
<code>NULL</code>. If <code>NULL</code> the population line(s) is (are) plotted in an empty grid.</p>
</td></tr>
<tr><td><code id="plot_pop_+3A_x">x</code></td>
<td>
<p>A numeric vector of length two or greater used for the x coordinates
of the population line. If <code>length(x) == 2</code> a sequence of length 200 between
<code>x[1]</code> and <code>x[2]</code> is created. This sequence is equidistant with respect to the
scale of the x axis. If <code>length(x) &gt; 2</code> the elements of <code>x</code> are the x
coordinates of the population line.</p>
</td></tr>
<tr><td><code id="plot_pop_+3A_dist_params_tbl">dist_params_tbl</code></td>
<td>
<p>A <code>data.frame</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="plot_pop_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable. The distinction
between a threshold distribution and the respective standard variant is made with
<code>dist_params_tbl</code>.</p>
</td></tr>
<tr><td><code id="plot_pop_+3A_tol">tol</code></td>
<td>
<p>The failure probability is restricted to the interval
<code class="reqn">[tol, 1 - tol]</code>. The default value is in accordance with the decimal
places shown in the hover for <code>plot_method = "plotly"</code>.</p>
</td></tr>
<tr><td><code id="plot_pop_+3A_title_trace">title_trace</code></td>
<td>
<p>A character string which is assigned to the legend trace.</p>
</td></tr>
<tr><td><code id="plot_pop_+3A_plot_method">plot_method</code></td>
<td>
<p>Package, which is used for generating the plot output. Only
used when <code>p_obj = NULL</code>. If <code>p_obj != NULL</code> the plot object is used to
determine the plot method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dist_params_tbl</code> is a <code>data.frame</code> with parameter columns. An overview of the
distribution-specific parameters and their order can be found in section
'Distributions'.
</p>
<p>If only one population line should be displayed, a numeric vector is also
supported. The order of the vector elements also corresponds to the table in
section 'Distributions'.
</p>


<h3>Value</h3>

<p>A plot object containing the linearized CDF(s).
</p>


<h3>Distributions</h3>

<p>The following table summarizes the available distributions and their parameters
</p>

<ul>
<li> <p><em>location parameter</em> <code class="reqn">\mu</code>,
</p>
</li>
<li> <p><em>scale parameter</em> <code class="reqn">\sigma</code> or <code class="reqn">\theta</code> and
</p>
</li>
<li> <p><em>threshold parameter</em> <code class="reqn">\gamma</code>.
</p>
</li></ul>

<p>The column order within <code>dist_params_tbl</code> is given in the table header.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong><code>distribution</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params_tbl[1]</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params_tbl[2]</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params_tbl[3]</code></strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"sev"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"weibull"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> (<code class="reqn">\gamma</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"normal"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"lognormal"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> (<code class="reqn">\gamma</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"logistic"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"loglogistic"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> (<code class="reqn">\gamma</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"exponential"</code> </td><td style="text-align: center;"> <code class="reqn">\theta</code> </td><td style="text-align: center;"> (<code class="reqn">\gamma</code>) </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rweibull(n = 100, shape = 1, scale = 20000)

# Example 1 - Two-parametric straight line:
pop_weibull &lt;- plot_pop(
  p_obj = NULL,
  x = range(x),
  dist_params_tbl = c(log(20000), 1),
  distribution = "weibull"
)

# Example 2 - Three-parametric curved line:
x2 &lt;- rweibull(n = 100, shape = 1, scale = 20000) + 5000

pop_weibull_2 &lt;- plot_pop(
  p_obj = NULL,
  x = x2,
  dist_params_tbl = c(log(20000 - 5000), 1, 5000),
  distribution = "weibull"
)

# Example 3 - Multiple lines:
pop_weibull_3 &lt;- plot_pop(
  p_obj = NULL,
  x = x,
  dist_params_tbl = data.frame(
    p_1 = c(log(20000), log(20000), log(20000)),
    p_2 = c(1, 1.5, 2)
    ),
  distribution = "weibull",
  plot_method = "ggplot2"
)

# Example 4 - Compare two- and three-parametric distributions:
pop_weibull_4 &lt;- plot_pop(
  p_obj = NULL,
  x = x,
  dist_params_tbl = data.frame(
    param_1 = c(log(20000), log(20000)),
    param_2 = c(1, 1),
    param_3 = c(NA, 2)
  ),
  distribution = "weibull"
)

</code></pre>

<hr>
<h2 id='plot_prob'>Probability Plotting Method for Univariate Lifetime Distributions</h2><span id='topic+plot_prob'></span><span id='topic+plot_prob.wt_cdf_estimation'></span><span id='topic+plot_prob.wt_model'></span>

<h3>Description</h3>

<p>This function is used to apply the graphical technique of probability
plotting. It is either applied to the output of <a href="#topic+estimate_cdf">estimate_cdf</a>
(<code>plot_prob.wt_cdf_estimation</code>) or to the output of a mixture model from
<a href="#topic+mixmod_regression">mixmod_regression</a> / <a href="#topic+mixmod_em">mixmod_em</a> (<code>plot_prob.wt_model</code>). Note that in the
latter case no distribution has to be specified because it is inferred from
the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_prob(x, ...)

## S3 method for class 'wt_cdf_estimation'
plot_prob(
  x,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "exponential"),
  title_main = "Probability Plot",
  title_x = "Characteristic",
  title_y = "Unreliability",
  title_trace = "Sample",
  plot_method = c("plotly", "ggplot2"),
  ...
)

## S3 method for class 'wt_model'
plot_prob(
  x,
  title_main = "Probability Plot",
  title_x = "Characteristic",
  title_y = "Unreliability",
  title_trace = "Sample",
  plot_method = c("plotly", "ggplot2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_prob_+3A_x">x</code></td>
<td>
<p>A tibble with class <code>wt_cdf_estimation</code> returned by <a href="#topic+estimate_cdf">estimate_cdf</a>
or a list with class <code>wt_model</code> returned by <a href="#topic+rank_regression">rank_regression</a>, <a href="#topic+ml_estimation">ml_estimation</a>,
<a href="#topic+mixmod_regression">mixmod_regression</a> or <a href="#topic+mixmod_em">mixmod_em</a>.</p>
</td></tr>
<tr><td><code id="plot_prob_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="plot_prob_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="plot_prob_+3A_title_main">title_main</code></td>
<td>
<p>A character string which is assigned to the main title.</p>
</td></tr>
<tr><td><code id="plot_prob_+3A_title_x">title_x</code></td>
<td>
<p>A character string which is assigned to the title of the x axis.</p>
</td></tr>
<tr><td><code id="plot_prob_+3A_title_y">title_y</code></td>
<td>
<p>A character string which is assigned to the title of the y axis.</p>
</td></tr>
<tr><td><code id="plot_prob_+3A_title_trace">title_trace</code></td>
<td>
<p>A character string which is assigned to the legend trace.</p>
</td></tr>
<tr><td><code id="plot_prob_+3A_plot_method">plot_method</code></td>
<td>
<p>Package, which is used for generating the plot output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> was split by <a href="#topic+mixmod_em">mixmod_em</a>, <a href="#topic+estimate_cdf">estimate_cdf</a> with method <code>"johnson"</code> is
applied to subgroup-specific data. The calculated plotting positions are
shaped according to the determined split in <a href="#topic+mixmod_em">mixmod_em</a>.
</p>
<p>In <a href="#topic+mixmod_regression">mixmod_regression</a> a maximum of three subgroups can be determined and thus
being plotted. The intention of this function is to give the user a hint for
the existence of a mixture model. An in-depth analysis should be done afterwards.
</p>
<p>For <code>plot_method == "plotly"</code> the marker label for x and y are determined by
the first word provided in the argument <code>title_x</code> and <code>title_y</code> respectively,
i.e. if <code>title_x = "Mileage in km"</code> the x label of the marker is &quot;Mileage&quot;.
The name of the legend entry is a combination of the <code>title_trace</code> and the
number of determined subgroups (if any). If <code>title_trace = "Group"</code> and the
data has been split in two groups, the legend entries are &quot;Group: 1&quot; and
&quot;Group: 2&quot;.
</p>


<h3>Value</h3>

<p>A plot object containing the probability plot.
</p>


<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reliability data:
data &lt;- reliability_data(
  alloy,
  x = cycles,
  status = status
)

# Probability estimation:
prob_tbl &lt;- estimate_cdf(
  data,
  methods = c("johnson", "kaplan")
)

# Example 1 - Probability Plot Weibull:
plot_weibull &lt;- plot_prob(prob_tbl)

# Example 2 - Probability Plot Lognormal:
plot_lognormal &lt;- plot_prob(
  x = prob_tbl,
  distribution = "lognormal"
)

## Mixture identification
# Reliability data:
data_mix &lt;- reliability_data(
  voltage,
  x = hours,
  status = status
)

prob_mix &lt;- estimate_cdf(
  data_mix,
  methods = c("johnson", "kaplan")
)

# Example 3 - Mixture identification using mixmod_regression:
mix_mod_rr &lt;- mixmod_regression(prob_mix)

plot_mix_mod_rr &lt;- plot_prob(x = mix_mod_rr)

# Example 4 - Mixture identification using mixmod_em:
mix_mod_em &lt;- mixmod_em(data_mix)

plot_mix_mod_em &lt;- plot_prob(x = mix_mod_em)

</code></pre>

<hr>
<h2 id='plot_prob_mix'>Probability Plot for Separated Mixture Models</h2><span id='topic+plot_prob_mix'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a>
</p>
<p><code>plot_prob_mix()</code> is no longer under active development, switching to
<a href="#topic+plot_prob">plot_prob</a> is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_prob_mix(
  x,
  status,
  id = rep("XXXXXX", length(x)),
  distribution = c("weibull", "lognormal", "loglogistic"),
  mix_output,
  title_main = "Probability Plot",
  title_x = "Characteristic",
  title_y = "Unreliability",
  title_trace = "Sample",
  plot_method = c("plotly", "ggplot2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_prob_mix_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime data
could be every characteristic influencing the reliability of a product, e.g.
operating time (days/months in service), mileage (km, miles), load cycles.</p>
</td></tr>
<tr><td><code id="plot_prob_mix_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is a
right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="plot_prob_mix_+3A_id">id</code></td>
<td>
<p>Identification for every unit.</p>
</td></tr>
<tr><td><code id="plot_prob_mix_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="plot_prob_mix_+3A_mix_output">mix_output</code></td>
<td>
<p>A list returned by <a href="#topic+mixmod_regression">mixmod_regression</a> or <a href="#topic+mixmod_em">mixmod_em</a>, which
consists of values necessary to visualize the subgroups.The default value of
<code>mix_output</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_prob_mix_+3A_title_main">title_main</code></td>
<td>
<p>A character string which is assigned to the main title.</p>
</td></tr>
<tr><td><code id="plot_prob_mix_+3A_title_x">title_x</code></td>
<td>
<p>A character string which is assigned to the title of the x axis.</p>
</td></tr>
<tr><td><code id="plot_prob_mix_+3A_title_y">title_y</code></td>
<td>
<p>A character string which is assigned to the title of the y axis.</p>
</td></tr>
<tr><td><code id="plot_prob_mix_+3A_title_trace">title_trace</code></td>
<td>
<p>A character string which is assigned to the legend trace.</p>
</td></tr>
<tr><td><code id="plot_prob_mix_+3A_plot_method">plot_method</code></td>
<td>
<p>Package, which is used for generating the plot output.</p>
</td></tr>
<tr><td><code id="plot_prob_mix_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to apply the graphical technique of probability
plotting to univariate mixture models that have been separated with functions
<a href="#topic+mixmod_regression">mixmod_regression</a> or <a href="#topic+mixmod_em">mixmod_em</a>.
</p>
<p>If data has been split by <code>mixmod_em</code> the function <code>johnson_method</code> is applied
to subgroup-specific data. The calculated plotting positions are shaped
regarding the obtained split of the used splitting function.
</p>
<p>In <a href="#topic+mixmod_regression">mixmod_regression</a> a maximum of three subgroups can be determined and thus
being plotted. The intention of this function is to give the user a hint for
the existence of a mixture model. An in-depth analysis should be done
afterwards.
</p>
<p>The marker label for x and y are determined by the first word provided in the
argument <code>title_x</code> and <code>title_y</code> respectively, i.e. if
<code>title_x = "Mileage in km"</code> the x label of the marker is &quot;Mileage&quot;.
</p>
<p>The name of the legend entry is a combination of the <code>title_trace</code> and the
number of determined subgroups (if any). If <code>title_trace = "Group"</code> and the
data has been split in two groups, the legend entries are &quot;Group: 1&quot; and
&quot;Group: 2&quot;.
</p>


<h3>References</h3>

<p>Doganaksoy, N.; Hahn, G.; Meeker, W. Q., Reliability Analysis by
Failure Mode, Quality Progress, 35(6), 47-52, 2002
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_prob">plot_prob</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
hours &lt;- voltage$hours
status &lt;- voltage$status

# Example 1 - Using result of mixmod_em:
mix_mod_em &lt;- mixmod_em(
  x = hours,
  status = status
)

plot_weibull_em &lt;- plot_prob_mix(
  x = hours,
  status = status,
  distribution = "weibull",
  mix_output = mix_mod_em
)

# Example 2 - Using result of mixmod_regression:
john &lt;- estimate_cdf(
  x = hours,
  status = status,
  method = "johnson"
)

mix_mod_reg &lt;- mixmod_regression(
  x = john$x,
  y = john$prob,
  status = john$status,
  distribution = "weibull"
)

plot_weibull_reg &lt;- plot_prob_mix(
  x = hours,
  status = status,
  distribution = "weibull",
  mix_output = mix_mod_reg
)

</code></pre>

<hr>
<h2 id='plot_prob.default'>Probability Plotting Method for Univariate Lifetime Distributions</h2><span id='topic+plot_prob.default'></span>

<h3>Description</h3>

<p>This function is used to apply the graphical technique of probability
plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
plot_prob(
  x,
  y,
  status,
  id = rep("XXXXXX", length(x)),
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "exponential"),
  title_main = "Probability Plot",
  title_x = "Characteristic",
  title_y = "Unreliability",
  title_trace = "Sample",
  plot_method = c("plotly", "ggplot2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_prob.default_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime data
could be every characteristic influencing the reliability of a product, e.g.
operating time (days/months in service), mileage (km, miles), load cycles.</p>
</td></tr>
<tr><td><code id="plot_prob.default_+3A_y">y</code></td>
<td>
<p>A numeric vector which consists of estimated failure probabilities
regarding the lifetime data in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot_prob.default_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is a
right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="plot_prob.default_+3A_id">id</code></td>
<td>
<p>Identification for every unit.</p>
</td></tr>
<tr><td><code id="plot_prob.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="plot_prob.default_+3A_title_main">title_main</code></td>
<td>
<p>A character string which is assigned to the main title.</p>
</td></tr>
<tr><td><code id="plot_prob.default_+3A_title_x">title_x</code></td>
<td>
<p>A character string which is assigned to the title of the x axis.</p>
</td></tr>
<tr><td><code id="plot_prob.default_+3A_title_y">title_y</code></td>
<td>
<p>A character string which is assigned to the title of the y axis.</p>
</td></tr>
<tr><td><code id="plot_prob.default_+3A_title_trace">title_trace</code></td>
<td>
<p>A character string which is assigned to the legend trace.</p>
</td></tr>
<tr><td><code id="plot_prob.default_+3A_plot_method">plot_method</code></td>
<td>
<p>Package, which is used for generating the plot output.</p>
</td></tr>
<tr><td><code id="plot_prob.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>plot_method == "plotly"</code> the marker label for x and y are determined by
the first word provided in the argument <code>title_x</code> and <code>title_y</code> respectively,
i.e. if <code>title_x = "Mileage in km"</code> the x label of the marker is &quot;Mileage&quot;.
</p>


<h3>Value</h3>

<p>A plot object containing the probability plot.
</p>


<h3>References</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical methods for
reliability data, New York: Wiley series in probability and statistics, 1998
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_prob">plot_prob</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
cycles   &lt;- alloy$cycles
status &lt;- alloy$status

# Probability estimation:
prob_tbl &lt;- estimate_cdf(
  x = cycles,
  status = status,
  method = "johnson"
)

# Example 1: Probability Plot Weibull:
plot_weibull &lt;- plot_prob(
  x = prob_tbl$x,
  y = prob_tbl$prob,
  status = prob_tbl$status,
  id = prob_tbl$id
)

# Example 2: Probability Plot Lognormal:
plot_lognormal &lt;- plot_prob(
  x = prob_tbl$x,
  y = prob_tbl$prob,
  status = prob_tbl$status,
  id = prob_tbl$id,
  distribution = "lognormal"
)

</code></pre>

<hr>
<h2 id='predict_prob'>Prediction of Failure Probabilities for Parametric Lifetime Distributions</h2><span id='topic+predict_prob'></span>

<h3>Description</h3>

<p>This function predicts the (failure) probabilities of a parametric lifetime
distribution using the (log-)location-scale parameterization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_prob(
  q,
  dist_params,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_prob_+3A_q">q</code></td>
<td>
<p>A numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="predict_prob_+3A_dist_params">dist_params</code></td>
<td>
<p>A vector of parameters. An overview of the
distribution-specific parameters can be found in section 'Distributions'.</p>
</td></tr>
<tr><td><code id="predict_prob_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given set of parameters and specified quantiles the probabilities
of the chosen model are determined.
</p>


<h3>Value</h3>

<p>A vector with predicted (failure) probabilities.
</p>


<h3>Distributions</h3>

<p>The following table summarizes the available distributions and their parameters
</p>

<ul>
<li> <p><em>location parameter</em> <code class="reqn">\mu</code>,
</p>
</li>
<li> <p><em>scale parameter</em> <code class="reqn">\sigma</code> or <code class="reqn">\theta</code> and
</p>
</li>
<li> <p><em>threshold parameter</em> <code class="reqn">\gamma</code>.
</p>
</li></ul>

<p>The order within <code>dist_params</code> is given in the table header.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong><code>distribution</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[1]</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[2]</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[3]</code></strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"sev"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"weibull"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"weibull3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"normal"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"lognormal"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"lognormal3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"logistic"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"loglogistic"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"loglogistic3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"exponential"</code> </td><td style="text-align: center;"> <code class="reqn">\theta</code> </td><td style="text-align: center;"> - </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"exponential2"</code> </td><td style="text-align: center;"> <code class="reqn">\theta</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1 - Predicted probabilities for a two-parameter weibull distribution:
probs_weib2 &lt;- predict_prob(
  q = c(15, 48, 124),
  dist_params = c(5, 0.5),
  distribution = "weibull"
)

# Example 2 - Predicted quantiles for a three-parameter weibull distribution:
probs_weib3 &lt;- predict_prob(
  q = c(25, 58, 134),
  dist_params = c(5, 0.5, 10),
  distribution = "weibull3"
)

</code></pre>

<hr>
<h2 id='predict_quantile'>Prediction of Quantiles for Parametric Lifetime Distributions</h2><span id='topic+predict_quantile'></span>

<h3>Description</h3>

<p>This function predicts the quantiles of a parametric lifetime distribution
using the (log-)location-scale parameterization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_quantile(
  p,
  dist_params,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_quantile_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="predict_quantile_+3A_dist_params">dist_params</code></td>
<td>
<p>A vector of parameters. An overview of the
distribution-specific parameters can be found in section 'Distributions'.</p>
</td></tr>
<tr><td><code id="predict_quantile_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given set of parameters and specified probabilities the quantiles
of the chosen model are determined.
</p>


<h3>Value</h3>

<p>A vector with predicted quantiles.
</p>


<h3>Distributions</h3>

<p>The following table summarizes the available distributions and their parameters
</p>

<ul>
<li> <p><em>location parameter</em> <code class="reqn">\mu</code>,
</p>
</li>
<li> <p><em>scale parameter</em> <code class="reqn">\sigma</code> or <code class="reqn">\theta</code> and
</p>
</li>
<li> <p><em>threshold parameter</em> <code class="reqn">\gamma</code>.
</p>
</li></ul>

<p>The order within <code>dist_params</code> is given in the table header.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong><code>distribution</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[1]</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[2]</code></strong> </td><td style="text-align: center;"> <strong><code>dist_params[3]</code></strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"sev"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"weibull"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"weibull3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"normal"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"lognormal"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"lognormal3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"logistic"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"loglogistic"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"loglogistic3"</code> </td><td style="text-align: center;"> <code class="reqn">\mu</code> </td><td style="text-align: center;"> <code class="reqn">\sigma</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"exponential"</code> </td><td style="text-align: center;"> <code class="reqn">\theta</code> </td><td style="text-align: center;"> - </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"exponential2"</code> </td><td style="text-align: center;"> <code class="reqn">\theta</code> </td><td style="text-align: center;"> <code class="reqn">\gamma</code> </td><td style="text-align: center;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1 - Predicted quantiles for a two-parameter weibull distribution:
quants_weib2 &lt;- predict_quantile(
  p = c(0.01, 0.1, 0.5),
  dist_params = c(5, 0.5),
  distribution = "weibull"
)

# Example 2 - Predicted quantiles for a three-parameter weibull distribution:
quants_weib3 &lt;- predict_quantile(
  p = c(0.01, 0.1, 0.5),
  dist_params = c(5, 0.5, 10),
  distribution = "weibull3"
)

</code></pre>

<hr>
<h2 id='r_squared_profiling'>R-Squared-Profile Function for Parametric Lifetime Distributions with Threshold</h2><span id='topic+r_squared_profiling'></span><span id='topic+r_squared_profiling.wt_cdf_estimation'></span>

<h3>Description</h3>

<p>This function evaluates the coefficient of determination with respect to a
given threshold parameter of a parametric lifetime distribution. In terms of
<em>Rank Regression</em> this function can be optimized (<a href="stats.html#topic+optim">optim</a>) to
estimate the threshold parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_squared_profiling(x, ...)

## S3 method for class 'wt_cdf_estimation'
r_squared_profiling(
  x,
  thres,
  distribution = c("weibull3", "lognormal3", "loglogistic3", "exponential2"),
  direction = c("x_on_y", "y_on_x"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_squared_profiling_+3A_x">x</code></td>
<td>
<p>A <code>tibble</code> with class <code>wt_cdf_estimation</code> returned by <a href="#topic+estimate_cdf">estimate_cdf</a>.</p>
</td></tr>
<tr><td><code id="r_squared_profiling_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="r_squared_profiling_+3A_thres">thres</code></td>
<td>
<p>A numeric value for the threshold parameter.</p>
</td></tr>
<tr><td><code id="r_squared_profiling_+3A_distribution">distribution</code></td>
<td>
<p>Supposed parametric distribution of the random variable.</p>
</td></tr>
<tr><td><code id="r_squared_profiling_+3A_direction">direction</code></td>
<td>
<p>Direction of the dependence in the regression model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the coefficient of determination with respect to the threshold
parameter <code>thres</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data:
data &lt;- reliability_data(
  alloy,
  x = cycles,
  status = status
)

# Probability estimation:
prob_tbl &lt;- estimate_cdf(
  data,
  methods = "johnson"
)

# Determining the optimal coefficient of determination:
## Range of threshold parameter must be smaller than the first failure:
threshold &lt;- seq(
  0,
  min(
    dplyr::pull(
      dplyr::filter(
        prob_tbl,
        status == 1,
        x == min(x)
      ),
      x
    ) - 0.1
  ),
  length.out = 100
)

## Coefficient of determination with respect to threshold values:
profile_r2 &lt;- r_squared_profiling(
  x = dplyr::filter(
    prob_tbl,
    status == 1
  ),
  thres = threshold,
  distribution = "weibull3"
)

## Threshold value (among the candidates) that maximizes the coefficient of determination:
threshold[which.max(profile_r2)]

## plot:
plot(
  threshold,
  profile_r2,
  type = "l"
)
abline(
  v = threshold[which.max(profile_r2)],
  h = max(profile_r2),
  col = "red"
)

</code></pre>

<hr>
<h2 id='r_squared_profiling.default'>R-Squared-Profile Function for Parametric Lifetime Distributions with Threshold</h2><span id='topic+r_squared_profiling.default'></span>

<h3>Description</h3>

<p>This function evaluates the coefficient of determination with respect to a
given threshold parameter of a parametric lifetime distribution. In terms of
<em>Rank Regression</em> this function can be optimized (<a href="stats.html#topic+optim">optim</a>) to
estimate the threshold parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
r_squared_profiling(
  x,
  y,
  thres,
  distribution = c("weibull3", "lognormal3", "loglogistic3", "exponential2"),
  direction = c("x_on_y", "y_on_x"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_squared_profiling.default_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime data
could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="r_squared_profiling.default_+3A_y">y</code></td>
<td>
<p>A numeric vector which consists of estimated failure probabilities
regarding the lifetime data in x.</p>
</td></tr>
<tr><td><code id="r_squared_profiling.default_+3A_thres">thres</code></td>
<td>
<p>A numeric value for the threshold parameter.</p>
</td></tr>
<tr><td><code id="r_squared_profiling.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed parametric distribution of the random variable.</p>
</td></tr>
<tr><td><code id="r_squared_profiling.default_+3A_direction">direction</code></td>
<td>
<p>Direction of the dependence in the regression model.</p>
</td></tr>
<tr><td><code id="r_squared_profiling.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the coefficient of determination with respect to the threshold
parameter <code>thres</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+r_squared_profiling">r_squared_profiling</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
cycles &lt;- alloy$cycles
status &lt;- alloy$status

# Probability estimation:
prob_tbl &lt;- estimate_cdf(
  x = cycles,
  status = status,
  method = "johnson"
)

# Determining the optimal coefficient of determination:
## Range of threshold parameter must be smaller than the first failure:
threshold &lt;- seq(
  0,
  min(cycles[status == 1]) - 0.1,
  length.out = 100
)

## Coefficient of determination with respect to threshold values:
profile_r2 &lt;- r_squared_profiling(
  x = prob_tbl$x[prob_tbl$status == 1],
  y = prob_tbl$prob[prob_tbl$status == 1],
  thres = threshold,
  distribution = "weibull3"
)

## Threshold value (among the candidates) that maximizes the
## coefficient of determination:
threshold[which.max(profile_r2)]

## plot:
plot(
  threshold,
  profile_r2,
  type = "l"
)
abline(
  v = threshold[which.max(profile_r2)],
  h = max(profile_r2),
  col = "red"
)

</code></pre>

<hr>
<h2 id='rank_regression'>Rank Regression for Parametric Lifetime Distributions</h2><span id='topic+rank_regression'></span><span id='topic+rank_regression.wt_cdf_estimation'></span>

<h3>Description</h3>

<p>This function fits a regression model to a linearized parametric lifetime
distribution for complete and (multiple) right-censored data. The parameters
are determined in the frequently used (log-)location-scale parameterization.
</p>
<p>For the Weibull, estimates are additionally transformed such that they are in
line with the parameterization provided by the <em>stats</em> package
(see <a href="stats.html#topic+Weibull">Weibull</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_regression(x, ...)

## S3 method for class 'wt_cdf_estimation'
rank_regression(
  x,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2"),
  conf_level = 0.95,
  direction = c("x_on_y", "y_on_x"),
  control = list(),
  options = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank_regression_+3A_x">x</code></td>
<td>
<p>A <code>tibble</code> with class <code>wt_cdf_estimation</code> returned by <a href="#topic+estimate_cdf">estimate_cdf</a>.</p>
</td></tr>
<tr><td><code id="rank_regression_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
<tr><td><code id="rank_regression_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="rank_regression_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level of the interval.</p>
</td></tr>
<tr><td><code id="rank_regression_+3A_direction">direction</code></td>
<td>
<p>Direction of the dependence in the regression model.</p>
</td></tr>
<tr><td><code id="rank_regression_+3A_control">control</code></td>
<td>
<p>A list of control parameters (see <a href="stats.html#topic+optim">optim</a>).
</p>
<p><code>control</code> is in use only if a three-parametric distribution was specified.
If this is the case, <code>optim</code> (always with <code>method = "L-BFGS-B"</code> and
<code>control$fnscale = -1</code>) is called to determine the threshold parameter
(see <a href="#topic+r_squared_profiling">r_squared_profiling</a>).</p>
</td></tr>
<tr><td><code id="rank_regression_+3A_options">options</code></td>
<td>
<p>A list of named options. See 'Options'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence intervals of the parameters are computed on the basis of a
heteroscedasticity-consistent (<strong>HC</strong>) covariance matrix. Here it should be
said that there is no statistical foundation to determine the standard errors
of the parameters using <em>Least Squares</em> in context of <em>Rank Regression</em>.
For an accepted statistical method use <a href="#topic+ml_estimation">maximum likelihood</a>.
</p>
<p>If <code>options = list(conf_method = "Mock")</code>, the argument <code>distribution</code> must be
one of <code>"weibull"</code> and <code>"weibull3"</code>. The approximated confidence intervals
for the Weibull parameters can then only be estimated on the following
confidence levels (see 'References' <em>(Mock, 1995)</em>):
</p>

<ul>
<li> <p><code>conf_level = 0.90</code>
</p>
</li>
<li> <p><code>conf_level = 0.95</code>
</p>
</li>
<li> <p><code>conf_level = 0.99</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A list with classes <code>wt_model</code>, <code>wt_rank_regression</code> and <code>wt_model_estimation</code>
which contains:
</p>

<ul>
<li> <p><code>coefficients</code> : A named vector of estimated coefficients (parameters of the
assumed distribution). <strong>Note</strong>: The parameters are given in the
(log-)location-scale-parameterization.
</p>
</li>
<li> <p><code>confint</code> : Confidence intervals for the (log-)location-scale parameters.
For threshold distributions no confidence interval for the threshold parameter
can be computed. If <code>direction = "y_on_x"</code>, back-transformed confidence
intervals are provided.
</p>
</li>
<li> <p><code>shape_scale_coefficients</code> : Only included if <code>distribution</code> is <code>"weibull"</code>
or <code>"weibull3"</code> (parameterization used in <a href="stats.html#topic+Weibull">Weibull</a>).
</p>
</li>
<li> <p><code>shape_scale_confint</code> : Only included if <code>distribution</code> is <code>"weibull"</code>
or <code>"weibull3"</code>. Approximated confidence intervals for scale <code class="reqn">\eta</code> and
shape <code class="reqn">\beta</code> (and threshold <code class="reqn">\gamma</code> if <code>distribution = "weibull3"</code>).
</p>
</li>
<li> <p><code>varcov</code> : Only provided if <code>options = list(conf_method = "HC")</code> (default).
Estimated heteroscedasticity-consistent (<strong>HC</strong>) variance-covariance matrix
for the (log-)location-scale parameters.
</p>
</li>
<li> <p><code>r_squared</code> : Coefficient of determination.
</p>
</li>
<li> <p><code>data</code> : A <code>tibble</code> with class <code>wt_cdf_estimation</code> returned by <a href="#topic+estimate_cdf">estimate_cdf</a>.
</p>
</li>
<li> <p><code>distribution</code> : Specified distribution.
</p>
</li>
<li> <p><code>direction</code> : Specified direction.
</p>
</li></ul>

<p>If more than one method was specified in <a href="#topic+estimate_cdf">estimate_cdf</a>, the resulting output
is a list with class <code>wt_model_estimation_list</code>. In this case, each list element
has classes <code>wt_rank_regression</code> and <code>wt_model_estimation</code>, and the items listed
above, are included.
</p>


<h3>Options</h3>

<p>Argument <code>options</code> is a named list of options:</p>

<table>
<tr>
 <td style="text-align: left;">
   Name </td><td style="text-align: left;"> Value </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>conf_method</code> </td><td style="text-align: left;"> <code>"HC"</code> (default) or <code>"Mock"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>


<ul>
<li><p> Mock, R., Methoden zur Datenhandhabung in Zuverlässigkeitsanalysen,
vdf Hochschulverlag AG an der ETH Zürich, 1995
</p>
</li>
<li><p> Meeker, William Q; Escobar, Luis A., Statistical methods for reliability data,
New York: Wiley series in probability and statistics, 1998
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Reliability data preparation:
## Data for two-parametric model:
data_2p &lt;- reliability_data(
  shock,
  x = distance,
  status = status
)

## Data for three-parametric model:
data_3p &lt;- reliability_data(
  alloy,
  x = cycles,
  status = status
)

# Probability estimation:
prob_tbl_2p &lt;- estimate_cdf(
  data_2p,
  methods = "johnson"
)

prob_tbl_3p &lt;- estimate_cdf(
  data_3p,
  methods = "johnson"
)

prob_tbl_mult &lt;- estimate_cdf(
  data_3p,
  methods = c("johnson", "kaplan")
)

# Example 1 - Fitting a two-parametric weibull distribution:
rr_2p &lt;- rank_regression(
  x = prob_tbl_2p,
  distribution = "weibull"
)

# Example 2 - Fitting a three-parametric lognormal distribution:
rr_3p &lt;- rank_regression(
  x = prob_tbl_3p,
  distribution = "lognormal3",
  conf_level = 0.99
)

# Example 3 - Fitting a three-parametric lognormal distribution using
# direction and control arguments:
rr_3p_control &lt;- rank_regression(
  x = prob_tbl_3p,
  distribution = "lognormal3",
  conf_level = 0.99,
  direction = "y_on_x",
  control = list(trace = TRUE, REPORT = 1)
)

# Example 4 - Fitting a three-parametric loglogistic distribution if multiple
# methods in estimate_cdf were specified:
rr_lists &lt;- rank_regression(
  x = prob_tbl_mult,
  distribution = "loglogistic3",
  conf_level = 0.90
)

</code></pre>

<hr>
<h2 id='rank_regression.default'>Rank Regression for Parametric Lifetime Distributions</h2><span id='topic+rank_regression.default'></span>

<h3>Description</h3>

<p>This function fits a regression model to a linearized parametric lifetime
distribution for complete and (multiple) right-censored data. The parameters
are determined in the frequently used (log-)location-scale parameterization.
</p>
<p>For the Weibull, estimates are additionally transformed such that they are in
line with the parameterization provided by the <em>stats</em> package
(see <a href="stats.html#topic+Weibull">Weibull</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
rank_regression(
  x,
  y,
  status,
  distribution = c("weibull", "lognormal", "loglogistic", "sev", "normal", "logistic",
    "weibull3", "lognormal3", "loglogistic3", "exponential", "exponential2"),
  conf_level = 0.95,
  direction = c("x_on_y", "y_on_x"),
  control = list(),
  options = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank_regression.default_+3A_x">x</code></td>
<td>
<p>A numeric vector which consists of lifetime data. Lifetime data
could be every characteristic influencing the reliability of a product,
e.g. operating time (days/months in service), mileage (km, miles), load
cycles.</p>
</td></tr>
<tr><td><code id="rank_regression.default_+3A_y">y</code></td>
<td>
<p>A numeric vector which consists of estimated failure probabilities
regarding the lifetime data in <code>x</code>.</p>
</td></tr>
<tr><td><code id="rank_regression.default_+3A_status">status</code></td>
<td>
<p>A vector of binary data (0 or 1) indicating whether a unit is
a right censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="rank_regression.default_+3A_distribution">distribution</code></td>
<td>
<p>Supposed distribution of the random variable.</p>
</td></tr>
<tr><td><code id="rank_regression.default_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level of the interval.</p>
</td></tr>
<tr><td><code id="rank_regression.default_+3A_direction">direction</code></td>
<td>
<p>Direction of the dependence in the regression model.</p>
</td></tr>
<tr><td><code id="rank_regression.default_+3A_control">control</code></td>
<td>
<p>A list of control parameters (see <a href="stats.html#topic+optim">optim</a>).
</p>
<p><code>control</code> is in use only if a three-parametric distribution was specified.
If this is the case, <code>optim</code> (always with <code>method = "L-BFGS-B"</code> and
<code>control$fnscale = -1</code>) is called to determine the threshold parameter
(see <a href="#topic+r_squared_profiling">r_squared_profiling</a>).</p>
</td></tr>
<tr><td><code id="rank_regression.default_+3A_options">options</code></td>
<td>
<p>A list of named options. See 'Options'.</p>
</td></tr>
<tr><td><code id="rank_regression.default_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence intervals of the parameters are computed on the basis of a
heteroscedasticity-consistent (<strong>HC</strong>) covariance matrix. Here it should be
said that there is no statistical foundation to determine the standard errors
of the parameters using <em>Least Squares</em> in context of <em>Rank Regression</em>.
For an accepted statistical method use <a href="#topic+ml_estimation">maximum likelihood</a>.
</p>
<p>If <code>options = list(conf_method = "Mock")</code>, the argument <code>distribution</code> must be
one of <code>"weibull"</code> and <code>"weibull3"</code>. The approximated confidence intervals
for the Weibull parameters can then only be estimated on the following
confidence levels (see 'References' <em>(Mock, 1995)</em>):
</p>

<ul>
<li> <p><code>conf_level = 0.90</code>
</p>
</li>
<li> <p><code>conf_level = 0.95</code>
</p>
</li>
<li> <p><code>conf_level = 0.99</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A list with classes <code>wt_model</code>, <code>wt_rank_regression</code> and <code>wt_model_estimation</code>
which contains:
</p>

<ul>
<li> <p><code>coefficients</code> : A named vector of estimated coefficients (parameters of the
assumed distribution). <strong>Note</strong>: The parameters are given in the
(log-)location-scale-parameterization.
</p>
</li>
<li> <p><code>confint</code> : Confidence intervals for the (log-)location-scale parameters.
For threshold distributions no confidence interval for the threshold parameter
can be computed. If <code>direction = "y_on_x"</code>, back-transformed confidence
intervals are provided.
</p>
</li>
<li> <p><code>shape_scale_coefficients</code> : Only included if <code>distribution</code> is <code>"weibull"</code>
or <code>"weibull3"</code> (parameterization used in <a href="stats.html#topic+Weibull">Weibull</a>).
</p>
</li>
<li> <p><code>shape_scale_confint</code> : Only included if <code>distribution</code> is <code>"weibull"</code>
or <code>"weibull3"</code>. Approximated confidence intervals for scale <code class="reqn">\eta</code> and
shape <code class="reqn">\beta</code> (and threshold <code class="reqn">\gamma</code> if <code>distribution = "weibull3"</code>).
</p>
</li>
<li> <p><code>varcov</code> : Only provided if <code>options = list(conf_method = "HC")</code> (default).
Estimated heteroscedasticity-consistent (<strong>HC</strong>) variance-covariance matrix
for the (log-)location-scale parameters.
</p>
</li>
<li> <p><code>r_squared</code> : Coefficient of determination.
</p>
</li>
<li> <p><code>data</code> : A <code>tibble</code> with columns <code>x</code>, <code>status</code> and <code>prob</code>.
</p>
</li>
<li> <p><code>distribution</code> : Specified distribution.
</p>
</li>
<li> <p><code>direction</code> : Specified direction.
</p>
</li></ul>



<h3>Options</h3>

<p>Argument <code>options</code> is a named list of options:</p>

<table>
<tr>
 <td style="text-align: left;">
   Name </td><td style="text-align: left;"> Value </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>conf_method</code> </td><td style="text-align: left;"> <code>"HC"</code> (default) or <code>"Mock"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>


<ul>
<li><p> Mock, R., Methoden zur Datenhandhabung in Zuverlässigkeitsanalysen,
vdf Hochschulverlag AG an der ETH Zürich, 1995
</p>
</li>
<li><p> Meeker, William Q; Escobar, Luis A., Statistical methods for reliability data,
New York: Wiley series in probability and statistics, 1998
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+rank_regression">rank_regression</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors:
obs &lt;- seq(10000, 100000, 10000)
status_1 &lt;- c(0, 1, 1, 0, 0, 0, 1, 0, 1, 0)

cycles &lt;- alloy$cycles
status_2 &lt;- alloy$status

# Example 1 - Fitting a two-parametric weibull distribution:
tbl_john &lt;- estimate_cdf(
  x = obs,
  status = status_1,
  method = "johnson"
)

rr &lt;- rank_regression(
  x = tbl_john$x,
  y = tbl_john$prob,
  status = tbl_john$status,
  distribution = "weibull",
  conf_level = 0.90
)

# Example 2 - Fitting a three-parametric lognormal distribution:
tbl_kaplan &lt;- estimate_cdf(
  x = cycles,
  status = status_2,
  method = "kaplan"
)

rr_2 &lt;- rank_regression(
  x = tbl_kaplan$x,
  y = tbl_kaplan$prob,
  status = tbl_kaplan$status,
  distribution = "lognormal3"
)

</code></pre>

<hr>
<h2 id='reliability_data'>Reliability Data</h2><span id='topic+reliability_data'></span>

<h3>Description</h3>

<p>Create consistent reliability data based on an existing <code>data.frame</code>
(preferred) or on multiple equal length vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reliability_data(data = NULL, x, status, id = NULL, .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reliability_data_+3A_data">data</code></td>
<td>
<p>Either <code>NULL</code> or a <code>data.frame</code>. If data is <code>NULL</code>,
<code>x</code>, <code>status</code> and <code>id</code> must be vectors containing
the data. Otherwise <code>x</code>, <code>status</code> and <code>id</code> can be either column
names or column positions.</p>
</td></tr>
<tr><td><code id="reliability_data_+3A_x">x</code></td>
<td>
<p>Lifetime data, that means any characteristic influencing the reliability
of a product, e.g. operating time (days/months in service), mileage (km, miles),
load cycles.</p>
</td></tr>
<tr><td><code id="reliability_data_+3A_status">status</code></td>
<td>
<p>Binary data (0 or 1) indicating whether a unit is a right
censored observation (= 0) or a failure (= 1).</p>
</td></tr>
<tr><td><code id="reliability_data_+3A_id">id</code></td>
<td>
<p>Identification of every unit.</p>
</td></tr>
<tr><td><code id="reliability_data_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code> keep remaining variables in <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with class <code>wt_reliability_data</code> containing the following
columns (if <code>.keep_all = FALSE</code>):
</p>

<ul>
<li> <p><code>x</code> : Lifetime characteristic.
</p>
</li>
<li> <p><code>status</code> : Binary data (0 or 1) indicating whether a unit is a right
censored observation (= 0) or a failure (= 1).
</p>
</li>
<li> <p><code>id</code> : Identification for every unit.
</p>
</li></ul>

<p>If <code>.keep_all = TRUE</code>, the remaining columns of <code>data</code> are also preserved.
</p>
<p>If <code>!is.null(data)</code> the attribute <code>characteristic</code> holds the name of the
characteristic described by <code>x</code>. Otherwise it is set to <code>"x"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 -  Based on an existing data.frame/tibble and column names:
data &lt;- reliability_data(
  data = shock,
  x = distance,
  status = status
)

# Example 2 - Based on an existing data.frame/tibble and column positions:
data_2 &lt;- reliability_data(
  data = shock,
  x = 1,
  status = 3
)

# Example 3 - Keep all variables of the tibble/data.frame entered to argument data:
data_3 &lt;- reliability_data(
  data = shock,
  x = distance,
  status = status,
  .keep_all = TRUE
)

# Example 4 - Based on vectors:
cycles &lt;- alloy$cycles
state &lt;- alloy$status
id &lt;- "XXXXXX"

data_4 &lt;- reliability_data(
  x = cycles,
  status = state,
  id = id
)

</code></pre>

<hr>
<h2 id='shock'>Distance to Failure for Vehicle Shock Absorbers</h2><span id='topic+shock'></span>

<h3>Description</h3>

<p>Distance to failure for 38 vehicle shock absorbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shock
</code></pre>


<h3>Format</h3>

<p>A tibble with 38 rows and 3 variables:
</p>

<dl>
<dt>distance</dt><dd><p>Observed distance.</p>
</dd>
<dt>failure_mode</dt><dd>
<p>One of two failure modes (<code>mode_1</code> and <code>mode_2</code>)
or <code>censored</code> if no failure occurred.
</p>
</dd>
<dt>status</dt><dd>
<p>If <code>failure_mode</code> is either <code>mode_1</code> or <code>mode_2</code>
this is <code>1</code> else <code>0</code>.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Meeker, William Q; Escobar, Luis A., Statistical Methods for
Reliability Data, New York: Wiley series in probability and statistics
(1998, p.630)
</p>

<hr>
<h2 id='voltage'>High Voltage Stress Test for the Dielectric Insulation of Generator armature bars</h2><span id='topic+voltage'></span>

<h3>Description</h3>

<p>A sample of 58 segments of bars were subjected to a high voltage stress test.
Two failure modes occurred, Mode D (degradation failure) and Mode E (early failure).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voltage
</code></pre>


<h3>Format</h3>

<p>A tibble with 58 rows and 3 variables:
</p>

<dl>
<dt>hours</dt><dd><p>Observed hours.</p>
</dd>
<dt>failure_mode</dt><dd>
<p>One of two failure modes (<code>D</code> and <code>E</code>)
or <code>censored</code> if no failure occurred.
</p>
</dd>
<dt>status</dt><dd>
<p>If <code>failure_mode</code> is either <code>D</code> or <code>E</code>
this is <code>1</code> else <code>0</code>.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Doganaksoy, N.; Hahn, G.; Meeker, W. Q., Reliability Analysis by
Failure Mode, Quality Progress, 35(6), 47-52, 2002
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
