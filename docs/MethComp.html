<!DOCTYPE html><html lang="en"><head><title>Help for package MethComp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MethComp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abconv'><p>Derive linear conversion coefficients from a set of indeterminate</p>
coefficients</a></li>
<li><a href='#AltReg'><p>Estimate in a method comparison model with replicates</p></a></li>
<li><a href='#Ancona'><p>Data from a rating experiment of recorgnizing point counts.</p></a></li>
<li><a href='#BA.est'><p>Bias and variance components for a Bland-Altman plot.</p></a></li>
<li><a href='#BA.plot'><p>Bland-Altman plot of differences versus averages.</p></a></li>
<li><a href='#bothlines'><p>Add regression lines to a plot</p></a></li>
<li><a href='#cardiac'><p>Measurement of cardiac output by two different methods.</p></a></li>
<li><a href='#CardOutput'><p>Measurements of Cardiac output.</p></a></li>
<li><a href='#check.trans'><p>Functions to handle transformations of measurement results.</p></a></li>
<li><a href='#choose.trans'><p>Functions to handle transformations of measurement results.</p></a></li>
<li><a href='#corr.measures'><p>Classical association measures</p></a></li>
<li><a href='#DA.reg'><p>Make a regression of differences on averages</p></a></li>
<li><a href='#DA2y'><p>Convert DA to (classical) regression</p></a></li>
<li><a href='#Deming'><p>Regression with errors in both variables (Deming regression)</p></a></li>
<li><a href='#ends'><p>Function to identify the extremes of a vector</p></a></li>
<li><a href='#Enzyme'><p>Enzyme activity data</p></a></li>
<li><a href='#fat'><p>Measurements of subcutaneous and visceral fat</p></a></li>
<li><a href='#glucose'><p>Glucose measurements by different methods</p></a></li>
<li><a href='#hba.MC'><p>A MCmcmc object from the hba1c data</p></a></li>
<li><a href='#hba1c'><p>Measurements of HbA1c from Steno Diabetes Center</p></a></li>
<li><a href='#MCmcmc'><p>Fit a model for method comparison studies using WinBUGS</p></a></li>
<li><a href='#Meth'><p>Create a Meth object representing a method comparison study</p></a></li>
<li><a href='#Meth.sim'><p>Simulate a dataframe containing replicate measurements on the same items</p>
using different methods.</a></li>
<li><a href='#MethComp'><p>Summarize conversion equations and prediction intervals between methods.</p></a></li>
<li><a href='#middle'><p>Function to identify the middle of a vector</p></a></li>
<li><a href='#milk'><p>Measurement of fat content of human milk by two different methods.</p></a></li>
<li><a href='#ox'><p>Measurement of oxygen saturation in blood</p></a></li>
<li><a href='#ox.MC'><p>A MCmcmc object from the oximetry data.</p></a></li>
<li><a href='#pairs.MCmcmc'><p>Create a pairs plot for an MCmcmc object</p></a></li>
<li><a href='#PBreg'><p>Passing-Bablok regression</p></a></li>
<li><a href='#PEFR'><p>Peak Expiratory Flow Rate (PEFR) measurements with Wright peak flow and mini</p>
Wright peak flow meter.</a></li>
<li><a href='#perm.repl'><p>Manipulate the replicate numbering within (item,method)</p></a></li>
<li><a href='#plot.MCmcmc'><p>Plot estimated conversion lines and formulae.</p></a></li>
<li><a href='#plot.MethComp'><p>Summarize conversion equations and prediction intervals between methods.</p></a></li>
<li><a href='#plvol'><p>Measurements of plasma volume measured by two different methods.</p></a></li>
<li><a href='#predict.PBreg'><p>Predict results from PBreg object</p></a></li>
<li><a href='#print.MCmcmc'><p>Print a MCmcmc object</p></a></li>
<li><a href='#rainman'><p>Perception of points in a swarm</p></a></li>
<li><a href='#sample.Meth'><p>Sample Meth object with replacement</p></a></li>
<li><a href='#sbp'><p>Systolic blood pressure measured by three different methods.</p></a></li>
<li><a href='#sbp.MC'><p>A MCmcmc object from the sbp data</p></a></li>
<li><a href='#scint'><p>Relative renal function by Scintigraphy</p></a></li>
<li><a href='#subset.MCmcmc'><p>Subset an MCmcmc object</p></a></li>
<li><a href='#summary.MCmcmc'><p>Summary</p></a></li>
<li><a href='#summary.Meth'><p>Summary for Meth obect</p></a></li>
<li><a href='#TDI'><p>Compute Lin's Total deviation index</p></a></li>
<li><a href='#to.long'><p>Functions to convert between long and wide representations of data</p></a></li>
<li><a href='#to.wide'><p>Functions to convert between long and wide representations of data</p></a></li>
<li><a href='#trace.MCmcmc'><p>Functions to graphically assess the convergence of the MCMC-simulation in a</p>
MCmcmc object</a></li>
<li><a href='#VitCap'><p>Merits of two instruments designed to measure certain aspects of human lung</p>
function (Vital Capacity)</a></li>
<li><a href='#y2DA'><p>Convert DA to (classical) regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.30.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-15</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Agreement in Method Comparison Studies</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, nlme</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice, lme4, rjags</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods (standard and advanced) for analysis of agreement between measurement methods. These cover Bland-Altman plots, Deming regression, Lin's Total deviation index, and difference-on-average regression. See Carstensen B. (2010) "Comparing Clinical Measurement Methods: A Practical Guide (Statistics in Practice)" &lt;<a href="https://doi.org/10.1002%2F9780470683019">doi:10.1002/9780470683019</a>&gt; for more information.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://BendixCarstensen.com/MethComp/">http://BendixCarstensen.com/MethComp/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ekstroem/MethComp/issues">https://github.com/ekstroem/MethComp/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS (http://mcmc-jags.sourceforge.net)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-20 00:18:05 UTC; ekstrom</td>
</tr>
<tr>
<td>Author:</td>
<td>Bendix Carstensen [aut],
  Lyle Gurrin [aut],
  Claus Thorn Ekstrøm [aut, cre],
  Michal Figurski [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Claus Thorn Ekstrøm &lt;ekstrom@sund.ku.dk&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-20 03:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abconv'>Derive linear conversion coefficients from a set of indeterminate
coefficients</h2><span id='topic+abconv'></span>

<h3>Description</h3>

<p>If a method comparison model is defined as <code class="reqn">y_{mi} = \alpha_m + \beta_m
\mu_i, m=1,2</code> y_mi = alpha_m + beta_m*mu_i, m=1,2 the coefficients of the
linear conversion from method 1 to 2 are computed as: <code class="reqn">\alpha_{2|1} =
-\alpha_2-\alpha_1\beta_2/\beta_1</code> alpha_(2|1) =
-alpha_2-alpha_1*beta_2/beta_1 <code class="reqn">\beta_{2|1} =
\beta_2/\beta_1</code> Morover the the point where the
linear conversion function intersects the identity line is computed too..
The function is designed to work on numerical vectors of posterior samples
from BUGS output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abconv(
  a1,
  b1 = 1:4,
  a2 = NULL,
  b2 = NULL,
  col.names = c("alpha.2.1", "beta.2.1", "id.2.1")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abconv_+3A_a1">a1</code></td>
<td>
<p>Numerical vector of intercepts for first method.  Alternatively a
dataframe where the vectors are selected from.</p>
</td></tr>
<tr><td><code id="abconv_+3A_b1">b1</code></td>
<td>
<p>Numerical vector of slopes for first method. If <code>a1</code> is a
dataframe, <code>b1</code> is assumed to be a numerical vector of length 4
pointing to the columns of <code>a1</code> with the intercepts and slopes.</p>
</td></tr>
<tr><td><code id="abconv_+3A_a2">a2</code></td>
<td>
<p>Numerical vector of intercepts for second method.</p>
</td></tr>
<tr><td><code id="abconv_+3A_b2">b2</code></td>
<td>
<p>Numerical vector of slopes for second method.</p>
</td></tr>
<tr><td><code id="abconv_+3A_col.names">col.names</code></td>
<td>
<p>Names for the resulting three vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with three columns: intercept and slope for the
conversion from method 1 to method 2, and the value where the conversion is
the identity.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="https://BendixCarstensen.com">https://BendixCarstensen.com</a>
</p>


<h3>References</h3>

<p>B Carstensen: Comparing and predicting between several methods
of measurement, Biostatistics, 5, pp 399-413, 2004
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BA.plot">BA.plot</a></code>, <code><a href="#topic+MCmcmc">MCmcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
abconv( 0.3, 0.9, 0.8, 0.8 )

</code></pre>

<hr>
<h2 id='AltReg'>Estimate in a method comparison model with replicates</h2><span id='topic+AltReg'></span>

<h3>Description</h3>

<p>Estimates in the general model for method comparison studies with replicate
measurements by each method, allowing for a linear relationship between
methods, using the method of alternating regressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AltReg(
  data,
  linked = FALSE,
  IxR = linked,
  MxI = TRUE,
  varMxI = FALSE,
  eps = 0.001,
  maxiter = 50,
  trace = FALSE,
  sd.lim = 0.01,
  Transform = NULL,
  trans.tol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AltReg_+3A_data">data</code></td>
<td>
<p>Data frame with the data in long format, (or a
<code><a href="#topic+Meth">Meth</a></code> object) i.e. it must have columns <code>meth</code>,
<code>item</code>, <code>repl</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="AltReg_+3A_linked">linked</code></td>
<td>
<p>Logical. Are the replicates linked across methods? If true, a
random <code>item</code> by <code>repl</code> is included in the model, otherwise not.</p>
</td></tr>
<tr><td><code id="AltReg_+3A_ixr">IxR</code></td>
<td>
<p>Logical, alias for linked.</p>
</td></tr>
<tr><td><code id="AltReg_+3A_mxi">MxI</code></td>
<td>
<p>Logical, should the method by item effect (matrix effect) be in
the model?</p>
</td></tr>
<tr><td><code id="AltReg_+3A_varmxi">varMxI</code></td>
<td>
<p>Logical, should the method by item effect have method-specific
variances. Ignored if only two methods are compared. See details.</p>
</td></tr>
<tr><td><code id="AltReg_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion, the test is the max of the relative change
since last iteration in both mean and variance parameters.</p>
</td></tr>
<tr><td><code id="AltReg_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximal number of iterations.</p>
</td></tr>
<tr><td><code id="AltReg_+3A_trace">trace</code></td>
<td>
<p>Should a trace of the iterations be printed? If <code>TRUE</code>
iteration number, convergence criterion and current estimates of means and
sds are printed.</p>
</td></tr>
<tr><td><code id="AltReg_+3A_sd.lim">sd.lim</code></td>
<td>
<p>Estimated standard deviations below <code>sd.lim</code> are
disregarded in the evaluation of convergence. See details.</p>
</td></tr>
<tr><td><code id="AltReg_+3A_transform">Transform</code></td>
<td>
<p>A character string, or a list of two functions, each
other's inverse. The measurements are transformed by this before analysis.
Possibilities are: &quot;exp&quot;, &quot;log&quot;, &quot;logit&quot;, &quot;pctlogit&quot; (transforms percentages
by the logit), &quot;sqrt&quot;, &quot;sq&quot; (square), &quot;cll&quot; (complementary log-minus-log),
&quot;ll&quot; (log-minus-log). For further details see <code><a href="#topic+choose.trans">choose.trans</a></code>.</p>
</td></tr>
<tr><td><code id="AltReg_+3A_trans.tol">trans.tol</code></td>
<td>
<p>The tolerance used to check whether the supplied
transformation and its inverse combine to the identity.  Only used if
<code>Transform</code> is a list of two functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When fitting a model with both IxR and MxI interactions it may become very
unstable to have different variances of the MxI random effects for each
method, and hence the default option is to have a constant MxI variance
across methods. On the other hand it may be grossly inadequate to assume
these variances to be identical.
</p>
<p>If only two methods are compared, it is not possible to separate different
variances of the MxI effect, and hence the <code>varMxI</code> is ignored in this
case.
</p>
<p>The model fitted is formulated as: </p>
<p style="text-align: center;"><code class="reqn">y_{mir} = \alpha_m +
\beta_m(\mu_i+a_{ir} + c_{mi}) + </code>
</p>
<p style="text-align: center;"><code class="reqn"> e_{mir}</code>
</p>
<p> and the relevant parameters to report are
the estimates sds of <code class="reqn">a_{ir}</code> and <code class="reqn">c_{mi}</code>
multiplied with the corresonidng <code class="reqn">\beta_m</code>. Therefore, different
values of the variances for MxI and IxR are reported also when
<code>varMxI==FALSE</code>. Note that <code>varMxI==FALSE</code> is the default and that
this is the opposite of the default in <code><a href="#topic+BA.est">BA.est</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>c("MethComp","AltReg")</code>, which is a list
with three elements: </p>
<table role = "presentation">
<tr><td><code>Conv</code></td>
<td>
<p>A 3-way array with the 2 first dimensions
named &quot;To:&quot; and &quot;From:&quot;, with methods as levels. The third dimension is
classifed by the linear parameters &quot;alpha&quot;, &quot;beta&quot;, and &quot;sd&quot;.</p>
</td></tr>
<tr><td><code>VarComp</code></td>
<td>
<p>A matrix with methods as rows and variance components as
columns. Entries are the estimated standard deviations.</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>The
original data used in the analysis, with untransformed measurements
(<code>y</code>s). This is needed for plotting purposes.</p>
</td></tr></table>
<p> Moreover, if a
transformation was applied before analysis, an attribute &quot;Transform&quot; is
present; a list with two elements <code>trans</code> and <code>inv</code>, both of which
are functions, the first the transform, the last the inverse.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>,
<a href="https://BendixCarstensen.com">https://BendixCarstensen.com</a>.
</p>


<h3>References</h3>

<p>B Carstensen: Comparing and predicting between several methods
of measurement. Biostatistics (2004), 5, 3, pp. 399&ndash;413.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BA.est">BA.est</a></code>, <code><a href="#topic+DA.reg">DA.reg</a></code>, <code><a href="#topic+Meth.sim">Meth.sim</a></code>,
<code><a href="#topic+MethComp">MethComp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( ox )
ox &lt;- Meth( ox )
## Not run: 
ox.AR &lt;- AltReg( ox, linked=TRUE, trace=TRUE, Transform="pctlogit" )
str( ox.AR )
ox.AR
# plot the resulting conversion between methods
plot(ox.AR,pl.type="conv",axlim=c(20,100),points=TRUE,xaxs="i",yaxs="i",pch=16)
# - or the rotated plot
plot(ox.AR,pl.type="BA",axlim=c(20,100),points=TRUE,xaxs="i",yaxs="i",pch=16) 
## End(Not run)

</code></pre>

<hr>
<h2 id='Ancona'>Data from a rating experiment of recorgnizing point counts.</h2><span id='topic+Ancona'></span>

<h3>Description</h3>

<p>At the course &quot;Statsitical Analysis of Method Comparison Studies&quot; ai the
SISMEC conference in Ancona, on 28 September 2011, the participants on the
course were used as raters of ten pictures of points. Pitures were shown 3
times each to the participants, and they assessed the number of points in
each.
</p>


<h3>Format</h3>

<p>A data frame with 510 observations on the following 4 variables.
</p>
 <dl>
<dt><code>rater</code></dt><dd><p>a factor with 17 levels</p>
</dd>
<dt><code>item</code></dt><dd><p>a numeric vector indicating the pictures shown. The
value is the actual number of points.</p>
</dd> <dt><code>repl</code></dt><dd><p>a numeric vector,
replicate number</p>
</dd> <dt><code>score</code></dt><dd><p>a numeric vector, the number of
points in <code>item</code></p>
</dd> </dl>



<h3>Source</h3>

<p>The course &quot;Statsitical Analysis of Method Comparison Studies&quot; ai
the SISMEC conference in Ancona, on 28 September 2011.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library( MethComp )
data( Ancona )
Anc &lt;- Meth( Ancona, 1, 2, 3, 4 )

</code></pre>

<hr>
<h2 id='BA.est'>Bias and variance components for a Bland-Altman plot.</h2><span id='topic+BA.est'></span>

<h3>Description</h3>

<p>A variance component model is fitted to method comparison data with
replicate measurements in each method by item stratum. The purpose is to
simplify the construction of a correct Bland-Altman-plot when replicate
measurements are available, and to give the REML-estimates of the relevant
variance components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BA.est(
  data,
  linked = TRUE,
  IxR = has.repl(data),
  MxI = has.repl(data),
  corMxI = FALSE,
  varMxI = TRUE,
  IxR.pr = FALSE,
  bias = TRUE,
  alpha = 0.05,
  Transform = NULL,
  trans.tol = 1e-06,
  random.raters = FALSE,
  lmecontrol = lmeControl(msMaxIter = 300),
  weightfunction = c("mean", "median")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BA.est_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+Meth">Meth</a></code> object representing method comparison data
with replicate measurements, i.e. with columns <code>meth</code>, <code>item</code>,
<code>repl</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="BA.est_+3A_linked">linked</code></td>
<td>
<p>Logical. Are replicates linked within item across methods?</p>
</td></tr>
<tr><td><code id="BA.est_+3A_ixr">IxR</code></td>
<td>
<p>Logical. Should an item by repl interaction be included in the
model. This is needed when the replicates are linked within item across
methods, so it is just another name for the <code>linked</code> argument.  If
<code>linked=</code> is given, this is ignored.</p>
</td></tr>
<tr><td><code id="BA.est_+3A_mxi">MxI</code></td>
<td>
<p>Logical. Should the method by item interaction (matrix effect) be
included in the model.</p>
</td></tr>
<tr><td><code id="BA.est_+3A_cormxi">corMxI</code></td>
<td>
<p>Logical. Should the method by item interaction allow
coorelated effects within item. Ignored if only two methods are compared.</p>
</td></tr>
<tr><td><code id="BA.est_+3A_varmxi">varMxI</code></td>
<td>
<p>Logical. Should the method by item interaction have a variance
that varies between methods. Ignored if only two methods are compared.</p>
</td></tr>
<tr><td><code id="BA.est_+3A_ixr.pr">IxR.pr</code></td>
<td>
<p>Logical. Should the item by repl interaction variation be
included in the prediction standard deviation?</p>
</td></tr>
<tr><td><code id="BA.est_+3A_bias">bias</code></td>
<td>
<p>Logical. Should a systematic bias between methods be estimated?
If <code>FALSE</code> no bias between methods are assumed, i.e.  <code class="reqn">\alpha_m=0,
m=1,\ldots M</code>.</p>
</td></tr>
<tr><td><code id="BA.est_+3A_alpha">alpha</code></td>
<td>
<p>Numerical. Significance level. By default the value 2 is used
when computing prediction intervals, otherwise the
<code class="reqn">1-\alpha/2</code> t-quantile is used. The number of d.f. is taken
as the number of units minus the number of items minus the number of methods
minus 1 (<code class="reqn">I-M-1</code>).</p>
</td></tr>
<tr><td><code id="BA.est_+3A_transform">Transform</code></td>
<td>
<p>Transformation applied to data (<code>y</code>) before analysis.
See <code><a href="#topic+check.trans">check.trans</a></code> for possible values.</p>
</td></tr>
<tr><td><code id="BA.est_+3A_trans.tol">trans.tol</code></td>
<td>
<p>Numerical. The tolerance used to check whether the supplied
transformation and its inverse combine to the identity.</p>
</td></tr>
<tr><td><code id="BA.est_+3A_random.raters">random.raters</code></td>
<td>
<p>Logical. Should methods/raters be considered as random.
Defaults to <code>FALSE</code> which corresponds to a fixed effect of
methods/raters.</p>
</td></tr>
<tr><td><code id="BA.est_+3A_lmecontrol">lmecontrol</code></td>
<td>
<p>A list of control parameters passed on to <code>lme</code>.</p>
</td></tr>
<tr><td><code id="BA.est_+3A_weightfunction">weightfunction</code></td>
<td>
<p>Function to weigh variance components for random
raters. Defaults to <code>mean</code> but can also be <code>median</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model fitted is: </p>
<p style="text-align: center;"><code class="reqn">y=\alpha_m + \mu_i + c_{mi} + a_{ir} + e_{mir},
</code>
</p>
<p style="text-align: center;"><code class="reqn"> \quad
\mathrm{var}(c_{mi})=\tau_m^2, </code>
</p>
<p style="text-align: center;"><code class="reqn"> \quad
\mathrm{var}(a_{ir})=\omega^2, </code>
</p>
<p style="text-align: center;"><code class="reqn"> \quad
\mathrm{var}(e_{mir})=\sigma_m^2, </code>
</p>
<p style="text-align: center;"><code class="reqn">
y=alpha_m + mu_i + c_mi + a_ir + e_ir, var(c_mi)=tau_m^2,
var(a_ir)=omega^2, var(e_mir)=sigma_m^2</code>
</p>
<p> We can only fit separate variances
for the <code class="reqn">\tau s</code> if more than two methods are compared (i.e.
<code>nM</code> &gt; 2), hence varMxI is ignored when <code>nM</code>==2.
</p>
<p>The function <code>VC.est</code> is the workhorse; <code>BA.est</code> just calls it.
<code>VC.est</code> figures out which model to fit by <code>lme</code>, extracts results
and returns estimates. <code>VC.est</code> is also used as part of the fitting
algorithm in <code><a href="#topic+AltReg">AltReg</a></code>, where each iteration step requires fit of
this model. The function <code>VC.est</code> is actually just a wrapper for the
functions <code>VC.est.fixed</code> that handles the case with fixed methods
(usually 2 or three) i.e. the classical method comparison problem, and
<code>VC.est.random</code> that handles the situation where &quot;methods&quot; are merely a
random sample of raters from some population of raters; and therefore are
regarded as random.
</p>


<h3>Value</h3>

<p><code>BA.est</code> returns an object of class
<code>c("<a href="#topic+MethComp">MethComp</a>","BA.est")</code>, a list with four elements <code>Conv</code>,
<code>VarComp</code>, <code>LoA</code>, <code>RepCoef</code>; <code>VC.est</code> returns
(invisibly!) a list with elements <code>Bias</code>, <code>VarComp</code>, <code>Mu</code>,
<code>RanEff</code>.  These list components are: </p>
<table role = "presentation">
<tr><td><code>Conv</code></td>
<td>
<p>3-dimensional array
with dimensions &quot;To&quot;, &quot;From&quot; and unnamed.  The first two dimensions have the
methods compared as levels, the last one
<code>c("alpha","beta","sd.pred","LoA: lower","upper")</code>.  It represents the
mean conversions between methods and the prediction standard deviation.
</p>
<p>Where &quot;To&quot; and &quot;From&quot; take the same value the value of the &quot;sd&quot; component is
<code class="reqn">\sqrt{2}</code> times the residual variation for the method. If
<code>IxR.pr=TRUE</code> the variation between replicates are included too, i.e.
<code class="reqn">\sqrt{2(\sigma_m^2+\omega^2)} </code> sqrt[2(sigma_m^2+omega^2)]. </p>
</td></tr>
<tr><td><code>VarComp</code></td>
<td>
<p>A matrix of variance components (on the SD scale) with
methods as rows and variance components &quot;IxR&quot;, &quot;MxI&quot; and &quot;res&quot; as columns.</p>
</td></tr>
<tr><td><code>LoA</code></td>
<td>
<p>Four-column matrix with mean difference, lower and upper limit of
agreement and prediction SD. Each row in the matrix represents a pair of
methods.</p>
</td></tr> <tr><td><code>RepCoef</code></td>
<td>
<p>Two-column matrix of repeatability SDs and
repeatability coefficients. The SDs are the standard deviation of the
difference between two measurements by the same method on the item under
identical circumstances; the repeatability coefficient the numerical extent
of the prediction interval for this difference, i.e.
<code class="reqn">2\sqrt{2}</code> times the sd.</p>
</td></tr> <tr><td><code>Mu</code></td>
<td>
<p>Estimates of the
item-specific parameters.</p>
</td></tr> <tr><td><code>RanEff</code></td>
<td>
<p>Estimates of the random effects
from the model (BLUPS).  This is a (possibly empty) list with possible
elements named <code>MxI</code> and <code>IxR</code> according to whether these random
effects are in the model.</p>
</td></tr></table>
<p> The returned object has an attribute,
<code>Transform</code> with the transformation applied to data before analysis,
and its inverse &mdash; see <code><a href="#topic+choose.trans">choose.trans</a></code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen
</p>


<h3>References</h3>

<p>Carstensen, Simpson &amp; Gurrin: Statistical models for assessing
agreement in method comparison studies with replicate measurements, The
International Journal of Biostatistics: Vol. 4 : Iss. 1, Article 16.
<a href="https://bepress.com">https://bepress.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BA.plot">BA.plot</a></code>, <code><a href="#topic+perm.repl">perm.repl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( ox )
ox &lt;- Meth( ox )
summary( ox )
BA.est( ox )
BA.est( ox, linked=FALSE )
BA.est( ox, linked=TRUE, Transform="pctlogit" )
## Not run: 
data( sbp )
BA.est( sbp )
BA.est( sbp, linked=FALSE )
# Check what you get from VC.est
str( VC.est( sbp ) )
## End(Not run)

</code></pre>

<hr>
<h2 id='BA.plot'>Bland-Altman plot of differences versus averages.</h2><span id='topic+BA.plot'></span><span id='topic+plot.PBreg'></span><span id='topic+plot.Meth'></span><span id='topic+plot.VarComp'></span>

<h3>Description</h3>

<p>For two vectors of equal length representing measurements of the same
quantity by two different methods, the differences are plotted versus the
average. The limits of agreement (prediction limits for the differences) are
plotted, optionally a regression of differences of means is given too. Works
with <code><a href="#topic+Meth">Meth</a></code> and <code><a href="#topic+MethComp">MethComp</a></code> objects too.
</p>
<p>A plot method for the <code>"PBreg"</code> class object, that is a result of
Passing-Bablok regression.
</p>
<p>When a method comparison model i fitted and stored in a <code><a href="#topic+MCmcmc">MCmcmc</a></code>
object, then the posterior distributions of the variance components are
plotted, in separate displays for method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BA.plot(
  y1,
  y2,
  meth.names = NULL,
  wh.comp = 1:2,
  pl.type = "BA",
  dif.type = "const",
  sd.type = "const",
  model = if (inherits(y1, "Meth") &amp; has.repl(y1)) "exch" else NULL,
  eqax = FALSE,
  axlim = if (is.data.frame(y1)) range(y1$y) else range(c(y1, y2)),
  diflim = NULL,
  grid = TRUE,
  N.grid = 10,
  col.grid = grey(0.9),
  points = TRUE,
  col.points = "black",
  cex.points = 1,
  pch.points = 16,
  lwd = c(3, 1, 1),
  col.lines = "blue",
  repl.conn = FALSE,
  col.conn = "gray",
  lwd.conn = 1,
  xlab = NULL,
  ylab = NULL,
  eqn = FALSE,
  col.eqn = col.lines,
  font.eqn = 2,
  digits = 2,
  Transform = if (mult) "log" else NULL,
  mult = FALSE,
  alpha = NULL,
  ...
)

## S3 method for class 'PBreg'
plot(
  x,
  pch = 21,
  bg = "#2200aa33",
  xlim = c(0, max(x$model)),
  ylim = c(0, max(x$model)),
  xlab = x$meths[1],
  ylab = x$meths[2],
  subtype = 1,
  colors = list(CI = "#ccaaff50", fit = "blue", ref = "#99999955", bars = "gray", dens =
    "#8866aaa0", ref2 = c("#1222bb99", "#bb221299")),
  ...
)

## S3 method for class 'Meth'
plot(
  x,
  which = NULL,
  col.LoA = "blue",
  col.pt = "black",
  cex.name = 2,
  var.range,
  diff.range,
  var.names = FALSE,
  pch = 16,
  cex = 0.7,
  Transform,
  ...
)

## S3 method for class 'VarComp'
plot(
  x,
  which,
  lwd.line = rep(2, 4),
  col.line = c("red", "green", "blue", "black"),
  lty.line = rep(1, 4),
  grid = TRUE,
  col.grid = gray(0.8),
  rug = TRUE,
  probs = c(5, 50, 95),
  tot.var = FALSE,
  same.ax = TRUE,
  meth.names = TRUE,
  VC.names = "first",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BA.plot_+3A_y1">y1</code></td>
<td>
<p>Numerical vector of measurements by 1st method. Can also be a
<code><a href="#topic+Meth">Meth</a></code> or a <code><a href="#topic+MethComp">MethComp</a></code> object, see details.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_y2">y2</code></td>
<td>
<p>Numerical vector of measurements by 2nd method. Must of same
length as <code>x</code>. Ignored if a <code><a href="#topic+Meth">Meth</a></code> or a
<code><a href="#topic+MethComp">MethComp</a></code> objects is given for <code>y1</code>.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_meth.names">meth.names</code></td>
<td>
<p>Should the names of the methods be put on the plots?</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_wh.comp">wh.comp</code></td>
<td>
<p>Which methods should be compared. Either numerical or
character.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_pl.type">pl.type</code></td>
<td>
<p>What type of plot should be made, <code>"BA"</code> for differences
versus averages, <code>"conv"</code> for method 1 versus method 2.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_dif.type">dif.type</code></td>
<td>
<p>How should difference depend on the averages. <code>"const"</code>
or <code>"lin"</code>.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_sd.type">sd.type</code></td>
<td>
<p>How should the standard deviation depend on the averages.
<code>"const"</code> or <code>"lin"</code>.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_model">model</code></td>
<td>
<p>Should a variance component model be used to compute the limits
of agreement? If <code>NULL</code> a simple analysis is made; other possibilities
are <code>"exch"</code> or <code>"linked"</code> for exchangeable or linked replicates.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_eqax">eqax</code></td>
<td>
<p>Should the axes be identical? If a Bland-Altman plot is drawn,
the axis for the differences will have the same extent as the axis for the
averages, but centered on 0 (see <code>diflim</code>).</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_axlim">axlim</code></td>
<td>
<p>The limits of the axes.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_diflim">diflim</code></td>
<td>
<p>The limits of the difference axis.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_grid">grid</code></td>
<td>
<p>Logical. Should a vertical grid be set up? If numeric it is set
up at the values specified. If <code>same.ax</code>, the range of the grid is
taken to be the extent of the x-axis for all plots.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_n.grid">N.grid</code></td>
<td>
<p>How many grid-lines should be drawn.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_col.grid">col.grid</code></td>
<td>
<p>The color of the grid.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_points">points</code></td>
<td>
<p>Logical. Should the observed points be drawn?</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_col.points">col.points</code></td>
<td>
<p>What color should they have?</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_cex.points">cex.points</code></td>
<td>
<p>How large should they be?</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_pch.points">pch.points</code></td>
<td>
<p>What plot character for the points</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_lwd">lwd</code></td>
<td>
<p>Numerical vector of 3, giving the width of the conversion line
(mean difference) and the limits of agreement.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_col.lines">col.lines</code></td>
<td>
<p>What color should the lines have.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_repl.conn">repl.conn</code></td>
<td>
<p>Should replicate measurements be connected (within items)?</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_col.conn">col.conn</code></td>
<td>
<p>Color of connecting lines.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_lwd.conn">lwd.conn</code></td>
<td>
<p>Width of connecting lines.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_xlab">xlab</code></td>
<td>
<p>Label on the x-axis.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_ylab">ylab</code></td>
<td>
<p>Label on the y-axis.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_eqn">eqn</code></td>
<td>
<p>Logical. Should the equations linking the methods be shown on the
plot? If a Bland-Altman plot is made, both the equations linking the methods
and the equation for the differences versus the averages are shown.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_col.eqn">col.eqn</code></td>
<td>
<p>Color for equations</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_font.eqn">font.eqn</code></td>
<td>
<p>Font for equations</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_digits">digits</code></td>
<td>
<p>How many digits after the decimal point should be used when
showing the equations.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_transform">Transform</code></td>
<td>
<p>Transformation used to the measurements prior to plotting.
Function or character, see <code><a href="#topic+choose.trans">choose.trans</a></code> for possible values.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_mult">mult</code></td>
<td>
<p>Logical. If TRUE, ratios of measurement instead of differences
will be plotted in the Bland-Altman plot on a logarithmic axis, and limits
of agreement will be given on this scale?  This gives the same analysis as
using <code>Transform="log"</code>, but a different plot. Using another
transformation than the log is accommodated, but no LoA is shown on the
axis.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_alpha">alpha</code></td>
<td>
<p>1 minus the confidence level. If <code>NULL</code> a multiplier of 2
is used for constructing prediction limits, otherwise a t-quantile with d.f.
equal th number of items minus 1.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_...">...</code></td>
<td>
<p>Parameters passed on the <code><a href="stats.html#topic+density">density</a></code> furnction that
does the smoothing of the posterior samples.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_x">x</code></td>
<td>
<p>A <code>MCmcmc</code> object.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_pch">pch</code></td>
<td>
<p>Plot character for points.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_bg">bg</code></td>
<td>
<p>Background colour for the plotting character.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_xlim">xlim</code></td>
<td>
<p>Limits for the x-axis.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the y-axis.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_subtype">subtype</code></td>
<td>
<p>a numeric value or vector, that selects the desired plot
subtype.  Subtype <b>1</b> is an x-y plot of raw data with regression line
and confidence boundaries for the fit as a shaded area.  This is the
default.  Subtype <b>2</b> is a ranked residuals plot.  Subtype <b>3</b> is
the &quot;Cusum&quot; plot useful for assessing linearity of the fit. Plot subtypes 1
through 3 are standard plots from the 1983 paper by Passing and Bablok - see
the reference.  Plot subtype <b>4</b> is a histogram (with overlaid density
line) of the individual slopes.  The range of this plot is limited to 5 x
IQR for better visibility.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_colors">colors</code></td>
<td>
<p>A list of 6 elements allowing customization of colors of
various plot elements. For plot subtype 1: &quot;CI&quot; is the color of the shaded
confidence interval area; and &quot;fit&quot; is the color of fit line. For plot
subtypes 2 &amp; 3: &quot;ref&quot; is the color of the horizontal reference line. For
plot subtype 4: &quot;bars&quot; is the bar background color, &quot;dens&quot; is the color of
the density line, and &quot;ref2&quot; is a vector of two colors for lines indicating
the median and confidence limits.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_which">which</code></td>
<td>
<p>For which of the compared methods should the plot be made?</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_col.loa">col.LoA</code></td>
<td>
<p>What color should be used for the limits of agreement.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_col.pt">col.pt</code></td>
<td>
<p>What color should be used for the points.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_cex.name">cex.name</code></td>
<td>
<p>Character expansion factor for plotting method names</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_var.range">var.range</code></td>
<td>
<p>The range of both axes in the scatter plot and the x-axis
in the Bland-Altman plot be?</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_diff.range">diff.range</code></td>
<td>
<p>The range of yaxis in the Bland-Altman plot. Defaults to a
range as the x-axis, but centered around 0.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_var.names">var.names</code></td>
<td>
<p>If logical: should the individual panels be labelled with
the variable names?. If character, then the values of the character will be
used to label the methods.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_cex">cex</code></td>
<td>
<p>Plot charcter expansion for points.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_lwd.line">lwd.line</code></td>
<td>
<p>Line width for drawing the density.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_col.line">col.line</code></td>
<td>
<p>Color for drawing the densities.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_lty.line">lty.line</code></td>
<td>
<p>Line type for drawing the densities.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_rug">rug</code></td>
<td>
<p>Should a small rug at the bottom show posterior quantiles?</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_probs">probs</code></td>
<td>
<p>Numeric vector with numbers in the range from 0 to 100,
indicating the posterior percentiles to be shown in the rug.</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_tot.var">tot.var</code></td>
<td>
<p>Should the posterior of the total variance also be shown?</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_same.ax">same.ax</code></td>
<td>
<p>Should the same axes be used for all methods?</p>
</td></tr>
<tr><td><code id="BA.plot_+3A_vc.names">VC.names</code></td>
<td>
<p>Should the names of the variance components be put on the
first plot (<code>"first"</code>), the last (<code>"last"</code>), all (<code>"all"</code>) or
none (<code>"none"</code>). Only the first letter is needed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot of the relationship between the methods is produced; either a
Bland-Altman plot of the differences versus averages, or a 45 degree
rotation as a conversion between the methods. If <code>model=NULL</code> a simple
regression of averages on differences is made by calling <code>DA.reg</code>, and
the specified conversion plotted.
</p>
<p>The function generates a series of plots, one for each method compared in
the <code>MCmcmc</code> object supplied (or those chosen by <code>which=</code>).
Therefore the user must take care to set <code>mfrow</code> or <code>mfcol</code> to
capture all the plots.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+MethComp">MethComp</a></code> and either <code>DA.reg</code>
(if <code>model=NULL</code>) or <code>BA.est</code> (if <code>model</code> is character).
</p>
<p>A plot as a side effect
</p>
<p>A list with one element for each method.  Each element of this is a
list of densities, i.e. of objects of class <code>density</code>, one for each
variance component.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>,
<a href="https://BendixCarstensen.com">https://BendixCarstensen.com</a>.
</p>
<p>Michal J. Figurski <a href="mailto:mfigrs@gmail.com">mfigrs@gmail.com</a>
</p>
<p>Bendix Carstensen, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>
</p>


<h3>References</h3>

<p>JM Bland and DG Altman: Statistical methods for assessing
agreement between two methods of clinical measurement, Lancet, i, 1986, pp.
307-310.
</p>
<p>JM Bland and DG Altman. Measuring agreement in method comparison studies.
Statistical Methods in Medical Research, 8:136-160, 1999.
</p>
<p>B Carstensen: Comparing methods of measurement: Extending the LoA by
regression. Stat Med. 2010 Feb 10;29(3):401-10.
</p>
<p>Passing, H. and Bablok, W. (1983), A New Biometrical Procedure
for Testing the Equality of Measurements from Two Different Analytical
Methods. <em>Journal of Clinical Chemistry and Clinical Biochemistry</em>,
<b>Vol 21</b>, 709&ndash;720
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BA.est">BA.est</a></code>, <code><a href="#topic+DA.reg">DA.reg</a></code>, <code><a href="#topic+MCmcmc">MCmcmc</a></code>.
</p>
<p><code><a href="#topic+PBreg">PBreg</a>, <a href="#topic+Deming">Deming</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( ox )
ox &lt;- Meth( ox )
# The simplest possible Bland-Altman plot
BA.plot( ox )

## With bells and whistles, comparing the naive and model
par( mfrow=c(2,2) )
BA.plot( ox, model=NULL, repl.conn=TRUE, col.lines="blue",
         axlim=c(0,100), diflim=c(-50,50), xaxs="i", yaxs="i",
         las=1, eqn=TRUE, dif.type="lin", pl.type="BA", sd.type="lin",
         grid=1:9*10, digits=3,font.eqn=1)
par(new=TRUE)
BA.plot( ox, model="linked", repl.conn=TRUE, col.lines="red",
         axlim=c(0,100), diflim=c(-50,50), xaxs="i", yaxs="i",
         las=1, eqn=FALSE, dif.type="lin", pl.type="BA", sd.type="lin",
        grid=1:0*10, digits=3)
BA.plot( ox, model=NULL, repl.conn=TRUE, col.lines="blue",
         axlim=c(0,100), diflim=c(-50,50), xaxs="i", yaxs="i",
         las=1, eqn=TRUE, dif.type="lin", pl.type="conv", sd.type="lin",
        grid=1:9*10, digits=3,font.eqn=1)
par(new=TRUE)
BA.plot( ox, model="linked", repl.conn=TRUE, col.lines="red",
         axlim=c(0,100), diflim=c(-50,50), xaxs="i", yaxs="i",
         las=1, eqn=FALSE, dif.type="lin", pl.type="conv", sd.type="lin",
         grid=1:9*10, digits=3)
# The same again, but now logit-transformed
BA.plot( ox, model=NULL, repl.conn=TRUE, col.lines="blue",
         axlim=c(0,100), diflim=c(-50,50), xaxs="i", yaxs="i",
         las=1, eqn=TRUE, dif.type="lin", pl.type="BA", sd.type="lin",
         grid=1:9*10, digits=3,font.eqn=1,Transform="pctlogit")
par(new=TRUE)
BA.plot( ox, model="linked", repl.conn=TRUE, col.lines="red",
         axlim=c(0,100), diflim=c(-50,50), xaxs="i", yaxs="i",
         las=1, eqn=FALSE, dif.type="lin", pl.type="BA", sd.type="lin",
         grid=1:0*10, digits=3,Transform="pctlogit")
BA.plot( ox, model=NULL, repl.conn=TRUE, col.lines="blue",
         axlim=c(0,100), diflim=c(-50,50), xaxs="i", yaxs="i",
         las=1, eqn=TRUE, dif.type="lin", pl.type="conv", sd.type="lin",
         grid=1:9*10, digits=3,font.eqn=1,Transform="pctlogit")
par(new=TRUE)
BA.plot( ox, model="linked", repl.conn=TRUE, col.lines="red",
         axlim=c(0,100), diflim=c(-50,50), xaxs="i", yaxs="i",
         las=1, eqn=FALSE, dif.type="lin", pl.type="conv", sd.type="lin",
         grid=1:9*10, digits=3,Transform="pctlogit")


  ## Model data frame generation
  a &lt;- data.frame(x=seq(1, 30)+rnorm(mean=0, sd=1, n=30),
                  y=seq(1, 30)*rnorm(mean=1, sd=0.4, n=30))

  ## Call to PBreg
  x &lt;- PBreg(a)
  print(x)
  par(mfrow=c(2,2))
  plot(x, s=1:4)

  ## Or the same using "Meth" object
  a &lt;- Meth(a, y=1:2)
  x &lt;- PBreg(a)
  print(x)
  par(mfrow=c(2,2))
  plot(x, s=1:4)

</code></pre>

<hr>
<h2 id='bothlines'>Add regression lines to a plot</h2><span id='topic+bothlines'></span>

<h3>Description</h3>

<p>Add the regression lines of <code class="reqn">y</code> on <code class="reqn">x</code> AND <code class="reqn">x</code> on
<code class="reqn">y</code> to the plot. Optionally add the line obtained by allowing errors
in both variables (Deming regression).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bothlines(x, y, Dem = FALSE, sdr = 1, col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bothlines_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="bothlines_+3A_y">y</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="bothlines_+3A_dem">Dem</code></td>
<td>
<p>Logical. Should the Deming regression line be added too?</p>
</td></tr>
<tr><td><code id="bothlines_+3A_sdr">sdr</code></td>
<td>
<p>Numeric. The assumed ratio of standard deviations used in the
Deming regression.</p>
</td></tr>
<tr><td><code id="bothlines_+3A_col">col</code></td>
<td>
<p>Colour of the lines. Can be a vector of up to 3 elements, one for
each line.</p>
</td></tr>
<tr><td><code id="bothlines_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="graphics.html#topic+abline">abline</a></code>, which
does the actual plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="https://BendixCarstensen.com">https://BendixCarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+abline">abline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( ox )
oxw &lt;- to.wide(ox)
attach( oxw )
plot( CO, pulse )
abline(0,1)
bothlines( CO, pulse, Dem=TRUE, col=rainbow(3), lwd=2 )
plot( CO, pulse,pch=16 )
abline(0,1, col=gray(0.7), lwd=2)
bothlines( CO, pulse, Dem=TRUE, col=c(rep("transparent",2),"black"), lwd=2 )

</code></pre>

<hr>
<h2 id='cardiac'>Measurement of cardiac output by two different methods.</h2><span id='topic+cardiac'></span>

<h3>Description</h3>

<p>For each subject cardiac output is measured repeatedly (three to six times)
by impedance cardiography (IC) and radionuclide ventriculography (RV).
</p>


<h3>Format</h3>

<p>A data frame with 120 observations on the following 4 variables.
</p>
 <dl>
<dt><code>meth</code></dt><dd><p>a factor with levels <code>IC</code> <code>RV</code></p>
</dd>
<dt><code>item</code></dt><dd><p>a numeric vector giving the item number.</p>
</dd>
<dt><code>repl</code></dt><dd><p>a numeric vector with replicate number.</p>
</dd>
<dt><code>y</code></dt><dd><p>the measuremnts of cardiac output.</p>
</dd> </dl>



<h3>Details</h3>

<p>It is not entirely clear from the source whether the replicates are
exchangeable within (method,item) or whether they represent pairs of
measurements. From the description it looks as if replicates are linked
between methods, but in the paper they are treated as if they were not.
</p>


<h3>Source</h3>

<p>The dataset is adapted from table 4 in: JM Bland and DG Altman:
Measuring agreement in method comparison studies. Statistical Methods in
Medical Research, 8:136-160, 1999. Originally supplied to Bland &amp; Altman by
Dr LS Bowling, see: Bowling LS, Sageman WS, O'Connor SM, Cole R, Amundson
DE.  Lack of agreement between measurement of ejection fraction by impedance
cardiography versus radionuclide ventriculography. Critical Care Medicine
1993; 21: 1523-27.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cardiac)
cardiac &lt;- Meth(cardiac)
summary(cardiac)
# Visually check exchangeability
plot( cardiac )
plot( perm.repl( cardiac ) )
BA.est(cardiac)
# Run MCmcmc using BRugs for an insufficient amount of iterations
## Not run: card.mi.ir &lt;- MCmcmc( cardiac,
                               beta=FALSE, random=c("mi","ir"),
                               n.iter=100, trace=T )
print( card.mi.ir )
## End(Not run)

</code></pre>

<hr>
<h2 id='CardOutput'>Measurements of Cardiac output.</h2><span id='topic+CardOutput'></span>

<h3>Description</h3>

<p>Two different ways of measuring cardiac output and oxygen saturation in 15
critically ill persons.
</p>


<h3>Format</h3>

<p>A data frame with 15 observations on the following 8 variables.
</p>
 <dl>
<dt><code>Age</code></dt><dd><p>Patient age</p>
</dd> <dt><code>Diag</code></dt><dd><p>Diagnosis, a
factor with levels <code>sepsis</code>, <code>cardiogenic</code>, <code>hypothermia</code></p>
</dd>
<dt><code>VO2</code></dt><dd><p>Oxygen consumption</p>
</dd> <dt><code>Svo2</code></dt><dd><p>Mixed venous O2
saturation</p>
</dd> <dt><code>Scvo2</code></dt><dd><p>Central venous oxygen saturation</p>
</dd>
<dt><code>TCO</code></dt><dd><p>Thermodilution-derived cardiac output</p>
</dd>
<dt><code>FCO</code></dt><dd><p>Fick-derived cardiac output.</p>
</dd> <dt><code>Sex</code></dt><dd><p>Sex, a
factor with levels <code>F</code>, <code>M</code></p>
</dd> </dl>



<h3>Source</h3>

<p>Avi A. Weinbroum, Philippe Biderman, Dror Soffer, Joseph M. Klausner &amp; Oded Szold:
</p>
<p>Reliability of cardiac output calculation by the fick principle and central
venous oxygen saturation in emergency conditions.
</p>
<p>Journal of Clinical Monitoring and Computing (2008) 22: 361-366
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CardOutput)

</code></pre>

<hr>
<h2 id='check.trans'>Functions to handle transformations of measurement results.</h2><span id='topic+check.trans'></span>

<h3>Description</h3>

<p>Check whether two functions actually are each others inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.trans(trans, y, trans.tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.trans_+3A_trans">trans</code></td>
<td>
<p>A list of two functions, each other's inverse.</p>
</td></tr>
<tr><td><code id="check.trans_+3A_y">y</code></td>
<td>
<p>Vector of numerical values where the functions should be each
other's inverse.</p>
</td></tr>
<tr><td><code id="check.trans_+3A_trans.tol">trans.tol</code></td>
<td>
<p>Numerical constant indication how precise the evaulation
should be.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>check.trans</code> returns nothing.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="https://bendixcarstensen.com/">https://bendixcarstensen.com/</a>.
</p>

<hr>
<h2 id='choose.trans'>Functions to handle transformations of measurement results.</h2><span id='topic+choose.trans'></span>

<h3>Description</h3>

<p>Choose a function and inverse based on a text string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose.trans(tr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choose.trans_+3A_tr">tr</code></td>
<td>
<p>A character string, or a list of two functions, they should be
each other's inverse. Names of the list are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>choose.trans</code> returns a named list with two elements &quot;trans&quot;
and &quot;inv&quot;, both functions which are each other's inverse. This is intended
to be stored as an attribute <code>"Transform"</code> with the resulting object
and used in plotting and reporting. All results will be on the transformed
scale. If the <code>tr</code> argument to <code>choose.trans</code> is a character
constant, the appropriate named list of two functions will be generated.
Possibilities are: &quot;exp&quot;, &quot;log&quot;, &quot;logit&quot;, &quot;pctlogit&quot; (transforms percentages
by the logit), &quot;sqrt&quot;, &quot;sq&quot; (square), &quot;cll&quot; (complementary log-minus-log),
&quot;ll&quot; (log-minus-log).  If there is no match <code>NULL</code> is returned, which
will correspond to no transformation.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="https://bendixcarstensen.com/">https://bendixcarstensen.com/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
choose.trans( "logit" )

</code></pre>

<hr>
<h2 id='corr.measures'>Classical association measures</h2><span id='topic+corr.measures'></span>

<h3>Description</h3>

<p>A function that returns the values of some of the classical
association measures proposed in the literature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr.measures(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corr.measures_+3A_x">x</code></td>
<td>
<p>A vector of numeric values of length N</p>
</td></tr>
<tr><td><code id="corr.measures_+3A_y">y</code></td>
<td>
<p>A vector of numeric values of length N</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of four association measures
</p>

<hr>
<h2 id='DA.reg'>Make a regression of differences on averages</h2><span id='topic+DA.reg'></span>

<h3>Description</h3>

<p>For each pair of methods in <code>data</code>, a regression of the differences on
the averages between methods is made and a linear relationship between
methods with prediction standard deviations is derived.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DA.reg(
  data,
  Transform = NULL,
  trans.tol = 1e-06,
  print = TRUE,
  random.raters = FALSE,
  DA.slope = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DA.reg_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+Meth">Meth</a></code> object. May also be a data frame with
columns <code>meth</code>, <code>item</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="DA.reg_+3A_transform">Transform</code></td>
<td>
<p>A character string, or a list of two functions, each
other's inverse. The measurements are transformed by this before analysis.
Possibilities are: &quot;exp&quot;, &quot;log&quot;, &quot;logit&quot;, &quot;pctlogit&quot; (transforms percentages
by the logit), &quot;sqrt&quot;, &quot;sq&quot; (square), &quot;cll&quot; (complementary log-minus-log),
&quot;ll&quot; (log-minus-log). For further details see <code><a href="#topic+choose.trans">choose.trans</a></code>.</p>
</td></tr>
<tr><td><code id="DA.reg_+3A_trans.tol">trans.tol</code></td>
<td>
<p>The tolerance used to check whether the supplied
transformation and its inverse combine to the identity.  Only used if
<code>Transform</code> is a list of two functions.</p>
</td></tr>
<tr><td><code id="DA.reg_+3A_print">print</code></td>
<td>
<p>Should the results be printed?</p>
</td></tr>
<tr><td><code id="DA.reg_+3A_random.raters">random.raters</code></td>
<td>
<p>If methods really are a random selection of raters,
neither intercept nor slope different from 0 are sensible, so if this is
<code>TRUE</code>, intercept and slope in the regression of difference on averages
are fixed to 0. Meaning that we are essentially looking at the raw
differences as residuals.</p>
</td></tr>
<tr><td><code id="DA.reg_+3A_da.slope">DA.slope</code></td>
<td>
<p>If this is TRUE, a slope of the differences in the verages
is estimated, otherwise the relationship is assumed constant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input object contains replicate measurements these are taken as
separate items in the order they appear in the dataset.
</p>


<h3>Value</h3>

<p><code>DA.reg</code> returns a <code><a href="#topic+MethComp">MethComp</a></code> object, i.e. a list
with three components, <code>Conv</code>, <code>VarComp</code>, and <code>data</code>.
<code>Conv</code> is a three-dimensional array, with dimensions <code>To</code>,
<code>From</code> (both with levels equal to the methods in <code>data</code>) and an
unnamed dimension with levels <code>"alpha"</code>, <code>"beta"</code>,
<code>"sd.pred"</code>, <code>"beta=1"</code>, referring to the linear relationship of
<code>To</code> to <code>From</code>, <code>"int(t-f)"</code>, <code>"slope(t-f)"</code>,
<code>"sd(t-f)"</code>, referring to the regression of the differences on the
averages, and <code>"int(sd)"</code>, <code>"slope(sd)"</code>, and <code>"s.d.=K"</code>,
referring to the regression of the absoulte residuals on the averages, and
<code>LoA-lo</code>, <code>LoA-hi</code>, the limits of agreement.
</p>
<p>Converting from method <code class="reqn">l</code> to method <code class="reqn">k</code> using
</p>
<p style="text-align: center;"><code class="reqn">y_{k|l}=\alpha+\beta y_l</code>
</p>
<p> with prediction standard deviation
<code class="reqn">\sigma</code>, just requires the entries
<code>[k,l,c("alpha","beta","sd.pred")]</code>, if we assume the s.d. is constant.
</p>
<p>The next entry is the p-values for the hypothesis <code class="reqn">\beta=1</code>, intercept
and slope of the SD of the differences as a linear function of the average
and finally p-value of the hypothesis that standard errors are constant over
the range. The latter three are derived by regressing the absolute values of
the residuals on the averages, and can be used to produce LoA where the s.d.
increases (or decreases) by the mean, using the function <code>DA2y</code>.
</p>
<p>The <code>VarComp</code> element of the list is <code>NULL</code>, and only present for
compatibility with the print method for <code>MethComp</code> objects.
</p>
<p>The <code>data</code> element is the input dataframe. The measurements in <code>y</code>
are left un-transformed, even if data are transformed (i.e. if the
<code>Transform</code> attribute of the object is non-null).
</p>
<p><code>DA2y</code> returns a 2 by 3 matrix with rownames <code>c("y1|2","y2|1")</code>
and columnnames <code>c("int","slope","sd")</code>, calculated under the
assumption that the differences were formed as <code>D &lt;- y1 - y2</code>.
</p>
<p><code>y2DA</code> returns a 3-component vector with names
<code>c("DA-int","DA-slope","DA-sd")</code>, referring to differences
<code>D=y1-y2</code> as a linear function of <code>A=(y1+y2)/2</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>,
<a href="https://BendixCarstensen.com/MethComp/">https://BendixCarstensen.com/MethComp/</a>
</p>


<h3>References</h3>

<p>B. Carstensen: Comparing methods of measurement: Extending the
LoA by regression.  Stat Med, 29:401-410, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( milk )
DA.reg( milk )
data( sbp )
print( DA.reg(sbp), digits=3 )
# Slope, intercept : y1 = 0.7 + 1.2*y2 (0.4)
A &lt;- c(0.7,1.2,0.4)
( y2DA( A ) )
( DA2y( y2DA( A ) ) )

</code></pre>

<hr>
<h2 id='DA2y'>Convert DA to (classical) regression</h2><span id='topic+DA2y'></span>

<h3>Description</h3>

<p>The functions <code>DA2y</code> and <code>y2DA</code> are convenience functions that
convert the estimates of intercept, slope and sd from the regression of
<code class="reqn">D=y_1-y_2</code> on <code class="reqn">A=(y_1+y_2)/2</code>, back and forth
to the resulting intercept, slope and sd in the relationship between
<code class="reqn">y_1</code> and <code class="reqn">y_2</code>, cf. Carstensen (2010), equation 6.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DA2y(a = 0, b = 0, s = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DA2y_+3A_a">a</code></td>
<td>
<p>Intercept in the linear relation of the differences <code>y1-y2</code> to
the averages <code>(y1+y2)/2</code>. If a vector of length&gt;1, this is used instead
of <code>a</code>, <code>b</code> and <code>s</code>, and <code>b</code> and <code>s</code> are ignored.</p>
</td></tr>
<tr><td><code id="DA2y_+3A_b">b</code></td>
<td>
<p>Slope in the linear relstion of the differences to the averages.</p>
</td></tr>
<tr><td><code id="DA2y_+3A_s">s</code></td>
<td>
<p>SD from the regression of the differences in the averages. Can be
<code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DA2y</code> takes the intercept(<code>a</code>), slope(<code>b</code>) and sd(<code>s</code>) from
the relationship <code>(y1-y2)=a+b((y1+y2)/2)+e</code> with sd(<code>e</code>)=<code>s</code>,
and returns a two by 3 matrix with columns <code>"int","slope","sd"</code> and
rows <code>"y1|2","y2|1"</code>.
</p>


<h3>Value</h3>

<p><code>DA2y</code> returns a 2 by 3 matrix with rownames <code>c("y1|2","y2|1")</code>
and columnnames <code>c("int","slope","sd")</code>, calculated under the
assumption that the differences were formed as <code>D &lt;- y1 - y2</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>,
<a href="https://BendixCarstensen.com/MethComp/">https://BendixCarstensen.com/MethComp/</a>
</p>


<h3>References</h3>

<p>B. Carstensen: Comparing methods of measurement: Extending the
LoA by regression.  Stat Med, 29:401-410, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( milk )
DA.reg( milk )
data( sbp )
print( DA.reg(sbp), digits=3 )
# Slope, intercept : y1 = 0.7 + 1.2*y2 (0.4)
A &lt;- c(0.7,1.2,0.4)
( y2DA( A ) )
( DA2y( y2DA( A ) ) )

</code></pre>

<hr>
<h2 id='Deming'>Regression with errors in both variables (Deming regression)</h2><span id='topic+Deming'></span>

<h3>Description</h3>

<p>The formal model underlying the procedure is based on a so called functional
relationship:
</p>
<p style="text-align: center;"><code class="reqn">x_i=\xi_i + e_{1i}, \qquad y_i=\alpha + \beta \xi_i + e_{2i}</code>
</p>

<p>with <code class="reqn">\mathrm{var}(e_{1i})=\sigma</code>,
<code class="reqn">\mathrm{var}(e_{2i})=\lambda\sigma</code>,
where <code class="reqn">\lambda</code> is the known variance ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Deming(
  x,
  y,
  vr = sdr^2,
  sdr = sqrt(vr),
  boot = FALSE,
  keep.boot = FALSE,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Deming_+3A_x">x</code></td>
<td>
<p>a numeric variable</p>
</td></tr>
<tr><td><code id="Deming_+3A_y">y</code></td>
<td>
<p>a numeric variable</p>
</td></tr>
<tr><td><code id="Deming_+3A_vr">vr</code></td>
<td>
<p>The assumed known ratio of the (residual) variance of the <code>y</code>s relative to that of the <code>x</code>s. Defaults to 1.</p>
</td></tr>
<tr><td><code id="Deming_+3A_sdr">sdr</code></td>
<td>
<p>do. for standard deviations. Defaults to 1. <code>vr</code> takes precedence if both are given.</p>
</td></tr>
<tr><td><code id="Deming_+3A_boot">boot</code></td>
<td>
<p>Should bootstrap estimates of standard errors of parameters be done? If <code>boot==TRUE</code>, 1000 bootstrap samples are done, if <code>boot</code> is numeric, <code>boot</code> samples are made.</p>
</td></tr>
<tr><td><code id="Deming_+3A_keep.boot">keep.boot</code></td>
<td>
<p>Should the 4-column matrix of bootstrap samples be returned? If <code>TRUE</code>, the summary is printed, but the matrix is returned invisibly. Ignored if <code>boot=FALSE</code></p>
</td></tr>
<tr><td><code id="Deming_+3A_alpha">alpha</code></td>
<td>
<p>What significance level should be used when displaying confidence intervals?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimates of the residual variance is based on a weighting of
the sum of squared deviations in both directions, divided by <code class="reqn">n-2</code>.
The ML estimate would use <code class="reqn">2n</code> instead, but in the model we actually
estimate <code class="reqn">n+2</code> parameters &mdash; <code class="reqn">\alpha, \beta</code> and
the <code class="reqn">n</code> <code class="reqn">\xi s</code>.
This is not in Peter Sprent's book (see references).
</p>


<h3>Value</h3>

<p>If <code>boot==FALSE</code> a named vector with components
<code>Intercept</code>, <code>Slope</code>, <code>sigma.x</code>, <code>sigma.y</code>, where <code>x</code>
and <code>y</code> are substituted by the variable names.
</p>
<p>If <code>boot==TRUE</code> a matrix with rows <code>Intercept</code>,
<code>Slope</code>, <code>sigma.x</code>, <code>sigma.y</code>, and colums giving the estimates,
the bootstrap standard error and the bootstrap estimate and c.i. as the 0.5,
<code class="reqn">\alpha/2</code> and <code class="reqn">1-\alpha/2</code> quantiles of the sample.
</p>
<p>If <code>keep.boot==TRUE</code> this summary is printed, but a matrix with columns
<code>Intercept</code>,
<code>Slope</code>, <code>sigma.x</code>, <code>sigma.y</code> and <code>boot</code> rows is returned.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>, <a href="https://BendixCarstensen.com">https://BendixCarstensen.com</a>
</p>


<h3>References</h3>

<p>Peter Sprent: Models in Regression, Methuen &amp; Co., London 1969, ch.3.4.
</p>
<p>WE Deming: Statistical adjustment of data, New York: Wiley, 1943.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# 'True' values 
M &lt;- runif(100,0,5)
# Measurements:
x &lt;- M + rnorm(100)
y &lt;- 2 + 3 * M + rnorm(100,sd=2)
# Deming regression with equal variances, variance ratio 2.
Deming(x,y)
Deming(x,y,vr=2)
Deming(x,y,boot=TRUE)
bb &lt;- Deming(x,y,boot=TRUE,keep.boot=TRUE)
str(bb)
# Plot data with the two classical regression lines
plot(x,y)
abline(lm(y~x))
ir &lt;- coef(lm(x~y))
abline(-ir[1]/ir[2],1/ir[2])
abline(Deming(x,y,sdr=2)[1:2],col="red")
abline(Deming(x,y,sdr=10)[1:2],col="blue")
# Comparing classical regression and "Deming extreme"
summary(lm(y~x))
Deming(x,y,vr=1000000)

</code></pre>

<hr>
<h2 id='ends'>Function to identify the extremes of a vector</h2><span id='topic+ends'></span>

<h3>Description</h3>

<p>Function to identify the extremes of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ends(w, rm = 1/3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ends_+3A_w">w</code></td>
<td>
<p>A numeric vector of values</p>
</td></tr>
<tr><td><code id="ends_+3A_rm">rm</code></td>
<td>
<p>A value between 0 and 1 giving the percentage of extreme observations to remove</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of indices that a
</p>

<hr>
<h2 id='Enzyme'>Enzyme activity data</h2><span id='topic+Enzyme'></span>

<h3>Description</h3>

<p>Three measurement of enzyme activity on 24 patients. The measurements is of
the enzymes sucrase and alkaline phosphatase. The interest is to compare the
'homogenate' and 'pellet' methods.
</p>


<h3>Format</h3>

<p>A data frame with 72 observations on the following 3 variables.
</p>
 <dl>
<dt><code>meth</code></dt><dd><p>a factor with levels <code>SucHom</code>
<code>SucPel</code> <code>Alkphos</code>, representing three different measurements,
i.e.  homogenate and pellet values of sucrase, as well as homogenate values
of alkaline.</p>
</dd> <dt><code>item</code></dt><dd><p>a numeric vector, the person ID for the 24
patients</p>
</dd> <dt><code>y</code></dt><dd><p>a numeric vector, the measurements on the enzyme
activity.</p>
</dd> </dl>



<h3>Source</h3>

<p>R. L. Carter; Restricted Maximum Likelihood Estimation of Bias and
Reliability in the Comparison of Several Measuring Methods; Biometrics,
Dec., 1981, Vol. 37, No. 4, pp. 733-741.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Enzyme)
Enzyme &lt;- Meth( Enzyme )
summary( Enzyme )
# plot( Enzyme )

</code></pre>

<hr>
<h2 id='fat'>Measurements of subcutaneous and visceral fat</h2><span id='topic+fat'></span>

<h3>Description</h3>

<p>43 persons had Subcutaneous and Visceral fat thickness measured at Steno
Diabetes Center in 2006 by two observers; all measurements were done three
times. The interest is to compare the measurements by the two observers.
Persons are items, observers are methods, the three replicates are
exchangeable within (person,observer)=(item,method)
</p>


<h3>Format</h3>

<p>A data frame with 258 observations on the following 6 variables.
</p>
 <dl>
<dt><code>Id</code></dt><dd><p>Person id.</p>
</dd> <dt><code>Obs</code></dt><dd><p>Observers, a
factor with levels <code>KL</code> and <code>SL</code>.</p>
</dd> <dt><code>Rep</code></dt><dd><p>Replicate
&mdash; exchangeable within person and observer.</p>
</dd>
<dt><code>Sub</code></dt><dd><p>Subcutaneous fat measured in cm.</p>
</dd>
<dt><code>Vic</code></dt><dd><p>Visceral fat measured in cm.</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(fat)
str(fat)
vic &lt;- Meth( fat, meth=2, item=1, repl="Rep", y="Vic" )
str(vic)
BA.est( vic, linked=FALSE )

</code></pre>

<hr>
<h2 id='glucose'>Glucose measurements by different methods</h2><span id='topic+glucose'></span>

<h3>Description</h3>

<p>74 persons in 5 centres in Finland had blood glucose measured by 11
different methods, based on 4 different types of blood. Each person had
blood sampled at 0, 30, 60 and 120 min after a 75 g glucose load.
</p>


<h3>Format</h3>

<p>A data frame with 1302 observations on the following 6 variables.
</p>
 <dl>
<dt><code>meth</code></dt><dd><p>Method of measurement. A factor with 11
levels: <code>n.plas1</code> <code>n.plas2</code> <code>h.cap</code> <code>h.blood</code>
<code>h.plas</code> <code>h.serum</code> <code>m.plas</code> <code>m.serum</code> <code>o.cap</code>
<code>s.serum</code> <code>k.plas</code>.</p>
</dd> <dt><code>type</code></dt><dd><p>Type of blood sample. A
factor with 4 levels: <code>blood</code> <code>plasma</code> <code>serum</code> <code>capil</code></p>
</dd>
<dt><code>item</code></dt><dd><p>Person id.</p>
</dd> <dt><code>time</code></dt><dd><p>Time of blood sampling.
Minutes since glucose load.</p>
</dd> <dt><code>cent</code></dt><dd><p>Center of sampling. Except
for the two first methods, <code>n.plas1</code> and <code>n.plas2</code>, samples were
analyzed at the centres too</p>
</dd> <dt><code>y</code></dt><dd><p>Glucose measurement in
mmol/l.</p>
</dd> </dl>



<h3>Source</h3>

<p>The study was conducted at the National Public Health Institute in
Helsinki by Jaana Lindstrom.
</p>


<h3>References</h3>

<p>B Carstensen, J Lindstrom, J Sundvall, K Borch-Johnsen1, J
Tuomilehto &amp; the DPS Study Group: Measurement of Blood Glucose: Comparison
between different Types of Specimens. Annals of Clinical Biochemistry, to
appear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data( glucose )
  str( glucose )
  # Use only plasma and serum as methods and make a Bland-Altman plot
  gluc &lt;- subset( glucose, type %in% c("plasma","serum") )
  gluc$meth &lt;- gluc$type
  gluc$repl &lt;- gluc$time
  BA.plot( gluc )
  
</code></pre>

<hr>
<h2 id='hba.MC'>A MCmcmc object from the hba1c data</h2><span id='topic+hba.MC'></span>

<h3>Description</h3>

<p>This object is included for illustrative purposes. It is a result of a
5-hour run using MCmcmc, with <code>n.iter=100000</code>.
</p>


<h3>Format</h3>

<p>The format is a <code><a href="#topic+MCmcmc">MCmcmc</a></code> object.
</p>


<h3>Details</h3>

<p>The data are the venous measurements from the <code><a href="#topic+hba1c">hba1c</a></code> dataset,
using the day of analysis as replicate. Measurements are taken to be linked
within replicate (=day of analysis).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(hba.MC)
attr(hba.MC,"mcmc.par")
# print.MCmcmc(hba.MC)
# One of the chains is really fishy (it's the first one)
# trace.MCmcmc(hba.MC)
# trace.MCmcmc(hba.MC,"beta")
# Try to have a look, excluding the first chain
# hba.MCsub &lt;- subset.MCmcmc(hba.MC,chains=-1)
# trace.MCmcmc(hba.MCsub)
# trace.MCmcmc(hba.MCsub,"beta")
# A MCmcmc object also has class mcmc.list, so we can use the
# coda functions for covergence diagnostics:
# acfplot( subset.MCmcmc(hba.MC, subset="sigma"))

</code></pre>

<hr>
<h2 id='hba1c'>Measurements of HbA1c from Steno Diabetes Center</h2><span id='topic+hba1c'></span>

<h3>Description</h3>

<p>Three analysers (machines) for determination of HbA1c (glycosylated
haemoglobin) were tested on samples from 38 individuals. Each had drawn a
venous and capillary blood sample. These were analysed on five different
days.
</p>


<h3>Format</h3>

<p>A data frame with 835 observations on the following 6 variables.
</p>
 <dl>
<dt><code>dev</code></dt><dd><p>Type of machine used.  A factor with levels
<code>BR.V2</code>, <code>BR.VC</code> and <code>Tosoh</code>.</p>
</dd> <dt><code>type</code></dt><dd><p>Type of
blood analysed (capillary or venous).  A factor with levels <code>Cap</code>
<code>Ven</code></p>
</dd> <dt><code>item</code></dt><dd><p>Person-id. A numeric vector</p>
</dd>
<dt><code>d.samp</code></dt><dd><p>Day of sampling.</p>
</dd> <dt><code>d.ana</code></dt><dd><p>Day of
laboratory analysis.</p>
</dd> <dt><code>y</code></dt><dd><p>The measured value of HbA1c.</p>
</dd> </dl>



<h3>Details</h3>

<p>In the terminology of method comparison studies, methods is the
cross-classification of <code>dev</code> and <code>type</code>, and replicate is
<code>d.ana</code>. It may be of interest to look at the effect of time between
<code>d.ana</code> and <code>d.samp</code>, i.e. the time between sampling and analysis.
</p>


<h3>Source</h3>

<p>Bendix Carstensen, Steno Diabetes Center.
</p>


<h3>References</h3>

<p>These data were analysed as example in: Carstensen: Comparing
and predicting between several methods of measurement, Biostatistics 5, pp.
399&ndash;413, 2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(hba1c)
str(hba1c)
hb1  &lt;- with( hba1c,
              Meth( meth = interaction(dev,type),
                    item = item,
                    repl = d.ana-d.samp,
                       y = y, print=TRUE ) )

</code></pre>

<hr>
<h2 id='MCmcmc'>Fit a model for method comparison studies using WinBUGS</h2><span id='topic+MCmcmc'></span>

<h3>Description</h3>

<p>A model linking each of a number of methods of measurement linearly to the
&quot;true&quot; value is set up in BUGS and run via the function
<code><a href="R2WinBUGS.html#topic+bugs">bugs</a></code> from the <code>R2WinBUGS</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCmcmc(
  data,
  bias = "linear",
  IxR = has.repl(data),
  linked = IxR,
  MxI = TRUE,
  matrix = MxI,
  varMxI = nlevels(factor(data$meth)) &gt; 2,
  n.chains = 4,
  n.iter = 2000,
  n.burnin = n.iter/2,
  n.thin = ceiling((n.iter - n.burnin)/1000),
  bugs.directory = getOption("bugs.directory"),
  debug = FALSE,
  bugs.code.file = "model.txt",
  clearWD = TRUE,
  code.only = FALSE,
  ini.mult = 2,
  list.ini = TRUE,
  org = FALSE,
  program = "JAGS",
  Transform = NULL,
  trans.tol = 1e-06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCmcmc_+3A_data">data</code></td>
<td>
<p>Data frame with variables <code>meth</code>, <code>item</code>, <code>repl</code>
and <code>y</code>, possibly a <code><a href="#topic+Meth">Meth</a></code> object.  <code>y</code> represents a
measurement on an <code>item</code> (typically patient or sample) by method
<code>meth</code>, in replicate <code>repl</code>.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_bias">bias</code></td>
<td>
<p>Character. Indicating how the bias between methods should be
modelled. Possible values are <code>"none"</code>, <code>"constant"</code>,
<code>"linear"</code> and <code>"proportional"</code>. Only the first three letters are
significant. Case insensitive.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_ixr">IxR</code></td>
<td>
<p>Logical. Are the replicates linked across methods, i.e. should a
random <code>item</code> by <code>repl</code> be included in the model.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_linked">linked</code></td>
<td>
<p>Logical, alias for <code>IxR</code>.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_mxi">MxI</code></td>
<td>
<p>Logical, should a <code>meth</code> by <code>item</code> effect be included
in the model?</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_matrix">matrix</code></td>
<td>
<p>Logical, alias for <code>MxI</code>.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_varmxi">varMxI</code></td>
<td>
<p>Logical, should the method by item effect have method-specific
variances. Ignored if only two methods are compared.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_n.chains">n.chains</code></td>
<td>
<p>How many chains should be run by WinBUGS &mdash; passed on to
<code>bugs</code>.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_n.iter">n.iter</code></td>
<td>
<p>How many total iterations &mdash; passed on to <code>bugs</code>.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_n.burnin">n.burnin</code></td>
<td>
<p>How many of these should be burn-in &mdash; passed on to
<code>bugs</code>.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_n.thin">n.thin</code></td>
<td>
<p>How many should be sampled &mdash; passed on to <code>bugs</code>.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_bugs.directory">bugs.directory</code></td>
<td>
<p>Where is WinBUGS (&gt;=1.4) installed &mdash; passed on to
<code>bugs</code>. The default is to use a parameter from options(). If you use
this routinely, this is most conveniently set in your <code>.Rprofile</code> file.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_debug">debug</code></td>
<td>
<p>Should WinBUGS remain open after running &mdash; passed on to
<code>bugs</code>.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_bugs.code.file">bugs.code.file</code></td>
<td>
<p>Where should the bugs code go?</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_clearwd">clearWD</code></td>
<td>
<p>Should the working directory be cleared for junk files after
the running of WinBUGS &mdash; passed on to <code>bugs</code>.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_code.only">code.only</code></td>
<td>
<p>Should <code>MCmcmc</code> just create a bugs code file and a set
of inits? See the <code>list.ini</code> argument.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_ini.mult">ini.mult</code></td>
<td>
<p>Numeric. What factor should be used to randomly perturb the
initial values for the variance components, see below in details.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_list.ini">list.ini</code></td>
<td>
<p>List of lists of starting values for the chains, or logical
indicating whether starting values should be generated.  If <code>TRUE</code> (the
default), the function VC.est will be used to generate initial
values for the chains. <code>list.ini</code> is a list of length <code>n.chains</code>.
Each element of which is a list with the following vectors as elements:
</p>
 <dl>
<dt><code>mu</code></dt><dd><p>- length I</p>
</dd> <dt><code>alpha</code></dt><dd><p>- length M</p>
</dd>
<dt><code>beta</code></dt><dd><p>- length M</p>
</dd> <dt><code>sigma.mi</code></dt><dd><p>- length M - if M is
2 then length 1</p>
</dd> <dt><code>sigma.ir</code></dt><dd><p>- length 1</p>
</dd>
<dt><code>sigma.mi</code></dt><dd><p>- length M</p>
</dd> <dt><code>sigma.res</code></dt><dd><p>- length M</p>
</dd></dl>
<p> If
<code>code.only==TRUE</code>, <code>list.ini</code> indicates whether a list of initial
values is returned (invisibly) or not.  If <code>code.only==FALSE</code>,
<code>list.ini==FALSE</code> is ignored.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_org">org</code></td>
<td>
<p>Logical. Should the posterior of the original model parameters be
returned too? If <code>TRUE</code>, the <code>MCmcmc</code> object will have an
attribute, <code>original</code>, with the posterior of the parameters in the
model actually simulated.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_program">program</code></td>
<td>
<p>Which program should be used for the MCMC simulation.
Possible values are &quot;<code>BRugs</code>&quot;, &quot;<code>ob</code>&quot;, &quot;<code>winbugs</code>&quot;, &quot;<code>wb</code>&quot; (WinBUGS), &quot;<code>jags</code>&quot;
(JAGS). Case insensitive. Defaults to &quot;<code>JAGS</code>&quot; since: 1) JAGS is
available on all platforms and 2) JAGS seems to be faster than BRugs on
(some) windows machines.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_transform">Transform</code></td>
<td>
<p>Transformation of data (<code>y</code>) before analysis.  See
<code><a href="#topic+choose.trans">choose.trans</a></code>.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_trans.tol">trans.tol</code></td>
<td>
<p>The tolerance used to check whether the supplied
transformation and its inverse combine to the identity.</p>
</td></tr>
<tr><td><code id="MCmcmc_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="R2WinBUGS.html#topic+bugs">bugs</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model set up for an observation <code class="reqn">y_{mir}</code> is: </p>
<p style="text-align: center;"><code class="reqn">y_{mir} =
\alpha_m + \beta_m(\mu_i+b_{ir} + c_{mi}) + </code>
</p>
<p style="text-align: center;"><code class="reqn"> e_{mir}</code>
</p>
<p> where <code class="reqn">b_{ir}</code> is a random
<code>item</code> by <code>repl</code> interaction (included if <code>"ir"</code> is in <code>random</code>)
and <code class="reqn">c_{mi}</code> is a random <code>meth</code> by <code>item</code> interaction
(included if <code>"mi"</code> is in <code>random</code>). The <code class="reqn">\mu_i</code>'s are
parameters in the model but are not monitored &mdash; only the
<code class="reqn">\alpha</code>s, <code class="reqn">\beta</code>s and the variances of
<code class="reqn">b_{ir}</code>, <code class="reqn">c_{mi}</code> and <code class="reqn">e_{mir}</code> are
monitored and returned. The estimated parameters are only determined up to a
linear transformation of the <code class="reqn">\mu</code>s, but the linear functions
linking methods are invariant. The identifiable conversion parameters are:
</p>
<p style="text-align: center;"><code class="reqn">\alpha_{m\cdot k}=\alpha_m - \alpha_k \beta_m/\beta_k, \quad
</code>
</p>
<p style="text-align: center;"><code class="reqn">
\beta_{m\cdot k}=\beta_m/\beta_k</code>
</p>
<p> The posteriors of these are derived and included in
the <code>posterior</code>, which also will contain the posterior of the variance
components (the SDs, that is).  Furthermore, the posterior of the point
where the conversion lines intersects the identity as well as the prediction
SDs between any pairs of methods are included.
</p>
<p>The function <code>summary.MCmcmc</code> method gives estimates of the conversion
parameters that are consistent. Clearly, </p>
<p style="text-align: center;"><code class="reqn">\mathrm{median}(\beta_{1\cdot
2})= </code>
</p>
<p style="text-align: center;"><code class="reqn">
1/\mathrm{median}(\beta_{2\cdot 1})</code>
</p>

<p>because the inverse is a monotone transformation, but there is no guarantee
that </p>
<p style="text-align: center;"><code class="reqn">\mathrm{median}(\alpha_{1\cdot 2})=
\mathrm{median}(-\alpha_{2\cdot 1}/
</code>
</p>
<p style="text-align: center;"><code class="reqn"> \beta_{2\cdot
1})</code>
</p>
<p> and hence no guarantee
that the parameters derived as posterior medians produce conversion lines
that are the same in both directions. Therefore, <code>summary.MCmcmc</code>
computes the estimate for <code class="reqn">\alpha_{2\cdot 1}</code> as
</p>
<p style="text-align: center;"><code class="reqn">(\mathrm{median}(\alpha_{1\cdot 2})-\mathrm{median}(\alpha_{2\cdot 1})
</code>
</p>
<p style="text-align: center;"><code class="reqn">
/\mathrm{median}(\beta_{2\cdot 1}))/2</code>
</p>
<p> and the estimate of <code class="reqn">\alpha_{1\cdot 2}</code>
correspondingly. The resulting parameter estimates defines the same lines.
</p>


<h3>Value</h3>

<p>If <code>code.only==FALSE</code>, an object of class <code>MCmcmc</code> which
is a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object of the relevant parameters, i.e.
the posteriors of the conversion parameters and the variance components
transformed to the scales of each of the methods.
</p>
<p>Furthermore, the object have the following attributes:
</p>
<table role = "presentation">
<tr><td><code>random</code></td>
<td>
<p>Character vector indicating which random effects (&quot;ir&quot;,&quot;mi&quot;)
were included in the model.</p>
</td></tr> <tr><td><code>methods</code></td>
<td>
<p>Character vector with the method
names.</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>The data frame used in the analysis. This is used in
<code><a href="#topic+plot.MCmcmc">plot.MCmcmc</a></code> when plotting points.</p>
</td></tr> <tr><td><code>mcmc.par</code></td>
<td>
<p>A list
giving the number of chains etc. used to generate the object.</p>
</td></tr>
<tr><td><code>original</code></td>
<td>
<p>If <code>org=TRUE</code>, an <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object
with the posterior of the original model parameters, i.e.  the variance
components and the unidentifiable mean parameters.</p>
</td></tr> <tr><td><code>Transform</code></td>
<td>
<p>The
transformation used to the measurements before the analysis.</p>
</td></tr></table>
<p> If
<code>code.only==TRUE</code>, a list containing the initial values is generated.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="https://BendixCarstensen.com">https://BendixCarstensen.com</a>, Lyle Gurrin, University of Melbourne,
<a href="https://mspgh.unimelb.edu.au/centres-institutes/centre-for-epidemiology-and-biostatistics">https://mspgh.unimelb.edu.au/centres-institutes/centre-for-epidemiology-and-biostatistics</a>.
</p>


<h3>References</h3>

<p>B Carstensen: Comparing and predicting between several methods
of measurement, Biostatistics, 5, pp 399-413, 2004
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BA.plot">BA.plot</a></code>, <code><a href="#topic+plot.MCmcmc">plot.MCmcmc</a></code>,
<code><a href="#topic+print.MCmcmc">print.MCmcmc</a></code>, <code><a href="#topic+check.MCmcmc">check.MCmcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( ox )
str( ox )
ox &lt;- Meth( ox )
# Writes the BUGS program to your console
MCmcmc( ox, MI=TRUE, IR=TRUE, code.only=TRUE, bugs.code.file="" )

### What is written here is not necessarily correct on your machine.
# ox.MC &lt;- MCmcmc( ox, MI=TRUE, IR=TRUE, n.iter=100, program="JAGS" )
# ox.MC &lt;- MCmcmc( ox, MI=TRUE, IR=TRUE, n.iter=100 )
#  data( ox.MC )
#   str( ox.MC )
# print( ox.MC )

</code></pre>

<hr>
<h2 id='Meth'>Create a Meth object representing a method comparison study</h2><span id='topic+Meth'></span>

<h3>Description</h3>

<p>Creates a dataframe with columns <code>meth</code>, <code>item</code>, (<code>repl</code>) and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Meth(
  data = NULL,
  meth = "meth",
  item = "item",
  repl = NULL,
  y = "y",
  print = !is.null(data),
  keep.vars = !is.null(data)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Meth_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="Meth_+3A_meth">meth</code></td>
<td>
<p>Vector of methods, numeric, character or factor. Can also be a number or character referring to a column in <code>data</code>.</p>
</td></tr>
<tr><td><code id="Meth_+3A_item">item</code></td>
<td>
<p>Vector of items, numeric, character or factor. Can also be a number or character referring to a column in <code>data</code>.</p>
</td></tr>
<tr><td><code id="Meth_+3A_repl">repl</code></td>
<td>
<p>Vector of replicates, numeric, character or factor. Can also be a number or character referring to a column in <code>data</code>.</p>
</td></tr>
<tr><td><code id="Meth_+3A_y">y</code></td>
<td>
<p>Vector of measurements. Can also be a character or numerical vector pointing to columns in <code>data</code> which contains the measurements by different methods or a dataframe with columns representing  measurements by different methods. In this case the argument <code>meth</code> is ignored, and the names of the columns are taken as method names.</p>
</td></tr>
<tr><td><code id="Meth_+3A_print">print</code></td>
<td>
<p>Logical: Should a summary result be printed?</p>
</td></tr>
<tr><td><code id="Meth_+3A_keep.vars">keep.vars</code></td>
<td>
<p>Logical. Should the remaining variables from the dataframe <code>data</code> be transferred to the <code>Meth</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to perform analyses of method comparisons it is convenient to have a
dataframe with classifying factors, <code>meth</code>, <code>item</code>, and possibly
<code>repl</code> and the response variable <code>y</code>. This function creates such a
dataframe, and gives it a class, <code>Meth</code>, for which there is a number of
methods: <code>summary</code> - tabulation, <code>plot</code> - plotting and a couple of
analysis methods.
</p>
<p>If there are replicates in the values of <code>item</code> it is assumed
that those observations represent replicate measurements and different
replicate numbers are given to those.
</p>


<h3>Value</h3>

<p>The <code>Meth</code> function returns a <code>Meth</code> object which is a   dataframe with columns <code>meth</code>, <code>item</code>, (<code>repl</code>) and <code>y</code>. <code>summary.Meth</code> returns a table classified by method and no. of replicate measurements, extended with columns of the total number of items, total number of observations and the range of the measurements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fat)
# Different ways of selecting columns and generating replicate numbers
Sub1 &lt;- Meth(fat,meth=2,item=1,repl=3,y=4,print=TRUE)
Sub2 &lt;- Meth(fat,2,1,3,4,print=TRUE)
Sub3 &lt;- Meth(fat,meth="Obs",item="Id",repl="Rep",y="Sub",print=TRUE)
summary( Sub3 )
plot( Sub3 )

# Use observation in different columns as methods
data( CardOutput )
head( CardOutput )
sv &lt;- Meth( CardOutput, y=c("Svo2","Scvo2") )
# Note that replicates are generated if a non-unique item-id is used
sv &lt;- Meth( CardOutput, y=c("Svo2","Scvo2"), item="Age" )
str( sv )
# A summary is not created if the the first argument (data=) is not used:
sv &lt;- Meth( y=CardOutput[,c("Svo2","Scvo2")], item=CardOutput$VO2 )
summary(sv)

# Sample items
ssv &lt;- sample.Meth( sv, how="item", N=8 )

# More than two methods
data( sbp )
plot( Meth( sbp ) )
# Creating non-unique replicate numbers per (meth,item) creates a warning:
data( hba1c )
hb1  &lt;- with( hba1c,
              Meth( meth=dev, item=item, repl=d.ana-d.samp, y=y, print=TRUE ) )
hb2  &lt;- with( subset(hba1c,type=="Cap"),
              Meth( meth=dev, item=item, repl=d.ana-d.samp, y=y, print=TRUE ) )

</code></pre>

<hr>
<h2 id='Meth.sim'>Simulate a dataframe containing replicate measurements on the same items
using different methods.</h2><span id='topic+Meth.sim'></span>

<h3>Description</h3>

<p>Simulates a dataframe representing data from a method comparison study. It
is returned as a <code><a href="#topic+Meth">Meth</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Meth.sim(
  Ni = 100,
  Nm = 2,
  Nr = 3,
  nr = Nr,
  alpha = rep(0, Nm),
  beta = rep(1, Nm),
  mu.range = c(0, 100),
  sigma.mi = rep(5, Nm),
  sigma.ir = 2.5,
  sigma.mir = rep(5, Nm),
  m.thin = 1,
  i.thin = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Meth.sim_+3A_ni">Ni</code></td>
<td>
<p>The number of items (patient, animal, sample, unit etc.)</p>
</td></tr>
<tr><td><code id="Meth.sim_+3A_nm">Nm</code></td>
<td>
<p>The number of methods of measurement.</p>
</td></tr>
<tr><td><code id="Meth.sim_+3A_nr">Nr</code></td>
<td>
<p>The (maximal) number of replicate measurements for each
(item,method) pair.</p>
</td></tr>
<tr><td><code id="Meth.sim_+3A_nr">nr</code></td>
<td>
<p>The minimal number of replicate measurements for each
(item,method) pair. If <code>nr&lt;Nr</code>, the number of replicates for each
(meth,item) pair is uniformly distributed on the points <code>nr:Nr</code>,
otherwise <code>nr</code> is ignored. Different number of replicates is only
meaningful if replicates are not linked, hence <code>nr</code> is also ignored
when <code>sigma.ir&gt;0</code>.</p>
</td></tr>
<tr><td><code id="Meth.sim_+3A_alpha">alpha</code></td>
<td>
<p>A vector of method-specific intercepts for the linear equation
relating the &quot;true&quot; underlying item mean measurement to the mean measurement
on each method.</p>
</td></tr>
<tr><td><code id="Meth.sim_+3A_beta">beta</code></td>
<td>
<p>A vector of method-specific slopes for the linear equation
relating the &quot;true&quot; underlying item mean measurement to the mean measurement
on each method.</p>
</td></tr>
<tr><td><code id="Meth.sim_+3A_mu.range">mu.range</code></td>
<td>
<p>The range across items of the &quot;true&quot; mean measurement.  Item
means are uniformly spaced across the range.  If a vector length <code>Ni</code>
is given, the values of that vector will be used as &quot;true&quot; means.</p>
</td></tr>
<tr><td><code id="Meth.sim_+3A_sigma.mi">sigma.mi</code></td>
<td>
<p>A vector of method-specific standard deviations for a method
by item random effect.  Some or all components can be zero.</p>
</td></tr>
<tr><td><code id="Meth.sim_+3A_sigma.ir">sigma.ir</code></td>
<td>
<p>Method-specific standard deviations for the item by
replicate random effect.</p>
</td></tr>
<tr><td><code id="Meth.sim_+3A_sigma.mir">sigma.mir</code></td>
<td>
<p>A vector of method-specific residual standard deviations
for a method by item by replicate random effect (residual variation).  All
components must be greater than zero.</p>
</td></tr>
<tr><td><code id="Meth.sim_+3A_m.thin">m.thin</code></td>
<td>
<p>Fraction of the observations from each method to keep.</p>
</td></tr>
<tr><td><code id="Meth.sim_+3A_i.thin">i.thin</code></td>
<td>
<p>Fraction of the observations from each item to keep. If both
<code>m.thin</code> and <code>i.thin</code> are given the thinning is by their
componentwise product.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are simulated according to the following model for an observation
<code class="reqn">y_{mir}</code>: </p>
<p style="text-align: center;"><code class="reqn">y_{mir} = \alpha_m + \beta_m(\mu_i+b_{ir} +
c_{mi}) + e_{mir}</code>
</p>
<p> where
<code class="reqn">b_{ir}</code> is a random <code>item</code> by <code>repl</code> interaction (with
standard deviation for method <code class="reqn">m</code> the corresponding component of the
vector <code class="reqn">\sigma_ir</code>), <code class="reqn">c_{mi}</code> is a random
<code>meth</code> by <code>item</code> interaction (with standard deviation for method
<code class="reqn">m</code> the corresponding component of the vector <code class="reqn">\sigma_mi</code>)
and <code class="reqn">e_{mir}</code> is a residual error term (with standard deviation
for method <code class="reqn">m</code> the corresponding component of the vector
<code class="reqn">\sigma_mir</code>).  The <code class="reqn">\mu_i</code>'s are uniformly spaced
in a range specified by <code>mu.range</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+Meth">Meth</a></code> object, i.e. dataframe with columns
<code>meth</code>, <code>item</code>, <code>repl</code> and <code>y</code>, representing results
from a method comparison study.
</p>


<h3>Author(s)</h3>

<p>Lyle Gurrin, University of Melbourne,
<a href="https://mspgh.unimelb.edu.au/centres-institutes/centre-for-epidemiology-and-biostatistics">https://mspgh.unimelb.edu.au/centres-institutes/centre-for-epidemiology-and-biostatistics</a>
</p>
<p>Bendix Carstensen, Steno Diabetes Center, <a href="https://BendixCarstensen.com">https://BendixCarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.Meth">summary.Meth</a></code>, <code><a href="#topic+plot.Meth">plot.Meth</a></code>,
<code><a href="#topic+MCmcmc">MCmcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  Meth.sim( Ni=4, Nr=3 )
  xx &lt;- Meth.sim( Nm=3, Nr=5, nr=2, alpha=1:3, beta=c(0.7,0.9,1.2), m.thin=0.7 )
  summary( xx )
  plot( xx )
  
</code></pre>

<hr>
<h2 id='MethComp'>Summarize conversion equations and prediction intervals between methods.</h2><span id='topic+MethComp'></span>

<h3>Description</h3>

<p>Takes the results from <code><a href="#topic+BA.est">BA.est</a></code>, <code><a href="#topic+DA.reg">DA.reg</a></code>,
<code><a href="#topic+AltReg">AltReg</a></code> or <code><a href="#topic+MCmcmc">MCmcmc</a></code> and returns a <code>MethComp</code>
object, suitable for displaying the relationship between methods in print pr
graphic form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MethComp(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MethComp_+3A_obj">obj</code></td>
<td>
<p>A <code>MethComp</code> or <code><a href="#topic+MCmcmc">MCmcmc</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>MethComp</code> on the results from <code><a href="#topic+BA.est">BA.est</a></code> or
<code><a href="#topic+AltReg">AltReg</a></code> is not necessary, as these two functions already return
objetcs of class <code>MethComp</code>.
</p>


<h3>Value</h3>

<p><code>MethComp</code> returns a <code>MethComp</code> object, which is a list
with three elements, <code>Conv</code>, a three-way array giving the linear
conversion equations between methods, <code>VarComp</code>, a two-way array
classified by methods and variance components and <code>data</code>, a copy of the
original <code><a href="#topic+Meth">Meth</a></code> object supplied &mdash; see the description under
<code><a href="#topic+BA.est">BA.est</a></code>.
</p>
<p>A <code>MethComp</code> object has an attribute <code>Transform</code>, which is either
NULL, or a named list with elements <code>trans</code> and <code>inv</code>, both of
which are functions. The first is the transformation applied to measurements
before analysis; the results are all given on the transformed scale. The
second is the inverse transformation; this is only used when plotting the
resulting relationship between methods.
</p>
<p>The methods <code>print</code>, <code>plot</code>, <code>lines</code> and <code>points</code> return
nothing.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BA.est">BA.est</a></code> <code><a href="#topic+AltReg">AltReg</a></code> <code><a href="#topic+MCmcmc">MCmcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( ox )
BA.ox &lt;- BA.est( ox, linked=TRUE )
print( BA.ox )
## Not run: 
AR.ox &lt;- AltReg( ox, linked=TRUE  )
print( AR.ox )
plot( AR.ox ) 
## End(Not run)

</code></pre>

<hr>
<h2 id='middle'>Function to identify the middle of a vector</h2><span id='topic+middle'></span>

<h3>Description</h3>

<p>Function to identify the middle of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>middle(w, rm = 1/3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="middle_+3A_w">w</code></td>
<td>
<p>A numeric vector of values</p>
</td></tr>
<tr><td><code id="middle_+3A_rm">rm</code></td>
<td>
<p>A value between 0 and 1 giving the percentage of extreme observations to remove</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of indices that a
</p>

<hr>
<h2 id='milk'>Measurement of fat content of human milk by two different methods.</h2><span id='topic+milk'></span>

<h3>Description</h3>

<p>Fat content of human milk determined by measurement of glycerol released by
enzymic hydrolysis of triglycerides (Trig) and measurement by the Standard
Gerber method (Gerber). Units are (g/100 ml).
</p>


<h3>Format</h3>

<p>A data frame with 90 observations on the following 3 variables.
</p>
 <dl>
<dt><code>meth</code></dt><dd><p>a factor with levels <code>Gerber</code>
<code>Trig</code></p>
</dd> <dt><code>item</code></dt><dd><p>sample id</p>
</dd> <dt><code>y</code></dt><dd><p>a numeric
vector</p>
</dd> </dl>



<h3>Source</h3>

<p>The dataset is adapted from table 3 in: JM Bland and DG Altman:
Measuring agreement in method comparison studies. Statistical Methods in
Medical Research, 8:136-160, 1999. See: Lucas A, Hudson GJ, Simpson P, Cole
TJ, Baker BA. An automated enzymic micromethod for the measurement of fat in
human milk. Journal of Dairy Research 1987; 54: 487-92.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(milk)
str(milk)
milk &lt;- Meth(milk)
plot(milk)
abline(0,1)

</code></pre>

<hr>
<h2 id='ox'>Measurement of oxygen saturation in blood</h2><span id='topic+ox'></span>

<h3>Description</h3>

<p>61 children had their blood oxygen content measured at the Children's
Hospital in Melbourne, either with a chemical method analysing gases in the
blood (<code>CO</code>) or by a pulse oximeter measuring transcutaneously
(<code>pulse</code>). Replicates are linked between methods; i.e. replicate 1 for
each of the two methods are done at the same time. However, replicate
measurements were taken in quick succession so the pairs of measurements are
exchangeable within person.
</p>


<h3>Format</h3>

<p>A data frame with 354 observations on the following 4 variables.
</p>
 <dl>
<dt><code>meth</code></dt><dd><p>Measurement methods, factor with levels
<code>CO</code>, <code>pulse</code></p>
</dd> <dt><code>item</code></dt><dd><p>Id for the child</p>
</dd>
<dt><code>repl</code></dt><dd><p>Replicate of measurements. There were 3 measurements for
most children, 4 had only 2 replicates with each method, one only 1</p>
</dd>
<dt><code>y</code></dt><dd><p>Oxygen saturation in percent.</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(ox)
str(ox)
ox &lt;- Meth(ox)
with( ox, table(table(item)) )
summary( ox )
# The effect of basing LoA on means over replicates:
par( mfrow=c(1,2), mar=c(4,4,1,4) )
BA.plot(      ox , diflim=c(-20,20), axlim=c(20,100), repl.conn=TRUE )
# BA.plot( mean(ox), diflim=c(-20,20), axlim=c(20,100) )

</code></pre>

<hr>
<h2 id='ox.MC'>A MCmcmc object from the oximetry data.</h2><span id='topic+ox.MC'></span>

<h3>Description</h3>

<p>This object is included for illustrative purposes. It is a result of using
<code><a href="#topic+MCmcmc">MCmcmc</a></code>, with <code>n.iter=20000</code>.
</p>


<h3>Format</h3>

<p>The format is a <code><a href="#topic+MCmcmc">MCmcmc</a></code> object.
</p>


<h3>Details</h3>

<p>The data are the <code><a href="#topic+ox">ox</a></code> dataset, where measurements are linked
within replicate (=day of analysis).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(ox.MC)
attr(ox.MC,"mcmc.par")
## Not run: 
print.MCmcmc(ox.MC)
trace.MCmcmc(ox.MC)
trace.MCmcmc(ox.MC,"beta")
 post.MCmcmc(ox.MC)
 post.MCmcmc(ox.MC,"beta") 
## End(Not run)
# A MCmcmc object also has class mcmc.list, so we can use the
# coda functions for covergence diagnostics:
## Not run:  acfplot( subset.MCmcmc(ox.MC, subset="sigma")) 

</code></pre>

<hr>
<h2 id='pairs.MCmcmc'>Create a pairs plot for an MCmcmc object</h2><span id='topic+pairs.MCmcmc'></span>

<h3>Description</h3>

<p>Create a pairs plot for an MCmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCmcmc'
pairs(
  x,
  what = "sd",
  subset = NULL,
  col = NULL,
  pch = 16,
  cex = 0.2,
  scales = "free",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairs.MCmcmc_+3A_x">x</code></td>
<td>
<p>An <code>MCmcmc</code> object.</p>
</td></tr>
<tr><td><code id="pairs.MCmcmc_+3A_what">what</code></td>
<td>
<p>Character indicating what parameters to plot.  Possible values
are <code>"sd"</code> or <code>"var"</code> which gives plots for the variance
components (on the sd. scale), <code>"beta"</code> or <code>"slope"</code>, which gives
plots for slope parameters and <code>"alpha"</code> or <code>"int"</code>, which gives
plots for the intercept parameters.</p>
</td></tr>
<tr><td><code id="pairs.MCmcmc_+3A_subset">subset</code></td>
<td>
<p>Character or numerical indicating the columns of the posterior
that should be plotted by <code>pairs</code>.</p>
</td></tr>
<tr><td><code id="pairs.MCmcmc_+3A_col">col</code></td>
<td>
<p>Color of the lines points used for plotting of the posterior
densities.</p>
</td></tr>
<tr><td><code id="pairs.MCmcmc_+3A_pch">pch</code></td>
<td>
<p>Plot symbol for the points.</p>
</td></tr>
<tr><td><code id="pairs.MCmcmc_+3A_cex">cex</code></td>
<td>
<p>Plot character size for points in <code>pairs</code>.</p>
</td></tr>
<tr><td><code id="pairs.MCmcmc_+3A_scales">scales</code></td>
<td>
<p>Character vector of length two, with possible values &quot;same&quot; or
&quot;free&quot;, indicating whether x- and y-axes of the plots should be constrained
to be the same across panels. For <code>pairs</code> only the first element is
used to decide whether all panles should have the same axes.</p>
</td></tr>
<tr><td><code id="pairs.MCmcmc_+3A_...">...</code></td>
<td>
<p>Further aruments passed on to the <code><a href="lattice.html#topic+Lattice">Lattice</a></code>
function called: <code>trace</code> calls <code><a href="coda.html#topic+xyplot.mcmc">xyplot.mcmc</a></code> from the
<code>coda</code> package, <code>post</code> calls <code><a href="coda.html#topic+densityplot.mcmc">densityplot.mcmc</a></code> from the
<code>coda</code> package, 
calls <code><a href="graphics.html#topic+pairs">pairs</a></code> from the <code>graphics</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="lattice.html#topic+Lattice">Lattice</a></code> plot.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>,
<a href="https://BendixCarstensen.com">https://BendixCarstensen.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCmcmc">MCmcmc</a></code>, <code><a href="#topic+plot.MCmcmc">plot.MCmcmc</a></code>,
<code><a href="#topic+ox.MC">ox.MC</a></code>, <code><a href="#topic+sbp.MC">sbp.MC</a></code>
</p>

<hr>
<h2 id='PBreg'>Passing-Bablok regression</h2><span id='topic+PBreg'></span><span id='topic+print.PBreg'></span>

<h3>Description</h3>

<p>Implementation of the Passing-Bablok's procedure for assessing of the
equality of measurements by two different analytical methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PBreg(x, y = NULL, conf.level = 0.05, wh.meth = 1:2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PBreg_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Meth">Meth</a></code> object, alternatively a numeric vector of
measurements by method A, or a data frame of exactly two columns, first
column with measurements by method A, second column with measurements by
method B.</p>
</td></tr>
<tr><td><code id="PBreg_+3A_y">y</code></td>
<td>
<p>a numeric vector of measurements by method B - must be of the same
length as <code>x</code>. If not provided, <code>x</code> must be the <code><a href="#topic+Meth">Meth</a></code>
object or a data frame of exactly 2 columns.</p>
</td></tr>
<tr><td><code id="PBreg_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for calculation of confidence boundaries
- 0.05 is the default.</p>
</td></tr>
<tr><td><code id="PBreg_+3A_wh.meth">wh.meth</code></td>
<td>
<p>Which of the methods from the <code>Meth</code> object are used in
the regression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of the original Passing-Bablok procedure of
fitting unbiased linear regression line to data in the method comparison
studies. It calcualtes the unbiased slope and intercept, along with their
confidence intervals. However, the tests for linearity is not yet fully
implemented.
</p>
<p>It doesn't matter which results are assigned to &quot;Method A&quot; and &quot;Method B&quot;,
however the &quot;Method A&quot; results will be plotted on the x-axis by the
<code>plot</code> method.
</p>


<h3>Value</h3>

<p><code>PBreg</code> returns an object of class <code>"PBreg"</code>, for which
the <code>print</code>, <code>predict</code> and <code>plot</code> methods are defined.
</p>
<p>An object of class <code>"PBreg"</code> is a list composed of the following
elements:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a matrix of 3 columns and 2 rows, containing the
estimates of the intercept and slope, along with their confidence
boundaries.</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>defined as in the <code>"lm"</code> class, as the
response minus the fitted value.</p>
</td></tr> <tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the model data frame used.</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>a vector of two values:
the number of observations read, and the number of observations used.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>A vector of all slope estimates.</p>
</td></tr> <tr><td><code>I</code></td>
<td>
<p>A vector of all
intercept estimates.</p>
</td></tr> <tr><td><code>adj</code></td>
<td>
<p>A vector of fit parameters, where <em>Ss</em>
is the number of estimated slopes (<code>length(S)</code>), <em>K</em> is the offset
for slopes &lt;(-1), <em>M1</em> and <em>M2</em> are the locations of confidence
boundaries in <code>S</code>, and <em>l</em> and <em>L</em> are the numbers of points
above and below the fitted line, used in cusum calculation.</p>
</td></tr> <tr><td><code>cusum</code></td>
<td>
<p>A
vector of cumulative sums of residuals sorted by the D-rank.</p>
</td></tr> <tr><td><code>Di</code></td>
<td>
<p>A
vector of D-ranks.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Please note that this method can become very computationally intensive
for larger numbers of observations. One can expect a reasonable computation
times for datasets with fewer than 100 observations.
</p>


<h3>Author(s)</h3>

<p>Michal J. Figurski <a href="mailto:mfigrs@gmail.com">mfigrs@gmail.com</a>
</p>


<h3>References</h3>

<p>Passing, H. and Bablok, W. (1983), A New Biometrical Procedure
for Testing the Equality of Measurements from Two Different Analytical
Methods. <em>Journal of Clinical Chemistry and Clinical Biochemistry</em>, Vol
21, 709&ndash;720
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.PBreg">plot.PBreg</a>, <a href="#topic+predict.PBreg">predict.PBreg</a>, <a href="#topic+Deming">Deming</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Model data frame generation
  a &lt;- data.frame(x=seq(1, 30)+rnorm(mean=0, sd=1, n=30),
                  y=seq(1, 30)*rnorm(mean=1, sd=0.4, n=30))

  ## Call to PBreg
  x &lt;- PBreg(a)
  print(x)

  par(mfrow=c(2,2))
  plot(x, s=1:4)

  ## A real data example
  data(milk)
  milk &lt;- Meth(milk)
  summary(milk)
  PBmilk &lt;- PBreg(milk)
  par(mfrow=c(2,2))
  plot(PBmilk, s=1:4)

</code></pre>

<hr>
<h2 id='PEFR'>Peak Expiratory Flow Rate (PEFR) measurements with Wright peak flow and mini
Wright peak flow meter.</h2><span id='topic+PEFR'></span>

<h3>Description</h3>

<p>Measurement of PEFR with Wright peak flow and mini Wright peak flow meter on
17 individuals.
</p>


<h3>Format</h3>

<p>A data frame with 68 observations on the following 3 variables.
</p>
 <dl>
<dt><code>meth</code></dt><dd><p>a factor with levels <code>Wright</code> and
<code>Mini</code>, representing measurements by a Wright peak flow meter and a
mini Wright meter respectively, in random order.</p>
</dd>
<dt><code>item</code></dt><dd><p>Numeric vector, the person ID.</p>
</dd> <dt><code>y</code></dt><dd><p>Numeric
vector, the measurements, i.e. PEFR for the two measurements with a Wright
peak flow meter and a mini Wright meter respectively. The measurement unit
is l/min.</p>
</dd> <dt><code>repl</code></dt><dd><p>Numeric vector, replicate number. Replicates
are exchangeable within item.</p>
</dd> </dl>



<h3>Source</h3>

<p>J. M. Bland and D. G. Altman (1986) Statistical Methods for
Assessing Agreement Between Two Methods of Clinical Measurement, Lancet.
1986 Feb 8;1(8476):307-10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(PEFR)
PEFR &lt;- Meth(PEFR)
summary(PEFR)
plot(PEFR)
plot(perm.repl(PEFR))

</code></pre>

<hr>
<h2 id='perm.repl'>Manipulate the replicate numbering within (item,method)</h2><span id='topic+perm.repl'></span><span id='topic+make.repl'></span><span id='topic+has.repl'></span>

<h3>Description</h3>

<p>Replicate numbers are generated within (item,method) in a dataframe
representing a method comparison study. The function assumes that
observations are in the correct order within each (item,method), i.e. if
replicate observations are non-exchangeable within method, linked
observations are assumed to be in the same order within each (item,method).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm.repl(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perm.repl_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+Meth">Meth</a></code> object or a data frame with columns
<code>meth</code>, <code>item</code> and <code>y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make.repl</code> just adds replicate numbers in the order of the data.frame
rows.  <code>perm.repl</code> is designed to explore the effect of permuting the
replicates within (item,method). If replicates are truly exchangeable within
methods, the inference should be independent of this permutation.
</p>


<h3>Value</h3>

<p><code>make.repl</code> returns a dataframe with a column, <code>repl</code>
added or replaced, whereas <code>has.repl</code> returns a logical indicating
wheter a combination of (<code>meth</code>,<code>item</code>) wioth more that one valid
<code class="reqn">y</code>- value.
</p>
<p><code>perm.repl</code> returns a dataframe of class <code><a href="#topic+Meth">Meth</a></code> where the
rows (i.e. replicates) are randomly permuted within
(<code>meth</code>,<code>item</code>), and subsequently ordered by
(<code>meth</code>,<code>item</code>,<code>repl</code>).
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="https://bendixcarstensen.com/">https://bendixcarstensen.com/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perm.repl">perm.repl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(ox)
  xx &lt;- subset( ox, item&lt;4 )[,-3]
  cbind( xx, make.repl(xx) )
  cbind( make.repl(xx), perm.repl(xx) )
  data( ox )
  xx &lt;- subset( ox, item&lt;4 )
  cbind( xx, perm.repl(xx) )
  # Replicates are linked in the oximetry dataset, so randomly permuting
  # them clearly inflates the limits of agreement:
  par( mfrow=c(1,2), mar=c(4,4,1,4) )
  BA.plot(           ox , ymax=30, digits=1 )
  BA.plot( perm.repl(ox), ymax=30, digits=1 )

  
</code></pre>

<hr>
<h2 id='plot.MCmcmc'>Plot estimated conversion lines and formulae.</h2><span id='topic+plot.MCmcmc'></span>

<h3>Description</h3>

<p>Plots the pairwise conversion formulae between methods from a
<code><a href="#topic+MCmcmc">MCmcmc</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCmcmc'
plot(
  x,
  axlim = range(attr(x, "data")$y, na.rm = TRUE),
  wh.cmp,
  lwd.line = c(3, 1),
  col.line = rep("black", 2),
  lty.line = rep(1, 2),
  eqn = TRUE,
  digits = 2,
  grid = FALSE,
  col.grid = gray(0.8),
  points = FALSE,
  col.pts = "black",
  pch.pts = 16,
  cex.pts = 0.8,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MCmcmc_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+MCmcmc">MCmcmc</a></code> object</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_axlim">axlim</code></td>
<td>
<p>The limits for the axes in the panels</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_wh.cmp">wh.cmp</code></td>
<td>
<p>Numeric vector or vector of method names.  Which of the
methods should be included in the plot?</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_lwd.line">lwd.line</code></td>
<td>
<p>Numerical vector of length 2. The width of the conversion
line and the prediction limits. If the second values is 0, no prediction
limits are drawn.</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_col.line">col.line</code></td>
<td>
<p>Numerical vector of length 2. The color of the conversion
line and the prediction limits.</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_lty.line">lty.line</code></td>
<td>
<p>Numerical vector of length 2. The line types of the
conversion line and the prediction limits.</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_eqn">eqn</code></td>
<td>
<p>Should the conversion equations be printed on the plot?. Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_digits">digits</code></td>
<td>
<p>How many digits after the decimal point shoudl be used when
printing the conversion equations.</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_grid">grid</code></td>
<td>
<p>Should a grid be drawn? If a numerical vector is given, the grid
is drawn at those values.</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_col.grid">col.grid</code></td>
<td>
<p>What color should the grid have?</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_points">points</code></td>
<td>
<p>Logical or character. Should the points be plotted. If
<code>TRUE</code> or <code>"repl"</code> paired values of single replicates are plotted.
If <code>"perm"</code>, replicates are randomly permuted within (item, method)
befor plotting. If <code>"mean"</code>, means across replicates within item,
method are formed and plotted.</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_col.pts">col.pts</code></td>
<td>
<p>What color should the observation have.</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_pch.pts">pch.pts</code></td>
<td>
<p>What plotting symbol should be used.</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_cex.pts">cex.pts</code></td>
<td>
<p>What scaling should be used for the plot symbols.</p>
</td></tr>
<tr><td><code id="plot.MCmcmc_+3A_...">...</code></td>
<td>
<p>Parameters to pass on. Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.  The lower part of a (M-1) by (M-1) matrix of plots is
drawn, showing the pairwise conversion lines. In the corners of each is
given the two conversion equations together with the prediction standard
error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCmcmc">MCmcmc</a></code>, <code><a href="#topic+print.MCmcmc">print.MCmcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: data( hba1c )
## Not run: str( hba1c )
## Not run: hba1c &lt;- transform( subset( hba1c, type=="Ven" ),
                    meth = dev,
                    repl = d.ana )
## End(Not run)
## Not run: hb.res &lt;- MCmcmc( hba1c, n.iter=50 )
## Not run: data( hba.MC )
## Not run: str( hba.MC )
## Not run: par( ask=TRUE )
## Not run: plot( hba.MC )
## Not run: plot( hba.MC, pl.obs=TRUE )

</code></pre>

<hr>
<h2 id='plot.MethComp'>Summarize conversion equations and prediction intervals between methods.</h2><span id='topic+plot.MethComp'></span>

<h3>Description</h3>

<p><code>plot.MethComp</code> plots the conversion function with prediction limits;
always using the original scale of measurements. It also sets the options
<code>"MethComp.wh.cmp"</code> indicating which two methods are plotted and
<code>"MethComp.pl.type"</code> indicating whether a plot of methods against each
other or a Bland-Altman type plot of differences versus averages. By default
the conversion lines are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MethComp'
plot(
  x,
  wh.comp = 1:2,
  pl.type = "conv",
  dif.type = "lin",
  sd.type = "const",
  axlim = range(x$data$y, na.rm = TRUE),
  diflim = axlim - mean(axlim),
  points = FALSE,
  repl.conn = FALSE,
  col.conn = "gray",
  lwd.conn = 1,
  grid = TRUE,
  N.grid = 10,
  col.grid = grey(0.9),
  lwd = c(3, 1, 1),
  col.lines = "black",
  col.points = "black",
  pch.points = 16,
  eqn = is.null(attr(x, "Transform")),
  col.eqn = col.lines,
  font.eqn = 2,
  digits = 2,
  mult = FALSE,
  alpha = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MethComp_+3A_x">x</code></td>
<td>
<p>A <code>MethComp</code> object.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_wh.comp">wh.comp</code></td>
<td>
<p>Numeric or character of length 2. Which two methods should be
plotted.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_pl.type">pl.type</code></td>
<td>
<p>Character. If &quot;conv&quot; it will be a plot of two methods against
each other, otherwise it will be a plot of the 1st minus the 2nd versus the
average; a Bland-Altman type plot.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_dif.type">dif.type</code></td>
<td>
<p>Character. If &quot;lin&quot; (the default) a linear relationship
between methods is allowed. Otherwise a constant difference is assumed and
LoA can be indicated on the plot.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_sd.type">sd.type</code></td>
<td>
<p>Should the estimated dependence of the SD (from
<code><a href="#topic+DA.reg">DA.reg</a></code> be used when plotting prediction limits?</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_axlim">axlim</code></td>
<td>
<p>The extent of the axes of the measurements.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_diflim">diflim</code></td>
<td>
<p>The extent of the axis of the differences.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_points">points</code></td>
<td>
<p>Logical. Should the points be included in the plot.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_repl.conn">repl.conn</code></td>
<td>
<p>Logical. Should replcate measurements be connected; this
assumes linked replicates.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_col.conn">col.conn</code></td>
<td>
<p>Color of the lines connecting replicates.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_lwd.conn">lwd.conn</code></td>
<td>
<p>Width of the connection lines.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_grid">grid</code></td>
<td>
<p>Should there be a grid? If numerical, gridlines are drawn at
these locations.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_n.grid">N.grid</code></td>
<td>
<p>Numeric. How many gridlines? If a vector of length&gt;1, it will
be taken as the position of the gridlines.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_col.grid">col.grid</code></td>
<td>
<p>Color of the gridlines.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_lwd">lwd</code></td>
<td>
<p>Numerical vector of length 3. Width of the conversion line and
the prediction limits.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_col.lines">col.lines</code></td>
<td>
<p>Color of the conversion lines.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_col.points">col.points</code></td>
<td>
<p>Color of the points.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_pch.points">pch.points</code></td>
<td>
<p>Plot character for points.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_eqn">eqn</code></td>
<td>
<p>Logical. Should the conversion equation be printed on the plot.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_col.eqn">col.eqn</code></td>
<td>
<p>Color of the conversion formula</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_font.eqn">font.eqn</code></td>
<td>
<p>font for the conversion formula</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_digits">digits</code></td>
<td>
<p>The number of digits after the decimal point in the conversion
formulae.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_mult">mult</code></td>
<td>
<p>Logical. Should ratios be plotted on a log-scale instead of
differences on a linear scale? See description of the argument for
<code><a href="#topic+BA.plot">BA.plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_alpha">alpha</code></td>
<td>
<p>1 minus the confidence level for the prediction interval. If
not given, the prediction interval is constructed as plus/minus twice the
SD.</p>
</td></tr>
<tr><td><code id="plot.MethComp_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lines.MethComp</code> and <code>points.MethComp</code> adds conversion lines with
prediction limits and points to a plot.
</p>


<h3>Value</h3>

<p><code>MethComp</code> returns a <code>MethComp</code> object, which is a list
with three elements, <code>Conv</code>, a three-way array giving the linear
conversion equations between methods, <code>VarComp</code>, a two-way array
classified by methods and variance components and <code>data</code>, a copy of the
original <code><a href="#topic+Meth">Meth</a></code> object supplied &mdash; see the description under
<code><a href="#topic+BA.est">BA.est</a></code>.
</p>
<p>A <code>MethComp</code> object has an attribute <code>Transform</code>, which is either
NULL, or a named list with elements <code>trans</code> and <code>inv</code>, both of
which are functions. The first is the transformation applied to measurements
before analysis; the results are all given on the transformed scale. The
second is the inverse transformation; this is only used when plotting the
resulting relationship between methods.
</p>
<p>The methods <code>print</code>, <code>plot</code>, <code>lines</code> and <code>points</code> return
nothing.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BA.est">BA.est</a></code> <code><a href="#topic+AltReg">AltReg</a></code> <code><a href="#topic+MCmcmc">MCmcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( ox )
BA.ox &lt;- BA.est( ox, linked=TRUE )
print( BA.ox )
## Not run: 
AR.ox &lt;- AltReg( ox, linked=TRUE  )
print( AR.ox )
plot( AR.ox ) 
## End(Not run)

</code></pre>

<hr>
<h2 id='plvol'>Measurements of plasma volume measured by two different methods.</h2><span id='topic+plvol'></span>

<h3>Description</h3>

<p>For each subject (<code>item</code>) the plasma volume is expressed as a
percentage of the expected value for normal individuals. Two alternative
sets of normal values are used, named Nadler and Hurley respectively.
</p>


<h3>Format</h3>

<p>A data frame with 198 observations on the following 3 variables.
</p>
 <dl>
<dt><code>meth</code></dt><dd><p>a factor with levels <code>Hurley</code> and
<code>Nadler</code></p>
</dd> <dt><code>item</code></dt><dd><p>a numeric vector</p>
</dd> <dt><code>y</code></dt><dd><p>a
numeric vector</p>
</dd> </dl>



<h3>Source</h3>

<p>The datset is adapted from table 2 in: JM Bland and DG Altman:
Measuring agreement in method comparison studies. Statistical Methods in
Medical Research, 8:136-160, 1999. Originally supplied to Bland &amp; Altman by
C Dore, see: Cotes PM, Dore CJ, Liu Yin JA, Lewis SM, Messinezy M, Pearson
TC, Reid C.  Determination of serum immunoreactive erythropoietin in the
investigation of erythrocytosis. New England Journal of Medicine 1986; 315:
283-87.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(plvol)
str(plvol)
plot( y[meth=="Nadler"]~y[meth=="Hurley"],data=plvol,
      xlab="Plasma volume (Hurley) (pct)",
      ylab="Plasma volume (Nadler) (pct)" )
abline(0,1)
par( mar=c(4,4,1,4) )
BA.plot(plvol)

</code></pre>

<hr>
<h2 id='predict.PBreg'>Predict results from PBreg object</h2><span id='topic+predict.PBreg'></span>

<h3>Description</h3>

<p>A predict method for the <code>"PBreg"</code> class object, that is a result of Passing-Bablok regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PBreg'
predict(
  object,
  newdata = object$model$x,
  interval = "confidence",
  level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.PBreg_+3A_object">object</code></td>
<td>
<p>an object of class <code>"PBreg"</code>.</p>
</td></tr>
<tr><td><code id="predict.PBreg_+3A_newdata">newdata</code></td>
<td>
<p>an optional vector of new values of <code>x</code> to make predictions for. If omitted, the fitted values will be used.</p>
</td></tr>
<tr><td><code id="predict.PBreg_+3A_interval">interval</code></td>
<td>
<p>type of interval calculation - either <code>confidence</code> or <code>none</code>. The former is the default.</p>
</td></tr>
<tr><td><code id="predict.PBreg_+3A_level">level</code></td>
<td>
<p>String. The type of interval to compute. Either &quot;tolerance&quot; or &quot;confidence&quot; (the default).</p>
</td></tr>
<tr><td><code id="predict.PBreg_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>interval</code> is <code>"confidence"</code> this function returns a data frame with three columns: &quot;fit&quot;, &quot;lwr&quot; and &quot;upr&quot; - similarly to <code>predict.lm</code>.
</p>
<p>If <code>interval</code> is <code>"none"</code> a vector of predicted values is returned.
</p>


<h3>Author(s)</h3>

<p>Michal J. Figurski <a href="mailto:mfigrs@gmail.com">mfigrs@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Model data frame generation
a &lt;- data.frame(x=seq(1, 30)+rnorm(mean=0, sd=1, n=30),
                y=seq(1, 30)*rnorm(mean=1, sd=0.4, n=30))

## Call to PBreg
x &lt;- PBreg(a)
print(x)
predict(x, interval="none")

## Or the same using "Meth" object
a &lt;- Meth(a, y=1:2)
x &lt;- PBreg(a)
print(x)
predict(x)

</code></pre>

<hr>
<h2 id='print.MCmcmc'>Print a MCmcmc object</h2><span id='topic+print.MCmcmc'></span>

<h3>Description</h3>

<p>Print a MCmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCmcmc'
print(x, digits = 3, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.MCmcmc_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.MCmcmc_+3A_digits">digits</code></td>
<td>
<p>Number of digits to print</p>
</td></tr>
<tr><td><code id="print.MCmcmc_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="print.MCmcmc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='rainman'>Perception of points in a swarm</h2><span id='topic+rainman'></span>

<h3>Description</h3>

<p>Five raters were asked to guess the number of points in a swarm for 10
different figures (which - unknown to the raters - were each repeated three
times).
</p>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 6 variables.
</p>
 <dl>
<dt><code>SAND</code></dt><dd><p>The true number of points in the swarm. Each
picture is replicated thrice</p>
</dd> <dt><code>ME</code></dt><dd><p>Ratings from judge 1</p>
</dd>
<dt><code>TM</code></dt><dd><p>Ratings from judge 2</p>
</dd> <dt><code>AJ</code></dt><dd><p>Ratings from judge
3</p>
</dd> <dt><code>BM</code></dt><dd><p>Ratings from judge 4</p>
</dd> <dt><code>LO</code></dt><dd><p>Ratings from
judge 5</p>
</dd> </dl>



<h3>Details</h3>

<p>The raters had approximately 10 seconds to judge each picture, and they
thought it were 30 different pictures. Before starting the experiment they
were shown 6 (unrelated) pictures and were told the number of points in each
of those pictures. The SAND column contains the picture id (which is also
the true number of points in the swarm).
</p>


<h3>Source</h3>

<p>Collected by Claus Ekstrom.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MethComp)
data( rainman )
str( rainman )
RM &lt;- Meth( rainman, item=1, y=2:6 )
head( RM )
BA.est( RM, linked=FALSE )
library(lme4)
mf &lt;- lmer( y ~ meth + item + (1|MI),
                data = transform( RM, MI=interaction(meth,item) ) )
summary( mf )
mr &lt;- lmer( y ~ (1|meth) + (1|item) + (1|MI),
                data = transform( RM, MI=interaction(meth,item) ) )
summary( mr )

#
# Point swarms were generated by the following program
#
## Not run: 
set.seed(2) # Original
npoints &lt;- sample(4:30)*4
nplots &lt;- 10
pdf(file="swarms.pdf", onefile=TRUE)

s1 &lt;- sample(npoints[1:nplots])
print(s1)
for (i in 1:nplots) {
  n &lt;- s1[i]
  set.seed(n)
  x &lt;- runif(n)
  y &lt;- runif(n)
  plot(x,y, xlim=c(-.15, 1.15), ylim=c(-.15, 1.15), pch=20, axes=F,
       xlab="", ylab="")
}
s1 &lt;- sample(npoints[1:nplots])
print(s1)
for (i in 1:nplots) {
  n &lt;- s1[i]
  set.seed(n)
  x &lt;- runif(n)
  y &lt;- runif(n)
  plot(y,x, xlim=c(-.15, 1.15), ylim=c(-.15, 1.15), pch=20, axes=F,
       xlab="", ylab="")
}
s1 &lt;- sample(npoints[1:nplots])
print(s1)
for (i in 1:nplots) {
  n &lt;- s1[i]
  set.seed(n)
  x &lt;- runif(n)
  y &lt;- runif(n)
  plot(-x,y, xlim=c(-1.15, .15), ylim=c(-.15, 1.15), pch=20, axes=F,
       xlab="", ylab="")
}
dev.off()

## End(Not run)

</code></pre>

<hr>
<h2 id='sample.Meth'>Sample Meth object with replacement</h2><span id='topic+sample.Meth'></span>

<h3>Description</h3>

<p>Sample a <code><a href="#topic+Meth">Meth</a></code> object with replacement.  If <code>how=="random"</code>, a random sample of the rows are
sampled, the existing values of <code>meth</code>, <code>item</code> and <code>y</code> are kept but new replicate numbers are 
generated.  If <code>how=="linked"</code>, a random sample of the linked observations (i.e.
observations with identical <code>item</code> and <code>repl</code> values) are
sampled with replacement and replicate numbers are kept. If
<code>how=="item"</code>, items are sampled with replacement, and their
observations are included the sampled numner of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.Meth(
  x,
  how = "random",
  N = if (how == "items") nlevels(x$item) else nrow(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample.Meth_+3A_x">x</code></td>
<td>
<p>A <code>Meth</code> object.</p>
</td></tr>
<tr><td><code id="sample.Meth_+3A_how">how</code></td>
<td>
<p>Character. What sampling strategy should be used, one of
<code>"random"</code>, <code>"linked"</code> or <code>"item"</code>. Only the first letter is
significant. See details for explanation.</p>
</td></tr>
<tr><td><code id="sample.Meth_+3A_n">N</code></td>
<td>
<p>How many observations should be sampled?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A meth object
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fat)
# Different ways of selecting columns and generating replicate numbers
Sub1 &lt;- Meth(fat,meth=2,item=1,repl=3,y=4,print=TRUE)
Sub2 &lt;- Meth(fat,2,1,3,4,print=TRUE)
Sub3 &lt;- Meth(fat,meth="Obs",item="Id",repl="Rep",y="Sub",print=TRUE)
summary( Sub3 )
plot( Sub3 )

# Use observation in different columns as methods
data( CardOutput )
head( CardOutput )
sv &lt;- Meth( CardOutput, y=c("Svo2","Scvo2") )
# Note that replicates are generated if a non-unique item-id is used
sv &lt;- Meth( CardOutput, y=c("Svo2","Scvo2"), item="Age" )
str( sv )
# A summary is not created if the the first argument (data=) is not used:
sv &lt;- Meth( y=CardOutput[,c("Svo2","Scvo2")], item=CardOutput$VO2 )
summary(sv)

# Sample items
ssv &lt;- sample.Meth( sv, how="item", N=8 )

# More than two methods
data( sbp )
plot( Meth( sbp ) )
# Creating non-unique replicate numbers per (meth,item) creates a warning:
data( hba1c )
hb1  &lt;- with( hba1c,
              Meth( meth=dev, item=item, repl=d.ana-d.samp, y=y, print=TRUE ) )
hb2  &lt;- with( subset(hba1c,type=="Cap"),
              Meth( meth=dev, item=item, repl=d.ana-d.samp, y=y, print=TRUE ) )
  
</code></pre>

<hr>
<h2 id='sbp'>Systolic blood pressure measured by three different methods.</h2><span id='topic+sbp'></span>

<h3>Description</h3>

<p>For each subject (<code>item</code>) there are three replicate measurements by
three methods (two observers, J and R and the automatic machine, S). The
replicates are linked within (method,item).
</p>


<h3>Format</h3>

<p>A data frame with 765 observations on the following 4 variables:
</p>
 <dl>
<dt><code>meth</code></dt><dd><p>Methods, a factor with levels
<code>J</code>(observer 1), <code>R</code>(observer 2) and <code>S</code>(machine)</p>
</dd>
<dt><code>item</code></dt><dd><p>Person id, numeric.</p>
</dd> <dt><code>repl</code></dt><dd><p>Replicate
number, a numeric vector</p>
</dd> <dt><code>y</code></dt><dd><p>Systolic blood pressure
masurement, a numeric vector</p>
</dd> </dl>



<h3>Source</h3>

<p>The dataset is adapted from table 1 in: JM Bland and DG Altman:
Measuring agreement in method comparison studies. Statistical Methods in
Medical Research, 8:136-160, 1999. Originally supplied to Bland &amp; Altman by
E. O'Brien, see: Altman DG, Bland JM. The analysis of blood pressure data.
In O'Brien E, O'Malley K eds. Blood pressure measurement. Amsterdam:
Elsevier, 1991: 287-314.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbp.MC">sbp.MC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sbp)
par( mfrow=c(2,2), mar=c(4,4,1,4) )
BA.plot( sbp, comp=1:2 )
BA.plot( sbp, comp=2:3 )
BA.plot( sbp, comp=c(1,3) )
## Not run:  BA.est( sbp, linked=TRUE ) 

</code></pre>

<hr>
<h2 id='sbp.MC'>A MCmcmc object from the sbp data</h2><span id='topic+sbp.MC'></span>

<h3>Description</h3>

<p>This object is included for illustrative purposes. It is a result of using
<code><a href="#topic+MCmcmc">MCmcmc</a></code>, with <code>n.iter=100000</code> on the dataset
<code><a href="#topic+sbp">sbp</a></code> from this package.
</p>


<h3>Format</h3>

<p>The format is a <code><a href="#topic+MCmcmc">MCmcmc</a></code> object.
</p>


<h3>Details</h3>

<p>The basic data are measurements of systolic blood pressure from the
<code><a href="#topic+sbp">sbp</a></code> dataset. Measurements are taken to be linked within
replicate.  The code used to generate the object was: </p>
<pre>
library(MethComp) data( sbp ) spb &lt;- Meth( sbp ) sbp.MC &lt;- MCmcmc( sbp,
linked=TRUE, n.iter=100000, program="JAGS" ) ) </pre>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sbp.MC)
# How was the data generated
attr(sbp.MC,"mcmc.par")

# Traceplots
trace.MCmcmc(sbp.MC)
trace.MCmcmc(sbp.MC,"beta")

# A MCmcmc object also has class mcmc.list, so we can use the
# standard coda functions for convergence diagnostics:
# acfplot( subset.MCmcmc(sbp.MC,subset="sigma") )

# Have a look at the correlation between the 9 variance parameters
pairs( sbp.MC )

# Have a look at whether the MxI variance components are the same between methods:
## Not run: 
pairs( sbp.MC, subset=c("mi"), eq=TRUE,
        panel=function(x,y,...)
              {
               abline(0,1)
               abline(v=median(x),h=median(y),col="gray")
               points(x,y,...)
              }
        ) 
## End(Not run)

</code></pre>

<hr>
<h2 id='scint'>Relative renal function by Scintigraphy</h2><span id='topic+scint'></span>

<h3>Description</h3>

<p>Measurements of the relative kidney function (=renal function) for 111
patients. The percentage of the total renal function present in the left
kidney is determined by one reference method, <code>DMSA</code> (static) and by
one of two dynamic methods, <code>DTPA</code> or <code>EC</code>.
</p>


<h3>Format</h3>

<p>A data frame with 222 observations on the following 5 variables:
</p>
 <dl>
<dt><code>meth</code></dt><dd><p>Measurement method, a factor with levels
<code>DMSA</code>, <code>DTPA</code>, <code>EC</code>.</p>
</dd> <dt><code>item</code></dt><dd><p>Patient
identification.</p>
</dd> <dt><code>y</code></dt><dd><p>Percentage of total kidney function in the
left kidney.</p>
</dd> <dt><code>age</code></dt><dd><p>Age of the patient.</p>
</dd> <dt><code>sex</code></dt><dd><p>Sex
of the patient, a factor with levels <code>F</code>, <code>M</code>.</p>
</dd> </dl>



<h3>Source</h3>

<p>F. C. Domingues, G. Y. Fujikawa, H. Decker, G. Alonso, J. C.
Pereira, P. S. Duarte: Comparison of Relative Renal Function Measured with
Either 99mTc-DTPA or 99mTc-EC Dynamic Scintigraphies with that Measured with
99mTc-DMSA Static Scintigraphy.  International Braz J Urol Vol. 32 (4):
405-409, 2006
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(scint)
  str(scint)
  # Make a Bland-Altman plot for each of the possible comparisons:
  par(mfrow=c(1,2),mgp=c(3,1,0)/1.6,mar=c(3,3,1,3))
  BA.plot(scint,comp.levels=c(1,2),ymax=15,digits=1,cex=2)
  BA.plot(scint,comp.levels=c(1,3),ymax=15,digits=1,cex=2)
  
</code></pre>

<hr>
<h2 id='subset.MCmcmc'>Subset an MCmcmc object</h2><span id='topic+subset.MCmcmc'></span>

<h3>Description</h3>

<p>Subset an MCmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCmcmc'
subset(x, subset = NULL, allow.repl = FALSE, chains = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.MCmcmc_+3A_x">x</code></td>
<td>
<p>object to be subsetted.</p>
</td></tr>
<tr><td><code id="subset.MCmcmc_+3A_subset">subset</code></td>
<td>
<p>Numerical, character or list giving the variables to keep.
If numerical, the variables in the <code>MCmcmc</code> object with
these numbers are selected. If character, each element of the
character vector is &quot;grep&quot;ed against the variable names, and
the matches are selected to the subset. If a list each element
is used in turn, numerical and character elements can be mixed.</p>
</td></tr>
<tr><td><code id="subset.MCmcmc_+3A_allow.repl">allow.repl</code></td>
<td>
<p>Logical. Should duplicate columns be allowed in the result?</p>
</td></tr>
<tr><td><code id="subset.MCmcmc_+3A_chains">chains</code></td>
<td>
<p>Numerical vector giving the number of the chains to keep.</p>
</td></tr>
<tr><td><code id="subset.MCmcmc_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.MCmcmc'>Summary</h2><span id='topic+summary.MCmcmc'></span>

<h3>Description</h3>

<p>Summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCmcmc'
summary(object, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.MCmcmc_+3A_object">object</code></td>
<td>
<p>An <code>MCmcmc</code> object</p>
</td></tr>
<tr><td><code id="summary.MCmcmc_+3A_alpha">alpha</code></td>
<td>
<p>1 minus the the confidence level</p>
</td></tr>
<tr><td><code id="summary.MCmcmc_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>

<hr>
<h2 id='summary.Meth'>Summary for Meth obect</h2><span id='topic+summary.Meth'></span>

<h3>Description</h3>

<p>Summary for Meth obect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Meth'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Meth_+3A_object">object</code></td>
<td>
<p>A <code>Meth</code> object.</p>
</td></tr>
<tr><td><code id="summary.Meth_+3A_...">...</code></td>
<td>
<p>Parameters passed on to both the panel function plotting methods against each other, as well as to those plotting differences against means.
</p>
<p>rdname summary</p>
</td></tr>
</table>

<hr>
<h2 id='TDI'>Compute Lin's Total deviation index</h2><span id='topic+TDI'></span>

<h3>Description</h3>

<p>This index calculates a value such that a certain fraction of difference between methods will be numerically smaller than this. The TDI is a measure which esentially is a number K such that the interval [-K,K] contains the limits of agreement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TDI(y1, y2, p = 0.05, boot = 1000, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TDI_+3A_y1">y1</code></td>
<td>
<p>Measurements by one method.</p>
</td></tr>
<tr><td><code id="TDI_+3A_y2">y2</code></td>
<td>
<p>Measurements by the other method.</p>
</td></tr>
<tr><td><code id="TDI_+3A_p">p</code></td>
<td>
<p>The fraction of items with differences numerically exceeding the TDI</p>
</td></tr>
<tr><td><code id="TDI_+3A_boot">boot</code></td>
<td>
<p>If numerical, this is the number of bootstraps. If <code>FALSE</code> no confidence interval for the TDI is produced.</p>
</td></tr>
<tr><td><code id="TDI_+3A_alpha">alpha</code></td>
<td>
<p>1 - confidende degree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>boot==FALSE</code> a single number, the TDI is returned.
If <code>boot</code> is a number, the median and the 1-<code>alpha</code>/2 central interval
based on <code>boot</code> resamples are returned too, in a named vector of length 4.
</p>


<h3>Value</h3>

<p>A list with 3 components. The names of the list are preceeded by the
criterion percentage, i.e. the percentage of the population that the TDI is
devised to catch.
</p>
<table role = "presentation">
<tr><td><code>TDI</code></td>
<td>
<p>The numerically computed value for the TDI. If <code>boot</code> is
numeric, a vector of median and a bootstrap c.i. is appended.</p>
</td></tr>
<tr><td><code>TDI</code></td>
<td>
<p>The approximate value of the TDI</p>
</td></tr>
<tr><td><code>Limits of Agreement</code></td>
<td>
<p>Limits of agreement</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>
</p>


<h3>References</h3>

<p>LI Lin: Total deviation index for measuring individual agreement with applications in laboratory performance and bioequivalence, Statistics in Medicine, 19, 255-270 (2000)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(plvol)
pw &lt;- to.wide(plvol)
with(pw,TDI(Hurley,Nadler))

</code></pre>

<hr>
<h2 id='to.long'>Functions to convert between long and wide representations of data</h2><span id='topic+to.long'></span>

<h3>Description</h3>

<p>These functions are merely wrappers for <code><a href="stats.html#topic+reshape">reshape</a></code>.
Given the complicated syntax of <code>reshape</code> and the particularly simple
structure of this problem, the functions facilitate the conversion
enormously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.long(data, vars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to.long_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+Meth">Meth</a></code> object.</p>
</td></tr>
<tr><td><code id="to.long_+3A_vars">vars</code></td>
<td>
<p>The variables representing measurements by different methods. Either a character vector of names, or a numerical vector with the number of the variables in the dataframe.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>data</code> represents method comparisons with exchangeable  replicates within method, the transformation to wide format does not necessarily make sense.
</p>


<h3>Value</h3>

<p>A data frame with the reshaped data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( milk )
str( milk )
mw &lt;- to.wide( milk )
str( mw )
( mw &lt;- subset( mw, as.integer(item) &lt; 3 ) )
to.long( mw, 3:4 )

</code></pre>

<hr>
<h2 id='to.wide'>Functions to convert between long and wide representations of data</h2><span id='topic+to.wide'></span>

<h3>Description</h3>

<p>These functions are merely wrappers for <code><a href="stats.html#topic+reshape">reshape</a></code>.
Given the complicated syntax of <code>reshape</code> and the particularly simple
structure of this problem, the functions facilitate the conversion
enormously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.wide(data, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to.wide_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+Meth">Meth</a></code> object.</p>
</td></tr>
<tr><td><code id="to.wide_+3A_warn">warn</code></td>
<td>
<p>Logical. Should a warning be printed when replicates are taken as items?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>data</code> represents method comparisons with exchangeable  replicates within method, the transformation to wide format does not necessarily make sense.
</p>


<h3>Value</h3>

<p>A data frame with the reshaped data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( milk )
str( milk )
mw &lt;- to.wide( milk )
str( mw )
( mw &lt;- subset( mw, as.integer(item) &lt; 3 ) )
to.long( mw, 3:4 )

</code></pre>

<hr>
<h2 id='trace.MCmcmc'>Functions to graphically assess the convergence of the MCMC-simulation in a
MCmcmc object</h2><span id='topic+trace.MCmcmc'></span><span id='topic+check.MCmcmc'></span><span id='topic+post.MCmcmc'></span>

<h3>Description</h3>

<p>These functions display traces for the relevant subset of the parameters in a MCmcmc object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCmcmc'
trace(
  obj,
  what = "sd",
  scales = c("same", "free"),
  layout = "col",
  aspect = "fill",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace.MCmcmc_+3A_obj">obj</code></td>
<td>
<p>A <code>MCmcmc</code> object.</p>
</td></tr>
<tr><td><code id="trace.MCmcmc_+3A_what">what</code></td>
<td>
<p>Character indicating what parameters to plot.  Possible values
are <code>"sd"</code> or <code>"var"</code> which gives plots for the variance
components (on the sd. scale), <code>"beta"</code> or <code>"slope"</code>, which gives
plots for slope parameters and <code>"alpha"</code> or <code>"int"</code>, which gives
plots for the intercept parameters.</p>
</td></tr>
<tr><td><code id="trace.MCmcmc_+3A_scales">scales</code></td>
<td>
<p>Character vector of length two, with possible values &quot;same&quot; or
&quot;free&quot;, indicating whether x- and y-axes of the plots should be constrained
to be the same across panels. For <code>pairs</code> only the first element is
used to decide whether all panles should have the same axes.</p>
</td></tr>
<tr><td><code id="trace.MCmcmc_+3A_layout">layout</code></td>
<td>
<p>Character. If <code>"col"</code> parameters are displayed columnwise
by method, if <code>"row"</code> they are displayed row-wise.</p>
</td></tr>
<tr><td><code id="trace.MCmcmc_+3A_aspect">aspect</code></td>
<td>
<p>How should the panels be scaled. Default (<code>"fill"</code>) is to
make a panels take up as much place as possible.</p>
</td></tr>
<tr><td><code id="trace.MCmcmc_+3A_...">...</code></td>
<td>
<p>Further aruments passed on to the <code><a href="lattice.html#topic+Lattice">Lattice</a></code> package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>lattice</code> plot is returned, which means that it must <code>print</code>ed
when these functions are called in a batch program or inside another
function or for-loop.
</p>
<p><code>trace</code> plots traces of the sampled chains, <code>post</code> plots posterior
densities of the parameters and <code>pairs</code> plots a scatter-plot matrix of
bivariate marginal posterior distributions.
</p>


<h3>Value</h3>

<p>A <code><a href="lattice.html#topic+Lattice">Lattice</a></code> plot.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>,
<a href="https://BendixCarstensen.com">https://BendixCarstensen.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCmcmc">MCmcmc</a></code>, <code><a href="#topic+plot.MCmcmc">plot.MCmcmc</a></code>,
<code><a href="#topic+ox.MC">ox.MC</a></code>, <code><a href="#topic+sbp.MC">sbp.MC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load a provided MCmcmc object
data( ox.MC )
trace.MCmcmc( ox.MC, what="beta" )
pairs( ox.MC, what="sd" )

</code></pre>

<hr>
<h2 id='VitCap'>Merits of two instruments designed to measure certain aspects of human lung
function (Vital Capacity)</h2><span id='topic+VitCap'></span>

<h3>Description</h3>

<p>Measurement on certain aspects of human lung capacity for 72 patients on 4
instrument-operative combination, i.e. two different instruments and two
different users, a skilled one and a new one.
</p>


<h3>Format</h3>

<p>A data frame with 288 observations on the following 5 variables.
</p>
 <dl>
<dt><code>meth</code></dt><dd><p>a factor with levels <code>StNew</code>,
<code>StSkil</code>, <code>ExpNew</code> and <code>ExpSkil</code>, representing the instrument
by user combinations. See below.</p>
</dd> <dt><code>item</code></dt><dd><p>a numeric vector, the
person ID, i.e. the 72 patients</p>
</dd> <dt><code>y</code></dt><dd><p>a numeric vector, the
measurements, i.e. vital capacity.</p>
</dd> <dt><code>user</code></dt><dd><p>a factor with levels
<code>New</code> <code>Skil</code>, for the new user and the skilled user</p>
</dd>
<dt><code>instrument</code></dt><dd><p>a factor with levels <code>Exp</code> and <code>St</code>, for
the experimental instrument and the standard one.</p>
</dd> </dl>



<h3>Source</h3>

<p>V. D. Barnett, Simultaneous Pairwise Linear Structural
Relationships, Biometrics, Mar. 1969, Vol. 25, No. 1, pp. 129-142.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(VitCap)
Vcap &lt;- Meth( VitCap )
str( Vcap )
plot( Vcap )

</code></pre>

<hr>
<h2 id='y2DA'>Convert DA to (classical) regression</h2><span id='topic+y2DA'></span>

<h3>Description</h3>

<p>The functions <code>DA2y</code> and <code>y2DA</code> are convenience functions that
convert the estimates of intercept, slope and sd from the regression of
<code class="reqn">D=y_1-y_2</code> on <code class="reqn">A=(y_1+y_2)/2</code>, back and forth
to the resulting intercept, slope and sd in the relationship between
<code class="reqn">y_1</code> and <code class="reqn">y_2</code>, cf. Carstensen (2010), equation 6.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>y2DA(A = 0, B = 1, S = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="y2DA_+3A_a">A</code></td>
<td>
<p>Intercept in the linear relation of y1 on y2.</p>
</td></tr>
<tr><td><code id="y2DA_+3A_b">B</code></td>
<td>
<p>Slope in the linear relation of y1 on y2.</p>
</td></tr>
<tr><td><code id="y2DA_+3A_s">S</code></td>
<td>
<p>SD for the linear relation of y1 on y2. Can be <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>#' <code>y2DA</code> takes intercept(<code>A</code>), slope(<code>B</code>) and sd(<code>S</code>) from
the relationship <code>y1=A+B y2 + E</code> with sd(<code>E</code>)=<code>E</code>, and
returns a vector of length 3 with names
<code>"int(t-f)","slope(t-f)","sd(t-f)"</code>, where <code>t</code> refers to &quot;to&quot;
(<code>y1</code> and <code>f</code> to &quot;from&quot; <code>y2</code>.
</p>


<h3>Value</h3>

<p><code>y2DA</code> returns a 3-component vector with names
<code>c("DA-int","DA-slope","DA-sd")</code>, referring to differences
<code>D=y1-y2</code> as a linear function of <code>A=(y1+y2)/2</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>,
<a href="https://BendixCarstensen.com/MethComp/">https://BendixCarstensen.com/MethComp/</a>
</p>


<h3>References</h3>

<p>B. Carstensen: Comparing methods of measurement: Extending the
LoA by regression.  Stat Med, 29:401-410, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( milk )
DA.reg( milk )
data( sbp )
print( DA.reg(sbp), digits=3 )
# Slope, intercept : y1 = 0.7 + 1.2*y2 (0.4)
A &lt;- c(0.7,1.2,0.4)
( y2DA( A ) )
( DA2y( y2DA( A ) ) )

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
