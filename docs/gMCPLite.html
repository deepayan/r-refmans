<!DOCTYPE html><html><head><title>Help for package gMCPLite</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gMCPLite}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gMCPLite-package'><p>gMCPLite: Lightweight Graph Based Multiple Comparison Procedures</p></a></li>
<li><a href='#bdiagNA'><p>Create a Block Diagonal Matrix with NA outside the diagonal</p></a></li>
<li><a href='#bonferroni.test'><p>Weighted Bonferroni-test</p></a></li>
<li><a href='#bonferroni.trimmed.simes.test'><p>Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test</p></a></li>
<li><a href='#checkCorrelation'><p>Check correlation matrix</p></a></li>
<li><a href='#entangledMCP-class'><p>Class entangledMCP</p></a></li>
<li><a href='#exampleGraphs'><p>Functions that create different example graphs</p></a></li>
<li><a href='#generatePvals'><p>generatePvals</p></a></li>
<li><a href='#generateWeights'><p>generateWeights</p></a></li>
<li><a href='#gMCP'><p>Graph based Multiple Comparison Procedures</p></a></li>
<li><a href='#gMCP.extended'><p>Graph based Multiple Comparison Procedures</p></a></li>
<li><a href='#gMCPResult-class'><p>Class gMCPResult</p></a></li>
<li><a href='#gPADInterim-class'><p>Class gPADInterim</p></a></li>
<li><a href='#graphMCP-class'><p>Class graphMCP</p></a></li>
<li><a href='#graphTest'><p>Multiple testing using graphs</p></a></li>
<li><a href='#hGraph'><p>Create multiplicity graphs using ggplot2</p></a></li>
<li><a href='#joinGraphs'><p>Joins two graphMCP objects</p></a></li>
<li><a href='#matrix2graph'><p>Matrix2Graph and Graph2Matrix</p></a></li>
<li><a href='#parametric.test'><p>Weighted parametric test</p></a></li>
<li><a href='#permutations'><p>Permutation for a design matrix</p></a></li>
<li><a href='#placeNodes'><p>Placement of graph nodes</p></a></li>
<li><a href='#rejectNode'><p>Rejects a node/hypothesis and updates the graph accordingly.</p></a></li>
<li><a href='#replaceVariables'><p>Replaces variables in a general graph with specified numeric values</p></a></li>
<li><a href='#simConfint'><p>Simultaneous confidence intervals for sequentially rejective multiple test</p>
procedures</a></li>
<li><a href='#simes.on.subsets.test'><p>Simes on subsets, otherwise Bonferroni</p></a></li>
<li><a href='#simes.test'><p>Weighted Simes test</p></a></li>
<li><a href='#subgraph'><p>Get a subgraph</p></a></li>
<li><a href='#substituteEps'><p>Substitute Epsilon</p></a></li>
<li><a href='#weighted.test.functions'><p>Weighted Test Functions for use with gMCP</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Lightweight Graph Based Multiple Comparison Procedures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>A lightweight fork of 'gMCP' with functions for graphical
    described multiple test procedures introduced in
    Bretz et al. (2009) &lt;<a href="https://doi.org/10.1002%2Fsim.3495">doi:10.1002/sim.3495</a>&gt; and
    Bretz et al. (2011) &lt;<a href="https://doi.org/10.1002%2Fbimj.201000239">doi:10.1002/bimj.201000239</a>&gt;.
    Implements a flexible function using 'ggplot2' to create
    multiplicity graph visualizations.
    Contains instructions of multiplicity graph and graphical testing for
    group sequential design, described in
    Maurer and Bretz (2013) &lt;<a href="https://doi.org/10.1080%2F19466315.2013.807748">doi:10.1080/19466315.2013.807748</a>&gt;,
    with necessary unit testing using 'testthat'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://merck.github.io/gMCPLite/">https://merck.github.io/gMCPLite/</a>,
<a href="https://github.com/Merck/gMCPLite">https://github.com/Merck/gMCPLite</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Merck/gMCPLite/issues">https://github.com/Merck/gMCPLite/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, graphics, grDevices, grid, MASS, methods, mvtnorm,
stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, gridExtra, gsDesign, gt, kableExtra, knitr,
multcomp, ragg, rmarkdown, scales, testthat (&ge; 3.0.0), tibble</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-11 18:44:54 UTC; xiaonan4</td>
</tr>
<tr>
<td>Author:</td>
<td>Yalin Zhu <a href="https://orcid.org/0000-0003-3830-8660"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Yilong Zhang [aut],
  Xuan Deng [aut],
  Keaven Anderson [aut],
  Nan Xiao <a href="https://orcid.org/0000-0002-0250-5673"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Kornelius Rohmeyer [ctb] (gMCP author),
  Florian Klinglmueller [ctb] (gMCP author),
  gMCP project contributors [cph] (gMCP package),
  Merck &amp; Co., Inc., Rahway, NJ, USA and its affiliates [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nan Xiao &lt;nan.xiao1@merck.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-11 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gMCPLite-package'>gMCPLite: Lightweight Graph Based Multiple Comparison Procedures</h2><span id='topic+gMCPLite'></span><span id='topic+gMCPLite-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A lightweight fork of 'gMCP' with functions for graphical described multiple test procedures introduced in Bretz et al. (2009) <a href="https://doi.org/10.1002/sim.3495">doi:10.1002/sim.3495</a> and Bretz et al. (2011) <a href="https://doi.org/10.1002/bimj.201000239">doi:10.1002/bimj.201000239</a>. Implements a flexible function using 'ggplot2' to create multiplicity graph visualizations. Contains instructions of multiplicity graph and graphical testing for group sequential design, described in Maurer and Bretz (2013) <a href="https://doi.org/10.1080/19466315.2013.807748">doi:10.1080/19466315.2013.807748</a>, with necessary unit testing using 'testthat'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nan Xiao <a href="mailto:nan.xiao1@merck.com">nan.xiao1@merck.com</a> (<a href="https://orcid.org/0000-0002-0250-5673">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Yalin Zhu <a href="mailto:yalin.zhu@outlook.com">yalin.zhu@outlook.com</a> (<a href="https://orcid.org/0000-0003-3830-8660">ORCID</a>)
</p>
</li>
<li><p> Yilong Zhang <a href="mailto:elong0527@gmail.com">elong0527@gmail.com</a>
</p>
</li>
<li><p> Xuan Deng <a href="mailto:xuan.deng@merck.com">xuan.deng@merck.com</a>
</p>
</li>
<li><p> Keaven Anderson <a href="mailto:keaven_anderson@merck.com">keaven_anderson@merck.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a> (gMCP author) [contributor]
</p>
</li>
<li><p> Florian Klinglmueller <a href="mailto:float@lefant.net">float@lefant.net</a> (gMCP author) [contributor]
</p>
</li>
<li><p> gMCP project contributors (gMCP package) [copyright holder]
</p>
</li>
<li><p> Merck &amp; Co., Inc., Rahway, NJ, USA and its affiliates [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://merck.github.io/gMCPLite/">https://merck.github.io/gMCPLite/</a>
</p>
</li>
<li> <p><a href="https://github.com/Merck/gMCPLite">https://github.com/Merck/gMCPLite</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Merck/gMCPLite/issues">https://github.com/Merck/gMCPLite/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bdiagNA'>Create a Block Diagonal Matrix with NA outside the diagonal</h2><span id='topic+bdiagNA'></span>

<h3>Description</h3>

<p>Build a block diagonal matrix with NA values outside the diagonal given
several building block matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdiagNA(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdiagNA_+3A_...">...</code></td>
<td>
<p>individual matrices or a <code>list</code> of matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful to build the correlation matrices, when only
partial knowledge of the correlation exists.
</p>


<h3>Value</h3>

<p>A block diagonal matrix with NA values outside the diagonal.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gMCP">gMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bdiagNA(diag(3), matrix(1/2,nr=3,nc=3), diag(2))

</code></pre>

<hr>
<h2 id='bonferroni.test'>Weighted Bonferroni-test</h2><span id='topic+bonferroni.test'></span>

<h3>Description</h3>

<p>Weighted Bonferroni-test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bonferroni.test(
  pvalues,
  weights,
  alpha = 0.05,
  adjPValues = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bonferroni.test_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values.</p>
</td></tr>
<tr><td><code id="bonferroni.test_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code id="bonferroni.test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> is not used.</p>
</td></tr>
<tr><td><code id="bonferroni.test_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default) an adjusted p-value for the weighted Bonferroni-test is returned.
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</td></tr>
<tr><td><code id="bonferroni.test_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="bonferroni.test_+3A_...">...</code></td>
<td>
<p>Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adjusted p-value or decision of rejection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bonferroni.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0))
bonferroni.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE)

</code></pre>

<hr>
<h2 id='bonferroni.trimmed.simes.test'>Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test</h2><span id='topic+bonferroni.trimmed.simes.test'></span>

<h3>Description</h3>

<p>Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bonferroni.trimmed.simes.test(
  pvalues,
  weights,
  alpha = 0.05,
  adjPValues = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values.</p>
</td></tr>
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> is not used.</p>
</td></tr>
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default) an adjusted p-value for the weighted test is returned.
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</td></tr>
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_...">...</code></td>
<td>
<p>Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adjusted p-value or decision of rejection
</p>


<h3>References</h3>

<p>Brannath, W., Bretz, F., Maurer, W., &amp; Sarkar, S. (2009).
Trimmed Weighted Simes Test for Two One-Sided Hypotheses With Arbitrarily Correlated Test Statistics.
Biometrical Journal, 51(6), 885-898.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bonferroni.trimmed.simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0))
bonferroni.trimmed.simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE)

</code></pre>

<hr>
<h2 id='checkCorrelation'>Check correlation matrix</h2><span id='topic+checkCorrelation'></span>

<h3>Description</h3>

<p>Sanity checks for the correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCorrelation(m, returnMessage = FALSE, na.allowed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkCorrelation_+3A_m">m</code></td>
<td>
<p>TBA</p>
</td></tr>
<tr><td><code id="checkCorrelation_+3A_returnmessage">returnMessage</code></td>
<td>
<p>TBA</p>
</td></tr>
<tr><td><code id="checkCorrelation_+3A_na.allowed">na.allowed</code></td>
<td>
<p>TBA</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks the following properties:
</p>

<ul>
<li><p> Values must be between -1 and 1.
</p>
</li>
<li><p> Diagonal must be equal to 1.
</p>
</li>
<li><p> Matrix must be symmetric.
</p>
</li></ul>



<h3>Value</h3>

<p>Logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='entangledMCP-class'>Class entangledMCP</h2><span id='topic+entangledMCP-class'></span><span id='topic+entangledMCP'></span><span id='topic+print+2CentangledMCP-method'></span><span id='topic+getWeights+2CentangledMCP-method'></span><span id='topic+getMatrices'></span><span id='topic+getMatrices+2CentangledMCP-method'></span><span id='topic+getRejected+2CentangledMCP-method'></span><span id='topic+getXCoordinates+2CentangledMCP-method'></span><span id='topic+getYCoordinates+2CentangledMCP-method'></span><span id='topic+getNodes+2CentangledMCP-method'></span>

<h3>Description</h3>

<p>A entangledMCP object describes ... TODO
</p>


<h3>Slots</h3>


<dl>
<dt><code>subgraphs</code></dt><dd><p>A list of graphs of class graphMCP.</p>
</dd>
<dt><code>weights</code></dt><dd><p>A numeric.</p>
</dd>
<dt><code>graphAttr</code></dt><dd><p>A list for graph attributes like color, etc.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(object = "entangledMCP")</code>: A method for printing the data of the entangled graph to the R console.</p>
</dd>
<dt>getMatrices</dt><dd><p><code>signature(object = "entangledMCP")</code>: A method for getting the list of transition matrices of the entangled graph.</p>
</dd>
<dt>getWeights</dt><dd><p><code>signature(object = "entangledMCP")</code>: A method for getting the matrix of weights of the entangled graph.</p>
</dd>
<dt>getRejected</dt><dd><p><code>signature(object = "entangledMCP")</code>:
A method for getting the information whether the hypotheses are marked in the graph as already rejected.
If a second optional argument <code>node</code> is specified, only for these nodes the boolean vector will be returned.</p>
</dd>
<dt>getXCoordinates</dt><dd><p><code>signature(object = "entangledMCP")</code>:
A method for getting the x coordinates of the graph.
If a second optional argument <code>node</code> is specified, only for these nodes the x coordinates will be returned.
If x coordinates are not yet set, <code>NULL</code> is returned.</p>
</dd>
<dt>getYCoordinates</dt><dd><p><code>signature(object = "entangledMCP")</code>:
A method for getting the y coordinates of the graph
If a second optional argument <code>node</code> is specified, only for these nodes the x coordinates will be returned.
If y coordinates are not yet set, <code>NULL</code> is returned.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP-class">graphMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- BonferroniHolm(2)
g2 &lt;- BonferroniHolm(2)

graph &lt;- new("entangledMCP", subgraphs=list(g1,g2), weights=c(0.5,0.5))

getMatrices(graph)
getWeights(graph)
</code></pre>

<hr>
<h2 id='exampleGraphs'>Functions that create different example graphs</h2><span id='topic+exampleGraphs'></span><span id='topic+BonferroniHolm'></span><span id='topic+BretzEtAl2011'></span><span id='topic+parallelGatekeeping'></span><span id='topic+improvedParallelGatekeeping'></span><span id='topic+HommelEtAl2007'></span><span id='topic+HommelEtAl2007Simple'></span><span id='topic+HungEtWang2010'></span><span id='topic+MaurerEtAl1995'></span><span id='topic+improvedFallbackI'></span><span id='topic+improvedFallbackII'></span><span id='topic+cycleGraph'></span><span id='topic+fixedSequence'></span><span id='topic+generalSuccessive'></span><span id='topic+simpleSuccessiveI'></span><span id='topic+simpleSuccessiveII'></span><span id='topic+truncatedHolm'></span><span id='topic+fallback'></span><span id='topic+HuqueAloshEtBhore2011'></span><span id='topic+BauerEtAl2001'></span><span id='topic+BretzEtAl2009a'></span><span id='topic+BretzEtAl2009b'></span><span id='topic+BretzEtAl2009c'></span><span id='topic+Ferber2011'></span><span id='topic+Entangled1Maurer2012'></span><span id='topic+Entangled2Maurer2012'></span><span id='topic+FerberTimeDose2011'></span><span id='topic+WangTing2014'></span>

<h3>Description</h3>

<p>Functions that creates example graphs, e.g. graphs that represents a
Bonferroni-Holm adjustment, parallel gatekeeping or special procedures from
selected papers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BonferroniHolm(n, weights = rep(1/n, n))

BretzEtAl2011()

BauerEtAl2001()

BretzEtAl2009a()

BretzEtAl2009b()

BretzEtAl2009c()

HommelEtAl2007()

HommelEtAl2007Simple()

parallelGatekeeping()

improvedParallelGatekeeping()

fallback(weights)

fixedSequence(n)

simpleSuccessiveI()

simpleSuccessiveII()

truncatedHolm(gamma)

generalSuccessive(weights = c(1/2, 1/2), gamma, delta)

HuqueAloshEtBhore2011()

HungEtWang2010(nu, tau, omega)

MaurerEtAl1995()

cycleGraph(nodes, weights)

improvedFallbackI(weights = rep(1/3, 3))

improvedFallbackII(weights = rep(1/3, 3))

FerberTimeDose2011(times, doses, w = "\\nu")

Ferber2011(w)

Entangled1Maurer2012()

Entangled2Maurer2012()

WangTing2014(nu, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exampleGraphs_+3A_n">n</code></td>
<td>
<p>Number of hypotheses.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of node weights.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_gamma">gamma</code></td>
<td>
<p>An optional number in [0,1] specifying the value for variable gamma.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_delta">delta</code></td>
<td>
<p>An optional number in [0,1] specifying the value for variable delta.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_nu">nu</code></td>
<td>
<p>An optional number in [0,1] specifying the value for variable nu.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_tau">tau</code></td>
<td>
<p>An optional number in [0,1] specifying the value for variable tau.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_omega">omega</code></td>
<td>
<p>An optional number in [0,1] specifying the value for variable omega.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_nodes">nodes</code></td>
<td>
<p>Character vector of node names.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_times">times</code></td>
<td>
<p>Number of time points.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_doses">doses</code></td>
<td>
<p>Number of dose levels.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_w">w</code></td>
<td>
<p>Further variable weight(s) in graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We are providing functions and not the resulting graphs directly because
this way you have additional examples: You can look at the function body
with <code><a href="base.html#topic+body">body</a></code> and see how the graph is built.
</p>
 <dl>
<dt>list(&quot;BonferroniHolm&quot;)</dt><dd><p> Returns a graph that represents a
Bonferroni-Holm adjustment.  The result is a complete graph, where all nodes
have the same weights and each edge weight is <code class="reqn">\frac{1}{n-1}</code>.
</p>
</dd> <dt>list(&quot;BretzEtAl2011&quot;)</dt><dd><p> Graph in figure 2 from Bretz et al. See
references (Bretz et al. 2011).  </p>
</dd> <dt>list(&quot;HommelEtAl2007&quot;)</dt><dd><p> Graph from
Hommel et al. See references (Hommel et al. 2007).  </p>
</dd>
<dt>list(&quot;parallelGatekeeping&quot;)</dt><dd><p> Graph for parallel gatekeeping. See
references (Dmitrienko et al. 2003).  </p>
</dd>
<dt>list(&quot;improvedParallelGatekeeping&quot;)</dt><dd><p> Graph for improved parallel
gatekeeping. See references (Hommel et al. 2007).  </p>
</dd>
<dt>list(&quot;HungEtWang2010&quot;)</dt><dd><p> Graph from Hung et Wang. See references (Hung
et Wang 2010).  </p>
</dd> <dt>list(&quot;MaurerEtAl1995&quot;)</dt><dd><p> Graph from Maurer et al.
See references (Maurer et al. 1995).  </p>
</dd> <dt>list(&quot;cycleGraph&quot;)</dt><dd><p> Cycle
graph. The weight <code>weights[i]</code> specifies the edge weight from node
<code class="reqn">i</code> to node <code class="reqn">i+1</code> for <code class="reqn">i=1,\ldots,n-1</code> and
<code>weight[n]</code> from node <code class="reqn">n</code> to node 1.  </p>
</dd>
<dt>list(&quot;improvedFallbackI&quot;)</dt><dd><p> Graph for the improved Fallback Procedure
by Wiens &amp; Dmitrienko. See references (Wiens et Dmitrienko 2005).  </p>
</dd>
<dt>list(&quot;improvedFallbackII&quot;)</dt><dd><p> Graph for the improved Fallback Procedure
by Hommel &amp; Bretz. See references (Hommel et Bretz 2008).  </p>
</dd>
<dt>list(&quot;Ferber2011&quot;)</dt><dd><p> Graph from Ferber et al. See references (Ferber
et al. 2011).  </p>
</dd> <dt>list(&quot;FerberTimeDose2011&quot;)</dt><dd><p> Graph from Ferber et al.
See references (Ferber et al. 2011).  </p>
</dd> <dt>list(&quot;Entangled1Maurer2012&quot;)</dt><dd>
<p>Entangled graph from Maurer et al. TODO: Add references as soon as they are
available.  </p>
</dd> </dl>



<h3>Value</h3>

<p>A graph of class <code>graphMCP</code> that represents a
sequentially rejective multiple test procedure.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Holm, S. (1979). A simple sequentially rejective multiple test
procedure. Scandinavian Journal of Statistics 6, 65-70.
</p>
<p>Dmitrienko, A., Offen, W., Westfall, P.H. (2003). Gatekeeping strategies for
clinical trials that do not require all primary effects to be significant.
Statistics in Medicine. 22, 2387-2400.
</p>
<p>Bretz, F., Maurer, W., Brannath, W., Posch, M.: A graphical approach to
sequentially rejective multiple test procedures. Statistics in Medicine 2009
vol. 28 issue 4 page 586-604.
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>
<p>Bretz, F., Maurer, W. and Hommel, G. (2011), Test and power considerations
for multiple endpoint analyses using sequentially rejective graphical
procedures. Statistics in Medicine, 30: 1489&ndash;1501.
</p>
<p>Hommel, G., Bretz, F. und Maurer, W. (2007). Powerful short-cuts for
multiple testing procedures with special reference to gatekeeping
strategies. Statistics in Medicine, 26(22), 4063-4073.
</p>
<p>Hommel, G., Bretz, F. (2008): Aesthetics and power considerations in
multiple testing - a contradiction? Biometrical Journal 50:657-666.
</p>
<p>Hung H.M.J., Wang S.-J. (2010). Challenges to multiple testing in clinical
trials. Biometrical Journal 52, 747-756.
</p>
<p>W. Maurer, L. Hothorn, W. Lehmacher: Multiple comparisons in drug clinical
trials and preclinical assays: a-priori ordered hypotheses. In Biometrie in
der chemisch-pharmazeutischen Industrie, Vollmar J (ed.). Fischer Verlag:
Stuttgart, 1995; 3-18.
</p>
<p>Maurer, W., &amp; Bretz, F. (2013). Memory and other properties of multiple test
procedures generated by entangled graphs. Statistics in medicine, 32 (10), 1739-1753.
</p>
<p>Wiens, B.L., Dmitrienko, A. (2005): The fallback procedure for evaluating a
single family of hypotheses. Journal of Biopharmaceutical Statistics
15:929-942.
</p>
<p>Wang, B., Ting, N. (2014). An Application of Graphical Approach to
Construct Multiple Testing Procedures in a Hypothetical Phase III Design.
Frontiers in public health, 1 (75).
</p>
<p>Ferber, G. Staner, L. and Boeijinga, P. (2011): Structured multiplicity and
confirmatory statistical analyses in pharmacodynamic studies using the
quantitative electroencephalogram, Journal of neuroscience methods, Volume
201, Issue 1, Pages 204-212.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- BonferroniHolm(5)

gMCP(g, pvalues=c(0.1, 0.2, 0.4, 0.4, 0.7))

HungEtWang2010()
HungEtWang2010(nu=1)

</code></pre>

<hr>
<h2 id='generatePvals'>generatePvals</h2><span id='topic+generatePvals'></span>

<h3>Description</h3>

<p>compute adjusted p-values either for the closed test defined by the graph or
for each elementary hypotheses within each intersection hypotheses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePvals(
  g,
  w,
  cr,
  p,
  adjusted = TRUE,
  hint = generateWeights(g, w),
  upscale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatePvals_+3A_g">g</code></td>
<td>
<p>graph defined as a matrix, each element defines how much of the
local alpha reserved for the hypothesis corresponding to its row index is
passed on to the hypothesis corresponding to its column index</p>
</td></tr>
<tr><td><code id="generatePvals_+3A_w">w</code></td>
<td>
<p>vector of weights, defines how much of the overall alpha is
initially reserved for each elementary hypothesis</p>
</td></tr>
<tr><td><code id="generatePvals_+3A_cr">cr</code></td>
<td>
<p>correlation matrix if p-values arise from one-sided tests with
multivariate normal distributed test statistics for which the correlation is
partially known. Unknown values can be set to NA. (See details for more
information)</p>
</td></tr>
<tr><td><code id="generatePvals_+3A_p">p</code></td>
<td>
<p>vector of observed unadjusted p-values, that belong to
test-statistics with a joint multivariate normal null distribution with
(partially) known correlation matrix <code>cr</code></p>
</td></tr>
<tr><td><code id="generatePvals_+3A_adjusted">adjusted</code></td>
<td>
<p>logical, if TRUE (default) adjusted p-values for the closed
test are returned, else a matrix of p-values adjusted only for each
intersection hypothesis is returned</p>
</td></tr>
<tr><td><code id="generatePvals_+3A_hint">hint</code></td>
<td>
<p>if intersection hypotheses weights have already been computed
(output of <code><a href="#topic+generateWeights">generateWeights</a></code>) can be passed here otherwise will
be computed during execution</p>
</td></tr>
<tr><td><code id="generatePvals_+3A_upscale">upscale</code></td>
<td>
<p>if <code>FALSE</code> (default) the p-values are additionally
adjusted for the case that non-exhaustive weights are specified. (See
details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that under the global null hypothesis
<code class="reqn">(\Phi^{-1}(1-p_1),...,\Phi^{-1}(1-p_m))</code> follow a multivariate normal
distribution with correlation matrix <code>cr</code> where <code class="reqn">\Phi^{-1}</code> denotes
the inverse of the standard normal distribution function.
</p>
<p>For example, this is the case if <code class="reqn">p_1,..., p_m</code> are the raw p-values
from one-sided z-tests for each of the elementary hypotheses where the
correlation between z-test statistics is generated by an overlap in the
observations (e.g. comparison with a common control, group-sequential
analyses etc.). An application of the transformation <code class="reqn">\Phi^{-1}(1-p_i)</code>
to raw p-values from a two-sided test will not in general lead to a
multivariate normal distribution. Partial knowledge of the correlation
matrix is supported. The correlation matrix has to be passed as a numeric
matrix with elements of the form: <code class="reqn">cr[i,i] = 1</code> for diagonal elements,
<code class="reqn">cr[i,j] = \rho_{ij}</code>, where <code class="reqn">\rho_{ij}</code> is the known value of the
correlation between <code class="reqn">\Phi^{-1}(1-p_i)</code> and <code class="reqn">\Phi^{-1}(1-p_j)</code> or
<code>NA</code> if the corresponding correlation is unknown. For example cr[1,2]=0
indicates that the first and second test statistic are uncorrelated, whereas
cr[2,3] = NA means that the true correlation between statistics two and
three is unknown and may take values between -1 and 1. The correlation has
to be specified for complete blocks (ie.: if cor(i,j), and cor(i,k) for
i!=j!=k are specified then cor(j,k) has to be specified as well) otherwise
the corresponding intersection null hypotheses tests are not uniquely
defined and an error is returned.
</p>
<p>The parametric tests in (Bretz et al. (2011)) are defined such that the
tests of intersection null hypotheses always exhaust the full alpha level
even if the sum of weights is strictly smaller than one. This has the
consequence that certain test procedures that do not test each intersection
null hypothesis at the full level alpha may not be implemented (e.g., a
single step Dunnett test). If <code>upscale</code> is set to <code>FALSE</code>
(default) the parametric tests are performed at a reduced level alpha of
sum(w) * alpha and p-values adjusted accordingly such that test procedures
with non-exhaustive weighting strategies may be implemented. If set to
<code>TRUE</code> the tests are performed as defined in Equation (3) of (Bretz et
al. (2011)).
</p>


<h3>Value</h3>

<p>If adjusted is set to true returns a vector of adjusted p-values.
Any elementary null hypothesis is rejected if its corresponding adjusted
p-value is below the predetermined alpha level. For adjusted set to false a
matrix with p-values adjusted only within each intersection hypotheses is
returned.  The intersection corresponding to each line is given by
conversion of the line number into binary (eg. 13 is binary 1101 and
corresponds to (H1,H2,H4)). If any adjusted p-value within a given line
falls below alpha, then the corresponding intersection hypotheses can be
rejected.
</p>


<h3>Author(s)</h3>

<p>Florian Klinglmueller
</p>


<h3>References</h3>

<p>Bretz F, Maurer W, Brannath W, Posch M; (2008) - A graphical
approach to sequentially rejective multiple testing procedures. - Stat Med -
28/4, 586-604 Bretz F, Posch M, Glimm E, Klinglmueller F, Maurer W, Rohmeyer
K; (2011) - Graphical approaches for multiple endpoint problems using
weighted Bonferroni, Simes or parametric tests - to appear
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Define some graph as matrix
g &lt;- matrix(c(0,0,1,0, 0,0,0,1, 0,1,0,0, 1,0,0,0), nrow = 4, byrow=TRUE)
## Choose weights
w &lt;- c(.5,.5,0,0)
## Some correlation (upper and lower first diagonal 1/2)
c &lt;- diag(4)
c[1:2,3:4] &lt;- NA
c[3:4,1:2] &lt;- NA
c[1,2] &lt;- 1/2
c[2,1] &lt;- 1/2
c[3,4] &lt;- 1/2
c[4,3] &lt;- 1/2
## p-values as Section 3 of Bretz et al. (2011),
p &lt;- c(0.0121,0.0337,0.0084,0.0160)

## Boundaries for correlated test statistics at alpha level .05:
generatePvals(g,w,c,p)

g &lt;- Entangled2Maurer2012()
generatePvals(g=g, cr=diag(5), p=rep(0.1,5))

</code></pre>

<hr>
<h2 id='generateWeights'>generateWeights</h2><span id='topic+generateWeights'></span>

<h3>Description</h3>

<p>compute Weights for each intersection Hypotheses in the closure of a graph
based multiple testing procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateWeights(g, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateWeights_+3A_g">g</code></td>
<td>
<p>Graph either defined as a matrix (each element defines how much of the
local alpha reserved for the hypothesis corresponding to its row index is
passed on to the hypothesis corresponding to its column index), as <code>graphMCP</code>
object or as <code>entangledMCP</code> object.</p>
</td></tr>
<tr><td><code id="generateWeights_+3A_w">w</code></td>
<td>
<p>Vector of weights, defines how much of the overall alpha is
initially reserved for each elementary hypothesis. Can be missing if <code>g</code>
is a <code>graphMCP</code> object (in which case the weights from the graph object are used).
Will be ignored if <code>g</code> is an <code>entangledMCP</code> object (since then the matrix
of weights from this object is used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns matrix with each row corresponding to one intersection
hypothesis in the closure of the multiple testing problem. The first half of
elements indicate whether an elementary hypotheses is in the intersection
(1) or not (0). The second half of each row gives the weights allocated to
each elementary hypotheses in the intersection.
</p>


<h3>Author(s)</h3>

<p>Florian Klinglmueller &lt;float@lefant.net&gt;, Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Bretz F, Maurer W, Brannath W, Posch M; (2008) - A graphical
approach to sequentially rejective multiple testing procedures. - Stat Med -
28/4, 586-604 Bretz F, Posch M, Glimm E, Klinglmueller F, Maurer W, Rohmeyer
K; (2011) - Graphical approaches for multiple endpoint problems using
weighted Bonferroni, Simes or parametric tests - to appear
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 g &lt;- matrix(c(0,0,1,0,
               0,0,0,1,
               0,1,0,0,
               1,0,0,0), nrow = 4,byrow=TRUE)
 ## Choose weights
 w &lt;- c(.5,.5,0,0)
 ## Weights of conventional gMCP test:
 generateWeights(g,w)

g &lt;- Entangled2Maurer2012()
generateWeights(g)

</code></pre>

<hr>
<h2 id='gMCP'>Graph based Multiple Comparison Procedures</h2><span id='topic+gMCP'></span>

<h3>Description</h3>

<p>Performs a graph based multiple test procedure for a given graph and
unadjusted p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gMCP(
  graph,
  pvalues,
  test,
  correlation,
  alpha = 0.05,
  approxEps = TRUE,
  eps = 10^(-3),
  ...,
  upscale = ifelse(missing(test) &amp;&amp; !missing(correlation) || !missing(test) &amp;&amp; test ==
    "Bretz2011", TRUE, FALSE),
  useC = FALSE,
  verbose = FALSE,
  keepWeights = FALSE,
  adjPValues = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gMCP_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code>graphMCP</code>.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values for the graph based
MCP. Note the assumptions in the details section for the parametric tests,
when a correlation is specified.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_test">test</code></td>
<td>
<p>Should be either <code>"Bonferroni"</code>, <code>"Simes"</code> or <code>"parametric"</code>.
If not specified by default the Bonferroni-based test procedure is used if no
correlation is specified or the algorithm from Bretz et al. 2011 if a
correlation is specified. If <code>test</code> is set to <code>"Simes"</code> the weighted
Simes test will be performed for each subset of hypotheses.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_correlation">correlation</code></td>
<td>
<p>Optional correlation matrix.  If the weighted Simes test
is performed, it is checked whether type I error rate can be ensured and a
warning is given if this is not the case.  For parametric tests the p-values
must arise from one-sided tests with multivariate normal distributed test
statistics for which the correlation is (partially) known. In that case a
weighted parametric closed test is performed (also see
<code><a href="#topic+generatePvals">generatePvals</a></code>). Unknown values can be set to NA. (See details
for more information)</p>
</td></tr>
<tr><td><code id="gMCP_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_approxeps">approxEps</code></td>
<td>
<p>A boolean specifying whether epsilon values should be
substituted with the value given in the parameter <code>eps</code>.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_eps">eps</code></td>
<td>
<p>A numeric scalar specifying a value for epsilon edges.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_...">...</code></td>
<td>
<p>Test specific arguments can be given here.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_upscale">upscale</code></td>
<td>
<p>Logical. If <code>upscale=FALSE</code> then for each intersection
of hypotheses (i.e. each subgraph) a weighted test is performed at the
possibly reduced level alpha of sum(w)*alpha,
where sum(w) is the sum of all node weights in this subset.
If <code>upscale=TRUE</code> all weights are upscaled, so that sum(w)=1.
</p>
<p>For backward compatibility the default value is TRUE if a the parameter <code>test</code>
is missing, but parameter <code>correlation</code> is specified or if <code>test=="Bretz2011"</code>.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_usec">useC</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> neither adjusted p-values nor
intermediate graphs are returned, but the calculation is sped up by using
code written in C. THIS CODE IS NOT FOR PRODUCTIVE USE YET!  If approxEps is
<code>FALSE</code> and the graph contains epsilon edges, a warning is thrown and
<code>useC</code> will be ignored.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_keepweights">keepWeights</code></td>
<td>
<p>Logical scalar. If <code>FALSE</code> the weight of a node
without outgoing edges is set to 0 if it is removed.  Otherwise it keeps its
weight.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>FALSE</code> no adjusted p-values will
be calculated.  Especially for the weighted Simes test this will result in
significantly less calculations in most cases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the Bonferroni procedure the p-values can arise from any statistical
test, but if you improve the test by specifying a correlation matrix, the
following assumptions apply:
</p>
<p>It is assumed that under the global null hypothesis
<code class="reqn">(\Phi^{-1}(1-p_1),...,\Phi^{-1}(1-p_m))</code> follow a multivariate normal
distribution with correlation matrix <code>correlation</code> where
<code class="reqn">\Phi^{-1}</code> denotes the inverse of the standard normal distribution
function.
</p>
<p>For example, this is the case if <code class="reqn">p_1,..., p_m</code> are the raw p-values
from one-sided z-tests for each of the elementary hypotheses where the
correlation between z-test statistics is generated by an overlap in the
observations (e.g. comparison with a common control, group-sequential
analyses etc.). An application of the transformation <code class="reqn">\Phi^{-1}(1-p_i)</code>
to raw p-values from a two-sided test will not in general lead to a
multivariate normal distribution. Partial knowledge of the correlation
matrix is supported. The correlation matrix has to be passed as a numeric
matrix with elements of the form: <code class="reqn">correlation[i,i] = 1</code> for diagonal
elements, <code class="reqn">correlation[i,j] = \rho_{ij}</code>, where <code class="reqn">\rho_{ij}</code> is the
known value of the correlation between <code class="reqn">\Phi^{-1}(1-p_i)</code> and
<code class="reqn">\Phi^{-1}(1-p_j)</code> or <code>NA</code> if the corresponding correlation is
unknown. For example correlation[1,2]=0 indicates that the first and second
test statistic are uncorrelated, whereas correlation[2,3] = NA means that
the true correlation between statistics two and three is unknown and may
take values between -1 and 1. The correlation has to be specified for
complete blocks (ie.: if cor(i,j), and cor(i,j') for i!=j!=j' are specified
then cor(j,j') has to be specified as well) otherwise the corresponding
intersection null hypotheses tests are not uniquely defined and an error is
returned.
</p>
<p>For further details see the given references.
</p>


<h3>Value</h3>

<p>An object of class <code>gMCPResult</code>, more specifically a list with
elements
</p>

<dl>
<dt><code>graphs</code></dt><dd><p>list of graphs</p>
</dd>
<dt><code>pvalues</code></dt><dd><p>p-values</p>
</dd>
<dt><code>rejected</code></dt><dd><p>logical whether hypotheses could be rejected</p>
</dd>
<dt><code>adjPValues</code></dt><dd><p>adjusted p-values</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: A
graphical approach to sequentially rejective multiple test procedures.
Statistics in Medicine 2009 vol. 28 issue 4 page 586-604.
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>
<p>Bretz F., Posch M., Glimm E., Klinglmueller F., Maurer W., Rohmeyer K.
(2011): Graphical approaches for multiple endpoint problems using weighted
Bonferroni, Simes or parametric tests. Biometrical Journal 53 (6),
pages 894-913, Wiley.
<a href="https://doi.org/10.1002/bimj.201000239">doi:10.1002/bimj.201000239</a>
</p>
<p>Strassburger K., Bretz F.: Compatible simultaneous lower confidence bounds
for the Holm procedure and other Bonferroni based closed tests. Statistics
in Medicine 2008; 27:4914-4927.
</p>
<p>Hommel G., Bretz F., Maurer W.: Powerful short-cuts for multiple testing
procedures with special reference to gatekeeping strategies. Statistics in
Medicine 2007; 26:4063-4073.
</p>
<p>Guilbaud O.: Simultaneous confidence regions corresponding to Holm's
stepdown procedure and other closed-testing procedures. Biometrical Journal
2008; 50:678-692.
</p>


<h3>See Also</h3>

<p><code>graphMCP</code> <code><a href="multcomp.html#topic+contrMat">multcomp::contrMat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- BonferroniHolm(5)
gMCP(g, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7))
# Simple Bonferroni with empty graph:
g2 &lt;- matrix2graph(matrix(0, nrow=5, ncol=5))
gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7))
# With 'upscale=TRUE' equal to BonferroniHolm:
gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7), upscale=TRUE)

</code></pre>

<hr>
<h2 id='gMCP.extended'>Graph based Multiple Comparison Procedures</h2><span id='topic+gMCP.extended'></span>

<h3>Description</h3>

<p>Performs a graph based multiple test procedure for a given graph and unadjusted p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gMCP.extended(
  graph,
  pvalues,
  test,
  alpha = 0.05,
  eps = 10^(-3),
  upscale = FALSE,
  verbose = FALSE,
  adjPValues = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gMCP.extended_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code>graphMCP</code>.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values for the graph based
MCP. Note the assumptions in the description of the selected test (if there are any -
for example <code>test=bonferroni.test</code> has no further assumptions, but
<code>test=parametric.test</code> assumes p-values from a multivariate normal distribution).</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_test">test</code></td>
<td>
<p>A weighted test function.
</p>
<p>The package gMCP provides the following weighted test functions:
</p>

<dl>
<dt>bonferroni.test</dt><dd><p>Bonferroni test - see <code>?bonferroni.test</code> for details.</p>
</dd>
<dt>parametric.test</dt><dd><p>Parametric test - see <code>?parametric.test</code> for details.</p>
</dd>
<dt>simes.test</dt><dd><p>Simes test - see <code>?simes.test</code> for details.</p>
</dd>
<dt>bonferroni.trimmed.simes.test</dt><dd><p>Trimmed Simes test for intersections of two hypotheses and otherwise Bonferroni - see <code>?bonferroni.trimmed.simes.test</code> for details.</p>
</dd>
<dt>simes.on.subsets.test</dt><dd><p>Simes test for intersections of hypotheses from certain sets and otherwise Bonferroni - see <code>?simes.on.subsets.test</code> for details.</p>
</dd>
</dl>

<p>To provide your own test function see <code>?weighted.test.function</code>.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_eps">eps</code></td>
<td>
<p>A numeric scalar specifying a value for epsilon edges.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_upscale">upscale</code></td>
<td>
<p>Logical. If <code>upscale=FALSE</code> then for each intersection
of hypotheses (i.e. each subgraph) a weighted test is performed at the
possibly reduced level alpha of sum(w)*alpha,
where sum(w) is the sum of all node weights in this subset.
If <code>upscale=TRUE</code> all weights are upscaled, so that sum(w)=1.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated
during sequentially rejection steps.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>FALSE</code> no adjusted p-values will
be calculated. Especially for the weighted Simes test this will result in
significantly less calculations in most cases.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_...">...</code></td>
<td>
<p>Test specific arguments can be given here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gMCPResult</code>, more specifically a list with
elements
</p>

<dl>
<dt><code>graphs</code></dt><dd><p>list of graphs</p>
</dd>
<dt><code>pvalues</code></dt><dd><p>p-values</p>
</dd>
<dt><code>rejected</code></dt><dd><p>logical whether hypotheses could be rejected</p>
</dd>
<dt><code>adjPValues</code></dt><dd><p>adjusted p-values</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: A
graphical approach to sequentially rejective multiple test procedures.
Statistics in Medicine 2009 vol. 28 issue 4 page 586-604.
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>
<p>Bretz F., Posch M., Glimm E., Klinglmueller F., Maurer W., Rohmeyer K.
(2011): Graphical approaches for multiple endpoint problems using weighted
Bonferroni, Simes or parametric tests. Biometrical Journal 53 (6),
pages 894-913, Wiley.
<a href="https://doi.org/10.1002/bimj.201000239">doi:10.1002/bimj.201000239</a>
</p>
<p>Strassburger K., Bretz F.: Compatible simultaneous lower confidence bounds
for the Holm procedure and other Bonferroni based closed tests. Statistics
in Medicine 2008; 27:4914-4927.
</p>
<p>Hommel G., Bretz F., Maurer W.: Powerful short-cuts for multiple testing
procedures with special reference to gatekeeping strategies. Statistics in
Medicine 2007; 26:4063-4073.
</p>
<p>Guilbaud O.: Simultaneous confidence regions corresponding to Holm's
stepdown procedure and other closed-testing procedures. Biometrical Journal
2008; 50:678-692.
</p>


<h3>See Also</h3>

<p><code>graphMCP</code> <code><a href="multcomp.html#topic+contrMat">multcomp::contrMat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- BonferroniHolm(5)
gMCP(g, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7))
# Simple Bonferroni with empty graph:
g2 &lt;- matrix2graph(matrix(0, nrow=5, ncol=5))
gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7))
# With 'upscale=TRUE' equal to BonferroniHolm:
gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7), upscale=TRUE)

# Entangled graphs:
g3 &lt;- Entangled2Maurer2012()
gMCP(g3, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7), correlation=diag(5))

</code></pre>

<hr>
<h2 id='gMCPResult-class'>Class gMCPResult</h2><span id='topic+gMCPResult-class'></span><span id='topic+gMCPResult'></span><span id='topic+print+2CgMCPResult-method'></span><span id='topic+plot+2CgMCPResult+2CANY-method'></span><span id='topic+plot+2CgMCPResult-method'></span><span id='topic+getWeights+2CgMCPResult-method'></span><span id='topic+getRejected+2CgMCPResult-method'></span>

<h3>Description</h3>

<p>A gMCPResult object describes an evaluated sequentially rejective multiple
test procedure.
</p>


<h3>Slots</h3>


<dl>
<dt><code>graphs</code></dt><dd><p>Object of class <code>list</code>.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A <code>numeric</code> specifying the maximal type I error rate.</p>
</dd>
<dt><code>pvalues</code></dt><dd><p>The <code>numeric</code> vector of p-values.</p>
</dd>
<dt><code>rejected</code></dt><dd><p>The <code>logical</code> vector of rejected null hypotheses.</p>
</dd>
<dt><code>adjPValues</code></dt><dd><p>The <code>numeric</code> vector of adjusted p-values.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gMCP">gMCP</a></code>
</p>

<hr>
<h2 id='gPADInterim-class'>Class gPADInterim</h2><span id='topic+gPADInterim-class'></span><span id='topic+gPADInterim'></span><span id='topic+print+2CgPADInterim-method'></span><span id='topic+plot+2CgPADInterim-method'></span><span id='topic+getWeights+2CgPADInterim-method'></span><span id='topic+getRejected+2CgPADInterim-method'></span>

<h3>Description</h3>

<p>A gPADInterim object describes an object holding interim information for an
adaptive procedure that is based on a preplanned graphical procedure.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Aj</code></dt><dd><p>Object of class <code>numeric</code>. Giving partial
conditional errors (PCEs) for all elementary hypotheses in each
intersection hypothesis </p>
</dd>
<dt><code>BJ</code></dt><dd><p>A <code>numeric</code> specifying the sum of PCEs per
intersection hypothesis.</p>
</dd>
<dt><code>z1</code></dt><dd><p>The <code>numeric</code> vector of first stage
z-scores.</p>
</dd>
<dt><code>v</code></dt><dd><p>A <code>numeric</code> specifying the proportion of
measurements collected up to interim</p>
</dd>
<dt><code>preplanned</code></dt><dd><p>Object of class <code><a href="#topic+graphMCP">graphMCP</a></code>
specifying the preplanned graphical procedure.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A <code>numeric</code> giving the alpha level of the
pre-planned test</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Florian Klinglmueller <a href="mailto:float@lefant.net">float@lefant.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gMCP">gMCP</a></code>
</p>

<hr>
<h2 id='graphMCP-class'>Class graphMCP</h2><span id='topic+graphMCP-class'></span><span id='topic+graphMCP'></span><span id='topic+print+2CgraphMCP-method'></span><span id='topic+plot+2CgraphMCP+2CANY-method'></span><span id='topic+plot+2CgraphMCP-method'></span><span id='topic+getWeights'></span><span id='topic+getWeights+2CgraphMCP-method'></span><span id='topic+getMatrix'></span><span id='topic+getMatrix+2CgraphMCP-method'></span><span id='topic+setWeights'></span><span id='topic+setWeights+2CgraphMCP-method'></span><span id='topic+setRejected+3C-'></span><span id='topic+setRejected+3C-+2CgraphMCP-method'></span><span id='topic+getRejected'></span><span id='topic+getRejected+2CgraphMCP-method'></span><span id='topic+getXCoordinates'></span><span id='topic+getXCoordinates+2CgraphMCP-method'></span><span id='topic+getYCoordinates'></span><span id='topic+getYCoordinates+2CgraphMCP-method'></span><span id='topic+setEdge'></span><span id='topic+setEdge+2Ccharacter+2Ccharacter+2CgraphMCP+2Ccharacter-method'></span><span id='topic+setEdge+2Ccharacter+2Ccharacter+2CgraphMCP+2Cnumeric-method'></span><span id='topic+getNodes'></span><span id='topic+getNodes+2CgraphMCP-method'></span><span id='topic+edgeAttr'></span><span id='topic+edgeAttr+3C-'></span><span id='topic+edgeAttr+2CgraphMCP+2Ccharacter+2Ccharacter+2Ccharacter-method'></span><span id='topic+edgeAttr+3C-+2CgraphMCP+2Ccharacter+2Ccharacter+2Ccharacter-method'></span><span id='topic+nodeAttr'></span><span id='topic+nodeAttr+3C-'></span><span id='topic+nodeAttr+2CgraphMCP+2Ccharacter+2Ccharacter-method'></span><span id='topic+nodeAttr+3C-+2CgraphMCP+2Ccharacter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>A graphMCP object describes a sequentially rejective multiple test
procedure.
</p>


<h3>Slots</h3>


<dl>
<dt><code>m</code></dt><dd><p>A transition matrix. Can be either <code>numerical</code> or
<code>character</code> depending whether the matrix contains variables or not.
Row and column names will be the names of the nodes.</p>
</dd>
<dt><code>weights</code></dt><dd><p>A numeric.</p>
</dd>
<dt><code>edgeAttr</code></dt><dd><p>A list for edge attributes.</p>
</dd>
<dt><code>nodeAttr</code></dt><dd><p>A list for node attributes.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getMatrix</dt><dd><p><code>signature(object = "graphMCP")</code>: A method for getting the transition matrix of the graph.</p>
</dd>
<dt>getWeights</dt><dd><p><code>signature(object = "graphMCP")</code>: A method for getting the weights.
If a third optional argument <code>node</code> is specified, only for these nodes the weight will be returned.</p>
</dd>
<dt>setWeights</dt><dd><p><code>signature(object = "graphMCP")</code>: A method for setting the weights.
If a third optional argument <code>node</code> is specified, only for these nodes the weight will be set.</p>
</dd>
<dt>getRejected</dt><dd><p><code>signature(object = "graphMCP")</code>:
A method for getting the information whether the hypotheses are marked in the graph as already rejected.
If a second optional argument <code>node</code> is specified, only for these nodes the boolean vector will be returned.</p>
</dd>
<dt>getXCoordinates</dt><dd><p><code>signature(object = "graphMCP")</code>:
A method for getting the x coordinates of the graph.
If a second optional argument <code>node</code> is specified, only for these nodes the x coordinates will be returned.
If x coordinates are not set yet <code>NULL</code> is returned.</p>
</dd>
<dt>getYCoordinates</dt><dd><p><code>signature(object = "graphMCP")</code>:
A method for getting the y coordinates of the graph
If a second optional argument <code>node</code> is specified, only for these nodes the x coordinates will be returned.
If y coordinates are not set yet <code>NULL</code> is returned.</p>
</dd>
<dt>setEdge</dt><dd><p><code>signature(from="character", to="character", graph="graphNEL", weights="numeric")</code>:
A method for adding new edges with the given weights.</p>
</dd>
<dt>setEdge</dt><dd><p><code>signature(from="character", to="character", graph="graphMCP", weights="character")</code>:
A method for adding new edges with the given weights.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- rbind(H11=c(0,   0.5, 0,   0.5, 0,   0  ),
			H21=c(1/3, 0,   1/3, 0,   1/3, 0  ),
			H31=c(0,   0.5, 0,   0,   0,   0.5),
			H12=c(0,   1,   0,   0,   0,   0  ),
			H22=c(0.5, 0,   0.5, 0,   0,   0  ),
			H32=c(0,   1,   0,   0,   0,   0  ))

weights &lt;- c(1/3, 1/3, 1/3, 0, 0, 0)

# Graph creation
graph &lt;- new("graphMCP", m=m, weights=weights)

# Visualization settings
nodeX &lt;- rep(c(100, 300, 500), 2)
nodeY &lt;- rep(c(100, 300), each=3)
graph@nodeAttr$X &lt;- nodeX
graph@nodeAttr$Y &lt;- nodeY

getWeights(graph)

getRejected(graph)

pvalues &lt;- c(0.1, 0.008, 0.005, 0.15, 0.04, 0.006)
result &lt;- gMCP(graph, pvalues)

getWeights(result@graphs[[4]])
getRejected(result@graphs[[4]])
</code></pre>

<hr>
<h2 id='graphTest'>Multiple testing using graphs</h2><span id='topic+graphTest'></span>

<h3>Description</h3>

<p>Implements the graphical test procedure described in Bretz et al. (2009).
Note that the gMCP function in the gMCP package performs the same task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphTest(
  pvalues,
  weights = NULL,
  alpha = 0.05,
  G = NULL,
  cr = NULL,
  graph = NULL,
  verbose = FALSE,
  test,
  upscale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphTest_+3A_pvalues">pvalues</code></td>
<td>
<p>Either a vector or a matrix containing the local p-values for
the hypotheses in the rows.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_weights">weights</code></td>
<td>
<p>Initial weight levels for the test procedure, in case of
multiple graphs this needs to be a matrix.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_alpha">alpha</code></td>
<td>
<p>Overall alpha level of the procedure. For entangled graphs
<code>alpha</code> should be a numeric vector of length equal to the number of
graphs, each element specifying the partial alpha for the respective graph.
The overall alpha level equals <code>sum(alpha)</code>.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_g">G</code></td>
<td>
<p>For simple graphs <code>G</code> should be a numeric matrix determining
the graph underlying the test procedure. Note that the diagonal need to
contain only 0s, while the rows need to sum to 1.  For entangled graphs it
needs to be a list containing the different graph matrices as elements.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_cr">cr</code></td>
<td>
<p>Correlation matrix that should be used for the parametric test.
If <code>cr==NULL</code> the Bonferroni based test procedure is used.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_graph">graph</code></td>
<td>
<p>As an alternative to the specification via <code>weights</code> and
<code>G</code> one can also hand over a <code>graphMCP</code> object to the code.
<code>graphMCP</code> objects can be created for example with the <code>graphGUI</code>
function.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_verbose">verbose</code></td>
<td>
<p>If verbose is TRUE, additional information about the
graphical rejection procedure is displayed.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_test">test</code></td>
<td>
<p>In the parametric case there is more than one way to handle
subgraphs with less than the full alpha. If the parameter <code>test</code> is
missing, the tests are performed as described by Bretz et al. (2011), i.e.
tests of intersection null hypotheses always exhaust the full alpha level
even if the sum of weights is strictly smaller than one. If
<code>test="simple-parametric"</code> the tests are performed as defined in
Equation (3) of Bretz et al. (2011).</p>
</td></tr>
<tr><td><code id="graphTest_+3A_upscale">upscale</code></td>
<td>
<p>Logical. If <code>upscale=FALSE</code> then for each intersection
of hypotheses (i.e. each subgraph) a weighted test is performed at the
possibly reduced level alpha of sum(w)*alpha,
where sum(w) is the sum of all node weights in this subset.
If <code>upscale=TRUE</code> all weights are upscaled, so that sum(w)=1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix containing the test results for the hypotheses
under consideration. Significant tests are denoted by a 1, non-significant
results by a 0.
</p>


<h3>References</h3>

<p>Bretz, F., Maurer, W., Brannath, W. and Posch, M. (2009) A graphical
approach to sequentially rejective multiple test procedures. Statistics in
Medicine, 28, 586&ndash;604
</p>
<p>Bretz, F., Maurer, W. and Hommel, G. (2010) Test and power considerations
for multiple endpoint analyses using sequentially rejective graphical
procedures, to appear in Statistics in Medicine
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#### example from Bretz et al. (2010)
weights &lt;- c(1/3, 1/3, 1/3, 0, 0, 0)
graph &lt;- rbind(c(0,       0.5, 0,     0.5, 0,      0),
               c(1/3,     0,   1/3,    0,   1/3,    0),
               c(0,       0.5, 0,     0,   0,      0.5),
               c(0,       1,   0,     0,   0,      0),
               c(0.5,     0,   0.5,   0,   0,      0),
               c(0,       1,   0,     0,   0,      0))
pvals &lt;- c(0.1, 0.008, 0.005, 0.15, 0.04, 0.006)
graphTest(pvals, weights, alpha=0.025, graph)

## observe graphical procedure in detail
graphTest(pvals, weights, alpha=0.025, graph, verbose = TRUE)

## now use many p-values (useful for power simulations)
pvals &lt;- matrix(rbeta(6e4, 1, 30), ncol = 6)
out &lt;- graphTest(pvals, weights, alpha=0.025, graph)
head(out)
# example using multiple graphs (instead of 1)
G1 &lt;- rbind(c(0,0.5,0.5,0,0), c(0,0,1,0,0),
            c(0, 0, 0, 1-0.01, 0.01), c(0, 1, 0, 0, 0),
            c(0, 0, 0, 0, 0))
G2 &lt;- rbind(c(0,0,1,0,0), c(0.5,0,0.5,0,0),
            c(0, 0, 0, 0.01, 1-0.01), c(0, 0, 0, 0, 0),
            c(1, 0, 0, 0, 0))
weights &lt;- rbind(c(1, 0, 0, 0, 0), c(0, 1, 0, 0, 0))
pvals &lt;- c(0.012, 0.025, 0.005, 0.0015, 0.0045)
out &lt;- graphTest(pvals, weights, alpha=c(0.0125, 0.0125), G=list(G1, G2), verbose = TRUE)

## now again with many p-values
pvals &lt;- matrix(rbeta(5e4, 1, 30), ncol = 5)
out &lt;- graphTest(pvals, weights, alpha=c(0.0125, 0.0125), G=list(G1, G2))
head(out)

</code></pre>

<hr>
<h2 id='hGraph'>Create multiplicity graphs using ggplot2</h2><span id='topic+hGraph'></span>

<h3>Description</h3>

<p>Plots a multiplicity graph defined by user inputs.
The graph can also be used with the gMCP package to evaluate a set of
nominal p-values for the tests of the hypotheses in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hGraph(
  nHypotheses = 4,
  nameHypotheses = paste("H", (1:nHypotheses), sep = ""),
  alphaHypotheses = 0.025/nHypotheses,
  m = matrix(array(1/(nHypotheses - 1), nHypotheses^2), nrow = nHypotheses) -
    diag(1/(nHypotheses - 1), nHypotheses),
  fill = 1,
  palette = grDevices::gray.colors(length(unique(fill)), start = 0.5, end = 0.8),
  labels = LETTERS[1:length(unique(fill))],
  legend.name = " ",
  legend.position = "none",
  halfWid = 0.5,
  halfHgt = 0.5,
  trhw = 0.1,
  trhh = 0.075,
  trprop = 1/3,
  digits = 5,
  trdigits = 2,
  size = 6,
  boxtextsize = 4,
  legend.textsize = size * 2.5,
  arrowsize = 0.02,
  radianStart = if ((nHypotheses)%%2 != 0) {
     pi * (1/2 + 1/nHypotheses)
 } else
    {
     pi * (1 + 2/nHypotheses)/2
 },
  offset = pi/4/nHypotheses,
  xradius = 2,
  yradius = xradius,
  x = NULL,
  y = NULL,
  wchar = "\u03b1"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hGraph_+3A_nhypotheses">nHypotheses</code></td>
<td>
<p>number of hypotheses in graph</p>
</td></tr>
<tr><td><code id="hGraph_+3A_namehypotheses">nameHypotheses</code></td>
<td>
<p>hypothesis names</p>
</td></tr>
<tr><td><code id="hGraph_+3A_alphahypotheses">alphaHypotheses</code></td>
<td>
<p>alpha-levels or weights for ellipses</p>
</td></tr>
<tr><td><code id="hGraph_+3A_m">m</code></td>
<td>
<p>square transition matrix of dimension 'nHypotheses'</p>
</td></tr>
<tr><td><code id="hGraph_+3A_fill">fill</code></td>
<td>
<p>grouping variable for hypotheses</p>
</td></tr>
<tr><td><code id="hGraph_+3A_palette">palette</code></td>
<td>
<p>colors for groups</p>
</td></tr>
<tr><td><code id="hGraph_+3A_labels">labels</code></td>
<td>
<p>text labels for groups</p>
</td></tr>
<tr><td><code id="hGraph_+3A_legend.name">legend.name</code></td>
<td>
<p>text for legend header</p>
</td></tr>
<tr><td><code id="hGraph_+3A_legend.position">legend.position</code></td>
<td>
<p>text string or x,y coordinates for legend</p>
</td></tr>
<tr><td><code id="hGraph_+3A_halfwid">halfWid</code></td>
<td>
<p>half width of ellipses</p>
</td></tr>
<tr><td><code id="hGraph_+3A_halfhgt">halfHgt</code></td>
<td>
<p>half height of ellipses</p>
</td></tr>
<tr><td><code id="hGraph_+3A_trhw">trhw</code></td>
<td>
<p>transition box width</p>
</td></tr>
<tr><td><code id="hGraph_+3A_trhh">trhh</code></td>
<td>
<p>transition box height</p>
</td></tr>
<tr><td><code id="hGraph_+3A_trprop">trprop</code></td>
<td>
<p>proportion of transition arrow length where transition box is placed</p>
</td></tr>
<tr><td><code id="hGraph_+3A_digits">digits</code></td>
<td>
<p>number of digits to show for alphaHypotheses</p>
</td></tr>
<tr><td><code id="hGraph_+3A_trdigits">trdigits</code></td>
<td>
<p>digits displayed for transition weights</p>
</td></tr>
<tr><td><code id="hGraph_+3A_size">size</code></td>
<td>
<p>text size in ellipses</p>
</td></tr>
<tr><td><code id="hGraph_+3A_boxtextsize">boxtextsize</code></td>
<td>
<p>transition text size</p>
</td></tr>
<tr><td><code id="hGraph_+3A_legend.textsize">legend.textsize</code></td>
<td>
<p>legend text size</p>
</td></tr>
<tr><td><code id="hGraph_+3A_arrowsize">arrowsize</code></td>
<td>
<p>size of arrowhead for transition arrows</p>
</td></tr>
<tr><td><code id="hGraph_+3A_radianstart">radianStart</code></td>
<td>
<p>radians from origin for first ellipse; nodes spaced equally in clockwise order with centers on an ellipse by default</p>
</td></tr>
<tr><td><code id="hGraph_+3A_offset">offset</code></td>
<td>
<p>rotational offset in radians for transition weight arrows</p>
</td></tr>
<tr><td><code id="hGraph_+3A_xradius">xradius</code></td>
<td>
<p>horizontal ellipse diameter on which ellipses are drawn</p>
</td></tr>
<tr><td><code id="hGraph_+3A_yradius">yradius</code></td>
<td>
<p>vertical ellipse diameter on which ellipses are drawn</p>
</td></tr>
<tr><td><code id="hGraph_+3A_x">x</code></td>
<td>
<p>x coordinates for hypothesis ellipses if elliptical arrangement is not wanted</p>
</td></tr>
<tr><td><code id="hGraph_+3A_y">y</code></td>
<td>
<p>y coordinates for hypothesis ellipses if elliptical arrangement is not wanted</p>
</td></tr>
<tr><td><code id="hGraph_+3A_wchar">wchar</code></td>
<td>
<p>character for alphaHypotheses in ellipses; defaults to the Unicode escape sequence <code>\u03b1</code> (Greek letter alpha).
See <a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters">list of Unicode characters</a> for a more comprehensive character list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See vignette **Multiplicity graphs formatting using ggplot2**
for explanation of formatting.
</p>


<h3>Value</h3>

<p>A 'ggplot' object with a multi-layer multiplicity graph
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use Cairo PDF device for better Unicode character support
# when checking the package. Needed for R &gt;= 4.4.0.
if (names(dev.cur()) == "pdf") {
  fn &lt;- attr(.Device, "filepath")
  fn0 &lt;- "gMCPLite-Ex.pdf"
  if (!is.null(fn) &amp;&amp; fn == fn0) {
    dv &lt;- cairo_pdf(fn0)
    on.exit(dev.off(dv), add = TRUE)
  }
}

# Defaults: note clockwise ordering
hGraph(5)
# Add colors (default is 3 gray shades)
hGraph(3,fill=1:3)
# Colorblind palette
cbPalette &lt;- c("#999999", "#E69F00", "#56B4E9", "#009E73",
               "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
hGraph(6,fill=as.factor(1:6),palette=cbPalette)
# Use a hue palette
hGraph(4,fill=factor(1:4),palette=scales::hue_pal(l=75)(4))
# different alpha allocation, hypothesis names and transitions
alphaHypotheses &lt;- c(.005,.007,.013)
nameHypotheses &lt;- c("ORR","PFS","OS")
m &lt;- matrix(c(0,1,0,
              0,0,1,
              1,0,0),nrow=3,byrow=TRUE)
hGraph(3,alphaHypotheses=alphaHypotheses,nameHypotheses=nameHypotheses,m=m)
# Custom position and size of ellipses, change text to multi-line text
# Adjust box width
# add legend in middle of plot
hGraph(3,x=sqrt(0:2),y=c(1,3,1.5),size=6,halfWid=.3,halfHgt=.3, trhw=0.6,
       palette=cbPalette[2:4], fill = c(1, 2, 2),
       legend.position = c(.6,.5), legend.name = "Legend:", labels = c("Group 1", "Group 2"),
       nameHypotheses=c("H1:\n Long name","H2:\n Longer name","H3:\n Longest name"))

</code></pre>

<hr>
<h2 id='joinGraphs'>Joins two graphMCP objects</h2><span id='topic+joinGraphs'></span>

<h3>Description</h3>

<p>Creates a new graphMCP object by joining two given graphMCP objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinGraphs(graph1, graph2, xOffset = 0, yOffset = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joinGraphs_+3A_graph1">graph1</code></td>
<td>
<p>A graph of class <code>graphMCP</code>.</p>
</td></tr>
<tr><td><code id="joinGraphs_+3A_graph2">graph2</code></td>
<td>
<p>A graph of class <code>graphMCP</code>.</p>
</td></tr>
<tr><td><code id="joinGraphs_+3A_xoffset">xOffset</code></td>
<td>
<p>A numeric specifying an offset (on the x-axis) for placing
the nodes and edge labels of the second graph.</p>
</td></tr>
<tr><td><code id="joinGraphs_+3A_yoffset">yOffset</code></td>
<td>
<p>A numeric specifying an offset (on the y-axis) for placing
the nodes and edge labels of the second graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>graph1</code> and <code>graph2</code> have duplicates in the node names, the
nodes of the second graph will be renamed.
</p>
<p>If and only if the sum of the weights of graph1 and graph2 exceeds 1, the
weights are scaled so that the sum equals 1.
</p>
<p>A description attribute of either graph will be discarded.
</p>


<h3>Value</h3>

<p>A graphMCP object that represents a graph that consists of the two
given graphs.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code>graphMCP</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

g1 &lt;- BonferroniHolm(2)
g2 &lt;- BonferroniHolm(3)

suppressWarnings(joinGraphs(g1, g2))


</code></pre>

<hr>
<h2 id='matrix2graph'>Matrix2Graph and Graph2Matrix</h2><span id='topic+matrix2graph'></span><span id='topic+graph2matrix'></span>

<h3>Description</h3>

<p>Creates a graph of class <code>graphMCP</code> from a given transition
matrix or vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix2graph(m, weights = rep(1/dim(m)[1], dim(m)[1]))

graph2matrix(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix2graph_+3A_m">m</code></td>
<td>
<p>A transition matrix.</p>
</td></tr>
<tr><td><code id="matrix2graph_+3A_weights">weights</code></td>
<td>
<p>A numeric for the initial weights.</p>
</td></tr>
<tr><td><code id="matrix2graph_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code>graphMCP</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hypotheses names are the row names or if these are <code>NULL</code>, the
column names or if these are also <code>NULL</code> of type H1, H2, H3, ...
</p>
<p>If the diagonal of the matrix is unequal zero, the values are ignored and a
warning is given.
</p>


<h3>Value</h3>

<p>A graph of class <code>graphMCP</code> with the given transition
matrix for matrix2graph.  The transition matrix of a <code>graphMCP</code>
graph for graph2matrix.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Bonferroni-Holm:
m &lt;- matrix(rep(1/3, 16), nrow=4)
diag(m) &lt;- c(0, 0, 0, 0)
graph &lt;- matrix2graph(m)
print(graph)
graph2matrix(graph)


</code></pre>

<hr>
<h2 id='parametric.test'>Weighted parametric test</h2><span id='topic+parametric.test'></span>

<h3>Description</h3>

<p>It is assumed that under the global null hypothesis
<code class="reqn">(\Phi^{-1}(1-p_1),...,\Phi^{-1}(1-p_m))</code> follow a multivariate normal
distribution with correlation matrix <code>correlation</code> where
<code class="reqn">\Phi^{-1}</code> denotes the inverse of the standard normal distribution
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parametric.test(
  pvalues,
  weights,
  alpha = 0.05,
  adjPValues = TRUE,
  verbose = FALSE,
  correlation,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parametric.test_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values.</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> is not used.</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default) an adjusted p-value for the weighted parametric test is returned.
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_correlation">correlation</code></td>
<td>
<p>Correlation matrix. For parametric tests the p-values
must arise from one-sided tests with multivariate normal distributed test
statistics for which the correlation is (partially) known. In that case a
weighted parametric closed test is performed (also see
<code><a href="#topic+generatePvals">generatePvals</a></code>). Unknown values can be set to NA. (See details
for more information)</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_...">...</code></td>
<td>
<p>Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, this is the case if <code class="reqn">p_1,..., p_m</code> are the raw p-values
from one-sided z-tests for each of the elementary hypotheses where the
correlation between z-test statistics is generated by an overlap in the
observations (e.g. comparison with a common control, group-sequential
analyses etc.). An application of the transformation <code class="reqn">\Phi^{-1}(1-p_i)</code>
to raw p-values from a two-sided test will not in general lead to a
multivariate normal distribution. Partial knowledge of the correlation
matrix is supported. The correlation matrix has to be passed as a numeric
matrix with elements of the form: <code class="reqn">correlation[i,i] = 1</code> for diagonal
elements, <code class="reqn">correlation[i,j] = \rho_{ij}</code>, where <code class="reqn">\rho_{ij}</code> is the
known value of the correlation between <code class="reqn">\Phi^{-1}(1-p_i)</code> and
<code class="reqn">\Phi^{-1}(1-p_j)</code> or <code>NA</code> if the corresponding correlation is
unknown. For example correlation[1,2]=0 indicates that the first and second
test statistic are uncorrelated, whereas correlation[2,3] = NA means that
the true correlation between statistics two and three is unknown and may
take values between -1 and 1. The correlation has to be specified for
complete blocks (ie.: if cor(i,j), and cor(i,j') for i!=j!=j' are specified
then cor(j,j') has to be specified as well) otherwise the corresponding
intersection null hypotheses tests are not uniquely defined and an error is
returned.
</p>
<p>For further details see the given references.
</p>


<h3>Value</h3>

<p>adjusted p-value or decision of rejection
</p>


<h3>References</h3>

<p>Bretz F., Posch M., Glimm E., Klinglmueller F., Maurer W., Rohmeyer K.
(2011): Graphical approaches for multiple endpoint problems using weighted
Bonferroni, Simes or parametric tests. Biometrical Journal 53 (6),
pages 894-913, Wiley.
<a href="https://doi.org/10.1002/bimj.201000239">doi:10.1002/bimj.201000239</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
parametric.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), correlation = diag(3))
parametric.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), correlation = diag(3),
adjPValues = FALSE)

</code></pre>

<hr>
<h2 id='permutations'>Permutation for a design matrix</h2><span id='topic+permutations'></span>

<h3>Description</h3>

<p>Permutation for a design matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutations(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutations_+3A_n">n</code></td>
<td>
<p>dimension of the matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a n*(2^n) dimensional matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>permutations(3)

</code></pre>

<hr>
<h2 id='placeNodes'>Placement of graph nodes</h2><span id='topic+placeNodes'></span>

<h3>Description</h3>

<p>Places the nodes of a graph according to a specified layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>placeNodes(graph, nrow, ncol, byrow = TRUE, topdown = TRUE, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="placeNodes_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code>graphMCP</code> or class
<code>entangledMCP</code>.</p>
</td></tr>
<tr><td><code id="placeNodes_+3A_nrow">nrow</code></td>
<td>
<p>The desired number of rows.</p>
</td></tr>
<tr><td><code id="placeNodes_+3A_ncol">ncol</code></td>
<td>
<p>The desired number of columns.</p>
</td></tr>
<tr><td><code id="placeNodes_+3A_byrow">byrow</code></td>
<td>
<p>Logical whether the graph is filled by rows (otherwise by
columns).</p>
</td></tr>
<tr><td><code id="placeNodes_+3A_topdown">topdown</code></td>
<td>
<p>Logical whether the rows are filled top-down or bottom-up.</p>
</td></tr>
<tr><td><code id="placeNodes_+3A_force">force</code></td>
<td>
<p>Logical whether a graph that has already a layout should be
given the specified new layout.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If one of <code>nrow</code> or <code>ncol</code> is not given, an attempt is made to
infer it from the number of nodes of the <code>graph</code> and the other
parameter.  If neither is given, the graph is placed as a circle.
</p>


<h3>Value</h3>

<p>The graph with nodes placed according to the specified layout.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code>graphMCP</code>, <code>entangledMCP</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

g &lt;- matrix2graph(matrix(0, nrow=6, ncol=6))

g &lt;- placeNodes(g, nrow=2, force=TRUE)


</code></pre>

<hr>
<h2 id='rejectNode'>Rejects a node/hypothesis and updates the graph accordingly.</h2><span id='topic+rejectNode'></span>

<h3>Description</h3>

<p>Rejects a node/hypothesis and updates the graph accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rejectNode(graph, node, upscale = FALSE, verbose = FALSE, keepWeights = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rejectNode_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code>graphMCP</code> or <code>entangledMCP</code>.</p>
</td></tr>
<tr><td><code id="rejectNode_+3A_node">node</code></td>
<td>
<p>A character string specifying the node to reject.</p>
</td></tr>
<tr><td><code id="rejectNode_+3A_upscale">upscale</code></td>
<td>
<p>Logical. If <code>upscale=TRUE</code> then the weights of all non-rejected
nodes are scaled so that the sum is equal to 1. This forces <code>keepWeights=FALSE</code>
to reduce confusion, since otherwise the sum of weights could become bigger than 1.</p>
</td></tr>
<tr><td><code id="rejectNode_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar.  If <code>TRUE</code> verbose output is generated
during sequentially rejection steps.</p>
</td></tr>
<tr><td><code id="rejectNode_+3A_keepweights">keepWeights</code></td>
<td>
<p>Logical scalar. If <code>FALSE</code> the weight of a node
without outgoing edges is set to 0 if it is removed.  Otherwise it keeps its
weight.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the given references.
</p>


<h3>Value</h3>

<p>An updated graph of class <code>graphMCP</code> or <code>entangledMCP</code>.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: A
graphical approach to sequentially rejective multiple test procedures.
Statistics in Medicine 2009 vol. 28 issue 4 page 586-604.
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>


<h3>See Also</h3>

<p><code>graphMCP</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(0, nrow = 4, ncol = 4)
m[1,3] &lt;- m[2,4] &lt;- m[3,2] &lt;- m[4,1] &lt;- 1
p1 &lt;- c(0.01, 0.005, 0.01, 0.5)
a &lt;- 0.05
w &lt;- c(1/2, 1/2, 0, 0)
g &lt;- matrix2graph(m, w)
gMCP(g, pvalues=p1, alpha=a)
rejectNode(graph = g, node = 4)


</code></pre>

<hr>
<h2 id='replaceVariables'>Replaces variables in a general graph with specified numeric values</h2><span id='topic+replaceVariables'></span>

<h3>Description</h3>

<p>Given a list of variables and real values a general graph is processed and
each variable replaced with the specified numeric value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceVariables(
  graph,
  variables = list(),
  ask = TRUE,
  partial = FALSE,
  expand = TRUE,
  list = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceVariables_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code>graphMCP</code> or class
<code>entangledMCP</code>.</p>
</td></tr>
<tr><td><code id="replaceVariables_+3A_variables">variables</code></td>
<td>
<p>A named list with one or more specified real values, for example
<code>list(a=0.5, b=0.8, "tau"=0.5)</code> or <code>list(a=c(0.5, 0.8), b=0.8, "tau"=0.5)</code>.
If <code>ask=TRUE</code> and this list is
missing at all or single variables are missing from the list, the user is
asked for the values (if the session is not interactive an error is thrown).
For interactively entered values only single numbers are supported.</p>
</td></tr>
<tr><td><code id="replaceVariables_+3A_ask">ask</code></td>
<td>
<p>If <code>FALSE</code> all variables that are not specified are not
replaced.</p>
</td></tr>
<tr><td><code id="replaceVariables_+3A_partial">partial</code></td>
<td>
<p>IF <code>TRUE</code> only specified variables are replaced and
parameter <code>ask</code> is ignored.</p>
</td></tr>
<tr><td><code id="replaceVariables_+3A_expand">expand</code></td>
<td>
<p>Used internally. Don't use yourself.</p>
</td></tr>
<tr><td><code id="replaceVariables_+3A_list">list</code></td>
<td>
<p>If <code>TRUE</code> the result will always be a list, even if only one
graph is returned in this list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph or a matrix with variables replaced by the specified numeric
values. Or a list of theses graphs and matrices if a variable had more than one value.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code>graphMCP</code>, <code>entangledMCP</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
graph &lt;- HungEtWang2010()
replaceVariables(graph, list("tau"=0.5,"omega"=0.5, "nu"=0.5))
replaceVariables(graph, list("tau"=c(0.1, 0.5, 0.9),"omega"=c(0.2, 0.8), "nu"=0.4))

</code></pre>

<hr>
<h2 id='simConfint'>Simultaneous confidence intervals for sequentially rejective multiple test
procedures</h2><span id='topic+simConfint'></span><span id='topic+simConfint+2CgraphMCP-method'></span>

<h3>Description</h3>

<p>Calculates simultaneous confidence intervals for sequentially rejective
multiple test procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simConfint(
  object,
  pvalues,
  confint,
  alternative = c("less", "greater"),
  estimates,
  df,
  alpha = 0.05,
  mu = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simConfint_+3A_object">object</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
<tr><td><code id="simConfint_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values for the sequentially
rejective MTP.</p>
</td></tr>
<tr><td><code id="simConfint_+3A_confint">confint</code></td>
<td>
<p>One of the following: A character string <code>"normal"</code>,
<code>"t"</code> or a function that calculates the confidence intervals.  If
<code>confint=="t"</code> the parameter <code>df</code> must be specified.  If
<code>confint</code> is a function it must be of signature <code>("character",
"numeric")</code>, where the first parameter is the hypothesis name and the second
the marginal confidence level (see examples).</p>
</td></tr>
<tr><td><code id="simConfint_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis,
must be &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="simConfint_+3A_estimates">estimates</code></td>
<td>
<p>Point estimates for the parameters of interest.</p>
</td></tr>
<tr><td><code id="simConfint_+3A_df">df</code></td>
<td>
<p>Degree of freedom as numeric.</p>
</td></tr>
<tr><td><code id="simConfint_+3A_alpha">alpha</code></td>
<td>
<p>The overall alpha level as numeric scalar.</p>
</td></tr>
<tr><td><code id="simConfint_+3A_mu">mu</code></td>
<td>
<p>The numerical parameter vector under null hypothesis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the given references.
</p>


<h3>Value</h3>

<p>A matrix with columns giving lower confidence limits, point
estimates and upper confidence limits for each parameter. These will be
labeled as &quot;lower bound&quot;, &quot;estimate&quot; and &quot;upper bound&quot;. 
(1-level)/2 in % (by default 2.5% and 97.5%).
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: A
graphical approach to sequentially rejective multiple test procedures.
Statistics in Medicine 2009 vol. 28 issue 4 page 586-604.
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>est &lt;- c("H1"=0.860382, "H2"=0.9161474, "H3"=0.9732953)
# Sample standard deviations:
ssd &lt;- c("H1"=0.8759528, "H2"=1.291310, "H3"=0.8570892)

pval &lt;- c(0.01260, 0.05154, 0.02124)/2

simConfint(BonferroniHolm(3), pvalues=pval,
		confint=function(node, alpha) {
			c(est[node]-qt(1-alpha,df=9)*ssd[node]/sqrt(10), Inf)
		}, estimates=est, alpha=0.025, mu=0, alternative="greater")

# Note that the sample standard deviations in the following call
# will be calculated from the pvalues and estimates.
ci &lt;- simConfint(BonferroniHolm(3), pvalues=pval,
		confint="t", df=9, estimates=est, alpha=0.025, alternative="greater")
ci

# plotSimCI(ci)
</code></pre>

<hr>
<h2 id='simes.on.subsets.test'>Simes on subsets, otherwise Bonferroni</h2><span id='topic+simes.on.subsets.test'></span>

<h3>Description</h3>

<p>Weighted Simes test introduced by Benjamini and Hochberg (1997)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simes.on.subsets.test(
  pvalues,
  weights,
  alpha = 0.05,
  adjPValues = TRUE,
  verbose = FALSE,
  subsets,
  subset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simes.on.subsets.test_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> is not used.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default) an adjusted p-value for the weighted test is returned.
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_subsets">subsets</code></td>
<td>
<p>A list of subsets given by numeric vectors containing the indices of the elementary hypotheses for which the weighted Simes test is applicable.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_subset">subset</code></td>
<td>
<p>A numeric vector containing the numbers of the indices of the currently tested elementary hypotheses.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_...">...</code></td>
<td>
<p>Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As an additional argument a list of subsets must be provided, that states in which cases a Simes test is applicable (i.e. if all hypotheses to test belong to one of these subsets), e.g.
subsets &lt;- list(c(&quot;H1&quot;, &quot;H2&quot;, &quot;H3&quot;), c(&quot;H4&quot;, &quot;H5&quot;, &quot;H6&quot;))
Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test
</p>


<h3>Value</h3>

<p>adjusted p-value or decision of rejection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simes.on.subsets.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0))
simes.on.subsets.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE)

graph &lt;- BonferroniHolm(4)
pvalues &lt;- c(0.01, 0.05, 0.03, 0.02)

gMCP.extended(graph=graph, pvalues=pvalues, test=simes.on.subsets.test, subsets=list(1:2, 3:4))

</code></pre>

<hr>
<h2 id='simes.test'>Weighted Simes test</h2><span id='topic+simes.test'></span>

<h3>Description</h3>

<p>Weighted Simes test introduced by Benjamini and Hochberg (1997)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simes.test(
  pvalues,
  weights,
  alpha = 0.05,
  adjPValues = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simes.test_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values.</p>
</td></tr>
<tr><td><code id="simes.test_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code id="simes.test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> is not used.</p>
</td></tr>
<tr><td><code id="simes.test_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default) an adjusted p-value for the weighted Simes test is returned.
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</td></tr>
<tr><td><code id="simes.test_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="simes.test_+3A_...">...</code></td>
<td>
<p>Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adjusted p-value or decision of rejection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0))
simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE)

</code></pre>

<hr>
<h2 id='subgraph'>Get a subgraph</h2><span id='topic+subgraph'></span>

<h3>Description</h3>

<p>Given a set of nodes and a graph this function creates the subgraph
containing only the specified nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgraph(graph, subset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subgraph_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code>graphMCP</code>.</p>
</td></tr>
<tr><td><code id="subgraph_+3A_subset">subset</code></td>
<td>
<p>A logical or character vector specifying the nodes in the
subgraph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subgraph containing only the specified nodes.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code>graphMCP</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

graph &lt;- improvedParallelGatekeeping()
subgraph(graph, c(TRUE, FALSE, TRUE, FALSE))
subgraph(graph, c("H1", "H3"))


</code></pre>

<hr>
<h2 id='substituteEps'>Substitute Epsilon</h2><span id='topic+substituteEps'></span>

<h3>Description</h3>

<p>Substitute Epsilon with a given value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substituteEps(graph, eps = 10^(-3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="substituteEps_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code>graphMCP</code> or class
<code>entangledMCP</code>.</p>
</td></tr>
<tr><td><code id="substituteEps_+3A_eps">eps</code></td>
<td>
<p>A numeric scalar specifying a value for epsilon edges.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the given references.
</p>


<h3>Value</h3>

<p>A graph where all epsilons have been replaced with the given value.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code>graphMCP</code>, <code>entangledMCP</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

graph &lt;- improvedParallelGatekeeping()
graph
substituteEps(graph, eps=0.01)


</code></pre>

<hr>
<h2 id='weighted.test.functions'>Weighted Test Functions for use with gMCP</h2><span id='topic+weighted.test.functions'></span>

<h3>Description</h3>

<p>The package gMCP provides the following weighted test functions:
</p>

<dl>
<dt>bonferroni.test</dt><dd><p>Bonferroni test - see <code>?bonferroni.test</code> for details.</p>
</dd>
<dt>parametric.test</dt><dd><p>Parametric test - see <code>?parametric.test</code> for details.</p>
</dd>
<dt>simes.test</dt><dd><p>Simes test - see <code>?simes.test</code> for details.</p>
</dd>
<dt>bonferroni.trimmed.simes.test</dt><dd><p>Trimmed Simes test for intersections of two hypotheses and otherwise Bonferroni - see <code>?bonferroni.trimmed.simes.test</code> for details.</p>
</dd>
<dt>simes.on.subsets.test</dt><dd><p>Simes test for intersections of hypotheses from certain sets and otherwise Bonferroni - see <code>?simes.on.subsets.test</code> for details.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Depending on whether <code>adjPValues==TRUE</code> these test functions return different values:
</p>

<ul>
<li><p> If <code>adjPValues==TRUE</code> the minimal value for alpha is returned for which the null hypothesis can be rejected. If that's not possible (for example in case of the trimmed Simes test adjusted p-values can not be calculated), the test function may throw an error.
</p>
</li>
<li><p> If <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.
</p>
</li></ul>

<p>To provide your own test function write a function that takes at least the following arguments:
</p>

<dl>
<dt>pvalues</dt><dd><p>A numeric vector specifying the p-values.</p>
</dd>
<dt>weights</dt><dd><p>A numeric vector of weights.</p>
</dd>
<dt>alpha</dt><dd><p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> should not be used.</p>
</dd>
<dt>adjPValues</dt><dd><p>Logical scalar. If <code>TRUE</code> an adjusted p-value for the weighted test is returned (if possible - if not the function should call <code>stop</code>).
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</dd>
<dt>...</dt><dd><p> Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</dd>
</dl>

<p>Further the following parameters have a predefined meaning:
</p>

<dl>
<dt>verbose</dt><dd><p>Logical scalar. If <code>TRUE</code> verbose output should be generated and printed to the standard output</p>
</dd>
<dt>subset</dt><dd></dd>
<dt>correlation</dt><dd></dd>
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The test function 'bonferroni.test' is used in by gMCP in the following call:
graph &lt;- BonferroniHolm(4)
pvalues &lt;- c(0.01, 0.05, 0.03, 0.02)
alpha &lt;- 0.05
r &lt;- gMCP.extended(graph=graph, pvalues=pvalues, test=bonferroni.test, verbose=TRUE)

# For the intersection of all four elementary hypotheses this results in a call
bonferroni.test(pvalues=pvalues, weights=getWeights(graph))
bonferroni.test(pvalues=pvalues, weights=getWeights(graph), adjPValues=FALSE)

# bonferroni.test function:
bonferroni.test &lt;- function(pvalues, weights, alpha=0.05, adjPValues=TRUE, verbose=FALSE, ...) {
  if (adjPValues) {
    return(min(pvalues/weights))
  } else {
    return(any(pvalues&lt;=alpha*weights))
  }
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
