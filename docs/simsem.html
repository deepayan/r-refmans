<!DOCTYPE html><html><head><title>Help for package simsem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simsem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyze'>
<p>Data analysis using the model specification</p></a></li>
<li><a href='#anova'>
<p>Provide a comparison of nested models and nonnested models across replications</p></a></li>
<li><a href='#bind'><p>Specify matrices for Monte Carlo simulation of structural equation models</p></a></li>
<li><a href='#bindDist'>
<p>Create a data distribution object.</p></a></li>
<li><a href='#coef'>
<p>Extract parameter estimates from a simulation result</p></a></li>
<li><a href='#combineSim'><p>Combine result objects</p></a></li>
<li><a href='#continuousCoverage'>
<p>Find coverage rate of model parameters when simulations have randomly varying parameters</p></a></li>
<li><a href='#continuousPower'>
<p>Find power of model parameters when simulations have randomly varying parameters</p></a></li>
<li><a href='#createData'>
<p>Create data from a set of drawn parameters.</p></a></li>
<li><a href='#draw'>
<p>Draw parameters from a <code>SimSem</code> object.</p></a></li>
<li><a href='#estmodel'>
<p>Shortcut for data analysis template for simulation.</p></a></li>
<li><a href='#exportData'>
<p>Export data sets for analysis with outside SEM program.</p></a></li>
<li><a href='#findCoverage'>
<p>Find a value of independent variables that provides a given value of coverage rate</p></a></li>
<li><a href='#findFactorIntercept'>
<p>Find factor intercept from regression coefficient matrix and factor total means</p></a></li>
<li><a href='#findFactorMean'>
<p>Find factor total means from regression coefficient matrix and factor intercept</p></a></li>
<li><a href='#findFactorResidualVar'>
<p>Find factor residual variances from regression coefficient matrix, factor (residual) correlations, and total factor variances</p></a></li>
<li><a href='#findFactorTotalCov'>
<p>Find factor total covariance from regression coefficient matrix, factor residual covariance</p></a></li>
<li><a href='#findFactorTotalVar'>
<p>Find factor total variances from regression coefficient matrix, factor (residual) correlations, and factor residual variances</p></a></li>
<li><a href='#findIndIntercept'>
<p>Find indicator intercepts from factor loading matrix, total factor mean, and indicator mean.</p></a></li>
<li><a href='#findIndMean'>
<p>Find indicator total means from factor loading matrix, total factor mean, and indicator intercept.</p></a></li>
<li><a href='#findIndResidualVar'>
<p>Find indicator residual variances from factor loading matrix, total factor covariance, and total indicator variances.</p></a></li>
<li><a href='#findIndTotalVar'>
<p>Find indicator total variances from factor loading matrix, total factor covariance, and indicator residual variances.</p></a></li>
<li><a href='#findPossibleFactorCor'>
<p>Find the appropriate position for freely estimated correlation (or covariance) given a regression coefficient matrix</p></a></li>
<li><a href='#findPower'>
<p>Find a value of independent variables that provides a given value of power.</p></a></li>
<li><a href='#findRecursiveSet'>
<p>Group variables regarding the position in mediation chain</p></a></li>
<li><a href='#generate'>
<p>Generate data using SimSem template</p></a></li>
<li><a href='#getCIwidth'>
<p>Find confidence interval width</p></a></li>
<li><a href='#getCoverage'>
<p>Find coverage rate of model parameters</p></a></li>
<li><a href='#getCutoff'>
<p>Find fit indices cutoff given a priori alpha level</p></a></li>
<li><a href='#getCutoffNested'>
<p>Find fit indices cutoff for nested model comparison given a priori alpha level</p></a></li>
<li><a href='#getCutoffNonNested'>
<p>Find fit indices cutoff for non-nested model comparison given a priori alpha level</p></a></li>
<li><a href='#getExtraOutput'>
<p>Get extra outputs from the result of simulation</p></a></li>
<li><a href='#getPopulation'>
<p>Extract the data generation population model underlying a result object</p></a></li>
<li><a href='#getPower'>
<p>Find power of model parameters</p></a></li>
<li><a href='#getPowerFit'>
<p>Find power in rejecting alternative models based on fit indices criteria</p></a></li>
<li><a href='#getPowerFitNested'>
<p>Find power in rejecting nested models based on the differences in fit indices</p></a></li>
<li><a href='#getPowerFitNonNested'>
<p>Find power in rejecting non-nested models based on the differences in fit indices</p></a></li>
<li><a href='#imposeMissing'>
<p>Impose MAR, MCAR, planned missingness, or attrition on a data set</p></a></li>
<li><a href='#inspect'>
<p>Extract information from a simulation result</p></a></li>
<li><a href='#likRatioFit'>
<p>Find the likelihood ratio (or Bayes factor) based on the bivariate distribution of fit indices</p></a></li>
<li><a href='#miss'>
<p>Specifying the missing template to impose on a dataset</p></a></li>
<li><a href='#model'>
<p>Data generation template and analysis template for simulation.</p></a></li>
<li><a href='#model.lavaan'>
<p>Build the data generation template and analysis template from the lavaan result</p></a></li>
<li><a href='#multipleAllEqual'>
<p>Test whether all objects are equal</p></a></li>
<li><a href='#plotCIwidth'>
<p>Plot a confidence interval width of a target parameter</p></a></li>
<li><a href='#plotCoverage'>
<p>Make a plot of confidence interval coverage rates</p></a></li>
<li><a href='#plotCutoff'>
<p>Plot sampling distributions of fit indices with fit indices cutoffs</p></a></li>
<li><a href='#plotCutoffNested'>
<p>Plot sampling distributions of the differences in fit indices between nested models with fit indices cutoffs</p></a></li>
<li><a href='#plotCutoffNonNested'>
<p>Plot sampling distributions of the differences in fit indices between non-nested models with fit indices cutoffs</p></a></li>
<li><a href='#plotDist'>
<p>Plot a distribution of a data distribution object</p></a></li>
<li><a href='#plotLogitMiss'>
<p>Visualize the missing proportion when the logistic regression method is used.</p></a></li>
<li><a href='#plotMisfit'>
<p>Plot the population misfit in the result object</p></a></li>
<li><a href='#plotPower'>
<p>Make a power plot of a parameter given varying parameters</p></a></li>
<li><a href='#plotPowerFit'>
<p>Plot sampling distributions of fit indices that visualize power of rejecting datasets underlying misspecified models</p></a></li>
<li><a href='#plotPowerFitNested'>
<p>Plot power of rejecting a nested model in a nested model comparison by each fit index</p></a></li>
<li><a href='#plotPowerFitNonNested'>
<p>Plot power of rejecting a non-nested model based on a difference in fit index</p></a></li>
<li><a href='#popDiscrepancy'>
<p>Find the discrepancy value between two means and covariance matrices</p></a></li>
<li><a href='#popMisfitMACS'>
<p>Find population misfit by sufficient statistics</p></a></li>
<li><a href='#pValue'>
<p>Find p-values (1 - percentile) by comparing a single analysis output from the result object</p></a></li>
<li><a href='#pValueNested'>
<p>Find p-values (1 - percentile) for a nested model comparison</p></a></li>
<li><a href='#pValueNonNested'>
<p>Find p-values (1 - percentile) for a non-nested model comparison</p></a></li>
<li><a href='#rawDraw'>
<p>Draw values from vector or matrix objects</p></a></li>
<li><a href='#setPopulation'>
<p>Set the data generation population model underlying an object</p></a></li>
<li><a href='#sim'>
<p>Run a Monte Carlo simulation with a structural equation model.</p></a></li>
<li><a href='#SimDataDist-class'><p>Class <code>"SimDataDist"</code>: Data distribution object</p></a></li>
<li><a href='#SimMatrix-class'><p>Matrix object: Random parameters matrix</p></a></li>
<li><a href='#SimMissing-class'><p>Class <code>"SimMissing"</code></p></a></li>
<li><a href='#SimResult-class'><p>Class <code>"SimResult"</code>: Simulation Result Object</p></a></li>
<li><a href='#SimSem-class'><p>Class <code>"SimSem"</code></p></a></li>
<li><a href='#SimVector-class'><p>Vector object: Random parameters vector</p></a></li>
<li><a href='#summaryConverge'>
<p>Provide a comparison between the characteristics of convergent replications and nonconvergent replications</p></a></li>
<li><a href='#summaryFit'>
<p>Provide summary of model fit across replications</p></a></li>
<li><a href='#summaryMisspec'>
<p>Provide summary of the population misfit and misspecified-parameter values across replications</p></a></li>
<li><a href='#summaryParam'>
<p>Provide summary of parameter estimates and standard error across replications</p></a></li>
<li><a href='#summaryPopulation'>
<p>Summarize the population model used for data generation underlying a result object</p></a></li>
<li><a href='#summarySeed'>
<p>Summary of a seed number</p></a></li>
<li><a href='#summaryShort'>
<p>Provide short summary of an object.</p></a></li>
<li><a href='#summaryTime'>
<p>Time summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>SIMulated Structural Equation Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-16</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-28</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Terrence D. Jorgensen &lt;TJorgensen314@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4), methods, lavaan(&ge; 0.6-7), utils, stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, Amelia, quantreg, splines, foreign, KernSmooth,
semTools(&ge; 0.4-15), OpenMx(&ge; 2.0.0), copula</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an easy framework for Monte Carlo simulation in structural equation modeling, which can be used for various purposes, such as such as model fit evaluation, power analysis, or missing data handling and planning. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://simsem.org/">https://simsem.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-28 19:58:14 UTC; terrence</td>
</tr>
<tr>
<td>Author:</td>
<td>Sunthud Pornprasertmanit [aut],
  Patrick Miller [aut],
  Alexander Schoemann
    <a href="https://orcid.org/0000-0002-8479-8798"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Terrence D. Jorgensen
    <a href="https://orcid.org/0000-0001-5111-6773"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Corbin Quick [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-28 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyze'>
Data analysis using the model specification
</h2><span id='topic+analyze'></span>

<h3>Description</h3>

<p>Data analysis using the model specification (<code>linkS4class{SimSem}</code>) or the mx model object (<code>MxModel</code>). Data will be multiply imputed if the <code>miss</code> argument is specified. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze(model, data, package="lavaan", miss=NULL, aux=NULL, group = NULL, 
	mxMixture = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_+3A_model">model</code></td>
<td>

<p>The simsem model template (<code>linkS4class{SimSem}</code>) or the mx model object (<code>MxModel</code>)
</p>
</td></tr>
<tr><td><code id="analyze_+3A_data">data</code></td>
<td>

<p>The target dataset 
</p>
</td></tr>
<tr><td><code id="analyze_+3A_package">package</code></td>
<td>

<p>The package used in data analysis. Currently, only <code>lavaan</code> package can be used.
</p>
</td></tr>
<tr><td><code id="analyze_+3A_miss">miss</code></td>
<td>
 
<p>The missing object with the specification of auxiliary variable or the specification for the multiple imputation.
</p>
</td></tr>
<tr><td><code id="analyze_+3A_aux">aux</code></td>
<td>
 
<p>List of auxiliary variables
</p>
</td></tr>
<tr><td><code id="analyze_+3A_group">group</code></td>
<td>
 
<p>A group variable. This argument is applicable only when the <code>model</code> argument is a <code>MxModel</code> object.
</p>
</td></tr>
<tr><td><code id="analyze_+3A_mxmixture">mxMixture</code></td>
<td>

<p>A logical whether to the analysis model is a mixture model. This argument is applicable when <code>MxModel</code> is used in the <code>model</code> argument only.
</p>
</td></tr>
<tr><td><code id="analyze_+3A_...">...</code></td>
<td>
 
<p>Additional arguments in the <code><a href="lavaan.html#topic+lavaan">lavaan</a></code> function. See also <code><a href="lavaan.html#topic+lavOptions">lavOptions</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> object containing the output
</p>


<h3>Author(s)</h3>

<p>Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>), 
Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p>Note that users can use functions provided by <code>lavaan</code> package (<code><a href="lavaan.html#topic+lavaan">lavaan</a></code>, <code><a href="lavaan.html#topic+cfa">cfa</a></code>, <code><a href="lavaan.html#topic+sem">sem</a></code>, or <code><a href="lavaan.html#topic+growth">growth</a></code>) if they wish to analyze data by lavaan directly. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

dat &lt;- generate(CFA.Model,200)
out &lt;- analyze(CFA.Model,dat)
</code></pre>

<hr>
<h2 id='anova'>
Provide a comparison of nested models and nonnested models across replications
</h2><span id='topic+anova+2CSimResult-method'></span>

<h3>Description</h3>

<p>This function will provide averages of model fit statistics and indices for nested models. It will also provide average differences of fit indices and power for likelihood ratio tests of nested models.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> object being described. Currently at least two objects must be included as arguments
</p>
</td></tr>
<tr><td><code id="anova_+3A_...">...</code></td>
<td>

<p>any additional arguments, such as additional objects or for the function with result object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that provides the statistics described above from all parameters.
For using with <code>linkS4class{SimResult}</code>, the result is a list with two or three elements:
</p>

<ul>
<li> <p><code>summary:</code> Average of fit indices across all replications
</p>
</li>
<li> <p><code>diff:</code> Average of the differences in fit indices across all replications
</p>
</li>
<li> <p><code>varyParam:</code> The statistical power of chi-square difference test given values of varying parameters (such as sample size or percent missing) 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>), 
Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> for the object input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading1 &lt;- matrix(0, 6, 1)
loading1[1:6, 1] &lt;- NA
loading2 &lt;- loading1
loading2[6,1] &lt;- 0
LY1 &lt;- bind(loading1, 0.7)
LY2 &lt;- bind(loading2, 0.7)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model1 &lt;- model(LY = LY1, RPS = RPS, RTE = RTE, modelType="CFA")
CFA.Model2 &lt;- model(LY = LY2, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
# Need to make sure that both simResult calls have the same seed!
Output1 &lt;- sim(5, n=500, model=CFA.Model1, generate=CFA.Model1, seed=123567)
Output2 &lt;- sim(5, n=500, model=CFA.Model2, generate=CFA.Model1, seed=123567)
anova(Output1, Output2)

# The example when the sample size is varying
Output1b &lt;- sim(NULL, n=seq(50, 500, 50), model=CFA.Model1, generate=CFA.Model1, seed=123567)
Output2b &lt;- sim(NULL, n=seq(50, 500, 50), model=CFA.Model2, generate=CFA.Model1, seed=123567)
anova(Output1b, Output2b)

## End(Not run)
</code></pre>

<hr>
<h2 id='bind'>Specify matrices for Monte Carlo simulation of structural equation models</h2><span id='topic+bind'></span><span id='topic+binds'></span>

<h3>Description</h3>

<p>Create <code><a href="#topic+SimMatrix-class">SimMatrix</a></code> or <code><a href="#topic+SimVector-class">SimVector</a></code> object that specifies
</p>

<ol>
<li><p>Pattern of fixed/freed parameters for analysis
</p>
</li>
<li><p>Population parameter values for data generation
</p>
</li>
<li><p>Any model misspecification (true population parameter is different than the one specified) for these parameters. </p>
</li></ol>

<p>Each matrix in the Lisrel-style notation is specified in this way (e.g. LY, PS, and TE) and is used to create a model analysis template and a data generation template for simulation through the <code>model</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind(free = NULL, popParam = NULL, misspec = NULL, symmetric = FALSE)
binds(free = NULL, popParam = NULL, misspec = NULL, symmetric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_+3A_free">free</code></td>
<td>
<p>Required matrix or vector where each element represents a fixed or freed parameter used for analysis with structural equation models. Parameters can be freed by setting the corresponding element in the matrix to <code>NA</code>, and can be fixed by setting the value of the element to any number (e.g. 0). Parameters can be labeled using any character string. Any labeled parameter is considered to be free, and parameters with identical labels will be constrained to equality for analysis.</p>
</td></tr>
<tr><td><code id="bind_+3A_popparam">popParam</code></td>
<td>
<p>Optional matrix or vector of identical dimension to the free matrix whose elements contain population parameter values for data generation in simulation. For simlutation, each free parameter requires a population parameter value, which is a quoted numeric value. Parameters that don't have population values are left as empty strings.
Population parameters can also be drawn from a distribution. This is done by wrapping a call to create 1 value from an existing random generation function in quotes: e.g <code>"runif(1,0,1)","rnorm(1,0,.01)"</code> Every replication in the simulation will draw a parameter value from this distribution. The function checks that what is quoted is valid R.
</p>
<p>If a random population parameter is constrained to equality in the free matrix, <em>each drawn population parameter value will be the same.</em> More details on data generation is available in <code>?generate</code>, <code>?createData</code>, and <code>?draw</code>.
</p>
<p>To simplify the most common case, <code>popParam</code> can take 1 value or distribution and create a matrix or vector that assigns that population parameter or distribution to all freed parameters. These population values are used as starting values for analysis by default.</p>
</td></tr>
<tr><td><code id="bind_+3A_misspec">misspec</code></td>
<td>
<p>Optional matrix or vector of identical dimension to the free matrix whose elements contain population parameter values for specifying misspecification. Elements of the misspec matrix contain population parameters that are added to parameters that are fixed or have an existing population value. These parameters are also quoted numeric strings, and can optionally be drawn from distributions as described above. To simplify the most common case, misspec can take 1 value or distribution and create a matrix or vector that assigns that value or distribution to all previously specified fixed parameters. Details about misspecification are included the data generation functions.</p>
</td></tr>
<tr><td><code id="bind_+3A_symmetric">symmetric</code></td>
<td>
<p>Set as <code>TRUE</code> if the matrix created is symmetric (RPS/PS, RTE/TE). The function <code>binds</code> can also be used, which defaults to <code>symmetric = TRUE</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bind is the first step in the <code>bind</code> -&gt; <code>model</code> -&gt; <code>sim</code> workflow of <em>simsem</em>, and this document outlines the user interface or language used to describe these simulations. This interface, while complex, enables a wide array of simulation specifications for structural equation models by building on LISREL-style parameter specifications.
</p>
<p>In simulations supported by <em>simsem</em>, a given parameter may be either fixed or freed for analysis, but may optionally also have a population value or distribution for data generation, or a value or distribution of misspecification. The purpose of bind is to stack these multiple meanings of a parameter into an object recognized by <em>simsem</em>, a <code><a href="#topic+SimMatrix-class">SimMatrix</a></code>. Each matrix in the Lisrel notation (e.g. LY, PS, TE, BE) becomes a <code><a href="#topic+SimMatrix-class">SimMatrix</a></code>, and is passed to the function <code>model</code>, which builds the data generation template and an analysis template (a lavaan parameter table), collectively forming a <code>SimSem</code> object, which can be passed to the function <code>sim</code> for simulation.
</p>
<p>Note that any <code>(dim)names</code> attributes will be set to NULL for any vectors or matrices passed to <code>free</code>, <code>popParam</code>, or <code>misspec</code> in order to prevent errors elsewhere in the workflow. To set custom variable names, please use any of the <code>indLab</code>, <code>facLab</code>, <code>covLab</code>, or <code>groupLab</code> arguments to <code><a href="#topic+model">model</a>()</code>.
</p>


<h3>Value</h3>

 <p><code><a href="#topic+SimMatrix-class">SimMatrix</a></code> or <code><a href="#topic+SimVector-class">SimVector</a></code> object that used for model specification for analysis and data generation in simsem.</p>


<h3>Author(s)</h3>

<p>Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>),
Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<ul>
<li> <p><code><a href="#topic+model">model</a></code> To combine simMatrix objects into a complete data analysis and data generation template, which is a <code><a href="#topic+SimSem-class">SimSem</a></code> object
</p>
</li>
<li> <p><code><a href="#topic+generate">generate</a></code> To generate data using the simsem template.
</p>
</li>
<li> <p><code><a href="#topic+analyze">analyze</a></code> To analyze real or generated data using the simsem template.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loadingValues &lt;- matrix(0, 6, 2)
loadingValues[1:3, 1] &lt;- 0.7
loadingValues[4:6, 2] &lt;- 0.7
LY &lt;- bind(loading, loadingValues)
summary(LY)

# Set both factor correlations to .05
latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

# Misspecify all error covarainces
error.cor &lt;- matrix(0, 6, 6)
diag(error.cor) &lt;- NA
RTE &lt;- binds(error.cor,1,"runif(1,-.05,.05)")
</code></pre>

<hr>
<h2 id='bindDist'>
Create a data distribution object.
</h2><span id='topic+bindDist'></span>

<h3>Description</h3>

<p>Create a data distribution object. There are two ways to specify nonnormal data-generation model. To create nonnormal data by the copula method, <code>margins</code> and <code>...</code> arguments are required. To create data by Vale and Maurelli's method, <code>skewness</code> and/or <code>kurtosis</code> arguments are required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bindDist(margins = NULL, ..., p = NULL, keepScale = TRUE, reverse = FALSE, 
	copula = NULL, skewness = NULL, kurtosis = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bindDist_+3A_margins">margins</code></td>
<td>

<p>A character vector specifying all the marginal distributions. The characters in argument margins are used to construct density, distribution, and quantile function names. For example, <code>"norm"</code> can be used to specify marginal distribution, because <code>"dnorm"</code>, <code>"pnorm"</code>, and <code>"qnorm"</code> are all available. A user-defined distribution or other distributions can be used. For example, <code>"gl"</code> function in the <code>"gld"</code> package can be used to represent the generalized lambda distribution where <code>"dgl"</code>, <code>"pgl"</code>, and <code>"qgl"</code> are available. See the description of <code>margins</code> attribute of the <code><a href="copula.html#topic+Mvdc">Mvdc</a></code> function for further details.
</p>
</td></tr>
<tr><td><code id="bindDist_+3A_...">...</code></td>
<td>

<p>A list whose each component is a list of named components, giving the parameter values of the marginal distributions. See the description of <code>paramMargins</code> attribute of the <code><a href="copula.html#topic+Mvdc">Mvdc</a></code> function for further details.
</p>
</td></tr>
<tr><td><code id="bindDist_+3A_p">p</code></td>
<td>

<p>Number of variables. If only one distribution object is listed, the <code>p</code> will make the same distribution objects for all variables.
</p>
</td></tr>
<tr><td><code id="bindDist_+3A_keepscale">keepScale</code></td>
<td>

<p>A vector representing whether each variable is transformed its mean and standard deviation or not. If TRUE, transform back to retain the mean and standard deviation of a variable equal to the model implied mean and standard deviation (with sampling error)
</p>
</td></tr>
<tr><td><code id="bindDist_+3A_reverse">reverse</code></td>
<td>

<p>A vector representing whether each variable is mirrored or not. If <code>TRUE</code>, reverse the distribution of a variable (e.g., from positive skewed to negative skewed. If one logical value is specified, it will apply to all variables.
</p>
</td></tr>
<tr><td><code id="bindDist_+3A_copula">copula</code></td>
<td>

<p>A copula class that represents the multivariate distribution, such as <code><a href="copula.html#topic+ellipCopula">ellipCopula</a></code>, <code><a href="copula.html#topic+normalCopula">normalCopula</a></code>, or <code><a href="copula.html#topic+archmCopula">archmCopula</a></code>. When this copula argument is specified, the data-transformation method from Mair, Satorra, and Bentler (2012) is used. If this copula argument is not specified, the naive Gaussian copula is used such that the correlation matrix is direct applied to the multivariate Gaussian copula. The correlation matrix will be equivalent to the Spearman's correlation (rank correlation) of the resulting data. 
</p>
</td></tr>
<tr><td><code id="bindDist_+3A_skewness">skewness</code></td>
<td>

<p>A vector of skewness of each variable. The Vale &amp; Maurelli (1983) method is used in data generation.
</p>
</td></tr>
<tr><td><code id="bindDist_+3A_kurtosis">kurtosis</code></td>
<td>

<p>A vector of (excessive) kurtosis of each variable. The Vale &amp; Maurelli (1983) method is used in data generation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+SimDataDist-class">SimDataDist</a></code> that saves analysis result from simulate data.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>References</h3>

<p>Mair, P., Satorra, A., &amp; Bentler, P. M. (2012). Generating nonnormal multivariate data using copulas: Applications to SEM. <em>Multivariate Behavioral Research, 47</em>, 547-565.
</p>
<p>Vale, C. D. &amp; Maurelli, V. A. (1983) Simulating multivariate nonormal distributions. <em>Psychometrika, 48</em>, 465-471.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for the type of resulting object
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>	
# Create data based on Vale and Maurelli's method by specifying skewness and kurtosis
dist &lt;- bindDist(skewness = c(0, -2, 2), kurtosis = c(0, 8, 4))

## Not run: 
library(copula)

# Create three-dimensional distribution by gaussian copula with 
# the following marginal distributions
#   1. t-distribution with df = 2
# 	2. chi-square distribution with df = 3
#	3. normal distribution with mean = 0 and sd = 1

# Setting the attribute of each marginal distribution
d1 &lt;- list(df=2)
d2 &lt;- list(df=3)
d3 &lt;- list(mean=0, sd=1)

# Create a data distribution object by setting the names of each distribution
# and their arguments
dist &lt;- bindDist(c("t", "chisq", "norm"), d1, d2, d3)

# Create data by using Gumbel Copula as the multivariate distribution
dist &lt;- bindDist(c("t", "chisq", "norm"), d1, d2, d3, copula = gumbelCopula(2, dim = 3))

# Reverse the direction of chi-square distribution from positively skew to negatively skew
dist &lt;- bindDist(c("t", "chisq", "norm"), d1, d2, d3, copula = gumbelCopula(2, dim = 3),
	reverse = c(FALSE, TRUE, FALSE))

## End(Not run)
</code></pre>

<hr>
<h2 id='coef'>
Extract parameter estimates from a simulation result
</h2><span id='topic+coef+2CSimResult-method'></span>

<h3>Description</h3>

<p>Extract parameter estimates from a simulation result. This function is similar to the <code><a href="#topic+inspect+2CSimResult-method">inspect</a></code> method with <code>what = "coef"</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>

<p>The target <code><a href="#topic+SimResult-class">SimResult</a></code> object
</p>
</td></tr>
<tr><td><code id="coef_+3A_improper">improper</code></td>
<td>

<p>Specify whether to include the information from the replications with improper solutions
</p>
</td></tr>
<tr><td><code id="coef_+3A_nonconverged">nonconverged</code></td>
<td>

<p>Specify whether to include the information from the nonconvergent replications
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameter estimates of each replication
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> for the object input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# In reality, more than 5 replications are needed.
Output &lt;- sim(5, CFA.Model, n=200)
coef(Output)
coef(Output, improper = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='combineSim'>Combine result objects</h2><span id='topic+combineSim'></span>

<h3>Description</h3>

<p>Combine result objects into a single result object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineSim(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineSim_+3A_...">...</code></td>
<td>
<p>Result objects, <code><a href="#topic+SimResult-class">SimResult</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>	A combined result object</p>


<h3>Author(s)</h3>

<p>Terry Jorgensen (University of Kansas; <a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>), 
Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p>Result object (<code><a href="#topic+SimResult-class">SimResult</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")
Output1 &lt;- sim(5, CFA.Model, n=200, seed=123321)
Output2 &lt;- sim(4, CFA.Model, n=200, seed=324567)
Output3 &lt;- sim(3, CFA.Model, n=200, seed=789987)
Output &lt;- combineSim(Output1, Output2, Output3)
summary(Output)
</code></pre>

<hr>
<h2 id='continuousCoverage'>
Find coverage rate of model parameters when simulations have randomly varying parameters
</h2><span id='topic+continuousCoverage'></span>

<h3>Description</h3>

<p>A function to find the coverage rate of confidence intervals in a model when one or more of the simulations parameters vary randomly across replications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuousCoverage(simResult, coverValue = NULL, contN = TRUE, contMCAR = FALSE, 
    contMAR = FALSE, contParam = NULL, coverParam = NULL, pred = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuousCoverage_+3A_simresult">simResult</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that includes at least one randomly varying parameter (e.g. sample size, percent missing, model parameters)
</p>
</td></tr>
<tr><td><code id="continuousCoverage_+3A_covervalue">coverValue</code></td>
<td>

<p>A target value used that users wish to find the coverage rate of that value (e.g., 0). If <code>NULL</code>, the parameter values will be used.
</p>
</td></tr>
<tr><td><code id="continuousCoverage_+3A_contn">contN</code></td>
<td>

<p>Logical indicating if N varies over replications.
</p>
</td></tr>
<tr><td><code id="continuousCoverage_+3A_contmcar">contMCAR</code></td>
<td>

<p>Logical indicating if the percentage of missing data that is MCAR varies over replications.
</p>
</td></tr>
<tr><td><code id="continuousCoverage_+3A_contmar">contMAR</code></td>
<td>

<p>Logical indicating if the percentage of missing data that is MAR varies over replications.
</p>
</td></tr>
<tr><td><code id="continuousCoverage_+3A_contparam">contParam</code></td>
<td>

<p>Vector of parameters names that vary over replications.
</p>
</td></tr>
<tr><td><code id="continuousCoverage_+3A_coverparam">coverParam</code></td>
<td>

<p>Vector of parameters names that the user wishes to find coverage rate for. This can be a vector of names (e.g., &quot;f1=~y2&quot;, &quot;f1~~f2&quot;). If parameters are not specified, coverage rates for all parameters in the model will be returned.
</p>
</td></tr>
<tr><td><code id="continuousCoverage_+3A_pred">pred</code></td>
<td>

<p>A list of varying parameter values that users wish to find statistical power from.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, the coverage (which can be 0 or 1) is regressed on randomly varying simulation parameters (e.g., sample size, percentage of missing data, or model parameters) using logistic regression. For a set of independent variables values, the predicted probability from the logistic regression equation is the predicted coverage rate.
</p>


<h3>Value</h3>

<p>Data frame containing columns representing values of the randomly varying simulation parameters, and coverage rates for model parameters of interest.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>), Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to see how to create a simResult object with randomly varying parameters.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Specify Sample Size by n
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.7)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)
Output &lt;- sim(NULL, CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))
summary(Output)

# Find the coverage rates of all combinations of different sample size and percent MCAR missing
Ccover &lt;- continuousCoverage(Output, contN = TRUE, contMCAR = TRUE)
Ccover

# Find the coverage rates of parameter estimates when sample size is 200 
# and percent MCAR missing is 0.3
Ccover2 &lt;- continuousCoverage(Output, coverValue=0, contN = TRUE, contMCAR = TRUE, 
     pred=list(N = 200, pmMCAR = 0.3))
Ccover2

## End(Not run)
</code></pre>

<hr>
<h2 id='continuousPower'>
Find power of model parameters when simulations have randomly varying parameters
</h2><span id='topic+continuousPower'></span>

<h3>Description</h3>

<p>A function to find the power of  parameters in a model when one or more of the simulations parameters vary randomly across replications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuousPower(simResult, contN = TRUE, contMCAR = FALSE, contMAR = FALSE, 
	contParam = NULL, alpha = .05, powerParam = NULL, pred = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuousPower_+3A_simresult">simResult</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that includes at least one randomly varying parameter (e.g. sample size, percent missing, model parameters)
</p>
</td></tr>
<tr><td><code id="continuousPower_+3A_contn">contN</code></td>
<td>

<p>Logical indicating if N varies over replications.
</p>
</td></tr>
<tr><td><code id="continuousPower_+3A_contmcar">contMCAR</code></td>
<td>

<p>Logical indicating if the percentage of missing data that is MCAR varies over replications.
</p>
</td></tr>
<tr><td><code id="continuousPower_+3A_contmar">contMAR</code></td>
<td>

<p>Logical indicating if the percentage of missing data that is MAR varies over replications.
</p>
</td></tr>
<tr><td><code id="continuousPower_+3A_contparam">contParam</code></td>
<td>

<p>Vector of parameters names that vary over replications.
</p>
</td></tr>
<tr><td><code id="continuousPower_+3A_alpha">alpha</code></td>
<td>

<p>Alpha level to use for power analysis.
</p>
</td></tr>
<tr><td><code id="continuousPower_+3A_powerparam">powerParam</code></td>
<td>

<p>Vector of parameters names that the user wishes to find power for. This can be a vector of names (e.g., &quot;f1=~y2&quot;, &quot;f1~~f2&quot;). If parameters are not specified, power for all parameters in the model will be returned.
</p>
</td></tr>
<tr><td><code id="continuousPower_+3A_pred">pred</code></td>
<td>

<p>A list of varying parameter values that users wish to find statistical power from.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A common use of simulations is to conduct power analyses, especially when using SEM (Muthen &amp; Muthen, 2002). Here, researchers select values for each parameter and a sample size and run a simulation to determine power in those conditions (the proportion of generated datasets in which a particular parameter of interest is significantly different from zero). To evaluate power at multiple sample sizes, one simulation for each sample size must be run. By continuously varying sample size across replications, only a single simulation is needed. In this simulation, the sample size for each replication varies randomly across plausible sample sizes (e.g., sample sizes between 200 and 500). For each replication, the sample size and significance of each parameter (0 = not significant, 1 = significant) are recorded. When the simulation is complete, parameter significance is regressed on sample size using logistic regression. For a given sample size, the predicted probability from the logistic regression equation is the power to detect an effect at that sample size. This approach can be extended to other randomly varying simulation parameters such as the percentage of missing data, and model parameters.
</p>


<h3>Value</h3>

<p>Data frame containing columns representing values of the randomly varying simulation parameters, and power for model parameters of interest.
</p>


<h3>Author(s)</h3>

<p>Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>), Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>References</h3>

<p>Muthen, L. K., &amp; Muthen, B. O. (2002). How to use a Monte Carlo study to decide on sample size and determine power. <em>Structural Equation Modeling, 4,</em> 599-620.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to see how to create a simResult object with randomly varying parameters.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Specify Sample Size by n
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.7)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")
dat &lt;- generate(CFA.Model, 50)
out &lt;- analyze(CFA.Model, dat)

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)
Output &lt;- sim(NULL, CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))
summary(Output)

# Find the power of all combinations of different sample size and percent MCAR missing
Cpow &lt;- continuousPower(Output, contN = TRUE, contMCAR = TRUE)
Cpow

# Find the power of parameter estimates when sample size is 200 and percent MCAR missing is 0.3
Cpow2 &lt;- continuousPower(Output, contN = TRUE, contMCAR = TRUE, pred=list(N = 200, pmMCAR = 0.3))
Cpow2

## End(Not run)
</code></pre>

<hr>
<h2 id='createData'>
Create data from a set of drawn parameters.
</h2><span id='topic+createData'></span>

<h3>Description</h3>

<p>This function can be used to create data from a set of parameters created from <code><a href="#topic+draw">draw</a></code>, called a codeparamSet. This function is used internally to create data, and is available publicly for accessibility and debugging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createData(paramSet, n, indDist=NULL, sequential=FALSE, facDist=NULL, 
errorDist=NULL, saveLatentVar = FALSE, indLab=NULL, facLab = NULL, 
modelBoot=FALSE, realData=NULL, covData=NULL, empirical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createData_+3A_paramset">paramSet</code></td>
<td>

<p>Set of drawn parameters from <code><a href="#topic+draw">draw</a></code>.
</p>
</td></tr>
<tr><td><code id="createData_+3A_n">n</code></td>
<td>

<p>Integer of desired sample size.
</p>
</td></tr>
<tr><td><code id="createData_+3A_inddist">indDist</code></td>
<td>

<p>A <code><a href="#topic+SimDataDist-class">SimDataDist</a></code> object or list of objects for a distribution of indicators. If one object is passed, each indicator will have the same distribution. Use when <code>sequential</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="createData_+3A_sequential">sequential</code></td>
<td>

<p>If <code>TRUE</code>, use a sequential method to create data such that the data from factor are generated first and apply to a set of equations to obtain the data of indicators. If <code>FALSE</code>, create data directly from model-implied mean and covariance of indicators.
</p>
</td></tr>
<tr><td><code id="createData_+3A_facdist">facDist</code></td>
<td>

<p>A <code><a href="#topic+SimDataDist-class">SimDataDist</a></code> object or list of objects for the distribution of factors. If one object is passed, all factors will have the same distribution. Use when <code>sequential</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="createData_+3A_errordist">errorDist</code></td>
<td>

<p>An object or list of objects of type <code>SimDataDist</code> indicating the distribution of errors. If a single <code>SimDataDist</code> is specified, each error will be genrated with that distribution.
</p>
</td></tr>
<tr><td><code id="createData_+3A_savelatentvar">saveLatentVar</code></td>
<td>
 
<p>If <code>TRUE</code>, the total latent variable scores, residual latent variable scores, and measurement error scores are also provided as the <code>"latentVar"</code> attribute of the generated data by the following line: <code>attr(generatedData, "latentVar")</code>. The <code>sequential</code> argument must be <code>TRUE</code> in order to use this option.
</p>
</td></tr>
<tr><td><code id="createData_+3A_indlab">indLab</code></td>
<td>

<p>A vector of indicator labels. When not specified, the variable names are <code>x1, x2, ... xN</code>.
</p>
</td></tr>
<tr><td><code id="createData_+3A_faclab">facLab</code></td>
<td>

<p>A vector of factor labels. When not specified, the variable names are <code>f1, f2, ... fN</code>.
</p>
</td></tr>
<tr><td><code id="createData_+3A_modelboot">modelBoot</code></td>
<td>

<p>When specified, a model-based bootstrap is used for data generation. See details for further information. This argument requires real data to be passed to <code>readData</code>.
</p>
</td></tr>
<tr><td><code id="createData_+3A_realdata">realData</code></td>
<td>

<p>A data.frame containing real data. The data generated will follow the distribution of this data set.
</p>
</td></tr>
<tr><td><code id="createData_+3A_covdata">covData</code></td>
<td>
 
<p>A data.frame containing covariate data, which can have any distributions. This argument is required when users specify <code>GA</code> or <code>KA</code> matrices in the model template (<code><a href="#topic+SimSem-class">SimSem</a></code>).
</p>
</td></tr>
<tr><td><code id="createData_+3A_empirical">empirical</code></td>
<td>
 
<p>Logical. If <code>TRUE</code>, the specified parameters are treated as sample statistics and data are created to get the specified sample statistics. This argument is applicable when multivariate normal distribution is specified only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will use the modified <code>mvrnorm</code> function (from the MASS package) by Paul E. Johnson  to create data from model implied covariance matrix if the data distribution object (<code><a href="#topic+SimDataDist-class">SimDataDist</a></code>) is not specified. The modified function is just a small modification from the original <code>mvrnorm</code> function such that the data generated with the sample sizes of n and n + k (where k &gt; 0) will be replicable in the first n rows.
</p>
<p>It the data distribution object is specified, either the copula model or the Vale and Maurelli's method is used. For the copula approach, if the <code>copula</code> argument is not specified in the data distribution object, the naive Gaussian copula is used. The correlation matrix is direct applied to the multivariate Gaussian copula. The correlation matrix will be equivalent to the Spearman's correlation (rank correlation) of the resulting data. If the <code>copula</code> argument is specified, such as <code><a href="copula.html#topic+ellipCopula">ellipCopula</a></code>, <code><a href="copula.html#topic+normalCopula">normalCopula</a></code>, or <code><a href="copula.html#topic+archmCopula">archmCopula</a></code>, the data-transformation method from Mair, Satorra, and Bentler (2012) is used. In brief, the data (<code class="reqn">X</code>) are created from the multivariate copula. The covariance from the generated data is used as the starting point (<code class="reqn">S</code>). Then, the target data (<code class="reqn">Y</code>) with the target covariance as model-implied covariance matrix (<code class="reqn">\Sigma_0</code>) can be created:
</p>
<p style="text-align: center;"><code class="reqn"> Y = XS^{-1/2}\Sigma^{1/2}_0. </code>
</p>

<p>See <code><a href="#topic+bindDist">bindDist</a></code> for further details. For the Vale and Maurelli's (1983) method, the code is brought from the <code>lavaan</code> package.
</p>
<p>For the model-based bootstrap, the transformation proposed by Yung &amp; Bentler (1996) is used. This procedure is the expansion from the Bollen and Stine (1992) bootstrap including a mean structure. The model-implied mean vector and covariance matrix with trivial misspecification will be used in the model-based bootstrap if <code>misspec</code> is specified. See page 133 of Bollen and Stine (1992) for a reference. 
</p>
<p>Internally, parameters are first drawn, and data is then created from these parameters. Both of these steps are available via the <code><a href="#topic+draw">draw</a></code> and <code><a href="#topic+createData">createData</a></code> functions respectively.
</p>


<h3>Value</h3>

<p>A data.frame containing simulated data from the data generation template. A variable &quot;group&quot; is appended indicating group membership.
</p>


<h3>Author(s)</h3>

	
<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>), Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>). The original code of <code>mvrnorm</code> function is based on the <code>MASS</code> package slightly modified by Paul E. Johnson. The code for data-transformation in multivariate copula is based on Mair et al. (2012) article. The code for Vale and Maurelli (1983) is slightly modified from the function provided in the <code>lavaan</code> package.
</p>


<h3>References</h3>

<p>Bollen, K. A., &amp; Stine, R. A. (1992). Bootstrapping goodness-of-fit measures in structural equation models. <em>Sociological Methods and Research, 21,</em> 205-229.
</p>
<p>Mair, P., Satorra, A., &amp; Bentler, P. M. (2012). Generating nonnormal multivariate data using copulas: Applications to SEM. <em>Multivariate Behavioral Research, 47</em>, 547-565.
</p>
<p>Vale, C. D. &amp; Maurelli, V. A. (1983) Simulating multivariate nonormal distributions. <em>Psychometrika, 48</em>, 465-471.
</p>
<p>Yung, Y.-F., &amp; Bentler, P. M. (1996). Bootstrapping techniques in analysis of mean and covariance structures. In G. A. Marcoulides &amp; R. E. Schumacker (Eds.), <em>Advanced structural equation modeling: Issues and techniques</em> (pp. 195-226). Mahwah, NJ: Erlbaum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# Draw a parameter set for data generation.
param &lt;- draw(CFA.Model)

# Generate data from the first group in the paramList.
dat &lt;- createData(param[[1]], n = 200) 
</code></pre>

<hr>
<h2 id='draw'>
Draw parameters from a <code><a href="#topic+SimSem-class">SimSem</a></code> object.
</h2><span id='topic+draw'></span>

<h3>Description</h3>

<p>This function draws parameters from a <code><a href="#topic+SimSem-class">SimSem</a></code> template, for debugging or other use. Used internally to create data. Data can be created in one step from a <code>SimSem</code> object using <code><a href="#topic+generate">generate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw(model, maxDraw=50, misfitBounds=NULL, averageNumMisspec=FALSE, 
optMisfit = NULL, optDraws = 50, misfitType = "f0", createOrder = c(1, 2, 3),
covData = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_+3A_model">model</code></td>
<td>

<p>A <code><a href="#topic+SimSem-class">SimSem</a></code> object. 
</p>
</td></tr>
<tr><td><code id="draw_+3A_maxdraw">maxDraw</code></td>
<td>

<p>Integer specifying the maximum number of attempts to draw a valid set of parameters (no negative error variance, standardized coefficients over 1).
</p>
</td></tr>
<tr><td><code id="draw_+3A_misfitbounds">misfitBounds</code></td>
<td>

<p>Vector that contains upper and lower bounds of the misfit measure. Sets of parameters drawn that are not within these bounds are rejected.
</p>
</td></tr>
<tr><td><code id="draw_+3A_averagenummisspec">averageNumMisspec</code></td>
<td>

<p>If <code>TRUE</code>, the provided fit will be divided by the number of misspecified parameters. 
</p>
</td></tr>
<tr><td><code id="draw_+3A_optmisfit">optMisfit</code></td>
<td>

<p>Character vector of either &quot;min&quot; or &quot;max&quot; indicating either maximum or minimum optimized misfit. If not null, the set of parameters out of the number of draws in &quot;optDraws&quot; that has either the maximum or minimum misfit of the given misfit type will be returned.
</p>
</td></tr>
<tr><td><code id="draw_+3A_optdraws">optDraws</code></td>
<td>

<p>Number of parameter sets to draw if optMisfit is not null. The set of parameters with the maximum or minimum misfit will be returned.
</p>
</td></tr>
<tr><td><code id="draw_+3A_misfittype">misfitType</code></td>
<td>

<p>Character vector indicating the fit measure used to assess the misfit of a set of parameters. Can be &quot;f0&quot;, &quot;rmsea&quot;, &quot;srmr&quot;, or &quot;all&quot;. 
</p>
</td></tr>
<tr><td><code id="draw_+3A_createorder">createOrder</code></td>
<td>

<p>The order of 1) applying equality/inequality constraints, 2) applying misspecification, and 3) fill unspecified parameters (e.g., residual variances when total variances are specified). The specification of this argument is a vector of different orders of 1 (constraint), 2 (misspecification), and 3 (filling parameters). For example, <code>c(1, 2, 3)</code> is to apply constraints first, then add the misspecification, and finally fill all parameters. 
</p>
</td></tr>
<tr><td><code id="draw_+3A_covdata">covData</code></td>
<td>
 
<p>A data.frame containing covariate data, which can have any distributions. This argument is required when users specify <code>GA</code> or <code>KA</code> matrices in the model template (<code><a href="#topic+SimSem-class">SimSem</a></code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nested list of drawn parameters in the form <code>[[Group]][[param,misspec,misOnly]][[SimMatrix]]</code>. E.g. The LY parameter matrix of the first group would be indexed as <code>obj[[1]]$param$LY</code>.
The values in $param are the raw parameter values with no misspecification. The values in $misspec are raw parameter values + misspecification. The values in $misOnly are only the misspecification values. 
</p>


<h3>Author(s)</h3>

	
<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>), Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>) 
</p>


<h3>See Also</h3>

		
<p><code><a href="#topic+createData">createData</a></code> To generate random data using a set of parameters from <code><a href="#topic+draw">draw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# Draw a parameter set for data generation.
param &lt;- draw(CFA.Model)

# Example of Multiple Group Model with Weak Invariance

loading.in &lt;- matrix(0, 6, 2)
loading.in[1:3, 1] &lt;- c("load1", "load2", "load3")
loading.in[4:6, 2] &lt;- c("load4", "load5", "load6")
mis &lt;- matrix(0,6,2)
mis[loading.in == "0"] &lt;- "runif(1, -0.1, 0.1)"
LY.in &lt;- bind(loading.in, "runif(1, 0.7, 0.8)", mis)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VTE &lt;- bind(rep(NA, 6), 0.51)

VPS1 &lt;- bind(rep(1, 2))

VPS2 &lt;- bind(rep(NA, 2), c(1.1, 1.2))

# Inequality constraint
script &lt;- "
sth := load1 + load2 + load3
load4 == (load5 + load6) / 2
load4 &gt; 0
load5 &gt; 0
sth2 := load1 - load2
"

# Model Template
weak &lt;- model(LY = LY.in, RPS = RPS, VPS=list(VPS1, VPS2), RTE = RTE, VTE=VTE, ngroups=2, 
     modelType = "CFA", con=script)

# Constraint --&gt; Misspecification --&gt; Fill Parameters
draw(weak, createOrder=c(1, 2, 3))

# Constraint --&gt; Fill Parameters --&gt; Misspecification 
draw(weak, createOrder=c(1, 3, 2))

# Misspecification --&gt; Constraint --&gt; Fill Parameters
draw(weak, createOrder=c(2, 1, 3))

# Misspecification --&gt; Fill Parameters --&gt; Constraint
draw(weak, createOrder=c(2, 3, 1))

# Fill Parameters --&gt; Constraint --&gt; Misspecification
draw(weak, createOrder=c(3, 1, 2))

# Fill Parameters --&gt; Misspecification --&gt; Constraint
draw(weak, createOrder=c(3, 2, 1))
</code></pre>

<hr>
<h2 id='estmodel'>
Shortcut for data analysis template for simulation.
</h2><span id='topic+estmodel'></span><span id='topic+estmodel.cfa'></span><span id='topic+estmodel.path'></span><span id='topic+estmodel.sem'></span>

<h3>Description</h3>

<p>Creates a data analysis template (lavaan parameter table) for simulations with structural equation models based on Y-side LISREL design matrices. Each corresponds to a LISREL matrix, but must be a matrix or a vector. In addition to the usual Y-side matrices in LISREL, both PS and TE can be specified using correlations (RPS, RTE) and scaled by a vector of residual variances (VTE, VPS) or total variances (VY, VE). Multiple groups are supported by passing lists of matrices or vectors to arguments, or by specifying the number of groups. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estmodel(LY = NULL, PS = NULL, RPS = NULL, TE = NULL, RTE = NULL, BE = NULL, 
	VTE = NULL, VY = NULL, VPS = NULL, VE = NULL, TY = NULL, AL = NULL, 
	MY = NULL, ME = NULL, KA = NULL, GA = NULL, modelType, indLab = NULL, 
	facLab = NULL, covLab = NULL, groupLab = "group", ngroups = 1, con = NULL)
estmodel.cfa(LY = NULL,PS = NULL,RPS = NULL, TE = NULL,RTE = NULL, VTE = NULL, 
	VY = NULL, VPS = NULL, VE = NULL, TY = NULL, AL = NULL, MY = NULL, ME = NULL, 
	KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1, con = NULL)
estmodel.path(PS = NULL, RPS = NULL, BE = NULL, VPS = NULL, VE = NULL, AL = NULL, 
	ME = NULL, KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1,con = NULL)
estmodel.sem(LY = NULL,PS = NULL,RPS = NULL, TE = NULL,RTE = NULL, BE = NULL, 
	VTE = NULL, VY = NULL, VPS = NULL, VE = NULL, TY = NULL, AL = NULL, MY = NULL, 
	ME = NULL, KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1, con = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estmodel_+3A_ly">LY</code></td>
<td>

<p>Factor loading matrix from endogenous factors to Y indicators (need to be a matrix or a list of matrices).
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_ps">PS</code></td>
<td>

<p>Residual covariance matrix among endogenous factors (need to be a symmetric matrix or a list of symmetric matrices).
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_rps">RPS</code></td>
<td>

<p>Residual correlation matrix among endogenous factors (need to be a symmetric matrix or a list of symmetric matrices).
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_te">TE</code></td>
<td>

<p>Measurement error covariance matrix among Y indicators (need to be a symmetric matrix or a list of symmetric matrices).
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_rte">RTE</code></td>
<td>

<p>Measurement error correlation matrix among Y indicators (need to be a symmetric matrix or a list of symmetric matrices).
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_be">BE</code></td>
<td>

<p>Regression coefficient matrix among endogenous factors (need to be a matrix or a list of matrices).
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_vte">VTE</code></td>
<td>

<p>Measurement error variance of indicators (need to be a vector or a list of vectors).
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_vy">VY</code></td>
<td>

<p>Total variance of indicators (need to be a vector or a list of vectors). NOTE: Either measurement error variance or indicator variance is specified. Both cannot be simultaneously specified.
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_vps">VPS</code></td>
<td>

<p>Residual variance of factors (need to be a vector or a list of vectors).
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_ve">VE</code></td>
<td>

<p>Total variance of of factors (need to be a vector or a list of vectors). NOTE: Either residual variance of factors or total variance of factors is specified. Both cannot be simulatneously specified.
</p>
</td></tr>  
<tr><td><code id="estmodel_+3A_ty">TY</code></td>
<td>

<p>Measurement intercepts of Y indicators. (need to be a vector or a list of vectors).
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_al">AL</code></td>
<td>

<p>Endogenous factor intercept (need to be a vector or a list of vectors).
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_my">MY</code></td>
<td>

<p>Overall Y indicator means. (need to be a vector or a list of vectors). NOTE: Either measurement intercept of indicator mean can be specified. Both cannot be specified simultaneously.
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_me">ME</code></td>
<td>

<p>Total mean of endogenous factors (need to be a vector or a list of vectors). NOTE: Either endogenous factor intercept or total mean of endogenous factor is specified. Both cannot be simultaneously specified.
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_ka">KA</code></td>
<td>

<p>Regression coefficient matrix from covariates to indicators (need to be a matrix or a list of matrices). KA is needed when (fixed) exogenous covariates are needed only.
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_ga">GA</code></td>
<td>

<p>Regression coefficient matrix from covariates to factors (need to be a matrix or a list of matrices). GA is needed when (fixed) exogenous covariates are needed only.
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_modeltype">modelType</code></td>
<td>

<p>&quot;CFA&quot;, &quot;Sem&quot;, or &quot;Path&quot;. This is specified to ensure that the analysis and data generation template created based on specified matrices in model correspond to what the user intends.
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_indlab">indLab</code></td>
<td>

<p>Character vector of indicator labels. If left blank, automatic labels will be generated as  <code>y1</code>, <code>y2</code>, ... <code>yy</code>.
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_faclab">facLab</code></td>
<td>
 
<p>Character vector of factor labels. If left blank, automatic labels will be generated as <code>f1</code>, <code>f2</code>, ... <code>ff</code>
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_covlab">covLab</code></td>
<td>
 
<p>Character vector of covariate labels. If left blank, automatic labels will be generated as <code>z1</code>, <code>z2</code>, ... <code>zz</code>
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_grouplab">groupLab</code></td>
<td>

<p>Character of group-variable label (not the names of each group). If left blank, automatic labels will be generated as <code>group</code>
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_ngroups">ngroups</code></td>
<td>

<p>Integer. Number of groups for data generation, defaults to 1. If larger than one, all specified matrices will be repeated for each additional group. If any matrix argument is a list, the length of this list will be the number of groups and ngroups is ignored.
</p>
</td></tr>
<tr><td><code id="estmodel_+3A_con">con</code></td>
<td>

<p>Additional parameters (phantom variables), equality constraints, and inequality constraints that users wish to specify in the model. The additional parameters are specified in lavaan syntax. The allowed operator are &quot;:=&quot; (is defined as), &quot;==&quot; (is equal to), &quot;&lt;&quot; (is less than), and &quot;&gt;&quot; (is greater than). Names used in the syntax are the labels defined on free parameters in the model except that the left-handed-side name of &quot;:=&quot; is a new parameter name. On the right hand side of all operators, any mathematical expressions are allowed, e.g., <code>"newparam := (load1 + load2 + load3)/3"</code>. For the &quot;&lt;&quot; and &quot;&gt;&quot; operators in data generation, if the parameters relation is not hold (e.g., the left hand side is less than the right hand side in the &quot;&gt;&quot; operator), the left hand side parameters will be changed such that the relation holds with a very small difference (i.e., 0.000001). For example, in &quot;load1 &gt; load2&quot;, if load1 is 0.5 and load2 is 0.6, load1 will be changed to 0.6 + 0.000001 = 0.600001. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function contains default settings:
</p>
<p>For <code>modelType="CFA"</code>, <code>LY</code> is required. As the default, the on-diagonal elements of <code>PS</code> are fixed as 1 and the off-diagonal elements of <code>PS</code> are freely estimated. The off-diagonal elements of <code>TE</code> are freely estimated and the off-diagonal elements of <code>TE</code> are fixed to 0. The <code>AL</code> elements are fixed to 0. The <code>TY</code> elements are freely estimated.
</p>
<p>For <code>modelType="Path"</code>, <code>BE</code> is required. As the default, the on-diagonal elements of <code>PS</code> are freely estimated, the off-diagonal elements between exogenous variables (covariance between exogenous variables) are freely estimated, and the other off-diagonal elements are fixed to 0. The <code>AL</code> elements are freely estimated. 
</p>
<p>For <code>modelType="SEM"</code>, <code>LY</code> and <code>BE</code> are required. As the default, the on-diagonal elements of <code>PS</code> are fixed to 1, the off-diagonal elements between exogenous factors (covariance between exogenous factors) are freely estimated, and the other off-diagonal elements are fixed to 0. The off-diagonal elements of <code>TE</code> are freely estimated and the off-diagonal elements of <code>TE</code> are fixed to 0. The <code>AL</code> elements are fixed to 0. The <code>TY</code> elements are freely estimated.
</p>
<p>The <code>estmodel.cfa</code>, <code>estmodel.path</code>, and <code>estmodel.sem</code> are the shortcuts for the <code>estmodel</code> function when <code>modelType</code> are <code>"CFA"</code>, <code>"Path"</code>, and <code>"SEM"</code>, respectively.
</p>


<h3>Value</h3>

<p><code>SimSem</code> object that contains the data generation template (<code>@dgen</code>) and analysis template (<code>@pt</code>).
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+model">model</a></code> To build data generation and data analysis template for simulation.
</p>
</li>
<li> <p><code><a href="#topic+sim">sim</a></code> For simulations using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li>
<li> <p><code><a href="#topic+generate">generate</a></code> To generate data using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li>
<li> <p><code><a href="#topic+analyze">analyze</a></code> To analyze real or generated data using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li>
<li> <p><code><a href="#topic+draw">draw</a></code> To draw parameters using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 12, 4)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loading[7:9, 3] &lt;- NA
loading[10:12, 4] &lt;- NA

CFA.Model &lt;- estmodel(LY = loading, modelType = "CFA")

path &lt;- matrix(0, 4, 4)
path[3, 1:2] &lt;- NA
path[4, 3] &lt;- NA
Path.Model &lt;- estmodel(BE = path, modelType = "Path")

SEM.Model &lt;- estmodel(BE = path, LY = loading, modelType="SEM")

# Shortcut
CFA.Model &lt;- estmodel.cfa(LY = loading)
Path.Model &lt;- estmodel.path(BE = path)
SEM.Model &lt;- estmodel.sem(BE = path, LY = loading)
</code></pre>

<hr>
<h2 id='exportData'>
Export data sets for analysis with outside SEM program.
</h2><span id='topic+exportData'></span>

<h3>Description</h3>

<p>This function can be used to export data created from a set of parameters created from <code><a href="#topic+draw">draw</a></code>, called a codeparamSet. This function can export data to be analyzed with either Mplus or LISREL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportData(nRep, model, n, program = "Mplus", fileStem = "sim", miss = NULL, 
	missCode = -999, datafun=NULL, pmMCAR = NULL, pmMAR = NULL, facDist = NULL, 
	indDist = NULL, errorDist = NULL, sequential = FALSE, modelBoot = FALSE, 
	realData = NULL, maxDraw = 50, misfitType = "f0", misfitBounds = NULL, 
	averageNumMisspec = NULL, optMisfit=NULL, optDraws = 50, seed = 123321, 
	silent = FALSE, multicore = FALSE, numProc = NULL,  params = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportData_+3A_nrep">nRep</code></td>
<td>

<p>Number of replications. Users can specify as <code>NULL</code> and specify <code>n</code>, <code>pmMCAR</code>, and <code>pmMAR</code>
</p>
</td></tr>
<tr><td><code id="exportData_+3A_model">model</code></td>
<td>

<p><code><a href="#topic+SimSem-class">SimSem</a></code> object created by <code><a href="#topic+model">model</a></code>. Will be used to generate data and analyze it.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_n">n</code></td>
<td>

<p>Sample size. This argument is not necessary except the user wish to vary sample size across replications. The sample size here is a vector of sample size in integers. For the random distribution object, if the resulting value has decimal, the value will be rounded. 
</p>
</td></tr>
<tr><td><code id="exportData_+3A_program">program</code></td>
<td>

<p>Statistical program that will be used to analyze data. Currently only Mplys and LISREL are supported.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_filestem">fileStem</code></td>
<td>

<p>The stem of the filename(s) for file(s) output. For example, a fileStem of &quot;sim&quot; will result in files named sim1.dat, sim2.dat, etc.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_miss">miss</code></td>
<td>

<p>Missing data handling template, created by the function <code><a href="#topic+miss">miss</a></code>.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_misscode">missCode</code></td>
<td>

<p>Missing data code, NA will be replaced by this value for all missing values in exported data.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_datafun">datafun</code></td>
<td>

<p>Function to be applied to generated data set at each replication.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_pmmcar">pmMCAR</code></td>
<td>

<p>The percent completely missing at random. This argument is not necessary except the user wish to vary percent missing completely at random across replications. The <code>pmMCAR</code> here is a vector of percent missing, which the values can be in between 0 and 1 only. The specification of <code>objMissing</code> is not needed (but is needed if users wish to specify complex missing value data generation or wish to use multiple imputation). 
</p>
</td></tr>
<tr><td><code id="exportData_+3A_pmmar">pmMAR</code></td>
<td>

<p>The percent missing at random. This argument is not necessary except the user wish to vary percent missing at random across replications. The <code>pmMAR</code> here is a vector of percent missing, which the values can be in between 0 and 1 only. The specification of <code>objMissing</code> is not needed (but is needed if users wish to specify complex missing value data generation or wish to use multiple imputation). 
</p>
</td></tr>
<tr><td><code id="exportData_+3A_facdist">facDist</code></td>
<td>
 
<p>A <code><a href="#topic+SimDataDist-class">SimDataDist</a></code> object or list of objects for the distribution of factors. If one object is passed, all factors will have the same distribution. Use when <code>sequential</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_inddist">indDist</code></td>
<td>
 
<p>A <code><a href="#topic+SimDataDist-class">SimDataDist</a></code> object or list of objects for a distribution of indicators. If one object is passed, each indicator will have the same distribution. Use when <code>sequential</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_errordist">errorDist</code></td>
<td>
 
<p>An object or list of objects of type <code>SimDataDist</code> indicating the distribution of errors. If a single <code>SimDataDist</code> is specified, each error will be genrated with that distribution.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_sequential">sequential</code></td>
<td>
 
<p>If <code>TRUE</code>, use a sequential method to create data such that the data from factor are generated first and apply to a set of equations to obtain the data of indicators. If <code>FALSE</code>, create data directly from model-implied mean and covariance of indicators.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_modelboot">modelBoot</code></td>
<td>
 
<p>When specified, a model-based bootstrap is used for data generation. See <code><a href="#topic+draw">draw</a></code> for further information. This argument requires real data to be passed to <code>realData</code>.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_realdata">realData</code></td>
<td>
 
<p>A data.frame containing real data. The data generated will follow the distribution of this data set.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_maxdraw">maxDraw</code></td>
<td>
 
<p>Integer specifying the maximum number of attempts to draw a valid set of parameters (no negative error variance, standardized coefficients over 1).
</p>
</td></tr>
<tr><td><code id="exportData_+3A_misfittype">misfitType</code></td>
<td>
 
<p>Character vector indicating the fit measure used to assess the misfit of a set of parameters. Can be &quot;f0&quot;, &quot;rmsea&quot;, &quot;srmr&quot;, or &quot;all&quot;. 
</p>
</td></tr>
<tr><td><code id="exportData_+3A_misfitbounds">misfitBounds</code></td>
<td>
 
<p>Vector that contains upper and lower bounds of the misfit measure. Sets of parameters drawn that are not within these bounds are rejected.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_averagenummisspec">averageNumMisspec</code></td>
<td>
 
<p>If <code>TRUE</code>, the provided fit will be divided by the number of misspecified parameters. 
</p>
</td></tr>
<tr><td><code id="exportData_+3A_optmisfit">optMisfit</code></td>
<td>
 
<p>Character vector of either &quot;min&quot; or &quot;max&quot; indicating either maximum or minimum optimized misfit. If not null, the set of parameters out of the number of draws in &quot;optDraws&quot; that has either the maximum or minimum misfit of the given misfit type will be returned.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_optdraws">optDraws</code></td>
<td>
 
<p>Number of parameter sets to draw if optMisfit is not null. The set of parameters with the maximum or minimum misfit will be returned.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_seed">seed</code></td>
<td>
 
<p>Random number seed. Reproducibility across multiple cores or clusters is ensured using R'Lecuyer package.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_silent">silent</code></td>
<td>
 
<p>If <code>TRUE</code>, suppress warnings.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_multicore">multicore</code></td>
<td>
 
<p>Use multiple processors within a computer. Specify as TRUE to use it.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_numproc">numProc</code></td>
<td>
 
<p>Number of processors for using multiple processors. If it is <code>NULL</code>, the package will find the maximum number of processors.
</p>
</td></tr>
<tr><td><code id="exportData_+3A_params">params</code></td>
<td>
 
<p>If <code>TRUE</code>, the parameters from each replication will be returned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text files saved to the current working directory. If <code>program</code> = &quot;Mplus&quot; one file is output for each replication, and an extra file is output with the names of all saved data sets (this file can be used with the MONTECARLO command in Mplus). If <code>program</code> = &quot;LISREL&quot; one file is output with each replication stacked on top of the next (this file can be used with the RP command in LISREL). If <code>program</code> = <code>TRUE</code>, a list of parameter values for each replication is returned.
</p>


<h3>Author(s)</h3>

	
<p>Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>) 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

## Export 20 replications to an external data file (not run).
#exportData(20, CFA.Model, 200)
</code></pre>

<hr>
<h2 id='findCoverage'>
Find a value of independent variables that provides a given value of coverage rate 
</h2><span id='topic+findCoverage'></span>

<h3>Description</h3>

<p>Find a value of independent variable that provides a given value of coverage rate. If there are more than one varying parameters, this function will find the value of the target varying parameters given the values of the other varying parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findCoverage(coverTable, iv, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findCoverage_+3A_covertable">coverTable</code></td>
<td>

<p>A <code>data.frame</code> providing varying parameters and coverage rates of each parameter. This table is obtained by <code><a href="#topic+getPower">getPower</a></code> or <code><a href="#topic+continuousPower">continuousPower</a></code> function.
</p>
</td></tr>
<tr><td><code id="findCoverage_+3A_iv">iv</code></td>
<td>

<p>The target varying parameter that users would like to find the value providing a given power from. This argument can be specified as the index of the target column or the name of target column (i.e., <code>"iv.N"</code> or <code>"N"</code>)
</p>
</td></tr>
<tr><td><code id="findCoverage_+3A_target">target</code></td>
<td>

<p>The target coverage rate
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>There are five possible types of values provided:
</p>

<ul>
<li> <p><em>Value</em> The varying parameter value that provides the coverage rate just under the specified coverage rate (the adjacent value of varying parameter provides over power than the specified power value).
</p>
</li>
<li> <p><em>Minimum value</em> The minimum value has already provided the low coverage rate (way under the specified coverage rate). The value of varying parameters that provides exact coverage rate may be lower than the minimum value. The example of varying parameter that can provides the minimum value is sample size.
</p>
</li>
<li> <p><em>Maximum value</em> The maximum value has already provided the low coverage rate (way under the specified coverage rate). The value of varying parameters that provides exact desired power may be higher than the maximum value. The example of varying parameter that can provides the maximum value is percent missing.
</p>
</li>
<li> <p><code>NA</code> There is no value in the domain of varying parameters that provides the coverage rate lower than the desired coverage rate.
</p>
</li>
<li> <p><code>Inf</code> The coverage rate of all values in the varying parameters is 0 (specifically more than 0.0001) and any values of the varying parameters can be picked and still provide enough power.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+getCoverage">getCoverage</a></code> to find the coverage rate of parameter estimates		
</p>
</li>
<li> <p><code><a href="#topic+continuousCoverage">continuousCoverage</a></code> to find the coverage rate of parameter estimates for the result object (<code>linkS4class{SimResult}</code>) with varying parameters.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Specify Sample Size by n
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.4)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both sample size and percent missing completely at random. Note that more fine-grained 
# values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) and pmMCAR=seq(0, 0.2, 0.01)
Output &lt;- sim(NULL, model=CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))

# Find the power of all possible combination of N and pmMCAR
cover &lt;- getCoverage(Output, coverValue = 0)

# Find the sample size that provides the power of 0.8
findCoverage(cover, "N", 0.20)

## End(Not run)
</code></pre>

<hr>
<h2 id='findFactorIntercept'>
Find factor intercept from regression coefficient matrix and factor total means
</h2><span id='topic+findFactorIntercept'></span>

<h3>Description</h3>

<p>Find factor intercept from regression coefficient matrix and factor total means for latent variable models. In the path analysis model, this function will find indicator intercept from regression coefficient and indicator total means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFactorIntercept(beta, factorMean = NULL, gamma = NULL, covmean = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findFactorIntercept_+3A_beta">beta</code></td>
<td>

<p>Regression coefficient matrix among factors
</p>
</td></tr>
<tr><td><code id="findFactorIntercept_+3A_factormean">factorMean</code></td>
<td>

<p>A vector of total (model-implied) factor (indicator) means. The default is that all total factor means are 0.
</p>
</td></tr>
<tr><td><code id="findFactorIntercept_+3A_gamma">gamma</code></td>
<td>

<p>Regression coefficient matrix from covariates (column) to factors (rows)
</p>
</td></tr>
<tr><td><code id="findFactorIntercept_+3A_covmean">covmean</code></td>
<td>

<p>A vector of covariate means.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of factor (indicator) intercepts
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+findIndIntercept">findIndIntercept</a></code> to find indicator (measurement) intercepts
</p>
</li>
<li> <p><code><a href="#topic+findIndMean">findIndMean</a></code> to find indicator (measurement) total means
</p>
</li>
<li> <p><code><a href="#topic+findIndResidualVar">findIndResidualVar</a></code> to find indicator (measurement) residual variances
</p>
</li>
<li> <p><code><a href="#topic+findIndTotalVar">findIndTotalVar</a></code> to find indicator (measurement) total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorMean">findFactorMean</a></code> to find factor means
</p>
</li>
<li> <p><code><a href="#topic+findFactorResidualVar">findFactorResidualVar</a></code> to find factor residual variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalVar">findFactorTotalVar</a></code> to find factor total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalCov">findFactorTotalCov</a></code> to find factor covariances
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- matrix(0, 9, 9)
path[4, 1] &lt;- path[7, 4] &lt;- 0.6
path[5, 2] &lt;- path[8, 5] &lt;- 0.6
path[6, 3] &lt;- path[9, 6] &lt;- 0.6
path[5, 1] &lt;- path[8, 4] &lt;- 0.4
path[6, 2] &lt;- path[9, 5] &lt;- 0.4
factorMean &lt;- c(5, 2, 3, 0, 0, 0, 0, 0, 0)
findFactorIntercept(path, factorMean)
</code></pre>

<hr>
<h2 id='findFactorMean'>
Find factor total means from regression coefficient matrix and factor intercept
</h2><span id='topic+findFactorMean'></span>

<h3>Description</h3>

<p>Find factor total means from regression coefficient matrix and factor intercepts for latent variable models. In the path analysis model, this function will find indicator total means from regression coefficient and indicator intercept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFactorMean(beta, alpha = NULL, gamma = NULL, covmean = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findFactorMean_+3A_beta">beta</code></td>
<td>

<p>Regression coefficient matrix among factors
</p>
</td></tr>
<tr><td><code id="findFactorMean_+3A_alpha">alpha</code></td>
<td>

<p>Factor (indicator) intercept. The default is that all factor intercepts are 0.
</p>
</td></tr>
<tr><td><code id="findFactorMean_+3A_gamma">gamma</code></td>
<td>

<p>Regression coefficient matrix from covariates (column) to factors (rows)
</p>
</td></tr>
<tr><td><code id="findFactorMean_+3A_covmean">covmean</code></td>
<td>

<p>A vector of covariate means.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of factor (indicator) total means
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+findIndIntercept">findIndIntercept</a></code> to find indicator (measurement) intercepts
</p>
</li>
<li> <p><code><a href="#topic+findIndMean">findIndMean</a></code> to find indicator (measurement) total means
</p>
</li>
<li> <p><code><a href="#topic+findIndResidualVar">findIndResidualVar</a></code> to find indicator (measurement) residual variances
</p>
</li>
<li> <p><code><a href="#topic+findIndTotalVar">findIndTotalVar</a></code> to find indicator (measurement) total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorIntercept">findFactorIntercept</a></code> to find factor intercepts
</p>
</li>
<li> <p><code><a href="#topic+findFactorResidualVar">findFactorResidualVar</a></code> to find factor residual variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalVar">findFactorTotalVar</a></code> to find factor total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalCov">findFactorTotalCov</a></code> to find factor covariances
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- matrix(0, 9, 9)
path[4, 1] &lt;- path[7, 4] &lt;- 0.6
path[5, 2] &lt;- path[8, 5] &lt;- 0.6
path[6, 3] &lt;- path[9, 6] &lt;- 0.6
path[5, 1] &lt;- path[8, 4] &lt;- 0.4
path[6, 2] &lt;- path[9, 5] &lt;- 0.4
intcept &lt;- c(5, 2, 3, 0, 0, 0, 0, 0, 0)
findFactorMean(path, intcept)
</code></pre>

<hr>
<h2 id='findFactorResidualVar'>
Find factor residual variances from regression coefficient matrix, factor (residual) correlations, and total factor variances
</h2><span id='topic+findFactorResidualVar'></span>

<h3>Description</h3>

<p>Find factor residual variances from regression coefficient matrix, factor (residual) correlation matrix, and total factor variances  for latent variable models. In the path analysis model, this function will find indicator residual variances from regression coefficient, indicator (residual) correlation matrix, and total indicator variances. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFactorResidualVar(beta, corPsi, totalVarPsi = NULL, gamma = NULL, covcov = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findFactorResidualVar_+3A_beta">beta</code></td>
<td>

<p>Regression coefficient matrix among factors
</p>
</td></tr>
<tr><td><code id="findFactorResidualVar_+3A_corpsi">corPsi</code></td>
<td>

<p>Factor or indicator residual correlations.
</p>
</td></tr>
<tr><td><code id="findFactorResidualVar_+3A_totalvarpsi">totalVarPsi</code></td>
<td>

<p>Factor or indicator total variances. The default is that all factor or indicator total variances are 1. 
</p>
</td></tr>
<tr><td><code id="findFactorResidualVar_+3A_gamma">gamma</code></td>
<td>

<p>Regression coefficient matrix from covariates (column) to factors (rows)
</p>
</td></tr>
<tr><td><code id="findFactorResidualVar_+3A_covcov">covcov</code></td>
<td>

<p>A covariance matrix among covariates
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of factor (indicator) residual variances
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+findIndIntercept">findIndIntercept</a></code> to find indicator (measurement) intercepts
</p>
</li>
<li> <p><code><a href="#topic+findIndMean">findIndMean</a></code> to find indicator (measurement) total means
</p>
</li>
<li> <p><code><a href="#topic+findIndResidualVar">findIndResidualVar</a></code> to find indicator (measurement) residual variances
</p>
</li>
<li> <p><code><a href="#topic+findIndTotalVar">findIndTotalVar</a></code> to find indicator (measurement) total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorIntercept">findFactorIntercept</a></code> to find factor intercepts
</p>
</li>
<li> <p><code><a href="#topic+findFactorMean">findFactorMean</a></code> to find factor means
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalVar">findFactorTotalVar</a></code> to find factor total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalCov">findFactorTotalCov</a></code> to find factor covariances
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- matrix(0, 9, 9)
path[4, 1] &lt;- path[7, 4] &lt;- 0.6
path[5, 2] &lt;- path[8, 5] &lt;- 0.6
path[6, 3] &lt;- path[9, 6] &lt;- 0.6
path[5, 1] &lt;- path[8, 4] &lt;- 0.4
path[6, 2] &lt;- path[9, 5] &lt;- 0.4
facCor &lt;- diag(9)
facCor[1, 2] &lt;- facCor[2, 1] &lt;- 0.4
facCor[1, 3] &lt;- facCor[3, 1] &lt;- 0.4
facCor[2, 3] &lt;- facCor[3, 2] &lt;- 0.4
totalVar &lt;- rep(1, 9)
findFactorResidualVar(path, facCor, totalVar)
</code></pre>

<hr>
<h2 id='findFactorTotalCov'>
Find factor total covariance from regression coefficient matrix, factor residual covariance
</h2><span id='topic+findFactorTotalCov'></span>

<h3>Description</h3>

<p>Find factor total covariances from regression coefficient matrix, factor residual covariance matrix. The residual covaraince matrix might be derived from factor residual correlation, total variance, and error variance. This function can be applied for path analysis model as well. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFactorTotalCov(beta, psi = NULL, corPsi = NULL, totalVarPsi = NULL, 
    errorVarPsi = NULL, gamma = NULL, covcov = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findFactorTotalCov_+3A_beta">beta</code></td>
<td>

<p>Regression coefficient matrix among factors
</p>
</td></tr>
<tr><td><code id="findFactorTotalCov_+3A_psi">psi</code></td>
<td>

<p>Factor or indicator residual covariances. This argument can be skipped if factor residual correlation and either total variances or error variances are specified.
</p>
</td></tr>
<tr><td><code id="findFactorTotalCov_+3A_corpsi">corPsi</code></td>
<td>

<p>Factor or indicator residual correlation. This argument must be specified with total variances or error variances.
</p>
</td></tr>
<tr><td><code id="findFactorTotalCov_+3A_totalvarpsi">totalVarPsi</code></td>
<td>

<p>Factor or indicator total variances.
</p>
</td></tr>
<tr><td><code id="findFactorTotalCov_+3A_errorvarpsi">errorVarPsi</code></td>
<td>

<p>Factor or indicator residual variances. 
</p>
</td></tr>
<tr><td><code id="findFactorTotalCov_+3A_gamma">gamma</code></td>
<td>

<p>Regression coefficient matrix from covariates (column) to factors (rows)
</p>
</td></tr>
<tr><td><code id="findFactorTotalCov_+3A_covcov">covcov</code></td>
<td>

<p>A covariance matrix among covariates
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of factor (model-implied) total covariance
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+findIndIntercept">findIndIntercept</a></code> to find indicator (measurement) intercepts
</p>
</li>
<li> <p><code><a href="#topic+findIndMean">findIndMean</a></code> to find indicator (measurement) total means
</p>
</li>
<li> <p><code><a href="#topic+findIndResidualVar">findIndResidualVar</a></code> to find indicator (measurement) residual variances
</p>
</li>
<li> <p><code><a href="#topic+findIndTotalVar">findIndTotalVar</a></code> to find indicator (measurement) total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorIntercept">findFactorIntercept</a></code> to find factor intercepts
</p>
</li>
<li> <p><code><a href="#topic+findFactorMean">findFactorMean</a></code> to find factor means
</p>
</li>
<li> <p><code><a href="#topic+findFactorResidualVar">findFactorResidualVar</a></code> to find factor residual variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalVar">findFactorTotalVar</a></code> to find factor total variances
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- matrix(0, 9, 9)
path[4, 1] &lt;- path[7, 4] &lt;- 0.6
path[5, 2] &lt;- path[8, 5] &lt;- 0.6
path[6, 3] &lt;- path[9, 6] &lt;- 0.6
path[5, 1] &lt;- path[8, 4] &lt;- 0.4
path[6, 2] &lt;- path[9, 5] &lt;- 0.4
facCor &lt;- diag(9)
facCor[1, 2] &lt;- facCor[2, 1] &lt;- 0.4
facCor[1, 3] &lt;- facCor[3, 1] &lt;- 0.4
facCor[2, 3] &lt;- facCor[3, 2] &lt;- 0.4
residualVar &lt;- c(1, 1, 1, 0.64, 0.288, 0.288, 0.64, 0.29568, 0.21888)
findFactorTotalCov(path, corPsi=facCor, errorVarPsi=residualVar)
</code></pre>

<hr>
<h2 id='findFactorTotalVar'>
Find factor total variances from regression coefficient matrix, factor (residual) correlations, and factor residual variances
</h2><span id='topic+findFactorTotalVar'></span>

<h3>Description</h3>

<p>Find factor total variances from regression coefficient matrix, factor (residual) correlation matrix, and factor residual variances  for latent variable models. In the path analysis model, this function will find indicator total variances from regression coefficient, indicator (residual) correlation matrix, and indicator residual variances. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFactorTotalVar(beta, corPsi, residualVarPsi, gamma = NULL, covcov = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findFactorTotalVar_+3A_beta">beta</code></td>
<td>

<p>Regression coefficient matrix among factors
</p>
</td></tr>
<tr><td><code id="findFactorTotalVar_+3A_corpsi">corPsi</code></td>
<td>

<p>Factor or indicator residual correlations.
</p>
</td></tr>
<tr><td><code id="findFactorTotalVar_+3A_residualvarpsi">residualVarPsi</code></td>
<td>

<p>Factor or indicator residual variances. 
</p>
</td></tr>
<tr><td><code id="findFactorTotalVar_+3A_gamma">gamma</code></td>
<td>

<p>Regression coefficient matrix from covariates (column) to factors (rows)
</p>
</td></tr>
<tr><td><code id="findFactorTotalVar_+3A_covcov">covcov</code></td>
<td>

<p>A covariance matrix among covariates
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of factor (indicator) total variances
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+findIndIntercept">findIndIntercept</a></code> to find indicator (measurement) intercepts
</p>
</li>
<li> <p><code><a href="#topic+findIndMean">findIndMean</a></code> to find indicator (measurement) total means
</p>
</li>
<li> <p><code><a href="#topic+findIndResidualVar">findIndResidualVar</a></code> to find indicator (measurement) residual variances
</p>
</li>
<li> <p><code><a href="#topic+findIndTotalVar">findIndTotalVar</a></code> to find indicator (measurement) total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorIntercept">findFactorIntercept</a></code> to find factor intercepts
</p>
</li>
<li> <p><code><a href="#topic+findFactorMean">findFactorMean</a></code> to find factor means
</p>
</li>
<li> <p><code><a href="#topic+findFactorResidualVar">findFactorResidualVar</a></code> to find factor residual variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalCov">findFactorTotalCov</a></code> to find factor covariances
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- matrix(0, 9, 9)
path[4, 1] &lt;- path[7, 4] &lt;- 0.6
path[5, 2] &lt;- path[8, 5] &lt;- 0.6
path[6, 3] &lt;- path[9, 6] &lt;- 0.6
path[5, 1] &lt;- path[8, 4] &lt;- 0.4
path[6, 2] &lt;- path[9, 5] &lt;- 0.4
facCor &lt;- diag(9)
facCor[1, 2] &lt;- facCor[2, 1] &lt;- 0.4
facCor[1, 3] &lt;- facCor[3, 1] &lt;- 0.4
facCor[2, 3] &lt;- facCor[3, 2] &lt;- 0.4
residualVar &lt;- c(1, 1, 1, 0.64, 0.288, 0.288, 0.64, 0.29568, 0.21888)
findFactorTotalVar(path, facCor, residualVar)
</code></pre>

<hr>
<h2 id='findIndIntercept'>
Find indicator intercepts from factor loading matrix, total factor mean, and indicator mean.
</h2><span id='topic+findIndIntercept'></span>

<h3>Description</h3>

<p>Find indicator (measurement) intercepts from a factor loading matrix, total factor mean, and indicator mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findIndIntercept(lambda, factorMean = NULL, indicatorMean = NULL, 
	kappa = NULL, covmean = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findIndIntercept_+3A_lambda">lambda</code></td>
<td>

<p>Factor loading matrix
</p>
</td></tr>
<tr><td><code id="findIndIntercept_+3A_factormean">factorMean</code></td>
<td>

<p>Total (model-implied) mean of factors. As a default, all total factor means are 0.
</p>
</td></tr>
<tr><td><code id="findIndIntercept_+3A_indicatormean">indicatorMean</code></td>
<td>

<p>Total indicator means. As a default, all total indicator means are 0.
</p>
</td></tr>
<tr><td><code id="findIndIntercept_+3A_kappa">kappa</code></td>
<td>

<p>Regression coefficient matrix from covariates (column) to indicators (rows)
</p>
</td></tr>
<tr><td><code id="findIndIntercept_+3A_covmean">covmean</code></td>
<td>

<p>A vector of covariate means.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indicator (measurement) intercepts.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+findIndMean">findIndMean</a></code> to find indicator (measurement) total means
</p>
</li>
<li> <p><code><a href="#topic+findIndResidualVar">findIndResidualVar</a></code> to find indicator (measurement) residual variances
</p>
</li>
<li> <p><code><a href="#topic+findIndTotalVar">findIndTotalVar</a></code> to find indicator (measurement) total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorIntercept">findFactorIntercept</a></code> to find factor intercepts
</p>
</li>
<li> <p><code><a href="#topic+findFactorMean">findFactorMean</a></code> to find factor means
</p>
</li>
<li> <p><code><a href="#topic+findFactorResidualVar">findFactorResidualVar</a></code> to find factor residual variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalVar">findFactorTotalVar</a></code> to find factor total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalCov">findFactorTotalCov</a></code> to find factor covariances
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- c(0.6, 0.7, 0.8)
loading[4:6, 2] &lt;- c(0.6, 0.7, 0.8)
facMean &lt;- c(0.5, 0.2)
indMean &lt;- rep(1, 6)
findIndIntercept(loading, facMean, indMean)
</code></pre>

<hr>
<h2 id='findIndMean'>
Find indicator total means from factor loading matrix, total factor mean, and indicator intercept.
</h2><span id='topic+findIndMean'></span>

<h3>Description</h3>

<p>Find indicator total means from a factor loading matrix, total factor means, and indicator (measurement) intercepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findIndMean(lambda, factorMean = NULL, tau = NULL, kappa = NULL, 
	covmean = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findIndMean_+3A_lambda">lambda</code></td>
<td>

<p>Factor loading matrix
</p>
</td></tr>
<tr><td><code id="findIndMean_+3A_factormean">factorMean</code></td>
<td>

<p>Total (model-implied) mean of factors. As a default, all total factor means are 0.
</p>
</td></tr>
<tr><td><code id="findIndMean_+3A_tau">tau</code></td>
<td>

<p>Indicator (measurement) intercepts. As a default, all intercepts are 0.
</p>
</td></tr>
<tr><td><code id="findIndMean_+3A_kappa">kappa</code></td>
<td>

<p>Regression coefficient matrix from covariates (column) to indicators (rows)
</p>
</td></tr>
<tr><td><code id="findIndMean_+3A_covmean">covmean</code></td>
<td>

<p>A vector of covariate means.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indicator total means.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+findIndIntercept">findIndIntercept</a></code> to find indicator (measurement) intercepts
</p>
</li>
<li> <p><code><a href="#topic+findIndResidualVar">findIndResidualVar</a></code> to find indicator (measurement) residual variances
</p>
</li>
<li> <p><code><a href="#topic+findIndTotalVar">findIndTotalVar</a></code> to find indicator (measurement) total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorIntercept">findFactorIntercept</a></code> to find factor intercepts
</p>
</li>
<li> <p><code><a href="#topic+findFactorMean">findFactorMean</a></code> to find factor means
</p>
</li>
<li> <p><code><a href="#topic+findFactorResidualVar">findFactorResidualVar</a></code> to find factor residual variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalVar">findFactorTotalVar</a></code> to find factor total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalCov">findFactorTotalCov</a></code> to find factor covariances
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- c(0.6, 0.7, 0.8)
loading[4:6, 2] &lt;- c(0.6, 0.7, 0.8)
facMean &lt;- c(0.5, 0.2)
intcept &lt;- rep(0, 6)
findIndMean(loading, facMean, intcept)
</code></pre>

<hr>
<h2 id='findIndResidualVar'>
Find indicator residual variances from factor loading matrix, total factor covariance, and total indicator variances.
</h2><span id='topic+findIndResidualVar'></span>

<h3>Description</h3>

<p>Find indicator (measurement) residual variances from a factor loading matrix, total factor covariance matrix, and total indicator variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findIndResidualVar(lambda, totalFactorCov, totalVarTheta = NULL, 
	kappa = NULL, covcov = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findIndResidualVar_+3A_lambda">lambda</code></td>
<td>

<p>Factor loading matrix
</p>
</td></tr>
<tr><td><code id="findIndResidualVar_+3A_totalfactorcov">totalFactorCov</code></td>
<td>

<p>Total (model-implied) covariance matrix among factors. 
</p>
</td></tr>
<tr><td><code id="findIndResidualVar_+3A_totalvartheta">totalVarTheta</code></td>
<td>

<p>Indicator total variances. As a default, all total variances are 1.
</p>
</td></tr>
<tr><td><code id="findIndResidualVar_+3A_kappa">kappa</code></td>
<td>

<p>Regression coefficient matrix from covariates (column) to indicators (rows)
</p>
</td></tr>
<tr><td><code id="findIndResidualVar_+3A_covcov">covcov</code></td>
<td>

<p>A covariance matrix among covariates
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indicator residual variances.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+findIndIntercept">findIndIntercept</a></code> to find indicator (measurement) intercepts
</p>
</li>
<li> <p><code><a href="#topic+findIndMean">findIndMean</a></code> to find indicator (measurement) total means
</p>
</li>
<li> <p><code><a href="#topic+findIndTotalVar">findIndTotalVar</a></code> to find indicator (measurement) total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorIntercept">findFactorIntercept</a></code> to find factor intercepts
</p>
</li>
<li> <p><code><a href="#topic+findFactorMean">findFactorMean</a></code> to find factor means
</p>
</li>
<li> <p><code><a href="#topic+findFactorResidualVar">findFactorResidualVar</a></code> to find factor residual variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalVar">findFactorTotalVar</a></code> to find factor total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalCov">findFactorTotalCov</a></code> to find factor covariances
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- c(0.6, 0.7, 0.8)
loading[4:6, 2] &lt;- c(0.6, 0.7, 0.8)
facCov &lt;- matrix(c(1, 0.5, 0.5, 1), 2, 2)
totalVar &lt;- rep(1, 6)
findIndResidualVar(loading, facCov, totalVar)
</code></pre>

<hr>
<h2 id='findIndTotalVar'>
Find indicator total variances from factor loading matrix, total factor covariance, and indicator residual variances.
</h2><span id='topic+findIndTotalVar'></span>

<h3>Description</h3>

<p>Find indicator total variances from a factor loading matrix, total factor covariance matrix, and indicator (measurement) residual variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findIndTotalVar(lambda, totalFactorCov, residualVarTheta, kappa = NULL, 
	covcov = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findIndTotalVar_+3A_lambda">lambda</code></td>
<td>

<p>Factor loading matrix
</p>
</td></tr>
<tr><td><code id="findIndTotalVar_+3A_totalfactorcov">totalFactorCov</code></td>
<td>

<p>Total (model-implied) covariance matrix among factors. 
</p>
</td></tr>
<tr><td><code id="findIndTotalVar_+3A_residualvartheta">residualVarTheta</code></td>
<td>

<p>Indicator (measurement) residual variances. 
</p>
</td></tr>
<tr><td><code id="findIndTotalVar_+3A_kappa">kappa</code></td>
<td>

<p>Regression coefficient matrix from covariates (column) to indicators (rows)
</p>
</td></tr>
<tr><td><code id="findIndTotalVar_+3A_covcov">covcov</code></td>
<td>

<p>A covariance matrix among covariates
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indicator total variances.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+findIndIntercept">findIndIntercept</a></code> to find indicator (measurement) intercepts
</p>
</li>
<li> <p><code><a href="#topic+findIndMean">findIndMean</a></code> to find indicator (measurement) total means
</p>
</li>
<li> <p><code><a href="#topic+findIndResidualVar">findIndResidualVar</a></code> to find indicator (measurement) residual variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorIntercept">findFactorIntercept</a></code> to find factor intercepts
</p>
</li>
<li> <p><code><a href="#topic+findFactorMean">findFactorMean</a></code> to find factor means
</p>
</li>
<li> <p><code><a href="#topic+findFactorResidualVar">findFactorResidualVar</a></code> to find factor residual variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalVar">findFactorTotalVar</a></code> to find factor total variances
</p>
</li>
<li> <p><code><a href="#topic+findFactorTotalCov">findFactorTotalCov</a></code> to find factor covariances
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- c(0.6, 0.7, 0.8)
loading[4:6, 2] &lt;- c(0.6, 0.7, 0.8)
facCov &lt;- matrix(c(1, 0.5, 0.5, 1), 2, 2)
resVar &lt;- c(0.64, 0.51, 0.36, 0.64, 0.51, 0.36)
findIndTotalVar(loading, facCov, resVar)
</code></pre>

<hr>
<h2 id='findPossibleFactorCor'>
Find the appropriate position for freely estimated correlation (or covariance) given a regression coefficient matrix
</h2><span id='topic+findPossibleFactorCor'></span>

<h3>Description</h3>

<p>Find the appropriate position for freely estimated correlation (or covariance) given a regression coefficient matrix. The appropriate position is the pair of variables that are not causally related.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPossibleFactorCor(beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPossibleFactorCor_+3A_beta">beta</code></td>
<td>

<p>The regression coefficient in path analysis.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The symmetric matrix containing the appropriate position for freely estimated correlation.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+findRecursiveSet">findRecursiveSet</a></code> to group variables regarding the position in mediation chain.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- matrix(0, 9, 9)
path[4, 1] &lt;- path[7, 4] &lt;- NA
path[5, 2] &lt;- path[8, 5] &lt;- NA
path[6, 3] &lt;- path[9, 6] &lt;- NA
path[5, 1] &lt;- path[8, 4] &lt;- NA
path[6, 2] &lt;- path[9, 5] &lt;- NA
findPossibleFactorCor(path)
</code></pre>

<hr>
<h2 id='findPower'>
Find a value of independent variables that provides a given value of power. 
</h2><span id='topic+findPower'></span>

<h3>Description</h3>

<p>Find a value of independent variable that provides a given value of power. If there are more than one varying parameters, this function will find the value of the target varying parameters given the values of the other varying parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPower(powerTable, iv, power)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPower_+3A_powertable">powerTable</code></td>
<td>

<p>A <code>data.frame</code> providing varying parameters and powers of each parameter. This table is obtained by <code><a href="#topic+getPower">getPower</a></code> or <code><a href="#topic+continuousPower">continuousPower</a></code> function.
</p>
</td></tr>
<tr><td><code id="findPower_+3A_iv">iv</code></td>
<td>

<p>The target varying parameter that users would like to find the value providing a given power from. This argument can be specified as the index of the target column or the name of target column (i.e., <code>"iv.N"</code> or <code>"N"</code>)
</p>
</td></tr>
<tr><td><code id="findPower_+3A_power">power</code></td>
<td>

<p>A desired power.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>There are five possible types of values provided:
</p>

<ul>
<li> <p><em>Value</em> The varying parameter value that provides the power just over the specified power value (the adjacent value of varying parameter provides lower power than the specified power value).
</p>
</li>
<li> <p><em>Minimum value</em> The minimum value has already provided enough power (way over the specified power value). The value of varying parameters that provides exact desired power may be lower than the minimum value. The example of varying parameter that can provides the minimum value is sample size.
</p>
</li>
<li> <p><em>Maximum value</em> The maximum value has already provided enough power (way over the specified power value). The value of varying parameters that provides exact desired power may be higher than the maximum value. The example of varying parameter that can provides the maximum value is percent missing.
</p>
</li>
<li> <p><code>NA</code> There is no value in the domain of varying parameters that provides the power greater than the desired power.
</p>
</li>
<li> <p><code>Inf</code> The power of all values in the varying parameters is 1 (specifically more than 0.9999) and any values of the varying parameters can be picked and still provide enough power.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+getPower">getPower</a></code> to find the power of parameter estimates		
</p>
</li>
<li> <p><code><a href="#topic+continuousPower">continuousPower</a></code> to find the power of parameter estimates for the result object (<code>linkS4class{SimResult}</code>) with varying parameters.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Specify Sample Size by n
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.4)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both sample size and percent missing completely at random. Note that more fine-grained 
# values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) and pmMCAR=seq(0, 0.2, 0.01)
Output &lt;- sim(NULL, model=CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))

# Find the power of all possible combination of N and pmMCAR
pow &lt;- getPower(Output)

# Find the sample size that provides the power of 0.8
findPower(pow, "N", 0.80)

## End(Not run)
</code></pre>

<hr>
<h2 id='findRecursiveSet'>
Group variables regarding the position in mediation chain
</h2><span id='topic+findRecursiveSet'></span>

<h3>Description</h3>

<p>In mediation analysis, variables affects other variables as a chain. This function will group variables regarding the chain of mediation analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findRecursiveSet(beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findRecursiveSet_+3A_beta">beta</code></td>
<td>

<p>The regression coefficient in path analysis.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of set of variables in the mediation chain. The variables in position 1 will be the independent variables. The variables in the last variables will be the end of the chain.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+findPossibleFactorCor">findPossibleFactorCor</a></code> to find the possible position for latent correlation given a regression coefficient matrix
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- matrix(0, 9, 9)
path[4, 1] &lt;- path[7, 4] &lt;- NA
path[5, 2] &lt;- path[8, 5] &lt;- NA
path[6, 3] &lt;- path[9, 6] &lt;- NA
path[5, 1] &lt;- path[8, 4] &lt;- NA
path[6, 2] &lt;- path[9, 5] &lt;- NA
findRecursiveSet(path)
</code></pre>

<hr>
<h2 id='generate'>
Generate data using SimSem template
</h2><span id='topic+generate'></span>

<h3>Description</h3>

<p>This function can be used to generate random data based on the 1. <code><a href="#topic+SimSem-class">SimSem</a></code> objects created with the <code><a href="#topic+model">model</a></code> function, 2. <code>lavaan</code> script or parameter tables, or 3. an <code>MxModel</code> object from the <code>OpenMx</code> package. Some notable features include fine control of misspecification and misspecification optimization (for <code><a href="#topic+SimSem-class">SimSem</a></code> only), as well as the ability to generate non-normal data. When using <em>simsem</em> for simulations, this function is used internally to generate data in the function <code>sim</code>, and can be helpful for debugging, or in creating data for use with other analysis programs. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate(model, n, maxDraw=50, misfitBounds=NULL, misfitType="f0",
	averageNumMisspec=FALSE, optMisfit=NULL, optDraws=50, 
	createOrder = c(1, 2, 3), indDist=NULL, sequential=FALSE,	
	facDist=NULL, errorDist=NULL, saveLatentVar = FALSE, indLab=NULL, 
	modelBoot=FALSE, realData=NULL, covData=NULL, params=FALSE, group = NULL, 
	empirical = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_+3A_model">model</code></td>
<td>

<p>A <code><a href="#topic+SimSem-class">SimSem</a></code> object, a <code>lavaan</code> script or parameter tables, or an <code>MxModel</code> object from the <code>OpenMx</code> package
</p>
</td></tr>
<tr><td><code id="generate_+3A_n">n</code></td>
<td>

<p>Integer of sample size.
</p>
</td></tr>
<tr><td><code id="generate_+3A_maxdraw">maxDraw</code></td>
<td>

<p>Integer specifying the maximum number of attempts to draw a valid set of parameters (no negative error variance, standardized coefficients over 1).
</p>
</td></tr>
<tr><td><code id="generate_+3A_misfitbounds">misfitBounds</code></td>
<td>
 
<p>Vector that contains upper and lower bounds of the misfit measure. Sets of parameters drawn that are not within these bounds are rejected.
</p>
</td></tr>
<tr><td><code id="generate_+3A_misfittype">misfitType</code></td>
<td>
 
<p>Character vector indicating the fit measure used to assess the misfit of a set of parameters. Can be &quot;f0&quot;, &quot;rmsea&quot;, &quot;srmr&quot;, or &quot;all&quot;. 
</p>
</td></tr>
<tr><td><code id="generate_+3A_averagenummisspec">averageNumMisspec</code></td>
<td>
 
<p>If <code>TRUE</code>, the provided fit will be divided by the number of misspecified parameters. 
</p>
</td></tr>
<tr><td><code id="generate_+3A_optmisfit">optMisfit</code></td>
<td>
 
<p>Character vector of either &quot;min&quot; or &quot;max&quot; indicating either maximum or minimum optimized misfit. If not null, the set of parameters out of the number of draws in &quot;optDraws&quot; that has either the maximum or minimum misfit of the given misfit type will be returned.
</p>
</td></tr>
<tr><td><code id="generate_+3A_optdraws">optDraws</code></td>
<td>
 
<p>Number of parameter sets to draw if optMisfit is not null. The set of parameters with the maximum or minimum misfit will be returned.
</p>
</td></tr>
<tr><td><code id="generate_+3A_createorder">createOrder</code></td>
<td>

<p>The order of 1) applying equality/inequality constraints, 2) applying misspecification, and 3) fill unspecified parameters (e.g., residual variances when total variances are specified). The specification of this argument is a vector of different orders of 1 (constraint), 2 (misspecification), and 3 (filling parameters). For example, <code>c(1, 2, 3)</code> is to apply constraints first, then add the misspecification, and finally fill all parameters. See the example of how to use it in the <code><a href="#topic+draw">draw</a></code> function. 
</p>
</td></tr>
<tr><td><code id="generate_+3A_inddist">indDist</code></td>
<td>
 
<p>A <code><a href="#topic+SimDataDist-class">SimDataDist</a></code> object or list of objects for a distribution of indicators. If one object is passed, each indicator will have the same distribution. Use when <code>sequential</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="generate_+3A_sequential">sequential</code></td>
<td>
 
<p>If <code>TRUE</code>, use a sequential method to create data such that the data from factor are generated first and apply to a set of equations to obtain the data of indicators. If <code>FALSE</code>, create data directly from model-implied mean and covariance of indicators.
</p>
</td></tr>
<tr><td><code id="generate_+3A_facdist">facDist</code></td>
<td>
 
<p>A <code><a href="#topic+SimDataDist-class">SimDataDist</a></code> object or list of objects for the distribution of factors. If one object is passed, all factors will have the same distribution. Use when <code>sequential</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="generate_+3A_errordist">errorDist</code></td>
<td>
 
<p>An object or list of objects of type <code>SimDataDist</code> indicating the distribution of errors. If a single <code>SimDataDist</code> is specified, each error will be genrated with that distribution.
</p>
</td></tr>
<tr><td><code id="generate_+3A_savelatentvar">saveLatentVar</code></td>
<td>
 
<p>If <code>TRUE</code>, the total latent variable scores, residual latent variable scores, and measurement error scores are also provided as the <code>"latentVar"</code> attribute of the generated data by the following line: <code>attr(generatedData, "latentVar")</code>. The <code>sequential</code> argument must be <code>TRUE</code> in order to use this option.
</p>
</td></tr>
<tr><td><code id="generate_+3A_indlab">indLab</code></td>
<td>
 
<p>A vector of indicator labels. When not specified, the variable names are <code>x1, x2, ... xN</code>.
</p>
</td></tr>
<tr><td><code id="generate_+3A_modelboot">modelBoot</code></td>
<td>
 
<p>When specified, a model-based bootstrap is used for data generation. See details for further information. This argument requires real data to be passed to <code>realData</code>.
</p>
</td></tr>
<tr><td><code id="generate_+3A_realdata">realData</code></td>
<td>
 
<p>A data.frame containing real data. The data generated will follow the distribution of this data set.
</p>
</td></tr>
<tr><td><code id="generate_+3A_covdata">covData</code></td>
<td>
 
<p>A data.frame containing covariate data, which can have any distributions. This argument is required when users specify <code>GA</code> or <code>KA</code> matrices in the model template (<code><a href="#topic+SimSem-class">SimSem</a></code>).
</p>
</td></tr>
<tr><td><code id="generate_+3A_params">params</code></td>
<td>
 
<p>If <code>TRUE</code>, return the parameters drawn along with the generated data set. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="generate_+3A_group">group</code></td>
<td>
 
<p>The label of the grouping variable
</p>
</td></tr>
<tr><td><code id="generate_+3A_empirical">empirical</code></td>
<td>
 
<p>Logical. If <code>TRUE</code>, the specified parameters are treated as sample statistics and data are created to get the specified sample statistics. This argument is applicable when multivariate normal distribution is specified only.
</p>
</td></tr>
<tr><td><code id="generate_+3A_...">...</code></td>
<td>
 
<p>Additional arguments for the <code><a href="lavaan.html#topic+simulateData">simulateData</a></code> function. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>lavaan</code> script or the <code>MxModel</code> are provided, the model-implied covariance matrix will be computed and internally use <code><a href="#topic+createData">createData</a></code> function to generate data. The data-generation method is based on whether the <code>indDist</code> argument is specified. For the <code>lavaan</code> script, the code for data generation is modified from the <code><a href="lavaan.html#topic+simulateData">simulateData</a></code> function.
</p>
<p>If the <code><a href="#topic+SimSem-class">SimSem</a></code> object is specified, it will check whether there are any random parameters or trivial misspecification in the model. If so, real or misspecified parameters are drawn via the <code><a href="#topic+draw">draw</a></code> function. Next, there are two methods to generate data. First, the function will calculate the model-implied covariance matrix (including model misspecification) and generate data similar to the <code>lavaan</code> script or the <code>MxModel</code> object. The second method is referred to as the <code>sequential</code> method, which can be used by specifying the <code>sequential</code> argument as <code>TRUE</code>. This function will create data based on the chain of equations in structural equation modeling such that independent variables and errors are generated and added as dependent variables and the dependent variables will be treated as independent variables in the next equation. For example, in the model with factor A and B are independent variables, factor C are dependent variables, factors A and B are generated first. Then, residual in factor C are created and added with factors A and B. This current step has all factor scores. Then, measurement errors are created and added with factor scores to create indicator scores. During each step, independent variables and errors can be nonnormal by setting <code>facDist</code> or <code>errorDist</code> arguments. The data generation in each step is based on the <code><a href="#topic+createData">createData</a></code> function.
</p>
<p>For the model-based bootstrap (providing the <code>realData</code> argument), the transformation proposed by Yung &amp; Bentler (1996) is used. This procedure is the expansion from the Bollen and Stine (1992) bootstrap including a mean structure. The model-implied mean vector and covariance matrix with trivial misspecification will be used in the model-based bootstrap if <code>misspec</code> is specified. See page 133 of Bollen and Stine (1992) for a reference. 
</p>


<h3>Value</h3>

<p>A data.frame containing simulated data from the data generation template. A variable &quot;group&quot; is appended indicating group membership.
</p>


<h3>Author(s)</h3>

	
<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>), Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>), the data generation code for lavaan script is modifed from the <code>simulateData</code> function in <code>lavaan</code> written by Yves Rosseel
</p>


<h3>References</h3>

<p>Bollen, K. A., &amp; Stine, R. A. (1992). Bootstrapping goodness-of-fit measures in structural equation models. <em>Sociological Methods and Research, 21,</em> 205-229.
</p>
<p>Yung, Y.-F., &amp; Bentler, P. M. (1996). Bootstrapping techniques in analysis of mean and covariance structures. In G. A. Marcoulides &amp; R. E. Schumacker (Eds.), <em>Advanced structural equation modeling: Issues and techniques</em> (pp. 195-226). Mahwah, NJ: Erlbaum.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+draw">draw</a></code> To draw parameters using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li>
<li> <p><code><a href="#topic+createData">createData</a></code> To generate random data using a set of parameters from <code><a href="#topic+draw">draw</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

dat &lt;- generate(CFA.Model, 200)

# Get the latent variable scores

dat2 &lt;- generate(CFA.Model, 20, sequential = TRUE, saveLatentVar = TRUE)
dat2
attr(dat2, "latentVar")
</code></pre>

<hr>
<h2 id='getCIwidth'>
Find confidence interval width
</h2><span id='topic+getCIwidth'></span>

<h3>Description</h3>

<p>Find the median of confidence interval width or a confidence interval value given a degree of assurance (Lai &amp; Kelley, 2011)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCIwidth(object, assurance = 0.50, nVal = NULL, pmMCARval = NULL, 
	pmMARval = NULL, df = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCIwidth_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the analysis results from multiple replications
</p>
</td></tr>
<tr><td><code id="getCIwidth_+3A_assurance">assurance</code></td>
<td>

<p>The percentile of the resulting confidence interval width. When assurance is 0.50, the median of the widths is provided. See Lai &amp; Kelley (2011) for more details.
</p>
</td></tr>
<tr><td><code id="getCIwidth_+3A_nval">nVal</code></td>
<td>

<p>The sample size value that researchers wish to find the confidence interval width from. This argument is applicable for <code><a href="#topic+SimResult-class">SimResult</a></code> with varying sample sizes or percent missing across replications
</p>
</td></tr>
<tr><td><code id="getCIwidth_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent missing completely at random value that researchers wish to find the confidence interval width from. This argument is applicable for <code><a href="#topic+SimResult-class">SimResult</a></code> with varying sample sizes or percent missing across replications
</p>
</td></tr>
<tr><td><code id="getCIwidth_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random value that researchers wish to find the confidence interval width from. This argument is applicable for <code><a href="#topic+SimResult-class">SimResult</a></code> with varying sample sizes or percent missing across replications
</p>
</td></tr>
<tr><td><code id="getCIwidth_+3A_df">df</code></td>
<td>

<p>The degree of freedom used in spline method in predicting the confidence interval width by the predictors. If <code>df</code> is 0, the spline method will not be applied. This argument is applicable for <code><a href="#topic+SimResult-class">SimResult</a></code> with varying sample sizes or percent missing across replications
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The median of confidence interval width or a confidence interval given a degree of assurance
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>References</h3>

<p>Lai, K., &amp; Kelley, K. (2011). Accuracy in parameter estimation for targeted effects in structural equation modeling: Sample size planning for narrow confidence intervals. <em>Psychological Methods, 16</em>, 127-148.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> for a detail of simResult
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loadingValues &lt;- matrix(0, 6, 2)
loadingValues[1:3, 1] &lt;- 0.7
loadingValues[4:6, 2] &lt;- 0.7
LY &lt;- bind(loading, loadingValues)
latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)
error.cor &lt;- matrix(0, 6, 6)
diag(error.cor) &lt;- 1
RTE &lt;- binds(error.cor)
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output &lt;- sim(5, n = 200, model=CFA.Model)

# Get the cutoff (critical value) when alpha is 0.05
getCIwidth(Output, assurance=0.80)

# Finding the cutoff when the sample size is varied. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output2 &lt;- sim(NULL, model=CFA.Model, n=seq(50, 100, 10))

# Get the fit index cutoff when sample size is 75.
getCIwidth(Output2, assurance=0.80, nVal = 75)

## End(Not run)
</code></pre>

<hr>
<h2 id='getCoverage'>
Find coverage rate of model parameters 
</h2><span id='topic+getCoverage'></span>

<h3>Description</h3>

<p>A function to find the coverage rate of confidence intervals in a model when none, one, or more of the simulations parameters vary randomly across replications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCoverage(simResult, coverValue = NULL, contParam = NULL, coverParam = NULL, 
    nVal = NULL, pmMCARval = NULL, pmMARval = NULL, paramVal = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCoverage_+3A_simresult">simResult</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that may include randomly varying parameters (e.g. sample size, percent missing, model parameters)
</p>
</td></tr>
<tr><td><code id="getCoverage_+3A_covervalue">coverValue</code></td>
<td>

<p>A target value used that users wish to find the coverage rate of that value (e.g., 0). If <code>NULL</code>, the parameter values will be used.
</p>
</td></tr>
<tr><td><code id="getCoverage_+3A_contparam">contParam</code></td>
<td>

<p>Vector of parameters names that vary over replications.
</p>
</td></tr>
<tr><td><code id="getCoverage_+3A_coverparam">coverParam</code></td>
<td>

<p>Vector of parameters names that the user wishes to find coverage rate for. This can be a vector of names (e.g., &quot;f1=~y2&quot;, &quot;f1~~f2&quot;). If parameters are not specified, coverage rates for all parameters in the model will be returned.
</p>
</td></tr>
<tr><td><code id="getCoverage_+3A_nval">nVal</code></td>
<td>

<p>The sample size values that users wish to find power from.
</p>
</td></tr>
<tr><td><code id="getCoverage_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent completely missing at random values that users wish to find power from.
</p>
</td></tr>
<tr><td><code id="getCoverage_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random values that users wish to find power from.
</p>
</td></tr>
<tr><td><code id="getCoverage_+3A_paramval">paramVal</code></td>
<td>

<p>A list of varying parameter values that users wish to find power from.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, the coverage (which can be 0 or 1) is regressed on randomly varying simulation parameters (e.g., sample size, percentage of missing data, or model parameters) using logistic regression. For a set of independent variables values, the predicted probability from the logistic regression equation is the predicted coverage rate.
</p>


<h3>Value</h3>

<p>Data frame containing columns representing values of the randomly varying simulation parameters, and coverage rates for model parameters of interest.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>), Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to see how to create a simResult object with randomly varying parameters.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.7)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both sample size and percent missing completely at random. Note that more fine-grained 
# values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) and pmMCAR=seq(0, 0.2, 0.01)
Output &lt;- sim(NULL, model=CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))
summary(Output)

# Get the coverage rates of all possible combinations of n and pmMCAR
getCoverage(Output)

# Get the coverage rates of the combinations of n of 100 and 200 and pmMCAR of 0, 0.1, and 0.2
getCoverage(Output, coverValue = 0, nVal=c(100, 200), pmMCARval=c(0, 0.1, 0.2))

## End(Not run)
</code></pre>

<hr>
<h2 id='getCutoff'>
Find fit indices cutoff given a priori alpha level
</h2><span id='topic+getCutoff'></span>

<h3>Description</h3>

<p>Extract fit indices information from the <code><a href="#topic+SimResult-class">SimResult</a></code> and get the cutoffs of fit indices given a priori alpha level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCutoff(object, alpha, revDirec = FALSE, usedFit = NULL, nVal = NULL, 
	pmMCARval = NULL, pmMARval = NULL, df = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCutoff_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the analysis results from multiple replications
</p>
</td></tr>
<tr><td><code id="getCutoff_+3A_alpha">alpha</code></td>
<td>

<p>A priori alpha level
</p>
</td></tr>
<tr><td><code id="getCutoff_+3A_revdirec">revDirec</code></td>
<td>

<p>The default is to find criticl point on the side that indicates worse fit (the right side of RMSEA or the left side of CFI). If specifying as <code>TRUE</code>, the directions are reversed.
</p>
</td></tr>
<tr><td><code id="getCutoff_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to getCutoffs from. The default is to getCutoffs of all fit indices.
</p>
</td></tr>
<tr><td><code id="getCutoff_+3A_nval">nVal</code></td>
<td>

<p>The sample size value that researchers wish to find the fit indices cutoffs from. This argument is applicable for <code><a href="#topic+SimResult-class">SimResult</a></code> with varying sample sizes or percent missing across replications
</p>
</td></tr>
<tr><td><code id="getCutoff_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent missing completely at random value that researchers wish to find the fit indices cutoffs from. This argument is applicable for <code><a href="#topic+SimResult-class">SimResult</a></code> with varying sample sizes or percent missing across replications
</p>
</td></tr>
<tr><td><code id="getCutoff_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random value that researchers wish to find the fit indices cutoffs from. This argument is applicable for <code><a href="#topic+SimResult-class">SimResult</a></code> with varying sample sizes or percent missing across replications
</p>
</td></tr>
<tr><td><code id="getCutoff_+3A_df">df</code></td>
<td>

<p>The degree of freedom used in spline method in predicting the fit indices by the predictors. If <code>df</code> is 0, the spline method will not be applied. This argument is applicable for <code><a href="#topic+SimResult-class">SimResult</a></code> with varying sample sizes or percent missing across replications
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One-tailed cutoffs of several fit indices with a priori alpha level 
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> for a detail of simResult
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loadingValues &lt;- matrix(0, 6, 2)
loadingValues[1:3, 1] &lt;- 0.7
loadingValues[4:6, 2] &lt;- 0.7
LY &lt;- bind(loading, loadingValues)
latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)
error.cor &lt;- matrix(0, 6, 6)
diag(error.cor) &lt;- 1
RTE &lt;- binds(error.cor)
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output &lt;- sim(5, n = 200, model=CFA.Model)

# Get the cutoff (critical value) when alpha is 0.05
getCutoff(Output, 0.05)

# Finding the cutoff when the sample size is varied. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output2 &lt;- sim(NULL, model=CFA.Model, n=seq(50, 100, 10))

# Get the fit index cutoff when sample size is 75.
getCutoff(Output2, 0.05, nVal = 75)

## End(Not run)
</code></pre>

<hr>
<h2 id='getCutoffNested'>
Find fit indices cutoff for nested model comparison given a priori alpha level
</h2><span id='topic+getCutoffNested'></span>

<h3>Description</h3>

<p>Extract fit indices information from the simulation of parent and nested models and getCutoff of fit indices given a priori alpha level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCutoffNested(nested, parent, alpha = 0.05, usedFit = NULL, nVal = NULL, 
	pmMCARval = NULL, pmMARval = NULL, df = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCutoffNested_+3A_nested">nested</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the analysis results of nested model from multiple replications
</p>
</td></tr>
<tr><td><code id="getCutoffNested_+3A_parent">parent</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the analysis results of parent model from multiple replications
</p>
</td></tr>
<tr><td><code id="getCutoffNested_+3A_alpha">alpha</code></td>
<td>

<p>A priori alpha level
</p>
</td></tr>
<tr><td><code id="getCutoffNested_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to getCutoffs from. The default is to getCutoffs of all fit indices.
</p>
</td></tr>
<tr><td><code id="getCutoffNested_+3A_nval">nVal</code></td>
<td>

<p>The sample size value that researchers wish to find the fit indices cutoffs from.
</p>
</td></tr>
<tr><td><code id="getCutoffNested_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent missing completely at random value that researchers wish to find the fit indices cutoffs from.
</p>
</td></tr>
<tr><td><code id="getCutoffNested_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random value that researchers wish to find the fit indices cutoffs from.
</p>
</td></tr>
<tr><td><code id="getCutoffNested_+3A_df">df</code></td>
<td>

<p>The degree of freedom used in spline method in predicting the fit indices by the predictors. If <code>df</code> is 0, the spline method will not be applied.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One-tailed cutoffs of several fit indices with a priori alpha level 
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> for a detail of simResult
<code><a href="#topic+getCutoff">getCutoff</a></code> for a detail of finding cutoffs for absolute fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Nested Model
loading.null &lt;- matrix(0, 6, 1)
loading.null[1:6, 1] &lt;- NA
LY.NULL &lt;- bind(loading.null, 0.7)
RPS.NULL &lt;- binds(diag(1))

error.cor.mis &lt;- matrix("rnorm(1, 0, 0.1)", 6, 6)
diag(error.cor.mis) &lt;- 1
RTE &lt;- binds(diag(6), misspec=error.cor.mis)
CFA.Model.NULL &lt;- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# Parent Model
loading.alt &lt;- matrix(0, 6, 2)
loading.alt[1:3, 1] &lt;- NA
loading.alt[4:6, 2] &lt;- NA
LY.ALT &lt;- bind(loading.alt, 0.7)
latent.cor.alt &lt;- matrix(NA, 2, 2)
diag(latent.cor.alt) &lt;- 1
RPS.ALT &lt;- binds(latent.cor.alt, "runif(1, 0.7, 0.9)")
CFA.Model.ALT &lt;- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.NULL.NULL &lt;- sim(10, n=500, model=CFA.Model.NULL, generate=CFA.Model.NULL)
Output.NULL.ALT &lt;- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.NULL)

# Find the fix index cutoff from the sampling distribution of the difference
# in fit index of nested models where the alpha is 0.05.
getCutoffNested(Output.NULL.NULL, Output.NULL.ALT, alpha=0.05)

## End(Not run)
</code></pre>

<hr>
<h2 id='getCutoffNonNested'>
Find fit indices cutoff for non-nested model comparison given a priori alpha level
</h2><span id='topic+getCutoffNonNested'></span>

<h3>Description</h3>

<p>Extract fit indices information from the simulation of two models fitting on the datasets created from both models and getCutoff of fit indices given a priori alpha level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCutoffNonNested(dat1Mod1, dat1Mod2, dat2Mod1=NULL, dat2Mod2=NULL, 
alpha=.05, usedFit=NULL, onetailed=FALSE, nVal = NULL, pmMCARval = NULL, 
pmMARval = NULL, df = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCutoffNonNested_+3A_dat1mod1">dat1Mod1</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 1
</p>
</td></tr>
<tr><td><code id="getCutoffNonNested_+3A_dat1mod2">dat1Mod2</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 1
</p>
</td></tr>
<tr><td><code id="getCutoffNonNested_+3A_dat2mod1">dat2Mod1</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="getCutoffNonNested_+3A_dat2mod2">dat2Mod2</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="getCutoffNonNested_+3A_alpha">alpha</code></td>
<td>

<p>A priori alpha level
</p>
</td></tr>
<tr><td><code id="getCutoffNonNested_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to get cutoffs from. The default is to get cutoffs of all fit indices.
</p>
</td></tr>
<tr><td><code id="getCutoffNonNested_+3A_onetailed">onetailed</code></td>
<td>

<p>If <code>TRUE</code>, the function will find the cutoff from one-tail test. If <code>FALSE</code>, the funciton will find the cutoff from two-tailed test.
</p>
</td></tr>
<tr><td><code id="getCutoffNonNested_+3A_nval">nVal</code></td>
<td>

<p>The sample size value that researchers wish to find the fit indices cutoffs from.
</p>
</td></tr>
<tr><td><code id="getCutoffNonNested_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent missing completely at random value that researchers wish to find the fit indices cutoffs from.
</p>
</td></tr>
<tr><td><code id="getCutoffNonNested_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random value that researchers wish to find the fit indices cutoffs from.
</p>
</td></tr>
<tr><td><code id="getCutoffNonNested_+3A_df">df</code></td>
<td>

<p>The degree of freedom used in spline method in predicting the fit indices by the predictors. If <code>df</code> is 0, the spline method will not be applied.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One- or two-tailed cutoffs of several fit indices with a priori alpha level. The cutoff is based on the fit indices from Model 1 subtracted by the fit indices from Model 2.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> for a detail of simResult
<code><a href="#topic+getCutoff">getCutoff</a></code> for a detail of finding cutoffs for absolute fit
<code><a href="#topic+getCutoffNested">getCutoffNested</a></code> for a detail of finding cutoffs for nested model comparison
<code><a href="#topic+plotCutoffNonNested">plotCutoffNonNested</a></code> Plot cutoffs for non-nested model comparison
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Model A: Factor 1 with items 1-3 and Factor 2 with items 4-8
loading.A &lt;- matrix(0, 8, 2)
loading.A[1:3, 1] &lt;- NA
loading.A[4:8, 2] &lt;- NA
LY.A &lt;- bind(loading.A, 0.7)
latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, "runif(1, 0.7, 0.9)")
RTE &lt;- binds(diag(8))
CFA.Model.A &lt;- model(LY = LY.A, RPS = RPS, RTE = RTE, modelType="CFA")

# Model B: Factor 1 with items 1-4 and Factor 2 with items 5-8
loading.B &lt;- matrix(0, 8, 2)
loading.B[1:4, 1] &lt;- NA
loading.B[5:8, 2] &lt;- NA
LY.B &lt;- bind(loading.B, 0.7)
CFA.Model.B &lt;- model(LY = LY.B, RPS = RPS, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.A.A &lt;- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.A)
Output.A.B &lt;- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.A)
Output.B.A &lt;- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.B)
Output.B.B &lt;- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.B)

# Find the cutoffs from the sampling distribution to reject model A (model 1)
# and to reject model B (model 2)
getCutoffNonNested(Output.A.A, Output.A.B, Output.B.A, Output.B.B)

# Find the cutoffs from the sampling distribution to reject model A (model 1)
getCutoffNonNested(Output.A.A, Output.A.B)

# Find the cutoffs from the sampling distribution to reject model B (model 1)
getCutoffNonNested(Output.B.B, Output.B.A)

## End(Not run)
</code></pre>

<hr>
<h2 id='getExtraOutput'>
Get extra outputs from the result of simulation
</h2><span id='topic+getExtraOutput'></span>

<h3>Description</h3>

<p>Get extra outputs from a simulation result object (<code><a href="#topic+SimResult-class">SimResult</a></code>). Users can ask this package to extra output from the <code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> object in each iteration by setting the <code>outfun</code> argument (in the <code>sim</code> function). See the example below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExtraOutput(object, improper = TRUE, nonconverged = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getExtraOutput_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that have the extra output extracted by the function defined in the <code>outfun</code> argument (in the <code>sim</code> function)
</p>
</td></tr>
<tr><td><code id="getExtraOutput_+3A_improper">improper</code></td>
<td>

<p>Specify whether to include the information from the replications with improper solutions
</p>
</td></tr>
<tr><td><code id="getExtraOutput_+3A_nonconverged">nonconverged</code></td>
<td>

<p>Specify whether to include the information from the nonconvergent replications
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of extra outputs
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+sim">sim</a></code> A function to run a Monte Carlo simulation
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.7)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Write a function to extract the modification index from lavaan object
outfun &lt;- function(out) {
	result &lt;- inspect(out, "mi")
}

# We will use only 5 replications to save time.
# In reality, more replications are needed.
Output &lt;- sim(5, n=200, model=CFA.Model, outfun=outfun)

# Get the modification index of each replication
getExtraOutput(Output)

## End(Not run)
</code></pre>

<hr>
<h2 id='getPopulation'>
Extract the data generation population model underlying a result object
</h2><span id='topic+getPopulation'></span>

<h3>Description</h3>

<p>This function will extract the data generation population model underlying a result object (<code>linkS4class{SimResult}</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPopulation(object, std = FALSE, improper = TRUE, nonconverged = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPopulation_+3A_object">object</code></td>
<td>

<p>The result object that you wish to extract the data generation population model from (<code>linkS4class{SimResult}</code>).
</p>
</td></tr>
<tr><td><code id="getPopulation_+3A_std">std</code></td>
<td>

<p>If <code>TRUE</code>, standardized parameters are returned.
</p>
</td></tr>
<tr><td><code id="getPopulation_+3A_improper">improper</code></td>
<td>

<p>Specify whether to include the information from the replications with improper solutions
</p>
</td></tr>
<tr><td><code id="getPopulation_+3A_nonconverged">nonconverged</code></td>
<td>

<p>Specify whether to include the information from the nonconvergent replications
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame contained the population of each replication
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for result object
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, "runif(1, 0.4, 0.9)")
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We will use only 10 replications to save time.
# In reality, more replications are needed.
Output &lt;- sim(10, n=200, model=CFA.Model)

# Get the population parameters
getPopulation(Output)

## End(Not run)
</code></pre>

<hr>
<h2 id='getPower'>
Find power of model parameters 
</h2><span id='topic+getPower'></span>

<h3>Description</h3>

<p>A function to find the power of  parameters in a model when none, one, or more of the simulations parameters vary randomly across replications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPower(simResult, alpha = 0.05, contParam = NULL, powerParam = NULL, 
	nVal = NULL, pmMCARval = NULL, pmMARval = NULL, paramVal = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPower_+3A_simresult">simResult</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that may include randomly varying parameters (e.g. sample size, percent missing, model parameters)
</p>
</td></tr>
<tr><td><code id="getPower_+3A_alpha">alpha</code></td>
<td>

<p>Alpha level to use for power analysis.
</p>
</td></tr>
<tr><td><code id="getPower_+3A_contparam">contParam</code></td>
<td>

<p>Vector of parameters names that vary over replications.
</p>
</td></tr>
<tr><td><code id="getPower_+3A_powerparam">powerParam</code></td>
<td>

<p>Vector of parameters names that the user wishes to find power for. This can be a vector of names (e.g., &quot;f1=~y2&quot;, &quot;f1~~f2&quot;). If parameters are not specified, power for all parameters in the model will be returned.
</p>
</td></tr>
<tr><td><code id="getPower_+3A_nval">nVal</code></td>
<td>

<p>The sample size values that users wish to find power from.
</p>
</td></tr>
<tr><td><code id="getPower_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent completely missing at random values that users wish to find power from.
</p>
</td></tr>
<tr><td><code id="getPower_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random values that users wish to find power from.
</p>
</td></tr>
<tr><td><code id="getPower_+3A_paramval">paramVal</code></td>
<td>

<p>A list of varying parameter values that users wish to find power from.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A common use of simulations is to conduct power analyses, especially when using SEM (Muthen &amp; Muthen, 2002). Here, researchers could select values for each parameter and a sample size and run a simulation to determine power in those conditions (the proportion of generated datasets in which a particular parameter of interest is significantly different from zero). To evaluate power at multiple sample sizes, one simulation for each sample size must be run. This function not only calculate power for each sample size but also calculate power for multiple sample sizes varying continuously. By continuously varying sample size across replications, only a single simulation is needed. In this simulation, the sample size for each replication varies randomly across plausible sample sizes (e.g., sample sizes between 200 and 500). For each replication, the sample size and significance of each parameter (0 = not significant, 1 = significant) are recorded. When the simulation is complete, parameter significance is regressed on sample size using logistic regression. For a given sample size, the predicted probability from the logistic regression equation is the power to detect an effect at that sample size. This approach can be extended to other randomly varying simulation parameters such as the percentage of missing data, and model parameters.
</p>


<h3>Value</h3>

<p>Data frame containing columns representing values of the randomly varying simulation parameters, and power for model parameters of interest.
</p>


<h3>Author(s)</h3>

<p>Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>), Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>References</h3>

<p>Muthen, L. K., &amp; Muthen, B. O. (2002). How to use a Monte Carlo study to decide on sample size and determine power. <em>Structural Equation Modeling, 4,</em> 599-620.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to see how to create a simResult object with randomly varying parameters.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.7)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both sample size and percent missing completely at random. Note that more fine-grained 
# values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) and pmMCAR=seq(0, 0.2, 0.01)
Output &lt;- sim(NULL, model=CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))
summary(Output)

# Get the power of all possible combinations of n and pmMCAR
getPower(Output)

# Get the power of the combinations of n of 100 and 200 and pmMCAR of 0, 0.1, and 0.2
getPower(Output, nVal=c(100, 200), pmMCARval=c(0, 0.1, 0.2))

## End(Not run)
</code></pre>

<hr>
<h2 id='getPowerFit'>
Find power in rejecting alternative models based on fit indices criteria
</h2><span id='topic+getPowerFit'></span>

<h3>Description</h3>

<p>Find the proportion of fit indices that indicate worse fit than a specified cutoffs. The cutoffs may be calculated from <code><a href="#topic+getCutoff">getCutoff</a></code> of the null model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPowerFit(altObject, cutoff = NULL, nullObject = NULL, revDirec = FALSE, 
usedFit = NULL, alpha = 0.05, nVal = NULL, pmMCARval = NULL, pmMARval = NULL, 
condCutoff = TRUE, df = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPowerFit_+3A_altobject">altObject</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that indicates alternative model that users wish to reject
</p>
</td></tr>
<tr><td><code id="getPowerFit_+3A_cutoff">cutoff</code></td>
<td>

<p>Fit indices cutoffs from null model or users. This should be a vector with a specified fit indices names as the name of vector elements. The <code>cutoff</code> cannot be specified if the <code>nullObject</code> is specified.
</p>
</td></tr>
<tr><td><code id="getPowerFit_+3A_nullobject">nullObject</code></td>
<td>

<p>The <code><a href="#topic+SimResult-class">SimResult</a></code> that contains the simulation result from fitting the null model by the data from the null model. The <code>nullObject</code> cannot be specified if the <code>cutoff</code> is specified.
</p>
</td></tr>
<tr><td><code id="getPowerFit_+3A_revdirec">revDirec</code></td>
<td>

<p>Reverse the direction of deciding a power by fit indices (e.g., less than &ndash;&gt; greater than). The default is to count the proportion of fit indices that indicates lower fit to the model, such as how many RMSEA in the alternative model that is worse than cutoffs. The direction can be reversed by setting as <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getPowerFit_+3A_usedfit">usedFit</code></td>
<td>

<p>The vector of names of fit indices that researchers wish to get powers from. The default is to get powers of all fit indices
</p>
</td></tr>
<tr><td><code id="getPowerFit_+3A_alpha">alpha</code></td>
<td>

<p>The alpha level used to find the cutoff if the <code>nullObject</code> is specified. This argument is not applicable if the <code>cutoff</code> is specified.
</p>
</td></tr>
<tr><td><code id="getPowerFit_+3A_nval">nVal</code></td>
<td>

<p>The sample size value that researchers wish to find the power from. This argument is applicable when <code>altObject</code> has a random sample size. 
</p>
</td></tr>
<tr><td><code id="getPowerFit_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent missing completely at random value that researchers wish to find the power from. This argument is applicable when <code>altObject</code> has a random percent missing completely at random. 
</p>
</td></tr>
<tr><td><code id="getPowerFit_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random value that researchers wish to find the power from. This argument is applicable when <code>altObject</code> has a random percent missing at random. 
</p>
</td></tr>
<tr><td><code id="getPowerFit_+3A_condcutoff">condCutoff</code></td>
<td>

<p>A logical value to use a conditional quantile method (if <code>TRUE</code>) or logistic regression method (if <code>FALSE</code>) to find the power. The conditional quantile method use quantile regression to find the quantile of the cutoff on the alternative sampling distribution that varies <code>nVal</code>, <code>pmMCARval</code>, or <code>pmMARval</code>. The value of 1 - quantile will be reported as the power given the set of <code>nVal</code>, <code>pmMCARval</code>, and <code>pmMARval</code>. The logistic regression method is based on transforming the fit indices value to reject/retain decision first. Then, the logistic regression is used to predict reject/retain decision given the set of <code>nVal</code>, <code>pmMCARval</code>, and <code>pmMARval</code>. The predicted probability is reported as a power. This argument is applicable for specification of <code>cutoff</code> only.
</p>
</td></tr>
<tr><td><code id="getPowerFit_+3A_df">df</code></td>
<td>

<p>The degree of freedom used in spline method in quantile regression (<code>condCutoff = TRUE</code>). If <code>df</code> is 0, which is the default, the spline method will not be applied.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of power given different fit indices. The <code>TraditionalChi</code> means the proportion of replications that are rejected by the traditional chi-square test.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+getCutoff">getCutoff</a></code> to find the cutoffs from null model.
</p>
</li>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to see how to create simResult
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Null model with one factor
loading.null &lt;- matrix(0, 6, 1)
loading.null[1:6, 1] &lt;- NA
LY.NULL &lt;- bind(loading.null, 0.7)
RPS.NULL &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model.NULL &lt;- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output.NULL &lt;- sim(5, n=500, model=CFA.Model.NULL)

# Get the fit index cutoff from the null model
Cut.NULL &lt;- getCutoff(Output.NULL, 0.05)

# Alternative model with two factor
loading.alt &lt;- matrix(0, 6, 2)
loading.alt[1:3, 1] &lt;- NA
loading.alt[4:6, 2] &lt;- NA
LY.ALT &lt;- bind(loading.alt, 0.7)
latent.cor.alt &lt;- matrix(NA, 2, 2)
diag(latent.cor.alt) &lt;- 1
RPS.ALT &lt;- binds(latent.cor.alt, "runif(1, 0.7, 0.9)")
CFA.Model.ALT &lt;- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output.ALT &lt;- sim(5, n=500, model=CFA.Model.NULL, generate=CFA.Model.ALT)

# Get the power based on the derived cutoff
getPowerFit(Output.ALT, cutoff=Cut.NULL)

# Get the power based on the rule of thumb proposed by Hu &amp; Bentler (1999)
Rule.of.thumb &lt;- c(RMSEA=0.05, CFI=0.95, TLI=0.95, SRMR=0.06)
getPowerFit(Output.ALT, cutoff=Rule.of.thumb, usedFit=c("RMSEA", "CFI", "TLI", "SRMR"))

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output.NULL2 &lt;- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.NULL, generate=CFA.Model.NULL)
Output.ALT2 &lt;- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.NULL, generate=CFA.Model.ALT)

# Get the power based on the derived cutoff from the null model at the sample size of 250
getPowerFit(Output.ALT2, nullObject=Output.NULL2, nVal=250)

## End(Not run)
</code></pre>

<hr>
<h2 id='getPowerFitNested'>
Find power in rejecting nested models based on the differences in fit indices 
</h2><span id='topic+getPowerFitNested'></span>

<h3>Description</h3>

<p>Find the proportion of the difference in fit indices that indicate worse fit than a specified (or internally derived) cutoffs. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPowerFitNested(altNested, altParent, cutoff = NULL, nullNested = NULL, 
nullParent = NULL, revDirec = FALSE, usedFit = NULL, alpha = 0.05, nVal = NULL, 
pmMCARval = NULL, pmMARval = NULL, condCutoff = TRUE, df = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPowerFitNested_+3A_altnested">altNested</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation result of the nested model when the nested model is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_altparent">altParent</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation result of the parent model when the nested model is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_cutoff">cutoff</code></td>
<td>

<p>A vector of priori cutoffs for fit indices. The <code>cutoff</code> cannot be specified if the <code>nullNested</code> and <code>nullParent</code> are specified.
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_nullnested">nullNested</code></td>
<td>

<p>The <code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation result of the nested model when the nested model is <code>TRUE</code>. This argument must be specified with <code>nullParent</code>. The <code>nullNested</code> cannot be specified if the <code>cutoff</code> is specified.
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_nullparent">nullParent</code></td>
<td>

<p>The <code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation result of the parent model when the nested model is <code>TRUE</code>. This argument must be specified with <code>nullNested</code>. The <code>nullNested</code> cannot be specified if the <code>cutoff</code> is specified.
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_revdirec">revDirec</code></td>
<td>

<p>Reverse the direction of deciding a power by fit indices (e.g., less than &ndash;&gt; greater than). The default is to count the proportion of fit indices that indicates lower fit to the model, such as how many RMSEA in the alternative model that is worse than cutoffs. The direction can be reversed by setting as <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_usedfit">usedFit</code></td>
<td>

<p>The vector of names of fit indices that researchers wish to get powers from. The default is to get powers of all fit indices
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_alpha">alpha</code></td>
<td>

<p>The alpha level used to find the cutoff if the <code>nullObject</code> is specified. This argument is not applicable if the <code>cutoff</code> is specified.
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_nval">nVal</code></td>
<td>

<p>The sample size value that researchers wish to find the power from. This argument is applicable when <code>altObject</code> has a random sample size. 
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent missing completely at random value that researchers wish to find the power from. This argument is applicable when <code>altObject</code> has a random percent missing completely at random. 
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random value that researchers wish to find the power from. This argument is applicable when <code>altObject</code> has a random percent missing at random. 
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_condcutoff">condCutoff</code></td>
<td>

<p>A logical value to use a conditional quantile method (if <code>TRUE</code>) or logistic regression method (if <code>FALSE</code>) to find the power. The conditional quantile method use quantile regression to find the quantile of the cutoff on the alternative sampling distribution that varies <code>nVal</code>, <code>pmMCARval</code>, or <code>pmMARval</code>. The value of 1 - quantile will be reported as the power given the set of <code>nVal</code>, <code>pmMCARval</code>, and <code>pmMARval</code>. The logistic regression method is based on transforming the fit indices value to reject/retain decision first. Then, the logistic regression is used to predict reject/retain decision given the set of <code>nVal</code>, <code>pmMCARval</code>, and <code>pmMARval</code>. The predicted probability is reported as a power. This argument is applicable for specification of <code>cutoff</code> only.
</p>
</td></tr>
<tr><td><code id="getPowerFitNested_+3A_df">df</code></td>
<td>

<p>The degree of freedom used in spline method in quantile regression (<code>condCutoff = TRUE</code>). If <code>df</code> is 0, which is the default, the spline method will not be applied.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of power given different fit indices. The <code>TraditionalChi</code> means the proportion of replications that are rejected by the traditional chi-square difference test.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+getCutoff">getCutoff</a></code> to find the cutoffs from null model.
</p>
</li>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to see how to create simResult
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Null model (Nested model) with one factor
loading.null &lt;- matrix(0, 6, 1)
loading.null[1:6, 1] &lt;- NA
LY.NULL &lt;- bind(loading.null, 0.7)
RPS.NULL &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model.NULL &lt;- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# Alternative model (Parent model) with two factors
loading.alt &lt;- matrix(0, 6, 2)
loading.alt[1:3, 1] &lt;- NA
loading.alt[4:6, 2] &lt;- NA
LY.ALT &lt;- bind(loading.alt, 0.7)
latent.cor.alt &lt;- matrix(NA, 2, 2)
diag(latent.cor.alt) &lt;- 1
RPS.ALT &lt;- binds(latent.cor.alt, 0.7)
CFA.Model.ALT &lt;- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")

# We make the examples running only 10 replications to save time.
# In reality, more replications are needed.
Output.NULL.NULL &lt;- sim(10, n=500, model=CFA.Model.NULL, generate=CFA.Model.NULL) 
Output.ALT.NULL &lt;- sim(10, n=500, model=CFA.Model.NULL, generate=CFA.Model.ALT) 
Output.NULL.ALT &lt;- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.NULL) 
Output.ALT.ALT &lt;- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.ALT) 

# Find the power based on the derived cutoff from the models analyzed on the null datasets
getPowerFitNested(Output.ALT.NULL, Output.ALT.ALT, nullNested=Output.NULL.NULL, 
	nullParent=Output.NULL.ALT)

# Find the power based on the chi-square value at df=1 and the CFI change (intentionally
# use a cutoff from Cheung and Rensvold (2002) in an appropriate situation).
getPowerFitNested(Output.ALT.NULL, Output.ALT.ALT, cutoff=c(Chi=3.84, CFI=-0.10))

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output.NULL.NULL2 &lt;- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.NULL, generate=CFA.Model.NULL) 
Output.ALT.NULL2 &lt;- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.NULL, generate=CFA.Model.ALT) 
Output.NULL.ALT2 &lt;- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.ALT, generate=CFA.Model.NULL) 
Output.ALT.ALT2 &lt;- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.ALT, generate=CFA.Model.ALT) 

# Get the power based on the derived cutoff from the null model at the sample size of 250
getPowerFitNested(Output.ALT.NULL2, Output.ALT.ALT2, nullNested=Output.NULL.NULL2, 
	nullParent=Output.NULL.ALT2, nVal = 250)

# Get the power based on the rule of thumb from the null model at the sample size of 250
getPowerFitNested(Output.ALT.NULL2, Output.ALT.ALT2, cutoff=c(Chi=3.84, CFI=-0.10), nVal = 250)

## End(Not run)
</code></pre>

<hr>
<h2 id='getPowerFitNonNested'>
Find power in rejecting non-nested models based on the differences in fit indices 
</h2><span id='topic+getPowerFitNonNested'></span><span id='topic+getPowerFitNonNested-methods'></span><span id='topic+getPowerFitNonNested+2CSimResult+2CSimResult+2Cvector-method'></span><span id='topic+getPowerFitNonNested+2CSimResult+2CSimResult+2Cmissing-method'></span>

<h3>Description</h3>

<p>Find the proportion of the difference in fit indices from one model that does not in the range of sampling distribution from another model (reject that the dataset comes from the second model) or indicates worse fit than a specified cutoff. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPowerFitNonNested(dat2Mod1, dat2Mod2, cutoff = NULL, dat1Mod1 = NULL, 
dat1Mod2 = NULL, revDirec = FALSE, usedFit = NULL, alpha = 0.05, nVal = NULL, 
pmMCARval = NULL, pmMARval = NULL, condCutoff = TRUE, df = 0, onetailed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPowerFitNonNested_+3A_dat2mod1">dat2Mod1</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_dat2mod2">dat2Mod2</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_cutoff">cutoff</code></td>
<td>

<p>A vector of priori cutoffs for fit indices. The <code>cutoff</code> cannot be specified if the <code>dat1Mod1</code> and <code>dat1Mod2</code> are specified.
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_dat1mod1">dat1Mod1</code></td>
<td>

<p>The <code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 1. This argument must be specified with <code>dat1Mod2</code>. The <code>dat1Mod1</code> cannot be specified if the <code>cutoff</code> is specified.
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_dat1mod2">dat1Mod2</code></td>
<td>

<p>The <code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 1. This argument must be specified with <code>dat1Mod1</code>. The <code>dat1Mod2</code> cannot be specified if the <code>cutoff</code> is specified.
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_revdirec">revDirec</code></td>
<td>

<p>Reverse the direction of deciding a power by fit indices (e.g., less than &ndash;&gt; greater than). The default is to count the proportion of fit indices that indicates lower fit to the model, such as how many RMSEA in the alternative model that is worse than cutoffs. The direction can be reversed by setting as <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_usedfit">usedFit</code></td>
<td>

<p>The vector of names of fit indices that researchers wish to get powers from. The default is to get powers of all fit indices
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_alpha">alpha</code></td>
<td>

<p>The alpha level used to find the cutoff if the <code>nullObject</code> is specified. This argument is not applicable if the <code>cutoff</code> is specified.
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_nval">nVal</code></td>
<td>

<p>The sample size value that researchers wish to find the power from. This argument is applicable when <code>altObject</code> has a random sample size. 
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent missing completely at random value that researchers wish to find the power from. This argument is applicable when <code>altObject</code> has a random percent missing completely at random. 
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random value that researchers wish to find the power from. This argument is applicable when <code>altObject</code> has a random percent missing at random. 
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_condcutoff">condCutoff</code></td>
<td>

<p>A logical value to use a conditional quantile method (if <code>TRUE</code>) or logistic regression method (if <code>FALSE</code>) to find the power. The conditional quantile method use quantile regression to find the quantile of the cutoff on the alternative sampling distribution that varies <code>nVal</code>, <code>pmMCARval</code>, or <code>pmMARval</code>. The value of 1 - quantile will be reported as the power given the set of <code>nVal</code>, <code>pmMCARval</code>, and <code>pmMARval</code>. The logistic regression method is based on transforming the fit indices value to reject/retain decision first. Then, the logistic regression is used to predict reject/retain decision given the set of <code>nVal</code>, <code>pmMCARval</code>, and <code>pmMARval</code>. The predicted probability is reported as a power. This argument is applicable for specification of <code>cutoff</code> only.
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_df">df</code></td>
<td>

<p>The degree of freedom used in spline method in quantile regression (<code>condCutoff = TRUE</code>). If <code>df</code> is 0, which is the default, the spline method will not be applied.
</p>
</td></tr>
<tr><td><code id="getPowerFitNonNested_+3A_onetailed">onetailed</code></td>
<td>

<p>Derive the cutoff by using one-tailed test if specified as <code>TRUE</code>. This argument is applicable only when <code>dat1Mod1</code> and <code>dat1Mod2</code> are specified.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of power given different fit indices.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+getCutoffNonNested">getCutoffNonNested</a></code> to find the cutoffs for non-nested model comparison
</p>
</li>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to see how to create simResult
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Model A: Factor 1 on Items 1-3 and Factor 2 on Items 4-8
loading.A &lt;- matrix(0, 8, 2)
loading.A[1:3, 1] &lt;- NA
loading.A[4:8, 2] &lt;- NA
LY.A &lt;- bind(loading.A, 0.7)
latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, "runif(1, 0.7, 0.9)")
RTE &lt;- binds(diag(8))
CFA.Model.A &lt;- model(LY = LY.A, RPS = RPS, RTE = RTE, modelType="CFA")

# Model B: Factor 1 on Items 1-4 and Factor 2 on Items 5-8
loading.B &lt;- matrix(0, 8, 2)
loading.B[1:4, 1] &lt;- NA
loading.B[5:8, 2] &lt;- NA
LY.B &lt;- bind(loading.B, 0.7)
CFA.Model.B &lt;- model(LY = LY.B, RPS = RPS, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.A.A &lt;- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.A) 
Output.A.B &lt;- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.A) 
Output.B.A &lt;- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.B) 
Output.B.B &lt;- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.B) 

# Find the power based on the derived cutoff for both models
getPowerFitNonNested(Output.B.A, Output.B.B, dat1Mod1=Output.A.A, dat1Mod2=Output.A.B)

# Find the power based on the AIC and BIC of 0 (select model B if Output.B.B has lower AIC or BIC)
getPowerFitNonNested(Output.B.A, Output.B.B, cutoff=c(AIC=0, BIC=0))

## End(Not run)
</code></pre>

<hr>
<h2 id='imposeMissing'> 
Impose MAR, MCAR, planned missingness, or attrition on a data set
</h2><span id='topic+imposeMissing'></span><span id='topic+impose'></span>

<h3>Description</h3>

<p>Function imposes missing values on a data based on the known missing data types,
including MCAR, MAR, planned, and attrition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impose(miss, data.mat, pmMCAR = NULL, pmMAR = NULL)
imposeMissing(data.mat, cov = 0, pmMCAR = 0, pmMAR = 0, nforms = 0, 
	itemGroups = list(), twoMethod = 0, prAttr = 0, timePoints = 1, 
	ignoreCols = 0, threshold = 0, logit = "", logical = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imposeMissing_+3A_miss">miss</code></td>
<td>

<p>Missing data object (<code><a href="#topic+SimMissing-class">SimMissing</a></code>) used as the template for impose missing values
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_data.mat">data.mat</code></td>
<td>

<p>Data to impose missing upon. Can be either a matrix or a data frame. 
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_cov">cov</code></td>
<td>

<p>Column indices of a covariate to be used to impose MAR missing, or
MAR attrition. Will not be included in any removal procedure. See details.
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_pmmcar">pmMCAR</code></td>
<td>

<p>Decimal percent of missingness to introduce completely at random on all variables.
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_pmmar">pmMAR</code></td>
<td>

<p>Decimal percent of missingness to introduce using the listed
covariate as predictor. See details.
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_nforms">nforms</code></td>
<td>

<p>The number of forms for planned missing data designs, not including
the shared form.
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_itemgroups">itemGroups</code></td>
<td>

<p>List of lists of item groupings for planned missing data
forms. Unless specified, items will be divided into groups sequentially (e.g. 1-3,4-6,7-9,10-12)
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_twomethod">twoMethod</code></td>
<td>

<p>With missing on one variable: vector of (column index, percent missing). Will put a given percent
missing on that column in the matrix to simulate a two method
planned missing data research design. With missing on two or more variables: list of (column indices, percent missing).
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_prattr">prAttr</code></td>
<td>

<p>Probability (or vector of probabilities) of an entire case being removed due to attrition at a
given time point. When a covariate is specified along with this argument, attrition
will be predicted by the covariate (MAR attrition). See details.
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_timepoints">timePoints</code></td>
<td>

<p>Number of timepoints items were measured over. For longitudinal
data, planned missing designs will be implemented within each
timepoint. All methods to impose missing values over time assume an equal number of
variables at each time point.
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_ignorecols">ignoreCols</code></td>
<td>

<p>The columns not imposed any missing values for any missing data patterns.
</p>
</td></tr> 
<tr><td><code id="imposeMissing_+3A_threshold">threshold</code></td>
<td>

<p>The threshold of the covariate used to impose missing values. Values
on the covariate above this threshold are eligible to be
deleted. The default threshold is the mean of the variable.
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_logit">logit</code></td>
<td>

<p>The script used for imposing missing values by logistic regression. The script is similar to the specification of regression in <code>lavaan</code> such that each line begins with a dependent variable, then '~' is used as regression sign, and the formula of a linear combination of independent variable plus constant, such as y1 ~ 0.5 + 0.2*y2. '#' and '!' can be used as a comment (like <code>lavaan</code>). For the intercept, users may use 'p()' to specify the average proportion of missing, such as y1 ~ p(0.2) + 0.3*y2, which the average missing proportion of y1 is 0.2 and the missing of y1 depends on y2. Users may visualize the missing proportion from the logistic specification by the <code><a href="#topic+plotLogitMiss">plotLogitMiss</a></code> function.
</p>
</td></tr>
<tr><td><code id="imposeMissing_+3A_logical">logical</code></td>
<td>

<p>A matrix of logical values (<code>TRUE/FALSE</code>). If a value in the dataset is corresponding to the <code>TRUE</code> in the logical matrix, the value will be missing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without specifying any arguments, no missing values will be
introduced.
</p>
<p>A single covariate is required to specify MAR missing - this
covariate can be distributed in any way. This covariate can be either continuous or categorical, as long as it is
numerical. If the covariate is categorical, the threshold should be
specified to one of the levels.
</p>
<p>MAR missingness is specified using the threshold method - any value on the covariate that is above
the specified threshold indicates a row eligible for deletion. If the
specified total amount of MAR missingness is not possible given the
total rows eligible based on the threshold, the function iteratively
lowers the threshold until the total percent missing is possible.
</p>
<p>Planned missingness is parameterized by the number of forms (n). This is used to divide the
cases into n groups. If the column groupings are not specified, a naive
method will be used that divides the columns into n+1 equal forms
sequentially (1-4,5-9,10-13..), where the first group is the shared
form.The first list of column indices given will be used as the shared
group. If this is not desired, this list can be left empty.
</p>
<p>For attrition, the probability can be specified as a single value or as
a vector. For a single value, the probability of attrition will be
the same across time points, and affects only
cases not previously lost due to attrition. If this argument is a
vector, this specifies different probabilities of
attrition for each time point. Values will be recycled if this
vector is smaller than the specified number of time points.
</p>
<p>An MNAR processes can be generated by specifying MAR missingness and then
dropping the covariate from the subsequent analysis.
</p>
<p>Currently, if MAR missing is imposed along with attrition, both processes will use
the same covariate and threshold.
</p>
<p>Currently, all types of missingness (MCAR, MAR, planned, and attrition)
are imposed independently. This means that specified global values of
percent missing will not be additive (10 percent MCAR + 10 percent MAR
does not equal 20 percent total missing). 
</p>


<h3>Value</h3>

<p>A data matrix with <code>NA</code>s introduced in the way specified by the arguments.
</p>


<h3>Author(s)</h3>

<p>Patrick Miller (University of Kansas; <a href="mailto:patr1ckm@ku.edu">patr1ckm@ku.edu</a>), 
Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>)  
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimMissing-class">SimMissing</a></code> for the alternative way to save missing data feature for using in the <code><a href="#topic+sim">sim</a></code> function.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(rep(rnorm(10,1,1),19),ncol=19)
datac &lt;- cbind(data,rnorm(10,0,1),rnorm(10,5,5))

# Imposing Missing with the following arguments produces no missing values
imposeMissing(data)
imposeMissing(data,cov=c(1,2))
imposeMissing(data,pmMCAR=0)
imposeMissing(data,pmMAR=0)
imposeMissing(data,nforms=0)

#Some more usage examples

# No missing at variables 1 and 2
imposeMissing(data,cov=c(1,2),pmMCAR=.1)

# 3-Form design
imposeMissing(data,nforms=3)

# 3-Form design with specified groups of items (XABC)
imposeMissing(data, nforms = 3, itemGroups =
	list(c(1,2,3,4,5), c(6,7,8,9,10), c(11,12,13,14,15), c(16,17,18,19)))

# 3-Form design when variables 20 and 21 are not missing
imposeMissing(datac,cov=c(20,21),nforms=3)

# 2 method design where the expensive measure is on Variable 19
imposeMissing(data,twoMethod=c(19,.8))

# Impose missing data with percent attrition of 0.1 in 5 time points
imposeMissing(datac,cov=21,prAttr=.1,timePoints=5)

# Logistic-regression MAR
colnames(data) &lt;- paste("y", 1:ncol(data), sep="")
script &lt;- 'y1 ~ 0.05 + 0.1*y2 + 0.3*y3
		y4 ~ -2 + 0.1*y4
		y5 ~ -0.5'
imposeMissing(data, logit=script)
</code></pre>

<hr>
<h2 id='inspect'>
Extract information from a simulation result
</h2><span id='topic+inspect+2CSimResult-method'></span><span id='topic+inspect'></span>

<h3>Description</h3>

<p>Extract information from a simulation result
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspect_+3A_object">object</code></td>
<td>

<p>The target <code><a href="#topic+SimResult-class">SimResult</a></code> object
</p>
</td></tr>
<tr><td><code id="inspect_+3A_what">what</code></td>
<td>

<p>The target component to be extracted. Please see details below.
</p>
</td></tr>
<tr><td><code id="inspect_+3A_improper">improper</code></td>
<td>

<p>Specify whether to include the information from the replications with improper solutions
</p>
</td></tr>
<tr><td><code id="inspect_+3A_nonconverged">nonconverged</code></td>
<td>

<p>Specify whether to include the information from the nonconvergent replications
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here are the list of information that can be specified in the <code>what</code> argument. The items starting with * are the information that the <code>improper</code> and <code>nonconverged</code> arguments are not applicable.
</p>

<ul>
<li><p> *<code>"modeltype"</code>: The type of the simulation result
</p>
</li>
<li><p> *<code>"nrep"</code>: The number of overall replications, including converged and nonconverged replications
</p>
</li>
<li> <p><code>"param"</code>: Parameter values (equivalent to the <code><a href="#topic+getPopulation">getPopulation</a></code> function)
</p>
</li>
<li> <p><code>"stdparam"</code>: Standardized parameter values (equivalent to the <code><a href="#topic+getPopulation">getPopulation</a></code> function with <code>std = TRUE</code>)
</p>
</li>
<li> <p><code>"coef"</code>: Parameter estimates (equivalent to the <code><a href="#topic+coef+2CSimResult-method">coef</a></code> method)
</p>
</li>
<li> <p><code>"se"</code>: Standard errors
</p>
</li>
<li> <p><code>"fit"</code>: Fit indices
</p>
</li>
<li> <p><code>"misspec"</code>: Misspecified parameter values
</p>
</li>
<li> <p><code>"popfit"</code>: Population misfit
</p>
</li>
<li> <p><code>"fmi1"</code>: Fraction missings type 1
</p>
</li>
<li> <p><code>"fmi2"</code>: Fraction missings type 2
</p>
</li>
<li> <p><code>"std"</code>: Standardized Parameter Estimates
</p>
</li>
<li> <p><code>"stdse"</code>: Standard Errors of Standardized Values
</p>
</li>
<li> <p><code>"cilower"</code>: Lower bounds of confidence intervals
</p>
</li>
<li> <p><code>"ciupper"</code>: Upper bounds of confidence intervals
</p>
</li>
<li> <p><code>"ciwidth"</code>: Widths of confidence intervals
</p>
</li>
<li><p> *<code>"seed"</code>: Seed number (equivalent to the <code><a href="#topic+summarySeed">summarySeed</a></code> function)
</p>
</li>
<li> <p><code>"ngroup"</code>: Sample size of each group
</p>
</li>
<li> <p><code>"ntotal"</code>: Total sample size
</p>
</li>
<li> <p><code>"mcar"</code>: Percent missing completely at random
</p>
</li>
<li> <p><code>"mar"</code>: Percent missing at random
</p>
</li>
<li> <p><code>"extra"</code>: Extra output from the <code>outfun</code> argument from the <code><a href="#topic+sim">sim</a></code> function)
</p>
</li>
<li><p> *<code>"time"</code>: Time elapsed in running the simulation (equivalent to the <code><a href="#topic+summaryTime">summaryTime</a></code> function)
</p>
</li>
<li><p> *<code>"converged"</code>: Convergence of each replication
</p>
</li></ul>



<h3>Value</h3>

<p>The target information depending on the <code>what</code> argument
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> for the object input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# In reality, more than 5 replications are needed.
Output &lt;- sim(5, CFA.Model, n=200)
inspect(Output, "coef")
inspect(Output, "param")
inspect(Output, "se", improper = TRUE, nonconverged = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='likRatioFit'>
Find the likelihood ratio (or Bayes factor) based on the bivariate distribution of fit indices
</h2><span id='topic+likRatioFit'></span>

<h3>Description</h3>

<p>Find the log-likelihood of the observed fit indices on Model 1 and 2 from the real data on the bivariate sampling distribution of fit indices fitting Model 1 and Model 2 by the datasets from the Model 1 and Model 2. Then, the likelihood ratio is computed (which may be interpreted as posterior odd). If the prior odd is 1 (by default), the likelihood ratio is equivalent to Bayes Factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likRatioFit(outMod1, outMod2, dat1Mod1, dat1Mod2, dat2Mod1, dat2Mod2, 
usedFit=NULL, prior=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likRatioFit_+3A_outmod1">outMod1</code></td>
<td>

<p><code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> that saves the analysis result of the first model from the target dataset
</p>
</td></tr>
<tr><td><code id="likRatioFit_+3A_outmod2">outMod2</code></td>
<td>

<p><code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> that saves the analysis result of the second model from the target dataset
</p>
</td></tr>
<tr><td><code id="likRatioFit_+3A_dat1mod1">dat1Mod1</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 1
</p>
</td></tr>
<tr><td><code id="likRatioFit_+3A_dat1mod2">dat1Mod2</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 1
</p>
</td></tr>
<tr><td><code id="likRatioFit_+3A_dat2mod1">dat2Mod1</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="likRatioFit_+3A_dat2mod2">dat2Mod2</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="likRatioFit_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to getCutoffs from. The default is to getCutoffs of all fit indices.
</p>
</td></tr>
<tr><td><code id="likRatioFit_+3A_prior">prior</code></td>
<td>

<p>The prior odds. The prior probability that Model 1 is correct over the prior probability that Model 2 is correct.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The likelihood ratio (Bayes Factor) in preference of Model 1 to Model 2. If the value is greater than 1, Model 1 is preferred. If the value is less than 1, Model 2 is preferred.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> for a detail of simResult
<code><a href="#topic+pValueNested">pValueNested</a></code> for a nested model comparison by the difference in fit indices
<code><a href="#topic+pValueNonNested">pValueNonNested</a></code> for a nonnested model comparison by the difference in fit indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Model A; Factor 1 --&gt; Factor 2; Factor 2 --&gt; Factor 3
library(lavaan)
loading &lt;- matrix(0, 11, 3)
loading[1:3, 1] &lt;- NA
loading[4:7, 2] &lt;- NA
loading[8:11, 3] &lt;- NA
path.A &lt;- matrix(0, 3, 3)
path.A[2, 1] &lt;- NA
path.A[3, 2] &lt;- NA
model.A &lt;- estmodel(LY=loading, BE=path.A, modelType="SEM", indLab=c(paste("x", 1:3, sep=""), 
	paste("y", 1:8, sep="")))

out.A &lt;- analyze(model.A, PoliticalDemocracy)

# Model A; Factor 1 --&gt; Factor 3; Factor 3 --&gt; Factor 2
path.B &lt;- matrix(0, 3, 3)
path.B[3, 1] &lt;- NA
path.B[2, 3] &lt;- NA
model.B &lt;- estmodel(LY=loading, BE=path.B, modelType="SEM", indLab=c(paste("x", 1:3, sep=""), 
	paste("y", 1:8, sep="")))

out.B &lt;- analyze(model.B, PoliticalDemocracy)

loading.mis &lt;- matrix("runif(1, -0.2, 0.2)", 11, 3)
loading.mis[is.na(loading)] &lt;- 0

# Create SimSem object for data generation and data analysis template
datamodel.A &lt;- model.lavaan(out.A, std=TRUE, LY=loading.mis)
datamodel.B &lt;- model.lavaan(out.B, std=TRUE, LY=loading.mis)

# Get sample size
n &lt;- nrow(PoliticalDemocracy)

# The actual number of replications should be greater than 20.
output.A.A &lt;- sim(20, n=n, model.A, generate=datamodel.A) 
output.A.B &lt;- sim(20, n=n, model.B, generate=datamodel.A)
output.B.A &lt;- sim(20, n=n, model.A, generate=datamodel.B)
output.B.B &lt;- sim(20, n=n, model.B, generate=datamodel.B)

# Find the likelihood ratio ;The output may contain some warnings here. 
# When the number of replications increases (e.g., 1000), the warnings should disappear.
likRatioFit(out.A, out.B, output.A.A, output.A.B, output.B.A, output.B.B)

## End(Not run)
</code></pre>

<hr>
<h2 id='miss'>
Specifying the missing template to impose on a dataset
</h2><span id='topic+miss'></span>

<h3>Description</h3>

<p>Specifying the missing template (<code><a href="#topic+SimMissing-class">SimMissing</a></code>) to impose on a dataset. The template will be used in Monte Carlo simulation such that, in the <code><a href="#topic+sim">sim</a></code> function, datasets are created and imposed by missing values created by this template. See <code><a href="#topic+imposeMissing">imposeMissing</a></code> for further details of each argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miss(cov = 0, pmMCAR = 0, pmMAR = 0, logit = "", nforms = 0, itemGroups = list(),
     timePoints = 1, twoMethod = 0, prAttr = 0, m = 0,
	   package = "default", convergentCutoff = 0.8, ignoreCols = 0,
     threshold = 0, covAsAux = TRUE, logical = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miss_+3A_cov">cov</code></td>
<td>
<p>Column indices of any normally distributed covariates used in the data set.</p>
</td></tr>
<tr><td><code id="miss_+3A_pmmcar">pmMCAR</code></td>
<td>
<p>Decimal percent of missingness to introduce completely at random on all variables.</p>
</td></tr>
<tr><td><code id="miss_+3A_pmmar">pmMAR</code></td>
<td>
<p>Decimal percent of missingness to introduce using the listed covariates as predictors.</p>
</td></tr>
<tr><td><code id="miss_+3A_logit">logit</code></td>
<td>
<p>The script used for imposing missing values by logistic regression. The script is similar to the specification of regression in <code>lavaan</code> such that each line begins with a dependent variable, then '~' is used as regression sign, and the formula of a linear combination of independent variable plus constant, such as y1 ~ 0.5 + 0.2*y2. '#' and '!' can be used as a comment (like <code>lavaan</code>). For the intercept, users may use 'p()' to specify the average proportion of missing, such as y1 ~ p(0.2) + 0.3*y2, which the average missing proportion of y1 is 0.2 and the missing of y1 depends on y2. Users may visualize the missing proportion from the logistic specification by the <code><a href="#topic+plotLogitMiss">plotLogitMiss</a></code> function.</p>
</td></tr>
<tr><td><code id="miss_+3A_nforms">nforms</code></td>
<td>
<p>The number of forms for planned missing data designs, not including the shared form.</p>
</td></tr>
<tr><td><code id="miss_+3A_itemgroups">itemGroups</code></td>
<td>
<p>List of lists of item groupings for planned missing data forms. Without this, items will be divided into groups sequentially (e.g. 1-3,4-6,7-9,10-12)</p>
</td></tr>
<tr><td><code id="miss_+3A_timepoints">timePoints</code></td>
<td>
<p>Number of timepoints items were measured over. For longitudinal data, planned missing designs will be implemented within each timepoint.</p>
</td></tr>
<tr><td><code id="miss_+3A_twomethod">twoMethod</code></td>
<td>
<p>With missing on one variable: vector of (column index, percent missing). Will put a given percent missing on that column in the matrix to simulate a two method planned missing data research design. With missing on two or more variables: list of (column indices, percent missing). </p>
</td></tr>
<tr><td><code id="miss_+3A_prattr">prAttr</code></td>
<td>
<p>Probability (or vector of probabilities) of an entire case being removed due to attrition at a given time point. See <code><a href="#topic+imposeMissing">imposeMissing</a></code> for further details.</p>
</td></tr>
<tr><td><code id="miss_+3A_m">m</code></td>
<td>
<p>The number of imputations. The default is 0 such that the full information maximum likelihood is used.</p>
</td></tr>
<tr><td><code id="miss_+3A_package">package</code></td>
<td>
<p>The package to be used in multiple imputation. The default value of this function is <code>"default"</code>. For the default option, if <code>m</code> is 0, the full information maximum likelihood is used. If <code>m</code> is greater than 0, the <code>"mice"</code> package is used. The possible inputs are <code>"default"</code>, <code>"Amelia"</code>, or <code>"mice"</code>.</p>
</td></tr>
<tr><td><code id="miss_+3A_convergentcutoff">convergentCutoff</code></td>
<td>
<p>If the proportion of convergent results across imputations are greater than the specified value (the default is 80%), the analysis on the dataset is considered as convergent. Otherwise, the analysis is considered as nonconvergent. This attribute is applied for multiple imputation only. </p>
</td></tr>
<tr><td><code id="miss_+3A_ignorecols">ignoreCols</code></td>
<td>
<p>The columns not imposed any missing values for any missing data patterns</p>
</td></tr>
<tr><td><code id="miss_+3A_threshold">threshold</code></td>
<td>
<p>The threshold of covariates that divide between the area to impose missing and the area not to impose missing. The default threshold is the mean of the covariate.</p>
</td></tr>
<tr><td><code id="miss_+3A_covasaux">covAsAux</code></td>
<td>
<p>If <code>TRUE</code>, the covariate listed in the object will be used as auxiliary variables when putting in the model object. If <code>FALSE</code>, the covariate will be included in the analysis.</p>
</td></tr>
<tr><td><code id="miss_+3A_logical">logical</code></td>
<td>
<p>A matrix of logical values (<code>TRUE/FALSE</code>). If a value in the dataset is corresponding to the <code>TRUE</code> in the logical matrix, the value will be missing.</p>
</td></tr>
<tr><td><code id="miss_+3A_...">...</code></td>
<td>
<p>Additional arguments used in multiple imputation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A missing object that contains missing-data template (<code><a href="#topic+SimMissing-class">SimMissing</a></code>)
</p>


<h3>Author(s)</h3>

<p>Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>),
Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>),
Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimMissing-class">SimMissing</a></code> The resulting missing object
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#Example of imposing 10% MCAR missing in all variables with no imputations (FIML method)
Missing &lt;- miss(pmMCAR=0.1, ignoreCols="group")
summary(Missing)

loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.7)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

#Create data
dat &lt;- generate(CFA.Model, n = 20)

#Impose missing
datmiss &lt;- impose(Missing, dat)

#Analyze data
out &lt;- analyze(CFA.Model, datmiss)
summary(out)

#Missing using logistic regression
script &lt;- 'y1 ~ 0.05 + 0.1*y2 + 0.3*y3
	y4 ~ -2 + 0.1*y4
	y5 ~ -0.5'
Missing2 &lt;- miss(logit=script, pmMCAR=0.1, ignoreCols="group")
summary(Missing2)
datmiss2 &lt;- impose(Missing2, dat)

#Missing using logistic regression (2)
script &lt;- 'y1 ~ 0.05 + 0.5*y3
	y2 ~ p(0.2)
	y3 ~ p(0.1) + -1*y1
	y4 ~ p(0.3) + 0.2*y1 + -0.3*y2
	y5 ~ -0.5'
Missing2 &lt;- miss(logit=script)
summary(Missing2)
datmiss2 &lt;- impose(Missing2, dat)

#Example to create simMissing object for 3 forms design at 3 timepoints with 10 imputations
Missing &lt;- miss(nforms=3, timePoints=3, numImps=10)

#Missing template for data analysis with multiple imputation
Missing &lt;- miss(package="mice", m=10, convergentCutoff=0.6)
</code></pre>

<hr>
<h2 id='model'>
Data generation template and analysis template for simulation.
</h2><span id='topic+model'></span><span id='topic+model.cfa'></span><span id='topic+model.path'></span><span id='topic+model.sem'></span>

<h3>Description</h3>

<p>This function creates a model template (lavaan parameter table), which can be used for data generation and/or analysis for simulated structural equation modeling using simsem. Models are specified using Y-side parameter matrices with LISREL syntax notation. Each parameter matrix must be a <code><a href="#topic+SimMatrix-class">SimMatrix</a></code> or <code><a href="#topic+SimVector-class">SimVector</a></code> built using <code>bind</code>. In addition to the usual Y-side matrices in LISREL, both PS and TE can be specified using correlation matrices (RPS, RTE) and scaled by a vector of residual variances (VTE, VPS) or total variances (VY, VE). Multiple group models can be created by passing lists of <code><a href="#topic+SimMatrix-class">SimMatrix</a></code> or <code><a href="#topic+SimVector-class">SimVector</a></code> to arguments, or by simply specifying the number of groups when all group models are identical. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model(LY = NULL, PS = NULL, RPS = NULL, TE = NULL, RTE = NULL, BE = NULL, 
	VTE = NULL, VY = NULL, VPS = NULL, VE = NULL, TY = NULL, AL = NULL, MY = NULL, 
	ME = NULL, KA = NULL, GA = NULL, modelType, indLab = NULL, facLab = NULL, 
	covLab = NULL, groupLab = "group", ngroups = 1, con = NULL)
model.cfa(LY = NULL,PS = NULL,RPS = NULL, TE = NULL,RTE = NULL, VTE = NULL, 
	VY = NULL, VPS = NULL, VE=NULL, TY = NULL, AL = NULL, MY = NULL, ME = NULL, 
	KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1, con = NULL)
model.path(PS = NULL, RPS = NULL, BE = NULL, VPS = NULL, VE=NULL, AL = NULL, 
	ME = NULL, KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1, con = NULL)
model.sem(LY = NULL,PS = NULL,RPS = NULL, TE = NULL,RTE = NULL, BE = NULL, 
	VTE = NULL, VY = NULL, VPS = NULL, VE=NULL, TY = NULL, AL = NULL, MY = NULL, 
	ME = NULL, KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1, con = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_+3A_ly">LY</code></td>
<td>

<p>Factor loading matrix from endogenous factors to Y indicators (must be <code><a href="#topic+SimMatrix-class">SimMatrix</a></code> object).
</p>
</td></tr>
<tr><td><code id="model_+3A_ps">PS</code></td>
<td>

<p>Residual variance-covariance matrix among endogenous factors (must be <code><a href="#topic+SimMatrix-class">SimMatrix</a></code> object). Either RPS or PS (but not both) must be specified in SEM and CFA models.
</p>
</td></tr>
<tr><td><code id="model_+3A_rps">RPS</code></td>
<td>

<p>Residual correlation matrix among endogenous factors (must be <code><a href="#topic+SimMatrix-class">SimMatrix</a></code> object). Either RPS or PS (but not both) must be specified in SEM and CFA models.
</p>
</td></tr>
<tr><td><code id="model_+3A_te">TE</code></td>
<td>

<p>Measurement error variance-covariance matrix among Y indicators (must be <code><a href="#topic+SimMatrix-class">SimMatrix</a></code> object). Either RTE or TE (but not both) must be specified in SEM and CFA models.
</p>
</td></tr>
<tr><td><code id="model_+3A_rte">RTE</code></td>
<td>

<p>Measurement error correlation matrix among Y indicators (must be <code><a href="#topic+SimMatrix-class">SimMatrix</a></code> object). Either RTE or TE (but not both) must be specified in SEM and CFA models.
</p>
</td></tr>
<tr><td><code id="model_+3A_be">BE</code></td>
<td>

<p>Regression coefficient matrix among endogenous factors (must be <code><a href="#topic+SimMatrix-class">SimMatrix</a></code> object). BE must be specified in path analysis and SEM models. 
</p>
</td></tr>
<tr><td><code id="model_+3A_vte">VTE</code></td>
<td>

<p>Measurement error variance of indicators (must be <code><a href="#topic+SimVector-class">SimVector</a></code> object). Either VTE or VY (but not both) can be specified when RTE (instead of TE) is specified.
</p>
</td></tr>
<tr><td><code id="model_+3A_vy">VY</code></td>
<td>

<p>Total variance of indicators (must be <code><a href="#topic+SimVector-class">SimVector</a></code> object). Either VTE or VY (but not both) can be specified when RTE (instead of TE) is specified.
</p>
</td></tr>
<tr><td><code id="model_+3A_vps">VPS</code></td>
<td>

<p>Residual variance of factors (must be <code><a href="#topic+SimVector-class">SimVector</a></code> object). Either VPS or VE (but not both) can be specified when RPS (instead of PS) is specified.
</p>
</td></tr>
<tr><td><code id="model_+3A_ve">VE</code></td>
<td>

<p>Total variance of of factors (must be <code><a href="#topic+SimVector-class">SimVector</a></code> object). Either VPS or VE (but not both) can be specified when RPS (instead of PS) is specified.
</p>
</td></tr>  
<tr><td><code id="model_+3A_ty">TY</code></td>
<td>

<p>Measurement intercepts of Y indicators (must be <code><a href="#topic+SimVector-class">SimVector</a></code> object). Either TY or MY (but not both) can be specified. 
</p>
</td></tr>
<tr><td><code id="model_+3A_al">AL</code></td>
<td>

<p>Endogenous factor intercepts (must be <code><a href="#topic+SimVector-class">SimVector</a></code> object). Either AL or ME (but not both) can be specified. 
</p>
</td></tr>
<tr><td><code id="model_+3A_my">MY</code></td>
<td>

<p>Y indicator means (must be <code><a href="#topic+SimVector-class">SimVector</a></code> object). Either TY or MY (but not both) can be specified. 
</p>
</td></tr>
<tr><td><code id="model_+3A_me">ME</code></td>
<td>

<p>Total mean of endogenous factors (must be <code><a href="#topic+SimVector-class">SimVector</a></code> object). NOTE: Either endogenous factor intercept or total mean of endogenous factor is specified. Both cannot be simultaneously specified.
</p>
</td></tr>
<tr><td><code id="model_+3A_ka">KA</code></td>
<td>

<p>Regression coefficient matrix from covariates to indicators (must be <code><a href="#topic+SimMatrix-class">SimMatrix</a></code> object). KA is needed when (fixed) exogenous covariates are needed only.
</p>
</td></tr>
<tr><td><code id="model_+3A_ga">GA</code></td>
<td>

<p>Regression coefficient matrix from covariates to factors (must be <code><a href="#topic+SimMatrix-class">SimMatrix</a></code> object). GA is needed when (fixed) exogenous covariates are needed only.
</p>
</td></tr>
<tr><td><code id="model_+3A_modeltype">modelType</code></td>
<td>

<p>&quot;CFA&quot;, &quot;Sem&quot;, or &quot;Path&quot;. Model type must be specified to ensure that the matrices specified in model templates for data generation and analysis correspond to what the user intends.
</p>
</td></tr>
<tr><td><code id="model_+3A_indlab">indLab</code></td>
<td>

<p>Character vector of indicator labels. If left blank, automatic labels will be generated as  <code>y1</code>, <code>y2</code>, ... <code>yy</code>.
</p>
</td></tr>
<tr><td><code id="model_+3A_faclab">facLab</code></td>
<td>
 
<p>Character vector of factor labels. If left blank, automatic labels will be generated as <code>f1</code>, <code>f2</code>, ... <code>ff</code>
</p>
</td></tr>
<tr><td><code id="model_+3A_covlab">covLab</code></td>
<td>
 
<p>Character vector of covariate labels. If left blank, automatic labels will be generated as <code>z1</code>, <code>z2</code>, ... <code>zz</code>
</p>
</td></tr>
<tr><td><code id="model_+3A_grouplab">groupLab</code></td>
<td>

<p>Character of group-variable label (not the names of each group). If left blank, automatic labels will be generated as <code>group</code>
</p>
</td></tr>
<tr><td><code id="model_+3A_ngroups">ngroups</code></td>
<td>

<p>Number of groups for data generation (defaults to 1). Should only be specified for multiple group models in which all parameter matrices are identical across groups (when ngroups &gt; 1, specified matrices are replicated for all groups). For multiple group models in which parameter matrices differ among groups, parameter matrices should instead be specified as a list (if any matrix argument is a list, the number of groups will be equal to the list's length, and the ngroups argument will be ignored).
</p>
</td></tr>
<tr><td><code id="model_+3A_con">con</code></td>
<td>

<p>Additional parameters (phantom variables), equality constraints, and inequality constraints. Additional parameters must be specified using lavaan syntax. Allowed operators are &quot;:=&quot; (is defined as), &quot;==&quot; (is equal to), &quot;&lt;&quot; (is less than), and &quot;&gt;&quot; (is greater than). Names used in syntax must correspond to labels defined on free parameters in the model (with the exception that the name to the left of &quot;:=&quot; is a new parameter name). On the right hand side of all operators, any mathematical expressions are allowed, e.g., <code>"newparam := (load1 + load2 + load3)/3"</code>. For the &quot;&lt;&quot; and &quot;&gt;&quot; operators in data generation, if the specified relation is at odds with parameter specifications (e.g., the parameter to the left of the &quot;&gt;&quot; operator is less that the parameter to the right), the left hand side parameter will be changed so that the relation holds with a very small difference (i.e., 0.000001). For example, in &quot;load1 &gt; load2&quot;, if load1 is 0.5 and load2 is 0.6, load1 will be changed to 0.6 + 0.000001 = 0.600001. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>simsem</em> package is intricately tied to the <em>lavaan</em> package for analysis of structural equation models. The analysis template that is generated by <code>model</code> is a lavaan parameter table, a low-level access point to lavaan that allows repeated analyses to happen more rapidly. If desired, the parameter table generated can be used directly with lavaan for many analyses.
</p>
<p>The data generation template is simply a list of <code>SimMatrix</code> or <code>SimVector</code> objects. The <code>SimSem</code> object can be passed to the function <code>generate</code> to generate data, or can be passed to the function <code>sim</code> to generate and/or analyze data.
</p>
<p>To simulate multiple group data, users can either specify a integer in the ngroups argument (which creates a list of identical model arguments for each group), or pass a list of  <code>SimMatrix</code> or <code>SimVector</code> to any of the matrix arguments with length(s) equal to the number of groups desired (this approach will cause the ngroups argument to be ignored). If only one argument is a list, all other arguments will be replicated across groups (with the same parameter identification, population parameter values/distributions, and misspecification). If equality constraints are specified, these parameters will be constrained to be equal across groups.	
</p>
<p>The <code>model.cfa</code>, <code>model.path</code>, and <code>model.sem</code> are the shortcuts for the <code>model</code> function when <code>modelType</code> are <code>"CFA"</code>, <code>"Path"</code>, and <code>"SEM"</code>, respectively.
</p>


<h3>Value</h3>

<p><code>SimSem</code> object that contains the data generation template (<code>@dgen</code>) and analysis template (<code>@pt</code>).
</p>


<h3>Author(s)</h3>

<p>Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>), 
Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<ul>
<li> <p><code><a href="#topic+sim">sim</a></code> for simulations using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li>
<li> <p><code><a href="#topic+generate">generate</a></code> To generate data using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li>
<li> <p><code><a href="#topic+analyze">analyze</a></code> To analyze real or generated data using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li>
<li> <p><code><a href="#topic+draw">draw</a></code> To draw parameters using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Confirmatory factor analysis
loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# Example 2: Multiple-group CFA with weak invariance
loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- paste0("con", 1:3)
loading[4:6, 2] &lt;- paste0("con", 4:6)
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VTE &lt;- bind(rep(NA, 6), 0.51)

CFA.Model &lt;- model(LY = LY, RPS = list(RPS, RPS), RTE = list(RTE, RTE), VTE=list(VTE, VTE), 
	ngroups=2, modelType = "CFA")

# Example 3: Linear growth curve model with model misspecification
factor.loading &lt;- matrix(NA, 4, 2)
factor.loading[,1] &lt;- 1
factor.loading[,2] &lt;- 0:3
LY &lt;- bind(factor.loading)

factor.mean &lt;- rep(NA, 2)
factor.mean.starting &lt;- c(5, 2)
AL &lt;- bind(factor.mean, factor.mean.starting)

factor.var &lt;- rep(NA, 2)
factor.var.starting &lt;- c(1, 0.25)
VPS &lt;- bind(factor.var, factor.var.starting)

factor.cor &lt;- matrix(NA, 2, 2)
diag(factor.cor) &lt;- 1
RPS &lt;- binds(factor.cor, 0.5)

VTE &lt;- bind(rep(NA, 4), 1.2)

RTE &lt;- binds(diag(4))

TY &lt;- bind(rep(0, 4))

LCA.Model &lt;- model(LY=LY, RPS=RPS, VPS=VPS, AL=AL, VTE=VTE, RTE=RTE, TY=TY, modelType="CFA")

# Example 4: Path analysis model with misspecified direct effect
path.BE &lt;- matrix(0, 4, 4)
path.BE[3, 1:2] &lt;- NA
path.BE[4, 3] &lt;- NA
starting.BE &lt;- matrix("", 4, 4)
starting.BE[3, 1:2] &lt;- "runif(1, 0.3, 0.5)"
starting.BE[4, 3] &lt;- "runif(1,0.5,0.7)"
mis.path.BE &lt;- matrix(0, 4, 4)
mis.path.BE[4, 1:2] &lt;- "runif(1,-0.1,0.1)"
BE &lt;- bind(path.BE, starting.BE, misspec=mis.path.BE)

residual.error &lt;- diag(4)
residual.error[1,2] &lt;- residual.error[2,1] &lt;- NA
RPS &lt;- binds(residual.error, "rnorm(1,0.3,0.1)")

ME &lt;- bind(rep(NA, 4), 0)

Path.Model &lt;- model(RPS = RPS, BE = BE, ME = ME, modelType="Path")

# Example 5: Full SEM model 
loading &lt;- matrix(0, 8, 3)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loading[7:8, 3] &lt;- "con1"
loading.start &lt;- matrix("", 8, 3)
loading.start[1:3, 1] &lt;- 0.7
loading.start[4:6, 2] &lt;- 0.7
loading.start[7:8, 3] &lt;- "rnorm(1,0.6,0.05)"
LY &lt;- bind(loading, loading.start)

RTE &lt;- binds(diag(8))

factor.cor &lt;- diag(3)
factor.cor[1, 2] &lt;- factor.cor[2, 1] &lt;- NA
RPS &lt;- binds(factor.cor, 0.5)

path &lt;- matrix(0, 3, 3)
path[3, 1:2] &lt;- NA
path.start &lt;- matrix(0, 3, 3)
path.start[3, 1] &lt;- "rnorm(1,0.6,0.05)"
path.start[3, 2] &lt;- "runif(1,0.3,0.5)"
BE &lt;- bind(path, path.start)

SEM.model &lt;- model(BE=BE, LY=LY, RPS=RPS, RTE=RTE, modelType="SEM")

# Shortcut example
SEM.model &lt;- model.sem(BE=BE, LY=LY, RPS=RPS, RTE=RTE)

# Example 6: Multiple Group Model
loading1 &lt;- matrix(NA, 6, 1)
LY1 &lt;- bind(loading1, 0.7)
loading2 &lt;- matrix(0, 6, 2)
loading2[1:3, 1] &lt;- NA
loading2[4:6, 2] &lt;- NA
LY2 &lt;- bind(loading2, 0.7)

latent.cor2 &lt;- matrix(NA, 2, 2)
diag(latent.cor2) &lt;- 1
RPS1 &lt;- binds(as.matrix(1))
RPS2 &lt;- binds(latent.cor2, 0.5)

RTE &lt;- binds(diag(6))

VTE &lt;- bind(rep(NA, 6), 0.51)

noninvariance &lt;- model(LY = list(LY1, LY2), RPS = list(RPS1, RPS2), RTE = list(RTE, RTE), 
	VTE=list(VTE, VTE), ngroups=2, modelType = "CFA")

# Example 7: Inequality Constraints

loading.in &lt;- matrix(0, 6, 2)
loading.in[1:3, 1] &lt;- c("load1", "load2", "load3")
loading.in[4:6, 2] &lt;- c("load4", "load5", "load6")
mis &lt;- matrix(0,6,2)
mis[loading.in == "0"] &lt;- "runif(1, -0.1, 0.1)"
LY.in &lt;- bind(loading.in, "runif(1, 0.7, 0.8)", mis)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VTE &lt;- bind(rep(NA, 6), 0.51)

VPS1 &lt;- bind(rep(1, 2))

VPS2 &lt;- bind(rep(NA, 2), c(1.1, 1.2))

# Inequality constraint
script &lt;- "
sth := load1 + load2 + load3
load4 == (load5 + load6) / 2
load4 &gt; 0
load5 &gt; 0
sth2 := load1 - load2
"

# Model Template
weak &lt;- model(LY = LY.in, RPS = RPS, VPS=list(VPS1, VPS2), RTE = RTE, VTE=VTE, ngroups=2, 
	modelType = "CFA", con=script)
</code></pre>

<hr>
<h2 id='model.lavaan'>
Build the data generation template and analysis template from the lavaan result
</h2><span id='topic+model.lavaan'></span>

<h3>Description</h3>

<p>Creates a data generation and analysis template (lavaan parameter table) for simulations with the <code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> result. Model misspecification may be added into the template by a vector, a matrix, or a list of vectors or matrices (for multiple groups). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.lavaan(object, std = FALSE, LY = NULL, PS = NULL, RPS = NULL, 
	TE = NULL, RTE = NULL, BE = NULL, VTE = NULL, VY = NULL, VPS = NULL, 
	VE=NULL, TY = NULL, AL = NULL, MY = NULL, ME = NULL, KA = NULL, 
	GA = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.lavaan_+3A_object">object</code></td>
<td>

<p>A <code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> object to be used to build the data generation and analysis template.
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_std">std</code></td>
<td>

<p>If TRUE, use the resulting standardized parameters for data generation. If FALSE, use the unstandardized parameters for data generation.
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_ly">LY</code></td>
<td>

<p>Model misspecification in factor loading matrix from endogenous factors to Y indicators (need to be a matrix or a list of matrices).
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_ps">PS</code></td>
<td>

<p>Model misspecification in residual covariance matrix among endogenous factors (need to be a symmetric matrix or a list of symmetric matrices).
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_rps">RPS</code></td>
<td>

<p>Model misspecification in residual correlation matrix among endogenous factors (need to be a symmetric matrix or a list of symmetric matrices).
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_te">TE</code></td>
<td>

<p>Model misspecification in measurement error covariance matrix among Y indicators (need to be a symmetric matrix or a list of symmetric matrices).
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_rte">RTE</code></td>
<td>

<p>Model misspecification in measurement error correlation matrix among Y indicators (need to be a symmetric matrix or a list of symmetric matrices).
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_be">BE</code></td>
<td>

<p>Model misspecification in regression coefficient matrix among endogenous factors (need to be a symmetric matrix or a list of symmetric matrices).
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_vte">VTE</code></td>
<td>

<p>Model misspecification in measurement error variance of indicators (need to be a vector or a list of vectors).
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_vy">VY</code></td>
<td>

<p>Model misspecification in total variance of indicators (need to be a vector or a list of vectors). NOTE: Either measurement error variance or indicator variance is specified. Both cannot be simultaneously specified.
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_vps">VPS</code></td>
<td>

<p>Model misspecification in residual variance of factors (need to be a vector or a list of vectors).
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_ve">VE</code></td>
<td>

<p>Model misspecification in total variance of of factors (need to be a vector or a list of vectors). NOTE: Either residual variance of factors or total variance of factors is specified. Both cannot be simulatneously specified.
</p>
</td></tr>  
<tr><td><code id="model.lavaan_+3A_ty">TY</code></td>
<td>

<p>Model misspecification in measurement intercepts of Y indicators. (need to be a vector or a list of vectors).
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_al">AL</code></td>
<td>

<p>Model misspecification in endogenous factor intercept (need to be a vector or a list of vectors).
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_my">MY</code></td>
<td>

<p>Model misspecification in overall Y indicator means. (need to be a vector or a list of vectors). NOTE: Either measurement intercept of indicator mean can be specified. Both cannot be specified simultaneously.
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_me">ME</code></td>
<td>

<p>Model misspecification in total mean of endogenous factors (need to be a vector or a list of vectors). NOTE: Either endogenous factor intercept or total mean of endogenous factor is specified. Both cannot be simultaneously specified.
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_ka">KA</code></td>
<td>

<p>Model misspecification in regression coefficient matrix from covariates to indicators (need to be a matrix or a list of matrices). KA is applicable when exogenous covariates are specified only.
</p>
</td></tr>
<tr><td><code id="model.lavaan_+3A_ga">GA</code></td>
<td>

<p>Model misspecification in regression coefficient matrix from covariates to factors (need to be a matrix or a list of matrices). KA is applicable when exogenous covariates are specified only.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SimSem</code> object that contains the data generation template (<code>@dgen</code>) and analysis template (<code>@pt</code>).
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+model">model</a></code> To build data generation and data analysis template for simulation.
</p>
</li>
<li> <p><code><a href="#topic+sim">sim</a></code> for simulations using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li>
<li> <p><code><a href="#topic+generate">generate</a></code> To generate data using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li>
<li> <p><code><a href="#topic+analyze">analyze</a></code> To analyze real or generated data using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li>
<li> <p><code><a href="#topic+draw">draw</a></code> To draw parameters using the <code><a href="#topic+SimSem-class">SimSem</a></code> template.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
HS.model &lt;- ' visual  =~ x1 + x2 + x3
             textual =~ x4 + x5 + x6
             speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)

# Create data generation and data analysis model from lavaan
# Data generation is based on standardized parameters
datamodel1 &lt;- model.lavaan(fit, std=TRUE)

# Data generation is based on unstandardized parameters
datamodel2 &lt;- model.lavaan(fit, std=FALSE)

# Data generation model with misspecification on cross-loadings
crossload &lt;- matrix("runif(1, -0.1, 0.1)", 9, 3)
crossload[1:3, 1] &lt;- 0
crossload[4:6, 2] &lt;- 0
crossload[7:9, 3] &lt;- 0
datamodel3 &lt;- model.lavaan(fit, std=TRUE, LY=crossload)
</code></pre>

<hr>
<h2 id='multipleAllEqual'>
Test whether all objects are equal
</h2><span id='topic+multipleAllEqual'></span>

<h3>Description</h3>

<p>Test whether all objects are equal. The test is based on the <code><a href="Matrix.html#topic+all.equal">all.equal</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipleAllEqual(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multipleAllEqual_+3A_...">...</code></td>
<td>

<p>The target objects 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all objects are equal.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>multipleAllEqual(1:5, 1:5, seq(2, 10, 2)/2) # Should be TRUE
multipleAllEqual(1:5, 1:6, seq(2, 10, 2)/2) # Should be FALSE
</code></pre>

<hr>
<h2 id='plotCIwidth'>
Plot a confidence interval width of a target parameter
</h2><span id='topic+plotCIwidth'></span>

<h3>Description</h3>

<p>Plot a confidence interval width of a target parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCIwidth(object, targetParam, assurance = 0.50, useContour = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCIwidth_+3A_object">object</code></td>
<td>

<p>The target (<code><a href="#topic+SimResult-class">SimResult</a></code> 
</p>
</td></tr>
<tr><td><code id="plotCIwidth_+3A_targetparam">targetParam</code></td>
<td>

<p>One or more target parameters to be plotted
</p>
</td></tr>
<tr><td><code id="plotCIwidth_+3A_assurance">assurance</code></td>
<td>

<p>The percentile of the resulting width. When assurance is 0.50, the median of the widths is provided. See Lai &amp; Kelley (2011) for more details.
</p>
</td></tr>
<tr><td><code id="plotCIwidth_+3A_usecontour">useContour</code></td>
<td>

<p>If there are two things from varying sample size, varying percent completely at random, or varying percent missing at random, the <code>plotCutoff</code> function will provide 3D graph. A contour graph is a default. However, if this is specified as <code>FALSE</code>, perspective plot is used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NONE. The plot the confidence interval width is provided.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>References</h3>

<p>Lai, K., &amp; Kelley, K. (2011). Accuracy in parameter estimation for targeted effects in structural equation modeling: Sample size planning for narrow confidence intervals. <em>Psychological Methods, 16</em>, 127-148.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for simResult that used in this function.
</p>
</li>
<li> <p><code><a href="#topic+getCIwidth">getCIwidth</a></code> to get confidence interval widths 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loadingValues &lt;- matrix(0, 6, 2)
loadingValues[1:3, 1] &lt;- 0.7
loadingValues[4:6, 2] &lt;- 0.7
LY &lt;- bind(loading, loadingValues)
latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)
error.cor &lt;- matrix(0, 6, 6)
diag(error.cor) &lt;- 1
RTE &lt;- binds(error.cor)
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output &lt;- sim(5, n=200, model=CFA.Model) 

# Plot the widths of factor correlation
plotCIwidth(Output, "f1~~f2", assurance = 0.80)

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output2 &lt;- sim(NULL, n=seq(450, 500, 10), model=CFA.Model)

# Plot the widths along sample size value
plotCIwidth(Output2, "f1~~f2", assurance = 0.80)

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)
Output3 &lt;- sim(NULL, n=seq(450, 500, 10), pmMCAR=c(0, 0.05, 0.1, 0.15), model=CFA.Model)

# Plot the contours that each contour represents the value of widths at each level
# of sample size and percent missing completely at random
plotCIwidth(Output3, "f1~~f2", assurance = 0.80)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotCoverage'>
Make a plot of confidence interval coverage rates
</h2><span id='topic+plotCoverage'></span>

<h3>Description</h3>

<p>Make a plot of confidence interval coverage rates given varying parameters (e.g., sample size, percent missing completely at random, or random parameters in the model)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCoverage(object, coverParam, coverValue = NULL, contParam = NULL, contN = TRUE, 
    contMCAR = TRUE, contMAR = TRUE, useContour = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCoverage_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that includes at least one randomly varying parameter (e.g. sample size, percent missing, model parameters)
</p>
</td></tr>
<tr><td><code id="plotCoverage_+3A_coverparam">coverParam</code></td>
<td>

<p>Vector of parameters names that the user wishes to find coverage rate for. This can be a vector of names (e.g., &quot;f1=~y2&quot;, &quot;f1~~f2&quot;).
</p>
</td></tr>
<tr><td><code id="plotCoverage_+3A_covervalue">coverValue</code></td>
<td>

<p>A target value used that users wish to find the coverage rate of that value (e.g., 0). If <code>NULL</code>, the parameter values will be used.
</p>
</td></tr>
<tr><td><code id="plotCoverage_+3A_contparam">contParam</code></td>
<td>

<p>Vector of parameters names that vary over replications that users wish to use in the plot.
</p>
</td></tr>
<tr><td><code id="plotCoverage_+3A_contn">contN</code></td>
<td>

<p>Include the varying sample size in the coverage rate plot if available
</p>
</td></tr>
<tr><td><code id="plotCoverage_+3A_contmcar">contMCAR</code></td>
<td>

<p>Include the varying MCAR (missing completely at random percentage) in the coverage rate plot if available
</p>
</td></tr>
<tr><td><code id="plotCoverage_+3A_contmar">contMAR</code></td>
<td>

<p>Include the varying MAR (missing at random percentage) in the coverage rate plot if available
</p>
</td></tr>
<tr><td><code id="plotCoverage_+3A_usecontour">useContour</code></td>
<td>

<p>This argument is used when users specify to plot two varying parameters. If <code>TRUE</code>, the contour plot is used. If <code>FALSE</code>, perspective plot is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predicting whether the confidence interval of each replication covers target value (or parameter) or not by varying parameters using logistic regression (without interaction). Then, plot the logistic curves predicting the probability of significance against the target varying parameters.
</p>


<h3>Value</h3>

<p>Not return any value. This function will plot a graph only.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>), Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to see how to create a simResult object with randomly varying parameters.
</p>
</li>
<li> <p><code><a href="#topic+getCoverage">getCoverage</a></code> to obtain a coverage rate given varying parameters values.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.4)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)

Output &lt;- sim(NULL, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2), model=CFA.Model)

# Plot the power of the first factor loading along the sample size value
plotCoverage(Output, "f1=~y1", contMCAR=FALSE)
plotCoverage(Output, "f1=~y1", coverValue = 0, contMCAR=FALSE)

# Plot the power of the correlation along the sample size and percent missing completely at random
plotCoverage(Output, "f1=~y1")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotCutoff'>
Plot sampling distributions of fit indices with fit indices cutoffs
</h2><span id='topic+plotCutoff'></span>

<h3>Description</h3>

<p>This function will plot sampling distributions of fit indices. The users may add cutoffs by specifying the <code>alpha</code> level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCutoff(object, alpha = NULL, revDirec = FALSE, usedFit = NULL, 
	useContour = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCutoff_+3A_object">object</code></td>
<td>

<p>The target (<code><a href="#topic+SimResult-class">SimResult</a></code> 
</p>
</td></tr>
<tr><td><code id="plotCutoff_+3A_alpha">alpha</code></td>
<td>

<p>A priori alpha level to get the cutoffs of fit indices
</p>
</td></tr>
<tr><td><code id="plotCutoff_+3A_revdirec">revDirec</code></td>
<td>

<p>The default is to find critical point on the side that indicates worse fit (the right side of RMSEA or the left side of CFI). If specifying as <code>TRUE</code>, the directions are reversed.
</p>
</td></tr>
<tr><td><code id="plotCutoff_+3A_usedfit">usedFit</code></td>
<td>

<p>The name of fit indices that researchers wish to plot
</p>
</td></tr>
<tr><td><code id="plotCutoff_+3A_usecontour">useContour</code></td>
<td>

<p>If there are two things from varying sample size, varying percent completely at random, or varying percent missing at random, the <code>plotCutoff</code> function will provide 3D graph. A contour graph is a default. However, if this is specified as <code>FALSE</code>, perspective plot is used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NONE. The plot the fit indices distributions is provided.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for simResult that used in this function.
</p>
</li>
<li> <p><code><a href="#topic+getCutoff">getCutoff</a></code> to find values of cutoffs based on null hypothesis sampling distributions only
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loadingValues &lt;- matrix(0, 6, 2)
loadingValues[1:3, 1] &lt;- 0.7
loadingValues[4:6, 2] &lt;- 0.7
LY &lt;- bind(loading, loadingValues)
latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)
error.cor &lt;- matrix(0, 6, 6)
diag(error.cor) &lt;- 1
RTE &lt;- binds(error.cor)
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output &lt;- sim(5, n=200, model=CFA.Model) 

# Plot the cutoffs with desired fit indices
plotCutoff(Output, 0.05, usedFit=c("RMSEA", "SRMR", "CFI", "TLI"))

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output2 &lt;- sim(NULL, n=seq(450, 500, 10), model=CFA.Model)

# Plot the cutoffs along sample size value
plotCutoff(Output2, 0.05)

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)
Output3 &lt;- sim(NULL, n=seq(450, 500, 10), pmMCAR=c(0, 0.05, 0.1, 0.15), model=CFA.Model)

# Plot the contours that each contour represents the value of cutoff at each level
# of sample size and percent missing completely at random
plotCutoff(Output3, 0.05)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotCutoffNested'>
Plot sampling distributions of the differences in fit indices between nested models with fit indices cutoffs 
</h2><span id='topic+plotCutoffNested'></span>

<h3>Description</h3>

<p>This function will plot sampling distributions of the differences in fit indices between nested models if the nested model is true. The users may add cutoffs by specifying the <code>alpha</code> level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCutoffNested(nested, parent, alpha = 0.05, cutoff = NULL, 
usedFit = NULL, useContour = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCutoffNested_+3A_nested">nested</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the analysis results of nested model from multiple replications
</p>
</td></tr>
<tr><td><code id="plotCutoffNested_+3A_parent">parent</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the analysis results of parent model from multiple replications
</p>
</td></tr>
<tr><td><code id="plotCutoffNested_+3A_alpha">alpha</code></td>
<td>

<p>A priori alpha level
</p>
</td></tr>
<tr><td><code id="plotCutoffNested_+3A_cutoff">cutoff</code></td>
<td>

<p>A priori cutoffs for fit indices, saved in a vector
</p>
</td></tr>
<tr><td><code id="plotCutoffNested_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to plot the sampling distribution. 
</p>
</td></tr>
<tr><td><code id="plotCutoffNested_+3A_usecontour">useContour</code></td>
<td>

<p>If there are two of sample size, percent completely at random, and percent missing at random are varying, the <code>plotCutoff</code> function will provide 3D graph. Contour graph is a default. However, if this is specified as <code>FALSE</code>, perspective plot is used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NONE. Only plot the fit indices distributions.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for simResult that used in this function.
</p>
</li>
<li> <p><code><a href="#topic+getCutoffNested">getCutoffNested</a></code> to find the difference in fit indices cutoffs
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Nested model: One factor
loading.null &lt;- matrix(0, 6, 1)
loading.null[1:6, 1] &lt;- NA
LY.NULL &lt;- bind(loading.null, 0.7)
RPS.NULL &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model.NULL &lt;- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# Parent model: two factors
loading.alt &lt;- matrix(0, 6, 2)
loading.alt[1:3, 1] &lt;- NA
loading.alt[4:6, 2] &lt;- NA
LY.ALT &lt;- bind(loading.alt, 0.7)
latent.cor.alt &lt;- matrix(NA, 2, 2)
diag(latent.cor.alt) &lt;- 1
RPS.ALT &lt;- binds(latent.cor.alt, "runif(1, 0.7, 0.9)")
CFA.Model.ALT &lt;- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.NULL.NULL &lt;- sim(10, n=500, model=CFA.Model.NULL) 
Output.NULL.ALT &lt;- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.NULL)

# Plot the cutoffs in nested model comparison
plotCutoffNested(Output.NULL.NULL, Output.NULL.ALT, alpha=0.05)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotCutoffNonNested'>
Plot sampling distributions of the differences in fit indices between non-nested models with fit indices cutoffs 
</h2><span id='topic+plotCutoffNonNested'></span>

<h3>Description</h3>

<p>This function will plot sampling distributions of the differences in fit indices between non-nested models. The users may add cutoffs by specifying the <code>alpha</code> level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCutoffNonNested(dat1Mod1, dat1Mod2, dat2Mod1=NULL, dat2Mod2=NULL, 
alpha=0.05, cutoff = NULL, usedFit = NULL, useContour = T, onetailed=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCutoffNonNested_+3A_dat1mod1">dat1Mod1</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 1
</p>
</td></tr>
<tr><td><code id="plotCutoffNonNested_+3A_dat1mod2">dat1Mod2</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 1
</p>
</td></tr>
<tr><td><code id="plotCutoffNonNested_+3A_dat2mod1">dat2Mod1</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="plotCutoffNonNested_+3A_dat2mod2">dat2Mod2</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="plotCutoffNonNested_+3A_alpha">alpha</code></td>
<td>

<p>A priori alpha level
</p>
</td></tr>
<tr><td><code id="plotCutoffNonNested_+3A_cutoff">cutoff</code></td>
<td>

<p>A priori cutoffs for fit indices, saved in a vector
</p>
</td></tr>
<tr><td><code id="plotCutoffNonNested_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to plot the sampling distribution. 
</p>
</td></tr>
<tr><td><code id="plotCutoffNonNested_+3A_usecontour">useContour</code></td>
<td>

<p>If there are two of sample size, percent completely at random, and percent missing at random are varying, the <code>plotCutoff</code> function will provide 3D graph. Contour graph is a default. However, if this is specified as <code>FALSE</code>, perspective plot is used.
</p>
</td></tr>
<tr><td><code id="plotCutoffNonNested_+3A_onetailed">onetailed</code></td>
<td>

<p>If <code>TRUE</code>, the function will find the cutoff from one-tail test. If <code>FALSE</code>, the funciton will find the cutoff from two-tailed test.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NONE. Only plot the fit indices distributions.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for simResult that used in this function.
</p>
</li>
<li> <p><code><a href="#topic+getCutoffNonNested">getCutoffNonNested</a></code> to find the difference in fit indices cutoffs for non-nested model comparison
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Model A: Factor 1 on Items 1-3 and Factor 2 on Items 4-8
loading.A &lt;- matrix(0, 8, 2)
loading.A[1:3, 1] &lt;- NA
loading.A[4:8, 2] &lt;- NA
LY.A &lt;- bind(loading.A, 0.7)
latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, "runif(1, 0.7, 0.9)")
RTE &lt;- binds(diag(8))
CFA.Model.A &lt;- model(LY = LY.A, RPS = RPS, RTE = RTE, modelType="CFA")

# Model B: Factor 1 on Items 1-4 and Factor 2 on Items 5-8
loading.B &lt;- matrix(0, 8, 2)
loading.B[1:4, 1] &lt;- NA
loading.B[5:8, 2] &lt;- NA
LY.B &lt;- bind(loading.B, 0.7)
CFA.Model.B &lt;- model(LY = LY.B, RPS = RPS, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.A.A &lt;- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.A)
Output.A.B &lt;- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.A)
Output.B.A &lt;- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.B)
Output.B.B &lt;- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.B)

# Plot cutoffs for both model A and model B
plotCutoffNonNested(Output.A.A, Output.A.B, Output.B.A, Output.B.B)

# Plot cutoffs for the model A only
plotCutoffNonNested(Output.A.A, Output.A.B)

# Plot cutoffs for the model A with one-tailed test
plotCutoffNonNested(Output.A.A, Output.A.B, onetailed=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotDist'>
Plot a distribution of a data distribution object
</h2><span id='topic+plotDist'></span>

<h3>Description</h3>

<p>Plot a distribution of a data distribution object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDist(object, xlim = NULL, ylim = NULL, r = 0, var = NULL, contour = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDist_+3A_object">object</code></td>
<td>

<p>The data distribution object (<code><a href="#topic+SimDataDist-class">SimDataDist</a></code>) to plot a distribution 
</p>
</td></tr>
<tr><td><code id="plotDist_+3A_xlim">xlim</code></td>
<td>

<p>A numeric vector with two elements specifying the lower and upper limit of the x-axis to be plotted. 
</p>
</td></tr>
<tr><td><code id="plotDist_+3A_ylim">ylim</code></td>
<td>

<p>A numeric vector with two elements specifying the lower and upper limit of the y-axis to be plotted. This argument is applicable for the joint distribution of two dimensions only
</p>
</td></tr>
<tr><td><code id="plotDist_+3A_r">r</code></td>
<td>

<p>The correlation of two dimensions in the joint distribution
</p>
</td></tr>
<tr><td><code id="plotDist_+3A_var">var</code></td>
<td>

<p>A vector of the index of variables to be plotted. The length of vector cannot be greater than 2.
</p>
</td></tr>
<tr><td><code id="plotDist_+3A_contour">contour</code></td>
<td>

<p>Applicable if two variables are used only. If TRUE, the contour plot is provided. If FALSE, the perspective plot is provided.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. This function will plot a graph only.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimDataDist-class">SimDataDist</a></code> for plotting a data distribution object
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
datadist &lt;- bindDist(skewness = c(0, -2, 2), kurtosis = c(2, 4, 4))

# Plot the joint distribution of Variables 1 and 2 with correlation of 0.5
plotDist(datadist, r=0.5, var=1:2)

# Plot the marginal distribution of the variable 3
plotDist(datadist, var=3)

## Not run: 
datadist2 &lt;- bindDist(c("chisq", "t", "f"), list(df=5), list(df=3), list(df1=3, df2=5))

# Plot the joint distribution of Variables 1 and 2 with correlation of 0.5
plotDist(datadist2, r=0.5, var=1:2)

# Plot the marginal distribution of the variable 3
plotDist(datadist2, var=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotLogitMiss'>
Visualize the missing proportion when the logistic regression method is used.
</h2><span id='topic+plotLogitMiss'></span>

<h3>Description</h3>

<p>Visualize the missing proportion when the logistic regression method is used. The maximum number of independent variables is 2. The extra independent variables will be fixed as a value (the default is 0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLogitMiss(script, ylim=c(0,1), x1lim=c(-3,3), x2lim=c(-3,3), otherx=0, 
	useContour=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLogitMiss_+3A_script">script</code></td>
<td>

<p>The script used in specifying missing data using the logistic regression. See further details in the <code>logit</code> argument of the <code><a href="#topic+miss">miss</a></code> function
</p>
</td></tr>
<tr><td><code id="plotLogitMiss_+3A_ylim">ylim</code></td>
<td>

<p>The range of missing proportion to be plotted.
</p>
</td></tr>
<tr><td><code id="plotLogitMiss_+3A_x1lim">x1lim</code></td>
<td>

<p>The range of the first independent variable to be plotted
</p>
</td></tr>
<tr><td><code id="plotLogitMiss_+3A_x2lim">x2lim</code></td>
<td>

<p>The range of the second independent variable to be plotted
</p>
</td></tr>
<tr><td><code id="plotLogitMiss_+3A_otherx">otherx</code></td>
<td>

<p>The value of the extra independent variables to be fixed as.
</p>
</td></tr>
<tr><td><code id="plotLogitMiss_+3A_usecontour">useContour</code></td>
<td>

<p>If there are two or more independent variables, the function will provide 3D graph. Contour graph is a default. However, if this is specified as <code>FALSE</code>, perspective plot is used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Not return any value. This function will plot a graph only. If the number of independent variable is 0, the bar graph is provided. If the number of independent variables is 1, the logistic curve is provided. If the number of independent variables is 2, contour or perspective plot is provided.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>), Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+miss">miss</a></code> to create the missing data template
</p>
</li>
<li> <p><code><a href="#topic+impose">impose</a></code> to impose missing data
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>script &lt;- 'y1 ~ 0.05 + 0.1*y2 + 0.3*y3
	y4 ~ -2 + 0.1*y4
	y5 ~ -0.5' 
plotLogitMiss(script)

script2 &lt;- 'y1 ~ 0.05 + 0.5*y3
	y2 ~ p(0.2)
	y3 ~ p(0.1) + -1*y1
	y4 ~ p(0.3) + 0.2*y1 + -0.3*y2
	y5 ~ -0.5' 
plotLogitMiss(script2)
</code></pre>

<hr>
<h2 id='plotMisfit'>
Plot the population misfit in the result object
</h2><span id='topic+plotMisfit'></span>

<h3>Description</h3>

<p>Plot a histogram of the amount of population misfit in parameter result object or the scatter plot of the relationship between misspecified parameter and the population misfit or the fit indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMisfit(object, usedFit="default", misParam=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMisfit_+3A_object">object</code></td>
<td>

<p>The result object, <code><a href="#topic+SimResult-class">SimResult</a></code>
</p>
</td></tr>
<tr><td><code id="plotMisfit_+3A_usedfit">usedFit</code></td>
<td>

<p>The sample fit indices or population misfit used to plot. All sample fit indices are available. The available population misfit are <code>"pop.f0"</code>, <code>"pop.rmsea"</code>, and <code>"pop.srmr"</code>. If the <code>misParam</code> is not specified, all population misfit are used. If the <code>misParam</code> is specified, the <code>"pop.rmsea"</code> is used in the plot.
</p>
</td></tr>
<tr><td><code id="plotMisfit_+3A_misparam">misParam</code></td>
<td>

<p>The index or the name of misspecified parameters used to plot.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. This function will plot only.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path.BE &lt;- matrix(0, 4, 4)
path.BE[3, 1:2] &lt;- NA
path.BE[4, 3] &lt;- NA
starting.BE &lt;- matrix("", 4, 4)
starting.BE[3, 1:2] &lt;- "runif(1, 0.3, 0.5)"
starting.BE[4, 3] &lt;- "runif(1, 0.5, 0.7)"
mis.path.BE &lt;- matrix(0, 4, 4)
mis.path.BE[4, 1:2] &lt;- "runif(1, -0.1, 0.1)"
BE &lt;- bind(path.BE, starting.BE, misspec=mis.path.BE)

residual.error &lt;- diag(4)
residual.error[1,2] &lt;- residual.error[2,1] &lt;- NA
RPS &lt;- binds(residual.error, "rnorm(1, 0.3, 0.1)")

ME &lt;- bind(rep(NA, 4), 0)

Path.Model &lt;- model(RPS = RPS, BE = BE, ME = ME, modelType="Path")

# The number of replications in actual analysis should be much more than 20
Output &lt;- sim(20, n=500, Path.Model)

# Plot the distribution of population misfit
plotMisfit(Output)

# Plot the relationship between population RMSEA and all misspecified direct effects
plotMisfit(Output, misParam=1:2)

# Plot the relationship between sample CFI and all misspecified direct effects 
plotMisfit(Output, usedFit="CFI", misParam=1:2)
</code></pre>

<hr>
<h2 id='plotPower'>
Make a power plot of a parameter given varying parameters
</h2><span id='topic+plotPower'></span>

<h3>Description</h3>

<p>Make a power plot of a parameter given varying parameters (e.g., sample size, percent missing completely at random, or random parameters in the model)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPower(object, powerParam, alpha = 0.05, contParam = NULL, contN = TRUE, 
	contMCAR = TRUE, contMAR = TRUE, useContour=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPower_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that includes at least one randomly varying parameter (e.g. sample size, percent missing, model parameters)
</p>
</td></tr>
<tr><td><code id="plotPower_+3A_powerparam">powerParam</code></td>
<td>

<p>Vector of parameters names that the user wishes to find power for. This can be a vector of names (e.g., &quot;f1=~y2&quot;, &quot;f1~~f2&quot;).
</p>
</td></tr>
<tr><td><code id="plotPower_+3A_alpha">alpha</code></td>
<td>

<p>Alpha level to use for power analysis.
</p>
</td></tr>
<tr><td><code id="plotPower_+3A_contparam">contParam</code></td>
<td>

<p>Vector of parameters names that vary over replications that users wish to use in the plot.
</p>
</td></tr>
<tr><td><code id="plotPower_+3A_contn">contN</code></td>
<td>

<p>Include the varying sample size in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPower_+3A_contmcar">contMCAR</code></td>
<td>

<p>Include the varying MCAR (missing completely at random percentage) in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPower_+3A_contmar">contMAR</code></td>
<td>

<p>Include the varying MAR (missing at random percentage) in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPower_+3A_usecontour">useContour</code></td>
<td>

<p>This argument is used when users specify to plot two varying parameters. If <code>TRUE</code>, the contour plot is used. If <code>FALSE</code>, perspective plot is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predicting whether each replication is significant or not by varying parameters using logistic regression (without interaction). Then, plot the logistic curves predicting the probability of significance against the target varying parameters.
</p>


<h3>Value</h3>

<p>Not return any value. This function will plot a graph only.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>), Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to see how to create a simResult object with randomly varying parameters.
</p>
</li>
<li> <p><code><a href="#topic+getPower">getPower</a></code> to obtain a statistical power given varying parameters values.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.4)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)

Output &lt;- sim(NULL, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2), model=CFA.Model)

# Plot the power of the first factor loading along the sample size value
plotPower(Output, "f1=~y1", contMCAR=FALSE)

# Plot the power of the correlation along the sample size and percent missing completely at random
plotPower(Output, "f1=~y1")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotPowerFit'>
Plot sampling distributions of fit indices that visualize power of rejecting datasets underlying misspecified models
</h2><span id='topic+plotPowerFit'></span>

<h3>Description</h3>

<p>This function will plot sampling distributions of fit indices that visualize power in rejecting the misspecified models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPowerFit(altObject, nullObject = NULL, cutoff = NULL, usedFit = NULL, 
alpha = 0.05, contN = TRUE, contMCAR = TRUE, contMAR = TRUE, 
useContour = TRUE, logistic = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPowerFit_+3A_altobject">altObject</code></td>
<td>

<p>The result object (<code><a href="#topic+SimResult-class">SimResult</a></code>) saves the simulation result of fitting the hypothesized model when the hypothesized model is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plotPowerFit_+3A_nullobject">nullObject</code></td>
<td>

<p>The result object (<code><a href="#topic+SimResult-class">SimResult</a></code>) saves the simulation result of fitting the hypothesized model when the hypothesized model is <code>TRUE</code>. This argument may be not specified if the <code>cutoff</code> is specified.
</p>
</td></tr>
<tr><td><code id="plotPowerFit_+3A_cutoff">cutoff</code></td>
<td>

<p>A vector of priori cutoffs for fit indices.
</p>
</td></tr>
<tr><td><code id="plotPowerFit_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to plot.
</p>
</td></tr>
<tr><td><code id="plotPowerFit_+3A_alpha">alpha</code></td>
<td>

<p>A priori alpha level
</p>
</td></tr>
<tr><td><code id="plotPowerFit_+3A_contn">contN</code></td>
<td>

<p>Include the varying sample size in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPowerFit_+3A_contmcar">contMCAR</code></td>
<td>

<p>Include the varying MCAR (missing completely at random percentage) in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPowerFit_+3A_contmar">contMAR</code></td>
<td>

<p>Include the varying MAR (missing at random percentage) in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPowerFit_+3A_usecontour">useContour</code></td>
<td>

<p>If there are two of sample size, percent completely at random, and percent missing at random are varying, the <code>plotCutoff</code> function will provide 3D graph. Contour graph is a default. However, if this is specified as <code>FALSE</code>, perspective plot is used.
</p>
</td></tr>
<tr><td><code id="plotPowerFit_+3A_logistic">logistic</code></td>
<td>

<p>If <code>logistic</code> is <code>TRUE</code> and the varying parameter exists (e.g., sample size or percent missing), the plot based on logistic regression predicting the significance by the varying parameters is preferred. If <code>FALSE</code>, the overlaying scatterplot with a line of cutoff is plotted.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NONE. Only plot the fit indices distributions.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for simResult that used in this function.
</p>
</li>
<li> <p><code><a href="#topic+getCutoff">getCutoff</a></code> to find values of cutoffs based on null hypothesis sampling distributions only
</p>
</li>
<li> <p><code><a href="#topic+getPowerFit">getPowerFit</a></code> to find power of rejecting the hypothesized model when the hypothesized model is <code>FALSE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Null model: One factor model
loading.null &lt;- matrix(0, 6, 1)
loading.null[1:6, 1] &lt;- NA
LY.NULL &lt;- bind(loading.null, 0.7)
RPS.NULL &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model.NULL &lt;- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output.NULL &lt;- sim(50, n=50, model=CFA.Model.NULL, generate=CFA.Model.NULL) 

# Alternative model: Two-factor model
loading.alt &lt;- matrix(0, 6, 2)
loading.alt[1:3, 1] &lt;- NA
loading.alt[4:6, 2] &lt;- NA
LY.ALT &lt;- bind(loading.alt, 0.7)
latent.cor.alt &lt;- matrix(NA, 2, 2)
diag(latent.cor.alt) &lt;- 1
RPS.ALT &lt;- binds(latent.cor.alt, 0.5)
CFA.Model.ALT &lt;- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")
Output.ALT &lt;- sim(50, n=50, model=CFA.Model.NULL, generate=CFA.Model.ALT)

# Plot the power based on derived cutoff from the null model using four fit indices
plotPowerFit(Output.ALT, nullObject=Output.NULL, alpha=0.05, 
	usedFit=c("RMSEA", "CFI", "TLI", "SRMR"))

# Plot the power of rejecting null model when the rule of thumb from Hu &amp; Bentler (1999) is used
Rule.of.thumb &lt;- c(RMSEA=0.05, CFI=0.95, TLI=0.95, SRMR=0.06)
plotPowerFit(Output.ALT, cutoff=Rule.of.thumb, alpha=0.05, 
	usedFit=c("RMSEA", "CFI", "TLI", "SRMR"))

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output.NULL2 &lt;- sim(NULL, n=seq(50, 250, 25), model=CFA.Model.NULL, generate=CFA.Model.NULL)
Output.ALT2 &lt;- sim(NULL, n=seq(50, 250, 25), model=CFA.Model.NULL, generate=CFA.Model.ALT)

# Plot the power based on derived cutoff from the null model using four fit indices 
# along sample size
plotPowerFit(Output.ALT2, nullObject=Output.NULL2, alpha=0.05, 
	usedFit=c("RMSEA", "CFI", "TLI", "SRMR"))

# Plot the power based on rule of thumb along sample size
plotPowerFit(Output.ALT2, cutoff=Rule.of.thumb, alpha=0.05, 
	usedFit=c("RMSEA", "CFI", "TLI", "SRMR"))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotPowerFitNested'>
Plot power of rejecting a nested model in a nested model comparison by each fit index 
</h2><span id='topic+plotPowerFitNested'></span>

<h3>Description</h3>

<p>This function will plot sampling distributions of the differences in fit indices between parent and nested models. Two sampling distributions will be compared: nested model is <code>FALSE</code> (alternative model) and nested model is <code>TRUE</code> (null model). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPowerFitNested(altNested, altParent, nullNested = NULL, 
nullParent = NULL, cutoff = NULL, usedFit = NULL, alpha = 0.05, 
contN = TRUE, contMCAR = TRUE, contMAR = TRUE, useContour = TRUE, 
logistic = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPowerFitNested_+3A_altnested">altNested</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation result of the nested model when the nested model is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plotPowerFitNested_+3A_altparent">altParent</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation result of the parent model when the nested model is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plotPowerFitNested_+3A_nullnested">nullNested</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation result of the nested model when the nested model is <code>TRUE</code>. This argument may not be specified if the <code>cutoff</code> is specified.
</p>
</td></tr>
<tr><td><code id="plotPowerFitNested_+3A_nullparent">nullParent</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation result of the parent model when the nested model is <code>TRUE</code>. This argument may not be specified if the <code>cutoff</code> is specified.
</p>
</td></tr>
<tr><td><code id="plotPowerFitNested_+3A_cutoff">cutoff</code></td>
<td>

<p>A vector of priori cutoffs for the differences in fit indices.
</p>
</td></tr>
<tr><td><code id="plotPowerFitNested_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to plot.
</p>
</td></tr>
<tr><td><code id="plotPowerFitNested_+3A_alpha">alpha</code></td>
<td>

<p>A priori alpha level
</p>
</td></tr>
<tr><td><code id="plotPowerFitNested_+3A_contn">contN</code></td>
<td>

<p>Include the varying sample size in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPowerFitNested_+3A_contmcar">contMCAR</code></td>
<td>

<p>Include the varying MCAR (missing completely at random percentage) in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPowerFitNested_+3A_contmar">contMAR</code></td>
<td>

<p>Include the varying MAR (missing at random percentage) in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPowerFitNested_+3A_usecontour">useContour</code></td>
<td>

<p>If there are two of sample size, percent completely at random, and percent missing at random are varying, the <code>plotCutoff</code> function will provide 3D graph. Contour graph is a default. However, if this is specified as <code>FALSE</code>, perspective plot is used.
</p>
</td></tr>
<tr><td><code id="plotPowerFitNested_+3A_logistic">logistic</code></td>
<td>

<p>If <code>logistic</code> is <code>TRUE</code> and the varying parameter exists (e.g., sample size or percent missing), the plot based on logistic regression predicting the significance by the varying parameters is preferred. If <code>FALSE</code>, the overlaying scatterplot with a line of cutoff is plotted.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NONE. Only plot the fit indices distributions.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for simResult that used in this function.
</p>
</li>
<li> <p><code><a href="#topic+getCutoffNested">getCutoffNested</a></code> to find the cutoffs of the differences in fit indices
</p>
</li>
<li> <p><code><a href="#topic+plotCutoffNested">plotCutoffNested</a></code> to visualize the cutoffs of the differences in fit indices
</p>
</li>
<li> <p><code><a href="#topic+getPowerFitNested">getPowerFitNested</a></code> to find the power in rejecting the nested model by the difference in fit indices cutoffs
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Null model: One-factor model
loading.null &lt;- matrix(0, 6, 1)
loading.null[1:6, 1] &lt;- NA
LY.NULL &lt;- bind(loading.null, 0.7)
RPS.NULL &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model.NULL &lt;- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# Alternative model: Two-factor model
loading.alt &lt;- matrix(0, 6, 2)
loading.alt[1:3, 1] &lt;- NA
loading.alt[4:6, 2] &lt;- NA
LY.ALT &lt;- bind(loading.alt, 0.7)
latent.cor.alt &lt;- matrix(NA, 2, 2)
diag(latent.cor.alt) &lt;- 1
RPS.ALT &lt;- binds(latent.cor.alt, 0.7)
CFA.Model.ALT &lt;- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")

# In reality, more than 10 replications are needed
Output.NULL.NULL &lt;- sim(10, n=500, model=CFA.Model.NULL, generate=CFA.Model.NULL) 
Output.ALT.NULL &lt;- sim(10, n=500, model=CFA.Model.NULL, generate=CFA.Model.ALT) 
Output.NULL.ALT &lt;- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.NULL) 
Output.ALT.ALT &lt;- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.ALT) 

# Plot the power based on the derived cutoff from the models analyzed on the null datasets
plotPowerFitNested(Output.ALT.NULL, Output.ALT.ALT, nullNested=Output.NULL.NULL, 
	nullParent=Output.NULL.ALT)

# Plot the power by only CFI
plotPowerFitNested(Output.ALT.NULL, Output.ALT.ALT, nullNested=Output.NULL.NULL, 
	nullParent=Output.NULL.ALT, usedFit="CFI")

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output.NULL.NULL2 &lt;- sim(NULL, n=seq(50, 500, 5), model=CFA.Model.NULL, generate=CFA.Model.NULL) 
Output.ALT.NULL2 &lt;- sim(NULL, n=seq(50, 500, 5), model=CFA.Model.NULL, generate=CFA.Model.ALT) 
Output.NULL.ALT2 &lt;- sim(NULL, n=seq(50, 500, 5), model=CFA.Model.ALT, generate=CFA.Model.NULL) 
Output.ALT.ALT2 &lt;- sim(NULL, n=seq(50, 500, 5), model=CFA.Model.ALT, generate=CFA.Model.ALT) 

# Plot logistic line for the power based on the derived cutoff from the null model 
# along sample size values
plotPowerFitNested(Output.ALT.NULL2, Output.ALT.ALT2, nullNested=Output.NULL.NULL2, 
	nullParent=Output.NULL.ALT2)

# Plot scatterplot for the power based on the derived cutoff from the null model 
# along sample size values
plotPowerFitNested(Output.ALT.NULL2, Output.ALT.ALT2, nullNested=Output.NULL.NULL2, 
	nullParent=Output.NULL.ALT2, logistic=FALSE)

# Plot scatterplot for the power based on the advanced CFI value
plotPowerFitNested(Output.ALT.NULL2, Output.ALT.ALT2, cutoff=c(CFI=-0.1), logistic=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotPowerFitNonNested'>
Plot power of rejecting a non-nested model based on a difference in fit index 
</h2><span id='topic+plotPowerFitNonNested'></span>

<h3>Description</h3>

<p>Plot the proportion of the difference in fit indices from one model that does not in the range of sampling distribution from another model (reject that the dataset comes from the second model) or indicates worse fit than a specified cutoff. This plot can show the proportion in the second model that does not in the range of sampling distribution from the first model too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPowerFitNonNested(dat2Mod1, dat2Mod2, dat1Mod1=NULL, dat1Mod2=NULL, 
cutoff = NULL, usedFit = NULL, alpha = 0.05, contN = TRUE, contMCAR = TRUE, 
contMAR = TRUE, useContour = TRUE, logistic = TRUE, onetailed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPowerFitNonNested_+3A_dat2mod1">dat2Mod1</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_dat2mod2">dat2Mod2</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_dat1mod1">dat1Mod1</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 1
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_dat1mod2">dat1Mod2</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 1
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_cutoff">cutoff</code></td>
<td>

<p>A vector of priori cutoffs for the differences in fit indices.
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to plot.
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_alpha">alpha</code></td>
<td>

<p>A priori alpha level
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_contn">contN</code></td>
<td>

<p>Include the varying sample size in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_contmcar">contMCAR</code></td>
<td>

<p>Include the varying MCAR (missing completely at random percentage) in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_contmar">contMAR</code></td>
<td>

<p>Include the varying MAR (missing at random percentage) in the power plot if available
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_usecontour">useContour</code></td>
<td>

<p>If there are two of sample size, percent completely at random, and percent missing at random are varying, the <code>plotCutoff</code> function will provide 3D graph. Contour graph is a default. However, if this is specified as <code>FALSE</code>, perspective plot is used.
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_logistic">logistic</code></td>
<td>

<p>If <code>logistic</code> is <code>TRUE</code> and the varying parameter exists (e.g., sample size or percent missing), the plot based on logistic regression predicting the significance by the varying parameters is preferred. If <code>FALSE</code>, the overlaying scatterplot with a line of cutoff is plotted.
</p>
</td></tr>
<tr><td><code id="plotPowerFitNonNested_+3A_onetailed">onetailed</code></td>
<td>

<p>If <code>TRUE</code>, the function will use the cutoff from one-tail test. If <code>FALSE</code>, the funciton will use the cutoff from two-tailed test.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NONE. Only plot the fit indices distributions.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for simResult that used in this function.
</p>
</li>
<li> <p><code><a href="#topic+getCutoffNonNested">getCutoffNonNested</a></code> to find the cutoffs of the differences in fit indices for non-nested model comparison
</p>
</li>
<li> <p><code><a href="#topic+plotCutoffNonNested">plotCutoffNonNested</a></code> to visualize the cutoffs of the differences in fit indices for non-nested model comparison
</p>
</li>
<li> <p><code><a href="#topic+getPowerFitNonNested">getPowerFitNonNested</a></code> to find the power in rejecting the non-nested model by the difference in fit indices cutoffs
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Model A: Factor 1 on Items 1-3 and Factor 2 on Items 4-8
loading.A &lt;- matrix(0, 8, 2)
loading.A[1:3, 1] &lt;- NA
loading.A[4:8, 2] &lt;- NA
LY.A &lt;- bind(loading.A, 0.7)
latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, "runif(1, 0.7, 0.9)")
RTE &lt;- binds(diag(8))
CFA.Model.A &lt;- model(LY = LY.A, RPS = RPS, RTE = RTE, modelType="CFA")

# Model B: Factor 1 on Items 1-4 and Factor 2 on Items 5-8
loading.B &lt;- matrix(0, 8, 2)
loading.B[1:4, 1] &lt;- NA
loading.B[5:8, 2] &lt;- NA
LY.B &lt;- bind(loading.B, 0.7)
CFA.Model.B &lt;- model(LY = LY.B, RPS = RPS, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.A.A &lt;- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.A)
Output.A.B &lt;- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.A)
Output.B.A &lt;- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.B)
Output.B.B &lt;- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.B)

# Plot the power based on the derived cutoff for both models
plotPowerFitNonNested(Output.B.A, Output.B.B, dat1Mod1=Output.A.A, dat1Mod2=Output.A.B)

# Plot the power based on AIC and BIC cutoffs
plotPowerFitNonNested(Output.B.A, Output.B.B, cutoff=c(AIC=0, BIC=0))

## End(Not run)
</code></pre>

<hr>
<h2 id='popDiscrepancy'>
Find the discrepancy value between two means and covariance matrices
</h2><span id='topic+popDiscrepancy'></span>

<h3>Description</h3>

<p>Find the discrepancy value between two means and covariance matrices. See the definition of each index at <code><a href="#topic+summaryMisspec">summaryMisspec</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popDiscrepancy(paramM, paramCM, misspecM, misspecCM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popDiscrepancy_+3A_paramm">paramM</code></td>
<td>

<p>The model-implied mean from the real parameters
</p>
</td></tr>
<tr><td><code id="popDiscrepancy_+3A_paramcm">paramCM</code></td>
<td>

<p>The model-implied covariance matrix from the real parameters
</p>
</td></tr>
<tr><td><code id="popDiscrepancy_+3A_misspecm">misspecM</code></td>
<td>

<p>The model-implied mean from the real and misspecified parameters
</p>
</td></tr>
<tr><td><code id="popDiscrepancy_+3A_misspeccm">misspecCM</code></td>
<td>

<p>The model-implied covariance matrix from the real and misspecified parameters
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The discrepancy between two means and covariance matrices
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>References</h3>

<p>Browne, M. W., &amp; Cudeck, R. (1992). Alternative ways of assessing model fit. <em>Sociological Methods &amp; Research, 21</em>, 230-258.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- rep(0, 3)
m2 &lt;- c(0.1, -0.1, 0.05)
S1 &lt;- matrix(c(1, 0.6, 0.5, 0.6, 1, 0.4, 0.5, 0.4, 1), 3, 3)
S2 &lt;- matrix(c(1, 0.55, 0.55, 0.55, 1, 0.55, 0.55, 0.55, 1), 3, 3)
popDiscrepancy(m1, S1, m2, S2)
</code></pre>

<hr>
<h2 id='popMisfitMACS'>
Find population misfit by sufficient statistics
</h2><span id='topic+popMisfitMACS'></span>

<h3>Description</h3>

<p>Find the value quantifying the amount of population misfit: <code class="reqn">F_0</code>, RMSEA, and SRMR. See the definition of each index at <code><a href="#topic+summaryMisspec">summaryMisspec</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popMisfitMACS(paramM, paramCM, misspecM, misspecCM, dfParam=NULL, fit.measures="all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popMisfitMACS_+3A_paramm">paramM</code></td>
<td>

<p>The model-implied mean from the real parameters
</p>
</td></tr>
<tr><td><code id="popMisfitMACS_+3A_paramcm">paramCM</code></td>
<td>

<p>The model-implied covariance matrix from the real parameters
</p>
</td></tr>
<tr><td><code id="popMisfitMACS_+3A_misspecm">misspecM</code></td>
<td>

<p>The model-implied mean from the real and misspecified parameters
</p>
</td></tr>
<tr><td><code id="popMisfitMACS_+3A_misspeccm">misspecCM</code></td>
<td>

<p>The model-implied covariance matrix from the real and misspecified parameters
</p>
</td></tr>
<tr><td><code id="popMisfitMACS_+3A_dfparam">dfParam</code></td>
<td>

<p>The degree of freedom of the real model
</p>
</td></tr>
<tr><td><code id="popMisfitMACS_+3A_fit.measures">fit.measures</code></td>
<td>

<p>The names of indices used to calculate population misfit. There are three types of misfit: 1) discrepancy function (<code>"f0"</code>; see <code><a href="#topic+popDiscrepancy">popDiscrepancy</a></code>), 2) root mean squared error of approximation (<code>"rmsea"</code>; Equation 12 in Browne &amp; Cudeck, 1992), and 3) standardized root mean squared residual (<code>"srmr"</code>)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of the misfit indices
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>References</h3>

<p>Browne, M. W., &amp; Cudeck, R. (1992). Alternative ways of assessing model fit. <em>Sociological Methods &amp; Research, 21</em>, 230-258.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- rep(0, 3)
m2 &lt;- c(0.1, -0.1, 0.05)
S1 &lt;- matrix(c(1, 0.6, 0.5, 0.6, 1, 0.4, 0.5, 0.4, 1), 3, 3)
S2 &lt;- matrix(c(1, 0.55, 0.55, 0.55, 1, 0.55, 0.55, 0.55, 1), 3, 3)
popMisfitMACS(m1, S1, m2, S2)
</code></pre>

<hr>
<h2 id='pValue'>
Find p-values (1 - percentile) by comparing a single analysis output from the result object
</h2><span id='topic+pValue'></span>

<h3>Description</h3>

<p>This function will provide <em>p</em> value from comparing a <code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code>) or a OpenMx result from the simulation result (in <code><a href="#topic+SimResult-class">SimResult</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pValue(target, dist, usedFit = NULL, nVal = NULL, pmMCARval = NULL, 
	pmMARval = NULL, df = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pValue_+3A_target">target</code></td>
<td>

<p>A value, multiple values, a lavaan object, or an OpenMx object used to find p values. This argument could be a cutoff of a fit index.
</p>
</td></tr>
<tr><td><code id="pValue_+3A_dist">dist</code></td>
<td>

<p>The comparison distribution, which can be a vector of numbers, a data frame, or a result object.
</p>
</td></tr>
<tr><td><code id="pValue_+3A_usedfit">usedFit</code></td>
<td>

<p>The vector of names of fit indices that researchers wish to find the <em>p</em> value from.
</p>
</td></tr>
<tr><td><code id="pValue_+3A_nval">nVal</code></td>
<td>

<p>The sample size value that researchers wish to find the fit indices cutoffs from
</p>
</td></tr>
<tr><td><code id="pValue_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent missing completely at random value that researchers wish to find the fit indices cutoffs from.
</p>
</td></tr>
<tr><td><code id="pValue_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random value that researchers wish to find the fit indices cutoffs from.
</p>
</td></tr>
<tr><td><code id="pValue_+3A_df">df</code></td>
<td>

<p>The degree of freedom used in spline method in predicting the fit indices by the predictors. If <code>df</code> is 0, the spline method will not be applied.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In comparing fit indices, the <em>p</em> value is the proportion of the number of replications that provide poorer fit (e.g., less CFI value or greater RMSEA value) than the analysis result from the observed data. 
</p>


<h3>Value</h3>

<p>The <em>p</em> values of fit indices are provided, as well as two additional values: <code>andRule</code> and <code>orRule</code>. The <code>andRule</code> is based on the principle that the model is retained only when all fit indices provide good fit. The proportion is calculated from the number of replications that have all fit indices indicating a better model than the observed data. The proportion from the <code>andRule</code> is the most stringent rule in retaining a hypothesized model. The <code>orRule</code> is based on the principle that the model is retained only when at least one fit index provides good fit. The proportion is calculated from the number of replications that have at least one fit index indicating a better model than the observed data. The proportion from the <code>orRule</code> is the most lenient rule in retaining a hypothesized model.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to run a simulation study
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Compare an analysis result with a result of simulation study
library(lavaan)
loading &lt;- matrix(0, 9, 3)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loading[7:9, 3] &lt;- NA
targetmodel &lt;- estmodel(LY=loading, modelType="CFA", indLab=paste("x", 1:9, sep=""))
out &lt;- analyze(targetmodel, HolzingerSwineford1939)

loading.trivial &lt;- matrix("runif(1, -0.2, 0.2)", 9, 3)
loading.trivial[is.na(loading)] &lt;- 0
mismodel &lt;- model.lavaan(out, std=TRUE, LY=loading.trivial)

# The actual number of replications should be much greater than 20.
simout &lt;- sim(20, n=nrow(HolzingerSwineford1939), mismodel)

# Find the p-value comparing the observed fit indices against the simulated 
# sampling distribution of fit indices
pValue(out, simout)

## End(Not run)
</code></pre>

<hr>
<h2 id='pValueNested'>
Find p-values (1 - percentile) for a nested model comparison
</h2><span id='topic+pValueNested'></span>

<h3>Description</h3>

<p>This function will provide <em>p</em> value from comparing the differences in fit indices between nested models with the simulation results of both parent and nested models when the nested model is true. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pValueNested(outNested, outParent, simNested, simParent, usedFit = NULL, 
nVal = NULL, pmMCARval = NULL, pmMARval = NULL, df = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pValueNested_+3A_outnested">outNested</code></td>
<td>

<p><code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> that saves the analysis result of the nested model from the target dataset
</p>
</td></tr>
<tr><td><code id="pValueNested_+3A_outparent">outParent</code></td>
<td>

<p><code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> that saves the analysis result of the parent model from the target dataset
</p>
</td></tr>
<tr><td><code id="pValueNested_+3A_simnested">simNested</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the analysis results of nested model from multiple replications
</p>
</td></tr>
<tr><td><code id="pValueNested_+3A_simparent">simParent</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the analysis results of parent model from multiple replications
</p>
</td></tr>
<tr><td><code id="pValueNested_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to getCutoffs from. The default is to getCutoffs of all fit indices.
</p>
</td></tr>
<tr><td><code id="pValueNested_+3A_nval">nVal</code></td>
<td>

<p>The sample size value that researchers wish to find the <em>p</em> value from.
</p>
</td></tr>
<tr><td><code id="pValueNested_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent missing completely at random value that researchers wish to find the <em>p</em> value from.
</p>
</td></tr>
<tr><td><code id="pValueNested_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random value that researchers wish to find the the <em>p</em> value from.
</p>
</td></tr>
<tr><td><code id="pValueNested_+3A_df">df</code></td>
<td>

<p>The degree of freedom used in spline method in predicting the fit indices by the predictors. If <code>df</code> is 0, the spline method will not be applied.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In comparing fit indices, the <em>p</em> value is the proportion of the number of replications that provide less preference for nested model (e.g., larger negative difference in CFI values or larger positive difference in RMSEA values) than the analysis result from the observed data. 
</p>


<h3>Value</h3>

<p>This function provides a vector of <em>p</em> values based on the comparison of the difference in fit indices from the real data with the simulation result. The <em>p</em> values of fit indices are provided, as well as two additional values: <code>andRule</code> and <code>orRule</code>. The <code>andRule</code> is based on the principle that the model is retained only when all fit indices provide good fit. The proportion is calculated from the number of replications that have all fit indices indicating a better model than the observed data. The proportion from the <code>andRule</code> is the most stringent rule in retaining a hypothesized model. The <code>orRule</code> is based on the principle that the model is retained only when at least one fit index provides good fit. The proportion is calculated from the number of replications that have at least one fit index indicating a better model than the observed data. The proportion from the <code>orRule</code> is the most lenient rule in retaining a hypothesized model.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>



<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to run a simulation study

</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(lavaan)

# Nested Model: Linear growth curve model
LY &lt;- matrix(1, 4, 2)
LY[,2] &lt;- 0:3
PS &lt;- matrix(NA, 2, 2)
TY &lt;- rep(0, 4)
AL &lt;- rep(NA, 2)
TE &lt;- diag(NA, 4)
nested &lt;- estmodel(LY=LY, PS=PS, TY=TY, AL=AL, TE=TE, modelType="CFA", 
	indLab=paste("t", 1:4, sep=""))

# Parent Model: Unconditional growth curve model
LY2 &lt;- matrix(1, 4, 2)
LY2[,2] &lt;- c(0, NA, NA, 3)
parent &lt;- estmodel(LY=LY2, PS=PS, TY=TY, AL=AL, TE=TE, modelType="CFA", 
	indLab=paste("t", 1:4, sep=""))

# Analyze the output
outNested &lt;- analyze(nested, Demo.growth)
outParent &lt;- analyze(parent, Demo.growth)

# Create data template from the nested model with small misfit on the linear curve
loadingMis &lt;- matrix(0, 4, 2)
loadingMis[2:3, 2] &lt;- "runif(1, -0.1, 0.1)"
datamodel &lt;- model.lavaan(outNested, LY=loadingMis)

# Get the sample size
n &lt;- nrow(Demo.growth)

# The actual replications should be much greater than 30.
simNestedNested &lt;- sim(30, n=n, nested, generate=datamodel) 
simNestedParent &lt;- sim(30, n=n, parent, generate=datamodel)

# Find the p-value comparing the observed fit indices against the simulated 
# sampling distribution of fit indices
pValueNested(outNested, outParent, simNestedNested, simNestedParent)

## End(Not run)
</code></pre>

<hr>
<h2 id='pValueNonNested'>
Find p-values (1 - percentile) for a non-nested model comparison
</h2><span id='topic+pValueNonNested'></span>

<h3>Description</h3>

<p>This function will provide <em>p</em> value from comparing the results of fitting real data into two models against the simulation from fitting the simulated data from both models into both models. The <em>p</em> values from both sampling distribution under the datasets from the first and the second models are reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pValueNonNested(outMod1, outMod2, dat1Mod1, dat1Mod2, dat2Mod1, dat2Mod2, 
usedFit = NULL, nVal = NULL, pmMCARval = NULL, pmMARval = NULL, df = 0, 
onetailed=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pValueNonNested_+3A_outmod1">outMod1</code></td>
<td>

<p><code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> that saves the analysis result of the first model from the target dataset
</p>
</td></tr>
<tr><td><code id="pValueNonNested_+3A_outmod2">outMod2</code></td>
<td>

<p><code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> that saves the analysis result of the second model from the target dataset
</p>
</td></tr>
<tr><td><code id="pValueNonNested_+3A_dat1mod1">dat1Mod1</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 1
</p>
</td></tr>
<tr><td><code id="pValueNonNested_+3A_dat1mod2">dat1Mod2</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 1
</p>
</td></tr>
<tr><td><code id="pValueNonNested_+3A_dat2mod1">dat2Mod1</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 1 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="pValueNonNested_+3A_dat2mod2">dat2Mod2</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> that saves the simulation of analyzing Model 2 by datasets created from Model 2
</p>
</td></tr>
<tr><td><code id="pValueNonNested_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to getCutoffs from. The default is to getCutoffs of all fit indices.
</p>
</td></tr>
<tr><td><code id="pValueNonNested_+3A_nval">nVal</code></td>
<td>

<p>The sample size value that researchers wish to find the <em>p</em> value from.
</p>
</td></tr>
<tr><td><code id="pValueNonNested_+3A_pmmcarval">pmMCARval</code></td>
<td>

<p>The percent missing completely at random value that researchers wish to find the <em>p</em> value from.
</p>
</td></tr>
<tr><td><code id="pValueNonNested_+3A_pmmarval">pmMARval</code></td>
<td>

<p>The percent missing at random value that researchers wish to find the the <em>p</em> value from.
</p>
</td></tr>
<tr><td><code id="pValueNonNested_+3A_df">df</code></td>
<td>

<p>The degree of freedom used in spline method in predicting the fit indices by the predictors. If <code>df</code> is 0, the spline method will not be applied.
</p>
</td></tr>
<tr><td><code id="pValueNonNested_+3A_onetailed">onetailed</code></td>
<td>

<p>If <code>TRUE</code>, the function will convert the <em>p</em> value based on two-tailed test. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In comparing fit indices, the <em>p</em> value is the proportion of the number of replications that provide less preference for either model 1 or model 2 than the analysis result from the observed data. In two-tailed test, the function will report the proportion of values under the sampling distribution that are more extreme that one obtained from real data. If the resulting <code>p</code> value is high (&gt; .05) on one model and low (&lt; .05) in the other model, the model with high <code>p</code> value is preferred. If the <code>p</code> values are both high or both low, the decision is undetermined.
</p>


<h3>Value</h3>

<p>This function provides a vector of <em>p</em> values based on the comparison of the difference in fit indices from the real data with the simulation results. The <em>p</em> values of fit indices are provided, as well as two additional values: <code>andRule</code> and <code>orRule</code>. The <code>andRule</code> is based on the principle that the model is retained only when all fit indices provide good fit. The proportion is calculated from the number of replications that have all fit indices indicating a better model than the observed data. The proportion from the <code>andRule</code> is the most stringent rule in retaining a hypothesized model. The <code>orRule</code> is based on the principle that the model is retained only when at least one fit index provides good fit. The proportion is calculated from the number of replications that have at least one fit index indicating a better model than the observed data. The proportion from the <code>orRule</code> is the most lenient rule in retaining a hypothesized model.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>



<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> to run a simulation study

</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Model A; Factor 1 --&gt; Factor 2; Factor 2 --&gt; Factor 3
library(lavaan)
loading &lt;- matrix(0, 11, 3)
loading[1:3, 1] &lt;- NA
loading[4:7, 2] &lt;- NA
loading[8:11, 3] &lt;- NA
path.A &lt;- matrix(0, 3, 3)
path.A[2, 1] &lt;- NA
path.A[3, 2] &lt;- NA
model.A &lt;- estmodel(LY=loading, BE=path.A, modelType="SEM", indLab=c(paste("x", 1:3, sep=""), 
	paste("y", 1:8, sep="")))

out.A &lt;- analyze(model.A, PoliticalDemocracy)

# Model A; Factor 1 --&gt; Factor 3; Factor 3 --&gt; Factor 2
path.B &lt;- matrix(0, 3, 3)
path.B[3, 1] &lt;- NA
path.B[2, 3] &lt;- NA
model.B &lt;- estmodel(LY=loading, BE=path.B, modelType="SEM", indLab=c(paste("x", 1:3, sep=""), 
	paste("y", 1:8, sep="")))

out.B &lt;- analyze(model.B, PoliticalDemocracy)

loading.mis &lt;- matrix("runif(1, -0.2, 0.2)", 11, 3)
loading.mis[is.na(loading)] &lt;- 0

# Create SimSem object for data generation and data analysis template
datamodel.A &lt;- model.lavaan(out.A, std=TRUE, LY=loading.mis)
datamodel.B &lt;- model.lavaan(out.B, std=TRUE, LY=loading.mis)

# Get sample size
n &lt;- nrow(PoliticalDemocracy)

# The actual number of replications should be greater than 20.
output.A.A &lt;- sim(20, n=n, model.A, generate=datamodel.A) 
output.A.B &lt;- sim(20, n=n, model.B, generate=datamodel.A)
output.B.A &lt;- sim(20, n=n, model.A, generate=datamodel.B)
output.B.B &lt;- sim(20, n=n, model.B, generate=datamodel.B)

# Find the p-value comparing the observed fit indices against the simulated 
# sampling distribution of fit indices

pValueNonNested(out.A, out.B, output.A.A, output.A.B, output.B.A, output.B.B)

# If the p-value for model A is significant but the p-value for model B is not
# significant, model B is preferred.

## End(Not run)
</code></pre>

<hr>
<h2 id='rawDraw'>
Draw values from vector or matrix objects
</h2><span id='topic+rawDraw'></span>

<h3>Description</h3>

<p>Takes one matrix or vector object (<code><a href="#topic+SimMatrix-class">SimMatrix</a></code> or <code><a href="#topic+SimVector-class">SimVector</a></code>) and returns a matrix or a vector with numerical values for population parameters. If a matrix is symmetric, it is arbitrarily chosen that parameters on the upper triangular elements are set equal to the parameters on the lower triangular elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawDraw(simDat, constraint = TRUE, misSpec = TRUE, parMisOnly = FALSE, 
    misOnly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawDraw_+3A_simdat">simDat</code></td>
<td>

<p>A matrix or vector object (<code><a href="#topic+SimMatrix-class">SimMatrix</a></code> or <code><a href="#topic+SimVector-class">SimVector</a></code>)
</p>
</td></tr>
<tr><td><code id="rawDraw_+3A_constraint">constraint</code></td>
<td>

<p>If TRUE, then constraints are applied simultaneously
</p>
</td></tr>
<tr><td><code id="rawDraw_+3A_misspec">misSpec</code></td>
<td>

<p>If TRUE, then a list is returned with [[1]] parameters with no misspec and [[2]] same parameters + misspec (if any)
</p>
</td></tr>
<tr><td><code id="rawDraw_+3A_parmisonly">parMisOnly</code></td>
<td>

<p>If TRUE, then only the parameters + misspecification is returned
</p>
</td></tr>
<tr><td><code id="rawDraw_+3A_misonly">misOnly</code></td>
<td>

<p>If TRUE, then only the misspecification is returned
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or vector) or a list of matrices (or vectors) which contains the draw result.
</p>


<h3>Author(s)</h3>

<p>Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 7, 3)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loading[1:7, 3] &lt;- NA
loadingVal &lt;- matrix(0, 7, 3)
loadingVal[1:3, 1] &lt;- "runif(1, 0.5, 0.7)"
loadingVal[4:6, 2] &lt;- "runif(1, 0.5, 0.7)"
loadingVal[1:6, 3] &lt;- "runif(1, 0.3, 0.5)"
loadingVal[7, 3] &lt;- 1
loading.mis &lt;- matrix("runif(1, -0.2, 0.2)", 7, 3)
loading.mis[is.na(loading)] &lt;- 0
loading.mis[,3] &lt;- 0
loading.mis[7,] &lt;- 0
loading[1:3, 1] &lt;- "con1"
LY &lt;- bind(loading, loadingVal, misspec=loading.mis)

# Draw values
rawDraw(LY)

# Draw only model parameters containing misspecification
rawDraw(LY, parMisOnly=TRUE)

# Draw only misspecification.
rawDraw(LY, misOnly=TRUE)
</code></pre>

<hr>
<h2 id='setPopulation'>
Set the data generation population model underlying an object
</h2><span id='topic+setPopulation'></span>

<h3>Description</h3>

<p>This function will set the data generation population model to be an appropriate one. If the appropriate data generation model is specified, the additional features can be seen in <code><a href="base.html#topic+summary">summary</a></code> or <code><a href="#topic+summaryParam">summaryParam</a></code> functions on the target object, such as bias in parameter estimates or percentage coverage. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPopulation(target, population)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPopulation_+3A_target">target</code></td>
<td>

<p>The result object that you wish to set the data generation population model (<code>linkS4class{SimResult}</code>).
</p>
</td></tr>
<tr><td><code id="setPopulation_+3A_population">population</code></td>
<td>

<p>The population parameters specified in the <code>linkS4class{SimSem}</code> object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The target object that is changed the parameter.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for result object
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># See each class for an example.
## Not run: 
# Data generation model
loading &lt;- matrix(0, 7, 3)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loading[1:7, 3] &lt;- NA
loadingVal &lt;- matrix(0, 7, 3)
loadingVal[1:3, 1] &lt;- "runif(1, 0.5, 0.7)"
loadingVal[4:6, 2] &lt;- "runif(1, 0.5, 0.7)"
loadingVal[1:6, 3] &lt;- "runif(1, 0.3, 0.5)"
loadingVal[7, 3] &lt;- 1
loading.mis &lt;- matrix("runif(1, -0.2, 0.2)", 7, 3)
loading.mis[is.na(loading)] &lt;- 0
loading.mis[,3] &lt;- 0
loading.mis[7,] &lt;- 0
LY &lt;- bind(loading, loadingVal, misspec=loading.mis)

RPS &lt;- binds(diag(3))

path &lt;- matrix(0, 3, 3)
path[2, 1] &lt;- NA
BE &lt;- bind(path, "runif(1, 0.3, 0.5)")

RTE &lt;- binds(diag(7))

VY &lt;- bind(c(rep(NA, 6), 0), c(rep(1, 6), ""))

datamodel &lt;- model(LY=LY, RPS=RPS, BE=BE, RTE=RTE, VY=VY, modelType="SEM")

# Data analysis model
loading &lt;- matrix(0, 7, 3)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loading[7, 3] &lt;- NA
path &lt;- matrix(0, 3, 3)
path[2, 1] &lt;- NA
path[1, 3] &lt;- NA
path[2, 3] &lt;- NA
errorCov &lt;- diag(NA, 7)
errorCov[7, 7] &lt;- 0
facCov &lt;- diag(3)
analysis &lt;- estmodel(LY=loading, BE=path, TE=errorCov, PS=facCov, modelType="SEM", 
	indLab=paste("y", 1:7, sep=""))

# In reality, more than 10 replications are needed.
Output &lt;- sim(10, n=200, analysis, generate=datamodel)

# Population 
loadingVal &lt;- matrix(0, 7, 3)
loadingVal[1:3, 1] &lt;- 0.6
loadingVal[4:6, 2] &lt;- 0.6
loadingVal[7, 3] &lt;- 1
LY &lt;- bind(loading, loadingVal)
pathVal &lt;- matrix(0, 3, 3)
pathVal[2, 1] &lt;- 0.4
pathVal[1, 3] &lt;- 0.4
pathVal[2, 3] &lt;- 0.4
BE &lt;- bind(path, pathVal)
PS &lt;- binds(facCov)
errorCovVal &lt;- diag(0.64, 7)
errorCovVal[7, 7] &lt;- 0
TE &lt;- binds(errorCov, errorCovVal)
population &lt;- model(LY=LY, PS=PS, BE=BE, TE=TE, modelType="SEM")

# Set up the new population
Output2 &lt;- setPopulation(Output, population) 

# This summary will contain the bias information
summary(Output2)

## End(Not run)
</code></pre>

<hr>
<h2 id='sim'>
Run a Monte Carlo simulation with a structural equation model.
</h2><span id='topic+sim'></span>

<h3>Description</h3>

<p>This function can be used to generate data, analyze the generated data, and summarized into a result object where parameter estimates, standard errors, fit indices, and other characteristics of each replications are saved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(nRep, model, n, generate = NULL, ..., rawData = NULL, miss = NULL, datafun=NULL,
	lavaanfun = "lavaan", outfun=NULL, outfundata = NULL, pmMCAR = NULL,
	pmMAR = NULL, 	facDist = NULL, indDist = NULL, errorDist = NULL,
	sequential = FALSE, saveLatentVar = FALSE, modelBoot = FALSE, realData = NULL,
	covData = NULL, maxDraw = 50, misfitType = "f0", misfitBounds = NULL,
	averageNumMisspec = FALSE, optMisfit=NULL, optDraws = 50,
	createOrder = c(1, 2, 3), aux = NULL, group = NULL, mxFit = FALSE,
	mxMixture = FALSE, citype = NULL, cilevel = 0.95, seed = 123321, silent = FALSE,
	multicore = options('simsem.multicore')[[1]], cluster = FALSE,
	numProc = NULL, paramOnly = FALSE, dataOnly=FALSE, smartStart=FALSE,
	previousSim = NULL, completeRep = FALSE, stopOnError = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_+3A_nrep">nRep</code></td>
<td>

<p>Number of replications. If any of the <code>n</code>, <code>pmMCAR</code>, or <code>pmMAR</code> arguments are specified as lists, the number of replications will default to the length of the list(s), and <code>nRep</code> need not be specified (can be set <code>NULL</code>).
</p>
</td></tr>
<tr><td><code id="sim_+3A_model">model</code></td>
<td>

<p>There are three options for this argument: 1. <code><a href="#topic+SimSem-class">SimSem</a></code> object created by <code><a href="#topic+model">model</a></code>, 2. <code>lavaan</code> script, <code>lavaan</code> parameter table, fitted <code>lavaan</code> object matching the analysis model, or a list that contains all argument that users use to run <code>lavaan</code> (including <code>cfa</code>, <code>sem</code>, <code>lavaan</code>), 3. <code>MxModel</code> object from the <code>OpenMx</code> package, or 4. a function that takes a data set and return a list of <code>coef</code>, <code>se</code>, and <code>converged</code> (see details below). For the <code><a href="#topic+SimSem-class">SimSem</a></code> object, if the <code>generate</code> argument is not specified, then the object in the <code>model</code> argument will be used for both data generation and analysis. If <code>generate</code> is specified, then the <code>model</code> argument will be used for data analysis only.
</p>
</td></tr>
<tr><td><code id="sim_+3A_n">n</code></td>
<td>

<p>Sample size(s). In single-group models, either a single <code>integer</code>, or a vector of integers to vary sample size across replications. In multigroup models, either a <code>list</code> of single integers (for constant group sizes across replications) or a <code>list</code> of vectors (to vary group sizes across replications).

Any non-integers will be rounded.
</p>
</td></tr>
<tr><td><code id="sim_+3A_generate">generate</code></td>
<td>

<p>There are four options for this argument: 1. <code><a href="#topic+SimSem-class">SimSem</a></code> object created by <code><a href="#topic+model">model</a></code>, 2. <code>lavaan</code> script, <code>lavaan</code> parameter table (for data generation; see <code><a href="lavaan.html#topic+simulateData">simulateData</a></code>), fitted <code>lavaan</code> object that estimated all nonzero population parameters, or a list that contains all argument that users use to run <code><a href="lavaan.html#topic+simulateData">simulateData</a></code>, 3. <code>MxModel</code> object with population parameters specified in the starting values of all matrices in the model, 4. a function that take only one sample size argument (by integer for single-group model or by a vector of integers for multiple-group model). The <code>generate</code> argument cannot be specified the same time as the <code>rawData</code> argument.
</p>
</td></tr>
<tr><td><code id="sim_+3A_rawdata">rawData</code></td>
<td>

<p>There are two options for this argument: 1. a list of data frames to be used in simulations or 2. a population data. If a list of data frames is specified, the <code>nRep</code> and <code>n</code> arguments must not be specified. If a population data frame is specified, the <code>nRep</code> and <code>n</code> arguments are required.
</p>
</td></tr>
<tr><td><code id="sim_+3A_miss">miss</code></td>
<td>

<p>A missing data template created using the <code><a href="#topic+miss">miss</a></code> function.
</p>
</td></tr>
<tr><td><code id="sim_+3A_datafun">datafun</code></td>
<td>

<p>A function to be applied to each generated data set across replications.
</p>
</td></tr>
<tr><td><code id="sim_+3A_lavaanfun">lavaanfun</code></td>
<td>

<p>The character of the function name used in running lavaan model (<code>"cfa"</code>, <code>"sem"</code>, <code>"growth"</code>, <code>"lavaan"</code>). This argument is required only when lavaan script or a list of arguments is specified in the <code>model</code> argument.
</p>
</td></tr>
<tr><td><code id="sim_+3A_outfun">outfun</code></td>
<td>

<p>A function to be applied to the <code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> output at each replication. Output from this function in each replication will be saved in the simulation output (<code><a href="#topic+SimResult-class">SimResult</a></code>), and can be obtained using the <code><a href="#topic+getExtraOutput">getExtraOutput</a></code> function.
</p>
</td></tr>
<tr><td><code id="sim_+3A_outfundata">outfundata</code></td>
<td>

<p>A function to be applied to the <code><a href="lavaan.html#topic+lavaan-class">lavaan</a></code> output and the generated data at each replication. Users can get the characteristics of the generated data and also compare the characteristics with the generated output. The output from this function in each replication will be saved in the simulation output (<code><a href="#topic+SimResult-class">SimResult</a></code>), and can be obtained using the <code><a href="#topic+getExtraOutput">getExtraOutput</a></code> function.
</p>
</td></tr>
<tr><td><code id="sim_+3A_pmmcar">pmMCAR</code></td>
<td>

<p>The percentage of data completely missing at random (0 &lt;= pmMCAR &lt; 1). Either a single value or a vector of values in order to vary pmMCAR across replications (with length equal to nRep or a divisor of nRep). The <code>objMissing</code> argument is only required when specifying complex missing value data generation, or when using multiple imputation.
</p>
</td></tr>
<tr><td><code id="sim_+3A_pmmar">pmMAR</code></td>
<td>

<p>The percentage of data missing at random (0 &lt;= pmCAR &lt; 1). Either a single value or a vector of values in order to vary pmCAR across replications (with length equal to nRep or a divisor of nRep). The <code>objMissing</code> argument is only required when specifying complex missing value data generation, or when using multiple imputation.
</p>
</td></tr>
<tr><td><code id="sim_+3A_facdist">facDist</code></td>
<td>

<p>Factor distributions. Either a list of <code><a href="#topic+SimDataDist-class">SimDataDist</a></code> objects or a single <code><a href="#topic+SimDataDist-class">SimDataDist</a></code> object to give all factors the same distribution. Use when <code>sequential</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="sim_+3A_inddist">indDist</code></td>
<td>

<p>Indicator distributions. Either a list of <code><a href="#topic+SimDataDist-class">SimDataDist</a></code> objects or a single <code><a href="#topic+SimDataDist-class">SimDataDist</a></code> object to give all indicators the same distribution. Use when <code>sequential</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="sim_+3A_errordist">errorDist</code></td>
<td>

<p>An object or list of objects of type <code>SimDataDist</code> indicating the distribution of errors. If a single <code>SimDataDist</code> is specified, each error will be genrated with that distribution.
</p>
</td></tr>
<tr><td><code id="sim_+3A_sequential">sequential</code></td>
<td>

<p>If <code>TRUE</code>, a sequential method is used to generate data in which factor data is generated first, and is subsequently applied to a set of equations to obtain the indicator data. If <code>FALSE</code>, data is generated directly from model-implied mean and covariance of the indicators.
</p>
</td></tr>
<tr><td><code id="sim_+3A_savelatentvar">saveLatentVar</code></td>
<td>

<p>If <code>TRUE</code>, the generated latent variable scores and measurement error scores are also provided as the attribute of the generated data. Users can use the <code>outfundata</code> to compare the latent variable scores with the estimated output. The <code>sequential</code> argument must be <code>TRUE</code> in order to use this option.
</p>
</td></tr>
<tr><td><code id="sim_+3A_modelboot">modelBoot</code></td>
<td>

<p>When specified, a model-based bootstrap is used for data generation (for use with the <code>realData</code> argument). See <code><a href="#topic+draw">draw</a></code> for further information.
</p>
</td></tr>
<tr><td><code id="sim_+3A_realdata">realData</code></td>
<td>

<p>A data.frame containing real data. Generated data will follow the distribution of this data set.
</p>
</td></tr>
<tr><td><code id="sim_+3A_covdata">covData</code></td>
<td>

<p>A data.frame containing covariate data, which can have any distributions. This argument is required when users specify <code>GA</code> or <code>KA</code> matrices in the model template (<code><a href="#topic+SimSem-class">SimSem</a></code>).
</p>
</td></tr>
<tr><td><code id="sim_+3A_maxdraw">maxDraw</code></td>
<td>

<p>The maximum number of attempts to draw a valid set of parameters (no negative error variance, standardized coefficients over 1).
</p>
</td></tr>
<tr><td><code id="sim_+3A_misfittype">misfitType</code></td>
<td>

<p>Character vector indicating the fit measure used to assess the misfit of a set of parameters. Can be &quot;f0&quot;, &quot;rmsea&quot;, &quot;srmr&quot;, or &quot;all&quot;.
</p>
</td></tr>
<tr><td><code id="sim_+3A_misfitbounds">misfitBounds</code></td>
<td>

<p>Vector that contains upper and lower bounds of the misfit measure. Sets of parameters drawn that are not within these bounds are rejected.
</p>
</td></tr>
<tr><td><code id="sim_+3A_averagenummisspec">averageNumMisspec</code></td>
<td>

<p>If <code>TRUE</code>, the provided fit will be divided by the number of misspecified parameters.
</p>
</td></tr>
<tr><td><code id="sim_+3A_optmisfit">optMisfit</code></td>
<td>

<p>Character vector of either &quot;min&quot; or &quot;max&quot; indicating either maximum or minimum optimized misfit. If not null, the set of parameters out of the number of draws in &quot;optDraws&quot; that has either the maximum or minimum misfit of the given misfit type will be returned.
</p>
</td></tr>
<tr><td><code id="sim_+3A_optdraws">optDraws</code></td>
<td>

<p>Number of parameter sets to draw if optMisfit is not null. The set of parameters with the maximum or minimum misfit will be returned.
</p>
</td></tr>
<tr><td><code id="sim_+3A_createorder">createOrder</code></td>
<td>

<p>The order of 1) applying equality/inequality constraints, 2) applying misspecification, and 3) fill unspecified parameters (e.g., residual variances when total variances are specified). The specification of this argument is a vector of different orders of 1 (constraint), 2 (misspecification), and 3 (filling parameters). For example, <code>c(1, 2, 3)</code> is to apply constraints first, then add the misspecification, and finally fill all parameters. See the example of how to use it in the <code><a href="#topic+draw">draw</a></code> function.
</p>
</td></tr>
<tr><td><code id="sim_+3A_aux">aux</code></td>
<td>

<p>The names of auxiliary variables saved in a vector.
</p>
</td></tr>
<tr><td><code id="sim_+3A_group">group</code></td>
<td>

<p>The name of the group variable. This argument is used when <code>lavaan</code> script or <code>MxModel</code> is used in the <code>model</code> only. When generating data from a multigroup population model, the grouping variable in each generated data set will be named &quot;group&quot;, so when additionally using a multigroup analysis model, users must specify this argument as <code>group="group"</code>.
</p>
</td></tr>
<tr><td><code id="sim_+3A_mxfit">mxFit</code></td>
<td>

<p>A logical whether to find an extensive list of fit measures (which will be slower). This argument is applicable when <code>MxModel</code> is used in the <code>model</code> argument only.
</p>
</td></tr>
<tr><td><code id="sim_+3A_mxmixture">mxMixture</code></td>
<td>

<p>A logical whether to the analysis model is a mixture model. This argument is applicable when <code>MxModel</code> is used in the <code>model</code> argument only.
</p>
</td></tr>
<tr><td><code id="sim_+3A_citype">citype</code></td>
<td>

<p>Type of confidence interval. For the current version, this argument will be forwarded to the <code>"boot.ci.type"</code> argument in the  <code><a href="lavaan.html#topic+parameterEstimates">parameterEstimates</a></code> function from the <code>lavaan</code> package. This argument is not active when the <code>OpenMx</code> package is used.
</p>
</td></tr>
<tr><td><code id="sim_+3A_cilevel">cilevel</code></td>
<td>

<p>Confidence level. For the current version, this argument will be forwarded to the <code>"level"</code> argument in the  <code><a href="lavaan.html#topic+parameterEstimates">parameterEstimates</a></code> function from the <code>lavaan</code> package. This argument is not active when the <code>OpenMx</code> package is used.
</p>
</td></tr>
<tr><td><code id="sim_+3A_seed">seed</code></td>
<td>

<p>Random number seed. Note that the seed number is always fixed in the <code>simsem</code> so that users can always replicate the same simulatin or can be confidence that the same data set are generated. Reproducibility across multiple cores or clusters is ensured using R'Lecuyer package.
</p>
</td></tr>
<tr><td><code id="sim_+3A_silent">silent</code></td>
<td>

<p>If <code>TRUE</code>, suppress warnings.
</p>
</td></tr>
<tr><td><code id="sim_+3A_multicore">multicore</code></td>
<td>

<p>Users may put <code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, multiple processors within a computer will be utilized. The default value is <code>FALSE</code>. Users may permanently change the default value by assigning the following line: <code>options('simsem.multicore' = TRUE)</code>
</p>
</td></tr>
<tr><td><code id="sim_+3A_cluster">cluster</code></td>
<td>

<p>Not applicable now. Used to specify nodes in hpc in order to be parallelizable.
</p>
</td></tr>
<tr><td><code id="sim_+3A_numproc">numProc</code></td>
<td>

<p>Number of processors for using multiple processors. If it is <code>NULL</code>, the package will find the maximum number of processors.
</p>
</td></tr>
<tr><td><code id="sim_+3A_paramonly">paramOnly</code></td>
<td>

<p>If <code>TRUE</code>, only the parameters from each replication will be returned.
</p>
</td></tr>
<tr><td><code id="sim_+3A_dataonly">dataOnly</code></td>
<td>

<p>If <code>TRUE</code>, only the raw data generated from each replication will be returned.
</p>
</td></tr>
<tr><td><code id="sim_+3A_smartstart">smartStart</code></td>
<td>

<p>Defaults to FALSE. If TRUE, population parameter values that are real numbers will be used as starting values. When tested in small models, the time elapsed when using population values as starting values was greater than the time reduced during analysis, and convergence rates were not affected.
</p>
</td></tr>
<tr><td><code id="sim_+3A_previoussim">previousSim</code></td>
<td>

<p>A result object that users wish to add the results of the current simulation in
</p>
</td></tr>
<tr><td><code id="sim_+3A_completerep">completeRep</code></td>
<td>

<p>If <code>TRUE</code>, the function will run until the number of convergent replication equal to the specified <code>nRep</code>.
</p>
</td></tr>
<tr><td><code id="sim_+3A_stoponerror">stopOnError</code></td>
<td>

<p>If <code>TRUE</code>, stop running the simulation when the error occurs during the data analysis on any replications.
</p>
</td></tr>
<tr><td><code id="sim_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>. See also <code><a href="lavaan.html#topic+lavOptions">lavOptions</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is executed as follows: 1. parameters are drawn from the specified data-generation model (applicable only simsem model template, <code><a href="#topic+SimSem-class">SimSem</a></code>, only), 2. the drawn (or the specified) parameters are used to create data, 3. data can be transformed using the <code>datafun</code> argument, 4. specified missingness (if any) is imposed, 5. data are analyzed using the specified analysis model, 6. parameter estimates, standard errors, fit indices, and other characteristics of a replication are extracted, 7. additional outputs (if any) are extracted using the <code>outfun</code> argument, and 8. results across replications are summarized in a result object, <code><a href="#topic+SimResult-class">SimResult</a></code>).
</p>
<p>There are six ways to provide or generate data in this function:
</p>

<ol>
<li> <p><code><a href="#topic+SimSem-class">SimSem</a></code> can be used as a template to generate data, which can be created by the <code><a href="#topic+model">model</a></code> function. The <code><a href="#topic+SimSem-class">SimSem</a></code> can be specified in the <code>generate</code> argument.
</p>
</li>
<li> <p><code>lavaan</code> script, parameter table for the <code>lavaan</code> package, or a list of arguments for the <code><a href="lavaan.html#topic+simulateData">simulateData</a></code> function. The <code>lavaan</code> script can be specified in the <code>generate</code> argument.
</p>
</li>
<li> <p><code>MxModel</code> object from the <code>OpenMx</code> package. The <code>MxModel</code> object can be specified in the <code>generate</code> argument.
</p>
</li>
<li><p> A list of raw data for each replication can be provided for the <code>rawData</code> argument. The <code>sim</code> function will analyze each data and summarize the result. Note that the <code>generate</code>, <code>n</code> and <code>nRep</code> could not be specified if the list of raw data is provided.
</p>
</li>
<li><p> Population data can be provided for the <code>rawData</code> argument. The <code>sim</code> function will randomly draw sample data sets and analyze data. Note that the <code>n</code> and <code>nRep</code> must be specified if the population data are provided. The <code>generate</code> argument must not be specified.
</p>
</li>
<li><p> A function can be used to generate data. The function must take sample size in a numeric format (or a vector of numerics for multiple groups) and return a data frame of the generated data set. Note that parameter values and their standardized values can be provided by using the attributes of the resulting data set. That is, users can assign parameter values and standardized parameter values to <code>attr(data, "param")</code> and <code>attr(data, "stdparam")</code>.
</p>
</li></ol>

<p>Note that all generated or provided data can be transformed based on Bollen-Stine approach by providing a real data in the <code>realData</code> argument if any of the first three methods are used.
</p>
<p>There are four ways to analyze the data sets for each replication by setting the <code>model</code> argument as
</p>

<ol>
<li> <p><code><a href="#topic+SimSem-class">SimSem</a></code> can be used as a template for data analysis.
</p>
</li>
<li> <p><code>lavaan</code> script, parameter table for the <code>lavaan</code> package, or a list of arguments for the <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>, <code><a href="lavaan.html#topic+sem">sem</a></code>, <code><a href="lavaan.html#topic+cfa">cfa</a></code>, or <code><a href="lavaan.html#topic+growth">growth</a></code> function. Note that if the desired function to analyze data can be specified in the <code>lavaanfun</code> argument, which the default is the <code><a href="lavaan.html#topic+lavaan">lavaan</a></code> function
</p>
</li>
<li> <p><code>MxModel</code> object from the <code>OpenMx</code> package. The object does not need to have data inside. Note that if users need an extensive fit indices, the <code>mxFit</code> argument should be specified as <code>TRUE</code>. If users wish to analyze by mixture model, the <code>mxMixture</code> argument should be <code>TRUE</code> such that the <code>sim</code> function knows how to handle the data.
</p>
</li>
<li><p> A function that takes a data set and returns a list. The list must contain at least three objects: a vector of parameter estimates (<code>coef</code>), a vector of standard error (<code>se</code>), and the convergence status as <code>TRUE</code> or <code>FALSE</code> (<code>converged</code>). There are seven optional objects in the list: a vector of fit indices (<code>fit</code>), a vector of standardized estimates (<code>std</code>), a vector of standard errors of standardized estimates (<code>stdse</code>), fraction missing type I (<code>FMI1</code>), fraction missing type II (<code>FMI2</code>), lower bounds of confidence intervals (<code>cilower</code>), and upper bounds of confidence intervals (<code>ciupper</code>). Note that the <code>coef</code>, <code>se</code>, <code>std</code>, <code>stdse</code>, <code>FMI1</code>, <code>FMI2</code>, <code>cilower</code>, and <code>ciupper</code> must be a vector with names. The name of those vectors across different objects must be the same. Users may optionally specify other objects in the list; however, the results of the other objects will not be automatically combined. Users need to specify the <code>outfun</code> argument to get the extra objects. For example, researchers may specify <code>residuals</code> in the list. The outfun argument should have the function as follows: <code>function(obj) obj$residuals</code>.
</p>
</li></ol>

<p>Any combination of data-generation methods and data-analysis methods are valid. For example, data can be simulated using lavaan script and analyzed by <code>MxModel</code>.  Paralleled processing can be enabled using the <code>multicore</code> argument.
</p>


<h3>Value</h3>

<p>A result object (<code><a href="#topic+SimResult-class">SimResult</a></code>)
</p>


<h3>Author(s)</h3>

<p>Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>)
Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for the resulting output description
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Please go to https://simsem.org/ for more examples in the Vignettes.

## Example of using simsem model template
library(lavaan)

loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# In reality, more than 5 replications are needed.
Output &lt;- sim(5, CFA.Model, n=200)
summary(Output)



## Example of using lavaan model syntax

popModel &lt;- "
f1 =~ 0.7*y1 + 0.7*y2 + 0.7*y3
f2 =~ 0.7*y4 + 0.7*y5 + 0.7*y6
f1 ~~ 1*f1
f2 ~~ 1*f2
f1 ~~ 0.5*f2
y1 ~~ 0.49*y1
y2 ~~ 0.49*y2
y3 ~~ 0.49*y3
y4 ~~ 0.49*y4
y5 ~~ 0.49*y5
y6 ~~ 0.49*y6
"

analysisModel &lt;- "
f1 =~ y1 + y2 + y3
f2 =~ y4 + y5 + y6
"

Output &lt;- sim(5, model=analysisModel, n=200, generate=popModel, std.lv=TRUE, lavaanfun = "cfa")
summary(Output)



## Example of using raw data as the population
pop &lt;- data.frame(y1 = rnorm(100000, 0, 1), y2 = rnorm(100000, 0, 1))
covModel &lt;- " y1 ~~ y2 "
Output &lt;- sim(5, model=covModel, n=200, rawData=pop, lavaanfun = "cfa")
summary(Output)



## Example of user-defined functions:

# data-transformation function: Transforming to standard score
fun1 &lt;- function(data) {
	temp &lt;- scale(data)
	as.data.frame(temp)
}

# additional-output function: Extract modification indices from lavaan
fun2 &lt;- function(out) {
	inspect(out, "mi")
}

# In reality, more than 5 replications are needed.
Output &lt;- sim(5, CFA.Model,n=200,datafun=fun1, outfun=fun2)
summary(Output)

# Get modification indices
getExtraOutput(Output)



## Example of additional output: Comparing latent variable correlation

outfundata &lt;- function(out, data) {
	predictcor &lt;- lavInspect(out, "est")$psi[2, 1]
	latentvar &lt;- attr(data, "latentVar")[,c("f1", "f2")]
	latentcor &lt;- cor(latentvar)[2,1]
	latentcor - predictcor
}
Output &lt;- sim(5, CFA.Model, n=200, sequential = TRUE, saveLatentVar = TRUE,
            	outfundata = outfundata)
getExtraOutput(Output)



## Example of analyze using a function

analyzeFUN &lt;- function(data) {
	out &lt;- lm(y2 ~ y1, data=data)
	coef &lt;- coef(out)
	se &lt;- sqrt(diag(vcov(out)))
	fit &lt;- c(loglik = as.numeric(logLik(out)))
	converged &lt;- TRUE # Assume to be convergent all the time
	return(list(coef = coef, se = se, fit = fit, converged = converged))
}
Output &lt;- sim(5, model=analyzeFUN, n=200, rawData=pop, lavaanfun = "cfa")
summary(Output)
</code></pre>

<hr>
<h2 id='SimDataDist-class'>Class <code>"SimDataDist"</code>: Data distribution object</h2><span id='topic+SimDataDist-class'></span><span id='topic+summary+2CSimDataDist-method'></span><span id='topic+plotDist+2CSimDataDist-method'></span>

<h3>Description</h3>

<p>This class will provide the distribution of a dataset.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by <code><a href="#topic+bindDist">bindDist</a></code> function. It can also be called from the form <code>new("SimDataDist", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>p</code>:</dt><dd><p>Number of variables</p>
</dd>
<dt><code>margins</code>:</dt><dd><p>A character vector specifying all the marginal distributions</p>
</dd>
<dt><code>paramMargins</code>:</dt><dd><p>A list whose each component is a list of named components, giving the parameter values of the marginal distributions.</p>
</dd>
<dt><code>keepScale</code>:</dt><dd><p>Transform back to retain the mean and standard deviation of a variable equal to the model implied mean and standard deviation (with sampling error)</p>
</dd>
<dt><code>reverse</code>:</dt><dd><p>To mirror each variable or not. If <code>TRUE</code>, reverse the distribution of a variable (e.g., from positive skewed to negative skewed).</p>
</dd>
<dt><code>copula</code>:</dt><dd><p>The multivariate copula template for data generation. See <code><a href="#topic+bindDist">bindDist</a></code></p>
</dd>
<dt><code>skewness</code>:</dt><dd><p>The target skewness values of each variable</p>
</dd>
<dt><code>kurtosis</code>:</dt><dd><p>The target (excessive) kurtosis values of each variable</p>
</dd>
</dl>



<h3>Methods</h3>


<ul>
<li><p>summaryTo summarize the object
</p>
</li>
<li><p>plotDistTo plot a density distribution (for one variable) or a contour plot (for two variables).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bindDist">bindDist</a></code> The constructor of this class.	
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("SimDataDist")

d1 &lt;- list(df=2)
d2 &lt;- list(df=3)
d3 &lt;- list(df=4)
d4 &lt;- list(df=5)
d5 &lt;- list(df=3)
d6 &lt;- list(df=4)
d7 &lt;- list(df=5)
d8 &lt;- list(df=6)

dist &lt;- bindDist(c(rep("t", 4), rep("chisq", 8)), d1, d2, d3, d4, d5, d6, d7, d8, d5, d6, d7, d8)
summary(dist)

dist2 &lt;- bindDist(skewness = seq(-3, 3, length.out=12), kurtosis = seq(2, 5, length.out=12))
summary(dist2)
</code></pre>

<hr>
<h2 id='SimMatrix-class'>Matrix object: Random parameters matrix</h2><span id='topic+SimMatrix-class'></span><span id='topic+summaryShort+2CSimMatrix-method'></span><span id='topic+summary+2CSimMatrix-method'></span>

<h3>Description</h3>

<p>This object can be used to represent a matrix in SEM model. It contains free parameters, fixed values, starting values, and model misspecification. This object can be represented mean, intercept, or variance vectors.
</p>


<h3>Objects from the Class</h3>

<p>This object is created by <code><a href="#topic+bind">bind</a></code> or <code><a href="#topic+binds">binds</a></code> function. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>free</code>:</dt><dd><p> The free-parameter vector. Any NA elements or character elements are free. Any numeric elements are fixed as the specified number. If any free elements have the same characters (except NA), the elements are equally constrained. </p>
</dd>
<dt><code>popParam</code>:</dt><dd><p> Real population parameters of the free elements. </p>
</dd>
<dt><code>misspec</code>:</dt><dd><p> Model misspecification that will be added on top of the fixed and real parameters. </p>
</dd>
<dt><code>symmetric</code>:</dt><dd><p> If TRUE, the specified matrix is symmetric. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code><a href="#topic+rawDraw">rawDraw</a></code></dt><dd><p>Draws data-generation parameters.</p>
</dd>
<dt><code><a href="#topic+summaryShort">summaryShort</a></code></dt><dd><p>Provides a short summary of all information in the object </p>
</dd>
<dt><code>summary</code></dt><dd><p>Provides a thorough description of all information in the object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimVector-class">SimVector</a></code> for random parameter vector.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("SimMatrix")

loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loadingValues &lt;- matrix(0, 6, 2)
loadingValues[1:3, 1] &lt;- 0.7
loadingValues[4:6, 2] &lt;- 0.7
LY &lt;- bind(loading, loadingValues)
summary(LY)
rawDraw(LY)

LY &lt;- bind(loading, "rnorm(1, 0.6, 0.05)")
summary(LY)
rawDraw(LY)

mis &lt;- matrix("runif(1, -0.1, 0.1)", 6, 2)
mis[is.na(loading)] &lt;- 0
LY &lt;- bind(loading, "rnorm(1, 0.6, 0.05)", mis)
summary(LY)
rawDraw(LY)
</code></pre>

<hr>
<h2 id='SimMissing-class'>Class <code>"SimMissing"</code></h2><span id='topic+SimMissing-class'></span><span id='topic+summary+2CSimMissing-method'></span>

<h3>Description</h3>

<p>Missing information imposing on the complete dataset
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by <code><a href="#topic+miss">miss</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cov</code>:</dt><dd><p>Column indices of any normally distributed covariates used in the data set.</p>
</dd>
<dt><code>pmMCAR</code>:</dt><dd><p>Decimal percent of missingness to introduce completely at random on all variables.</p>
</dd>
<dt><code>pmMAR</code>:</dt><dd><p>Decimal percent of missingness to introduce using the listed covariates as predictors.</p>
</dd>
<dt><code>logit</code>:</dt><dd><p>The script used for imposing missing values by logistic regression. See <code><a href="#topic+miss">miss</a></code> for further details.</p>
</dd>
<dt><code>nforms</code>:</dt><dd><p>The number of forms for planned missing data designs, not including the shared form.</p>
</dd>
<dt><code>itemGroups</code>:</dt><dd><p>List of lists of item groupings for planned missing data forms. Without this, items will be divided into groups sequentially (e.g. 1-3,4-6,7-9,10-12)</p>
</dd>
<dt><code>twoMethod</code>:</dt><dd><p>Vector of (percent missing, column index). Will put a given percent
missing on that column in the matrix to simulate a two method
planned missing data research design. </p>
</dd>
<dt><code>prAttr</code>:</dt><dd><p>Probability (or vector of probabilities) of an entire case being removed due to attrition at a given time point. See <code><a href="#topic+imposeMissing">imposeMissing</a></code> for further details.</p>
</dd>
<dt><code>m</code>:</dt><dd><p>The number of imputations. The default is 0 such that the full information maximum likelihood is used.</p>
</dd>
<dt><code>package</code>:</dt><dd><p>The package to be used in multiple imputation. The default value of this function is <code>"default"</code>. For the default option, if <code>m</code> is 0, the full information maximum likelihood is used. If <code>m</code> is greater than 0, the <code>mice</code> package is used.</p>
</dd>
<dt><code>convergentCutoff</code>:</dt><dd><p>If the proportion of convergent results across imputations are greater than the specified value (the default is 80%), the analysis on the dataset is considered as convergent. Otherwise, the analysis is considered as nonconvergent. This attribute is applied for multiple imputation only.</p>
</dd>
<dt><code>timePoints</code>:</dt><dd><p>Number of timepoints items were measured over. For longitudinal data, planned missing designs will be implemented within each timepoint.</p>
</dd>
<dt><code>ignoreCols</code>:</dt><dd><p>The columns not imposed any missing values for any missing data patterns</p>
</dd>
<dt><code>threshold</code>:</dt><dd><p>The threshold of covariates that divide between the area to impose missing and the area not to impose missing. The default threshold is the mean of the covariate.</p>
</dd>
<dt><code>covAsAux</code>:</dt><dd><p>If <code>TRUE</code>, the covariate listed in the object will be used as auxiliary variables when putting in the model object. If <code>FALSE</code>, the covariate will be included in the analysis.</p>
</dd>
<dt><code>logical</code>:</dt><dd><p>A matrix of logical values (<code>TRUE/FALSE</code>). If a value in the dataset is corresponding to the <code>TRUE</code> in the logical matrix, the value will be missing.</p>
</dd>
<dt><code>args</code>:</dt><dd><p>A list of additional options to be passed to the multiple impuatation function in each package.</p>
</dd>
</dl>



<h3>Methods</h3>


<ul>
<li> <p><code><a href="base.html#topic+summary">summary</a></code> To summarize the object
</p>
</li>
<li> <p><code><a href="#topic+impose">impose</a></code> To impose missing information into data
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>)
Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>)
Kyle Lang (University of Kansas; <a href="mailto:kylelang@ku.edu">kylelang@ku.edu</a>)
Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+imposeMissing">imposeMissing</a></code> for directly imposing missingness into a dataset.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>misstemplate &lt;- miss(pmMCAR=0.2)
summary(misstemplate)
</code></pre>

<hr>
<h2 id='SimResult-class'>Class <code>"SimResult"</code>: Simulation Result Object</h2><span id='topic+SimResult-class'></span><span id='topic+summary+2CSimResult-method'></span><span id='topic+summaryShort+2CSimResult-method'></span>

<h3>Description</h3>

<p>This class will save data analysis results from multiple replications, such as fit indices cutoffs or power, parameter values, model misspecification, etc.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by <code><a href="#topic+sim">sim</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelType</code>:</dt><dd><p>Analysis model type (CFA, Path, or SEM) </p>
</dd>
<dt><code>nRep</code>:</dt><dd><p>Number of replications have been created and run simulated data. </p>
</dd>
<dt><code>coef</code>:</dt><dd><p>Parameter estimates from each replication</p>
</dd>
<dt><code>se</code>:</dt><dd><p>Standard errors of parameter estimates from each replication</p>
</dd>
<dt><code>fit</code>:</dt><dd><p>Fit Indices values from each replication</p>
</dd>
<dt><code>converged</code>:</dt><dd><p>The convergence status of each replication: 0 = convergent, 1 = not convergent, 2 = nonconvergent in multiple imputed results, 3 = improper solutions for SE (less than 0 or NA), 4 = converged with improper solution for latent or observed (residual) covariance matrix (i.e., nonpositive definite, possible due to a Heywood case). For multiple imputations, these codes are applied when the proporion of imputed data sets with that characteristic is below the <code>convergentCutoff</code> threshold (see <code>linkS4class{SimMissing}</code>). For <code>OpenMx</code> analyses only, a code &quot;7&quot; indicates Optimal estimates could not be obtained (&quot;Status 6&quot; in <code>OpenMx</code>).</p>
</dd>
<dt><code>seed</code>:</dt><dd><p><code>integer</code> used to set the seed for the L'Ecuyer-CMRG pseudorandom number generator. </p>
</dd>
<dt><code>paramValue</code>:</dt><dd><p>Population model underlying each simulated dataset.</p>
</dd>
<dt><code>stdParamValue</code>:</dt><dd><p>Standardized parameters of the population model underlying each simulated dataset.</p>
</dd>
<dt><code>paramOnly</code>:</dt><dd><p>If <code>TRUE</code>, the result object saves only population characteristics and do not save sample characteristics (e.g., parameter estimates and standard errors.</p>
</dd>
<dt><code>misspecValue</code>:</dt><dd><p>Misspecified-parameter values that are imposed on the population model in each replication.</p>
</dd>
<dt><code>popFit</code>:</dt><dd><p>The amount of population misfit. See details at <code><a href="#topic+summaryMisspec">summaryMisspec</a></code></p>
</dd>
<dt><code>FMI1</code>:</dt><dd><p>Fraction Missing Method 1.</p>
</dd>
<dt><code>FMI2</code>:</dt><dd><p>Fraction Missing Method 2.</p>
</dd>
<dt><code>cilower</code>:</dt><dd><p>Lower bounds of confidence interval.</p>
</dd>
<dt><code>ciupper</code>:</dt><dd><p>Upper bounds of confidence interval.</p>
</dd>
<dt><code>stdCoef</code>:</dt><dd><p>Standardized coefficients from each replication</p>
</dd>
<dt><code>stdSe</code>:</dt><dd><p>Standard Errors of Standardized coefficients from each replication</p>
</dd>
<dt><code>n</code>:</dt><dd><p>The total sample size of the analyzed data.</p>
</dd>
<dt><code>nobs</code>:</dt><dd><p>The sample size within each group.</p>
</dd>
<dt><code>pmMCAR</code>:</dt><dd><p>Percent missing completely at random.</p>
</dd>
<dt><code>pmMAR</code>:</dt><dd><p>Percent missing at random.</p>
</dd>
<dt><code>extraOut</code>:</dt><dd><p>Extra outputs obtained from running the function specified in <code>outfun</code> argument in the <code><a href="#topic+sim">sim</a></code> function.</p>
</dd>
<dt><code>timing</code>:</dt><dd><p>Time elapsed in each phase of the simulation.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>The following methods are listed alphabetically. More details can be found by following the link of each method.
</p>

<ul>
<li> <p><code><a href="#topic+anova+2CSimResult-method">anova</a></code> to find the averages of model fit statistics and indices for nested models, as well as the differences of model fit indices among models. This function requires at least two <code>SimResult</code> objects.
</p>
</li>
<li> <p><code><a href="#topic+coef+2CSimResult-method">coef</a></code> to extract parameter estimates of each replication
</p>
</li>
<li> <p><code><a href="#topic+findCoverage">findCoverage</a></code> to find a value of independent variables (e.g., sample size) that provides a given value of coverage rate.
</p>
</li>
<li> <p><code><a href="#topic+findPower">findPower</a></code> to find a value of independent variables (e.g., sample size) that provides a given value of power of a parameter estimate.
</p>
</li>
<li> <p><code><a href="#topic+getCoverage">getCoverage</a></code> to get the coverage rate of the confidence interval of each parameter estimate
</p>
</li>
<li> <p><code><a href="#topic+getCIwidth">getCIwidth</a></code> to get a median or percentile rank (assurance) of confidence interval widths of parameters estimates
</p>
</li>
<li> <p><code><a href="#topic+getCutoff">getCutoff</a></code> to get the cutoff of fit indices based on a priori alpha level.
</p>
</li>
<li> <p><code><a href="#topic+getCutoffNested">getCutoffNested</a></code> to get the cutoff of the difference in fit indices of nested models based on a priori alpha level.
</p>
</li>
<li> <p><code><a href="#topic+getCutoffNonNested">getCutoffNonNested</a></code> to get the cutoff of the difference in fit indices of nonnested models based on a priori alpha level.
</p>
</li>
<li> <p><code><a href="#topic+getExtraOutput">getExtraOutput</a></code> to get extra outputs that users requested before running a simulation
</p>
</li>
<li> <p><code><a href="#topic+getPopulation">getPopulation</a></code> to get population parameter values underlying each dataset
</p>
</li>
<li> <p><code><a href="#topic+getPower">getPower</a></code> to get the power of each parameter estimate
</p>
</li>
<li> <p><code><a href="#topic+getPowerFit">getPowerFit</a></code> to get the power in rejecting alternative models based on absolute model fit cutoff.
</p>
</li>
<li> <p><code><a href="#topic+getPowerFitNested">getPowerFitNested</a></code> to get the power in rejecting alternative models based on the difference between model fit cutoffs of nested models.
</p>
</li>
<li> <p><code><a href="#topic+getPowerFitNonNested">getPowerFitNonNested</a></code> to get the power in rejecting alternative models based on the difference between model fit cutoffs of nonnested models.
</p>
</li>
<li> <p><code><a href="#topic+inspect+2CSimResult-method">inspect</a></code> Extract target information from the simulation result. The available information is listed in this <code><a href="#topic+inspect+2CSimResult-method">link</a></code>
</p>
</li>
<li> <p><code><a href="#topic+likRatioFit">likRatioFit</a></code> to find the likelihood ratio (or Bayes factor) based on the bivariate distribution of fit indices
</p>
</li>
<li> <p><code><a href="#topic+plotCoverage">plotCoverage</a></code> to plot the coverage rate of confidence interval of parameter estimates
</p>
</li>
<li> <p><code><a href="#topic+plotCIwidth">plotCIwidth</a></code> to plot confidence interval widths with a line of a median or percentile rank (assurance)
</p>
</li>
<li> <p><code><a href="#topic+plotCutoff">plotCutoff</a></code> to plot sampling distributions of fit indices with an option to draw fit indices cutoffs by specifying a priori alpha level.
</p>
</li>
<li> <p><code><a href="#topic+plotCutoffNested">plotCutoffNested</a></code> to plot sampling distributions of the difference in fit indices between nested models with an option to draw fit indices cutoffs by specifying a priori alpha level.
</p>
</li>
<li> <p><code><a href="#topic+plotCutoffNonNested">plotCutoffNonNested</a></code> to plot sampling distributions of the difference in fit indices between nonnested models with an option to draw fit indices cutoffs by specifying a priori alpha level.
</p>
</li>
<li> <p><code><a href="#topic+plotMisfit">plotMisfit</a></code> to visualize the population misfit and misspecified parameter values
</p>
</li>
<li> <p><code><a href="#topic+plotPower">plotPower</a></code> to plot power of parameter estimates
</p>
</li>
<li> <p><code><a href="#topic+plotPowerFit">plotPowerFit</a></code> to plot the power in rejecting alternative models based on absolute model fit cutoff.
</p>
</li>
<li> <p><code><a href="#topic+plotPowerFitNested">plotPowerFitNested</a></code> to plot the power in rejecting alternative models based on the difference between model fit cutoffs of nested models.
</p>
</li>
<li> <p><code><a href="#topic+plotPowerFitNonNested">plotPowerFitNonNested</a></code> to plot the power in rejecting alternative models based on the difference between model fit cutoffs of nonnested models.
</p>
</li>
<li> <p><code><a href="#topic+pValue">pValue</a></code> to find a p-value in comparing sample fit indices with the null sampling distribution of fit indices
</p>
</li>
<li> <p><code><a href="#topic+pValueNested">pValueNested</a></code> to find a p-value in comparing the difference in sample fit indices between nested models with the null sampling distribution of the difference in fit indices
</p>
</li>
<li> <p><code><a href="#topic+pValueNonNested">pValueNonNested</a></code> to find a p-value in comparing the difference in sample fit indices between nonnested models with the null sampling distribution of the difference in fit indices
</p>
</li>
<li> <p><code><a href="#topic+setPopulation">setPopulation</a></code> to set population model for computing bias
</p>
</li>
<li> <p><code><a href="base.html#topic+summary">summary</a></code> to summarize the result output
</p>
</li>
<li> <p><code><a href="#topic+summaryConverge">summaryConverge</a></code> to provide a head-to-head comparison between the characteristics of convergent and nonconvergent replications
</p>
</li>
<li> <p><code><a href="#topic+summaryMisspec">summaryMisspec</a></code> to provide a summary of model misfit
</p>
</li>
<li> <p><code><a href="#topic+summaryParam">summaryParam</a></code> to summarize all parameter estimates
</p>
</li>
<li> <p><code><a href="#topic+summaryPopulation">summaryPopulation</a></code> to summarize the data generation population underlying the simulation study.
</p>
</li>
<li> <p><code><a href="#topic+summarySeed">summarySeed</a></code> to provide a summary of the seed number in the simulation
</p>
</li>
<li> <p><code><a href="#topic+summaryShort">summaryShort</a></code> to provide a short summary of the result output
</p>
</li>
<li> <p><code><a href="#topic+summaryTime">summaryTime</a></code> to provide a summary of time elapsed in the simulation
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+sim">sim</a></code> for the constructor of this class
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("SimResult")
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.7)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output &lt;- sim(5, n=500, CFA.Model)

# Summary the simulation result
summary(Output)

# Short summary of the simulation result
summaryShort(Output)

# Find the fit index cutoff
getCutoff(Output, 0.05)

# Summary of parameter estimates
summaryParam(Output)

# Summary of population parameters
summaryPopulation(Output)
</code></pre>

<hr>
<h2 id='SimSem-class'>Class <code>"SimSem"</code></h2><span id='topic+SimSem-class'></span><span id='topic+summary+2CSimSem-method'></span>

<h3>Description</h3>

<p>The template containing data-generation and data-analysis specification
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by <code><a href="#topic+model">model</a></code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>pt</code>:</dt><dd><p> Parameter table used in data analysis </p>
</dd>
<dt><code>dgen</code>:</dt><dd><p> Data generation template </p>
</dd>
<dt><code>modelType</code>:</dt><dd><p> Type of models (CFA, Path, or SEM) contained in this object </p>
</dd>
<dt><code>groupLab</code>:</dt><dd><p> The label of grouping variable </p>
</dd>
<dt><code>con</code>:</dt><dd><p> The list of defined parameters, equality constraints, or inequality constraints specified in the model </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>summary</dt><dd><p>Get the summary of model specification </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>), 
Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li><p> Create an object this class by CFA, Path Analysis, or SEM model by <code><a href="#topic+model">model</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("SimSem")

loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loadingValues &lt;- matrix(0, 6, 2)
loadingValues[1:3, 1] &lt;- 0.7
loadingValues[4:6, 2] &lt;- 0.7
LY &lt;- bind(loading, loadingValues)
summary(LY)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

# Error Correlation Object
error.cor &lt;- matrix(0, 6, 6)
diag(error.cor) &lt;- 1
RTE &lt;- binds(error.cor)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")
summary(CFA.Model)
</code></pre>

<hr>
<h2 id='SimVector-class'>Vector object: Random parameters vector</h2><span id='topic+SimVector-class'></span><span id='topic+summaryShort+2CSimVector-method'></span><span id='topic+summary+2CSimVector-method'></span>

<h3>Description</h3>

<p>This object can be used to represent a vector in SEM model. It contains free parameters, fixed values, starting values, and model misspecification. This object can be represented mean, intercept, or variance vectors.
</p>


<h3>Objects from the Class</h3>

<p>This object is created by <code><a href="#topic+bind">bind</a></code> function. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>free</code>:</dt><dd><p>The free-parameter vector. Any NA elements or character elements are free. Any numeric elements are fixed as the specified number. If any free elements have the same characters (except NA), the elements are equally constrained.</p>
</dd>
<dt><code>popParam</code>:</dt><dd><p>Real population parameters of the free elements.</p>
</dd>
<dt><code>misspec</code>:</dt><dd><p>Model misspecification that will be added on top of the fixed and real parameters.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code><a href="#topic+rawDraw">rawDraw</a></code></dt><dd><p>Draws data-generation parameters.</p>
</dd>
<dt><code><a href="#topic+summaryShort">summaryShort</a></code></dt><dd><p>Provides a short summary of all information in the object </p>
</dd>
<dt><code><a href="base.html#topic+summary">summary</a></code></dt><dd><p>Provides a thorough description of all information in the object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Patrick Miller (University of Notre Dame; <a href="mailto:pmille13@nd.edu">pmille13@nd.edu</a>)
Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimMatrix-class">SimMatrix</a></code> for random parameter matrix 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SimVector")

factor.mean &lt;- rep(NA, 2)
factor.mean.starting &lt;- c(5, 2)
AL &lt;- bind(factor.mean, factor.mean.starting)
rawDraw(AL)
summary(AL)
summaryShort(AL)
</code></pre>

<hr>
<h2 id='summaryConverge'>
Provide a comparison between the characteristics of convergent replications and nonconvergent replications
</h2><span id='topic+summaryConverge'></span>

<h3>Description</h3>

<p>This function provides a comparison between the characteristics of convergent replications and nonconvergent replications. The comparison includes sample size (if varying), percent missing completely at random (if varying), percent missing at random (if varying), parameter values, misspecified-parameter values (if applicable), and population misfit (if applicable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryConverge(object, std = FALSE, improper = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryConverge_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> object being described
</p>
</td></tr>
<tr><td><code id="summaryConverge_+3A_std">std</code></td>
<td>

<p>If <code>TRUE</code>, the standardized parameter values are used instead of unstandardized parameter values.
</p>
</td></tr>
<tr><td><code id="summaryConverge_+3A_improper">improper</code></td>
<td>

<p>If TRUE, include the replications that provided improper solutions
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>Converged</code> The number of convergent and nonconvergent replications
</p>
</li>
<li> <p><code>n</code> Sample size
</p>
</li>
<li> <p><code>pmMCAR</code> Percent missing completely at random
</p>
</li>
<li> <p><code>pmMAR</code> Percent missing at random
</p>
</li>
<li> <p><code>paramValue</code> Parameter values
</p>
</li>
<li> <p><code>misspecValue</code> Misspecified-parameter values
</p>
</li>
<li> <p><code>popFit</code> Population misfit. See details of each element at <code><a href="#topic+summaryMisspec">summaryMisspec</a></code>.
</p>
</li></ul>

<p>Each element will provide the head-to-head comparison between convergent and nonconvergent replications properties.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path.BE &lt;- matrix(0, 4, 4)
path.BE[3, 1:2] &lt;- NA
path.BE[4, 3] &lt;- NA
starting.BE &lt;- matrix("", 4, 4)
starting.BE[3, 1:2] &lt;- "runif(1, 0.3, 0.5)"
starting.BE[4, 3] &lt;- "runif(1, 0.5, 0.7)"
mis.path.BE &lt;- matrix(0, 4, 4)
mis.path.BE[4, 1:2] &lt;- "runif(1, -0.1, 0.1)"
BE &lt;- bind(path.BE, starting.BE, misspec=mis.path.BE)

residual.error &lt;- diag(4)
residual.error[1,2] &lt;- residual.error[2,1] &lt;- NA
RPS &lt;- binds(residual.error, "rnorm(1, 0.3, 0.1)")

loading &lt;- matrix(0, 12, 4)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loading[7:9, 3] &lt;- NA
loading[10:12, 4] &lt;- NA
mis.loading &lt;- matrix("runif(1, -0.3, 0.3)", 12, 4)
mis.loading[is.na(loading)] &lt;- 0
LY &lt;- bind(loading, "runif(1, 0.7, 0.9)", misspec=mis.loading)

mis.error.cor &lt;- matrix("rnorm(1, 0, 0.1)", 12, 12)
diag(mis.error.cor) &lt;- 0
RTE &lt;- binds(diag(12), misspec=mis.error.cor)

SEM.Model &lt;- model(RPS = RPS, BE = BE, LY=LY, RTE=RTE, modelType="SEM")

n1 &lt;- list(mean = 0, sd = 0.1)
chi5 &lt;- list(df = 5)

facDist &lt;- bindDist(c("chisq", "chisq", "norm", "norm"), chi5, chi5, n1, n1)

# In reality, more than 50 replications are needed.
simOut &lt;- sim(50, n=500, SEM.Model, sequential=TRUE, facDist=facDist, estimator="mlr")

# Summary the convergent and nonconvergent replications
summaryConverge(simOut)

## End(Not run)
</code></pre>

<hr>
<h2 id='summaryFit'>
Provide summary of model fit across replications
</h2><span id='topic+summaryFit'></span>

<h3>Description</h3>

<p>This function will provide fit index cutoffs for values of alpha, and mean fit index values across all replications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryFit(object, alpha = NULL, improper = TRUE, usedFit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryFit_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> to be summarized
</p>
</td></tr>
<tr><td><code id="summaryFit_+3A_alpha">alpha</code></td>
<td>

<p>The alpha level used to find the fit indices cutoff. If there is no varying condition, a vector of different alpha levels can be provided.
</p>
</td></tr>
<tr><td><code id="summaryFit_+3A_improper">improper</code></td>
<td>

<p>If TRUE, include the replications that provided improper solutions
</p>
</td></tr>
<tr><td><code id="summaryFit_+3A_usedfit">usedFit</code></td>
<td>

<p>Vector of names of fit indices that researchers wish to summarize. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that provides fit statistics cutoffs and means
</p>
<p>When <code>linkS4class{SimResult}</code> has fixed simulation parameters the first colmns are fit index cutoffs for values of alpha and the last column is the mean fit across all replications. Rows are
</p>

<ul>
<li> <p>Chi Chi-square fit statistic
</p>
</li>
<li> <p>AIC Akaike Information Criterion
</p>
</li>
<li> <p>BIC Baysian Information Criterion
</p>
</li>
<li> <p>RMSEA Root Mean Square Error of Approximation
</p>
</li>
<li> <p>CFI Comparative Fit Index
</p>
</li>
<li> <p>TLI Tucker-Lewis Index
</p>
</li>
<li> <p>SRMR Standardized Root Mean Residual
</p>
</li></ul>

<p>When <code>linkS4class{SimResult}</code> has random simulation parameters (sample size or percent missing), columns are the fit indices listed above and rows are values of the random parameter.
</p>


<h3>Author(s)</h3>

<p>Alexander M. Schoemann (East Carolina University; <a href="mailto:schoemanna@ecu.edu">schoemanna@ecu.edu</a>)
Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> for the result object input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.7)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output &lt;- sim(5, n=500, CFA.Model)

# Summarize the sample fit indices
summaryFit(Output)
</code></pre>

<hr>
<h2 id='summaryMisspec'>
Provide summary of the population misfit and misspecified-parameter values across replications
</h2><span id='topic+summaryMisspec'></span>

<h3>Description</h3>

<p>This function provides the summary of the population misfit and misspecified-parameter values across replications. The summary will be summarized for the convergent replications only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryMisspec(object, improper = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryMisspec_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> object being described
</p>
</td></tr>
<tr><td><code id="summaryMisspec_+3A_improper">improper</code></td>
<td>

<p>If TRUE, include the replications that provided improper solutions
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that provides the summary of population misfit and misspecified-parameter values imposed on the real parameters.
</p>
<p>The discrepancy value (<code class="reqn">f_0</code>; Browne &amp; Cudeck, 1992) is calculated by
</p>
<p style="text-align: center;"><code class="reqn"> F_0 = tr\left( \tilde{\Sigma} \Sigma^{-1} \right) - \log{\left| \tilde{\Sigma} \Sigma^{-1} \right|} - p + \left( \tilde{\mu} - \mu \right)^{\prime} \Sigma^{-1} \left( \tilde{\mu} - \mu \right).	</code>
</p>

<p>where <code class="reqn">\mu</code> is the model-implied mean from the real parameters, <code class="reqn">\Sigma</code> is the model-implied covariance matrix from the real parameters, <code class="reqn">\tilde{\mu}</code> is the model-implied mean from the real and misspecified parameters, <code class="reqn">\tilde{\Sigma}</code> is the model-implied covariance matrix from the real and misspecified parameter, <em>p</em> is the number of indicators. For the multiple groups, the resulting <code class="reqn">f_0</code> value is the sum of this value across groups.
</p>
<p>The root mean squared error of approximation (rmsea) is calculated by
</p>
<p style="text-align: center;"><code class="reqn">rmsea = \sqrt{\frac{f_0}{df}}</code>
</p>

<p>where <code class="reqn">df</code> is the degree of freedom in the real model.
</p>
<p>The standardized root mean squared residual (srmr) can be calculated by
</p>
<p style="text-align: center;"><code class="reqn">srmr = \sqrt{\frac{2\sum_{g} \sum_{i} \sum_{j \le i} \left( \frac{s_{gij}}{\sqrt{s_{gii}}\sqrt{s_{gjj}}} - \frac{\hat{\sigma}_{gij}}{\sqrt{\hat{\sigma}_{gii}}\sqrt{\hat{\sigma}_{gjj}}} \right)}{g \times p(p + 1)}}</code>
</p>

<p>where <code class="reqn">s_{gij}</code> is the observed covariance between indicators <em>i</em> and <em>j</em> in group <em>g</em>, <code class="reqn">\hat{\sigma}_{ij}</code> is the model-implied covariance between indicators <em>i</em> and <em>j</em> in group <em>g</em>, <em>p</em> is the number of indicators.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>References</h3>

<p>Browne, M. W., &amp; Cudeck, R. (1992). Alternative ways of assessing model fit. <em>Sociological Methods &amp; Research, 21</em>, 230-258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> for the object input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path &lt;- matrix(0, 4, 4)
path[3, 1:2] &lt;- NA
path[4, 3] &lt;- NA
pathVal &lt;- matrix("", 4, 4)
pathVal[3, 1:2] &lt;- "runif(1, 0.3, 0.5)"
pathVal[4, 3] &lt;- "runif(1, 0.5, 0.7)"
pathMis &lt;- matrix(0, 4, 4)
pathMis[4, 1:2] &lt;- "runif(1, -0.1, 0.1)"
BE &lt;- bind(path, pathVal, pathMis)

residual.error &lt;- diag(4)
residual.error[1,2] &lt;- residual.error[2,1] &lt;- NA
RPS &lt;- binds(residual.error, "rnorm(1, 0.3, 0.1)")

Path.Model &lt;- model(RPS = RPS, BE = BE, modelType="Path")

# The number of replications in actual analysis should be much more than 5
ParamObject &lt;- sim(5, n=200, Path.Model)

# Summarize the model misspecification that is specified in the 'pathMis' object
summaryMisspec(ParamObject)

## End(Not run)
</code></pre>

<hr>
<h2 id='summaryParam'>
Provide summary of parameter estimates and standard error across replications
</h2><span id='topic+summaryParam'></span>

<h3>Description</h3>

<p>This function will provide averages of parameter estimates, standard deviations of parameter estimates, averages of standard errors, and power of rejection with a priori alpha level for the null hypothesis of parameters equal 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryParam(object, alpha = 0.05, std = FALSE, detail = FALSE, 
    improper = TRUE, digits = NULL, matchParam = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryParam_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> object being described
</p>
</td></tr>
<tr><td><code id="summaryParam_+3A_alpha">alpha</code></td>
<td>

<p>The alpha level used to find the statistical power of each parameter estimate
</p>
</td></tr>
<tr><td><code id="summaryParam_+3A_std">std</code></td>
<td>

<p>If <code>TRUE</code>, (a) standardized coefficients and their standard errors substitute unstandardized coefficients, (b) standardized parameter values substitute parameter values, (c) confidence intervals of standardized coefficients are calculated using Wald confidence interval, and (d) all results (e.g., biases or coverage) are calculated based on standardized coefficients.
</p>
</td></tr>
<tr><td><code id="summaryParam_+3A_detail">detail</code></td>
<td>

<p>If TRUE, more details about each parameter estimate are provided, such as relative bias, standardized bias, or relative standard error bias.
</p>
</td></tr>
<tr><td><code id="summaryParam_+3A_improper">improper</code></td>
<td>

<p>If TRUE, include the replications that provided improper solutions
</p>
</td></tr>
<tr><td><code id="summaryParam_+3A_digits">digits</code></td>
<td>

<p>The number of digits rounded in the result. If <code>NULL</code>, the results will not be rounded.
</p>
</td></tr>
<tr><td><code id="summaryParam_+3A_matchparam">matchParam</code></td>
<td>

<p>If <code>TRUE</code>, only parameter estimates that have the same names as the parameter values will be reported. This argument is recommended when users know that the data-generation model and analysis model are the same. Then the comparison between the parameter estimates and parameter value will be valid.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that provides the statistics described above from all parameters.
For using with <code>linkS4class{SimResult}</code>, each column means
</p>

<ul>
<li> <p><code>Estimate.Average:</code> Average of parameter estimates across all replications
</p>
</li>
<li> <p><code>Estimate.SD:</code> Standard Deviation of parameter estimates across all replications
</p>
</li>
<li> <p><code>Average.SE:</code> Average of standard errors across all replications
</p>
</li>
<li> <p><code>Power (Not equal 0):</code> Proportion of significant replications when testing whether the parameters are different from zero. The alpha level can be set by the <code>alpha</code> argument of this function.
</p>
</li>
<li> <p><code>Average.Param:</code> Parameter values or average values of parameters if random parameters are specified
</p>
</li>
<li> <p><code>SD.Param:</code> Standard Deviations of parameters. Show only when random parameters are specified.
</p>
</li>
<li> <p><code>Average.Bias:</code> The difference between parameter estimates and parameter underlying data
</p>
</li>
<li> <p><code>SD.Bias:</code> Standard Deviations of bias across all replications. Show only when random parameters are specified. 
This value is the expected value of average standard error when random parameter are specified.
</p>
</li>
<li> <p><code>Coverage:</code> The percentage of (1-alpha)% confidence interval covers parameters underlying the data.
</p>
</li>
<li> <p><code>Rel.Bias:</code> Relative Bias, which is (<code>Estimate.Average</code> - <code>Average.Param</code>)/<code>Average.Param</code>. 
Hoogland and Boomsma (1998) proposed that the cutoff of .05 may be used for acceptable relative bias.
This option will be available when <code>detail=TRUE</code>. This value will not be available when parameter values are very close to 0.
</p>
</li>
<li> <p><code>Std.Bias:</code> Standardized Bias, which is (<code>Estimate.Average</code> - <code>Average.Param</code>)/<code>Estimate.SD</code> 
for fixed parameters and (<code>Estimate.Average</code> - <code>Average.Param</code>)/<code>SD.Bias</code> 
for random parameters. Collins, Schafer, and Kam (2001) recommended that biases will be 
only noticeable when standardized bias is greater than 0.4 in magnitude.
This option will be available when <code>detail=TRUE</code>
</p>
</li>
<li> <p><code>Rel.SE.Bias:</code> Relative Bias in standard error, which is (<code>Average.SE</code> - <code>Estimate.SD</code>)/<code>Estimate.SD</code> 
for fixed parameters and (<code>Average.SE</code> - <code>SD.Bias</code>)/<code>SD.Bias</code> 
for random parameters. 	Hoogland and Boomsma (1998) proposed that 0.10 is the acceptable level.
This option will be available when <code>detail=TRUE</code>
</p>
</li>
<li> <p><code>Not Cover Below:</code> The percentage of (1-alpha)% confidence interval does not cover the parameter and the parameter is below the confidence interval.
</p>
</li>
<li> <p><code>Not Cover Above:</code> The percentage of (1-alpha)% confidence interval does not cover the parameter and the parameter is above the confidence interval.
</p>
</li>
<li> <p><code>Average CI Width:</code> The average of (1-alpha)% confidence interval width across replications.
</p>
</li>
<li> <p><code>SD CI Width:</code> The standard deviation of (1-alpha)% confidence interval width across replications.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>References</h3>

<p>Collins, L. M., Schafer, J. L., &amp; Kam, C. M. (2001). A comparison of inclusive and restrictive strategies in modern missing data procedures. <em>Psychological Methods, 6</em>, 330-351.
</p>
<p>Hoogland, J. J., &amp; Boomsma, A. (1998). Robustness studies in covariance structure modeling. <em>Sociological Methods &amp; Research, 26</em>, 329-367.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> for the object input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SimResult")
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, 0.7)
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output &lt;- sim(5, n=500, CFA.Model)

# Summary of the parameter estimates
summaryParam(Output)

# Summary of the parameter estimates with additional details
summaryParam(Output, detail=TRUE)
</code></pre>

<hr>
<h2 id='summaryPopulation'>
Summarize the population model used for data generation underlying a result object
</h2><span id='topic+summaryPopulation'></span>

<h3>Description</h3>

<p>Summarize the population model used for data generation underlying a result object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryPopulation(object, std = FALSE, improper = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryPopulation_+3A_object">object</code></td>
<td>

<p>The result object that you wish to extract the data generation population model from (<code>linkS4class{SimResult}</code>).
</p>
</td></tr>
<tr><td><code id="summaryPopulation_+3A_std">std</code></td>
<td>

<p>If <code>TRUE</code>, the standardized parameter values are used instead of unstandardized parameter values.
</p>
</td></tr>
<tr><td><code id="summaryPopulation_+3A_improper">improper</code></td>
<td>

<p>If TRUE, include the replications that provided improper solutions
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> contianing the summary of population model across replications.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+SimResult-class">SimResult</a></code> for result object
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 1)
loading[1:6, 1] &lt;- NA
LY &lt;- bind(loading, "runif(1, 0.4, 0.9)")
RPS &lt;- binds(diag(1))
RTE &lt;- binds(diag(6))
CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We will use only 10 replications to save time.
# In reality, more replications are needed.
Output &lt;- sim(10, n=200, model=CFA.Model)

# Get the summary of population model
summaryPopulation(Output)

## End(Not run)
</code></pre>

<hr>
<h2 id='summarySeed'>
Summary of a seed number
</h2><span id='topic+summarySeed'></span>

<h3>Description</h3>

<p>Summary of a seed number used in the simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarySeed(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarySeed_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> object being described
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first section is the seed number used in running the whole simulation. The second section is the L'Ecuyer seed of the last replication.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# In reality, more than 5 replications are needed.
Output &lt;- sim(5, CFA.Model, n=200)
summarySeed(Output)

## End(Not run)
</code></pre>

<hr>
<h2 id='summaryShort'>
Provide short summary of an object.
</h2><span id='topic+summaryShort'></span><span id='topic+summaryShort-methods'></span><span id='topic+summaryShort+2CANY-method'></span><span id='topic+summaryShort+2Cvector-method'></span><span id='topic+summaryShort+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Provide short summary if it is available. Otherwise, it is an alias for <code>summary</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryShort(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryShort_+3A_object">object</code></td>
<td>

<p>Desired object being described
</p>
</td></tr>
<tr><td><code id="summaryShort_+3A_...">...</code></td>
<td>

<p>any additional arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NONE. This function will print on screen only.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>See Also</h3>

<p>This is the list of classes that can use <code>summaryShort</code> method.
</p>

<ul>
<li> <p><code><a href="#topic+SimMatrix-class">SimMatrix</a></code>
</p>
</li>
<li> <p><code><a href="#topic+SimVector-class">SimVector</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
loadingValues &lt;- matrix(0, 6, 2)
LY &lt;- bind(loading, "runif(1, 0.8, 0.9)")
summaryShort(LY)
</code></pre>

<hr>
<h2 id='summaryTime'>
Time summary
</h2><span id='topic+summaryTime'></span>

<h3>Description</h3>

<p>Provide a summary of time elapsed in running the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryTime(object, units = "seconds")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryTime_+3A_object">object</code></td>
<td>

<p><code><a href="#topic+SimResult-class">SimResult</a></code> object being described
</p>
</td></tr>
<tr><td><code id="summaryTime_+3A_units">units</code></td>
<td>

<p>The units of time, which can be &quot;seconds&quot;, &quot;minutes&quot;, &quot;hours&quot;, or &quot;days&quot;
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first section is the actual time used in each step of the simulation. The second section is the average system (processor) time used in each replication. The third section is the summary of starting time, end time, total actual time, and total system time.
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loading &lt;- matrix(0, 6, 2)
loading[1:3, 1] &lt;- NA
loading[4:6, 2] &lt;- NA
LY &lt;- bind(loading, 0.7)

latent.cor &lt;- matrix(NA, 2, 2)
diag(latent.cor) &lt;- 1
RPS &lt;- binds(latent.cor, 0.5)

RTE &lt;- binds(diag(6))

VY &lt;- bind(rep(NA,6),2)

CFA.Model &lt;- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# In reality, more than 5 replications are needed.
Output &lt;- sim(5, CFA.Model, n=200)
summaryTime(Output)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
