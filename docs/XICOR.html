<!DOCTYPE html><html><head><title>Help for package XICOR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {XICOR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#backdec'><p>Inverse function to wholebinary returns the number from its expansion</p></a></li>
<li><a href='#borelmerge'><p>Auxiliary function that takes avector and produces a single number through</p>
a Borel isomorphism using the wholebinary and backdec functions.</a></li>
<li><a href='#calculateXI'><p>Compute the cross rank coefficient xi on two vectors.</p></a></li>
<li><a href='#fracbinary'><p>Take fractionary part and make its binary expansion</p>
Auxiliary function used in expanding real numbers</a></li>
<li><a href='#FRpredcor'><p>Compute the FR coefficient  on two vectors based exactly on Gamma2.</p></a></li>
<li><a href='#FRpredcorhalf'><p>Compute the FR half coefficient  on two vectors based on half Gamma 2.</p></a></li>
<li><a href='#genxicor'><p>Compute the generalized cross rank increment correlation coefficient gxi.</p></a></li>
<li><a href='#numbinary'><p>Computes the binary expansion of a number</p></a></li>
<li><a href='#weave'><p>Take a matrix of two numbers given in their binary expansion</p>
one in each of the two rows
and return the interleaving of the two numbers</a></li>
<li><a href='#wholebinary'><p>Encodes a number as a two row binary matrix and its sign</p></a></li>
<li><a href='#xicor'><p>Compute the cross rank increment correlation coefficient xi.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Association Measurement Through Cross Rank Increments</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Susan Holmes [aut,cre], Sourav Chatterjee [aut] </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Susan Holmes &lt;sp.holmes@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes robust association measures that do not 
    presuppose linearity. The xi correlation (xicor) is based
    on cross correlation between ranked increments.
    The reference for the methods implemented here is 
    Chatterjee, Sourav (2020) &lt;<a href="https://arxiv.org/abs/1909.10140">arXiv:1909.10140</a>&gt;
    This package includes the Galton peas example.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-07</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>psychTools, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), ggplot2</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-21 12:21:25 UTC; susan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-21 15:52:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='backdec'>Inverse function to wholebinary returns the number from its expansion</h2><span id='topic+backdec'></span>

<h3>Description</h3>

<p>Inverse function to wholebinary returns the number from its expansion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backdec(rmat, sgn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backdec_+3A_rmat">rmat</code></td>
<td>
<p>is a matrix of two rows, the first row
of the matrix is the expansion of the integer part
the second row is the binary expansion of the fractional part.</p>
</td></tr>
<tr><td><code id="backdec_+3A_sgn">sgn</code></td>
<td>
<p>is the sign</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It may be necessary to make a new version of this
using special functions for large integers.
</p>

<hr>
<h2 id='borelmerge'>Auxiliary function that takes avector and produces a single number through 
a Borel isomorphism using the wholebinary and backdec functions.</h2><span id='topic+borelmerge'></span>

<h3>Description</h3>

<p>Auxiliary function that takes avector and produces a single number through 
a Borel isomorphism using the wholebinary and backdec functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>borelmerge(xvec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="borelmerge_+3A_xvec">xvec</code></td>
<td>
<p>is a vector of real numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>produces a single real number by converting each element
</p>

<hr>
<h2 id='calculateXI'>Compute the cross rank coefficient xi on two vectors.</h2><span id='topic+calculateXI'></span><span id='topic+xicorcoefficient'></span>

<h3>Description</h3>

<p>This function computes the xi coefficient between two vectors x and y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateXI(xvec, yvec, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateXI_+3A_xvec">xvec</code></td>
<td>
<p>Vector of numeric values in the first coordinate.</p>
</td></tr>
<tr><td><code id="calculateXI_+3A_yvec">yvec</code></td>
<td>
<p>Vector of numeric values in the second coordinate.</p>
</td></tr>
<tr><td><code id="calculateXI_+3A_simple">simple</code></td>
<td>
<p>Whether auxiliary information is kept to pass on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the case simple = TRUE, function returns the value of the
xi
coefficient,
If simple = FALSE is chosen, the function returns a list:
</p>
<dl>
<dt>xi</dt><dd><p>The xi coefficient</p>
</dd>
<dt>fr</dt><dd><p>rearranged rank of yvec</p>
</dd>
<dt>CU</dt><dd><p><code>mean(gr*(1-gr))</code></p>
</dd>
</dl>



<h3>Note</h3>

<p>Auxiliary function with no checks for NA, etc.
</p>


<h3>Author(s)</h3>

<p>Sourav Chatterjee, Susan Holmes
</p>


<h3>References</h3>

<p>Chatterjee, S. (2020) A New Coefficient Of Correlation,
&lt;arXiv:1909.10140&gt;.
</p>


<h3>See Also</h3>

<p>xicor
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute one of the coefficients
library("psychTools")
data(peas)
calculateXI(peas$parent,peas$child)
calculateXI(peas$child,peas$parent)
</code></pre>

<hr>
<h2 id='fracbinary'>Take fractionary part and make its binary expansion
Auxiliary function used in expanding real numbers</h2><span id='topic+fracbinary'></span>

<h3>Description</h3>

<p>Take fractionary part and make its binary expansion
Auxiliary function used in expanding real numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fracbinary(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fracbinary_+3A_x">x</code></td>
<td>
<p>is a number between 0 and 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Binary expansion of length 31 of the decimal input
</p>


<h3>Note</h3>

<p>this implementation uses the built-in function intToBits
</p>

<hr>
<h2 id='FRpredcor'>Compute the FR coefficient  on two vectors based exactly on Gamma2.</h2><span id='topic+FRpredcor'></span><span id='topic+Gamma2'></span>

<h3>Description</h3>

<p>This function computes the unidimensional graph prediction coefficient
between two vectors xvec and yvec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FRpredcor(xvec, yvec, tiemethod = "average")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FRpredcor_+3A_xvec">xvec</code></td>
<td>
<p>Vector of numeric values in the first coordinate.</p>
</td></tr>
<tr><td><code id="FRpredcor_+3A_yvec">yvec</code></td>
<td>
<p>Vector of numeric values in the second coordinate.</p>
</td></tr>
<tr><td><code id="FRpredcor_+3A_tiemethod">tiemethod</code></td>
<td>
<p>Choice of treatment for ties, default is the &quot;average&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the case simple = TRUE, function returns the value of the
FR standardized coefficient.
</p>


<h3>Note</h3>

<p>Auxiliary function with no checks for NA, etc.
</p>


<h3>Author(s)</h3>

<p>Sourav Chatterjee, Susan Holmes
</p>


<h3>References</h3>

<p>Chatterjee, S. and Holmes, S (2020)
Practical observations and applications of the robust prediction
coefficient.
</p>


<h3>See Also</h3>

<p>xicor FRpredcorhalf
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute  the coefficient and compare to the xi coefficient
simulCompare &lt;- function(n = 20, B = 1000)
{
 diffs&lt;- rep(0,B)
 xvec &lt;- 1:n
 for (i in 1:B)
 {
   yvec &lt;- runif(n)
   diffs[i] &lt;- FRpredcor(xvec, yvec) - xicor(xvec, yvec)
 }
 return(diffs)
 }

 simulcompare1K &lt;- simulCompare()
 summary(simulcompare1K)


</code></pre>

<hr>
<h2 id='FRpredcorhalf'>Compute the FR half coefficient  on two vectors based on half Gamma 2.</h2><span id='topic+FRpredcorhalf'></span>

<h3>Description</h3>

<p>This function computes the unidimensional ranked
half graph prediction coefficient
between two vectors xvec and yvec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FRpredcorhalf(xvec, yvec, tiemethod = "average")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FRpredcorhalf_+3A_xvec">xvec</code></td>
<td>
<p>Vector of numeric values in the first coordinate.</p>
</td></tr>
<tr><td><code id="FRpredcorhalf_+3A_yvec">yvec</code></td>
<td>
<p>Vector of numeric values in the second coordinate.</p>
</td></tr>
<tr><td><code id="FRpredcorhalf_+3A_tiemethod">tiemethod</code></td>
<td>
<p>Choice of treatment for ties, default is the &quot;average&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the case simple = TRUE, function returns the value of the
FR standardized coefficient.
</p>


<h3>Note</h3>

<p>Auxiliary function with no checks for NA, etc.
</p>


<h3>Author(s)</h3>

<p>Sourav Chatterjee, Susan Holmes
</p>


<h3>References</h3>

<p>Chatterjee, S. and Holmes, S (2020)
Practical observations and applications of the robust prediction
coefficient.
</p>


<h3>See Also</h3>

<p>xicor FRpredcor
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute  the coefficient and compare to the xi coefficient
simulCompare &lt;- function(n = 20, B = 1000)
{
 diffsim &lt;- rep(0,B)
 xvec &lt;- 1:n
 for (i in 1:B)
 {
   yvec &lt;- sample(n,n)
   diffsim[i] &lt;- FRpredcorhalf(xvec,yvec)-xicor(xvec,yvec)
 }
 return(diffsim)
 }

 compare1K &lt;- simulCompare()
 summary(compare1K)


</code></pre>

<hr>
<h2 id='genxicor'>Compute the generalized cross rank increment correlation coefficient gxi.</h2><span id='topic+genxicor'></span>

<h3>Description</h3>

<p>This function computes the generalized xi coefficient between two matrices
xmat and ymat.
There is a limitation on the size of the matrices, for the time
being, xmat and ymat can only have 31 columns.
If they are wider than 31, there is the option of using a
dimension reduction technique to bring the number of columns down
to 31, the first 31 components are then used.
The function encodes the data using a binary expansion and
then calls xicor on the vectors, so some of the arguments
relevant for xicor can be specified, such as pvalue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genxicor(xmat, ymat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genxicor_+3A_xmat">xmat</code></td>
<td>
<p>Matrix of numeric values in the first argument.</p>
</td></tr>
<tr><td><code id="genxicor_+3A_ymat">ymat</code></td>
<td>
<p>Matrix of numeric values in the second argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns the value of the genxi coefficient.
Since by default the option pvalue=TRUE is chosen, the function 
returns a list:
</p>
<dl>
<dt>xi</dt><dd><p>The
value of the xi coefficient.</p>
</dd>
<dt>sd</dt><dd><p>The standard deviation.</p>
</dd>
<dt>pval</dt><dd><p>The test p-value.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This version does not use a seed as argument, if reproducibility is an issue, set a seed before calling the function.
</p>
<p>The p-value of rejecting independence is set to TRUE.
</p>


<h3>Author(s)</h3>

<p>Sourav Chatterjee, Susan Holmes
</p>


<h3>References</h3>

<p>Chatterjee, S. (2022) &lt;arXiv:2211.04702&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example_joint_calc = function(n,x=runif(n),y=runif(n),ep=runif(n)) {
u = (x + y + ep) %% 1
v = ((x + y)/2 + ep) %% 1
w = (4*x/3 + 2*y/3 + ep) %% 1
z = (2*x/3 + y/3 + ep) %% 1
q = cbind(u,v,w,z)
p = cbind(x,y)
c1 = genxicor(u, p)
c2 = genxicor(v, p)
c3 = genxicor(w, p)
c4 = genxicor(z, p)
c5 = genxicor(q, p)
return(list(marg1 = c1$xi, marg2 = c2$xi, marg3 = c3$xi, 
marg4 = c4$xi, joint = c5$xi, p1 = c1$pval, p2 = c2$pval, p3 = c3$pval,
p4 = c4$pval, p5 = c5$pval))
}
result1 &lt;- example_joint_calc(n=10)

</code></pre>

<hr>
<h2 id='numbinary'>Computes the binary expansion of a number</h2><span id='topic+numbinary'></span>

<h3>Description</h3>

<p>If the argument x is a real number the decimal
portion is dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numbinary(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numbinary_+3A_x">x</code></td>
<td>
<p>is a real or integer number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the output is a binary vector of length 31
</p>

<hr>
<h2 id='weave'>Take a matrix of two numbers given in their binary expansion
one in each of the two rows
and return the interleaving of the two numbers</h2><span id='topic+weave'></span>

<h3>Description</h3>

<p>Take a matrix of two numbers given in their binary expansion
one in each of the two rows
and return the interleaving of the two numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weave(rmat, sgn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weave_+3A_rmat">rmat</code></td>
<td>
<p>a matrix with two times m rows corresponding to the 
the expansions of the m numbers to be interleaved.</p>
</td></tr>
<tr><td><code id="weave_+3A_sgn">sgn</code></td>
<td>
<p>is the sign vector associated to the numbers to be weaved</p>
</td></tr>
</table>

<hr>
<h2 id='wholebinary'>Encodes a number as a two row binary matrix and its sign</h2><span id='topic+wholebinary'></span>

<h3>Description</h3>

<p>Auxiliary function used for generating expansion of a number,
the binary expansion of length nc of the integer part is the first row 
and the binary expansion of length nc of the fractional part
is the second row of the matrix.
The sign as appended into the final list object which the function
returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wholebinary(x, nc = 31)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wholebinary_+3A_x">x</code></td>
<td>
<p>is a decimal number</p>
</td></tr>
<tr><td><code id="wholebinary_+3A_nc">nc</code></td>
<td>
<p>is the length of the binary expansion and defines the
number of columns of the output matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function generates a list with a binary matrix
rmat
with two rows and the sign sgn in a separate entry of the list.
</p>

<hr>
<h2 id='xicor'>Compute the cross rank increment correlation coefficient xi.</h2><span id='topic+xicor'></span><span id='topic+xi'></span>

<h3>Description</h3>

<p>This function computes the xi coefficient between two vectors x and y,
possibly all coefficients for a matrix. If only one coefficient is computed
it can be used to test independence using a Monte Carlo permutation test or
through an asymptotic approximation test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xicor(
  x,
  y = NULL,
  pvalue = FALSE,
  ties = TRUE,
  method = "asymptotic",
  nperm = 1000,
  factor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xicor_+3A_x">x</code></td>
<td>
<p>Vector of numeric values in the first coordinate.</p>
</td></tr>
<tr><td><code id="xicor_+3A_y">y</code></td>
<td>
<p>Vector of numeric values in the second coordinate.</p>
</td></tr>
<tr><td><code id="xicor_+3A_pvalue">pvalue</code></td>
<td>
<p>Whether or not to return the p-value of rejecting
independence, if TRUE the function also returns the standard deviation of
xi.</p>
</td></tr>
<tr><td><code id="xicor_+3A_ties">ties</code></td>
<td>
<p>Do we need to handle ties? If ties=TRUE the algorithm assumes
that the data has ties and employs the more elaborated theory for
calculating s.d. and P-value. Otherwise, it uses the simpler theory. There
is no harm in putting ties = TRUE even if there are no ties.</p>
</td></tr>
<tr><td><code id="xicor_+3A_method">method</code></td>
<td>
<p>If method = &quot;asymptotic&quot; the function returns P-values
computed by the asymptotic theory. If method = &quot;permutation&quot;, a permutation
test with nperm permutations is employed to estimate the P-value. Usually,
there is no need for the permutation test. The asymptotic theory is good
enough.</p>
</td></tr>
<tr><td><code id="xicor_+3A_nperm">nperm</code></td>
<td>
<p>In the case of a permutation test, <code>nperm</code> is the number
of permutations to do.</p>
</td></tr>
<tr><td><code id="xicor_+3A_factor">factor</code></td>
<td>
<p>Whether to transform integers into factors, the default is to
leave them alone.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the case pvalue=FALSE, function returns the value of the xi
coefficient, if the input is a matrix, a matrix of coefficients is returned.
In the case pvalue=TRUE is chosen, the function returns a list:
</p>
<dl>
<dt>xi</dt><dd><p>The
value of the xi coefficient.</p>
</dd>
<dt>sd</dt><dd><p>The standard deviation.</p>
</dd>
<dt>pval</dt><dd><p>The test p-value.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Dataset peas no longer available in psych, we are now using psychTools.
</p>
<p>This version does not use a seed as argument, if reproducibility is an issue, set a seed before calling the function.
</p>


<h3>Author(s)</h3>

<p>Sourav Chatterjee, Susan Holmes
</p>


<h3>References</h3>

<p>Chatterjee, S. (2020) &lt;arXiv:1909.10140&gt;.
</p>


<h3>See Also</h3>

<p>dcov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##---- Should be DIRECTLY executable !! ----
library("psychTools")
data(peas)
# Visualize       the peas data
library(ggplot2)
ggplot(peas,aes(parent,child)) +
geom_count() + scale_radius(range=c(0,5)) +
       xlim(c(13.5,24))+ylim(c(13.5,24))+       coord_fixed() +
       theme(legend.position="bottom")
# Compute one of the coefficients
xicor(peas$parent,peas$child,pvalue=TRUE)
xicor(peas$child,peas$parent)
# Compute all the coefficients
xicor(peas)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
