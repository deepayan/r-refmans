<!DOCTYPE html><html><head><title>Help for package cheese</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cheese}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#absorb'><p>Absorb values into a string containing keys</p></a></li>
<li><a href='#depths'><p>Find the elements in a list structure that satisfy a predicate</p></a></li>
<li><a href='#descriptives'><p>Compute descriptive statistics on columns of a data frame</p></a></li>
<li><a href='#dish'><p>Evaluate a two-argument function with combinations of columns</p></a></li>
<li><a href='#divide'><p>Divide a data frame into a list</p></a></li>
<li><a href='#fasten'><p>Bind a list of data frames back together</p></a></li>
<li><a href='#grable'><p>Make a <code>kable</code> with a hierarchical header</p></a></li>
<li><a href='#heart_disease'><p>Heart Disease</p></a></li>
<li><a href='#muddle'><p>Randomly permute some or all columns of a data frame</p></a></li>
<li><a href='#some_type'><p>Is an object one of the specified types?</p></a></li>
<li><a href='#stratiply'><p>Stratify a data frame and apply a function</p></a></li>
<li><a href='#stretch'><p>Span keys and values across the columns</p></a></li>
<li><a href='#typly'><p>Evaluate a function on columns conforming to one or more (or no) specified types</p></a></li>
<li><a href='#univariate_associations'><p>Compute association statistics between columns of a data frame</p></a></li>
<li><a href='#univariate_table'><p>Create a custom descriptive table for a dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Working with Data During Statistical Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains tools for working with data during statistical analysis, promoting flexible, intuitive, and reproducible workflows. There are functions designated for specific statistical tasks such building a custom univariate descriptive table, computing pairwise association statistics, etc. These are built on a collection of data manipulation tools designed for general use that are motivated by the functional programming concept.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://zajichek.github.io/cheese/">https://zajichek.github.io/cheese/</a>,
<a href="https://github.com/zajichek/cheese/">https://github.com/zajichek/cheese/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.8.2), forcats (&ge; 0.3.0), kableExtra (&ge; 1.0.1),
knitr (&ge; 1.20), magrittr (&ge; 1.5), methods (&ge; 3.4.1), purrr
(&ge; 0.3.2), rlang (&ge; 0.4.3), stringr (&ge; 1.3.1), tibble (&ge;
2.1.3), tidyr (&ge; 0.8.1), tidyselect (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown (&ge; 1.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-04 20:57:54 UTC; alexzajichek</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Zajichek [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Zajichek &lt;alexzajichek@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-06 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator from <code><a href="magrittr.html#topic+magrittr">magrittr</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='absorb'>Absorb values into a string containing keys</h2><span id='topic+absorb'></span>

<h3>Description</h3>

<p>Populate string templates containing keys with their values. The keys are interpreted as regular expressions. Results can optionally be evaluated as <code>R</code> expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absorb(
    key, 
    value, 
    text, 
    sep = "_",
    trace = FALSE,
    evaluate = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absorb_+3A_key">key</code></td>
<td>
<p>A vector that can be coerced to type <code><a href="base.html#topic+character">character</a></code>.</p>
</td></tr>
<tr><td><code id="absorb_+3A_value">value</code></td>
<td>
<p>A vector with the same length as <code>key</code>.</p>
</td></tr>
<tr><td><code id="absorb_+3A_text">text</code></td>
<td>
<p>A (optionally named) <code><a href="base.html#topic+character">character</a></code> vector containing patterns.</p>
</td></tr>
<tr><td><code id="absorb_+3A_sep">sep</code></td>
<td>
<p>Delimiter to separate values by in the placeholder for duplicate patterns. Defaults to <code>"_"</code></p>
</td></tr>
<tr><td><code id="absorb_+3A_trace">trace</code></td>
<td>
<p>Should the recursion results be printed to the console each iteration? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="absorb_+3A_evaluate">evaluate</code></td>
<td>
<p>Should the result(s) be evaluated as <code>R</code> expressions? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inputs are iterated in sequential order to replace each pattern with its corresponding value. It is possible that a subsequent pattern could match with a prior result, and hence be replaced more than once. If duplicate keys exist, the placeholder will be filled with a collapsed string of all the values for that key.
</p>


<h3>Value</h3>


<ul>
<li><p> If <code>evaluate = FALSE</code> (default), a <code><a href="base.html#topic+character">character</a></code> vector the same length as <code>text</code> with all matching patterns replaced by their value.
</p>
</li>
<li><p> Otherwise, a <code><a href="base.html#topic+list">list</a></code> with the same length as <code>text</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simple example
absorb(
    key = c("mean", "sd", "var"),
    value = c("10", "2", "4"),
    text = 
        c("MEAN: mean, SD: sd",
          "VAR: var = sd^2",
          MEAN = "mean"
        )
)

#Evaluating results
absorb(
    key = c("mean", "mean", "sd", "var"),
    value = c("10", "20", "2", "4"),
    text = c("(mean)/2", "sd^2"),
    sep = "+",
    trace = TRUE,
    evaluate = TRUE
) %&gt;%
    rlang::flatten_dbl()

</code></pre>

<hr>
<h2 id='depths'>Find the elements in a list structure that satisfy a predicate</h2><span id='topic+depths'></span><span id='topic+depths_string'></span>

<h3>Description</h3>

<p>Traverse a list of structure to find the depths and positions of its elements that satisfy a predicate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depths(
    list,
    predicate,
    bare = TRUE,
    ...
)
depths_string(
    list,
    predicate,
    bare = TRUE,
    ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depths_+3A_list">list</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, <code><a href="base.html#topic+data.frame">data.frame</a></code>, or <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="depths_+3A_predicate">predicate</code></td>
<td>
<p>A <code><a href="base.html#topic+function">function</a></code> that evaluates to <code>TRUE</code> or <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="depths_+3A_bare">bare</code></td>
<td>
<p>Should algorithm only continue for bare lists? Defaults to TRUE. See <code>rlang::`bare-type-predicates`</code></p>
</td></tr>
<tr><td><code id="depths_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>predicate</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is recursively evaluated to find elements that satisfy <code>predicate</code>, and only proceeds where <code>rlang::is_list</code> when argument <code>bare</code> is <code>FALSE</code>, and <code>rlang::is_bare_list</code> when it is <code>TRUE</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>depths()</code> returns an <code><a href="base.html#topic+integer">integer</a></code> vector indicating the levels that contain elements satisfying the predicate.
</p>
</li>
<li> <p><code>depths_string()</code> returns a <code><a href="base.html#topic+character">character</a></code> representation of the traversal. Brackets {} are used to indicate the level of the tree, commas to separate element-indices within a level, and the sign of the index to indicate whether the element satisfied <code>predicate</code> (- = yes, + = no).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Find depths of data frames
df1 &lt;-
  heart_disease %&gt;%
  
    #Divide the frame into a list
    divide(
      Sex,
      HeartDisease,
      ChestPain
    )

df1 %&gt;%
  
  #Get depths as an integer
  depths(
    predicate = is.data.frame
  )

df1 %&gt;%

  #Get full structure
  depths_string(
    predicate = is.data.frame
  )

#Shallower list
df2 &lt;-
  heart_disease %&gt;%
    divide(
      Sex,
      HeartDisease,
      ChestPain,
      depth = 1
    ) 

df2 %&gt;%
  depths(
    predicate = is.data.frame
  )

df2 %&gt;%
  depths_string(
    predicate = is.data.frame
  )

#Allow for non-bare lists to be traversed
df1 %&gt;%
  depths(
    predicate = is.factor,
    bare = FALSE
  )

#Make uneven list with diverse objects
my_list &lt;-
  list(
    heart_disease,
    list(
      heart_disease
    ),
    1:10,
    list(
      heart_disease$Age,
      list(
        heart_disease
      )
    ),
    glm(
      formula = HeartDisease ~ .,
      data = heart_disease,
      family = "binomial"
    )
  )

#Find the data frames
my_list %&gt;%
  depths(
    predicate = is.data.frame
  )

my_list %&gt;%
  depths_string(
    predicate = is.data.frame
  )

#Go deeper by relaxing bare list argument
my_list %&gt;%
  depths_string(
    predicate = is.data.frame,
    bare = FALSE
  )

</code></pre>

<hr>
<h2 id='descriptives'>Compute descriptive statistics on columns of a data frame</h2><span id='topic+descriptives'></span>

<h3>Description</h3>

<p>The user can specify an unlimited number of functions to evaluate and the types of data that each set of functions will be applied to (including the default; see &quot;Details&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descriptives(
    data,
    f_all = NULL,
    f_numeric = NULL,
    numeric_types = "numeric",
    f_categorical = NULL,
    categorical_types = "factor",
    f_other = NULL,
    useNA = c("ifany", "no", "always"),
    round = 2,
    na_string = "(missing)"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="descriptives_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="descriptives_+3A_f_all">f_all</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of functions to evaluate on all columns.</p>
</td></tr>
<tr><td><code id="descriptives_+3A_f_numeric">f_numeric</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of functions to evaluate on <code>numeric_types</code> columns.</p>
</td></tr>
<tr><td><code id="descriptives_+3A_numeric_types">numeric_types</code></td>
<td>
<p>Character vector of data types that should be evaluated by <code>f_numeric</code>.</p>
</td></tr>
<tr><td><code id="descriptives_+3A_f_categorical">f_categorical</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of functions to evaluate on <code>categorical_types</code> columns.</p>
</td></tr>
<tr><td><code id="descriptives_+3A_categorical_types">categorical_types</code></td>
<td>
<p>Character vector of data types that should be evaluated by <code>f_categorical</code>.</p>
</td></tr>
<tr><td><code id="descriptives_+3A_f_other">f_other</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of functions to evaluate on remaining columns.</p>
</td></tr>
<tr><td><code id="descriptives_+3A_usena">useNA</code></td>
<td>
<p>See <code><a href="base.html#topic+table">table</a></code> for details. Defaults to <code>"ifany"</code>.</p>
</td></tr>
<tr><td><code id="descriptives_+3A_round">round</code></td>
<td>
<p>Digit to round numeric data. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="descriptives_+3A_na_string">na_string</code></td>
<td>
<p>String to fill in <code>NA</code> names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following <code>fun_key</code>'s are available by default for the specified types:
</p>

<ul>
<li><p> ALL: <code><a href="base.html#topic+length">length</a>, missing, available, <a href="base.html#topic+class">class</a>, <a href="base.html#topic+unique">unique</a></code>
</p>
</li>
<li><p> Numeric: <code><a href="base.html#topic+mean">mean</a>, <a href="stats.html#topic+sd">sd</a>, <a href="base.html#topic+min">min</a>, q1, <a href="stats.html#topic+median">median</a>, q3, <a href="base.html#topic+max">max</a>, iqr, range</code>
</p>
</li>
<li><p> Categorical: <code>count, proportion, percent</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble::tibble</code> with the following columns:
</p>

<ul>
<li> <p><code>fun_eval</code>: Column types function was applied to
</p>
</li>
<li> <p><code>fun_key</code>: Name of function that was evaluated
</p>
</li>
<li> <p><code>col_ind</code>: Index from input dataset
</p>
</li>
<li> <p><code>col_lab</code>: Label of the column
</p>
</li>
<li> <p><code>val_ind</code>: Index of the value within the function result
</p>
</li>
<li> <p><code>val_lab</code>: Label extracted from the result with <code><a href="base.html#topic+names">names</a></code>
</p>
</li>
<li> <p><code>val_dbl</code>: Numeric result
</p>
</li>
<li> <p><code>val_chr</code>: Non-numeric result
</p>
</li>
<li> <p><code>val_cbn</code>: Combination of (rounded) numeric and non-numeric values
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Default
heart_disease %&gt;%
    descriptives()

#Allow logicals as categorical
heart_disease %&gt;%
    descriptives(
        categorical_types = c("logical", "factor")
    ) %&gt;%
    
    #Extract info from the column
    dplyr::filter(
        col_lab == "BloodSugar"
    ) 

#Nothing treated as numeric
heart_disease %&gt;%
    descriptives(
        numeric_types = NULL
    )

#Evaluate a custom function
heart_disease %&gt;%
    descriptives(
        f_numeric = 
            list(
                cv = function(x) sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE)
            )
    ) %&gt;%
    
    #Extract info from the custom function
    dplyr::filter(
        fun_key == "cv"
    ) 

</code></pre>

<hr>
<h2 id='dish'>Evaluate a two-argument function with combinations of columns</h2><span id='topic+dish'></span>

<h3>Description</h3>

<p>Split up columns into groups and apply a function to combinations of those columns with control over whether each group is entered as a single <code><a href="base.html#topic+data.frame">data.frame</a></code> or individual <code><a href="base.html#topic+vector">vector</a></code>'s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dish(
    data,
    f,
    left,
    right,
    each_left = TRUE,
    each_right = TRUE,
    ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dish_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="dish_+3A_f">f</code></td>
<td>
<p>A <code><a href="base.html#topic+function">function</a></code> that takes a <code><a href="base.html#topic+vector">vector</a></code> and/or <code><a href="base.html#topic+data.frame">data.frame</a></code> in the first two arguments.</p>
</td></tr>    
<tr><td><code id="dish_+3A_left">left</code></td>
<td>
<p>A vector of quoted/unquoted columns, positions, and/or <code>tidyselect::select_helpers</code> to be evaluated in the first argument of <code>f</code>.</p>
</td></tr>
<tr><td><code id="dish_+3A_right">right</code></td>
<td>
<p>A vector of quoted/unquoted columns, positions, and/or <code>tidyselect::select_helpers</code> to be evaluated in the second argument of <code>f</code>.</p>
</td></tr>
<tr><td><code id="dish_+3A_each_left">each_left</code></td>
<td>
<p>Should each <code>left</code> variable be indivdually evaluated in <code>f</code>? Defaults to <code>TRUE</code>. If <code>FALSE</code>, <code>left</code> columns are entered into <code>f</code> as a single <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="dish_+3A_each_right">each_right</code></td>
<td>
<p>Should each <code>right</code> variable be individually evaluated in <code>f</code>? Defaults to <code>TRUE</code>. If <code>FALSE</code>, <code>right</code> columns are entered into <code>f</code> as a single <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="dish_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> 
</p>


<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>#All variables on both sides
heart_disease %&gt;%
    dplyr::select(
        where(is.numeric)
    ) %&gt;%
    dish(
        f = cor
    )

#Simple regression of each numeric variable on each other variable
heart_disease %&gt;%
    dish(
        f =
            function(y, x) {
                mod &lt;- lm(y ~ x)
                tibble::tibble(
                    Parameter = names(mod$coef),
                    Estimate = mod$coef
                )
            },
        left = where(is.numeric)
    ) %&gt;%
    
    #Bind rows together
    fasten(
        into = c("Outcome", "Predictor")
    )

#Multiple regression of each numeric variable on all others simultaneously
heart_disease %&gt;%
    dish(
        f =
            function(y, x) {
                mod &lt;- lm(y ~ ., data = x)
                tibble::tibble(
                    Parameter = names(mod$coef),
                    Estimate = mod$coef
                )
            },
        left = where(is.numeric),
        each_right = FALSE
    ) %&gt;%
    
    #Bind rows together
    fasten(
        into = "Outcome"
    )

</code></pre>

<hr>
<h2 id='divide'>Divide a data frame into a list</h2><span id='topic+divide'></span>

<h3>Description</h3>

<p>Separate a <code><a href="base.html#topic+data.frame">data.frame</a></code> into a <code><a href="base.html#topic+list">list</a></code> of any depth by one or more stratification columns whose levels become the names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divide(
    data,
    ...,
    depth = Inf,
    remove = TRUE,
    drop = TRUE,
    sep = "|"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divide_+3A_data">data</code></td>
<td>
<p>Any <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="divide_+3A_...">...</code></td>
<td>
<p>Selection of columns to split by. See <code>dplyr::select</code> for details.</p>
</td></tr>
<tr><td><code id="divide_+3A_depth">depth</code></td>
<td>
<p>Depth to split to. Defaults to <code>Inf</code>. See details for more information.</p>
</td></tr>
<tr><td><code id="divide_+3A_remove">remove</code></td>
<td>
<p>Should the stratfication columns be removed? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="divide_+3A_drop">drop</code></td>
<td>
<p>Should unused combinations of stratification variables be dropped? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="divide_+3A_sep">sep</code></td>
<td>
<p>String to separate values of each stratification variable by. Defaults to <code>"|"</code>. Only used when the number of stratification columns exceeds the desired depth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>depth</code>, use positive integers to move from the root and negative integers to move from the leaves. The maximum (minimum) depth will be used for integers larger (smaller) than such.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code>
</p>


<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Unquoted selection
heart_disease %&gt;%
    divide(
        Sex
    )

#Using select helpers
heart_disease %&gt;%
    divide(
        matches("^S")
    )

#Reduced depth
heart_disease %&gt;%
    divide(
        Sex,
        HeartDisease,
        depth = 1
    )
    
#Keep columns in result; change delimiter in names
heart_disease %&gt;%
    divide(
        Sex,
        HeartDisease,
        depth = 1,
        remove = FALSE,
        sep = ","
    )

#Move inward from maximum depth
heart_disease %&gt;%
    divide(
        Sex,
        HeartDisease,
        ChestPain,
        depth = -1
    )

#No depth returns original data (and warning)
heart_disease %&gt;%
    divide(
        Sex,
        depth = 0
    )
heart_disease %&gt;%
    divide(
        Sex,
        HeartDisease,
        depth = -5
    )

#Larger than maximum depth returns maximum depth (default)
heart_disease %&gt;%
    divide(
        Sex,
        depth = 100
    )

</code></pre>

<hr>
<h2 id='fasten'>Bind a list of data frames back together</h2><span id='topic+fasten'></span>

<h3>Description</h3>

<p>Roll up a <code><a href="base.html#topic+list">list</a></code> of arbitrary depth with <code><a href="base.html#topic+data.frame">data.frame</a></code>'s at the leaves row-wise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fasten(
    list,
    into = NULL,
    depth = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fasten_+3A_list">list</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> with <code><a href="base.html#topic+data.frame">data.frame</a></code>'s at the leaves.</p>
</td></tr>
<tr><td><code id="fasten_+3A_into">into</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector of resulting column names. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fasten_+3A_depth">depth</code></td>
<td>
<p>Depth to bind the list to. Defaults to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use empty strings <code>""</code> in the <code>into</code> argument to omit column creation when rows are binded. Use positive integers for the <code>depth</code> to move from the root and negative integers to move from the leaves. The maximum (minimum) depth will be used for integers larger (smaller) than such. The leaves of the input <code>list</code> should be at the same depth.
</p>


<h3>Value</h3>

<p>A <code>tibble::tibble</code> or reduced <code><a href="base.html#topic+list">list</a></code>
</p>


<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make a divided data frame
list &lt;-
  heart_disease %&gt;%
  divide(
    Sex,
    HeartDisease,
    ChestPain
  )

#Bind without creating names
list %&gt;% 
  fasten

#Bind with names
list %&gt;% 
  fasten(
    into = c("Sex", "HeartDisease", "ChestPain")
  )

#Only retain "Sex"
list %&gt;%
  fasten(
    into = "Sex"
  )

#Only retain "HeartDisease"
list %&gt;%
  fasten(
    into = c("", "HeartDisease")
  )

#Bind up to Sex
list %&gt;%
  fasten(
    into = c("HeartDisease", "ChestPain"),
    depth = 1
  )

#Same thing, but start at the leaves
list %&gt;%
  fasten(
    into = c("HeartDisease", "ChestPain"),
    depth = -2
  )

#Too large of depth returns original list
list %&gt;%
  fasten(
    depth = 100
  )

#Too small of depth goes to 0
list %&gt;%
  fasten(
    depth = -100
  )
</code></pre>

<hr>
<h2 id='grable'>Make a <code>kable</code> with a hierarchical header</h2><span id='topic+grable'></span>

<h3>Description</h3>

<p>Create a <code>knitr::kable</code> with a multi-layered (graded) header.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grable(
    data,
    at,
    sep = "_",
    reverse = FALSE,
    format = c("html", "latex"),
    caption = NULL,
    ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grable_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="grable_+3A_at">at</code></td>
<td>
<p>A vector of quoted/unquoted columns, positions, and/or <code>tidyselect::select_helpers</code>. Defaults to all columns.</p>
</td></tr>
<tr><td><code id="grable_+3A_sep">sep</code></td>
<td>
<p>String to separate the columns. Defaults to &quot;_&quot;.</p>
</td></tr>
<tr><td><code id="grable_+3A_reverse">reverse</code></td>
<td>
<p>Should the layers be added in the opposite direction? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="grable_+3A_format">format</code></td>
<td>
<p>Format for rendering the table. Must be &quot;html&quot; (default) or &quot;latex&quot;.</p>
</td></tr>
<tr><td><code id="grable_+3A_caption">caption</code></td>
<td>
<p>Optional caption for the table</p>
</td></tr>
<tr><td><code id="grable_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>kableExtra::kable_styling</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>knitr::kable</code>
</p>


<h3>Author(s)</h3>

<p>Alex Zajichek</p>

<hr>
<h2 id='heart_disease'>Heart Disease</h2><span id='topic+heart_disease'></span>

<h3>Description</h3>

<p>This is a cleaned up version of the &quot;heart disease data set&quot; found in the UCI Machine Learning Repository (https://archive.ics.uci.edu/ml/datasets/Heart+Disease), containing a subset of the default variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heart_disease
</code></pre>


<h3>Format</h3>

<p>See &quot;Source&quot; for link to dataset home page</p>


<h3>Source</h3>

<p>https://archive.ics.uci.edu/ml/datasets/Heart+Disease</p>

<hr>
<h2 id='muddle'>Randomly permute some or all columns of a data frame</h2><span id='topic+muddle'></span>

<h3>Description</h3>

<p>Shuffle any of the columns of a <code><a href="base.html#topic+data.frame">data.frame</a></code> to artificially distort relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muddle(
    data,
    at,
    ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muddle_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="muddle_+3A_at">at</code></td>
<td>
<p>A vector of quoted/unquoted columns, positions, and/or <code>tidyselect::select_helpers</code>. Defaults to all columns.</p>
</td></tr>
<tr><td><code id="muddle_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+sample">sample</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble::tibble</code>
</p>


<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Set a seed
set.seed(123)

#Default permutes all columns
heart_disease %&gt;%
  muddle

#Permute select columns
heart_disease %&gt;%
  muddle(
    at = c(Age, Sex)
  )

#Using a select helper
heart_disease %&gt;%
  muddle(
    at = matches("^S")
  )

#Pass other arguments
heart_disease %&gt;%
  muddle(
    size = 5,
    replace = TRUE
  )

</code></pre>

<hr>
<h2 id='some_type'>Is an object one of the specified types?</h2><span id='topic+some_type'></span>

<h3>Description</h3>

<p>Check if an object inherits one (or more) of a vector classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>some_type(
    object,
    types
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="some_type_+3A_object">object</code></td>
<td>
<p>Any <code>R</code> object.</p>
</td></tr>
<tr><td><code id="some_type_+3A_types">types</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector of classes to test against.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+logical">logical</a></code> indicator
</p>


<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Columns of a data frame
heart_disease %&gt;%
    purrr::map_lgl(
        some_type,
        types = c("numeric", "logical")
    )

</code></pre>

<hr>
<h2 id='stratiply'>Stratify a data frame and apply a function</h2><span id='topic+stratiply'></span>

<h3>Description</h3>

<p>Split a <code><a href="base.html#topic+data.frame">data.frame</a></code> by any number of columns and apply a function to subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratiply(
    data,
    f,
    by,
    ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratiply_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="stratiply_+3A_f">f</code></td>
<td>
<p>A function that takes a <code><a href="base.html#topic+data.frame">data.frame</a></code> as an argument.</p>
</td></tr>
<tr><td><code id="stratiply_+3A_by">by</code></td>
<td>
<p>A vector of quoted/unquoted columns, positions, and/or <code>tidyselect::select_helpers</code></p>
</td></tr>
<tr><td><code id="stratiply_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code>
</p>


<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Unquoted selection
heart_disease %&gt;%
    stratiply(
        head,
        Sex
    )

#Select helper
heart_disease %&gt;%
    stratiply(
        f = head,
        by = starts_with("S")
    )
    
#Use additional arguments for the function
heart_disease %&gt;%
  stratiply(
        f = glm,
        by = Sex,
        formula = HeartDisease ~ .,
        family = "binomial"
  )

#Use mixed selections to split by desired columns
heart_disease %&gt;%
  stratiply(
        f = glm,
        by = c(Sex, where(is.logical)),
        formula = HeartDisease ~ Age,
        family = "binomial"
  ) 
  
</code></pre>

<hr>
<h2 id='stretch'>Span keys and values across the columns</h2><span id='topic+stretch'></span>

<h3>Description</h3>

<p>Pivot one or more values across the columns by one or more keys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stretch(
    data,
    key,
    value,
    sep = "_"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stretch_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="stretch_+3A_key">key</code></td>
<td>
<p>A vector of quoted/unquoted columns, positions, and/or <code>tidyselect::select_helpers</code> whose values will become the column name(s).</p>
</td></tr>
<tr><td><code id="stretch_+3A_value">value</code></td>
<td>
<p>A vector of quoted/unquoted columns, positions, and/or <code>tidyselect::select_helpers</code> whose values will be spread across the columns.</p>
</td></tr>
<tr><td><code id="stretch_+3A_sep">sep</code></td>
<td>
<p>String to separate keys/values by in the resulting column names. Defaults to <code>"_"</code>. Only used when there are more than one keys/values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of multiple <code>value</code>'s, the labels are always appended to the end of the resulting columns.
</p>


<h3>Value</h3>

<p>A <code>tibble::tibble</code>
</p>


<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Make a summary table
set.seed(123)
data &lt;- 
  heart_disease %&gt;%
  dplyr::group_by(
    Sex,
    BloodSugar,
    HeartDisease
  ) %&gt;%
  dplyr::summarise(
    Mean = mean(Age),
    SD = sd(Age),
    .groups = "drop"
  ) %&gt;%
  dplyr::mutate(
    Random =
      rbinom(nrow(.), size = 1, prob = .5) %&gt;%
      factor
  )

data %&gt;%
  stretch(
    key = c(BloodSugar, HeartDisease),
    value = c(Mean, SD, Random)
  )

data %&gt;%
  stretch(
    key = where(is.factor),
    value = where(is.numeric)
  )

data %&gt;%
  stretch(
    key = c(where(is.factor), where(is.logical)),
    value = where(is.numeric)
  )

</code></pre>

<hr>
<h2 id='typly'>Evaluate a function on columns conforming to one or more (or no) specified types</h2><span id='topic+typly'></span>

<h3>Description</h3>

<p>Apply a function to columns in a <code><a href="base.html#topic+data.frame">data.frame</a></code> that inherit one of the specified types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typly(
    data,
    f,
    types,
    negated = FALSE,
    ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="typly_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="typly_+3A_f">f</code></td>
<td>
<p>A <code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
<tr><td><code id="typly_+3A_types">types</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector of classes to test against.</p>
</td></tr>
<tr><td><code id="typly_+3A_negated">negated</code></td>
<td>
<p>Should the function be applied to columns that don't match any <code>types</code>? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="typly_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code>
</p>


<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>heart_disease %&gt;%
    
    #Compute means on numeric or logical data
    typly(
        f = mean,
        types = c("numeric", "logical"),
        na.rm = TRUE
    ) 
</code></pre>

<hr>
<h2 id='univariate_associations'>Compute association statistics between columns of a data frame</h2><span id='topic+univariate_associations'></span>

<h3>Description</h3>

<p>Evaluate a <code><a href="base.html#topic+list">list</a></code> of scalar functions on any number of &quot;response&quot; columns by any number of &quot;predictor&quot; columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>univariate_associations(
    data,
    f,
    responses,
    predictors
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="univariate_associations_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="univariate_associations_+3A_f">f</code></td>
<td>
<p>A function or a <code><a href="base.html#topic+list">list</a></code> of functions (preferably named) that take a vector as input in the first two arguments and return a scalar.</p>
</td></tr>
<tr><td><code id="univariate_associations_+3A_responses">responses</code></td>
<td>
<p>A vector of quoted/unquoted columns, positions, and/or <code>tidyselect::select_helpers</code> to be evaluated as the first argument. See the <code>left</code> argument in <code><a href="#topic+dish">dish</a></code>.</p>
</td></tr>
<tr><td><code id="univariate_associations_+3A_predictors">predictors</code></td>
<td>
<p>A vector of quoted/unquoted columns, positions, and/or <code>tidyselect::select_helpers</code> to be evaluated as the second argument. See the <code>right</code> argument in <code><a href="#topic+dish">dish</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble::tibble</code> with the response/predictor columns down the rows and the results of the <code>f</code> across the columns. The names of the result columns will be the names provided in <code>f</code>.
</p>


<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make a list of functions to evaluate
f &lt;-
  list(
    
    #Compute a univariate p-value
    `P-value` =
      function(y, x) {
        if(some_type(x, c("factor", "character"))) {
          
          p &lt;- fisher.test(factor(y), factor(x), simulate.p.value = TRUE)$p.value
          
        } else {
          
          p &lt;- kruskal.test(x, factor(y))$p.value
          
        }
        
        ifelse(p &lt; 0.001, "&lt;0.001", as.character(round(p, 2)))
        
      },
    
    #Compute difference in AIC model between null model and one predictor model
    `AIC Difference` =
      function(y, x) {
        
        glm(factor(y)~1, family = "binomial")$aic -
          glm(factor(y)~x, family = "binomial")$aic
        
      }
  )

#Choose a couple binary outcomes
heart_disease %&gt;% 
  univariate_associations(
    f = f,
    responses = c(ExerciseInducedAngina, HeartDisease)
  )

#Use a subset of predictors
heart_disease %&gt;% 
  univariate_associations(
    f = f,
    responses = c(ExerciseInducedAngina, HeartDisease),
    predictors = c(Age, BP)
  )

#Numeric predictors only
heart_disease %&gt;% 
  univariate_associations(
    f = f,
    responses = c(ExerciseInducedAngina, HeartDisease),
    predictors = is.numeric
  )

</code></pre>

<hr>
<h2 id='univariate_table'>Create a custom descriptive table for a dataset</h2><span id='topic+univariate_table'></span>

<h3>Description</h3>

<p>Produces a formatted table of univariate summary statistics with options allowing for stratification by one or more variables, computing of custom summary/association statistics, custom string templates for results, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>univariate_table(
    data,
    strata = NULL,
    associations = NULL,
    numeric_summary = c(Summary = "median (q1, q3)"),
    categorical_summary = c(Summary = "count (percent%)"),
    other_summary = NULL,
    all_summary = NULL,
    evaluate = FALSE,
    add_n = FALSE,
    order = NULL,
    labels = NULL,
    levels = NULL,
    format = c("html", "latex", "markdown", "pandoc", "none"),
    variableName = "Variable",
    levelName = "Level",
    sep = "_",
    fill_blanks = "",
    caption = NULL,
    ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="univariate_table_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_strata">strata</code></td>
<td>
<p>An additive <code><a href="stats.html#topic+formula">formula</a></code> specifying stratification columns. Columns on the left side go down the rows, and columns on the right side go across the columns. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_associations">associations</code></td>
<td>
<p>A named <code><a href="base.html#topic+list">list</a></code> of functions to evaluate with column strata and each variable. Defaults to <code>NULL</code>. See <code><a href="#topic+univariate_associations">univariate_associations</a></code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_numeric_summary">numeric_summary</code></td>
<td>
<p>A named vector containing string templates of how results for numeric data should be presented. See details for what is available by default. Defaults to <code>c(Summary = "median (q1, q3)")</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_categorical_summary">categorical_summary</code></td>
<td>
<p>A named vector containing string templates of how results for categorical data should be presented. See details for what is available by default. Defaults to <code>c(Summary = "count (percent%)")</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_other_summary">other_summary</code></td>
<td>
<p>A named character vector containing string templates of how results for non-numeric and non-categorical data should be presented. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_all_summary">all_summary</code></td>
<td>
<p>A named character vector containing string templates of additional results applying to all variables. See details for what is available by default. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_evaluate">evaluate</code></td>
<td>
<p>Should the results of the string templates be evaluated as an <code>R</code> expression after filled with their values? See <code><a href="#topic+absorb">absorb</a></code> for details.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_add_n">add_n</code></td>
<td>
<p>Should the sample size for each stratfication level be added to the result? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_order">order</code></td>
<td>
<p>Arguments passed to <code>forcats::fct_relevel</code> for reordering the variables. Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="univariate_table_+3A_labels">labels</code></td>
<td>
<p>A named character vector containing the new labels. Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="univariate_table_+3A_levels">levels</code></td>
<td>
<p>A named <code><a href="base.html#topic+list">list</a></code> of named character vectors containing the new levels. Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="univariate_table_+3A_format">format</code></td>
<td>
<p>The format that the result should be rendered in. Must be &quot;html&quot;, &quot;latex&quot;, &quot;markdown&quot;, &quot;pandoc&quot;, or &quot;none&quot;. Defaults to <code>"html"</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_variablename">variableName</code></td>
<td>
<p>Header for the variable column in the result. Defaults to <code>"Variable"</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_levelname">levelName</code></td>
<td>
<p>Header for the factor level column in the result. Defaults to <code>"Level"</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_sep">sep</code></td>
<td>
<p>Delimiter to separate summary columns. Defaults to <code>"_"</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_fill_blanks">fill_blanks</code></td>
<td>
<p>String to fill in blank spaces in the result. Defaults to <code>""</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_caption">caption</code></td>
<td>
<p>Caption for resulting table passed to <code>knitr::kable</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="univariate_table_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="#topic+descriptives">descriptives</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of summary statistics in the specified <code>format</code>. A <code>tibble::tibble</code> is returned if <code>format = "none"</code>.
</p>


<h3>Author(s)</h3>

<p>Alex Zajichek</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Set format
format &lt;- "pandoc"

#Default summary
heart_disease %&gt;%
    univariate_table(
      format = format
    )

#Stratified summary
heart_disease %&gt;%
    univariate_table(
        strata = ~Sex,
        add_n = TRUE,
        format = format
    )

#Row strata with custom summaries with
heart_disease %&gt;%
    univariate_table(
        strata = HeartDisease~1,
        numeric_summary = c(Mean = "mean", Median = "median"),
        categorical_summary = c(`Count (%)` = "count (percent%)"),
        categorical_types = c("factor", "logical"),
        add_n = TRUE,
        format = format
    )
    
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
