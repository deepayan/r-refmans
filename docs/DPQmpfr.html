<!DOCTYPE html><html lang="en"><head><title>Help for package DPQmpfr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DPQmpfr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DPQmpfr-package'>
<p>DPQ (Density, Probability, Quantile) Distribution Computations using MPFR</p></a></li>
<li><a href='#algdivM'><p>Compute log(gamma(b)/gamma(a+b)) Accurately, also via <span class="pkg">Rmpfr</span></p></a></li>
<li><a href='#betaD94'><p>Ding(1994) (non-central) Beta Distribution Functions</p></a></li>
<li><a href='#dhyperQ'><p>Exact Hypergeometric Distribution Probabilites</p></a></li>
<li><a href='#dnt'><p>Non-central t-Distribution Density</p></a></li>
<li><a href='#DPQmpfr-utils'><p>Numeric / Mpfr Utilities for DPQmpfr</p></a></li>
<li><a href='#gam1M'><p>Compute  1/Gamma(x+1) - 1  Accurately</p></a></li>
<li><a href='#lgamma1pM'><p>Compute  log( Gamma(x+1) ) Arbitrarily (MPFR) Accurately</p></a></li>
<li><a href='#pbeta_ser'><p>Beta Distribution Function &ndash; &lsquo;BPSER&rsquo; Series Expansion from TOMS 708</p></a></li>
<li><a href='#pnormLU'><p>Bounds for 1-Phi(.) &ndash; Mill's Ratio related Bounds for pnorm()</p></a></li>
<li><a href='#pqnormAsymp'><p>Asymptotic Approximations of Extreme Tail 'pnorm()' and 'qnorm()'</p></a></li>
<li><a href='#qbBaha2017'><p>Accurate qbeta() values from Baharev et al (2017)'s Program</p></a></li>
<li><a href='#stirlerrM'><p>Stirling Formula Approximation Error</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>DPQ (Density, Probability, Quantile) Distribution Computations
using MPFR</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-3</td>
</tr>
<tr>
<td>VersionNote:</td>
<td>Last CRAN: 0.3-2 on 2023-12-05; 0.3-1 on 2021-05-17</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-19</td>
</tr>
<tr>
<td>Description:</td>
<td>An extension to the 'DPQ' package with computations for 'DPQ'
  (Density (pdf), Probability (cdf) and Quantile) functions, where
  the functions here partly use the 'Rmpfr' package and hence the
  underlying 'MPFR' and 'GMP' C libraries.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>DPQ (&ge; 0.5-3), Rmpfr (&ge; 0.9-0), gmp (&ge; 0.6-4), sfsmisc,
stats, graphics, methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix</td>
</tr>
<tr>
<td>SuggestsNote:</td>
<td>Matrix for its test-tools-1.R</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://specfun.r-forge.r-project.org/">https://specfun.r-forge.r-project.org/</a>,
<a href="https://r-forge.r-project.org/R/?group_id=611">https://r-forge.r-project.org/R/?group_id=611</a>,
<a href="https://r-forge.r-project.org/scm/viewvc.php/pkg/DPQmpfr/?root=specfun">https://r-forge.r-project.org/scm/viewvc.php/pkg/DPQmpfr/?root=specfun</a>,
svn://svn.r-forge.r-project.org/svnroot/specfun/pkg/DPQmpfr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://r-forge.r-project.org/tracker/?atid=2462&amp;group_id=611">https://r-forge.r-project.org/tracker/?atid=2462&amp;group_id=611</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-19 12:46:01 UTC; maechler</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-19 13:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='DPQmpfr-package'>
DPQ (Density, Probability, Quantile) Distribution Computations using MPFR
</h2><span id='topic+DPQmpfr-package'></span><span id='topic+DPQmpfr'></span>

<h3>Description</h3>

<p>An extension to the 'DPQ' package with computations for 'DPQ'
  (Density (pdf), Probability (cdf) and Quantile) functions, where
  the functions here partly use the 'Rmpfr' package and hence the
  underlying 'MPFR' and 'GMP' C libraries.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> DPQmpfr</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> DPQ (Density, Probability, Quantile) Distribution Computations using MPFR</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3-3</td>
</tr>
<tr>
 <td style="text-align: left;">
VersionNote: </td><td style="text-align: left;"> Last CRAN: 0.3-2 on 2023-12-05; 0.3-1 on 2021-05-17</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-08-19</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person("Martin","Maechler", role=c("aut","cre"),
   email="maechler@stat.math.ethz.ch", comment = c(ORCID = "0000-0002-8685-9910"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> An extension to the 'DPQ' package with computations for 'DPQ'
  (Density (pdf), Probability (cdf) and Quantile) functions, where
  the functions here partly use the 'Rmpfr' package and hence the
  underlying 'MPFR' and 'GMP' C libraries.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.6.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> DPQ (&gt;= 0.5-3), Rmpfr (&gt;= 0.9-0), gmp (&gt;= 0.6-4), sfsmisc, stats, graphics, methods, utils</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> Matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
SuggestsNote: </td><td style="text-align: left;"> Matrix for its test-tools-1.R</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://specfun.r-forge.r-project.org/,
https://r-forge.r-project.org/R/?group_id=611,
https://r-forge.r-project.org/scm/viewvc.php/pkg/DPQmpfr/?root=specfun,
svn://svn.r-forge.r-project.org/svnroot/specfun/pkg/DPQmpfr</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://r-forge.r-project.org/tracker/?atid=2462&amp;group_id=611</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Martin Maechler [aut, cre] (&lt;https://orcid.org/0000-0002-8685-9910&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
DPQmpfr-package         DPQ (Density, Probability, Quantile)
                        Distribution Computations using MPFR
algdivM                 Compute log(gamma(b)/gamma(a+b)) Accurately,
                        also via 'Rmpfr'
dbetaD94                Ding(1994) (non-central) Beta Distribution
                        Functions
dhyperQ                 Exact Hypergeometric Distribution Probabilites
dntJKBm                 Non-central t-Distribution Density
gam1M                   Compute 1/Gamma(x+1) - 1 Accurately
ldexp                   Numeric / Mpfr Utilities for DPQmpfr
lgamma1pM               Compute log( Gamma(x+1) ) Arbitrarily (MPFR)
                        Accurately
pbeta_ser               Beta Distribution Function - 'BPSER' Series
                        Expansion from TOMS 708
pnormAsymp              Asymptotic Approximations of Extreme Tail
                        'pnorm()' and 'qnorm()'
pnormL_LD10             Bounds for 1-Phi(.) - Mill's Ratio related
                        Bounds for pnorm()
qbBaha2017              Accurate qbeta() values from Baharev et al
                        (2017)'s Program
stirlerrM               Stirling Formula Approximation Error
</pre>


<h3>Author(s)</h3>

<p>Martin Maechler [aut, cre] (&lt;https://orcid.org/0000-0002-8685-9910&gt;)
</p>
<p>Maintainer: Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;
</p>


<h3>See Also</h3>

<p>Packages <span class="pkg"><a href="DPQ.html#topic+DPQ-package">DPQ</a></span>,
<span class="pkg"><a href="Rmpfr.html#topic+Rmpfr-package">Rmpfr</a></span> are both used by this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## An example how mpfr-numbers  "just work" with reasonable R functions:
.srch &lt;- search() ; doAtt &lt;- is.na(match("Rmpfr:package", .srch))
if(doAtt) require(Rmpfr)
nu.s &lt;- 2^seqMpfr(mpfr(-30, 64), mpfr(100, 64), by = 1/mpfr(4, 64))
b0 &lt;- DPQ::b_chi(nu.s)
b1 &lt;- DPQ::b_chi(nu.s, one.minus=TRUE)
stopifnot(inherits(b0,"mpfr"), inherits(b1, "mpfr"),
          b0+b1 == 1,  diff(log(b1)) &lt; 0)
plot(nu.s,          log(b1),  type="l", log="x")
plot(nu.s[-1], diff(log(b1)), type="l", log="x")
if(doAtt) # detach the package(s) we've attached above
  for(pkg in setdiff(search(), .srch)) detach(pkg, character.only=TRUE)
</code></pre>

<hr>
<h2 id='algdivM'>Compute log(gamma(b)/gamma(a+b)) Accurately, also via <span class="pkg">Rmpfr</span></h2><span id='topic+algdivM'></span>

<h3>Description</h3>

<p>Computes </p>
<p style="text-align: center;"><code class="reqn">\code{algdiv(a,b)} := \log \frac{\Gamma(b)}{\Gamma(a+b)} = \log
    \Gamma(b) - \log\Gamma(a+b) = \code{lgamma(b) - lgamma(a+b)}</code>
</p>

<p>in a numerically stable way.
</p>
<p>The name &lsquo;algdiv&rsquo; is from the auxiliary function in <span class="rlang"><b>R</b></span>'s (TOMS 708) implementation of
<code><a href="stats.html#topic+pbeta">pbeta</a>()</code>.
As package <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a> provides <span class="rlang"><b>R</b></span>'s Mathlib (double precision) as <span class="rlang"><b>R</b></span>
function <code>algdiv()</code>, we append &lsquo;M&rsquo; to show the reliance on
the <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
algdivM(a, b, usePr = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="algdivM_+3A_a">a</code>, <code id="algdivM_+3A_b">b</code></td>
<td>
<p>numeric or numeric-alike vectors (recycled to the same length
if needed), typically inheriting from <code>class</code> <code>"mpfr"</code>.</p>
</td></tr>
<tr><td><code id="algdivM_+3A_usepr">usePr</code></td>
<td>
<p>positive integer specifying the precision in <b>bit</b>s, or
<code><a href="base.html#topic+NULL">NULL</a></code> when a smart default will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this is also useful to compute the Beta function
</p>
<p style="text-align: center;"><code class="reqn">B(a,b) = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}.</code>
</p>

<p>Clearly,
</p>
<p style="text-align: center;"><code class="reqn">\log B(a,b) = \log\Gamma(a) + \mathrm{algdiv(a,b)}
                    = \log\Gamma(a) - \mathrm{logQab}(a,b).</code>
</p>

<p>In our &lsquo;<span class="file">../tests/qbeta-dist.R</span>&rsquo; file, we look into computing
<code class="reqn">\log(p B(p,q))</code> accurately for
<code class="reqn">p \ll q</code> .
</p>
<p>We are proposing a nice solution there. 
<br /> How is this related to <code>algdiv()</code> ?
</p>
<p>Additionally, we have defined
</p>
<p style="text-align: center;"><code class="reqn">Qab = Q_{a,b} := \frac{\Gamma(a+b),\Gamma(b)},</code>
</p>

<p>such that <code class="reqn">\code{logQab(a,b)} := \log Qab(a,b)</code>
fulfills simply
</p>
<p style="text-align: center;"><code class="reqn">\code{logQab(a,b)} = - \code{algdiv(a,b)}</code>
</p>

<p>see <code><a href="DPQ.html#topic+logQab_asy">logQab_asy</a></code> from package <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>.
</p>


<h3>Value</h3>

<p>a numeric vector of length <code>max(length(a), length(b))</code> (if neither
is of length 0, in which case the result has length 0 as well).
</p>


<h3>Author(s)</h3>

<p>Martin Maechler (for the <span class="pkg">Rmpfr</span> version).</p>


<h3>References</h3>

<p>Didonato, A. and Morris, A., Jr, (1992)
Algorithm 708: Significant digit computation of the incomplete beta
function ratios,
<em>ACM Transactions on Mathematical Software</em> <b>18</b>, 360&ndash;373. 
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+gamma">gamma</a></code>, <code><a href="base.html#topic+beta">beta</a></code>;
the (double precision) version <code><a href="DPQ.html#topic+algdiv">algdiv</a>()</code> in <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>,
and also in <span class="pkg">DPQ</span>, the asymptotic approximation
<code><a href="DPQ.html#topic+logQab_asy">logQab_asy</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Qab &lt;- algdivM(2:3, 8:14)
cbind(a = 2:3, b = 8:14, Qab) # recycling with a warning

## algdivM()  and my  logQab_asy()  give *very* similar results for largish b:
(lQab &lt;- DPQ::logQab_asy(3, 100))
all.equal( - algdivM(3, 100), lQab, tolerance=0) # 1.283e-16 !!
## relative error
1 + lQab/ algdivM(3, 1e10) # 0 (64b F 30 Linux; 2019-08-15)

## in-and outside of "certified" argument range {b &gt;= 8}:
a. &lt;- c(1:3, 4*(1:8))/32
b. &lt;- seq(1/4, 20, by=1/4)
ad &lt;- t(outer(a., b., algdivM))
## direct computation:
f.algdiv0 &lt;- function(a,b) lgamma(b) - lgamma(a+b)
f.algdiv1 &lt;- function(a,b) lgamma(b) - lgamma(a+b)
ad.d &lt;- t(outer(a., b., f.algdiv0))

matplot (b., ad.d, type = "o", cex=3/4,
         main = quote(log(Gamma(b)/Gamma(a+b)) ~"  vs.  algdivM(a,b)"))
mtext(paste0("a[1:",length(a.),"] = ",
        paste0(paste(head(paste0(formatC(a.*32), "/32")), collapse=", "), ", .., 1")))
matlines(b., ad,   type = "l", lwd=4, lty=1, col=adjustcolor(1:6, 1/2))
abline(v=1, lty=3, col="midnightblue")
# The larger 'b', the more accurate the direct formula wrt algdivM()
all.equal(ad[b. &gt;= 1,], ad.d[b. &gt;= 1,]       )# 1.5e-5
all.equal(ad[b. &gt;= 2,], ad.d[b. &gt;= 2,], tol=0)# 3.9e-9
all.equal(ad[b. &gt;= 4,], ad.d[b. &gt;= 4,], tol=0)# 4.6e-13
all.equal(ad[b. &gt;= 6,], ad.d[b. &gt;= 6,], tol=0)# 3.0e-15
all.equal(ad[b. &gt;= 8,], ad.d[b. &gt;= 8,], tol=0)# 2.5e-15 (not much better)
</code></pre>

<hr>
<h2 id='betaD94'>Ding(1994) (non-central) Beta Distribution Functions</h2><span id='topic+dbetaD94'></span><span id='topic+pbetaD94'></span><span id='topic+qbetaD94'></span>

<h3>Description</h3>


<p>The three functions &quot;p&quot; (cumulative distribution, CDF), &quot;d&quot; (density
(PDF)), and &quot;q&quot; (quantile) use Ding(1994)'s algorithm A, B, and C, respectively,
each of which implements a recursion formula using only simple
arithmetic and <code><a href="base.html#topic+log">log</a></code> and <code><a href="base.html#topic+exp">exp</a></code>.
</p>
<p>These are particularly useful also for using with high precision
<code>"mpfr"</code> numbers from the <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a> CRAN package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbetaD94(x, shape1, shape2, ncp = 0, log = FALSE,
         eps = 1e-10, itrmax = 100000L, verbose = FALSE)
pbetaD94(q, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE,
	 log_scale = (a * b &gt; 0) &amp;&amp; (a + b &gt; 100 || c &gt;= 500),
         eps = 1e-10, itrmax = 100000L, verbose = FALSE)

qbetaD94(p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE,
	 log_scale = (a * b &gt; 0) &amp;&amp; (a + b &gt; 100 || c &gt;= 500),
         delta = 1e-6,
         eps = delta^2,
         itrmax = 100000L,
         iterN = 1000L,
         verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betaD94_+3A_x">x</code>, <code id="betaD94_+3A_q">q</code></td>
<td>
<p>numeric vector of values in <code class="reqn">[0,1]</code> as beta variates.</p>
</td></tr>
<tr><td><code id="betaD94_+3A_shape1">shape1</code>, <code id="betaD94_+3A_shape2">shape2</code></td>
<td>
<p>the two shape parameters of the beta
distribution, must be positive.</p>
</td></tr>
<tr><td><code id="betaD94_+3A_ncp">ncp</code></td>
<td>
<p>the noncentrality parameter; by default zero for the
(<em>central</em>) beta distribution; if positive, we have a noncentral
beta distribution.</p>
</td></tr>
<tr><td><code id="betaD94_+3A_p">p</code></td>
<td>
<p>numeric vector of probabilities, <code><a href="base.html#topic+log">log</a>()</code>ged in
case <code>log.p</code> is true.</p>
</td></tr>
<tr><td><code id="betaD94_+3A_log">log</code>, <code id="betaD94_+3A_log.p">log.p</code></td>
<td>
<p>logical indicating if the density or probability
values should be <code><a href="base.html#topic+log">log</a>()</code>ged.</p>
</td></tr>
<tr><td><code id="betaD94_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical indicating if the lower or upper tail
probability should be computed, or for <code>qbeta*()</code> are provided.</p>
</td></tr>
<tr><td><code id="betaD94_+3A_eps">eps</code></td>
<td>
<p>a non-negative number specifying the desired accuracy for
computing F() and f().</p>
</td></tr>
<tr><td><code id="betaD94_+3A_itrmax">itrmax</code></td>
<td>
<p>the maximal number of steps for computing F() and f().</p>
</td></tr>
<tr><td><code id="betaD94_+3A_delta">delta</code></td>
<td>
<p>[For <code>qbeta*()</code>:] non-negative number indicating the
desired accuracy for computing <code class="reqn">x_p</code> (the root of <code class="reqn">pbeta*() == p</code>),
i.e., the convergence tolerance for the Newton iterations.   This sets
default <code>eps = delta^2</code> which is sensible but may be too small,
such that <code>eps</code> should be specified in addition to <code>delta</code>.</p>
</td></tr>
<tr><td><code id="betaD94_+3A_itern">iterN</code></td>
<td>
<p>[For <code>qbeta*()</code>:] The maximal number of <b>N</b>ewton iterations.</p>
</td></tr>
<tr><td><code id="betaD94_+3A_log_scale">log_scale</code></td>
<td>
<p>logical indicating if most of the computations should
happen in <code><a href="base.html#topic+log">log</a></code> scale, which protects from &ldquo;early&rdquo;
overflow and underflow but takes more computations.  The current
default is somewhat <em>arbitrary</em>, still derived from the facts that
<code><a href="base.html#topic+gamma">gamma</a>(172)</code> overflows to <code>Inf</code> already and
<code><a href="base.html#topic+exp">exp</a>(-750)</code> underflows to <code>0</code> already.</p>
</td></tr>
<tr><td><code id="betaD94_+3A_verbose">verbose</code></td>
<td>
<p>logical (or integer) indicating the amount of
diagnostic output during computation; by default none.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In all three cases, a numeric vector with the same attributes as
<code>x</code> (or <code>q</code> respectively),
containing (an approximation) to the correponding beta distribution function.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, notably <code>log_scale</code> was not part of Ding's
proposals.</p>


<h3>References</h3>

<p>Cherng G. Ding (1994) 
On the computation of the noncentral beta distribution.
<em>Computational Statistics &amp; Data Analysis</em> <b>18</b>, 449&ndash;455.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pbeta">pbeta</a></code>.  Package <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a>'s <code><a href="Rmpfr.html#topic+pbetaI">pbetaI</a>()</code> needs
both <code>shape1</code> and <code>shape2</code> to be integer but is typically more
efficient than the current <code>pbetaD94()</code> implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
          
## Low precision (eps, delta) values as "e.g." in Ding(94): ------------------

## Compare with  Table 3  of  Baharev_et_al 2017 %% ===&gt; ./qbBaha2017.Rd &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
aa &lt;- c(0.5, 1, 1.5, 2, 2.5, 3, 5, 10, 25)
bb &lt;- c(1:15, 10*c(2:5, 10, 25, 50))
utime &lt;-
 qbet &lt;- matrix(NA_real_, length(aa), length(bb),
                dimnames = list(a = formatC(aa), b = formatC(bb)))
(doExtras &lt;- DPQmpfr:::doExtras())
if(doExtras) qbetL &lt;- utimeL &lt;- utime

p &lt;- 0.95
delta &lt;- 1e-4
eps   &lt;- 1e-6
system.t.usr &lt;- function(expr)
  system.time(gcFirst = FALSE, expr)[["user.self"]]

system.time(
for(ia in seq_along(aa)) {
    a &lt;- aa[ia]; cat("\n--==--\na=",a,":\n")
    for(ib in seq_along(bb)) {
        b &lt;- bb[ib]; cat("\n&gt;&gt; b=",b,"\n")
        utime [ia, ib] &lt;- system.t.usr(
          qbet[ia, ib] &lt;-   qbetaD94(p, a, b, ncp = 0, delta=delta, eps=eps, verbose = 2))
        if(doExtras)
          utimeL[ia, ib] &lt;- system.t.usr(
           qbetL[ia, ib] &lt;-   qbetaD94(p, a, b, ncp = 0, delta=delta, eps=eps,
                                       verbose = 2, log_scale=TRUE))
    }
    cat("\n")
}
)# system.time(.): ~ 1 sec (lynne i7-7700T, Fedora 32, 2020)
sum(print(table(round(1000*utime)))) # lynne .. :
##  0  1  2  3  4  5  6  7  8  9 10 11 14 15 16 29
## 53 94 15  3  3 12  2  2  2  2  1  2  3  1  2  1
## [1] 198
if(doExtras) print(sum(print(table(round(1000*utimeL))))) # lynne .. :
</code></pre>

<hr>
<h2 id='dhyperQ'>Exact Hypergeometric Distribution Probabilites</h2><span id='topic+dhyperQ'></span><span id='topic+phyperQ'></span><span id='topic+phyperQall'></span>

<h3>Description</h3>


<p>Computes <b>exact</b> probabilities for the hypergeometric distribution
(see, e.g., <code><a href="stats.html#topic+dhyper">dhyper</a>()</code> in <span class="rlang"><b>R</b></span>), using package <a href="https://CRAN.R-project.org/package=gmp"><span class="pkg">gmp</span></a>'s
big integer and rational numbers, notably <code><a href="gmp.html#topic+chooseZ">chooseZ</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhyperQ(x, m, n, k)
phyperQ(x, m, n, k, lower.tail=TRUE)
phyperQall(m, n, k, lower.tail=TRUE)
</code></pre>


<h3>Arguments</h3>


<table role = "presentation">
<tr><td><code id="dhyperQ_+3A_x">x</code></td>
<td>
<p>the number of white balls drawn without replacement from an urn
which contains both black and white balls.</p>
</td></tr>
<tr><td><code id="dhyperQ_+3A_m">m</code></td>
<td>
<p>the number of white balls in the urn.</p>
</td></tr>
<tr><td><code id="dhyperQ_+3A_n">n</code></td>
<td>
<p>the number of black balls in the urn.</p>
</td></tr>
<tr><td><code id="dhyperQ_+3A_k">k</code></td>
<td>
<p>the number of balls drawn from the urn, hence must be in
<code class="reqn">0,1,\dots, m+n</code>.</p>
</td></tr>
<tr><td><code id="dhyperQ_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical indicating if the lower or upper tail
probability should be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a bigrational (class <code>"bigq"</code> from package <a href="https://CRAN.R-project.org/package=gmp"><span class="pkg">gmp</span></a>) vector
&ldquo;as&rdquo; <code>x</code>; currently of length one (as all the function
arguments must be &ldquo;scalar&rdquo;, currently).
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="gmp.html#topic+chooseZ">chooseZ</a></code> (pkg <a href="https://CRAN.R-project.org/package=gmp"><span class="pkg">gmp</span></a>),
and <span class="rlang"><b>R</b></span>'s own <code><a href="stats.html#topic+Hypergeometric">Hypergeometric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## dhyperQ() is simply
 function (x, m, n, k)
 {
    stopifnot(k - x == as.integer(k - x))
    chooseZ(m, x) * chooseZ(n, k - x) / chooseZ(m + n, k)
 }

# a case where  phyper(11, 15, 0, 12, log=TRUE) gave 'NaN'
(phyp5.0.12 &lt;- cumsum(dhyperQ(0:12, m=15,n=0,k=12)))
stopifnot(phyp5.0.12 == c(rep(0, 12), 1))

for(x in 0:9)
  stopifnot(phyperQ(x, 10,7,8) +
            phyperQ(x, 10,7,8, lower.tail=FALSE) == 1)

(ph. &lt;- phyperQall(m=10, n=7, k=8))
## Big Rational ('bigq') object of length 8:
## [1] 1/2431    5/374     569/4862  2039/4862 3803/4862 4685/4862 4853/4862 1
stopifnot(identical(gmp::c_bigq(list(0, ph.)),
                    1- c(phyperQall(10,7,8, lower.tail=FALSE), 0)))

(doExtras &lt;- DPQmpfr:::doExtras())
if(doExtras) { # too slow for standard testing
 k &lt;- 5000
 system.time(ph &lt;-   phyper(k, 2*k, 2*k, 2*k)) #   0 (&lt; 0.001 sec)
 system.time(phQ &lt;- phyperQ(k, 2*k, 2*k, 2*k)) # 5.6 (was 6.3) sec
 ## Relative error of R's phyper()
 stopifnot(print(gmp::asNumeric(1 - ph/phQ)) &lt; 1e-14) # seen 1.063e-15
}
</code></pre>

<hr>
<h2 id='dnt'>Non-central t-Distribution Density</h2><span id='topic+dntJKBm'></span><span id='topic+dtWVm'></span>

<h3>Description</h3>

<p><code>dntJKBm</code> is a fully <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a>-ified vectorized version of

<code><a href="DPQ.html#topic+dntJKBf">dntJKBf</a>()</code> from <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>; see there.
</p>
<p><code>dtWVm(x, df, ncp)</code> computes the density function <code class="reqn">f(x)</code> of the t distribution with
<code>df</code> degrees of freedom and non-centrality parameter <code>ncp</code>,
according to Wolfgang Viechtbauer's proposal in 2002, using an asymptotic
formula for &ldquo;large&rdquo; <code>df</code><code class="reqn"> = \nu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dntJKBm(x, df, ncp, log = FALSE, M = 1000) # __ Deprecated __ use DPQ :: dntJKBf
dtWVm  (x, df, ncp, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dnt_+3A_x">x</code></td>
<td>
<p>numeric or <code>"<a href="Rmpfr.html#topic+mpfr-class">mpfr</a>"</code> vector.</p>
</td></tr>
<tr><td><code id="dnt_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt; 0</code>, maybe non-integer).  <code>df = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="dnt_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter <code class="reqn">\delta</code>;
If omitted, use the central t distribution.</p>
</td></tr>
<tr><td><code id="dnt_+3A_log">log</code></td>
<td>
<p>as in <code><a href="stats.html#topic+dt">dt</a>()</code>, a logical indicating if
<code class="reqn">\log(f(x,*))</code> should be returned instead of <code class="reqn">f(x,*)</code>.</p>
</td></tr>
<tr><td><code id="dnt_+3A_m">M</code></td>
<td>
<p>the number of terms to be used, a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="DPQ.html#topic+dtWV">dtWV</a></code>'s details (package <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>).
</p>
<p>As <span class="pkg">DPQ</span>'s <code><a href="DPQ.html#topic+dntJKBf">dntJKBf</a>()</code> <b>is</b> already fully
mpfr-ized, <code>dntJKBm()</code> is deprecated.
</p>


<h3>Value</h3>

<p>an <code><a href="Rmpfr.html#topic+mpfr-class">mpfr</a></code> vector of the same length as the maximum
of the lengths of <code>x, df, ncp</code>.
</p>


<h3>Note</h3>

<p>Package <span class="pkg">DPQ</span>'s <code><a href="DPQ.html#topic+dntJKBf">dntJKBf</a>()</code> <b>is</b> already fully
mpfr-ized, and hence <code>dntJKBm()</code> is redundant, and therefore deprecated.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><span class="rlang"><b>R</b></span>'s <code><a href="stats.html#topic+dt">dt</a></code>, and package <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>'s
<code><a href="DPQ.html#topic+dntJKBf">dntJKBf</a>()</code> and <code><a href="DPQ.html#topic+dtWV">dtWV</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- seq(0, 10, len = 21)
ncp &lt;- seq(0, 6, len = 31)
dt3R  &lt;- outer(tt, ncp, dt  , df = 3)
dt3WV &lt;- outer(tt, ncp, dtWVm, df = 3)
all.equal(dt3R, dt3WV) # rel.err 0.00063
dt25R  &lt;- outer(tt, ncp, dt  , df = 25)
dt25WV &lt;- outer(tt, ncp, dtWVm, df = 25)
all.equal(dt25R, dt25WV) # rel.err 1.1e-5

x &lt;- -10:700
fx  &lt;- dt  (x, df = 22, ncp =100)
lfx &lt;- dt  (x, df = 22, ncp =100, log=TRUE)
lfV &lt;- dtWVm(x, df = 22, ncp =100, log=TRUE)

head(lfx, 15) # shows that R's dt(*, log=TRUE) implementation is "quite suboptimal"

## graphics
opa &lt;- par(no.readonly=TRUE)
par(mar=.1+c(5,4,4,3), mgp = c(2, .8,0))
plot(fx ~ x, type="l")
par(new=TRUE) ; cc &lt;- c("red", adjustcolor("orange", 0.4))
plot(lfx ~ x, type = "o", pch=".", col=cc[1], cex=2, ann=FALSE, yaxt="n")
sfsmisc::eaxis(4, col=cc[1], col.axis=cc[1], small.args = list(col=cc[1]))
lines(x, lfV, col=cc[2], lwd=3)
dtt1 &lt;- "      dt"; dtt2 &lt;- "(x, df=22, ncp=100"; dttL &lt;- paste0(dtt2,", log=TRUE)")
legend("right", c(paste0(dtt1,dtt2,")"), paste0(c(dtt1,"dtWVm"), dttL)),
       lty=1, lwd=c(1,1,3), col=c("black", cc), bty = "n")
par(opa) # reset


## For dntJKBm(), see  example(dntJKBf, package="DPQ")
</code></pre>

<hr>
<h2 id='DPQmpfr-utils'>Numeric / Mpfr Utilities for DPQmpfr</h2><span id='topic+ldexp'></span>

<h3>Description</h3>

<p>Utilities for package <a href="https://CRAN.R-project.org/package=DPQmpfr"><span class="pkg">DPQmpfr</span></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldexp(f, E)
</code></pre>


<h3>Arguments</h3>


<table role = "presentation">
<tr><td><code id="DPQmpfr-utils_+3A_f">f</code></td>
<td>
<p>&lsquo;fraction&rsquo;, as such with absolute value in <code class="reqn">[0.5, 1)</code>, but can
be any numbers.</p>
</td></tr>
<tr><td><code id="DPQmpfr-utils_+3A_e">E</code></td>
<td>
<p>integer-valued exponent(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ldexp()</code> is a simple wrapper, either calling
<code>DPQ::<a href="DPQ.html#topic+ldexp">ldexp</a></code> from <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a> or
<code><a href="Rmpfr.html#topic+ldexpMpfr">ldexpMpfr</a></code> from the <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a> package,
</p>
<p style="text-align: center;"><code class="reqn"> ldexp(f, E) := f \times 2^E,</code>
</p>

<p>computed accurately and fast on typical platforms with internally binary
arithmetic.
</p>


<h3>Value</h3>


<p>either a numeric or a <code>"<a href="Rmpfr.html#topic+mpfr">mpfr</a>"</code>, depending on the type of
<code>f</code>, vector as (the recyled) combination of <code>f</code> and <code>E</code>.
</p>


<h3>See Also</h3>

<p><code><a href="DPQ.html#topic+ldexp">ldexp</a></code> from package <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a> and
<code><a href="Rmpfr.html#topic+ldexpMpfr">ldexpMpfr</a></code> from package <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ldexp(1:10, 2)
ldexp(Rmpfr::Const("pi", 96), -2:2) # =  pi * (1/4  1/2  1  2  4)
</code></pre>

<hr>
<h2 id='gam1M'>Compute  1/Gamma(x+1) - 1  Accurately</h2><span id='topic+gam1M'></span>

<h3>Description</h3>

<p>FIXME: &quot;R's own&quot; double prec version is now in package DPQ:
e.g. ~/R/Pkgs/DPQ/man/gam1.Rd
</p>
<p>FIXME2: R-only implementation is in
~/R/Pkgs/DPQ/TODO_R_versions_gam1_etc.R
</p>
<p>Computes <code class="reqn">1/\Gamma(a+1) - 1</code> accurately in <code class="reqn">[-0.5, 1.5]</code> for numeric argument <code>a</code>;
For <code>"mpfr"</code> numbers, the precision is increased intermediately such
that <code class="reqn">a+1</code> should not lose precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam1M(a, usePr = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gam1M_+3A_a">a</code></td>
<td>
<p>a numeric or numeric-alike, typically inheriting from <code>class</code> <code>"mpfr"</code>.</p>
</td></tr>
<tr><td><code id="gam1M_+3A_usepr">usePr</code></td>
<td>
<p>the precision to use; the default, <code>NULL</code>, means to use
a default which depends on <code>a</code>, specifically <code><a href="Rmpfr.html#topic+getPrec">getPrec</a>(a)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

 

<p><a href="https://dlmf.nist.gov/">https://dlmf.nist.gov/</a> states the well-know Taylor series for
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\Gamma(z)} = \sum_{k=1}^\infty c_k z^k</code>
</p>

<p>with <code class="reqn">c_1 = 1</code>,  <code class="reqn">c_2 = \gamma</code>, (Euler's gamma, <code class="reqn">\gamma = 0.5772...</code>), with
recursion <code class="reqn">c_k = (\gamma c_{k-1} - \zeta(2) c_{k-2} ... +(-1)^k \zeta(k-1) c_1) /(k-1)</code>.
</p>
<p>Hence,
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\Gamma(z+1)}    = z+1 + \sum_{k=2}^\infty c_k (z+1)^k,</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{1}{\Gamma(z+1)} -1 = z   + \gamma*(z+1)^2 + \sum_{k=3}^\infty c_k (z+1)^k.</code>
</p>

<p>Consequently, for <code class="reqn">\zeta_k := \zeta(k)</code>,
<code class="reqn">c_3 = (\gamma^2 - \zeta_2)/2</code>,
<code class="reqn">c_4 = \gamma^3/6 - \gamma \zeta_2/2 + \zeta_3/3</code>.
</p>
<pre>
  require(Rmpfr) # Const(), mpfr(), zeta()
  gam &lt;- Const("gamma", 128)
  z &lt;- zeta(mpfr(1:7, 128))
  (c3 &lt;- (gam^2 -z[2])/2)                       # -0.655878071520253881077019515145
  (c4 &lt;- (gam*c3 - z[2]*c2 + z[3])/3)           # -0.04200263503409523552900393488
  (c4 &lt;- gam*(gam^2/6 - z[2]/2) + z[3]/3)
  (c5 &lt;- (gam*c4 - z[2]*c3 + z[3]*c2 - z[4])/4) # 0.1665386113822914895017007951
  (c5 &lt;- (gam^4/6 - gam^2*z[2] + z[2]^2/2 + gam*z[3]*4/3 - z[4])/4)
</pre>


<h3>Value</h3>

<p>a numeric-alike vector like <code>a</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler building on C code of TOMS 708</p>


<h3>References</h3>

<p>TOMS 708, see <code><a href="stats.html#topic+pbeta">pbeta</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+gamma">gamma</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##' naive direct formula:
g1 &lt;- function(u) 1/gamma(u+1) - 1


##' @title gam1() from TOMS 708 -- translated to R (*and* vectorized)
##' @author Martin Maechler
gam1R &lt;- function(a, chk=TRUE) { ##  == 1/gamma(a+1) - 1  -- accurately  ONLY for  -0.5 &lt;= a &lt;= 1.5
    if(!length(a)) return(a)
    ## otherwise:
    if(chk) stopifnot(-0.5 &lt;= a, a &lt;= 1.5) # if not, the computation below is non-sense!
    d  &lt;- a - 0.5
    ## t := if(a &gt; 1/2)  a-1  else  a  ==&gt; t in [-0.5, 0.5]  &lt;==&gt;  |t| &lt;= 0.5
    R &lt;- t &lt;- a
    dP &lt;- d &gt; 0
    t[dP] &lt;- d[dP] - 0.5
    if(any(N &lt;- (t &lt; 0.))) { ## L30: */
        r &lt;- c(-.422784335098468, -.771330383816272,
               -.244757765222226, .118378989872749, 9.30357293360349e-4,
               -.0118290993445146, .00223047661158249, 2.66505979058923e-4,
               -1.32674909766242e-4)
        s1 &lt;- .273076135303957
        s2 &lt;- .0559398236957378
        t_ &lt;- t[N]
        top  &lt;- (((((((r[9] * t_ + r[8]) * t_ + r[7]) * t_ + r[6]) * t_ + r[5]) * t_ + r[4]
        ) * t_ + r[3]) * t_ + r[2]) * t_ + r[1]
        bot &lt;- (s2 * t_ + s1) * t_ + 1.
        w &lt;- top / bot
        ## if (d &gt; 0.) :
        if(length(iP &lt;- which(dP[N])))
            R[N &amp;  dP] &lt;- (t_ * w)[iP] / a[N &amp; dP]
        ## else d &lt;= 0 :
        if(length(iN &lt;- which(!dP[N])))
            R[N &amp; !dP] &lt;- a[N &amp; !dP] * (w[iN] + 0.5 + 0.5)
    }
    if(any(Z &lt;- (t == 0))) ## L10: a in {0, 1}
        R[Z] &lt;- 0.
    if(any(P &lt;- t &gt; 0)) { ## t &gt; 0;  L20: */
        p &lt;- c( .577215664901533, -.409078193005776,
               -.230975380857675, .0597275330452234, .0076696818164949,
               -.00514889771323592, 5.89597428611429e-4 )
        q &lt;- c(1., .427569613095214, .158451672430138, .0261132021441447, .00423244297896961)
        t &lt;- t[P]
        top &lt;- (((((p[7] * t + p[6])*t + p[5])*t + p[4])*t + p[3])*t + p[2])*t + p[1]
        bot &lt;- (((q[5] * t + q[4]) * t + q[3]) * t + q[2]) * t + 1.
        w &lt;- top / bot
        ## if (d &gt; 0.) ## L21: */
        if(length(iP &lt;- which(dP[P])))
            R[P &amp;  dP] &lt;- t[iP] / a[P &amp;  dP] * (w[iP] - 0.5 - 0.5)
        ## else d &lt;= 0 :
        if(length(iN &lt;- which(!dP[P])))
            R[P &amp; !dP] &lt;- a[P &amp; !dP] * w[iN]
    }
    R
} ## gam1R()

u &lt;- seq(-.5, 1.5, by=1/16); set.seed(1); u &lt;- sample(u) # permuted (to check logic)
g11   &lt;- vapply(u, gam1R, 1) # [-.5, 1.5]  == the interval for which the above gam1() was made
gam1. &lt;- gam1R(u)
cbind(u, gam1., D = sfsmisc::relErrV(gam1., g1(u)))[order(u),]
                               # looks "too good", as we are not close (but different) to {0, 1}
stopifnot( identical(g11, gam1.) )
           all.equal(g1(u), gam1., tolerance = 0) # 6.7e-16  ("too good", see above)
stopifnot( all.equal(g1(u), gam1.) )

## Comparison using Rmpfr; slightly extending [-.5, 1.5] interval (and getting much closer to {0,1})
u &lt;- seq(-0.525, 1.525, length.out = 2001)
uM &lt;- Rmpfr::mpfr(u, 128)
gam1M. &lt;- gam1M(uM)
relE &lt;- Rmpfr::asNumeric(sfsmisc::relErrV(gam1M., gam1R(u, chk=FALSE)))
rbind(rErr = summary(relE),
     `|rE|` = summary(abs(relE)))
##            Min.    1st Qu.    Median      Mean   3rd Qu.     Max.
## rErr -3.280e-15 -3.466e-16 1.869e-17 1.526e-16 4.282e-16 1.96e-14
## |rE|  1.343e-19  2.363e-16 3.861e-16 6.014e-16 6.372e-16 1.96e-14
stopifnot(max(abs(relE)) &lt; 1e-13)

relEtit &lt;- expression("Relative Error of " ~~ gam1(u) %~%{} == frac(1, Gamma(u+1)) - 1) #%
plot(relE ~ u, type="l", ylim = c(-1,1) * 2.5e-15, main = relEtit)
grid(lty = 3); abline(v = c(-.5, 1.5), col = adjustcolor(4, 1/2), lty=2, lwd=2)

## what about the direct formula -- how bad is it really ?
relED &lt;- Rmpfr::asNumeric(sfsmisc::relErrV(gam1M., g1(u)))

plot(relE ~ u, type="l", ylim = c(-1,1) * 1e-14, main = relEtit)
lines(relED ~ u, col = adjustcolor(2, 1/2), lwd = 2); abline(v = (-1:3)/2, lty=2, col="orange3")
mtext("comparing with direct formula   1/gamma(u+1) - 1", col=2, cex=3/4)
legend("top", c("gam1R(u)", "1/gamma(u+1) - 1"), col = 1:2, lwd=1:2, bty="n")
## direct is clearly *worse* , but not catastrophical
</code></pre>

<hr>
<h2 id='lgamma1pM'>Compute  log( Gamma(x+1) ) Arbitrarily (MPFR) Accurately</h2><span id='topic+gamln1'></span><span id='topic+lgamma1pM'></span>

<h3>Description</h3>

<p>Computes <code class="reqn">\log \Gamma(x+1)</code> accurately notably when <code class="reqn">|x| \ll 1</code>.

For <code>"mpfr"</code> numbers, the precision is increased intermediately such
that <code class="reqn">a+1</code> should not lose precision.
</p>
<p><span class="rlang"><b>R</b></span>'s &quot;own&quot; double prec version is
soon 
available in package in <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>,


under the name <code>gamln1()</code> (from TOMS 708).

</p>




<h3>Usage</h3>

<pre><code class='language-R'>
lgamma1pM(a, usePr = NULL, DPQmethod = c("lgamma1p", "algam1"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lgamma1pM_+3A_a">a</code></td>
<td>
<p>a numeric or numeric-alike vector, typically inheriting from
<code>class</code> <code>"mpfr"</code>.</p>
</td></tr>
<tr><td><code id="lgamma1pM_+3A_usepr">usePr</code></td>
<td>
<p>positive integer specifying the precision in <b>bit</b>s, or
<code><a href="base.html#topic+NULL">NULL</a></code> when a smart default will be used.</p>
</td></tr>
<tr><td><code id="lgamma1pM_+3A_dpqmethod">DPQmethod</code></td>
<td>
<p>a character string; must be the name of an
<code>lgamma1p()</code>-alike function from package <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>.  It will
be called in case of <code>is.numeric(a)</code> (and when <span class="pkg">DPQ</span> is available).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric-alike vector like <code>a</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>TOMS 708, see <code><a href="stats.html#topic+pbeta">pbeta</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+lgamma">lgamma</a>()</code> (and <code>gamma()</code> (same page)),
and our <code><a href="#topic+algdivM">algdivM</a>()</code>; further, package <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>'s
<code><a href="DPQ.html#topic+lgamma1p">lgamma1p</a>()</code> and
(if already available) <code>gamln1()</code>. 

</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Package {DPQ}'s  lgamma1p():
lgamma1p &lt;- DPQ::lgamma1p
lg1 &lt;- function(u) lgamma(u+1) # the simple direct form
u &lt;- seq(-.5, 1.5, by=1/16); set.seed(1); u &lt;- sample(u) # permuted (to check logic)
g11   &lt;- vapply(u, lgamma1p, numeric(1))
lgamma1p. &lt;- lgamma1p(u)
all.equal(lg1(u), g11, tolerance = 0) # see 3.148e-16
stopifnot(exprs = {
    all.equal(lg1(u), g11, tolerance = 2e-15)
    identical(g11, lgamma1p.)
})

## Comparison using Rmpfr; slightly extending the [-.5, 1.5] interval:
u &lt;- seq(-0.525, 1.525, length.out = 2001)
lg1p  &lt;- lgamma1pM(   u)
lg1pM &lt;- lgamma1pM(Rmpfr::mpfr(u, 128))
asNumeric &lt;- Rmpfr::asNumeric
relErrV   &lt;- sfsmisc::relErrV
if(FALSE) { # DPQ "latest" version __FIXME__
lng1  &lt;- DPQ::lngam1(u)
relE &lt;- asNumeric(relErrV(lg1pM, cbind(lgamma1p = lg1p, lngam1 = lng1)))
} else {
relE &lt;- asNumeric(relErrV(lg1pM, cbind(lgamma1p = lg1p)))#, lngam1 = lng1)))
}

## FIXME: lgamma1p() is *NOT* good around u =1. -- even though it should
##        and the R-only vs (not installed) *does* "work" (is accurate there) ?????
## --&gt; ~/R/Pkgs/DPQ/TODO_R_versions_gam1_etc.R
if(FALSE) {
matplot(u, relE, type="l", ylim = c(-1,1) * 2.5e-15,
     main = expression("relative error of " ~~ lgamma1p(u) == log( Gamma(u+1) )))
} else {
plot(relE ~ u, type="l", ylim = c(-1,1) * 2.5e-15,
     main = expression("relative error of " ~~ lgamma1p(u) == log( Gamma(u+1) )))
}
grid(lty = 3); abline(v = c(-.5, 1.5), col = adjustcolor(4, 1/2), lty=2, lwd=2)

## what about the direct formula -- how bad is it really ?
relED &lt;- asNumeric(relErrV(lg1pM, lg1(u)))
lines(relED ~ u, col = adjustcolor(2, 1/2), lwd = 2)
</code></pre>

<hr>
<h2 id='pbeta_ser'>Beta Distribution Function &ndash; &lsquo;BPSER&rsquo; Series Expansion from TOMS 708</h2><span id='topic+pbeta_ser'></span>

<h3>Description</h3>

<p>Compute a version of the Beta cumulative distribution function
(<code><a href="stats.html#topic+pbeta">pbeta</a>()</code> in <span class="rlang"><b>R</b></span>), namely using the series expansion, named
<code>BPSER()</code>, from &ldquo;TOMS 708&rdquo;, i.e., Didonato and Morris (1992).
</p>
<p>This &ldquo;pure R&rdquo; function exists for didactical or documentational reasons on one hand,
as <span class="rlang"><b>R</b></span>'s own <code><a href="stats.html#topic+pbeta">pbeta</a>()</code> uses this expansion when appropriate and
other algorithms otherwise.
On the other hand, using high precision <code>q</code> and MPFR arithmetic (via
package <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a>) may allow to get highly accurate <code>pbeta()</code>
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbeta_ser(q, shape1, shape2, log.p = FALSE, eps = 1e-15, errPb = 0, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pbeta_ser_+3A_q">q</code>, <code id="pbeta_ser_+3A_shape1">shape1</code>, <code id="pbeta_ser_+3A_shape2">shape2</code></td>
<td>
<p>quantiles and shape parameters of the Beta
distribution, <code>q</code> typically in <code class="reqn">[0,1]</code>, see <code><a href="stats.html#topic+pbeta">pbeta</a></code>.
Here, <code>q</code> <em>must be scalar</em>, i.e., of length one, and may inherit from
<code>class</code> <code>"mpfr"</code>, in order to be more accurate (than with the
double precision computations).</p>
</td></tr>
<tr><td><code id="pbeta_ser_+3A_log.p">log.p</code></td>
<td>
<p>if TRUE, probabilities <code>p</code> are given as <code>log(p)</code>.</p>
</td></tr>
<tr><td><code id="pbeta_ser_+3A_eps">eps</code></td>
<td>
<p>non-negative number; <code>tol &lt;- eps/shape1</code> will be used for
convergence checks in the series computations.</p>
</td></tr>
<tr><td><code id="pbeta_ser_+3A_errpb">errPb</code></td>
<td>
<p>an integer code, typically in <code>-2, -1, 0</code> to determine how
warnings on convergence failures are handled.</p>
</td></tr>
<tr><td><code id="pbeta_ser_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if console output about intermediate
results should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pbeta_ser()</code> crucially needs three auxiliary functions which we
&ldquo;mpfr-ized&rdquo; as well: <code><a href="#topic+gam1M">gam1M</a>()</code>,
<code><a href="#topic+lgamma1pM">lgamma1pM</a>()</code>, and <code><a href="#topic+algdivM">algdivM</a></code>.
</p>


<h3>Value</h3>

<p>An approximation to the Beta probability  <code class="reqn">P[X \le q]</code>
for <code class="reqn"> X \sim B(a,b),</code> (where <code class="reqn">a=</code><code>shape1</code>, and <code class="reqn">b=</code><code>shape2</code>).
</p>


<h3>Author(s)</h3>

<p>Didonato and Morris and R Core team;
separate packaging by Martin Maechler.
</p>


<h3>References</h3>

<p>Didonato, A. and Morris, A., Jr, (1992)
Algorithm 708: Significant digit computation of the incomplete beta
function ratios,
<em>ACM Transactions on Mathematical Software</em> <b>18</b>, 360&ndash;373; 
<a href="https://doi.org/10.1145/131766.131776">doi:10.1145/131766.131776</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pbeta">pbeta</a></code>, <span class="pkg">DPQmpfr</span>'s own <code><a href="#topic+pbetaD94">pbetaD94</a></code>;
even more <code>pbeta()</code> approximations in package <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>, e.g.,
<code><a href="DPQ.html#topic+pnbetaAS310">pnbetaAS310</a></code>, or <code><a href="DPQ.html#topic+pbetaRv1">pbetaRv1</a></code>.
</p>
<p>In addition, for integer shape parameters, the potentially &ldquo;fully accurate&rdquo;
finite sum base <code><a href="Rmpfr.html#topic+pbetaI">pbetaI</a>()</code> in package <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(p. &lt;- pbeta_ser(1/2, shape1 = 2, shape2 = 3, verbose=TRUE))
(lp &lt;- pbeta_ser(1/2, shape1 = 2, shape2 = 3, log.p = TRUE))
          all.equal(lp, log(p.), tolerance=0) # 1.48e-16
stopifnot(all.equal(lp, log(p.), tolerance = 1e-13))

## Using  Vectorize() in order to allow vector 'q' e.g. for curve():
str(pbetaSer &lt;- Vectorize(pbeta_ser, "q"))
curve(pbetaSer(x, 1.5, 4.5)); abline(h=0:1, v=0:1, lty=2, col="gray")
curve(pbeta   (x, 1.5, 4.5), add=TRUE, col = adjustcolor(2, 1/4), lwd=3)

## now using mpfr-numbers:
half &lt;- 1/Rmpfr::mpfr(2, 256)
(p2 &lt;- pbeta_ser(half, shape1 = 1, shape2 = 123))

</code></pre>

<hr>
<h2 id='pnormLU'>Bounds for 1-Phi(.) &ndash; Mill's Ratio related Bounds for pnorm()</h2><span id='topic+pnormL_LD10'></span><span id='topic+pnormU_S53'></span>

<h3>Description</h3>

<p>Bounds for <code class="reqn">1 - \Phi(x)</code>, i.e., <code><a href="stats.html#topic+pnorm">pnorm</a>(x, *,
    lower.tail=FALSE)</code>, typically related to Mill's Ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
pnormL_LD10(x, lower.tail = FALSE, log.p = FALSE)
pnormU_S53 (x, lower.tail = FALSE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnormLU_+3A_x">x</code></td>
<td>
<p>positive (at least non-negative) numeric <code>"<a href="Rmpfr.html#topic+mpfr">mpfr</a>"</code>
vector (or <code><a href="base.html#topic+array">array</a></code>).</p>
</td></tr>
<tr><td><code id="pnormLU_+3A_lower.tail">lower.tail</code>, <code id="pnormLU_+3A_log.p">log.p</code></td>
<td>
<p>logical, see, e.g., <code><a href="stats.html#topic+pnorm">pnorm</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector/array/mpfr like <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Lutz Duembgen (2010)
<em>Bounding Standard Gaussian Tail Probabilities</em>;
arXiv preprint <code>1012.2063</code>,
<a href="https://arxiv.org/abs/1012.2063">https://arxiv.org/abs/1012.2063</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pnorm">pnorm</a></code>.  The same functions  &ldquo;numeric-only&rdquo; are in my
<a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(1/64, 10, by=1/64)
px &lt;- cbind(
    lQ = pnorm      (x, lower.tail=FALSE, log.p=TRUE)
  , Lo = pnormL_LD10(x, lower.tail=FALSE, log.p=TRUE)
  , Up = pnormU_S53 (x, lower.tail=FALSE, log.p=TRUE))
matplot(x, px, type="l") # all on top of each other

matplot(x, (D &lt;- px[,2:3] - px[,1]), type="l") # the differences
abline(h=0, lty=3, col=adjustcolor(1, 1/2))

## check they are lower and upper bounds indeed :
stopifnot(D[,"Lo"] &lt; 0, D[,"Up"] &gt; 0)

matplot(x[x&gt;4], D[x&gt;4,], type="l") # the differences
abline(h=0, lty=3, col=adjustcolor(1, 1/2))

### zoom out to larger x : [1, 1000]
x &lt;- seq(1, 1000, by=1/4)
px &lt;- cbind(
    lQ = pnorm      (x, lower.tail=FALSE, log.p=TRUE)
  , Lo = pnormL_LD10(x, lower.tail=FALSE, log.p=TRUE)
  , Up = pnormU_S53 (x, lower.tail=FALSE, log.p=TRUE))
matplot(x, px, type="l") # all on top of each other
matplot(x, (D &lt;- px[,2:3] - px[,1]), type="l") # the differences
abline(h=0, lty=3, col=adjustcolor(1, 1/2))

## check they are lower and upper bounds indeed :
table(D[,"Lo"] &lt; 0) # no longer always true
table(D[,"Up"] &gt; 0)
## not even when equality (where it's much better though):
table(D[,"Lo"] &lt;= 0)
table(D[,"Up"] &gt;= 0)

## *relative* differences:
matplot(x, (rD &lt;- 1 - px[,2:3] / px[,1]), type="l", log = "x")
abline(h=0, lty=3, col=adjustcolor(1, 1/2))
## abs()
matplot(x, abs(rD), type="l", log = "xy", axes=FALSE, # NB: curves *cross*
        main = "relative differences 1 - pnormUL(x, *)/pnorm(x,*)")
legend("top", c("Low.Bnd(D10)", "Upp.Bnd(S53)"), bty="n", col=1:2, lty=1:2)
sfsmisc::eaxis(1, sub10 = 2)
sfsmisc::eaxis(2)
abline(h=(1:4)*2^-53, col=adjustcolor(1, 1/4))

### zoom out to LARGE x : ---------------------------

x &lt;- 2^seq(0,    30, by = 1/64)
col4 &lt;- adjustcolor(1:4, 1/2)
options(width = 111) -&gt; oop # (nicely printing "tables")
if(FALSE)## or even HUGE:
   x &lt;- 2^seq(4, 513, by = 1/16)
px &lt;- cbind(
    lQ = pnorm      (x, lower.tail=FALSE, log.p=TRUE)
  , a0 = dnorm(x, log=TRUE)
  , a1 = dnorm(x, log=TRUE) - log(x)
  , Lo = pnormL_LD10(x, lower.tail=FALSE, log.p=TRUE)
  , Up = pnormU_S53 (x, lower.tail=FALSE, log.p=TRUE))
doLegTit &lt;- function(col=1:4) {
  title(main = "relative differences 1 - pnormUL(x, *)/pnorm(x,*)")
  legend("top", c("phi(x)", "phi(x)/x", "Low.Bnd(D10)", "Upp.Bnd(S53)"),
         bty="n", col=col, lty=1:4)
}
## *relative* differences are relevant:
matplot(x, (rD &lt;- 1 - px[,-1] / px[,1]), type="l", log = "x",
            ylim = c(-1,1)/2^8, col=col4) ; doLegTit()
abline(h=0, lty=3, col=adjustcolor(1, 1/2))

if(x[length(x)] &gt; 1e150) # the "HUGE" case (not default)
  print( tail(cbind(x, px), 20) )
  ##--&gt; For very large x ~= 1e154, the approximations overflow *later* than pnorm() itself !!


## abs(rel.Diff)  ---&gt; can use log-log:
matplot(x, abs(rD), type="l", log = "xy", xaxt="n", yaxt="n"); doLegTit()
sfsmisc::eaxis(1, sub10=2)
sfsmisc::eaxis(2)
abline(h=(1:4)*2^-53, col=adjustcolor(1, 1/4))

## lower.tail=TRUE (w/ log.p=TRUE) works "the same" for x &lt; 0:
require(Rmpfr)
x &lt;- - 2^seq(0,    30, by = 1/64)
##   ==
log1mexp &lt;- Rmpfr::log1mexp # Rmpfr version &gt;= 0.8-2 (2020-11-11 on CRAN)
px &lt;- cbind(
    lQ = pnorm   (x, lower.tail=TRUE, log.p=TRUE)
  , a0 = log1mexp(- dnorm(-x, log=TRUE))
  , a1 = log1mexp(-(dnorm(-x, log=TRUE) - log(-x)))
  , Lo = log1mexp(-pnormL_LD10(-x, lower.tail=TRUE, log.p=TRUE))
  , Up = log1mexp(-pnormU_S53 (-x, lower.tail=TRUE, log.p=TRUE)) )
matplot(-x, (rD &lt;- 1 - px[,-1] / px[,1]), type="l", log = "x",
            ylim = c(-1,1)/2^8, col=col4) ; doLegTit()
abline(h=0, lty=3, col=adjustcolor(1, 1/2))

## Comparison with  Rmpfr::erf() / erfc() based pnorm():

## Set the exponential ranges to maximal -- to evade underflow as long as possible
.mpfr_erange_set(value = (1-2^-52) * .mpfr_erange(c("min.emin","max.emax")))
l2t &lt;- seq(0, 32, by=1/4)
twos &lt;- mpfr(2, 1024)^l2t
Qt  &lt;- pnorm(twos, lower.tail=FALSE)
pnU &lt;- pnormU_S53 (twos, log.p=TRUE)
pnL &lt;- pnormL_LD10(twos, log.p=TRUE)
logQt &lt;- log(Qt)
M &lt;- cbind(twos, Qt, logQt = logQt, pnU)
roundMpfr(M, 40)
dM &lt;- asNumeric(cbind(dU = pnU - logQt,    dL = logQt - pnL,
                      # NB: the numbers are *negative*
                      rdU= 1 - pnU/logQt, rdL = pnL/logQt - 1))
data.frame(l2t, dM)
## The bounds are ok (where Qt does not underflow): L &lt; p &lt; U :
stopifnot(pnU &gt; pnL, pnU &gt; logQt, (logQt &gt; pnL)[Qt &gt; 0])
roundMpfr(cbind(twos, pnL, pnU, D=pnU-pnL, relD=(pnU-pnL)/((pnU+pnL)/2)), 40)

## ----- R's pnorm() -- is it always inside [L, U]  ?? ---------------------
nQt &lt;- stats::pnorm(asNumeric(twos), lower.tail=FALSE, log.p=TRUE)
data.frame(l2t, check.names=FALSE
         , nQt
         , "L &lt;= p" = c(" ", "W")[2 -(pnL &lt;= nQt)]
         , "p &lt;= U" = c(" ", "W")[2- (nQt &lt;= pnU)])
## ==&gt; pnorm() is *outside* sometimes for l2t &gt;= 7.25; always as soon as l2t &gt;= 9.25

## *but* the relative errors are around c_epsilon  in all these cases :
plot (2^l2t, asNumeric(abs(nQt-pnL)/abs(pnU)), type="o", cex=1/4, log="xy", axes=FALSE)
sfsmisc::eaxis(1, sub10 = 2)
sfsmisc::eaxis(2)
lines(2^l2t, asNumeric(abs(nQt-pnU)/abs(pnU)), type="o", cex=1/4, col=2)
abline(h=c(1:4)*2^-53, lty=2, col=adjustcolor(1, 1/4))

options(oop)# reverting
</code></pre>

<hr>
<h2 id='pqnormAsymp'>Asymptotic Approximations of Extreme Tail 'pnorm()' and 'qnorm()'</h2><span id='topic+pnormAsymp'></span><span id='topic+qnormAsymp'></span>

<h3>Description</h3>

<p>These functions provide the first terms of asymptotic series approximations to
<code><a href="stats.html#topic+pnorm">pnorm</a>()</code>'s (extreme) tail, from Abramawitz and Stegun's
26.2.13 (p.932),
or <code><a href="stats.html#topic+qnorm">qnorm</a>()</code> where the approximations have been derived via
iterative plugin using Abramowitz and Stegun's formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
pnormAsymp(x, k, lower.tail = FALSE, log.p = FALSE)
qnormAsymp(p, lp = .DT_Clog(p, lower.tail = lower.tail, log.p = log.p),
           order, M_2PI =,
           lower.tail = TRUE, log.p = missing(p))
</code></pre>


<h3>Arguments</h3>


<table role = "presentation">
<tr><td><code id="pqnormAsymp_+3A_x">x</code></td>
<td>
<p>positive (at least non-negative) numeric vector.</p>
</td></tr>
<tr><td><code id="pqnormAsymp_+3A_k">k</code></td>
<td>
<p>integer <code class="reqn">\ge 0</code> indicating how many terms the approximation
should use; currently <code class="reqn">k \le 5</code>.</p>
</td></tr>

<tr><td><code id="pqnormAsymp_+3A_p">p</code></td>
<td>
<p>numeric vector of probabilities, possibly transformed, depending
on <code>log.p</code>.  Does not need to be specified, if <code>lp</code> is instead.</p>
</td></tr>
<tr><td><code id="pqnormAsymp_+3A_lp">lp</code></td>
<td>
<p>numeric (vector) of <code>log(1-p)</code> values; if not specified,
computed from <code>p</code>, depending on <code>lower.tail</code> and <code>log.p</code>.</p>
</td></tr>
<tr><td><code id="pqnormAsymp_+3A_order">order</code></td>
<td>
<p>an integer in <code class="reqn">\{0,1,\dots,5\}</code>, specifying the
approximation order.</p>
</td></tr>
<tr><td><code id="pqnormAsymp_+3A_m_2pi">M_2PI</code></td>
<td>
<p>the number <code class="reqn">2\pi</code> in the same precision as <code>p</code> or
<code>lp</code>, i.e., <code><a href="base.html#topic+numeric">numeric</a></code> or of class
<code>"<a href="Rmpfr.html#topic+mpfr">mpfr</a>"</code>.</p>
</td></tr>
<tr><td><code id="pqnormAsymp_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if true, probabilities are <code class="reqn">P[X \le x]</code>,
otherwise upper tail probabilities, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="pqnormAsymp_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code> (default for <code>qnormAsymp</code> !!), probabilities
<code class="reqn">p</code> are given as <code class="reqn">\log(p)</code> in argument <code>p</code>
or <code class="reqn">\log{(1-p)}</code> in <code>lp</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <em>both</em> help pages <code><a href="DPQ.html#topic+pnormAsymp">pnormAsymp</a></code> and
<code><a href="DPQ.html#topic+qnormAsymp">qnormAsymp</a></code> from our package <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>.
</p>


<h3>Value</h3>

<p>vector/array/mpfr like first argument <code>x</code> or <code>p</code> or <code>lp</code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pnorm">pnorm</a></code>.  The same functions  &ldquo;numeric-only&rdquo; are in my
<a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a> package with more extensive documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require("Rmpfr") # (in strong dependencies of this pkg {DPQmpfr})
x &lt;- seq(1/64, 10, by=1/64)
xm  &lt;- mpfr( x, 96)
"TODO"

## More extreme tails: ----------------------------------------------
##
## 1. pnormAsymp() ---------------------
lx &lt;- c((2:10)*2, 25, (3:9)*10, (1:9)*100, (1:8)*1000, (2:7)*5000)
lxm &lt;- mpfr(lx, 256)
Px &lt;- pnorm(lxm, lower.tail = FALSE, log.p=TRUE)
PxA &lt;- sapplyMpfr(setNames(0:5, paste("k =",0:5)),
                  pnormAsymp, x=lxm, lower.tail = FALSE, log.p=TRUE)
if(interactive())
  roundMpfr(PxA, 40)
# rel.errors :
relE &lt;- asNumeric(1 - PxA/Px)
options(width = 99) -&gt; oop # (nicely printing the matrices)
cbind(lx, relE)
matplot(lx, abs(relE), type="b", cex = 1/2, log="xy", pch=as.character(0:5),
        axes=FALSE,
        main = "|relE( &lt;pnormAsymp(lx, k=*, lower.tail=FALSE, log.p=TRUE) )|")
sfsmisc::eaxis(1, sub10=2); sfsmisc::eaxis(2)
legend("bottom", paste("k =", 0:5), col=1:6, lty=1:5,
       pch = as.character(0:5), pt.cex=1/2, bty="n")
## NB: rel.Errors go down to  7e-59 ==&gt; need precision of  -log2(7e-59) ~ 193.2 bits

## 2. qnormAsymp() ---------------------
QPx &lt;- sapplyMpfr(setNames(0:5, paste("k =",0:5)),
                  function(k) qnormAsymp(Px, order=k, lower.tail = FALSE, log.p=TRUE))
(relE.q &lt;- asNumeric(QPx/lx - 1))
         # note how consistent the signs are (!) &lt;==&gt; have upper/lower bounds

matplot(-asNumeric(Px), abs(relE.q), type="b", cex = 1/2, log="xy", pch=as.character(0:5),
        xlab = quote(-Px), axes=FALSE,
        main = "|relE( &lt;qnormAsymp(Px, k=*, lower.tail=FALSE, log.p=TRUE) )|")
sfsmisc::eaxis(1, sub10=2); sfsmisc::eaxis(2)
legend("bottom", paste("k =", 0:5), col=1:6, lty=1:5,
       pch = as.character(0:5), pt.cex=1/2, bty="n")

options(oop) # {revert to previous state}
</code></pre>

<hr>
<h2 id='qbBaha2017'>Accurate qbeta() values from Baharev et al (2017)'s Program</h2><span id='topic+qbBaha2017'></span>

<h3>Description</h3>

<p>Compuate &quot;accurate&quot; <code><a href="stats.html#topic+qbeta">qbeta</a>()</code> values from
Baharev et al (2017)'s Program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("qbBaha2017")
</code></pre>


<h3>Format</h3>

<p>FIXME: Their published table only shows 6 digits,
but running their (32-bit statically linked) Linux executable
&lsquo;<span class="file">mindiffver</span>&rsquo; (from their github repos, see &quot;source&quot;)
with their own &lsquo;<span class="file">input.txt</span>&rsquo; gives <em>12</em>
digits accuracy, which we should be able to increase even more,



see <a href="https://github.com/baharev/mindiffver/blob/master/README.md">https://github.com/baharev/mindiffver/blob/master/README.md</a>
</p>
<p>A numeric matrix, <code class="reqn">9 \times 22</code> with guaranteed accuracy
<code><a href="stats.html#topic+qbeta">qbeta</a>(0.95, a,b)</code> values, for
<code class="reqn">a = 0.5, 1, 1.5, 2, 2.5, 3, 5, 10, 25</code> and
<code class="reqn">b = </code>
with <code><a href="utils.html#topic+str">str</a>()</code> </p>
<pre>
   num [1:9, 1:22] 0.902 0.95 0.966 0.975 0.98 ...
   - attr(*, "dimnames")=List of 2
    ..$ a: chr [1:9] "0.5" "1" "1.5" "2" ...
    ..$ b: chr [1:22] "1" "2" "3" "4" ...</pre>


<h3>Details</h3>

<p>MM constructed this data as follows  (TODO: say more..):
</p>
<pre>
        ff &lt;- "~/R/MM/NUMERICS/dpq-functions/beta-gamma-etc/Baharev_et_al-2017_table3.txt"
        qbB2017 &lt;- t( data.matrix(read.table(ff)) )
        dimnames(qbB2017) &lt;- dimnames(qbet)
        saveRDS(qbB2017, "..../qbBaha2017.rds")
    </pre>


<h3>Source</h3>


<p>This matrix comprises all entries of Table 3, p. 776 of
<br /> 
Baharev, A., Schichl, H. and Rv, E. (2017)
Computing the noncentral-F distribution and the power of the F-test with
guaranteed accuracy;
<em>Comput. Stat.</em> <b>32</b>(2), 763&ndash;779.
<a href="https://doi.org/10.1007/s00180-016-0701-3">doi:10.1007/s00180-016-0701-3</a>
</p>
<p>The paper mentions the first author's &lsquo;<span class="file">github</span>&rsquo; repos where source code and
executables are available from:
<a href="https://github.com/baharev/mindiffver/">https://github.com/baharev/mindiffver/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(qbBaha2017)
str(qbBaha2017)
str(ab &lt;- lapply(dimnames(qbBaha2017), as.numeric))
stopifnot(ab$a == c((1:6)/2, 5, 10, 25),
          ab$b == c(1:15, 10*c(2:5, 10, 25, 50)))
matplot(ab$b, t(qbBaha2017)[,9:1], type="l", log = "x", xlab = "b",
        ylab = "qbeta(.95, a,b)",
        main = "Guaranteed accuracy 95% percentiles of Beta distribution")
legend("right", paste("a = ", format(ab$a)),
       lty=1:5, col=1:6, bty="n")

## Relative error of R's qbeta() -- given that the table only shows 6
## digits, there is *no* relevant error: R's qbeta() is accurate enough:
x.ab &lt;- do.call(expand.grid, ab)
matplot(ab$b, 1 - t(qbeta(0.95, x.ab$a, x.ab$b) / qbBaha2017),
        main = "rel.error of R's qbeta() -- w/ 6 digits, it is negligible",
        ylab = "1 - qbeta()/'true'",
        type = "l", log="x", xlab="b")
abline(h=0, col=adjustcolor("gray", 1/2))
</code></pre>

<hr>
<h2 id='stirlerrM'>Stirling Formula Approximation Error</h2><span id='topic+stirlerrM'></span><span id='topic+stirlerrSer'></span>

<h3>Description</h3>

<p>Compute the <code><a href="base.html#topic+log">log</a>()</code> of the error of Stirling's formula for <code class="reqn">n!</code>.
Used in certain accurate approximations of (negative) binomial and Poisson probabilities.
</p>
<p><code>stirlerrM()</code> currently simply uses the direct mathematical formula,
based on <code><a href="base.html#topic+lgamma">lgamma</a>()</code>, adapted for use with <code><a href="Rmpfr.html#topic+mpfr">mpfr</a></code>-numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stirlerrM(n, minPrec = 128L)
stirlerrSer(n, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stirlerrM_+3A_n">n</code></td>
<td>
<p>numeric or &ldquo;numeric-alike&rdquo; vector, typically
&ldquo;large&rdquo; positive integer or half integer valued, here typically an
<code>"mpfr"</code>-number vector.</p>
</td></tr>
<tr><td><code id="stirlerrM_+3A_k">k</code></td>
<td>
<p>integer <em>scalar</em>, now in <code>1:22</code>.</p>
</td></tr>
<tr><td><code id="stirlerrM_+3A_minprec">minPrec</code></td>
<td>
<p>minimal precision (in bits) to be used when coercing
number-alikes, say, biginteger (<code><a href="gmp.html#topic+bigz">bigz</a></code>) to <code>"mpfr"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stirling's approximation to <code class="reqn">n!</code> has been
</p>
<p style="text-align: center;"><code class="reqn">n! \approx \bigl(\frac{n}{e}\bigr)^n \sqrt{2\pi n},</code>
</p>

<p>where by definition the error is the difference of the left and right
hand side of this formula, in  <code class="reqn">\log</code>-scale,
</p>
<p style="text-align: center;"><code class="reqn">\delta(n) =  \log\Gamma(n + 1) - n \log(n) + n - \log(2 \pi n)/2.</code>
</p>

<p>See the vignette <em>log1pmx, bd0, stirlerr, ...</em> from package
<a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>, where the series expansion of <code class="reqn">\delta(n)</code> is used with
11 terms, starting with
</p>
<p style="text-align: center;"><code class="reqn">\delta(n) = \frac 1{12 n} - \frac 1{360 n^3} + \frac 1{1260 n^5}
                    \pm O(n^{-7}).</code>
</p>



<h3>Value</h3>

<p>a numeric or other &ldquo;numeric-alike&rdquo; class vector, e.g.,
<code><a href="Rmpfr.html#topic+mpfr">mpfr</a></code>, of the same length as <code>n</code>.
</p>


<h3>Note</h3>

<p>In principle, the direct formula should be replaced by a few terms of the
series in powers of <code class="reqn">1/n</code> for large <code>n</code>, but we assume using
high enough precision for <code>n</code> should be sufficient and &ldquo;easier&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Catherine Loader, see <code><a href="stats.html#topic+dbinom">dbinom</a></code>;
</p>

<p>Martin Maechler (2021)
log1pmx(), bd0(), stirlerr() &ndash; Computing Poisson, Binomial, Gamma Probabilities in <span class="rlang"><b>R</b></span>.
<a href="https://CRAN.R-project.org/package=DPQ/vignettes/log1pmx-etc.pdf">https://CRAN.R-project.org/package=DPQ/vignettes/log1pmx-etc.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbinom">dbinom</a></code>; rational exact <code><a href="gmp.html#topic+dbinomQ">dbinomQ</a>()</code> in package <a href="https://CRAN.R-project.org/package=gmp"><span class="pkg">gmp</span></a>.
<code><a href="DPQ.html#topic+stirlerr">stirlerr</a>()</code> in package
<a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a> which is a pure <span class="rlang"><b>R</b></span> version <span class="rlang"><b>R</b></span>'s mathlib-internal C function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### ----------------  Regular R  double precision -------------------------------

n &lt;- n. &lt;- c(1:10, 15, 20, 30, 50*(1:6), 100*(4:9), 10^(3:12))
(stE &lt;- stirlerrM(n)) # direct formula is *not* good when n is large:
require(graphics)
plot(stirlerrM(n) ~ n, log = "x", type = "b", xaxt="n") # --&gt; *negative for large n!
sfsmisc::eaxis(1, sub10=3) ; abline(h = 0, lty=3, col=adjustcolor(1, 1/2))
oMax &lt;- 22 # was 8 originally
str(stirSer &lt;- sapply(setNames(1:oMax, paste0("k=",1:oMax)),
                      function(k) stirlerrSer(n, k)))
cols &lt;- 1:(oMax+1)
matlines(n, stirSer, col = cols, lty=1)
leg1 &lt;- c("stirlerrM(n): [dble prec] direct f()",
          paste0("stirlerrSer(n, k=", 1:oMax, ")"))
legend("top", leg1, pch = c(1,rep(NA,oMax)), col=cols, lty=1, bty="n")
## for larger n, current values are even *negative* ==&gt; dbl prec *not* sufficient

## y in log-scale [same conclusion]
plot (stirlerrM(n) ~ n, log = "xy", type = "b", ylim = c(1e-13, 0.08))
matlines(n, stirSer, col = cols, lty=1)
legend("bottomleft", leg1, pch=c(1,rep(NA,oMax)), col=1:(oMax+1), lty=1, bty="n")

## the numbers:
options(digits=4, width=111)
stEmat. &lt;- cbind(sM = setNames(stirlerrM(n),n), stirSer)
stEmat.
# note *bad* values for (n=1, k &gt;= 8) !


## for printing n=&lt;nice&gt;: 8
N &lt;- Rmpfr::asNumeric
dfm &lt;- function(n, mm) data.frame(n=formatC(N(n)), N(mm), check.names=FALSE)
## relative differences:
dfm(n, stEmat.[,-1]/stEmat.[,1] - 1)
    # =&gt; stirlerrM() {with dbl prec} deteriorates after ~ n = 200--500



### ----------------  MPFR High Accuracy -------------------------------

stopifnot(require(gmp),
          require(Rmpfr))
n &lt;- as.bigz(n.)
## now repeat everything .. from above ... FIXME shows bugs !
## fully accurate using big rational arithmetic
class(stEserQ &lt;- sapply(setNames(1:oMax, paste0("k=",1:oMax)),
                        function(k) stirlerrSer(n=n, k=k))) # list ..
stopifnot(sapply(stEserQ, class) == "bigq") # of exact big rationals
str(stEsQM  &lt;- lapply(stEserQ, as, Class="mpfr"))# list of oMax;  each prec. 128..702
    stEsQM. &lt;- lapply(stEserQ, .bigq2mpfr, precB = 512) # constant higher precision
    stEsQMm &lt;- sapply(stEserQ, asNumeric) # a matrix -- "exact" values of Stirling series

stEM   &lt;- stirlerrM(mpfr(n, 128)) # now ok (loss of precision, but still ~ 10 digits correct)
stEM4k &lt;- stirlerrM(mpfr(n, 4096))# assume practically "perfect"/ "true" stirlerr() values
## ==&gt; what's the accuracy of the 128-bit 'stEM'?
N &lt;- asNumeric # short
dfm &lt;- function(n, mm) data.frame(n=formatC(N(n)), N(mm), check.names=FALSE)
dfm(n, stEM/stEM4k - 1)
## ...........
## 29 1e+06  4.470e-25
## 30 1e+07 -7.405e-23
## 31 1e+08 -4.661e-21
## 32 1e+09 -7.693e-20
## 33 1e+10  3.452e-17  (still ok)
## 34 1e+11 -3.472e-15  &lt;&lt; now start losing  --&gt; 128 bits *not* sufficient!
## 35 1e+12 -3.138e-13  &lt;&lt;&lt;&lt;
## same conclusion via  number of correct (decimal) digits:
dfm(n, log10(abs(stEM/stEM4k - 1)))

plot(N(-log10(abs(stEM/stEM4k - 1))) ~ N(n), type="o", log="x",
     xlab = quote(n), main = "#{correct digits} of 128-bit stirlerrM(n)")
ubits &lt;- c(128, 52) # above 128-bit and double precision
abline(h = ubits* log10(2), lty=2)
text(1, ubits* log10(2), paste0(ubits,"-bit"), adj=c(0,0))

stopifnot(identical(stirlerrM(n), stEM)) # for bigz &amp; bigq, we default to precBits = 128
all.equal(roundMpfr(stEM4k, 64),
          stirlerrSer (n., oMax)) # 0.00212 .. because of 1st few n.  ==&gt; drop these
all.equal(roundMpfr(stEM4k,64)[n. &gt;= 3], stirlerrSer (n.[n. &gt;= 3], oMax)) # 6.238e-8

plot(asNumeric(abs(stirlerrSer(n., oMax) - stEM4k)) ~ n.,
     log="xy", type="b", main="absolute error of stirlerrSer(n, oMax)  &amp; (n, 5)")
abline(h = 2^-52, lty=2); text(1, 2^-52, "52-bits", adj=c(1,-1)/oMax)
lines(asNumeric(abs(stirlerrSer(n., 5) - stEM4k)) ~ n., col=2)

plot(asNumeric(stirlerrM(n)) ~ n., log = "x", type = "b")
for(k in 1:oMax) lines(n, stirlerrSer(n, k), col = k+1)
legend("top", c("stirlerrM(n)", paste0("stirlerrSer(n, k=", 1:oMax, ")")),
       pch=c(1,rep(NA,oMax)), col=1:(oMax+1), lty=1, bty="n")

## y in log-scale
plot(asNumeric(stirlerrM(n)) ~ n., log = "xy", type = "b", ylim = c(1e-13, 0.08))
for(k in 1:oMax) lines(n, stirlerrSer(n, k), col = k+1)
legend("topright", c("stirlerrM(n)", paste0("stirlerrSer(n, k=", 1:oMax, ")")),
       pch=c(1,rep(NA,oMax)), col=1:(oMax+1), lty=1, bty="n")
## all "looks" perfect (so we could skip this)

## The numbers ...  reused
## stopifnot(sapply(stEserQ, class) == "bigq") # of exact big rationals
## str(stEsQM  &lt;- lapply(stEserQ, as, Class="mpfr"))# list of oMax;  each prec. 128..702
##     stEsQM. &lt;- lapply(stEserQ, .bigq2mpfr, precB = 512) # constant higher precision
##     stEsQMm &lt;- sapply(stEserQ, asNumeric) # a matrix -- "exact" values of Stirling series

## stEM   &lt;- stirlerrM(mpfr(n, 128)) # now ok (loss of precision, but still ~ 10 digits correct)
## stEM4k &lt;- stirlerrM(mpfr(n, 4096))# assume "perfect"
stEmat &lt;- cbind(sM = stEM4k, stEsQMm)
signif(asNumeric(stEmat), 6) # prints nicely -- large n = 10^e: see ~= 1/(12 n)  =  0.8333 / n
## print *relative errors* nicely :
## simple double precision version of direct formula (cancellation for n &gt;&gt; 1 !):
stE &lt;- stirlerrM(n.) # --&gt; bad for small n;  catastrophically bad for n &gt;= 10^7
## relative *errors*
dfm(n , cbind(stEsQMm, dbl=stE)/stEM4k - 1)
## only "perfect" Series (showing true mathematical approx. error; not *numerical*
relE &lt;- N(stEsQMm / stEM4k - 1)
dfm(n, relE)
matplot(n, relE, type = "b", log="x", ylim = c(-1,1) * 1e-12)
## |rel.Err|  in  [log log]
matplot(n, abs(N(relE)), type = "b", log="xy")
matplot(n, pmax(abs(N(relE)), 1e-19), type = "b", log="xy", ylim = c(1e-17, 1e-12))
matplot(n, pmax(abs(N(relE)), 1e-19), type = "b", log="xy", ylim = c(4e-17, 1e-15))
abline(h = 2^-(53:52), lty=3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
