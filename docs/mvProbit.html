<!DOCTYPE html><html><head><title>Help for package mvProbit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvProbit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mvProbit'><p>Estimation of Multivariate Probit Models</p></a></li>
<li><a href='#mvProbitLogLik'><p>Log Likelihood Values for Multivariate Probit Models</p></a></li>
<li><a href='#mvProbitMargEff'><p>Expectations and Marginal Effects from Multivariate Probit Models</p></a></li>
<li><a href='#summary.mvProbit'><p>Summary Results of Multivariate Probit Models</p></a></li>
<li><a href='#summary.mvProbitMargEff'><p>Summarize Marginal Effects of Multivariate Probit Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Probit Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Arne Henningsen &lt;arne.henningsen@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arne Henningsen &lt;arne.henningsen@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.4.0), mvtnorm (&ge; 0.9-9994), maxLik (&ge; 1.0-0), abind
(&ge; 1.3-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bayesm (&ge; 2.2-4), miscTools (&ge; 0.6-11)</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for estimating multivariate probit models,
   calculating conditional and unconditional expectations,
   and calculating marginal effects on conditional and unconditional
   expectations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.sampleSelection.org">http://www.sampleSelection.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-07 15:58:00 UTC; gsl324</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-11 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mvProbit'>Estimation of Multivariate Probit Models</h2><span id='topic+mvProbit'></span><span id='topic+print.mvProbit'></span>

<h3>Description</h3>

<p>Estimating multivariate probit models by the maximum likelihood method.
</p>
<p>WARNING: this function is experimental and extremely
(perhaps even unusably) slow!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvProbit( formula, data, start = NULL, startSigma = NULL, 
   method = "BHHH", finalHessian = "BHHH", 
   algorithm = "GHK", nGHK = 1000, 
   intGrad = TRUE, oneSidedGrad = FALSE, eps = 1e-6, 
   random.seed = 123, ... )

## S3 method for class 'mvProbit'
print( x, digits = 4, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvProbit_+3A_formula">formula</code></td>
<td>
<p>a <code>"formula"</code>:
a symbolic description of the model
(currently, all binary outcome variables must have the same regressors).</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing the data.</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_start">start</code></td>
<td>
<p>an optional numeric vector specifying the starting values 
for the model coefficients; 
if argument <code>startSigma</code> is not specified,
this vector can also include the correlation coefficients;
the order of elements is explained in the section &ldquo;details&rdquo;;
if this argument is not specified,
coefficients estimated by univariate probit models 
are used as starting values for the model coefficients.</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_startsigma">startSigma</code></td>
<td>
<p>optional starting values for the covariance/correlation matrix 
of the residuals (must be symmetric and have ones on its diagonal);
if this argument is not specified
and the starting values for the correlation coefficients
are not included in argument <code>start</code>,
the correlation matrix of the &lsquo;response&rsquo; residuals, 
i.e. y - pnorm( X' beta ),
is used as starting values for sigma.</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_method">method</code></td>
<td>
<p>maximisation method / algorithm 
(see <code><a href="maxLik.html#topic+maxLik">maxLik</a></code>).</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_finalhessian">finalHessian</code></td>
<td>
<p>Calculation of the final Hessian:
either <code>FALSE</code> (no calculation of Hessian), 
<code>TRUE</code> (finite-distance calculation of Hessian), or 
<code>"BHHH"</code> (calculation based on information equality approach
and finite-distance gradients, the default).</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_algorithm">algorithm</code></td>
<td>
<p>algorithm for computing integrals 
of the multivariate normal distribution,
either function <code>GenzBretz()</code>, <code>Miwa()</code>, or <code>TVPACK()</code>
(see documentation of <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>)
or character string <code>"GHK"</code> 
(see documentation of <code><a href="bayesm.html#topic+ghkvec">ghkvec</a></code>).</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_nghk">nGHK</code></td>
<td>
<p>numeric value specifying the number of simulation draws 
of the GHK algorithm for computing integrals 
of the multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_intgrad">intGrad</code></td>
<td>
<p>logical. If <code>TRUE</code>, 
the computation of the gradients
with respect to the estimated parameters
is done internally in function <code><a href="#topic+mvProbitLogLik">mvProbitLogLik</a></code>
when it computes the log-likelihood values.
If the optimization method requires gradients 
and this argument is <code>FALSE</code>,
<code><a href="maxLik.html#topic+maxLik">maxLik</a></code> computes the gradients
by <code><a href="maxLik.html#topic+numericGradient">numericGradient</a></code>,
which is usually slower 
than the calculation in function <code><a href="#topic+mvProbitLogLik">mvProbitLogLik</a></code>.
This argument should be set to <code>FALSE</code>
if an optimisation algorithm is used that is not based on gradients.</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_onesidedgrad">oneSidedGrad</code></td>
<td>
<p>logical. If this argument
and argument <code>intGrad</code> are both <code>TRUE</code>, 
the gradients of the log-likelihood function
with respect to the estimated parameters 
are obtained by one-sided numeric finit-difference differentiation,
which is faster but less precise 
than two-sided numeric finit-difference differentiation.</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_eps">eps</code></td>
<td>
<p>numeric. The step size for the one-sided numeric
finit-distance differentiation.
Unfortunately, it is currently not possible to set the step size
for the two-sided numeric finit-distance differentiation.</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_random.seed">random.seed</code></td>
<td>
<p>an integer used to seed R's random number generator;
this is to ensure replicability 
when computing (cumulative) probabilities of the multivariate normal distribution
which is required to calculate the log likelihood values;
<code>set.seed( random.seed )</code> is called each time before
a (cumulative) probability of the multivariate normal distribution 
is computed;
defaults to 123.</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_x">x</code></td>
<td>
<p>object of class <code>mvProbit</code> (returned by <code>mvProbit</code>).</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_digits">digits</code></td>
<td>
<p>positive integer specifiying the minimum number of
significant digits to be printed
(see <code><a href="base.html#topic+print.default">print.default</a></code>).</p>
</td></tr>
<tr><td><code id="mvProbit_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>mvProbit</code> are passed
to <code><a href="maxLik.html#topic+maxLik">maxLik</a></code> and <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>;
additional arguments to <code>print.mvProbit</code> are currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to specify starting values 
(a) both for the model coefficients and the correlation coefficients
(using argument <code>start</code> alone or arguments <code>start</code> and <code>startSigma</code>
together),
(b) only for the model coefficients (using argument <code>start</code> alone), or
(c) only for the correlation coefficients (using argument <code>startSigma</code> alone).
</p>
<p>If the model has <code class="reqn">n</code> dependent variables (equations)
and <code class="reqn">k</code> explanatory variables in each equation,
the order of the starting values in argument <code>start</code> must be as follows:
<code class="reqn">b_{1,1}</code>, ..., <code class="reqn">b_{1,k}</code>, 
<code class="reqn">b_{2,1}</code>, ..., <code class="reqn">b_{2,k}</code>, ...,
<code class="reqn">b_{n,1}</code>, ..., <code class="reqn">b_{n,k}</code>,
where <code class="reqn">b_{i,j}</code> is the coefficient
of the <code class="reqn">j</code>th explanatory variable in the <code class="reqn">i</code>th equation.
If argument <code>startSigma</code> is not specified,
argument <code>start</code> can additionally include following elements:
<code class="reqn">R_{1,2}</code>, <code class="reqn">R_{1,3}</code>, <code class="reqn">R_{1,4}</code>, ..., <code class="reqn">R_{1,n}</code>,
<code class="reqn">R_{2,3}</code>, <code class="reqn">R_{2,4}</code>, ..., <code class="reqn">R_{2,n}</code>, ...,
<code class="reqn">R_{n-1,n}</code>,
where <code class="reqn">R_{i,j}</code> is the correlation coefficient corresponding to
the <code class="reqn">i</code>th and <code class="reqn">j</code>th equation.
</p>
<p>The &lsquo;state&rsquo; (or &lsquo;seed&rsquo;) of R's random number generator 
is saved at the beginning of the <code>mvProbit</code> function 
and restored at the end of this function 
so that this function does <em>not</em> affect the generation 
of random numbers outside this function
although the random seed is set to argument <code>random.seed</code>
and the calculation of the (cumulative) multivariate normal distribution
uses random numbers.
</p>


<h3>Value</h3>

<p><code>mvProbit</code> returns an object of class <code>"mvProbit"</code>
inheriting from class <code>"maxLik"</code>.
The returned object contains the same components as objects
returned by <code><a href="maxLik.html#topic+maxLik">maxLik</a></code> and additionally
the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>the vector of starting values.</p>
</td></tr>
<tr><td><code>nDep</code></td>
<td>
<p>the number of dependent variables.</p>
</td></tr>
<tr><td><code>nReg</code></td>
<td>
<p>the number of explanatory variables (regressors).</p>
</td></tr>
<tr><td><code>nObs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>dummyVars</code></td>
<td>
<p>vector of character strings
indicating the names of explanatory variables
that contain only zeros and ones or only <code>TRUE</code> and <code>FALSE</code>.
It is <code>NULL</code>, if no explanatory variable is indentified 
as a dummy variable.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Greene, W.H. (1996): 
<em>Marginal Effects in the Bivariate Probit Model</em>,
NYU Working Paper No. EC-96-11. 
Available at <a href="https://www.ssrn.com/abstract=1293106">https://www.ssrn.com/abstract=1293106</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvProbitLogLik">mvProbitLogLik</a></code>,
<code><a href="#topic+mvProbitMargEff">mvProbitMargEff</a></code>,
<code><a href="sampleSelection.html#topic+probit">probit</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a simulated data set
set.seed( 123 )
# number of observations
nObs &lt;- 50

# generate explanatory variables
xMat &lt;- cbind( 
   const = rep( 1, nObs ),
   x1 = as.numeric( rnorm( nObs ) &gt; 0 ),
   x2 = rnorm( nObs ) )

# model coefficients
beta &lt;- cbind( c(  0.8,  1.2, -0.8 ),
               c( -0.6,  1.0, -1.6 ),
               c(  0.5, -0.6,  1.2 ) )

# covariance matrix of error terms
library( miscTools )
sigma &lt;- symMatrix( c( 1, 0.2, 0.4, 1, -0.1, 1 ) )

# generate dependent variables
yMatLin &lt;- xMat %*% beta 
yMat &lt;- ( yMatLin + rmvnorm( nObs, sigma = sigma ) ) &gt; 0
colnames( yMat ) &lt;- paste( "y", 1:3, sep = "" )

# estimation (BHHH optimizer and GHK algorithm)
estResult &lt;- mvProbit( cbind( y1, y2, y3 ) ~ x1 + x2,
   data = as.data.frame( cbind( xMat, yMat ) ), iterlim = 1, nGHK = 50 )
summary( estResult )

# same estimation with user-defined starting values
estResultStart &lt;- mvProbit( cbind( y1, y2, y3 ) ~ x1 + x2,
   start = c( beta ), startSigma = sigma, 
   data = as.data.frame( cbind( xMat, yMat ) ), iterlim = 1, nGHK = 50 )
summary( estResultStart )
</code></pre>

<hr>
<h2 id='mvProbitLogLik'>Log Likelihood Values for Multivariate Probit Models</h2><span id='topic+mvProbitLogLik'></span><span id='topic+logLik.mvProbit'></span>

<h3>Description</h3>

<p>Function <code>mvProbitLogLik</code> calculates log likelihood values 
of multivariate probit models.
</p>
<p>The <code>logLik</code> model returns or calculates log likelihood values 
of multivariate probit models estimated by <code><a href="#topic+mvProbit">mvProbit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvProbitLogLik( formula, coef, sigma = NULL, data,
   algorithm = "GHK", nGHK = 1000, 
   returnGrad = oneSidedGrad, oneSidedGrad = FALSE, eps = 1e-6, 
   random.seed = 123, ... )

## S3 method for class 'mvProbit'
logLik( object, coef = NULL, data = NULL, 
   algorithm = NULL, nGHK = NULL, random.seed = NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvProbitLogLik_+3A_formula">formula</code></td>
<td>
<p>a <code>"formula"</code>:
a symbolic description of the model
(currently, all binary outcome variables must have the same regressors).</p>
</td></tr>
<tr><td><code id="mvProbitLogLik_+3A_coef">coef</code></td>
<td>
<p>a numeric vector of the model coefficients;
if argument <code>sigma</code> is not specified,
this vector must also include the correlation coefficients;
the order of elements is explained in the section &ldquo;details&rdquo;.</p>
</td></tr>
<tr><td><code id="mvProbitLogLik_+3A_sigma">sigma</code></td>
<td>
<p>optional argument for specifying
the covariance/correlation matrix of the residuals
(must be symmetric and have ones on its diagonal);
if this argument is not specified, 
the correlation coefficients must be specified by argument <code>coef</code>.</p>
</td></tr>
<tr><td><code id="mvProbitLogLik_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing the data.</p>
</td></tr>
<tr><td><code id="mvProbitLogLik_+3A_algorithm">algorithm</code></td>
<td>
<p>algorithm for computing integrals 
of the multivariate normal distribution,
either function <code>GenzBretz()</code>, <code>Miwa()</code>, or <code>TVPACK()</code>
(see documentation of <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>)
or character string <code>"GHK"</code> 
(see documentation of <code><a href="bayesm.html#topic+ghkvec">ghkvec</a></code>).</p>
</td></tr>
<tr><td><code id="mvProbitLogLik_+3A_nghk">nGHK</code></td>
<td>
<p>numeric value specifying the number of simulation draws 
of the GHK algorithm for computing integrals 
of the multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="mvProbitLogLik_+3A_returngrad">returnGrad</code></td>
<td>
<p>logical. If <code>TRUE</code>, the returned object
has an attribute <code>"gradient"</code>,
which is a matrix and provides 
the gradients of the log-likelihood function
with respect to all parameters 
(<code>coef</code> and upper triangle of <code>sigma</code>)
evaluated at each observation
and obtained by (two-sided) numeric finite-difference differentiation.</p>
</td></tr>
<tr><td><code id="mvProbitLogLik_+3A_onesidedgrad">oneSidedGrad</code></td>
<td>
<p>logical. If <code>TRUE</code>,
attribute <code>"gradient"</code> of the returned object
is obtained by one-sided numeric finite-difference differentiation.</p>
</td></tr>
<tr><td><code id="mvProbitLogLik_+3A_eps">eps</code></td>
<td>
<p>numeric. The step size for the numeric
finite-distance differentiation.</p>
</td></tr>
<tr><td><code id="mvProbitLogLik_+3A_random.seed">random.seed</code></td>
<td>
<p>an integer used to seed R's random number generator;
this is to ensure replicability 
when computing (cumulative) probabilities of the multivariate normal distribution
which is required to calculate the log likelihood values;
<code>set.seed( random.seed )</code> is called each time before
a (cumulative) probability of the multivariate normal distribution 
is computed;
defaults to 123.</p>
</td></tr>
<tr><td><code id="mvProbitLogLik_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mvProbit"</code>
(returned by <code><a href="#topic+mvProbit">mvProbit</a></code>.</p>
</td></tr>
<tr><td><code id="mvProbitLogLik_+3A_...">...</code></td>
<td>
<p>additional arguments are passed
to <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>
when calculating conditional expectations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>logLik</code> method is called with <code>object</code>
as the only argument,
it returns the log-likelihood value 
found in the maximum likelihood estimation.
If any other argument is not <code>NULL</code>,
the <code>logLik</code> method calculates the log-likelihood value
by calling <code>mvProbitLogLik</code>.
All arguments that are <code>NULL</code>,
are taken from argument <code>object</code>.
</p>
<p>If the model has <code class="reqn">n</code> dependent variables (equations)
and <code class="reqn">k</code> explanatory variables in each equation,
the order of the model coefficients in argument <code>coef</code> must be as follows:
<code class="reqn">b_{1,1}</code>, ..., <code class="reqn">b_{1,k}</code>, 
<code class="reqn">b_{2,1}</code>, ..., <code class="reqn">b_{2,k}</code>, ...,
<code class="reqn">b_{n,1}</code>, ..., <code class="reqn">b_{n,k}</code>,
where <code class="reqn">b_{i,j}</code> is the coefficient
of the <code class="reqn">j</code>th explanatory variable in the <code class="reqn">i</code>th equation.
If argument <code>sigma</code> is not specified,
argument <code>coef</code> must additionally include following elements:
<code class="reqn">R_{1,2}</code>, <code class="reqn">R_{1,3}</code>, <code class="reqn">R_{1,4}</code>, ..., <code class="reqn">R_{1,n}</code>,
<code class="reqn">R_{2,3}</code>, <code class="reqn">R_{2,4}</code>, ..., <code class="reqn">R_{2,n}</code>, ...,
<code class="reqn">R_{n-1,n}</code>,
where <code class="reqn">R_{i,j}</code> is the correlation coefficient corresponding to
the <code class="reqn">i</code>th and <code class="reqn">j</code>th equation.
</p>
<p>The &lsquo;state&rsquo; (or &lsquo;seed&rsquo;) of R's random number generator 
is saved at the beginning of the <code>mvProbitLogLik</code> function 
and restored at the end of this function 
so that this function does <em>not</em> affect the generation 
of random numbers outside this function
although the random seed is set to argument <code>random.seed</code>
and the calculation of the (cumulative) multivariate normal distribution
uses random numbers.
</p>


<h3>Value</h3>

<p><code>mvProbitLogLik</code> returns a vector 
containing the log likelihood values for each observation.
</p>
<p>If argument <code>returnGrad</code> is <code>TRUE</code>,
the vector returned by <code>mvProbitLogLik</code> 
has an attribute <code>"gradient"</code>,
which is a matrix and provides 
the gradients of the log-likelihood function
with respect to all parameters 
(<code>coef</code> and upper triangle of <code>sigma</code>)
evaluated at each observation
and obtained by numeric finite-difference differentiation.
</p>
<p>The <code>logLik</code> method returns the total log likelihood value
(sum over all observations) 
with attribute <code>df</code> equal to the number of estimated parameters
(model coefficients and correlation coefficients).
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Greene, W.H. (1996): 
<em>Marginal Effects in the Bivariate Probit Model</em>,
NYU Working Paper No. EC-96-11. 
Available at <a href="https://www.ssrn.com/abstract=1293106">https://www.ssrn.com/abstract=1293106</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvProbit">mvProbit</a></code>,
<code><a href="#topic+mvProbitMargEff">mvProbitMargEff</a></code>,
<code><a href="sampleSelection.html#topic+probit">probit</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a simulated data set
set.seed( 123 )
# number of observations
nObs &lt;- 10

# generate explanatory variables
xMat &lt;- cbind( 
   const = rep( 1, nObs ),
   x1 = as.numeric( rnorm( nObs ) &gt; 0 ),
   x2 = as.numeric( rnorm( nObs ) &gt; 0 ),
   x3 = rnorm( nObs ),
   x4 = rnorm( nObs ) )

# model coefficients
beta &lt;- cbind( c(  0.8,  1.2, -1.0,  1.4, -0.8 ),
               c( -0.6,  1.0,  0.6, -1.2, -1.6 ),
               c(  0.5, -0.6, -0.7,  1.1,  1.2 ) )

# covariance matrix of error terms
library( miscTools )
sigma &lt;- symMatrix( c( 1, 0.2, 0.4, 1, -0.1, 1 ) )

# generate dependent variables
yMatLin &lt;- xMat %*% beta 
yMat &lt;- ( yMatLin + rmvnorm( nObs, sigma = sigma ) ) &gt; 0
colnames( yMat ) &lt;- paste( "y", 1:3, sep = "" )

# log likelihood values
myData &lt;- as.data.frame( cbind( xMat, yMat ) )
logLikVal &lt;- mvProbitLogLik( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
   coef = c( beta ), sigma = sigma, data = myData )
print( logLikVal )
</code></pre>

<hr>
<h2 id='mvProbitMargEff'>Expectations and Marginal Effects from Multivariate Probit Models</h2><span id='topic+mvProbitExp'></span><span id='topic+mvProbitMargEff'></span><span id='topic+margEff.mvProbit'></span>

<h3>Description</h3>

<p><code>mvProbitExp</code> calculates expected outcomes 
from multivariate probit models.
</p>
<p><code>mvProbitMargEff</code> calculates marginal effects of the explanatory variables
on expected outcomes from multivariate probit models.
</p>
<p>The <code>margEff</code> method for objects of class <code>"mvProbit"</code>
is a wrapper function
that (for the convenience of the user)
extracts the relevant information from the estimation results
and then calls <code>mvProbitMargEff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvProbitExp( formula, coef, sigma = NULL, data,
   cond = FALSE, algorithm = "GHK", nGHK = 1000, random.seed = 123, ... )

mvProbitMargEff( formula, coef, sigma = NULL, vcov = NULL, data,
   cond = FALSE, algorithm = "GHK", nGHK = 1000, 
   eps = 1e-06, dummyVars = NA, addMean = FALSE, 
   returnJacobian = FALSE, random.seed = 123,
   ... )

## S3 method for class 'mvProbit'
margEff( object, data = eval( object$call$data ),
   cond = FALSE, othDepVar = NULL, dummyVars = object$dummyVars, 
   atMean = FALSE, calcVCov = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvProbitMargEff_+3A_formula">formula</code></td>
<td>
<p>a one-sided or two-sided <code>"formula"</code>:
a symbolic description of the model
(currently, all binary outcome variables must have 
the same explanatory variables).</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_coef">coef</code></td>
<td>
<p>a numeric vector of the model coefficients;
if argument <code>sigma</code> is not specified,
this vector must also include the correlation coefficients;
the order of elements is explained in the section &ldquo;details&rdquo;.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_sigma">sigma</code></td>
<td>
<p>optional argument for specifying
the covariance/correlation matrix of the residuals
(must be symmetric and have ones on its diagonal);
if this argument is not specified, 
the correlation coefficients must be specified by argument <code>coef</code>.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_vcov">vcov</code></td>
<td>
<p>an optional symmetric matrix 
specifying the variance-covariance matrix of all coefficients 
(model coefficients and correlation coefficients);
if this argument is specified,
the approximate variance covariance matrices of the marginal effects
are calculated and returned as an attribute (see below).</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing the data.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_cond">cond</code></td>
<td>
<p>logical value indicating 
whether (marginal effects on) conditional expectations (if <code>TRUE</code>)
or (marginal effects on) unconditional expectations (if <code>FALSE</code>, default)
should be returned.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_algorithm">algorithm</code></td>
<td>
<p>algorithm for computing integrals 
of the multivariate normal distribution,
either function <code>GenzBretz()</code>, <code>Miwa()</code>, or <code>TVPACK()</code>
(see documentation of <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>)
or character string <code>"GHK"</code> 
(see documentation of <code><a href="bayesm.html#topic+ghkvec">ghkvec</a></code>).</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_nghk">nGHK</code></td>
<td>
<p>numeric value specifying the number of simulation draws 
of the GHK algorithm for computing integrals 
of the multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_eps">eps</code></td>
<td>
<p>numeric, the difference between the two values 
of each (numerical) explanatory
variable that is used for the numerical differentiation.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_dummyvars">dummyVars</code></td>
<td>
<p>optional vector containing the names (character strings)
of explanatory variables
that should be treated as dummy variables (see section &lsquo;Details&rsquo;).
If <code>NA</code> (the default), dummy variables are detected automatically,
i.e. all explanatory variables
which contain only zeros and ones or only <code>TRUE</code> and <code>FALSE</code>
in the data set specified by argument <code>data</code>
are treated as dummy variables.
If <code>NULL</code>,
no variable is treated as dummy variable.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_addmean">addMean</code></td>
<td>
<p>logical.
If <code>TRUE</code>, the mean of values of all marginal effects are added
in an additional row at the bottom of the returned data.frame.
If argument <code>returnJacobian</code> is <code>TRUE</code>,
the Jacobian of the mean marginal effects with respect to the coefficients 
is included in the returned array of the Jacobians
(in an additional slot at the end of the first dimension).
If argument <code>vcov</code> of <code>mvProbitMargEff</code> is specified 
or argument <code>calcVCov</code> of the <code>margEff</code> method is <code>TRUE</code>,
the variance covariance matrix of the mean marginal effects
is included in the returned array of the variance covariance matrices
(in an additional slot at the end of the first dimension).</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_returnjacobian">returnJacobian</code></td>
<td>
<p>logical.
If <code>TRUE</code>, the Jacobian of the marginal effects 
with respect to the coefficients is returned.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_random.seed">random.seed</code></td>
<td>
<p>an integer used to seed R's random number generator;
this is to ensure replicability 
when computing (cumulative) probabilities of the multivariate normal distribution
which is required to calculate the conditional expectations;
<code>set.seed( random.seed )</code> is called each time before
a (cumulative) probability of the multivariate normal distribution 
is computed;
defaults to 123.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mvProbit"</code>
(returned by <code><a href="#topic+mvProbit">mvProbit</a></code>.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_othdepvar">othDepVar</code></td>
<td>
<p>optional scalar or vector for specifying
the values of the (other) dependent variables
when calculating the marginal effects on the conditional expectations.
If this argument is a scalar (zero or one), 
it is assumed that all (other) dependent variables have this value
at all observations.
If this argument is a vector (filled with zeros or ones)
with length equal to the number of dependent variables, 
it is assumed that the vector of dependent variables has these values
at all observations.
If this argument is <code>NULL</code> (the default), 
the dependent variables are assumed to have the values 
that these variables have in the data set <code>data</code>.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_atmean">atMean</code></td>
<td>
<p>logical. 
If <code>TRUE</code>, the marginal effects are calculated
not at each observation 
but at the mean values across all observations 
of the variables in the data set specified by argument <code>data</code>.</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_calcvcov">calcVCov</code></td>
<td>
<p>logical. 
If <code>TRUE</code>, 
the approximate variance covariance matrices of the marginal effects
are calculated and returned as an attribute (see below).</p>
</td></tr>
<tr><td><code id="mvProbitMargEff_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>mvProbitExp</code> are passed
to <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>
when calculating conditional expectations;
additional arguments of <code>mvProbitMargEff</code> are passed
to <code>mvProbitExp</code> and possibly further
to <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>;
additional arguments of the <code>margEff</code> method are passed
to <code>mvProbitMargEff</code>
and possibly further to <code>mvProbitMargEff</code>
and <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When calculating (marginal effects on) unconditional expectations,
the left-hand side of argument <code>formula</code> is ignored.
When calculating (marginal effects on) conditional expectations
and argument <code>formula</code> is a one-sided formula
(i.e. only the right-hand side is specified)
or argument <code>othDepOne</code> is <code>TRUE</code>,
(the marginal effects on) the conditional expectations 
are calculated based on the assumption
that all other dependent variables are one.
</p>
<p>The computation of the marginal effects
of dummy variables 
(i.e. variables specified in argument <code>dummyVars</code>)
ignores argument <code>eps</code> 
and evaluates the effect of increasing these variables from zero to one.
The marginal effects of (continuous) variables 
(i.e. variables not specified in argument <code>dummyVars</code>)
are calculated by evaluating the effect 
of increasing these variables from their actual values minus <code>0.5 * eps</code> 
to their actual values plus <code>0.5 * eps</code> (divided by <code>eps</code>).
</p>
<p>If the model has <code class="reqn">n</code> dependent variables (equations)
and <code class="reqn">k</code> explanatory variables in each equation,
the order of the model coefficients in argument <code>coef</code> must be as follows:
<code class="reqn">b_{1,1}</code>, ..., <code class="reqn">b_{1,k}</code>, 
<code class="reqn">b_{2,1}</code>, ..., <code class="reqn">b_{2,k}</code>, ...,
<code class="reqn">b_{n,1}</code>, ..., <code class="reqn">b_{n,k}</code>,
where <code class="reqn">b_{i,j}</code> is the coefficient
of the <code class="reqn">j</code>th explanatory variable in the <code class="reqn">i</code>th equation.
If argument <code>sigma</code> is not specified,
argument <code>coef</code> must additionally include following elements:
<code class="reqn">R_{1,2}</code>, <code class="reqn">R_{1,3}</code>, <code class="reqn">R_{1,4}</code>, ..., <code class="reqn">R_{1,n}</code>,
<code class="reqn">R_{2,3}</code>, <code class="reqn">R_{2,4}</code>, ..., <code class="reqn">R_{2,n}</code>, ...,
<code class="reqn">R_{n-1,n}</code>,
where <code class="reqn">R_{i,j}</code> is the correlation coefficient corresponding to
the <code class="reqn">i</code>th and <code class="reqn">j</code>th equation.
</p>
<p>If argument <code>vcov</code> of function <code>mvProbitMargEff</code> is specified
or argument <code>calcVCov</code> of the <code>margEff</code> method is <code>TRUE</code>,
the approximate variance covariance matrices of the marginal effects
are calculated at each observation by using the &lsquo;delta method&rsquo;,
where the jacobian matrix of the marginal effects 
with respect to the coefficients is obtained by numerical differentiation.
</p>
<p>The &lsquo;state&rsquo; (or &lsquo;seed&rsquo;) of R's random number generator 
is saved at the beginning of the call to these functions
and restored at the end
so that these functions do <em>not</em> affect the generation 
of random numbers outside this function
although the random seed is set to argument <code>random.seed</code>
and the calculation of the (cumulative) multivariate normal distribution
uses random numbers.
</p>


<h3>Value</h3>

<p><code>mvProbitExp</code> returns a data frame 
containing the expectations of the dependent variables.
</p>
<p><code>mvProbitMargEff</code> and the <code>margEff</code> method return a data frame 
containing the marginal effects of the explanatory variables
on the expectations of the dependent variables.
</p>
<p>If argument <code>vcov</code> of function <code>mvProbitMargEff</code> is specified
or argument <code>calcVCov</code> of the <code>margEff</code> method is <code>TRUE</code>,
the returned data frame has an attribute <code>vcov</code>,
which is a three-dimensional array,
where the first dimension corresponds to the observation
and the latter two dimensions span the approximate variance covariance matrix
of the marginal effects calculated for each observation.
</p>
<p>If argument <code>returnJacobian</code> of function <code>mvProbitMargEff</code>
or method <code>margEff</code> is set to <code>TRUE</code>,
the returned data frame has an attribute <code>jacobian</code>,
which is a three-dimensional array
that contains the Jacobian matrices of the marginal effects 
with respect to the coefficients at each observation,
where the first dimension corresponds to the observations,
the second dimension corresponds to the marginal effects,
and the third dimension corresponds to the coefficients.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Greene, W.H. (1996): 
<em>Marginal Effects in the Bivariate Probit Model</em>,
NYU Working Paper No. EC-96-11. 
Available at <a href="https://www.ssrn.com/abstract=1293106">https://www.ssrn.com/abstract=1293106</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvProbit">mvProbit</a></code>,
<code><a href="#topic+mvProbitLogLik">mvProbitLogLik</a></code>,
<code><a href="sampleSelection.html#topic+probit">probit</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a simulated data set
set.seed( 123 )
# number of observations
nObs &lt;- 10

# generate explanatory variables
xData &lt;- data.frame( 
   const = rep( 1, nObs ),
   x1 = as.numeric( rnorm( nObs ) &gt; 0 ),
   x2 = as.numeric( rnorm( nObs ) &gt; 0 ),
   x3 = rnorm( nObs ),
   x4 = rnorm( nObs ) )

# model coefficients
beta &lt;- c(  0.8,  1.2, -1.0,  1.4, -0.8,
           -0.6,  1.0,  0.6, -1.2, -1.6,
            0.5, -0.6, -0.7,  1.1,  1.2 )

# covariance matrix of error terms
library( miscTools )
sigma &lt;- symMatrix( c( 1, 0.2, 0.4, 1, -0.1, 1 ) )

# unconditional expectations of dependent variables
yExp &lt;- mvProbitExp( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
   sigma = sigma, data = xData )
print( yExp )

# marginal effects on unconditional expectations of dependent variables
margEffUnc &lt;- mvProbitMargEff( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
   sigma = sigma, data = xData )
print( margEffUnc )

# conditional expectations of dependent variables
# (assuming that all other dependent variables are one)
yExpCond &lt;- mvProbitExp( ~ x1 + x2 + x3 + x4, coef = beta,
   sigma = sigma, data = xData, cond = TRUE )
print( yExpCond )

# marginal effects on conditional expectations of dependent variables
# (assuming that all other dependent variables are one)
margEffCond &lt;- mvProbitMargEff( ~ x1 + x2 + x3 + x4, coef = beta,
   sigma = sigma, data = xData, cond = TRUE )
print( margEffCond )

# conditional expectations of dependent variables
# (assuming that all other dependent variables are zero)
xData$y1 &lt;- 0
xData$y2 &lt;- 0
xData$y3 &lt;- 0
yExpCond0 &lt;- mvProbitExp( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
   coef = beta, sigma = sigma, data = xData, cond = TRUE )
print( yExpCond0 )

# marginal effects on conditional expectations of dependent variables
# (assuming that all other dependent variables are zero)
margEffCond0 &lt;- mvProbitMargEff( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
   coef = beta, sigma = sigma, data = xData, cond = TRUE )
print( margEffCond0 )
</code></pre>

<hr>
<h2 id='summary.mvProbit'>Summary Results of Multivariate Probit Models</h2><span id='topic+summary.mvProbit'></span><span id='topic+print.summary.mvProbit'></span>

<h3>Description</h3>

<p>These methods prepare and print summary results
for multivariate probit models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvProbit'
summary( object, ... )

## S3 method for class 'summary.mvProbit'
print( x, digits = 4, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mvProbit_+3A_object">object</code></td>
<td>
<p>object of class <code>"mvProbit"</code>
(returned by <code><a href="#topic+mvProbit">mvProbit</a></code>).</p>
</td></tr>
<tr><td><code id="summary.mvProbit_+3A_x">x</code></td>
<td>
<p>object of class <code>"summary.mvProbit"</code>
(returned by <code><a href="#topic+summary.mvProbit">summary.mvProbit</a></code>).</p>
</td></tr>
<tr><td><code id="summary.mvProbit_+3A_digits">digits</code></td>
<td>
<p>positive integer specifiying the minimum number of
significant digits to be printed
(passed to <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>).</p>
</td></tr>
<tr><td><code id="summary.mvProbit_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.mvProbit</code> returns an object of class <code>"summary.mvProbit"</code>
inheriting from class <code>"summary.maxLik"</code>.
The returned object contains the same components as objects
returned by <code><a href="maxLik.html#topic+summary.maxLik">summary.maxLik</a></code> and additionally
the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>the vector of starting values.</p>
</td></tr>
<tr><td><code>nDep</code></td>
<td>
<p>the number of dependent variables.</p>
</td></tr>
<tr><td><code>nReg</code></td>
<td>
<p>the number of explanatory variables (regressors).</p>
</td></tr>
<tr><td><code>nObs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvProbit">mvProbit</a></code></p>

<hr>
<h2 id='summary.mvProbitMargEff'>Summarize Marginal Effects of Multivariate Probit Models</h2><span id='topic+summary.mvProbitMargEff'></span><span id='topic+print.summary.mvProbitMargEff'></span>

<h3>Description</h3>

<p>These methods prepare and print a statistical summary
of marginal effects of multivariate probit models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvProbitMargEff'
summary( object, ... )

## S3 method for class 'summary.mvProbitMargEff'
print( x, digits = 4, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mvProbitMargEff_+3A_object">object</code></td>
<td>
<p>object of class <code>"mvProbitMargEff"</code>
(returned by <code><a href="#topic+mvProbitMargEff">mvProbitMargEff</a></code> or 
<code><a href="#topic+margEff.mvProbit">margEff.mvProbit</a></code>).</p>
</td></tr>
<tr><td><code id="summary.mvProbitMargEff_+3A_x">x</code></td>
<td>
<p>object of class <code>"summary.mvProbitMargEff"</code>
(returned by <code><a href="#topic+summary.mvProbitMargEff">summary.mvProbitMargEff</a></code>).</p>
</td></tr>
<tr><td><code id="summary.mvProbitMargEff_+3A_digits">digits</code></td>
<td>
<p>positive integer specifiying the minimum number of
significant digits to be printed
(passed to <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>).</p>
</td></tr>
<tr><td><code id="summary.mvProbitMargEff_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.mvProbitMargEff</code> returns an object 
of class <code>"summary.mvProbitMargEff"</code>
inheriting from class <code>"matrix"</code>.
The returned object is a matrix with four columns,
where the marginal effects are in the first column,
their standard errors are in the second column,
corresponding &lsquo;z values&rsquo; are in the third column,
and the resulting &lsquo;P values&rsquo; are in the last column.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvProbitMargEff">mvProbitMargEff</a></code>, 
<code><a href="#topic+margEff.mvProbit">margEff.mvProbit</a></code>,
<code><a href="#topic+mvProbit">mvProbit</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
