<!DOCTYPE html><html lang="en-GB"><head><title>Help for package IsoriX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IsoriX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IsoriX-package'><p>Isoscape Computation and Inference of Spatial Origins using Mixed Models</p></a></li>
<li><a href='#AssignDataAlien'><p>Simulated assignment dataset</p></a></li>
<li><a href='#AssignDataBat'><p>Assignment datasets for bat species</p></a></li>
<li><a href='#AssignDataBat2'><p>Assignment datasets for bat species</p></a></li>
<li><a href='#CalibDataAlien'><p>Simulated calibration dataset</p></a></li>
<li><a href='#CalibDataBat'><p>Calibration datasets for bat species</p></a></li>
<li><a href='#CalibDataBat2'><p>Calibration datasets for bat species</p></a></li>
<li><a href='#calibfit'><p>Fit the calibration model (or load parameters from calibration done outside</p>
IsoriX)</a></li>
<li><a href='#CALIBFIT-class'><p>Class CALIBFIT</p></a></li>
<li><a href='#CountryBorders'><p>Borders of world CountryBorders</p></a></li>
<li><a href='#create_aliens'><p>Simulate datasets for calibrations or assignments</p></a></li>
<li><a href='#downloadfile'><p>Download files and check their binary integrity</p></a></li>
<li><a href='#ElevRasterDE'><p>The raster of elevation for Germany</p></a></li>
<li><a href='#getelev'><p>Download an elevation raster from internet</p></a></li>
<li><a href='#getprecip'><p>Download rasters of monthly precipitation from internet</p></a></li>
<li><a href='#GNIPDataDE'><p>Hydrogen delta values in precipitation water, Germany</p></a></li>
<li><a href='#GNIPDataEUagg'><p>Hydrogen delta values in precipitation water (aggregated per location)</p></a></li>
<li><a href='#isofind'><p>Infer spatial origins</p></a></li>
<li><a href='#ISOFIND-class'><p>Class ISOFIND</p></a></li>
<li><a href='#isofit'><p>Fit the isoscape models</p></a></li>
<li><a href='#isomultifit'><p>Fit isoscape models per strata (typically time interval such as months)</p></a></li>
<li><a href='#isomultiscape'><p>Predicts the average spatial distribution of isotopic values over months,</p>
years...</a></li>
<li><a href='#isopalette2'><p>Colour palettes for plotting</p></a></li>
<li><a href='#IsoriX-defunct'><p>Defunct and deprecated functions</p></a></li>
<li><a href='#isoscape'><p>Predicts the spatial distribution of source isotopic values</p></a></li>
<li><a href='#ISOSCAPE-class'><p>Class ISOSCAPE</p></a></li>
<li><a href='#OceanMask'><p>Mask of world oceans</p></a></li>
<li><a href='#options'><p>Setting and displaying the options of the package</p></a></li>
<li><a href='#plots'><p>Plotting functions for IsoriX</p></a></li>
<li><a href='#PrecipBrickDE'><p>The precipitation monthly amounts for Germany</p></a></li>
<li><a href='#prepcipitate'><p>Prepare the raster brick containing the precipitation data</p></a></li>
<li><a href='#prepraster'><p>Prepare the structural raster</p></a></li>
<li><a href='#prepsources'><p>Filter and aggregate the raw source dataset</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#serialize'><p>Save and read objects produced by IsoriX using RDS files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.9.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Isoscape Computation and Inference of Spatial Origins using
Mixed Models</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, grid, lattice (&ge; 0.22-2), latticeExtra,
methods, numDeriv, rasterVis (&ge; 0.51.6), spaMM (&ge; 3.13),
stats, terra, tools, utils, viridisLite</td>
</tr>
<tr>
<td>Description:</td>
<td>Building isoscapes using mixed models and inferring the geographic
  origin of samples based on their isotopic ratios. This package is essentially a
  simplified interface to several other packages which implements a new
  statistical framework based on mixed models. It uses 'spaMM' for fitting and
  predicting isoscapes, and assigning an organism's origin depending on its
  isotopic ratio. 'IsoriX' also relies heavily on the package 'rasterVis' for
  plotting the maps produced with 'terra' using 'lattice'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>colorspace, elevatr, gmp, magick, rgl, spelling, testthat,
webshot2, withr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/courtiol/IsoriX">https://github.com/courtiol/IsoriX</a>,
<a href="https://bookdown.org/content/782">https://bookdown.org/content/782</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/courtiol/IsoriX/issues">https://github.com/courtiol/IsoriX/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-07 12:16:20 UTC; courtiol</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexandre Courtiol
    <a href="https://orcid.org/0000-0003-0637-2959"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  François Rousset <a href="https://orcid.org/0000-0003-4670-0371"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Marie-Sophie Rohwaeder [aut],
  Stephanie Kramer-Schadt
    <a href="https://orcid.org/0000-0002-9269-4446"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexandre Courtiol &lt;alexandre.courtiol@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-08 07:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='IsoriX-package'>Isoscape Computation and Inference of Spatial Origins using Mixed Models</h2><span id='topic+IsoriX-package'></span><span id='topic+IsoriX'></span>

<h3>Description</h3>

<p><span class="pkg">IsoriX</span> can be used for building isoscapes using mixed models and
inferring the geographic origin of organisms based on their isotopic
signature. This package is essentially a simplified interface combining
several other packages which implements the statistical framework proposed by
Courtiol &amp; Rousset 2017. It uses the package <span class="pkg">spaMM</span> for fitting and
predicting isoscapes, and for performing the assignment. <span class="pkg">IsoriX</span> also
heavily relies on the package <span class="pkg">rasterVis</span> for plotting the maps produced
with the package <span class="pkg">terra</span> using the powerful package <span class="pkg">lattice</span>
visualization system.
</p>


<h3>Details</h3>

<p>Below, we describe briefly the main steps of the workflow that aims at
performing the construction of an isoscape and the assignment of organisms of
unknown geographic origin(s) based on their isotopic signature. We advise you
to also read the detailed book chapter we wrote (in press), as well as our
<a href="https://bookdown.org/content/782/">online documentation</a>, which essentially
cover the same material in a more detailed manner. You should also read the
dedicated help pages of the functions you are using.
</p>
<p>The statistical methods will not be detailed in this document but information
on the computation of isoscapes is available in Courtiol &amp; Rousset 2017, and
information on the calibration and assignment in the appendix of Courtiol et
al. 2019.
</p>
 <ol>
<li><p> Fitting the isoscape model with <code><a href="#topic+isofit">isofit</a></code>:
</p>
<p>The function <code><a href="#topic+isofit">isofit</a></code> fits a geostatistical model, which
approximates the relationship between the topographic features of a location
and its isotopic signature (see <code><a href="#topic+isofit">isofit</a></code> for details). The model
fits observations of isotopic delta values at several geographic locations
(hereafter, called <em>sources</em>). One common type of sources used in
ecology is the delta values for hydrogen in precipitation water collected at
weather stations, but one may also use measurements performed on sedentary
organisms. In either case, the accuracy of the isoscape (and thereby the
accuracy of assignments) increases with the number and spatial coverage of
the sources. The function <code><a href="#topic+isofit">isofit</a></code> is designed to fit the model
on data aggregated per location across all measurements. If instead you want
to fit the model on measurements split per time intervals (e.g. per month),
within each location, you should use the alternative function
<code><a href="#topic+isomultifit">isomultifit</a></code>. Either way the data must be prepared using the
function <code><a href="#topic+prepsources">prepsources</a></code>.
</p>
</li>
<li><p> Preparing the structural raster with <code><a href="#topic+prepraster">prepraster</a></code>:
</p>
<p>Building isoscapes and assigning organisms to their origin requires an
adequate structural raster, i.e. a matrix representing a spatial grid. The
function <code><a href="#topic+prepraster">prepraster</a></code> allows restricting the extent of the raster
to the area covered by isoscape data (in order to avoid extrapolation) and to
reduce the resolution of the original structural raster (in order to speed up
computation in all following steps). Note that aggregating the raster may
lead to different results for the assignment, if the structural raster is
used to define a covariate. This is because the values of raster cells
changes depending on the aggregation function, which in turn will affect
model predictions.
</p>
<p>We provide the function <code><a href="#topic+getelev">getelev</a></code> to download an elevation raster
for the entire world at a resolution of one altitude per square-km, and other
rasters may be used. Such an elevation raster can be used as a structural
raster. We have also stored a low resolution raster for Germany in our
package (see <code><a href="#topic+ElevRasterDE">ElevRasterDE</a></code>) for users to try things out, but we
do not encourage its use for real application.
</p>
</li>
<li><p> Predicting the isoscape across the area covered by the elevation raster
with <code><a href="#topic+isoscape">isoscape</a></code>:
</p>
<p>The function <code><a href="#topic+isoscape">isoscape</a></code> generates the isoscapes: it uses the
fitted geostatistical models to predict the isotopic values (and several
variances associated to those) for each raster cell defined by the structural
raster. If the model has been fitted with <code><a href="#topic+isomultifit">isomultifit</a></code>, you
should use the alternative function <code><a href="#topic+isomultiscape">isomultiscape</a></code> to generate
the isoscape.
</p>
<p>Our package allows the production of fine-tuned isoscape figures (using the
function <code><a href="#topic+plot.ISOSCAPE">plot.ISOSCAPE</a></code>). Alternatively, the isoscape rasters
can be exported as ascii raster and edited in any Geographic Information
System (GIS) software (see <code><a href="#topic+isoscape">isoscape</a></code> and the online
documentation for details).
</p>
</li>
<li><p> Fitting the calibration model with <code><a href="#topic+calibfit">calibfit</a></code>:
</p>
<p>In most cases, organisms are of another kind than the sources used to build
the isoscape (i.e. the isoscape is built on precipitation isotopic values and
organisms are not water drops, but e.g. the fur of some bats). In such a
case, the hydrogen delta values of the sampled organisms were modulated by
their distinct physiology and do not directly correspond to the isotopic
signature of the sources. In this situation, one must use sedentary organisms
to study the relationship between the isotopic values in organisms and that
of their environment. The function <code><a href="#topic+calibfit">calibfit</a></code> fits a statistical
model on such a calibration dataset.
</p>
<p>If the isoscape is directly built from isotopic values of organisms, there is
no need to fit a calibration model.
</p>
</li>
<li><p> Inferring spatial origins of samples with <code><a href="#topic+isofind">isofind</a></code>:
</p>
<p>The function <code><a href="#topic+isofind">isofind</a></code> tests for each location across the
isoscape if it presents a similar isotopic signature than the unknown origin
of a given individual(s). This assignment procedure considered the some (but
not all, see Courtiol et al. 2019) uncertainty stemming from the model fits
(geostatistical models and calibration model). The function
<code><a href="#topic+plot.ISOFIND">plot.ISOFIND</a></code> then draws such assignment by plotting the most
likely origin with the prediction region around it. When several organisms
are being assigned, both assignments at the level of each sample and a single
assignment for the whole group can be performed. </p>
</li></ol>



<h3>Note</h3>

<p>Please note that the geographic coordinates (latitude,
longitude) of any spatial data (locations, rasters) must be given in decimal
degrees following the WGS84 spheroid standard.
</p>


<h3>Author(s)</h3>

<p>Alexandre Courtiol <a href="mailto:alexandre.courtiol@gmail.com">alexandre.courtiol@gmail.com</a>,
</p>
<p>François Rousset,
</p>
<p>Marie-Sophie Rohwaeder,
</p>
<p>Stephanie Kramer-Schadt <a href="mailto:kramer@izw-berlin.de">kramer@izw-berlin.de</a>
</p>


<h3>References</h3>

<p>Courtiol A, Rousset F, Rohwäder M, Soto DX, Lehnert L, Voigt CC, Hobson KA,
Wassenaar LI &amp; Kramer-Schadt S (2019). &quot;Isoscape computation and inference of
spatial origins with mixed models using the R package IsoriX.&quot; In Hobson KA,
Wassenaar LI (eds.), Tracking Animal Migration with Stable Isotopes, second
edition. Academic Press, London.
</p>
<p>Courtiol A, Rousset F (2017). &quot;Modelling isoscapes using mixed models.&quot; bioRxiv.
doi: 10.1101/207662, <a href="https://www.biorxiv.org/content/10.1101/207662v1">link</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/courtiol/IsoriX">https://github.com/courtiol/IsoriX</a>
</p>
</li>
<li> <p><a href="https://bookdown.org/content/782">https://bookdown.org/content/782</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/courtiol/IsoriX/issues">https://github.com/courtiol/IsoriX/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AssignDataAlien'>Simulated assignment dataset</h2><span id='topic+AssignDataAlien'></span>

<h3>Description</h3>

<p>This dataset contains simulated hydrogen delta values.
The data can be used as an example to perform assignments using the function <code><a href="#topic+isofind">isofind</a></code>.
</p>


<h3>Format</h3>

<p>A <em>dataframe</em> with 10 observations and 2 variables:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_ID </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> Identification of the sample </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_value </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Hydrogen delta value of the tissue </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+isofind">isofind</a></code> to perform assignments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(AssignDataAlien)
str(AssignDataAlien)

## The examples below will only be run if sufficient time is allowed
## You can change that by typing e.g. options_IsoriX(example_maxtime = XX)
## if you want to allow for examples taking up to ca. XX seconds to run
## (so don't write XX but put a number instead!)

if (getOption_IsoriX("example_maxtime") &gt; 30) {
  ## The following describes how we created such dataset

  ### We prepare the precipitation data
  GNIPDataDEagg &lt;- prepsources(data = GNIPDataDE)

  ### We fit the models for Germany
  GermanFit &lt;- isofit(data = GNIPDataDEagg)

  ### We build the isoscape
  GermanScape &lt;- isoscape(raster = ElevRasterDE, isofit = GermanFit)

  ### We create a simulated dataset with 1 site and 10 observations
  set.seed(1L)
  Aliens &lt;- create_aliens(
    calib_fn = list(intercept = 3, slope = 0.5, resid_var = 5),
    isoscape = GermanScape,
    raster = ElevRasterDE,
    coordinates = data.frame(
      site_ID = "Berlin",
      long = 13.52134,
      lat = 52.50598
    ),
    n_sites = 1,
    min_n_samples = 10,
    max_n_samples = 10
  )
  AssignDataAlien &lt;- Aliens[, c("sample_ID", "sample_value")]

  ### Uncomment the following to store the file as we did
  # save(AssignDataAlien, file = "AssignDataAlien.rda", compress = "xz")
}

</code></pre>

<hr>
<h2 id='AssignDataBat'>Assignment datasets for bat species</h2><span id='topic+AssignDataBat'></span><span id='topic+AssignDataBatRev'></span>

<h3>Description</h3>

<p>These datasets contain data from Voigt &amp; Lenhert (2019). They contain hydrogen
delta values of fur keratin from common noctule bats (<em>Nyctalus noctula</em>)
killed at wind turbines in northern Germany. These data can be used as an
example to perform assignments using the function <code><a href="#topic+isofind">isofind</a></code>. The difference
between <code>AssignDataBat</code> and <code>AssignDataBatRev</code> is that in the latter the bat
fur isotope values were corrected to align with the current delta values for deuterium
for keratin reference materials (Soto et al. 2017, https://doi.org/10.1002/rcm.7893)
ensuring comparability between formerly and more recently normalized datasets of delta values for deuterium.
</p>


<h3>Format</h3>

<p>Two <em>dataframes</em> with 14 observations and 4 variables:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_ID </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> Identification of the animal </td>
</tr>
<tr>
 <td style="text-align: left;">
   lat </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Latitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   long </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Longitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_value </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Hydrogen delta value of the tissue </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>data provided by  Voigt CC &amp; Lehnert L.
</p>


<h3>References</h3>

<p>Voigt CC &amp; Lehnert L (2019). Tracking of movements of terrestrial
mammals using stable isotopes. In Hobson KA &amp; Wassenaar LI (eds.), Tracking Animal
Migration with Stable Isotopes, second edition. Academic Press, London.
</p>
<p>Soto DX, Koehler G, Wassenaar LI &amp; Hobson KA (2017). Re-evaluation of the hydrogen stable
isotopic composition of keratin calibration standards for wildlife and forensic
science applications. Rapid Commun Mass Spectrom. 31(14):1193-1203.
doi: 10.1002/rcm.7893. PMID: 28475227.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isofind">isofind</a></code> to perform assignments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(AssignDataBat)
str(AssignDataBat)

</code></pre>

<hr>
<h2 id='AssignDataBat2'>Assignment datasets for bat species</h2><span id='topic+AssignDataBat2'></span><span id='topic+AssignDataBat2Rev'></span>

<h3>Description</h3>

<p>These datasets contain data from Voigt, Lehmann &amp; Greif (2015). It contains
hydrogen delta values of fur keratin from bats captured in 2008, 2009 and
2013 from their roosting sites in Bulgaria. We only retained the bats of the
genus Myotis from the original study. These data can be used as an example to
perform assignments using the function <code><a href="#topic+isofind">isofind</a></code>.  The difference
between <code>AssignDataBat2</code> and <code>AssignDataBat2Rev</code> is that in the latter the bat
fur isotope values were corrected to align with the current delta values for deuterium
for keratin reference materials (Soto et al. 2017, https://doi.org/10.1002/rcm.7893)
ensuring comparability between formerly and more recently normalized datasets of delta values for deuterium.
</p>


<h3>Format</h3>

<p>Two <em>dataframes</em> with 244 observations and 3 variables:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_ID </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> Identification of the animal </td>
</tr>
<tr>
 <td style="text-align: left;">
   species </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> Animal species name </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_value </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Hydrogen delta value of the tissue </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>data provided by Voigt CC, Lehmann D &amp; Greif S.
</p>


<h3>References</h3>

<p>Voigt CC, Lehmann D &amp; Greif S (2015). Stable isotope
ratios of hydrogen separate mammals of aquatic and terrestrial food webs.
Methods in Ecology and Evolution 6(11).
</p>
<p>Soto DX, Koehler G, Wassenaar LI &amp; Hobson KA (2017). Re-evaluation of the hydrogen stable
isotopic composition of keratin calibration standards for wildlife and forensic
science applications. Rapid Commun Mass Spectrom. 31(14):1193-1203.
doi: 10.1002/rcm.7893. PMID: 28475227.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isofind">isofind</a></code> to perform assignments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(AssignDataBat2)
str(AssignDataBat2)

</code></pre>

<hr>
<h2 id='CalibDataAlien'>Simulated calibration dataset</h2><span id='topic+CalibDataAlien'></span>

<h3>Description</h3>

<p>This dataset contains simulated hydrogen delta values for corresponding locations
based on an assumed linear relationship between the animal tissue value and the
hydrogen delta values in the environment.
The data can be used as an example to fit a calibration model using the
function <code><a href="#topic+calibfit">calibfit</a></code>.
</p>


<h3>Format</h3>

<p>A <em>dataframe</em> with x observations and 6 variables:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   site_ID </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> Identification of the sampling site </td>
</tr>
<tr>
 <td style="text-align: left;">
   long </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Longitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   lat </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Latitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   elev </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Elevation asl (m) </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_ID </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> Identification of the sampled animal </td>
</tr>
<tr>
 <td style="text-align: left;">
   tissue.value </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Hydrogen delta value of the tissue </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>Users who wish to use their own dataset for calibration should create a
<em>dataframe</em> of similar structure than this one. The columns should possess
the same names as the ones described above. If the elevation is unknown at the
sampling sites, elevation information can be extracted from a high resolution elevation
raster using the function <code><a href="terra.html#topic+extract">terra::extract</a></code>. In this dataset, we
retrieved elevations from the Global Multi-resolution Terrain Elevation Data
2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibfit">calibfit</a></code> to fit a calibration model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(CalibDataAlien)
str(CalibDataAlien)

## The examples below will only be run if sufficient time is allowed
## You can change that by typing e.g. options_IsoriX(example_maxtime = XX)
## if you want to allow for examples taking up to ca. XX seconds to run
## (so don't write XX but put a number instead!)

if (getOption_IsoriX("example_maxtime") &gt; 30) {
  ## We prepare the precipitation data
  GNIPDataDEagg &lt;- prepsources(data = GNIPDataDE)

  ## We fit the models for Germany
  GermanFit &lt;- isofit(data = GNIPDataDEagg)

  ## We build the isoscape
  GermanScape &lt;- isoscape(raster = ElevRasterDE, isofit = GermanFit)

  ## We create a simulated dataset with 50 site and 10 observations per site
  set.seed(2L)
  CalibDataAlien &lt;- create_aliens(
    calib_fn = list(intercept = 3, slope = 0.5, resid_var = 5),
    isoscape = GermanScape,
    raster = ElevRasterDE,
    n_sites = 50,
    min_n_samples = 10,
    max_n_samples = 10
  )
  plot(sample_value ~ source_value, data = CalibDataAlien)
  abline(3, 0.5)

  CalibDataAlien$source_value &lt;- NULL

  ## Uncomment the following to store the file as we did
  # save(CalibDataAlien, file = "CalibDataAlien.rda", compress = "xz")
}

</code></pre>

<hr>
<h2 id='CalibDataBat'>Calibration datasets for bat species</h2><span id='topic+CalibDataBat'></span><span id='topic+CalibDataBatRev'></span>

<h3>Description</h3>

<p>These datasets contain hydrogen delta values of fur keratin from 6 sedentary
bat species. They correspond to the combination of several studies as detailed
in Voigt &amp; Lenhert 2019. <code>CalibDataBat</code> is the dataset used in Courtiol et al. 2019.
The data can be used as an example to fit a calibration model using the
function <code><a href="#topic+calibfit">calibfit</a></code>. <code>CalibDataBatRev</code> is the same data but the bat
fur isotope values were corrected to align with the current delta values for deuterium
for keratin reference materials (Soto et al. 2017, https://doi.org/10.1002/rcm.7893)
ensuring comparability between formerly and more recently normalized datasets of delta values for deuterium.
</p>


<h3>Format</h3>

<p>Two <em>dataframes</em> with 335 observations and 7 variables:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   site_ID </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> Identification of the sampling site </td>
</tr>
<tr>
 <td style="text-align: left;">
   long </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Longitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   lat </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Latitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   elev </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Elevation asl (m) </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_ID </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> Identification of the sampled animal </td>
</tr>
<tr>
 <td style="text-align: left;">
   species </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> A code for the species </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_value </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Hydrogen delta value of the tissue </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>Users who wish to use their own dataset for calibration should create a
<em>dataframe</em> of similar structure than these ones (only the column 'species'
can be dropped). The columns should possess the same names as the ones
described above. If the elevation is unknown at the sampling sites, elevation
information can be extracted from a high resolution elevation raster using
the function <code><a href="terra.html#topic+extract">terra::extract</a></code> (see <strong>Examples</strong> in
<code><a href="#topic+CalibDataBat2">CalibDataBat2</a></code>).
</p>


<h3>Source</h3>

<p>data provided by Voigt CC &amp; Lehnert L.
</p>


<h3>References</h3>

<p>Voigt CC &amp; Lehnert L (2019). Tracking of movements of terrestrial
mammals using stable isotopes. In Hobson KA &amp; Wassenaar LI (eds.), Tracking Animal
Migration with Stable Isotopes, second edition. Academic Press, London.
</p>
<p>Courtiol A, Rousset F, Rohwäder M, Soto DX, Lehnert L, Voigt CC, Hobson KA, Wassenaar LI &amp; Kramer-Schadt S (2019). Isoscape
computation and inference of spatial origins with mixed models using the R package IsoriX. In Hobson KA &amp; Wassenaar LI (eds.),
Tracking Animal Migration with Stable Isotopes, second edition. Academic Press, London.
</p>
<p>Soto DX, Koehler G, Wassenaar LI &amp; Hobson KA (2017). Re-evaluation of the hydrogen stable
isotopic composition of keratin calibration standards for wildlife and forensic
science applications. Rapid Commun Mass Spectrom. 31(14):1193-1203.
doi: 10.1002/rcm.7893. PMID: 28475227.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalibDataBat2">CalibDataBat2</a></code> for another (related) calibration dataset
</p>
<p><code><a href="#topic+calibfit">calibfit</a></code> to fit a calibration model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(CalibDataBat)
str(CalibDataBat)
</code></pre>

<hr>
<h2 id='CalibDataBat2'>Calibration datasets for bat species</h2><span id='topic+CalibDataBat2'></span><span id='topic+CalibDataBat2Rev'></span>

<h3>Description</h3>

<p>These datasets contain hydrogen delta values of fur keratin from sedentary
bat species captured between 2005 and 2009 from Popa-Lisseanu et al. (2012).
These data can be used as an example to fit a calibration model using the
function <code><a href="#topic+calibfit">calibfit</a></code>. The difference between <code>CalibDataBat2</code> and
<code>CalibDataBat2Rev</code> is that in the latter the bat
fur isotope values were corrected to align with the current delta values for deuterium
for keratin reference materials (Soto et al. 2017, https://doi.org/10.1002/rcm.7893)
ensuring comparability between formerly and more recently normalized datasets of delta values for deuterium.
</p>


<h3>Format</h3>

<p>Two <em>dataframes</em> with 178 observations and 6 variables:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   site_ID </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> Identification of the sampling site </td>
</tr>
<tr>
 <td style="text-align: left;">
   long </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Longitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   lat </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Latitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   elev </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Elevation asl (m) </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_ID </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> Identification of the sampled animal </td>
</tr>
<tr>
 <td style="text-align: left;">
   sample_value </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Hydrogen delta value of the tissue </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>Users who wish to use their own dataset for calibration should create a
<em>dataframe</em> of similar structure than these ones (only the column
'species' can be dropped). The columns should possess the same names as the
ones described above. If the elevation is unknown at the sampling sites,
elevation information can be extracted from a high resolution elevation
raster using the function <code><a href="terra.html#topic+extract">terra::extract</a></code> (see <strong>Examples</strong>).
Note that the original study used a different source of elevation data.
</p>


<h3>Source</h3>

<p>data provided by Popa-Lisseanu AG et al.
</p>


<h3>References</h3>

<p>Popa-Lisseanu AG, Soergel K, Luckner A, Wassenaar LI, Ibanez C,
Kramer-Schadt S, Ciechanowski M, Goerfoel T, Niermann I, Beuneux G,
Myslajek RW, Juste J, Fonderflick J, Kelm D &amp; Voigt CC (2012).
A triple isotope approach to predict the breeding origins of European bats.
PLoS ONE 7(1):e30388.
</p>
<p>Soto DX, Koehler G, Wassenaar LI &amp; Hobson KA (2017). Re-evaluation of the hydrogen stable
isotopic composition of keratin calibration standards for wildlife and forensic
science applications. Rapid Commun Mass Spectrom. 31(14):1193-1203.
doi: 10.1002/rcm.7893. PMID: 28475227.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalibDataBat">CalibDataBat</a></code> for another (related) calibration dataset
</p>
<p><code><a href="#topic+calibfit">calibfit</a></code> to fit a calibration model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(CalibDataBat2)
str(CalibDataBat2)

## The following example require to have downloaded
## an elevation raster with the function getelev()
## and will therefore not run unless you uncomment it

# if (require(terra)){
#    ## We delete the elevation data
#    CalibDataBat2$elev &lt;- NULL
#
#    ## We reconstruct the elevation data using an elevation raster
#    getelev(file = "elevBats.tif", z = 6,
#            lat_min = min(CalibDataBat2$lat),
#            lat_max = max(CalibDataBat2$lat),
#            long_min = min(CalibDataBat2$long),
#            long_max = max(CalibDataBat2$long))
#    ElevationRasterBig &lt;- rast("elevBats.tif")
#    CalibDataBat2$elev &lt;- extract(
#        ElevationRasterBig,
#        cbind(CalibDataBat2$long, CalibDataBat2$lat))
#    head(CalibDataBat2)
# }

</code></pre>

<hr>
<h2 id='calibfit'>Fit the calibration model (or load parameters from calibration done outside
IsoriX)</h2><span id='topic+calibfit'></span><span id='topic+print.CALIBFIT'></span><span id='topic+summary.CALIBFIT'></span>

<h3>Description</h3>

<p>This function establishes the relationship between the isotopic values of
organisms (e.g. tissues such as hair, horn, ivory or feathers; referred in
code as <em>sample_value</em>) and the isotopic values of their environment (e.g.
precipitation water; referred in code as <em>source_value</em>). This function is
only needed when the assignment of organisms has to be performed within an
isoscape that was not built using the organisms themselves, but that was
instead built using another source of isotopic values (e.g., precipitation).
If the isoscape had been fitted using isotopic ratios from sedentary animals
directly, this calibration step is not needed (e.g. isoscape fitted using
sedentary butterflies and migratory butterflies to assign). In other cases,
this calibration step is usually needed since organisms may not directly
reflect the isotopic values of their environment. Depending on the
calibration data to be used (provided via the argument <code>data</code>), one of four
possible calibration methods must be selected (via the argument <code>method</code>).
Each method considers a different statistical model and requires particular
data that are organised in a specific way (see <strong>Details</strong> for explanations
and <strong>Examples</strong> for use cases).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibfit(
  data,
  isofit = NULL,
  method = c("wild", "lab", "desk", "desk_inverse"),
  verbose = interactive(),
  control_optim = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibfit_+3A_data">data</code></td>
<td>
<p>A <em>dataframe</em> containing the calibration data (see note
below)</p>
</td></tr>
<tr><td><code id="calibfit_+3A_isofit">isofit</code></td>
<td>
<p>The fitted isoscape created by <code><a href="#topic+isofit">isofit</a></code></p>
</td></tr>
<tr><td><code id="calibfit_+3A_method">method</code></td>
<td>
<p>A <em>string</em> indicating the method used to generate the data
used for the calibration. By default method is <code>"wild"</code>, but the other
<code>"lab"</code>, <code>"desk"</code> and <code>"desk_inverse"</code>.
See <strong>Details</strong> for the difference between these three methods.</p>
</td></tr>
<tr><td><code id="calibfit_+3A_verbose">verbose</code></td>
<td>
<p>A <em>logical</em> indicating whether information about the
progress of the procedure should be displayed or not while the function is
running. By default verbose is <code>TRUE</code> if you run an interactive R
session and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="calibfit_+3A_control_optim">control_optim</code></td>
<td>
<p>A <em>list</em> to pass information to the argument control
in the call to <code><a href="stats.html#topic+optim">optim</a></code> (only effective when <code>method = "wild"</code>; for advanced users only).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>method</code> argument can take one of the four values &quot;wild&quot; (default),
&quot;lab&quot;, &quot;desk&quot; and &quot;desk_inverse&quot; corresponding to the four calibration
methods. It is crucial for you to select the method that is most appropriate
for your workflow, as the choice of method can impact the most likely
assignment locations during the assignment test performed in
<code><a href="#topic+isofind">isofind</a></code>.
</p>


<h4>Method &quot;wild&quot;</h4>

<p>This calibration method is the one to be used when the calibration data to be
used correspond to isotopic values measured on sedentary organisms and when
no direct measurement of isotopic values in the environment are available at
the locations where sedentary organisms have been collected. In such a case,
the isotopic values in the environment of sedentary organisms are predicted
internally using an isoscape fitted with <code><a href="#topic+isofit">isofit</a></code>. This calibration method
thus aims at estimating and accounting for the uncertainty associated with
these predicted values. Such uncertainty is accounted for when fitting the
calibration fit so as to produce an unbiased estimation of the calibration
relationship and it is also then accounted for by <code><a href="#topic+isofind">isofind</a></code> when inferring
the possible locations of origin. Before we added the argument <code>method</code> in
calibfit (i.e. before releasing the version 0.8.3), this method was the only
one available in IsoriX.
</p>

<ul>
<li> <p><strong>Statistical model</strong>: in this case, the calibration model to be fitted is
a linear mixed-effects model (LMM) that fits the isotopic values of sedentary
organisms as a linear function of the isotopic values in their environment
(e.g. precipitation). The function considers that the isotopic values from
the environment (e.g. from precipitation) at the locations at which organisms
were sampled are not known. The function therefore predicts these isotopic
values from the geostatistical model fitted by the function <code><a href="#topic+isofit">isofit</a></code>, which
is provided to calibfit using the argument <code>isofit</code>. The LMM used to fit the
calibration function has a simple fixed-effect structure: an intercept and a
slope. The random effect is more complex: it is normally distributed with
mean zero, a certain variance between locations proportional to the squared
(fixed) slope, and a covariance structure defined by the prediction
covariance matrix of the isoscape model between the calibration locations.
See appendix in Courtiol et al. 2019 for more details.
</p>
</li>
<li> <p><strong>Required calibration data</strong>: the calibration data to be used here must be
a dataframe (or a tibble) containing at least the following columns:
</p>

<ul>
<li> <p><code>sample_value</code>: the isotopic value of the calibration sample
</p>
</li>
<li> <p><code>long</code>: the longitude coordinate (decimal degrees)
</p>
</li>
<li> <p><code>lat</code>: the latitude coordinate (decimal degrees)
</p>
</li>
<li> <p><code>site_ID</code>: the sample site
</p>
</li></ul>

<p>The column name must be identical to those indicated here. Other columns
can be present in the data but won't be used. Each row must correspond to
a different calibration sample (i.e. a single isotopic measurement). See
<code><a href="#topic+CalibDataAlien">CalibDataAlien</a></code>, <code><a href="#topic+CalibDataBat">CalibDataBat</a></code>, or
<code><a href="#topic+CalibDataBat2">CalibDataBat2</a></code> for examples of such a dataset.
</p>
</li></ul>




<h4>Method &quot;lab&quot;</h4>

<p>This calibration method is the one to be used when the calibration data to be
used correspond to isotopic values recorded for both organisms and their
environment. We can foresee three main situations in which the &quot;lab&quot; method
is the one to be used:
</p>

<ol>
<li><p> the data are generated by growing organisms in a controlled
environment where they are fed and/or given water with a specific (known)
isotopic value.
</p>
</li>
<li><p> sedentary organisms are sampled in the wild together with a sample
from their environment and that isotopic values have been measured for
both.
</p>
</li>
<li><p> you want to use a calibration made by others based on a plot of that
calibration showing the datapoints. In such a case, you should use an R
package (e.g. metaDigitse or digitize) or software (e.g. graphClick or
dataThief) to extract the coordinates on the plots so as to obtain the
isotopic values of the sample and the environment behind each point.
</p>
</li></ol>

<p>Note that the use cases 1 and 2 will allow for the propagation of all
relevant sources of uncertainty during the assignment. In contrast, the third
use case implies to neglect uncertainty in the isotopic values in the
environment if those were initially predicted using an isoscape. It also
neglects the covariances involving such predicted values. That being said, if
you want to use someone else calibration relationship, using this method is
generally preferable to using the method &quot;desk&quot; described below (less error
prone and de facto accounting for all five parameters mentioned for the
method &quot;desk&quot;).
</p>

<ul>
<li> <p><strong>Statistical model</strong>: in this case, the calibration model to be fitted is
a simple linear model (LM) or a simple linear mixed-effects model (LMM) that
fits the isotopic values of sedentary organisms as a linear function of the
isotopic values in their environment (e.g. precipitation). Whether it is a LM
or a LMM depends on the presence of a column <code>site_ID</code> in the dataset as
well as on the number of unique values for such a column. If the column is
present and the number of unique values is larger than 4, a LMM is fitted.
Otherwise, a LM is fitted. In both cases, the function considers that the
isotopic values from the environment (e.g. from precipitation) at the
locations at which organisms were sampled are known. Contrary to the method
&quot;wild&quot;, the environment values are thus considered as observed and not
predicted from an isoscape. The argument <code>isofit</code> should thus remain
<code>NULL</code> in this case (since no isoscape is used, no isoscape fit is
required to perform the calibration). The model used to fit the calibration
function has a simple fixed effect structure: an intercept and a slope.
</p>
</li>
<li> <p><strong>Required calibration data</strong>: the calibration data to be used here must be
a dataframe (or a tibble) containing at least the following columns:
</p>

<ul>
<li> <p><code>sample_value</code>: the isotopic value of the calibration sample
</p>
</li>
<li> <p><code>source_value</code>: the isotopic value of the environment
</p>
</li>
<li> <p><code>site_ID</code> (optional): the sample site
</p>
</li></ul>

<p>The column name must be identical to those indicated here. Other columns
can be present in the data but won't be used. Each row must correspond to
a different calibration sample (i.e. a single sample-environment pair of
isotopic measurements).
</p>
</li></ul>




<h4>Methods &quot;desk&quot; and &quot;desk_inverse&quot;</h4>

<p>These calibration methods must only be used as a last resource! They are
unlikely to yield robust inference during the assignment step. These
calibration methods are the ones to be used when no calibration data is
directly available, when you cannot either extract the data from a plot, and
thus when you must rely solely on published metrics (including intercept and
slope) to represent a calibration relationship. They work by making crude
assumptions that various uncertainty components are null.
</p>
<p>The method &quot;desk&quot; is the one to be used when the published calibration
relationship is of the form <code>lm(sample_value ~ source_value)</code> and the
method &quot;desk_inverse&quot; is the one to be used when the published calibration
relationship is of the form <code>lm(source_value ~ sample_value)</code>. Do make
sure you are using the correct alternative. Note that the model used for the
published calibration must be a linear regression (LM) and not a reduced
major axis regression (RMA). If you use parameter values stemming from a RMA,
the assignment will most likely be biased.
</p>
<p>Both methods require five metrics to work at their best: the intercept and
slope of a calibration relationship, the standard errors (SE) associated to
them, and the residual variance (not SD). For statistical reasons, the method
&quot;desk&quot; is more flexible than the method &quot;desk_inverse&quot; and can still work (in
the sense of running, but the reliability of the assignments will get worse)
if the SEs and/or the residual variance is not provided. For the method
&quot;desk_inverse&quot; all metrics are unfortunately necessary.
</p>
<p>Don't expect miracles: even if the &quot;desk&quot; method is used together with its
five parameters, the assignment will still suffer from the same limitations
as those impacting the method &quot;lab&quot; usage number 3. If less than five
parameters are provided, further assumptions are made and this comes with a
cost: again, it can bias the assignment and bias the confidence region. For
these reasons, we were tempted to use <code>method = "dirty"</code> instead of
<code>method = "desk"</code>... but we chickened out since we predicted that users
would then refrain from mentioning the method they used in publications...
</p>
<p>Note that if the provided slope is set to 0 and an intercept is considered,
the calibration methods actually corresponds to the simple consideration of a
fractionation factor.
</p>

<ul>
<li> <p><strong>Statistical model</strong>: none!
</p>
</li>
<li> <p><strong>Required calibration data</strong> for method &quot;desk&quot;: the calibration data to be
used here must be a dataframe (or a tibble) containing a single row with the
following columns:
</p>

<ul>
<li> <p><code>intercept</code>: the estimated slope of a LM calibration fit
</p>
</li>
<li> <p><code>slope</code>: the estimated slope of a LM calibration fit
</p>
</li>
<li> <p><code>intercept_se</code> (optional): the standard error around the intercept
</p>
</li>
<li> <p><code>slope_se</code> (optional): the standard error around the slope
</p>
</li>
<li> <p><code>resid_var</code> (optional): the residual variance (not SD) of a LM
calibration fit
</p>
</li></ul>

</li>
<li> <p><strong>Required calibration data</strong> for method &quot;desk_inverse&quot;: the calibration
data to be used here must be a dataframe (or a tibble) containing a single
row with the following columns:
</p>

<ul>
<li> <p><code>intercept</code>: the estimated slope of a LM calibration fit
</p>
</li>
<li> <p><code>slope</code>: the estimated slope of a LM calibration fit
</p>
</li>
<li> <p><code>intercept_se</code>: the standard error around the intercept
</p>
</li>
<li> <p><code>slope_se</code>: the standard error around the slope
</p>
</li>
<li> <p><code>resid_var</code>: the residual variance (not SD) of a LM calibration fit
</p>
</li>
<li> <p><code>sign_mean_Y</code>: a <em>numeric</em> indicating the sign of the mean
value of the isotopes in the environment in the format returned by <code><a href="base.html#topic+sign">sign</a></code>;
that is either <code>1</code> (if positive) or <code>-1</code> (if negative). This is
required for pivoting the regression from &quot;desk_inverse&quot; to &quot;desk&quot;.
</p>
</li>
<li> <p><code>N</code>: a  <em>numeric</em> indicating the sample size of the data used
for the calibration fit. This is required for pivoting the regression from
&quot;desk_inverse&quot; to &quot;desk&quot;.
</p>
</li></ul>

</li></ul>




<h3>Value</h3>

<p>This function returns a <em>list</em> of class <em>CALIBFIT</em> containing
the name of the calibration method used, whether a species_ID random effect
was estimated, whether a site_ID random effect was estimated, the
fixed-effect estimates of the calibration function, the covariance of the
fixed effects, the residual variance of the calibration fit, the fitted
calibration model (if applicable), the fitted isoscape model (if
applicable), the original calibration data set with additional information
added during the fit, and the location of the calibration points as spatial
points.
</p>


<h3>References</h3>

<p>Courtiol A, Rousset F, Rohwäder M, Soto DX, Lehnert L, Voigt CC,
Hobson KA, Wassenaar LI &amp; Kramer-Schadt S (2019). Isoscape computation and
inference of spatial origins with mixed models using the R package IsoriX.
In Hobson KA &amp; Wassenaar LI (eds.), Tracking Animal Migration with Stable
Isotopes, second edition. Academic Press, London.
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+plot">plot</a></code> for the help on how to plot the calibration
relationship.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The examples below will only be run if sufficient time is allowed
## You can change that by typing e.g. options_IsoriX(example_maxtime = XX)
## if you want to allow for examples taking up to ca. XX seconds to run
## (so don't write XX but put a number instead!)

if (getOption_IsoriX("example_maxtime") &gt; 30) {
  #####################################################
  ## 1 Example of calibration using the method "wild" #
  #####################################################

  ## 1.1 We prepare the data to fit the isoscape:
  GNIPDataDEagg &lt;- prepsources(data = GNIPDataDE)

  ## 1.2 We fit the isoscape models for Germany:
  GermanFit &lt;- isofit(
    data = GNIPDataDEagg,
    mean_model_fix = list(elev = TRUE, lat_abs = TRUE)
  )

  ## 1.3 We fit the calibration model using the method "wild" (the default):
  CalibAlien &lt;- calibfit(data = CalibDataAlien, isofit = GermanFit)

  ## 1.4 We explore the outcome of the calibration:
  CalibAlien
  summary(CalibAlien)
  plot(CalibAlien)

  ## Note 1: you can plot several calibrations at once (using bats this time):
  CalibBat1 &lt;- calibfit(data = CalibDataBat, isofit = GermanFit)
  CalibBat2 &lt;- calibfit(data = CalibDataBat2, isofit = GermanFit)
  plot(CalibBat1)
  points(CalibBat2, pch = 3, col = "red", CI = list(col = "green"))

  ## Note 2: you can extract data created by plot()
  ## for plotting things yourself:
  dataplot &lt;- plot(CalibAlien, plot = FALSE)
  plot(sample_fitted ~ source_value,
    data = dataplot,
    xlim = range(dataplot$source_value),
    ylim = range(dataplot$sample_lwr, dataplot$sample_upr), col = NULL
  )
  polygon(
    x = c(dataplot$source_value, rev(dataplot$source_value)),
    y = c(dataplot$sample_lwr, rev(dataplot$sample_upr)),
    col = 3
  )
  points(sample_fitted ~ source_value, data = dataplot, type = "l", lty = 2)


  ####################################################
  ## 2 Example of calibration using the method "lab" #
  ####################################################

  ## 2.0 We create made up data here because we don't have yet a good dataset
  ## for this case, but you should use your own data instead:
  GermanScape &lt;- isoscape(raster = ElevRasterDE, isofit = GermanFit)
  set.seed(123)
  CalibDataAlien2 &lt;- create_aliens(
    calib_fn = list(
      intercept = 3, slope = 0.5,
      resid_var = 5
    ),
    isoscape = GermanScape,
    raster = ElevRasterDE,
    n_sites = 25,
    min_n_samples = 5,
    max_n_samples = 5
  )
  CalibDataAlien2 &lt;- CalibDataAlien2[, c(
    "site_ID", "sample_ID",
    "source_value", "sample_value"
  )]
  head(CalibDataAlien2) ## your data should have this structure

  ## 2.1 We fit the calibration model using the method "lab":
  CalibAlien2 &lt;- calibfit(data = CalibDataAlien2, method = "lab")

  ## 2.2 We explore the outcome of the calibration:
  CalibAlien2
  summary(CalibAlien2)
  plot(CalibAlien2)


  #####################################################
  ## 3 Example of calibration using the method "desk" #
  #####################################################

  ## 3.1 We format the information about the calibration function to be used
  ## as a dataframe:
  CalibDataAlien3 &lt;- data.frame(
    intercept = 1.67, slope = 0.48,
    intercept_se = 1.65, slope_se = 0.03,
    resid_var = 3.96
  )
  CalibDataAlien3

  ## 3.2 We fit the calibration model using the method "desk":
  CalibAlien3 &lt;- calibfit(data = CalibDataAlien3, method = "desk")

  ## 3.3 We explore the outcome of the calibration:
  CalibAlien3
  summary(CalibAlien3)
  plot(CalibAlien3, xlim = c(-100, 100), ylim = c(-50, 50))

  ## Note: the desk function also work with just intercept and slope:
  CalibDataAlien4 &lt;- CalibDataAlien3[, c("intercept", "slope")]
  CalibAlien4 &lt;- calibfit(data = CalibDataAlien4, method = "desk")
  CalibAlien4
  summary(CalibAlien4)
  plot(CalibAlien3, xlim = c(-100, 100), ylim = c(-50, 50))
  points(CalibAlien4, line = list(col = "orange"))
  ## Regression lines are the same, but the new calibration does not have a
  ## confidence intervals since we provided no uncertainty measure in
  ## CalibDataAlien4, which will make a difference during assignments...


  #############################################################
  ## 4 Example of calibration using the method "desk_inverse" #
  #############################################################

  ## 4.1 We format the information about the calibration function to be used
  ## as a dataframe:
  CalibDataAlien4 &lt;- data.frame(
    intercept = -16.98822, slope = 1.588885,
    intercept_se = 2.200435, slope_se = 0.08106032,
    resid_var = 13.15102, N = 125, sign_mean_Y = -1
  )
  CalibDataAlien4

  ## 4.2 We fit the calibration model using the method "desk_inverse":
  CalibAlien4 &lt;- calibfit(data = CalibDataAlien4, method = "desk_inverse")

  ## 4.3 We explore the outcome of the calibration:
  CalibAlien4
  summary(CalibAlien4)
  plot(CalibAlien4, xlim = c(-100, 100), ylim = c(-50, 50))
}

</code></pre>

<hr>
<h2 id='CALIBFIT-class'>Class CALIBFIT</h2><span id='topic+CALIBFIT-class'></span>

<h3>Description</h3>

<p>Class CALIBFIT
</p>


<h3>Slots</h3>


<dl>
<dt><code>method</code></dt><dd><p>a character string indicating the method used for the calibration</p>
</dd>
<dt><code>species_rand</code></dt><dd><p>a logical indicating whether the species random effect is included in the model</p>
</dd>
<dt><code>site_rand</code></dt><dd><p>a logical indicating whether the site random effect is included in the model</p>
</dd>
<dt><code>param</code></dt><dd><p>the fixed-effect estimates of the calibration function</p>
</dd>
<dt><code>fixefCov</code></dt><dd><p>the covariance matrix of the fixed effects</p>
</dd>
<dt><code>phi</code></dt><dd><p>the residual variance of the calibration fit</p>
</dd>
<dt><code>calib_fit</code></dt><dd><p>the fitted calibration model (if applicable)</p>
</dd>
<dt><code>iso_fit</code></dt><dd><p>the fitted calibration model (if applicable)</p>
</dd>
<dt><code>data</code></dt><dd><p>the calibration data</p>
</dd>
<dt><code>sp_points</code></dt><dd><p>a list of spatial points used for calibration</p>
</dd>
</dl>

<hr>
<h2 id='CountryBorders'>Borders of world CountryBorders</h2><span id='topic+CountryBorders'></span>

<h3>Description</h3>

<p>This dataset contains a polygon polygon SpatVector (from <span class="pkg">terra</span>).
It can be used to draw the borders of world countries.
</p>


<h3>Format</h3>

<p>A <em>SpatVector</em> object
</p>


<h3>Source</h3>

<p>This <em>SpatVector</em> is derived from the package
<span class="pkg">rnaturalearth</span>. Please refer to this other package for description and
sources of this dataset. See example for details on how we created the
dataset.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+OceanMask">OceanMask</a></code> for another polygon used to embellish the plots
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
plot(CountryBorders, border = "red", col = "darkgrey")

## How did we create this file?

## Uncomment the following to create the file as we did
# if (require(rnaturalearth) &amp;&amp; require(terra)) {
#    CountryBorders &lt;- rnaturalearth::ne_countries(scale = 'medium', returnclass = 'sf')
#    CountryBorders &lt;- vect(CountryBorders[, 0])
#    #saveRDS(CountryBorders, file = "IsoriX/inst/extdata/CountryBorders.rds", compress = "xz")
# }

</code></pre>

<hr>
<h2 id='create_aliens'>Simulate datasets for calibrations or assignments</h2><span id='topic+create_aliens'></span>

<h3>Description</h3>

<p>This function allows to simulate data so to provide examples for the
calibration and for the assignment procedure. We name the simulated
individuals 'Aliens' so to make it clear that the data we use to illustrate
our package are not real data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_aliens(
  calib_fn = list(intercept = 3, slope = 0.5, resid_var = 5),
  isoscape = NULL,
  coordinates = NA,
  raster = NULL,
  n_sites = NA,
  min_n_samples = 1,
  max_n_samples = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_aliens_+3A_calib_fn">calib_fn</code></td>
<td>
<p>A <em>list</em> containing the parameter values describing the
relationship between the isotope values in the environment and those in the
simulated organisms. This list must contain three parameters: the
intercept, the slope, and the residual variance.</p>
</td></tr>
<tr><td><code id="create_aliens_+3A_isoscape">isoscape</code></td>
<td>
<p>The output of the function <code><a href="#topic+isoscape">isoscape</a></code></p>
</td></tr>
<tr><td><code id="create_aliens_+3A_coordinates">coordinates</code></td>
<td>
<p>An optional <em>data.frame</em> with columns <code>site_ID</code>,
<code>long</code> and <code>lat</code></p>
</td></tr>
<tr><td><code id="create_aliens_+3A_raster">raster</code></td>
<td>
<p>A <em>SpatRaster</em> containing an elevation raster</p>
</td></tr>
<tr><td><code id="create_aliens_+3A_n_sites">n_sites</code></td>
<td>
<p>The number of sites from which the simulated organisms
originate (<em>integer</em>)</p>
</td></tr>
<tr><td><code id="create_aliens_+3A_min_n_samples">min_n_samples</code></td>
<td>
<p>The minimal number of observations (<em>integer</em>) per
site</p>
</td></tr>
<tr><td><code id="create_aliens_+3A_max_n_samples">max_n_samples</code></td>
<td>
<p>The maximal number of observations (<em>integer</em>) per
site</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The isostopic values for the organisms are assumed to be linearly related to
the one from the environment. The linear function can be parametrized using
the first argument of the function (<code>calib_fn</code>). With this function the user
can simulate data for different sites.
</p>
<p>The number and locations of sites can be controlled in two ways. A first
possibility is to use the argument <code>n_sites</code>. The sites will then be selected
randomly among the locations present in the isoscape (argument <code>isoscape</code>)
provided to this function. An alternative possibility is to provide a data
frame containing three columns (<code>site_ID</code>, <code>long</code> and <code>lat</code>) to input the
coordinate of the sampling site manually.
</p>
<p>Irrespective of how locations are chosen, a random number of observations
will be drawn, at each site, according to a uniform distribution bounded by
the values of the argument <code>min_n_samples</code> and <code>max_n_samples</code>.
</p>
<p>From the selected coordinates, the isotope values for the environment are
directly extracted from the corresponding point predictions stored in the
isoscape object. No uncertainty is considered during this process. Then the
linear calibration defines the means of the isotope values for the simulated
organisms. The actual values is then drawn from a Gaussian distribution
centred around such mean and a variance defined by the residual variance
(<code>resid_var</code>) input within the list <code>calib_fn</code>.
</p>


<h3>Value</h3>

<p>This functions returns a <em>data.frame</em> (see example for column
names)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibfit">calibfit</a></code> for a calibration based on simulated data
</p>
<p><code><a href="#topic+isofind">isofind</a></code> for an assignment based on simulated data
</p>
<p><code><a href="#topic+IsoriX">IsoriX</a></code> for the complete work-flow of our package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The examples below will only be run if sufficient time is allowed
## You can change that by typing e.g. options_IsoriX(example_maxtime = XX)
## if you want to allow for examples taking up to ca. XX seconds to run
## (so don't write XX but put a number instead!)

if (getOption_IsoriX("example_maxtime") &gt; 30) {
  ## We fit the models for Germany
  GNIPDataDEagg &lt;- prepsources(data = GNIPDataDE)

  GermanFit &lt;- isofit(data = GNIPDataDEagg)

  ## We build the isoscapes
  GermanScape &lt;- isoscape(raster = ElevRasterDE, isofit = GermanFit)

  ## We create a simulated dataset with 25 sites and 5 observations per site
  Aliens &lt;- create_aliens(
    calib_fn = list(intercept = 3, slope = 0.5, resid_var = 5),
    isoscape = GermanScape,
    raster = ElevRasterDE,
    n_sites = 25,
    min_n_samples = 5,
    max_n_samples = 5
  )

  ## We display the simulated dataset
  Aliens

  ## We plot the relationship between the environmental isotope values
  ## and those from the simulated organisms
  plot(sample_value ~ source_value, data = Aliens, ylab = "Tissue", xlab = "Environment")
  abline(3, 0.5, col = "blue") ## the true relationship

  ## We create a simulated dataset with 2 sites imputing coordinates manually
  Aliens2 &lt;- create_aliens(
    calib_fn = list(intercept = 3, slope = 0.5, resid_var = 5),
    isoscape = GermanScape,
    coordinates = data.frame(
      site_ID = c("Berlin", "Bielefeld"),
      long = c(13.52134, 8.49914),
      lat = c(52.50598, 52.03485)
    ),
    raster = ElevRasterDE,
    min_n_samples = 5,
    max_n_samples = 5
  )

  Aliens2
}

</code></pre>

<hr>
<h2 id='downloadfile'>Download files and check their binary integrity</h2><span id='topic+downloadfile'></span>

<h3>Description</h3>

<p>This function is the internal function used in IsoriX to download the large
files from internet and it could be useful to download anything from within
R. We created this function to make sure that the downloaded files are valid.
Downloads can indeed result in files that are corrupted, so we tweaked the
options to reduce this possibility and the function runs a check if the
signature of the file is provided to the argument <code>md5sum</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downloadfile(
  address = NULL,
  filename = NULL,
  path = NULL,
  overwrite = FALSE,
  md5sum = NULL,
  verbose = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="downloadfile_+3A_address">address</code></td>
<td>
<p>A <em>string</em> indicating the address of the file on internet</p>
</td></tr>
<tr><td><code id="downloadfile_+3A_filename">filename</code></td>
<td>
<p>A <em>string</em> indicating the name under which the file must
be stored</p>
</td></tr>
<tr><td><code id="downloadfile_+3A_path">path</code></td>
<td>
<p>A <em>string</em> indicating where to store the file on the hard
drive (without the file name!). Default = current directory.</p>
</td></tr>
<tr><td><code id="downloadfile_+3A_overwrite">overwrite</code></td>
<td>
<p>A <em>logical</em> indicating if an existing file should be
re-downloaded</p>
</td></tr>
<tr><td><code id="downloadfile_+3A_md5sum">md5sum</code></td>
<td>
<p>A <em>string</em> indicating the md5 signature of the valid file
as created with <code><a href="tools.html#topic+md5sum">tools::md5sum</a></code></p>
</td></tr>
<tr><td><code id="downloadfile_+3A_verbose">verbose</code></td>
<td>
<p>A <em>logical</em> indicating whether information about the
progress of the procedure should be displayed or not while the function is
running. By default verbose is <code>TRUE</code> if users use an interactive R
session and <code>FALSE</code> otherwise. If a <em>numeric</em> is provided instead,
additional information about the download will be provided if the number is
greater than 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The complete path of the downloaded file (invisibly)
</p>


<h3>Note</h3>

<p>Users should directly use the function <code><a href="#topic+getelev">getelev</a></code> and
<code><a href="#topic+getprecip">getprecip</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getelev">getelev</a></code>, <code><a href="#topic+getprecip">getprecip</a></code>
</p>

<hr>
<h2 id='ElevRasterDE'>The raster of elevation for Germany</h2><span id='topic+ElevRasterDE'></span>

<h3>Description</h3>

<p>This raster contains the elevation of the surface of Germany (meters above sea
level) with a resolution of approximately 40 square-km.
</p>


<h3>Format</h3>

<p>A <em>SpatRaster</em> object
</p>


<h3>Details</h3>

<p>This raster contains elevation data of Germany in a highly aggregated form
corresponding to a resolution of approximately one elevation value per 40
square-km. This is only for the purpose of having a small and easy-to-handle
file to practice, but it should not be used to perform real assignments!
</p>


<h3>Source</h3>

<p><a href="https://topotools.cr.usgs.gov/gmted_viewer/viewer.htm">https://topotools.cr.usgs.gov/gmted_viewer/viewer.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepraster">prepraster</a></code> to crop and/or aggregate this raster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Compute crudely the resolution (approximative size of cells in km2)
median(values(cellSize(ElevRasterDE, unit = "km")))

## How did we create this file (without IsoriX) ?

## Uncomment the following to create the file as we did

# ElevRasterDE &lt;- elevatr::get_elev_raster(locations = data.frame(
#                              x = c(5.5, 15.5), y = c(47, 55.5)),
#                              prj = "+proj=longlat +datum=WGS84 +no_defs",
#                              clip = "bbox", z = 3)
#
# ElevRasterDE &lt;- terra::rast(ElevRasterDE)


## How to create a similar file with IsoriX ?
#
# ## Download the tif file (see ?getelev)
# getelev(file = "~/ElevRasterDE.tif",
#         z = 3,
#         long_min = 5.5, long_max = 15.5, lat_min = 47, lat_max = 55.5)

# ## Convert the tif into R raster format
# ElevRasterDE &lt;- rast('~/ElevRasterDE.tif')

</code></pre>

<hr>
<h2 id='getelev'>Download an elevation raster from internet</h2><span id='topic+getelev'></span>

<h3>Description</h3>

<p>The function <code>getelev</code> downloads an elevation raster from internet. It
is a wrapper that 1) calls the function <code><a href="elevatr.html#topic+get_elev_raster">elevatr::get_elev_raster</a></code> to
download the data and 2) saves the downloaded raster on the hard drive (so
that you don't have to keep downloading the same file over and over again).
The file saved on the disk is a *.tif file which you can directly read using
the function <code><a href="terra.html#topic+rast">terra::rast</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getelev(
  file = "~/elevation_world_z5.tif",
  z = 5,
  long_min = -180,
  long_max = 180,
  lat_min = -90,
  lat_max = 90,
  margin_pct = 5,
  override_size_check = FALSE,
  overwrite = FALSE,
  Ncpu = getOption_IsoriX("Ncpu"),
  verbose = interactive(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getelev_+3A_file">file</code></td>
<td>
<p>A <em>string</em> indicating where to store the file on the hard
drive (default = <code style="white-space: pre;">&#8288;~/elevation_world_z5.tif&#8288;</code>)</p>
</td></tr>
<tr><td><code id="getelev_+3A_z">z</code></td>
<td>
<p>An <em>integer</em> between 1 and 14 indicating the resolution of the
file do be downloaded (1 = lowest, 14 = highest; default = 5)</p>
</td></tr>
<tr><td><code id="getelev_+3A_long_min">long_min</code></td>
<td>
<p>A <em>numeric</em> indicating the minimum longitude to select
from. Should be a number between -180 and 180 (default = -180).</p>
</td></tr>
<tr><td><code id="getelev_+3A_long_max">long_max</code></td>
<td>
<p>A <em>numeric</em> indicating the maximal longitude to select
from. Should be a number between -180 and 180 (default = 180).</p>
</td></tr>
<tr><td><code id="getelev_+3A_lat_min">lat_min</code></td>
<td>
<p>A <em>numeric</em> indicating the minimum latitude to select
from. Should be a number between -90 and 90 (default = -90).</p>
</td></tr>
<tr><td><code id="getelev_+3A_lat_max">lat_max</code></td>
<td>
<p>A <em>numeric</em> indicating the maximal latitude to select
from (default = 90).</p>
</td></tr>
<tr><td><code id="getelev_+3A_margin_pct">margin_pct</code></td>
<td>
<p>The percentage representing by how much the area should
extend outside the area used for cropping (default = 5, corresponding to
5%). Set to 0 if you want exact cropping.</p>
</td></tr>
<tr><td><code id="getelev_+3A_override_size_check">override_size_check</code></td>
<td>
<p>A <em>logical</em> indicating whether or not to
override size checks (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="getelev_+3A_overwrite">overwrite</code></td>
<td>
<p>A <em>logical</em> indicating if an existing file should be
re-downloaded</p>
</td></tr>
<tr><td><code id="getelev_+3A_ncpu">Ncpu</code></td>
<td>
<p>An <em>integer</em> specifying the number of CPU's to use when downloading AWS tiles (default set by global package options).</p>
</td></tr>
<tr><td><code id="getelev_+3A_verbose">verbose</code></td>
<td>
<p>A <em>logical</em> indicating whether information about the
progress of the procedure should be displayed or not while the function is
running. By default verbose is <code>TRUE</code> if users use an interactive R
session and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="getelev_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to the function
<code><a href="elevatr.html#topic+get_elev_raster">elevatr::get_elev_raster</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default (and to keep with the spirit of the former implementations of
<code>getelev</code> in IsoriX, which did not rely on <code><a href="elevatr.html#topic+elevatr">elevatr::elevatr</a></code>), an
elevation raster of the whole world is downloaded with a resolution
correspond to ca. 0.6 km2 per raster cell. You can increase the resolution by
increasing the value of the argument <code>z</code>. You can also restrict the area
to be downloaded using the arguments <code>long_min</code>, <code>long_max</code>, <code>lat_min</code> &amp;
<code>lat_max</code>.
</p>
<p>Note that when using <code><a href="#topic+prepraster">prepraster</a></code> you will be able to reduce the resolution
and restrict the boundaries of this elevation raster, but you won't be able
to increase the resolution or expend the boundaries. As a consequence, it is
probably a good idea to overshoot a little when using <code>getelev</code> and
download data at a resolution slightly higher than you need and for a extent
larger than your data.
</p>
<p>You can customise further what you download by using other parameters of
<code><a href="elevatr.html#topic+get_elev_raster">elevatr::get_elev_raster</a></code> (via the elipsis <code>...</code>).
</p>
<p>Please refer to the documentation of
<code><a href="elevatr.html#topic+get_elev_raster">elevatr::get_elev_raster</a></code> for information on the sources and follows link in
there to know how to cite them.
</p>


<h3>Value</h3>

<p>This function returns the full path where the file has been stored
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## To download the high resolution
## elevation raster in the current folder, just type:
## getelev()

</code></pre>

<hr>
<h2 id='getprecip'>Download rasters of monthly precipitation from internet</h2><span id='topic+getprecip'></span>

<h3>Description</h3>

<p>The function <code>getprecip</code> allows for the download of rasters of monthly
precipitation from internet. It downloads the &quot;precipitation (mm) WorldClim
Version 2.1&quot; at a spatial resolution of 30 seconds (~1 km2). After download,
the function also unzip the file. The function <code>getprecip</code> uses the
generic function <code>downloadfile</code> that can also be used to download
directly other files. This raster needs further processing with the function
<code><a href="#topic+prepcipitate">prepcipitate</a></code>. It can then be used to predict annual averages
precipitation weighted isoscapes with the function
<code><a href="#topic+isomultiscape">isomultiscape</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getprecip(path = NULL, overwrite = FALSE, verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getprecip_+3A_path">path</code></td>
<td>
<p>A <em>string</em> indicating where to store the file on the hard
drive (without the file name!). Default = current directory.</p>
</td></tr>
<tr><td><code id="getprecip_+3A_overwrite">overwrite</code></td>
<td>
<p>A <em>logical</em> indicating if an existing file should be
re-downloaded</p>
</td></tr>
<tr><td><code id="getprecip_+3A_verbose">verbose</code></td>
<td>
<p>A <em>logical</em> indicating whether information about the
progress of the procedure should be displayed or not while the function is
running. By default verbose is <code>TRUE</code> if users use an interactive R
session and <code>FALSE</code> otherwise. If a <em>numeric</em> is provided instead,
additional information about the download will be provided if the number is
greater than 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the argument &quot;path&quot; is not provided, the file will be stored in the
current working directory. The functions can create new directories, so you
can also indicate a new path. The integrity of the elevation raster is tested
after a call to <code>getprecip</code>. In case of corruption, try downloading the
file again, specifying overwrite = TRUE to overwrite the corrupted file.
</p>


<h3>Value</h3>

<p>This function returns the path of the folder where the files have
been stored
</p>


<h3>Source</h3>

<p><a href="https://worldclim.org/data/worldclim21.html">https://worldclim.org/data/worldclim21.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## To download the monthly precipitation
## in a temporary directory
## directory, just type:
## temp_folder &lt;- tempdir()
## getprecip(path = temp_folder)
## Mind that the file weights ca. 1GB!
## For real use, replace temp_folder by your selected computer path
</code></pre>

<hr>
<h2 id='GNIPDataDE'>Hydrogen delta values in precipitation water, Germany</h2><span id='topic+GNIPDataDE'></span>

<h3>Description</h3>

<p>This dataset contains the hydrogen delta value from
precipitation water sampled at weather stations between 1961 and 2013 in
Germany. These data have been kindly provided by Christine Stumpp and
processed by the International Atomic Energy Agency IAEA in Vienna (GNIP
Project: Global Network of Isotopes in Precipitation). These data are free to
reuse provided the relevant citations (see references). These data represent
a small sample of the much larger dataset compiled by the GNIP. We no longer
provide larger GNIP dataset in the package as those are not free to reuse (but
we do provide aggregated versions of it; see <code><a href="#topic+GNIPDataEUagg">GNIPDataEUagg</a></code>).
You can still download the complete GNIP dataset for free, but you will have
to proceed to a registration process with GNIP and use their downloading
interface WISER (<a href="https://nucleus.iaea.org/wiser/index.aspx">https://nucleus.iaea.org/wiser/index.aspx</a>).
</p>


<h3>Format</h3>

<p>The <em>dataframe</em> includes 8591 observations and the following
variables:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   lat </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Latitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   long </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Longitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   elev </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Elevation asl (m) </td>
</tr>
<tr>
 <td style="text-align: left;">
   source_value </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> hydrogen delta value (per thousand) </td>
</tr>
<tr>
 <td style="text-align: left;">
   year </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Year of sampling </td>
</tr>
<tr>
 <td style="text-align: left;">
   month </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Month of sampling </td>
</tr>
<tr>
 <td style="text-align: left;">
   source_ID </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> The unique identifier of the weather station </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>The dataset contains non-aggregated data for 27 weather stations across Germany.
</p>
<p>This dataset is the raw data source and should not be directly used for
fitting isoscapes.
</p>
<p>Please use <code><a href="#topic+prepsources">prepsources</a></code> to filter the dataset by time and
location.
</p>
<p>If you want to use your own dataset, you must format your data as those
produced by the function <code><a href="#topic+prepsources">prepsources</a></code>.
</p>


<h3>Source</h3>

<p>data provided by the IAEA.
</p>


<h3>References</h3>

<p>GNIP Project IAEA Global Network of Isotopes in Precipitation: <a href="https://www.iaea.org">https://www.iaea.org</a>
</p>
<p>Stumpp, C., Klaus, J., &amp; Stichler, W. (2014). Analysis of long-term stable isotopic composition in German precipitation. Journal of hydrology, 517, 351-361.
</p>
<p>Klaus, J., Chun, K. P., &amp; Stumpp, C. (2015). Temporal trends in d18O composition of precipitation in Germany: insights from time series modelling and trend analysis. Hydrological Processes, 29(12), 2668-2680.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepsources">prepsources</a></code> to prepare the dataset for the analyses and
to filter by time and location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(GNIPDataDE)

</code></pre>

<hr>
<h2 id='GNIPDataEUagg'>Hydrogen delta values in precipitation water (aggregated per location)</h2><span id='topic+GNIPDataEUagg'></span><span id='topic+GNIPDataALLagg'></span>

<h3>Description</h3>

<p>These datasets contain the mean and variance of hydrogen delta value from
precipitation water sampled at weather stations between 1953 and 2015 in
Europe (<code>GNIPDataEUagg</code>) and in the entire world (<code>GNIPDataALLagg</code>). These
data have been extracted from the International Atomic Energy Agency IAEA in
Vienna (GNIP Project: Global Network of Isotopes in Precipitation) and
processed by us using the function <code><a href="#topic+prepsources">prepsources</a></code>. The data are aggregated per
location (across all month-year combinations). We no longer provide the full
non-aggregate GNIP dataset in the package as it is not free to reuse. You can
still download the complete GNIP dataset for free, but you will have to
proceed to a registration process with GNIP and use their downloading
interface WISER
(<a href="https://nucleus.iaea.org/wiser/index.aspx">https://nucleus.iaea.org/wiser/index.aspx</a>).
</p>


<h3>Format</h3>

<p>The <em>dataframe</em>s include many observations and the following
variables:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   source_ID </td><td style="text-align: left;"> (<em>factor</em>) </td><td style="text-align: left;"> The unique identifier of the weather station </td>
</tr>
<tr>
 <td style="text-align: left;">
   mean_source_value </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Average of the aggregate of hydrogen delta values (per thousand) </td>
</tr>
<tr>
 <td style="text-align: left;">
   var_source_value </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Variance of the aggregate of hydrogen delta values (per thousand^2) </td>
</tr>
<tr>
 <td style="text-align: left;">
   n_source_value </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Number of hydrogen delta values aggregated </td>
</tr>
<tr>
 <td style="text-align: left;">
   lat </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Latitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   long </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Longitude coordinate (decimal degrees) </td>
</tr>
<tr>
 <td style="text-align: left;">
   elev </td><td style="text-align: left;"> (<em>numeric</em>) </td><td style="text-align: left;"> Elevation asl (m) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>These datasets have been aggregated and can thus be directly used for fitting
isoscapes.
</p>
<p>If you want to use your own dataset, you must format your data as these
datasets.
</p>


<h3>Source</h3>

<p>data provided by the IAEA and processed by us.
</p>


<h3>References</h3>

<p>GNIP Project IAEA Global Network of Isotopes in Precipitation: <a href="https://www.iaea.org">https://www.iaea.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GNIPDataDE">GNIPDataDE</a></code> for a non-aggregated dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(GNIPDataALLagg)
dim(GNIPDataALLagg)
head(GNIPDataEUagg)
dim(GNIPDataEUagg)

</code></pre>

<hr>
<h2 id='isofind'>Infer spatial origins</h2><span id='topic+isofind'></span><span id='topic+print.ISOFIND'></span><span id='topic+summary.ISOFIND'></span>

<h3>Description</h3>

<p>This function performs the assignment of samples of unknown origins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isofind(
  data,
  isoscape,
  calibfit = NULL,
  mask = NA,
  neglect_covPredCalib = TRUE,
  verbose = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isofind_+3A_data">data</code></td>
<td>
<p>A <em>dataframe</em> containing the assignment data (see note below)</p>
</td></tr>
<tr><td><code id="isofind_+3A_isoscape">isoscape</code></td>
<td>
<p>The output of the function <code><a href="#topic+isoscape">isoscape</a></code></p>
</td></tr>
<tr><td><code id="isofind_+3A_calibfit">calibfit</code></td>
<td>
<p>The output of the function <code><a href="#topic+calibfit">calibfit</a></code> (This
argument is not needed if the isoscape had been fitted using isotopic
ratios from sedentary animals.)</p>
</td></tr>
<tr><td><code id="isofind_+3A_mask">mask</code></td>
<td>
<p>A polygon of class <em>SpatVector</em> representing a mask to replace values on all
rasters by NA inside polygons (see details)</p>
</td></tr>
<tr><td><code id="isofind_+3A_neglect_covpredcalib">neglect_covPredCalib</code></td>
<td>
<p>A <em>logical</em> indicating whether to neglect the
covariance between the uncertainty of predictions from the isoscape mean
fit and the uncertainty in predictions from the calibration fit (default =
<code>TRUE</code>). See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="isofind_+3A_verbose">verbose</code></td>
<td>
<p>A <em>logical</em> indicating whether information about the
progress of the procedure should be displayed or not while the function is
running. By default verbose is <code>TRUE</code> if users use an interactive R
session and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An assignment is a comparison, for a given organism, of the predicted
isotopic source value at its location of origin and the predicted isotopic
source value at each location of the <code>isoscape</code>. The difference between
these two values constitute the statistic of the assignment test. Under the
null hypothesis (the organism is at a location with the same isotopic value
than its original location), the test statistics follows a normal
distribution with mean zero and a certain variance that stems from both the
isoscape model fits and the calibration fit. The function
<code><a href="#topic+isofind">isofind</a></code> computes the map of p-value for such an assignment test
(i.e. the p-values in all locations of the isoscape) for all samples in the
dataframe <code>data</code>. The function also performs a single assignment for the
entire group by combining the p-value maps of all samples using the Fisher's
method (Fisher 1925). Significant p-values are strong evidence that the
sample do NOT come from the candidate location (and not the opposite!). For
statistical details about this procedure as well as a discussion of which
uncertainties are captured and which are not, please refer to Courtiol et al.
2019.
</p>
<p><strong>Details on parameters:</strong>
</p>

<ul>
<li> <p><em>neglect_covPredCalib</em>: as long as the calibration method used in
<code><a href="#topic+calibfit">calibfit</a></code> is &quot;wild&quot;, a covariance is expected between the
uncertainty of predictions from the isoscape mean fit and the uncertainty in
predictions from the calibration fit. This is because both the isoscape and
the calibration use in part the same data. By default this term is omitted
(i.e. the value for the argument <code>neglect_covPredCalib</code> is <code>TRUE</code>)
since in practice it seems to affect the results only negligibly in our
trials and the computation of this term can be quite computer intensive. We
nonetheless recommend to set <code>neglect_covPredCalib</code> to <code>FALSE</code> in
your final analysis. If the calibration method used in <code><a href="#topic+calibfit">calibfit</a></code>
is not &quot;wild&quot;, this parameter has no effect.
</p>
</li>
<li> <p><em>mask</em>: a mask can be used so to remove all values falling in the mask.
This can be useful for performing for example assignments on lands only and
discard anything falling in large bodies of water (see example). By default
our <code><a href="#topic+OceanMask">OceanMask</a></code> is considered. Setting <code>mask</code> to NULL allows
to prevent this automatic behaviour.
</p>
</li></ul>



<h3>Value</h3>

<p>This function returns a <em>list</em> of class <em>ISOFIND</em> containing
itself three lists (<code>sample</code>, <code>group</code>, and <code>sp_points</code>)
storing all rasters built during assignment and the spatial points for
sources, calibration and assignments. The <em>list</em> <code>sample</code> contains
three set of raster layers: one storing the value of the test statistic
(&quot;stat&quot;), one storing the value of the variance of the test statistic
(&quot;var&quot;) and one storing the p-value of the test (&quot;pv&quot;). The <em>list</em>
<code>group</code> contains one raster storing the p-values of the assignment for
the group. The <em>list</em> <code>sp_points</code> contains two spatial point
objects: <code>sources</code> and <code>calibs</code>.
</p>


<h3>Note</h3>

<p>See <code><a href="#topic+AssignDataAlien">AssignDataAlien</a></code> to know which variables are needed to
perform the assignment and their names.
</p>


<h3>References</h3>

<p>Courtiol A, Rousset F, Rohwäder M, Soto DX, Lehnert L, Voigt CC, Hobson KA, Wassenaar LI &amp; Kramer-Schadt S (2019). Isoscape
computation and inference of spatial origins with mixed models using the R package IsoriX. In Hobson KA &amp; Wassenaar LI (eds.),
Tracking Animal Migration with Stable Isotopes, second edition. Academic Press, London.
</p>
<p>Fisher, R.A. (1925). Statistical Methods for Research Workers.
Oliver and Boyd (Edinburgh). ISBN 0-05-002170-2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The examples below will only be run if sufficient time is allowed
## You can change that by typing e.g. options_IsoriX(example_maxtime = XX)
## if you want to allow for examples taking up to ca. XX seconds to run
## (so don't write XX but put a number instead!)

if (getOption_IsoriX("example_maxtime") &gt; 200) {
  ## We fit the models for Germany
  GNIPDataDEagg &lt;- prepsources(data = GNIPDataDE)

  GermanFit &lt;- isofit(
    data = GNIPDataDEagg,
    mean_model_fix = list(elev = TRUE, lat_abs = TRUE)
  )


  ## We build the isoscape
  GermanScape &lt;- isoscape(
    raster = ElevRasterDE,
    isofit = GermanFit
  )


  ## We fit the calibration model
  CalibAlien &lt;- calibfit(
    data = CalibDataAlien,
    isofit = GermanFit
  )

  ## We perform the assignment on land only
  AssignmentDry &lt;- isofind(
    data = AssignDataAlien,
    isoscape = GermanScape,
    calibfit = CalibAlien
  )

  ## perform the assignment on land and water
  Assignment &lt;- isofind(
    data = AssignDataAlien,
    isoscape = GermanScape,
    calibfit = CalibAlien,
    mask = NULL
  )

  ## We plot the group assignment
  plot(Assignment, who = "group", mask = list(mask = NULL))

  plot(AssignmentDry, who = "group", mask = list(mask = NULL))

  ## We plot the assignment for the 8 first samples
  plot(AssignmentDry,
    who = 1:8,
    sources = list(draw = FALSE),
    calibs = list(draw = FALSE)
  )

  ## We plot the assignment for the sample "Alien_10"
  plot(AssignmentDry, who = "Alien_10")


  ### Other example without calibration:
  ### We will try to assign a weather station
  ### in the water isoscape

  ## We create the assignment data taking
  ## GARMISCH-PARTENKIRCHEN as the station to assign
  GPIso &lt;- GNIPDataDEagg[GNIPDataDEagg$source_ID == "GARMISCH-PARTENKIRCHEN", "mean_source_value"]
  AssignDataGP &lt;- data.frame(
    sample_value = GPIso,
    sample_ID = "GARMISCH-PARTENKIRCHEN"
  )

  ## We perform the assignment
  AssignedGP &lt;- isofind(
    data = AssignDataGP,
    isoscape = GermanScape,
    calibfit = NULL
  )
  ## We plot the assignment and
  ## show where the station really is (using lattice)
  plot(AssignedGP, plot = FALSE) +
    xyplot(47.48 ~ 11.06,
      cex = 5, pch = 13, lwd = 2, col = "black"
    )
}

</code></pre>

<hr>
<h2 id='ISOFIND-class'>Class ISOFIND</h2><span id='topic+ISOFIND-class'></span>

<h3>Description</h3>

<p>Class ISOFIND
</p>


<h3>Slots</h3>


<dl>
<dt><code>sample</code></dt><dd><p>a list of SpatRaster objects storing the assignment info for each sample</p>
</dd>
<dt><code>group</code></dt><dd><p>a SpatRaster storing the group assignment info</p>
</dd>
<dt><code>sp_points</code></dt><dd><p>a list of SpatVector storing the spatial points for sources, calibration and assignment samples</p>
</dd>
</dl>

<hr>
<h2 id='isofit'>Fit the isoscape models</h2><span id='topic+isofit'></span><span id='topic+print.ISOFIT'></span><span id='topic+summary.ISOFIT'></span>

<h3>Description</h3>

<p>This function fits the aggregated source data using mixed models. The fitting
procedures are done by the package <code><a href="spaMM.html#topic+spaMM">spaMM::spaMM</a></code> which we use to jointly fit
the mean isotopic values and their associated residual dispersion variance in
a spatially explicit manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isofit(
  data,
  mean_model_fix = list(elev = FALSE, lat_abs = FALSE, lat_2 = FALSE, long = FALSE,
    long_2 = FALSE),
  disp_model_fix = list(elev = FALSE, lat_abs = FALSE, lat_2 = FALSE, long = FALSE,
    long_2 = FALSE),
  mean_model_rand = list(uncorr = TRUE, spatial = TRUE),
  disp_model_rand = list(uncorr = TRUE, spatial = TRUE),
  uncorr_terms = list(mean_model = "lambda", disp_model = "lambda"),
  spaMM_method = list(mean_model = "fitme", disp_model = "fitme"),
  dist_method = "Earth",
  control_mean = list(),
  control_disp = list(),
  verbose = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isofit_+3A_data">data</code></td>
<td>
<p>The <em>dataframe</em> containing the data used for fitting the
isoscape model</p>
</td></tr>
<tr><td><code id="isofit_+3A_mean_model_fix">mean_model_fix</code></td>
<td>
<p>A <em>list</em> of <em>logical</em> indicating which fixed
effects to consider in mean_fit</p>
</td></tr>
<tr><td><code id="isofit_+3A_disp_model_fix">disp_model_fix</code></td>
<td>
<p>A <em>list</em> of <em>logical</em> indicating which fixed
effects to consider in disp_fit</p>
</td></tr>
<tr><td><code id="isofit_+3A_mean_model_rand">mean_model_rand</code></td>
<td>
<p>A <em>list</em> of <em>logical</em> indicating which random
effects to consider in mean_fit</p>
</td></tr>
<tr><td><code id="isofit_+3A_disp_model_rand">disp_model_rand</code></td>
<td>
<p>A <em>list</em> of <em>logical</em> indicating which random
effects to consider in disp_fit</p>
</td></tr>
<tr><td><code id="isofit_+3A_uncorr_terms">uncorr_terms</code></td>
<td>
<p>A <em>list</em> of two strings defining the parametrization
used to model the uncorrelated random effects for mean_fit and disp_fit</p>
</td></tr>
<tr><td><code id="isofit_+3A_spamm_method">spaMM_method</code></td>
<td>
<p>A <em>list</em> of two strings defining the spaMM functions
used for mean_fit and disp_fit</p>
</td></tr>
<tr><td><code id="isofit_+3A_dist_method">dist_method</code></td>
<td>
<p>A <em>string</em> indicating the distance method</p>
</td></tr>
<tr><td><code id="isofit_+3A_control_mean">control_mean</code></td>
<td>
<p>A <em>list</em> of additional arguments to be passed to the
call of mean_fit</p>
</td></tr>
<tr><td><code id="isofit_+3A_control_disp">control_disp</code></td>
<td>
<p>A <em>list</em> of additional arguments to be passed to the
call of disp_fit</p>
</td></tr>
<tr><td><code id="isofit_+3A_verbose">verbose</code></td>
<td>
<p>A <em>logical</em> indicating whether information about the
progress of the procedure should be displayed or not while the function is
running. By default verbose is <code>TRUE</code> if users use an interactive R
session and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The detailed statistical definition of the isoscape model is described in
Courtiol &amp; Rousset 2017 and summarized in Courtiol et al. 2019.
</p>
<p>Briefly, the fitting procedure of the isoscape model is divided into two
fits: <code>mean_fit</code> and <code>disp_fit</code>. <code>mean_fit</code> corresponds to the fit of the
&quot;mean model&quot;, which we will use to predict the mean isotopic values at any
location in other functions of the package. <code>disp_fit</code> corresponds to the fit
of the &quot;residual dispersion model&quot;, which we will use to predict the residual
dispersion variance associated to the mean predictions. <code>mean_fit</code> is a
linear mixed-effects model (LMM) with fixed effects, an optional spatial
random effect with a Matérn correlation structure and an optional
uncorrelated random effect accounting for variation between sources unrelated
to their location. <code>disp_fit</code> is a Gamma Generalized LMM (Gamma GLMM) that
also has fixed effects, an optional spatial random effect with a Matérn
correlation structure and an optional uncorrelated random effect. For the
GLMM the residual variance is fixed to its theoretical expectation.
</p>
<p>The <em>dataframe</em> <code>data</code> must contain a single row per source location with the
following columns: <code>mean_source_value</code> (the mean isotopic value),
<code>var_source_value</code> (the unbiased variance estimate of the isotopic value at
the location), <code>n_source_value</code> (the number of measurements performed at the
location, could be 1) and <code>source_ID</code> (a factor defining the identity of the
sources at a given location).
</p>
<p>The arguments <code>mean_model_fix</code> and <code>disp_model_fix</code> allow the user to choose
among different fixed-effect structures for each model. These arguments are
lists of booleans (<code>TRUE</code> or <code>FALSE</code>), which define which of the following
fixed effects must be considered: the elevation (<code>elev</code>), the absolute value
of the latitude (<code>lat_abs</code>), the squared latitude (<code>lat_2</code>), the longitude
(<code>long</code>) and the squared longitude (<code>long_2</code>). An intercept is always
considered in both models.
</p>
<p>In the models, the mean (for the mean model) or the log residual variance
(for the residual dispersion model) follow a Gaussian distribution around a
constant value. The arguments <code>mean_model_rand</code> and <code>disp_model_rand</code> allow
to choose among different random effects for each model influencing the
realizations of these Gaussian random processes. For each model one can
choose not to include random effects or to include an uncorrelated random
effect, a spatial random effect, or both (default). Setting <code>"uncorr" = TRUE</code>
implies that the realizations of the random effect differ between sources for
reasons that have nothing to do with the relative geographic location (e.g.
some micro-climate or some measurement errors trigger a shift in all
measurements (mean model) or a shift in the variance between measurements
(residual dispersion model) performed at a given source by the same amount).
Setting <code>"spatial" = TRUE</code> (default) implies that the random realizations of
the Gaussian process follow a Matérn correlation structure. Put simply, this
implies that the closer two locations are, the more similar the means (or the
log residual variance) in isotopic values are (e.g. because they are likely
to be traversed by the same air masses).
</p>
<p>The arguments <code>uncorr_terms</code> allow the choice between two alternative
parametrizations for the uncorrelated random effect in the fits:
<code>"lambda"</code> or <code>"nugget"</code> for each model. When using
<code>"lambda"</code>, the variance of the uncorrelated random terms is classically
modelled by a variance. When a spatial random effect is considered, one can
alternatively choose <code>"nugget"</code>, which modifies the Matérn correlation
value when distance between location tends to zero. If no random effect is
considered, one should stick to the default setting and it will be ignored by
the function. The choice of the parametrization is a matter of personal
preferences and it does not change the underlying models, so the estimations
for all the other parameters of the models should not be impacted by whether
one chooses <code>"lambda"</code> or <code>"nugget"</code>. However, only uncertainty in
the estimation of <code>"lambda"</code> can be accounted for while computing
prediction variances, which is why we chose this alternative as the default.
Depending on the data one parametrization may lead to faster fit than the
other.
</p>
<p>The argument <code>spaMM_method</code> is also a list of two <em>strings</em> where the first
element defines the spaMM functions used for fitting the mean model and the
second element defines the spaMM method used for fitting the residual
dispersion model. The possible options are <code>"HLfit"</code>, <code>"corrHLfit"</code> and
<code>"fitme"</code>. Note that <code>"HLfit"</code> shall only be used in the absence of a Matérn
correlation structure and <code>"corrHLfit"</code> shall only be used in the presence of
it. In contrast, <code>"fitme"</code> should work in all situations. Which method is
best remains to be determined and it is good practice to try different
methods (if applicable) to check for the robustness of the results. If all is
well one should obtain very similar results with the different methods. If
this is not the case, carefully check the model output to see if one model
fit did not get stuck at a local minimum during optimization (which would
translate in a lower likelihood, or weird isoscapes looking flat with high
peaks at very localised locations).
</p>
<p>The argument <code>dist_method</code> allows modifying how the distance between
locations is computed to estimate the spatial correlation structure. By
default, we consider the so-called &quot;Earth&quot; distances which are technically
called orthodromic distances. They account for earth curvature. The
alternative &quot;Euclidean&quot; distances do not. For studies performed on a small
geographic scale, both distance methods should lead to similar results.
</p>
<p>The arguments <code>control_mean</code> and <code>control_dist</code> are lists that are
transmitted to the <code><a href="spaMM.html#topic+spaMM">spaMM::spaMM</a></code> fitting functions (defined by
<code>spaMM_method</code>). These lists can be used to finely control the fitting
procedure, so advanced knowledge of the package <code><a href="spaMM.html#topic+spaMM">spaMM::spaMM</a></code> is required
before messing around with these inputs.
</p>
<p>We highly recommend users to examine the output produced by isofit.
Sometimes, poor fit may occur and such models should therefore not be used
for building isoscapes or performing assignments.
</p>


<h3>Value</h3>

<p>This function returns a <em>list</em> of class <em>ISOFIT</em> containing
two inter-related fits: <code>mean_fit</code> and <code>disp_fit</code>. The returned
<em>list</em> also contains the object <code>info_fit</code> that contains all the
call arguments.
</p>


<h3>Note</h3>

<p>There is no reason to restrict <code>mean_fit</code> and <code>disp_fit</code> to
using the same parametrization for fixed and random effects.
</p>
<p>Never use a mean_fit object to draw predictions without considering a
disp_fit object: mean_fit is not fitted independently from disp_fit.
</p>
<p>For all methods, fixed effects are being estimated by Maximum Likelihood
(ML) and dispersion parameters (i.e. random effects and Matérn correlation
parameters) are estimated by Restricted Maximum Likelihood (REML). Using
REML provides more accurate prediction intervals but impedes the accuracy
of Likelihood Ratio Tests (LRT). Our choice for REML was motivated by the
fact that our package is more likely to be used for drawing inferences than
null hypothesis testing. Users interested in model comparisons may rely on
the conditional AIC values that can be extracted from fitted models using
the function <code><a href="spaMM.html#topic+AIC">spaMM::AIC</a></code> from  <span class="pkg">spaMM</span>.
</p>
<p>Variable names for <code>data</code> must be respected to ensure a correct utilization
of this package. Alteration to the fixed effect structure is not
implemented so far (beyond the different options proposed) to avoid misuse
of the package. Users that would require more flexibility should consider
using spaMM directly (see Courtiol &amp; Rousset 2017) or let us know which
other covariates would be useful to add in IsoriX.
</p>


<h3>Source</h3>

<p><a href="https://kimura.univ-montp2.fr/~rousset/spaMM.htm">https://kimura.univ-montp2.fr/~rousset/spaMM.htm</a>
</p>


<h3>References</h3>

<p>Courtiol, A., Rousset, F. (2017). Modelling isoscapes using mixed
models. <a href="https://www.biorxiv.org/content/10.1101/207662v1">https://www.biorxiv.org/content/10.1101/207662v1</a>
</p>
<p>Courtiol A, Rousset F, Rohwäder M, Soto DX, Lehnert L, Voigt CC, Hobson KA, Wassenaar LI &amp; Kramer-Schadt S (2019). Isoscape
computation and inference of spatial origins with mixed models using the R package IsoriX. In Hobson KA &amp; Wassenaar LI (eds.),
Tracking Animal Migration with Stable Isotopes, second edition. Academic Press, London.
</p>
<p>Rousset, F., Ferdy, J. B. (2014). Testing environmental and genetic effects
in the presence of spatial autocorrelation. Ecography, 37(8):781-790.
</p>
<p>Bowen, G. J., Wassenaar, L. I., Hobson, K. A. (2005). Global application of
stable hydrogen and oxygen isotopes to wildlife forensics. Oecologia,
143(3):337-348.
</p>


<h3>See Also</h3>

<p><code><a href="spaMM.html#topic+spaMM">spaMM::spaMM</a></code> for an overview of the <span class="pkg">spaMM</span> package
</p>
<p><code><a href="spaMM.html#topic+fitme">spaMM::fitme</a></code> and <code><a href="spaMM.html#topic+corrHLfit">spaMM::corrHLfit</a></code> for
information about the two possible fitting procedures that can be used here
</p>
<p><code><a href="spaMM.html#topic+MaternCorr">spaMM::MaternCorr</a></code> for information about the Matérn
correlation structure
</p>
<p><code><a href="#topic+prepsources">prepsources</a></code> for the function preparing the data for isofit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The examples below will only be run if sufficient time is allowed
## You can change that by typing e.g. options_IsoriX(example_maxtime = XX)
## if you want to allow for examples taking up to ca. XX seconds to run
## (so don't write XX but put a number instead!)

if (getOption_IsoriX("example_maxtime") &gt; 10) {
  ## Fitting the models for Germany
  GNIPDataDEagg &lt;- prepsources(data = GNIPDataDE)

  GermanFit &lt;- isofit(data = GNIPDataDEagg, mean_model_fix = list(elev = TRUE, lat_abs = TRUE))

  GermanFit

  ## Diagnostics for the fits
  plot(GermanFit)

  ## Exploration of the fitted models
  GermanFit$mean_fit
  GermanFit$disp_fit
  AIC(GermanFit$disp_fit)
}

</code></pre>

<hr>
<h2 id='isomultifit'>Fit isoscape models per strata (typically time interval such as months)</h2><span id='topic+isomultifit'></span>

<h3>Description</h3>

<p>This function fits several set of isoscapes (e.g. one per strata). It can thus be
used to predict annual averages precipitation weighted isoscapes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isomultifit(
  data,
  split_by = "month",
  mean_model_fix = list(elev = FALSE, lat_abs = FALSE, lat_2 = FALSE, long = FALSE,
    long_2 = FALSE),
  disp_model_fix = list(elev = FALSE, lat_abs = FALSE, lat_2 = FALSE, long = FALSE,
    long_2 = FALSE),
  mean_model_rand = list(uncorr = TRUE, spatial = TRUE),
  disp_model_rand = list(uncorr = TRUE, spatial = TRUE),
  uncorr_terms = list(mean_model = "lambda", disp_model = "lambda"),
  spaMM_method = list(mean_model = "fitme", disp_model = "fitme"),
  dist_method = "Earth",
  control_mean = list(),
  control_disp = list(),
  verbose = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isomultifit_+3A_data">data</code></td>
<td>
<p>The <em>dataframe</em> containing the data used for fitting the
isoscape model</p>
</td></tr>
<tr><td><code id="isomultifit_+3A_split_by">split_by</code></td>
<td>
<p>A <em>string</em> indicating the name of the column of
<code>data</code> used to split the dataset. The function
<code><a href="#topic+isofit">isofit</a></code> will then be called on each of these sub-datasets. The
default behaviour is to consider that the dataset should be split per
months (<code>split_by = "month"</code>).</p>
</td></tr>
<tr><td><code id="isomultifit_+3A_mean_model_fix">mean_model_fix</code></td>
<td>
<p>A <em>list</em> of <em>logical</em> indicating which fixed
effects to consider in mean_fit</p>
</td></tr>
<tr><td><code id="isomultifit_+3A_disp_model_fix">disp_model_fix</code></td>
<td>
<p>A <em>list</em> of <em>logical</em> indicating which fixed
effects to consider in disp_fit</p>
</td></tr>
<tr><td><code id="isomultifit_+3A_mean_model_rand">mean_model_rand</code></td>
<td>
<p>A <em>list</em> of <em>logical</em> indicating which random
effects to consider in mean_fit</p>
</td></tr>
<tr><td><code id="isomultifit_+3A_disp_model_rand">disp_model_rand</code></td>
<td>
<p>A <em>list</em> of <em>logical</em> indicating which random
effects to consider in disp_fit</p>
</td></tr>
<tr><td><code id="isomultifit_+3A_uncorr_terms">uncorr_terms</code></td>
<td>
<p>A <em>list</em> of two strings defining the parametrization
used to model the uncorrelated random effects for mean_fit and disp_fit</p>
</td></tr>
<tr><td><code id="isomultifit_+3A_spamm_method">spaMM_method</code></td>
<td>
<p>A <em>list</em> of two strings defining the spaMM functions
used for mean_fit and disp_fit</p>
</td></tr>
<tr><td><code id="isomultifit_+3A_dist_method">dist_method</code></td>
<td>
<p>A <em>string</em> indicating the distance method</p>
</td></tr>
<tr><td><code id="isomultifit_+3A_control_mean">control_mean</code></td>
<td>
<p>A <em>list</em> of additional arguments to be passed to the
call of mean_fit</p>
</td></tr>
<tr><td><code id="isomultifit_+3A_control_disp">control_disp</code></td>
<td>
<p>A <em>list</em> of additional arguments to be passed to the
call of disp_fit</p>
</td></tr>
<tr><td><code id="isomultifit_+3A_verbose">verbose</code></td>
<td>
<p>A <em>logical</em> indicating whether information about the
progress of the procedure should be displayed or not while the function is
running. By default verbose is <code>TRUE</code> if users use an interactive R
session and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around the function <code><a href="#topic+isofit">isofit</a></code>.
</p>


<h3>Value</h3>

<p>This function returns a <em>list</em> of class <em>MULTIISOFIT</em>
containing all pairs of inter-related fits (stored under
<code>multi_fits</code>). The returned <em>list</em> also contains the object
<code>info_fit</code> that contains all the call arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isofit">isofit</a></code> for information about the fitting procedure of
each isoscape.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The examples below will only be run if sufficient time is allowed
## You can change that by typing e.g. options_IsoriX(example_maxtime = XX)
## if you want to allow for examples taking up to ca. XX seconds to run
## (so don't write XX but put a number instead!)

if (getOption_IsoriX("example_maxtime") &gt; 30) {
  ## We prepare the GNIP monthly data between January and June for Germany

  GNIPDataDEmonthly &lt;- prepsources(
    data = GNIPDataDE,
    month = 1:6,
    split_by = "month"
  )

  head(GNIPDataDEmonthly)

  ## We fit the isoscapes

  GermanMonthlyFit &lt;- isomultifit(data = GNIPDataDEmonthly)

  GermanMonthlyFit

  plot(GermanMonthlyFit)
}
</code></pre>

<hr>
<h2 id='isomultiscape'>Predicts the average spatial distribution of isotopic values over months,
years...</h2><span id='topic+isomultiscape'></span>

<h3>Description</h3>

<p>This function is the counterpart of <code><a href="#topic+isoscape">isoscape</a></code> for the objects
created with <code><a href="#topic+isomultifit">isomultifit</a></code>. It creates the isoscapes for each
strata (e.g. month) defined by <code>split_by</code> during the call to
<code><a href="#topic+isomultifit">isomultifit</a></code> and the aggregate them. The function can handle
weighting for the aggregation process and may thus be used to predict annual
averages precipitation weighted isoscapes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isomultiscape(raster, isofit, weighting = NULL, verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isomultiscape_+3A_raster">raster</code></td>
<td>
<p>The structural raster (<em>SpatRaster</em>) such as an elevation
raster created using <code><a href="#topic+prepelev">prepelev</a></code></p>
</td></tr>
<tr><td><code id="isomultiscape_+3A_isofit">isofit</code></td>
<td>
<p>The fitted isoscape created by <code><a href="#topic+isofit">isofit</a></code></p>
</td></tr>
<tr><td><code id="isomultiscape_+3A_weighting">weighting</code></td>
<td>
<p>An optional RasterBrick containing the weights</p>
</td></tr>
<tr><td><code id="isomultiscape_+3A_verbose">verbose</code></td>
<td>
<p>A <em>logical</em> indicating whether information about the
progress of the procedure should be displayed or not while the function is
running. By default verbose is <code>TRUE</code> if users use an interactive R
session and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a <em>list</em> of class <em>ISOSCAPE</em>
containing a set of all 8 raster layers mentioned above (all being of
class <em>SpatRaster</em>), and the location of the sources as spatial points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isoscape">isoscape</a></code> for details on the function used to compute the isoscapes for each strata
<code><a href="#topic+isomultifit">isomultifit</a></code> for the function fitting the isoscape
</p>
<p><code><a href="#topic+plot.ISOSCAPE">plot.ISOSCAPE</a></code> for the function plotting the isoscape model
</p>
<p><code><a href="#topic+IsoriX">IsoriX</a></code> for the complete work-flow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The examples below will only be run if sufficient time is allowed
## You can change that by typing e.g. options_IsoriX(example_maxtime = XX)
## if you want to allow for examples taking up to ca. XX seconds to run
## (so don't write XX but put a number instead!)

if (getOption_IsoriX("example_maxtime") &gt; 180) {
  ## We prepare the data and split them by month:

  GNIPDataDEmonthly &lt;- prepsources(
    data = GNIPDataDE,
    split_by = "month"
  )

  dim(GNIPDataDEmonthly)

  ## We fit the isoscapes:#'
  GermanMultiFit &lt;- isomultifit(
    data = GNIPDataDEmonthly,
    mean_model_fix = list(elev = TRUE, lat.abs = TRUE)
  )

  ## We build the annual isoscapes by simple averaging (equal weighting):
  GermanMultiscape &lt;- isomultiscape(
    raster = ElevRasterDE,
    isofit = GermanMultiFit
  )

  ## We build the annual isoscapes with a weighting based on precipitation amount:
  GermanMultiscapeWeighted &lt;- isomultiscape(
    raster = ElevRasterDE,
    isofit = GermanMultiFit,
    weighting = PrecipBrickDE
  )

  ## We plot the mean isoscape of the averaging with equal weighting:
  plot(x = GermanMultiscape, which = "mean")

  ## We plot the mean isoscape of the averaging with precipitation weighting:
  plot(x = GermanMultiscapeWeighted, which = "mean")

  ## We build the isoscapes for a given month (here January):
  GermanScapeJan &lt;- isoscape(
    raster = ElevRasterDE,
    isofit = GermanMultiFit$multi_fits[["month_1"]]
  )

  ## We plot the mean isoscape for January:
  plot(x = GermanScapeJan, which = "mean")
}
</code></pre>

<hr>
<h2 id='isopalette2'>Colour palettes for plotting</h2><span id='topic+isopalette2'></span><span id='topic+isopalette1'></span>

<h3>Description</h3>

<p>These datasets contain colour vectors that can be used for plotting. In our
examples, we use the <code>isopalette1</code> for plotting the isoscape using
<code><a href="#topic+plot.ISOSCAPE">plot.ISOSCAPE</a></code> and <code>isopalette2</code> for plotting the
assignment outcome using <code><a href="#topic+plot.ISOFIND">plot.ISOFIND</a></code>.
</p>


<h3>Format</h3>

<p>A vector of colours
</p>


<h3>Details</h3>

<p>Colour palettes can be created by using the function <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code>
that interpolates colours between a set of given colours. One can also use
<code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code> to create functions providing colours. Also
interesting, the function <code><a href="colorspace.html#topic+choose_palette">colorspace::choose_palette</a></code> offers a GUI
interface allowing to create and save a palette in a hexadecimal format
(which can later on be imported into R). This latter function is however
limited to a maximum of 50 colours. You can also use R colour palettes
already available such as <code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code> or others available
(see examples below). Alternatively, you can design your own colour palette
by writing standard hexadecimal code of colours into a vector.
</p>


<h3>Note</h3>

<p>We use the package <span class="pkg">rasterVis</span> for plotting. Instead of using
colour palettes directly, one can also use any &quot;Theme&quot; designed for the
lattice graphic environment (see source for details).
</p>


<h3>Source</h3>

<p>For information on how to use themes, check:
</p>
<p><a href="https://oscarperpinan.github.io/rastervis/#themes">https://oscarperpinan.github.io/rastervis/#themes</a>
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+palettes">grDevices::rainbow</a></code> for information about R colour palettes
</p>
<p><code><a href="grDevices.html#topic+colorRamp">grDevices::colorRamp</a></code> and <code><a href="colorspace.html#topic+choose_palette">colorspace::choose_palette</a></code> to create your
own palettes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A comparison of some colour palette

par(mfrow = c(2, 3))
pie(rep(1, length(isopalette1)),
  col = isopalette1,
  border = NA, labels = NA, clockwise = TRUE, main = "isopalette1"
)
pie(rep(1, length(isopalette2)),
  col = isopalette2,
  border = NA, labels = NA, clockwise = TRUE, main = "isopalette2"
)
pie(rep(1, 100),
  col = terrain.colors(100), border = NA, labels = NA,
  clockwise = TRUE, main = "terrain.colors"
)
pie(rep(1, 100),
  col = rainbow(100), border = NA, labels = NA,
  clockwise = TRUE, main = "rainbow"
)
pie(rep(1, 100),
  col = topo.colors(100), border = NA, labels = NA,
  clockwise = TRUE, main = "topo.colors"
)
pie(rep(1, 100),
  col = heat.colors(100), border = NA, labels = NA,
  clockwise = TRUE, main = "heat.colors"
)

## Creating your own colour palette
MyPalette &lt;- colorRampPalette(c("blue", "green", "red"), bias = 0.7)
par(mfrow = c(1, 1))
pie(1:100,
  col = MyPalette(100), border = NA, labels = NA,
  clockwise = TRUE, main = "a home-made palette"
)

## Turing palettes into functions for use in IsoriX
Isopalette1Fn &lt;- colorRampPalette(isopalette1, bias = 0.5)
Isopalette2Fn &lt;- colorRampPalette(isopalette2, bias = 0.5)
par(mfrow = c(1, 2))
pie(1:100,
  col = Isopalette1Fn(100), border = NA, labels = NA,
  clockwise = TRUE, main = "isopalette1"
)
pie(1:100,
  col = Isopalette2Fn(100), border = NA, labels = NA,
  clockwise = TRUE, main = "isopalette2"
)

</code></pre>

<hr>
<h2 id='IsoriX-defunct'>Defunct and deprecated functions</h2><span id='topic+IsoriX-defunct'></span><span id='topic+Calibfit'></span><span id='topic+GetElev'></span><span id='topic+Isofit'></span><span id='topic+Isorix'></span><span id='topic+Isoscape'></span><span id='topic+Isosim'></span><span id='topic+QueryGNIP'></span><span id='topic+queryGNIP'></span><span id='topic+prepdata'></span><span id='topic+prepelev'></span><span id='topic+prepiso'></span><span id='topic+RElevate'></span><span id='topic+relevate'></span>

<h3>Description</h3>

<p>The function you asked help for has been defunct (i.e. it does not longer
exists) or deprecated (i.e. it will disappear soon). A new function with a
different name is surely doing the old job.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsoriX-defunct_+3A_...">...</code></td>
<td>
<p>The call of the defunct or deprecated function</p>
</td></tr>
</table>

<hr>
<h2 id='isoscape'>Predicts the spatial distribution of source isotopic values</h2><span id='topic+isoscape'></span><span id='topic+print.isoscape'></span><span id='topic+summary.isoscape'></span>

<h3>Description</h3>

<p>This function produces the set of isoscapes, i.e. the spatial prediction
(i.e. maps) of the distribution of source isotopic values, as well as several
variances around such predictions. The predictions are computed using the
fitted geostatistical models for each raster cell of a structural raster.
All shape files can be exported and loaded into any Geographic Information
System (GIS) if needed (see online tutorials).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isoscape(raster, isofit, verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isoscape_+3A_raster">raster</code></td>
<td>
<p>The structural raster (<em>SpatRaster</em>) such as an elevation
raster created using <code><a href="#topic+prepelev">prepelev</a></code></p>
</td></tr>
<tr><td><code id="isoscape_+3A_isofit">isofit</code></td>
<td>
<p>The fitted isoscape created by <code><a href="#topic+isofit">isofit</a></code></p>
</td></tr>
<tr><td><code id="isoscape_+3A_verbose">verbose</code></td>
<td>
<p>A <em>logical</em> indicating whether information about the
progress of the procedure should be displayed or not while the function is
running. By default verbose is <code>TRUE</code> if users use an interactive R
session and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the predictions (<code>mean</code>), prediction variances
(<code>mean_predVar</code>), residual variances (<code>mean_residVar</code>) and response
variances (<code>mean_respVar</code>) for the isotopic values at a resolution equal
to the one of the structural raster. It also computes the same information
for the residual dispersion variance (<code>disp_pred</code>, <code>disp_predVar</code>,
<code>disp_residVar</code>, or <code>disp_respVar</code>).
</p>
<p>The predictions of isotopic values across the landscape are performed by
calling the function <code><a href="spaMM.html#topic+predict">spaMM::predict</a></code> from the package
<span class="pkg">spaMM</span> on the fitted isoscape produced by
<code><a href="#topic+isofit">isofit</a></code>.
</p>
<p>Let us summarize the meaning of <code>mean</code>, <code>mean_predVar</code>,
<code>mean_residVar</code> and <code>mean_respVar</code> (see Courtiol &amp; Rousset 2017 and
Courtiol et al. 2019 for more details):
</p>
<p>Our model assumes that that there is a single true unknown isoscape, which is
fixed but which is represented by the mixed-effect model as a random draw
from possible realizations of isoscapes (random draws of the
Matérn-correlated process and of the uncorrelated random effects if
considered). We infer this realized isoscape by fitting the model to a
limited amount of data, with some uncertainty since different random draws of
the unknown isoscape may give the same observed data. There is thus a
conditional distribution of possible true isoscapes given the data. For
linear mixed-effects models, the mean prediction is the mean of this
conditional distribution. The prediction variance is ideally the mean square
difference between the true unknown value of the linear predictor and the
mean prediction at a given location. The residual variance is simply the
prediction of the variance in isotopic value at a given location. Its exact
meaning depends on the aggregation scheme used in <code><a href="#topic+prepsources">prepsources</a></code>,
but by default, it would correspond to the temporal variation between months
and across years. The response variance estimates the variance of new
observations drawn from the true unknown isoscape at a given location. The
response variance is simply equal to the sum of the prediction variance and
the residual variance (note that the residual variance considered assume that
a single observation is being observed per location).
</p>
<p>The isoscape can be plotted using the function <code><a href="#topic+plot.ISOSCAPE">plot.ISOSCAPE</a></code>
(see examples).
</p>


<h3>Value</h3>

<p>This function returns a <em>list</em> of class <em>ISOSCAPE</em> containing
a set of all 8 raster layers mentioned above (all being of class
<em>SpatRaster</em>), and the location of the sources as spatial points.
</p>


<h3>References</h3>

<p>Courtiol, A., Rousset, F. (2017). Modelling isoscapes using mixed
models. <a href="https://www.biorxiv.org/content/10.1101/207662v1">https://www.biorxiv.org/content/10.1101/207662v1</a>
</p>
<p>Courtiol A, Rousset F, Rohwäder M, Soto DX, Lehnert L, Voigt CC, Hobson KA, Wassenaar LI &amp; Kramer-Schadt S (2019). Isoscape
computation and inference of spatial origins with mixed models using the R package IsoriX. In Hobson KA &amp; Wassenaar LI (eds.),
Tracking Animal Migration with Stable Isotopes, second edition. Academic Press, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isofit">isofit</a></code> for the function fitting the isoscape
</p>
<p><code><a href="#topic+plot.ISOSCAPE">plot.ISOSCAPE</a></code> for the function plotting the isoscape model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The examples below will only be run if sufficient time is allowed
## You can change that by typing e.g. options_IsoriX(example_maxtime = XX)
## if you want to allow for examples taking up to ca. XX seconds to run
## (so don't write XX but put a number instead!)

if (getOption_IsoriX("example_maxtime") &gt; 30) {
  ## We prepare the data
  GNIPDataDEagg &lt;- prepsources(data = GNIPDataDE)

  ## We fit the models
  GermanFit &lt;- isofit(
    data = GNIPDataDEagg,
    mean_model_fix = list(elev = TRUE, lat_abs = TRUE)
  )

  ## We build the isoscapes
  GermanScape &lt;- isoscape(raster = ElevRasterDE, isofit = GermanFit)

  GermanScape
  plot(GermanScape)

  ## We build more plots
  PlotMean &lt;- plot(x = GermanScape, which = "mean", plot = FALSE)

  PlotMeanPredVar &lt;- plot(x = GermanScape, which = "mean_predVar", plot = FALSE)

  PlotMeanResidVar &lt;- plot(x = GermanScape, which = "mean_residVar", plot = FALSE)

  PlotMeanRespVar &lt;- plot(x = GermanScape, which = "mean_respVar", plot = FALSE)

  ## We display the plots
  print(PlotMean, split = c(1, 1, 2, 2), more = TRUE)
  print(PlotMeanPredVar, split = c(2, 1, 2, 2), more = TRUE)
  print(PlotMeanResidVar, split = c(1, 2, 2, 2), more = TRUE)
  print(PlotMeanRespVar, split = c(2, 2, 2, 2), more = FALSE)

  ## We build a sphere with our isoscape
  plot(x = GermanScape, which = "mean", plot = FALSE, sphere = list(build = TRUE))

  ## We can save a rotating sphere with the isoscape as a .gif-file.
  ## This file will be located inside your working directory.
  ## Make sure your current rgl device (from the previous step) is still open
  ## and that you have both the packages 'rgl' and 'magick' installed.
  ## The building of the .gif implies to create temporarily many .png
  ## but those will be removed automatically once the .gif is done.
  ## Uncomment to proceed (after making sure you have rgl, magick &amp; webshot2 installed)
  # if(require("rgl") &amp;&amp; require("magick") &amp;&amp; require("webshot2")) {
  #   movie3d(spin3d(axis = c(0, 0, 1), rpm = 2), duration = 30, dir = getwd())
  # }
}

</code></pre>

<hr>
<h2 id='ISOSCAPE-class'>Class ISOSCAPE</h2><span id='topic+ISOSCAPE-class'></span>

<h3>Description</h3>

<p>Class ISOSCAPE
</p>


<h3>Slots</h3>


<dl>
<dt><code>isoscapes</code></dt><dd><p>a SpatRaster storing the isoscapes</p>
</dd>
<dt><code>sp_points</code></dt><dd><p>a list of spatial points</p>
</dd>
</dl>

<hr>
<h2 id='OceanMask'>Mask of world oceans</h2><span id='topic+OceanMask'></span>

<h3>Description</h3>

<p>This dataset contains a polygon SpatVector (from <span class="pkg">terra</span>).
It can be used to mask large bodies of water.
</p>


<h3>Format</h3>

<p>A <em>SpatVector</em> object
</p>


<h3>Source</h3>

<p>See example for details on how we created the dataset.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+CountryBorders">CountryBorders</a></code> for another polygon used to embellish the plots
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
plot(OceanMask, col = "blue")

## How did we create this file?

## Uncomment the following to create the file as we did
# if (require(terra)) {
#   worldlimit &lt;- vect(ext(CountryBorders))
#   crs(worldlimit) &lt;- crs(CountryBorders)
#   OceanMask &lt;- worldlimit - CountryBorders
#   #saveRDS(OceanMask, file = "IsoriX/inst/extdata/OceanMask.rds", compress = "xz")
# }

</code></pre>

<hr>
<h2 id='options'>Setting and displaying the options of the package</h2><span id='topic+options'></span><span id='topic+options_IsoriX'></span><span id='topic+getOption_IsoriX'></span>

<h3>Description</h3>

<p>** Information on the settings for the delta notation **
</p>


<h3>Usage</h3>

<pre><code class='language-R'>options_IsoriX(...)

getOption_IsoriX(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="options_+3A_...">...</code></td>
<td>
<p>A named value or a list of named values. The following values, with their defaults, are used:
</p>

<dl>
<dt>title_delta_notation</dt><dd><p>a name, call, or expression used as default in titles to refer to the delta notation.</p>
</dd>
<dt>example_maxtime</dt><dd><p>The number of seconds allowed for a given example to run. It is used to control whether the longer examples should be run or not based on the comparison between this option and the approximate running time of the example on our computers.</p>
</dd>
<dt>Ncpu</dt><dd><p>An <em>integer</em> corresponding to the number of cores to be used (in functions that can handle parallel processing).</p>
</dd>
<dt>dont_ask</dt><dd><p>A <em>logical</em> indicating if the user prompt during interactive session during plotting must be inactivated (for development purposes only).</p>
</dd>
<dt>spaMM_debugmod</dt><dd><p>A <em>logical</em> indicating if the warnings and errors produced by the spaMM package should stopped being turned into messages (for development purposes only).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="options_+3A_x">x</code></td>
<td>
<p>A character string holding an option name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if the delta notation is not successfully rendered on
your plots (which can happen for various reasons related to fonts, encoding
settings, graphic devices and perhaps more), you may try to use e.g.
<code>options_IsoriX(title_delta_notation = bquote(italic("\u03B4")**2*H[p]))</code>
to override the default for all plots. The default does correspond to
<code>options_IsoriX(title_delta_notation = bquote(delta**2*H))</code>. If you
are working with oxygen (rather than with deuterium), modifying the
global option is also a good place to do so. You may do:
<code>options_IsoriX(title_delta_notation = bquote(delta**18*O))</code>.
</p>


<h3>Value</h3>

<p>The options are invisibly returned in an object called <code>IsoriX:::.data_IsoriX$options</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>OldOptions &lt;- options_IsoriX()
OldOptions
getOption_IsoriX("title_delta_notation")
getOption_IsoriX("example_maxtime")
options_IsoriX(example_maxtime = 30)
options_IsoriX()
options_IsoriX(example_maxtime = OldOptions$example_maxtime)
options_IsoriX()
</code></pre>

<hr>
<h2 id='plots'>Plotting functions for IsoriX</h2><span id='topic+plots'></span><span id='topic+plot.ISOFIT'></span><span id='topic+plot.ISOSCAPE'></span><span id='topic+plot.CALIBFIT'></span><span id='topic+plot.ISOFIND'></span><span id='topic+plot.SpatRaster'></span><span id='topic+points.CALIBFIT'></span>

<h3>Description</h3>

<p>These functions plot objects created by IsoriX (with the exception of plot
method for SpatRaster created using <code><a href="terra.html#topic+terra-package">terra::terra</a></code>. All plotting functions
are based on the powerful package <span class="pkg">lattice</span>. If instead you want to
use <span class="pkg">ggplot2</span>, please follow the instructions on the
<a href="https://bookdown.org/content/782/advanced.html#ggplot">online tutorial</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ISOSCAPE'
plot(
  x,
  which = "mean",
  y_title = list(which = TRUE, title = getOption_IsoriX("title_delta_notation")),
  sources = list(draw = TRUE, cex = 0.5, pch = 2, lwd = 1, col = "red"),
  borders = list(borders = NA, lwd = 0.5, col = "black"),
  mask = list(mask = NA, lwd = 0, col = "black", fill = "black"),
  palette = list(step = NA, range = c(NA, NA), n_labels = 11, digits = 2, fn = NA),
  plot = TRUE,
  sphere = list(build = FALSE, keep_image = TRUE),
  ...
)

## S3 method for class 'ISOFIND'
plot(
  x,
  who = "group",
  cutoff = list(draw = TRUE, level = 0.05, col = "#909090"),
  sources = list(draw = TRUE, cex = 0.5, pch = 2, lwd = 1, col = "red"),
  calibs = list(draw = TRUE, cex = 0.5, pch = 4, lwd = 1, col = "blue"),
  assigns = list(draw = TRUE, cex = 0.5, pch = 5, lwd = 1, col = "white"),
  borders = list(borders = NA, lwd = 0.5, col = "black"),
  mask = list(mask = NA, lwd = 0, col = "black", fill = "black"),
  mask2 = list(mask = NA, lwd = 0, col = "purple", fill = "purple"),
  palette = list(step = NA, range = c(0, 1), n_labels = 11, digits = 2, fn = NA),
  plot = TRUE,
  sphere = list(build = FALSE, keep_image = TRUE),
  ...
)

## S3 method for class 'ISOFIT'
plot(x, cex_scale = 0.2, ...)

## S3 method for class 'CALIBFIT'
plot(
  x,
  pch = 1,
  col = "black",
  xlab = "Isotopic value in the environment",
  ylab = "Isotopic value in the calibration sample",
  xlim = NULL,
  ylim = NULL,
  line = list(show = TRUE, col = "blue"),
  CI = list(show = TRUE, col = "blue"),
  plot = TRUE,
  ...
)

## S3 method for class 'CALIBFIT'
points(
  x,
  pch = 2,
  col = "red",
  line = list(show = TRUE, col = "red"),
  CI = list(show = TRUE, col = "red"),
  plot = TRUE,
  ...
)

## S3 method for class 'SpatRaster'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plots_+3A_x">x</code></td>
<td>
<p>The return object of a call to <code><a href="#topic+isofit">isofit</a></code>, <code><a href="#topic+isoscape">isoscape</a></code>, <code><a href="#topic+calibfit">calibfit</a></code>,
<code><a href="#topic+isofind">isofind</a></code>, or <code><a href="terra.html#topic+rast">terra::rast</a></code></p>
</td></tr>
<tr><td><code id="plots_+3A_which">which</code></td>
<td>
<p>A <em>string</em> indicating the name of the raster to be plotted
(see details)</p>
</td></tr>
<tr><td><code id="plots_+3A_y_title">y_title</code></td>
<td>
<p>A <em>list</em> containing information for the display of the
title (see details)</p>
</td></tr>
<tr><td><code id="plots_+3A_sources">sources</code></td>
<td>
<p>A <em>list</em> containing information for the display of the
location of the sources (see details)</p>
</td></tr>
<tr><td><code id="plots_+3A_borders">borders</code></td>
<td>
<p>A <em>list</em> containing information for the display of borders
(e.g. country borders) (see details)</p>
</td></tr>
<tr><td><code id="plots_+3A_mask">mask</code></td>
<td>
<p>A <em>list</em> containing information for the display of a mask
(e.g. an ocean mask) (see details)</p>
</td></tr>
<tr><td><code id="plots_+3A_palette">palette</code></td>
<td>
<p>A <em>list</em> containing information for the display of the
colours for the isoscape (see details)</p>
</td></tr>
<tr><td><code id="plots_+3A_plot">plot</code></td>
<td>
<p>A <em>logical</em> indicating whether the plot shall be plotted or
just returned</p>
</td></tr>
<tr><td><code id="plots_+3A_sphere">sphere</code></td>
<td>
<p>A <em>list</em> containing information whether the raster should
be returned as a rotating sphere and if the image created during the
process should be saved in your current working directory. The default
settings are FALSE and TRUE, respectively.</p>
</td></tr>
<tr><td><code id="plots_+3A_...">...</code></td>
<td>
<p>Additional arguments (only in use in plot.CALIBFIT and
plot.SpatRaster)</p>
</td></tr>
<tr><td><code id="plots_+3A_who">who</code></td>
<td>
<p>Either &quot;group&quot;, or a vector of indices (e.g. 1:3) or names of the
individuals (e.g. c(&quot;Mbe_1&quot;, &quot;Mbe_3&quot;)) to be considered in assignment plots</p>
</td></tr>
<tr><td><code id="plots_+3A_cutoff">cutoff</code></td>
<td>
<p>A <em>list</em> containing information for the display of the
region outside the prediction interval (see details)</p>
</td></tr>
<tr><td><code id="plots_+3A_calibs">calibs</code></td>
<td>
<p>A <em>list</em> containing information for the display of the
location of the calibration sampling location (see details)</p>
</td></tr>
<tr><td><code id="plots_+3A_assigns">assigns</code></td>
<td>
<p>A <em>list</em> containing information for the display of the
location of the assignment sampling location (see details)</p>
</td></tr>
<tr><td><code id="plots_+3A_mask2">mask2</code></td>
<td>
<p>A <em>list</em> containing information for the display of a mask
(e.g. a distribution mask) (see details)</p>
</td></tr>
<tr><td><code id="plots_+3A_cex_scale">cex_scale</code></td>
<td>
<p>A <em>numeric</em> giving a scaling factor for the points in
the plots</p>
</td></tr>
<tr><td><code id="plots_+3A_pch">pch</code></td>
<td>
<p>The argument pch as in <code><a href="graphics.html#topic+par">par</a></code> for plot.CALIBFIT and
points.CALIBFIT</p>
</td></tr>
<tr><td><code id="plots_+3A_col">col</code></td>
<td>
<p>The argument col as in <code><a href="graphics.html#topic+par">par</a></code> for plot.CALIBFIT and
points.CALIBFIT</p>
</td></tr>
<tr><td><code id="plots_+3A_xlab">xlab</code></td>
<td>
<p>A <em>string</em> the x-axis label in plot.CALIBFIT</p>
</td></tr>
<tr><td><code id="plots_+3A_ylab">ylab</code></td>
<td>
<p>A <em>string</em> the y-axis label in plot.CALIBFIT</p>
</td></tr>
<tr><td><code id="plots_+3A_xlim">xlim</code></td>
<td>
<p>A range defining the extreme coordinates for the the x-axis in
plot.CALIBFIT</p>
</td></tr>
<tr><td><code id="plots_+3A_ylim">ylim</code></td>
<td>
<p>A range defining the extreme coordinates for the the y-axis in
plot.CALIBFIT</p>
</td></tr>
<tr><td><code id="plots_+3A_line">line</code></td>
<td>
<p>A <em>list</em> containing two elements: <code>show</code>, a
<em>logical</em> indicating whether to show the regression line or not; and
<code>col</code>, a <em>string</em> or <em>integer</em> indicating the colour for
plotting the regression line</p>
</td></tr>
<tr><td><code id="plots_+3A_ci">CI</code></td>
<td>
<p>A <em>list</em> containing two elements: <code>show</code>, a <em>logical</em>
indicating whether to show the confidence interval or not; and <code>col</code>,
a <em>string</em> or <em>integer</em> indicating the colour for plotting the
confidence interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>General</strong>
</p>
<p>When called upon an object of class <em>ISOFIT</em>, the plot function
draws diagnostic information for the fits of the isoscape geostatistical
model.
</p>
<p>When called upon an object of class <em>CALIBFIT</em>, the plot function draws the
fitted calibration function.
</p>
<p>When called upon an object of class <em>ISOSCAPE</em>, the plot function draws a
fine-tuned plot of the isoscape.
</p>
<p>When called upon an object of class <em>SpatRaster</em>, the plot function displays
the raster (just for checking things fast and dirty). In this case, the
function is a simple shortcut to <code><a href="rasterVis.html#topic+levelplot-methods">rasterVis::levelplot</a></code>.
</p>
<p><strong>Plotting isoscapes</strong>
</p>
<p>When used on a fitted isoscape, the user can choose between plotting the
predictions (<code>which = "mean"</code>; default), the prediction variance (<code>which = "mean_predVar"</code>), the residual variance (<code>which = "mean_residVar"</code>), or the
response variance (<code>which = "mean_respVar"</code>) for the mean model; or the
corresponding information for the residual dispersion variance model
(<code>"disp"</code>, <code>"disp_predVar"</code>, <code>"disp_residVar"</code>, or <code>"disp_respVar"</code>).
</p>
<p>When used on a simulated isoscape produced with the function <code>isosim</code>
(currently dropped due to the package RandomFields being temporarily retired
from CRAN), the user can choose between plotting the mean isotopic value
(<code>which = "mean"</code>) or the residual dispersion (<code>which = "disp"</code>).
</p>
<p><strong>Plotting assignments</strong>
</p>
<p>When called upon an object of class <em>ISOFIND</em>, the plot function draws a
fine-tuned plot of the assignment. You can use the argument <code>who</code> to choose
between plotting the assignment for the group or for some individuals (check
the <a href="https://bookdown.org/content/782/">online tutorial</a> for examples).
</p>
<p><strong>Info on parameters influencing the rendering of maps</strong>
</p>
<p>The argument <code>y_title</code> is a list that can be tweaked to customise the title
of isoscapes. Within this list, the element <code>which</code> is a logical indicating
if the name of the layer should be displayed or not. The element <code>title</code> is a
string or a call used to define the rest of the title. By default it draws
the delta value for hydrogen. Check the syntax of this default before trying
to modify it. If you want to modify it for all plots, see <code><a href="#topic+getOption_IsoriX">getOption_IsoriX</a></code>.
</p>
<p>The arguments <code>cutoff</code>, <code>sources</code>, <code>calibs</code>, <code>assigns</code>, <code>borders</code>, <code>mask</code>,
and <code>mask2</code> are used to fine-tune additional layers that can be added to the
main plot to embellish it. These arguments must be lists that provide details
on how to draw, respectively, the area outside the prediction interval (for
assignment plots), the locations of sources (for both isoscape and assignment
plots), the locations of the calibration samples (for assignment plots), the
locations of the assignment samples (for assignment plots), the borders (for
both types of plots), and the mask (again, for both). For assignment maps, an
extra mask can be used (mask2), as one may want to add a mask covering the
area outside the biological range of the species. Within these lists, the
elements <code>lwd</code>, <code>col</code>, <code>cex</code>, <code>pch</code> and <code>fill</code> influences their respective
objects as in traditional R plotting functions (see <code><a href="graphics.html#topic+par">par</a></code> for details). The
element <code>draw</code> should be a <em>logical</em> that indicates whether the layer must be
created or not. The argument <code>borders</code> (within the list borders) expects an
object of the class <em>SpatVector</em>, such as the object <code><a href="#topic+CountryBorders">CountryBorders</a></code>
provided with this package. The argument <code>mask</code> (within the list mask)
also expects an object of the class <em>SpatVector</em>, such as the object
<code><a href="#topic+OceanMask">OceanMask</a></code> provided with this package (see examples).
</p>
<p>The argument <code>palette</code> is used to define how to colour the isoscape and
assignment plot. Within this list, <code>step</code> defines the number of units on the
z-scale that shares a given colour; <code>range</code> can be used to constrain the
minimum and/or maximum values to be drawn (e.g. range = c(0, 1)) (this latter
argument is useful if one wants to create several plots with the same
z-scale); <code>n_labels</code> allows for the user to approximately define the
maximum number of numbers plotted on the z-scale; <code>digits</code> defines the number
of digits displayed for the numbers used as labels; and <code>fn</code> is used to
specify the function that is used to sample the colours. If <code>fn</code> is NULL
(default) the palette functions derived from <code><a href="#topic+isopalette1">isopalette1</a></code> and <code><a href="#topic+isopalette2">isopalette2</a></code>
are used when plotting isoscape and assignments, respectively. If <code>fn</code> is NA
the function used is the palette <code><a href="viridisLite.html#topic+viridis">viridisLite::viridis</a></code>.
</p>
<p><strong>Default symbols used on maps</strong>
</p>
<p>Under the default settings, we chose to
represent:
</p>

<ul>
<li><p> the source data by little red triangles.
</p>
</li>
<li><p> the calibration data by little blue crosses.
</p>
</li>
<li><p> the locations where the samples to assign were collected by white
diamonds.
</p>
</li></ul>

<p>These symbols can be changed as explained above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isofit">isofit</a></code> for the function fitting the isoscape
</p>
<p><code><a href="#topic+isoscape">isoscape</a></code> for the function building the isoscape
</p>
<p><code><a href="#topic+calibfit">calibfit</a></code> for the function fitting the calibration function
</p>
<p><code><a href="#topic+isofind">isofind</a></code> for the function performing the assignment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See ?isoscape or ?isofind for examples

</code></pre>

<hr>
<h2 id='PrecipBrickDE'>The precipitation monthly amounts for Germany</h2><span id='topic+PrecipBrickDE'></span>

<h3>Description</h3>

<p>This brick of rasters contains the monthly precipitation amounts (in mm) for
Germany with a resolution of approximately 30 square-km.
</p>


<h3>Format</h3>

<p>A <em>SpatRaster</em> with 12 layers
</p>


<h3>Details</h3>

<p>The data are derived from &quot;precipitation (mm) WorldClim Version2&quot; which can
be downloaded using the function <code><a href="#topic+getprecip">getprecip</a></code>.
</p>


<h3>Source</h3>

<p><a href="https://worldclim.org/data/worldclim21.html">https://worldclim.org/data/worldclim21.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepcipitate">prepcipitate</a></code> to prepare this raster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The following example requires to download
## a large precipitation rasters with the function getprecip()
## and will therefore not run unless you uncomment it

## How did we create this file?

## Uncomment the following to create the file as we did
# getprecip() ## Download the tif files (~ 1 Gb compressed)
# PrecipBrickDE &lt;- prepcipitate(raster = ElevRasterDE)
# terra::saveRDS(PrecipBrickDE, file = "PrecipBrickDE.rds", compress = "xz")

</code></pre>

<hr>
<h2 id='prepcipitate'>Prepare the raster brick containing the precipitation data</h2><span id='topic+prepcipitate'></span>

<h3>Description</h3>

<p>This functions turns the WorldClim data downloaded using the function
<code><a href="#topic+getprecip">getprecip</a></code> into a <em>SpatRaster</em> of same resolution and
extent as the structural raster. This function is designed to be used with
<code><a href="#topic+isomultiscape">isomultiscape</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepcipitate(path = NULL, raster, verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepcipitate_+3A_path">path</code></td>
<td>
<p>A <em>string</em> indicating the path where the WorldClim data have
been downloaded. If the path is null (the default) the function will assume
that the folder containing the precipitation data is in the current
directory</p>
</td></tr>
<tr><td><code id="prepcipitate_+3A_raster">raster</code></td>
<td>
<p>A <em>raster</em> containing the structural raster</p>
</td></tr>
<tr><td><code id="prepcipitate_+3A_verbose">verbose</code></td>
<td>
<p>A <em>logical</em> indicating whether information about the
progress of the procedure should be displayed or not while the function is
running. By default verbose is <code>TRUE</code> if users use an interactive R
session, and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+getprecip">getprecip</a></code> to download the relevant precipitation data
</p>
<p><code><a href="#topic+PrecipBrickDE">PrecipBrickDE</a></code> for the stored precipitation data for Germany
</p>
<p><code><a href="#topic+prepelev">prepelev</a></code> to prepare an elevation raster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The following example takes some time and download a large amount of data (~ 1 Gb).
## It will therefore not be run unless you uncomment it

### We fit the models for Germany:
# GNIPDataDEagg &lt;- prepsources(data = GNIPDataDE)
#
# GermanFit &lt;- isofit(data = GNIPDataDEagg,
#                     mean_model_fix = list(elev = TRUE, lat.abs = TRUE))
#
### We prepare the structural raster:
# StrRaster &lt;- prepraster(raster = ElevRasterDE,
#                         isofit = GermanFit,
#                         aggregation_factor = 0)
#
### We download the precipitation data:
# temp_folder &lt;- tempdir()
# getprecip(path = temp_folder)
#
### We prepare the raster brick with all the precipitation data:
# PrecipitationBrick &lt;- prepcipitate(path = temp_folder,
#                                    raster = StrRaster)
#
### We plot the precipitation data:
# levelplot(PrecipitationBrick)

</code></pre>

<hr>
<h2 id='prepraster'>Prepare the structural raster</h2><span id='topic+prepraster'></span>

<h3>Description</h3>

<p>This function prepares the structural raster for the follow-up analyses. The
size and extent of the structural raster defines the resolution at which the
isoscapes and the assignments are defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepraster(
  raster,
  isofit = NULL,
  margin_pct = 5,
  aggregation_factor = 0L,
  aggregation_fn = mean,
  manual_crop = NULL,
  values_to_zero = c(-Inf, 0),
  verbose = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepraster_+3A_raster">raster</code></td>
<td>
<p>The structural raster (<em>SpatRaster</em>)</p>
</td></tr>
<tr><td><code id="prepraster_+3A_isofit">isofit</code></td>
<td>
<p>The fitted isoscape model returned by the function <code><a href="#topic+isofit">isofit</a></code></p>
</td></tr>
<tr><td><code id="prepraster_+3A_margin_pct">margin_pct</code></td>
<td>
<p>The percentage representing by how much the area should
extend outside the area used for cropping (default = 5, corresponding to
5%). Set to 0 if you want exact cropping.</p>
</td></tr>
<tr><td><code id="prepraster_+3A_aggregation_factor">aggregation_factor</code></td>
<td>
<p>The number of neighbouring cells (<em>integer</em>) to
merge during aggregation</p>
</td></tr>
<tr><td><code id="prepraster_+3A_aggregation_fn">aggregation_fn</code></td>
<td>
<p>The <em>function</em> used to aggregate cells</p>
</td></tr>
<tr><td><code id="prepraster_+3A_manual_crop">manual_crop</code></td>
<td>
<p>A vector of four coordinates (<em>numeric</em>) for manual
cropping, e.g. the spatial extent</p>
</td></tr>
<tr><td><code id="prepraster_+3A_values_to_zero">values_to_zero</code></td>
<td>
<p>A <em>numeric vector</em> of length two specifying the range
of values for the structural raster that must be turned into 0. Default is
<code>c(-Inf, 0)</code> which for an elevation raster brings all seas to an elevation
of zero. For using IsoriX for marine organisms, you should use <code>c(0, Inf)</code>
instead.</p>
</td></tr>
<tr><td><code id="prepraster_+3A_verbose">verbose</code></td>
<td>
<p>A <em>logical</em> indicating whether information about the progress
of the procedure should be displayed or not while the function is running.
By default verbose is <code>TRUE</code> if users use an interactive R session, and
<code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions allows the user to crop a raster according to either the
extent of the isoscape or manually. If a fitted isoscape object is provided
(see <code><a href="#topic+isofit">isofit</a></code>), the function extracts the observed locations of isotopic
sources from the model object and crops the structural raster accordingly.
Alternatively, <code>manual_crop</code> allows you to crop the structural raster to a
desired extent. If no model and no coordinates for manual cropping are
provided, no crop will be performed. Importantly, cropping is recommended as
it prevents extrapolations outside the latitude/longitude range of the source
data. Predicting outside the range of the source data may lead to highly
unreliable predictions.
</p>
<p>Aggregation changes the spatial resolution of the raster, making computation
faster and using less memory (this can affect the assignment; see note
below). An aggregation factor of zero (or one) keeps the resolution constant
(default).
</p>
<p>This function relies on calls to the functions <code><a href="terra.html#topic+aggregate">terra::aggregate</a></code> and
<code><a href="terra.html#topic+crop">terra::crop</a></code> from the package <span class="pkg">terra</span>. It thus share the limitations
of these functions. In particular, <code><a href="terra.html#topic+crop">terra::crop</a></code> expects extents with
increasing longitudes and latitudes. We have tried to partially relax this
constrains for longitude and you can use the argument <code>manual_crop</code> to
provide longitudes in decreasing order, which is useful to centre a isoscape
around the pacific for instance. But this fix does not solve all the
limitations as plotting polygons or points on top of that remains problematic
(see example bellow). We will work on this on the future but we have other
priorities for now (let us know if you really need this feature).
</p>


<h3>Value</h3>

<p>The prepared structural raster of class <em>SpatRaster</em>
</p>


<h3>Note</h3>

<p>Aggregating the raster may lead to different results for the
assignment, because the values of raster cells changes depending on the
aggregation function (see example below), which in turn affects model
predictions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ElevRasterDE">ElevRasterDE</a></code> for information on elevation rasters, which can be
used as structural rasters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The examples below will only be run if sufficient time is allowed
## You can change that by typing e.g. options_IsoriX(example_maxtime = XX)
## if you want to allow for examples taking up to ca. XX seconds to run
## (so don't write XX but put a number instead!)

if (getOption_IsoriX("example_maxtime") &gt; 30) {
  ## We fit the models for Germany
  GNIPDataDEagg &lt;- prepsources(data = GNIPDataDE)

  GermanFit &lt;- isofit(
    data = GNIPDataDEagg,
    mean_model_fix = list(elev = TRUE, lat_abs = TRUE)
  )

  ### Let's explore the difference between aggregation schemes

  ## We aggregate and crop using different settings
  ElevationRaster1 &lt;- prepraster(
    raster = ElevRasterDE,
    isofit = GermanFit,
    margin_pct = 0,
    aggregation_factor = 0
  )

  ElevationRaster2 &lt;- prepraster(
    raster = ElevRasterDE,
    isofit = GermanFit,
    margin_pct = 5,
    aggregation_factor = 5
  )

  ElevationRaster3 &lt;- prepraster(
    raster = ElevRasterDE,
    isofit = GermanFit,
    margin_pct = 10,
    aggregation_factor = 5, aggregation_fn = max
  )

  ## We plot the outcome of the 3 different aggregation schemes using terra

  oripar &lt;- par(mfrow = c(1, 3)) ## display 3 plots side-by-side

  plot(ElevationRaster1, main = "Original small raster")
  polys(CountryBorders)
  polys(OceanMask, col = "blue")

  plot(ElevationRaster2, main = "Small raster aggregated (by mean)")
  polys(CountryBorders)
  polys(OceanMask, col = "blue")

  plot(ElevationRaster3, main = "Small raster aggregated (by max)")
  polys(CountryBorders)
  polys(OceanMask, col = "blue")

  par(oripar) ## restore graphical settings
}

## The examples below will only be run if sufficient time is allowed
## You can change that by typing e.g. options_IsoriX(example_maxtime = XX)
## if you want to allow for examples taking up to ca. XX seconds to run
## (so don't write XX but put a number instead!)

if (getOption_IsoriX("example_maxtime") &gt; 10) {
  ### Let's create a raster centered around the pacific

  ## We first create an empty raster
  EmptyRaster &lt;- rast(matrix(0, ncol = 360, nrow = 180))
  ext(EmptyRaster) &lt;- c(-180, 180, -90, 90)
  crs(EmptyRaster) &lt;- "+proj=longlat +datum=WGS84"

  ## We crop it around the pacific
  PacificA &lt;- prepraster(EmptyRaster, manual_crop = c(110, -70, -90, 90))
  ext(PacificA) # note that the extent has changed!

  ## We plot (note the use of the function shift()!)
  plot(PacificA, col = "blue", legend = FALSE)
  polys(CountryBorders, col = "black")
  polys(shift(CountryBorders, dx = 360), col = "black")
}

</code></pre>

<hr>
<h2 id='prepsources'>Filter and aggregate the raw source dataset</h2><span id='topic+prepsources'></span>

<h3>Description</h3>

<p>This function prepares the available dataset to be used for creating the
isoscape (e.g. <code><a href="#topic+GNIPDataDE">GNIPDataDE</a></code>). This function allows the trimming of data
by months, years and location, and for the aggregation of selected data per
location, location:month combination or location:year combination. The
function can also be used to randomly exclude some observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepsources(
  data,
  month = 1:12,
  year,
  long_min = -180,
  long_max = 180,
  lat_min = -90,
  lat_max = 90,
  split_by = NULL,
  prop_random = 0,
  random_level = "source",
  col_source_value = "source_value",
  col_source_ID = "source_ID",
  col_lat = "lat",
  col_long = "long",
  col_elev = "elev",
  col_month = "month",
  col_year = "year"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepsources_+3A_data">data</code></td>
<td>
<p>A <em>dataframe</em> containing raw isotopic measurements of sources</p>
</td></tr>
<tr><td><code id="prepsources_+3A_month">month</code></td>
<td>
<p>A <em>numeric vector</em> indicating the months to select from.
Should be a vector of round numbers between 1 and 12. The default is 1:12
selecting all months.</p>
</td></tr>
<tr><td><code id="prepsources_+3A_year">year</code></td>
<td>
<p>A <em>numeric vector</em> indicating the years to select from.
Should be a vector of round numbers. The default is to select all years
available.</p>
</td></tr>
<tr><td><code id="prepsources_+3A_long_min">long_min</code></td>
<td>
<p>A <em>numeric</em> indicating the minimum longitude to select
from. Should be a number between -180 and 180 (default = -180).</p>
</td></tr>
<tr><td><code id="prepsources_+3A_long_max">long_max</code></td>
<td>
<p>A <em>numeric</em> indicating the maximal longitude to select
from. Should be a number between -180 and 180 (default = 180).</p>
</td></tr>
<tr><td><code id="prepsources_+3A_lat_min">lat_min</code></td>
<td>
<p>A <em>numeric</em> indicating the minimum latitude to select
from. Should be a number between -90 and 90 (default = -90).</p>
</td></tr>
<tr><td><code id="prepsources_+3A_lat_max">lat_max</code></td>
<td>
<p>A <em>numeric</em> indicating the maximal latitude to select
from (default = 90).</p>
</td></tr>
<tr><td><code id="prepsources_+3A_split_by">split_by</code></td>
<td>
<p>A <em>string</em> indicating whether data should be aggregated
per location (<code>split_by = NULL</code>, the default), per location:month
combination (<code>split_by = "month"</code>), or per location:year combination
(<code>split_by = "year"</code>).</p>
</td></tr>
<tr><td><code id="prepsources_+3A_prop_random">prop_random</code></td>
<td>
<p>A <em>numeric</em> indicating the proportion of observations
or sampling locations (depending on the argument for <code>random_level</code>)
that will be kept. If <code>prop_random</code> is greater than 0, then the
function will return a list containing two dataframes: one containing the
selected data, called <code>selected_data</code>, and one containing the
remaining data, called <code>remaining_data</code>.</p>
</td></tr>
<tr><td><code id="prepsources_+3A_random_level">random_level</code></td>
<td>
<p>A <em>string</em> indicating the level at which random draws
can be performed. The two possibilities are <code>"obs"</code>, which indicates
that observations are randomly drawn taken independently of their location,
or &quot;source&quot; (default), which indicates that observations are randomly drawn
at the level of sampling locations.</p>
</td></tr>
<tr><td><code id="prepsources_+3A_col_source_value">col_source_value</code></td>
<td>
<p>A <em>string</em> indicating the column containing the
isotopic measurements</p>
</td></tr>
<tr><td><code id="prepsources_+3A_col_source_id">col_source_ID</code></td>
<td>
<p>A <em>string</em> indicating the column containing the ID of
each sampling location</p>
</td></tr>
<tr><td><code id="prepsources_+3A_col_lat">col_lat</code></td>
<td>
<p>A <em>string</em> indicating the column containing the latitude
of each sampling location</p>
</td></tr>
<tr><td><code id="prepsources_+3A_col_long">col_long</code></td>
<td>
<p>A <em>string</em> indicating the column containing the longitude
of each sampling location</p>
</td></tr>
<tr><td><code id="prepsources_+3A_col_elev">col_elev</code></td>
<td>
<p>A <em>string</em> indicating the column containing the elevation
of each sampling location</p>
</td></tr>
<tr><td><code id="prepsources_+3A_col_month">col_month</code></td>
<td>
<p>A <em>string</em> indicating the column containing the month of
sampling</p>
</td></tr>
<tr><td><code id="prepsources_+3A_col_year">col_year</code></td>
<td>
<p>A <em>string</em> indicating the column containing the year of
sampling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aggregates the data as required for the IsoriX workflow. Three
aggregation schemes are possible for now. The most simple one, used as
default, aggregates the data so to obtained a single row per sampling
location. Datasets prepared in this way can be readily fitted with the
function <code><a href="#topic+isofit">isofit</a></code> to build an isoscape. It is also possible to
aggregate data in a different way in order to build sub-isoscapes
representing temporal variation in isotope composition, or in order to
produce isoscapes weighted by the amount of precipitation (for isoscapes on
precipitation data only). The two possible options are to either split the
data from each location by month or to split them by year. This is set with
the <code>split_by</code> argument of the function. Datasets prepared in this way
should be fitted with the function <code><a href="#topic+isomultifit">isomultifit</a></code>.
</p>
<p>The function also allows the user to filter the sampling locations based on
time (years and/ or months) and space (locations given in geographic
coordinates, i.e. longitude and latitude) to calculate tailored isoscapes
matching e.g. the time of sampling and speeding up the model fit by
cropping/clipping a certain area. The dataframe produced by this function can
be used as input to fit the isoscape (see <code><a href="#topic+isofit">isofit</a></code> and
<code><a href="#topic+isomultifit">isomultifit</a></code>).
</p>


<h3>Value</h3>

<p>This function returns a <em>dataframe</em> containing the filtered data
aggregated by sampling location, or a <em>list</em>, see above argument
<code>prop_random</code>. For each sampling location the mean and variance sample
estimates are computed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a processed dataset for Germany
GNIPDataDEagg &lt;- prepsources(data = GNIPDataDE)

head(GNIPDataDEagg)

## Create a processed dataset for Germany per month
GNIPDataDEmonthly &lt;- prepsources(
  data = GNIPDataDE,
  split_by = "month"
)

head(GNIPDataDEmonthly)

## Create a processed dataset for Germany per year
GNIPDataDEyearly &lt;- prepsources(
  data = GNIPDataDE,
  split_by = "year"
)

head(GNIPDataDEyearly)

## Create isoscape-dataset for warm months in germany between 1995 and 1996
GNIPDataDEwarm &lt;- prepsources(
  data = GNIPDataDE,
  month = 5:8,
  year = 1995:1996
)

head(GNIPDataDEwarm)


## Create a dataset with 90% of obs
GNIPDataDE90pct &lt;- prepsources(
  data = GNIPDataDE,
  prop_random = 0.9,
  random_level = "obs"
)

lapply(GNIPDataDE90pct, head) # show beginning of both datasets

## Create a dataset with half the weather sources
GNIPDataDE50pctsources &lt;- prepsources(
  data = GNIPDataDE,
  prop_random = 0.5,
  random_level = "source"
)

lapply(GNIPDataDE50pctsources, head)


## Create a dataset with half the weather sources split per month
GNIPDataDE50pctsourcesMonthly &lt;- prepsources(
  data = GNIPDataDE,
  split_by = "month",
  prop_random = 0.5,
  random_level = "source"
)

lapply(GNIPDataDE50pctsourcesMonthly, head)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+gpar'></span><span id='topic+grid.text'></span><span id='topic+lpolygon'></span><span id='topic+xyplot'></span><span id='topic+layer'></span><span id='topic+levelplot'></span><span id='topic+RdBuTheme'></span><span id='topic+get_ranPars'></span><span id='topic+plot'></span><span id='topic+points'></span><span id='topic+polys'></span><span id='topic+rast'></span><span id='topic+vect'></span><span id='topic+extract'></span><span id='topic+crs'></span><span id='topic+crs+3C-'></span><span id='topic+ext'></span><span id='topic+ext+3C-'></span><span id='topic+shift'></span><span id='topic+values'></span><span id='topic+cellSize'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>grid</dt><dd><p><code><a href="grid.html#topic+gpar">gpar</a></code>, <code><a href="grid.html#topic+grid.text">grid.text</a></code></p>
</dd>
<dt>lattice</dt><dd><p><code><a href="lattice.html#topic+llines">lpolygon</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</dd>
<dt>latticeExtra</dt><dd><p><code><a href="latticeExtra.html#topic+layer">layer</a></code></p>
</dd>
<dt>rasterVis</dt><dd><p><code><a href="rasterVis.html#topic+levelplot-methods">levelplot</a></code>, <code><a href="rasterVis.html#topic+rasterTheme">RdBuTheme</a></code></p>
</dd>
<dt>spaMM</dt><dd><p><code><a href="spaMM.html#topic+get_fittedPars">get_ranPars</a></code></p>
</dd>
<dt>terra</dt><dd><p><code><a href="terra.html#topic+cellSize">cellSize</a></code>, <code><a href="terra.html#topic+crs">crs</a></code>, <code><a href="terra.html#topic+crs">crs&lt;-</a></code>, <code><a href="terra.html#topic+ext">ext</a></code>, <code><a href="terra.html#topic+ext">ext&lt;-</a></code>, <code><a href="terra.html#topic+extract">extract</a></code>, <code><a href="terra.html#topic+plot">plot</a></code>, <code><a href="terra.html#topic+lines">points</a></code>, <code><a href="terra.html#topic+lines">polys</a></code>, <code><a href="terra.html#topic+rast">rast</a></code>, <code><a href="terra.html#topic+shift">shift</a></code>, <code><a href="terra.html#topic+values">values</a></code>, <code><a href="terra.html#topic+vect">vect</a></code></p>
</dd>
</dl>

<hr>
<h2 id='serialize'>Save and read objects produced by IsoriX using RDS files</h2><span id='topic+serialize'></span><span id='topic+serialise'></span><span id='topic+readRDS'></span><span id='topic+saveRDS'></span><span id='topic+saveRDS_IsoriX'></span><span id='topic+saveRDS.ISOSCAPE'></span><span id='topic+saveRDS.CALIBFIT'></span><span id='topic+saveRDS.ISOFIND'></span><span id='topic+readRDS.character'></span><span id='topic+saveRDS+2CISOSCAPE-method'></span><span id='topic+saveRDS+2CCALIBFIT-method'></span><span id='topic+saveRDS+2CISOFIND-method'></span><span id='topic+readRDS+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Because files created with IsoriX contain <code><a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a></code> and
<code><a href="terra.html#topic+SpatVector-class">terra::SpatVector</a></code> objects, they cannot be saved using <code><a href="base.html#topic+readRDS">base::saveRDS</a></code>
or <code><a href="base.html#topic+save">base::save</a></code> functions. The reason is that objects created with <code><a href="terra.html#topic+terra-package">terra::terra</a></code>
point to data stored in memory which are not contained in the R objects
themselves. Adapting the approach implemented in the <code><a href="terra.html#topic+terra-package">terra::terra</a></code> package, we
provide a wrapper for <code><a href="base.html#topic+readRDS">base::saveRDS</a></code> and <code><a href="base.html#topic+readRDS">base::readRDS</a></code> functions,
which allows one to save and read objects produced with IsoriX by simply
using <code>saveRDS()</code> and <code>readRDS()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveRDS_IsoriX(
  object,
  file = "",
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)

## S3 method for class 'ISOSCAPE'
saveRDS(
  object,
  file = "",
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)

## S3 method for class 'CALIBFIT'
saveRDS(
  object,
  file = "",
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)

## S3 method for class 'ISOFIND'
saveRDS(
  object,
  file = "",
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)

## S3 method for class 'character'
readRDS(file, refhook = NULL)

## S4 method for signature 'ISOSCAPE'
saveRDS(
  object,
  file = "",
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)

## S4 method for signature 'CALIBFIT'
saveRDS(
  object,
  file = "",
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)

## S4 method for signature 'ISOFIND'
saveRDS(
  object,
  file = "",
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)

## S4 method for signature 'character'
readRDS(file, refhook = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="serialize_+3A_object">object</code></td>
<td>
<p>(definition copied from  <code><a href="base.html#topic+readRDS">base::readRDS</a></code>:) R object to serialize.</p>
</td></tr>
<tr><td><code id="serialize_+3A_file">file</code></td>
<td>
<p>(definition copied from  <code><a href="base.html#topic+readRDS">base::readRDS</a></code>:) a connection or the name of the file where the R object is saved to or read from.</p>
</td></tr>
<tr><td><code id="serialize_+3A_ascii">ascii</code></td>
<td>
<p>(definition copied from  <code><a href="base.html#topic+readRDS">base::readRDS</a></code>:) a logical. If <code>TRUE</code> or <code>NA</code>, an ASCII representation is written; otherwise (default), a binary one is used. See the comments in the help for <code><a href="base.html#topic+save">base::save</a></code>.</p>
</td></tr>
<tr><td><code id="serialize_+3A_version">version</code></td>
<td>
<p>(definition copied from  <code><a href="base.html#topic+readRDS">base::readRDS</a></code>:) the workspace format version to use. <code>NULL</code> specifies the current default version (3). The only other supported value is <code>2</code>, the default from R 1.4.0 to R 3.5.0.</p>
</td></tr>
<tr><td><code id="serialize_+3A_compress">compress</code></td>
<td>
<p>(definition copied from  <code><a href="base.html#topic+readRDS">base::readRDS</a></code>:) a logical specifying whether saving to a named file is to use &quot;gzip&quot; compression, or one of &quot;gzip&quot;, &quot;bzip2&quot; or &quot;xz&quot; to indicate the type of compression to be used. Ignored if file is a connection.</p>
</td></tr>
<tr><td><code id="serialize_+3A_refhook">refhook</code></td>
<td>
<p>(definition copied from  <code><a href="base.html#topic+readRDS">base::readRDS</a></code>:) a hook function for handling reference objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="base.html#topic+readRDS">base::saveRDS</a></code> and <code><a href="base.html#topic+readRDS">base::readRDS</a></code> are standard S3 functions. So in
order to be able to have a specific behaviour for objects produced with
IsoriX, we imported <code>saveRDS</code> and <code>readRDS</code> S4 generics from  <code><a href="terra.html#topic+terra-package">terra::terra</a></code> to
dispatch both S3 and S4 IsoriX-specific methods (see <a href="methods.html#topic+Methods_for_S3">Methods_for_S3</a>). The
S3 implementation is consistent with the rest of the package and presents all
usual benefits associated with S3 methods (e.g. simple access to the code).
The S4 implementation makes IsoriX methods compatible with the use of
<code><a href="terra.html#topic+serialize">terra::saveRDS</a></code> and <code><a href="terra.html#topic+serialize">terra::readRDS</a></code>.
</p>


<h3>Value</h3>

<p>For <code>saveRDS</code>, <code>NULL</code> invisibly.
</p>
<p>For <code>readRDS</code>, an R object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>saveRDS_IsoriX()</code>: S3 function to save IsoriX objects into a RDS file
</p>
</li>
<li> <p><code>saveRDS(ISOSCAPE)</code>: S3 method to save an <code>ISOSCAPE</code> object into a RDS file
</p>
</li>
<li> <p><code>saveRDS(CALIBFIT)</code>: S3 method to save a <code>CALIBFIT</code> object into a RDS file
</p>
</li>
<li> <p><code>saveRDS(ISOFIND)</code>: S3 method to save an <code>ISOFIND</code> object into a RDS file
</p>
</li>
<li> <p><code>readRDS(character)</code>: S3 method to read an object produced with IsoriX (or other) stored in a RDS file
</p>
</li>
<li> <p><code>saveRDS(ISOSCAPE)</code>: S4 method to save an <code>ISOSCAPE</code> object into a RDS file
</p>
</li>
<li> <p><code>saveRDS(CALIBFIT)</code>: S4 method to save an <code>CALIBFIT</code> object into a RDS file
</p>
</li>
<li> <p><code>saveRDS(ISOFIND)</code>: S4 method to save an <code>ISOFIND</code> object into a RDS file
</p>
</li>
<li> <p><code>readRDS(character)</code>: S4 method to read an object produced with IsoriX (or other) stored in a RDS file
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>if (getOption_IsoriX("example_maxtime") &gt; 30) {
  ## We prepare the data
  GNIPDataDEagg &lt;- prepsources(data = GNIPDataDE)

  ## We fit the models
  GermanFit &lt;- isofit(
    data = GNIPDataDEagg,
    mean_model_fix = list(elev = TRUE, lat_abs = TRUE)
  )

  ## We build the isoscapes
  GermanScape &lt;- isoscape(raster = ElevRasterDE, isofit = GermanFit)

  ## Saving as RDS
  filename &lt;- tempfile(fileext = ".rds") # or whatever names you want
  saveRDS(GermanScape, file = filename)

  ## Reading RDS
  GermanScape2 &lt;- readRDS(filename)
  GermanScape2
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
