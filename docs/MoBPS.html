<!DOCTYPE html><html><head><title>Help for package MoBPS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MoBPS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.array'><p>Add a genotyping array</p></a></li>
<li><a href='#add.combi'><p>Add a trait as a linear combination of other traits</p></a></li>
<li><a href='#add.diag'><p>Add something to the diagonal</p></a></li>
<li><a href='#add.founder.kinship'><p>Add a relationship matrix for founder individuals</p></a></li>
<li><a href='#alpha_to_beta'><p>Moore-Penrose-Transfomration</p></a></li>
<li><a href='#analyze.bv'><p>Analyze genomic values</p></a></li>
<li><a href='#analyze.population'><p>Analyze allele frequency of a single marker</p></a></li>
<li><a href='#bit.snps'><p>Decoding of bitwise-storing in R</p></a></li>
<li><a href='#bit.storing'><p>Bitwise-storing in R</p></a></li>
<li><a href='#breeding.diploid'><p>Breeding function</p></a></li>
<li><a href='#breeding.intern'><p>Internal function to simulate one meiosis</p></a></li>
<li><a href='#bv.development'><p>Development of genetic/breeding value</p></a></li>
<li><a href='#bv.development.box'><p>Development of genetic/breeding value using a boxplot</p></a></li>
<li><a href='#bv.standardization'><p>BV standardization</p></a></li>
<li><a href='#calculate.bv'><p>Calculate breeding values</p></a></li>
<li><a href='#cattle_chip'><p>Cattle chip</p></a></li>
<li><a href='#check.parents'><p>Relatedness check between two individuals</p></a></li>
<li><a href='#chicken_chip'><p>chicken chip</p></a></li>
<li><a href='#clean.up'><p>Clean-up recombination points</p></a></li>
<li><a href='#codeOriginsR'><p>Origins-coding(R)</p></a></li>
<li><a href='#combine.traits'><p>Combine traits</p></a></li>
<li><a href='#compute.costs'><p>Compute costs of a breeding program</p></a></li>
<li><a href='#compute.costs.cohorts'><p>Compute costs of a breeding program by cohorts</p></a></li>
<li><a href='#compute.snps'><p>Compute genotype/haplotype</p></a></li>
<li><a href='#compute.snps_single'><p>Compute genotype/haplotype in gene editing application</p></a></li>
<li><a href='#creating.diploid'><p>Generation of the starting population</p></a></li>
<li><a href='#creating.phenotypic.transform'><p>Create a phenotypic transformation</p></a></li>
<li><a href='#creating.trait'><p>Generation of genomic traits</p></a></li>
<li><a href='#decodeOriginsR'><p>Origins-Decoding(R)</p></a></li>
<li><a href='#demiraculix'><p>Remove miraculix-coding for genotypes</p></a></li>
<li><a href='#derive.loop.elements'><p>Derive loop elements</p></a></li>
<li><a href='#diag.mobps'><p>Add a genotyping array</p></a></li>
<li><a href='#edges.fromto'><p>Detection of parental/child nodes</p></a></li>
<li><a href='#edit_animal'><p>Internal gene editing function</p></a></li>
<li><a href='#effect.estimate.add'><p>Estimation of marker effects</p></a></li>
<li><a href='#effective.size'><p>Estimate effective population size</p></a></li>
<li><a href='#epi'><p>Martini-Test function</p></a></li>
<li><a href='#ex_json'><p>ex_json</p></a></li>
<li><a href='#ex_pop'><p>ex_pop</p></a></li>
<li><a href='#find.chromo'><p>Position detection (chromosome)</p></a></li>
<li><a href='#find.snpbefore'><p>Position detection (SNPs)</p></a></li>
<li><a href='#founder.simulation'><p>Founder simulation</p></a></li>
<li><a href='#generation.individual'><p>Function to generate a new individual</p></a></li>
<li><a href='#get.admixture'><p>Admixture Plot</p></a></li>
<li><a href='#get.age.point'><p>Derive age point</p></a></li>
<li><a href='#get.bv'><p>Export underlying true breeding values</p></a></li>
<li><a href='#get.bve'><p>Export estimated breeding values</p></a></li>
<li><a href='#get.class'><p>Derive class</p></a></li>
<li><a href='#get.cohorts'><p>Export Cohort-names</p></a></li>
<li><a href='#get.creating.type'><p>Derive creating type</p></a></li>
<li><a href='#get.cullingtime'><p>Derive time of culling</p></a></li>
<li><a href='#get.database'><p>gen/database/cohorts conversion</p></a></li>
<li><a href='#get.death.point'><p>Derive death point</p></a></li>
<li><a href='#get.dendrogram'><p>Dendrogram</p></a></li>
<li><a href='#get.dendrogram.heatmap'><p>Dendrogram Heatmap</p></a></li>
<li><a href='#get.dendrogram.trait'><p>Dendrogram</p></a></li>
<li><a href='#get.distance'><p>Calculate Nei distance between two or more population</p></a></li>
<li><a href='#get.effect.freq'><p>Compute marker frequency in QTL-markers</p></a></li>
<li><a href='#get.effective.size'><p>Estimate effective population size</p></a></li>
<li><a href='#get.geno'><p>Derive genotypes of selected individuals</p></a></li>
<li><a href='#get.genotyped'><p>Derive genotyping status</p></a></li>
<li><a href='#get.genotyped.snp'><p>Derive which markers are genotyped of selected individuals</p></a></li>
<li><a href='#get.haplo'><p>Derive haplotypes of selected individuals</p></a></li>
<li><a href='#get.id'><p>Derive ID on an individual</p></a></li>
<li><a href='#get.individual.loc'><p>Export location of individuals from the population list</p></a></li>
<li><a href='#get.infos'><p>Extract bv/pheno/geno of selected individuals</p></a></li>
<li><a href='#get.map'><p>Map generation</p></a></li>
<li><a href='#get.npheno'><p>Export underlying number of observations per phenotype</p></a></li>
<li><a href='#get.pca'><p>Principle components analysis</p></a></li>
<li><a href='#get.pedigree'><p>Derive pedigree</p></a></li>
<li><a href='#get.pedigree2'><p>Derive pedigree including grandparents</p></a></li>
<li><a href='#get.pedigree3'><p>Derive pedigree parents and grandparents</p></a></li>
<li><a href='#get.pedmap'><p>Generate plink-file (pedmap)</p></a></li>
<li><a href='#get.pheno'><p>Export underlying phenotypes</p></a></li>
<li><a href='#get.pheno.off'><p>Export underlying offspring phenotypes</p></a></li>
<li><a href='#get.pheno.off.count'><p>Export underlying number of used offspring for offspring phenotypes</p></a></li>
<li><a href='#get.phylogenetic.tree'><p>Phylogenetic Tree</p></a></li>
<li><a href='#get.qtl'><p>QTL extraction</p></a></li>
<li><a href='#get.qtl.effects'><p>QTL effect extraction</p></a></li>
<li><a href='#get.qtl.variance'><p>QTL effect variance extraction</p></a></li>
<li><a href='#get.recombi'><p>Derive genetic origins</p></a></li>
<li><a href='#get.reliabilities'><p>Export underlying reliabilities</p></a></li>
<li><a href='#get.selectionbve'><p>Export derived breeding values based on the selection index</p></a></li>
<li><a href='#get.selectionindex'><p>Export underlying last used selection index</p></a></li>
<li><a href='#get.time.point'><p>Derive time point</p></a></li>
<li><a href='#get.vcf'><p>Generate vcf-file</p></a></li>
<li><a href='#group.diff'><p>Function to exclude individuals from a database</p></a></li>
<li><a href='#insert.bve'><p>Manually enter estimated breeding values</p></a></li>
<li><a href='#json.simulation'><p>Simulation of a breeding program based on a JSON-file from MoBPSweb</p></a></li>
<li><a href='#kinship.development'><p>Devolopment of genetic/breeding value</p></a></li>
<li><a href='#kinship.emp'><p>Empirical kinship</p></a></li>
<li><a href='#kinship.emp.fast'><p>Approximate empirical kinship</p></a></li>
<li><a href='#kinship.exp'><p>Derive expected kinship</p></a></li>
<li><a href='#ld.decay'><p>Generate LD plot</p></a></li>
<li><a href='#maize_chip'><p>maize chip</p></a></li>
<li><a href='#miesenberger.index'><p>Miesenberger Index</p></a></li>
<li><a href='#miraculix'><p>Add miraculix-coding for genotypes</p></a></li>
<li><a href='#mutation.intro'><p>Mutation intro</p></a></li>
<li><a href='#new.base.generation'><p>Set new base generation</p></a></li>
<li><a href='#OGC'><p>Optimal genetic contribution</p></a></li>
<li><a href='#pedigree.simulation'><p>Simulation of a given pedigree</p></a></li>
<li><a href='#pedmap.to.phasedbeaglevcf'><p>Internal function to perform imputing/phasing</p></a></li>
<li><a href='#pig_chip'><p>pig chip</p></a></li>
<li><a href='#plot.population'><p>Plot Population</p></a></li>
<li><a href='#set.class'><p>Export estimated breeding values</p></a></li>
<li><a href='#set.default'><p>Set defaults</p></a></li>
<li><a href='#sheep_chip'><p>sheep chip</p></a></li>
<li><a href='#sortd'><p>Apply sort and unique</p></a></li>
<li><a href='#ssGBLUP'><p>Single Step GBLUP</p></a></li>
<li><a href='#summary.population'><p>Summary Population</p></a></li>
<li><a href='#vlist'><p>Generation of a sublist</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modular Breeding Program Simulator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.64</td>
</tr>
<tr>
<td>Author:</td>
<td>Torsten Pook</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Torsten Pook &lt;torsten.pook@uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Framework for the simulation framework for the simulation of complex breeding programs and compare their economic and genetic impact. The package is also used as the background simulator for our a web-based interface &lt;http:www.mobps.de&gt;. Associated publication: Pook et al. (2020) &lt;<a href="https://doi.org/10.1534%2Fg3.120.401193">doi:10.1534/g3.120.401193</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>EMMREML, BGLR, MASS, doMPI, doRNG, compiler, foreach, sommer,
vcfR, jsonlite, rrBLUP, biomaRt, Matrix, doParallel,
RColorBrewer, optiSel, alstructure, NAM, gplots, phylogram,
cPCG</td>
</tr>
<tr>
<td>Enhances:</td>
<td>miraculix (&ge; 0.9.10), RandomFieldsUtils (&ge; 0.5.9),
MoBPSmaps</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://tpook92.github.io/drat/">https://tpook92.github.io/drat/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-11-03</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-03 13:09:32 UTC; pook</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-09 16:50:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.array'>Add a genotyping array</h2><span id='topic+add.array'></span>

<h3>Description</h3>

<p>Function to add a genotyping array for the population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.array(population, marker.included = TRUE, array.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.array_+3A_population">population</code></td>
<td>
<p>population list</p>
</td></tr>
<tr><td><code id="add.array_+3A_marker.included">marker.included</code></td>
<td>
<p>Vector with number of SNP entries coding if each marker is on the array (TRUE/FALSE)</p>
</td></tr>
<tr><td><code id="add.array_+3A_array.name">array.name</code></td>
<td>
<p>Name of the added array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
population &lt;- add.array(ex_pop, marker.included = c(TRUE, FALSE), array.name="Half-density")
</code></pre>

<hr>
<h2 id='add.combi'>Add a trait as a linear combination of other traits</h2><span id='topic+add.combi'></span>

<h3>Description</h3>

<p>Function to create an additional trait that is the results of a linear combination of the other traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.combi(population, trait, combi.weights, trait.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.combi_+3A_population">population</code></td>
<td>
<p>population list</p>
</td></tr>
<tr><td><code id="add.combi_+3A_trait">trait</code></td>
<td>
<p>trait nr. for which to implement a combination of other traits</p>
</td></tr>
<tr><td><code id="add.combi_+3A_combi.weights">combi.weights</code></td>
<td>
<p>Weights (only linear combinations of other traits are allowed!)</p>
</td></tr>
<tr><td><code id="add.combi_+3A_trait.name">trait.name</code></td>
<td>
<p>Name of the trait generated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population list
</p>
<p>Population list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
population &lt;- creating.trait(ex_pop, n.additive = 100)
population &lt;- add.combi(population, trait = 3, combi.weights = c(1,5))
</code></pre>

<hr>
<h2 id='add.diag'>Add something to the diagonal</h2><span id='topic+add.diag'></span>

<h3>Description</h3>

<p>Function to add numeric to the diagonal of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.diag(M, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.diag_+3A_m">M</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="add.diag_+3A_d">d</code></td>
<td>
<p>Vector to add to the diagonal of the matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with increased diagonal elements
</p>
<p>Matrix with modified diagonal entries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1,2,3,4), ncol=2)
B &lt;- add.diag(A, 5)
</code></pre>

<hr>
<h2 id='add.founder.kinship'>Add a relationship matrix for founder individuals</h2><span id='topic+add.founder.kinship'></span>

<h3>Description</h3>

<p>Function to relationship matrix for founder individuals that is used for any calculation of the pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.founder.kinship(population, founder.kinship = "vanRaden", gen = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.founder.kinship_+3A_population">population</code></td>
<td>
<p>population list</p>
</td></tr>
<tr><td><code id="add.founder.kinship_+3A_founder.kinship">founder.kinship</code></td>
<td>
<p>Default is to use vanRaden relationship. Alternative is to enter a pedigree-matrix (order of individuals is first male then female)</p>
</td></tr>
<tr><td><code id="add.founder.kinship_+3A_gen">gen</code></td>
<td>
<p>Generation for which to enter the pedigree-matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
population &lt;- add.founder.kinship(ex_pop)
</code></pre>

<hr>
<h2 id='alpha_to_beta'>Moore-Penrose-Transfomration</h2><span id='topic+alpha_to_beta'></span>

<h3>Description</h3>

<p>Internal transformation using Moore-Penrose
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha_to_beta(alpha, G, Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha_to_beta_+3A_alpha">alpha</code></td>
<td>
<p>alpha</p>
</td></tr>
<tr><td><code id="alpha_to_beta_+3A_g">G</code></td>
<td>
<p>kinship-matrix</p>
</td></tr>
<tr><td><code id="alpha_to_beta_+3A_z">Z</code></td>
<td>
<p>genomic information matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with single marker effects
</p>

<hr>
<h2 id='analyze.bv'>Analyze genomic values</h2><span id='topic+analyze.bv'></span>

<h3>Description</h3>

<p>Function to analyze correlation between bv/bve/pheno
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze.bv(
  population,
  gen = NULL,
  database = NULL,
  cohorts = NULL,
  bvrow = "all",
  advanced = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze.bv_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="analyze.bv_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="analyze.bv_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="analyze.bv_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="analyze.bv_+3A_bvrow">bvrow</code></td>
<td>
<p>Which traits to display</p>
</td></tr>
<tr><td><code id="analyze.bv_+3A_advanced">advanced</code></td>
<td>
<p>Set to TRUE to also look at offspring pheno</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[[1]] Correlation between BV/BVE/Phenotypes [[2]] Genetic variance of the traits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
analyze.bv(ex_pop,gen=1)
</code></pre>

<hr>
<h2 id='analyze.population'>Analyze allele frequency of a single marker</h2><span id='topic+analyze.population'></span>

<h3>Description</h3>

<p>Analyze allele frequency of a single marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze.population(
  population,
  chromosome = NULL,
  snp = NULL,
  snp.name = NULL,
  database = NULL,
  gen = NULL,
  cohorts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze.population_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="analyze.population_+3A_chromosome">chromosome</code></td>
<td>
<p>Number of the chromosome of the relevant SNP</p>
</td></tr>
<tr><td><code id="analyze.population_+3A_snp">snp</code></td>
<td>
<p>Number of the relevant SNP</p>
</td></tr>
<tr><td><code id="analyze.population_+3A_snp.name">snp.name</code></td>
<td>
<p>Name of the SNP to analyze</p>
</td></tr>
<tr><td><code id="analyze.population_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="analyze.population_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="analyze.population_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Frequency of AA/AB/BB in selected gen/database/cohorts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
analyze.population(ex_pop, snp=1, chromosome=1, gen=1:5)
</code></pre>

<hr>
<h2 id='bit.snps'>Decoding of bitwise-storing in R</h2><span id='topic+bit.snps'></span>

<h3>Description</h3>

<p>Function for decoding in bitwise-storing in R (only 30 of 32 bits are used!)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bit.snps(bit.seq, nbits, population = NULL, from.p.bit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bit.snps_+3A_bit.seq">bit.seq</code></td>
<td>
<p>bitweise gespeicherte SNP-Sequenz</p>
</td></tr>
<tr><td><code id="bit.snps_+3A_nbits">nbits</code></td>
<td>
<p>Number of usable bits (default: 30)</p>
</td></tr>
<tr><td><code id="bit.snps_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="bit.snps_+3A_from.p.bit">from.p.bit</code></td>
<td>
<p>Bit to start on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>De-coded marker sequence
</p>

<hr>
<h2 id='bit.storing'>Bitwise-storing in R</h2><span id='topic+bit.storing'></span>

<h3>Description</h3>

<p>Function for bitwise-storing in R (only 30 of 32 bits are used!)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bit.storing(snpseq, nbits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bit.storing_+3A_snpseq">snpseq</code></td>
<td>
<p>SNP sequence</p>
</td></tr>
<tr><td><code id="bit.storing_+3A_nbits">nbits</code></td>
<td>
<p>Number of usable bits (default: 30)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bit-wise coded marker sequence
</p>

<hr>
<h2 id='breeding.diploid'>Breeding function</h2><span id='topic+breeding.diploid'></span>

<h3>Description</h3>

<p>Function to simulate a step in a breeding scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breeding.diploid(
  population,
  mutation.rate = 10^-8,
  remutation.rate = 10^-8,
  recombination.rate = 1,
  selection.m = NULL,
  selection.f = NULL,
  new.selection.calculation = TRUE,
  selection.function.matrix = NULL,
  selection.size = 0,
  ignore.best = 0,
  breeding.size = 0,
  breeding.sex = NULL,
  breeding.sex.random = FALSE,
  relative.selection = FALSE,
  class.m = 0,
  class.f = 0,
  add.gen = 0,
  recom.f.indicator = NULL,
  duplication.rate = 0,
  duplication.length = 0.01,
  duplication.recombination = 1,
  new.class = 0L,
  bve = FALSE,
  sigma.e = NULL,
  sigma.g = 100,
  new.bv.child = NULL,
  phenotyping.child = NULL,
  relationship.matrix = "vanRaden",
  relationship.matrix.ogc = "kinship",
  computation.A = NULL,
  computation.A.ogc = NULL,
  delete.haplotypes = NULL,
  delete.individuals = NULL,
  fixed.breeding = NULL,
  fixed.breeding.best = NULL,
  max.offspring = Inf,
  max.litter = Inf,
  store.breeding.totals = FALSE,
  forecast.sigma.g = TRUE,
  multiple.bve = "add",
  store.bve.data = FALSE,
  fixed.assignment = FALSE,
  reduce.group = NULL,
  reduce.group.selection = "random",
  selection.highest = c(TRUE, TRUE),
  selection.criteria = NULL,
  same.sex.activ = FALSE,
  same.sex.sex = 0.5,
  same.sex.selfing = FALSE,
  selfing.mating = FALSE,
  selfing.sex = 0.5,
  praeimplantation = NULL,
  heritability = NULL,
  repeatability = NULL,
  save.recombination.history = FALSE,
  martini.selection = FALSE,
  BGLR.bve = FALSE,
  BGLR.model = "RKHS",
  BGLR.burnin = 500,
  BGLR.iteration = 5000,
  BGLR.print = FALSE,
  copy.individual = FALSE,
  copy.individual.m = FALSE,
  copy.individual.f = FALSE,
  dh.mating = FALSE,
  dh.sex = 0.5,
  n.observation = NULL,
  bve.0isNA = FALSE,
  phenotype.bv = FALSE,
  delete.same.origin = FALSE,
  remove.effect.position = FALSE,
  estimate.u = FALSE,
  new.phenotype.correlation = NULL,
  new.residual.correlation = NULL,
  new.breeding.correlation = NULL,
  estimate.add.gen.var = FALSE,
  estimate.pheno.var = FALSE,
  best1.from.group = NULL,
  best2.from.group = NULL,
  best1.from.cohort = NULL,
  best2.from.cohort = NULL,
  add.class.cohorts = TRUE,
  store.comp.times = TRUE,
  store.comp.times.bve = TRUE,
  store.comp.times.generation = TRUE,
  import.position.calculation = NULL,
  BGLR.save = "RKHS",
  BGLR.save.random = FALSE,
  ogc = FALSE,
  ogc.target = "min.sKin",
  ogc.uniform = NULL,
  ogc.ub = NULL,
  ogc.lb = NULL,
  ogc.ub.sKin = NULL,
  ogc.lb.BV = NULL,
  ogc.ub.BV = NULL,
  ogc.eq.BV = NULL,
  ogc.ub.sKin.increase = NULL,
  ogc.lb.BV.increase = NULL,
  emmreml.bve = FALSE,
  rrblup.bve = FALSE,
  sommer.bve = FALSE,
  sommer.multi.bve = FALSE,
  nr.edits = 0,
  gene.editing.offspring = FALSE,
  gene.editing.best = FALSE,
  gene.editing.offspring.sex = c(TRUE, TRUE),
  gene.editing.best.sex = c(TRUE, TRUE),
  gwas.u = FALSE,
  approx.residuals = TRUE,
  sequenceZ = FALSE,
  maxZ = 5000,
  maxZtotal = 0,
  delete.sex = 1:2,
  gwas.group.standard = FALSE,
  y.gwas.used = "pheno",
  gen.architecture.m = 0,
  gen.architecture.f = NULL,
  add.architecture = NULL,
  ncore = 1,
  ncore.generation = 1,
  Z.integer = FALSE,
  store.effect.freq = FALSE,
  backend = "doParallel",
  randomSeed = NULL,
  randomSeed.generation = NULL,
  Rprof = FALSE,
  miraculix = NULL,
  miraculix.cores = 1,
  miraculix.mult = NULL,
  miraculix.chol = TRUE,
  best.selection.ratio.m = 1,
  best.selection.ratio.f = NULL,
  best.selection.criteria.m = "bv",
  best.selection.criteria.f = NULL,
  best.selection.manual.ratio.m = NULL,
  best.selection.manual.ratio.f = NULL,
  best.selection.manual.reorder = TRUE,
  bve.class = NULL,
  parallel.generation = FALSE,
  name.cohort = NULL,
  display.progress = TRUE,
  combine = FALSE,
  repeat.mating = NULL,
  repeat.mating.copy = NULL,
  repeat.mating.fixed = NULL,
  repeat.mating.overwrite = TRUE,
  time.point = 0,
  creating.type = 0,
  multiple.observation = FALSE,
  new.bv.observation = NULL,
  new.bv.observation.gen = NULL,
  new.bv.observation.cohorts = NULL,
  new.bv.observation.database = NULL,
  phenotyping = NULL,
  phenotyping.gen = NULL,
  phenotyping.cohorts = NULL,
  phenotyping.database = NULL,
  bve.gen = NULL,
  bve.cohorts = NULL,
  bve.database = NULL,
  sigma.e.gen = NULL,
  sigma.e.cohorts = NULL,
  sigma.e.database = NULL,
  sigma.g.gen = NULL,
  sigma.g.cohorts = NULL,
  sigma.g.database = NULL,
  gwas.gen = NULL,
  gwas.cohorts = NULL,
  gwas.database = NULL,
  bve.insert.gen = NULL,
  bve.insert.cohorts = NULL,
  bve.insert.database = NULL,
  reduced.selection.panel.m = NULL,
  reduced.selection.panel.f = NULL,
  breeding.all.combination = FALSE,
  depth.pedigree = 7,
  depth.pedigree.ogc = 7,
  copy.individual.keep.bve = TRUE,
  copy.individual.keep.pheno = TRUE,
  bve.avoid.duplicates = TRUE,
  report.accuracy = TRUE,
  share.genotyped = 1,
  singlestep.active = FALSE,
  remove.non.genotyped = TRUE,
  added.genotyped = 0,
  fast.uhat = TRUE,
  offspring.bve.parents.gen = NULL,
  offspring.bve.parents.database = NULL,
  offspring.bve.parents.cohorts = NULL,
  offspring.bve.offspring.gen = NULL,
  offspring.bve.offspring.database = NULL,
  offspring.bve.offspring.cohorts = NULL,
  culling.gen = NULL,
  culling.database = NULL,
  culling.cohort = NULL,
  culling.time = Inf,
  culling.name = "Not_named",
  culling.bv1 = 0,
  culling.share1 = 0,
  culling.bv2 = NULL,
  culling.share2 = NULL,
  culling.index = 0,
  culling.single = TRUE,
  culling.all.copy = TRUE,
  calculate.reliability = FALSE,
  selection.m.gen = NULL,
  selection.f.gen = NULL,
  selection.m.database = NULL,
  selection.f.database = NULL,
  selection.m.cohorts = NULL,
  selection.f.cohorts = NULL,
  selection.m.miesenberger = FALSE,
  selection.f.miesenberger = NULL,
  selection.miesenberger.reliability.est = "estimated",
  miesenberger.trafo = 0,
  multiple.bve.weights.m = 1,
  multiple.bve.weights.f = NULL,
  multiple.bve.scale.m = "bv_sd",
  multiple.bve.scale.f = NULL,
  verbose = TRUE,
  bve.parent.mean = FALSE,
  bve.grandparent.mean = FALSE,
  bve.mean.between = "bvepheno",
  bve.direct.est = TRUE,
  bve.pseudo = FALSE,
  bve.pseudo.accuracy = 1,
  miraculix.destroyA = TRUE,
  mas.bve = FALSE,
  mas.markers = NULL,
  mas.number = 5,
  mas.effects = NULL,
  threshold.selection = NULL,
  threshold.sign = "&gt;",
  input.phenotype = "own",
  bve.ignore.traits = NULL,
  bv.ignore.traits = NULL,
  genotyped.database = NULL,
  genotyped.gen = NULL,
  genotyped.cohorts = NULL,
  genotyped.share = 1,
  genotyped.array = 1,
  sex.s = NULL,
  bve.imputation = TRUE,
  bve.imputation.errorrate = 0,
  share.phenotyped = 1,
  avoid.mating.fullsib = FALSE,
  avoid.mating.halfsib = FALSE,
  max.mating.pair = Inf,
  bve.per.sample.sigma.e = TRUE,
  bve.solve = "exact"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breeding.diploid_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_mutation.rate">mutation.rate</code></td>
<td>
<p>Mutation rate in each marker (default: 10^-8)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_remutation.rate">remutation.rate</code></td>
<td>
<p>Remutation rate in each marker (default: 10^-8)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_recombination.rate">recombination.rate</code></td>
<td>
<p>Average number of recombination per 1 length unit (default: 1M)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.m">selection.m</code></td>
<td>
<p>Selection criteria for male individuals (Set to &quot;random&quot; to randomly select individuals - this happens automatically when no the input in selection.criteria has no input ((usually breeding values)))</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.f">selection.f</code></td>
<td>
<p>Selection criteria for female individuals (default: selection.m , alt: &quot;random&quot;, function&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_new.selection.calculation">new.selection.calculation</code></td>
<td>
<p>If TRUE recalculate breeding values obtained by selection.function.matrix</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.function.matrix">selection.function.matrix</code></td>
<td>
<p>Manuel generation of a temporary selection function (Use BVs instead!)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.size">selection.size</code></td>
<td>
<p>Number of selected individuals for breeding (default: c(0,0) - alt: positive numbers)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ignore.best">ignore.best</code></td>
<td>
<p>Not consider the top individuals of the selected individuals (e.g. to use 2-10 best individuals)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_breeding.size">breeding.size</code></td>
<td>
<p>Number of individuals to generate</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_breeding.sex">breeding.sex</code></td>
<td>
<p>Share of female animals (if single value is used for breeding size; default: 0.5)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_breeding.sex.random">breeding.sex.random</code></td>
<td>
<p>If TRUE randomly chose sex of new individuals (default: FALSE - use expected values)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_relative.selection">relative.selection</code></td>
<td>
<p>Use best.selection.ratio instead!</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_class.m">class.m</code></td>
<td>
<p>Migrationlevels of male individuals to consider for mating process (default: 0)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_class.f">class.f</code></td>
<td>
<p>Migrationlevels of female individuals to consider for mating process (default: 0)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_add.gen">add.gen</code></td>
<td>
<p>Generation you want to add the new individuals to (default: New generation)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_recom.f.indicator">recom.f.indicator</code></td>
<td>
<p>Use step function for recombination map (transform snp.positions if possible instead)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_duplication.rate">duplication.rate</code></td>
<td>
<p>Share of recombination points with a duplication (default: 0 - DEACTIVATED)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_duplication.length">duplication.length</code></td>
<td>
<p>Average length of a duplication (Exponentially distributed)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_duplication.recombination">duplication.recombination</code></td>
<td>
<p>Average number of recombinations per 1 length uit of duplication (default: 1)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_new.class">new.class</code></td>
<td>
<p>Migration level of newly generated individuals (default: 0)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve">bve</code></td>
<td>
<p>If TRUE perform a breeding value estimation (default: FALSE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sigma.e">sigma.e</code></td>
<td>
<p>Enviromental variance (default: 100)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sigma.g">sigma.g</code></td>
<td>
<p>Genetic variance (default: 100 - only used if not computed via estimate.sigma.g^2 in der Zuchtwertschaetzung (Default: 100)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_new.bv.child">new.bv.child</code></td>
<td>
<p>(OLD! - use phenotyping.child) Starting phenotypes of newly generated individuals (default: &quot;mean&quot; of both parents, &quot;obs&quot; - regular observation, &quot;zero&quot; - 0)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_phenotyping.child">phenotyping.child</code></td>
<td>
<p>Starting phenotypes of newly generated individuals (default: &quot;mean&quot; of both parents, &quot;obs&quot; - regular observation, &quot;zero&quot; - 0)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_relationship.matrix">relationship.matrix</code></td>
<td>
<p>Method to calculate relationship matrix for the breeding value estimation (Default: &quot;vanRaden&quot;, alt: &quot;kinship&quot;, &quot;CE&quot;, &quot;non_stand&quot;, &quot;CE2&quot;, &quot;CM&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_relationship.matrix.ogc">relationship.matrix.ogc</code></td>
<td>
<p>Method to calculate relationship matrix for OGC (Default: &quot;kinship&quot;, alt: &quot;vanRaden&quot;, &quot;CE&quot;, &quot;non_stand&quot;, &quot;CE2&quot;, &quot;CM&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_computation.a">computation.A</code></td>
<td>
<p>(OLD! - use relationship.matrix) Method to calculate relationship matrix for the breeding value estimation (Default: &quot;vanRaden&quot;, alt: &quot;kinship&quot;, &quot;CE&quot;, &quot;non_stand&quot;, &quot;CE2&quot;, &quot;CM&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_computation.a.ogc">computation.A.ogc</code></td>
<td>
<p>(OLD! use relationship.matrix.ogc) Method to calculate pedigree matrix in OGC (Default: &quot;kinship&quot;, alt: &quot;vanRaden&quot;, &quot;CE&quot;, &quot;non_stand&quot;, &quot;CE2&quot;, &quot;CM&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_delete.haplotypes">delete.haplotypes</code></td>
<td>
<p>Generations for with haplotypes of founders can be deleted (only use if storage problem!)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_delete.individuals">delete.individuals</code></td>
<td>
<p>Generations for with individuals are completley deleted (only use if storage problem!)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_fixed.breeding">fixed.breeding</code></td>
<td>
<p>Set of targeted matings to perform</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_fixed.breeding.best">fixed.breeding.best</code></td>
<td>
<p>Perform targeted matings in the group of selected individuals</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_max.offspring">max.offspring</code></td>
<td>
<p>Maximum number of offspring per individual (default: c(Inf,Inf) - (m,w))</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_max.litter">max.litter</code></td>
<td>
<p>Maximum number of offspring per individual (default: c(Inf,Inf) - (m,w))</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_store.breeding.totals">store.breeding.totals</code></td>
<td>
<p>If TRUE store information on selected animals in $info$breeding.totals</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_forecast.sigma.g">forecast.sigma.g</code></td>
<td>
<p>Set FALSE to not estimate sigma.g (Default: TRUE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_multiple.bve">multiple.bve</code></td>
<td>
<p>Way to handle multiple traits in bv/selection (default: &quot;add&quot;, alt: &quot;ranking&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_store.bve.data">store.bve.data</code></td>
<td>
<p>If TRUE store information of bve in $info$bve.data</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_fixed.assignment">fixed.assignment</code></td>
<td>
<p>Set TRUE for targeted mating of best-best individual till worst-worst (of selected). set to &quot;bestworst&quot; for best-worst mating</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_reduce.group">reduce.group</code></td>
<td>
<p>(OLD! - use culling modules) Groups of animals for reduce to a new size (by changing class to -1)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_reduce.group.selection">reduce.group.selection</code></td>
<td>
<p>(OLD! - use culling modules) Selection criteria for reduction of groups (cf. selection.m / selection.f - default: &quot;random&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.highest">selection.highest</code></td>
<td>
<p>If 0 individuals with lowest bve are selected as best individuals (default c(1,1) - (m,w))</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.criteria">selection.criteria</code></td>
<td>
<p>What to use in the selection proces (default: &quot;bve&quot;, alt: &quot;bv&quot;, &quot;pheno&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_same.sex.activ">same.sex.activ</code></td>
<td>
<p>If TRUE allow matings of individuals of same sex</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_same.sex.sex">same.sex.sex</code></td>
<td>
<p>Probability to use female individuals as parents (default: 0.5)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_same.sex.selfing">same.sex.selfing</code></td>
<td>
<p>Set to TRUE to allow for selfing when using same.sex matings</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selfing.mating">selfing.mating</code></td>
<td>
<p>If TRUE generate new individuals via selfing</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selfing.sex">selfing.sex</code></td>
<td>
<p>Share of female individuals used for selfing (default: 0.5)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_praeimplantation">praeimplantation</code></td>
<td>
<p>Only use matings the lead to a specific genotype in a specific marker</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_heritability">heritability</code></td>
<td>
<p>Use sigma.e to obtain a certain heritability (default: NULL)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_repeatability">repeatability</code></td>
<td>
<p>Set this to control the share of the residual variance (sigma.e) that is permanent (there for each observation)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_save.recombination.history">save.recombination.history</code></td>
<td>
<p>If TRUE store the time point of each recombination event</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_martini.selection">martini.selection</code></td>
<td>
<p>If TRUE use the group of non-selected individuals as second parent</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bglr.bve">BGLR.bve</code></td>
<td>
<p>If TRUE use BGLR to perform breeding value estimation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bglr.model">BGLR.model</code></td>
<td>
<p>Select which BGLR model to use (default: &quot;RKHS&quot;, alt: &quot;BRR&quot;, &quot;BL&quot;, &quot;BayesA&quot;, &quot;BayesB&quot;, &quot;BayesC&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bglr.burnin">BGLR.burnin</code></td>
<td>
<p>Number of burn-in steps in BGLR (default: 1000)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bglr.iteration">BGLR.iteration</code></td>
<td>
<p>Number of iterations in BGLR (default: 5000)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bglr.print">BGLR.print</code></td>
<td>
<p>If TRUE set verbose to TRUE in BGLR</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_copy.individual">copy.individual</code></td>
<td>
<p>If TRUE copy the selected father for a mating</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_copy.individual.m">copy.individual.m</code></td>
<td>
<p>If TRUE generate exactly one copy of all selected male in a new cohort (or more by setting breeding.size)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_copy.individual.f">copy.individual.f</code></td>
<td>
<p>If TRUE generate exactly one copy of all selected female in a new cohort (or more by setting breeding.size)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_dh.mating">dh.mating</code></td>
<td>
<p>If TRUE generate a DH-line in mating process</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_dh.sex">dh.sex</code></td>
<td>
<p>Share of DH-lines generated from selected female individuals</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_n.observation">n.observation</code></td>
<td>
<p>Number of phenotypes generated per individuals (influences enviromental variance)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.0isna">bve.0isNA</code></td>
<td>
<p>Individuals with phenotype 0 are used as NA in breeding value estimation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_phenotype.bv">phenotype.bv</code></td>
<td>
<p>If TRUE use phenotype as estimated breeding value</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_delete.same.origin">delete.same.origin</code></td>
<td>
<p>If TRUE delete recombination points when genetic origin of adjacent segments is the same</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_remove.effect.position">remove.effect.position</code></td>
<td>
<p>If TRUE remove real QTLs in breeding value estimation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_estimate.u">estimate.u</code></td>
<td>
<p>If TRUE estimate u in breeding value estimation (Y = Xb + Zu + e)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_new.phenotype.correlation">new.phenotype.correlation</code></td>
<td>
<p>(OLD! - use new.residual.correlation!) Correlation of the simulated enviromental variance</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_new.residual.correlation">new.residual.correlation</code></td>
<td>
<p>Correlation of the simulated enviromental variance</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_new.breeding.correlation">new.breeding.correlation</code></td>
<td>
<p>Correlation of the simulated genetic variance (child share! heritage is not influenced!)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_estimate.add.gen.var">estimate.add.gen.var</code></td>
<td>
<p>If TRUE estimate additive genetic variance and heritability based on parent model</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_estimate.pheno.var">estimate.pheno.var</code></td>
<td>
<p>If TRUE estimate total variance in breeding value estimation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_best1.from.group">best1.from.group</code></td>
<td>
<p>(OLD!- use selection.m.database) Groups of individuals to consider as First Parent / Father (also female individuals are possible)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_best2.from.group">best2.from.group</code></td>
<td>
<p>(OLD!- use selection.f.database) Groups of individuals to consider as Second Parent / Mother (also male individuals are possible)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_best1.from.cohort">best1.from.cohort</code></td>
<td>
<p>(OLD!- use selection.m.cohorts) Groups of individuals to consider as First Parent / Father (also female individuals are possible)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_best2.from.cohort">best2.from.cohort</code></td>
<td>
<p>(OLD! - use selection.f.cohorts) Groups of individuals to consider as Second Parent / Mother (also male individuals are possible)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_add.class.cohorts">add.class.cohorts</code></td>
<td>
<p>Migration levels of all cohorts selected for reproduction are automatically added to class.m/class.f (default: TRUE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_store.comp.times">store.comp.times</code></td>
<td>
<p>If TRUE store computation times in $info$comp.times (default: TRUE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_store.comp.times.bve">store.comp.times.bve</code></td>
<td>
<p>If TRUE store computation times of breeding value estimation in $info$comp.times.bve (default: TRUE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_store.comp.times.generation">store.comp.times.generation</code></td>
<td>
<p>If TRUE store computation times of mating simulations in $info$comp.times.generation (default: TRUE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_import.position.calculation">import.position.calculation</code></td>
<td>
<p>Function to calculate recombination point into adjacent/following SNP</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bglr.save">BGLR.save</code></td>
<td>
<p>Method to use in BGLR (default: &quot;RKHS&quot; - alt: NON currently)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bglr.save.random">BGLR.save.random</code></td>
<td>
<p>Add random number to store location of internal BGLR computations (only needed when simulating a lot in parallel!)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ogc">ogc</code></td>
<td>
<p>If TRUE use optimal genetic contribution theory to perform selection ( This requires the use of the R-package optiSel)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ogc.target">ogc.target</code></td>
<td>
<p>Target of OGC (default: &quot;min.sKin&quot; - minimize inbreeding; alt: &quot;max.BV&quot; / &quot;min.BV&quot; - maximize genetic gain; both under constrains selected below)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ogc.uniform">ogc.uniform</code></td>
<td>
<p>This corresponds to the uniform constrain in optiSel</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ogc.ub">ogc.ub</code></td>
<td>
<p>This corresponds to the ub constrain in optiSel</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ogc.lb">ogc.lb</code></td>
<td>
<p>This corresponds to the lb constrain in optiSel</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ogc.ub.skin">ogc.ub.sKin</code></td>
<td>
<p>This corresponds to the ub.sKin constrain in optiSel</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ogc.lb.bv">ogc.lb.BV</code></td>
<td>
<p>This corresponds to the lb.BV constrain in optiSel</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ogc.ub.bv">ogc.ub.BV</code></td>
<td>
<p>This corresponds to the ub.BV constrain in optiSel</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ogc.eq.bv">ogc.eq.BV</code></td>
<td>
<p>This corresponds to the eq.BV constrain in optiSel</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ogc.ub.skin.increase">ogc.ub.sKin.increase</code></td>
<td>
<p>This corresponds to the upper bound (current sKin + ogc.ub.sKin.increase) as ub.sKin in optiSel</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ogc.lb.bv.increase">ogc.lb.BV.increase</code></td>
<td>
<p>This corresponds to the lower bound (current BV + ogc.lb.BV.increase) as lb.BV in optiSel</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_emmreml.bve">emmreml.bve</code></td>
<td>
<p>If TRUE use REML estimator from R-package EMMREML in breeding value estimation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_rrblup.bve">rrblup.bve</code></td>
<td>
<p>If TRUE use REML estimator from R-package rrBLUP in breeding value estimation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sommer.bve">sommer.bve</code></td>
<td>
<p>If TRUE use REML estimator from R-package sommer in breeding value estimation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sommer.multi.bve">sommer.multi.bve</code></td>
<td>
<p>Set TRUE to use a mulit-trait model in the R-package sommer for BVE</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_nr.edits">nr.edits</code></td>
<td>
<p>Number of edits to perform per individual</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_gene.editing.offspring">gene.editing.offspring</code></td>
<td>
<p>If TRUE perform gene editing on newly generated individuals</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_gene.editing.best">gene.editing.best</code></td>
<td>
<p>If TRUE perform gene editing on selected individuals</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_gene.editing.offspring.sex">gene.editing.offspring.sex</code></td>
<td>
<p>Which sex to perform editing on (Default c(TRUE,TRUE), mw)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_gene.editing.best.sex">gene.editing.best.sex</code></td>
<td>
<p>Which sex to perform editing on (Default c(TRUE,TRUE), mw)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_gwas.u">gwas.u</code></td>
<td>
<p>If TRUE estimate u via GWAS (relevant for gene editing)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_approx.residuals">approx.residuals</code></td>
<td>
<p>If FALSE calculate the variance for each marker separatly instead of using a set variance (doesnt change order - only p-values)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sequencez">sequenceZ</code></td>
<td>
<p>Split genomic matric into parts (relevent if high memory usage)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_maxz">maxZ</code></td>
<td>
<p>Number of SNPs to consider in each part of sequenceZ</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_maxztotal">maxZtotal</code></td>
<td>
<p>Number of matrix entries to consider jointly (maxZ = maxZtotal/number of animals)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_delete.sex">delete.sex</code></td>
<td>
<p>Remove all individuals from these sex from generation delete.individuals (default: 1:2 ; note:delete individuals=NULL)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_gwas.group.standard">gwas.group.standard</code></td>
<td>
<p>If TRUE standardize phenotypes by group mean</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_y.gwas.used">y.gwas.used</code></td>
<td>
<p>What y value to use in GWAS study (Default: &quot;pheno&quot;, alt: &quot;bv&quot;, &quot;bve&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_gen.architecture.m">gen.architecture.m</code></td>
<td>
<p>Genetic architecture for male animal (default: 0 - no transformation)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_gen.architecture.f">gen.architecture.f</code></td>
<td>
<p>Genetic architecture for female animal (default: gen.architecture.m - no transformation)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_add.architecture">add.architecture</code></td>
<td>
<p>List with two vectors containing (A: length of chromosomes, B: position in cM of SNPs)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ncore">ncore</code></td>
<td>
<p>Cores used for parallel computing in compute.snps</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_ncore.generation">ncore.generation</code></td>
<td>
<p>Number of cores to use in parallel generation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_z.integer">Z.integer</code></td>
<td>
<p>If TRUE save Z as a integer in parallel computing</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_store.effect.freq">store.effect.freq</code></td>
<td>
<p>If TRUE store the allele frequency of effect markers per generation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_backend">backend</code></td>
<td>
<p>Chose the used backend (default: &quot;doParallel&quot;, alt: &quot;doMPI&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_randomseed">randomSeed</code></td>
<td>
<p>Set random seed of the process</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_randomseed.generation">randomSeed.generation</code></td>
<td>
<p>Set random seed for parallel generation process</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_rprof">Rprof</code></td>
<td>
<p>Store computation times of each function</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_miraculix">miraculix</code></td>
<td>
<p>If TRUE use miraculix to perform computations (ideally already generate population in creating.diploid with this; default: automatic detection from population list)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_miraculix.cores">miraculix.cores</code></td>
<td>
<p>Number of cores used in miraculix applications (default: 1)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_miraculix.mult">miraculix.mult</code></td>
<td>
<p>If TRUE use miraculix for matrix multiplications even if miraculix is not used for storage</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_miraculix.chol">miraculix.chol</code></td>
<td>
<p>Set to FALSE to deactive miraculix based Cholesky-decomposition (default: TRUE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_best.selection.ratio.m">best.selection.ratio.m</code></td>
<td>
<p>Ratio of the frequency of the selection of the best best animal and the worst best animal (default=1)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_best.selection.ratio.f">best.selection.ratio.f</code></td>
<td>
<p>Ratio of the frequency of the selection of the best best animal and the worst best animal (default=1)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_best.selection.criteria.m">best.selection.criteria.m</code></td>
<td>
<p>Criteria to calculate this ratio (default: &quot;bv&quot;, alt: &quot;bve&quot;, &quot;pheno&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_best.selection.criteria.f">best.selection.criteria.f</code></td>
<td>
<p>Criteria to calculate this ratio (default: &quot;bv&quot;, alt: &quot;bve&quot;, &quot;pheno&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_best.selection.manual.ratio.m">best.selection.manual.ratio.m</code></td>
<td>
<p>vector containing probability to draw from for every individual (e.g. c(0.1,0.2,0.7))</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_best.selection.manual.ratio.f">best.selection.manual.ratio.f</code></td>
<td>
<p>vector containing probability to draw from for every individual (e.g. c(0.1,0.2,0.7))</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_best.selection.manual.reorder">best.selection.manual.reorder</code></td>
<td>
<p>Set to FALSE to not use the order from best to worst selected individual but plain order based on database-order</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.class">bve.class</code></td>
<td>
<p>Consider only animals of those class classes in breeding value estimation (default: NULL - use all)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_parallel.generation">parallel.generation</code></td>
<td>
<p>Set TRUE to active parallel computing in animal generation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_name.cohort">name.cohort</code></td>
<td>
<p>Name of the newly added cohort</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_display.progress">display.progress</code></td>
<td>
<p>Set FALSE to not display progress bars. Setting verbose to FALSE will automatically deactive progress bars</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_combine">combine</code></td>
<td>
<p>Copy existing individuals (e.g. to merge individuals from different groups in a joined cohort). Individuals to use are used as the first parent</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_repeat.mating">repeat.mating</code></td>
<td>
<p>Generate multiple mating from the same dam/sire combination (first column: number of offspring; second column: probability)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_repeat.mating.copy">repeat.mating.copy</code></td>
<td>
<p>Generate multiple copies from a copy action (combine / copy.individuals.m/f) (first column: number of offspring; second column: probability)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_repeat.mating.fixed">repeat.mating.fixed</code></td>
<td>
<p>Vector containing number of times each mating is repeated. This will overwrite sampling from repeat.mating / repeat.mating.copy (default: NULL)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_repeat.mating.overwrite">repeat.mating.overwrite</code></td>
<td>
<p>Set to FALSE to not use the current repeat.mating / repeat.mating.copy input as the new standard values (default: TRUE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_time.point">time.point</code></td>
<td>
<p>Time point at which the new individuals are generated</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_creating.type">creating.type</code></td>
<td>
<p>Technique to generate new individuals (usage in web-based application)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_multiple.observation">multiple.observation</code></td>
<td>
<p>Set TRUE to allow for more than one phenotype observation per individual (this will decrease enviromental variance!)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_new.bv.observation">new.bv.observation</code></td>
<td>
<p>(OLD! - use phenotyping) Quick acces to phenotyping for (all: &quot;all&quot;, non-phenotyped: &quot;non_obs&quot;, non-phenotyped male: &quot;non_obs_m&quot;, non-phenotyped female: &quot;non_obs_f&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_new.bv.observation.gen">new.bv.observation.gen</code></td>
<td>
<p>(OLD! use phenotyping.gen) Vector of generation from which to generate additional phenotypes</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_new.bv.observation.cohorts">new.bv.observation.cohorts</code></td>
<td>
<p>(OLD! use phenotyping.cohorts)Vector of cohorts from which to generate additional phenotype</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_new.bv.observation.database">new.bv.observation.database</code></td>
<td>
<p>(OLD! use phenotyping.database) Matrix of groups from which to generate additional phenotypes</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_phenotyping">phenotyping</code></td>
<td>
<p>Quick acces to phenotyping for (all: &quot;all&quot;, non-phenotyped: &quot;non_obs&quot;, non-phenotyped male: &quot;non_obs_m&quot;, non-phenotyped female: &quot;non_obs_f&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_phenotyping.gen">phenotyping.gen</code></td>
<td>
<p>Vector of generation from which to generate additional phenotypes</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_phenotyping.cohorts">phenotyping.cohorts</code></td>
<td>
<p>Vector of cohorts from which to generate additional phenotype</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_phenotyping.database">phenotyping.database</code></td>
<td>
<p>Matrix of groups from which to generate additional phenotypes</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.gen">bve.gen</code></td>
<td>
<p>Generations of individuals to consider in breeding value estimation (default: NULL)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.cohorts">bve.cohorts</code></td>
<td>
<p>Cohorts of individuals to consider in breeding value estimation (default: NULL)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.database">bve.database</code></td>
<td>
<p>Groups of individuals to consider in breeding value estimation (default: NULL)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sigma.e.gen">sigma.e.gen</code></td>
<td>
<p>Generations to consider when estimating sigma.e when using hertability</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sigma.e.cohorts">sigma.e.cohorts</code></td>
<td>
<p>Cohorts to consider when estimating sigma.e when using hertability</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sigma.e.database">sigma.e.database</code></td>
<td>
<p>Groups to consider when estimating sigma.e when using hertability</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sigma.g.gen">sigma.g.gen</code></td>
<td>
<p>Generations to consider when estimating sigma.g</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sigma.g.cohorts">sigma.g.cohorts</code></td>
<td>
<p>Cohorts to consider when estimating sigma.g</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sigma.g.database">sigma.g.database</code></td>
<td>
<p>Groups to consider when estimating sigma.g</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_gwas.gen">gwas.gen</code></td>
<td>
<p>Generations to consider in GWAS analysis</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_gwas.cohorts">gwas.cohorts</code></td>
<td>
<p>Cohorts to consider in GWAS analysis</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_gwas.database">gwas.database</code></td>
<td>
<p>Groups to consider in GWAS analysis</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.insert.gen">bve.insert.gen</code></td>
<td>
<p>Generations of individuals to compute breeding values for (default: all groups in bve.database)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.insert.cohorts">bve.insert.cohorts</code></td>
<td>
<p>Cohorts of individuals to compute breeding values for (default: all groups in bve.database)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.insert.database">bve.insert.database</code></td>
<td>
<p>Groups of individuals to compute breeding values for (default: all groups in bve.database)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_reduced.selection.panel.m">reduced.selection.panel.m</code></td>
<td>
<p>Use only a subset of individuals of the potential selected ones (&quot;Split in user-interface&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_reduced.selection.panel.f">reduced.selection.panel.f</code></td>
<td>
<p>Use only a subset of individuals of the potential selected ones (&quot;Split in user-interface&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_breeding.all.combination">breeding.all.combination</code></td>
<td>
<p>Set to TRUE to automatically perform each mating combination possible exactly ones.</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_depth.pedigree">depth.pedigree</code></td>
<td>
<p>Depth of the pedigree in generations (default: 7)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_depth.pedigree.ogc">depth.pedigree.ogc</code></td>
<td>
<p>Depth of the pedigree in generations (default: 7)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_copy.individual.keep.bve">copy.individual.keep.bve</code></td>
<td>
<p>Set to FALSE to not keep estimated breeding value in case of use of copy.individuals</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_copy.individual.keep.pheno">copy.individual.keep.pheno</code></td>
<td>
<p>Set to FALSE to not keep estimated breeding values in case of use of copy.individuals</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.avoid.duplicates">bve.avoid.duplicates</code></td>
<td>
<p>If set to FALSE multiple generatations of the same individual can be used in the bve (only possible by using copy.individual to generate individuals)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_report.accuracy">report.accuracy</code></td>
<td>
<p>Report the accuracy of the breeding value estimation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_share.genotyped">share.genotyped</code></td>
<td>
<p>Share of individuals newly generated individuals that are genotyped</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_singlestep.active">singlestep.active</code></td>
<td>
<p>Set TRUE to use single step in breeding value estimation (only implemented for vanRaden- G matrix and without use sequenceZ) (Legarra 2014)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_remove.non.genotyped">remove.non.genotyped</code></td>
<td>
<p>Set to FALSE to manually include non-genotyped individuals in genetic BVE, single-step will deactive this as well</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_added.genotyped">added.genotyped</code></td>
<td>
<p>Share of individuals that is additionally genotyped (only for copy.individuals)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_fast.uhat">fast.uhat</code></td>
<td>
<p>Set to FALSE to  derive inverse of A in rrBLUP</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_offspring.bve.parents.gen">offspring.bve.parents.gen</code></td>
<td>
<p>Generations to consider to derive phenotype from offspring phenotypes</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_offspring.bve.parents.database">offspring.bve.parents.database</code></td>
<td>
<p>Groups to consider to derive phenotype from offspring phenotypes</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_offspring.bve.parents.cohorts">offspring.bve.parents.cohorts</code></td>
<td>
<p>Cohorts to consider to derive phenotype from offspring phenotypes</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_offspring.bve.offspring.gen">offspring.bve.offspring.gen</code></td>
<td>
<p>Active generations for import of offspring phenotypes</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_offspring.bve.offspring.database">offspring.bve.offspring.database</code></td>
<td>
<p>Active groups for import of offspring phenotypes</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_offspring.bve.offspring.cohorts">offspring.bve.offspring.cohorts</code></td>
<td>
<p>Active cohorts for import of offspring phenotypes</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.gen">culling.gen</code></td>
<td>
<p>Generations to consider to culling</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.database">culling.database</code></td>
<td>
<p>Groups to consider to culling</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.cohort">culling.cohort</code></td>
<td>
<p>Cohort to consider to culling</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.time">culling.time</code></td>
<td>
<p>Age of the individuals at culling</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.name">culling.name</code></td>
<td>
<p>Name of the culling action (user-interface stuff)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.bv1">culling.bv1</code></td>
<td>
<p>Reference Breeding value</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.share1">culling.share1</code></td>
<td>
<p>Probability of death for individuals with bv1</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.bv2">culling.bv2</code></td>
<td>
<p>Alternative breeding value (linear extended for other bvs)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.share2">culling.share2</code></td>
<td>
<p>Probability of death for individuals with bv2</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.index">culling.index</code></td>
<td>
<p>Genomic index (default:0 - no genomic impact, use: &quot;lastindex&quot; to use the last selection index applied in selection)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.single">culling.single</code></td>
<td>
<p>Set to FALSE to not apply the culling module on all individuals of the cohort</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_culling.all.copy">culling.all.copy</code></td>
<td>
<p>Set to FALSE to not kill copies of the same individual in the culling module</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_calculate.reliability">calculate.reliability</code></td>
<td>
<p>Set TRUE to calculate a reliability when performing Direct-Mixed-Model BVE</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.m.gen">selection.m.gen</code></td>
<td>
<p>Generations available for selection of paternal parent</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.f.gen">selection.f.gen</code></td>
<td>
<p>Generations available for selection of maternal parent</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.m.database">selection.m.database</code></td>
<td>
<p>Groups available for selection of paternal parent</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.f.database">selection.f.database</code></td>
<td>
<p>Groups available for selection of maternal parent</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.m.cohorts">selection.m.cohorts</code></td>
<td>
<p>Cohorts available for selection of paternal parent</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.f.cohorts">selection.f.cohorts</code></td>
<td>
<p>Cohorts available for selection of maternal parent</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.m.miesenberger">selection.m.miesenberger</code></td>
<td>
<p>Use Weighted selection index according to Miesenberger 1997 for paternal selection</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.f.miesenberger">selection.f.miesenberger</code></td>
<td>
<p>Use Weighted selection index according to Miesenberger 1997 for maternal selection</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_selection.miesenberger.reliability.est">selection.miesenberger.reliability.est</code></td>
<td>
<p>If available reliability estimated are used. If not use default:&quot;estimated&quot; (SD BVE / SD Pheno), alt: &quot;heritability&quot;, &quot;derived&quot; (cor(BVE,BV)^2) as replacement</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_miesenberger.trafo">miesenberger.trafo</code></td>
<td>
<p>Ignore all eigenvalues below this threshold and apply dimension reduction (default: 0 - use all)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_multiple.bve.weights.m">multiple.bve.weights.m</code></td>
<td>
<p>Weighting between traits when using &quot;add&quot; (default: 1)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_multiple.bve.weights.f">multiple.bve.weights.f</code></td>
<td>
<p>Weighting between traits when using &quot;add&quot; (default: same as multiple.bve.weights.m)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_multiple.bve.scale.m">multiple.bve.scale.m</code></td>
<td>
<p>Default: &quot;bv_sd&quot;; Set to &quot;pheno_sd&quot; when using gains per phenotypic SD, &quot;unit&quot; when using gains per unit, &quot;bve&quot; when using estimated breeding values</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_multiple.bve.scale.f">multiple.bve.scale.f</code></td>
<td>
<p>Default: &quot;bv_sd&quot;; Set to &quot;pheno_sd&quot; when using gains per phenotypic SD, &quot;unit&quot; when using gains per unit, &quot;bve&quot; when using estimated breeding values</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.parent.mean">bve.parent.mean</code></td>
<td>
<p>Set to TRUE to use the average parental performance as the breeding value estimate</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.grandparent.mean">bve.grandparent.mean</code></td>
<td>
<p>Set to TRUE to use the average grandparental performance as the breeding value estimate</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.mean.between">bve.mean.between</code></td>
<td>
<p>Select if you want to use the &quot;bve&quot;, &quot;bv&quot;, &quot;pheno&quot; or &quot;bvepheno&quot; to form the mean (default: &quot;bvepheno&quot; - if available bve, else pheno)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.direct.est">bve.direct.est</code></td>
<td>
<p>If TRUE predict BVEs in direct estimation according to vanRaden 2008 method 2 (default: TRUE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.pseudo">bve.pseudo</code></td>
<td>
<p>If set to TRUE the breeding value estimation will be simulated with resulting accuracy bve.pseudo.accuracy (default: 1)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.pseudo.accuracy">bve.pseudo.accuracy</code></td>
<td>
<p>The accuracy to be obtained in the &quot;pseudo&quot; - breeding value estimation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_miraculix.destroya">miraculix.destroyA</code></td>
<td>
<p>If FALSE A will not be destroyed in the process of inversion (less computing / more memory)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_mas.bve">mas.bve</code></td>
<td>
<p>If TRUE use marker assisted selection in the breeding value estimation</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_mas.markers">mas.markers</code></td>
<td>
<p>Vector containing markers to be used in marker assisted selection</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_mas.number">mas.number</code></td>
<td>
<p>If no markers are provided this nr of markers is selected (if single marker QTL are present highest effect markers are prioritized)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_mas.effects">mas.effects</code></td>
<td>
<p>Effects assigned to the MAS markers (Default: estimated via lm())</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_threshold.selection">threshold.selection</code></td>
<td>
<p>Minimum value in the selection index selected individuals have to have</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_threshold.sign">threshold.sign</code></td>
<td>
<p>Pick all individuals above (&quot;&gt;&quot;) the threshold. Alt: (&quot;&lt;&quot;, &quot;=&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_input.phenotype">input.phenotype</code></td>
<td>
<p>Select what to use in BVE (default: own phenotype (&quot;own&quot;), offspring phenotype (&quot;off&quot;), their average (&quot;mean&quot;) or a weighted average (&quot;weighted&quot;))</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.ignore.traits">bve.ignore.traits</code></td>
<td>
<p>Vector of traits to ignore in the breeding value estimation (default: NULL, use: &quot;zero&quot; to not consider traits with 0 index weight in multiple.bve.weights.m/.w)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bv.ignore.traits">bv.ignore.traits</code></td>
<td>
<p>Vector of traits to ignore in the calculation of the genomic value (default: NULL; Only recommended for high number of traits and experienced users!)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_genotyped.database">genotyped.database</code></td>
<td>
<p>Groups to generate genotype data (that can be used in a BVE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_genotyped.gen">genotyped.gen</code></td>
<td>
<p>Generations to generate genotype data (that can be used in a BVE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_genotyped.cohorts">genotyped.cohorts</code></td>
<td>
<p>Cohorts to generate genotype data (that can be used in a BVE)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_genotyped.share">genotyped.share</code></td>
<td>
<p>Share of individuals in genotyped.gen/database/cohort to generate genotype data from (default: 1)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_genotyped.array">genotyped.array</code></td>
<td>
<p>Genotyping array used</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_sex.s">sex.s</code></td>
<td>
<p>Specify which newly added individuals are male (1) or female (2)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.imputation">bve.imputation</code></td>
<td>
<p>Set to FALSE to not perform imputation up to the highest marker density of genotyping data that is available</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.imputation.errorrate">bve.imputation.errorrate</code></td>
<td>
<p>Share of errors in the imputation procedure (default: 0)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_share.phenotyped">share.phenotyped</code></td>
<td>
<p>Share of the individuals to phenotype</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_avoid.mating.fullsib">avoid.mating.fullsib</code></td>
<td>
<p>Set to TRUE to not generate offspring of full siblings</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_avoid.mating.halfsib">avoid.mating.halfsib</code></td>
<td>
<p>Set to TRUE to not generate offspring from half or full siblings</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_max.mating.pair">max.mating.pair</code></td>
<td>
<p>Set to the maximum number of matings between two individuals (default: Inf)</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.per.sample.sigma.e">bve.per.sample.sigma.e</code></td>
<td>
<p>Set to FALSE to deactivate the use of a heritablity based on the number of observations generated per sample</p>
</td></tr>
<tr><td><code id="breeding.diploid_+3A_bve.solve">bve.solve</code></td>
<td>
<p>Provide solver to be used in BVE (default: &quot;exact&quot; solution via inversion, alt: &quot;pcg&quot;, function with inputs A, b and output y_hat)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>population &lt;- creating.diploid(nsnp=1000, nindi=100)
population &lt;- breeding.diploid(population, breeding.size=100, selection.size=c(25,25))
</code></pre>

<hr>
<h2 id='breeding.intern'>Internal function to simulate one meiosis</h2><span id='topic+breeding.intern'></span>

<h3>Description</h3>

<p>Internal function to simulate one meiosis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breeding.intern(
  info.parent,
  parent,
  population,
  mutation.rate = 10^-5,
  remutation.rate = 10^-5,
  recombination.rate = 1,
  recom.f.indicator = NULL,
  duplication.rate = 0,
  duplication.length = 0.01,
  duplication.recombination = 1,
  delete.same.origin = FALSE,
  gene.editing = FALSE,
  nr.edits = 0,
  gen.architecture = 0,
  decodeOriginsU = MoBPS::decodeOriginsR
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breeding.intern_+3A_info.parent">info.parent</code></td>
<td>
<p>position of the parent in the dataset</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_parent">parent</code></td>
<td>
<p>list of information regarding the parent</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_mutation.rate">mutation.rate</code></td>
<td>
<p>Mutation rate in each marker (default: 10^-5)</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_remutation.rate">remutation.rate</code></td>
<td>
<p>Remutation rate in each marker (default: 10^-5)</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_recombination.rate">recombination.rate</code></td>
<td>
<p>Average number of recombination per 1 length unit (default: 1M)</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_recom.f.indicator">recom.f.indicator</code></td>
<td>
<p>Use step function for recombination map (transform snp.positions if possible instead)</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_duplication.rate">duplication.rate</code></td>
<td>
<p>Share of recombination points with a duplication (default: 0 - DEACTIVATED)</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_duplication.length">duplication.length</code></td>
<td>
<p>Average length of a duplication (Exponentially distributed)</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_duplication.recombination">duplication.recombination</code></td>
<td>
<p>Average number of recombinations per 1 length uit of duplication (default: 1)</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_delete.same.origin">delete.same.origin</code></td>
<td>
<p>If TRUE delete recombination points when genetic origin of adjacent segments is the same</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_gene.editing">gene.editing</code></td>
<td>
<p>If TRUE perform gene editing on newly generated individual</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_nr.edits">nr.edits</code></td>
<td>
<p>Number of edits to perform per individual</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_gen.architecture">gen.architecture</code></td>
<td>
<p>Used underlying genetic architecture (genome length in M)</p>
</td></tr>
<tr><td><code id="breeding.intern_+3A_decodeoriginsu">decodeOriginsU</code></td>
<td>
<p>Used function for the decoding of genetic origins [[5]]/[[6]]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Inherited parent gamete
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
child_gamete &lt;- breeding.intern(info.parent = c(1,1,1), parent = ex_pop$breeding[[1]][[1]][[1]],
                                population = ex_pop)
</code></pre>

<hr>
<h2 id='bv.development'>Development of genetic/breeding value</h2><span id='topic+bv.development'></span>

<h3>Description</h3>

<p>Function to plot genetic/breeding values for multiple generation/cohorts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bv.development(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  confidence = c(1, 2, 3),
  development = c(1, 2, 3),
  quantile = 0.95,
  bvrow = "all",
  ignore.zero = TRUE,
  json = FALSE,
  display.time.point = FALSE,
  display.creating.type = FALSE,
  display.cohort.name = FALSE,
  display.sex = FALSE,
  equal.spacing = FALSE,
  time_reorder = FALSE,
  display.line = TRUE,
  ylim = NULL,
  fix_mfrow = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bv.development_+3A_population">population</code></td>
<td>
<p>population list</p>
</td></tr>
<tr><td><code id="bv.development_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="bv.development_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="bv.development_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="bv.development_+3A_confidence">confidence</code></td>
<td>
<p>Draw confidence intervals for (1- bv, 2- bve, 3- pheno; default: c(1,2,3))</p>
</td></tr>
<tr><td><code id="bv.development_+3A_development">development</code></td>
<td>
<p>Include development of (1- bv, 2- bve, 3- pheno; default: c(1,2,3))</p>
</td></tr>
<tr><td><code id="bv.development_+3A_quantile">quantile</code></td>
<td>
<p>Quantile of the confidence interval to draw (default: 0.05)</p>
</td></tr>
<tr><td><code id="bv.development_+3A_bvrow">bvrow</code></td>
<td>
<p>Which traits to display (for multiple traits separate plots (par(mfrow)))</p>
</td></tr>
<tr><td><code id="bv.development_+3A_ignore.zero">ignore.zero</code></td>
<td>
<p>Cohorts with only 0 individuals are not displayed (default: TRUE)</p>
</td></tr>
<tr><td><code id="bv.development_+3A_json">json</code></td>
<td>
<p>If TRUE extract which cohorts to plot according to the json-file used in json.simulation</p>
</td></tr>
<tr><td><code id="bv.development_+3A_display.time.point">display.time.point</code></td>
<td>
<p>Set TRUE to use time point of generated to sort groups</p>
</td></tr>
<tr><td><code id="bv.development_+3A_display.creating.type">display.creating.type</code></td>
<td>
<p>Set TRUE to show Breedingtype used in generation (web-interface)</p>
</td></tr>
<tr><td><code id="bv.development_+3A_display.cohort.name">display.cohort.name</code></td>
<td>
<p>Set TRUE to display the name of the cohort in the x-axis</p>
</td></tr>
<tr><td><code id="bv.development_+3A_display.sex">display.sex</code></td>
<td>
<p>Set TRUE to display the creating.type (Shape of Points - web-based-application)</p>
</td></tr>
<tr><td><code id="bv.development_+3A_equal.spacing">equal.spacing</code></td>
<td>
<p>Equal distance between groups (independent of time.point)</p>
</td></tr>
<tr><td><code id="bv.development_+3A_time_reorder">time_reorder</code></td>
<td>
<p>Set TRUE to order cohorts according to the time point of generation</p>
</td></tr>
<tr><td><code id="bv.development_+3A_display.line">display.line</code></td>
<td>
<p>Set FALSE to not display the line connecting cohorts</p>
</td></tr>
<tr><td><code id="bv.development_+3A_ylim">ylim</code></td>
<td>
<p>Set this to fix the y-axis of the plot</p>
</td></tr>
<tr><td><code id="bv.development_+3A_fix_mfrow">fix_mfrow</code></td>
<td>
<p>Set TRUE to not use mfrow - use for custom plots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genomic values of selected gen/database/cohort
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
bv.development(ex_pop, gen=1:5)
</code></pre>

<hr>
<h2 id='bv.development.box'>Development of genetic/breeding value using a boxplot</h2><span id='topic+bv.development.box'></span>

<h3>Description</h3>

<p>Function to plot genetic/breeding values for multiple generation/cohorts using box plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bv.development.box(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  bvrow = "all",
  json = FALSE,
  display = "bv",
  display.selection = FALSE,
  display.reproduction = FALSE,
  ylim = NULL,
  fix_mfrow = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bv.development.box_+3A_population">population</code></td>
<td>
<p>population list</p>
</td></tr>
<tr><td><code id="bv.development.box_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="bv.development.box_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="bv.development.box_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="bv.development.box_+3A_bvrow">bvrow</code></td>
<td>
<p>Which traits to display (for multiple traits separte plots (par(mfrow)))</p>
</td></tr>
<tr><td><code id="bv.development.box_+3A_json">json</code></td>
<td>
<p>If TRUE extract which cohorts to plot according to the json-file used in json.simulation</p>
</td></tr>
<tr><td><code id="bv.development.box_+3A_display">display</code></td>
<td>
<p>Choose between &quot;bv&quot;, &quot;pheno&quot;, &quot;bve&quot; (default: &quot;bv&quot;)</p>
</td></tr>
<tr><td><code id="bv.development.box_+3A_display.selection">display.selection</code></td>
<td>
<p>Display lines between generated cohorts via selection (webinterface)</p>
</td></tr>
<tr><td><code id="bv.development.box_+3A_display.reproduction">display.reproduction</code></td>
<td>
<p>Display lines between generated cohorts via reproduction (webinterface)</p>
</td></tr>
<tr><td><code id="bv.development.box_+3A_ylim">ylim</code></td>
<td>
<p>Set this to fix the y-axis of the plot</p>
</td></tr>
<tr><td><code id="bv.development.box_+3A_fix_mfrow">fix_mfrow</code></td>
<td>
<p>Set TRUE to not use mfrow - use for custom plots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genomic values of selected gen/database/cohort
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
bv.development.box(ex_pop, gen=1:5)
</code></pre>

<hr>
<h2 id='bv.standardization'>BV standardization</h2><span id='topic+bv.standardization'></span>

<h3>Description</h3>

<p>Function to get mean and genetic variance of a trait to a fixed value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bv.standardization(
  population,
  mean.target = 100,
  var.target = 10,
  gen = NULL,
  database = NULL,
  cohorts = NULL,
  adapt.bve = FALSE,
  adapt.pheno = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bv.standardization_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="bv.standardization_+3A_mean.target">mean.target</code></td>
<td>
<p>Target mean</p>
</td></tr>
<tr><td><code id="bv.standardization_+3A_var.target">var.target</code></td>
<td>
<p>Target variance</p>
</td></tr>
<tr><td><code id="bv.standardization_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="bv.standardization_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="bv.standardization_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="bv.standardization_+3A_adapt.bve">adapt.bve</code></td>
<td>
<p>Modify previous breeding value estimations by scaling (default: FALSE)</p>
</td></tr>
<tr><td><code id="bv.standardization_+3A_adapt.pheno">adapt.pheno</code></td>
<td>
<p>Modify previous phenotypes by scaling (default: FALSE)</p>
</td></tr>
<tr><td><code id="bv.standardization_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE to display prints</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-list with scaled QTL-effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>population &lt;- creating.diploid(nsnp=1000, nindi=100, n.additive=100)
population &lt;- bv.standardization(population, mean.target=200, var.target=5)
</code></pre>

<hr>
<h2 id='calculate.bv'>Calculate breeding values</h2><span id='topic+calculate.bv'></span>

<h3>Description</h3>

<p>Internal function to calculate the breeding value of a given individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.bv(
  population,
  gen,
  sex,
  nr,
  activ_bv,
  import.position.calculation = NULL,
  decodeOriginsU = decodeOriginsR,
  store.effect.freq = FALSE,
  bit.storing = FALSE,
  nbits = 30,
  output_compressed = FALSE,
  bv.ignore.traits = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate.bv_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="calculate.bv_+3A_gen">gen</code></td>
<td>
<p>Generation of the individual of interest</p>
</td></tr>
<tr><td><code id="calculate.bv_+3A_sex">sex</code></td>
<td>
<p>Sex of the individual of interest</p>
</td></tr>
<tr><td><code id="calculate.bv_+3A_nr">nr</code></td>
<td>
<p>Number of the individual of interest</p>
</td></tr>
<tr><td><code id="calculate.bv_+3A_activ_bv">activ_bv</code></td>
<td>
<p>traits to consider</p>
</td></tr>
<tr><td><code id="calculate.bv_+3A_import.position.calculation">import.position.calculation</code></td>
<td>
<p>Function to calculate recombination point into adjacent/following SNP</p>
</td></tr>
<tr><td><code id="calculate.bv_+3A_decodeoriginsu">decodeOriginsU</code></td>
<td>
<p>Used function for the decoding of genetic origins [[5]]/[[6]]</p>
</td></tr>
<tr><td><code id="calculate.bv_+3A_store.effect.freq">store.effect.freq</code></td>
<td>
<p>If TRUE store the allele frequency of effect markers per generation</p>
</td></tr>
<tr><td><code id="calculate.bv_+3A_bit.storing">bit.storing</code></td>
<td>
<p>Set to TRUE if the MoBPS (not-miraculix! bit-storing is used)</p>
</td></tr>
<tr><td><code id="calculate.bv_+3A_nbits">nbits</code></td>
<td>
<p>Bits available in MoBPS-bit-storing</p>
</td></tr>
<tr><td><code id="calculate.bv_+3A_output_compressed">output_compressed</code></td>
<td>
<p>Set to TRUE to get a miraculix-compressed genotype/haplotype</p>
</td></tr>
<tr><td><code id="calculate.bv_+3A_bv.ignore.traits">bv.ignore.traits</code></td>
<td>
<p>Vector of traits to ignore in the calculation of the genomic value (default: NULL; Only recommended for high number of traits and experienced users!)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[[1]] true genomic value [[2]] allele frequency at QTL markers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
calculate.bv(ex_pop, gen=1, sex=1, nr=1, activ_bv = 1)
</code></pre>

<hr>
<h2 id='cattle_chip'>Cattle chip</h2><span id='topic+cattle_chip'></span>

<h3>Description</h3>

<p>Genome for cattle according to Ma et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cattle_chip
</code></pre>


<h3>Author(s)</h3>

<p>Torsten Pook <a href="mailto:torsten.pook@uni-goettingen.de">torsten.pook@uni-goettingen.de</a>
</p>


<h3>Source</h3>

<p>Ma et al 2015
</p>

<hr>
<h2 id='check.parents'>Relatedness check between two individuals</h2><span id='topic+check.parents'></span>

<h3>Description</h3>

<p>Internal function to check the relatedness between two individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.parents(population, info.father, info.mother, max.rel = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.parents_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="check.parents_+3A_info.father">info.father</code></td>
<td>
<p>position of the first parent in the dataset</p>
</td></tr>
<tr><td><code id="check.parents_+3A_info.mother">info.mother</code></td>
<td>
<p>position of the second parent in the dataset</p>
</td></tr>
<tr><td><code id="check.parents_+3A_max.rel">max.rel</code></td>
<td>
<p>maximal allowed relationship (default: 2, alt: 1 no full-sibs, 0 no half-sibs)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical with TRUE if relatedness does not excced max.rel / FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
check.parents(ex_pop, info.father=c(4,1,1,1), info.mother=c(4,2,1,1))
</code></pre>

<hr>
<h2 id='chicken_chip'>chicken chip</h2><span id='topic+chicken_chip'></span>

<h3>Description</h3>

<p>Genome for chicken according to Groenen et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chicken_chip
</code></pre>


<h3>Author(s)</h3>

<p>Torsten Pook <a href="mailto:torsten.pook@uni-goettingen.de">torsten.pook@uni-goettingen.de</a>
</p>


<h3>Source</h3>

<p>Groenen et al 2009
</p>

<hr>
<h2 id='clean.up'>Clean-up recombination points</h2><span id='topic+clean.up'></span>

<h3>Description</h3>

<p>Function to remove recombination points + origins with no influence on markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean.up(population, gen = "all", database = NULL, cohorts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean.up_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="clean.up_+3A_gen">gen</code></td>
<td>
<p>Generations to clean up (default: &quot;current&quot;)</p>
</td></tr>
<tr><td><code id="clean.up_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider</p>
</td></tr>
<tr><td><code id="clean.up_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-list with deleted irrelevant recombination points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
ex_pop &lt;- clean.up(ex_pop)
</code></pre>

<hr>
<h2 id='codeOriginsR'>Origins-coding(R)</h2><span id='topic+codeOriginsR'></span>

<h3>Description</h3>

<p>R-Version of the internal bitwise-coding of origins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codeOriginsR(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codeOriginsR_+3A_m">M</code></td>
<td>
<p>Origins matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bit-wise coded origins
</p>


<h3>Examples</h3>

<pre><code class='language-R'>codeOriginsR(cbind(1,1,1,1))
</code></pre>

<hr>
<h2 id='combine.traits'>Combine traits</h2><span id='topic+combine.traits'></span>

<h3>Description</h3>

<p>Function to combine traits in the BVE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.traits(
  population,
  combine.traits = NULL,
  combine.name = NULL,
  remove.combine = NULL,
  remove.all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.traits_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="combine.traits_+3A_combine.traits">combine.traits</code></td>
<td>
<p>Vector containing the traits (numbers) to combine into a joined trait</p>
</td></tr>
<tr><td><code id="combine.traits_+3A_combine.name">combine.name</code></td>
<td>
<p>Name of the combined trait</p>
</td></tr>
<tr><td><code id="combine.traits_+3A_remove.combine">remove.combine</code></td>
<td>
<p>Remove a selected previously generated combined trait</p>
</td></tr>
<tr><td><code id="combine.traits_+3A_remove.all">remove.all</code></td>
<td>
<p>Set TRUE to remove all previously generated combined traits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>population &lt;- creating.diploid(nsnp=100, nindi=100, n.additive = c(50,50))
population &lt;- combine.traits(population, combine.traits=1:2)
population &lt;- breeding.diploid(population, bve=TRUE, phenotyping.gen=1, heritability=0.3)
</code></pre>

<hr>
<h2 id='compute.costs'>Compute costs of a breeding program</h2><span id='topic+compute.costs'></span>

<h3>Description</h3>

<p>Function to derive the costs of a breeding program / population-list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.costs(
  population,
  phenotyping.costs = 10,
  genotyping.costs = 100,
  fix.costs = 0,
  fix.costs.annual = 0,
  profit.per.bv = 1,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  interest.rate = 1,
  base.gen = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.costs_+3A_population">population</code></td>
<td>
<p>population-list</p>
</td></tr>
<tr><td><code id="compute.costs_+3A_phenotyping.costs">phenotyping.costs</code></td>
<td>
<p>Costs for the generation of a phenotype</p>
</td></tr>
<tr><td><code id="compute.costs_+3A_genotyping.costs">genotyping.costs</code></td>
<td>
<p>Costs for the geneation of a genotype</p>
</td></tr>
<tr><td><code id="compute.costs_+3A_fix.costs">fix.costs</code></td>
<td>
<p>one time occuring fixed costs</p>
</td></tr>
<tr><td><code id="compute.costs_+3A_fix.costs.annual">fix.costs.annual</code></td>
<td>
<p>annually occuring fixed costs</p>
</td></tr>
<tr><td><code id="compute.costs_+3A_profit.per.bv">profit.per.bv</code></td>
<td>
<p>profit generated by bv per animal</p>
</td></tr>
<tr><td><code id="compute.costs_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider</p>
</td></tr>
<tr><td><code id="compute.costs_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to consider)</p>
</td></tr>
<tr><td><code id="compute.costs_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to consider)</p>
</td></tr>
<tr><td><code id="compute.costs_+3A_interest.rate">interest.rate</code></td>
<td>
<p>Applied yearly interest rate</p>
</td></tr>
<tr><td><code id="compute.costs_+3A_base.gen">base.gen</code></td>
<td>
<p>Base generation (application of interest rate)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cost-table for selected gen/database/cohorts of a population-list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
compute.costs(ex_pop, gen=1:5)
</code></pre>

<hr>
<h2 id='compute.costs.cohorts'>Compute costs of a breeding program by cohorts</h2><span id='topic+compute.costs.cohorts'></span>

<h3>Description</h3>

<p>Function to derive the costs of a breeding program / population-list by cohorts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.costs.cohorts(
  population,
  gen = NULL,
  database = NULL,
  cohorts = NULL,
  json = TRUE,
  phenotyping.costs = NULL,
  genotyping.costs = 0,
  housing.costs = NULL,
  fix.costs = 0,
  fix.costs.annual = 0,
  profit.per.bv = 1,
  interest.rate = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.costs.cohorts_+3A_population">population</code></td>
<td>
<p>population-list</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to consider)</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to consider)</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_json">json</code></td>
<td>
<p>If TRUE extract which cohorts to plot according to the json-file used in json.simulation</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_phenotyping.costs">phenotyping.costs</code></td>
<td>
<p>Costs for the generation of a phenotype</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_genotyping.costs">genotyping.costs</code></td>
<td>
<p>Costs for the geneation of a genotype</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_housing.costs">housing.costs</code></td>
<td>
<p>Costs for housing</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_fix.costs">fix.costs</code></td>
<td>
<p>one time occuring fixed costs</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_fix.costs.annual">fix.costs.annual</code></td>
<td>
<p>annually occuring fixed costs</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_profit.per.bv">profit.per.bv</code></td>
<td>
<p>profit generated by bv per animal</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_interest.rate">interest.rate</code></td>
<td>
<p>Applied yearly interest rate</p>
</td></tr>
<tr><td><code id="compute.costs.cohorts_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cost-table for selected gen/database/cohorts of a population-list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
compute.costs.cohorts(ex_pop, gen=1:5, genotyping.costs=25, json=FALSE)
</code></pre>

<hr>
<h2 id='compute.snps'>Compute genotype/haplotype</h2><span id='topic+compute.snps'></span>

<h3>Description</h3>

<p>Internal function for the computation of genotypes &amp; haplotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.snps(
  population,
  gen,
  sex,
  nr,
  faster = TRUE,
  import.position.calculation = NULL,
  from_p = 1,
  to_p = Inf,
  decodeOriginsU = decodeOriginsR,
  bit.storing = FALSE,
  nbits = 30,
  output_compressed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.snps_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="compute.snps_+3A_gen">gen</code></td>
<td>
<p>Generation of the individual to compute</p>
</td></tr>
<tr><td><code id="compute.snps_+3A_sex">sex</code></td>
<td>
<p>Gender of the individual to compute</p>
</td></tr>
<tr><td><code id="compute.snps_+3A_nr">nr</code></td>
<td>
<p>Number of the individual to compute</p>
</td></tr>
<tr><td><code id="compute.snps_+3A_faster">faster</code></td>
<td>
<p>If FALSE use slower version to compute markers between recombination points</p>
</td></tr>
<tr><td><code id="compute.snps_+3A_import.position.calculation">import.position.calculation</code></td>
<td>
<p>Function to calculate recombination point into adjacent/following SNP</p>
</td></tr>
<tr><td><code id="compute.snps_+3A_from_p">from_p</code></td>
<td>
<p>First SNP to consider</p>
</td></tr>
<tr><td><code id="compute.snps_+3A_to_p">to_p</code></td>
<td>
<p>Last SNP to consider</p>
</td></tr>
<tr><td><code id="compute.snps_+3A_decodeoriginsu">decodeOriginsU</code></td>
<td>
<p>Used function for the decoding of genetic origins [[5]]/[[6]]</p>
</td></tr>
<tr><td><code id="compute.snps_+3A_bit.storing">bit.storing</code></td>
<td>
<p>Set to TRUE if the MoBPS (not-miraculix! bit-storing is used)</p>
</td></tr>
<tr><td><code id="compute.snps_+3A_nbits">nbits</code></td>
<td>
<p>Bits available in MoBPS-bit-storing</p>
</td></tr>
<tr><td><code id="compute.snps_+3A_output_compressed">output_compressed</code></td>
<td>
<p>Set to TRUE to get a miraculix-compressed genotype/haplotype</p>
</td></tr>
</table>


<h3>Value</h3>

<p>haplotypes for the selected individual
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
compute.snps(ex_pop, gen=1, sex=1, nr=1)
</code></pre>

<hr>
<h2 id='compute.snps_single'>Compute genotype/haplotype in gene editing application</h2><span id='topic+compute.snps_single'></span>

<h3>Description</h3>

<p>Internal function for the computation of genotypes &amp; haplotypes in gene editing application
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.snps_single(
  population,
  current.recombi,
  current.mut,
  current.ursprung,
  faster = TRUE,
  import.position.calculation = NULL,
  decodeOriginsU = decodeOriginsR
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.snps_single_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="compute.snps_single_+3A_current.recombi">current.recombi</code></td>
<td>
<p>vector of currently activ recombination points</p>
</td></tr>
<tr><td><code id="compute.snps_single_+3A_current.mut">current.mut</code></td>
<td>
<p>vector of currently activ mutations</p>
</td></tr>
<tr><td><code id="compute.snps_single_+3A_current.ursprung">current.ursprung</code></td>
<td>
<p>vector of currently activ origins</p>
</td></tr>
<tr><td><code id="compute.snps_single_+3A_faster">faster</code></td>
<td>
<p>If FALSE use slower version to compute markers between recombination points</p>
</td></tr>
<tr><td><code id="compute.snps_single_+3A_import.position.calculation">import.position.calculation</code></td>
<td>
<p>Function to calculate recombination point into adjacent/following SNP</p>
</td></tr>
<tr><td><code id="compute.snps_single_+3A_decodeoriginsu">decodeOriginsU</code></td>
<td>
<p>Used function for the decoding of genetic origins [[5]]/[[6]]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>haplotypes for the selected individual
</p>

<hr>
<h2 id='creating.diploid'>Generation of the starting population</h2><span id='topic+creating.diploid'></span>

<h3>Description</h3>

<p>Generation of the starting population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>creating.diploid(
  dataset = NULL,
  vcf = NULL,
  chr.nr = NULL,
  bp = NULL,
  snp.name = NULL,
  hom0 = NULL,
  hom1 = NULL,
  bpcm.conversion = 0,
  nsnp = 0,
  nindi = 0,
  freq = "beta",
  population = NULL,
  sex.s = "fixed",
  add.chromosome = FALSE,
  generation = 1,
  class = 0L,
  sex.quota = 0.5,
  chromosome.length = NULL,
  length.before = 5,
  length.behind = 5,
  real.bv.add = NULL,
  real.bv.mult = NULL,
  real.bv.dice = NULL,
  snps.equidistant = NULL,
  change.order = FALSE,
  bv.total = 0,
  polygenic.variance = 100,
  bve.mult.factor = NULL,
  bve.poly.factor = NULL,
  base.bv = NULL,
  add.chromosome.ends = TRUE,
  new.phenotype.correlation = NULL,
  new.residual.correlation = NULL,
  new.breeding.correlation = NULL,
  add.architecture = NULL,
  snp.position = NULL,
  position.scaling = FALSE,
  bit.storing = FALSE,
  nbits = 30,
  randomSeed = NULL,
  miraculix = TRUE,
  miraculix.dataset = TRUE,
  n.additive = 0,
  n.equal.additive = 0,
  n.dominant = 0,
  n.equal.dominant = 0,
  n.qualitative = 0,
  n.quantitative = 0,
  dominant.only.positive = FALSE,
  var.additive.l = NULL,
  var.dominant.l = NULL,
  var.qualitative.l = NULL,
  var.quantitative.l = NULL,
  effect.size.equal.add = 1,
  effect.size.equal.dom = 1,
  exclude.snps = NULL,
  replace.real.bv = FALSE,
  shuffle.traits = NULL,
  shuffle.cor = NULL,
  skip.rest = FALSE,
  enter.bv = TRUE,
  name.cohort = NULL,
  template.chip = NULL,
  beta.shape1 = 1,
  beta.shape2 = 1,
  time.point = 0,
  creating.type = 0,
  trait.name = NULL,
  share.genotyped = 1,
  genotyped.s = NULL,
  map = NULL,
  remove.invalid.qtl = TRUE,
  verbose = TRUE,
  bv.standard = FALSE,
  mean.target = NULL,
  var.target = NULL,
  is.maternal = NULL,
  is.paternal = NULL,
  vcf.maxsnp = Inf,
  internal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="creating.diploid_+3A_dataset">dataset</code></td>
<td>
<p>SNP dataset, use &quot;random&quot;, &quot;allhetero&quot; &quot;all0&quot; when generating a dataset via nsnp,nindi</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_vcf">vcf</code></td>
<td>
<p>Path to a vcf-file used as input genotypes (correct haplotype phase is assumed!)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_chr.nr">chr.nr</code></td>
<td>
<p>Vector containing the assosiated chromosome for each marker (default: all on the same)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_bp">bp</code></td>
<td>
<p>Vector containing the physical position (bp) for each marker (default: 1,2,3...)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_snp.name">snp.name</code></td>
<td>
<p>Vector containing the name of each marker (default ChrXSNPY - XY chosen accordingly)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_hom0">hom0</code></td>
<td>
<p>Vector containing the first allelic variant in each marker (default: 0)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_hom1">hom1</code></td>
<td>
<p>Vector containing the second allelic variant in each marker (default: 1)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_bpcm.conversion">bpcm.conversion</code></td>
<td>
<p>Convert physical position (bp) into a cM position (default: 0 - not done)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_nsnp">nsnp</code></td>
<td>
<p>number of markers to generate in a random dataset</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_nindi">nindi</code></td>
<td>
<p>number of inidividuals to generate in a random dataset</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_freq">freq</code></td>
<td>
<p>frequency of allele 1 when randomly generating a dataset</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_sex.s">sex.s</code></td>
<td>
<p>Specify which newly added individuals are male (1) or female (2)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_add.chromosome">add.chromosome</code></td>
<td>
<p>If TRUE add an additional chromosome to the dataset</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_generation">generation</code></td>
<td>
<p>Generation of the newly added individuals (default: 1)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_class">class</code></td>
<td>
<p>Migration level of the newly added individuals</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_sex.quota">sex.quota</code></td>
<td>
<p>Share of newly added female individuals (deterministic if sex.s=&quot;fixed&quot;, alt: sex.s=&quot;random&quot;)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_chromosome.length">chromosome.length</code></td>
<td>
<p>Length of the newly added chromosome (default: 5)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_length.before">length.before</code></td>
<td>
<p>Length before the first SNP of the dataset (default: 5)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_length.behind">length.behind</code></td>
<td>
<p>Length after the last SNP of the dataset (default: 5)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_real.bv.add">real.bv.add</code></td>
<td>
<p>Single Marker effects</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_real.bv.mult">real.bv.mult</code></td>
<td>
<p>Two Marker effects</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_real.bv.dice">real.bv.dice</code></td>
<td>
<p>Multi-marker effects</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_snps.equidistant">snps.equidistant</code></td>
<td>
<p>Use equidistant markers (computationally faster! ; default: TRUE)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_change.order">change.order</code></td>
<td>
<p>If TRUE sort markers according to given marker positions</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_bv.total">bv.total</code></td>
<td>
<p>Number of traits (If more than traits via real.bv.X use traits with no directly underlying QTL)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_polygenic.variance">polygenic.variance</code></td>
<td>
<p>Genetic variance of traits with no underlying QTL</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_bve.mult.factor">bve.mult.factor</code></td>
<td>
<p>Multiplicate trait value times this</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_bve.poly.factor">bve.poly.factor</code></td>
<td>
<p>Potency trait value over this</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_base.bv">base.bv</code></td>
<td>
<p>Average genetic value of a trait</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_add.chromosome.ends">add.chromosome.ends</code></td>
<td>
<p>Add chromosome ends as recombination points</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_new.phenotype.correlation">new.phenotype.correlation</code></td>
<td>
<p>(OLD! - use new.residual.correlation) Correlation of the simulated enviromental variance</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_new.residual.correlation">new.residual.correlation</code></td>
<td>
<p>Correlation of the simulated enviromental variance</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_new.breeding.correlation">new.breeding.correlation</code></td>
<td>
<p>Correlation of the simulated genetic variance (child share! heritage is not influenced!</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_add.architecture">add.architecture</code></td>
<td>
<p>Add genetic architecture (marker positions)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_snp.position">snp.position</code></td>
<td>
<p>Location of each marker on the genetic map</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_position.scaling">position.scaling</code></td>
<td>
<p>Manual scaling of snp.position</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_bit.storing">bit.storing</code></td>
<td>
<p>Set to TRUE if the MoBPS (not-miraculix! bit-storing is used)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_nbits">nbits</code></td>
<td>
<p>Bits available in MoBPS-bit-storing</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_randomseed">randomSeed</code></td>
<td>
<p>Set random seed of the process</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_miraculix">miraculix</code></td>
<td>
<p>If TRUE use miraculix package for data storage, computations and dataset generation</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_miraculix.dataset">miraculix.dataset</code></td>
<td>
<p>Set FALSE to deactive miraculix package for dataset generation</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_n.additive">n.additive</code></td>
<td>
<p>Number of additive QTL with effect size drawn from a gaussian distribution</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_n.equal.additive">n.equal.additive</code></td>
<td>
<p>Number of additive QTL with equal effect size (effect.size)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_n.dominant">n.dominant</code></td>
<td>
<p>Number of dominant QTL with effect size drawn from a gaussian distribution</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_n.equal.dominant">n.equal.dominant</code></td>
<td>
<p>Number of n.equal.dominant QTL with equal effect size</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_n.qualitative">n.qualitative</code></td>
<td>
<p>Number of qualitative epistatic QTL</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_n.quantitative">n.quantitative</code></td>
<td>
<p>Number of quantitative epistatic QTL</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_dominant.only.positive">dominant.only.positive</code></td>
<td>
<p>Set to TRUE to always asign the heterozygous variant with the higher of the two homozygous effects (e.g. hybrid breeding); default: FALSE</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_var.additive.l">var.additive.l</code></td>
<td>
<p>Variance of additive QTL</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_var.dominant.l">var.dominant.l</code></td>
<td>
<p>Variance of dominante QTL</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_var.qualitative.l">var.qualitative.l</code></td>
<td>
<p>Variance of qualitative epistatic QTL</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_var.quantitative.l">var.quantitative.l</code></td>
<td>
<p>Variance of quantitative epistatic QTL</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_effect.size.equal.add">effect.size.equal.add</code></td>
<td>
<p>Effect size of the QTLs in n.equal.additive</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_effect.size.equal.dom">effect.size.equal.dom</code></td>
<td>
<p>Effect size of the QTLs in n.equal.dominant</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_exclude.snps">exclude.snps</code></td>
<td>
<p>Marker were no QTL are simulated on</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_replace.real.bv">replace.real.bv</code></td>
<td>
<p>If TRUE delete the simulated traits added before</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_shuffle.traits">shuffle.traits</code></td>
<td>
<p>Combine different traits into a joined trait</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_shuffle.cor">shuffle.cor</code></td>
<td>
<p>Target Correlation between shuffeled traits</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_skip.rest">skip.rest</code></td>
<td>
<p>Internal variable needed when adding multipe chromosomes jointly</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_enter.bv">enter.bv</code></td>
<td>
<p>Internal parameter</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_name.cohort">name.cohort</code></td>
<td>
<p>Name of the newly added cohort</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_template.chip">template.chip</code></td>
<td>
<p>Import genetic map and chip from a species (&quot;cattle&quot;, &quot;chicken&quot;, &quot;pig&quot;)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_beta.shape1">beta.shape1</code></td>
<td>
<p>First parameter of the beta distribution for simulating allele frequencies</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_beta.shape2">beta.shape2</code></td>
<td>
<p>Second parameter of the beta distribution for simulating allele frequencies</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_time.point">time.point</code></td>
<td>
<p>Time point at which the new individuals are generated</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_creating.type">creating.type</code></td>
<td>
<p>Technique to generate new individuals (usage in web-based application)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_trait.name">trait.name</code></td>
<td>
<p>Name of the trait generated</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_share.genotyped">share.genotyped</code></td>
<td>
<p>Share of individuals genotyped in the founders</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_genotyped.s">genotyped.s</code></td>
<td>
<p>Specify with newly added individuals are genotyped (1) or not (0)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_map">map</code></td>
<td>
<p>map-file that contains up to 5 colums (Chromsome, SNP-id, M-position, Bp-position, allele freq - Everything not provides it set to NA). A map can be imported via MoBPSmaps::ensembl.map()</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_remove.invalid.qtl">remove.invalid.qtl</code></td>
<td>
<p>Set to FALSE to deactive the automatic removal of QTLs on markers that do not exist</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_bv.standard">bv.standard</code></td>
<td>
<p>Set TRUE to standardize trait mean and variance via bv.standardization() - automatically set to TRUE when mean/var.target are used</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_mean.target">mean.target</code></td>
<td>
<p>Target mean</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_var.target">var.target</code></td>
<td>
<p>Target variance</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_is.maternal">is.maternal</code></td>
<td>
<p>Vector coding if a trait is caused by a maternal effect (Default: all FALSE)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_is.paternal">is.paternal</code></td>
<td>
<p>Vector coding if a trait is caused by a paternal effect (Default: all FALSE)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_vcf.maxsnp">vcf.maxsnp</code></td>
<td>
<p>Maximum number of SNPs to include in the genotype file (default: Inf)</p>
</td></tr>
<tr><td><code id="creating.diploid_+3A_internal">internal</code></td>
<td>
<p>Dont touch!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>population &lt;- creating.diploid(nsnp=1000, nindi=100)
</code></pre>

<hr>
<h2 id='creating.phenotypic.transform'>Create a phenotypic transformation</h2><span id='topic+creating.phenotypic.transform'></span>

<h3>Description</h3>

<p>Function to perform create a transformation of phenotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>creating.phenotypic.transform(
  population,
  phenotypic.transform.function = NULL,
  trait = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="creating.phenotypic.transform_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="creating.phenotypic.transform_+3A_phenotypic.transform.function">phenotypic.transform.function</code></td>
<td>
<p>Phenotypic transformation to apply</p>
</td></tr>
<tr><td><code id="creating.phenotypic.transform_+3A_trait">trait</code></td>
<td>
<p>Trait for which a transformation is to be applied
data(ex_pop)
trafo &lt;- function(x) return(x^2)
ex_pop &lt;- creating.phenotypic.transform(ex_pop, phenotypic.transform.function=trafo)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-list with a new phenotypic transformation function
</p>

<hr>
<h2 id='creating.trait'>Generation of genomic traits</h2><span id='topic+creating.trait'></span>

<h3>Description</h3>

<p>Generation of the trait in a starting population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>creating.trait(
  population,
  real.bv.add = NULL,
  real.bv.mult = NULL,
  real.bv.dice = NULL,
  bv.total = 0,
  polygenic.variance = 100,
  bve.mult.factor = NULL,
  bve.poly.factor = NULL,
  base.bv = NULL,
  new.phenotype.correlation = NULL,
  new.residual.correlation = NULL,
  new.breeding.correlation = NULL,
  n.additive = 0,
  n.equal.additive = 0,
  n.dominant = 0,
  n.equal.dominant = 0,
  n.qualitative = 0,
  n.quantitative = 0,
  dominant.only.positive = FALSE,
  var.additive.l = NULL,
  var.dominant.l = NULL,
  var.qualitative.l = NULL,
  var.quantitative.l = NULL,
  effect.size.equal.add = 1,
  effect.size.equal.dom = 1,
  exclude.snps = NULL,
  randomSeed = NULL,
  shuffle.traits = NULL,
  shuffle.cor = NULL,
  replace.traits = FALSE,
  trait.name = NULL,
  remove.invalid.qtl = TRUE,
  bv.standard = FALSE,
  mean.target = NULL,
  var.target = NULL,
  verbose = TRUE,
  is.maternal = NULL,
  is.paternal = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="creating.trait_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_real.bv.add">real.bv.add</code></td>
<td>
<p>Single Marker effects</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_real.bv.mult">real.bv.mult</code></td>
<td>
<p>Two Marker effects</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_real.bv.dice">real.bv.dice</code></td>
<td>
<p>Multi-marker effects</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_bv.total">bv.total</code></td>
<td>
<p>Number of traits (If more than traits via real.bv.X use traits with no directly underlying QTL)</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_polygenic.variance">polygenic.variance</code></td>
<td>
<p>Genetic variance of traits with no underlying QTL</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_bve.mult.factor">bve.mult.factor</code></td>
<td>
<p>Multiplicate trait value times this</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_bve.poly.factor">bve.poly.factor</code></td>
<td>
<p>Potency trait value over this</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_base.bv">base.bv</code></td>
<td>
<p>Average genetic value of a trait</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_new.phenotype.correlation">new.phenotype.correlation</code></td>
<td>
<p>(OLD! - use new.residual.correlation) Correlation of the simulated enviromental variance</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_new.residual.correlation">new.residual.correlation</code></td>
<td>
<p>Correlation of the simulated enviromental variance</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_new.breeding.correlation">new.breeding.correlation</code></td>
<td>
<p>Correlation of the simulated genetic variance (child share! heritage is not influenced!</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_n.additive">n.additive</code></td>
<td>
<p>Number of additive QTL with effect size drawn from a gaussian distribution</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_n.equal.additive">n.equal.additive</code></td>
<td>
<p>Number of additive QTL with equal effect size (effect.size)</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_n.dominant">n.dominant</code></td>
<td>
<p>Number of dominant QTL with effect size drawn from a gaussian distribution</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_n.equal.dominant">n.equal.dominant</code></td>
<td>
<p>Number of n.equal.dominant QTL with equal effect size</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_n.qualitative">n.qualitative</code></td>
<td>
<p>Number of qualitative epistatic QTL</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_n.quantitative">n.quantitative</code></td>
<td>
<p>Number of quantitative epistatic QTL</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_dominant.only.positive">dominant.only.positive</code></td>
<td>
<p>Set to TRUE to always asign the heterozygous variant with the higher of the two homozygous effects (e.g. hybrid breeding); default: FALSE</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_var.additive.l">var.additive.l</code></td>
<td>
<p>Variance of additive QTL</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_var.dominant.l">var.dominant.l</code></td>
<td>
<p>Variance of dominante QTL</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_var.qualitative.l">var.qualitative.l</code></td>
<td>
<p>Variance of qualitative epistatic QTL</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_var.quantitative.l">var.quantitative.l</code></td>
<td>
<p>Variance of quantitative epistatic QTL</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_effect.size.equal.add">effect.size.equal.add</code></td>
<td>
<p>Effect size of the QTLs in n.equal.additive</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_effect.size.equal.dom">effect.size.equal.dom</code></td>
<td>
<p>Effect size of the QTLs in n.equal.dominant</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_exclude.snps">exclude.snps</code></td>
<td>
<p>Marker were no QTL are simulated on</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_randomseed">randomSeed</code></td>
<td>
<p>Set random seed of the process</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_shuffle.traits">shuffle.traits</code></td>
<td>
<p>Combine different traits into a joined trait</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_shuffle.cor">shuffle.cor</code></td>
<td>
<p>Target Correlation between shuffeled traits</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_replace.traits">replace.traits</code></td>
<td>
<p>If TRUE delete the simulated traits added before</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_trait.name">trait.name</code></td>
<td>
<p>Name of the trait generated</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_remove.invalid.qtl">remove.invalid.qtl</code></td>
<td>
<p>Set to FALSE to deactive the automatic removal of QTLs on markers that do not exist</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_bv.standard">bv.standard</code></td>
<td>
<p>Set TRUE to standardize trait mean and variance via bv.standardization()</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_mean.target">mean.target</code></td>
<td>
<p>Target mean</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_var.target">var.target</code></td>
<td>
<p>Target variance</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_is.maternal">is.maternal</code></td>
<td>
<p>Vector coding if a trait is caused by a maternal effect (Default: all FALSE)</p>
</td></tr>
<tr><td><code id="creating.trait_+3A_is.paternal">is.paternal</code></td>
<td>
<p>Vector coding if a trait is caused by a paternal effect (Default: all FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-list with one or more additional new traits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>population &lt;- creating.diploid(nsnp=1000, nindi=100)
population &lt;- creating.trait(population, n.additive=100)
</code></pre>

<hr>
<h2 id='decodeOriginsR'>Origins-Decoding(R)</h2><span id='topic+decodeOriginsR'></span>

<h3>Description</h3>

<p>R-Version of the internal bitwise-decoding of origins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decodeOriginsR(P, row)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decodeOriginsR_+3A_p">P</code></td>
<td>
<p>coded origins vector</p>
</td></tr>
<tr><td><code id="decodeOriginsR_+3A_row">row</code></td>
<td>
<p>row to decode</p>
</td></tr>
</table>


<h3>Value</h3>

<p>de-coded origins
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decodeOriginsR(0L)
</code></pre>

<hr>
<h2 id='demiraculix'>Remove miraculix-coding for genotypes</h2><span id='topic+demiraculix'></span>

<h3>Description</h3>

<p>Internal function to decode all genotypes to non-miraculix objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demiraculix(population)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demiraculix_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population list
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is only relevant with the package miraculix is installed and used
population &lt;- creating.diploid(nsnp=100, nindi=50)
population &lt;- demiraculix(population)
</code></pre>

<hr>
<h2 id='derive.loop.elements'>Derive loop elements</h2><span id='topic+derive.loop.elements'></span>

<h3>Description</h3>

<p>Internal function to derive the position of all individuals to consider for BVE/GWAS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive.loop.elements(
  population,
  bve.database,
  bve.class,
  bve.avoid.duplicates,
  store.adding = FALSE,
  store.which.adding = FALSE,
  list.of.copys = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive.loop.elements_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="derive.loop.elements_+3A_bve.database">bve.database</code></td>
<td>
<p>Groups of individuals to consider in breeding value estimation</p>
</td></tr>
<tr><td><code id="derive.loop.elements_+3A_bve.class">bve.class</code></td>
<td>
<p>Consider only animals of those class classes in breeding value estimation (default: NULL - use all)</p>
</td></tr>
<tr><td><code id="derive.loop.elements_+3A_bve.avoid.duplicates">bve.avoid.duplicates</code></td>
<td>
<p>If set to FALSE multiple generatations of the same individual can be used in the bve (only possible by using copy.individual to generate individuals)</p>
</td></tr>
<tr><td><code id="derive.loop.elements_+3A_store.adding">store.adding</code></td>
<td>
<p>Internal parameter to derive number of added individuals per database entry (only relevant internally for GWAS)</p>
</td></tr>
<tr><td><code id="derive.loop.elements_+3A_store.which.adding">store.which.adding</code></td>
<td>
<p>Internal parameter to derive which individuals are copy entries</p>
</td></tr>
<tr><td><code id="derive.loop.elements_+3A_list.of.copys">list.of.copys</code></td>
<td>
<p>Internal parameter to derive further information on the copies individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of individuals in the entered database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
derive.loop.elements(ex_pop, bve.database=get.database(ex_pop, gen=2),
bve.class=NULL, bve.avoid.duplicates=TRUE)
</code></pre>

<hr>
<h2 id='diag.mobps'>Add a genotyping array</h2><span id='topic+diag.mobps'></span>

<h3>Description</h3>

<p>Function to add a genotyping array for the population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag.mobps(elements)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag.mobps_+3A_elements">elements</code></td>
<td>
<p>vector with entries to put on the diagonal of a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Diagonal matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diag.mobps(5)
</code></pre>

<hr>
<h2 id='edges.fromto'>Detection of parental/child nodes</h2><span id='topic+edges.fromto'></span>

<h3>Description</h3>

<p>Internal function to extract parental/child node of an edge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges.fromto(edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges.fromto_+3A_edges">edges</code></td>
<td>
<p>Edges of the json-file generated via the web-interface</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of Parent/Child-nodes for the considered edges
</p>

<hr>
<h2 id='edit_animal'>Internal gene editing function</h2><span id='topic+edit_animal'></span>

<h3>Description</h3>

<p>Internal function to perform gene editing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edit_animal(
  population,
  gen,
  sex,
  nr,
  nr.edits,
  decodeOriginsU = decodeOriginsR,
  bit.storing = FALSE,
  nbits = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edit_animal_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="edit_animal_+3A_gen">gen</code></td>
<td>
<p>Generation of the individual to edit</p>
</td></tr>
<tr><td><code id="edit_animal_+3A_sex">sex</code></td>
<td>
<p>Gender of the individual to edit</p>
</td></tr>
<tr><td><code id="edit_animal_+3A_nr">nr</code></td>
<td>
<p>Number of the individual to edit</p>
</td></tr>
<tr><td><code id="edit_animal_+3A_nr.edits">nr.edits</code></td>
<td>
<p>Number of edits to perform</p>
</td></tr>
<tr><td><code id="edit_animal_+3A_decodeoriginsu">decodeOriginsU</code></td>
<td>
<p>Used function for the decoding of genetic origins [[5]]/[[6]]</p>
</td></tr>
<tr><td><code id="edit_animal_+3A_bit.storing">bit.storing</code></td>
<td>
<p>Set to TRUE if the MoBPS (not-miraculix! bit-storing is used)</p>
</td></tr>
<tr><td><code id="edit_animal_+3A_nbits">nbits</code></td>
<td>
<p>Bits available in MoBPS-bit-storing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>animal after genome editing
</p>

<hr>
<h2 id='effect.estimate.add'>Estimation of marker effects</h2><span id='topic+effect.estimate.add'></span>

<h3>Description</h3>

<p>Function to estimate marker effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effect.estimate.add(geno, pheno, map = NULL, scaling = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effect.estimate.add_+3A_geno">geno</code></td>
<td>
<p>genotype dataset (marker x individuals)</p>
</td></tr>
<tr><td><code id="effect.estimate.add_+3A_pheno">pheno</code></td>
<td>
<p>phenotype dataset (each phenotype in a row)</p>
</td></tr>
<tr><td><code id="effect.estimate.add_+3A_map">map</code></td>
<td>
<p>genomic map</p>
</td></tr>
<tr><td><code id="effect.estimate.add_+3A_scaling">scaling</code></td>
<td>
<p>Set FALSE to not perform variance scaling</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Empirical kinship matrix (IBD-based since Founders)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
pheno &lt;- get.pheno(ex_pop, gen=1:5)
geno &lt;- get.geno(ex_pop, gen=1:5)
map &lt;- get.map(ex_pop, use.snp.nr=TRUE)
real.bv.add &lt;- effect.estimate.add(geno, pheno, map)
</code></pre>

<hr>
<h2 id='effective.size'>Estimate effective population size</h2><span id='topic+effective.size'></span>

<h3>Description</h3>

<p>Internal function to estimate the effective population size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effective.size(ld, dist, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effective.size_+3A_ld">ld</code></td>
<td>
<p>ld between markers</p>
</td></tr>
<tr><td><code id="effective.size_+3A_dist">dist</code></td>
<td>
<p>distance between markers in Morgan</p>
</td></tr>
<tr><td><code id="effective.size_+3A_n">n</code></td>
<td>
<p>Population size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated effective population size
</p>

<hr>
<h2 id='epi'>Martini-Test function</h2><span id='topic+epi'></span>

<h3>Description</h3>

<p>Internal function to perform martini test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epi(y, Z, G = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epi_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code id="epi_+3A_z">Z</code></td>
<td>
<p>genomic information matrix</p>
</td></tr>
<tr><td><code id="epi_+3A_g">G</code></td>
<td>
<p>kinship matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated breeding values
</p>

<hr>
<h2 id='ex_json'>ex_json</h2><span id='topic+ex_json'></span>

<h3>Description</h3>

<p>Exemplary json-data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_json
</code></pre>


<h3>Author(s)</h3>

<p>Torsten Pook <a href="mailto:torsten.pook@uni-goettingen.de">torsten.pook@uni-goettingen.de</a>
</p>


<h3>Source</h3>

<p>Web-interface
</p>

<hr>
<h2 id='ex_pop'>ex_pop</h2><span id='topic+ex_pop'></span>

<h3>Description</h3>

<p>Exemplary population-list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_pop
</code></pre>


<h3>Author(s)</h3>

<p>Torsten Pook <a href="mailto:torsten.pook@uni-goettingen.de">torsten.pook@uni-goettingen.de</a>
</p>


<h3>Source</h3>

<p>MoBPS
</p>

<hr>
<h2 id='find.chromo'>Position detection (chromosome)</h2><span id='topic+find.chromo'></span>

<h3>Description</h3>

<p>Internal function for the detection on which chromosome each marker is
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.chromo(position, length.total)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.chromo_+3A_position">position</code></td>
<td>
<p>position in the genome</p>
</td></tr>
<tr><td><code id="find.chromo_+3A_length.total">length.total</code></td>
<td>
<p>Length of each chromosome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Chromosome the marker is part of
</p>

<hr>
<h2 id='find.snpbefore'>Position detection (SNPs)</h2><span id='topic+find.snpbefore'></span>

<h3>Description</h3>

<p>Internal function for the detection on which position each marker is
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.snpbefore(position, snp.position)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.snpbefore_+3A_position">position</code></td>
<td>
<p>Position on the genome</p>
</td></tr>
<tr><td><code id="find.snpbefore_+3A_snp.position">snp.position</code></td>
<td>
<p>Position of the SNPs on the genome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SNP-position of the target position
</p>

<hr>
<h2 id='founder.simulation'>Founder simulation</h2><span id='topic+founder.simulation'></span>

<h3>Description</h3>

<p>Function to generate founder genotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>founder.simulation(
  nindi = 100,
  sex.quota = 0.5,
  nsnp = 0,
  n.gen = 100,
  nfinal = NULL,
  sex.quota.final = NULL,
  big.output = FALSE,
  plot = TRUE,
  display.progress = TRUE,
  depth.pedigree = 7,
  dataset = NULL,
  vcf = NULL,
  chr.nr = NULL,
  bp = NULL,
  snp.name = NULL,
  hom0 = NULL,
  hom1 = NULL,
  bpcm.conversion = 0,
  freq = "beta",
  sex.s = "fixed",
  chromosome.length = NULL,
  length.before = 5,
  length.behind = 5,
  snps.equidistant = NULL,
  change.order = FALSE,
  snp.position = NULL,
  position.scaling = FALSE,
  bit.storing = FALSE,
  nbits = 30,
  randomSeed = NULL,
  miraculix = TRUE,
  miraculix.dataset = TRUE,
  template.chip = NULL,
  beta.shape1 = 1,
  beta.shape2 = 1,
  map = NULL,
  verbose = TRUE,
  vcf.maxsnp = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="founder.simulation_+3A_nindi">nindi</code></td>
<td>
<p>number of inidividuals to generate in a random dataset</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_sex.quota">sex.quota</code></td>
<td>
<p>Share of newly added female individuals (deterministic if sex.s=&quot;fixed&quot;, alt: sex.s=&quot;random&quot;)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_nsnp">nsnp</code></td>
<td>
<p>number of markers to generate in a random dataset</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_n.gen">n.gen</code></td>
<td>
<p>Number of generations to simulate (default: 100)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_nfinal">nfinal</code></td>
<td>
<p>Number of final individuals to include (default: nindi)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_sex.quota.final">sex.quota.final</code></td>
<td>
<p>Share of female individuals in the final generation</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_big.output">big.output</code></td>
<td>
<p>Set to TRUE to export map, population list and pedigree relationship</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_plot">plot</code></td>
<td>
<p>Set to FALSE to not generate LD-decay plot and allele frequency spectrum</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_display.progress">display.progress</code></td>
<td>
<p>Set FALSE to not display progress bars. Setting verbose to FALSE will automatically deactive progress bars</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_depth.pedigree">depth.pedigree</code></td>
<td>
<p>Depth of the pedigree in generations (default: 7)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_dataset">dataset</code></td>
<td>
<p>SNP dataset, use &quot;random&quot;, &quot;allhetero&quot; &quot;all0&quot; when generating a dataset via nsnp,nindi</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_vcf">vcf</code></td>
<td>
<p>Path to a vcf-file used as input genotypes (correct haplotype phase is assumed!)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_chr.nr">chr.nr</code></td>
<td>
<p>Vector containing the assosiated chromosome for each marker (default: all on the same)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_bp">bp</code></td>
<td>
<p>Vector containing the physical position (bp) for each marker (default: 1,2,3...)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_snp.name">snp.name</code></td>
<td>
<p>Vector containing the name of each marker (default ChrXSNPY - XY chosen accordingly)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_hom0">hom0</code></td>
<td>
<p>Vector containing the first allelic variant in each marker (default: 0)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_hom1">hom1</code></td>
<td>
<p>Vector containing the second allelic variant in each marker (default: 1)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_bpcm.conversion">bpcm.conversion</code></td>
<td>
<p>Convert physical position (bp) into a cM position (default: 0 - not done)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_freq">freq</code></td>
<td>
<p>frequency of allele 1 when randomly generating a dataset</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_sex.s">sex.s</code></td>
<td>
<p>Specify which newly added individuals are male (1) or female (2)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_chromosome.length">chromosome.length</code></td>
<td>
<p>Length of the newly added chromosome (default: 5)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_length.before">length.before</code></td>
<td>
<p>Length before the first SNP of the dataset (default: 5)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_length.behind">length.behind</code></td>
<td>
<p>Length after the last SNP of the dataset (default: 5)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_snps.equidistant">snps.equidistant</code></td>
<td>
<p>Use equidistant markers (computationally faster! ; default: TRUE)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_change.order">change.order</code></td>
<td>
<p>If TRUE sort markers according to given marker positions</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_snp.position">snp.position</code></td>
<td>
<p>Location of each marker on the genetic map</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_position.scaling">position.scaling</code></td>
<td>
<p>Manual scaling of snp.position</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_bit.storing">bit.storing</code></td>
<td>
<p>Set to TRUE if the MoBPS (not-miraculix! bit-storing is used)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_nbits">nbits</code></td>
<td>
<p>Bits available in MoBPS-bit-storing</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_randomseed">randomSeed</code></td>
<td>
<p>Set random seed of the process</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_miraculix">miraculix</code></td>
<td>
<p>If TRUE use miraculix package for data storage, computations and dataset generation</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_miraculix.dataset">miraculix.dataset</code></td>
<td>
<p>Set FALSE to deactive miraculix package for dataset generation</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_template.chip">template.chip</code></td>
<td>
<p>Import genetic map and chip from a species (&quot;cattle&quot;, &quot;chicken&quot;, &quot;pig&quot;)</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_beta.shape1">beta.shape1</code></td>
<td>
<p>First parameter of the beta distribution for simulating allele frequencies</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_beta.shape2">beta.shape2</code></td>
<td>
<p>Second parameter of the beta distribution for simulating allele frequencies</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_map">map</code></td>
<td>
<p>map-file that contains up to 5 colums (Chromsome, SNP-id, M-position, Bp-position, allele freq - Everything not provides it set to NA). A map can be imported via MoBPSmaps::ensembl.map()</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td></tr>
<tr><td><code id="founder.simulation_+3A_vcf.maxsnp">vcf.maxsnp</code></td>
<td>
<p>Maximum number of SNPs to include in the genotype file (default: Inf)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>population &lt;- founder.simulation(nindi=100, nsnp=1000, n.gen=5)
</code></pre>

<hr>
<h2 id='generation.individual'>Function to generate a new individual</h2><span id='topic+generation.individual'></span>

<h3>Description</h3>

<p>Function to generate a new individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generation.individual(
  indexb,
  population,
  info_father_list,
  info_mother_list,
  copy.individual,
  mutation.rate,
  remutation.rate,
  recombination.rate,
  recom.f.indicator,
  duplication.rate,
  duplication.length,
  duplication.recombination,
  delete.same.origin,
  gene.editing,
  nr.edits,
  gen.architecture.m,
  gen.architecture.f,
  decodeOriginsU,
  current.gen,
  save.recombination.history,
  new.bv.child,
  dh.mating,
  share.genotyped,
  added.genotyped,
  genotyped.array,
  dh.sex,
  n.observation
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generation.individual_+3A_indexb">indexb</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_population">population</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_info_father_list">info_father_list</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_info_mother_list">info_mother_list</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_copy.individual">copy.individual</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_mutation.rate">mutation.rate</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_remutation.rate">remutation.rate</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_recombination.rate">recombination.rate</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_recom.f.indicator">recom.f.indicator</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_duplication.rate">duplication.rate</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_duplication.length">duplication.length</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_duplication.recombination">duplication.recombination</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_delete.same.origin">delete.same.origin</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_gene.editing">gene.editing</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_nr.edits">nr.edits</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_gen.architecture.m">gen.architecture.m</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_gen.architecture.f">gen.architecture.f</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_decodeoriginsu">decodeOriginsU</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_current.gen">current.gen</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_save.recombination.history">save.recombination.history</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_new.bv.child">new.bv.child</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_dh.mating">dh.mating</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_share.genotyped">share.genotyped</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_added.genotyped">added.genotyped</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_genotyped.array">genotyped.array</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_dh.sex">dh.sex</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
<tr><td><code id="generation.individual_+3A_n.observation">n.observation</code></td>
<td>
<p>windows parallel internal test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Offspring individual
</p>

<hr>
<h2 id='get.admixture'>Admixture Plot</h2><span id='topic+get.admixture'></span>

<h3>Description</h3>

<p>Function to generate admixture plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.admixture(
  population,
  geno = NULL,
  gen = NULL,
  database = NULL,
  cohorts = NULL,
  d = NULL,
  verbose = TRUE,
  plot = TRUE,
  sort = FALSE,
  sort.cutoff = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.admixture_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.admixture_+3A_geno">geno</code></td>
<td>
<p>Manually provided genotype dataset to use instead of gen/database/cohorts</p>
</td></tr>
<tr><td><code id="get.admixture_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to consider)</p>
</td></tr>
<tr><td><code id="get.admixture_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider</p>
</td></tr>
<tr><td><code id="get.admixture_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to consider)</p>
</td></tr>
<tr><td><code id="get.admixture_+3A_d">d</code></td>
<td>
<p>dimensions to consider in admixture plot (default: automatically estimate a reasonable number)</p>
</td></tr>
<tr><td><code id="get.admixture_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td></tr>
<tr><td><code id="get.admixture_+3A_plot">plot</code></td>
<td>
<p>Set to FALSE to not generate an admixture plot</p>
</td></tr>
<tr><td><code id="get.admixture_+3A_sort">sort</code></td>
<td>
<p>Set to TRUE to sort individuals according to contributes from the first dimension</p>
</td></tr>
<tr><td><code id="get.admixture_+3A_sort.cutoff">sort.cutoff</code></td>
<td>
<p>Skip individuals with contributions under this threshold (and use next dimension instead)
data(ex_pop)
get.admixture(ex_pop, gen=4:6, d=2, sort=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with admixture proportion
</p>

<hr>
<h2 id='get.age.point'>Derive age point</h2><span id='topic+get.age.point'></span>

<h3>Description</h3>

<p>Function to devide age point for each individual (Same as time.point unless copy.individual is used for aging)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.age.point(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.age.point_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.age.point_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.age.point_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.age.point_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.age.point_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time point selected gen/database/cohorts-individuals are born
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.age.point(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.bv'>Export underlying true breeding values</h2><span id='topic+get.bv'></span>

<h3>Description</h3>

<p>Function to export underlying true breeding values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.bv(population, database = NULL, gen = NULL, cohorts = NULL, use.id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.bv_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.bv_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.bv_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.bv_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.bv_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genomic value of in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.bv(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.bve'>Export estimated breeding values</h2><span id='topic+get.bve'></span>

<h3>Description</h3>

<p>Function to export estimated breeding values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.bve(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.bve_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.bve_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.bve_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.bve_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.bve_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated breeding value of in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.bve(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.class'>Derive class</h2><span id='topic+get.class'></span>

<h3>Description</h3>

<p>Function to devide the class for each individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.class(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.class_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.class_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.class_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.class_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.class_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Class of in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.class(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.cohorts'>Export Cohort-names</h2><span id='topic+get.cohorts'></span>

<h3>Description</h3>

<p>Function to export cohort names for the population list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.cohorts(population, extended = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.cohorts_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.cohorts_+3A_extended">extended</code></td>
<td>
<p>extended cohorts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of all cohorts in the population-list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.cohorts(ex_pop)
</code></pre>

<hr>
<h2 id='get.creating.type'>Derive creating type</h2><span id='topic+get.creating.type'></span>

<h3>Description</h3>

<p>Function to devide creating type for each individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.creating.type(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.creating.type_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.creating.type_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.creating.type_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.creating.type_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.creating.type_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creating type of in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.creating.type(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.cullingtime'>Derive time of culling</h2><span id='topic+get.cullingtime'></span>

<h3>Description</h3>

<p>Function to devide the time of culling for all individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.cullingtime(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.cullingtime_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.cullingtime_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.cullingtime_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.cullingtime_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.cullingtime_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time of death of in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.cullingtime(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.database'>gen/database/cohorts conversion</h2><span id='topic+get.database'></span>

<h3>Description</h3>

<p>Function to derive a database based on gen/database/cohorts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.database(
  population,
  gen = NULL,
  database = NULL,
  cohorts = NULL,
  avoid.merging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.database_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.database_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.database_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.database_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.database_+3A_avoid.merging">avoid.merging</code></td>
<td>
<p>Set to TRUE to avoid different cohorts to be merged in a joint group when possible</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Combine gen/database/cohorts to a joined database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.database(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.death.point'>Derive death point</h2><span id='topic+get.death.point'></span>

<h3>Description</h3>

<p>Function to devide the time of death for each individual (NA for individuals that are still alive))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.death.point(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.death.point_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.death.point_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.death.point_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.death.point_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.death.point_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time of death of in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.death.point(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.dendrogram'>Dendrogram</h2><span id='topic+get.dendrogram'></span>

<h3>Description</h3>

<p>Function calculate a dendogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.dendrogram(
  population,
  path = NULL,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  method = NULL,
  individual.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.dendrogram_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.dendrogram_+3A_path">path</code></td>
<td>
<p>provide a path if the dendrogram would be saved as a png-file</p>
</td></tr>
<tr><td><code id="get.dendrogram_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider</p>
</td></tr>
<tr><td><code id="get.dendrogram_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to consider)</p>
</td></tr>
<tr><td><code id="get.dendrogram_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to consider)</p>
</td></tr>
<tr><td><code id="get.dendrogram_+3A_method">method</code></td>
<td>
<p>Method used to calculate genetic distances (default: &quot;Nei&quot;, alt: &quot;Rogers&quot;, &quot;Prevosti&quot;, &quot;Modified Rogers&quot;</p>
</td></tr>
<tr><td><code id="get.dendrogram_+3A_individual.names">individual.names</code></td>
<td>
<p>Names of the individuals in the database ((default are MoBPS internal names based on position))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dendrogram plot for genotypes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.dendrogram(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.dendrogram.heatmap'>Dendrogram Heatmap</h2><span id='topic+get.dendrogram.heatmap'></span>

<h3>Description</h3>

<p>Function calculate a dendogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.dendrogram.heatmap(
  population,
  path = NULL,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  method = NULL,
  individual.names = NULL,
  traits = NULL,
  type = "pheno"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.dendrogram.heatmap_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.dendrogram.heatmap_+3A_path">path</code></td>
<td>
<p>provide a path if the dendrogram would be saved as a png-file</p>
</td></tr>
<tr><td><code id="get.dendrogram.heatmap_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider</p>
</td></tr>
<tr><td><code id="get.dendrogram.heatmap_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to consider)</p>
</td></tr>
<tr><td><code id="get.dendrogram.heatmap_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to consider)</p>
</td></tr>
<tr><td><code id="get.dendrogram.heatmap_+3A_method">method</code></td>
<td>
<p>Method used to calculate genetic distances (default: &quot;Nei&quot;, alt: &quot;Rogers&quot;, &quot;Prevosti&quot;, &quot;Modified Rogers&quot;</p>
</td></tr>
<tr><td><code id="get.dendrogram.heatmap_+3A_individual.names">individual.names</code></td>
<td>
<p>Names of the individuals in the database ((default are MoBPS internal names based on position))</p>
</td></tr>
<tr><td><code id="get.dendrogram.heatmap_+3A_traits">traits</code></td>
<td>
<p>Traits to include in the dendrogram (default: all traits)</p>
</td></tr>
<tr><td><code id="get.dendrogram.heatmap_+3A_type">type</code></td>
<td>
<p>Which traits values to consider (default: &quot;pheno&quot;, alt: &quot;bv&quot;, &quot;bve&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dendrogram plot of genotypes vs phenotypes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>population &lt;- creating.diploid(nsnp=1000, nindi=40, n.additive = c(100,100,100),
               shuffle.cor = matrix(c(1,0.8,0.2,0.8,1,0.2,0.2,0.2,1), ncol=3), shuffle.traits = 1:3)
population &lt;- breeding.diploid(population, phenotyping = "all", heritability = 0.5)
get.dendrogram.heatmap(population, gen=1, type="pheno")
</code></pre>

<hr>
<h2 id='get.dendrogram.trait'>Dendrogram</h2><span id='topic+get.dendrogram.trait'></span>

<h3>Description</h3>

<p>Function calculate a dendogram for the traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.dendrogram.trait(
  population,
  path = NULL,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  traits = NULL,
  type = "pheno"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.dendrogram.trait_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.dendrogram.trait_+3A_path">path</code></td>
<td>
<p>provide a path if the dendrogram would be saved as a png-file</p>
</td></tr>
<tr><td><code id="get.dendrogram.trait_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider</p>
</td></tr>
<tr><td><code id="get.dendrogram.trait_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to consider)</p>
</td></tr>
<tr><td><code id="get.dendrogram.trait_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to consider)</p>
</td></tr>
<tr><td><code id="get.dendrogram.trait_+3A_traits">traits</code></td>
<td>
<p>Traits to include in the dendrogram (default: all traits)</p>
</td></tr>
<tr><td><code id="get.dendrogram.trait_+3A_type">type</code></td>
<td>
<p>Which traits values to consider (default: &quot;pheno&quot;, alt: &quot;bv&quot;, &quot;bve&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dendrogram plot for traits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>population &lt;- creating.diploid(nsnp=1000, nindi=100, n.additive = c(100,100,100),
               shuffle.cor = matrix(c(1,0.8,0.2,0.8,1,0.2,0.2,0.2,1), ncol=3), shuffle.traits = 1:3)
population &lt;- breeding.diploid(population, phenotyping = "all", heritability = 0.5)
get.dendrogram.trait(population, gen=1, type="pheno")
</code></pre>

<hr>
<h2 id='get.distance'>Calculate Nei distance between two or more population</h2><span id='topic+get.distance'></span>

<h3>Description</h3>

<p>Function to calculate Nei's distance between two or more population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.distance(
  population,
  type = "nei",
  marker = "all",
  per.marker = FALSE,
  gen1 = NULL,
  database1 = NULL,
  cohorts1 = NULL,
  gen2 = NULL,
  database2 = NULL,
  cohorts2 = NULL,
  database.list = NULL,
  gen.list = NULL,
  cohorts.list = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.distance_+3A_population">population</code></td>
<td>
<p>population list</p>
</td></tr>
<tr><td><code id="get.distance_+3A_type">type</code></td>
<td>
<p>Chose type of distance to compute (default: Neis standard genetic distance &quot;nei&quot;). Alt: Reynolds distance (&quot;reynold&quot;), Cavalli-Sforza (&quot;cavalli&quot;), Neis distance (&quot;nei_distance&quot;), Neis minimum distance (&quot;nei_minimum&quot;)</p>
</td></tr>
<tr><td><code id="get.distance_+3A_marker">marker</code></td>
<td>
<p>Vector with SNPs to consider (Default: &quot;all&quot; - use of all markers)</p>
</td></tr>
<tr><td><code id="get.distance_+3A_per.marker">per.marker</code></td>
<td>
<p>Set to TRUE to return per marker statistics on genetic distances</p>
</td></tr>
<tr><td><code id="get.distance_+3A_gen1">gen1</code></td>
<td>
<p>Quick-insert for database (vector of all generations to consider)</p>
</td></tr>
<tr><td><code id="get.distance_+3A_database1">database1</code></td>
<td>
<p>First Groups of individuals to consider</p>
</td></tr>
<tr><td><code id="get.distance_+3A_cohorts1">cohorts1</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to consider)</p>
</td></tr>
<tr><td><code id="get.distance_+3A_gen2">gen2</code></td>
<td>
<p>Quick-insert for database (vector of all generations to consider)</p>
</td></tr>
<tr><td><code id="get.distance_+3A_database2">database2</code></td>
<td>
<p>Second Groups of individuals to consider</p>
</td></tr>
<tr><td><code id="get.distance_+3A_cohorts2">cohorts2</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to consider)</p>
</td></tr>
<tr><td><code id="get.distance_+3A_database.list">database.list</code></td>
<td>
<p>List of databases to consider (use when working with more than 2 populations)</p>
</td></tr>
<tr><td><code id="get.distance_+3A_gen.list">gen.list</code></td>
<td>
<p>Quick-insert for database (vector of all generations to consider)</p>
</td></tr>
<tr><td><code id="get.distance_+3A_cohorts.list">cohorts.list</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to consider)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.distance(ex_pop, database1 = cbind(1,1), database2 = cbind(1,2))
</code></pre>

<hr>
<h2 id='get.effect.freq'>Compute marker frequency in QTL-markers</h2><span id='topic+get.effect.freq'></span>

<h3>Description</h3>

<p>Function to compute marker frequency in QTL-markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.effect.freq(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  sort = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.effect.freq_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.effect.freq_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.effect.freq_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.effect.freq_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.effect.freq_+3A_sort">sort</code></td>
<td>
<p>Set to FALSE to not sort markers according to position on the genome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with allele frequencies in the QTLs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.effect.freq(ex_pop, gen=1)
</code></pre>

<hr>
<h2 id='get.effective.size'>Estimate effective population size</h2><span id='topic+get.effective.size'></span>

<h3>Description</h3>

<p>Function to estimate the effective population size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.effective.size(population, gen = NULL, database = NULL, cohorts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.effective.size_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.effective.size_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.effective.size_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.effective.size_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated effective population size
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.effective.size(population=ex_pop, gen=5)
</code></pre>

<hr>
<h2 id='get.geno'>Derive genotypes of selected individuals</h2><span id='topic+get.geno'></span>

<h3>Description</h3>

<p>Function to devide genotypes of selected individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.geno(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  chromosomen = "all",
  export.alleles = FALSE,
  non.genotyped.as.missing = FALSE,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.geno_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.geno_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.geno_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.geno_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.geno_+3A_chromosomen">chromosomen</code></td>
<td>
<p>Beschraenkung des Genotypen auf bestimmte Chromosomen (default: 1)</p>
</td></tr>
<tr><td><code id="get.geno_+3A_export.alleles">export.alleles</code></td>
<td>
<p>If TRUE export underlying alleles instead of just 012</p>
</td></tr>
<tr><td><code id="get.geno_+3A_non.genotyped.as.missing">non.genotyped.as.missing</code></td>
<td>
<p>Set to TRUE to replace non-genotyped markers with NA</p>
</td></tr>
<tr><td><code id="get.geno_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genotype data for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
geno &lt;- get.geno(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.genotyped'>Derive genotyping status</h2><span id='topic+get.genotyped'></span>

<h3>Description</h3>

<p>Function to if selected individuals are genotyped
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.genotyped(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.genotyped_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.genotyped_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.genotyped_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.genotyped_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.genotyped_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Check if in gen/database/cohorts selected individuals are genotyped
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.genotyped(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.genotyped.snp'>Derive which markers are genotyped of selected individuals</h2><span id='topic+get.genotyped.snp'></span>

<h3>Description</h3>

<p>Function to devide which markers are genotyped for the selected individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.genotyped.snp(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  export.alleles = FALSE,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.genotyped.snp_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.genotyped.snp_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.genotyped.snp_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.genotyped.snp_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.genotyped.snp_+3A_export.alleles">export.alleles</code></td>
<td>
<p>If TRUE export underlying alleles instead of just 012</p>
</td></tr>
<tr><td><code id="get.genotyped.snp_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Binary Coded is/isnot genotyped level for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
genotyped.snps &lt;- get.genotyped.snp(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.haplo'>Derive haplotypes of selected individuals</h2><span id='topic+get.haplo'></span>

<h3>Description</h3>

<p>Function to devide haplotypes of selected individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.haplo(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  chromosomen = "all",
  export.alleles = FALSE,
  non.genotyped.as.missing = FALSE,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.haplo_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.haplo_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.haplo_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.haplo_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.haplo_+3A_chromosomen">chromosomen</code></td>
<td>
<p>Beschraenkung der Haplotypen auf bestimmte Chromosomen (default: 1)</p>
</td></tr>
<tr><td><code id="get.haplo_+3A_export.alleles">export.alleles</code></td>
<td>
<p>If TRUE export underlying alleles instead of just 012</p>
</td></tr>
<tr><td><code id="get.haplo_+3A_non.genotyped.as.missing">non.genotyped.as.missing</code></td>
<td>
<p>Set to TRUE to replace non-genotyped markers with NA</p>
</td></tr>
<tr><td><code id="get.haplo_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Haplotype data for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
haplo &lt;- get.haplo(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.id'>Derive ID on an individual</h2><span id='topic+get.id'></span>

<h3>Description</h3>

<p>Function to derive the internal ID given to each individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.id(population, database = NULL, gen = NULL, cohorts = NULL, use.id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.id_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.id_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.id_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.id_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.id_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Individual ID for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.id(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.individual.loc'>Export location of individuals from the population list</h2><span id='topic+get.individual.loc'></span>

<h3>Description</h3>

<p>Export location of individuals from the population list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.individual.loc(population, database = NULL, gen = NULL, cohorts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.individual.loc_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.individual.loc_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.individual.loc_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.individual.loc_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Storage Position for in gen/database/cohorts selected individuals (Generation/Sex/IndividualNr)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.individual.loc(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.infos'>Extract bv/pheno/geno of selected individuals</h2><span id='topic+get.infos'></span>

<h3>Description</h3>

<p>Function to extract bv/pheno/geno of selected individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.infos(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.infos_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.infos_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.infos_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.infos_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.infos_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Info list [[1]] phenotypes [[2]] genomic values [[3]] Z [[4/5/6]] additive/epistatic/dice marker effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.infos(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.map'>Map generation</h2><span id='topic+get.map'></span>

<h3>Description</h3>

<p>Function to derive the genomic map for a given population list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.map(population, use.snp.nr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.map_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.map_+3A_use.snp.nr">use.snp.nr</code></td>
<td>
<p>Set to TRUE to display SNP number and not SNP name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genomic map of the population list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
map &lt;- get.map(ex_pop)
</code></pre>

<hr>
<h2 id='get.npheno'>Export underlying number of observations per phenotype</h2><span id='topic+get.npheno'></span>

<h3>Description</h3>

<p>Function to export the number of observation of each underlying phenotype
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.npheno(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.all.copy = FALSE,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.npheno_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.npheno_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.npheno_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.npheno_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.npheno_+3A_use.all.copy">use.all.copy</code></td>
<td>
<p>Set to TRUE to extract phenotyping</p>
</td></tr>
<tr><td><code id="get.npheno_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Phenotypes for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.pheno(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.pca'>Principle components analysis</h2><span id='topic+get.pca'></span>

<h3>Description</h3>

<p>Function to perform a principle component analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pca(
  population,
  path = NULL,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  coloring = "group",
  components = c(1, 2),
  plot = TRUE,
  pch = 1,
  export.color = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pca_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.pca_+3A_path">path</code></td>
<td>
<p>Location were to save the PCA-plot</p>
</td></tr>
<tr><td><code id="get.pca_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.pca_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.pca_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.pca_+3A_coloring">coloring</code></td>
<td>
<p>Coloring by &quot;group&quot;, &quot;sex&quot;, &quot;plain&quot;</p>
</td></tr>
<tr><td><code id="get.pca_+3A_components">components</code></td>
<td>
<p>Default: c(1,2) for the first two principle components</p>
</td></tr>
<tr><td><code id="get.pca_+3A_plot">plot</code></td>
<td>
<p>Set to FALSE to not generate a plot</p>
</td></tr>
<tr><td><code id="get.pca_+3A_pch">pch</code></td>
<td>
<p>Point type in the PCA plot</p>
</td></tr>
<tr><td><code id="get.pca_+3A_export.color">export.color</code></td>
<td>
<p>Set to TRUE to export the per point coloring</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genotype data for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.pca(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.pedigree'>Derive pedigree</h2><span id='topic+get.pedigree'></span>

<h3>Description</h3>

<p>Derive pedigree for selected individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pedigree(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  founder.zero = TRUE,
  raw = FALSE,
  id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pedigree_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.pedigree_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.pedigree_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.pedigree_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.pedigree_+3A_founder.zero">founder.zero</code></td>
<td>
<p>Parents of founders are displayed as &quot;0&quot; (default: TRUE)</p>
</td></tr>
<tr><td><code id="get.pedigree_+3A_raw">raw</code></td>
<td>
<p>Set to TRUE to not convert numbers into Sex etc.</p>
</td></tr>
<tr><td><code id="get.pedigree_+3A_id">id</code></td>
<td>
<p>Set to TRUE to extract individual IDs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pedigree-file for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.pedigree(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.pedigree2'>Derive pedigree including grandparents</h2><span id='topic+get.pedigree2'></span>

<h3>Description</h3>

<p>Derive pedigree for selected individuals including grandparents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pedigree2(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  shares = FALSE,
  founder.zero = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pedigree2_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.pedigree2_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.pedigree2_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.pedigree2_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.pedigree2_+3A_shares">shares</code></td>
<td>
<p>Determine actual inherited shares of grandparents</p>
</td></tr>
<tr><td><code id="get.pedigree2_+3A_founder.zero">founder.zero</code></td>
<td>
<p>Parents of founders are displayed as &quot;0&quot; (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pedigree-file (grandparents) for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.pedigree2(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.pedigree3'>Derive pedigree parents and grandparents</h2><span id='topic+get.pedigree3'></span>

<h3>Description</h3>

<p>Derive pedigree for selected individuals including parents/grandparents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pedigree3(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  founder.zero = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pedigree3_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.pedigree3_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.pedigree3_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.pedigree3_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.pedigree3_+3A_founder.zero">founder.zero</code></td>
<td>
<p>Parents of founders are displayed as &quot;0&quot; (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pedigree-file (parents + grandparents) for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.pedigree3(ex_pop, gen=3)
</code></pre>

<hr>
<h2 id='get.pedmap'>Generate plink-file (pedmap)</h2><span id='topic+get.pedmap'></span>

<h3>Description</h3>

<p>Generate a ped and map file (PLINK format) for selected groups and chromosome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pedmap(
  population,
  path = NULL,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  non.genotyped.as.missing = FALSE,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pedmap_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.pedmap_+3A_path">path</code></td>
<td>
<p>Location to save pedmap-file</p>
</td></tr>
<tr><td><code id="get.pedmap_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.pedmap_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.pedmap_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.pedmap_+3A_non.genotyped.as.missing">non.genotyped.as.missing</code></td>
<td>
<p>Set to TRUE to replaced non-genotyped entries with &quot;./.&quot;</p>
</td></tr>
<tr><td><code id="get.pedmap_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ped and map-file for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)

file_path &lt;- tempdir()
get.pedmap(path=file_path, ex_pop, gen=2)
file.remove(paste0(file_path, ".ped"))
file.remove(paste0(file_path, ".map"))

</code></pre>

<hr>
<h2 id='get.pheno'>Export underlying phenotypes</h2><span id='topic+get.pheno'></span>

<h3>Description</h3>

<p>Function to export underlying phenotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pheno(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.all.copy = FALSE,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pheno_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.pheno_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.pheno_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.pheno_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.pheno_+3A_use.all.copy">use.all.copy</code></td>
<td>
<p>Set to TRUE to extract phenotyping</p>
</td></tr>
<tr><td><code id="get.pheno_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Phenotypes for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.pheno(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.pheno.off'>Export underlying offspring phenotypes</h2><span id='topic+get.pheno.off'></span>

<h3>Description</h3>

<p>Function to export offspring phenotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pheno.off(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pheno.off_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.pheno.off_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.pheno.off_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.pheno.off_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.pheno.off_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Avg. phenotype of the offspring of in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.pheno.off(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.pheno.off.count'>Export underlying number of used offspring for offspring phenotypes</h2><span id='topic+get.pheno.off.count'></span>

<h3>Description</h3>

<p>Function to export number of observations used for offspring phenotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pheno.off.count(population, database = NULL, gen = NULL, cohorts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pheno.off.count_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.pheno.off.count_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.pheno.off.count_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.pheno.off.count_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of offspring with phenotypes for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.pheno.off.count(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.phylogenetic.tree'>Phylogenetic Tree</h2><span id='topic+get.phylogenetic.tree'></span>

<h3>Description</h3>

<p>Function calculate a phylogenetic tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.phylogenetic.tree(
  population,
  path = NULL,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  method = NULL,
  individual.names = NULL,
  circular = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.phylogenetic.tree_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.phylogenetic.tree_+3A_path">path</code></td>
<td>
<p>provide a path if the dendrogram would be saved as a png-file</p>
</td></tr>
<tr><td><code id="get.phylogenetic.tree_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider</p>
</td></tr>
<tr><td><code id="get.phylogenetic.tree_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to consider)</p>
</td></tr>
<tr><td><code id="get.phylogenetic.tree_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to consider)</p>
</td></tr>
<tr><td><code id="get.phylogenetic.tree_+3A_method">method</code></td>
<td>
<p>Method used to calculate genetic distances (default: &quot;Nei&quot;, alt: &quot;Rogers&quot;, &quot;Prevosti&quot;, &quot;Modified Rogers&quot;</p>
</td></tr>
<tr><td><code id="get.phylogenetic.tree_+3A_individual.names">individual.names</code></td>
<td>
<p>Names of the individuals in the database ((default are MoBPS internal names based on position))</p>
</td></tr>
<tr><td><code id="get.phylogenetic.tree_+3A_circular">circular</code></td>
<td>
<p>Set to TRUE to generate a fan/circular layout tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dendrogram plot for traits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.phylogenetic.tree(ex_pop, gen=1, circular=TRUE)
</code></pre>

<hr>
<h2 id='get.qtl'>QTL extraction</h2><span id='topic+get.qtl'></span>

<h3>Description</h3>

<p>Function to the position of QTLs (for snp/chr use get.qtl.effects()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.qtl(population)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.qtl_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of SNP positions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
positions &lt;- get.qtl(ex_pop)
</code></pre>

<hr>
<h2 id='get.qtl.effects'>QTL effect extraction</h2><span id='topic+get.qtl.effects'></span>

<h3>Description</h3>

<p>Function to extract QTL effect sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.qtl.effects(population)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.qtl.effects_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with [[1]] single SNP QTLs [[2]] epistatic SNP QTLs [[3]] dice QTL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
effects &lt;- get.qtl.effects(ex_pop)
</code></pre>

<hr>
<h2 id='get.qtl.variance'>QTL effect variance extraction</h2><span id='topic+get.qtl.variance'></span>

<h3>Description</h3>

<p>Function to extract QTL effect variance for single SNP QTLs in a given gen/database/cohort
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.qtl.variance(population, gen = NULL, database = NULL, cohorts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.qtl.variance_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.qtl.variance_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to consider)</p>
</td></tr>
<tr><td><code id="get.qtl.variance_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider</p>
</td></tr>
<tr><td><code id="get.qtl.variance_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to consider)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with SNP / Chr / estimated effect variance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
effects &lt;- get.qtl.variance(ex_pop)
</code></pre>

<hr>
<h2 id='get.recombi'>Derive genetic origins</h2><span id='topic+get.recombi'></span>

<h3>Description</h3>

<p>Function to derive genetic origin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.recombi(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.recombi_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.recombi_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.recombi_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.recombi_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.recombi_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Recombination points for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.recombi(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.reliabilities'>Export underlying reliabilities</h2><span id='topic+get.reliabilities'></span>

<h3>Description</h3>

<p>Function to export underlying reliabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.reliabilities(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.reliabilities_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.reliabilities_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.reliabilities_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.reliabilities_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.reliabilities_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated reliability for BVE for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.reliabilities(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.selectionbve'>Export derived breeding values based on the selection index</h2><span id='topic+get.selectionbve'></span>

<h3>Description</h3>

<p>Function to export last breeding values based on the selection index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.selectionbve(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.selectionbve_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.selectionbve_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.selectionbve_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.selectionbve_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.selectionbve_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Last applied selection index for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.selectionindex(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.selectionindex'>Export underlying last used selection index</h2><span id='topic+get.selectionindex'></span>

<h3>Description</h3>

<p>Function to export last used selection index (mostly relevant for Miesenberger 1997 stuff)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.selectionindex(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.selectionindex_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.selectionindex_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.selectionindex_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.selectionindex_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.selectionindex_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Last applied selection index for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.selectionindex(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.time.point'>Derive time point</h2><span id='topic+get.time.point'></span>

<h3>Description</h3>

<p>Function to devide time point for each individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.time.point(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.time.point_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.time.point_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.time.point_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.time.point_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.time.point_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time point of generation for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
get.time.point(ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='get.vcf'>Generate vcf-file</h2><span id='topic+get.vcf'></span>

<h3>Description</h3>

<p>Generate a vcf-file for selected groups and chromosome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.vcf(
  population,
  path = NULL,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  chromosomen = "all",
  non.genotyped.as.missing = FALSE,
  use.id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.vcf_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="get.vcf_+3A_path">path</code></td>
<td>
<p>Location to save vcf-file</p>
</td></tr>
<tr><td><code id="get.vcf_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="get.vcf_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="get.vcf_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="get.vcf_+3A_chromosomen">chromosomen</code></td>
<td>
<p>Beschraenkung des Genotypen auf bestimmte Chromosomen (default: 1)</p>
</td></tr>
<tr><td><code id="get.vcf_+3A_non.genotyped.as.missing">non.genotyped.as.missing</code></td>
<td>
<p>Set to TRUE to replaced non-genotyped entries with &quot;./.&quot;</p>
</td></tr>
<tr><td><code id="get.vcf_+3A_use.id">use.id</code></td>
<td>
<p>Set to TRUE to use MoBPS ids instead of Sex_Nr_Gen based names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>VCF-file for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
data(ex_pop)

file_path &lt;- tempdir()
get.vcf(path=file_path, ex_pop, gen=2)
file.remove(paste0(file_path, ".vcf"))

</code></pre>

<hr>
<h2 id='group.diff'>Function to exclude individuals from a database</h2><span id='topic+group.diff'></span>

<h3>Description</h3>

<p>Function to exclude individuals from a database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.diff(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  remove.gen = NULL,
  remove.database = NULL,
  remove.cohorts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group.diff_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="group.diff_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="group.diff_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="group.diff_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="group.diff_+3A_remove.gen">remove.gen</code></td>
<td>
<p>Generations of individuals to remove from the database (same IDs!)</p>
</td></tr>
<tr><td><code id="group.diff_+3A_remove.database">remove.database</code></td>
<td>
<p>Groups of individuals to remove from the database (same IDs!)</p>
</td></tr>
<tr><td><code id="group.diff_+3A_remove.cohorts">remove.cohorts</code></td>
<td>
<p>Cohorts of individuals to remove from the database (same IDs!)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Database excluding removals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
database &lt;- group.diff(ex_pop, gen=1, remove.database=cbind(1,1))
</code></pre>

<hr>
<h2 id='insert.bve'>Manually enter estimated breeding values</h2><span id='topic+insert.bve'></span>

<h3>Description</h3>

<p>Function to manually enter estimated breeding values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert.bve(
  population,
  bves,
  type = "bve",
  na.override = FALSE,
  count = 1,
  count.only.increase = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert.bve_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="insert.bve_+3A_bves">bves</code></td>
<td>
<p>Matrix of breeding values to enter (one row per individual with 1 element coding individual name)</p>
</td></tr>
<tr><td><code id="insert.bve_+3A_type">type</code></td>
<td>
<p>which time of values to input (default: &quot;bve&quot;, alt: &quot;bv&quot;, &quot;pheno&quot;)</p>
</td></tr>
<tr><td><code id="insert.bve_+3A_na.override">na.override</code></td>
<td>
<p>Set to TRUE to also enter NA values (Default: FALSE - those entries will be skipped)</p>
</td></tr>
<tr><td><code id="insert.bve_+3A_count">count</code></td>
<td>
<p>Counting for economic cost calculation (default: 1 - (one observation (for &quot;pheno&quot;), one genotyping (for &quot;bve&quot;)))</p>
</td></tr>
<tr><td><code id="insert.bve_+3A_count.only.increase">count.only.increase</code></td>
<td>
<p>Set to FALSE to reduce the number of observation for a phenotype to &quot;count&quot; (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-List with newly entered estimated breeding values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
bv &lt;- get.bv(ex_pop, gen=2)
new.bve &lt;- cbind( colnames(bv), bv[,1]) ## Unrealistic but you do not get better than this!
ex_pop &lt;- insert.bve(ex_pop, bves=new.bve)
</code></pre>

<hr>
<h2 id='json.simulation'>Simulation of a breeding program based on a JSON-file from MoBPSweb</h2><span id='topic+json.simulation'></span>

<h3>Description</h3>

<p>Function to simulate a breeding program based on a JSON-file from MoBPSweb
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json.simulation(
  file = NULL,
  log = NULL,
  total = NULL,
  fast.mode = FALSE,
  progress.bars = FALSE,
  size.scaling = NULL,
  rep.max = 1,
  verbose = TRUE,
  miraculix.cores = NULL,
  miraculix.chol = NULL,
  skip.population = FALSE,
  time.check = FALSE,
  time.max = 7200,
  export.population = FALSE,
  export.gen = NULL,
  export.timepoint = NULL,
  fixed.generation.order = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json.simulation_+3A_file">file</code></td>
<td>
<p>Path to a json-file generated by the user-interface</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_log">log</code></td>
<td>
<p>Provide Path where to write a log-file of your simulation (or false to not write a log-file)</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_total">total</code></td>
<td>
<p>Json-file imported via jsonlite::read_json</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_fast.mode">fast.mode</code></td>
<td>
<p>Set to TRUE work on a small genome with few markers</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_progress.bars">progress.bars</code></td>
<td>
<p>Set to TRUE to display progress bars</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_size.scaling">size.scaling</code></td>
<td>
<p>Scale the size of nodes by this factor (especially for testing smaller examples)</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_rep.max">rep.max</code></td>
<td>
<p>Maximum number of repeats to use in fast.mode</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_miraculix.cores">miraculix.cores</code></td>
<td>
<p>Number of cores used in miraculix applications (default: 1)</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_miraculix.chol">miraculix.chol</code></td>
<td>
<p>Set to FALSE to manually deactive the use of miraculix for any cholesky decompostion even though miraculix is actived</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_skip.population">skip.population</code></td>
<td>
<p>Set to TRUE to not execute breeding actions (only cost/time estimation will be performed)</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_time.check">time.check</code></td>
<td>
<p>Set to TRUE to automatically check simulation run-time before executing breeding actions</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_time.max">time.max</code></td>
<td>
<p>Maximum length of the simulation in seconds when time.check is active</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_export.population">export.population</code></td>
<td>
<p>Path were to export the population to (at state selected in export.gen/timepoint)</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_export.gen">export.gen</code></td>
<td>
<p>Last generation to simulate before exporting population to file</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_export.timepoint">export.timepoint</code></td>
<td>
<p>Last timepoint to simulate before exporting population to file</p>
</td></tr>
<tr><td><code id="json.simulation_+3A_fixed.generation.order">fixed.generation.order</code></td>
<td>
<p>Vector containing the order of cohorts to generate (Advanced // Testing Parameter!)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_json)
population &lt;- json.simulation(total=ex_json)
</code></pre>

<hr>
<h2 id='kinship.development'>Devolopment of genetic/breeding value</h2><span id='topic+kinship.development'></span>

<h3>Description</h3>

<p>Function to plot genetic/breeding values for multiple generation/cohorts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship.development(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  json = FALSE,
  ibd.obs = 50,
  hbd.obs = 10,
  display.cohort.name = FALSE,
  display.time.point = FALSE,
  equal.spacing = FALSE,
  time_reorder = FALSE,
  display.hbd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinship.development_+3A_population">population</code></td>
<td>
<p>population list</p>
</td></tr>
<tr><td><code id="kinship.development_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="kinship.development_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="kinship.development_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="kinship.development_+3A_json">json</code></td>
<td>
<p>If TRUE extract which cohorts to plot according to the json-file used in json.simulation</p>
</td></tr>
<tr><td><code id="kinship.development_+3A_ibd.obs">ibd.obs</code></td>
<td>
<p>Number of Individual pairs to sample for IBD estimation</p>
</td></tr>
<tr><td><code id="kinship.development_+3A_hbd.obs">hbd.obs</code></td>
<td>
<p>Number of Individuals to sample for HBD estimation</p>
</td></tr>
<tr><td><code id="kinship.development_+3A_display.cohort.name">display.cohort.name</code></td>
<td>
<p>Set TRUE to display the name of the cohort in the x-axis</p>
</td></tr>
<tr><td><code id="kinship.development_+3A_display.time.point">display.time.point</code></td>
<td>
<p>Set TRUE to use time point of generated to sort groups</p>
</td></tr>
<tr><td><code id="kinship.development_+3A_equal.spacing">equal.spacing</code></td>
<td>
<p>Equal distance between groups (independent of time.point)</p>
</td></tr>
<tr><td><code id="kinship.development_+3A_time_reorder">time_reorder</code></td>
<td>
<p>Set TRUE to order cohorts according to the time point of generation</p>
</td></tr>
<tr><td><code id="kinship.development_+3A_display.hbd">display.hbd</code></td>
<td>
<p>Set to TRUE to also display HBD in plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated of avg. kinship/inbreeding based on IBD/HBD
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
kinship.development(ex_pop,gen=1:5)
</code></pre>

<hr>
<h2 id='kinship.emp'>Empirical kinship</h2><span id='topic+kinship.emp'></span>

<h3>Description</h3>

<p>Function to compute empirical kinship for a set of individuals)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship.emp(
  animals = NULL,
  population = NULL,
  gen = NULL,
  database = NULL,
  cohorts = NULL,
  sym = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinship.emp_+3A_animals">animals</code></td>
<td>
<p>List of animals to compute kinship for</p>
</td></tr>
<tr><td><code id="kinship.emp_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="kinship.emp_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="kinship.emp_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="kinship.emp_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="kinship.emp_+3A_sym">sym</code></td>
<td>
<p>If True derive matrix entries below principle-diagonal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Empirical kinship matrix (IBD-based since Founders)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
kinship &lt;- kinship.emp(population=ex_pop, database=cbind(2,1,1,25))
</code></pre>

<hr>
<h2 id='kinship.emp.fast'>Approximate empirical kinship</h2><span id='topic+kinship.emp.fast'></span>

<h3>Description</h3>

<p>Function to compute empirical kinship for a set of individuals (not all pairs of individuals are evaluated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship.emp.fast(
  animals = NULL,
  population = NULL,
  gen = NULL,
  database = NULL,
  cohorts = NULL,
  sym = FALSE,
  ibd.obs = 50,
  hbd.obs = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinship.emp.fast_+3A_animals">animals</code></td>
<td>
<p>List of animals to compute kinship for</p>
</td></tr>
<tr><td><code id="kinship.emp.fast_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="kinship.emp.fast_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="kinship.emp.fast_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="kinship.emp.fast_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="kinship.emp.fast_+3A_sym">sym</code></td>
<td>
<p>If True derive matrix entries below principle-diagonal</p>
</td></tr>
<tr><td><code id="kinship.emp.fast_+3A_ibd.obs">ibd.obs</code></td>
<td>
<p>Number of Individual pairs to sample for IBD estimation</p>
</td></tr>
<tr><td><code id="kinship.emp.fast_+3A_hbd.obs">hbd.obs</code></td>
<td>
<p>Number of Individuals to sample for HBD estimation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Empirical kinship matrix (IBD-based since Founders) per gen/database/cohort
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
kinship.emp.fast(population=ex_pop,gen=2)
</code></pre>

<hr>
<h2 id='kinship.exp'>Derive expected kinship</h2><span id='topic+kinship.exp'></span>

<h3>Description</h3>

<p>Function to derive expected kinship
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship.exp(
  population,
  gen = NULL,
  database = NULL,
  cohorts = NULL,
  depth.pedigree = 7,
  start.kinship = NULL,
  elements = NULL,
  mult = 2,
  storage.save = 1.5,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinship.exp_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="kinship.exp_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="kinship.exp_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="kinship.exp_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="kinship.exp_+3A_depth.pedigree">depth.pedigree</code></td>
<td>
<p>Depth of the pedigree in generations</p>
</td></tr>
<tr><td><code id="kinship.exp_+3A_start.kinship">start.kinship</code></td>
<td>
<p>Relationship matrix of the individuals in the first considered generation</p>
</td></tr>
<tr><td><code id="kinship.exp_+3A_elements">elements</code></td>
<td>
<p>Vector of individuals from the database to include in pedigree matrix</p>
</td></tr>
<tr><td><code id="kinship.exp_+3A_mult">mult</code></td>
<td>
<p>Multiplicator of kinship matrix (default: 2)</p>
</td></tr>
<tr><td><code id="kinship.exp_+3A_storage.save">storage.save</code></td>
<td>
<p>Lower numbers will lead to less memory but slightly higher computing time (default: 1.5, min: 1)</p>
</td></tr>
<tr><td><code id="kinship.exp_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pedigree-based kinship matrix for in gen/database/cohort selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
kinship &lt;- kinship.exp(population=ex_pop, gen=2)
</code></pre>

<hr>
<h2 id='ld.decay'>Generate LD plot</h2><span id='topic+ld.decay'></span>

<h3>Description</h3>

<p>Generate LD pot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ld.decay(
  population,
  genotype.dataset = NULL,
  chromosomen = 1,
  dist = NULL,
  step = 5,
  max = 500,
  max.cases = 100,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  type = "snp",
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ld.decay_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="ld.decay_+3A_genotype.dataset">genotype.dataset</code></td>
<td>
<p>Genotype dataset (default: NULL - just to save computation time when get.geno was already run)</p>
</td></tr>
<tr><td><code id="ld.decay_+3A_chromosomen">chromosomen</code></td>
<td>
<p>Only consider a specific chromosome in calculations (default: 1)</p>
</td></tr>
<tr><td><code id="ld.decay_+3A_dist">dist</code></td>
<td>
<p>Manuel input of marker distances to analyse</p>
</td></tr>
<tr><td><code id="ld.decay_+3A_step">step</code></td>
<td>
<p>Stepsize to calculate LD</p>
</td></tr>
<tr><td><code id="ld.decay_+3A_max">max</code></td>
<td>
<p>Maximum distance between markers to consider for LD-plot</p>
</td></tr>
<tr><td><code id="ld.decay_+3A_max.cases">max.cases</code></td>
<td>
<p>Maximum number of marker pairs to consider of each distance (default: 100; randomly sampled!)</p>
</td></tr>
<tr><td><code id="ld.decay_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="ld.decay_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="ld.decay_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="ld.decay_+3A_type">type</code></td>
<td>
<p>Compute LD decay according to following distance measure between markers (default: &quot;snp&quot;, alt: &quot;bp&quot;, &quot;cM&quot;)</p>
</td></tr>
<tr><td><code id="ld.decay_+3A_plot">plot</code></td>
<td>
<p>Set to FALSE to not generate an LD plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LD-decay plot for in gen/database/cohorts selected individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
ld.decay(population=ex_pop, gen=5)
</code></pre>

<hr>
<h2 id='maize_chip'>maize chip</h2><span id='topic+maize_chip'></span>

<h3>Description</h3>

<p>Genome for maize according to Lee et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maize_chip
</code></pre>


<h3>Author(s)</h3>

<p>Torsten Pook <a href="mailto:torsten.pook@uni-goettingen.de">torsten.pook@uni-goettingen.de</a>
</p>


<h3>Source</h3>

<p>Lee et al 2002
</p>

<hr>
<h2 id='miesenberger.index'>Miesenberger Index</h2><span id='topic+miesenberger.index'></span>

<h3>Description</h3>

<p>Function to selection index weights according to Miesenberger 1997
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miesenberger.index(V, G, V1 = NULL, RG = NULL, r, w, zw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miesenberger.index_+3A_v">V</code></td>
<td>
<p>Phenotypic covarianz matrix</p>
</td></tr>
<tr><td><code id="miesenberger.index_+3A_g">G</code></td>
<td>
<p>Genomic covarianz matrix</p>
</td></tr>
<tr><td><code id="miesenberger.index_+3A_v1">V1</code></td>
<td>
<p>Inverted phenotypic covarianz matrix</p>
</td></tr>
<tr><td><code id="miesenberger.index_+3A_rg">RG</code></td>
<td>
<p>Genomic correlation matrix</p>
</td></tr>
<tr><td><code id="miesenberger.index_+3A_r">r</code></td>
<td>
<p>reliability for the breeding value estimation</p>
</td></tr>
<tr><td><code id="miesenberger.index_+3A_w">w</code></td>
<td>
<p>relative weighting of each trait (per genetic SD)</p>
</td></tr>
<tr><td><code id="miesenberger.index_+3A_zw">zw</code></td>
<td>
<p>Estimated breeding value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>weights of the selection index
</p>

<hr>
<h2 id='miraculix'>Add miraculix-coding for genotypes</h2><span id='topic+miraculix'></span>

<h3>Description</h3>

<p>Internal function to store genotypes bit-wise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miraculix(population)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miraculix_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population list
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is only relevant with the package miraculix is installed and used
population &lt;- creating.diploid(nsnp=100, nindi=50, miraculix=FALSE)
population &lt;- miraculix(population)
</code></pre>

<hr>
<h2 id='mutation.intro'>Mutation intro</h2><span id='topic+mutation.intro'></span>

<h3>Description</h3>

<p>Function to change the base-pair in a specific loci
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation.intro(population, gen, sex, individual.nr, qtl.posi, haplo.set = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutation.intro_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="mutation.intro_+3A_gen">gen</code></td>
<td>
<p>Generation of the individual to introduce a mutation in</p>
</td></tr>
<tr><td><code id="mutation.intro_+3A_sex">sex</code></td>
<td>
<p>Sex of the individual to introduce a mutation in</p>
</td></tr>
<tr><td><code id="mutation.intro_+3A_individual.nr">individual.nr</code></td>
<td>
<p>Individual Nr. of the individual to introduce a mutation in</p>
</td></tr>
<tr><td><code id="mutation.intro_+3A_qtl.posi">qtl.posi</code></td>
<td>
<p>Marker number to mutate</p>
</td></tr>
<tr><td><code id="mutation.intro_+3A_haplo.set">haplo.set</code></td>
<td>
<p>Select chromosome set (default: 1 , alt: 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-List with mutated marker for the selected individual
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
ex_pop &lt;- mutation.intro(ex_pop, 1,1,1, qtl.posi=100)
</code></pre>

<hr>
<h2 id='new.base.generation'>Set new base generation</h2><span id='topic+new.base.generation'></span>

<h3>Description</h3>

<p>Function to set a new base generation for the population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.base.generation(
  population,
  base.gen = NULL,
  delete.previous.gen = FALSE,
  delete.breeding.totals = FALSE,
  delete.bve.data = FALSE,
  add.chromosome.ends = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new.base.generation_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="new.base.generation_+3A_base.gen">base.gen</code></td>
<td>
<p>Vector containing all new base generations</p>
</td></tr>
<tr><td><code id="new.base.generation_+3A_delete.previous.gen">delete.previous.gen</code></td>
<td>
<p>Delete all data before base.gen (default: FALSE)</p>
</td></tr>
<tr><td><code id="new.base.generation_+3A_delete.breeding.totals">delete.breeding.totals</code></td>
<td>
<p>Delete all breeding totals before base.gen (default: FALSE)</p>
</td></tr>
<tr><td><code id="new.base.generation_+3A_delete.bve.data">delete.bve.data</code></td>
<td>
<p>Deleta all previous bve data (default: FALSE)</p>
</td></tr>
<tr><td><code id="new.base.generation_+3A_add.chromosome.ends">add.chromosome.ends</code></td>
<td>
<p>Add chromosome ends as recombination points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-List with mutated marker for the selected individual
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
ex_pop &lt;- new.base.generation(ex_pop, base.gen=2)
</code></pre>

<hr>
<h2 id='OGC'>Optimal genetic contribution</h2><span id='topic+OGC'></span>

<h3>Description</h3>

<p>In this function the OGC selection according to Meuwissen 1997 is performed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OGC(
  A,
  u,
  Q,
  cAc = NA,
  single = TRUE,
  verbose = FALSE,
  max_male = Inf,
  max_female = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OGC_+3A_a">A</code></td>
<td>
<p>relationship matrix</p>
</td></tr>
<tr><td><code id="OGC_+3A_u">u</code></td>
<td>
<p>breeding values</p>
</td></tr>
<tr><td><code id="OGC_+3A_q">Q</code></td>
<td>
<p>sex indicator</p>
</td></tr>
<tr><td><code id="OGC_+3A_cac">cAc</code></td>
<td>
<p>target gain in inbreeding</p>
</td></tr>
<tr><td><code id="OGC_+3A_single">single</code></td>
<td>
<p>If FALSE multiple individuals can be removed at the same type (this is faster but potentially inaccurate!)</p>
</td></tr>
<tr><td><code id="OGC_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td></tr>
<tr><td><code id="OGC_+3A_max_male">max_male</code></td>
<td>
<p>maximum number of male with positive contributions</p>
</td></tr>
<tr><td><code id="OGC_+3A_max_female">max_female</code></td>
<td>
<p>maximum number of females with positive contributions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[[1]] Contributions [[2]] expected inbreeding gain
</p>

<hr>
<h2 id='pedigree.simulation'>Simulation of a given pedigree</h2><span id='topic+pedigree.simulation'></span>

<h3>Description</h3>

<p>Function to simulate a given pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigree.simulation(
  pedigree,
  keep.ids = FALSE,
  plot = TRUE,
  dataset = NULL,
  vcf = NULL,
  chr.nr = NULL,
  bp = NULL,
  snp.name = NULL,
  hom0 = NULL,
  hom1 = NULL,
  bpcm.conversion = 0,
  nsnp = 0,
  freq = "beta",
  sex.s = "fixed",
  chromosome.length = NULL,
  length.before = 5,
  length.behind = 5,
  real.bv.add = NULL,
  real.bv.mult = NULL,
  real.bv.dice = NULL,
  snps.equidistant = NULL,
  change.order = FALSE,
  bv.total = 0,
  polygenic.variance = 100,
  bve.mult.factor = NULL,
  bve.poly.factor = NULL,
  base.bv = NULL,
  add.chromosome.ends = TRUE,
  new.phenotype.correlation = NULL,
  new.residual.correlation = NULL,
  new.breeding.correlation = NULL,
  add.architecture = NULL,
  snp.position = NULL,
  position.scaling = FALSE,
  bit.storing = FALSE,
  nbits = 30,
  randomSeed = NULL,
  miraculix = TRUE,
  miraculix.dataset = TRUE,
  n.additive = 0,
  n.dominant = 0,
  n.qualitative = 0,
  n.quantitative = 0,
  var.additive.l = NULL,
  var.dominant.l = NULL,
  var.qualitative.l = NULL,
  var.quantitative.l = NULL,
  exclude.snps = NULL,
  replace.real.bv = FALSE,
  shuffle.traits = NULL,
  shuffle.cor = NULL,
  skip.rest = FALSE,
  enter.bv = TRUE,
  name.cohort = NULL,
  template.chip = NULL,
  beta.shape1 = 1,
  beta.shape2 = 1,
  time.point = 0,
  creating.type = 0,
  trait.name = NULL,
  share.genotyped = 1,
  genotyped.s = NULL,
  map = NULL,
  remove.invalid.qtl = TRUE,
  verbose = TRUE,
  bv.standard = FALSE,
  mean.target = NULL,
  var.target = NULL,
  is.maternal = NULL,
  is.paternal = NULL,
  vcf.maxsnp = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedigree.simulation_+3A_pedigree">pedigree</code></td>
<td>
<p>Pedigree-file (matrix with 3 columns (Individual ID, Father ID, Mother ID), optional forth columns with earliest generations to generate an individual)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_keep.ids">keep.ids</code></td>
<td>
<p>Set to TRUE to keep the IDs from the pedigree-file instead of the default MoBPS ids</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_plot">plot</code></td>
<td>
<p>Set to FALSE to not generate an overview of inbreeding and number of individuals over time</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_dataset">dataset</code></td>
<td>
<p>SNP dataset, use &quot;random&quot;, &quot;allhetero&quot; &quot;all0&quot; when generating a dataset via nsnp,nindi</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_vcf">vcf</code></td>
<td>
<p>Path to a vcf-file used as input genotypes (correct haplotype phase is assumed!)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_chr.nr">chr.nr</code></td>
<td>
<p>Vector containing the assosiated chromosome for each marker (default: all on the same)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_bp">bp</code></td>
<td>
<p>Vector containing the physical position (bp) for each marker (default: 1,2,3...)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_snp.name">snp.name</code></td>
<td>
<p>Vector containing the name of each marker (default ChrXSNPY - XY chosen accordingly)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_hom0">hom0</code></td>
<td>
<p>Vector containing the first allelic variant in each marker (default: 0)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_hom1">hom1</code></td>
<td>
<p>Vector containing the second allelic variant in each marker (default: 1)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_bpcm.conversion">bpcm.conversion</code></td>
<td>
<p>Convert physical position (bp) into a cM position (default: 0 - not done)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_nsnp">nsnp</code></td>
<td>
<p>number of markers to generate in a random dataset</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_freq">freq</code></td>
<td>
<p>frequency of allele 1 when randomly generating a dataset</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_sex.s">sex.s</code></td>
<td>
<p>Specify which newly added individuals are male (1) or female (2)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_chromosome.length">chromosome.length</code></td>
<td>
<p>Length of the newly added chromosome (default: 5)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_length.before">length.before</code></td>
<td>
<p>Length before the first SNP of the dataset (default: 5)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_length.behind">length.behind</code></td>
<td>
<p>Length after the last SNP of the dataset (default: 5)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_real.bv.add">real.bv.add</code></td>
<td>
<p>Single Marker effects</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_real.bv.mult">real.bv.mult</code></td>
<td>
<p>Two Marker effects</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_real.bv.dice">real.bv.dice</code></td>
<td>
<p>Multi-marker effects</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_snps.equidistant">snps.equidistant</code></td>
<td>
<p>Use equidistant markers (computationally faster! ; default: TRUE)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_change.order">change.order</code></td>
<td>
<p>If TRUE sort markers according to given marker positions</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_bv.total">bv.total</code></td>
<td>
<p>Number of traits (If more than traits via real.bv.X use traits with no directly underlying QTL)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_polygenic.variance">polygenic.variance</code></td>
<td>
<p>Genetic variance of traits with no underlying QTL</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_bve.mult.factor">bve.mult.factor</code></td>
<td>
<p>Multiplicate trait value times this</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_bve.poly.factor">bve.poly.factor</code></td>
<td>
<p>Potency trait value over this</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_base.bv">base.bv</code></td>
<td>
<p>Average genetic value of a trait</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_add.chromosome.ends">add.chromosome.ends</code></td>
<td>
<p>Add chromosome ends as recombination points</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_new.phenotype.correlation">new.phenotype.correlation</code></td>
<td>
<p>(OLD! - use new.residual.correlation) Correlation of the simulated enviromental variance</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_new.residual.correlation">new.residual.correlation</code></td>
<td>
<p>Correlation of the simulated enviromental variance</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_new.breeding.correlation">new.breeding.correlation</code></td>
<td>
<p>Correlation of the simulated genetic variance (child share! heritage is not influenced!</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_add.architecture">add.architecture</code></td>
<td>
<p>Add genetic architecture (marker positions)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_snp.position">snp.position</code></td>
<td>
<p>Location of each marker on the genetic map</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_position.scaling">position.scaling</code></td>
<td>
<p>Manual scaling of snp.position</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_bit.storing">bit.storing</code></td>
<td>
<p>Set to TRUE if the MoBPS (not-miraculix! bit-storing is used)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_nbits">nbits</code></td>
<td>
<p>Bits available in MoBPS-bit-storing</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_randomseed">randomSeed</code></td>
<td>
<p>Set random seed of the process</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_miraculix">miraculix</code></td>
<td>
<p>If TRUE use miraculix package for data storage, computations and dataset generation</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_miraculix.dataset">miraculix.dataset</code></td>
<td>
<p>Set FALSE to deactive miraculix package for dataset generation</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_n.additive">n.additive</code></td>
<td>
<p>Number of additive QTL</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_n.dominant">n.dominant</code></td>
<td>
<p>Number of dominante QTL</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_n.qualitative">n.qualitative</code></td>
<td>
<p>Number of qualitative epistatic QTL</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_n.quantitative">n.quantitative</code></td>
<td>
<p>Number of quantitative epistatic QTL</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_var.additive.l">var.additive.l</code></td>
<td>
<p>Variance of additive QTL</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_var.dominant.l">var.dominant.l</code></td>
<td>
<p>Variance of dominante QTL</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_var.qualitative.l">var.qualitative.l</code></td>
<td>
<p>Variance of qualitative epistatic QTL</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_var.quantitative.l">var.quantitative.l</code></td>
<td>
<p>Variance of quantitative epistatic QTL</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_exclude.snps">exclude.snps</code></td>
<td>
<p>Marker were no QTL are simulated on</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_replace.real.bv">replace.real.bv</code></td>
<td>
<p>If TRUE delete the simulated traits added before</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_shuffle.traits">shuffle.traits</code></td>
<td>
<p>Combine different traits into a joined trait</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_shuffle.cor">shuffle.cor</code></td>
<td>
<p>Target Correlation between shuffeled traits</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_skip.rest">skip.rest</code></td>
<td>
<p>Internal variable needed when adding multipe chromosomes jointly</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_enter.bv">enter.bv</code></td>
<td>
<p>Internal parameter</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_name.cohort">name.cohort</code></td>
<td>
<p>Name of the newly added cohort</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_template.chip">template.chip</code></td>
<td>
<p>Import genetic map and chip from a species (&quot;cattle&quot;, &quot;chicken&quot;, &quot;pig&quot;)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_beta.shape1">beta.shape1</code></td>
<td>
<p>First parameter of the beta distribution for simulating allele frequencies</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_beta.shape2">beta.shape2</code></td>
<td>
<p>Second parameter of the beta distribution for simulating allele frequencies</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_time.point">time.point</code></td>
<td>
<p>Time point at which the new individuals are generated</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_creating.type">creating.type</code></td>
<td>
<p>Technique to generate new individuals (usage in web-based application)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_trait.name">trait.name</code></td>
<td>
<p>Name of the trait generated</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_share.genotyped">share.genotyped</code></td>
<td>
<p>Share of individuals genotyped in the founders</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_genotyped.s">genotyped.s</code></td>
<td>
<p>Specify with newly added individuals are genotyped (1) or not (0)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_map">map</code></td>
<td>
<p>map-file that contains up to 5 colums (Chromsome, SNP-id, M-position, Bp-position, allele freq - Everything not provides it set to NA). A map can be imported via MoBPSmaps::ensembl.map()</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_remove.invalid.qtl">remove.invalid.qtl</code></td>
<td>
<p>Set to FALSE to deactive the automatic removal of QTLs on markers that do not exist</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_bv.standard">bv.standard</code></td>
<td>
<p>Set TRUE to standardize trait mean and variance via bv.standardization() - automatically set to TRUE when mean/var.target are used</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_mean.target">mean.target</code></td>
<td>
<p>Target mean</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_var.target">var.target</code></td>
<td>
<p>Target variance</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_is.maternal">is.maternal</code></td>
<td>
<p>Vector coding if a trait is caused by a maternal effect (Default: all FALSE)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_is.paternal">is.paternal</code></td>
<td>
<p>Vector coding if a trait is caused by a paternal effect (Default: all FALSE)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_vcf.maxsnp">vcf.maxsnp</code></td>
<td>
<p>Maximum number of SNPs to include in the genotype file (default: Inf)</p>
</td></tr>
<tr><td><code id="pedigree.simulation_+3A_add.chromosome">add.chromosome</code></td>
<td>
<p>If TRUE add an additional chromosome to the dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pedigree &lt;- matrix(c(1,0,0,
2,0,0,
3,0,0,
4,1,2,
5,1,3,
6,1,3,
7,1,3,
8,4,6,
9,4,7), ncol=3, byrow=TRUE)
population &lt;- pedigree.simulation(pedigree, nsnp=1000)
</code></pre>

<hr>
<h2 id='pedmap.to.phasedbeaglevcf'>Internal function to perform imputing/phasing</h2><span id='topic+pedmap.to.phasedbeaglevcf'></span>

<h3>Description</h3>

<p>Internal function to perform imputing/phasing (path chosen for the web-based application)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedmap.to.phasedbeaglevcf(
  ped_path = NULL,
  map_path = NULL,
  vcf_path = NULL,
  beagle_jar = "/home/nha/beagle.03Jul18.40b.jar",
  plink_dir = "/home/nha/Plink/plink",
  db_dir = "/home/nha/Plink/DB/",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedmap.to.phasedbeaglevcf_+3A_ped_path">ped_path</code></td>
<td>
<p>Directory of the ped-file</p>
</td></tr>
<tr><td><code id="pedmap.to.phasedbeaglevcf_+3A_map_path">map_path</code></td>
<td>
<p>Directory of the map-file</p>
</td></tr>
<tr><td><code id="pedmap.to.phasedbeaglevcf_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Directory of the vcf-file (this will override any ped/map-file input)</p>
</td></tr>
<tr><td><code id="pedmap.to.phasedbeaglevcf_+3A_beagle_jar">beagle_jar</code></td>
<td>
<p>Directory of BEAGLE</p>
</td></tr>
<tr><td><code id="pedmap.to.phasedbeaglevcf_+3A_plink_dir">plink_dir</code></td>
<td>
<p>Directory of Plink</p>
</td></tr>
<tr><td><code id="pedmap.to.phasedbeaglevcf_+3A_db_dir">db_dir</code></td>
<td>
<p>Directory to save newly generated files (ped/map will be stored in the original folder)</p>
</td></tr>
<tr><td><code id="pedmap.to.phasedbeaglevcf_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Phased vcf file in vcf_path
</p>

<hr>
<h2 id='pig_chip'>pig chip</h2><span id='topic+pig_chip'></span>

<h3>Description</h3>

<p>Genome for pig according to Rohrer et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pig_chip
</code></pre>


<h3>Author(s)</h3>

<p>Torsten Pook <a href="mailto:torsten.pook@uni-goettingen.de">torsten.pook@uni-goettingen.de</a>
</p>


<h3>Source</h3>

<p>Rohrer et al 1994
</p>

<hr>
<h2 id='plot.population'>Plot Population</h2><span id='topic+plot.population'></span>

<h3>Description</h3>

<p>Basic plot of the population list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'population'
plot(x, type = "bve", gen = NULL, database = NULL, cohorts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.population_+3A_x">x</code></td>
<td>
<p>Population-list</p>
</td></tr>
<tr><td><code id="plot.population_+3A_type">type</code></td>
<td>
<p>Default &quot;bve&quot; - bv.development, alt: &quot;kinship&quot; - kinship.development(), &quot;pca&quot; - get.pca()</p>
</td></tr>
<tr><td><code id="plot.population_+3A_gen">gen</code></td>
<td>
<p>generations to consider</p>
</td></tr>
<tr><td><code id="plot.population_+3A_database">database</code></td>
<td>
<p>groups to consider</p>
</td></tr>
<tr><td><code id="plot.population_+3A_cohorts">cohorts</code></td>
<td>
<p>cohorts to consider</p>
</td></tr>
<tr><td><code id="plot.population_+3A_...">...</code></td>
<td>
<p>remaining stuff</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary of the population list including number of individuals, genone length and trait overview
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
plot(ex_pop)
</code></pre>

<hr>
<h2 id='set.class'>Export estimated breeding values</h2><span id='topic+set.class'></span>

<h3>Description</h3>

<p>Function to export estimated breeding values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.class(
  population,
  database = NULL,
  gen = NULL,
  cohorts = NULL,
  new.class = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.class_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="set.class_+3A_database">database</code></td>
<td>
<p>Groups of individuals to consider for the export</p>
</td></tr>
<tr><td><code id="set.class_+3A_gen">gen</code></td>
<td>
<p>Quick-insert for database (vector of all generations to export)</p>
</td></tr>
<tr><td><code id="set.class_+3A_cohorts">cohorts</code></td>
<td>
<p>Quick-insert for database (vector of names of cohorts to export)</p>
</td></tr>
<tr><td><code id="set.class_+3A_new.class">new.class</code></td>
<td>
<p>Class to change to (either single character or vector for each individual when just a single group is selected)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-List with newly entered class values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
population &lt;- set.class(ex_pop, database=cbind(1,1), new.class = 2)
</code></pre>

<hr>
<h2 id='set.default'>Set defaults</h2><span id='topic+set.default'></span>

<h3>Description</h3>

<p>Set default parameter values in breeding.diploid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.default(
  population,
  parameter.name = NULL,
  parameter.value = NULL,
  parameter.remove = NULL,
  reset.all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.default_+3A_population">population</code></td>
<td>
<p>Population list</p>
</td></tr>
<tr><td><code id="set.default_+3A_parameter.name">parameter.name</code></td>
<td>
<p>Number of traits (If more than traits via real.bv.X use traits with no directly underlying QTL)</p>
</td></tr>
<tr><td><code id="set.default_+3A_parameter.value">parameter.value</code></td>
<td>
<p>Genetic variance of traits with no underlying QTL</p>
</td></tr>
<tr><td><code id="set.default_+3A_parameter.remove">parameter.remove</code></td>
<td>
<p>Remove a specific previously generated parameter default</p>
</td></tr>
<tr><td><code id="set.default_+3A_reset.all">reset.all</code></td>
<td>
<p>Set to TRUE to remove all prior parameter values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Population-list with one or more additional new traits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
population &lt;- set.default(ex_pop, parameter.name="heritability", parameter.value=0.3)
</code></pre>

<hr>
<h2 id='sheep_chip'>sheep chip</h2><span id='topic+sheep_chip'></span>

<h3>Description</h3>

<p>Genome for sheep according to Prieur et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheep_chip
</code></pre>


<h3>Author(s)</h3>

<p>Torsten Pook <a href="mailto:torsten.pook@uni-goettingen.de">torsten.pook@uni-goettingen.de</a>
</p>


<h3>Source</h3>

<p>Prieur et al 2017
</p>

<hr>
<h2 id='sortd'>Apply sort and unique</h2><span id='topic+sortd'></span>

<h3>Description</h3>

<p>Efficient function to perform sort(unique(v))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortd(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortd_+3A_v">v</code></td>
<td>
<p>Vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical sorted vector without duplicates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c(1,1,4,5)
sortd(v)
</code></pre>

<hr>
<h2 id='ssGBLUP'>Single Step GBLUP</h2><span id='topic+ssGBLUP'></span>

<h3>Description</h3>

<p>Function to perform single step GBLUP according to Legarra 2014
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssGBLUP(A11, A12, A22, G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssGBLUP_+3A_a11">A11</code></td>
<td>
<p>pedigree relationship matrix of non-genotyped individuals</p>
</td></tr>
<tr><td><code id="ssGBLUP_+3A_a12">A12</code></td>
<td>
<p>pedigree relationship matrix between non-genotyped and genotyped individuals</p>
</td></tr>
<tr><td><code id="ssGBLUP_+3A_a22">A22</code></td>
<td>
<p>pedigree relationship matrix of genotyped individuals</p>
</td></tr>
<tr><td><code id="ssGBLUP_+3A_g">G</code></td>
<td>
<p>genomic relationship matrix of genotyped individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single step relationship matrix
</p>

<hr>
<h2 id='summary.population'>Summary Population</h2><span id='topic+summary.population'></span>

<h3>Description</h3>

<p>Summary of the population list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'population'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.population_+3A_object">object</code></td>
<td>
<p>Population-list</p>
</td></tr>
<tr><td><code id="summary.population_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary of the population list including number of individuals, genone length and trait overview
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
summary(ex_pop)
</code></pre>

<hr>
<h2 id='vlist'>Generation of a sublist</h2><span id='topic+vlist'></span>

<h3>Description</h3>

<p>Internal function to write a couple of list entries in a new list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vlist(list, skip = NULL, first = NULL, select = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vlist_+3A_list">list</code></td>
<td>
<p>list you want to print details of</p>
</td></tr>
<tr><td><code id="vlist_+3A_skip">skip</code></td>
<td>
<p>Skip first that many list-elements</p>
</td></tr>
<tr><td><code id="vlist_+3A_first">first</code></td>
<td>
<p>Only display first that many list-elements</p>
</td></tr>
<tr><td><code id="vlist_+3A_select">select</code></td>
<td>
<p>Display only selected list-elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Selected elements of a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex_pop)
vlist(ex_pop$breeding[[1]], select=3:10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
