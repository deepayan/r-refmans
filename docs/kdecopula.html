<!DOCTYPE html><html><head><title>Help for package kdecopula</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kdecopula}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#kdecopula'><p>Kernel Smoothing for Bivariate Copula Densities</p></a></li>
<li><a href='#bw_bern'><p>Bandwidth selection for the Bernstein copula estimator</p></a></li>
<li><a href='#bw_beta'><p>Bandwidth selection for the beta kernel estimator</p></a></li>
<li><a href='#bw_mr'><p>Bandwidth selection for the mirror-reflection estimator</p></a></li>
<li><a href='#bw_t'><p>Bandwidth selection for the transformation kernel estimator</p></a></li>
<li><a href='#bw_tll'><p>Bandwidth selection for the transformation local likelihood estimator</p></a></li>
<li><a href='#bw_tll_nn'><p>Nearest-neighbor bandwidth selection for the transformation local likelihood</p>
estimator</a></li>
<li><a href='#bw_tt_pi'><p>Nearest-neighbor bandwidth selection for the tapered transformation estimator</p></a></li>
<li><a href='#dep_measures'><p>Dependence measures of a <code>kdecop()</code> fit</p></a></li>
<li><a href='#dkdecop'><p>Working with <code>kdecopula</code> objects</p></a></li>
<li><a href='#fitted.kdecopula'><p>Extract fitted values from a <code>kdecop()</code> fits.</p></a></li>
<li><a href='#hkdecop'><p>H-function and inverse of a <code>kdecop()</code> fit</p></a></li>
<li><a href='#kdecop'><p>Bivariate kernel copula density estimation</p></a></li>
<li><a href='#logLik.kdecopula'><p>Log-Likelihood of a <code>kdecopula</code> object</p></a></li>
<li><a href='#plot.kdecopula'><p>Plotting <code>kdecopula</code> objects</p></a></li>
<li><a href='#predict.kdecopula'><p>Prediction method for <code>kdecop()</code> fits</p></a></li>
<li><a href='#simulate.kdecopula'><p>Simulate data from a <code>kdecop()</code> fit.</p></a></li>
<li><a href='#wdbc'><p>Wisconsin Diagnostic Breast Cancer (WDBC)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kernel Smoothing for Bivariate Copula Densities</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides fast implementations of kernel smoothing techniques for
    bivariate copula densities, in particular density estimation and resampling,
    see Nagler (2018) &lt;<a href="https://doi.org/10.18637%2Fjss.v084.i07">doi:10.18637/jss.v084.i07</a>&gt;. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tnagler/kdecopula">https://github.com/tnagler/kdecopula</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tnagler/kdecopula/issues">https://github.com/tnagler/kdecopula/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, locfit, qrng, Rcpp (&ge; 0.11.2), graphics, grDevices,
stats, utils, quadprog</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, VineCopula, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-04-09 13:08:35 UTC; n5</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Nagler [aut, cre],
  Kuangyu Wen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Nagler &lt;thomas.nagler@tum.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-04-09 22:33:46 UTC</td>
</tr>
</table>
<hr>
<h2 id='kdecopula'>Kernel Smoothing for Bivariate Copula Densities</h2><span id='topic+kdecopula'></span><span id='topic+kdecopula-package'></span><span id='topic+kdecopula-package'></span>

<h3>Description</h3>

<p>This package provides fast implementations of kernel estimators for the
copula density. Due to its several plotting options it is particularly
useful for the exploratory analysis of dependence structures. It can be
further used for flexible nonparametric estimation of copula densities
and resampling.
</p>


<h3>Details</h3>

<p>The function <code><a href="#topic+kdecop">kdecop</a></code> can be used to estimate a copula density
with a number of popular kernel estimators. The density estimate can be
evaluated on arbitrary points with <code><a href="#topic+dkdecop">dkdecop</a></code>;
the cdf with <code><a href="#topic+pkdecop">pkdecop</a></code>. Furthermore, synthetic
data can be simulated with <code><a href="#topic+rkdecop">rkdecop</a></code>, and
several plot options are provided by
<code><a href="#topic+plot.kdecopula">plot.kdecopula</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>References</h3>

<p>Nagler, T. (2018)
kdecopula: An R Package for the Kernel Estimation of Bivariate Copula
Densities.
Journal of Statistical Software 84(7), 1-22
<br /> <br />
Gijbels, I. and Mielniczuk, J. (1990).
Estimating the density of a copula function.
Communications in Statistics - Theory and Methods, 19(2):445-464.
<br /> <br />
Charpentier, A., Fermanian, J.-D., and Scaillet, O. (2006).
The estimation of copulas: Theory and practice.
In Rank, J., editor, Copulas: From theory to application in finance. Risk Books.
<br /> <br />
Geenens, G., Charpentier, A., and Paindaveine, D. (2017).
Probit transformation for nonparametric kernel estimation of the copula
density.
Bernoulli, 23(3), 1848-1873.
<br /> <br />
Nagler, T. (2014).
Kernel Methods for Vine Copula Estimation.
Master's Thesis, Technische Universitaet Muenchen,
<a href="https://mediatum.ub.tum.de/node?id=1231221">https://mediatum.ub.tum.de/node?id=1231221</a>
<br /> <br />
Wen, K. and Wu, X. (2015).
Transformation-Kernel Estimation of the Copula Density,
Working paper,
<a href="http://agecon2.tamu.edu/people/faculty/wu-ximing/agecon2/public/copula.pdf">http://agecon2.tamu.edu/people/faculty/wu-ximing/agecon2/public/copula.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data and transform with empirical cdf
data(wdbc)
udat &lt;- apply(wdbc[, -1], 2, function(x) rank(x)/(length(x)+1))

## estimation of copula density of variables 5 and 6
dens.est &lt;- kdecop(udat[, 5:6])
plot(dens.est)

## evaluate density estimate at (u1,u2)=(0.123,0.321)
dkdecop(c(0.123, 0.321), dens.est)

## evaluate cdf estimate at (u1,u2)=(0.123,0.321)
pkdecop(c(0.123, 0.321), dens.est)

## simulate 500 samples from density estimate
rkdecop(500, dens.est)

</code></pre>

<hr>
<h2 id='bw_bern'>Bandwidth selection for the Bernstein copula estimator</h2><span id='topic+bw_bern'></span>

<h3>Description</h3>

<p>The optimal size of knots is chosen by a rule of thumb adapted from
Rose (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_bern(udata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_bern_+3A_udata">udata</code></td>
<td>
<p>data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula is
</p>
<p style="text-align: center;"><code class="reqn">max(1, round(n^(1/3) * exp(abs(rho)^(1/n)) * (abs(rho) + 0.1))),</code>
</p>

<p>where <code class="reqn">\rho</code> is the empirical Spearman's rho of the data.
</p>


<h3>Value</h3>

<p>optimal order of the Bernstein polynomials.
</p>

<hr>
<h2 id='bw_beta'>Bandwidth selection for the beta kernel estimator</h2><span id='topic+bw_beta'></span>

<h3>Description</h3>

<p>The bandwidth is selected by minimizing the MISE using the Frank copula as
the reference family. The copula parameter is set by inversion of Kendall's
tau. See Nagler (2014) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_beta(udata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_beta_+3A_udata">udata</code></td>
<td>
<p>data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To speed things up, optimal bandwidths have been pre-calculated on a grid of
tau values.
</p>


<h3>Value</h3>

<p>A scalar bandwidth parameter.
</p>


<h3>References</h3>

<p>Nagler, T. (2014).
Kernel Methods for Vine Copula Estimation.
Master's Thesis, Technische Universitaet Muenchen,
<a href="https://mediatum.ub.tum.de/node?id=1231221">https://mediatum.ub.tum.de/node?id=1231221</a>
</p>

<hr>
<h2 id='bw_mr'>Bandwidth selection for the mirror-reflection estimator</h2><span id='topic+bw_mr'></span>

<h3>Description</h3>

<p>The bandwidth is selected by minimizing the MISE using the Frank copula as
the reference family. The copula parameter is set by inversion of Kendall's
tau. See Nagler (2014) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_mr(udata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_mr_+3A_udata">udata</code></td>
<td>
<p>data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To speed things up, optimal bandwidths have been pre-calculated on a grid of
tau values.
</p>


<h3>Value</h3>

<p>A scalar bandwidth parameter.
</p>


<h3>References</h3>

<p>Nagler, T. (2014).
Kernel Methods for Vine Copula Estimation.
Master's Thesis, Technische Universitaet Muenchen,
<a href="https://mediatum.ub.tum.de/node?id=1231221">https://mediatum.ub.tum.de/node?id=1231221</a>
</p>

<hr>
<h2 id='bw_t'>Bandwidth selection for the transformation kernel estimator</h2><span id='topic+bw_t'></span>

<h3>Description</h3>

<p>The bandwidth is selected by a rule of thumb. It approximately minimizes
the MISE of the Gaussian copula on the transformed domain. The usual normal
reference matrix is multiplied by 1.25 to account for the higher variance
on the copula level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_t(udata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_t_+3A_udata">udata</code></td>
<td>
<p>data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula is
</p>
<p style="text-align: center;"><code class="reqn">1.25  n^{-1 / 6}  \hat{\Sigma}^{1/2},</code>
</p>

<p>where <code class="reqn">\hat{Sigma}</code> is empirical covariance matrix of the transformed
random vector.
</p>


<h3>Value</h3>

<p>A <code>2 x 2</code> bandwidth matrix.
</p>


<h3>References</h3>

<p>Nagler, T. (2014).
Kernel Methods for Vine Copula Estimation.
Master's Thesis, Technische Universitaet Muenchen,
<a href="https://mediatum.ub.tum.de/node?id=1231221">https://mediatum.ub.tum.de/node?id=1231221</a>
</p>

<hr>
<h2 id='bw_tll'>Bandwidth selection for the transformation local likelihood estimator</h2><span id='topic+bw_tll'></span>

<h3>Description</h3>

<p>The bandwidth is selected by a rule of thumb similar to <code><a href="#topic+bw_t">bw_t</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_tll(udata, deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_tll_+3A_udata">udata</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id="bw_tll_+3A_deg">deg</code></td>
<td>
<p>degree of the polynomial.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula is
</p>
<p style="text-align: center;"><code class="reqn">5  n^{-1 / (4q + 2)}  \hat{\Sigma}^{1/2},</code>
</p>

<p>where <code class="reqn">\hat{Sigma}</code> is empirical covariance matrix of the transformed
random vector and <code class="reqn">q = 1</code> for <code>TLL1</code> and <code class="reqn">q = 2</code> for
<code>TLL2</code>.
</p>


<h3>Value</h3>

<p>A <code>2 x 2</code> bandwidth matrix.
</p>

<hr>
<h2 id='bw_tll_nn'>Nearest-neighbor bandwidth selection for the transformation local likelihood
estimator</h2><span id='topic+bw_tll_nn'></span>

<h3>Description</h3>

<p>The smoothing parameters is selected by the method of Geenens et al. (2017).
It uses principal components for the rotation matrix and selects the
nearest neighbor fraction along each principal direction by approximate
least-squares cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_tll_nn(udata, deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_tll_nn_+3A_udata">udata</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id="bw_tll_nn_+3A_deg">deg</code></td>
<td>
<p>degree of the polynomial.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries:
</p>

<dl>
<dt><code>B</code></dt><dd><p>rotation matrix,</p>
</dd>
<dt><code>alpha</code></dt><dd><p>nearest neighbor fraction (this one is multiplied
with <code>mult</code> in <code><a href="#topic+kdecop">kdecop()</a></code>),</p>
</dd>
<dt><code>kappa</code></dt><dd><p>correction factor for differences in roughness along
the axes,</p>
</dd>
</dl>

<p>see Geenens et al. (2017).
</p>


<h3>References</h3>

<p>Geenens, G., Charpentier, A., and Paindaveine, D. (2017).
Probit transformation for nonparametric kernel estimation of the copula
density.
Bernoulli, 23(3), 1848-1873.
</p>

<hr>
<h2 id='bw_tt_pi'>Nearest-neighbor bandwidth selection for the tapered transformation estimator</h2><span id='topic+bw_tt_pi'></span><span id='topic+bw_tt_cv'></span>

<h3>Description</h3>

<p>The smoothing parameters are selected by the method of Wen and Wu (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_tt_pi(udata, rho.add = TRUE)

bw_tt_cv(udata, rho.add = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_tt_pi_+3A_udata">udata</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id="bw_tt_pi_+3A_rho.add">rho.add</code></td>
<td>
<p>logical; whether a rotation (correlation) parameter shall be
included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Optimal smoothing parameters as in Wen and Wu (2015): a numeric
vector of length 4; entries are <code class="reqn">(h, \rho, \theta_1, \theta_2)</code>.
</p>


<h3>Author(s)</h3>

<p>Kuangyu Wen
</p>


<h3>References</h3>

<p>Wen, K. and Wu, X. (2015).
Transformation-Kernel Estimation of the Copula Density,
Working paper,
<a href="http://agecon2.tamu.edu/people/faculty/wu-ximing/agecon2/public/copula.pdf">http://agecon2.tamu.edu/people/faculty/wu-ximing/agecon2/public/copula.pdf</a>
</p>

<hr>
<h2 id='dep_measures'>Dependence measures of a <code>kdecop()</code> fit</h2><span id='topic+dep_measures'></span>

<h3>Description</h3>

<p>Calculates several dependence measures derived from the copula density. All
measures except <code>"blomqvist"</code> are computed by quasi Monte Carlo methods
(see <code><a href="#topic+rkdecop">rkdecop()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dep_measures(object, measures = "all", n_qmc = 10^3, seed = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dep_measures_+3A_object">object</code></td>
<td>
<p>an object of class <code>kdecopula</code>.</p>
</td></tr>
<tr><td><code id="dep_measures_+3A_measures">measures</code></td>
<td>
<p>which measures to compute, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="dep_measures_+3A_n_qmc">n_qmc</code></td>
<td>
<p>the number of quasi Monte Carlo samples.</p>
</td></tr>
<tr><td><code id="dep_measures_+3A_seed">seed</code></td>
<td>
<p>the seed for quasi Monte Carlo integration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of dependence measures.
</p>
<p>The following measures are available:
</p>

<dl>
<dt><code>"kendall"</code></dt><dd><p>Kendall's <code class="reqn">\tau</code>, see Nelsen (2007); computed as the
sample version of a quasi Monte Carlo sample.</p>
</dd>
<dt><code>"spearman"</code></dt><dd><p>Spearman's <code class="reqn">\rho</code>, see Nelsen (2007); computed as the
sample version of a quasi Monte Carlo sample.</p>
</dd>
<dt><code>"blomqvist"</code></dt><dd><p>Blomqvist's <code class="reqn">\beta</code>, see Nelsen (2007); computed
as <code class="reqn">4C(0.5, 0.5) - 1</code>.</p>
</dd>
<dt><code>"gini"</code></dt><dd><p>Gini's <code class="reqn">\gamma</code>, see Nelsen (2007); computed by quasi
Monte Carlo integration.</p>
</dd>
<dt><code>"vd_waerden"</code></dt><dd><p>van der Waerden's coefficient, see Genest and Verret
(2005); computed as the sample version of a quasi Monte Carlo sample.</p>
</dd>
<dt><code>"minfo"</code></dt><dd><p>mutual information, see Joe (1989); computed by quasi Monte
Carlo integration.</p>
</dd>
<dt><code>"linfoot"</code></dt><dd><p>Linfoot's correlation coefficient, see Joe (1989);
computed by quasi Monte Carlo integration.</p>
</dd>
</dl>



<h3>References</h3>

<p>Nelsen, R. (2007). An introduction to copulas. Springer Science
&amp; Business Media, 2007.
</p>
<p>Genest, C., and Verret, F. (2005). Locally most powerful rank tests of
independence for copula models. Journal of Nonparametric Statistics, 17(5)
</p>
<p>Joe, H. (1989). Relative Entropy Measures of Multivariate Dependence.
Journal of the American Statistical Association, 84(405)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data and transform with empirical cdf
data(wdbc)
udat &lt;- apply(wdbc[, -1], 2, function(x) rank(x) / (length(x) + 1))

## estimate copula density and calculate dependence measures
fit &lt;- kdecop(udat[, 5:6])
dep_measures(fit)

</code></pre>

<hr>
<h2 id='dkdecop'>Working with <code>kdecopula</code> objects</h2><span id='topic+dkdecop'></span><span id='topic+pkdecop'></span><span id='topic+rkdecop'></span><span id='topic+pkdecop'></span><span id='topic+rkdecop'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+kdecop">kdecop()</a></code> stores it's result in object of class <code>kdecopula</code>.
The density estimate can be evaluated on arbitrary points with <code><a href="#topic+dkdecop">dkdecop()</a></code>;
the cdf with <code><a href="#topic+pkdecop">pkdecop()</a></code>. Furthermore, synthetic data can be simulated with
<code><a href="#topic+rkdecop">rkdecop()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkdecop(u, obj, stable = FALSE)

pkdecop(u, obj)

rkdecop(n, obj, quasi = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dkdecop_+3A_u">u</code></td>
<td>
<p><code>mx2</code> matrix of evaluation points.</p>
</td></tr>
<tr><td><code id="dkdecop_+3A_obj">obj</code></td>
<td>
<p><code>kdecopula</code> object.</p>
</td></tr>
<tr><td><code id="dkdecop_+3A_stable">stable</code></td>
<td>
<p>logical; option for stabilizing the estimator: the estimated
density is cut off at <code class="reqn">50</code>.</p>
</td></tr>
<tr><td><code id="dkdecop_+3A_n">n</code></td>
<td>
<p>integer; number of observations.</p>
</td></tr>
<tr><td><code id="dkdecop_+3A_quasi">quasi</code></td>
<td>
<p>logical; the default (<code>FALSE</code>) returns pseudo-random
numbers, use <code>TRUE</code> for quasi-random numbers (generalized Halton, see
<code><a href="qrng.html#topic+ghalton">qrng::ghalton()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the density/cdf or a <code>n x 2</code> matrix of
simulated data.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>References</h3>

<p>#' Nagler, T. (2018)
kdecopula: An R Package for the Kernel Estimation of Bivariate Copula
Densities.
Journal of Statistical Software 84(7), 1-22
<br /> <br />#'
Geenens, G., Charpentier, A., and Paindaveine, D. (2017). Probit
transformation for nonparametric kernel estimation of the copula density.
Bernoulli, 23(3), 1848-1873.
<br /> <br />
Nagler, T. (2014). Kernel Methods for
Vine Copula Estimation. Master's Thesis, Technische Universitaet Muenchen,
<a href="https://mediatum.ub.tum.de/node?id=1231221">https://mediatum.ub.tum.de/node?id=1231221</a>
<br /> <br />
Cambou, T., Hofert,
M., Lemieux, C. (2015). A primer on quasi-random numbers for copula models,
arXiv:1508.03483
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kdecop">kdecop</a></code>,
<code><a href="#topic+plot.kdecopula">plot.kdecopula</a></code>,
<code><a href="qrng.html#topic+ghalton">ghalton</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data and transform with empirical cdf
data(wdbc)
udat &lt;- apply(wdbc[, -1], 2, function(x) rank(x) / (length(x) + 1))

## estimation of copula density of variables 5 and 6
fit &lt;- kdecop(udat[, 5:6])
plot(fit) 

## evaluate density estimate at (u1,u2)=(0.123,0.321)
dkdecop(c(0.123, 0.321), fit) 

## evaluate cdf estimate at (u1,u2)=(0.123,0.321)
pkdecop(c(0.123, 0.321), fit) 

## simulate 500 samples from density estimate
plot(rkdecop(500, fit))

</code></pre>

<hr>
<h2 id='fitted.kdecopula'>Extract fitted values from a <code>kdecop()</code> fits.</h2><span id='topic+fitted.kdecopula'></span>

<h3>Description</h3>

<p>Simply calls <code>predict(object, object$udata, what)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kdecopula'
fitted(object, what = "pdf", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.kdecopula_+3A_object">object</code></td>
<td>
<p>an object of class <code>kdecopula</code>.</p>
</td></tr>
<tr><td><code id="fitted.kdecopula_+3A_what">what</code></td>
<td>
<p>what to predict, one of <code>c("pdf", "cdf", "hfunc1", "hfunc2", "hinv1", "hinv2")</code>.</p>
</td></tr>
<tr><td><code id="fitted.kdecopula_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>predict.kdecopula()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wdbc)
udat &lt;- apply(wdbc[, -1], 2, function(x) rank(x) / (length(x) + 1))
fit &lt;- kdecop(udat[, 5:6])

all.equal(fitted(fit), predict(fit, fit$udata))
</code></pre>

<hr>
<h2 id='hkdecop'>H-function and inverse of a <code>kdecop()</code> fit</h2><span id='topic+hkdecop'></span>

<h3>Description</h3>

<p>Evaluates the h-function (or its inverse) corresponding to a <code>kdecopula</code>
object. H-functions are conditional distribution functions obtained by
integrating the copula density w.r.t. to one of its arguments (see also
<code><a href="VineCopula.html#topic+BiCopHfunc">VineCopula::BiCopHfunc()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hkdecop(u, obj, cond.var, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hkdecop_+3A_u">u</code></td>
<td>
<p><code class="reqn">n x 2</code> matrix of evaluation points.</p>
</td></tr>
<tr><td><code id="hkdecop_+3A_obj">obj</code></td>
<td>
<p><code>kdecopula</code> object.</p>
</td></tr>
<tr><td><code id="hkdecop_+3A_cond.var">cond.var</code></td>
<td>
<p>integer; <code>cond.var = 1</code> conditions on the first variable,
<code>cond.var = 2</code> on the second.</p>
</td></tr>
<tr><td><code id="hkdecop_+3A_inverse">inverse</code></td>
<td>
<p>logical; indicates whether the h-function or its inverse shall be
calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length <code class="reqn">n</code> vector of the (inverse) h-function evaluated at
<code>u</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data and transform with empirical cdf
data(wdbc)
udat &lt;- apply(wdbc[, -1], 2, function(x) rank(x) / (length(x) + 1))

## estimation of copula density of variables 5 and 6
fit &lt;- kdecop(udat[, 5:6])
plot(fit) 

## evaluate h-function estimate and its inverse at (u1|u2) = (0.123 | 0.321)
hkdecop(c(0.123, 0.321), fit, cond.var = 2) 
hkdecop(c(0.123, 0.321), fit, cond.var = 2, inverse = TRUE) 

</code></pre>

<hr>
<h2 id='kdecop'>Bivariate kernel copula density estimation</h2><span id='topic+kdecop'></span>

<h3>Description</h3>

<p>Based on samples from a bivariate copula, the copula density is estimated.
The user can choose between different methods. If no bandwidth is provided
by the user, it will be set by a method-specific automatic selection
procedure. The related (d/p/r)kdecop functions evaluate the density and cdf
or simulate synthetic data, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdecop(udata, bw = NA, mult = 1, method = "TLL2nn", knots = 30,
  renorm.iter = 3L, info = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdecop_+3A_udata">udata</code></td>
<td>
<p><code>nx2</code> matrix of copula data.</p>
</td></tr>
<tr><td><code id="kdecop_+3A_bw">bw</code></td>
<td>
<p>bandwidth specification; if <code>NA</code>, <code>bw</code> is selected
automatically (see Details); Otherwise, please provide <br />
<code>"T", "TLL1", "TLL2"</code>: a <code class="reqn">2x2</code> bandwidth matrix, <br />
<code>"TLL1nn", "TLL2nn"</code>: a list with (named) entries <code>B</code>, <code>alpha</code>,
and <code>kappa</code>, <br />
<code>"TTCV", "TTPI"</code>: a numeric vector of length four containing <code class="reqn">(h,
\rho, \theta_1, \theta_2)</code>, c.f. Wen and Wu (2015), <br />
<code>"MR", "beta"</code>: a positive real number.</p>
</td></tr>
<tr><td><code id="kdecop_+3A_mult">mult</code></td>
<td>
<p>bandwidth multiplier, has to be positive; useful for making
estimates more/less smooth manually.</p>
</td></tr>
<tr><td><code id="kdecop_+3A_method">method</code></td>
<td>
<p><code>"T"</code>: transformation estimator based on classical bivariate kernel
estimation (e.g., Geenenens et al., 2014), <br />
<code>"TLL1"</code>: transformation estimator with log-linear local likelihood
estimation (Geenenens et al., 2014), <br />
<code>"TLL2"</code>: transformation estimator with log-quadratic local likelihood
estimation (Geenenens et al., 2014), <br />
<code>"TLL1nn"</code>: transformation estimator with log-linear local likelihood
estimation and nearest-neighbor bandwidths (Geenenens et al., 2014), <br />
<code>"TLL2nn"</code>: transformation estimator with log-quadratic local likelihood
estimation and nearest-neighbor bandwidths (Geenenens et al., 2014), <br />
<code>"TTPI"</code>: tapered transformation estimator with plug-in bandwidths
(Wu and Wen, 2015), <br />
<code>"TTCV"</code>: tapered transformation estimator with profile cross-validation
bandwidths (Wu and Wen, 2015), <br />
<code>"MR"</code>: mirror-reflection estimator (Gijbels and Mielniczuk, 1990), <br />
<code>"beta"</code>: beta kernel estimator (Charpentier et al., 2006), <br />
<code>"bern"</code>: Bernstein copula estimator (Sanchetta and Satchell, 2004); the
coefficients are adjusted by the method of Weiss and Scheffer (2012).</p>
</td></tr>
<tr><td><code id="kdecop_+3A_knots">knots</code></td>
<td>
<p>integer; number of knots in each dimension for the spline
approximation.</p>
</td></tr>
<tr><td><code id="kdecop_+3A_renorm.iter">renorm.iter</code></td>
<td>
<p>integer; number of iterations for the renormalization
procedure (see <em>Details</em>).</p>
</td></tr>
<tr><td><code id="kdecop_+3A_info">info</code></td>
<td>
<p>logical; if <code>TRUE</code>, additional information about the
estimate will be gathered (see <em>Value</em>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use a Gaussian product kernel function for all methods
except the beta kernel and Bernstein estimators. For details on bandwidth
selection for a specific method, see: <code><a href="#topic+bw_t">bw_t</a></code>,
<code><a href="#topic+bw_tll">bw_tll</a></code>, <code><a href="#topic+bw_tll_nn">bw_tll_nn</a></code>, <code><a href="#topic+bw_tt_pi">bw_tt_pi</a></code>,
<code><a href="#topic+bw_tt_cv">bw_tt_cv</a></code>, <code><a href="#topic+bw_mr">bw_mr</a></code>, <code><a href="#topic+bw_beta">bw_beta</a></code>,
<code><a href="#topic+bw_bern">bw_bern</a></code>.
<br />
</p>
<p>Kernel estimates are usually no proper copula densities. In particular, the
estimated marginal densities are not uniform. We mitigate this issue by
a renormalization procedure. The number of iterations of the
renormalization algorithm can be specified with the <code>renorm.iter</code>
argument. Typically, a very small number of iterations is sufficient. <br />
</p>


<h3>Value</h3>

<p>The function <code><a href="#topic+kdecop">kdecop</a></code> returns an
object of class <code>kdecopula</code> that contains all information necessary for
evaluation of the estimator. If no bandwidth was provided in the function
call, the automatically selected value can be found in the variable
<code>object$bw</code>. If <code>info=TRUE</code>, also the following will be available
under <code>object$info</code>:
</p>
<table>
<tr><td><code>likvalues</code></td>
<td>
<p>Estimator evaluated in sample points</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log likelihood</p>
</td></tr>
<tr><td><code>effp</code></td>
<td>
<p>Effective number of parameters</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion</p>
</td></tr>
<tr><td><code>cAIC</code></td>
<td>
<p>Bias-corrected version of Akaike information criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criterion.</p>
</td></tr> </table>
<p><br />
The density estimate can be evaluated on arbitrary points with
<code><a href="#topic+dkdecop">dkdecop</a></code>; the cdf with
<code><a href="#topic+pkdecop">pkdecop</a></code>. Furthermore, synthetic data can be
simulated with <code><a href="#topic+rkdecop">rkdecop</a></code>, and several plotting
options are available with <code><a href="graphics.html#topic+plot">plot</a></code>
and <code><a href="graphics.html#topic+contour">contour</a></code>.
</p>


<h3>Note</h3>

<p>The implementation of the tapered transformation estimator (&quot;TTPI&quot;/&quot;TTCV&quot;)
was kindly provided by Kuangyu Wen.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>References</h3>

<p>Nagler, T. (2018)
kdecopula: An R Package for the Kernel Estimation of Bivariate Copula
Densities.
Journal of Statistical Software 84(7), 1-22
<br /> <br />
Geenens, G., Charpentier, A., and Paindaveine, D. (2017).
Probit transformation for nonparametric kernel estimation of the copula
density.
Bernoulli, 23(3), 1848-1873.
<br /> <br />
Wen, K. and Wu, X. (2015).
Transformation-Kernel Estimation of the Copula Density,
Working paper,
<a href="http://agecon2.tamu.edu/people/faculty/wu-ximing/agecon2/public/copula.pdf">http://agecon2.tamu.edu/people/faculty/wu-ximing/agecon2/public/copula.pdf</a>
<br /> <br />
Gijbels, I. and Mielniczuk, J. (1990).
Estimating the density of a copula function.
Communications in Statistics - Theory and Methods, 19(2):445-464.
<br /> <br />
Charpentier, A., Fermanian, J.-D., and Scaillet, O. (2006).
The estimation of copulas: Theory and practice.
In Rank, J., editor, Copulas: From theory to application in finance. Risk Books.
<br /> <br />
Weiss, G. and Scheffer, M. (2012).
Smooth Nonparametric Bernstein Vine Copulas.
arXiv:1210.2043
<br /> <br />
Nagler, T. (2014).
Kernel Methods for Vine Copula Estimation.
Master's Thesis, Technische Universitaet Muenchen,
<a href="https://mediatum.ub.tum.de/node?id=1231221">https://mediatum.ub.tum.de/node?id=1231221</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kdecopula">kdecopula</a></code>,
<code><a href="#topic+plot.kdecopula">plot.kdecopula</a></code>,
<code><a href="#topic+predict.kdecopula">predict.kdecopula</a></code>,
<code><a href="#topic+fitted.kdecopula">fitted.kdecopula</a></code>,
<code><a href="#topic+simulate.kdecopula">simulate.kdecopula</a></code>,
<code><a href="#topic+dkdecop">dkdecop</a></code>,
<code><a href="#topic+pkdecop">pkdecop</a></code>,
<code><a href="#topic+rkdecop">rkdecop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data and transform with empirical cdf
data(wdbc)
udat &lt;- apply(wdbc[, -1], 2, function(x) rank(x) / (length(x) + 1))

## estimation of copula density of variables 5 and 6
fit &lt;- kdecop(udat[, 5:6])
summary(fit)
plot(fit)
contour(fit)

## evaluate density estimate at (u1,u2)=(0.123,0.321)
dkdecop(c(0.123, 0.321), fit)

## evaluate cdf estimate at (u1,u2)=(0.123,0.321)
pkdecop(c(0.123, 0.321), fit)

## simulate 500 samples from density estimate
plot(rkdecop(500, fit))  # pseudo-random
plot(rkdecop(500, fit, quasi = TRUE))  # quasi-random


</code></pre>

<hr>
<h2 id='logLik.kdecopula'>Log-Likelihood of a <code>kdecopula</code> object</h2><span id='topic+logLik.kdecopula'></span>

<h3>Description</h3>

<p>Log-Likelihood of a <code>kdecopula</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kdecopula'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.kdecopula_+3A_object">object</code></td>
<td>
<p>an object of class <code>kdecopula</code>.</p>
</td></tr>
<tr><td><code id="logLik.kdecopula_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code><a href="stats.html#topic+logLik">logLik</a></code> containing the log-
likelihood, number of observations and effective number of parameters (&quot;df&quot;).
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code>,
<code><a href="stats.html#topic+AIC">AIC</a></code>,
<code><a href="stats.html#topic+BIC">BIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data and transform with empirical cdf
data(wdbc)
udat &lt;- apply(wdbc[, -1], 2, function(x) rank(x) / (length(x) + 1))

## estimation of copula density of variables 5 and 6
fit &lt;- kdecop(udat[, 5:6])

## compute fit statistics
logLik(fit)
AIC(fit)
BIC(fit)

</code></pre>

<hr>
<h2 id='plot.kdecopula'>Plotting <code>kdecopula</code> objects</h2><span id='topic+plot.kdecopula'></span><span id='topic+contour.kdecopula'></span><span id='topic+contour.kdecopula'></span>

<h3>Description</h3>

<p>Produces perspective or contour plots for a <code>kdecopula</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kdecopula'
plot(x, type = "surface", margins, size, ...)

## S3 method for class 'kdecopula'
contour(x, margins = "norm", size = 100L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.kdecopula_+3A_x">x</code></td>
<td>
<p><code>kdecopula</code> object.</p>
</td></tr>
<tr><td><code id="plot.kdecopula_+3A_type">type</code></td>
<td>
<p>plot type; either <code>"contour"</code> or <code>"surface"</code> (partial
matching is activated) for a contour or perspective/surface plot
respectively.</p>
</td></tr>
<tr><td><code id="plot.kdecopula_+3A_margins">margins</code></td>
<td>
<p><code>"unif"</code> for the original copula density,
<code>"norm"</code> for the transformed density with standard normal margins,
<code>"exp"</code> with standard exponential margins, and  <code>"flexp"</code> with
flipped exponential margins. Default is <code>"norm"</code> for <code>type =
"contour"</code>, and <code>"unif"</code> for <code>type = "surface"</code>.</p>
</td></tr>
<tr><td><code id="plot.kdecopula_+3A_size">size</code></td>
<td>
<p>integer; the plot is based on values on a <code class="reqn">size x size</code>
grid; default is 100 for <code>type = "contour"</code>, and 25 for <code>type =
"surface"</code>.</p>
</td></tr>
<tr><td><code id="plot.kdecopula_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="graphics.html#topic+contour">contour</a></code> or
<code><a href="lattice.html#topic+wireframe">wireframe</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>References</h3>

<p>Nagler, T. (2018)
kdecopula: An R Package for the Kernel Estimation of Bivariate Copula
Densities.
Journal of Statistical Software 84(7), 1-22
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kdecop">kdecop</a></code>,
<code><a href="graphics.html#topic+contour">contour</a></code>,
<code><a href="lattice.html#topic+wireframe">wireframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data and transform with empirical cdf
data(wdbc)
udat &lt;- apply(wdbc[, -1], 2, function(x) rank(x)/(length(x)+1))

## estimation of copula density of variables 5 and 6
obj &lt;- kdecop(udat[, 5:6])

## plots
plot(obj)  # surface plot of copula density
contour(obj)  # contour plot with standard normal margins
contour(obj, margins = "unif")  # contour plot of copula density

</code></pre>

<hr>
<h2 id='predict.kdecopula'>Prediction method for <code>kdecop()</code> fits</h2><span id='topic+predict.kdecopula'></span>

<h3>Description</h3>

<p>Predicts the pdf, cdf, or (inverse) h-functions by calling <code>dkdecop()</code>,
<code>pkdecop()</code>, or <code>hkdecop()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kdecopula'
predict(object, newdata, what = "pdf", stable = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.kdecopula_+3A_object">object</code></td>
<td>
<p>an object of class <code>kdecopula</code>.</p>
</td></tr>
<tr><td><code id="predict.kdecopula_+3A_newdata">newdata</code></td>
<td>
<p>evaluation point(s), a length two vector or a matrix with
two columns.</p>
</td></tr>
<tr><td><code id="predict.kdecopula_+3A_what">what</code></td>
<td>
<p>what to predict, one of <code>c("pdf", "cdf", "hfunc1", "hfunc2", "hinv1", "hinv2")</code>.</p>
</td></tr>
<tr><td><code id="predict.kdecopula_+3A_stable">stable</code></td>
<td>
<p>only used for <code>what = "pdf"</code>, see <code>dkdecop()</code>.</p>
</td></tr>
<tr><td><code id="predict.kdecopula_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wdbc)
udat &lt;- apply(wdbc[, -1], 2, function(x) rank(x) / (length(x) + 1))
fit &lt;- kdecop(udat[, 5:6])

all.equal(predict(fit, c(0.1, 0.2)), dkdecop(c(0.1, 0.2), fit))
all.equal(predict(fit, udat, "hfunc1"), hkdecop(udat, fit, cond.var = 1))
</code></pre>

<hr>
<h2 id='simulate.kdecopula'>Simulate data from a <code>kdecop()</code> fit.</h2><span id='topic+simulate.kdecopula'></span>

<h3>Description</h3>

<p>See <code>rkdecop()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kdecopula'
simulate(object, nsim = 1, seed = NULL, quasi = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.kdecopula_+3A_object">object</code></td>
<td>
<p>an object of class <code>kdecopula</code>.</p>
</td></tr>
<tr><td><code id="simulate.kdecopula_+3A_nsim">nsim</code></td>
<td>
<p>integer; number of observations.</p>
</td></tr>
<tr><td><code id="simulate.kdecopula_+3A_seed">seed</code></td>
<td>
<p>integer; <code>set.seed(seed)</code> will be called prior to <code>rkdecop()</code>.</p>
</td></tr>
<tr><td><code id="simulate.kdecopula_+3A_quasi">quasi</code></td>
<td>
<p>logical; the default (<code>FALSE</code>) returns pseudo-random
numbers, use <code>TRUE</code> for quasi-random numbers (generalized Halton, see</p>
</td></tr>
<tr><td><code id="simulate.kdecopula_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated data from the fitted <code>kdecopula</code> model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wdbc)
udat &lt;- apply(wdbc[, -1], 2, function(x) rank(x) / (length(x) + 1))
fit &lt;- kdecop(udat[, 5:6])
plot(simulate(fit, 500))

</code></pre>

<hr>
<h2 id='wdbc'>Wisconsin Diagnostic Breast Cancer (WDBC)</h2><span id='topic+wdbc'></span>

<h3>Description</h3>

<p>The data contain measurements on cells in suspicious lumps in a woman's
breast. Features are computed from a digitized image of a fine needle
aspirate (FNA) of a breast mass. They describe characteristics of the cell
nuclei present in the image. All samples are classified as either
<em>benign</em> or <em>malignant</em>.
</p>


<h3>Format</h3>

<p><code>wdbc</code> is a <code>data.frame</code> with 31 columns. The first column
indicates whether the sample is classified as benign (<code>B</code>) or malignant
(<code>M</code>). The remaining columns contain measurements for 30 features.</p>


<h3>Details</h3>

<p>Ten real-valued features are computed for each cell nucleus: <br />
</p>
<p>a) radius (mean of distances from center to points on the perimeter) <br /> b)
texture (standard deviation of gray-scale values) <br /> c) perimeter <br /> d)
area <br /> e) smoothness (local variation in radius lengths) <br /> f)
compactness (perimeter^2 / area - 1.0) <br /> g) concavity (severity of concave
portions of the contour) <br /> h) concave points (number of concave portions
of the contour) <br /> i) symmetry <br /> j) fractal dimension (&quot;coastline
approximation&quot; - 1) <br />
</p>
<p>The references listed below contain detailed descriptions of how these
features are computed.
</p>
<p>The mean, standard error, and &quot;worst&quot; or largest (mean of the three largest
values) of these features were computed for each image, resulting in 30
features.
</p>


<h3>Note</h3>

<p>This breast cancer database was obtained from the University of
Wisconsin Hospitals, Madison from Dr. William H. Wolberg.
</p>


<h3>Source</h3>

<p><a href="http://mlr.cs.umass.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)">http://mlr.cs.umass.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)</a>
<br /> <br />
Bache, K. &amp; Lichman, M. (2013).
UCI Machine Learning Repository.
Irvine, CA: University of California, School of Information and Computer
Science.
</p>


<h3>References</h3>

<p>O. L. Mangasarian and W. H. Wolberg: &quot;Cancer diagnosis via
linear programming&quot;,<br /> SIAM News, Volume 23, Number 5, September 1990, pp 1
&amp; 18.
</p>
<p>William H. Wolberg and O.L. Mangasarian: &quot;Multisurface method of pattern
separation for medical diagnosis applied to breast cytology&quot;, <br />
Proceedings of the National Academy of Sciences, U.S.A., Volume 87, December
1990, pp 9193-9196.
</p>
<p>K. P. Bennett &amp; O. L. Mangasarian: &quot;Robust linear programming discrimination
of two linearly inseparable sets&quot;,<br /> Optimization Methods and Software 1,
1992, 23-34 (Gordon &amp; Breach Science Publishers).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(wdbc)
str(wdbc)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
