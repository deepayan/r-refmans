<!DOCTYPE html><html><head><title>Help for package IPCAPS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IPCAPS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IPCAPS-package'><p>IPCAPS : Iterative Pruning to CApture Population Structure</p></a></li>
<li><a href='#cal.eigen.fit'><p>(Internal function) Calculae a vector of EigenFit values, internally used for</p>
parallelization</a></li>
<li><a href='#check.stopping'><p>(Internal function) Check whether the IPCAPS process meets the stopping</p>
criterion.</a></li>
<li><a href='#clustering'><p>(Internal function) Perform the clustering process of IPCAPS</p></a></li>
<li><a href='#clustering.mode'><p>(Internal function) Select a clustering method to be used for the IPCAPS</p>
process.</a></li>
<li><a href='#diff.eigen.fit'><p>(Internal function) Calculate a vector of different values from a vector of</p>
EigenFit values, internally used for parallelization</a></li>
<li><a href='#diff.xy'><p>(Internal function) Check the different value of X and Y, internally used for</p>
parallelization</a></li>
<li><a href='#do.glm'><p>(Internal function) Perform regression models, internally used for</p>
parallelization</a></li>
<li><a href='#export.groups'><p>Export the IPCAPS result to a text file</p></a></li>
<li><a href='#get.node.info'><p>Get the information for specified node</p></a></li>
<li><a href='#ipcaps'><p>Perform unsupervised clustering to capture population structure based on iterative pruning</p></a></li>
<li><a href='#label'><p>Synthetic dataset containing population labels for the dataset <code>raw.data</code></p></a></li>
<li><a href='#output.template'><p>(Internal object) The HTML output template for IPCAPS</p></a></li>
<li><a href='#pasre.categorical.data'><p>(Internal function) Manipulate categorical input files</p></a></li>
<li><a href='#PC'><p>Synthetic dataset containing the top 10 principal components (PC) from the</p>
dataset <code>raw.data</code></a></li>
<li><a href='#postprocess'><p>(Internal function) Perform the post-processing step of IPCAPS</p></a></li>
<li><a href='#preprocess'><p>(Internal function) Perform the pre-processing step of IPCAPS</p></a></li>
<li><a href='#process.each.node'><p>(Internal function) Perform the iterative process for each node</p></a></li>
<li><a href='#raw.data'><p>Synthetic dataset containing single nucleotide polymorphisms (SNP)</p></a></li>
<li><a href='#replace.missing'><p>(Internal function) Replace missing values by specified values, internally</p>
used for parallelization</a></li>
<li><a href='#save.eigenplots.html'><p>Generate HTML file for EigenFit plots</p></a></li>
<li><a href='#save.html'><p>Generate HTML file for clustering result in text mode</p></a></li>
<li><a href='#save.plots'><p>Workflow to generate HTML files for all kinds of plots</p></a></li>
<li><a href='#save.plots.cluster.html'><p>Generate HTML file for scatter plots which all data points are highlighted by IPCAPS clusters</p></a></li>
<li><a href='#save.plots.label.html'><p>Generate HTML file for scatter plots which data points are highlighted by given labels</p></a></li>
<li><a href='#top.discriminator'><p>Detecting top discriminators between two groups</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Iterative Pruning to Capture Population Structure</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.8</td>
</tr>
<tr>
<td>Description:</td>
<td>An unsupervised clustering algorithm based on iterative pruning is for capturing population structure. This version supports ordinal data which can be applied directly to SNP data to identify fine-level population structure and it is built on the iterative pruning Principal Component Analysis ('ipPCA') algorithm as explained in Intarapanich et al. (2009) &lt;<a href="https://doi.org/10.1186%2F1471-2105-10-382">doi:10.1186/1471-2105-10-382</a>&gt;. The 'IPCAPS' involves an iterative process using multiple splits based on multivariate Gaussian mixture modeling of principal components and 'Expectation-Maximization' clustering as explained in Lebret et al. (2015) &lt;<a href="https://doi.org/10.18637%2Fjss.v067.i06">doi:10.18637/jss.v067.i06</a>&gt;. In each iteration, rough clusters and outliers are also identified using the function rubikclust() from the R package 'KRIS'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats,utils,graphics,grDevices,MASS,Matrix,expm,KRIS,fpc,LPCM,apcluster,Rmixmod</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/kris.ccp/ipcaps/-/issues">https://gitlab.com/kris.ccp/ipcaps/-/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/kris.ccp/ipcaps">https://gitlab.com/kris.ccp/ipcaps</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'parallelization.R' 'check.stopping.R' 'clustering.mode.R'
'clustering.R' 'data.R' 'export.groups.R' 'get.node.info.R'
'ipcaps-package.R' 'process.each.node.R' 'output.template.R'
'save.html.R' 'save.eigenplots.html.R'
'save.plots.label.html.R' 'save.plots.cluster.html.R'
'save.plots.R' 'postprocess.R' 'preprocess.R' 'ipcaps.R'
'top.discriminator.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-25 11:25:50 UTC; kris</td>
</tr>
<tr>
<td>Author:</td>
<td>Kridsadakorn Chaichoompu [aut, cre],
  Kristel Van Steen [aut],
  Fentaw Abegaz [aut],
  Sissades Tongsima [aut],
  Philip Shaw [aut],
  Anavaj Sakuntabhai [aut],
  Luisa Pereira [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kridsadakorn Chaichoompu &lt;kridsadakorn@biostatgen.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-25 17:00:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='IPCAPS-package'>IPCAPS : Iterative Pruning to CApture Population Structure</h2><span id='topic+IPCAPS'></span><span id='topic+IPCAPS-package'></span>

<h3>Description</h3>

<p>An unsupervised clustering algorithm based on iterative pruning is for capturing
population structure. This version supports ordinal data which can be applied
directly to SNP data to identify fine-level population structure and it is
built on the iterative pruning Principal Component Analysis (ipPCA) algorithm
(Intarapanich et al., 2009; Limpiti et al., 2011). The IPCAPS involves an
iterative process using multiple splits based on multivariate Gaussian
mixture modeling of principal components and Clustering EM estimation as explained in
Lebret et al. (2015). In each iteration, rough clusters and outliers are also
identified using the function rubikclust() from the R package <span class="pkg">KRIS</span>.
</p>


<h3>Details</h3>

<p>The R package <span class="pkg">IPCAPS</span> requires the package <span class="pkg">KRIS</span>.
</p>
<p>Here is the list of functions in the R package <span class="pkg">IPCAPS</span>:
</p>

<ul>
<li> <p><code><a href="#topic+export.groups">export.groups</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get.node.info">get.node.info</a></code>
</p>
</li>
<li> <p><code><a href="#topic+ipcaps">ipcaps</a></code>
</p>
</li>
<li> <p><code><a href="#topic+save.eigenplots.html">save.eigenplots.html</a></code>
</p>
</li>
<li> <p><code><a href="#topic+save.html">save.html</a></code>
</p>
</li>
<li> <p><code><a href="#topic+save.plots.cluster.html">save.plots.cluster.html</a></code>
</p>
</li>
<li> <p><code><a href="#topic+save.plots.label.html">save.plots.label.html</a></code>
</p>
</li>
<li> <p><code><a href="#topic+save.plots">save.plots</a></code>
</p>
</li>
<li> <p><code><a href="#topic+top.discriminator">top.discriminator</a></code>
</p>
</li></ul>

<p>Moreover, here is the list of example datasets in the R package <span class="pkg">IPCAPS</span>:
</p>

<ul>
<li> <p><code><a href="#topic+raw.data">raw.data</a></code>
</p>
</li>
<li> <p><code><a href="#topic+label">label</a></code>
</p>
</li>
<li> <p><code><a href="#topic+PC">PC</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kridsadakorn Chaichoompu <a href="mailto:kridsadakorn@biostatgen.org">kridsadakorn@biostatgen.org</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Kristel Van Steen
</p>
</li>
<li><p> Fentaw Abegaz
</p>
</li>
<li><p> Sissades Tongsima
</p>
</li>
<li><p> Philip Shaw
</p>
</li>
<li><p> Anavaj Sakuntabhai
</p>
</li>
<li><p> Luisa Pereira
</p>
</li></ul>



<h3>References</h3>

<p>Intarapanich, A., Shaw, P.J., Assawamakin, A., Wangkumhang, P., Ngamphiw, C.,
Chaichoompu, K., Piriyapongsa, J., and Tongsima, S. (2009). Iterative pruning
PCA improves resolution of highly structured populations. BMC Bioinformatics
10, 382.
</p>
<p>Lebret, R., Iovleff, S., Langrognet, F., Biernacki, C., Celeux, G., and
Govaert, G. (2015). Rmixmod: TheRPackage of the Model-Based Unsupervised,
Supervised, and Semi-Supervised ClassificationMixmodLibrary. J. Stat. Softw.
67.
</p>
<p>Limpiti, T., Intarapanich, A., Assawamakin, A., Shaw, P.J., Wangkumhang, P.,
Piriyapongsa, J., Ngamphiw, C., and Tongsima, S. (2011). Study of large and
highly stratified population datasets by combining iterative pruning
principal component analysis and structure. BMC Bioinformatics 12, 255.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gitlab.com/kris.ccp/ipcaps">https://gitlab.com/kris.ccp/ipcaps</a>
</p>
</li>
<li><p> Report bugs at <a href="https://gitlab.com/kris.ccp/ipcaps/-/issues">https://gitlab.com/kris.ccp/ipcaps/-/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cal.eigen.fit'>(Internal function) Calculae a vector of EigenFit values, internally used for
parallelization</h2><span id='topic+cal.eigen.fit'></span>

<h3>Description</h3>

<p>(Internal function) Calculae a vector of EigenFit values, internally used for
parallelization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal.eigen.fit(eigen.value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal.eigen.fit_+3A_eigen.value">eigen.value</code></td>
<td>
<p>A vector of Eigenvalues return from <code><a href="base.html#topic+svd">svd</a></code>
($d), <code>rARPACK::svds</code> ($d),  <code><a href="base.html#topic+eigen">eigen</a></code>
($values) or <code>rARPACK::eigs</code> ($values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of all possible values for EigenFit.
</p>

<hr>
<h2 id='check.stopping'>(Internal function) Check whether the IPCAPS process meets the stopping
criterion.</h2><span id='topic+check.stopping'></span>

<h3>Description</h3>

<p>(Internal function) Check whether the IPCAPS process meets the stopping
criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.stopping(eigen.value, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.stopping_+3A_eigen.value">eigen.value</code></td>
<td>
<p>A vector of Eigenvalues return from <code>svd</code> ($d),
<code>rARPACK::svds</code> ($d),  <code>eigen</code> ($values) or <code>rARPACK::eigs</code> ($values).</p>
</td></tr>
<tr><td><code id="check.stopping_+3A_threshold">threshold</code></td>
<td>
<p>A threshold or a cutoff to stop the IPCAPS process. Also see
<code><a href="#topic+ipcaps">ipcaps</a></code> (the parameter <code>threshold</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing <code>status</code>, <code>eigen.value</code>, <code>eigen.fit</code>,
<code>threshold</code>, and <code>no.significant.PC</code> as explained below:
</p>

<ul>
<li> <p><code>$status</code> is either <code>0</code> representing that the criterion is
not met, or <code>1</code> representing that the criterion is met.
</p>
</li>
<li> <p><code>$eigen.value</code> is a vector of Eigenvalues as the input parameter.
</p>
</li>
<li> <p><code>$eigen.fit</code> is a vector of EigenFit values.
</p>
</li>
<li> <p><code>$threshold</code> is a threashold as the input parameter.
</p>
</li>
<li> <p><code>$no.significant.PC</code> is an estimated number of sinificant
principal components (PC).
</p>
</li></ul>


<hr>
<h2 id='clustering'>(Internal function) Perform the clustering process of IPCAPS</h2><span id='topic+clustering'></span>

<h3>Description</h3>

<p>(Internal function) Perform the clustering process of IPCAPS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering(
  dataframe,
  node = 1,
  result.dir,
  threshold,
  min.fst,
  method = "mix",
  min.in.group = 20,
  datatype = "snp",
  nonlinear = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustering_+3A_dataframe">dataframe</code></td>
<td>
<p>A data frame containing <code>raw.data</code> (matrix or data
frame), <code>label</code> (vector), and <code>index</code> (vector). <code>raw.data</code>
represents a matrix of subset of input data. <code>label</code> represents a vector
of labels for all rows of <code>raw.data</code>. <code>index</code> represents a vector
of indexes that are selected from the original input data.</p>
</td></tr>
<tr><td><code id="clustering_+3A_node">node</code></td>
<td>
<p>An integer representing the current node number which is being
analyzed.</p>
</td></tr>
<tr><td><code id="clustering_+3A_result.dir">result.dir</code></td>
<td>
<p>An output directory</p>
</td></tr>
<tr><td><code id="clustering_+3A_threshold">threshold</code></td>
<td>
<p>A threshold or a cutoff to stop the IPCAPS process. Also see
<code><a href="#topic+ipcaps">ipcaps</a></code> (the parameter <code>threshold</code>).</p>
</td></tr>
<tr><td><code id="clustering_+3A_min.fst">min.fst</code></td>
<td>
<p>A number represents a cutoff for mininum Fst value.</p>
</td></tr>
<tr><td><code id="clustering_+3A_method">method</code></td>
<td>
<p>A clustering method selected from the <code><a href="#topic+ipcaps">ipcaps</a></code>
function. See <code><a href="#topic+ipcaps">ipcaps</a></code> for available methods.</p>
</td></tr>
<tr><td><code id="clustering_+3A_min.in.group">min.in.group</code></td>
<td>
<p>A integer represents a minimum number of group members.</p>
</td></tr>
<tr><td><code id="clustering_+3A_datatype">datatype</code></td>
<td>
<p>To specify whether the input data are 'snp' or other type.
Defalut = 'snp'.</p>
</td></tr>
<tr><td><code id="clustering_+3A_nonlinear">nonlinear</code></td>
<td>
<p>(Unimplemented) To specify whether linear or non-linear
method is used for IPCAPS analysis. If TRUE, non-linear method is used,
otherwise linear method is used. Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing <code>status</code>, <code>node</code>, and <code>new.index</code>
as explained below:
</p>

<ul>
<li> <p><code>$status</code> is either <code>0</code> representing that the criterion is
not met, or <code>1</code> representing that the criterion is met.
</p>
</li>
<li> <p><code>$node</code> is an integer representing the current node number which
is being analyzed.
</p>
</li>
<li> <p><code>$new.index</code> is a list of vectors containing a subset of indexes
split from <code>dataframe$index</code> according to a clustering result.
</p>
</li></ul>


<hr>
<h2 id='clustering.mode'>(Internal function) Select a clustering method to be used for the IPCAPS
process.</h2><span id='topic+clustering.mode'></span>

<h3>Description</h3>

<p>(Internal function) Select a clustering method to be used for the IPCAPS
process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering.mode(node, work.dir, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustering.mode_+3A_node">node</code></td>
<td>
<p>An integer representing the current node number which is being
analyzed.</p>
</td></tr>
<tr><td><code id="clustering.mode_+3A_work.dir">work.dir</code></td>
<td>
<p>A working directory.</p>
</td></tr>
<tr><td><code id="clustering.mode_+3A_method">method</code></td>
<td>
<p>A clustering method selected from the <code><a href="#topic+ipcaps">ipcaps</a></code>
function. See <code><a href="#topic+ipcaps">ipcaps</a></code> for available methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of cluster assignment, for which cluster each individual
belongs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ipcaps">ipcaps</a></code>
</p>

<hr>
<h2 id='diff.eigen.fit'>(Internal function) Calculate a vector of different values from a vector of
EigenFit values, internally used for parallelization</h2><span id='topic+diff.eigen.fit'></span>

<h3>Description</h3>

<p>(Internal function) Calculate a vector of different values from a vector of
EigenFit values, internally used for parallelization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eigen.fit'
diff(eigen.value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff.eigen.fit_+3A_eigen.value">eigen.value</code></td>
<td>
<p>A vector of Eigenvalues return from <code>svd</code> ($d),
<code>rARPACK::svds</code> ($d), <code>eigen</code> ($values) or <code>rARPACK::eigs</code> ($values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of different values from a vector of EigenFit values
</p>

<hr>
<h2 id='diff.xy'>(Internal function) Check the different value of X and Y, internally used for
parallelization</h2><span id='topic+diff.xy'></span>

<h3>Description</h3>

<p>(Internal function) Check the different value of X and Y, internally used for
parallelization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xy'
diff(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff.xy_+3A_x">x</code></td>
<td>
<p>The first number</p>
</td></tr>
<tr><td><code id="diff.xy_+3A_y">y</code></td>
<td>
<p>The second number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The different number of <code>x</code> and <code>y</code>.
</p>

<hr>
<h2 id='do.glm'>(Internal function) Perform regression models, internally used for
parallelization</h2><span id='topic+do.glm'></span>

<h3>Description</h3>

<p>(Internal function) Perform regression models, internally used for
parallelization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do.glm(X, PC, method = "linear")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do.glm_+3A_x">X</code></td>
<td>
<p>A vector of data</p>
</td></tr>
<tr><td><code id="do.glm_+3A_pc">PC</code></td>
<td>
<p>A matrix of principal components</p>
</td></tr>
<tr><td><code id="do.glm_+3A_method">method</code></td>
<td>
<p>Specify a method to be used for regression model, which can be
&quot;linear&quot;, &quot;poisson&quot;, and &quot;negative.binomial&quot;. Default = &quot;linear&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of residuals computed from regression model
</p>

<hr>
<h2 id='export.groups'>Export the IPCAPS result to a text file</h2><span id='topic+export.groups'></span>

<h3>Description</h3>

<p>Export clustering result of
<code><a href="#topic+ipcaps">ipcaps</a></code> to text file called 'groups.txt'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.groups(result.dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export.groups_+3A_result.dir">result.dir</code></td>
<td>
<p>A result directory as the <code>$output</code> object returned
from the <code><a href="#topic+ipcaps">ipcaps</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After running, this function exports the file called 'groups.txt' to the same result
directory. If 'groups.txt' already exists in the result directory, the
exported file is changed to 'groups1.txt', 'groups2.txt', 'groups3.txt', ...,
accordingly.
</p>


<h3>Value</h3>

<p>A data frame of exported data containing 4 columns; <code>group</code>,
<code>node</code>, <code>label</code>, <code>row.number</code>, as described below for more
details:
</p>

<ul>
<li> <p><code>group</code> represents group membership of IPCAPS result.
</p>
</li>
<li> <p><code>node</code> represents node numbers of IPCAPS result.
</p>
</li>
<li> <p><code>label</code> represents labels of rows in orginal input data.
</p>
</li>
<li> <p><code>row.number</code> represents row numbers of orginal input data.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Importantly, bed file, bim file, and fam file are required
# Use the example files embedded in the package

BED.file &lt;- system.file("extdata","ipcaps_example.bed",package="IPCAPS")
LABEL.file &lt;- system.file("extdata","ipcaps_example_individuals.txt.gz",package="IPCAPS")

my.cluster &lt;- ipcaps(bed=BED.file,label.file=LABEL.file,lab.col=2,out=tempdir())

#Here, to export the IPCAPS result to a text file
exported.data &lt;- export.groups(my.cluster$output.dir)
print(dim(exported.data))
head(exported.data)
</code></pre>

<hr>
<h2 id='get.node.info'>Get the information for specified node</h2><span id='topic+get.node.info'></span>

<h3>Description</h3>

<p>Obtain the information for specified
node from the output list of <code><a href="#topic+ipcaps">ipcaps</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.node.info(cluster.obj, node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.node.info_+3A_cluster.obj">cluster.obj</code></td>
<td>
<p>A list returned from the <code><a href="#topic+ipcaps">ipcaps</a></code> function.</p>
</td></tr>
<tr><td><code id="get.node.info_+3A_node">node</code></td>
<td>
<p>An integer representing a node number to enquire information as
shown in the HTML output files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value is <code>NULL</code> if node's information does not exist or a list containing
<code>PCs</code>, <code>eigen.fit</code>, <code>index</code>, and <code>label</code> as explained
below:
</p>

<ul>
<li> <p><code>$PCs</code> is a matrix of pricipal components of this node.
</p>
</li>
<li> <p><code>$eigen.fit</code> is a number represeting the EigenFit value of this
node.
</p>
</li>
<li> <p><code>$index</code> is a vector of row number (individuals) of <code>raw.data</code> (input data).
</p>
</li>
<li> <p><code>$label</code> is the vector of labels of all individuals that belongs
to this node.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Importantly, bed file, bim file, and fam file are required
# Use the example files embedded in the package

BED.file &lt;- system.file("extdata","ipcaps_example.bed",package="IPCAPS")
LABEL.file &lt;- system.file("extdata","ipcaps_example_individuals.txt.gz",package="IPCAPS")

my.cluster &lt;- ipcaps(bed=BED.file,label.file=LABEL.file,lab.col=2,out=tempdir())

#Here, to obtain the information of specified node, for example, node 3
node.info &lt;- get.node.info(my.cluster,3)
ls(node.info)
</code></pre>

<hr>
<h2 id='ipcaps'>Perform unsupervised clustering to capture population structure based on iterative pruning</h2><span id='topic+ipcaps'></span>

<h3>Description</h3>

<p>This version supports ordinal data which can be applied directly
to SNP data to identify fine-scale population structure. It was built on the
iterative pruning Principal Component Analysis (ipPCA) algorithm
(Intarapanich et al., 2009; Limpiti et al., 2011). The IPCAPS involves an
iterative process using multiple splits based on multivariate Gaussian
mixture modeling of principal components and Clustering EM estimation (Lebret
et al., 2015). In each iteration, rough clusters and outliers are also
identified using our own method called rubikclust (R package <span class="pkg">KRIS</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipcaps(
  bed = NA,
  rdata = NA,
  files = NA,
  label.file = NA,
  lab.col = 1,
  out,
  plot.as.pdf = FALSE,
  method = "mix",
  missing = NA,
  covariate = NA,
  cov.col.first = NA,
  cov.col.last = NA,
  threshold = 0.18,
  min.fst = 8e-04,
  min.in.group = 20,
  no.plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipcaps_+3A_bed">bed</code></td>
<td>
<p>A PLINK binary format consists of 3 files; bed, bim, and fam. To
generate these files from PLINK, use option –make-bed. See more details at:
<a href="http://zzz.bwh.harvard.edu/plink/data.shtml">http://zzz.bwh.harvard.edu/plink/data.shtml</a>.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_rdata">rdata</code></td>
<td>
<p>In case of re-analysis, it is convenient to run IPCAPS using the
file rawdata.RData generated by IPCAPS. This file contains a matrix of SNPs
(raw.data) and a vector of labels (label).</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_files">files</code></td>
<td>
<p>IPCAPS supports SNPs encoded as 0, 1 and 2 (dosage encoding).
Rows represent SNPs and columns represent subjects. Each column needs to be
separated by a space or a tab. A big text file should be divided into smaller
files to load faster. For instance, to input 3 files, use as: files=c(
'input1.txt', 'input2.txt', 'input3.txt').</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_label.file">label.file</code></td>
<td>
<p>An additional useful information (called &quot;labels&quot; in
IPCAPS) related subject, for example, geographic location or disease
phenotype. These labels (one at a time) are used in displaying the clustering
outcome of IPCAPS. A label file must contain at least one column. However,
it may contain more than one column in which case each column need to be
separated by a space or a tab.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_lab.col">lab.col</code></td>
<td>
<p>The label in the label file to be used in the tree-like
display of IPCAPS clustering results.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_out">out</code></td>
<td>
<p>To set an absolute path for IPCAPS output. If the specified output
directory already exists, result files are saved in sub-directories
cluster_out, cluster_out1, cluster_out2, etc.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_plot.as.pdf">plot.as.pdf</code></td>
<td>
<p>To export plots as PDF. When omitted, plots are saved as PNG.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_method">method</code></td>
<td>
<p>The internal clustering method. It can be set to &quot;mix&quot;
(rubikclust &amp; mixmod), &quot;mixmod&quot; (Lebret et al., 2015), &quot;clara&quot; (R: Clustering
Large Applications), &quot;pam&quot; (R: Partitioning Around Medoids (PAM) Object),
&quot;meanshift&quot; (Wang, 2016), &quot;apcluster&quot; (Bodenhofer et al., 2016), and &quot;hclust&quot;
(R: Hierarchical Clustering). Default = &quot;mix&quot;.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_missing">missing</code></td>
<td>
<p>Symbol used for missing genotypes. Default = NA.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_covariate">covariate</code></td>
<td>
<p>A file of covariates; one covariate per column. SNPs can be
adjusted for these covariates via regression modeling and residual
computation.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_cov.col.first">cov.col.first</code></td>
<td>
<p>Refer to a covariate file, the first covariate to be
considered as confounding variable.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_cov.col.last">cov.col.last</code></td>
<td>
<p>Refer to a covariate file, the last covariate to be
considered as confounding variable. All the variables in between the
cov.col.first and cov.col.last will be considered in the adjustment process.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_threshold">threshold</code></td>
<td>
<p>Cutoff value for EigenFit. Possible values range from 0.03
to 0.18. The smaller, the potentially finer the substructure can be. Default
= 0.18.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_min.fst">min.fst</code></td>
<td>
<p>Minimum Fst between a pair of subgroups. Default = 0.0008.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_min.in.group">min.in.group</code></td>
<td>
<p>Minimum number of individuals to constitute a cluster or
subgroup. Default = 20.</p>
</td></tr>
<tr><td><code id="ipcaps_+3A_no.plot">no.plot</code></td>
<td>
<p>No plot is generated if this option is TRUE. This option is
useful when the system does not support X Windows in the unix based system.
Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computational time depends on the number of individuals.
Consequentially, if large data sets are analyzed, it may be necessary first
to split data into smaller files, and then load into computer memory (with
parameter 'files'). Internally, the split files are merged to construct
a com-prehensive matrix.
</p>


<h3>Value</h3>

<p>Returns the list object containing 2 internal objects;
output.dir as class character and cluster as class data.frame. The object
output.dir stores a result directory. The object cluster contains 4 columns,
group, node, label, and row.number. The column group contains the assigned
groups from IPCAPS. The column node contains node numbers in a tree as
illustrated in the HTML result files. The column label contains the given
labels that is set to the parameter label. The column row.number contains
indices to an input data, which is matched to row numbers of input matrix.
All clustering result files are saved in one directory (as specified by out)
containing assigned groups, hierarchical trees of group membership, PC plots,
and binary data for further analysis.
</p>

<ul>
<li> <p><code>$snp</code> is a SNP matrix from BED file.
</p>
</li>
<li> <p><code>$snp.info</code> is a data.frame of SNP information from BIM file.
</p>
</li>
<li> <p><code>$ind.info</code> is a data.frame of individual information from FAM file.
</p>
</li></ul>

<p>If function return <code>NULL</code>, it means the input files are not in proper
format.
</p>


<h3>References</h3>

<p>Bodenhofer, U., Palme, J., Melkonian, C., and Kothmeier, A. (2016). apcluster
: Affinity Propagation Clustering. Available at: <a href="https://CRAN.R-project.org/package=apcluster">https://CRAN.R-project.org/package=apcluster</a> (Accessed March 7, 2017).
</p>
<p>Intarapanich, A., Shaw, P. J., Assawamakin, A., Wangkumhang, P., Ngamphiw, C.
, Chaichoompu, K., et al. (2009). Iterative pruning PCA improves resolution
of highly structured populations. BMC Bioinformatics 10, 382. doi:10.1186/
1471-2105-10-382.
</p>
<p>Lebret, R., Iovleff, S., Langrognet, F., Biernacki, C., Celeux, G., and
Govaert, G. (2015). Rmixmod: TheRPackage of the Model-Based Unsupervised,
Supervised, and Semi-Supervised ClassificationMixmodLibrary. J. Stat. Softw.
67. doi:10.18637/jss.v067.i06.
</p>
<p>Limpiti, T., Intarapanich, A., Assawamakin, A., Shaw, P. J., Wangkumhang, P.,
Piriyapongsa, J., et al. (2011). Study of large and highly stratified
population datasets by combining iterative pruning principal component
analysis and structure. BMC Bioinformatics 12, 255. doi:10.1186/1471-2105-12-
255.
</p>
<p>Maechler, M., Rousseeuw, P., Struyf, A., Hubert, M., and Hornik, K. (2017).
cluster: Cluster Analysis Basics and Extensions.
</p>
<p>R: Clustering Large Applications Available at: <a href="https://stat.ethz.ch/R-manual/R-devel/library/cluster/html/clara.html">https://stat.ethz.ch/R-manual/R-devel/library/cluster/html/clara.html</a> (Accessed March 7, 2017).
</p>
<p>R Core Team (2017). R: A Language and Environment for Statistical Computing.
Vienna, Austria: R Foundation for Statistical Computing Available at:
<a href="https://www.R-project.org/">https://www.R-project.org/</a>.
</p>
<p>R: Hierarchical Clustering Available at: <a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/hclust.html">https://stat.ethz.ch/R-manual/R-devel/library/stats/html/hclust.html</a> (Accessed March 7, 2017).
</p>
<p>R: Partitioning Around Medoids (PAM) Object Available at: <a href="https://stat.ethz.ch/R-manual/R-devel/library/cluster/html/pam.object.html">https://stat.ethz.ch/R-manual/R-devel/library/cluster/html/pam.object.html</a> (Accessed
March 7, 2017).
</p>
<p>Wang, M. C. and D. (2016). MeanShift: Clustering via the Mean Shift
Algorithm. Available at: <a href="https://CRAN.R-project.org/package=MeanShift">https://CRAN.R-project.org/package=MeanShift</a>
(Accessed March 7, 2017).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Use the BED format as input
#Importantly, bed file, bim file, and fam file are required
#Use the example files embedded in the package

BED.file &lt;- system.file("extdata", "ipcaps_example.bed", package = "IPCAPS")
LABEL.file &lt;- system.file("extdata", "ipcaps_example_individuals.txt.gz",
                          package = "IPCAPS")
my.cluster1 &lt;- ipcaps(bed = BED.file, label.file = LABEL.file, lab.col = 2,
out = tempdir())

table(my.cluster1$cluster$label, my.cluster1$cluster$group)

# Alternatively, use a text file as input
# Use the example files embedded in the package

#text.file &lt;- system.file("extdata", "ipcaps_example_rowVar_colInd.txt.gz",
#                          package="IPCAPS")
#LABEL.file &lt;- system.file("extdata", "ipcaps_example_individuals.txt.gz",
#                           package="IPCAPS")

#my.cluster2 &lt;- ipcaps(files = c(text.file), label.file = LABEL.file, lab.col = 2,
#                       out=tempdir())
#table(my.cluster2$cluster$label, my.cluster2$cluster$group)

# The other alternative way, use an R Data file as input
# Use the example file embedded in the package

#rdata.file &lt;- system.file("extdata", "ipcaps_example.rda", package = "IPCAPS")

#my.cluster3 &lt;- ipcaps(rdata = rdata.file, out = tempdir())
#table(my.cluster3$cluster$label, my.cluster3$cluster$group)

</code></pre>

<hr>
<h2 id='label'>Synthetic dataset containing population labels for the dataset <code>raw.data</code></h2><span id='topic+label'></span>

<h3>Description</h3>

<p>A dataset contains a character vector of 1,004 elements containing labels or
populations of 1,004 individuals which they belong. Five populations and
outliers were labeled as &quot;pop1&quot;, &quot;pop2&quot;, &quot;pop3&quot;, &quot;pop4&quot;, &quot;pop5&quot;, and &quot;outlier&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ipcaps_example)
</code></pre>


<h3>Format</h3>

<p>A vector with 1,004 elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raw.data">raw.data</a></code> and <code><a href="#topic+PC">PC</a></code>
</p>

<hr>
<h2 id='output.template'>(Internal object) The HTML output template for IPCAPS</h2><span id='topic+output.template'></span>

<h3>Description</h3>

<p><code>output.template</code> contains <code>$lno_title</code>, <code>$lno_data</code>,
<code>$lno_leafnode</code>, <code>$lno_body</code>, and <code>$template</code> as explained
below:
</p>

<dl>
<dt>lno_title</dt><dd><p>A index number of <code>$template</code> that a title of HTML
file is replaced.</p>
</dd>
<dt>lno_data</dt><dd><p>A index number of <code>$template</code> that a data section in
the HTML file is replaced.</p>
</dd>
<dt>lno_leafnode</dt><dd><p>A index number of <code>$template</code> that a leaf-node
section in the HTML file is replaced.</p>
</dd>
<dt>lno_body</dt><dd><p>A index number of <code>$template</code> that a body section in
the HTML file is replaced.</p>
</dd>
<dt>template</dt><dd><p>A vector of characters for HTML file.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>output.template
</code></pre>


<h3>Format</h3>

<p>A list with with 5 objects
</p>

<hr>
<h2 id='pasre.categorical.data'>(Internal function) Manipulate categorical input files</h2><span id='topic+pasre.categorical.data'></span>

<h3>Description</h3>

<p>(Internal function) Manipulate categorical input files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pasre.categorical.data(files)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pasre.categorical.data_+3A_files">files</code></td>
<td>
<p>IPCAPS supports categorical data, which rows represent features
and columns represent subjects or individuals. Each column needs to be
separated by a space or a tab. A big text file should be divided into smaller
files to load faster. For instance, to input 3 files, use as: files=c(
'input1.txt', 'input2.txt', 'input3.txt').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of input data
</p>

<hr>
<h2 id='PC'>Synthetic dataset containing the top 10 principal components (PC) from the
dataset <code>raw.data</code></h2><span id='topic+PC'></span>

<h3>Description</h3>

<p>A dataset contains a numeric matrix of 1,004 rows and 10 columns of top 10
PCs calculated from the dataset <code>raw.data</code>. The PCs were calculated
using linear principal component analysis (PCA), see more datails at
<code>KRIS::cal.pc.linear</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ipcaps_example)
</code></pre>


<h3>Format</h3>

<p>A matrix with 10 columns and 1,004 rows
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raw.data">raw.data</a></code> and <code><a href="#topic+label">label</a></code>
</p>

<hr>
<h2 id='postprocess'>(Internal function) Perform the post-processing step of IPCAPS</h2><span id='topic+postprocess'></span>

<h3>Description</h3>

<p>(Internal function) Perform the post-processing step of IPCAPS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postprocess(result.dir, reanalysis = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postprocess_+3A_result.dir">result.dir</code></td>
<td>
<p>A result directory as the <code>$output</code> object returned
from the <code><a href="#topic+ipcaps">ipcaps</a></code> function.</p>
</td></tr>
<tr><td><code id="postprocess_+3A_reanalysis">reanalysis</code></td>
<td>
<p>(Unimplemented) To specify whether it is re-analysis or not. If TRUE, it is
re-analysis, otherwise it is not. Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of clustering result containing 4 columns;
<code>group</code>, <code>node</code>, <code>label</code>, <code>row.number</code>, as described
below for more details:
</p>

<ul>
<li> <p><code>group</code> represents group membership of IPCAPS result.
</p>
</li>
<li> <p><code>node</code> represents node numbers of IPCAPS result.
</p>
</li>
<li> <p><code>label</code> represents labels of rows in orginal input data.
</p>
</li>
<li> <p><code>row.number</code> represents row numbers of orginal input data.
</p>
</li></ul>


<hr>
<h2 id='preprocess'>(Internal function) Perform the pre-processing step of IPCAPS</h2><span id='topic+preprocess'></span>

<h3>Description</h3>

<p>(Internal function) Perform the pre-processing step of IPCAPS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess(
  files,
  label.file,
  lab.col,
  rdata.infile,
  bed.infile,
  cate.list,
  result.dir,
  threshold,
  min.fst,
  max.thread = NA,
  reanalysis = FALSE,
  method = "mix",
  min.in.group = 20,
  datatype = "snp",
  nonlinear = FALSE,
  missing.char = NA,
  regression.file = NA,
  regression.col.first = NA,
  regression.col.last = NA,
  reg.method = "linear",
  plot.as.pdf = NA,
  no.plot = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_+3A_files">files</code></td>
<td>
<p>IPCAPS supports SNPs encoded as 0, 1 and 2 (dosage encoding).
Rows represent SNPs and columns represent subjects. Each column needs to be
separated by a space or a tab. A big text file should be divided into smaller
files to load faster. For instance, to input 3 files, use as: files=c(
'input1.txt', 'input2.txt', 'input3.txt').</p>
</td></tr>
<tr><td><code id="preprocess_+3A_label.file">label.file</code></td>
<td>
<p>An additional useful information (called &quot;labels&quot; in
IPCAPS) related subject, for example, geographic location or disease
phenotype. These labels (one at a time) are used in displaying the clustering
outcome of IPCAPS. A label file must contain at least one column. However,
it may contain more than one column in which case each column need to be
separated by a space or a tab.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_lab.col">lab.col</code></td>
<td>
<p>The label in the label file to be used in the tree-like
display of IPCAPS clustering results.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_rdata.infile">rdata.infile</code></td>
<td>
<p>In case of re-analysis, it is convenient to run IPCAPS
using the file rawdata.RData generated by IPCAPS. This file contains a matrix
of SNPs
(raw.data) and a vector of labels (label).</p>
</td></tr>
<tr><td><code id="preprocess_+3A_bed.infile">bed.infile</code></td>
<td>
<p>A PLINK binary format consists of 3 files; bed, bim, and
fam. To generate these files from PLINK, use option –make-bed. See more
details at: <a href="http://zzz.bwh.harvard.edu/plink/data.shtml">http://zzz.bwh.harvard.edu/plink/data.shtml</a>.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_cate.list">cate.list</code></td>
<td>
<p>(Unimplemented) A list of categorical input file (text). For
instance, to input 3 files, use as: files=c('input1.txt', 'input2.txt',
'input3.txt').</p>
</td></tr>
<tr><td><code id="preprocess_+3A_result.dir">result.dir</code></td>
<td>
<p>To set an absolute path for IPCAPS output. If the specified output
directory already exists, result files are saved in sub-directories
cluster_out, cluster_out1, cluster_out2, etc.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_threshold">threshold</code></td>
<td>
<p>Cutoff value for EigenFit.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_min.fst">min.fst</code></td>
<td>
<p>Minimum Fst between a pair of subgroups.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_max.thread">max.thread</code></td>
<td>
<p>(Require the parallelization patch) Maximum number of
concurrent threads.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_reanalysis">reanalysis</code></td>
<td>
<p>(Unimplemented) To specify whether it is re-analysis or
not. If TRUE, it is re-analysis, otherwise it is not. Default = FALSE.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_method">method</code></td>
<td>
<p>The internal clustering method. It can be set to &quot;mix&quot;
(rubikclust &amp; mixmod), &quot;mixmod&quot; (Lebret et al., 2015), &quot;clara&quot; (R: Clustering
Large Applications), &quot;pam&quot; (R: Partitioning Around Medoids (PAM) Object),
&quot;meanshift&quot; (Wang, 2016), &quot;apcluster&quot; (Bodenhofer et al., 2016), and &quot;hclust&quot;
(R: Hierarchical Clustering). Default = &quot;mix&quot;.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_min.in.group">min.in.group</code></td>
<td>
<p>Minimum number of individuals to constitute a cluster or
subgroup.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_datatype">datatype</code></td>
<td>
<p>To specify whether the input data are 'snp' or other type.
Defalut = 'snp'.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_nonlinear">nonlinear</code></td>
<td>
<p>(Unimplemented) To specify whether linear or non-linear
method is used for IPCAPS analysis. If TRUE, non-linear method is used,
otherwise linear method is used. Default = FALSE.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_missing.char">missing.char</code></td>
<td>
<p>Symbol used for missing genotypes. Default = NA.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_regression.file">regression.file</code></td>
<td>
<p>A file of covariates; one covariate per column. SNPs
can be adjusted for these covariates via regression modeling and residual
computation.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_regression.col.first">regression.col.first</code></td>
<td>
<p>Refer to a covariate file, the first covariate to
be considered as confounding variable.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_regression.col.last">regression.col.last</code></td>
<td>
<p>Refer to a covariate file, the last covariate to be
considered as confounding variable. All the variables in between the
cov.col.first and cov.col.last will be considered in the adjustment process.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_reg.method">reg.method</code></td>
<td>
<p>(Fixed) Specify a method for regression analysis.
Default = 'linear'.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_plot.as.pdf">plot.as.pdf</code></td>
<td>
<p>To export plots as PDF. When omitted, plots are saved as
PNG.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_no.plot">no.plot</code></td>
<td>
<p>No plot is generated if this option is TRUE. This option is
useful when the system does not support X Windows in the unix based system.
Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of input data.
</p>

<hr>
<h2 id='process.each.node'>(Internal function) Perform the iterative process for each node</h2><span id='topic+process.each.node'></span>

<h3>Description</h3>

<p>(Internal function) Perform the iterative process for each node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.each.node(node, work.dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process.each.node_+3A_node">node</code></td>
<td>
<p>An integer representing the current node number which is being
analyzed.</p>
</td></tr>
<tr><td><code id="process.each.node_+3A_work.dir">work.dir</code></td>
<td>
<p>A working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='raw.data'>Synthetic dataset containing single nucleotide polymorphisms (SNP)</h2><span id='topic+raw.data'></span>

<h3>Description</h3>

<p>The raw.data is the simulated dataset which consists of 3,000 independent SNPs
and 1,004 individuals belonging to one of 5 populations (200 individuals
each) and 4 outlying individuals. The matrix <code>raw.data</code> contains the number 0, 1,
and 2 representing SNP in additive coding. The pairwise genetic distance between
populations are listed below (see Balding, 1995):
</p>

<table>
<tr>
 <td style="text-align: center;">
</td><td style="text-align: center;"> pop1   </td><td style="text-align: center;"> pop2   </td><td style="text-align: center;">  pop3  </td><td style="text-align: center;">  pop4  </td><td style="text-align: center;">  pop5  </td>
</tr>
<tr>
 <td style="text-align: center;">
pop1 </td><td style="text-align: center;">        </td><td style="text-align: center;"> 0.0040 </td><td style="text-align: center;"> 0.0059 </td><td style="text-align: center;"> 0.0085 </td><td style="text-align: center;"> 0.0101 </td>
</tr>
<tr>
 <td style="text-align: center;">
pop2 </td><td style="text-align: center;"> 0.0040 </td><td style="text-align: center;">        </td><td style="text-align: center;"> 0.0055 </td><td style="text-align: center;"> 0.0082 </td><td style="text-align: center;"> 0.0099 </td>
</tr>
<tr>
 <td style="text-align: center;">
pop3 </td><td style="text-align: center;"> 0.0059 </td><td style="text-align: center;"> 0.0055 </td><td style="text-align: center;">        </td><td style="text-align: center;"> 0.0104 </td><td style="text-align: center;"> 0.0119 </td>
</tr>
<tr>
 <td style="text-align: center;">
pop4 </td><td style="text-align: center;"> 0.0085 </td><td style="text-align: center;"> 0.0082 </td><td style="text-align: center;"> 0.0104 </td><td style="text-align: center;">        </td><td style="text-align: center;"> 0.0139 </td>
</tr>
<tr>
 <td style="text-align: center;">
pop5 </td><td style="text-align: center;"> 0.0101 </td><td style="text-align: center;"> 0.0099 </td><td style="text-align: center;"> 0.0119 </td><td style="text-align: center;"> 0.0139 </td><td style="text-align: center;">
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>data(ipcaps_example)
</code></pre>


<h3>Format</h3>

<p>A matrix with 3,000 columns and 1,004 rows
</p>


<h3>References</h3>

<p>Balding, D.J., and Nichols, R.A. (1995). A method for quantifying
differentiation between populations at multi-allelic loci and its
implications for investigating identity and paternity. Genetica 96, 3-12.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+label">label</a></code> and <code><a href="#topic+PC">PC</a></code>
</p>

<hr>
<h2 id='replace.missing'>(Internal function) Replace missing values by specified values, internally
used for parallelization</h2><span id='topic+replace.missing'></span>

<h3>Description</h3>

<p>(Internal function) Replace missing values by specified values, internally
used for parallelization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace.missing(X, missing = NA, rep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace.missing_+3A_x">X</code></td>
<td>
<p>A vector of data</p>
</td></tr>
<tr><td><code id="replace.missing_+3A_missing">missing</code></td>
<td>
<p>The old characters representing a missing value, for example, 'NA' or '-'</p>
</td></tr>
<tr><td><code id="replace.missing_+3A_rep">rep</code></td>
<td>
<p>The new characters to replace the old characters, for example, 'NULL' or '-1'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of data with replaced character for miss values
</p>

<hr>
<h2 id='save.eigenplots.html'>Generate HTML file for EigenFit plots</h2><span id='topic+save.eigenplots.html'></span>

<h3>Description</h3>

<p>Generate HTML file called 'tree_scree.html' from the result of
<code><a href="#topic+ipcaps">ipcaps</a></code>. This function is a part of workflow in
<code><a href="#topic+save.plots">save.plots</a></code>. The clustering result is shown as a tree rendering
by the online Google Organizational Chart library. Note that the Internet is
required to view the HTML file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.eigenplots.html(output.dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.eigenplots.html_+3A_output.dir">output.dir</code></td>
<td>
<p>A result directory as the <code>$output</code> object returned
from the <code><a href="#topic+ipcaps">ipcaps</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After running, this function generates the file called 'tree_scree.html' in the
same result directory. All plots are generated and saved as image files in
the sub-directory 'images'.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save.html">save.html</a></code>,
<code><a href="#topic+save.plots">save.plots</a></code>,
<code><a href="#topic+save.plots.cluster.html">save.plots.cluster.html</a></code>,
and <code><a href="#topic+save.plots.label.html">save.plots.label.html</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Importantly, bed file, bim file, and fam file are required
# Use the example files embedded in the package

BED.file &lt;- system.file("extdata","ipcaps_example.bed",package="IPCAPS")
LABEL.file &lt;- system.file("extdata","ipcaps_example_individuals.txt.gz",package="IPCAPS")

my.cluster &lt;- ipcaps(bed=BED.file,label.file=LABEL.file,lab.col=2,out=tempdir())

#Here, to generate HTML file
save.eigenplots.html(my.cluster$output.dir)
</code></pre>

<hr>
<h2 id='save.html'>Generate HTML file for clustering result in text mode</h2><span id='topic+save.html'></span>

<h3>Description</h3>

<p>Generate HTML file called 'tree_text.html' from the result of
<code><a href="#topic+ipcaps">ipcaps</a></code>. The clustering result is shown as a tree rendering by
the online Google Organizational Chart library. Note that the Internet is
required to view the HTML file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.html(output.dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.html_+3A_output.dir">output.dir</code></td>
<td>
<p>A result directory as the <code>$output</code> object returned
from the <code><a href="#topic+ipcaps">ipcaps</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After running, this function generates the file called 'tree_text.html' in the
same result directory.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save.plots">save.plots</a></code>,
<code><a href="#topic+save.plots.cluster.html">save.plots.cluster.html</a></code>,
<code><a href="#topic+save.eigenplots.html">save.eigenplots.html</a></code>,
and <code><a href="#topic+save.plots.label.html">save.plots.label.html</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Importantly, bed file, bim file, and fam file are required
# Use the example files embedded in the package

BED.file &lt;- system.file("extdata","ipcaps_example.bed",package="IPCAPS")
LABEL.file &lt;- system.file("extdata","ipcaps_example_individuals.txt.gz",package="IPCAPS")

my.cluster &lt;- ipcaps(bed=BED.file,label.file=LABEL.file,lab.col=2,out=tempdir())

#Here, to generate HTML file
save.html(my.cluster$output.dir)
</code></pre>

<hr>
<h2 id='save.plots'>Workflow to generate HTML files for all kinds of plots</h2><span id='topic+save.plots'></span>

<h3>Description</h3>

<p>Generate HTML files and all image files (plots) from the result
of <code><a href="#topic+ipcaps">ipcaps</a></code>. The clustering result is shown as a tree rendering
by the online Google Organizational Chart library. Note that the Internet is
required to view the HTML files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.plots(output.dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.plots_+3A_output.dir">output.dir</code></td>
<td>
<p>A result directory as the <code>$output</code> object returned
from the <code><a href="#topic+ipcaps">ipcaps</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After running, this function generates all plots and saves as image files in the
sub-directory 'images'. It calls <code><a href="#topic+save.plots.cluster.html">save.plots.cluster.html</a></code>,
<code><a href="#topic+save.eigenplots.html">save.eigenplots.html</a></code>, and <code><a href="#topic+save.plots.label.html">save.plots.label.html</a></code>
to generate all HTML files.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save.html">save.html</a></code>,
<code><a href="#topic+save.plots.cluster.html">save.plots.cluster.html</a></code>,
<code><a href="#topic+save.eigenplots.html">save.eigenplots.html</a></code>,
and <code><a href="#topic+save.plots.label.html">save.plots.label.html</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Importantly, bed file, bim file, and fam file are required
# Use the example files embedded in the package

BED.file &lt;- system.file("extdata","ipcaps_example.bed",package="IPCAPS")
LABEL.file &lt;- system.file("extdata","ipcaps_example_individuals.txt.gz",package="IPCAPS")

my.cluster &lt;- ipcaps(bed=BED.file,label.file=LABEL.file,lab.col=2,out=tempdir())

#Here, to generate all plots and HTML files
save.plots.label.html(my.cluster$output.dir)
</code></pre>

<hr>
<h2 id='save.plots.cluster.html'>Generate HTML file for scatter plots which all data points are highlighted by IPCAPS clusters</h2><span id='topic+save.plots.cluster.html'></span>

<h3>Description</h3>

<p>Generate HTML file called 'tree_scatter_cluster.html' from the
result of <code><a href="#topic+ipcaps">ipcaps</a></code>. This function is a part of workflow in
<code><a href="#topic+save.plots">save.plots</a></code>. The clustering result is shown as a tree rendering
by the online Google Organizational Chart library. Note that the Internet is
required to view the HTML file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.plots.cluster.html(output.dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.plots.cluster.html_+3A_output.dir">output.dir</code></td>
<td>
<p>A result directory as the <code>$output</code> object returned
from the <code><a href="#topic+ipcaps">ipcaps</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After running, this function generates the file called 'tree_scatter_cluster.html'
in the same result directory. All plots are generated and saved as image files
in the sub-directory 'images'.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save.html">save.html</a></code>,
<code><a href="#topic+save.plots">save.plots</a></code>,
<code><a href="#topic+save.eigenplots.html">save.eigenplots.html</a></code>,
and <code><a href="#topic+save.plots.label.html">save.plots.label.html</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Importantly, bed file, bim file, and fam file are required
# Use the example files embedded in the package

BED.file &lt;- system.file("extdata","ipcaps_example.bed",package="IPCAPS")
LABEL.file &lt;- system.file("extdata","ipcaps_example_individuals.txt.gz",package="IPCAPS")

my.cluster &lt;- ipcaps(bed=BED.file,label.file=LABEL.file,lab.col=2,out=tempdir())

#Here, to generate HTML file
save.plots.cluster.html(my.cluster$output.dir)
</code></pre>

<hr>
<h2 id='save.plots.label.html'>Generate HTML file for scatter plots which data points are highlighted by given labels</h2><span id='topic+save.plots.label.html'></span>

<h3>Description</h3>

<p>Generate HTML file called 'tree_scatter_label.html' from the
result of <code><a href="#topic+ipcaps">ipcaps</a></code>. This function is a part of workflow in
<code><a href="#topic+save.plots">save.plots</a></code>. The clustering result is shown as a tree rendering
by the online Google Organizational Chart library. Note that the Internet is
required to view the HTML file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.plots.label.html(output.dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.plots.label.html_+3A_output.dir">output.dir</code></td>
<td>
<p>A result directory as the <code>$output</code> object returned
from the <code><a href="#topic+ipcaps">ipcaps</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After running, this function generates the file called 'tree_scatter_label.html'
in the same result directory. All plots are generated and saved as image files
in the sub-directory 'images'.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save.html">save.html</a></code>,
<code><a href="#topic+save.plots">save.plots</a></code>,
<code><a href="#topic+save.plots.cluster.html">save.plots.cluster.html</a></code>,
and <code><a href="#topic+save.eigenplots.html">save.eigenplots.html</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Importantly, bed file, bim file, and fam file are required
# Use the example files embedded in the package

BED.file &lt;- system.file("extdata","ipcaps_example.bed",package="IPCAPS")
LABEL.file &lt;- system.file("extdata","ipcaps_example_individuals.txt.gz",package="IPCAPS")

my.cluster &lt;- ipcaps(bed=BED.file,label.file=LABEL.file,lab.col=2,out=tempdir())

#Here, to generate HTML file
save.plots.label.html(my.cluster$output.dir)
</code></pre>

<hr>
<h2 id='top.discriminator'>Detecting top discriminators between two groups</h2><span id='topic+top.discriminator'></span>

<h3>Description</h3>

<p>Detects top discriminators that contribute to
group separation based on the fixation index (Fst).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top.discriminator(
  cluster.obj = NULL,
  group1,
  group2,
  bim.file,
  use.node.number = FALSE,
  num.top = 100,
  percentile = 0.9,
  use.percentile = FALSE,
  use.path = FALSE,
  result.path = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top.discriminator_+3A_cluster.obj">cluster.obj</code></td>
<td>
<p>The object which is returned from <code><a href="#topic+ipcaps">ipcaps</a></code>.
This parameter is used when <code>use.path</code> is FALSE.</p>
</td></tr>
<tr><td><code id="top.discriminator_+3A_group1">group1</code></td>
<td>
<p>To specify the first group number to be compared. (also see
<code>use.node.number</code>)</p>
</td></tr>
<tr><td><code id="top.discriminator_+3A_group2">group2</code></td>
<td>
<p>To specify the second group number to be compared. (also see
<code>use.node.number</code>)</p>
</td></tr>
<tr><td><code id="top.discriminator_+3A_bim.file">bim.file</code></td>
<td>
<p>Option: In case that SNP information is not provided to
<code><a href="#topic+ipcaps">ipcaps</a></code>, an absolute path of SNP information file is required.
It needs to be in PLINK format (bim). See more details at:
<a href="http://zzz.bwh.harvard.edu/plink/data.shtml">http://zzz.bwh.harvard.edu/plink/data.shtml</a>.</p>
</td></tr>
<tr><td><code id="top.discriminator_+3A_use.node.number">use.node.number</code></td>
<td>
<p>To specify whether a group number or a node number
is be used. If TRUE, a node nubmer is used instead. Default = FALSE.</p>
</td></tr>
<tr><td><code id="top.discriminator_+3A_num.top">num.top</code></td>
<td>
<p>A number of top Fst SNPs to be returned. This parameter is
used when <code>percentile</code> is FALSE. Default = 100.</p>
</td></tr>
<tr><td><code id="top.discriminator_+3A_percentile">percentile</code></td>
<td>
<p>A percentile for top Fst SNPs to be returned. This parameter
is used when <code>percentile</code> is TRUE. Default = 0.999.</p>
</td></tr>
<tr><td><code id="top.discriminator_+3A_use.percentile">use.percentile</code></td>
<td>
<p>A logical value to indicate whether <code>percentile</code>
is used instead of <code>num.top</code>. This parameter is used when <code>percentile</code>
is TRUE. Default = FALSE.</p>
</td></tr>
<tr><td><code id="top.discriminator_+3A_use.path">use.path</code></td>
<td>
<p>A logical value to indicate whether <code>result.path</code> is
used instead of <code>cluster.obj</code>. Importantly, <code>result.path</code> needs to
be set. This parameter only work with the IPCAPS's result from version 1.1.7
onward. Default = FALSE.</p>
</td></tr>
<tr><td><code id="top.discriminator_+3A_result.path">result.path</code></td>
<td>
<p>A path to an result directory of IPCAPS. This parameter is
used when <code>use.path</code> is TRUE. This parameter only work with the IPCAPS's
result from version 1.1.7 onward.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a data.frame of SNP information sorting by Fst
in descending order, which contains 7 columns, chr, SNP, centimorgans,
position, allele1, allele2, and Fst. The column 1-6 are SNP information from
the bim file. The column Fst contains estimated Fst between group1 and group2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Importantly, bed file, bim file, and fam file are required
# Use the example files embedded in the package
BED.file &lt;- system.file("extdata","ipcaps_example.bed",package="IPCAPS")
LABEL.file &lt;- system.file("extdata","ipcaps_example_individuals.txt.gz",package="IPCAPS")
my.cluster &lt;- ipcaps(bed=BED.file,label.file=LABEL.file,lab.col=2,out=tempdir())
table(my.cluster$cluster$label,my.cluster$cluster$group)
# 1 2 3 4 5 6
# outlier4 5 4 1 0 0 0
# pop1 0 0 0 0 250 0
# pop2 0 0 0 0 0 250
# pop3 0 0 0 250 0 0

#Identify top discriminators between groups, for example, group 4 and group 5
top.snp &lt;-top.discriminator(my.cluster,4,5)
#or, specify the bim file
#top.snp &lt;-top.discriminator(my.cluster,4,5,bim.file="ipcaps_example.bim")
head(top.snp)
# chr SNP centimorgans position allele1 allele2 Fst
#V5452 1 marker5452 0 54520000 A T 0.11337260
#V2348 1 marker2348 0 23480000 A T 0.11194490
#V8244 1 marker8244 0 82440000 A T 0.09556580
#V5972 1 marker5972 0 59720000 A T 0.08747794
#V3561 1 marker3561 0 35610000 A T 0.08725860
#V8419 1 marker8419 0 84190000 A T 0.08293494

#Alternatively, specify the previous result directory of IPCAPS and identify
#top discriminators between groups, for example, group 4 and group 5
previous.res.path &lt;- my.cluster$output.dir
top.snp &lt;-top.discriminator(result.path = previous.res.path, use.path = TRUE,
group1 = 4, group2 = 5)
head(top.snp)

#Identify top discriminators between groups, for example, group 4 and group 5
top.snp &lt;-top.discriminator(my.cluster,4,5)
#or, specify the bim file
#top.snp &lt;-top.discriminator(my.cluster,4,5,bim.file="ipcaps_example.bim")
dim(top.snp)
head(top.snp)

#Here, it is possible to select the top Fst SNPs based on a percentile.
top.snp &lt;-top.discriminator(my.cluster,4,5, percentile = 0.9,
use.percentile = TRUE)
dim(top.snp)
head(top.snp)

#Identify top discriminators between groups, for example, node 7 and node 8
top.snp2 &lt;-top.discriminator(my.cluster,7,8,use.node.number=TRUE)
head(top.snp2)
# chr SNP centimorgans position allele1 allele2 Fst
#V5452 1 marker5452 0 54520000 A T 0.11337260
#V2348 1 marker2348 0 23480000 A T 0.11194490
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
