<!DOCTYPE html><html lang="en"><head><title>Help for package cgaim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cgaim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boot.cgaim'><p>Boostrap CGAIM</p></a></li>
<li><a href='#build_constraints'><p>Common constraints</p></a></li>
<li><a href='#cgaim'><p>Constrained groupwise additive index models</p></a></li>
<li><a href='#cgaim.control'><p>Parameters controlling the CGAIM fit</p></a></li>
<li><a href='#confint.cgaim'><p>Confidence intervals</p></a></li>
<li><a href='#g'><p>Defining terms in CGAIM formula</p></a></li>
<li><a href='#plot.cgaim'><p>Plot ridge function</p></a></li>
<li><a href='#predict.cgaim'><p>Predictions from a fitted CGAIM object</p></a></li>
<li><a href='#print.cgaim'><p>Print a cgaim object</p></a></li>
<li><a href='#vcov.cgaim'><p>Calculate Variance-Covariance Matrix for a Fitted CGAIM Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Constrained Groupwise Additive Index Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits constrained groupwise additive index models and provides functions for inference and interpretation of these models. The method is described in Masselot, Chebana, Campagna, Lavigne, Ouarda, Gosselin (2022) "Constrained groupwise additive index models" &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxac023">doi:10.1093/biostatistics/kxac023</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, scam, scar, quadprog, osqp, limSolve, Matrix,
grDevices, methods, MASS, cgam, mgcv, gratia, doParallel,
coneproj, TruncatedNormal, foreach</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-29 15:33:03 UTC; PierreMasselot</td>
</tr>
<tr>
<td>Author:</td>
<td>Pierre Masselot <a href="https://orcid.org/0000-0002-7326-1290"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre Masselot &lt;pierre.masselot@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-03 11:52:58 UTC</td>
</tr>
</table>
<hr>
<h2 id='boot.cgaim'>Boostrap CGAIM</h2><span id='topic+boot.cgaim'></span>

<h3>Description</h3>

<p>Generates bootstrap replicates of a <code>cgaim</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.cgaim(object, boot.type = c("residuals", "wild", "pairs"),
  bsamples = NULL, B = 100, l = 1, nc = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot.cgaim_+3A_object">object</code></td>
<td>
<p>A <code>cgaim</code> object.</p>
</td></tr>
<tr><td><code id="boot.cgaim_+3A_boot.type">boot.type</code></td>
<td>
<p>The type of bootstrap to perform. Currently
available type are <code>"residuals"</code>, <code>"wild"</code> and 
<code>"pairs"</code>. See details</p>
</td></tr>
<tr><td><code id="boot.cgaim_+3A_bsamples">bsamples</code></td>
<td>
<p>A numerical matrix of observation indices specifying 
bootstrap samples.
Rows indicate observations and columns bootstrap samples.
If <code>NULL</code> (the default), samples are generated internally.</p>
</td></tr>
<tr><td><code id="boot.cgaim_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples to generate when <code>bsamples = NULL</code>.</p>
</td></tr>
<tr><td><code id="boot.cgaim_+3A_l">l</code></td>
<td>
<p>Block length for block-bootstrap. Samples are generated by
resampling block of observation of length <code>l</code>. The classical
bootstrap corresponds to <code>l = 1</code> (the default).</p>
</td></tr>
<tr><td><code id="boot.cgaim_+3A_nc">nc</code></td>
<td>
<p>Positive integer. If <code>nc &gt; 1</code>, the function is parallelized with <code>nc</code> indicating the number of cores to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the <code>cgaim</code> on bootstrap samples.
It is called internally by the <code><a href="#topic+confint.cgaim">confint.cgaim</a></code> function, but can also be
called directly to generate various statistics.
</p>
<p>Three types of bootstrap are currently implemented. <code>"residuals"</code> 
(the default) resamples the residuals in <code>object</code> to then be added to fitted values, creating alternative response vectors. The <code>cgaim</code> is then fitted on these newly generated y values with the original x. <code>"wild"</code> is
similar except that residuals are multiplied by random draws from a
standard normal distribution before being added to fitted values. 
<code>"pairs"</code> resamples directly pairs of y and x to create 
bootstrap samples.
</p>
<p>Bootstrap samples can either be prespecified by the user through
<code>bsamples</code> or generated internally. In the former case, 
the columns of <code>bsamples</code> indicate the number of replications <code>B</code> and
the rows should match the original number of observations. Internally
generated bootstrap samples are controlled by the number of replications
<code>B</code> and block length <code>l</code>, implementing block bootstrap.
The latter is particularly recommended for time series data.
</p>
<p>As fitting a large number of <code>cgaim</code> models can be computationally
intensive, the function can be run in parallel, using the 
<code>doParallel</code> package. This can be done by setting the
argument <code>nc</code> to a value greater than 1, controlling the number
of cores used in parallelization.
</p>


<h3>Value</h3>

<p>A <code>boot.cgaim</code> object with components
</p>
<table role = "presentation">
<tr><td><code>boot</code></td>
<td>
<p>The bootstrap result. A list that includes all
<code>B</code> replications of <code>alpha</code>, <code>beta</code>, <code>gfit</code> and
<code>indexfit</code> organized in arrays.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>The original <code>object</code> passed to the function.</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>The bootstrap samples. A matrix with indices 
corresponding to original observations.</p>
</td></tr>
<tr><td><code>boot.type</code></td>
<td>
<p>The type of bootstrap performed.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The number of bootstrap replications.</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>The block length for block bootstrap.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A simple CGAIM
n &lt;- 200
x1 &lt;- rnorm(n)
x2 &lt;- x1 + rnorm(n)
z &lt;- x1 + x2
y &lt;- z + rnorm(n)
df1 &lt;- data.frame(y, x1, x2) 
ans &lt;- cgaim(y ~ g(x1, x2, acons = list(monotone = 1)), data = df1)

# Use function to compute confidence intervals (B should be increased)
set.seed(1989) 
boot1 &lt;- boot.cgaim(ans, B = 10)
ci1 &lt;- confint(boot1)

# Produces the same result as
set.seed(1989)
ci2 &lt;- confint(ans, type = "boot", B = 10)

# Create sampling beforehand
bsamp &lt;- matrix(sample(1:n, n * 10, replace = TRUE), n)
boot2 &lt;- boot.cgaim(ans, bsamples = bsamp)

# Parallel computing (two cores)

boot3 &lt;- boot.cgaim(ans, nc = 2)


</code></pre>

<hr>
<h2 id='build_constraints'>Common constraints</h2><span id='topic+build_constraints'></span>

<h3>Description</h3>

<p>Build a constraint matrix from common simple constraints. Internally used
by <code><a href="#topic+g">g</a></code> to construct index-specific constraint matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_constraints(p, first = 0, sign = 0, monotone = 0, convex = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_constraints_+3A_p">p</code></td>
<td>
<p>The number of variables.</p>
</td></tr>
<tr><td><code id="build_constraints_+3A_first">first</code></td>
<td>
<p>Indicates sign constraint for first coefficient.
Recommended for identifiability if no other constraint is passed.</p>
</td></tr>
<tr><td><code id="build_constraints_+3A_sign">sign</code></td>
<td>
<p>Sign constraint applied to all coefficients. <code>0</code>: no constraint,</p>
</td></tr>
<tr><td><code id="build_constraints_+3A_monotone">monotone</code></td>
<td>
<p>Monotonicity constraint. <code>0</code>: no constraint, <code>-1</code>:
decreasing coefficients and <code>1</code>: increasing coefficients.</p>
</td></tr>
<tr><td><code id="build_constraints_+3A_convex">convex</code></td>
<td>
<p>Convexity constraint. <code>0</code>: no constraint, <code>-1</code>:
convex coefficients and <code>1</code>: concave coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For monotonicity and convexity / concavity, the function assumes the 
coefficients are ordered. For instance, for increasing monotone coefficients,
the first one will be lower than the second, which be lower than the
third and so on.
</p>
<p>The function automatically removes redundant constraints. For instance,
if both <code>sign = 1</code> and <code>monotone = 1</code>, then only the sign
constraint on the first variable is kept as others are not needed.
</p>
<p>Note that, for all arguments, any number can be passed to the function. In
which case, the sign of the argument is used. Therefore passing
<code>monotone = 3.14</code> is the same as passing <code>monotone = 1</code>.
</p>


<h3>Value</h3>

<p>A p-column constraint matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># By default, produces only the identifiability constraint
build_constraints(4)

# Positive and increasing coefficients
build_constraints(4, sign = 1, monotone = 1)

# Concavity constraint
build_constraints(7, convex = -1)

# Any numeric can be passed to the function
build_constraints(5, monotone = pi)

</code></pre>

<hr>
<h2 id='cgaim'>Constrained groupwise additive index models</h2><span id='topic+cgaim'></span>

<h3>Description</h3>

<p>Fits constrained groupwise additive index models (CGAIM) to data. CGAIM fits indices subjected to constraints on their coefficients and shape of their association with the outcome. Such constraints can be specified in the formula through <code><a href="#topic+g">g</a></code> for grouped terms and <code><a href="#topic+s">s</a></code> for smooth covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgaim(formula, data, weights, subset, na.action, Cmat = NULL, bvec = NULL,
  control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cgaim_+3A_formula">formula</code></td>
<td>
<p>A CGAIM formula with index terms <code><a href="#topic+g">g</a></code>, smooth terms <code><a href="#topic+s">s</a></code> and linear terms. See details.</p>
</td></tr>
<tr><td><code id="cgaim_+3A_data">data</code></td>
<td>
<p>A data.frame containing the variables of the model.</p>
</td></tr>
<tr><td><code id="cgaim_+3A_weights">weights</code></td>
<td>
<p>An optional vector of observation weights.</p>
</td></tr>
<tr><td><code id="cgaim_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="cgaim_+3A_na.action">na.action</code></td>
<td>
<p>A function indicating how to treat NAs. The default is set by the <code>na.action</code> setting of <code>options</code>. See <code><a href="stats.html#topic+na.fail">na.fail</a></code>.</p>
</td></tr>
<tr><td><code id="cgaim_+3A_cmat">Cmat</code></td>
<td>
<p>A constraint matrix for index coefficients alpha. Columns must match all variables entering any index through <code><a href="#topic+g">g</a></code>. See details.</p>
</td></tr>
<tr><td><code id="cgaim_+3A_bvec">bvec</code></td>
<td>
<p>A vector of lower bounds for the constraints in <code>Cmat</code>. Potentially recycled to match the number of constraints.</p>
</td></tr>
<tr><td><code id="cgaim_+3A_control">control</code></td>
<td>
<p>A list of parameters controlling the fitting process. See <code><a href="#topic+cgaim.control">cgaim.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CGAIM is expressed 
</p>
<p style="text-align: center;"><code class="reqn">y_{i} = \beta_{0} + \sum_{j} \beta_{j} g_{j}(\alpha_{j}^{T} x_{ij})
   + \sum_{k} \gamma_{k} f_{k}(w_{ik}) + \sum_{l} \theta_{l} u_{il} + e_{i}</code>
</p>

<p>where the <code class="reqn">x_{ij}</code> are variables entering grouped indices, the <code class="reqn">w_{ik}</code> are smooth covariates and the <code class="reqn">u_{il}</code> are linear covariates.
</p>
<p>The formula interface considers <code><a href="#topic+g">g</a></code> to identify index terms, <code><a href="#topic+s">s</a></code> for smooth functions and can also include linear terms as usual. All smooth terms can be shape constrained.
</p>
<p>The CGAIM allows for linear constraints on the alpha coefficients. Such constraints can be specified through the <code><a href="#topic+g">g</a></code> interface in the formula, or through <code>alpha.control$Cmat</code>. The <code><a href="#topic+g">g</a></code> interface is used for constraints meant for a specific index only. In this case, common constraints can easily be specified through the <code>acons</code> argument (see <code><a href="#topic+build_constraints">build_constraints</a></code>). Alternatively, more general constraint can be specified by passing a matrix to the <code>Cmat</code> argument. Constraints encompassing several indices can be specified through an element <code>Cmat</code> in <code>alpha.control</code>. Its number of columns must match the total number of index coefficients alpha to estimate. In all cases, arguments <code>bvec</code> are used to specify the bounds of constraints.
</p>
<p>Both indices (<code><a href="#topic+g">g</a></code>) and smooth covariate terms (<code><a href="#topic+s">s</a></code>) allow shape constraints. See dedicated help for the list of constraints allowed.
</p>
<p>The CGAIM is fitted through an iterative algorithm that alternates between estimating the ridge functions <code class="reqn">g_{j}</code> (and other non-index terms) and updating the coefficients <code class="reqn">\alpha_{j}</code>. The smoothing of ridge functions currently supports three methods: <code><a href="scam.html#topic+scam">scam</a></code> (the default), <code><a href="cgam.html#topic+cgam">cgam</a></code> and <code><a href="scar.html#topic+scar">scar</a></code>. The list <code>smooth.control</code> controls the smoothing with allowed parameters defined in <code><a href="#topic+cgaim.control">cgaim.control</a></code>.
</p>


<h3>Value</h3>

<p>A <code>cgaim</code> object, i.e. a list with components:
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>A named list of index coefficients.</p>
</td></tr>
<tr><td><code>gfit</code></td>
<td>
<p>A matrix containing the ridge and smooth functions evaluated at the observations. Note that column ordering puts indices first and covariates after.</p>
</td></tr>
<tr><td><code>indexfit</code></td>
<td>
<p>A matrix containing the indices evaluated at the observations.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A vector containing the intercept and the scale coefficient of each ridge and smooth function. Includes the <code class="reqn">\gamma_{k}</code> of the CGAIM model above. Note that ordering puts indices first and covariates after.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>A vector identifying to which index the columns of the element <code>x</code> belong.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>A vector of fitted responses.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A vector of residuals.</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>The residual sum of squares of the fit.</p>
</td></tr>
<tr><td><code>flag</code></td>
<td>
<p>A flag indicating how the algorithm stopped. 1 for proper convergence, 2 when the algorithm stopped for failing to decrease the RSS and 3 when the maximum number of iterations has been reached.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations performed.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Effective degrees of freedom of the estimator.</p>
</td></tr>
<tr><td><code>gcv</code></td>
<td>
<p>Generalized cross validation score.</p>
</td></tr>
<tr><td><code>dg</code></td>
<td>
<p>A matrix containing derivatives of ridge and smooth functions.</p>
</td></tr>
<tr><td><code>gse</code></td>
<td>
<p>A matrix containing standard errors of ridge and smooth functions.</p>
</td></tr>
<tr><td><code>active</code></td>
<td>
<p>A logical vector indicating which constraints are active at convergence.</p>
</td></tr>
<tr><td><code>Cmat</code></td>
<td>
<p>The constraint matrix used to fit index coefficients alpha. Will include all constraints given through <code><a href="#topic+g">g</a></code> and the <code>Cmat</code> parameter.</p>
</td></tr>
<tr><td><code>bvec</code></td>
<td>
<p>The lower bound vector associated with <code>Cmat</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A matrix containing the variables entering the indices. The variables are mapped to each index through the element <code>index</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The response vector.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>The weights used for estimation.</p>
</td></tr>
<tr><td><code>sm_mod</code></td>
<td>
<p>A list of model elements for the smoothing step of the estimation. Notably includes the matrix <code>Xcov</code> that includes the covariates not entering any index. Other elements depend on the method chosen for smoothing.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>The control list used to fit the cgaim.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The model terms.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A model without intercept can only be fitted when the smoothing step is performed with <code>scam</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.cgaim">confint.cgaim</a></code> for confidence intervals,
<code><a href="#topic+predict.cgaim">predict.cgaim</a></code> to predict on new data,
<code><a href="#topic+plot.cgaim">plot.cgaim</a></code> to plot ridge functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate some data
n &lt;- 200
x1 &lt;- rnorm(n)
x2 &lt;- rnorm(n)
x3 &lt;- rnorm(n)
x4 &lt;- rnorm(n)
mu &lt;- 4 * exp(8 * x1) / (1 + exp(8 * x1)) + exp(x3)
y &lt;- mu + rnorm(n)
df1 &lt;- data.frame(y, x1, x2, x3, x4)

## Fit an unconstrained the model
ans &lt;- cgaim(y ~ g(x1, x2) + g(x3, x4), data = df1)

# Compute confidence intervals
# In practice, higher B values are warranted
cia &lt;- confint(ans, B = 100)
cia$alpha
cia$beta

# Display ridge functions
plot(ans, ci = cia)

# Predict
newdf &lt;- as.data.frame(matrix(rnorm(100), 25, 4))
names(newdf) &lt;- sprintf("x%i", 1:4)
yhat &lt;- predict(ans, newdf)

## Fit constrained model
ans2 &lt;- cgaim(y ~ g(x1, x2, acons = list(monotone = -1)) + 
  g(x3, x4, fcons = "cvx"), data = df1)

# Check results
ans2
plot(ans2)

# Same result
Cmat &lt;- as.matrix(Matrix::bdiag(list(build_constraints(2, monotone = -1), 
  build_constraints(2, first = 1))))
ans3 &lt;- cgaim(y ~ g(x1, x2) + g(x3, x4, fcons = "cvx"), data = df1,
  Cmat = Cmat)

## A mis-specified model
ans4 &lt;- cgaim(y ~ g(x1, x2, acons = list(monotone = 1)) + 
  g(x3, x4, fcons = "dec"), data = df1)

</code></pre>

<hr>
<h2 id='cgaim.control'>Parameters controlling the CGAIM fit</h2><span id='topic+cgaim.control'></span>

<h3>Description</h3>

<p>Internal function setting the parameters to control the CGAIM fit. Sets default values and check parameters passed by the user. It is called internally by <code><a href="#topic+cgaim">cgaim</a></code> and should not be called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgaim.control(max.iter = 50, tol = 0.001, halving = TRUE,
  min.step.len = 0.1, convergence_criterion = "rss", trace = FALSE,
  alpha.start = NULL, init.type = "regression", norm.type = "1",
  check.Cmat = TRUE, solver = "osqp", ctol = 0.001, qp_pars = list(),
  sample_pars = list(), sm_method = "scam", sm_pars = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cgaim.control_+3A_max.iter">max.iter</code></td>
<td>
<p>The maximum number of iteration allowed.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_tol">tol</code></td>
<td>
<p>The tolerance for convergence. The algorithm stops when the convergence criterion falls below <code>tol</code>.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_halving">halving</code></td>
<td>
<p>Logical turning on and off halving for bad steps. See details.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_min.step.len">min.step.len</code></td>
<td>
<p>Numeric between 0 and 1 giving the minimum descent step length to be considered in case of bad step. See details.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_convergence_criterion">convergence_criterion</code></td>
<td>
<p>Character indicating the convergence criterion for the algorithm. See details.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_trace">trace</code></td>
<td>
<p>If TRUE, prints the convergence criterion and alpha coefficients at each step.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_alpha.start">alpha.start</code></td>
<td>
<p>An optional vector or list of starting alpha values. If <code>NULL</code>, starting values are generated internally. See the <code>init.type</code> argument.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_init.type">init.type</code></td>
<td>
<p>The type of initialization to perform if no initial value is provided. If <code>init.type = "regression"</code> (the default), starting values are generated by regressing the index design matrix on the response. If <code>init.type = "random"</code>, feasible starting values are generated randomly.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_norm.type">norm.type</code></td>
<td>
<p>The type of norm used to normalize index coefficients vectors. See <code><a href="base.html#topic+norm">norm</a></code> for available norms. Default to L1 norm meaning that, for each index, absolute values of coefficients sum to 1.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_check.cmat">check.Cmat</code></td>
<td>
<p>Logical indicating whether to check for redundant constraints and remove them from <code>Cmat</code>.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_solver">solver</code></td>
<td>
<p>The quadratic programming solver to use. One of <code>"osqp"</code> (the default), <code>"quadprog"</code> or <code>"coneproj"</code>.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_ctol">ctol</code></td>
<td>
<p>Tolerance value on constraints. See details.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_qp_pars">qp_pars</code></td>
<td>
<p>A named list of parameters to be passed to the <code>solver</code> function.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_sample_pars">sample_pars</code></td>
<td>
<p>A named list of parameters to be passed to <code><a href="limSolve.html#topic+xsample">xsample</a></code> when randomly generating initial alpha coefficients.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_sm_method">sm_method</code></td>
<td>
<p>Character specifying which method to use for constrained smoothing. Either <code><a href="scam.html#topic+scam">scam</a></code> (the default), <code><a href="cgam.html#topic+cgam">cgam</a></code> or <code><a href="scar.html#topic+scar">scar</a></code>.</p>
</td></tr>
<tr><td><code id="cgaim.control_+3A_sm_pars">sm_pars</code></td>
<td>
<p>Named list to pass specific parameters to the smoothing function of <code>sm_method</code>. See help pages of corresponding functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fitted by an iterative sequential quadratic programming algorithm. The algorithm iterates between updating the index alpha coefficients and updating the smoothing of indices and covariates. It stops when the criterion given in <code>convergence_criterion</code> is below <code>tol</code>, or when <code>max.iter</code> is reached. Convergence criteria include <code>rss</code> for which the algorithm stops when the relative decrease in residual sum of squares, <code>(rss_new - rss_old) / rss_old</code> is below <code>tol</code>, <code>alpha</code> for which the algorithm stops when the largest update <code>max(abs(alpha_new - alpha_old) / abs(alpha_old))</code> is below <code>tol</code>, and <code>offset</code> when the scalar product between the RSS and current direction (measuring orthogonality) is below <code>tol</code> (EXPERIMENTAL, use at your own risk).
</p>
<p>By default, when the RSS fails to decrease during a step (a &quot;bad&quot; step), the step length is iteratively halved until the RSS decreases. The minimum step length allowed is controlled by <code>min.step.len</code> as the proportion of the original step length. This is a common behaviour in non-linear least squares and is implement in <code><a href="stats.html#topic+nls">nls</a></code> for instance, but can be turned off by setting <code>halving = FALSE</code>, in which case the algorithm stops for any bad step. 
</p>
<p>The alpha updating step consists in estimating an update vector in a descent direction by a constrained regression of index derivatives on the current residuals of the model. This is fitted through a quadratic program, ensuring the updated coefficients respect the constraints at each step of the algorithm. Initial values can either be provided by the user through the argument <code>alpha.start</code> or be internally generated. The latter is controlled by the argument <code>init.type</code> allowing to initialize the weights either by regressing the index variables on the response (<code>init.type = "regression"</code>) ensuring feasible starting values (the default), or by randomly generating feasible values (<code>init.type = "random"</code>). In the latter case, random generation is performed by the function <code><a href="limSolve.html#topic+xsample">xsample</a></code> which can be controlled by the parameter <code>sample_pars</code>. When random initial values are chosen, it is recommended to fit the algorithm several time and keep the best fit, to avoid falling into a local minimum. 
</p>
<p>At the moment, three solvers are available to perform quadratic programming, which can be controlled by the argument <code>solver</code>. By default the function <code><a href="osqp.html#topic+solve_osqp">solve_osqp</a></code> (<code>solver = "osqp"</code>) is used. Alternatively the more established but slower function <code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> (<code>solver = "quadprog"</code>) as well as <code><a href="coneproj.html#topic+qprog">qprog</a></code> (<code>solver = "coneproj"</code>) functions can be used. Although default parameters are internally set for these function, they can entirely be controlled through the argument <code>qp_pars</code>. See their specific help pages for details.
</p>
<p>In some cases, minimal numerical imprecision in the repeated call to quadratic program, along with the normalization of alpha coefficients, can lead to unfeasible alphas at convergence. To avoid this, these imprecision are compensated by adding a small tolerance <code>ctol</code> to the constraints, defaulting to 0.001. If no tolerance is wanted, it can be set to 0.
</p>
<p>By default, the package automatically checks that <code>Cmat</code> is irreducible, i.e. that no constraint is redundant. A constraint is redundant if it can be expressed as a non-negative linear combination of other constraints. If <code>check.Cmat = TRUE</code>, such constraints are removed with a warning.
</p>


<h3>Value</h3>

<p>A named list containing all arguments to be used in <code><a href="#topic+cgaim">cgaim</a></code>.
</p>


<h3>References</h3>

<p>Bates, D.M., Watts, D.G., 1981. A Relative Off set Orthogonality Convergence Criterion for Nonlinear least Squares. Technometrics 23, 179–183.
</p>
<p>Bates, D.M., Watts, D.G., 1988. Nonlinear Regression Analysis and Its Applications, Wiley Series in Probability and Statistics. Wiley.
</p>


<h3>See Also</h3>

<p>These parameters control the fitting of <code><a href="#topic+cgaim">cgaim</a></code>.
</p>

<hr>
<h2 id='confint.cgaim'>Confidence intervals</h2><span id='topic+confint.cgaim'></span><span id='topic+confint.boot.cgaim'></span>

<h3>Description</h3>

<p>Computes confidence intervals for the CGAIM components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgaim'
confint(object, parm, level = 0.95, type = c("normal",
  "bootstrap"), B = 100, ...)

## S3 method for class 'boot.cgaim'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.cgaim_+3A_object">object</code></td>
<td>
<p>A <code>cgaim</code> or <code>boot.cgaim</code> object.</p>
</td></tr>
<tr><td><code id="confint.cgaim_+3A_parm">parm</code></td>
<td>
<p>The model components for which to get confidence intervals. 
One or several of: <code>"alpha"</code> for index weights,
<code>"beta"</code> for scaling coefficients and <code>"g"</code> for ridge function. By default,
returns confidence intervals for all components.</p>
</td></tr>
<tr><td><code id="confint.cgaim_+3A_level">level</code></td>
<td>
<p>The level of confidence intervals. Default to 0.95.</p>
</td></tr>
<tr><td><code id="confint.cgaim_+3A_type">type</code></td>
<td>
<p>The type of confidence intervals. Either <code>"normal"</code> (the default)
or <code>"bootstrap"</code>. See details.</p>
</td></tr>
<tr><td><code id="confint.cgaim_+3A_b">B</code></td>
<td>
<p>The number of samples to be simulated.</p>
</td></tr>
<tr><td><code id="confint.cgaim_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+boot.cgaim">boot.cgaim</a></code> for bootstrap confidence intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two types of confidence intervals are currently implemented in the function.
When <code>type = "normal"</code>, confidence intervals are computed assuming 
components are normally distributed. Beta coefficients are treated as
regular linear regression coefficients and g as regular smooth functions
estimated by (shape-constrained) generalized additive models. For alpha
coefficients, we consider a linear transformation mapping them to a 
Truncated Multivariate Normal distribution (i.e. with only bound constraints). 
Simulation from the TMVN are performed (see <code><a href="TruncatedNormal.html#topic+tmvnorm">tmvnorm</a></code>) 
and transformed 
back into the original coefficient space (i.e. with linear constraints). The parameter <code>B</code> controls the number of simulations from the TMVN. 
Confidence intervals are computed as the percentiles of these simulated
coefficients, ensuring the confidence region is entirely within the feasible
region defined by the constraints.
</p>
<p>When <code>type = "bootstrap"</code>, confidence intervals are estimated by 
percentile bootstrap. <code><a href="#topic+boot.cgaim">boot.cgaim</a></code> is called internally
to create <code>B</code> samples of model components, and confidence intervals are then computed
as the percentiles of bootstrap samples. Alternatively, the user can directly
call <code><a href="#topic+boot.cgaim">boot.cgaim</a></code> and feed the result into 
<code>confint.boot.cgaim</code>.
</p>


<h3>Value</h3>

<p>A list of confidence intervals. Contains one element per model
component in the <code>parm</code> argument.
</p>


<h3>Note</h3>

<p>Confidence intervals for the g functions are evaluated on the 
same <code>n</code> index values as the functions in <code>object</code>.
</p>


<h3>References</h3>

<p>Masselot, P. and others, 2022. Constrained groupwise additive index models.
Biostatistics.
</p>
<p>Pya, N., Wood, S.N., 2015. Shape constrained additive models. 
Stat. Comput. 25, 543–559. 
</p>
<p>Wood, S.N., 2017. Generalized Additive Models: An Introduction with R, 
2nd ed, Texts in Statistical Science. Chapman and Hall/CRC.
</p>
<p>DiCiccio, T.J., Efron, B., 1996. Bootstrap Confidence Intervals. 
Statistical Science 11, 189–212.
</p>
<p>Carpenter, J., Bithell, J., 2000. Bootstrap confidence intervals: 
when, which, what? A practical guide for medical statisticians. 
Statistics in Medicine 19, 1141–1164.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot.cgaim">boot.cgaim</a></code> for bootstrapping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple CGAIM
n &lt;- 200
x1 &lt;- rnorm(n)
x2 &lt;- x1 + rnorm(n)
z &lt;- x1 + x2
y &lt;- z + rnorm(n)
df1 &lt;- data.frame(y, x1, x2) 
ans &lt;- cgaim(y ~ g(x1, x2, acons = list(monotone = 1)), data = df1)

# Normal confidence intervals
set.seed(1)
ci1 &lt;- confint(ans, B = 1000)
ci1$alpha
ci1$beta

# Select only alphas: identical to above result
set.seed(1)
confint(ans, B = 1000, parm = "alpha")

# Select only betas: identical to above result
set.seed(1)
confint(ans, B = 1000, parm = "beta")

# Confidence intervals by bootstrap (more computationally intensive, B should be increased)
set.seed(2)
ci2 &lt;- confint(ans, type = "boot", B = 10)

# Alternatively, bootstrap samples can be performed beforehand
set.seed(2) 
boot1 &lt;- boot.cgaim(ans, B = 10)
ci3 &lt;- confint(boot1)

</code></pre>

<hr>
<h2 id='g'>Defining terms in CGAIM formula</h2><span id='topic+g'></span><span id='topic+s'></span>

<h3>Description</h3>

<p>Functions used to define terms within a <code>cgaim</code> formula. <code>g</code> 
defines an index with ridge function and <code>s</code> a smooth covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g(..., label = NULL, acons = list(), Cmat = NULL, bvec = 0,
  fcons = NULL, s_opts = list())

s(x, fcons = NULL, s_opts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="g_+3A_...">...</code></td>
<td>
<p>Variables entering the index. May include vectors and 
matrices.</p>
</td></tr>
<tr><td><code id="g_+3A_label">label</code></td>
<td>
<p>Character (or any object that can coerced into one) labeling the index. By default, named after the first variable in <code>...</code>.</p>
</td></tr>
<tr><td><code id="g_+3A_acons">acons</code></td>
<td>
<p>A list of character naming common constraints to be applied to 
the index weights <code>alpha</code>. See <code><a href="#topic+build_constraints">build_constraints</a></code> for 
allowed constraints.</p>
</td></tr>
<tr><td><code id="g_+3A_cmat">Cmat</code></td>
<td>
<p>A constraint matrix for alpha coefficients. Number of
columns must match the number of variables in the index.</p>
</td></tr>
<tr><td><code id="g_+3A_bvec">bvec</code></td>
<td>
<p>Numeric vector of constraint bounds. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="g_+3A_fcons">fcons</code></td>
<td>
<p>The type of shape constraint to be applied on the smooth 
function. See details.</p>
</td></tr>
<tr><td><code id="g_+3A_s_opts">s_opts</code></td>
<td>
<p>A named list of options to be passed to the smoothing of 
ridge functions. Depends on the method used to smooth additive models. 
See details.</p>
</td></tr>
<tr><td><code id="g_+3A_x">x</code></td>
<td>
<p>Covariate on which the smooth is applied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions define nonlinear terms in the formula, with <code>g</code> defining
an index created from a collection of terms passed through the <code>...</code>
argument while <code>s</code> is applied to a single variable, similarly to 
<code><a href="mgcv.html#topic+s">s</a></code> in <code>mgcv</code>. 
</p>
<p>For indices, <code>g</code> allows the definition of constraints applied to
the index only. This is a convenient alternative to passing the whole
constraint matrix <code>Cmat</code> in <code><a href="#topic+cgaim">cgaim</a></code>. Constraints can be
defined by a prespecified matrix through the argument <code>Cmat</code> or
through the argument <code>acons</code> for common constraints (see 
<code><a href="#topic+build_constraints">build_constraints</a></code>). Note that any provided <code>Cmat</code> must
match the total number of variables in <code>...</code>, including potential
matrix expansion and factors. Both <code>Cmat</code> and <code>acons</code> can be
passed to the function, which will bind them internally.
</p>
<p>Both <code>g</code> and <code>s</code> allow the definition of shape constraints for the
smooth. Eight shape-constraints are currently available: 
monotone increasing (<code>fcons = "inc"</code>), 
monotone decreasing (<code>fcons = "dec"</code>), 
convex (<code>fcons = "cvx"</code>), 
concave (<code>fcons = "ccv"</code>), 
increasing and convex(<code>fcons = "inccvx"</code>), 
decreasing and convex (<code>fcons = "deccvx"</code>), 
increasing and concave (<code>fcons = "incccv"</code>), 
decreasing and concave (<code>fcons = "decccv"</code>). 
</p>
<p>Smoothing can be controlled by the <code>s_opts</code> parameter. It is a list of
argument depends on the method used for smoothing. See <code><a href="mgcv.html#topic+s">s</a></code> 
for <code>smooth_method = "scam"</code>. For <code>smooth_method = "cgam"</code>, 
the parameters allowed may vary according to the shape-constraint chosen. 
The full list can be found in <code><a href="cgam.html#topic+cgam">cgam</a></code>, but only the 
constraints beginning with <code>s.</code> are allowed for now. 
No parameter are necessary when <code>smooth_method = "scar"</code> 
(see <code><a href="scar.html#topic+scar">scar</a></code>).
</p>


<h3>Value</h3>

<p>A matrix containing the variables passed in <code>...</code> with 
additional attributes:
</p>
<table role = "presentation">
<tr><td><code>fcons</code></td>
<td>
<p>The shape constraint for smoothing.</p>
</td></tr>
<tr><td><code>s_opts</code></td>
<td>
<p>Arguments passed to the smoothing function.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>The label of the term.</p>
</td></tr>
</table>
<p>The following attributes result from a call to <code>g</code> only:
</p>
<table role = "presentation">
<tr><td><code>term</code></td>
<td>
<p>The terms in the index.</p>
</td></tr>
<tr><td><code>nterms</code></td>
<td>
<p>The number of variables in the index.</p>
</td></tr>
<tr><td><code>Cmat</code></td>
<td>
<p>The constraint matrix for alpha coefficients.</p>
</td></tr>
<tr><td><code>bvec</code></td>
<td>
<p>The associated boundary vector.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cgaim">cgaim</a></code> for fitting the CGAIM, 
<code><a href="#topic+build_constraints">build_constraints</a></code> for built-in constraint matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate some data
n &lt;- 200
x1 &lt;- rnorm(n)
x2 &lt;- rnorm(n)
x3 &lt;- rnorm(n)
x4 &lt;- rnorm(n)
mu &lt;- 4 * exp(8 * x1) / (1 + exp(8 * x1)) + exp(x3)
y &lt;- mu + rnorm(n)
df1 &lt;- data.frame(y, x1, x2, x3, x4)

## Fit an unconstrained the model
ans &lt;- cgaim(y ~ g(x1, x2) + g(x3, x4), data = df1)

## Fit constrained model
ans2 &lt;- cgaim(y ~ g(x1, x2, acons = list(monotone = -1)) + 
  g(x3, x4, fcons = "cvx"), data = df1)
  
## Pass constraint matrices instead
ans3 &lt;- cgaim(y ~ g(x1, x2, Cmat = -diff(diag(2))) + 
  g(x3, x4, fcons = "cvx"), data = df1)
  
## Label indices   
ans4 &lt;- cgaim(y ~ g(x1, x2, label = "foo") + g(x3, x4, label = "bar"), 
  data = df1)
  
</code></pre>

<hr>
<h2 id='plot.cgaim'>Plot ridge function</h2><span id='topic+plot.cgaim'></span>

<h3>Description</h3>

<p>Plot method for the ridge and smooth terms of a <code>cgaim</code> object. If
provided, also plots confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgaim'
plot(x, select = NULL, ci = NULL, ci.plot = c("polygon",
  "lines"), ci.args = list(), add = FALSE, xcenter = FALSE,
  xscale = FALSE, yshift = FALSE, yscale = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cgaim_+3A_x">x</code></td>
<td>
<p>A <code>cgaim</code> object.</p>
</td></tr>
<tr><td><code id="plot.cgaim_+3A_select">select</code></td>
<td>
<p>A numeric or character vector indicating which terms
to plot.</p>
</td></tr>
<tr><td><code id="plot.cgaim_+3A_ci">ci</code></td>
<td>
<p>An object returned by a call to <code><a href="#topic+confint.cgaim">confint.cgaim</a></code>. If
<code>NULL</code>, no confidence interval is drawn.</p>
</td></tr>
<tr><td><code id="plot.cgaim_+3A_ci.plot">ci.plot</code></td>
<td>
<p>Whether to plot the confidence intervals as shaded areas
<code>ci.plot = "polygon"</code> or as lines <code>ci.plot = "lines"</code>.</p>
</td></tr>
<tr><td><code id="plot.cgaim_+3A_ci.args">ci.args</code></td>
<td>
<p>Additional arguments to be passed to the function used
to draw confidence interval. Either <code><a href="graphics.html#topic+polygon">polygon</a></code> or
<code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cgaim_+3A_add">add</code></td>
<td>
<p>Logical. If TRUE, adds the function to the current active plot.</p>
</td></tr>
<tr><td><code id="plot.cgaim_+3A_xcenter">xcenter</code>, <code id="plot.cgaim_+3A_xscale">xscale</code></td>
<td>
<p>Centering and scaling values for the x axis. See
<code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cgaim_+3A_yshift">yshift</code>, <code id="plot.cgaim_+3A_yscale">yscale</code></td>
<td>
<p>Either logical or numeric values to shift and scale 
the ridge functions. See details.</p>
</td></tr>
<tr><td><code id="plot.cgaim_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters for the drawn function. See
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>yshift</code> and <code>yscale</code> determine how
ridge functions are shifted and scaled for plotting. This can be used to
display the functions over data points for instance. If numeric, a vector
can be passed with one value for each plotted function. The vector is 
recycled if necessary. This indicate the desired mean and standard deviation 
of plotted ridge functions. Note that this is inverse to the parameters
in <code><a href="base.html#topic+scale">scale</a></code> (and <code>xcenter,xscale</code>).
If TRUE is passed instead, functions are shifted
to the intercept and scaled to their corresponding beta coefficients, placing
them on the response scale.
</p>


<h3>Value</h3>

<p>The function is called to generate plots and returns no value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cgaim">cgaim</a></code> for the main fitting function and 
<code><a href="#topic+confint.cgaim">confint.cgaim</a></code> for confidence interval computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate some data
n &lt;- 200
x1 &lt;- rnorm(n)
x2 &lt;- rnorm(n)
x3 &lt;- rnorm(n)
x4 &lt;- rnorm(n)
mu &lt;- 4 * exp(8 * x1) / (1 + exp(8 * x1)) + exp(x3)
y &lt;- 5 + mu + rnorm(n)
df1 &lt;- data.frame(y, x1, x2, x3, x4)

## Fit a model
ans &lt;- cgaim(y ~ g(x1, x2, label = "foo") + g(x3, x4, label = "bar"), 
  data = df1)

## Default plot method
plot(ans)

## Select variable
plot(ans, select = 1)

# Same as
plot(ans, select = "foo")

## Add confidence intervals
ci &lt;- confint(ans)
plot(ans, select = 1, ci = ci)

## Change scale and location
# On the response scale
plot(ans, select = 1, ci = ci, yshift = TRUE, yscale = TRUE)

# Arbitrary scale
plot(ans, select = 1, ci = ci, yshift = 1000)

## Change look

# Main line
plot(ans, select = 1, ci = ci, col = 2, lwd = 3)

# Confidence intervals
plot(ans, select = 1, ci = ci, col = 2, lwd = 3,
  ci.args = list(col = adjustcolor(2, .5)))

# Confidence interval type
plot(ans, select = 1, ci = ci, ci.plot = "lines", col = 2, lwd = 3,
  ci.args = list(col = 2, lty = 4))

## Put curves on the same plot (need to shift and scale)
plot(ans, select = 1, col = 2, ylim = c(-2, 3))
plot(ans, select = 2, col = 4, add = TRUE)

</code></pre>

<hr>
<h2 id='predict.cgaim'>Predictions from a fitted CGAIM object</h2><span id='topic+predict.cgaim'></span>

<h3>Description</h3>

<p>Uses a fitted <code>cgaim</code> object and computes prediction for the
observed data or new data. Predicts the response, indices or 
ridge functions values at the provided data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgaim'
predict(object, newdata, type = c("response", "terms",
  "scterms", "indices"), select = NULL, na.action = "na.pass", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cgaim_+3A_object">object</code></td>
<td>
<p>A <code>gaim</code> object.</p>
</td></tr>
<tr><td><code id="predict.cgaim_+3A_newdata">newdata</code></td>
<td>
<p>A list or data.frame containing the new data to predict.
If missing, fitted values from the model are returned.</p>
</td></tr>
<tr><td><code id="predict.cgaim_+3A_type">type</code></td>
<td>
<p>A character indicating the type of prediction to return.
<code>type = "response"</code> returns the predicted response. 
<code>type = "terms"</code>, returns ridge and smooth functions evaluated at
index predicted for <code>newdata</code>. <code>type = "scterms"</code> is the same,
except that terms are postmultiplied by their scaling coefficients beta.
<code>type = "indices"</code> returns predicted indices values.</p>
</td></tr>
<tr><td><code id="predict.cgaim_+3A_select">select</code></td>
<td>
<p>A numeric or character vector indicating terms to return
for all types except <code>"response"</code>.</p>
</td></tr>
<tr><td><code id="predict.cgaim_+3A_na.action">na.action</code></td>
<td>
<p>A function indicating how to treat NAs. See
<code><a href="stats.html#topic+na.fail">na.fail</a></code>.</p>
</td></tr>
<tr><td><code id="predict.cgaim_+3A_...">...</code></td>
<td>
<p>For compatibility with the default <code>predict</code> method. Unused
at the moment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>type = "terms"</code> returns the scaled ridge functions, i.e. before being multiplied by scaling coefficients beta.
</p>


<h3>Value</h3>

<p>When <code>type = "response"</code> returns a vector of predicted response.
When <code>type = "terms"</code> or <code>"scterms"</code>, returns a matrix of evaluated ridge and 
smooth terms. When <code>type = "indices"</code>, returns
a matrix of evaluated indices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cgaim">cgaim</a></code> for main fitting function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate some data
n &lt;- 200
x1 &lt;- rnorm(n)
x2 &lt;- rnorm(n)
x3 &lt;- rnorm(n)
x4 &lt;- rnorm(n)
mu &lt;- 4 * exp(8 * x1) / (1 + exp(8 * x1)) + exp(x3)
y &lt;- mu + rnorm(n)
df1 &lt;- data.frame(y, x1, x2, x3, x4)

## Fit an unconstrained the model
ans &lt;- cgaim(y ~ g(x1, x2, label = "foo") + g(x3, x4, label = "bar"), 
  data = df1)

## Get fitted values
yhat &lt;- predict(ans)

## Predict on new data
newdf &lt;- as.data.frame(matrix(rnorm(100), 25, 4))
names(newdf) &lt;- sprintf("x%i", 1:4)

# predicted response
ypred &lt;- predict(ans, newdf)

# Indices
indices &lt;- predict(ans, newdata = newdf, type = "indices")

# Ridge functions
funs &lt;- predict(ans, newdata = newdf, type = "terms")

## Select specific terms
ind1 &lt;- predict(ans, newdata = newdf, select = "foo", type = "indices")
fun1 &lt;- predict(ans, newdata = newdf, select = "foo", type = "terms")

# Plot
plot(ans, select = "foo")
points(ind1, fun1)

## Scaled terms
fun2 &lt;- predict(ans, newdata = newdf, select = "foo", type = "scterms")

# Plot
plot(ans, select = "foo", yscale = TRUE)
points(ind1, fun2)
 
</code></pre>

<hr>
<h2 id='print.cgaim'>Print a cgaim object</h2><span id='topic+print.cgaim'></span>

<h3>Description</h3>

<p>Default method to print the results from a call to <code>cgaim</code>. 
Conveniently prints the formula, <code>beta</code> and <code>alpha</code> coefficients
as well as the residual sum of squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgaim'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cgaim_+3A_x">x</code></td>
<td>
<p>A <code>cgaim</code> object.</p>
</td></tr>
<tr><td><code id="print.cgaim_+3A_...">...</code></td>
<td>
<p>For compatibility with the default <code>print</code> method. Unused
at the moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function called for its side effect of printing a <code>cgaim</code> object. Returns no value.
</p>


<h3>See Also</h3>

<p>The main fitting function <code><a href="#topic+cgaim">cgaim</a></code>.
</p>

<hr>
<h2 id='vcov.cgaim'>Calculate Variance-Covariance Matrix for a Fitted CGAIM Object</h2><span id='topic+vcov.cgaim'></span><span id='topic+vcov.boot.cgaim'></span>

<h3>Description</h3>

<p>Returns the variance covariance matrix of the main parameters of a fitted <code>cgaim</code> object. These parameters correspond to the index weights <code>alpha</code> and the scaling coefficients <code>beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgaim'
vcov(object, parm = c("alpha", "beta"), type = c("normal",
  "bootstrap"), B = 100, complete = TRUE, ...)

## S3 method for class 'boot.cgaim'
vcov(object, parm = c("alpha", "beta"),
  complete = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.cgaim_+3A_object">object</code></td>
<td>
<p>A <code>cgaim</code> or <code>boot.cgaim</code> object.</p>
</td></tr>
<tr><td><code id="vcov.cgaim_+3A_parm">parm</code></td>
<td>
<p>The model components for which to get confidence intervals. 
Either <code>"alpha"</code> (the default) for index weights or <code>"beta"</code> for scaling coefficients.</p>
</td></tr>
<tr><td><code id="vcov.cgaim_+3A_type">type</code></td>
<td>
<p>The type of confidence intervals. Either <code>"normal"</code> (the default)
or <code>"bootstrap"</code>. See details.</p>
</td></tr>
<tr><td><code id="vcov.cgaim_+3A_b">B</code></td>
<td>
<p>The number of samples to be simulated.</p>
</td></tr>
<tr><td><code id="vcov.cgaim_+3A_complete">complete</code></td>
<td>
<p>Indicates whether the full variance-covariance matrix should be returned when some of the parameters could not be estimated. If so, the matrix is padded with <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="vcov.cgaim_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="#topic+boot.cgaim">boot.cgaim</a></code> for bootstrap replications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two types of computation are currently implemented in the function.
When <code>type = "normal"</code>, variance-covariance matrices are computed assuming 
components are normally distributed. Beta coefficients are treated as
regular linear regression coefficients and alpha
coefficients are assumed to follow a Truncated Multivariate Normal distribution. 
The latter is obtained by simulating from TMVN (see <code><a href="TruncatedNormal.html#topic+tmvnorm">tmvnorm</a></code>) 
and computing the empirical variance covariance matrix from these simulations. The parameter <code>B</code> controls the number of simulations from the TMVN (and is not used when <code>parm = "beta"</code>).
</p>
<p>When <code>type = "bootstrap"</code>, the variance-covariance matrix is computed on Bootstrap replications. In this case <code><a href="#topic+boot.cgaim">boot.cgaim</a></code> is called internally and <code>B</code> corresponds to the number of replications. Alternatively, the user can directly call <code><a href="#topic+boot.cgaim">boot.cgaim</a></code> and feed the result into <code>vcov.boot.cgaim</code> (see examples).
</p>


<h3>Value</h3>

<p>A variance-covariance matrix object.
</p>


<h3>References</h3>

<p>Masselot, P. and others, 2022. Constrained groupwise additive index models.
Biostatistics.
</p>
<p>Pya, N., Wood, S.N., 2015. Shape constrained additive models. 
Stat. Comput. 25, 543–559. 
</p>
<p>Wood, S.N., 2017. Generalized Additive Models: An Introduction with R, 
2nd ed, Texts in Statistical Science. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot.cgaim">boot.cgaim</a></code> for bootstrapping and <code><a href="#topic+confint.cgaim">confint.cgaim</a></code> for confidence intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple CGAIM
n &lt;- 200
x1 &lt;- rnorm(n)
x2 &lt;- x1 + rnorm(n)
z &lt;- x1 + x2
y &lt;- z + rnorm(n)
df1 &lt;- data.frame(y, x1, x2) 
ans &lt;- cgaim(y ~ g(x1, x2, acons = list(monotone = 1)), data = df1)

# (Truncated) Normal variance-covariance matrix
set.seed(1)
vcov(ans, B = 1000)
set.seed(1)
vcov(ans, parm = "alpha", B = 1000) # Same result
vcov(ans, parm = "beta", B = 1000)

# Confidence intervals by bootstrap (more computationally intensive, B should be increased)
set.seed(2)
vcov(ans, type = "boot", B = 10)

# Alternatively, bootstrap samples can be performed beforehand
set.seed(2) 
boot1 &lt;- boot.cgaim(ans, B = 10)
vcov(boot1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
