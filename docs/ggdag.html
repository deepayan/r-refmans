<!DOCTYPE html><html><head><title>Help for package ggdag</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggdag}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggdag-package'><p>ggdag: Analyze and Create Elegant Directed Acyclic Graphs</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#activate_collider_paths'><p>Activate paths opened by stratifying on a collider</p></a></li>
<li><a href='#Adjust for variables'><p>Adjust for variables and activate any biasing paths that result</p></a></li>
<li><a href='#as_tbl_graph'><p>Convert DAGS to tidygraph</p></a></li>
<li><a href='#as_tidy_dagitty'><p>Convert objects into <code>tidy_dagitty</code> objects</p></a></li>
<li><a href='#as.data.frame.tidy_dagitty'><p>Convert a <code>tidy_dagitty</code> object to data.frame</p></a></li>
<li><a href='#as.tbl.tidy_daggity'><p>Convert a <code>tidy_dagitty</code> object to tbl</p></a></li>
<li><a href='#Assess d-separation between variables'><p>D-relationship between variables</p></a></li>
<li><a href='#Assess familial relationships between variables'><p>Familial relationships between variables</p></a></li>
<li><a href='#Canonicalize DAGs'><p>Canonicalize a DAG</p></a></li>
<li><a href='#Colliders'><p>Find colliders</p></a></li>
<li><a href='#coordinates'><p>Manipulate DAG coordinates</p></a></li>
<li><a href='#Covariate Adjustment Sets'><p>Covariate Adjustment Sets</p></a></li>
<li><a href='#dag'><p>Create a dagitty DAG</p></a></li>
<li><a href='#DAG Edges'><p>Directed DAG edges</p></a></li>
<li><a href='#DAG Labels'><p>DAG labels</p></a></li>
<li><a href='#dagify'><p>Create a dagitty DAG using R-like syntax</p></a></li>
<li><a href='#dplyr'><p>Dplyr verb methods for <code>tidy_dagitty</code> objects</p></a></li>
<li><a href='#Equivalent DAGs and Classes'><p>Generating Equivalent Models</p></a></li>
<li><a href='#Exogenous Variables'><p>Find Exogenous Variables</p></a></li>
<li><a href='#expand_plot'><p>Quickly scale the size of a ggplot</p></a></li>
<li><a href='#fortify'><p>Fortify a <code>tidy_dagitty</code> object for <code>ggplot2</code></p></a></li>
<li><a href='#geom_dag_collider_edges'><p>Edges for paths activated by stratification on colliders</p></a></li>
<li><a href='#geom_dag_edges'><p>Directed and bidirected DAG edges</p></a></li>
<li><a href='#geom_dag_label'><p>Node text labels</p></a></li>
<li><a href='#geom_dag_text'><p>Node text</p></a></li>
<li><a href='#ggdag'><p>Quickly plot a DAG in ggplot2</p></a></li>
<li><a href='#ggdag_classic'><p>Quickly plot a DAG in ggplot2</p></a></li>
<li><a href='#ggplot.tidy_dagitty'><p>Create a new ggplot</p></a></li>
<li><a href='#ggrepel functions'><p>Repulsive textual annotations</p></a></li>
<li><a href='#Instrumental Variables'><p>Find Instrumental Variables</p></a></li>
<li><a href='#is_confounder'><p>Assess if a variable confounds a relationship</p></a></li>
<li><a href='#is.tidy_dagitty'><p>Test for object class for tidy_dagitty</p></a></li>
<li><a href='#Nodes'><p>DAG Nodes</p></a></li>
<li><a href='#Pathways'><p>Find Open Paths Between Variables</p></a></li>
<li><a href='#print.tidy_dagitty'><p>Print a <code>tidy_dagitty</code></p></a></li>
<li><a href='#pull_dag'><p>Pull components from DAG objects</p></a></li>
<li><a href='#Quick Plots for Common DAGs'><p>Quickly create a DAGs with common structures of bias</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#remove_axes'><p>Quickly remove plot axes and grids</p></a></li>
<li><a href='#scale_adjusted'><p>Common scale adjustments for DAGs</p></a></li>
<li><a href='#simulate_data'><p>Simulate Data from Structural Equation Model</p></a></li>
<li><a href='#tbl_df.tidy_daggity'><p>Convert a <code>tidy_dagitty</code> object to tbl_df</p></a></li>
<li><a href='#Test if Variable Is Collider'><p>Detecting colliders in DAGs</p></a></li>
<li><a href='#theme_dag_blank'><p>Minimalist DAG themes</p></a></li>
<li><a href='#theme_dag_grey'><p>Simple grey themes for DAGs</p></a></li>
<li><a href='#tidy_dagitty'><p>Tidy a <code>dagitty</code> object</p></a></li>
<li><a href='#time_ordered_coords'><p>Create a time-ordered coordinate data frame</p></a></li>
<li><a href='#Variable Status'><p>Find variable status</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analyze and Create Elegant Directed Acyclic Graphs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.12</td>
</tr>
<tr>
<td>Description:</td>
<td>Tidy, analyze, and plot directed acyclic graphs (DAGs).
    'ggdag' is built on top of 'dagitty', an R package that uses the
    'DAGitty' web tool (<a href="https://dagitty.net/">https://dagitty.net/</a>) for creating and analyzing
    DAGs. 'ggdag' makes it easy to tidy and plot 'dagitty' objects using
    'ggplot2' and 'ggraph', as well as common analytic and graphical
    functions, such as determining adjustment sets and node relationships.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-causal/ggdag">https://github.com/r-causal/ggdag</a>,
<a href="https://r-causal.github.io/ggdag/">https://r-causal.github.io/ggdag/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-causal/ggdag/issues">https://github.com/r-causal/ggdag/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dagitty, dplyr, forcats, ggplot2 (&ge; 3.0.0), ggraph (&ge;
2.0.0), ggrepel, igraph, magrittr, pillar, purrr, rlang,
stringr, tibble, tidygraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, spelling, testthat (&ge; 3.0.0), vdiffr
(&ge; 1.0.2), withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-08 04:16:00 UTC; malcolmbarrett</td>
</tr>
<tr>
<td>Author:</td>
<td>Malcolm Barrett <a href="https://orcid.org/0000-0003-0299-5825"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Malcolm Barrett &lt;malcolmbarrett@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-08 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggdag-package'>ggdag: Analyze and Create Elegant Directed Acyclic Graphs</h2><span id='topic+ggdag-package'></span><span id='topic+_PACKAGE'></span><span id='topic+ggdag_pkg'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Tidy, analyze, and plot directed acyclic graphs (DAGs). 'ggdag' is built on top of 'dagitty', an R package that uses the 'DAGitty' web tool (<a href="https://dagitty.net/">https://dagitty.net/</a>) for creating and analyzing DAGs. 'ggdag' makes it easy to tidy and plot 'dagitty' objects using 'ggplot2' and 'ggraph', as well as common analytic and graphical functions, such as determining adjustment sets and node relationships.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Malcolm Barrett <a href="mailto:malcolmbarrett@gmail.com">malcolmbarrett@gmail.com</a> (<a href="https://orcid.org/0000-0003-0299-5825">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-causal/ggdag">https://github.com/r-causal/ggdag</a>
</p>
</li>
<li> <p><a href="https://r-causal.github.io/ggdag/">https://r-causal.github.io/ggdag/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-causal/ggdag/issues">https://github.com/r-causal/ggdag/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='activate_collider_paths'>Activate paths opened by stratifying on a collider</h2><span id='topic+activate_collider_paths'></span>

<h3>Description</h3>

<p>Stratifying on colliders can open biasing pathways between variables.
<code>activate_collider_paths</code> activates any such pathways given a variable
or set of variables to adjust for and adds them to the <code>tidy_dagitty</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate_collider_paths(.tdy_dag, adjust_for, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="activate_collider_paths_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="activate_collider_paths_+3A_adjust_for">adjust_for</code></td>
<td>
<p>a character vector, the variable(s) to adjust for.</p>
</td></tr>
<tr><td><code id="activate_collider_paths_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> with additional rows for collider-activated
pathways
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control_for">control_for()</a></code>, <code><a href="#topic+ggdag_adjust">ggdag_adjust()</a></code>,
<code><a href="#topic+geom_dag_collider_edges">geom_dag_collider_edges()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dag &lt;- dagify(m ~ x + y, x ~ y)

collided_dag &lt;- activate_collider_paths(dag, adjust_for = "m")
collided_dag

</code></pre>

<hr>
<h2 id='Adjust+20for+20variables'>Adjust for variables and activate any biasing paths that result</h2><span id='topic+Adjust+20for+20variables'></span><span id='topic+control_for'></span><span id='topic+adjust_for'></span><span id='topic+ggdag_adjust'></span>

<h3>Description</h3>

<p>Adjust for variables and activate any biasing paths that result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_for(.tdy_dag, var, as_factor = TRUE, activate_colliders = TRUE, ...)

adjust_for(.tdy_dag, var, as_factor = TRUE, activate_colliders = TRUE, ...)

ggdag_adjust(
  .tdy_dag,
  var = NULL,
  ...,
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL,
  collider_lines = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_var">var</code></td>
<td>
<p>a character vector, the variable(s) to adjust for.</p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_as_factor">as_factor</code></td>
<td>
<p>logical. Should the <code>adjusted</code> column be a factor?</p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_activate_colliders">activate_colliders</code></td>
<td>
<p>logical. Include colliders activated by adjustment?</p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for
<code>geom_dag_label_repel()</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Adjust+2B20for+2B20variables_+3A_collider_lines">collider_lines</code></td>
<td>
<p>logical. Should the plot show paths activated by
adjusting for a collider?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> with a <code>adjusted</code> column for adjusted
variables, as well as any biasing paths that arise, or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dag &lt;- dagify(m ~ a + b, x ~ a, y ~ b)

control_for(dag, var = "m")
ggdag_adjust(dag, var = "m")

</code></pre>

<hr>
<h2 id='as_tbl_graph'>Convert DAGS to tidygraph</h2><span id='topic+as_tbl_graph'></span><span id='topic+as_tbl_graph.tidy_dagitty'></span><span id='topic+as_tbl_graph.dagitty'></span>

<h3>Description</h3>

<p>A thin wrapper to convert <code>tidy_dagitty</code> and <code>dagitty</code> objects to
<code>tbl_graph</code>, which can then be used to work in <code>tidygraph</code> and
<code>ggraph</code> directly. See <code><a href="tidygraph.html#topic+tbl_graph">tidygraph::as_tbl_graph()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidy_dagitty'
as_tbl_graph(x, directed = TRUE, ...)

## S3 method for class 'dagitty'
as_tbl_graph(x, directed = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tbl_graph_+3A_x">x</code></td>
<td>
<p>an object of class <code>tidy_dagitty</code> or <code>dagitty</code></p>
</td></tr>
<tr><td><code id="as_tbl_graph_+3A_directed">directed</code></td>
<td>
<p>logical. Should the constructed graph be directed? Default
is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="as_tbl_graph_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>as_tbl_graph</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tbl_graph</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggraph)
library(tidygraph)
butterfly_bias() %&gt;%
  as_tbl_graph() %&gt;%
  ggraph() +
  geom_edge_diagonal() +
  geom_node_point()

</code></pre>

<hr>
<h2 id='as_tidy_dagitty'>Convert objects into <code>tidy_dagitty</code> objects</h2><span id='topic+as_tidy_dagitty'></span><span id='topic+as_tidy_dagitty.dagitty'></span><span id='topic+as_tidy_dagitty.data.frame'></span>

<h3>Description</h3>

<p>An alternative API and specification to <code><a href="#topic+tidy_dagitty">tidy_dagitty()</a></code>, <code>as_tidy_dagitty()</code>
allows you to create <code>tidy_dagitty</code> objects from data frames. There is also a
method for <code>dagitty</code> objects, which is a thin wrapper for <code><a href="#topic+tidy_dagitty">tidy_dagitty()</a></code>.
To create a DAG from a data frame, it must contain <code>name</code> and <code>to</code> columns,
representing the nodes and any edges leading from the nodes. If there are
<code>x</code>, <code>y</code>, <code>xend</code>, and <code>yend</code> columns, they will be used as coordinates.
Otherwise, <code>layout</code> will be used. See <a href="#topic+tidy_dagitty">tidy_dagitty</a> for more information
about layouts. Additionally, you can specify status (one of <code>exposure</code>,
<code>outcome</code>, or <code>latent</code>) by including a <code>status</code> column. Any other columns in
the data set will also be joined to the <code>tidy_dagitty</code> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tidy_dagitty(x, ...)

## S3 method for class 'dagitty'
as_tidy_dagitty(x, seed = NULL, layout = "nicely", ...)

## S3 method for class 'data.frame'
as_tidy_dagitty(x, seed = NULL, layout = "nicely", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tidy_dagitty_+3A_x">x</code></td>
<td>
<p>An object to convert into a <code>tidy_dagitty</code>. Currently supports
<code>dagitty</code> and <code>data.frame</code> objects.</p>
</td></tr>
<tr><td><code id="as_tidy_dagitty_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>ggraph::create_layout()</code></p>
</td></tr>
<tr><td><code id="as_tidy_dagitty_+3A_seed">seed</code></td>
<td>
<p>a numeric seed for reproducible layout generation</p>
</td></tr>
<tr><td><code id="as_tidy_dagitty_+3A_layout">layout</code></td>
<td>
<p>a layout available in <code>ggraph</code>. See <code><a href="ggraph.html#topic+ggraph">ggraph::create_layout()</a></code>
for details. Alternatively, <code>"time_ordered"</code> will use
<code>time_ordered_coords()</code> to algorithmically sort the graph by time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy_dagitty">tidy_dagitty()</a></code>, <code><a href="#topic+pull_dag">pull_dag()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.frame(name = c("c", "c", "x"), to = c("x", "y", "y")) %&gt;%
  as_tidy_dagitty()

</code></pre>

<hr>
<h2 id='as.data.frame.tidy_dagitty'>Convert a <code>tidy_dagitty</code> object to data.frame</h2><span id='topic+as.data.frame.tidy_dagitty'></span>

<h3>Description</h3>

<p>Convert a <code>tidy_dagitty</code> object to data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidy_dagitty'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.tidy_dagitty_+3A_x">x</code></td>
<td>
<p>an object of class <code>tidy_dagitty</code></p>
</td></tr>
<tr><td><code id="as.data.frame.tidy_dagitty_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a character vector giving the row names for the data
frame. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.tidy_dagitty_+3A_optional">optional</code></td>
<td>
<p>logical. If TRUE, setting row names and converting column
names (to syntactic names: see make.names) is optional. Note that all of
R's base package <code>as.data.frame()</code> methods use optional only for column names
treatment, basically with the meaning of <code style="white-space: pre;">&#8288;data.frame(*, check.names = !optional)&#8288;</code></p>
</td></tr>
<tr><td><code id="as.data.frame.tidy_dagitty_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>as.data.frame()</code></p>
</td></tr>
</table>

<hr>
<h2 id='as.tbl.tidy_daggity'>Convert a <code>tidy_dagitty</code> object to tbl</h2><span id='topic+as.tbl.tidy_daggity'></span><span id='topic+as_tibble.tidy_daggity'></span>

<h3>Description</h3>

<p>Convert a <code>tidy_dagitty</code> object to tbl
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidy_daggity'
as.tbl(x, row.names = NULL, optional = FALSE, ...)

## S3 method for class 'tidy_daggity'
as_tibble(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.tbl.tidy_daggity_+3A_x">x</code></td>
<td>
<p>an object of class <code>tidy_dagitty</code></p>
</td></tr>
<tr><td><code id="as.tbl.tidy_daggity_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a character vector giving the row names for the data
frame. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.tbl.tidy_daggity_+3A_optional">optional</code></td>
<td>
<p>logical. If TRUE, setting row names and converting column
names (to syntactic names: see make.names) is optional. Note that all of
R's base package <code>as.data.frame()</code> methods use optional only for column names
treatment, basically with the meaning of <code style="white-space: pre;">&#8288;data.frame(*, check.names = !optional)&#8288;</code></p>
</td></tr>
<tr><td><code id="as.tbl.tidy_daggity_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="dplyr.html#topic+reexports">dplyr::as_tibble()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='Assess+20d-separation+20between+20variables'>D-relationship between variables</h2><span id='topic+Assess+20d-separation+20between+20variables'></span><span id='topic+node_dconnected'></span><span id='topic+node_dseparated'></span><span id='topic+node_drelationship'></span><span id='topic+ggdag_drelationship'></span><span id='topic+ggdag_dseparated'></span><span id='topic+ggdag_dconnected'></span>

<h3>Description</h3>

<p>D-separation is a key concept in causal structural models. Variables are
d-separated if there are no open paths between them. The <code style="white-space: pre;">&#8288;node_d*()&#8288;</code>
functions label variables as d-connected or d-separated. The
<code style="white-space: pre;">&#8288;ggdag_d*()&#8288;</code> functions plot the results. The <code style="white-space: pre;">&#8288;*_dconnected()&#8288;</code>,
<code style="white-space: pre;">&#8288;*_dseparated()&#8288;</code>, and <code style="white-space: pre;">&#8288;*_drelationship()&#8288;</code> functions essentially
produce the same output and are just different ways of thinking about the
relationship. See <code><a href="dagitty.html#topic+dconnected">dagitty::dseparated()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_dconnected(
  .tdy_dag,
  from = NULL,
  to = NULL,
  controlling_for = NULL,
  as_factor = TRUE,
  ...
)

node_dseparated(
  .tdy_dag,
  from = NULL,
  to = NULL,
  controlling_for = NULL,
  as_factor = TRUE
)

node_drelationship(
  .tdy_dag,
  from = NULL,
  to = NULL,
  controlling_for = NULL,
  as_factor = TRUE
)

ggdag_drelationship(
  .tdy_dag,
  from = NULL,
  to = NULL,
  controlling_for = NULL,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL,
  collider_lines = TRUE
)

ggdag_dseparated(
  .tdy_dag,
  from = NULL,
  to = NULL,
  controlling_for = NULL,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL,
  collider_lines = TRUE
)

ggdag_dconnected(
  .tdy_dag,
  from = NULL,
  to = NULL,
  controlling_for = NULL,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL,
  collider_lines = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_from">from</code></td>
<td>
<p>a character vector, the starting variable (must by in DAG). If
<code>NULL</code>, checks DAG for exposure variable.</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_to">to</code></td>
<td>
<p>a character vector, the ending variable (must by in DAG). If
<code>NULL</code>, checks DAG for outcome variable.</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_controlling_for">controlling_for</code></td>
<td>
<p>a character vector, variables in the DAG to control
for.</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_as_factor">as_factor</code></td>
<td>
<p>logical. Should the <code>d_relationship</code> variable be a
factor?</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_edge_type">edge_type</code></td>
<td>
<p>a character vector, the edge geom to use. One of:
&quot;link_arc&quot;, which accounts for directed and bidirected edges, &quot;link&quot;,
&quot;arc&quot;, or &quot;diagonal&quot;</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for <code>geom_dag_label_repel()</code>.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Assess+2B20d-separation+2B20between+2B20variables_+3A_collider_lines">collider_lines</code></td>
<td>
<p>logical. Should the plot show paths activated by
adjusting for a collider?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> with a <code>d_relationship</code> column for
variable D relationship or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
dag &lt;- dagify(m ~ x + y)
dag %&gt;% ggdag_drelationship("x", "y")
dag %&gt;% ggdag_drelationship("x", "y", controlling_for = "m")

dag %&gt;%
  node_dseparated("x", "y") %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend, shape = adjusted, col = d_relationship)) +
  geom_dag_edges() +
  geom_dag_collider_edges() +
  geom_dag_node() +
  geom_dag_text(col = "white") +
  theme_dag() +
  scale_adjusted()

dag %&gt;%
  node_dconnected("x", "y", controlling_for = "m") %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend, shape = adjusted, col = d_relationship)) +
  geom_dag_edges() +
  geom_dag_collider_edges() +
  geom_dag_node() +
  geom_dag_text(col = "white") +
  theme_dag() +
  scale_adjusted()

dagify(m ~ x + y, m_jr ~ m) %&gt;%
  tidy_dagitty(layout = "nicely") %&gt;%
  node_dconnected("x", "y", controlling_for = "m_jr") %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend, shape = adjusted, col = d_relationship)) +
  geom_dag_edges() +
  geom_dag_collider_edges() +
  geom_dag_node() +
  geom_dag_text(col = "white") +
  theme_dag() +
  scale_adjusted()
</code></pre>

<hr>
<h2 id='Assess+20familial+20relationships+20between+20variables'>Familial relationships between variables</h2><span id='topic+Assess+20familial+20relationships+20between+20variables'></span><span id='topic+node_children'></span><span id='topic+node_parents'></span><span id='topic+node_ancestors'></span><span id='topic+node_descendants'></span><span id='topic+node_markov_blanket'></span><span id='topic+node_adjacent'></span><span id='topic+ggdag_children'></span><span id='topic+ggdag_parents'></span><span id='topic+ggdag_ancestors'></span><span id='topic+ggdag_descendants'></span><span id='topic+ggdag_markov_blanket'></span><span id='topic+ggdag_adjacent'></span>

<h3>Description</h3>

<p>Parents and children are those nodes that either directly cause or are caused
by the variable, respectively. Ancestors and descendants are those nodes that
are on the path to or descend from the variable. The <code style="white-space: pre;">&#8288;node_*()&#8288;</code>
functions label variables depending on their relationship. The
<code style="white-space: pre;">&#8288;ggdag_*()&#8288;</code> functions plot the results. See
<a href="dagitty.html#topic+AncestralRelations">dagitty::children</a> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_children(.tdy_dag, .var, as_factor = TRUE)

node_parents(.tdy_dag, .var, as_factor = TRUE)

node_ancestors(.tdy_dag, .var, as_factor = TRUE)

node_descendants(.tdy_dag, .var, as_factor = TRUE)

node_markov_blanket(.tdy_dag, .var, as_factor = TRUE)

node_adjacent(.tdy_dag, .var, as_factor = TRUE)

ggdag_children(
  .tdy_dag,
  .var,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)

ggdag_parents(
  .tdy_dag,
  .var,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)

ggdag_ancestors(
  .tdy_dag,
  .var,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)

ggdag_descendants(
  .tdy_dag,
  .var,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)

ggdag_markov_blanket(
  .tdy_dag,
  .var,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)

ggdag_adjacent(
  .tdy_dag,
  .var,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_.var">.var</code></td>
<td>
<p>a character vector, the variable to be assessed (must by in DAG)</p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_as_factor">as_factor</code></td>
<td>
<p>logical. Should the relationship variable be a factor?</p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_edge_type">edge_type</code></td>
<td>
<p>a character vector, the edge geom to use. One of:
&quot;link_arc&quot;, which accounts for directed and bidirected edges, &quot;link&quot;,
&quot;arc&quot;, or &quot;diagonal&quot;</p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Assess+2B20familial+2B20relationships+2B20between+2B20variables_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for
<code>geom_dag_label_repel()</code>. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> with an column related to the given
relationship for variable D relationship or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
dag &lt;- dagify(
  y ~ x + z2 + w2 + w1,
  x ~ z1 + w1,
  z1 ~ w1 + v,
  z2 ~ w2 + v,
  w1 ~ ~w2
)

ggdag_children(dag, "w1")

dag %&gt;%
  node_children("w1") %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend, color = children)) +
  geom_dag_edges() +
  geom_dag_node() +
  geom_dag_text(col = "white") +
  geom_dag_label_repel(aes(label = children, fill = children), col = "white", show.legend = FALSE) +
  theme_dag() +
  scale_adjusted() +
  scale_color_hue(breaks = c("parent", "child"))

ggdag_parents(dag, "y")

ggdag_ancestors(dag, "x")

ggdag_descendants(dag, "w1")

dag %&gt;%
  node_parents("y") %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend, color = parent)) +
  geom_dag_edges() +
  geom_dag_point() +
  geom_dag_text(col = "white") +
  geom_dag_label_repel(aes(label = parent, fill = parent), col = "white", show.legend = FALSE) +
  theme_dag() +
  scale_adjusted() +
  scale_color_hue(breaks = c("parent", "child"))

</code></pre>

<hr>
<h2 id='Canonicalize+20DAGs'>Canonicalize a DAG</h2><span id='topic+Canonicalize+20DAGs'></span><span id='topic+node_canonical'></span><span id='topic+ggdag_canonical'></span>

<h3>Description</h3>

<p>Takes an input graph with bidirected edges and replaces every bidirected edge
x &lt;-&gt; y with a substructure x &lt;- L -&gt; y, where L is a latent variable. See
<code><a href="dagitty.html#topic+canonicalize">dagitty::canonicalize()</a></code> for details. Undirected edges
are not currently supported in <code>ggdag</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_canonical(.dag, ...)

ggdag_canonical(
  .tdy_dag,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_.dag">.dag</code>, <code id="Canonicalize+2B20DAGs_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_edge_type">edge_type</code></td>
<td>
<p>a character vector, the edge geom to use. One of:
&quot;link_arc&quot;, which accounts for directed and bidirected edges, &quot;link&quot;,
&quot;arc&quot;, or &quot;diagonal&quot;</p>
</td></tr>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Canonicalize+2B20DAGs_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for <code>geom_dag_label_repel()</code>.
Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> that includes L or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dag &lt;- dagify(y ~ x + z, x ~ ~z)

ggdag(dag)

node_canonical(dag)
ggdag_canonical(dag)

</code></pre>

<hr>
<h2 id='Colliders'>Find colliders</h2><span id='topic+Colliders'></span><span id='topic+node_collider'></span><span id='topic+ggdag_collider'></span>

<h3>Description</h3>

<p>Detects any colliders given a DAG.
<code>node_collider</code> tags colliders and <code>ggdag_collider</code> plots all
exogenous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_collider(.dag, as_factor = TRUE, ...)

ggdag_collider(
  .tdy_dag,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Colliders_+3A_.dag">.dag</code>, <code id="Colliders_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="Colliders_+3A_as_factor">as_factor</code></td>
<td>
<p>treat <code>collider</code> variable as factor</p>
</td></tr>
<tr><td><code id="Colliders_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
<tr><td><code id="Colliders_+3A_edge_type">edge_type</code></td>
<td>
<p>a character vector, the edge geom to use. One of:
&quot;link_arc&quot;, which accounts for directed and bidirected edges, &quot;link&quot;,
&quot;arc&quot;, or &quot;diagonal&quot;</p>
</td></tr>
<tr><td><code id="Colliders_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Colliders_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Colliders_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Colliders_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Colliders_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="Colliders_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Colliders_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Colliders_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Colliders_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for <code>geom_dag_label_repel()</code>.
Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> with a <code>collider</code> column for
colliders or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dag &lt;- dagify(m ~ x + y, y ~ x)

node_collider(dag)
ggdag_collider(dag)

</code></pre>

<hr>
<h2 id='coordinates'>Manipulate DAG coordinates</h2><span id='topic+coordinates'></span><span id='topic+coords2df'></span><span id='topic+coords2list'></span>

<h3>Description</h3>

<p>Manipulate DAG coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords2df(coord_list)

coords2list(coord_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordinates_+3A_coord_list">coord_list</code></td>
<td>
<p>a named list of coordinates</p>
</td></tr>
<tr><td><code id="coordinates_+3A_coord_df">coord_df</code></td>
<td>
<p>a data.frame with columns x, y, and name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a list or a data.frame with DAG node coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dagitty)
coords &lt;- list(
  x = c(A = 1, B = 2, D = 3, C = 3, F = 3, E = 4, G = 5, H = 5, I = 5),
  y = c(A = 0, B = 0, D = 1, C = 0, F = -1, E = 0, G = 1, H = 0, I = -1)
)
coord_df &lt;- coords2df(coords)
coords2list(coord_df)

x &lt;- dagitty("dag{
             G &lt;-&gt; H &lt;-&gt; I &lt;-&gt; G
             D &lt;- B -&gt; C -&gt; I &lt;- F &lt;- B &lt;- A
             H &lt;- E &lt;- C -&gt; G &lt;- D
             }")
coordinates(x) &lt;- coords2list(coord_df)

</code></pre>

<hr>
<h2 id='Covariate+20Adjustment+20Sets'>Covariate Adjustment Sets</h2><span id='topic+Covariate+20Adjustment+20Sets'></span><span id='topic+dag_adjustment_sets'></span><span id='topic+ggdag_adjustment_set'></span>

<h3>Description</h3>

<p>See <code><a href="dagitty.html#topic+adjustmentSets">dagitty::adjustmentSets()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag_adjustment_sets(.tdy_dag, exposure = NULL, outcome = NULL, ...)

ggdag_adjustment_set(
  .tdy_dag,
  exposure = NULL,
  outcome = NULL,
  ...,
  shadow = FALSE,
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL,
  expand_x = expansion(c(0.25, 0.25)),
  expand_y = expansion(c(0.2, 0.2))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_exposure">exposure</code></td>
<td>
<p>a character vector, the exposure variable. Default is
<code>NULL</code>, in which case it will be determined from the DAG.</p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_outcome">outcome</code></td>
<td>
<p>a character vector, the outcome variable. Default is
<code>NULL</code>, in which case it will be determined from the DAG.</p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>adjustmentSets</code></p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_shadow">shadow</code></td>
<td>
<p>logical. Show paths blocked by adjustment?</p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for <code>geom_dag_label_repel()</code>.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Covariate+2B20Adjustment+2B20Sets_+3A_expand_x">expand_x</code>, <code id="Covariate+2B20Adjustment+2B20Sets_+3A_expand_y">expand_y</code></td>
<td>
<p>Vector of range expansion constants used to add some
padding around the data, to ensure that they are placed some distance away
from the axes. Use the convenience function <code>ggplot2::expansion()</code> to
generate the values for the expand argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> with an <code>adjusted</code> column and <code>set</code>
column, indicating adjustment status and DAG ID, respectively, for the
adjustment sets or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dag &lt;- dagify(y ~ x + z2 + w2 + w1,
  x ~ z1 + w1,
  z1 ~ w1 + v,
  z2 ~ w2 + v,
  w1 ~ ~w2,
  exposure = "x",
  outcome = "y"
)

tidy_dagitty(dag) %&gt;% dag_adjustment_sets()

ggdag_adjustment_set(dag)

ggdag_adjustment_set(dagitty::randomDAG(10, .5),
  exposure = "x3",
  outcome = "x5"
)

</code></pre>

<hr>
<h2 id='dag'>Create a dagitty DAG</h2><span id='topic+dag'></span>

<h3>Description</h3>

<p>A convenience wrapper for <code>dagitty::dagitty()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dag_+3A_...">...</code></td>
<td>
<p>a character vector in the style of dagitty. See
<code>dagitty::<a href="dagitty.html#topic+dagitty">dagitty</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>dagitty</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dag("{x m} -&gt; y")

</code></pre>

<hr>
<h2 id='DAG+20Edges'>Directed DAG edges</h2><span id='topic+DAG+20Edges'></span><span id='topic+geom_dag_edges_link'></span><span id='topic+geom_dag_edges_arc'></span><span id='topic+geom_dag_edges_diagonal'></span><span id='topic+geom_dag_edges_fan'></span>

<h3>Description</h3>

<p>Directed DAG edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dag_edges_link(
  mapping = NULL,
  data = NULL,
  arrow = grid::arrow(length = grid::unit(5, "pt"), type = "closed"),
  position = "identity",
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_dag_edges_arc(
  mapping = NULL,
  data = NULL,
  curvature = 0.5,
  arrow = grid::arrow(length = grid::unit(5, "pt"), type = "closed"),
  position = "identity",
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE,
  fold = FALSE,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  ...
)

geom_dag_edges_diagonal(
  mapping = NULL,
  data = NULL,
  position = "identity",
  arrow = grid::arrow(length = grid::unit(5, "pt"), type = "closed"),
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE,
  curvature = 1,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  ...
)

geom_dag_edges_fan(
  mapping = NULL,
  data = NULL,
  position = "identity",
  arrow = grid::arrow(length = grid::unit(5, "pt"), type = "closed"),
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE,
  spread = 0.7,
  n = 100,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  label_colour = "black",
  label_alpha = 1,
  label_parse = FALSE,
  check_overlap = FALSE,
  angle_calc = "rot",
  force_flip = TRUE,
  label_dodge = NULL,
  label_push = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DAG+2B20Edges_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by aes() or aes_(). If
specified and inherit.aes = TRUE (the default), it is combined with the
default mapping at the top level of the plot. You must supply mapping if
there is no plot mapping.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer.
There are three options: If NULL, the default, the data is inherited from
the plot data as specified in the call to ggplot(). A data.frame, or other
object, will override the plot data. All objects will be fortified to
produce a data frame. See fortify() for which variables will be created. A
function will be called with a single argument, the plot data. The return
value must be a data.frame., and will be used as the layer data.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by arrow()</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_na.rm">na.rm</code></td>
<td>
<p>If FALSE (the default), removes missing values with a warning.
If TRUE silently removes missing values</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends? NA,
the default, includes if any aesthetics are mapped. FALSE never includes,
and TRUE always includes. It can also be a named logical vector to finely
select the aesthetics to display.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If FALSE, overrides the default aesthetics, rather than
combining with them. This is most useful for helper functions that define
both data and aesthetics and shouldn't inherit behaviour from the default
plot specification, e.g. borders().</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_...">...</code></td>
<td>
<p>Other arguments passed to ggraph::geom_edge_*()</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_curvature">curvature</code></td>
<td>
<p>The bend of the curve. 1 approximates a halfcircle while 0
will give a straight line. Negative number will change the direction of the
curve. Only used if layout circular = FALSE.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_fold">fold</code></td>
<td>
<p>Logical. Should arcs appear on the same side of the nodes despite
different directions. Default to FALSE.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_n">n</code></td>
<td>
<p>The number of points to create along the path.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_label_colour">label_colour</code></td>
<td>
<p>The colour of the edge label. If <code>NA</code> it will use
the colour of the edge.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_label_alpha">label_alpha</code></td>
<td>
<p>The opacity of the edge label. If <code>NA</code> it will use
the opacity of the edge.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_label_parse">label_parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions
and displayed as described in <code><a href="grDevices.html#topic+plotmath">grDevices::plotmath()</a></code>.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_angle_calc">angle_calc</code></td>
<td>
<p>Either 'none', 'along', or 'across'. If 'none' the label will
use the angle aesthetic of the geom. If 'along' The label will be written
along the edge direction. If 'across' the label will be written across the
edge direction.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_force_flip">force_flip</code></td>
<td>
<p>Logical. If <code>angle_calc</code> is either 'along' or 'across'
should the label be flipped if it is on it's head. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_label_dodge">label_dodge</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed vertical shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_label_push">label_push</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> giving a fixed horizontal shift
to add to the label in case of <code>angle_calc</code> is either 'along' or 'across'</p>
</td></tr>
<tr><td><code id="DAG+2B20Edges_+3A_spread">spread</code></td>
<td>
<p>Deprecated. Use <code>strength</code> instead.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_dag_edges_link</code>, <code>geom_dag_edges_arc</code>, <code>geom_dag_edges_diagonal</code>, and
<code>geom_dag_edges_fan</code> understand the following aesthetics. Bold aesthetics are
required.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>

<p><code>geom_dag_edges_arc</code> and <code>geom_dag_edges_diagonal</code> also require
<strong>circular</strong>, but this is automatically set.
</p>
<p><code>geom_dag_edges_fan</code> requires <strong>to</strong> and <strong>from</strong>, but these are also
automatically set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
p &lt;- dagify(
  y ~ x + z2 + w2 + w1,
  x ~ z1 + w1,
  z1 ~ w1 + v,
  z2 ~ w2 + v,
  L ~ w1 + w2
) %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_point() +
  geom_dag_text() +
  theme_dag()

p + geom_dag_edges_link()
p + geom_dag_edges_arc()
p + geom_dag_edges_diagonal()
p + geom_dag_edges_fan()

</code></pre>

<hr>
<h2 id='DAG+20Labels'>DAG labels</h2><span id='topic+DAG+20Labels'></span><span id='topic+label+3C-'></span><span id='topic+label+3C-.dagitty'></span><span id='topic+label+3C-.tidy_dagitty'></span><span id='topic+dag_label'></span><span id='topic+label'></span><span id='topic+has_labels'></span>

<h3>Description</h3>

<p>Label or otherwise retrieve labels from objects of either class
<code>tidy_dagitty</code> or <code>dagitty</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label(x) &lt;- value

## S3 replacement method for class 'dagitty'
label(x) &lt;- value

## S3 replacement method for class 'tidy_dagitty'
label(x) &lt;- value

dag_label(.tdy_dag, labels = NULL)

label(.tdy_dag)

has_labels(.tdy_dag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DAG+2B20Labels_+3A_x">x</code></td>
<td>
<p>an object of either class <code>tidy_dagitty</code> or <code>dagitty</code></p>
</td></tr>
<tr><td><code id="DAG+2B20Labels_+3A_value">value</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="DAG+2B20Labels_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>an object of class <code>tidy_dagitty</code></p>
</td></tr>
<tr><td><code id="DAG+2B20Labels_+3A_labels">labels</code></td>
<td>
<p>a character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>label</code> returns the label attribute of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>labelled_dag &lt;- dagify(y ~ z, x ~ z) %&gt;%
  tidy_dagitty() %&gt;%
  dag_label(labels = c("x" = "exposure", "y" = "outcome", "z" = "confounder"))

has_labels(labelled_dag)
</code></pre>

<hr>
<h2 id='dagify'>Create a dagitty DAG using R-like syntax</h2><span id='topic+dagify'></span>

<h3>Description</h3>

<p><code>dagify()</code> creates dagitty DAGs using a more R-like syntax. It currently
accepts formulas in the usual R style, e.g. <code>y ~ x + z</code>, which gets
translated to <code style="white-space: pre;">&#8288;y &lt;- {x z}&#8288;</code>, as well as using a double tilde (<code style="white-space: pre;">&#8288;~~&#8288;</code>) to
graph bidirected variables, e.g. <code>x1 ~~ x2</code> is translated to <code style="white-space: pre;">&#8288;x1 &lt;-&gt; x2&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dagify(
  ...,
  exposure = NULL,
  outcome = NULL,
  latent = NULL,
  labels = NULL,
  coords = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dagify_+3A_...">...</code></td>
<td>
<p>formulas, which are converted to <code>dagitty</code> syntax</p>
</td></tr>
<tr><td><code id="dagify_+3A_exposure">exposure</code></td>
<td>
<p>a character vector for the exposure (must be a variable name
in the DAG)</p>
</td></tr>
<tr><td><code id="dagify_+3A_outcome">outcome</code></td>
<td>
<p>a character vector for the outcome (must be a variable name in
the DAG)</p>
</td></tr>
<tr><td><code id="dagify_+3A_latent">latent</code></td>
<td>
<p>a character vector for any latent variables (must be a variable
name in the DAG)</p>
</td></tr>
<tr><td><code id="dagify_+3A_labels">labels</code></td>
<td>
<p>a named character vector, labels for variables in the DAG</p>
</td></tr>
<tr><td><code id="dagify_+3A_coords">coords</code></td>
<td>
<p>coordinates for the DAG nodes. Can be a named list or a
<code>data.frame</code> with columns x, y, and name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>dagitty</code> DAG
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag">dag()</a></code>, <code><a href="#topic+coords2df">coords2df()</a></code>, <code><a href="#topic+coords2list">coords2list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dagify(y ~ x + z, x ~ z)

coords &lt;- list(
  x = c(A = 1, B = 2, D = 3, C = 3, F = 3, E = 4, G = 5, H = 5, I = 5),
  y = c(A = 0, B = 0, D = 1, C = 0, F = -1, E = 0, G = 1, H = 0, I = -1)
)

dag &lt;- dagify(G ~ ~H,
  G ~ ~I,
  I ~ ~G,
  H ~ ~I,
  D ~ B,
  C ~ B,
  I ~ C + F,
  F ~ B,
  B ~ A,
  H ~ E,
  C ~ E + G,
  G ~ D,
  coords = coords
)

dagitty::is.dagitty(dag)

ggdag(dag)

dag2 &lt;- dagify(y ~ x + z2 + w2 + w1,
  x ~ z1 + w1,
  z1 ~ w1 + v,
  z2 ~ w2 + v,
  w1 ~ ~w2,
  exposure = "x",
  outcome = "y"
)

ggdag(dag2)

</code></pre>

<hr>
<h2 id='dplyr'>Dplyr verb methods for <code>tidy_dagitty</code> objects</h2><span id='topic+dplyr'></span><span id='topic+select.tidy_dagitty'></span><span id='topic+filter.tidy_dagitty'></span><span id='topic+mutate.tidy_dagitty'></span><span id='topic+summarise.tidy_dagitty'></span><span id='topic+distinct.tidy_dagitty'></span><span id='topic+arrange.tidy_dagitty'></span><span id='topic+group_by.tidy_dagitty'></span><span id='topic+ungroup.tidy_dagitty'></span><span id='topic+transmute.tidy_dagitty'></span><span id='topic+full_join.tidy_dagitty'></span><span id='topic+inner_join.tidy_dagitty'></span><span id='topic+left_join.tidy_dagitty'></span><span id='topic+right_join.tidy_dagitty'></span><span id='topic+anti_join.tidy_dagitty'></span><span id='topic+semi_join.tidy_dagitty'></span><span id='topic+slice.tidy_dagitty'></span><span id='topic+select_.tidy_dagitty'></span><span id='topic+filter_.tidy_dagitty'></span><span id='topic+mutate_.tidy_dagitty'></span><span id='topic+summarise_.tidy_dagitty'></span><span id='topic+arrange_.tidy_dagitty'></span><span id='topic+slice_.tidy_dagitty'></span>

<h3>Description</h3>

<p>Dplyr verb methods for <code>tidy_dagitty</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidy_dagitty'
select(.data, ...)

## S3 method for class 'tidy_dagitty'
filter(.data, ...)

## S3 method for class 'tidy_dagitty'
mutate(.data, ...)

## S3 method for class 'tidy_dagitty'
summarise(.data, ...)

## S3 method for class 'tidy_dagitty'
distinct(.data, ..., .keep_all = FALSE)

## S3 method for class 'tidy_dagitty'
arrange(.data, ...)

## S3 method for class 'tidy_dagitty'
group_by(.data, ...)

## S3 method for class 'tidy_dagitty'
ungroup(x, ...)

## S3 method for class 'tidy_dagitty'
transmute(.data, ...)

## S3 method for class 'tidy_dagitty'
distinct(.data, ..., .keep_all = FALSE)

## S3 method for class 'tidy_dagitty'
full_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

## S3 method for class 'tidy_dagitty'
inner_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

## S3 method for class 'tidy_dagitty'
left_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

## S3 method for class 'tidy_dagitty'
right_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

## S3 method for class 'tidy_dagitty'
anti_join(x, y, by = NULL, copy = FALSE, ...)

## S3 method for class 'tidy_dagitty'
semi_join(x, y, by = NULL, copy = FALSE, ...)

## S3 method for class 'tidy_dagitty'
slice(.data, ..., .dots = list())

## S3 method for class 'tidy_dagitty'
select_(.data, ..., .dots = list())

## S3 method for class 'tidy_dagitty'
filter_(.data, ..., .dots = list())

## S3 method for class 'tidy_dagitty'
mutate_(.data, ..., .dots = list())

## S3 method for class 'tidy_dagitty'
summarise_(.data, ..., .dots = list())

## S3 method for class 'tidy_dagitty'
arrange_(.data, ..., .dots = list())

## S3 method for class 'tidy_dagitty'
slice_(.data, ..., .dots = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplyr_+3A_.data">.data</code></td>
<td>
<p>data object of class <code>tidy_dagitty</code></p>
</td></tr>
<tr><td><code id="dplyr_+3A_...">...</code></td>
<td>
<p>other arguments passed to the <code>dplyr</code> function</p>
</td></tr>
<tr><td><code id="dplyr_+3A_.dots">.dots</code>, <code id="dplyr_+3A_x">x</code>, <code id="dplyr_+3A_y">y</code>, <code id="dplyr_+3A_by">by</code>, <code id="dplyr_+3A_copy">copy</code>, <code id="dplyr_+3A_suffix">suffix</code>, <code id="dplyr_+3A_.keep_all">.keep_all</code></td>
<td>
<p>see corresponding function in
package <code>dplyr</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
tidy_dagitty(m_bias()) %&gt;%
  group_by(name) %&gt;%
  summarize(n = n())
</code></pre>

<hr>
<h2 id='Equivalent+20DAGs+20and+20Classes'>Generating Equivalent Models</h2><span id='topic+Equivalent+20DAGs+20and+20Classes'></span><span id='topic+node_equivalent_dags'></span><span id='topic+ggdag_equivalent_dags'></span><span id='topic+node_equivalent_class'></span><span id='topic+ggdag_equivalent_class'></span>

<h3>Description</h3>

<p>Returns a set of complete partially directed acyclic graphs (CPDAGs) given an
input DAG. CPDAGs are Markov equivalent to the input graph. See
<code><a href="dagitty.html#topic+EquivalentModels">dagitty::equivalentDAGs()</a></code> for details.
<code>node_equivalent_dags()</code> returns a set of DAGs, while
<code>node_equivalent_class()</code> tags reversable edges.
<code>ggdag_equivalent_dags()</code> plots all equivalent DAGs, while
<code>ggdag_equivalent_class()</code> plots all reversable edges as undirected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_equivalent_dags(.dag, n = 100, layout = "auto", ...)

ggdag_equivalent_dags(
  .tdy_dag,
  ...,
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = "black",
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)

node_equivalent_class(.dag, layout = "auto")

ggdag_equivalent_class(
  .tdy_dag,
  expand_x = expansion(c(0.1, 0.1)),
  expand_y = expansion(c(0.1, 0.1)),
  breaks = ggplot2::waiver(),
  ...,
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_.dag">.dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or <code>dagitty</code></p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_n">n</code></td>
<td>
<p>maximal number of returned graphs.</p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_layout">layout</code></td>
<td>
<p>a layout available in <code>ggraph</code>. See <code><a href="ggraph.html#topic+ggraph">ggraph::create_layout()</a></code>
for details. Alternatively, <code>"time_ordered"</code> will use
<code>time_ordered_coords()</code> to algorithmically sort the graph by time.</p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>ggraph::create_layout()</code></p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>an object of class <code>tidy_dagitty</code> or <code>dagitty</code></p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for <code>geom_dag_label_repel()</code>.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_expand_x">expand_x</code>, <code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_expand_y">expand_y</code></td>
<td>
<p>Vector of range expansion constants used to add some
padding around the data, to ensure that they are placed some distance away
from the axes. Use the convenience function <code>ggplot2::expansion()</code> to
generate the values for the expand argument.</p>
</td></tr>
<tr><td><code id="Equivalent+2B20DAGs+2B20and+2B20Classes_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> NULL for no breaks
</p>
</li>
<li><p> waiver() for the default breaks computed by the transformation object
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks as output
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> with at least one DAG, including a <code>dag</code>
column to identify graph set for equivalent DAGs or a <code>reversable</code>
column for equivalent classes, or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_ex &lt;- dagify(y ~ x + z, x ~ z)

g_ex %&gt;% node_equivalent_class()

g_ex %&gt;% ggdag_equivalent_dags()

</code></pre>

<hr>
<h2 id='Exogenous+20Variables'>Find Exogenous Variables</h2><span id='topic+Exogenous+20Variables'></span><span id='topic+node_exogenous'></span><span id='topic+ggdag_exogenous'></span>

<h3>Description</h3>

<p><code>node_exogenous</code> tags exogenous variables given an exposure and
outcome. <code>ggdag_exogenous</code> plots all exogenous variables. See
<code><a href="dagitty.html#topic+exogenousVariables">dagitty::exogenousVariables()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_exogenous(.dag, ...)

ggdag_exogenous(
  .tdy_dag,
  ...,
  node_size = 16,
  text_size = 3.88,
  edge_type = "link_arc",
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exogenous+2B20Variables_+3A_.dag">.dag</code>, <code id="Exogenous+2B20Variables_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="Exogenous+2B20Variables_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
<tr><td><code id="Exogenous+2B20Variables_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Exogenous+2B20Variables_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Exogenous+2B20Variables_+3A_edge_type">edge_type</code></td>
<td>
<p>a character vector, the edge geom to use. One of:
&quot;link_arc&quot;, which accounts for directed and bidirected edges, &quot;link&quot;,
&quot;arc&quot;, or &quot;diagonal&quot;</p>
</td></tr>
<tr><td><code id="Exogenous+2B20Variables_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Exogenous+2B20Variables_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Exogenous+2B20Variables_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="Exogenous+2B20Variables_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Exogenous+2B20Variables_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Exogenous+2B20Variables_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Exogenous+2B20Variables_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for <code>geom_dag_label_repel()</code>.
Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> with an <code>exogenous</code> column for
exogenous variables or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dag &lt;- dagify(y ~ x1 + x2 + x3, b ~ x1 + x2)
ggdag_exogenous(dag)
node_exogenous(dag)

</code></pre>

<hr>
<h2 id='expand_plot'>Quickly scale the size of a ggplot</h2><span id='topic+expand_plot'></span>

<h3>Description</h3>

<p><code>expand_plot()</code> is a convenience function that expands the scales of a
ggplot, as the large node sizes in a DAG will often get clipped in themes
that don't have DAGs in mind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_plot(
  expand_x = expansion(c(0.1, 0.1)),
  expand_y = expansion(c(0.1, 0.1))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_plot_+3A_expand_x">expand_x</code>, <code id="expand_plot_+3A_expand_y">expand_y</code></td>
<td>
<p>Vector of range expansion constants used to add some
padding around the data, to ensure that they are placed some distance away
from the axes. Use the convenience function <code>ggplot2::expansion()</code> to
generate the values for the expand argument.</p>
</td></tr>
</table>

<hr>
<h2 id='fortify'>Fortify a <code>tidy_dagitty</code> object for <code>ggplot2</code></h2><span id='topic+fortify'></span><span id='topic+fortify.tidy_dagitty'></span><span id='topic+fortify.dagitty'></span>

<h3>Description</h3>

<p>Fortify a <code>tidy_dagitty</code> object for <code>ggplot2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidy_dagitty'
fortify(model, data = NULL, ...)

## S3 method for class 'dagitty'
fortify(model, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify_+3A_model">model</code></td>
<td>
<p>an object of class <code>tidy_dagitty</code> or <code>dagitty</code></p>
</td></tr>
<tr><td><code id="fortify_+3A_data">data</code></td>
<td>
<p>(not used)</p>
</td></tr>
<tr><td><code id="fortify_+3A_...">...</code></td>
<td>
<p>(not used)</p>
</td></tr>
</table>

<hr>
<h2 id='geom_dag_collider_edges'>Edges for paths activated by stratification on colliders</h2><span id='topic+geom_dag_collider_edges'></span>

<h3>Description</h3>

<p>Adjusting for a collider activates pathways between the parent of the
collider. This geom adds a curved edge between any such parent nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dag_collider_edges(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  linewidth = 0.6,
  size = NULL,
  curvature = 0.5,
  angle = 90,
  ncp = 5,
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_dag_collider_edges_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_linewidth">linewidth</code></td>
<td>
<p>a numeric vector of length 1. Edge width</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_size">size</code></td>
<td>
<p>deprecated. Please use <code>linewidth</code>.</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_curvature">curvature</code></td>
<td>
<p>A numeric value giving the amount of curvature.
Negative values produce left-hand curves, positive values
produce right-hand curves, and zero produces a straight line.</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_angle">angle</code></td>
<td>
<p>A numeric value between 0 and 180,
giving an amount to skew the control
points of the curve.  Values less than 90 skew the curve towards
the start point and values greater than 90 skew the curve
towards the end point.</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_ncp">ncp</code></td>
<td>
<p>The number of control points used to draw the curve.
More control points creates a smoother curve.</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_dag_collider_edges_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dagitty)
library(ggplot2)
dagify(m ~ a + b, x ~ a, y ~ b) %&gt;%
  tidy_dagitty() %&gt;%
  control_for("m") %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend, shape = adjusted)) +
  geom_dag_edges() +
  geom_dag_collider_edges() +
  geom_dag_point() +
  geom_dag_text() +
  theme_dag() +
  scale_adjusted()
</code></pre>

<hr>
<h2 id='geom_dag_edges'>Directed and bidirected DAG edges</h2><span id='topic+geom_dag_edges'></span>

<h3>Description</h3>

<p>Directed and bidirected DAG edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dag_edges(
  mapping = NULL,
  data_directed = filter_direction("-&gt;"),
  data_bidirected = filter_direction("&lt;-&gt;"),
  curvature = 0.3,
  arrow_directed = grid::arrow(length = grid::unit(5, "pt"), type = "closed"),
  arrow_bidirected = grid::arrow(length = grid::unit(5, "pt"), ends = "both", type =
    "closed"),
  position = "identity",
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE,
  fold = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_dag_edges_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by aes() or aes_(). If
specified and inherit.aes = TRUE (the default), it is combined with the
default mapping at the top level of the plot. You must supply mapping if
there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_dag_edges_+3A_data_directed">data_directed</code>, <code id="geom_dag_edges_+3A_data_bidirected">data_bidirected</code></td>
<td>
<p>The data to be displayed in this layer.
There are three options: If NULL, the default, the data is inherited from
the plot data as specified in the call to ggplot(). A data.frame, or other
object, will override the plot data. All objects will be fortified to
produce a data frame. See fortify() for which variables will be created. A
function will be called with a single argument, the plot data. The return
value must be a data.frame., and will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_dag_edges_+3A_curvature">curvature</code></td>
<td>
<p>The bend of the curve. 1 approximates a halfcircle while 0
will give a straight line. Negative number will change the direction of the
curve. Only used if layout circular = FALSE.</p>
</td></tr>
<tr><td><code id="geom_dag_edges_+3A_arrow_directed">arrow_directed</code>, <code id="geom_dag_edges_+3A_arrow_bidirected">arrow_bidirected</code></td>
<td>
<p>specification for arrow heads, as
created by arrow()</p>
</td></tr>
<tr><td><code id="geom_dag_edges_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_dag_edges_+3A_na.rm">na.rm</code></td>
<td>
<p>If FALSE (the default), removes missing values with a warning.
If TRUE silently removes missing values</p>
</td></tr>
<tr><td><code id="geom_dag_edges_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends? NA,
the default, includes if any aesthetics are mapped. FALSE never includes,
and TRUE always includes. It can also be a named logical vector to finely
select the aesthetics to display.</p>
</td></tr>
<tr><td><code id="geom_dag_edges_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If FALSE, overrides the default aesthetics, rather than
combining with them. This is most useful for helper functions that define
both data and aesthetics and shouldn't inherit behaviour from the default
plot specification, e.g. borders().</p>
</td></tr>
<tr><td><code id="geom_dag_edges_+3A_fold">fold</code></td>
<td>
<p>Logical. Should arcs appear on the same side of the nodes despite
different directions. Default to FALSE.</p>
</td></tr>
<tr><td><code id="geom_dag_edges_+3A_...">...</code></td>
<td>
<p>Other arguments passed to ggraph::geom_edge_*()</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_dag_edges</code> understand the following aesthetics. Bold aesthetics are
required.
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li><p> edge_colour
</p>
</li>
<li><p> edge_width
</p>
</li>
<li><p> edge_linetype
</p>
</li>
<li><p> edge_alpha
</p>
</li>
<li><p> start_cap
</p>
</li>
<li><p> end_cap
</p>
</li>
<li><p> label
</p>
</li>
<li><p> label_pos
</p>
</li>
<li><p> label_size
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> vjust
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> lineheight
</p>
</li></ul>

<p><code>geom_dag_edges</code> also uses <code>geom_dag_edges_arc</code>, which requires the
<strong>circular</strong> aesthetic, but this is automatically set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
dagify(
  y ~ x + z2 + w2 + w1,
  x ~ z1 + w1,
  z1 ~ w1 + v,
  z2 ~ w2 + v,
  w1 ~ ~w2
) %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges() +
  geom_dag_point() +
  geom_dag_text() +
  theme_dag()

</code></pre>

<hr>
<h2 id='geom_dag_label'>Node text labels</h2><span id='topic+geom_dag_label'></span>

<h3>Description</h3>

<p>Node text labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dag_label(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_dag_label_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_dag_label_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_dag_label_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_dag_label_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function. Cannot be jointly specified with
<code>nudge_x</code> or <code>nudge_y</code>.</p>
</td></tr>
<tr><td><code id="geom_dag_label_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_dag_label_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_dag_label_+3A_nudge_x">nudge_x</code>, <code id="geom_dag_label_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</td></tr>
<tr><td><code id="geom_dag_label_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_dag_label_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_dag_label_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_dag_label_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_dag_label</code> understand the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>label</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> group
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> lineheight
</p>
</li>
<li><p> size
</p>
</li>
<li><p> vjust
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(ggraph)
g &lt;- dagify(m ~ x + y, y ~ x)

ggdag(g, text = FALSE) + geom_dag_label()

g %&gt;%
  tidy_dagitty() %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(
    start_cap = label_rect(name, padding = margin(2.5, 2.5, 2.5, 2.5, "mm")),
    end_cap = label_rect(name, padding = margin(2.5, 2.5, 2.5, 2.5, "mm"))
  )) +
  geom_dag_label(size = 5, fill = "black", color = "white") +
  theme_dag()
</code></pre>

<hr>
<h2 id='geom_dag_text'>Node text</h2><span id='topic+geom_dag_text'></span>

<h3>Description</h3>

<p>Node text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dag_text(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_dag_text_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_dag_text_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_dag_text_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_dag_text_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function. Cannot be jointly specified with
<code>nudge_x</code> or <code>nudge_y</code>.</p>
</td></tr>
<tr><td><code id="geom_dag_text_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_dag_text_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_dag_text_+3A_nudge_x">nudge_x</code>, <code id="geom_dag_text_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</td></tr>
<tr><td><code id="geom_dag_text_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_dag_text_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_dag_text_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_dag_text_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_dag_text</code> understand the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>label</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> angle
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> family
</p>
</li>
<li><p> fontface
</p>
</li>
<li><p> group
</p>
</li>
<li><p> hjust
</p>
</li>
<li><p> lineheight
</p>
</li>
<li><p> size
</p>
</li>
<li><p> vjust
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
g &lt;- dagify(m ~ x + y, y ~ x)
g %&gt;%
  tidy_dagitty() %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_point() +
  geom_dag_edges() +
  geom_dag_text() +
  theme_dag()
</code></pre>

<hr>
<h2 id='ggdag'>Quickly plot a DAG in ggplot2</h2><span id='topic+ggdag'></span>

<h3>Description</h3>

<p><code>ggdag()</code> is a wrapper to quickly plot DAGs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggdag(
  .tdy_dag,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = "black",
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggdag_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="ggdag_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
<tr><td><code id="ggdag_+3A_edge_type">edge_type</code></td>
<td>
<p>a character vector, the edge geom to use. One of:
&quot;link_arc&quot;, which accounts for directed and bidirected edges, &quot;link&quot;,
&quot;arc&quot;, or &quot;diagonal&quot;</p>
</td></tr>
<tr><td><code id="ggdag_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="ggdag_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="ggdag_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="ggdag_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="ggdag_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="ggdag_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="ggdag_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="ggdag_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="ggdag_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for <code>geom_dag_label_repel()</code>.
Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggdag_classic">ggdag_classic()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dag &lt;- dagify(
  y ~ x + z2 + w2 + w1,
  x ~ z1 + w1,
  z1 ~ w1 + v,
  z2 ~ w2 + v,
  w1 ~ ~w2
)

ggdag(dag)
ggdag(dag) + theme_dag_blank()

ggdag(dagitty::randomDAG(5, .5))

</code></pre>

<hr>
<h2 id='ggdag_classic'>Quickly plot a DAG in ggplot2</h2><span id='topic+ggdag_classic'></span>

<h3>Description</h3>

<p><code>ggdag_classic()</code> is a wrapper to quickly plot DAGs in a more
traditional style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggdag_classic(
  .tdy_dag,
  ...,
  size = 8,
  label_rect_size = NULL,
  text_label = "name",
  text_col = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggdag_classic_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="ggdag_classic_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
<tr><td><code id="ggdag_classic_+3A_size">size</code></td>
<td>
<p>text size, with a default of 8.</p>
</td></tr>
<tr><td><code id="ggdag_classic_+3A_label_rect_size">label_rect_size</code></td>
<td>
<p>specify the <code>fontsize</code> argument in
<code>ggraph::label_rect</code>; default is <code>NULL</code>, in which case it is
scaled relative ti <code>size</code></p>
</td></tr>
<tr><td><code id="ggdag_classic_+3A_text_label">text_label</code></td>
<td>
<p>text variable, with a default of &quot;name&quot;</p>
</td></tr>
<tr><td><code id="ggdag_classic_+3A_text_col">text_col</code></td>
<td>
<p>text color, with a default of &quot;black&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggdag">ggdag()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dag &lt;- dagify(
  y ~ x + z2 + w2 + w1,
  x ~ z1 + w1,
  z1 ~ w1 + v,
  z2 ~ w2 + v,
  w1 ~ ~w2
)

ggdag_classic(dag)
ggdag_classic(dag) + theme_dag_blank()

ggdag_classic(dagitty::randomDAG(5, .5))

</code></pre>

<hr>
<h2 id='ggplot.tidy_dagitty'>Create a new ggplot</h2><span id='topic+ggplot.tidy_dagitty'></span><span id='topic+ggplot.dagitty'></span>

<h3>Description</h3>

<p>Create a new ggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidy_dagitty'
ggplot(data = NULL, mapping = aes(), ...)

## S3 method for class 'dagitty'
ggplot(data = NULL, mapping = aes(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot.tidy_dagitty_+3A_data">data</code></td>
<td>
<p>Default dataset to use for plot. If not already a data.frame,
will be converted to one by <code><a href="ggplot2.html#topic+fortify">fortify()</a></code>. If not specified,
must be supplied in each layer added to the plot.</p>
</td></tr>
<tr><td><code id="ggplot.tidy_dagitty_+3A_mapping">mapping</code></td>
<td>
<p>Default list of aesthetic mappings to use for plot.
If not specified, must be supplied in each layer added to the plot.</p>
</td></tr>
<tr><td><code id="ggplot.tidy_dagitty_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
</table>

<hr>
<h2 id='ggrepel+20functions'>Repulsive textual annotations</h2><span id='topic+ggrepel+20functions'></span><span id='topic+geom_dag_text_repel'></span><span id='topic+geom_dag_label_repel'></span>

<h3>Description</h3>

<p>These functions are minor modifications of those in the <code>ggrepel</code>
package. geom_dag_text_repel adds text directly to the plot.
geom_dag_label_repel draws a rectangle underneath the text, making it easier
to read. The text labels repel away from each other and away from the data
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dag_text_repel(
  mapping = NULL,
  data = NULL,
  parse = FALSE,
  ...,
  box.padding = 0.35,
  point.padding = 1.5,
  segment.color = "#666666",
  fontface = "bold",
  segment.size = 0.5,
  arrow = NULL,
  force = 1,
  max.iter = 2000,
  nudge_x = 0,
  nudge_y = 0,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_dag_label_repel(
  mapping = NULL,
  data = NULL,
  parse = FALSE,
  ...,
  box.padding = grid::unit(0.35, "lines"),
  label.padding = grid::unit(0.25, "lines"),
  point.padding = grid::unit(1.5, "lines"),
  label.r = grid::unit(0.15, "lines"),
  label.size = 0.25,
  segment.color = "grey50",
  segment.size = 0.5,
  arrow = NULL,
  force = 1,
  max.iter = 2000,
  nudge_x = 0,
  nudge_y = 0,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggrepel+2B20functions_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), is combined with the default mapping at the top level of the
plot. You only need to supply <code>mapping</code> if there isn't a mapping
defined for the plot.</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_data">data</code></td>
<td>
<p>A data frame. If specified, overrides the default data frame
defined at the top level of the plot.</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_parse">parse</code></td>
<td>
<p>If TRUE, the labels will be parsed into expressions and
displayed as described in ?plotmath</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. There are
three types of arguments you can use here:
</p>

<ul>
<li><p> Aesthetics: to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>.
</p>
</li>
<li><p> Other arguments to the layer, for example you override the
default <code>stat</code> associated with the layer.
</p>
</li>
<li><p> Other arguments passed on to the stat.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_box.padding">box.padding</code></td>
<td>
<p>Amount of padding around bounding box, as unit or number.
Defaults to 0.25. (Default unit is lines, but other units can be specified
by passing <code>unit(x, "units")</code>).</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_point.padding">point.padding</code></td>
<td>
<p>Amount of padding around labeled point, as unit or
number. Defaults to 0. (Default unit is lines, but other units can be
specified by passing <code>unit(x, "units")</code>).</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_segment.color">segment.color</code>, <code id="ggrepel+2B20functions_+3A_segment.size">segment.size</code></td>
<td>
<p>See <code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_text_repel()</a></code></p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_fontface">fontface</code></td>
<td>
<p>A character vector. Default is &quot;bold&quot;</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by <code><a href="grid.html#topic+arrow">arrow</a></code></p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_force">force</code></td>
<td>
<p>Force of repulsion between overlapping text labels. Defaults
to 1.</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations to try to resolve overlaps.
Defaults to 10000.</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_nudge_x">nudge_x</code>, <code id="ggrepel+2B20functions_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_label.padding">label.padding</code></td>
<td>
<p>Amount of padding around label, as unit or number.
Defaults to 0.25. (Default unit is lines, but other units can be specified
by passing <code>unit(x, "units")</code>).</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_label.r">label.r</code></td>
<td>
<p>Radius of rounded corners, as unit or number. Defaults
to 0.15. (Default unit is lines, but other units can be specified by
passing <code>unit(x, "units")</code>).</p>
</td></tr>
<tr><td><code id="ggrepel+2B20functions_+3A_label.size">label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
g &lt;- dagify(m ~ x + y,
  y ~ x,
  exposure = "x",
  outcome = "y",
  latent = "m",
  labels = c("x" = "Exposure", "y" = "Outcome", "m" = "Collider")
)

g %&gt;%
  tidy_dagitty() %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges() +
  geom_dag_point() +
  geom_dag_text_repel(aes(label = name), show.legend = FALSE) +
  theme_dag()

g %&gt;%
  tidy_dagitty() %&gt;%
  dag_label(labels = c(
    "x" = "This is the exposure",
    "y" = "Here's the outcome",
    "m" = "Here is where they collide"
  )) %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges() +
  geom_dag_point() +
  geom_dag_text() +
  geom_dag_label_repel(aes(label = label, fill = label),
    col = "white", show.legend = FALSE
  ) +
  theme_dag()

</code></pre>

<hr>
<h2 id='Instrumental+20Variables'>Find Instrumental Variables</h2><span id='topic+Instrumental+20Variables'></span><span id='topic+node_instrumental'></span><span id='topic+ggdag_instrumental'></span>

<h3>Description</h3>

<p><code>node_instrumental</code> tags instrumental variables given an exposure and
outcome. <code>ggdag_instrumental</code> plots all instrumental variables. See
<code><a href="dagitty.html#topic+instrumentalVariables">dagitty::instrumentalVariables()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_instrumental(.dag, exposure = NULL, outcome = NULL, ...)

ggdag_instrumental(
  .tdy_dag,
  exposure = NULL,
  outcome = NULL,
  ...,
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Instrumental+2B20Variables_+3A_.dag">.dag</code>, <code id="Instrumental+2B20Variables_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_exposure">exposure</code></td>
<td>
<p>character vector of length 1, name of exposure variable.
Default is <code>NULL</code>, in which case it will check the input DAG for
exposure.</p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_outcome">outcome</code></td>
<td>
<p>character vector of length 1, name of exposure variable.
Default is <code>NULL</code>, in which case it will check the input DAG for
exposure.</p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Instrumental+2B20Variables_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for <code>geom_dag_label_repel()</code>.
Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> with an <code>instrumental</code> column for
instrumental variables or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dagitty)

node_instrumental(dagitty("dag{ i-&gt;x-&gt;y; x&lt;-&gt;y }"), "x", "y")
ggdag_instrumental(dagitty("dag{ i-&gt;x-&gt;y; i2-&gt;x-&gt;y; x&lt;-&gt;y }"), "x", "y")

</code></pre>

<hr>
<h2 id='is_confounder'>Assess if a variable confounds a relationship</h2><span id='topic+is_confounder'></span>

<h3>Description</h3>

<p>Assess if a variable confounds a relationship
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_confounder(.tdy_dag, z, x, y, direct = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_confounder_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="is_confounder_+3A_z">z</code></td>
<td>
<p>a character vector, the potential confounder</p>
</td></tr>
<tr><td><code id="is_confounder_+3A_x">x</code>, <code id="is_confounder_+3A_y">y</code></td>
<td>
<p>a character vector, the variables z may confound.</p>
</td></tr>
<tr><td><code id="is_confounder_+3A_direct">direct</code></td>
<td>
<p>logical. Only consider direct confounding? Default is
<code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. Is the variable a confounder?
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dag &lt;- dagify(y ~ z, x ~ z)

is_confounder(dag, "z", "x", "y")
is_confounder(dag, "x", "z", "y")

</code></pre>

<hr>
<h2 id='is.tidy_dagitty'>Test for object class for tidy_dagitty</h2><span id='topic+is.tidy_dagitty'></span>

<h3>Description</h3>

<p>Test for object class for tidy_dagitty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.tidy_dagitty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.tidy_dagitty_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>

<hr>
<h2 id='Nodes'>DAG Nodes</h2><span id='topic+Nodes'></span><span id='topic+geom_dag_node'></span><span id='topic+geom_dag_point'></span>

<h3>Description</h3>

<p><code>geom_dag_node</code> and <code>geom_dag_point</code> are very similar to
<a href="ggplot2.html#topic+geom_point">ggplot2::geom_point</a> but with a few defaults changed. <code>geom_dag_node</code> is
slightly stylized and includes an internal white circle, while
<code>geom_dag_point</code> plots a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dag_node(
  mapping = NULL,
  data = NULL,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_dag_point(
  mapping = NULL,
  data = NULL,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nodes_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="Nodes_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="Nodes_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="Nodes_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="Nodes_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="Nodes_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="Nodes_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_dag_node</code> and <code>geom_dag_point</code> understand the
following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> shape
</p>
</li>
<li><p> size
</p>
</li>
<li><p> stroke
</p>
</li>
<li><p> filter
</p>
</li></ul>

<p><code>geom_dag_node</code> also accepts:
</p>

<ul>
<li><p> internal_colour
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
g &lt;- dagify(m ~ x + y, y ~ x)
p &lt;- g %&gt;%
  tidy_dagitty() %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges() +
  theme_dag()

p +
  geom_dag_node() +
  geom_dag_text()

p +
  geom_dag_point() +
  geom_dag_text()
</code></pre>

<hr>
<h2 id='Pathways'>Find Open Paths Between Variables</h2><span id='topic+Pathways'></span><span id='topic+dag_paths'></span><span id='topic+ggdag_paths'></span><span id='topic+ggdag_paths_fan'></span>

<h3>Description</h3>

<p><code>dag_paths</code> finds open paths between a given exposure and outcome.
<code>ggdag_paths</code> and <code>ggdag_paths_fan</code> plot all open paths. See
<code><a href="dagitty.html#topic+paths">dagitty::paths()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag_paths(
  .dag,
  from = NULL,
  to = NULL,
  adjust_for = NULL,
  limit = 100,
  directed = FALSE,
  paths_only = FALSE,
  ...
)

ggdag_paths(
  .tdy_dag,
  from = NULL,
  to = NULL,
  adjust_for = NULL,
  limit = 100,
  directed = FALSE,
  shadow = FALSE,
  ...,
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)

ggdag_paths_fan(
  .tdy_dag,
  from = NULL,
  to = NULL,
  adjust_for = NULL,
  limit = 100,
  directed = FALSE,
  ...,
  shadow = FALSE,
  spread = 0.7,
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pathways_+3A_.dag">.dag</code>, <code id="Pathways_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="Pathways_+3A_from">from</code></td>
<td>
<p>character vector of length 1, name of exposure variable. Default
is <code>NULL</code>, in which case it will check the input DAG for exposure.</p>
</td></tr>
<tr><td><code id="Pathways_+3A_to">to</code></td>
<td>
<p>character vector of length 1, name of exposure variable. Default is
<code>NULL</code>, in which case it will check the input DAG for exposure.</p>
</td></tr>
<tr><td><code id="Pathways_+3A_adjust_for">adjust_for</code></td>
<td>
<p>character vector, a set of variables to control for.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Pathways_+3A_limit">limit</code></td>
<td>
<p>maximum amount of paths to show. In general, the number of paths grows
exponentially with the number of variables in the graph, such that path inspection
is not useful except for the most simple models.</p>
</td></tr>
<tr><td><code id="Pathways_+3A_directed">directed</code></td>
<td>
<p>logical. Should only directed paths be shown?</p>
</td></tr>
<tr><td><code id="Pathways_+3A_paths_only">paths_only</code></td>
<td>
<p>logical. Should only open paths be returned? Default is
<code>FALSE</code>, which includes every variable and edge in the DAG regardless
if they are part of the path.</p>
</td></tr>
<tr><td><code id="Pathways_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
<tr><td><code id="Pathways_+3A_shadow">shadow</code></td>
<td>
<p>logical. Show edges which are not on an open path? Ignored if
<code>paths_only</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Pathways_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Pathways_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Pathways_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Pathways_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Pathways_+3A_label_col">label_col</code></td>
<td>
<p>label color</p>
</td></tr>
<tr><td><code id="Pathways_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Pathways_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Pathways_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Pathways_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for <code>geom_dag_label_repel()</code>.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Pathways_+3A_spread">spread</code></td>
<td>
<p>the width of the fan spread</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> with a <code>path</code> column for path variables and a <code>set</code>
grouping column or a <code>ggplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>confounder_triangle(x_y_associated = TRUE) %&gt;%
  dag_paths(from = "x", to = "y")

confounder_triangle(x_y_associated = TRUE) %&gt;%
  ggdag_paths(from = "x", to = "y")

butterfly_bias(x_y_associated = TRUE) %&gt;%
  ggdag_paths_fan(shadow = TRUE)

</code></pre>

<hr>
<h2 id='print.tidy_dagitty'>Print a <code>tidy_dagitty</code></h2><span id='topic+print.tidy_dagitty'></span>

<h3>Description</h3>

<p>Print a <code>tidy_dagitty</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidy_dagitty'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tidy_dagitty_+3A_x">x</code></td>
<td>
<p>an object of class <code>tidy_dagitty</code></p>
</td></tr>
<tr><td><code id="print.tidy_dagitty_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>print()</code></p>
</td></tr>
</table>

<hr>
<h2 id='pull_dag'>Pull components from DAG objects</h2><span id='topic+pull_dag'></span><span id='topic+pull_dag.tidy_dagitty'></span><span id='topic+pull_dag.dagitty'></span><span id='topic+pull_dag_data'></span><span id='topic+pull_dag_data.tidy_dagitty'></span><span id='topic+pull_dag_data.dagitty'></span><span id='topic+update_dag_data+3C-'></span><span id='topic+update_dag_data+3C-.tidy_dagitty'></span><span id='topic+update_dag'></span><span id='topic+update_dag+3C-'></span><span id='topic+update_dag.tidy_dagitty'></span><span id='topic+update_dag+3C-.tidy_dagitty'></span>

<h3>Description</h3>

<p><code>pull_dag()</code> and <code>pull_dag_data()</code> are generic methods to pull components of
DAG objects, e.g. <code>tidy_dagitty</code>, such as the <code>dagitty</code> object or the data
frame associated with it. These methods are recommended over extracting
components manually, e.g. <code>my_dag$data</code>, because the internal structure of
these objects may change over time. Similarly, use <code>update_dag()</code> if you want
to sync the data back to the DAG object or override it with another DAG; use
<code>update_dag_data()</code> to do update the data frame. This is useful with
<code>pull_dag_data()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_dag(x, ...)

## S3 method for class 'tidy_dagitty'
pull_dag(x, ...)

## S3 method for class 'dagitty'
pull_dag(x, ...)

pull_dag_data(x, ...)

## S3 method for class 'tidy_dagitty'
pull_dag_data(x, ...)

## S3 method for class 'dagitty'
pull_dag_data(x, ...)

update_dag_data(x) &lt;- value

## S3 replacement method for class 'tidy_dagitty'
update_dag_data(x) &lt;- value

update_dag(x, ...)

update_dag(x) &lt;- value

## S3 method for class 'tidy_dagitty'
update_dag(x, ...)

## S3 replacement method for class 'tidy_dagitty'
update_dag(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_dag_+3A_x">x</code></td>
<td>
<p>a <code>tidy_dagitty</code> or <code>dagitty</code> object.</p>
</td></tr>
<tr><td><code id="pull_dag_+3A_...">...</code></td>
<td>
<p>For <code>dagitty</code> objects, passed to <code>tidy_dagitty()</code> if needed,
otherwise currently unused.</p>
</td></tr>
<tr><td><code id="pull_dag_+3A_value">value</code></td>
<td>
<p>a value to set, either a <code>dagitty</code> or <code>data.frame</code> object,
depending on the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a DAG object, e.g. <code>dagitty</code>, or data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tidy_dagitty_obj &lt;- dagify(y ~ x + z, x ~ z) %&gt;%
  tidy_dagitty()
dag &lt;- pull_dag(tidy_dagitty_obj)
dag_data &lt;- pull_dag_data(tidy_dagitty_obj)

tidy_dagitty_obj %&gt;%
  dplyr::mutate(name = toupper(name)) %&gt;%
  # recreate the DAG component
  update_dag()

dag_data$label &lt;- paste0(dag_data$name, "(observed)")
update_dag_data(tidy_dagitty_obj) &lt;- dag_data

</code></pre>

<hr>
<h2 id='Quick+20Plots+20for+20Common+20DAGs'>Quickly create a DAGs with common structures of bias</h2><span id='topic+Quick+20Plots+20for+20Common+20DAGs'></span><span id='topic+m_bias'></span><span id='topic+butterfly_bias'></span><span id='topic+confounder_triangle'></span><span id='topic+collider_triangle'></span><span id='topic+mediation_triangle'></span><span id='topic+ggdag_m_bias'></span><span id='topic+ggdag_butterfly_bias'></span><span id='topic+ggdag_confounder_triangle'></span><span id='topic+ggdag_collider_triangle'></span><span id='topic+ggdag_mediation_triangle'></span>

<h3>Description</h3>

<p>base functions create an object of class <code>dagitty</code>; <code style="white-space: pre;">&#8288;ggdag_* &#8288;</code> functions
are wrappers that also call <code>ggdag()</code> on the <code>dagitty</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m_bias(
  x = NULL,
  y = NULL,
  a = NULL,
  b = NULL,
  m = NULL,
  x_y_associated = FALSE
)

butterfly_bias(
  x = NULL,
  y = NULL,
  a = NULL,
  b = NULL,
  m = NULL,
  x_y_associated = FALSE
)

confounder_triangle(x = NULL, y = NULL, z = NULL, x_y_associated = FALSE)

collider_triangle(x = NULL, y = NULL, m = NULL, x_y_associated = FALSE)

mediation_triangle(x = NULL, y = NULL, m = NULL, x_y_associated = FALSE)

ggdag_m_bias(
  x = NULL,
  y = NULL,
  a = NULL,
  b = NULL,
  m = NULL,
  x_y_associated = FALSE,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)

ggdag_butterfly_bias(
  x = NULL,
  y = NULL,
  a = NULL,
  b = NULL,
  m = NULL,
  x_y_associated = FALSE,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)

ggdag_confounder_triangle(
  x = NULL,
  y = NULL,
  z = NULL,
  x_y_associated = FALSE,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)

ggdag_collider_triangle(
  x = NULL,
  y = NULL,
  m = NULL,
  x_y_associated = FALSE,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)

ggdag_mediation_triangle(
  x = NULL,
  y = NULL,
  m = NULL,
  x_y_associated = FALSE,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_x">x</code>, <code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_y">y</code>, <code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_a">a</code>, <code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_b">b</code>, <code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_m">m</code>, <code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_z">z</code></td>
<td>
<p>Character vector. Optional label. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_x_y_associated">x_y_associated</code></td>
<td>
<p>Logical. Are x and y associated? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_edge_type">edge_type</code></td>
<td>
<p>a character vector, the edge geom to use. One of:
&quot;link_arc&quot;, which accounts for directed and bidirected edges, &quot;link&quot;,
&quot;arc&quot;, or &quot;diagonal&quot;</p>
</td></tr>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Quick+2B20Plots+2B20for+2B20Common+2B20DAGs_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for <code>geom_dag_label_repel()</code>.
Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a DAG of class <code>dagitty</code> or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m_bias() %&gt;% ggdag_adjust("m")
ggdag_confounder_triangle()

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+filter'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter">filter</a></code></p>
</dd>
</dl>

<hr>
<h2 id='remove_axes'>Quickly remove plot axes and grids</h2><span id='topic+remove_axes'></span><span id='topic+remove_grid'></span>

<h3>Description</h3>

<p><code>remove_axes()</code> and <code>remove_grid()</code> are convenience functions that removes
the axes and grids from a ggplot, respectively. This is useful when you want
to use an existing theme, e.g. those included in <code>ggplot2</code>, for a DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_axes()

remove_grid()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggdag(confounder_triangle()) +
  theme_bw() +
  remove_axes()

</code></pre>

<hr>
<h2 id='scale_adjusted'>Common scale adjustments for DAGs</h2><span id='topic+scale_adjusted'></span><span id='topic+scale_dag'></span>

<h3>Description</h3>

<p><code>scale_adjusted()</code> is a convenience function that implements ways of
visualizing adjustment for a variable. By convention, a square shape is used
to indicate adjustment and a circle when not adjusted. Arrows out of adjusted
variables are often eliminated or de-emphasized, and <code>scale_adjusted()</code> uses
a lower <code>alpha</code> for these arrows. When adjusting a collider, a dashed line is
sometimes used to demarcate opened pathways, and <code>scale_adjusted()</code> does this
whenever <code><a href="#topic+geom_dag_collider_edges">geom_dag_collider_edges()</a></code> is used. <code>scale_dag()</code> is deprecated in
favor of <code>scale_adjusted()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_adjusted()

scale_dag(breaks = ggplot2::waiver())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_adjusted_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> NULL for no breaks
</p>
</li>
<li><p> waiver() for the default breaks computed by the transformation object
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks as output
</p>
</li></ul>
</td></tr>
</table>

<hr>
<h2 id='simulate_data'>Simulate Data from Structural Equation Model</h2><span id='topic+simulate_data'></span>

<h3>Description</h3>

<p>This is a thin wrapper for the <code>simulateSEM()</code>function in <code>dagitty</code>
that works with tidied dagitty objects. It treats the input DAG as a
structural equation model, generating random path coefficients and simulating
corresponding data. See <code><a href="dagitty.html#topic+simulateSEM">dagitty::simulateSEM()</a></code> for
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_data(
  .tdy_dag,
  b.default = NULL,
  b.lower = -0.6,
  b.upper = 0.6,
  eps = 1,
  N = 500,
  standardized = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_data_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>the input DAG, which can be a <code>tidy_dagitty</code> or
<code>dagitty</code> object.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_b.default">b.default</code></td>
<td>
<p>default path coefficient applied to arrows for which no
coefficient is defined in the model syntax.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_b.lower">b.lower</code></td>
<td>
<p>lower bound for random path coefficients, applied if b.default
= NULL.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_b.upper">b.upper</code></td>
<td>
<p>upper bound for path coefficients.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_eps">eps</code></td>
<td>
<p>residual variance (only meaningful if standardized=FALSE).</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_n">N</code></td>
<td>
<p>number of samples to generate.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_standardized">standardized</code></td>
<td>
<p>whether a standardized output is desired (all variables
have variance 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tbl</code>with N values for each variable in .tdy_dag
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dagify(y ~ z, x ~ z) %&gt;%
  tidy_dagitty() %&gt;%
  simulate_data()
</code></pre>

<hr>
<h2 id='tbl_df.tidy_daggity'>Convert a <code>tidy_dagitty</code> object to tbl_df</h2><span id='topic+tbl_df.tidy_daggity'></span>

<h3>Description</h3>

<p>Convert a <code>tidy_dagitty</code> object to tbl_df
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_df.tidy_daggity(.tdy_dag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl_df.tidy_daggity_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>an object of class <code>tidy_dagitty</code></p>
</td></tr>
</table>

<hr>
<h2 id='Test+20if+20Variable+20Is+20Collider'>Detecting colliders in DAGs</h2><span id='topic+Test+20if+20Variable+20Is+20Collider'></span><span id='topic+is_collider'></span><span id='topic+is_downstream_collider'></span>

<h3>Description</h3>

<p>Detecting colliders in DAGs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_collider(.dag, .var, downstream = TRUE)

is_downstream_collider(.dag, .var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Test+2B20if+2B20Variable+2B20Is+2B20Collider_+3A_.dag">.dag</code></td>
<td>
<p>an input graph, an object of class <code>tidy_dagitty</code> or <code>dagitty</code></p>
</td></tr>
<tr><td><code id="Test+2B20if+2B20Variable+2B20Is+2B20Collider_+3A_.var">.var</code></td>
<td>
<p>a character vector of length 1, the potential collider to check</p>
</td></tr>
<tr><td><code id="Test+2B20if+2B20Variable+2B20Is+2B20Collider_+3A_downstream">downstream</code></td>
<td>
<p>Logical. Check for downstream colliders? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. Is the variable a collider or downstream collider?
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dag &lt;- dagify(m ~ x + y, m_jr ~ m)
is_collider(dag, "m")
is_downstream_collider(dag, "m_jr")

#  a downstream collider is also treated as a collider
is_collider(dag, "m_jr")

#  but a direct collider is not treated as a downstream collider
is_downstream_collider(dag, "m")

</code></pre>

<hr>
<h2 id='theme_dag_blank'>Minimalist DAG themes</h2><span id='topic+theme_dag_blank'></span><span id='topic+theme_dag'></span><span id='topic+theme_dag_grid'></span>

<h3>Description</h3>

<p>Minimalist DAG themes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_dag_blank(base_size = 12, base_family = "", ...)

theme_dag(base_size = 12, base_family = "", ...)

theme_dag_grid(base_size = 12, base_family = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_dag_blank_+3A_base_size">base_size</code></td>
<td>
<p>base font size, given in pts.</p>
</td></tr>
<tr><td><code id="theme_dag_blank_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
<tr><td><code id="theme_dag_blank_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>theme()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggdag(m_bias()) + theme_dag_blank() # the default

</code></pre>

<hr>
<h2 id='theme_dag_grey'>Simple grey themes for DAGs</h2><span id='topic+theme_dag_grey'></span><span id='topic+theme_dag_gray'></span><span id='topic+theme_dag_grey_grid'></span><span id='topic+theme_dag_gray_grid'></span>

<h3>Description</h3>

<p>Simple grey themes for DAGs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_dag_grey(base_size = 12, base_family = "", ...)

theme_dag_gray(base_size = 12, base_family = "", ...)

theme_dag_grey_grid(base_size = 12, base_family = "", ...)

theme_dag_gray_grid(base_size = 12, base_family = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_dag_grey_+3A_base_size">base_size</code></td>
<td>
<p>base font size, given in pts.</p>
</td></tr>
<tr><td><code id="theme_dag_grey_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
<tr><td><code id="theme_dag_grey_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>theme()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ggdag(m_bias()) + theme_dag_grey()

</code></pre>

<hr>
<h2 id='tidy_dagitty'>Tidy a <code>dagitty</code> object</h2><span id='topic+tidy_dagitty'></span>

<h3>Description</h3>

<p>Tidy a <code>dagitty</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_dagitty(.dagitty, seed = NULL, layout = "nicely", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_dagitty_+3A_.dagitty">.dagitty</code></td>
<td>
<p>a <code>dagitty</code></p>
</td></tr>
<tr><td><code id="tidy_dagitty_+3A_seed">seed</code></td>
<td>
<p>a numeric seed for reproducible layout generation</p>
</td></tr>
<tr><td><code id="tidy_dagitty_+3A_layout">layout</code></td>
<td>
<p>a layout available in <code>ggraph</code>. See <code><a href="ggraph.html#topic+ggraph">ggraph::create_layout()</a></code>
for details. Alternatively, <code>"time_ordered"</code> will use
<code>time_ordered_coords()</code> to algorithmically sort the graph by time.</p>
</td></tr>
<tr><td><code id="tidy_dagitty_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>ggraph::create_layout()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dagitty)
library(ggplot2)

dag &lt;- dagitty("dag {
  Y &lt;- X &lt;- Z1 &lt;- V -&gt; Z2 -&gt; Y
  Z1 &lt;- W1 &lt;-&gt; W2 -&gt; Z2
  X &lt;- W1 -&gt; Y
  X &lt;- W2 -&gt; Y
  X [exposure]
  Y [outcome]
  }")

tidy_dagitty(dag)

tidy_dagitty(dag, layout = "fr") %&gt;%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_node() +
  geom_dag_text() +
  geom_dag_edges() +
  theme_dag()
</code></pre>

<hr>
<h2 id='time_ordered_coords'>Create a time-ordered coordinate data frame</h2><span id='topic+time_ordered_coords'></span>

<h3>Description</h3>

<p><code>time_ordered_coords()</code> is a helper function to create time-ordered DAGs.
Pass the results to the <code>coords</code> argument of <code>dagify()</code>. If <code>.vars</code> if not
specified, these coordinates will be determined automatically. If you want to
be specific, you can also use a list or data frame. The default is to assume
you want variables to go from left to right in order by time. Variables are
spread along the y-axis using a simple algorithm to stack them. You can also
work along the y-axis by setting <code>direction = "y"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_ordered_coords(
  .vars = NULL,
  time_points = NULL,
  direction = c("x", "y"),
  auto_sort_direction = c("right", "left")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_ordered_coords_+3A_.vars">.vars</code></td>
<td>
<p>A list of character vectors, where each vector represents a
single time period. Alternatively, a data frame where the first column is
the variable name and the second column is the time period.</p>
</td></tr>
<tr><td><code id="time_ordered_coords_+3A_time_points">time_points</code></td>
<td>
<p>A vector of time points. Default is <code>NULL</code>, which creates
a sequence from 1 to the number of variables.</p>
</td></tr>
<tr><td><code id="time_ordered_coords_+3A_direction">direction</code></td>
<td>
<p>A character string indicating the axis along which the
variables should be time-ordered. Either &quot;x&quot; or &quot;y&quot;. Default is &quot;x&quot;.</p>
</td></tr>
<tr><td><code id="time_ordered_coords_+3A_auto_sort_direction">auto_sort_direction</code></td>
<td>
<p>If <code>.vars</code> is <code>NULL</code>: nodes will be placed as far
<code>"left"</code> or <code>"right"</code> of in the graph as is reasonable. Default is right,
meaning the nodes will be as close as possible in time to their
descendants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with three columns: <code>name</code>, <code>x</code>, and <code>y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dagify">dagify()</a></code>, <code><a href="#topic+coords2df">coords2df()</a></code>, <code><a href="#topic+coords2list">coords2list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dagify(
  d ~ c1 + c2 + c3,
  c1 ~ b1 + b2,
  c3 ~ a,
  b1 ~ a,
  coords = time_ordered_coords()
) %&gt;% ggdag()

coords &lt;- time_ordered_coords(list(
  # time point 1
  "a",
  # time point 2
  c("b1", "b2"),
  # time point 3
  c("c1", "c2", "c3"),
  # time point 4
  "d"
))

dagify(
  d ~ c1 + c2 + c3,
  c1 ~ b1 + b2,
  c3 ~ a,
  b1 ~ a,
  coords = coords
) %&gt;% ggdag()

# or use a data frame
x &lt;- data.frame(
  name = c("x1", "x2", "y", "z1", "z2", "z3", "a"),
  time = c(1, 1, 2, 3, 3, 3, 4)
)
dagify(
  z3 ~ y,
  y ~ x1 + x2,
  a ~ z1 + z2 + z3,
  coords = time_ordered_coords(x)
) %&gt;%
  ggdag()

</code></pre>

<hr>
<h2 id='Variable+20Status'>Find variable status</h2><span id='topic+Variable+20Status'></span><span id='topic+node_status'></span><span id='topic+ggdag_status'></span>

<h3>Description</h3>

<p>Detects variable status given a DAG (exposure, outcome, latent). See
<code><a href="dagitty.html#topic+VariableStatus">dagitty::VariableStatus()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_status(.dag, as_factor = TRUE, ...)

ggdag_status(
  .tdy_dag,
  ...,
  edge_type = "link_arc",
  node_size = 16,
  text_size = 3.88,
  label_size = text_size,
  text_col = "white",
  label_col = text_col,
  node = TRUE,
  stylized = FALSE,
  text = TRUE,
  use_labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variable+2B20Status_+3A_.dag">.dag</code>, <code id="Variable+2B20Status_+3A_.tdy_dag">.tdy_dag</code></td>
<td>
<p>input graph, an object of class <code>tidy_dagitty</code> or
<code>dagitty</code></p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_as_factor">as_factor</code></td>
<td>
<p>treat <code>status</code> variable as factor</p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>tidy_dagitty()</code></p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_edge_type">edge_type</code></td>
<td>
<p>a character vector, the edge geom to use. One of:
&quot;link_arc&quot;, which accounts for directed and bidirected edges, &quot;link&quot;,
&quot;arc&quot;, or &quot;diagonal&quot;</p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_node_size">node_size</code></td>
<td>
<p>size of DAG node</p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_text_size">text_size</code></td>
<td>
<p>size of DAG text</p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_label_size">label_size</code></td>
<td>
<p>size of label text</p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_text_col">text_col</code></td>
<td>
<p>color of DAG text</p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_label_col">label_col</code></td>
<td>
<p>color of label text</p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_node">node</code></td>
<td>
<p>logical. Should nodes be included in the DAG?</p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_stylized">stylized</code></td>
<td>
<p>logical. Should DAG nodes be stylized? If so, use
<code>geom_dag_nodes</code> and if not use <code>geom_dag_point</code></p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_text">text</code></td>
<td>
<p>logical. Should text be included in the DAG?</p>
</td></tr>
<tr><td><code id="Variable+2B20Status_+3A_use_labels">use_labels</code></td>
<td>
<p>a string. Variable to use for <code>geom_dag_label_repel()</code>.
Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>node_collider</code> tags variable status and <code>ggdag_collider</code> plots all
variable statuses.
</p>


<h3>Value</h3>

<p>a <code>tidy_dagitty</code> with a <code>status</code> column for
variable status or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dag &lt;- dagify(l ~ x + y,
  y ~ x,
  exposure = "x",
  outcome = "y",
  latent = "l"
)

node_status(dag)
ggdag_status(dag)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
