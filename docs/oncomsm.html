<!DOCTYPE html><html lang="en-US"><head><title>Help for package oncomsm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {oncomsm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#oncomsm-package'><p>The oncomsm package</p></a></li>
<li><a href='#check_data'><p>Check a visits data set for correct format</p></a></li>
<li><a href='#compute_pfs'><p>Compute progression-free-survival rate given sample</p></a></li>
<li><a href='#impute'><p>Sample visits from predictive distribution</p></a></li>
<li><a href='#parameter_sample_to_tibble'><p>Convert parameter sample to data table</p></a></li>
<li><a href='#plot_mstate'><p>Swimmer plot of multi-state data</p></a></li>
<li><a href='#plot_pfs'><p>Plot progression-free-survival function</p></a></li>
<li><a href='#plot_response_probability'><p>Plot the response probability distributions</p></a></li>
<li><a href='#plot_transition_times'><p>Plot the transition times of a model</p></a></li>
<li><a href='#plot.srpmodel'><p>Summary plot of model prior</p></a></li>
<li><a href='#print.srpmodel'><p>Print an srpmodel</p></a></li>
<li><a href='#sample_posterior'><p>Sample parameters from a model</p></a></li>
<li><a href='#simulate_decision_rule'><p>Simulate results under a custom decision rule</p></a></li>
<li><a href='#srpmodel'><p>A stable-response-progression model</p></a></li>
<li><a href='#visits_to_mstate'><p>Convert cross-sectional visit data to multi-state format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Multi-State Models for Early Oncology</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements methods to fit a parametric Bayesian multi-state model
    to tumor response data.
    The model can be used to sample from the predictive distribution to impute
    missing data and calculate probability of success for custom decision
    criteria in early clinical trials during an ongoing trial.
    The inference is implemented using 'stan'.</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp, RcppNumerical (&ge; 0.4), rstan (&ge; 2.18), rlang
(&ge; 0.4), magrittr, tibble, dplyr, tidyr, purrr, furrr,
stringr, ggplot2, checkmate, rstantools</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp, RcppEigen (&ge; 0.3), RcppNumerical (&ge;
0.4), rstan (&ge; 2.18), StanHeaders (&ge; 2.18), RcppParallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0), patchwork, bhmbasket,
vdiffr, DiagrammeR, future, doFuture, doRNG, rjags</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://boehringer-ingelheim.github.io/oncomsm/">https://boehringer-ingelheim.github.io/oncomsm/</a>,
<a href="https://github.com/Boehringer-Ingelheim/oncomsm">https://github.com/Boehringer-Ingelheim/oncomsm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Boehringer-Ingelheim/oncomsm/issues">https://github.com/Boehringer-Ingelheim/oncomsm/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-16 23:24:10 UTC; kunzmann</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Kunzmann <a href="https://orcid.org/0000-0002-1140-7143"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Karthik Ananthakrishnan [ctb],
  Boehringer Ingelheim Ltd. [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Kunzmann &lt;kevin.kunzmann@boehringer-ingelheim.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-17 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='oncomsm-package'>The oncomsm package</h2><span id='topic+oncomsm-package'></span><span id='topic+oncomsm'></span>

<h3>Description</h3>

<p>This package implements methods to dynamically predict response
and progression of individuals in early oncology trials using parametric
multi-state models and Bayesian inference.
This allows the dynamic computation of Probability of Success for a wide
The inference is implemented using 'rstan'.
</p>


<h3>References</h3>

<p>Stan Development Team (2021). &quot;RStan: the R interface to Stan&quot;.
R package version 2.21.3. https://mc-stan.org
</p>

<hr>
<h2 id='check_data'>Check a visits data set for correct format</h2><span id='topic+check_data'></span>

<h3>Description</h3>

<p>Raises specific errors when encountering issues in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data(data, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_data_+3A_data">data</code></td>
<td>
<p>data.frame to check</p>
</td></tr>
<tr><td><code id="check_data_+3A_model">model</code></td>
<td>
<p><a href="#topic+srpmodel">srpmodel</a> object used to fit data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame, same as input but all censoring events after terminal
states are removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tbl &lt;- data.frame(group_id = "A", subject_id = "A1", t = 0, state = "stable")
mdl &lt;- create_srpmodel(A = define_srp_prior())
check_data(tbl, mdl)
</code></pre>

<hr>
<h2 id='compute_pfs'>Compute progression-free-survival rate given sample</h2><span id='topic+compute_pfs'></span>

<h3>Description</h3>

<p><code>compute_pfs()</code> computes the progression-free-survival rate at specified
times given a paramter sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_pfs(
  model,
  t,
  parameter_sample = NULL,
  warmup = 500L,
  nsim = 1000L,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_pfs_+3A_model">model</code></td>
<td>
<p>an object of class <a href="#topic+srpmodel">srpmodel</a> containing prior information</p>
</td></tr>
<tr><td><code id="compute_pfs_+3A_t">t</code></td>
<td>
<p>a vector of time-points at which the PFS rate should be computed</p>
</td></tr>
<tr><td><code id="compute_pfs_+3A_parameter_sample">parameter_sample</code></td>
<td>
<p>a stanfit object with samples from the respective model.</p>
</td></tr>
<tr><td><code id="compute_pfs_+3A_warmup">warmup</code></td>
<td>
<p>integer, number of warm-up samples for the MCMC sampler
before retaining samples; see <code>warmup</code> parameter in <code><a href="rstan.html#topic+stan">rstan::stan()</a></code>.</p>
</td></tr>
<tr><td><code id="compute_pfs_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of samples to draw</p>
</td></tr>
<tr><td><code id="compute_pfs_+3A_seed">seed</code></td>
<td>
<p>integer, fixed random seed; NULL for no fixed seed</p>
</td></tr>
<tr><td><code id="compute_pfs_+3A_...">...</code></td>
<td>
<p>further arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with samples of PFS rates at each of the time points
in the vector t.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdl &lt;- create_srpmodel(A = define_srp_prior())
smpl &lt;- sample_prior(mdl, nsim = 500, seed = 34L)
dplyr::filter(
  compute_pfs(mdl, t = seq(0, 12), parameter_sample = smpl),
  iter == 1
)

</code></pre>

<hr>
<h2 id='impute'>Sample visits from predictive distribution</h2><span id='topic+impute'></span><span id='topic+sample_predictive'></span>

<h3>Description</h3>

<p><code>impute()</code> samples visits for individuals in <code>data</code>
and potentially missing
individuals up to a maximum of <code>n_per_group</code> from the posterior
predictive distribution of the given model.
</p>
<p><code>sample_predictive()</code> draws samples from the predictive distribution of a
model given a parameter sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute(
  model,
  data,
  nsim,
  n_per_group = NULL,
  sample = NULL,
  p = NULL,
  shape = NULL,
  scale = NULL,
  now = NULL,
  seed = NULL,
  nsim_parameters = 1000L,
  warmup_parameters = 250L,
  nuts_control = list(),
  as_mstate = FALSE,
  ...
)

sample_predictive(
  model,
  nsim,
  n_per_group,
  sample = NULL,
  p = NULL,
  shape = NULL,
  scale = NULL,
  seed = NULL,
  nsim_parameters = 1000L,
  warmup_parameters = 250,
  nuts_control = list(),
  as_mstate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute_+3A_model">model</code></td>
<td>
<p>an object of class <a href="#topic+srpmodel">srpmodel</a> containing prior information</p>
</td></tr>
<tr><td><code id="impute_+3A_data">data</code></td>
<td>
<p>a data frame with variables
<code style="white-space: pre;">&#8288;subject_id&lt;chr&gt;&#8288;</code> (subject identifier),
<code style="white-space: pre;">&#8288;group_id&lt;chr&gt;&#8288;</code> (group identifier),
<code style="white-space: pre;">&#8288;t&lt;dbl&gt;&#8288;</code> (time of visit, relative to first visit in study),
<code style="white-space: pre;">&#8288;state&lt;chr&gt;&#8288;</code> (state recorded at visit).
Allowed states are &quot;stable&quot;, &quot;response&quot;, &quot;progression&quot; (or death),
and &quot;EOF&quot; (end of follow-up).
The EOF state marks the end of an individual's follow-up before the absorbing
state &quot;progression&quot;.</p>
</td></tr>
<tr><td><code id="impute_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of samples to draw</p>
</td></tr>
<tr><td><code id="impute_+3A_n_per_group">n_per_group</code></td>
<td>
<p>integer vector with number of individuals per group.</p>
</td></tr>
<tr><td><code id="impute_+3A_sample">sample</code></td>
<td>
<p>a stanfit object with samples from the respective model.</p>
</td></tr>
<tr><td><code id="impute_+3A_p">p</code></td>
<td>
<p>numeric, vector of optional fixed response probabilities to use for
sampling</p>
</td></tr>
<tr><td><code id="impute_+3A_shape">shape</code></td>
<td>
<p>numeric, matrix of optional fixed Weibull shape parameters to
use for sampling must be a matrix of dim c(n_groups, 3) where the second
dimension corresponds to the transitions between s-&gt;r, s-&gt;p, r-&gt;p</p>
</td></tr>
<tr><td><code id="impute_+3A_scale">scale</code></td>
<td>
<p>numeric, matrix of optional fixed Weibull scale parameters to
use for sampling must be a matrix of dim c(n_groups, 3) where the second
dimension corresponds to the transitions between s-&gt;r, s-&gt;p, r-&gt;p</p>
</td></tr>
<tr><td><code id="impute_+3A_now">now</code></td>
<td>
<p>numeric, time since first visit in data if not last recorded
visit time</p>
</td></tr>
<tr><td><code id="impute_+3A_seed">seed</code></td>
<td>
<p>integer, fixed random seed; NULL for no fixed seed</p>
</td></tr>
<tr><td><code id="impute_+3A_nsim_parameters">nsim_parameters</code></td>
<td>
<p>integer, number of parameter samples</p>
</td></tr>
<tr><td><code id="impute_+3A_warmup_parameters">warmup_parameters</code></td>
<td>
<p>integer, number of warmup samples for the rstan sampler before retaining samples of the parameters.</p>
</td></tr>
<tr><td><code id="impute_+3A_nuts_control">nuts_control</code></td>
<td>
<p>list, parameters for NUTS algorithm see <code>control</code>
argument in<code><a href="rstan.html#topic+stan">rstan::stan()</a></code></p>
</td></tr>
<tr><td><code id="impute_+3A_as_mstate">as_mstate</code></td>
<td>
<p>logical, return data in mstate format?</p>
</td></tr>
<tr><td><code id="impute_+3A_...">...</code></td>
<td>
<p>further arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with variables
<code style="white-space: pre;">&#8288;subject_id&lt;chr&gt;&#8288;</code> (subject identifier),
<code style="white-space: pre;">&#8288;group_id&lt;chr&gt;&#8288;</code> (group identifier),
<code style="white-space: pre;">&#8288;t&lt;dbl&gt;&#8288;</code> (time of visit, relative to first visit in study),
<code style="white-space: pre;">&#8288;state&lt;chr&gt;&#8288;</code> (state recorded at visit)
<code style="white-space: pre;">&#8288;iter&lt;int&gt;&#8288;</code> (re-sample indicator).
Allowed states are &quot;stable&quot;, &quot;response&quot;, &quot;progression&quot; (or death),
and &quot;EOF&quot; (end of follow-up).
The EOF state marks the end of an individual's follow-up before the absorbing
state &quot;progression&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_prior">sample_prior()</a></code> <code><a href="#topic+sample_posterior">sample_posterior()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdl &lt;- create_srpmodel(A = define_srp_prior())
tbl &lt;- tibble::tibble(
  subject_id = c("A1", "A1"),
  group_id = c("A", "A"),
  t = c(0, 1.5),
  state = c("stable", "stable")
)
impute(mdl, tbl, 1L, seed = 38L)

sample_predictive(mdl, 1L, 20L, seed = 38L)

</code></pre>

<hr>
<h2 id='parameter_sample_to_tibble'>Convert parameter sample to data table</h2><span id='topic+parameter_sample_to_tibble'></span>

<h3>Description</h3>

<p><code>parameter_sample_to_tibble()</code> takes a <a href="rstan.html#topic+stanfit-class">rstan::stanfit</a> parameter sample of
a model, extracts the paramters values and returns them in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameter_sample_to_tibble(model, sample, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameter_sample_to_tibble_+3A_model">model</code></td>
<td>
<p>an object of class <a href="#topic+srpmodel">srpmodel</a> containing prior information</p>
</td></tr>
<tr><td><code id="parameter_sample_to_tibble_+3A_sample">sample</code></td>
<td>
<p>a stanfit object with samples from the respective model.</p>
</td></tr>
<tr><td><code id="parameter_sample_to_tibble_+3A_...">...</code></td>
<td>
<p>further arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with the sampled parameters, in long format
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_prior">sample_prior()</a></code> <code><a href="#topic+sample_posterior">sample_posterior()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdl &lt;- create_srpmodel(A = define_srp_prior())
smpl &lt;- sample_prior(mdl, seed = 3647L)
parameter_sample_to_tibble(mdl, smpl)

</code></pre>

<hr>
<h2 id='plot_mstate'>Swimmer plot of multi-state data</h2><span id='topic+plot_mstate'></span>

<h3>Description</h3>

<p><code>plot_mstate()</code> plots data in 'multi-state-format' as swimmer plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mstate(
  data,
  model,
  now = max(tbl_mstate$t_max),
  relative_to_sot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mstate_+3A_data">data</code></td>
<td>
<p>a data frame with multi-state data; variables are
<code style="white-space: pre;">&#8288;subject_id&lt;chr&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;group_id&lt;chr&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;subject_id&lt;chr&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;from&lt;chr&gt;&#8288;</code>,
<code style="white-space: pre;">&#8288;to&lt;chr&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;t_min&lt;dbl&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;t_max&lt;dbl&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;t_sot&lt;dbl&gt;&#8288;</code>, where
<code>to</code> and <code>from</code> indicate the state from which and into which the transitions
occurs (stable, response, progression), <code>t_max</code> and <code>t_min</code> specify the
interval in which the transition occurred relative to <code>t_sot</code>
(start of treatment).</p>
</td></tr>
<tr><td><code id="plot_mstate_+3A_model">model</code></td>
<td>
<p>an object of class <a href="#topic+srpmodel">srpmodel</a> containing prior information</p>
</td></tr>
<tr><td><code id="plot_mstate_+3A_now">now</code></td>
<td>
<p>the current time relative to the start of the trial</p>
</td></tr>
<tr><td><code id="plot_mstate_+3A_relative_to_sot">relative_to_sot</code></td>
<td>
<p>logical, should the timeline be relative to the start
of trial or the start of treatment for each individual</p>
</td></tr>
<tr><td><code id="plot_mstate_+3A_...">...</code></td>
<td>
<p>further arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+visits_to_mstate">visits_to_mstate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdl &lt;- create_srpmodel(A = define_srp_prior())
tbl_visits &lt;- sample_predictive(mdl, n_per_group = 5L, nsim = 1, seed = 468L)
tbl_mstate &lt;- visits_to_mstate(tbl_visits, mdl)
plot_mstate(tbl_mstate, mdl)

</code></pre>

<hr>
<h2 id='plot_pfs'>Plot progression-free-survival function</h2><span id='topic+plot_pfs'></span>

<h3>Description</h3>

<p><code>plot_pfs()</code> plots the progression-free-survival function of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pfs(
  model,
  parameter_sample = NULL,
  seed = 42L,
  nsim = 500L,
  warmup = 250,
  nuts_control = list(),
  dt_interval = NULL,
  dt_n_grid = 25,
  dt_expand = 1.1,
  dt_grid = NULL,
  confidence = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_pfs_+3A_model">model</code></td>
<td>
<p>an object of class <a href="#topic+srpmodel">srpmodel</a> containing prior information</p>
</td></tr>
<tr><td><code id="plot_pfs_+3A_parameter_sample">parameter_sample</code></td>
<td>
<p>a stanfit object with samples from the respective model.</p>
</td></tr>
<tr><td><code id="plot_pfs_+3A_seed">seed</code></td>
<td>
<p>integer, fixed random seed; NULL for no fixed seed</p>
</td></tr>
<tr><td><code id="plot_pfs_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of samples to draw</p>
</td></tr>
<tr><td><code id="plot_pfs_+3A_warmup">warmup</code></td>
<td>
<p>integer, number of warm-up samples for the MCMC sampler
before retaining samples; see <code>warmup</code> parameter in <code><a href="rstan.html#topic+stan">rstan::stan()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_pfs_+3A_nuts_control">nuts_control</code></td>
<td>
<p>list, parameters for NUTS algorithm see <code>control</code>
argument in<code><a href="rstan.html#topic+stan">rstan::stan()</a></code></p>
</td></tr>
<tr><td><code id="plot_pfs_+3A_dt_interval">dt_interval</code></td>
<td>
<p>numeric vector of length two with minimal and maximal
time (relative to individual first visit) to use for plotting</p>
</td></tr>
<tr><td><code id="plot_pfs_+3A_dt_n_grid">dt_n_grid</code></td>
<td>
<p>number of grid points to use when automatically choosing
plotting interval</p>
</td></tr>
<tr><td><code id="plot_pfs_+3A_dt_expand">dt_expand</code></td>
<td>
<p>expansion factor for upper plotting limit when using
automatic interval detection</p>
</td></tr>
<tr><td><code id="plot_pfs_+3A_dt_grid">dt_grid</code></td>
<td>
<p>numeric vector of time points to use for plotting</p>
</td></tr>
<tr><td><code id="plot_pfs_+3A_confidence">confidence</code></td>
<td>
<p>numeric in (0, 1) confidence level for point-wise
confidence bands around mean; none plotted if NULL.</p>
</td></tr>
<tr><td><code id="plot_pfs_+3A_...">...</code></td>
<td>
<p>further arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_transition_times">plot_transition_times()</a></code> <code><a href="#topic+plot_response_probability">plot_response_probability()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mdl &lt;- create_srpmodel(A = define_srp_prior())
plot_pfs(mdl)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_response_probability'>Plot the response probability distributions</h2><span id='topic+plot_response_probability'></span>

<h3>Description</h3>

<p><code>plot_response_probability()</code> plots the distribution over the response
probability parameter in the specified model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_response_probability(
  model,
  parameter_sample = NULL,
  seed = 42L,
  nsim = 500L,
  warmup = 250,
  nuts_control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_response_probability_+3A_model">model</code></td>
<td>
<p>an object of class <a href="#topic+srpmodel">srpmodel</a> containing prior information</p>
</td></tr>
<tr><td><code id="plot_response_probability_+3A_parameter_sample">parameter_sample</code></td>
<td>
<p>a stanfit object with samples from the respective model.</p>
</td></tr>
<tr><td><code id="plot_response_probability_+3A_seed">seed</code></td>
<td>
<p>integer, fixed random seed; NULL for no fixed seed</p>
</td></tr>
<tr><td><code id="plot_response_probability_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of samples to draw</p>
</td></tr>
<tr><td><code id="plot_response_probability_+3A_warmup">warmup</code></td>
<td>
<p>integer, number of warm-up samples for the MCMC sampler
before retaining samples; see <code>warmup</code> parameter in <code><a href="rstan.html#topic+stan">rstan::stan()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_response_probability_+3A_nuts_control">nuts_control</code></td>
<td>
<p>list, parameters for NUTS algorithm see <code>control</code>
argument in<code><a href="rstan.html#topic+stan">rstan::stan()</a></code></p>
</td></tr>
<tr><td><code id="plot_response_probability_+3A_...">...</code></td>
<td>
<p>further arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_transition_times">plot_transition_times()</a></code> <code><a href="#topic+plot_pfs">plot_pfs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdl &lt;- create_srpmodel(A = define_srp_prior())
plot_response_probability(mdl)

</code></pre>

<hr>
<h2 id='plot_transition_times'>Plot the transition times of a model</h2><span id='topic+plot_transition_times'></span>

<h3>Description</h3>

<p><code>plot_transition_times()</code> plots a the survival functions for the transition
times in a multi-state model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_transition_times(
  model,
  parameter_sample = NULL,
  seed = 42L,
  nsim = 500L,
  warmup = 250,
  nuts_control = list(),
  dt_interval = NULL,
  dt_n_grid = 25,
  dt_expand = 1.1,
  dt_grid = NULL,
  confidence = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_transition_times_+3A_model">model</code></td>
<td>
<p>an object of class <a href="#topic+srpmodel">srpmodel</a> containing prior information</p>
</td></tr>
<tr><td><code id="plot_transition_times_+3A_parameter_sample">parameter_sample</code></td>
<td>
<p>a stanfit object with samples from the respective model.</p>
</td></tr>
<tr><td><code id="plot_transition_times_+3A_seed">seed</code></td>
<td>
<p>integer, fixed random seed; NULL for no fixed seed</p>
</td></tr>
<tr><td><code id="plot_transition_times_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of samples to draw</p>
</td></tr>
<tr><td><code id="plot_transition_times_+3A_warmup">warmup</code></td>
<td>
<p>integer, number of warm-up samples for the MCMC sampler
before retaining samples; see <code>warmup</code> parameter in <code><a href="rstan.html#topic+stan">rstan::stan()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_transition_times_+3A_nuts_control">nuts_control</code></td>
<td>
<p>list, parameters for NUTS algorithm see <code>control</code>
argument in<code><a href="rstan.html#topic+stan">rstan::stan()</a></code></p>
</td></tr>
<tr><td><code id="plot_transition_times_+3A_dt_interval">dt_interval</code></td>
<td>
<p>numeric vector of length two with minimal and maximal
time (relative to individual first visit) to use for plotting</p>
</td></tr>
<tr><td><code id="plot_transition_times_+3A_dt_n_grid">dt_n_grid</code></td>
<td>
<p>number of grid points to use when automatically choosing
plotting interval</p>
</td></tr>
<tr><td><code id="plot_transition_times_+3A_dt_expand">dt_expand</code></td>
<td>
<p>expansion factor for upper plotting limit when using
automatic interval detection</p>
</td></tr>
<tr><td><code id="plot_transition_times_+3A_dt_grid">dt_grid</code></td>
<td>
<p>numeric vector of time points to use for plotting</p>
</td></tr>
<tr><td><code id="plot_transition_times_+3A_confidence">confidence</code></td>
<td>
<p>numeric in (0, 1) confidence level for point-wise
confidence bands around mean; none plotted if NULL.</p>
</td></tr>
<tr><td><code id="plot_transition_times_+3A_...">...</code></td>
<td>
<p>further arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_pfs">plot_pfs()</a></code> <code><a href="#topic+plot_response_probability">plot_response_probability()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mdl &lt;- create_srpmodel(A = define_srp_prior())
plot_transition_times(mdl)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.srpmodel'>Summary plot of model prior</h2><span id='topic+plot.srpmodel'></span>

<h3>Description</h3>

<p>Summary plot of model prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'srpmodel'
plot(
  x,
  parameter_sample = NULL,
  seed = 42L,
  nsim = 500L,
  warmup = 250,
  nuts_control = list(),
  dt_interval = NULL,
  dt_n_grid = 25,
  dt_expand = 1.1,
  dt_grid = NULL,
  confidence = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.srpmodel_+3A_x">x</code></td>
<td>
<p>the model to plot</p>
</td></tr>
<tr><td><code id="plot.srpmodel_+3A_parameter_sample">parameter_sample</code></td>
<td>
<p>a stanfit object with samples from the respective model.</p>
</td></tr>
<tr><td><code id="plot.srpmodel_+3A_seed">seed</code></td>
<td>
<p>integer, fixed random seed; NULL for no fixed seed</p>
</td></tr>
<tr><td><code id="plot.srpmodel_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of samples to draw</p>
</td></tr>
<tr><td><code id="plot.srpmodel_+3A_warmup">warmup</code></td>
<td>
<p>integer, number of warm-up samples for the MCMC sampler
before retaining samples; see <code>warmup</code> parameter in <code><a href="rstan.html#topic+stan">rstan::stan()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.srpmodel_+3A_nuts_control">nuts_control</code></td>
<td>
<p>list, parameters for NUTS algorithm see <code>control</code>
argument in<code><a href="rstan.html#topic+stan">rstan::stan()</a></code></p>
</td></tr>
<tr><td><code id="plot.srpmodel_+3A_dt_interval">dt_interval</code></td>
<td>
<p>numeric vector of length two with minimal and maximal
time (relative to individual first visit) to use for plotting</p>
</td></tr>
<tr><td><code id="plot.srpmodel_+3A_dt_n_grid">dt_n_grid</code></td>
<td>
<p>number of grid points to use when automatically choosing
plotting interval</p>
</td></tr>
<tr><td><code id="plot.srpmodel_+3A_dt_expand">dt_expand</code></td>
<td>
<p>expansion factor for upper plotting limit when using
automatic interval detection</p>
</td></tr>
<tr><td><code id="plot.srpmodel_+3A_dt_grid">dt_grid</code></td>
<td>
<p>numeric vector of time points to use for plotting</p>
</td></tr>
<tr><td><code id="plot.srpmodel_+3A_confidence">confidence</code></td>
<td>
<p>numeric in (0, 1) confidence level for point-wise
confidence bands around mean; none plotted if NULL.</p>
</td></tr>
<tr><td><code id="plot.srpmodel_+3A_...">...</code></td>
<td>
<p>further arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>patchwork</code> object, see <a href="patchwork.html#topic+patchwork-package">patchwork::patchwork</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_pfs">plot_pfs()</a></code> <code><a href="#topic+plot_transition_times">plot_transition_times()</a></code>
<code><a href="#topic+plot_response_probability">plot_response_probability()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mdl &lt;- create_srpmodel(A = define_srp_prior())
plot(mdl)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.srpmodel'>Print an srpmodel</h2><span id='topic+print.srpmodel'></span><span id='topic+format.srpmodel'></span>

<h3>Description</h3>

<p>Print an srpmodel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'srpmodel'
print(x, ...)

## S3 method for class 'srpmodel'
format(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.srpmodel_+3A_x">x</code></td>
<td>
<p>model to print</p>
</td></tr>
<tr><td><code id="print.srpmodel_+3A_...">...</code></td>
<td>
<p>further arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>format()</code> returns a character string representation of the object,
<code>print()</code> prints to the console and returns the object itself invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(create_srpmodel(A = define_srp_prior()))
format(create_srpmodel(A = define_srp_prior()))
</code></pre>

<hr>
<h2 id='sample_posterior'>Sample parameters from a model</h2><span id='topic+sample_posterior'></span><span id='topic+sample_prior'></span>

<h3>Description</h3>

<p><code>sample_posterior()</code> draws samples from the
posterior distribution of the specified model given a data set with
visit data.
</p>
<p><code>sample_prior()</code> draws samples from the
prior distribution of the specified model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_posterior(
  model,
  data,
  now = NULL,
  nsim = 2000L,
  seed = NULL,
  warmup = 500L,
  nuts_control = list(),
  acceptable_divergent_transition_fraction = 0.1,
  ...
)

sample_prior(
  model,
  nsim = 2000L,
  seed = NULL,
  warmup = 500L,
  nuts_control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_posterior_+3A_model">model</code></td>
<td>
<p>an object of class <a href="#topic+srpmodel">srpmodel</a> containing prior information</p>
</td></tr>
<tr><td><code id="sample_posterior_+3A_data">data</code></td>
<td>
<p>a data frame with variables
<code style="white-space: pre;">&#8288;subject_id&lt;chr&gt;&#8288;</code> (subject identifier),
<code style="white-space: pre;">&#8288;group_id&lt;chr&gt;&#8288;</code> (group identifier),
<code style="white-space: pre;">&#8288;t&lt;dbl&gt;&#8288;</code> (time of visit, relative to first visit in study),
<code style="white-space: pre;">&#8288;state&lt;chr&gt;&#8288;</code> (state recorded at visit).
Allowed states are &quot;stable&quot;, &quot;response&quot;, &quot;progression&quot; (or death),
and &quot;EOF&quot; (end of follow-up).
The EOF state marks the end of an individual's follow-up before the absorbing
state &quot;progression&quot;.</p>
</td></tr>
<tr><td><code id="sample_posterior_+3A_now">now</code></td>
<td>
<p>numeric, time from first visit in data if different form last
recorded visit</p>
</td></tr>
<tr><td><code id="sample_posterior_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of samples to draw</p>
</td></tr>
<tr><td><code id="sample_posterior_+3A_seed">seed</code></td>
<td>
<p>integer, fixed random seed; NULL for no fixed seed</p>
</td></tr>
<tr><td><code id="sample_posterior_+3A_warmup">warmup</code></td>
<td>
<p>integer, number of warm-up samples for the MCMC sampler
before retaining samples; see <code>warmup</code> parameter in <code><a href="rstan.html#topic+stan">rstan::stan()</a></code>.</p>
</td></tr>
<tr><td><code id="sample_posterior_+3A_nuts_control">nuts_control</code></td>
<td>
<p>list, parameters for NUTS algorithm see <code>control</code>
argument in<code><a href="rstan.html#topic+stan">rstan::stan()</a></code></p>
</td></tr>
<tr><td><code id="sample_posterior_+3A_acceptable_divergent_transition_fraction">acceptable_divergent_transition_fraction</code></td>
<td>
<p>numeric between 0 and 1
giving the acceptable fraction of divergent transitions before throwing an
error</p>
</td></tr>
<tr><td><code id="sample_posterior_+3A_...">...</code></td>
<td>
<p>further arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="rstan.html#topic+stanfit-class">rstan::stanfit</a> object with posterior samples.
</p>


<h3>See Also</h3>

<p><code><a href="rstan.html#topic+stan">rstan::stan()</a></code> <code><a href="#topic+parameter_sample_to_tibble">parameter_sample_to_tibble()</a></code>
<code><a href="#topic+sample_predictive">sample_predictive()</a></code> <code><a href="#topic+impute">impute()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdl &lt;- create_srpmodel(A = define_srp_prior())
tbl &lt;- tibble::tibble(
  subject_id = c("A1", "A1"),
  group_id = c("A", "A"),
  t = c(0, 1.5),
  state = c("stable", "response")
)
sample_posterior(mdl, tbl, seed = 42L)

sample_prior(mdl, seed = 42L)

</code></pre>

<hr>
<h2 id='simulate_decision_rule'>Simulate results under a custom decision rule</h2><span id='topic+simulate_decision_rule'></span>

<h3>Description</h3>

<p><code>simulate_decision_rule()</code> simulates from the prior or posterior
predictive distribution of a model and applies a custom decision rule to each
simulated data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_decision_rule(
  model,
  n_per_group,
  decision_rule,
  data = NULL,
  parameter_sample = NULL,
  seed = NULL,
  nsim = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_decision_rule_+3A_model">model</code></td>
<td>
<p>model to use for sampling</p>
</td></tr>
<tr><td><code id="simulate_decision_rule_+3A_n_per_group">n_per_group</code></td>
<td>
<p>group size</p>
</td></tr>
<tr><td><code id="simulate_decision_rule_+3A_decision_rule">decision_rule</code></td>
<td>
<p>a function with signature <code>rule(mdl, data, ...)</code>
returning a
data frame with results from a applying the decision rule to data set<code>data</code>,
typically contains a column <code>group_id</code> and a one column per decision/result.</p>
</td></tr>
<tr><td><code id="simulate_decision_rule_+3A_data">data</code></td>
<td>
<p>a data frame with visit data to condition on</p>
</td></tr>
<tr><td><code id="simulate_decision_rule_+3A_parameter_sample">parameter_sample</code></td>
<td>
<p>an optional parameter sample to reuse</p>
</td></tr>
<tr><td><code id="simulate_decision_rule_+3A_seed">seed</code></td>
<td>
<p>optional fixed seed</p>
</td></tr>
<tr><td><code id="simulate_decision_rule_+3A_nsim">nsim</code></td>
<td>
<p>the number of resamples to draw from the predictive distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sampling is implementing using <code>furrr::future_map()</code> and thus
supports parallel execution when specifying a <code>future::plan()</code>.
</p>


<h3>Value</h3>

<p>A data frame with columns <code>iter</code> (the resample index) and any columns
returned by <code>decision_rule</code> applied to each of the <code>nsim</code> datasets sampled
from the predictive distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdl &lt;- create_srpmodel(A = define_srp_prior())
rule &lt;- function(model, data) {
  tibble::tibble(decision = sample(c(0,1), 1))
}
simulate_decision_rule(mdl, 5, rule, nsim = 3)

</code></pre>

<hr>
<h2 id='srpmodel'>A stable-response-progression model</h2><span id='topic+srpmodel'></span><span id='topic+srp-model'></span><span id='topic+define_srp_prior'></span><span id='topic+create_srpmodel'></span>

<h3>Description</h3>

<p><code>create_model()</code> takes one or more prior-specifications for an
SRP multi-state model and combines them into a single model object.
Groups are still treated as independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_srp_prior(
  p_mean = 0.5,
  p_n = 3,
  p_eta = 0,
  p_min = 0,
  p_max = 1,
  median_t_q05 = c(1, 1, 1),
  median_t_q95 = c(60, 60, 60),
  shape_q05 = rep(0.9, 3),
  shape_q95 = rep(2.5, 3),
  visit_spacing = 1,
  recruitment_rate = 1
)

create_srpmodel(
  ...,
  maximal_time = 10 * 12,
  states = c("stable", "response", "progression"),
  censored = "EOF"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srpmodel_+3A_p_mean">p_mean</code></td>
<td>
<p>numeric, mean of the beta prior for the response probability</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_p_n">p_n</code></td>
<td>
<p>numeric, beta prior equivalent sample size (a + b)</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_p_eta">p_eta</code></td>
<td>
<p>numeric, robustification parameter for beta prior; actual
prior is (1 - eta) beta + eta; i.e., eta is the non-informative weight.</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_p_min">p_min</code></td>
<td>
<p>numeric, minimal response probability</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_p_max">p_max</code></td>
<td>
<p>numeric, maximal response probability</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_median_t_q05">median_t_q05</code></td>
<td>
<p>numeric of length three,
5% quantiles of the log-normal distributions for the
median time-to-next-event for the three transitions s-&gt;r, s-&gt;p, r-&gt;p.</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_median_t_q95">median_t_q95</code></td>
<td>
<p>numeric of length three,
95% quantiles of the log-normal distributions for the
median time-to-next-event for the three transitions s-&gt;r, s-&gt;p, r-&gt;p.</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_shape_q05">shape_q05</code></td>
<td>
<p>numeric of length three,
5% quantiles of the log-normal distributions for the shapes of the
time-to-next-event distributions for the three transitions s-&gt;r, s-&gt;p, r-&gt;p.</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_shape_q95">shape_q95</code></td>
<td>
<p>numeric of length three,
95% quantiles of the log-normal distributions for the shapes of the
time-to-next-event distributions for the three transitions s-&gt;r, s-&gt;p, r-&gt;p.</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_visit_spacing">visit_spacing</code></td>
<td>
<p>numeric, fixed duration between visits</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_recruitment_rate">recruitment_rate</code></td>
<td>
<p>numeric, constant recruitment rate</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_...">...</code></td>
<td>
<p>named <code>srp_prior</code> objects; the argument names serve as
group labels</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_maximal_time">maximal_time</code></td>
<td>
<p>the maximal overall runtime of the trial as measured from
the first visit of any group. No visits past this point are sampled.</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_states">states</code></td>
<td>
<p>character vector of three states (initial, intermediate,
terminal)</p>
</td></tr>
<tr><td><code id="srpmodel_+3A_censored">censored</code></td>
<td>
<p>string, indicator of premature censoring events;
no data is imputed after this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>define_srp_prior()</code> specifies a prior distribution for a
three state model (stable, response, progression) for
a single group.
</p>


<h3>Value</h3>

<p><code>define_srp_prior()</code> returns an object of class <code>srp_prior</code>,
all inputs are accessible via
<code style="white-space: pre;">&#8288;$x&#8288;</code> where <code>x</code> is the name of the input argument in the function call except
for the two parameters <code>visit_spacing</code> and <code>recruitment_rate</code>.
These two parameters are saved as attributes
and can be retrieved directly using <code>attr(mdl, "visit_spacing")</code> and
<code>attr(mdl, "recruitment_rate")</code>.
</p>
<p><code>create_srpmodel()</code> returns an object of class <code>c("srpmodel", "list")</code> that
holds information about potentially multiple groups in a compact format and
can be accessed using the list operator <code style="white-space: pre;">&#8288;$name&#8288;</code>.
<code>group_id</code> is a character vector with the group names,
<code>maximal_time</code> is the maximal follow-up time since the first visit in the
study, <code>visit_spacing</code> is the vector of per-group difference between visits
(only relevant for forward sampling), <code>recruitment_rate</code> is the vector of
per-group recruitment rates, <code>stan_model</code> is the pre-compiled 'stan' model
used for inference, <code>states</code> is the vector of state names in the multi-state
model, and <code>prior</code> is a list of hyperparamters for the model prior with
elements <code>p</code>, vector, for the response probability per group,
<code>median_t</code> is an <code>c(n_groups, 3, 2)</code> dimensional array where
<code>median_t[i,j,1]</code>
holds the 5% quantile of the the lognormal prior on median transition time
for group <code>i</code> and transition <code>j</code> and <code>median_t[i,j,2]</code> the corresponding
upper 95% quantile. The <code>shape</code> hyperparamter has the same format and
specified the corresponding quantiles for the Weibull shape parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a model with prior 25% response rate and variance equivalent to
# 10 data points (i.e. a Beta(2.5, 7.5) distribution).
grp &lt;- define_srp_prior(p_mean = 0.25, p_n = 10)
attr(grp, "recruitment_rate")

# a model with two groups and different priors on the respective response
# probabilities
mdl &lt;- create_srpmodel(
  A = define_srp_prior(),
  B = define_srp_prior(p_mean = 0.33, p_n = 10)
)
mdl$median_t

</code></pre>

<hr>
<h2 id='visits_to_mstate'>Convert cross-sectional visit data to multi-state format</h2><span id='topic+visits_to_mstate'></span>

<h3>Description</h3>

<p><code>visits_to_mstate()</code> converts visits to interval-censored multi-state
data where each row corresponds to a transition between states.
The conversion assumes that visit spacing is tight enough to not miss any
transitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visits_to_mstate(tbl_visits, model, now = max(tbl_visits$t))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="visits_to_mstate_+3A_tbl_visits">tbl_visits</code></td>
<td>
<p>data frame, visit data in long format</p>
</td></tr>
<tr><td><code id="visits_to_mstate_+3A_model">model</code></td>
<td>
<p>an object of class <a href="#topic+srpmodel">srpmodel</a> containing prior information</p>
</td></tr>
<tr><td><code id="visits_to_mstate_+3A_now">now</code></td>
<td>
<p>time point since start of trial (might be later than last
recorded visit)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with multi-state data; variables are
<code style="white-space: pre;">&#8288;subject_id&lt;chr&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;group_id&lt;chr&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;subject_id&lt;chr&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;from&lt;chr&gt;&#8288;</code>,
<code style="white-space: pre;">&#8288;to&lt;chr&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;t_min&lt;dbl&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;t_max&lt;dbl&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;t_sot&lt;dbl&gt;&#8288;</code>, where
<code>to</code> and <code>from</code> indicate the state from which and into which the transitions
occurs, <code>t_max</code> and <code>t_min</code> specify the
interval in which the transition occurred relative to <code>t_sot</code>
(start of treatment).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdl &lt;- create_srpmodel(A = define_srp_prior())
tbl_visits &lt;- sample_predictive(mdl, n_per_group = 5L, nsim = 1, seed = 468L)
visits_to_mstate(tbl_visits, mdl)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
