<!DOCTYPE html><html lang="en"><head><title>Help for package unbalhaar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {unbalhaar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#unbalhaar-package'>
<p>Function estimation via Unbalanced Haar wavelets</p></a></li>
<li><a href='#best.unbal.haar'><p>Best top-down Unbalanced Haar decomposition</p></a></li>
<li><a href='#best.unbal.haar.bu'><p>Best bottom-up Unbalanced Haar decomposition</p></a></li>
<li><a href='#hard.thresh'><p>Hard thresholding of a top-down Unbalanced Haar decomposition</p></a></li>
<li><a href='#hard.thresh.bu'><p>Hard thresholding of a bottom-up Unbalanced Haar decomposition</p></a></li>
<li><a href='#inner.prod.iter'><p>Inner products with Unbalanced Haar wavelets</p></a></li>
<li><a href='#inner.prod.max'><p>Unbalanced Haar wavelet which maximises the inner product</p></a></li>
<li><a href='#inner.prod.max.p'><p>Unbalanced Haar wavelet which maximises the inner product</p></a></li>
<li><a href='#med'><p>Median</p></a></li>
<li><a href='#reconstr'><p>Reconstruct a top-down Unbalanced Haar decomposition</p></a></li>
<li><a href='#reconstr.bu'><p>Reconstruct a bottom-up Unbalanced Haar decomposition</p></a></li>
<li><a href='#uh'><p> Denoising via top-down Unbalanced Haar</p></a></li>
<li><a href='#uh.bu'><p> Denoising via bottom-up Unbalanced Haar</p></a></li>
<li><a href='#unbal.haar.vector'><p>Unbalanced Haar vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Function Estimation via Unbalanced Haar Wavelets</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Piotr Fryzlewicz</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Piotr Fryzlewicz &lt;p.fryzlewicz@lse.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Top-down and bottom-up algorithms
        for nonparametric function estimation in Gaussian noise using
        Unbalanced Haar wavelets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-19 06:23:36 UTC; piotr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-19 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='unbalhaar-package'>
Function estimation via Unbalanced Haar wavelets
</h2><span id='topic+unbalhaar-package'></span><span id='topic+unbalhaar'></span>

<h3>Description</h3>

<p>The package implements top-down and bottom-up algorithms for nonparametric
function estimation in Gaussian noise using Unbalanced Haar wavelets.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> unbalhaar</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2010-08-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main functions of the package are <code><a href="#topic+uh">uh</a></code> and <code><a href="#topic+uh.bu">uh.bu</a></code>.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz
</p>
<p>Maintainer: Piotr Fryzlewicz &lt;p.fryzlewicz@lse.ac.uk&gt;
</p>


<h3>References</h3>

<p>P. Fryzlewicz (2007) &ldquo;Unbalanced Haar technique for nonparametric 
function estimation&rdquo;. <em>Journal of the American Statistical Association</em>, 102, 1318-1327. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rep(0, 100), rep(1, 200)) + rnorm(300)
est.topdown &lt;- uh(x)
est.bottomup &lt;- uh.bu(x)
</code></pre>

<hr>
<h2 id='best.unbal.haar'>Best top-down Unbalanced Haar decomposition</h2><span id='topic+best.unbal.haar'></span>

<h3>Description</h3>

<p>The function finds the &ldquo;best&rdquo; top-down Unbalanced Haar (UH) decomposition of the input vector
<code>x</code>, according to a selection rule (<code>criterion</code>) which specifies which 
UH vector gets chosen at each scale and location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.unbal.haar(x, criterion = inner.prod.max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best.unbal.haar_+3A_x">x</code></td>
<td>
<p>            a vector</p>
</td></tr>
<tr><td><code id="best.unbal.haar_+3A_criterion">criterion</code></td>
<td>
<p>    a function which takes a vector of length <em>n</em> and returns an integer between 1 and <em>n</em>-1</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>tree</code></td>
<td>
<p>      A list of J matrices, where J represents the number of &ldquo;scales&rdquo;. Each matrix is of size 5 x (the number of UH
coefficients at a given scale). Each column (= vector of length 5) contains an Unbalanced Haar coefficient
in the following format: 1st component - an index of the coefficient; 2nd component - the value of the coefficient;
3rd component - time point where the corresponding UH vector starts; 4th component - last time point before the 
breakpoint of the UH vector; 5th component - end point of the UH vector.  </p>
</td></tr>
<tr><td><code>smooth</code></td>
<td>
<p>    the &ldquo;smooth&rdquo; component of <code>x</code>, equal to <code>sum(x) / sqrt(n)</code>, where <code>n</code> is the length of <code>x</code>  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>See Also</h3>

<p><code><a href="#topic+inner.prod.max">inner.prod.max</a></code>, <code><a href="#topic+inner.prod.max.p">inner.prod.max.p</a></code>, <code><a href="#topic+best.unbal.haar.bu">best.unbal.haar.bu</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>best.unbal.haar(rnorm(100), inner.prod.max.p)
</code></pre>

<hr>
<h2 id='best.unbal.haar.bu'>Best bottom-up Unbalanced Haar decomposition</h2><span id='topic+best.unbal.haar.bu'></span>

<h3>Description</h3>

<p>The function finds the &ldquo;best&rdquo; bottom-up Unbalanced Haar (UH) decomposition of the input vector
<code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.unbal.haar.bu(x, stretch = length(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best.unbal.haar.bu_+3A_x">x</code></td>
<td>
<p>            a vector</p>
</td></tr>
<tr><td><code id="best.unbal.haar.bu_+3A_stretch">stretch</code></td>
<td>
<p>    at each iteration, only the first <code>1:stretch</code> elements of the current input vector (whose length
decreases by one with each iteration) get scanned in the search for the worst-fitting fine-scale Unbalanced Haar wavelet</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>detail</code></td>
<td>
<p>      A matrix of size 3 x <code>n-1</code>, where <code>n</code> is the length of <code>x</code>, containing the detail 
coefficients of <code>x</code> in the order they were chosen. Each column corresponds to a single coefficient and contains, from top 
to bottom: location of the coefficient, the associated weight, and the value of the coefficient. </p>
</td></tr>
<tr><td><code>smooth</code></td>
<td>
<p>    the &ldquo;smooth&rdquo; component of <code>x</code>, equal to <code>sum(x) / sqrt(n)</code>, where <code>n</code> is the length of <code>x</code>  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>See Also</h3>

<p><code><a href="#topic+best.unbal.haar">best.unbal.haar</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>best.unbal.haar.bu(rnorm(100))
</code></pre>

<hr>
<h2 id='hard.thresh'>Hard thresholding of a top-down Unbalanced Haar decomposition</h2><span id='topic+hard.thresh'></span>

<h3>Description</h3>

<p>Presented with an object returned by <code>best.unbal.haar</code>, the function
sets to zero those Unbalanced Haar coefficients which fall below a certain threshold
<code>sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hard.thresh(buh, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hard.thresh_+3A_buh">buh</code></td>
<td>
<p>      an object returned by <code>best.unbal.haar</code> containing the decomposition to be thresholded</p>
</td></tr>
<tr><td><code id="hard.thresh_+3A_sigma">sigma</code></td>
<td>
<p>    the threshold (a positive scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a thresholded object, of the same class as <code>buh</code>
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>See Also</h3>

<p><code><a href="#topic+best.unbal.haar">best.unbal.haar</a></code>, <code><a href="#topic+hard.thresh.bu">hard.thresh.bu</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
x.uh &lt;- best.unbal.haar(x)
x.uh.th &lt;- hard.thresh(x.uh)
x.uh.th.r &lt;- reconstr(x.uh.th)
ts.plot(x.uh.th.r)
</code></pre>

<hr>
<h2 id='hard.thresh.bu'>Hard thresholding of a bottom-up Unbalanced Haar decomposition</h2><span id='topic+hard.thresh.bu'></span>

<h3>Description</h3>

<p>Presented with an object returned by <code>best.unbal.haar.bu</code>, the function
sets to zero those Unbalanced Haar coefficients which fall below a certain threshold
<code>sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hard.thresh.bu(buh.bu, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hard.thresh.bu_+3A_buh.bu">buh.bu</code></td>
<td>
<p>      an object returned by <code>best.unbal.haar.bu</code> containing the decomposition to be thresholded</p>
</td></tr>
<tr><td><code id="hard.thresh.bu_+3A_sigma">sigma</code></td>
<td>
<p>    the threshold (a positive scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a thresholded object, of the same class as <code>buh.bu</code>
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>See Also</h3>

<p><code><a href="#topic+best.unbal.haar.bu">best.unbal.haar.bu</a></code>, <code><a href="#topic+hard.thresh">hard.thresh</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
x.uh &lt;- best.unbal.haar.bu(x)
x.uh.th &lt;- hard.thresh.bu(x.uh)
x.uh.th.r &lt;- reconstr.bu(x.uh.th)
ts.plot(x.uh.th.r)
</code></pre>

<hr>
<h2 id='inner.prod.iter'>Inner products with Unbalanced Haar wavelets</h2><span id='topic+inner.prod.iter'></span>

<h3>Description</h3>

<p>For an input vector of length <em>n</em>, the function computes inner products between the input
vector and all possible <em>n</em>-1 Unbalanced Haar vectors of length <em>n</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner.prod.iter(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner.prod.iter_+3A_x">x</code></td>
<td>
<p>    a vector of length <em>n</em></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation is iterative and is performed in computational time <em>O(n)</em>.
</p>


<h3>Value</h3>

<p>a vector of length <em>n</em>-1, containing inner products between <code>x</code> and consecutive Unbalanced Haar wavelets
of length <em>n</em>
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>Examples</h3>

<pre><code class='language-R'>inner.prod.iter(rnorm(100))
</code></pre>

<hr>
<h2 id='inner.prod.max'>Unbalanced Haar wavelet which maximises the inner product</h2><span id='topic+inner.prod.max'></span>

<h3>Description</h3>

<p>The function finds the Unbalanced Haar vector which yields the largest (in absolute value)
inner product with the input vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner.prod.max(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner.prod.max_+3A_x">x</code></td>
<td>
<p>    a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index where <code>abs(inner.prod.iter(x))</code> is maximised. If two or more maxima are found, the <code>med</code>
of their locations is returned.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>See Also</h3>

<p><code><a href="#topic+inner.prod.iter">inner.prod.iter</a></code>, <code><a href="#topic+med">med</a></code>, <code><a href="#topic+inner.prod.max.p">inner.prod.max.p</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>inner.prod.max(c(rep(0, 100), rep(1, 200)))
</code></pre>

<hr>
<h2 id='inner.prod.max.p'>Unbalanced Haar wavelet which maximises the inner product</h2><span id='topic+inner.prod.max.p'></span>

<h3>Description</h3>

<p>The function finds the Unbalanced Haar vector which yields the largest (in absolute value)
inner product with the input vector, amongst those Unbalanced Haar vectors whose breakpoint
is located between 100(1-<em>p</em>)% and 100<em>p</em>% of their support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner.prod.max.p(x, p = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner.prod.max.p_+3A_x">x</code></td>
<td>
<p>    a vector</p>
</td></tr>
<tr><td><code id="inner.prod.max.p_+3A_p">p</code></td>
<td>
<p>    a scalar in (0.5, 1]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index where <code>abs(inner.prod.iter(x))</code> is maximised on the subinterval
<code>(1+floor((1-p)*n)):ceiling(p*n)</code>, where <code>n</code> is the length of <code>x</code>.
If two or more maxima are found, the <code>med</code> of their locations is returned.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>See Also</h3>

<p><code><a href="#topic+inner.prod.iter">inner.prod.iter</a></code>, <code><a href="#topic+med">med</a></code>, <code><a href="#topic+inner.prod.max">inner.prod.max</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>inner.prod.max.p(c(rep(0, 100), rep(1, 200)), .55)
</code></pre>

<hr>
<h2 id='med'>Median</h2><span id='topic+med'></span>

<h3>Description</h3>

<p>The function computes the median of a vector. Unlike <code>median</code>, it is guaranteed to
return a value which is a component of the input vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>med(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="med_+3A_x">x</code></td>
<td>
<p>    a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar defined as <code>quantile(x, .5, type=3)[[1]]</code>
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>Examples</h3>

<pre><code class='language-R'>med(1:4)
median(1:4)
</code></pre>

<hr>
<h2 id='reconstr'>Reconstruct a top-down Unbalanced Haar decomposition</h2><span id='topic+reconstr'></span>

<h3>Description</h3>

<p>Reconstructs a vector from its top-down Unbalanced Haar decomposition stored in an object returned
by <code>best.unbal.haar</code> or <code>hard.thresh</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstr(buh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconstr_+3A_buh">buh</code></td>
<td>
<p>    an object of the type returned by <code>best.unbal.haar</code> and <code>hard.thresh</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the inverse Unbalanced Haar transform of <code>buh</code>
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>See Also</h3>

<p><code><a href="#topic+best.unbal.haar">best.unbal.haar</a></code>, <code><a href="#topic+hard.thresh">hard.thresh</a></code>, <code><a href="#topic+reconstr.bu">reconstr.bu</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
x.uh &lt;- best.unbal.haar(x)
x.uh.th &lt;- hard.thresh(x.uh)
x.uh.th.r &lt;- reconstr(x.uh.th)
ts.plot(x.uh.th.r)
</code></pre>

<hr>
<h2 id='reconstr.bu'>Reconstruct a bottom-up Unbalanced Haar decomposition</h2><span id='topic+reconstr.bu'></span>

<h3>Description</h3>

<p>Reconstructs a vector from its bottom-up Unbalanced Haar decomposition stored in an object returned
by <code>best.unbal.haar.bu</code> or <code>hard.thresh.bu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstr.bu(buh.bu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconstr.bu_+3A_buh.bu">buh.bu</code></td>
<td>
<p>    an object of the type returned by <code>best.unbal.haar.bu</code> and <code>hard.thresh.bu</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the inverse Unbalanced Haar transform of <code>buh.bu</code>
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>See Also</h3>

<p><code><a href="#topic+best.unbal.haar.bu">best.unbal.haar.bu</a></code>, <code><a href="#topic+hard.thresh.bu">hard.thresh.bu</a></code>, <code><a href="#topic+reconstr">reconstr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
x.uh &lt;- best.unbal.haar.bu(x)
x.uh.th &lt;- hard.thresh.bu(x.uh)
x.uh.th.r &lt;- reconstr.bu(x.uh.th)
ts.plot(x.uh.th.r)
</code></pre>

<hr>
<h2 id='uh'> Denoising via top-down Unbalanced Haar </h2><span id='topic+uh'></span>

<h3>Description</h3>

<p>Given an input vector of the form &ldquo;signal + iid Gaussian noise&rdquo;, the function
estimates the noise level via Median Absolute Deviation, finds the best top-down
Unbalanced Haar decomposition (according to the selection rule <code>criterion</code>), 
thresholds it with the universal threshold, and performs the inverse Unbalanced 
Haar transform to yield an estimate of the signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uh(x, criterion = inner.prod.max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uh_+3A_x">x</code></td>
<td>
<p>            a vector of the form &ldquo;signal + iid Gaussian noise&rdquo; </p>
</td></tr>
<tr><td><code id="uh_+3A_criterion">criterion</code></td>
<td>
<p>    a function which takes a vector of length <em>n</em> and returns an integer between 1 and <em>n</em>-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an estimate of the signal
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>References</h3>

<p>P. Fryzlewicz (2007) &ldquo;Unbalanced Haar technique for nonparametric 
function estimation&rdquo;. <em>Journal of the American Statistical Association</em>, 102, 1318-1327. </p>


<h3>See Also</h3>

<p><code><a href="#topic+uh.bu">uh.bu</a></code>, <code><a href="#topic+best.unbal.haar">best.unbal.haar</a></code>, <code><a href="#topic+inner.prod.max">inner.prod.max</a></code>, <code><a href="#topic+inner.prod.max.p">inner.prod.max.p</a></code>, 
<code><a href="#topic+hard.thresh">hard.thresh</a></code>, <code><a href="#topic+reconstr">reconstr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rep(0, 100), rep(1, 200)) + rnorm(300)
est &lt;- uh(x)
</code></pre>

<hr>
<h2 id='uh.bu'> Denoising via bottom-up Unbalanced Haar </h2><span id='topic+uh.bu'></span>

<h3>Description</h3>

<p>Given an input vector of the form &ldquo;signal + iid Gaussian noise&rdquo;, the function
estimates the noise level via Median Absolute Deviation, finds the best bottom-up
Unbalanced Haar decomposition, thresholds it with the universal threshold, and 
performs the inverse Unbalanced Haar transform to yield an estimate of the signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uh.bu(x, stretch = length(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uh.bu_+3A_x">x</code></td>
<td>
<p>            a vector of the form &ldquo;signal + iid Gaussian noise&rdquo; </p>
</td></tr>
<tr><td><code id="uh.bu_+3A_stretch">stretch</code></td>
<td>
<p>    at each iteration, only the first <code>1:stretch</code> elements of the current input vector (whose length
decreases by one with each iteration) get scanned in the search for the worst-fitting fine-scale Unbalanced Haar wavelet</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an estimate of the signal
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>References</h3>

<p>P. Fryzlewicz (2007) &ldquo;Unbalanced Haar technique for nonparametric 
function estimation&rdquo;. <em>Journal of the American Statistical Association</em>, 102, 1318-1327. </p>


<h3>See Also</h3>

<p><code><a href="#topic+uh">uh</a></code>, <code><a href="#topic+best.unbal.haar.bu">best.unbal.haar.bu</a></code>, <code><a href="#topic+hard.thresh.bu">hard.thresh.bu</a></code>, <code><a href="#topic+reconstr.bu">reconstr.bu</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rep(0, 100), rep(1, 200)) + rnorm(300)
est &lt;- uh.bu(x)
</code></pre>

<hr>
<h2 id='unbal.haar.vector'>Unbalanced Haar vector</h2><span id='topic+unbal.haar.vector'></span>

<h3>Description</h3>

<p>Computes the non-zero part of an Unbalanced Haar vector with a given start-, break-
and end-point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbal.haar.vector(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unbal.haar.vector_+3A_a">a</code></td>
<td>
<p>    a three-component vector of integers such that <code>a[1]</code> &lt;= <code>a[2]</code> &lt; <code>a[3]</code>.
The three components specify, respectively, the start point, the time point just before the breakpoint,
and the endpoint of the desired Unbalanced Haar vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the non-zero part of the corresponding Unbalanced Haar vector
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz</p>


<h3>Examples</h3>

<pre><code class='language-R'>unbal.haar.vector(c(1, 1, 2))
unbal.haar.vector(c(2, 5, 12))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
