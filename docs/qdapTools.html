<!DOCTYPE html><html><head><title>Help for package qdapTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qdapTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25l+2A+25'><p>Hash/Dictionary Lookup</p></a></li>
<li><a href='#hash'><p>Hash/Dictionary Lookup</p></a></li>
<li><a href='#hms2sec'><p>Convert h:m:s To/From Seconds</p></a></li>
<li><a href='#id'><p>ID By Row Number or Sequence Along</p></a></li>
<li><a href='#list2df'><p>List/Matrix/Vector to Dataframe/List/Matrix</p></a></li>
<li><a href='#loc_split'><p>Split Data Forms at Specified Locations</p></a></li>
<li><a href='#lookup'><p>Hash Table/Dictionary Lookup</p>
</p>
<p><code>lookup</code> - <a href="http://datatable.r-forge.r-project.org/"><span class="pkg">data.table</span></a></p>
based hash table useful for large vector lookups.</a></li>
<li><a href='#lookup_e'><p>Hash Table/Dictionary Lookup</p>
</p>
<p><code>lookup_e</code> - Environment based hash table useful for large vector lookups.</p></a></li>
<li><a href='#mtabulate'><p>Tabulate Frequency Counts for Multiple Vectors</p></a></li>
<li><a href='#pad'><p>Pad Strings</p></a></li>
<li><a href='#print.v_outer'><p>Prints a v_outer Object.</p></a></li>
<li><a href='#read_docx'><p>Read in .docx Content</p></a></li>
<li><a href='#repo2github'><p>Upload a Local Repo to GitHub</p></a></li>
<li><a href='#run_split'><p>Split a String Into Run Chunks</p></a></li>
<li><a href='#shift'><p>Shift Vector Left/Right</p></a></li>
<li><a href='#split_vector'><p>Split a Vector By Split Points</p></a></li>
<li><a href='#start_end'><p>Get Location of Start/End Points</p></a></li>
<li><a href='#text2color'><p>Map Words to Colors</p></a></li>
<li><a href='#url_dl'><p>Download Instructional Documents</p></a></li>
<li><a href='#v_outer'><p>Vectorized Version of outer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for the 'qdap' Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler Rinker &lt;tyler.rinker@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>chron, data.table (&ge; 1.9.6), methods, RCurl, XML</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of tools associated with the 'qdap' package that may be useful outside of the
            context of text analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/trinker/qdapTools">https://github.com/trinker/qdapTools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/trinker/qdapTools/issues">https://github.com/trinker/qdapTools/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-10 03:20:47 UTC; tylerrinker</td>
</tr>
<tr>
<td>Author:</td>
<td>Bryan Goodrich [ctb],
  Dason Kurkiewicz [ctb],
  Kirill Muller [ctb],
  Tyler Rinker [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-10 07:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25l+2A+25'>Hash/Dictionary Lookup</h2><span id='topic++25l+2A+25'></span><span id='topic++25ha+25'></span>

<h3>Description</h3>

<p><code>%l*%</code> - A deprecated binary operator version of <code>lookup</code>.  This
will be removed in a subsequent version of <span class="pkg">qdapTools</span>.  Use <code>%l%</code>
instead.
</p>
<p><code>%ha%</code> - A deprecated binary operator version of <code>hash_look</code>.
This will be removed in a subsequent version of <span class="pkg">qdapTools</span>.  Use
<code>%hl%</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terms %l*% key.match

terms %ha% key
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25l+2B2A+2B25_+3A_terms">terms</code></td>
<td>
<p>A vector of terms to undergo a lookup.</p>
</td></tr>
<tr><td><code id="+2B25l+2B2A+2B25_+3A_key.match">key.match</code></td>
<td>
<p>Takes one of the following: (1) a two column data.frame of a
match key and reassignment column, (2) a named list of vectors (Note: if
data.frame or named list supplied no key reassign needed) or (3) a single
vector match key.</p>
</td></tr>
<tr><td><code id="+2B25l+2B2A+2B25_+3A_key">key</code></td>
<td>
<p>The hash key to use.</p>
</td></tr>
</table>

<hr>
<h2 id='hash'>Hash/Dictionary Lookup</h2><span id='topic+hash'></span><span id='topic+hash_look'></span><span id='topic++25hl+25'></span><span id='topic++25hl+2B+25'></span><span id='topic+hash_e'></span>

<h3>Description</h3>

<p><code>hash</code> - Creates a <a href="https://github.com/Rdatatable/data.table/wiki"><span class="pkg">data.table</span></a>
based hash table for quick hash style dictionary lookup.
</p>
<p><code>hash_look</code> - Works with a hash table such as is returned from
<code>hash</code>, to lookup values.
</p>
<p><code>%hl%</code> - A binary operator version of <code>hash_look</code>.
</p>
<p><code>%hl+%</code> - A binary operator version of <code>hash_look</code>
for when <code>missing</code> is assumed to be <code>NULL</code>.
</p>
<p><code>hash_e</code> - Creates a new environment for quick hash style dictionary lookup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hash(x)

hash_look(terms, key, missing = NA)

terms %hl% key

terms %hl+% key

hash_e(x, mode.out = "numeric")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hash_+3A_x">x</code></td>
<td>
<p>A two column dataframe.</p>
</td></tr>
<tr><td><code id="hash_+3A_terms">terms</code></td>
<td>
<p>A vector of terms to undergo a lookup.</p>
</td></tr>
<tr><td><code id="hash_+3A_key">key</code></td>
<td>
<p>The hash key to use.</p>
</td></tr>
<tr><td><code id="hash_+3A_missing">missing</code></td>
<td>
<p>Value to assign to terms not found in the hash table.</p>
</td></tr>
<tr><td><code id="hash_+3A_mode.out">mode.out</code></td>
<td>
<p>The type of output (column 2) expected (e.g.,
<code>"character"</code>, <code>"numeric"</code>, etc.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hash</code> - Creates a &quot;hash table&quot;, a two column <span class="pkg">data.table</span>.
</p>
<p><code>hash_e</code> - Creates a &quot;hash table&quot;, a two column <code>data.frame</code> 
in its own environment.
</p>


<h3>Author(s)</h3>

<p><code>hash_e</code> - Bryan Goodrich and Tyler Rinker &lt;tyler.rinker@gmail.com&gt;.
</p>


<h3>References</h3>

<p>https://www.talkstats.com/showthread.php/22754-Create-a-fast-dictionary
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+setDT">setDT</a></code>,
<code><a href="#topic+hash">hash</a></code>
</p>
<p><code><a href="base.html#topic+environment">environment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##===================##
## data.table Hashes ##
##===================##
(DF &lt;- aggregate(mpg~as.character(carb), mtcars, mean))
x &lt;- sample(DF[, 1], 20, TRUE)
new.hash &lt;- hash(DF)
x2 &lt;- c(9, 12, x)
hash_look(x, new.hash)

x %hl% new.hash
x2 %hl% new.hash
x2 %hl+% new.hash

## Create generic functions
hfun &lt;- function(x, ...) {
    hsh &lt;- hash(x, ...)
    function(x, ...) hash_look(x, hsh, ...)
}

m &lt;- hfun(DF)
m(x)

##====================##
## Environment Hashes ##
##====================##
new.hash2 &lt;- hash_e(DF)

x %hl% new.hash2
x2 %hl% new.hash2
x2 %hl+% new.hash2
</code></pre>

<hr>
<h2 id='hms2sec'>Convert h:m:s To/From Seconds</h2><span id='topic+hms2sec'></span><span id='topic+sec2hms'></span>

<h3>Description</h3>

<p><code>hms2sec</code> - Converts a vector of h:m:s to seconds.
</p>
<p><code>sec2hms</code> - Converts a vector of seconds to h:m:s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hms2sec(x)

sec2hms(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hms2sec_+3A_x">x</code></td>
<td>
<p>A vector of times in h:m:s (for <code>hms2sec</code>) or seconds (for 
<code>sec2hms</code>) .</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hms2sec</code> - Returns a vector of times in seconds.
</p>
<p><code>sec2hms</code> - Returns a vector of times in h:m:s format.
</p>


<h3>See Also</h3>

<p><code><a href="chron.html#topic+times">times</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hms2sec(c("02:00:03", "04:03:01"))
hms2sec(sec2hms(c(222, 1234, 55)))
sec2hms(c(256, 3456, 56565))
</code></pre>

<hr>
<h2 id='id'>ID By Row Number or Sequence Along</h2><span id='topic+id'></span>

<h3>Description</h3>

<p>Generate a sequence of integers the 
<code><a href="base.html#topic+length">length</a></code>/<code><a href="base.html#topic+ncol">ncol</a></code> of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id(x, prefix = FALSE, pad = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_+3A_x">x</code></td>
<td>
<p>A dataframe, matrix, vector, or list object.</p>
</td></tr>
<tr><td><code id="id_+3A_prefix">prefix</code></td>
<td>
<p>A character string to use as a prefix. <code>FALSE</code> or 
<code>NULL</code> results in no prefix being used.  <code>TRUE</code> will utilize the 
prefix <code>"X."</code>.</p>
</td></tr>
<tr><td><code id="id_+3A_pad">pad</code></td>
<td>
<p>logical.  If <code>TRUE</code> the beginning number will be padded with 
zeros.</p>
</td></tr>
<tr><td><code id="id_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+pad">pad</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of sequential integers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id(list(1, 4, 6))
id(matrix(1:10, ncol=1))
id(mtcars)
id(mtcars, TRUE)
id("w")
id(mtcars, prefix="id-")
## Not run: 
library(qdap)
question_type(DATA.SPLIT$state, id(DATA.SPLIT, TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='list2df'>List/Matrix/Vector to Dataframe/List/Matrix</h2><span id='topic+list2df'></span><span id='topic+matrix2df'></span><span id='topic+vect2df'></span><span id='topic+list_df2df'></span><span id='topic+list_vect2df'></span><span id='topic+counts2list'></span><span id='topic+vect2list'></span><span id='topic+df2matrix'></span><span id='topic+matrix2long'></span>

<h3>Description</h3>

<p><code>list2df</code> - Convert a named list of vectors to a dataframe.
</p>
<p><code>matrix2df</code> - Convert a matrix to a dataframe and convert the rownames 
to the first column.
</p>
<p><code>vect2df</code> - Convert a named vector to a dataframe.
</p>
<p><code>list_df2df</code> - Convert a list of equal numbered/named columns to a 
dataframe using the list names as the level two variable.
</p>
<p><code>list_vect2df</code> - Convert a list of named vectors to a hierarchical
dataframe.
</p>
<p><code>counts2list</code> - Convert a count matrix to a named list of elements.
</p>
<p><code>vect2list</code> - Convert a vector to a named list.
</p>
<p><code>df2matrix</code> - Convert a dataframe to a <code>matrix</code> and simultaneously 
move a column (default is the first column) to the rownames of a 
<code>matrix</code>.
</p>
<p><code>matrix2long</code> - Convert a matrix to a long format dataframe where column 
names become column 1, row names, column 2 and the values become column 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2df(list.object, col1 = "X1", col2 = "X2")

matrix2df(matrix.object, col1 = "var1")

vect2df(vector.object, col1 = "X1", col2 = "X2", order = TRUE, rev = FALSE)

list_df2df(list.df.object, col1 = "X1")

list_vect2df(
  list.vector.object,
  col1 = "X1",
  col2 = "X2",
  col3 = "X3",
  order = TRUE,
  ...
)

counts2list(mat, nm = rownames(mat))

vect2list(vector.object, use.names = TRUE, numbered.names = FALSE)

df2matrix(data.frame.object, i = 1)

matrix2long(matrix.object, col1 = "cols", col2 = "rows", col3 = "vals")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2df_+3A_list.object">list.object</code></td>
<td>
<p>A named <code><a href="base.html#topic+list">list</a></code> of vectors..</p>
</td></tr>
<tr><td><code id="list2df_+3A_col1">col1</code></td>
<td>
<p>Name for column 1 (the vector elements if converting a list or 
the rownames if converting a matrix).</p>
</td></tr>
<tr><td><code id="list2df_+3A_col2">col2</code></td>
<td>
<p>Name for column 2 (the names of the vectors).</p>
</td></tr>
<tr><td><code id="list2df_+3A_matrix.object">matrix.object</code></td>
<td>
<p>A matrix or simple_triplet_matrix object.</p>
</td></tr>
<tr><td><code id="list2df_+3A_vector.object">vector.object</code></td>
<td>
<p>A vector object.</p>
</td></tr>
<tr><td><code id="list2df_+3A_order">order</code></td>
<td>
<p>logical.  If <code>TRUE</code> the dataframe will be ordered.</p>
</td></tr>
<tr><td><code id="list2df_+3A_rev">rev</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>order = TRUE</code> the dataframe will 
be ordered in descending order.</p>
</td></tr>
<tr><td><code id="list2df_+3A_list.df.object">list.df.object</code></td>
<td>
<p>A list of dataframes with equal number/named of columns.</p>
</td></tr>
<tr><td><code id="list2df_+3A_list.vector.object">list.vector.object</code></td>
<td>
<p>A list of dataframes with equal number/named of 
columns.</p>
</td></tr>
<tr><td><code id="list2df_+3A_col3">col3</code></td>
<td>
<p>The name of the third column (<code>list_vect2df</code>).</p>
</td></tr>
<tr><td><code id="list2df_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>vect2df</code>.</p>
</td></tr>
<tr><td><code id="list2df_+3A_mat">mat</code></td>
<td>
<p>A matrix of counts.</p>
</td></tr>
<tr><td><code id="list2df_+3A_nm">nm</code></td>
<td>
<p>A character vector of names to assign to the list.</p>
</td></tr>
<tr><td><code id="list2df_+3A_use.names">use.names</code></td>
<td>
<p>logical.  If <code>TRUE</code> and the vector is named, these 
names will be transferred to the list names.</p>
</td></tr>
<tr><td><code id="list2df_+3A_numbered.names">numbered.names</code></td>
<td>
<p>logical.  If <code>TRUE</code> padded numbers will be used
as list names.  If <code>FALSE</code> the vector elements themselves will become
the list names.</p>
</td></tr>
<tr><td><code id="list2df_+3A_data.frame.object">data.frame.object</code></td>
<td>
<p>A <code>data.frame</code> object.</p>
</td></tr>
<tr><td><code id="list2df_+3A_i">i</code></td>
<td>
<p>The column number or name to become the rownames of the 
<code>matrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list2df</code> - Returns a dataframe with two columns.
</p>
<p><code>matrix2df</code> - Returns a dataframe.
</p>
<p><code>vect2df</code> - Returns a dataframe.
</p>
<p><code>list_df2df</code> - Returns a dataframe.
</p>
<p><code>list_vect2df</code> - Returns a dataframe.
</p>
<p><code>counts2list</code> - Returns a list of elements.
</p>
<p><code>vect2list</code> - Returns a list of named elements.
</p>
<p><code>df2matrix</code> - Returns a matrix.
</p>
<p><code>matrix2long</code> - Returns a long format dataframe.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mtabulate">mtabulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lst1 &lt;- list(x=c("foo", "bar"), y=1:5)
list2df(lst1)

lst2 &lt;- list(a=c("hello", "everybody"), b = mtcars[1:6, 1])
list2df(lst2, "col 1", "col 2")

matrix2df(mtcars)
matrix2df(cor(mtcars))
matrix2df(matrix(1:9, ncol=3))

vect2df(1:10)
vect2df(c(table(mtcars[, "gear"])))

list_df2df(list(mtcars, mtcars))

L1 &lt;- list(a=1:10, b=1:6, c=5:8)
list_vect2df(L1)

L2 &lt;- list(
  months=setNames(1:12, month.abb),
  numbers=1:6, 
  states=setNames(factor(state.name[1:4]), state.abb[1:4])
)

list_vect2df(L2)

set.seed(10)
cnts &lt;- data.frame(month=month.name,
    matrix(sample(0:2, 36, TRUE), ncol=3))

counts2list(cnts[, -1], cnts[, 1])
df2matrix(cnts)
counts2list(df2matrix(cnts))
counts2list(t(df2matrix(cnts)))

mat &lt;- matrix(1:9, ncol=3)
matrix2long(mat)
matrix2long(mtcars)

## Not run: 
library(qdap)
term &lt;- c("the ", "she", " wh")
(out &lt;- with(raj.act.1,  termco(dialogue, person, term)))
x &lt;- counts(out)

counts2list(x[, -c(1:2)], x[, 1])

## End(Not run)

vect2list(LETTERS[1:10])
vect2list(LETTERS[1:10], numbered.names = TRUE)
x &lt;- setNames(LETTERS[1:4], paste0("Element_", 1:4))
vect2list(x)
vect2list(x, FALSE)
vect2list(x, FALSE, TRUE)
</code></pre>

<hr>
<h2 id='loc_split'>Split Data Forms at Specified Locations</h2><span id='topic+loc_split'></span><span id='topic+loc_split.list'></span><span id='topic+loc_split.data.frame'></span><span id='topic+loc_split.matrix'></span><span id='topic+loc_split.numeric'></span><span id='topic+loc_split.factor'></span><span id='topic+loc_split.character'></span><span id='topic+loc_split.default'></span>

<h3>Description</h3>

<p>Split data forms at specified integer locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loc_split(x, locs, names = NULL, ...)

## S3 method for class 'list'
loc_split(x, locs, names = NULL, ...)

## S3 method for class 'data.frame'
loc_split(x, locs, names = NULL, ...)

## S3 method for class 'matrix'
loc_split(x, locs, names = NULL, ...)

## S3 method for class 'numeric'
loc_split(x, locs, names = NULL, ...)

## S3 method for class 'factor'
loc_split(x, locs, names = NULL, ...)

## S3 method for class 'character'
loc_split(x, locs, names = NULL, ...)

## Default S3 method:
loc_split(x, locs, names = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loc_split_+3A_x">x</code></td>
<td>
<p>A data form (<code>list</code>, <code>vector</code>, <code>data.frame</code>, 
<code>matrix</code>).</p>
</td></tr>
<tr><td><code id="loc_split_+3A_locs">locs</code></td>
<td>
<p>A vector of integer locations to split at.  If <code>locs</code> 
contains the index 1, it will be silently dropped.</p>
</td></tr>
<tr><td><code id="loc_split_+3A_names">names</code></td>
<td>
<p>Optional vector of names to give to the list elements.</p>
</td></tr>
<tr><td><code id="loc_split_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns of list of data forms broken at the <code>locs</code>.
</p>


<h3>Note</h3>

<p>Two dimensional object will retain dimension (i.e., <code>drop = FALSE</code> 
is used).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run_split">run_split</a></code>,
<code><a href="#topic+split_vector">split_vector</a></code>
<a href="https://github.com/trinker/loc_split_example">https://github.com/trinker/loc_split_example</a> for practical usage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## character
loc_split(LETTERS, c(4, 10, 16))
loc_split(LETTERS, c(4, 10, 16), c("dog", "cat", "chicken", "rabbit"))

## numeric
loc_split(1:100, c(33, 66))

## factor
(p_chng &lt;- head(1 + cumsum(rle(as.character(CO2[["Plant"]]))[[1]]), -1))
loc_split(CO2[["Plant"]], p_chng)

## list
loc_split(as.list(LETTERS), c(4, 10, 16))

## data.frame
(vs_change &lt;- head(1 + cumsum(rle(as.character(mtcars[["vs"]]))[[1]]), -1))
loc_split(mtcars, vs_change)

## matrix
(mat &lt;- matrix(1:50, nrow=10))
loc_split(mat, c(3, 6, 10))
</code></pre>

<hr>
<h2 id='lookup'>Hash Table/Dictionary Lookup
<code>lookup</code> - <a href="http://datatable.r-forge.r-project.org/"><span class="pkg">data.table</span></a> 
based hash table useful for large vector lookups.</h2><span id='topic+lookup'></span><span id='topic+lookup.list'></span><span id='topic+lookup.data.frame'></span><span id='topic+lookup.matrix'></span><span id='topic+lookup.numeric'></span><span id='topic+lookup.factor'></span><span id='topic+lookup.character'></span><span id='topic++25l+25'></span><span id='topic++25l+2B+25'></span><span id='topic++25lc+25'></span><span id='topic++25lc+2B+25'></span>

<h3>Description</h3>

<p><code>%l%</code> - A binary operator version of <code>lookup</code> 
for when <code>key.match</code> is a data.frame or named list.
</p>
<p><code>%l+%</code> - A binary operator version of <code>lookup</code> 
for when <code>key.match</code> is a data.frame or named list and <code>missing</code> is
assumed to be <code>NULL</code>.
</p>
<p><code>%lc%</code> - A binary operator version of <code>lookup</code> 
for when <code>key.match</code> is a data.frame or named list and all arguments are 
converted to character.
</p>
<p><code>%lc+%</code> - A binary operator version of <code>lookup</code> 
for when <code>key.match</code> is a data.frame or named list, <code>missing</code> is
assumed to be <code>NULL</code>, and all arguments are converted to character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup(terms, key.match, key.reassign = NULL, missing = NA)

## S3 method for class 'list'
lookup(terms, key.match, key.reassign = NULL, missing = NA)

## S3 method for class 'data.frame'
lookup(terms, key.match, key.reassign = NULL, missing = NA)

## S3 method for class 'matrix'
lookup(terms, key.match, key.reassign = NULL, missing = NA)

## S3 method for class 'numeric'
lookup(terms, key.match, key.reassign, missing = NA)

## S3 method for class 'factor'
lookup(terms, key.match, key.reassign, missing = NA)

## S3 method for class 'character'
lookup(terms, key.match, key.reassign, missing = NA)

terms %l% key.match

terms %l+% key.match

terms %lc% key.match

terms %lc+% key.match
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_+3A_terms">terms</code></td>
<td>
<p>A vector of terms to undergo a lookup.</p>
</td></tr>
<tr><td><code id="lookup_+3A_key.match">key.match</code></td>
<td>
<p>Takes one of the following: (1) a two column data.frame of a 
match key and reassignment column, (2) a named list of vectors (Note: if 
data.frame or named list supplied no key reassign needed) or (3) a single 
vector match key.</p>
</td></tr>
<tr><td><code id="lookup_+3A_key.reassign">key.reassign</code></td>
<td>
<p>A single reassignment vector supplied if key.match is 
not a two column data.frame/named list.</p>
</td></tr>
<tr><td><code id="lookup_+3A_missing">missing</code></td>
<td>
<p>Value to assign to terms not matching the key.match.  If set 
to <code>NULL</code> the original values in <code>terms</code> corresponding to the 
missing elements are retained.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs A new vector with reassigned values.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+setDT">setDT</a></code>,
<code><a href="#topic+hash">hash</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Supply a dataframe to key.match

lookup(1:5, data.frame(1:4, 11:14))

## Retain original values for missing 
lookup(1:5, data.frame(1:4, 11:14), missing=NULL) 

lookup(LETTERS[1:5], data.frame(LETTERS[1:5], 100:104))
lookup(LETTERS[1:5], factor(LETTERS[1:5]), 100:104)

## Supply a named list of vectors to key.match

codes &lt;- list(
    A = c(1, 2, 4), 
    B = c(3, 5),
    C = 7,
    D = c(6, 8:10)
)

lookup(1:10, codes)

## Supply a single vector to key.match and key.reassign

lookup(mtcars$carb, sort(unique(mtcars$carb)),        
    c("one", "two", "three", "four", "six", "eight")) 
    
lookup(mtcars$carb, sort(unique(mtcars$carb)),        
    seq(10, 60, by=10))
  
## %l%, a binary operator version of lookup
1:5 %l% data.frame(1:4, 11:14)
1:10 %l% codes

1:12 %l% codes
1:12 %l+% codes
  
(key &lt;- data.frame(a=1:3, b=factor(paste0("l", 1:3))))
1:3 %l% key

##Larger Examples
key &lt;- data.frame(x=1:2, y=c("A", "B"))
big.vec &lt;- sample(1:2, 3000000, TRUE)
out &lt;- lookup(big.vec, key)
out[1:20]

## A big string to recode with variation
## means a bigger dictionary
recode_me &lt;- sample(1:(length(LETTERS)*10), 10000000, TRUE)

## Time it
tic &lt;- Sys.time()  

output &lt;- recode_me %l% split(1:(length(LETTERS)*10), LETTERS)
difftime(Sys.time(), tic)

## view it
sample(output, 100)
</code></pre>

<hr>
<h2 id='lookup_e'>Hash Table/Dictionary Lookup
<code>lookup_e</code> - Environment based hash table useful for large vector lookups.</h2><span id='topic+lookup_e'></span><span id='topic+lookup_e.matrix'></span><span id='topic+lookup_e.data.frame'></span><span id='topic+lookup_e.list'></span><span id='topic+lookup_e.numeric'></span><span id='topic+lookup_e.factor'></span><span id='topic+lookup_e.character'></span><span id='topic++25le+25'></span><span id='topic++25le+2B+25'></span>

<h3>Description</h3>

<p><code>%le%</code> - A binary operator version of <code>lookup_e</code> 
for when <code>key.match</code> is a data.frame or named list.
</p>
<p><code>%le+%</code> - A binary operator version of <code>lookup_e</code> 
for when <code>key.match</code> is a data.frame or named list and <code>missing</code> is
assumed to be <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup_e(terms, key.match, key.reassign = NULL, missing = NA)

## S3 method for class 'matrix'
lookup_e(terms, key.match, key.reassign = NULL, missing = NA)

## S3 method for class 'data.frame'
lookup_e(terms, key.match, key.reassign = NULL, missing = NA)

## S3 method for class 'list'
lookup_e(terms, key.match, key.reassign = NULL, missing = NA)

## S3 method for class 'numeric'
lookup_e(terms, key.match, key.reassign = NULL, missing = NA)

## S3 method for class 'factor'
lookup_e(terms, key.match, key.reassign = NULL, missing = NA)

## S3 method for class 'character'
lookup_e(terms, key.match, key.reassign = NULL, missing = NA)

terms %le% key.match

terms %le+% key.match
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_e_+3A_terms">terms</code></td>
<td>
<p>A vector of terms to undergo a lookup_e.</p>
</td></tr>
<tr><td><code id="lookup_e_+3A_key.match">key.match</code></td>
<td>
<p>Takes one of the following: (1) a two column data.frame of a 
match key and reassignment column, (2) a named list of vectors (Note: if 
data.frame or named list supplied no key reassign needed) or (3) a single 
vector match key.</p>
</td></tr>
<tr><td><code id="lookup_e_+3A_key.reassign">key.reassign</code></td>
<td>
<p>A single reassignment vector supplied if key.match is 
not a two column data.frame/named list.</p>
</td></tr>
<tr><td><code id="lookup_e_+3A_missing">missing</code></td>
<td>
<p>Value to assign to terms not matching the key.match.  If set 
to <code>NULL</code> the original values in <code>terms</code> corresponding to the 
missing elements are retained.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs A new vector with reassigned values.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+new.env">new.env</a></code>, <code><a href="#topic+lookup">lookup</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lookup_e(1:5, data.frame(1:4, 11:14))

## Retain original values for missing
lookup_e(1:5, data.frame(1:4, 11:14), missing=NULL)

lookup_e(LETTERS[1:5], data.frame(LETTERS[1:5], 100:104))
lookup_e(LETTERS[1:5], factor(LETTERS[1:5]), 100:104)

## Supply a named list of vectors to key.match

codes &lt;- list(
    A = c(1, 2, 4),
    B = c(3, 5),
    C = 7,
    D = c(6, 8:10)
)

lookup_e(1:10, codes)

## Supply a single vector to key.match and key.reassign

lookup_e(mtcars$carb, sort(unique(mtcars$carb)),
    c("one", "two", "three", "four", "six", "eight"))

lookup_e(mtcars$carb, sort(unique(mtcars$carb)),
    seq(10, 60, by=10))

## %le%, a binary operator version of lookup
1:5 %le% data.frame(1:4, 11:14)
1:10 %le% codes

1:12 %le% codes
1:12 %le+% codes
</code></pre>

<hr>
<h2 id='mtabulate'>Tabulate Frequency Counts for Multiple Vectors</h2><span id='topic+mtabulate'></span>

<h3>Description</h3>

<p>Similar to <code><a href="base.html#topic+tabulate">tabulate</a></code> that works on multiple vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtabulate(vects)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtabulate_+3A_vects">vects</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code>, <code><a href="base.html#topic+list">list</a></code>, or 
<code><a href="base.html#topic+data.frame">data.frame</a></code> of named/unnamed vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns equal to 
number of unique elements and the number of rows equal to the the original 
length of the <code><a href="base.html#topic+vector">vector</a></code>, <code><a href="base.html#topic+list">list</a></code>, or 
<code><a href="base.html#topic+data.frame">data.frame</a></code> (length equals ncols in 
<code><a href="base.html#topic+data.frame">data.frame</a></code>).  If list of vectors is named 
these will be the rownames of the dataframe.
</p>


<h3>Author(s)</h3>

<p>Joran Elias and Tyler Rinker &lt;tyler.rinker@gmail.com&gt;.
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/9961324/1000343">https://stackoverflow.com/a/9961324/1000343</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tabulate">tabulate</a></code>, <code><a href="#topic+counts2list">counts2list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtabulate(list(w=letters[1:10], x=letters[1:5], z=letters))
mtabulate(list(mtcars$cyl[1:10]))

## Dummy coding
mtabulate(mtcars$cyl[1:10])
mtabulate(CO2[, "Plant"])

dat &lt;- data.frame(matrix(sample(c("A", "B"), 30, TRUE), ncol=3))
mtabulate(dat)
t(mtabulate(dat))
counts2list(mtabulate(dat))
</code></pre>

<hr>
<h2 id='pad'>Pad Strings</h2><span id='topic+pad'></span>

<h3>Description</h3>

<p>A convenience wrapper for <code><a href="base.html#topic+sprintf">sprintf</a></code> that pads the front end 
of strings with spaces or 0s. Useful for creating multiple uniform directories 
that will maintain correct order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(x, padding = max(nchar(as.character(x))), sort = TRUE, type = "detect")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_+3A_x">x</code></td>
<td>
<p>A character, factor, numeric vector.</p>
</td></tr>
<tr><td><code id="pad_+3A_padding">padding</code></td>
<td>
<p>Number of characters to pad.  Default makes all elements of a 
string the number of characters of the element with the maximum characters.</p>
</td></tr>
<tr><td><code id="pad_+3A_sort">sort</code></td>
<td>
<p>logical.  If <code>TRUE</code> the outcome is sorted.</p>
</td></tr>
<tr><td><code id="pad_+3A_type">type</code></td>
<td>
<p>A character string of <code>"detect"</code>, <code>"numeric"</code>, 
<code>"character"</code>, <code>"d"</code> or <code>"s"</code>.  If numeric zeros are padded.  
If character spaces are padded.  The <code>detect</code> attempts to determine if x 
is numeric (d) or not (s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector every element padded with 0/spaces.
</p>


<h3>Note</h3>

<p><code>pad</code> is a wrapper for the <code><a href="base.html#topic+sprintf">sprintf</a></code> function.
<code>pad</code> may behave differently on various platforms in accordance with the
documentation for <code><a href="base.html#topic+sprintf">sprintf</a></code>: &quot;actual implementation will 
follow the C99 standard and fine details (especially the behaviour under user 
error) may depend on the platform.&quot;  See <code><a href="base.html#topic+sprintf">sprintf</a></code> for more 
information.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sprintf">sprintf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pad(sample(1:10, 10))
pad(sample(1:10, 10), sort=FALSE)
pad(as.character(sample(1:10, 10)))
pad(as.character(sample(1:10, 10)), sort=FALSE)
pad(as.character(sample(1:10, 10)), 4)
pad(month.name)
</code></pre>

<hr>
<h2 id='print.v_outer'>Prints a v_outer Object.</h2><span id='topic+print.v_outer'></span>

<h3>Description</h3>

<p>Prints a v_outer object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'v_outer'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.v_outer_+3A_x">x</code></td>
<td>
<p>The v_outer object</p>
</td></tr>
<tr><td><code id="print.v_outer_+3A_digits">digits</code></td>
<td>
<p>Number of decimal places to print.</p>
</td></tr>
<tr><td><code id="print.v_outer_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='read_docx'>Read in .docx Content</h2><span id='topic+read_docx'></span>

<h3>Description</h3>

<p>Read in the content from a .docx file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_docx(file, skip = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_docx_+3A_file">file</code></td>
<td>
<p>The path to the .docx file.</p>
</td></tr>
<tr><td><code id="read_docx_+3A_skip">skip</code></td>
<td>
<p>The number of lines to skip.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p>Bryan Goodrich and Tyler Rinker &lt;tyler.rinker@gmail.com&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Mining Citation
url_dl("http://umlreading.weebly.com/uploads/2/5/2/5/25253346/whole_language_timeline-updated.docx")

(txt &lt;- read_docx("whole_language_timeline-updated.docx"))

library(qdapTools); library(ggplot2); library(qdap)
txt &lt;- rm_non_ascii(txt)

parts &lt;- split_vector(txt, split = "References", include = TRUE, regex=TRUE)

parts[[1]]

rm_citation(unbag(parts[[1]]), extract=TRUE)[[1]]

## By line
rm_citation(parts[[1]], extract=TRUE)

## Frequency
left_just(cites &lt;- list2df(sort(table(rm_citation(unbag(parts[[1]]),
    extract=TRUE)), T), "freq", "citation")[2:1])

## Distribution of citations (find locations and then plot)
cite_locs &lt;- do.call(rbind, lapply(cites[[1]], function(x){
    m &lt;- gregexpr(x, unbag(parts[[1]]), fixed=TRUE)
    data.frame(
        citation=x,
        start = m[[1]] -5,
        end =  m[[1]] + 5 + attributes(m[[1]])[["match.length"]]
    )
}))

ggplot(cite_locs) +
    geom_segment(aes(x=start, xend=end, y=citation, yend=citation), size=3,
        color="yellow") +
    xlab("Duration") +
    scale_x_continuous(expand = c(0,0),
        limits = c(0, nchar(unbag(parts[[1]])) + 25)) +
    theme_grey() +
    theme(
        panel.grid.major=element_line(color="grey20"),
        panel.grid.minor=element_line(color="grey20"),
        plot.background = element_rect(fill="black"),
        panel.background = element_rect(fill="black"),
        panel.border = element_rect(colour = "grey50", fill=NA, size=1),
        axis.text=element_text(color="grey50"),    
        axis.title=element_text(color="grey50")  
    )

## End(Not run)
</code></pre>

<hr>
<h2 id='repo2github'>Upload a Local Repo to GitHub</h2><span id='topic+repo2github'></span>

<h3>Description</h3>

<p>Allows uploading a local repository to <a href="https://github.com/">GitHub</a> 
without first creating the repository in the clouds. 
<code><a href="#topic+repo2github">repo2github</a></code> is designed for the initial push to 
GitHub.  Future pushes can be handled via RStudio or other 
<a href="https://git-scm.com/">Git</a> interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repo2github(
  password,
  project.dir = getwd(),
  repo = basename(getwd()),
  github.user = getOption("github.user"),
  gitpath = NULL,
  readme = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repo2github_+3A_password">password</code></td>
<td>
<p>GitHub user password (character string).  If this is not 
supplied the user will be prompted to enter a password.</p>
</td></tr>
<tr><td><code id="repo2github_+3A_project.dir">project.dir</code></td>
<td>
<p>The path to the root directory of the report/presentation.</p>
</td></tr>
<tr><td><code id="repo2github_+3A_repo">repo</code></td>
<td>
<p>A character string naming the repo; default attempts to use the 
report project directory name.</p>
</td></tr>
<tr><td><code id="repo2github_+3A_github.user">github.user</code></td>
<td>
<p>GitHub user name (character string).</p>
</td></tr>
<tr><td><code id="repo2github_+3A_gitpath">gitpath</code></td>
<td>
<p>Path to the location of <a href="https://git-scm.com/">Git</a>.  If 
<code>NULL</code> <code>repo2github</code> will attempt to locate the path if necessary.</p>
</td></tr>
<tr><td><code id="repo2github_+3A_readme">readme</code></td>
<td>
<p>logical.  If <code>TRUE</code> repo initializes with a README.md file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>project.dir</code> and <code>repo</code> use 
<code><a href="base.html#topic+getwd">getwd</a></code>.  This assumes is the current working directory is 
the root directory and is done for convenience.  The user should ensure that 
either their working directory is the root directory or supply the correct 
root directory/name to these arguments.
</p>


<h3>Value</h3>

<p>Creates GitHub repository.
</p>


<h3>Warning</h3>

<p>For Windows users this function creates a temporary _netrc 
file in the home directory and attempts to delete this file.  The _netrc 
contains username and password information for GitHub. 
<code><a href="#topic+repo2github">repo2github</a></code> attempts to delete this file but care 
should be taken.  The file is created in: <br />
<code>file.path(Sys.getenv()["HOME"], "DELETE_ME_REPORTS_PACKAGE/_nectrc")</code>.
</p>


<h3>Suggestion</h3>

<p>The user may want to set <code><a href="base.html#topic+options">options</a></code> for 
<code>github.user</code> in the user's primary <code>.Rprofile</code>.
</p>


<h3>Note</h3>

<p>The user will need to have a <a href="https://github.com/">GitHub</a> account 
established.
</p>


<h3>Author(s)</h3>

<p>Simon O'Hanlon, Daniel Chaffiol, and Tyler Rinker &lt;tyler.rinker@gmail.com&gt;
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/15047013/1000343">https://stackoverflow.com/a/15047013/1000343</a> <br />
<a href="https://stackoverflow.com/a/18692400/1000343">https://stackoverflow.com/a/18692400/1000343</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
repo2github()

## End(Not run)
</code></pre>

<hr>
<h2 id='run_split'>Split a String Into Run Chunks</h2><span id='topic+run_split'></span>

<h3>Description</h3>

<p>Splits a string into a vector of runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_split(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_split_+3A_x">x</code></td>
<td>
<p>A string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of vectors.
</p>


<h3>Author(s)</h3>

<p>Robert Reed and Tyler Rinker &lt;tyler.rinker@gmail.com&gt;.
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/24319217/1000343">https://stackoverflow.com/a/24319217/1000343</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loc_split">loc_split</a></code>,
<code><a href="#topic+split_vector">split_vector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run_split(c("122333444455555666666", NA, "abbcccddddeeeeeffffff"))
</code></pre>

<hr>
<h2 id='shift'>Shift Vector Left/Right</h2><span id='topic+shift'></span><span id='topic+shift_right'></span><span id='topic+shift_left'></span>

<h3>Description</h3>

<p>Shift a vector left or right n spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(x, n, direction = "right")

shift_right(x, n)

shift_left(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="shift_+3A_n">n</code></td>
<td>
<p>The number of moves left or right to shift.</p>
</td></tr>
<tr><td><code id="shift_+3A_direction">direction</code></td>
<td>
<p>A direction to shift; must be either &quot;left&quot; or &quot;right&quot;.
Use explicit directional shift functions <code>shift_right</code> and 
<code>shift_left</code> for better performance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a shifted vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lapply(0:9, function(i) shift(1:10, i))
lapply(0:9, function(i) shift(1:10, i, "left"))

## Explicit, faster shifting
lapply(0:9, function(i) shift_right(1:10, i))
lapply(0:9, function(i) shift_left(1:10, i))
lapply(0:25, function(i) shift_left(LETTERS, i))
</code></pre>

<hr>
<h2 id='split_vector'>Split a Vector By Split Points</h2><span id='topic+split_vector'></span>

<h3>Description</h3>

<p>Splits a <code>vector</code> into a list of vectors based on split points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_vector(x, split = "", include = FALSE, regex = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_vector_+3A_x">x</code></td>
<td>
<p>A vector with split points.</p>
</td></tr>
<tr><td><code id="split_vector_+3A_split">split</code></td>
<td>
<p>A vector of places (elements) to split on or a regular 
expression if <code>regex</code> argument is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="split_vector_+3A_include">include</code></td>
<td>
<p>An integer of <code>1</code> (<code>split</code> character(s) are not 
included in the output), <code>2</code> (<code>split</code> character(s) are included at 
the beginning of the output), or <code>3</code> (<code>split</code> character(s) are 
included at the end of the output).</p>
</td></tr>
<tr><td><code id="split_vector_+3A_regex">regex</code></td>
<td>
<p>logical.  If <code>TRUE</code> regular expressions will be enabled for
<code>split</code> argument.</p>
</td></tr>
<tr><td><code id="split_vector_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="base.html#topic+grep">grep</a></code> and
<code><a href="base.html#topic+grepl">grepl</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of vectors.
</p>


<h3>Author(s)</h3>

<p>Matthew Flickinger and Tyler Rinker &lt;tyler.rinker@gmail.com&gt;.
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/24319217/1000343">https://stackoverflow.com/a/24319217/1000343</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loc_split">loc_split</a></code>,
<code><a href="#topic+run_split">run_split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(15)
x &lt;- sample(c("", LETTERS[1:10]), 25, TRUE, prob=c(.2, rep(.08, 10)))

split_vector(x)
split_vector(x, "C")
split_vector(x, c("", "C"))

split_vector(x, include = 0)
split_vector(x, include = 1)
split_vector(x, include = 2)

set.seed(15)
x &lt;- sample(1:11, 25, TRUE, prob=c(.2, rep(.08, 10)))
split_vector(x, 1)

## relationship to `loc_split`
all.equal(
    split_vector(x, include = 1),
    loc_split(x, which(x == ""), names=1:6)
)
</code></pre>

<hr>
<h2 id='start_end'>Get Location of Start/End Points</h2><span id='topic+start_end'></span>

<h3>Description</h3>

<p>Get the locations of start/end places for the ones in a binary vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_end(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_end_+3A_x">x</code></td>
<td>
<p>A vector of 1 and 0 or <code><a href="base.html#topic+logical">logical</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a two column <code><a href="base.html#topic+data.frame">data.frame</a></code> of start and end locations for ones.
</p>


<h3>Author(s)</h3>

<p>Roland (<a href="https://stackoverflow.com/users/1412059/roland">https://stackoverflow.com/users/1412059/roland</a>) and Tyler Rinker &lt;tyler.rinker@gmail.com&gt;.
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/29184841/1000343">https://stackoverflow.com/a/29184841/1000343</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10); (x &lt;- sample(0:1, 50, TRUE, c(.35, .65)))
start_end(x)
(y &lt;- sample(c(TRUE, FALSE), 50, TRUE, c(.35, .65)))
start_end(y)
</code></pre>

<hr>
<h2 id='text2color'>Map Words to Colors</h2><span id='topic+text2color'></span>

<h3>Description</h3>

<p>A dictionary lookup that maps words to colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text2color(words, recode.words, colors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text2color_+3A_words">words</code></td>
<td>
<p>A vector of words.</p>
</td></tr>
<tr><td><code id="text2color_+3A_recode.words">recode.words</code></td>
<td>
<p>A vector of unique words or a list of unique word vectors 
that will be matched against corresponding colors.</p>
</td></tr>
<tr><td><code id="text2color_+3A_colors">colors</code></td>
<td>
<p>A vector of colors of equal in length to recode.words +1 (the 
+1 is for unmatched words).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of mapped colors equal in length to the words vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lookup">lookup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- structure(list(X1 = structure(c(3L, 1L, 8L, 4L, 7L, 2L, 2L, 2L, 
    4L, 8L, 4L, 3L, 5L, 3L, 1L, 8L, 7L, 2L, 1L, 6L), .Label = c("a", 
    "and", "in", "is", "of", "that", "the", "to"), class = "factor")), 
    .Names = "X1", row.names = c(NA, -20L), class = "data.frame")

#blue was recycled
text2color(x$X1, c("the", "and", "is"), c("red", "green", "blue")) 
text2color(x$X1, c("the", "and", "is"), c("red", "green", "blue", "white"))
x$X2 &lt;- text2color(x$X1, list(c("the", "and", "is"), "that"), 
    c("red", "green", "white"))
x
</code></pre>

<hr>
<h2 id='url_dl'>Download Instructional Documents</h2><span id='topic+url_dl'></span>

<h3>Description</h3>

<p>This function enables downloading documents for future instructional training.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_dl(..., url = 61803503)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="url_dl_+3A_url">url</code></td>
<td>
<p>The download url or <a href="https://www.dropbox.com/">Dropbox</a> key.</p>
</td></tr>
<tr><td><code id="url_dl_+3A_...">...</code></td>
<td>
<p>Document names to download. Quoted strings (complete urls) can
also be supplied (if so no url argument is supplied).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Places a copy of the downloaded document in the users working 
directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example 1 (download from Dropbox)
# download transcript of the debate to working directory
library(qdap)
url_dl(pres.deb1.docx, pres.deb2.docx, pres.deb3.docx)   

# load multiple files with read transcript and assign to working directory
dat1 &lt;- read.transcript("pres.deb1.docx", c("person", "dialogue"))
dat2 &lt;- read.transcript("pres.deb2.docx", c("person", "dialogue"))
dat3 &lt;- read.transcript("pres.deb3.docx", c("person", "dialogue"))

docs &lt;- qcv(pres.deb1.docx, pres.deb2.docx, pres.deb3.docx)
dir() %in% docs
library(reports); delete(docs)    #remove the documents
dir() %in% docs

## Example 2 (quoted string urls)
url_dl("https://dl.dropboxusercontent.com/u/61803503/qdap.pdf", 
   "http://www.cran.r-project.org/doc/manuals/R-intro.pdf")

delete(c("qdap.pdf", "R-intro.pdf"))

## End(Not run)
</code></pre>

<hr>
<h2 id='v_outer'>Vectorized Version of outer</h2><span id='topic+v_outer'></span><span id='topic+v_outer.list'></span><span id='topic+v_outer.data.frame'></span><span id='topic+v_outer.matrix'></span>

<h3>Description</h3>

<p>Vectorized <code><a href="base.html#topic+outer">outer</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v_outer(x, FUN, ...)

## S3 method for class 'list'
v_outer(x, FUN, ...)

## S3 method for class 'data.frame'
v_outer(x, FUN, ...)

## S3 method for class 'matrix'
v_outer(x, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="v_outer_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code>, <code>dataframe</code> or equal length <code>list</code> of 
vectors.</p>
</td></tr>
<tr><td><code id="v_outer_+3A_fun">FUN</code></td>
<td>
<p>A vectorized function.</p>
</td></tr>
<tr><td><code id="v_outer_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function supplied to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with the vectorized <code><a href="base.html#topic+outer">outer</a></code> 
function.
</p>


<h3>Author(s)</h3>

<p>Vincent Zoonekynd, eddi of stackoverflow.com, and Tyler Rinker &lt;tyler.rinker@gmail.com&gt;.
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/9917425/1000343">https://stackoverflow.com/a/9917425/1000343</a> <br /> 
<a href="https://stackoverflow.com/q/23817341/1000343">https://stackoverflow.com/q/23817341/1000343</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+outer">outer</a></code>,
<code><a href="stats.html#topic+cor">cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#|------------------------------------------------------|
#|    SETTING UP VARIOUS FUNCTIONS THAT WILL BE USED    |
#|------------------------------------------------------|
pooled_sd &lt;- function(x, y) {
    n1 &lt;- length(x)
    n2 &lt;- length(y)
    s1 &lt;- sd(x)
    s2 &lt;- sd(y)
    sqrt(((n1-1)*s1 + (n2-1)*s2)/((n1-1) + (n2-1)))
}

## Effect Size: Cohen's d 
cohens_d &lt;- function(x, y) {
    (mean(y) - mean(x))/pooled_sd(x, y)
}


## Euclidean Distance
euc_dist &lt;- function(x,y) sqrt(sum((x - y) ^ 2))

## Cosine similarity
cos_sim &lt;- function(x, y) x %*% y / sqrt(x%*%x * y%*%y)

sum2 &lt;- function(x, y) sum(x, y)
arbitrary &lt;- function(x, y) round(sqrt(sum(x)) - sum(y), digits=1)
#--------------------------------------------------------#

## A data.frame
v_outer(mtcars, cor)
v_outer(mtcars, pooled_sd)
v_outer(mtcars[, 1:7], euc_dist)
v_outer(mtcars[, 1:7], sum2)
v_outer(mtcars[, 1:7], arbitrary)

## mtcars as a list
mtcars2 &lt;- lapply(mtcars[, 1:7], "[")
v_outer(mtcars2, cor)
v_outer(mtcars2, cor,  method = "spearman")
v_outer(mtcars2, pooled_sd)
v_outer(split(mtcars[["mpg"]], mtcars[["carb"]]), cohens_d)
v_outer(split(CO2[["uptake"]], CO2[["Plant"]]), cohens_d)
print(v_outer(mtcars[, 1:7], pooled_sd), digits = 1)
print(v_outer(mtcars[, 1:7], pooled_sd), digits = NULL)
v_outer(mtcars2, euc_dist)
v_outer(mtcars2, sum2)
v_outer(mtcars2, arbitrary)

## A matrix
mat &lt;- matrix(rbinom(500, 0:1, .45), ncol=10)
v_outer(mat, cos_sim)
v_outer(mat, euc_dist)
v_outer(mat, arbitrary)

## Not run: 
library(qdap)
wc3 &lt;- function(x, y) sum(sapply(list(x, y), wc, byrow = FALSE))
L1 &lt;- word_list(DATA$state, DATA$person)$cwl
(x &lt;- v_outer(L1, wc3))
diag(x) &lt;- (sapply(L1, length))
x

v_outer(with(DATA, wfm(state, person)), cos_sim)
with(DATA, Dissimilarity(state, person))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
