<!DOCTYPE html><html><head><title>Help for package sra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#1.+20sra+20package'>
<p>Selection Response Analysis: a <span class="rlang"><b>R</b></span> package</p></a></li>
<li><a href='#2.+20Phenomenological+20models'><p> Descriptive models of artificial-selection responses: auto-regressive models</p></a></li>
<li><a href='#3.+20Mechanistic+20models'><p> Descriptive models of artificial-selection responses: quantitative genetics models</p></a></li>
<li><a href='#4.+20Methods+20for+20srafit+20objects+20'><p> Overloaded functions for &quot;srafit&quot; objects</p></a></li>
<li><a href='#5.+20plot.srafit'><p> Plotting &quot;srafit&quot; objects</p></a></li>
<li><a href='#6.+20sraData'><p> Generates an object of class &quot;sradata&quot;, necessary to run the models provided by the sra package.</p></a></li>
<li><a href='#Expected+20time+20series+20dynamics'><p> Expected dynamics for different SRA models (internal functions).</p></a></li>
<li><a href='#sraMakeObject'><p>Creates an object of class &quot;srafit&quot; (internal function)</p></a></li>
<li><a href='#sraMinuslogL'><p> Calculation of the likelihood of time series (internal functions)</p></a></li>
<li><a href='#sraStartingvalues'><p>Provides reasonable starting values for sra model fit (internal function)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Selection Response Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Arnaud Le Rouzic</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arnaud Le Rouzic &lt;arnaud.le-rouzic@universite-paris-saclay.fr&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, stats4, graphics</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lerouzic/sra">https://github.com/lerouzic/sra</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Artificial selection through selective breeding is an efficient way to induce changes in traits of interest in experimental populations. This package (sra) provides a set of tools to analyse artificial-selection response datasets. The data typically feature for several generations the average value of a trait in a population, the variance of the trait, the population size and the average value of the parents that were chosen to breed. Sra implements two families of models aiming at describing the dynamics of the genetic architecture of the trait during the selection response. The first family relies on purely descriptive (phenomenological) models, based on an autoregressive framework. The second family provides different mechanistic models, accounting e.g. for inbreeding, mutations, genetic and environmental canalization, or epistasis. The parameters underlying the dynamics of the time series are estimated by maximum likelihood. The sra package thus provides (i) a wrapper for the R functions mle() and optim() aiming at fitting in a convenient way a predetermined set of models, and (ii) some functions to plot and analyze the output of the models. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-14 08:37:00 UTC; lerouzic</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-14 09:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='1.+20sra+20package'>
Selection Response Analysis: a <span class="rlang"><b>R</b></span> package
</h2><span id='topic+sra-package'></span><span id='topic+sra'></span>

<h3>Description</h3>

<p>This package (<code>sra</code>) provides a set of tools to analyse artificial-selection response datasets. The data typically feature for several generations the average value of a trait in a population, the variance of the trait, the population size and the average value of the parents that were chosen to breed. <code>sra</code> implements two families of models aiming at describing the dynamics of the genetic architecture of the trait during the selection response. The first family relies on purely descriptive (phenomenological) models, based on an autoregressive framework. The second family provides different mechanistic models, accounting e.g.\ for inbreeding, mutations, genetic and environmental canalization, or epistasis. The parameters underlying the dynamics of the time series are estimated by maximum likelihood. The <code>sra</code> package thus provides (i) a wrapper for the <span class="rlang"><b>R</b></span> functions <code><a href="stats4.html#topic+mle">mle</a></code> and <code><a href="stats.html#topic+optim">optim</a></code> aiming at fitting in a convenient way a predetermined set of models, and (ii) some functions to plot and analyze the output of the models. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> sra</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><strong>Data set</strong> The user must provide (i) a vector containing the mean phenotype for all generations, (ii) a vector containing the phenoypic variance, (iii) a vector for the population sizes, (iv) a vector for the mean phenotype of the breeders, (v) (if available) a vector of the phenotypic variances among breeders. Several time series (e.g.\ several lines submitted to similar or different selection pressures) can be analyzed. 
</p>
<p><strong>Phenomenological models</strong> The function <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> fits an autoregressive model to the variance trends, and provides a description of the dynamics of the genetic architecture that is not based on <em>a priori</em> biological mechanisms. The complexity of the model can be adjusted by adding extra autoregressive parameters.
</p>
<p><strong>Scaling</strong> The relevant scale for genetic architecture models is not necessarily the original measurement scale. Autoregressive models can be run from data e.g.\ on a log scale, but the package also provides two additional 'scales' that are specific to genetic architecture properties. <code><a href="#topic+sraAutoregHerit">sraAutoregHerit</a></code> fits the same models as <code><a href="#topic+sraAutoreg">sraAutoreg</a></code>, but considering that the dynamics of environmental variance is constrained by the quantity known as &quot;heritability&quot; (ratio between additive and phenotypic variances). <code><a href="#topic+sraAutoregEvolv">sraAutoregEvolv</a></code> proposes that both genetic and environmental variances are constrained by the mean of the population (&quot;mean-scaled evolvability&quot;). 
</p>
<p><strong>Mechanistic models</strong> Classical quantitative-genetics models are also provided. <code><a href="#topic+sraCstvar">sraCstvar</a></code> implements a &quot;constant-variance&quot; model, <code><a href="#topic+sraDrift">sraDrift</a></code> considers the effects of inbreeding on the additive genetic variance, <code><a href="#topic+sraMutation">sraMutation</a></code> introduces some mutational variance, <code><a href="#topic+sraCanalization">sraCanalization</a></code> illustrates the impact of a simple model of genetic and environmental canalization, <code><a href="#topic+sraDirepistasis">sraDirepistasis</a></code> considers directional epistasis, and <code><a href="#topic+sraSelection">sraSelection</a></code> models the effect of unavoidable natural (stabilizing) selection competing with directional artificial selection. 
</p>
<p><strong>Plotting and analysis</strong> All the models provide an objet of class <code>srafit</code> that can be plotted directly (see e.g.  <code><a href="#topic+plot.srafit">plot.srafit</a></code>). 
</p>


<h3>Author(s)</h3>

<p>Arnaud Le Rouzic 
</p>
<p>Maintainer: Arnaud Le Rouzic &lt;a.p.s.lerouzic@bio.uio.no&gt;
</p>


<h3>References</h3>

<p>Le Rouzic, A., Houle, D., and Hansen, T.F. (2011) A modelling framework for the analysis of artificial selection-response time series. Genetics Research.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########### Generating a dummy dataset ################

m &lt;- c(12,11,12,14,18,17,19,22,20,19)
v &lt;- c(53,47,97,155,150,102,65,144,179,126)
s &lt;- c(15,14,14,17,21,20,22,25,24,NA)
n &lt;- c(100,80,120,60,100,90,110,80,60,100)

########## Making a sra data set #######################
data &lt;- sraData(phen.mean=m, phen.var=v, phen.sel=s, N=n)

#################### Data Analysis ####################

# Autoregressive models
autor &lt;- sraAutoreg(data)

# AIC of the model:
AIC(autor)

# Maximum-likelihood estimates
coef(autor)

autor.herit &lt;- sraAutoregHerit(data)
autor.evolv &lt;- sraAutoregEvolv(data)

# Mechanistic models

# Constant variance
cstvar &lt;- sraCstvar(data)
# Inbreeding
drift &lt;- sraDrift(data)

# Plotting
plot(drift)
plot(drift, var=TRUE)

</code></pre>

<hr>
<h2 id='2.+20Phenomenological+20models'> Descriptive models of artificial-selection responses: auto-regressive models </h2><span id='topic+sraAutoreg'></span><span id='topic+sraAutoregLog'></span><span id='topic+sraAutoregHerit'></span><span id='topic+sraAutoregEvolv'></span>

<h3>Description</h3>

<p>The <code>sraAutoreg</code> functions are wrappers for the maximum-likelihood optimization function <code><a href="stats4.html#topic+mle">mle</a></code>. They propose descriptive models for the dynamics of genetic architectures of different complexities based on an auto-regressive framework, additional parameters corresponding to different generation lags. The model can also be fit considering logatithmic, &quot;heritability&quot; and &quot;evolvability&quot; scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sraAutoreg(sradata, active = c(FALSE, TRUE, FALSE, FALSE), 
	start = NULL, fixed = NULL, negative.k = FALSE, 
	rand = 0, rep = 1, ...)
sraAutoregLog(sradata, active = c(FALSE, TRUE, FALSE, FALSE), 
	start = NULL, fixed = NULL, negative.k = FALSE, 
	rand = 0, rep = 1, ...)
sraAutoregHerit(sradata, active = c(FALSE, TRUE, FALSE, FALSE), 
	start = NULL, fixed = NULL, negative.k = FALSE, 
	rand = 0, rep = 1, ...)
sraAutoregEvolv(sradata, active = c(FALSE, TRUE, FALSE, FALSE), 
	start = NULL, fixed = NULL, negative.k = FALSE, 
	rand = 0, rep = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="2.+2B20Phenomenological+2B20models_+3A_sradata">sradata</code></td>
<td>
<p> A data object generated by <code><a href="#topic+sraData">sraData</a></code>. </p>
</td></tr>
<tr><td><code id="2.+2B20Phenomenological+2B20models_+3A_active">active</code></td>
<td>
<p> A vector of four booleans, corresponding to the active lags for both genetic and environmental variances (see Details). By default, only lag 1 is active, corresponding to an exponential change of the variances.</p>
</td></tr>
<tr><td><code id="2.+2B20Phenomenological+2B20models_+3A_start">start</code></td>
<td>
<p> A named list of starting values for the convergence algorithm. <code>NULL</code> is allowed and lets the function <code><a href="#topic+sraStartingvalues">sraStartingvalues</a></code> calculating a (hopefully) educated guess on the starting values. See Details. </p>
</td></tr>
<tr><td><code id="2.+2B20Phenomenological+2B20models_+3A_fixed">fixed</code></td>
<td>
<p> A named list of the parameters that have to be kept constant. <code>NULL</code> is allowed. </p>
</td></tr>
<tr><td><code id="2.+2B20Phenomenological+2B20models_+3A_negative.k">negative.k</code></td>
<td>
<p> Whether or not the k parameters can take negative values. Negtive values for k lead to more complex likelihood functions, and the resulting dynamics may display cyclic patterns.</p>
</td></tr>
<tr><td><code id="2.+2B20Phenomenological+2B20models_+3A_rand">rand</code></td>
<td>
<p> Amount of randomness for the starting values. Useful in case of convergence issues. Although this variable can take any positive value, reasonable figures should not exceed 0.2. </p>
</td></tr>
<tr><td><code id="2.+2B20Phenomenological+2B20models_+3A_rep">rep</code></td>
<td>
<p> Number of convergence attempts. When the likelihood function is complex, which is often the case when the number of parameters exceeds 6 to 8, convergence may often fail or end up on a local maximum. When <code>rep</code> &gt; 1, several attempts are made from different starting values (the amount of randomness for the starting values being set by the <code>rand</code> parameter), and the best fit (highest likelihood) is returned. Setting high values of <code>rep</code> may slow down significantly the convergence process. In practice, 10 to 30 repetitions with <code>rand</code> = 0.1  are generally enough to ensure convergence. </p>
</td></tr>
<tr><td><code id="2.+2B20Phenomenological+2B20models_+3A_...">...</code></td>
<td>
<p> Additional parameters to be passed to <code><a href="stats4.html#topic+mle">mle</a></code>, and thus to <code><a href="stats.html#topic+optim">optim</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Model</strong>
</p>
<p>The following summarizes the models developed in Le Rouzic et al. 2010. 
</p>
<p>The mean of the population <code class="reqn">\mu</code> changes according to the Lande equation (Lande and Arnold 1983):
</p>
<p style="text-align: center;"><code class="reqn">\mu(t+1) = \mu(t) + VarA(t)*\beta(t),</code>
</p>

<p>where <code class="reqn">\beta(t)</code> is the selection gradient at generation t.
</p>
<p>The genetic architecture models predict the dynamics of a parameter P as:
</p>
<p style="text-align: center;"><code class="reqn">P(t+1) = k0 + k1*P(t) + k2*P(t-1) + k3*P(t-2)</code>
</p>

<p>Models with time lags &gt; 3 could be easily implemented, but convergence issues increase with the number of parameters. The first time points are calculated as if <code class="reqn">P(t&lt;1)=P(1)</code>, e.g. <code class="reqn">P(3) = k0 + k1*P(2) + k2*P(1) + k3*P(1)</code>. 
</p>
<p>Each model considers the dynamics of two independent parameters, one related to the additive genetic variance (<code class="reqn">VarA</code>), one related to the residual (environmental) variance <code class="reqn">VarE</code> (which actually also accounts for all non-additive genetic variance). 
</p>
<p>The default model <code>sraAutoreg</code> considers directly the dynamics of <code class="reqn">VarA</code> (parameters: <code>kA0</code>, <code>kA1</code>, <code>kA2</code>, and <code>kA3</code>) and the dynamics of <code class="reqn">VarE</code> (parameters <code>kE0</code>, <code>kE1</code>, <code>kE2</code>, and <code>kE3</code>).
</p>
<p>The log scale turns a multiplicative trait into an additive one, and is particularly relevant for ratio-scale traits (i.e. most quantitative traits such as size, fertility, etc). The original data is transformed assuming log-normality, and the likelihood is computed based on the log-normal density function. 
</p>
<p>The &quot;heritability&quot; model <code>sraAutoregHerit</code> focuses on the dynamics of <code class="reqn">h^2=VarA/(VarA+VarE)</code>, described by the parameters <code>kA0</code>, <code>kA1</code>, <code>kA2</code>, and <code>kA3</code>, and considers that <code>kE0</code>, <code>kE1</code>, <code>kE2</code>, and <code>kE3</code> describe the dynamics of the phenotypic variance <code class="reqn">VarP=VarA+VarE</code>. Therefore, <code class="reqn">VarE</code> is constrained both by the dynamics of <code class="reqn">VarP</code> and the independent dynamics of <code class="reqn">h^2</code>. 
</p>
<p>The &quot;evolvability&quot; model considers that <code>kA0</code>, <code>kA1</code>, <code>kA2</code>, and <code>kA3</code> describe the dynamics of <code class="reqn">IA(t) = VarA(t)/(\mu(t)^2)</code>, and <code>kE0</code>, <code>kE1</code>, <code>kE2</code>, and <code>kE3</code> the dynamics of <code class="reqn">IE(t) = VarE(t)/(\mu(t)^2)</code>. 
</p>
<p><strong>Shortcut for active and inactive parameters</strong>
</p>
<p>The user will often have to fit models of different complexity. This can be achieve by manipulating the <code>active</code> vector. <code>c(FALSE,FALSE,FALSE,FALSE)</code> corresponds to a constant-variance model (no dynamic parameter), <code>c(TRUE,FALSE,FALSE,FALSE)</code> to a case in which only <code>kA0</code> and <code>kE0</code> are active, <code>c(TRUE,TRUE,FALSE,FALSE)</code> to active parameters for lags 0 and 1 only, etc. The total number of parameters in the model will be <code class="reqn">3+2*x</code>, where <code class="reqn">x</code> is the number of <code>TRUE</code> in the vector <code>active</code>.
</p>
<p>To bypass the constrains of this shortcut, it is possible to specify the active and inactive parameters through the list of starting values. A combination such as <code>active=c(TRUE,FALSE,TRUE,</code><code>FALSE)</code>, <code>start=list(kA1=0,kE3=NA)</code>, <code>fixed=list(kE2=1)</code> will lead to a model with 8 active parameters (<code>mu0</code>, <code>varA0</code>, <code>varE0</code>, <code>kA0</code>, <code>kE0</code>, <code>kA1</code> (which starting value will be 0), <code>kA2</code>, and <code>kE3</code> (which starting value, specified as <code>NA</code>, will be determined via the function <code><a href="#topic+sraStartingvalues">sraStartingvalues</a></code>. All other parameters are fixed. 
</p>
<p><strong>Parameterization</strong>
</p>
<p>The models thus involve up to 11 parameters: three initial values (<code class="reqn">\mu(1)</code>, <code class="reqn">VarA(1)</code> and <code class="reqn">VarE(1)</code>), four parameters to describe the dynamics of the additive variance (or relative variable such as <code class="reqn">IA</code> or <code class="reqn">h^2</code>) (<code>kA0</code>, <code>kA1</code>, <code>kA2</code>, and <code>kA3</code>), and four parameters for the environmental variance (or <code class="reqn">IE</code>, or <code class="reqn">h^2</code>): <code>kE0</code>, <code>kE1</code>, <code>kE2</code>, and <code>kE3</code>. To make numerical convergence more efficient, the following parameterization was implemented: parameters <code>mu0</code>, <code>logvarA0</code> and <code>logvarE0</code> correspond to the estimates of the initial values of, respectively, the population mean, the logarithm of the additive variance, and the logarithm of the environmental variance. The parameters <code>kA0</code> and <code>kE0</code> are calculated as relative to the initial values of the dynamic variable, e.g. <code>relativekA0</code> = <code class="reqn">k0A/VarA(1)</code> (so that <code>relativekA0</code> has the same unit and the same order of magnitude as <code>kA1</code>, <code>kA2</code> and <code>kA3</code>).
</p>


<h3>Value</h3>

<p>The functions return objects of class <code>srafit</code>, a list containing information about the model, the data, and the parameter estimates. Some standard <span class="rlang"><b>R</b></span> functions can be applied to the object, including <code>AIC</code> (<code><a href="#topic+AIC.srafit">AIC.srafit</a></code>), <code>logLik</code> (<code><a href="#topic+logLik.srafit">logLik.srafit</a></code>), <code>vcov</code> (<code><a href="#topic+vcov.srafit">vcov.srafit</a></code>), <code>coef</code> (<code><a href="#topic+coef.srafit">coef.srafit</a></code>) <code>confint</code> (<code><a href="#topic+confint.srafit">confint.srafit</a></code>), and <code>plot</code> (<code><a href="#topic+plot.srafit">plot.srafit</a></code>).
</p>


<h3>Author(s)</h3>

<p> Arnaud Le Rouzic </p>


<h3>References</h3>

 
<p>Le Rouzic, A., Houle, D., and Hansen, T.F. (2011) A modelling framework for the analysis of artificial selection-response time series. Genetics Research. 
</p>
<p>Lande, R., and Arnold, S. (1983) The measurement of selection on correlated characters. Evolution 37:1210-1226.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sraCstvar">sraCstvar</a></code>, <code><a href="#topic+sraDrift">sraDrift</a></code> and all other mechanistic models, <code><a href="#topic+sraAutoregTsMinuslogL">sraAutoregTsMinuslogL</a></code> and <code><a href="#topic+sraAutoregTimeseries">sraAutoregTimeseries</a></code> for some details about the internal functions, <code><a href="#topic+AIC.srafit">AIC.srafit</a></code>, <code><a href="#topic+logLik.srafit">logLik.srafit</a></code>, <code><a href="#topic+vcov.srafit">vcov.srafit</a></code>, <code><a href="#topic+coef.srafit">coef.srafit</a></code>, <code><a href="#topic+confint.srafit">confint.srafit</a></code>, <code><a href="#topic+plot.srafit">plot.srafit</a></code> for the analysis of the results. </p>


<h3>Examples</h3>

<pre><code class='language-R'># Making the example reproducible
########### Generating a dummy dataset ################

m &lt;- c(12,11,12,14,18,17,19,22,20,19)
v &lt;- c(53,47,97,155,150,102,65,144,179,126)
s &lt;- c(15,14,14,17,21,20,22,25,24,NA)
n &lt;- c(100,80,120,60,100,90,110,80,60,100)

########## Making a sra data set #######################
data &lt;- sraData(phen.mean=m, phen.var=v, phen.sel=s, N=n)

#################### Data Analysis ####################

# Autoregressive models
autor &lt;- sraAutoreg(data)

# Details of the model:
AIC(autor)
coef(autor)
plot(autor)
plot(autor, var=TRUE)

# Alternative scales
autor.log &lt;- sraAutoregLog(data)
autor.herit &lt;- sraAutoregHerit(data)
autor.evolv &lt;- sraAutoregEvolv(data)


# Changes in the complexity of the model:
autor0 &lt;- sraAutoreg(data, active=c(TRUE,TRUE,FALSE,FALSE))
                         
# In case of convergence issues
autor1 &lt;- sraAutoreg(data, active=c(TRUE,TRUE,TRUE,TRUE), rep=2, rand=0.1)

</code></pre>

<hr>
<h2 id='3.+20Mechanistic+20models'> Descriptive models of artificial-selection responses: quantitative genetics models </h2><span id='topic+sraCstvar'></span><span id='topic+sraDrift'></span><span id='topic+sraMutation'></span><span id='topic+sraCanalization'></span><span id='topic+sraCanalizationOpt'></span><span id='topic+sraSelection'></span><span id='topic+sraDirepistasis'></span>

<h3>Description</h3>

<p>The sra functions for mechanistic model are wrappers for the maximum-likelihood optimization routine <code><a href="stats4.html#topic+mle">mle</a></code>. They implement classical quantitative genetics models, fit them to artificial-selection time series, and provide estimates of e.g. the effective population size, the mutational variance, the strength of genetic / environmental canalization, the directionality and strength of epistasis, etc., given some assumptions about the properties of the genetic architecture. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sraCstvar(sradata, start=NULL, fixed=NULL, macroE=FALSE, Bulmer=TRUE, ...)
sraDrift(sradata, start=NULL, fixed=NULL, macroE=FALSE, Bulmer=TRUE, ...)
sraMutation(sradata, start=NULL, fixed=NULL, macroE=FALSE, Bulmer=TRUE, ...)
sraCanalization(sradata, start=NULL, fixed=NULL, macroE=FALSE, Bulmer=TRUE, ...)
sraCanalizationOpt(sradata, start=NULL, fixed=NULL, macroE=FALSE, Bulmer=TRUE, ...)
sraSelection(sradata, start=NULL, fixed=NULL, macroE=FALSE, Bulmer=TRUE, ...)
sraDirepistasis(sradata, start=NULL, fixed=NULL, macroE=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="3.+2B20Mechanistic+2B20models_+3A_sradata">sradata</code></td>
<td>
<p> A data object generated by <code><a href="#topic+sraData">sraData</a></code>. </p>
</td></tr>
<tr><td><code id="3.+2B20Mechanistic+2B20models_+3A_start">start</code></td>
<td>
<p> A named list of starting values for the convergence algorithm. <code>NA</code> is allowed and lets the function <code><a href="#topic+sraStartingvalues">sraStartingvalues</a></code> calculating a (hopefully) educated guess on the starting values. Parameters are described below. </p>
</td></tr>
<tr><td><code id="3.+2B20Mechanistic+2B20models_+3A_fixed">fixed</code></td>
<td>
<p> A named list of the parameters that have to be kept constant. <code>NA</code> is not allowed. </p>
</td></tr>
<tr><td><code id="3.+2B20Mechanistic+2B20models_+3A_macroe">macroE</code></td>
<td>
<p> Whether or not macro-environmental effects (random deviation of the phenotypic mean each generation) should be included. This might have some side effects. </p>
</td></tr>
<tr><td><code id="3.+2B20Mechanistic+2B20models_+3A_bulmer">Bulmer</code></td>
<td>
<p> Whether or not the impact of linkage disequilibrium (Bulmer effect) due to selection on variance should be accounted for. </p>
</td></tr>
<tr><td><code id="3.+2B20Mechanistic+2B20models_+3A_...">...</code></td>
<td>
<p> Additional parameters to be passed to <code><a href="stats4.html#topic+mle">mle</a></code>, and thus to <code><a href="stats.html#topic+optim">optim</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions (except <code>sraDirepistasis</code>) rely on the same underlying model, and thus simply provide convenient shortcuts for different sets of parameters to fit. 
</p>
<p><code>mu0</code> is the initial phenotype of the population.
</p>
<p><code>logvarA0</code> is the logarithm of the initial additive variance in the population.
</p>
<p><code>logvarE0</code> is the logarithm of the initial environmental variance in the population.
</p>
<p><code>logNe</code> is the logarithm of the effective population size.
</p>
<p><code>logn</code> is the logarithm of the effective number of loci.
</p>
<p><code>logvarM</code> is the logarithm of the mutational variance.
</p>
<p><code>kc</code> and <code>kg</code> are the strength of environmental and genetic canalization, respectively. 
</p>
<p><code>o</code> corresponds to the 'optimum' phenotype. When fixed and set to <code>NA</code>, <code>o</code> is identical to <code>mu0</code>. For convenience, the same optimum is used for environmental canalization, genetic canalization and natural stabilizing selection. 
</p>
<p><code>s</code> corresponds to the strength of natural selection.
</p>
<p><code>logvarepsilon</code> is the logarithm of the variance of the epistatic coefficient (<code class="reqn">\varepsilon</code>). This parameter is fixed by default, since it is unlikely that realistic data sets contain enough information to estimate it properly. 
</p>
<p>The dynamic model that is fitted (except of the directional epistasis, detailed in the next paragraph) is:
</p>
<p style="text-align: center;"><code class="reqn">\mu(t+1) = \mu(t) + VarA(t) * (\beta(t) + s \delta(t)) </code>
</p>

<p style="text-align: center;"><code class="reqn">VarA(t+1) = VarM + VarA(t) * (1 - 1/(2*N_e)) * e^{kg*(|\delta(t+1)| - |\delta(t)|)}</code>
</p>

<p style="text-align: center;"><code class="reqn">VarE(t+1) = VarE(t) * e^{kc*|\delta(t)|}</code>
</p>

<p><code class="reqn">\mu(1)</code>, <code class="reqn">VarA(1)</code> and <code class="reqn">varE(1)</code> are parameters of the model, <code class="reqn">\beta(t)</code> is the selection gradient, calculated for each generation from the data set, and <code class="reqn">\delta(t) = \mu(t) - o</code>. 
</p>
<p>The directional epistasis model has its own setting:
</p>
<p style="text-align: center;"><code class="reqn">\mu(t+1) = \mu(t) + varA(t) * \beta(t)</code>
</p>

<p style="text-align: center;"><code class="reqn">VarA(t+1) = VarA(t) + 2*\beta(t)*\varepsilon*VarA(t)^2</code>
</p>

<p style="text-align: center;"><code class="reqn">VarE(t+1) = VarE(1) + (\varepsilon^2 + Var\varepsilon)*VarA(t)^2</code>
</p>

<p>Where <code>epsilon</code> is a key parameter, representing the directionality of epistasis (Hansen and Wagner 2001, Carter et al. 2005). The properties of the likelihood function when epsilon varies makes numerical convergence tricky, and the function <code>SRAdirepistasis</code> actually performs two model fits: one for positive epsilons (the estimated parameter being <code>logepsilon</code>) and one for negative epsilons (estimating <code>logminusepsilon</code>). The likelihood of both models is then compared, and the best model is returned, providing either <code>logepsilon</code> or <code>logminusepsilon</code>. Although part of the model, the parameter <code>logvarepsilon</code> appeared to affect environmental variance only weakly, and its estimation is problematic in most cases. 
</p>
<p>These models are extensively described in le Rouzic et al 2010. 
</p>


<h3>Value</h3>

<p>The functions return objects of class <code>srafit</code>, a list containing information about the model, the data, and the parameter estimates. Some standard <span class="rlang"><b>R</b></span> functions can be applied to the object, including <code>AIC</code> (<code><a href="#topic+AIC.srafit">AIC.srafit</a></code>), <code>logLik</code> (<code><a href="#topic+logLik.srafit">logLik.srafit</a></code>), <code>vcov</code> (<code><a href="#topic+vcov.srafit">vcov.srafit</a></code>), <code>coef</code> (<code><a href="#topic+coef.srafit">coef.srafit</a></code>) <code>confint</code> (<code><a href="#topic+confint.srafit">confint.srafit</a></code>), and <code>plot</code> (<code><a href="#topic+plot.srafit">plot.srafit</a></code>).
</p>


<h3>Author(s)</h3>

<p> Arnaud Le Rouzic </p>


<h3>References</h3>

 
<p>Carter, A.J.R., Hermisson, J. and Hansen, T.F. (2005) The role of epistatic genetic interactions in the response to selection and the evolution of evolvability. Theor. Pop. Biol. 68, 179-196. 
</p>
<p>Hansen, T.F. and Wagner, G.P. (2001) Modelling genetic architecture: a multilinear theory of gene interaction. Theor. Pop. biol. 59, 61-86.
</p>
<p>Le Rouzic, A., Houle, D., and Hansen, T.F. (2010) A modelling framework for the analysis of artificial selection-response time series. in prep.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sraAutoreg">sraAutoreg</a></code>, <code><a href="#topic+sraAutoregHerit">sraAutoregHerit</a></code> and <code><a href="#topic+sraAutoregEvolv">sraAutoregEvolv</a></code> for phenomenological models, <code><a href="#topic+sraAutoregTsMinuslogL">sraAutoregTsMinuslogL</a></code> and <code><a href="#topic+sraAutoregTimeseries">sraAutoregTimeseries</a></code> for some details about the internal functions, <code><a href="#topic+AIC.srafit">AIC.srafit</a></code>, <code><a href="#topic+logLik.srafit">logLik.srafit</a></code>,<code><a href="#topic+vcov.srafit">vcov.srafit</a></code>, <code><a href="#topic+coef.srafit">coef.srafit</a></code>, <code><a href="#topic+confint.srafit">confint.srafit</a></code>, <code><a href="#topic+plot.srafit">plot.srafit</a></code> for the analysis of the results. </p>


<h3>Examples</h3>

<pre><code class='language-R'>########### Generating a dummy dataset ################

m &lt;- c(12,11,12,14,18,17,19,22,20,19)
v &lt;- c(53,47,97,155,150,102,65,144,179,126)
s &lt;- c(15,14,14,17,21,20,22,25,24,NA)
n &lt;- c(100,80,120,60,100,90,110,80,60,100)

########## Making a sra data set #######################
data &lt;- sraData(phen.mean=m, phen.var=v, phen.sel=s, N=n)

#################### Data Analysis ####################

cstvar &lt;- sraCstvar(data)
drift &lt;- sraDrift(data)
direpi &lt;- sraDirepistasis(data)

# In case of convergence problems, better starting values can be provided:
direpi &lt;- sraDirepistasis(data, start=list(mu0=10, logvarA0=log(20), logvarE0=NA), 
fixed=list(logNe=log(50)))

plot(cstvar)

AIC(direpi)
</code></pre>

<hr>
<h2 id='4.+20Methods+20for+20srafit+20objects+20'> Overloaded functions for &quot;srafit&quot; objects </h2><span id='topic+AIC.srafit'></span><span id='topic+coef.srafit'></span><span id='topic+logLik.srafit'></span><span id='topic+confint.srafit'></span><span id='topic+vcov.srafit'></span>

<h3>Description</h3>

<p>The functions return the output expected from the corresponding <span class="rlang"><b>R</b></span> functions, applied to an object of class <code>srafit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'srafit'
logLik(object, ...)
## S3 method for class 'srafit'
AIC(object, ...)
## S3 method for class 'srafit'
coef(object, ...)
## S3 method for class 'srafit'
confint(object, ...)
## S3 method for class 'srafit'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="4.+2B20Methods+2B20for+2B20srafit+2B20objects+2B20_+3A_object">object</code></td>
<td>
<p> An object of class <code>srafit</code>. </p>
</td></tr>
<tr><td><code id="4.+2B20Methods+2B20for+2B20srafit+2B20objects+2B20_+3A_...">...</code></td>
<td>
<p> Any additional parameters to the corresponding functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence intervals are calculated from the estimate standard errors, and are thus different (less precise) from what would be calculated from the profile likelihood. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sraAutoreg">sraAutoreg</a></code>, <code><a href="#topic+sraCstvar">sraCstvar</a></code> and other mechanistic models, <code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>########### Generating a dummy dataset ################

m &lt;- c(12,11,12,14,18,17,19,22,20,19)
v &lt;- c(53,47,97,155,150,102,65,144,179,126)
s &lt;- c(15,14,14,17,21,20,22,25,24,NA)
n &lt;- c(100,80,120,60,100,90,110,80,60,100)

########## Making a sra data set #######################
data &lt;- sraData(phen.mean=m, phen.var=v, phen.sel=s, N=n)

#################### Data Analysis ####################

cstvar &lt;- sraCstvar(data)

AIC(cstvar)
logLik(cstvar)
coef(cstvar)
confint(cstvar)
vcov(cstvar)
</code></pre>

<hr>
<h2 id='5.+20plot.srafit'> Plotting &quot;srafit&quot; objects </h2><span id='topic+plot.srafit'></span><span id='topic+sraPlotMean'></span><span id='topic+sraPlotMeanResid'></span><span id='topic+sraPlotVar'></span><span id='topic+sraPlotVarResid'></span><span id='topic+sraPlotlegend'></span><span id='topic+sraFormatlegend'></span>

<h3>Description</h3>

<p>These functions plot in a nice way the content of objects of class <code>srafit</code>, the result of <code>sra</code> model fitting. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'srafit'
 plot(x, series = levels(x$data$rep), resid = FALSE, 
			variance = FALSE, ...)
sraPlotMean(srafit, series=levels(srafit$data$rep), legend=TRUE, 
               		xlim=NULL, ylim=NULL, xlab=NULL, ylab=NULL, pch=1, ...)
sraPlotMeanResid(srafit, series=levels(srafit$data$rep))
sraPlotVar (srafit, series=levels(srafit$data$rep), legend=TRUE, 
            		xlim=NULL, ylim=NULL, xlab=NULL, ylab=NULL, pch=1, ...)
sraPlotVarResid (srafit, series=levels(srafit$data$rep))
sraPlotlegend(labels, estimates, AIC=NULL, confint=NULL, 
                       	location="topleft")
sraFormatlegend(names, values, AIC=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="5.+2B20plot.srafit_+3A_x">x</code></td>
<td>
<p> An object of class <code>srafit</code> </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_srafit">srafit</code></td>
<td>
<p> An object of class <code>srafit</code> </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_series">series</code></td>
<td>
<p> The identifier (<code>rep</code>) of the time series that should be plotted. By default, all series are displayed. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_resid">resid</code></td>
<td>
<p> Whether or not the residuals (data - model expectation) should be displayed. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_variance">variance</code></td>
<td>
<p> If <code>TRUE</code>, the phenotypic variance is displayed. If <code>FALSE</code> (default), the phenotypic mean is displayed. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_legend">legend</code></td>
<td>
<p> If <code>TRUE</code>, a legend with the parameter estimates is displayed. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_xlim">xlim</code></td>
<td>
<p> Same meaning as in <code><a href="base.html#topic+plot">plot</a></code>. If <code>NULL</code>, a (hopefully) nice range is calculated. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_ylim">ylim</code></td>
<td>
<p> Same meaning as in <code><a href="base.html#topic+plot">plot</a></code>. If <code>NULL</code>, a (hopefully) nice range is calculated.</p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_xlab">xlab</code></td>
<td>
<p> Same meaning as in <code><a href="base.html#topic+plot">plot</a></code>. If <code>NULL</code>, a default label is provided. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_ylab">ylab</code></td>
<td>
<p> Same meaning as in <code><a href="base.html#topic+plot">plot</a></code>. If <code>NULL</code>, a default label is provided. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_pch">pch</code></td>
<td>
<p> Same meaning as in <code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_labels">labels</code></td>
<td>
<p> Formatted labels of the names of the estimates in the legend. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_estimates">estimates</code></td>
<td>
<p> Values of the parameter estimates. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_aic">AIC</code></td>
<td>
<p> Value of the AIC. If <code>NULL</code>, the AIC is not added to the legend. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_confint">confint</code></td>
<td>
<p> Confidence intervals of the parameters. If <code>NULL</code> (default), they are not displayed in the legend. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_location">location</code></td>
<td>
<p> Location of the legend, corresponding to <code>x</code> in <code><a href="graphics.html#topic+legend">legend</a></code>. </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_names">names</code></td>
<td>
<p> Names of the parameters (as defined in the models). </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_values">values</code></td>
<td>
<p> Values of the parameter estimates (as defined in the models). </p>
</td></tr>
<tr><td><code id="5.+2B20plot.srafit_+3A_...">...</code></td>
<td>
<p> For <code>plot.srafit</code>, <code>sraPlotMean</code>, <code>sraPlotVar</code>: Additional parameters for the function <code><a href="base.html#topic+plot">plot</a></code>. For <code>sraFormatlegend</code>: Additional parameters to <code><a href="base.html#topic+format">format</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only function that should be used by the end user is <code>plot.srafit</code>. 
</p>


<h3>Author(s)</h3>

<p> Arnaud Le Rouzic </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sraAutoreg">sraAutoreg</a></code>, <code><a href="#topic+sraCstvar">sraCstvar</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>########### Generating a dummy dataset ################

m &lt;- c(12,11,12,14,18,17,19,22,20,19)
v &lt;- c(53,47,97,155,150,102,65,144,179,126)
s &lt;- c(15,14,14,17,21,20,22,25,24,NA)
n &lt;- c(100,80,120,60,100,90,110,80,60,100)

########## Making a sra data set #######################
data &lt;- sraData(phen.mean=m, phen.var=v, phen.sel=s, N=n)

cstvar &lt;- sraCstvar(data)


plot(cstvar)
plot(cstvar, xlim=c(3,9))
plot(cstvar, var=TRUE, ylab="This is a custom Y axis label")
plot(cstvar, resid=TRUE, legend=FALSE, main="Constant variance model fit")
</code></pre>

<hr>
<h2 id='6.+20sraData'> Generates an object of class &quot;sradata&quot;, necessary to run the models provided by the sra package. </h2><span id='topic+sraData'></span>

<h3>Description</h3>

<p>The data necessary to analyse selection response time series are, for each generation, (i) the mean phenotype of the population, (ii) the phenotypic variance, (iii) the mean of the breeders, and (iv) the population size. These data have to be grouped into an object of class &quot;sradata&quot;, which can be provided to the sra analysis functions such as <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> or <code><a href="#topic+sraCstvar">sraCstvar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sraData(phen.mean, phen.var, phen.sel, var.sel=NULL, N=NULL, 
  gen=NULL, rep=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="6.+2B20sraData_+3A_phen.mean">phen.mean</code></td>
<td>
<p> The vector of phenotypic means. </p>
</td></tr>
<tr><td><code id="6.+2B20sraData_+3A_phen.var">phen.var</code></td>
<td>
<p> The vector of phenotypic variances. </p>
</td></tr>  
<tr><td><code id="6.+2B20sraData_+3A_phen.sel">phen.sel</code></td>
<td>
<p> The vector of the mean phenotype of breeders. Can be <code>NA</code> for the last generations. </p>
</td></tr> 
<tr><td><code id="6.+2B20sraData_+3A_var.sel">var.sel</code></td>
<td>
<p> The vector of the phenotypic variances if breeders. If not provided (<code>NULL</code>), the vector is estimated assuming truncation selection and normal distribution of phenotypes.</p>
</td></tr>
<tr><td><code id="6.+2B20sraData_+3A_n">N</code></td>
<td>
<p> The vector of population size for each generation (before selection). </p>
</td></tr>
<tr><td><code id="6.+2B20sraData_+3A_gen">gen</code></td>
<td>
<p> The generation numbers. Useful when several times series are provided. </p>
</td></tr>
<tr><td><code id="6.+2B20sraData_+3A_rep">rep</code></td>
<td>
<p> The repetition identification. Useful when several time series are provided. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If not provided, the default value for <code>N</code> is 100. Incorrect values for <code>N</code> will affect the likelihood value and the maximum-likelihood estimates.
</p>
<p><code>gen</code> will be assumed to vary from 1 to the maximum number of generations by default. 
</p>
<p>If more than one time series are provided, it is dangerous not to specify <code>gen</code> or <code>rep</code>. <code>rep</code> can be any unique identifier. For instance, fro two times series of 3 generations each, <code>gen</code> can be <code>c(1,2,3,1,2,3)</code> and <code>rep</code> can be <code>c("up","up","up","down","down","down")</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>sradata</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sraAutoreg">sraAutoreg</a></code>, <code><a href="#topic+sraCstvar">sraCstvar</a></code>, and other mechanistic models, <code><a href="#topic+sraAutoregTimeseries">sraAutoregTimeseries</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>########### Generating a dummy dataset ################

m &lt;- c(12,11,12,14,18,17,19,22,20,19)
v &lt;- c(53,47,97,155,150,102,65,144,179,126)
s &lt;- c(15,14,14,17,21,20,22,25,24,NA)
n &lt;- c(100,80,120,60,100,90,110,80,60,100)

########## Making a sra data set #######################
data &lt;- sraData(phen.mean=m, phen.var=v, phen.sel=s, N=n)

</code></pre>

<hr>
<h2 id='Expected+20time+20series+20dynamics'> Expected dynamics for different SRA models (internal functions). </h2><span id='topic+sraAutoregTimeseries'></span><span id='topic+sraAutoregHeritTimeseries'></span><span id='topic+sraAutoregEvolvTimeseries'></span><span id='topic+sraTimeseries'></span><span id='topic+sraEpiTimeseries'></span>

<h3>Description</h3>

<p>Each genetic architecture model leads to an expected dynamics for the mean and the variance of the population, given a selection pressure. These functions provide the expectation of the models, which are used (i) to fit the model by maximum-likelihood, and (ii) to provide the theoretical dynamics of the best model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sraAutoregTimeseries(beta, delta=rep(0, length(beta)), mu0=0, logvarA0=0, logvarE0=0, 
	relativekA0=0, kA1=1, kA2=0, kA3=0, 
	relativekE0=0, kE1=1, kE2=0, kE3=0, threshold=1e-10, 
	logrelativekA0=NULL, logrelativekE0=NULL, 
	logkA1=NULL, logkE1=NULL, logkA2=NULL, logkE2=NULL, logkA3=NULL, logkE3=NULL)
sraAutoregHeritTimeseries(beta, delta=rep(0, length(beta)), mu0=0, logith20=0, logvarP0=0,
	relativekA0=0, kA1=1, kA2=0, kA3=0, 
	relativekE0=0, kE1=1, kE2=0, kE3=0, threshold=1e-10, 
	logrelativekA0=NULL, logrelativekE0=NULL, 
	logkA1=NULL, logkE1=NULL, logkA2=NULL, logkE2=NULL, logkA3=NULL, logkE3=NULL)
sraAutoregEvolvTimeseries(beta, delta=rep(0, length(beta)), mu0=0, logIA0=0, logIE0=0, 
	relativekA0=0, kA1=1, kA2=0, kA3=0, 
	relativekE0=0, kE1=1, kE2=0, kE3=0, threshold=1e-10, 
	logrelativekA0=NULL, logrelativekE0=NULL, 
	logkA1=NULL, logkE1=NULL, logkA2=NULL, logkE2=NULL, logkA3=NULL, logkE3=NULL)
sraTimeseries(beta, delta=rep(0, length(beta)), mu0=0, logvarA0=0, logvarE0=0, 
	logNe=log(100), logn=log(1e+10), logvarM=log(1e-20), kc=0, kg=0, o=mu0, s=0)
sraEpiTimeseries(beta, delta=rep(0, length(beta)), mu0=0, logvarA0=0, logvarE0=0, 
	logNe=log(1000), logvarM=log(1.e-20), 
	logepsilon=0, logminusepsilon=-99, logvarepsilon=0)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_beta">beta</code></td>
<td>
<p> The vector of the selection gradients for all generations. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_delta">delta</code></td>
<td>
<p> The vector of the relative selection strenght on variance. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_mu0">mu0</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logvara0">logvarA0</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logvare0">logvarE0</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_relativeka0">relativekA0</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_ka1">kA1</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_ka2">kA2</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_ka3">kA3</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_relativeke0">relativekE0</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_ke1">kE1</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_ke2">kE2</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_ke3">kE3</code></td>
<td>
<p>See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logrelativeka0">logrelativekA0</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logka1">logkA1</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logka2">logkA2</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logka3">logkA3</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logrelativeke0">logrelativekE0</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logke1">logkE1</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logke2">logkE2</code></td>
<td>
<p> See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logke3">logkE3</code></td>
<td>
<p>See <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logne">logNe</code></td>
<td>
<p>See <code><a href="#topic+sraCstvar">sraCstvar</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logn">logn</code></td>
<td>
<p>See <code><a href="#topic+sraCstvar">sraCstvar</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logvarm">logvarM</code></td>
<td>
<p>See <code><a href="#topic+sraCstvar">sraCstvar</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_kc">kc</code></td>
<td>
<p>See <code><a href="#topic+sraCstvar">sraCstvar</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_kg">kg</code></td>
<td>
<p>See <code><a href="#topic+sraCstvar">sraCstvar</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_o">o</code></td>
<td>
<p>See <code><a href="#topic+sraCstvar">sraCstvar</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logepsilon">logepsilon</code></td>
<td>
<p>See <code><a href="#topic+sraCstvar">sraCstvar</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logminusepsilon">logminusepsilon</code></td>
<td>
<p>See <code><a href="#topic+sraCstvar">sraCstvar</a></code> for the description of the model parameters. </p>
</td></tr>
<tr><td><code id="Expected+2B20time+2B20series+2B20dynamics_+3A_logvarepsilon">logvarepsilon</code></td>
<td>
<p>See <code><a href="#topic+sraCstvar">sraCstvar</a></code> for the description of the model parameters. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>sraEpitimeseries</code>, the value of the directionality of epistasis (epsilon) should be provided either by <code>logepsilon</code> when epsilon is positive, or by <code>logminusepsilon</code> when epsilon is negative. One of them should therefore be <code>NA</code>. 
</p>


<h3>Value</h3>

<p>The functions return a list of vectors: <code>means</code> for the phenotypic average, <code>varA</code>, <code>varE</code> and <code>varP</code> for the additive, residual, and phenotypic variances respectively. 
</p>


<h3>Note</h3>

<p> These functions are not designed to be called directly by the end user. The models implemented in the time series functions are described in <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> and <code><a href="#topic+sraCstvar">sraCstvar</a></code>. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sraAutoreg">sraAutoreg</a></code>, <code><a href="#topic+sraCstvar">sraCstvar</a></code> </p>

<hr>
<h2 id='sraMakeObject'>Creates an object of class &quot;srafit&quot; (internal function) </h2><span id='topic+sraMakeObject'></span>

<h3>Description</h3>

<p>The content of an object of class <code>srafit</code> correponding to several models is very similar; this function initializes a new object and performs basic instructions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sraMakeObject(sradata, model, start, fixed, FUNtimeseries)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sraMakeObject_+3A_sradata">sradata</code></td>
<td>
<p> A data object generated by <code><a href="#topic+sraData">sraData</a></code>. </p>
</td></tr>
<tr><td><code id="sraMakeObject_+3A_model">model</code></td>
<td>
<p> The result of the call of <code><a href="stats4.html#topic+mle">mle</a></code>. </p>
</td></tr>
<tr><td><code id="sraMakeObject_+3A_start">start</code></td>
<td>
<p> The list of the starting values (for the function to know which parameters were active). </p>
</td></tr>
<tr><td><code id="sraMakeObject_+3A_fixed">fixed</code></td>
<td>
<p> The list of the fixed values. </p>
</td></tr>
<tr><td><code id="sraMakeObject_+3A_funtimeseries">FUNtimeseries</code></td>
<td>
<p> The time series function, one among those listed in <code><a href="#topic+sraAutoregTimeseries">sraAutoregTimeseries</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>srafit</code> (see <code><a href="#topic+sraAutoreg">sraAutoreg</a></code> for more details).
</p>


<h3>Note</h3>

<p> This function should not be called by the end user. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sraAutoreg">sraAutoreg</a></code>, <code><a href="#topic+sraCstvar">sraCstvar</a></code>, and other mechanistic models, <code><a href="#topic+sraAutoregTimeseries">sraAutoregTimeseries</a></code>. </p>

<hr>
<h2 id='sraMinuslogL'> Calculation of the likelihood of time series (internal functions) </h2><span id='topic+sraMinuslogL'></span><span id='topic+sraMinuslogL.log'></span><span id='topic+sraAutoregTsMinuslogL'></span><span id='topic+sraAutoregTsMinuslogL.log'></span>

<h3>Description</h3>

<p>These functions are used internally by the sra package to compute the likelihood of the dataset given a specific model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sraMinuslogL(sradata, FUNtimeseries = sraAutoregTimeseries, 
	Bulmer=TRUE, logvarME=log(1e-20), ...)
sraMinuslogL.log(sradata.log, FUNtimeseries = sraAutoregTimeseries, 
	Bulmer=TRUE, logvarME=log(1e-20), ...)
sraAutoregTsMinuslogL(data.mean, data.var, data.N, 
	theor.mean, theor.var, logvarME=log(1e-20))
sraAutoregTsMinuslogL.log(data.mean, data.var, data.N, 
	theor.mean, theor.var, logvarME=log(1e-20))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sraMinuslogL_+3A_sradata">sradata</code></td>
<td>
<p> A data object generated by <code><a href="#topic+sraData">sraData</a></code>. </p>
</td></tr>
<tr><td><code id="sraMinuslogL_+3A_sradata.log">sradata.log</code></td>
<td>
<p> A data object generated by <code><a href="#topic+sraData">sraData</a></code> after log transformation. </p>
</td></tr>
<tr><td><code id="sraMinuslogL_+3A_funtimeseries">FUNtimeseries</code></td>
<td>
<p> The corresponding function to compute the expected time series (one of those listed in <code><a href="#topic+sraAutoregTimeseries">sraAutoregTimeseries</a></code>. </p>
</td></tr>
<tr><td><code id="sraMinuslogL_+3A_bulmer">Bulmer</code></td>
<td>
<p> Whether or not the impact of linkage disequilibrium (Bulmer effect) due to selection on variance should be accounted for. </p>
</td></tr>
<tr><td><code id="sraMinuslogL_+3A_logvarme">logvarME</code></td>
<td>
<p> (log)-macroenvironmental variance, which is not included in the models themself (no impact on the expected time series), but can be estimated through its effect on the residual variance.</p>
</td></tr>
<tr><td><code id="sraMinuslogL_+3A_...">...</code></td>
<td>
<p> The parameters of the model. </p>
</td></tr>
<tr><td><code id="sraMinuslogL_+3A_data.mean">data.mean</code></td>
<td>
<p> The vector of the mean phenotypes, from the data. </p>
</td></tr>
<tr><td><code id="sraMinuslogL_+3A_data.var">data.var</code></td>
<td>
<p> The vector of the phenotypic variances, from the data. </p>
</td></tr>
<tr><td><code id="sraMinuslogL_+3A_data.n">data.N</code></td>
<td>
<p> The vector of the population sizes, from the data. </p>
</td></tr>
<tr><td><code id="sraMinuslogL_+3A_theor.mean">theor.mean</code></td>
<td>
<p> The vector of the theoretical mean phenotypes, from the model. </p>
</td></tr>
<tr><td><code id="sraMinuslogL_+3A_theor.var">theor.var</code></td>
<td>
<p> The vector of the theoretical phenotypic variances, from the model. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sraAutoregTsMinuslogL</code> returns the minus log likelihood of a single time series (e.g. one selection line). <code>sraMinuslogL</code>
returns the minus log likelihood of the whole dataset, including all repetitions. The &quot;.log&quot; version of these functions compute the likelihood when sradata has been log-transformed. 
</p>


<h3>Note</h3>

<p> These functions are not designed to be called by the end user. </p>


<h3>References</h3>

<p> Le Rouzic, A., Houle, D., and Hansen, T.F. (2011) A modelling framework for the analysis of artificial selection-response time series. Genetics Research. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sraAutoreg">sraAutoreg</a></code>, <code><a href="#topic+sraCstvar">sraCstvar</a></code>, and all other mechanistic models, <code><a href="#topic+sraAutoregTimeseries">sraAutoregTimeseries</a></code>. </p>

<hr>
<h2 id='sraStartingvalues'>Provides reasonable starting values for sra model fit (internal function) </h2><span id='topic+sraStartingvalues'></span>

<h3>Description</h3>

<p>These functions aim at providing educated starting values for the parameters to estimate through sra models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sraStartingvalues(parameter, sradata, rand=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sraStartingvalues_+3A_parameter">parameter</code></td>
<td>
<p> A character string corresponding to the name of a parameter to consider, e.g. <code>"mu0"</code> or <code>"logepsilon"</code>. Depending on the parameter, starting values can be estimated from the dataset, or a reasonable arbitrary value may be returned. </p>
</td></tr>
<tr><td><code id="sraStartingvalues_+3A_sradata">sradata</code></td>
<td>
<p> A data object generated by <code><a href="#topic+sraData">sraData</a></code>. </p>
</td></tr>
<tr><td><code id="sraStartingvalues_+3A_rand">rand</code></td>
<td>
<p> Amount of randomness to add to the parameter value. Setting a value different from 0 leads to a different answer for each function call, which can be useful when trying different vectors of staring values to solve problematic convergence cases. In general, values &gt; 0.2 provide starting values that are too extreme to be useful. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> The end user has no particular reason to call these functions directly. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sraAutoreg">sraAutoreg</a></code>, <code><a href="#topic+sraCstvar">sraCstvar</a></code>, and other mechanistic models. </p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
