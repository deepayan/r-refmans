<!DOCTYPE html><html lang="en"><head><title>Help for package GSD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GSD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjmatrix'><p>Weighted Adjacency Matrix</p></a></li>
<li><a href='#gextrema'><p>Finding Local Extrema of a Graph Signal</p></a></li>
<li><a href='#gfdecomp'><p>Graph Fourier Decomposition</p></a></li>
<li><a href='#gftplot'><p>Plot of the absolute values of the graph Fourier coefficients vs the eigenvalues</p></a></li>
<li><a href='#ginterpolating'><p>Interpolation of a Graph Signal</p></a></li>
<li><a href='#gplot'><p>Plot of a Graph Signal</p></a></li>
<li><a href='#gsignal'><p>Graph Object with a Signal</p></a></li>
<li><a href='#gsmoothing'><p>Smoothing a Graph Signal</p></a></li>
<li><a href='#gsubway'><p>Seoul Subway Ridership Data</p></a></li>
<li><a href='#sgemd'><p>Statistical Graph Empirical Mode Decomposition</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graph Signal Decomposition</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Hyeonglae Cho [aut],
  Hee-Seok Oh [aut],
  Donghoh Kim [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Donghoh Kim &lt;donghoh.kim@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Graph signals residing on the vertices of a graph have recently gained prominence in research in various fields. Many methodologies have been proposed to analyze graph signals by adapting classical signal processing tools. Recently, several notable graph signal decomposition methods have been proposed, which include graph Fourier decomposition based on graph Fourier transform, graph empirical mode decomposition, and statistical graph empirical mode decomposition. This package efficiently implements multiscale analysis applicable to various fields, and offers an effective tool for visualizing and decomposing graph signals. For the detailed methodology, see Ortega et al. (2018) &lt;<a href="https://doi.org/10.1109%2FJPROC.2018.2820126">doi:10.1109/JPROC.2018.2820126</a>&gt;, Shuman et al. (2013) &lt;<a href="https://doi.org/10.1109%2FMSP.2012.2235192">doi:10.1109/MSP.2012.2235192</a>&gt;, Tremblay et al. (2014) <a href="https://www.eurasip.org/Proceedings/Eusipco/Eusipco2014/HTML/papers/1569922141.pdf">https://www.eurasip.org/Proceedings/Eusipco/Eusipco2014/HTML/papers/1569922141.pdf</a>, and Cho et al. (2024) "Statistical graph empirical mode decomposition by graph denoising and boundary treatment".</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), igraph, Matrix, EbayesThresh, ggplot2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-04 14:02:32 UTC; donghohkim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 20:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjmatrix'>Weighted Adjacency Matrix</h2><span id='topic+adjmatrix'></span>

<h3>Description</h3>

<p>This function produces weighted adjacency matrix by Gaussian kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjmatrix(xy, method = c("dist", "neighbor"), alpha) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjmatrix_+3A_xy">xy</code></td>
<td>
<p>matrix or data.frame containing vertex coordinate <code>x</code>, <code>y</code>.</p>
</td></tr>
<tr><td><code id="adjmatrix_+3A_method">method</code></td>
<td>
<p>When <code>method="dist"</code>, edge weights are calculated by Gaussian kernel for connecting vertices within distance <code>alpha</code>.
When <code>method="neighbor"</code>, edge weights are calcaulated by Gaussian kernel for connecting <code>alpha</code> neighboring vertices.</p>
</td></tr>
<tr><td><code id="adjmatrix_+3A_alpha">alpha</code></td>
<td>
<p>specifies distance between vertices when <code>method="dist"</code>, and the number of neighboring vertices when <code>method="neighbor"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a sparse weighted adjacency matrix by Gaussian kernel based on the distance between vertices.
</p>


<h3>Value</h3>

<p>a sparse weighted adjacency matrix
</p>


<h3>References</h3>

<p>Zeng, J., Cheung, G., and Ortega, A. (2017). Bipartite approximation for graph wavelet signal decomposition. <em>IEEE Transactions on Signal Processing</em>, <b>65(20)</b>, 5466&ndash;5480.
<a href="https://doi.org/10.1109/TSP.2017.2733489">doi:10.1109/TSP.2017.2733489</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsignal">gsignal</a></code>, <code><a href="#topic+gplot">gplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define vertex coordinate
x &lt;- y &lt;- seq(0, 1, length=30)
xy &lt;- expand.grid(x=x, y=y)

## weighted adjacency matrix by Gaussian kernel 
## for connecting vertices within distance 0.04
A1 &lt;- adjmatrix(xy, method = "dist", 0.04) 

## weighted adjacency matrix by Gaussian kernel 
## for connecting seven neighboring vertices
A2 &lt;- adjmatrix(xy, method="neighbor", 7)
</code></pre>

<hr>
<h2 id='gextrema'>Finding Local Extrema of a Graph Signal</h2><span id='topic+gextrema'></span>

<h3>Description</h3>

<p>This function finds the local extrema of a graph signal identifying the edge between neighboring vertices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gextrema(ad_mat, signal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gextrema_+3A_ad_mat">ad_mat</code></td>
<td>
<p>an weighted adjacency matrix.</p>
</td></tr>
<tr><td><code id="gextrema_+3A_signal">signal</code></td>
<td>
<p>a graph signal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the local extrema of a graph signal identifying the edge between neighboring vertices. 
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>maxima_list</code></td>
<td>
<p>vertex index of local maxima of a <code>signal</code>.</p>
</td></tr>
<tr><td><code>minima_list</code></td>
<td>
<p>vertex index of local minima of a <code>signal</code>.</p>
</td></tr>
<tr><td><code>n_extrema</code></td>
<td>
<p>the number of local maxima and local minima of a <code>signal</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tremblay, N., Borgnat, P., and Flandrin, P. (2014). Graph empirical mode decomposition. <em>22nd European Signal Processing Conference (EUSIPCO)</em>, 2350&ndash;2354.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ginterpolating">ginterpolating</a></code>, <code><a href="#topic+gsmoothing">gsmoothing</a></code>, <code><a href="#topic+sgemd">sgemd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies

## define vertex coordinate
x &lt;- y &lt;- seq(0, 1, length=30)
xy &lt;- expand.grid(x=x, y=y)

## weighted adjacency matrix by Gaussian kernel 
## for connecting vertices within distance 0.04
A &lt;- adjmatrix(xy, method = "dist", 0.04) 

## signal
# high-frequency component
signal1 &lt;- rep(sin(12.5*pi*x - 1.25*pi), 30)

# low-frequency component
signal2 &lt;- rep(sin(5*pi*x - 0.5*pi), 30)

# composite signal
signal0 &lt;- signal1 + signal2

# noisy signal with SNR(signal-to-noise ratio)=5
signal &lt;- signal0 + rnorm(900, 0, sqrt(var(signal0) / 5)) 

# graph with signal
gsig &lt;- gsignal(vertex = cbind(xy, signal), edge = A, edgetype = "matrix")

# local extrema
gextrema(A, signal)

# local extrema using graph object
gextrema(as_adjacency_matrix(gsig, attr="weight"), V(gsig)$z)
</code></pre>

<hr>
<h2 id='gfdecomp'>Graph Fourier Decomposition</h2><span id='topic+gfdecomp'></span>

<h3>Description</h3>

<p>This function performs the graph Fourier decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfdecomp(graph, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gfdecomp_+3A_graph">graph</code></td>
<td>
<p>an <span class="pkg">igraph</span> graph object with vertex attributes of coordinates <code>x</code>, <code>y</code>, a signal <code>z</code>, and edge attribute of <code>weight</code>.</p>
</td></tr>
<tr><td><code id="gfdecomp_+3A_k">K</code></td>
<td>
<p>specifies the number of frequency components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the graph Fourier decomposition.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>fc</code></td>
<td>
<p>list of frequency components according to the frequencies with <code>fc[[1]]</code> the lowest-frequency component.</p>
</td></tr>
<tr><td><code>residue</code></td>
<td>
<p>residue signal after extracting frequency components.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ortega, A., Frossard, P., Kovačević, J., Moura, J. M. F., and Vandergheynst, P. (2018).
Graph signal processing: overview, challenges, and applications. <em>Proceedings of the IEEE 106</em>, 808&ndash;828.
<a href="https://doi.org/10.1109/JPROC.2018.2820126">doi:10.1109/JPROC.2018.2820126</a>
</p>
<p>Shuman, D. I., Narang, S. K., Frossard, P., Ortega, A., and Vandergheynst, P. (2013). The emerging field of signal processing on graphs: Extending high-dimensional data analysis to networks and other irregular domains. <em>IEEE Signal Processing Magazine</em>, <b>30(3)</b>, 83&ndash;98.
<a href="https://doi.org/10.1109/MSP.2012.2235192">doi:10.1109/MSP.2012.2235192</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sgemd">sgemd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies

## define vertex coordinate
x &lt;- y &lt;- seq(0, 1, length=30)
xy &lt;- expand.grid(x=x, y=y)

## weighted adjacency matrix by Gaussian kernel 
## for connecting vertices within distance 0.04
A &lt;- adjmatrix(xy, method = "dist", 0.04) 

## signal
# high-frequency component
signal1 &lt;- rep(sin(12.5*pi*x - 1.25*pi), 30)

# low-frequency component
signal2 &lt;- rep(sin(5*pi*x - 0.5*pi), 30)

# composite signal
signal0 &lt;- signal1 + signal2

# noisy signal with SNR(signal-to-noise ratio)=5
signal &lt;- signal0 + rnorm(900, 0, sqrt(var(signal0) / 5)) 

# graph with signal
gsig &lt;- gsignal(vertex = cbind(xy, signal), edge = A, edgetype = "matrix")

# display of absolute values of the graph Fourier coefficients vs the eigenvalues 
gftplot(gsig)
gftplot(gsig, K=5, size=3)
outgft &lt;- gftplot(gsig, K=5, plot=FALSE)
outgft$eigenvalues

# graph Fourier decomposition 
out &lt;- gfdecomp(gsig, K=4)
names(out)

# display of a signal, the extracted low- and high-frequency components by GFD
gplot(gsig, size=3) 
gplot(gsig, out$fc[[1]]+out$fc[[2]], size=3) 
gplot(gsig, out$fc[[3]]+out$fc[[4]], size=3) 
</code></pre>

<hr>
<h2 id='gftplot'>Plot of the absolute values of the graph Fourier coefficients vs the eigenvalues</h2><span id='topic+gftplot'></span>

<h3>Description</h3>

<p>This function displays the absolute values of the graph Fourier coefficients vs the eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gftplot(graph, signal = NULL, K = NULL, size = 1, plot=TRUE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gftplot_+3A_graph">graph</code></td>
<td>
<p>an <span class="pkg">igraph</span> graph object with vertex attributes of coordinates <code>x</code>, <code>y</code>, a signal <code>z</code>, and edge attribute of <code>weight</code>.</p>
</td></tr>
<tr><td><code id="gftplot_+3A_signal">signal</code></td>
<td>
<p>specifies a signal for the graph Fourier transform.
When <code>signal=NULL</code>, a signal <code>z</code> of object <code>graph</code> is used.</p>
</td></tr>
<tr><td><code id="gftplot_+3A_k">K</code></td>
<td>
<p>specifies the number of frequency components.</p>
</td></tr>   
<tr><td><code id="gftplot_+3A_size">size</code></td>
<td>
<p>specifies point size.</p>
</td></tr>
<tr><td><code id="gftplot_+3A_plot">plot</code></td>
<td>
<p>specifies whether plot is displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays the absolute values of the graph Fourier coefficients vs the eigenvalues for <code>signal</code>.
The red color denotes the nonnegative graph Fourier coefficients, and the blue color indicates the negative graph Fourier coefficients.
</p>


<h3>Value</h3>

 
<p>If <code>plot=TRUE</code>, plot of the absolute values of the graph Fourier coefficients vs the eigenvalues for <code>signal</code> over a graph using package <span class="pkg">ggplot2</span>.
If <code>plot=FALSE</code>, a list with components:
</p>
<table role = "presentation">
<tr><td><code>absgFCoeffs</code></td>
<td>
<p>the absolute values of the graph Fourier coefficients in decreasing order.</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>the eigenvalues according to the absolute values of the graph Fourier coefficients.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gsignal">gsignal</a></code>, <code><a href="#topic+gfdecomp">gfdecomp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies

## define vertex coordinate
x &lt;- y &lt;- seq(0, 1, length=30)
xy &lt;- expand.grid(x=x, y=y)

## weighted adjacency matrix by Gaussian kernel 
## for connecting vertices within distance 0.04
A &lt;- adjmatrix(xy, method = "dist", 0.04) 

## signal
# high-frequency component
signal1 &lt;- rep(sin(12.5*pi*x - 1.25*pi), 30)

# low-frequency component
signal2 &lt;- rep(sin(5*pi*x - 0.5*pi), 30)

# composite signal
signal0 &lt;- signal1 + signal2

# noisy signal with SNR(signal-to-noise ratio)=5
signal &lt;- signal0 + rnorm(900, 0, sqrt(var(signal0) / 5)) 

# graph with signal
gsig &lt;- gsignal(vertex = cbind(xy, signal), edge = A, edgetype = "matrix")

# display a signal over graph
gplot(gsig, size=3) 

# display of absolute values of the graph Fourier coefficients vs the eigenvalues 
# for signal
gftplot(gsig)

gftplot(gsig, K=5, size=3)
out &lt;- gftplot(gsig, K=5, plot=FALSE)
names(out)

## signal3
# high-frequency component
signal11 &lt;- c(outer(sin(6*pi*x - 0.5*pi), sin(6*pi*y - 0.5*pi)))

# low-frequency component
signal22 &lt;- c(outer(sin(2*pi*x - 0.5*pi), sin(2*pi*y - 0.5*pi)))

# composite signal
signal00 &lt;- signal11 + signal22

# noisy signal
signal3 &lt;- signal00 + rnorm(900, 0, sqrt(var(signal00) / 5)) 

# display signal3 over graph
gplot(gsig, signal=signal3, size=3) 

# display of absolute values of the graph Fourier coefficients vs the eigenvalues 
# for signal3
gftplot(gsig, signal=signal3)
gftplot(gsig, signal=signal3, K=10, size=2)

</code></pre>

<hr>
<h2 id='ginterpolating'>Interpolation of a Graph Signal</h2><span id='topic+ginterpolating'></span>

<h3>Description</h3>

<p>This function interpolates a graph signal utilizing the Laplacian matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ginterpolating(ad_mat, signal, vertices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ginterpolating_+3A_ad_mat">ad_mat</code></td>
<td>
<p>an weighted adjacency matrix.</p>
</td></tr>
<tr><td><code id="ginterpolating_+3A_signal">signal</code></td>
<td>
<p>a graph signal.</p>
</td></tr>
<tr><td><code id="ginterpolating_+3A_vertices">vertices</code></td>
<td>
<p>specifies vertices for the observed signal. A signal on <code>vertices</code> and Laplacian matrix
is used for interpolating a signal outside <code>vertices</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function interpolates a graph signal utilizing the Laplacian matrix.
</p>


<h3>Value</h3>

 
<p>a signal with interpolated points.
</p>


<h3>References</h3>

<p>Ortega, A., Frossard, P., Kovačević, J., Moura, J. M. F., and Vandergheynst, P. (2018).
Graph signal processing: overview, challenges, and applications. <em>Proceedings of the IEEE 106</em>, 808&ndash;828.
<a href="https://doi.org/10.1109/JPROC.2018.2820126">doi:10.1109/JPROC.2018.2820126</a>
</p>
<p>Shuman, D. I., Narang, S. K., Frossard, P., Ortega, A., and Vandergheynst, P. (2013). The emerging field of signal processing on graphs: Extending high-dimensional data analysis to networks and other irregular domains. <em>IEEE Signal Processing Magazine</em>, <b>30(3)</b>, 83&ndash;98.
<a href="https://doi.org/10.1109/MSP.2012.2235192">doi:10.1109/MSP.2012.2235192</a>
</p>
<p>Tremblay, N., Borgnat, P., and Flandrin, P. (2014). Graph empirical mode decomposition. <em>22nd European Signal Processing Conference (EUSIPCO)</em>, 2350&ndash;2354.
</p>
<p>Zeng, J., Cheung, G., and Ortega, A. (2017). Bipartite approximation for graph wavelet signal decomposition. <em>IEEE Transactions on Signal Processing</em>, <b>65(20)</b>, 5466&ndash;5480.
<a href="https://doi.org/10.1109/TSP.2017.2733489">doi:10.1109/TSP.2017.2733489</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gextrema">gextrema</a></code>, <code><a href="#topic+gsmoothing">gsmoothing</a></code>, <code><a href="#topic+sgemd">sgemd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies

## define vertex coordinate
x &lt;- y &lt;- seq(0, 1, length=30)
xy &lt;- expand.grid(x=x, y=y)

## weighted adjacency matrix by Gaussian kernel 
## for connecting vertices within distance 0.04
A &lt;- adjmatrix(xy, method = "dist", 0.04) 

## signal
# high-frequency component
signal1 &lt;- rep(sin(12.5*pi*x - 1.25*pi), 30)

# low-frequency component
signal2 &lt;- rep(sin(5*pi*x - 0.5*pi), 30)

# composite signal
signal0 &lt;- signal1 + signal2

# noisy signal with SNR(signal-to-noise ratio)=5
signal &lt;- signal0 + rnorm(900, 0, sqrt(var(signal0) / 5)) 

# graph with signal
gsig &lt;- gsignal(vertex = cbind(xy, signal), edge = A, edgetype = "matrix")

# local extrema using graph object
extremaout &lt;- gextrema(as_adjacency_matrix(gsig, attr="weight"), V(gsig)$z)
maxima &lt;- extremaout$maxima_list; minima &lt;- extremaout$minima_list

# Interpolation of upper, lower and mean envelope
uenvelope &lt;- ginterpolating(as_adjacency_matrix(gsig, attr="weight"), 
    V(gsig)$z, maxima)
lenvelope &lt;- ginterpolating(as_adjacency_matrix(gsig, attr="weight"), 
    V(gsig)$z, minima) 
menvelope &lt;- (uenvelope + lenvelope) / 2

# display a graph signal
gplot(gsig, size=3, legend=FALSE) 

# display mean envelope
gplot(gsig, menvelope, size=3, legend=FALSE) 
</code></pre>

<hr>
<h2 id='gplot'>Plot of a Graph Signal</h2><span id='topic+gplot'></span>

<h3>Description</h3>

<p>This function displays a signal on a graph using a color palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gplot(graph, signal = NULL, size = 1, limits = range(V(graph)$z), 
    gpalette = NULL, legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gplot_+3A_graph">graph</code></td>
<td>
<p>an <span class="pkg">igraph</span> graph object with vertex attributes of coordinates <code>x</code>, <code>y</code>, a signal <code>z</code>, and edge attribute of <code>weight</code>.</p>
</td></tr>
<tr><td><code id="gplot_+3A_signal">signal</code></td>
<td>
<p>specifies a signal to be displayed over object <code>graph</code> using a color palette.
When <code>signal=NULL</code>, a signal <code>z</code> of object <code>graph</code> is used.</p>
</td></tr>
<tr><td><code id="gplot_+3A_size">size</code></td>
<td>
<p>specifies point size of vertex.</p>
</td></tr>
<tr><td><code id="gplot_+3A_limits">limits</code></td>
<td>
<p>specifies color palette limits.</p>
</td></tr>
<tr><td><code id="gplot_+3A_gpalette">gpalette</code></td>
<td>
<p>specifies a character vector of color palette. When <code>gpalette=NULL</code>, <code>c('#00008D', '#002AFF', '#00D4FF', '#2AFFD4', 
  '#FFFF00', '#FF8D00', '#FF0000')</code> is used as default palette.</p>
</td></tr>
<tr><td><code id="gplot_+3A_legend">legend</code></td>
<td>
<p>if <code>legend=FALSE</code>, the legend is not included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays a signal on a graph using a color palette.
</p>


<h3>Value</h3>

 
<p>plot of a signal over a graph using package <span class="pkg">ggplot2</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsignal">gsignal</a></code>, <code><a href="#topic+adjmatrix">adjmatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies

## define vertex coordinate
x &lt;- y &lt;- seq(0, 1, length=30)
xy &lt;- expand.grid(x=x, y=y)

## weighted adjacency matrix by Gaussian kernel 
## for connecting vertices within distance 0.04
A &lt;- adjmatrix(xy, method = "dist", 0.04) 

## signal
# high-frequency component
signal1 &lt;- rep(sin(12.5*pi*x - 1.25*pi), 30)

# low-frequency component
signal2 &lt;- rep(sin(5*pi*x - 0.5*pi), 30)

# composite signal
signal0 &lt;- signal1 + signal2

# noisy signal with SNR(signal-to-noise ratio)=5
signal &lt;- signal0 + rnorm(900, 0, sqrt(var(signal0) / 5)) 

# graph with signal
gsig &lt;- gsignal(vertex = cbind(xy, signal), edge = A, edgetype = "matrix")

# display a signal over graph with legend
gplot(gsig, size=3, legend=TRUE) 

# display a signal over graph without legend
gplotout &lt;- gplot(gsig, size=3, legend=FALSE) 
gplotout

# adding labels using ggplot2 package
gplotout + 
  theme(axis.title=element_text(), 
    plot.title=element_text(hjust = 0.5, vjust = 0)) + 
    labs(x="x", y="y", title="visualization of a composite signal")

# deleting axis title, text and ticks using ggplot2 package
gplotout + 
  theme(axis.title=element_blank(),
        axis.text=element_blank(),
        axis.ticks=element_blank())

# display high-frequency component
gplot(gsig, signal1, size=3, legend=FALSE) 

# display low-frequency component
gplot(gsig, signal2, size=3, legend=FALSE) 
</code></pre>

<hr>
<h2 id='gsignal'>Graph Object with a Signal</h2><span id='topic+gsignal'></span>

<h3>Description</h3>

<p>This function constructs an <span class="pkg">igraph</span> graph object with several vertex and edge attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsignal(vertex, edge, edgetype = c("matrix", "list"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsignal_+3A_vertex">vertex</code></td>
<td>
<p>matrix or data.frame containing vertex information.
The first two columns are vertex coordinate <code>x</code>, <code>y</code>, and the third column is a signal <code>z</code> on each vertex.</p>
</td></tr>
<tr><td><code id="gsignal_+3A_edge">edge</code></td>
<td>
<p>When <code>edgetype="matrix"</code>, a square weighted adjacency matrix. 
This can be a sparse matrix created with <span class="pkg">Matrix</span> package.
When <code>edgetype="list"</code>, matrix or data.frame of edge list with three columns.
The first two columns are edge lists and the third column is an edge weight.</p>
</td></tr>
<tr><td><code id="gsignal_+3A_edgetype">edgetype</code></td>
<td>
<p>edges and weights information are provided by <code>"matrix"</code> or <code>"list"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function constructs an <span class="pkg">igraph</span> graph object with <code>vertex</code> and <code>edge</code> attributes.
</p>


<h3>Value</h3>

 
<p>an <span class="pkg">igraph</span> graph object. The vertex attributes are vertex coordinate <code>x</code>, <code>y</code>, and a signal <code>z</code> on each vertex.
The edge attribute is <code>weight</code>.
These vertex and edge attributes can be identified by <code>names(vertex_attr())</code> and <code>names(edge_attr())</code>,
and are accessible by <code>V()</code>, <code>E()</code>, <code>as_edgelist()</code>, <code>as_adjacency_matrix()</code> or other <span class="pkg">igraph</span> functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjmatrix">adjmatrix</a></code>, <code><a href="#topic+gplot">gplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies

## define vertex coordinate
x &lt;- y &lt;- seq(0, 1, length=30)
xy &lt;- expand.grid(x=x, y=y)

## weighted adjacency matrix by Gaussian kernel 
## for connecting vertices within distance 0.04
A &lt;- adjmatrix(xy, method = "dist", 0.04) 

## signal
# high-frequency component
signal1 &lt;- rep(sin(12.5*pi*x - 1.25*pi), 30)

# low-frequency component
signal2 &lt;- rep(sin(5*pi*x - 0.5*pi), 30)

# composite signal
signal0 &lt;- signal1 + signal2

# noisy signal with SNR(signal-to-noise ratio)=5
signal &lt;- signal0 + rnorm(900, 0, sqrt(var(signal0) / 5)) 

# graph with signal
gsig &lt;- gsignal(vertex = cbind(xy, signal), edge = A, edgetype = "matrix")

# vertex and edge attribute
names(vertex_attr(gsig)); names(edge_attr(gsig))

# edge list
# as_edgelist(gsig, name=FALSE)

# weighted adjacency matrix
# as_adjacency_matrix(gsig, attr="weight")

# display a noisy graph signal 
gplot(gsig, size=3)

# display a composite graph signal 
gplot(gsig, signal0, size=3)

# display high-frequency component
gplot(gsig, signal1, size=3)

# display low-frequency component
gplot(gsig, signal2, size=3)
</code></pre>

<hr>
<h2 id='gsmoothing'>Smoothing a Graph Signal</h2><span id='topic+gsmoothing'></span>

<h3>Description</h3>

<p>This function denoises a graph signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsmoothing(ad_mat, signal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsmoothing_+3A_ad_mat">ad_mat</code></td>
<td>
<p>an weighted adjacency matrix.</p>
</td></tr>
<tr><td><code id="gsmoothing_+3A_signal">signal</code></td>
<td>
<p>a graph signal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function denoises a graph signal utilizing the graph Fourier transform and empirical Bayes thresholding.
</p>


<h3>Value</h3>

 
<p>a denoised signal.
</p>


<h3>References</h3>

<p>Ortega, A., Frossard, P., Kovačević, J., Moura, J. M. F., and Vandergheynst, P. (2018).
Graph signal processing: overview, challenges, and applications. <em>Proceedings of the IEEE 106</em>, 808&ndash;828.
<a href="https://doi.org/10.1109/JPROC.2018.2820126">doi:10.1109/JPROC.2018.2820126</a>
</p>
<p>Shuman, D. I., Narang, S. K., Frossard, P., Ortega, A., and Vandergheynst, P. (2013). The emerging field of signal processing on graphs: Extending high-dimensional data analysis to networks and other irregular domains. <em>IEEE Signal Processing Magazine</em>, <b>30(3)</b>, 83&ndash;98.
<a href="https://doi.org/10.1109/MSP.2012.2235192">doi:10.1109/MSP.2012.2235192</a>
</p>
<p>Johnstone, I. and Silverman, B.~W. (2004).
Needles and straw in haystacks: empirical Bayes estimates of possibly sparse sequences. <em>The Annals of Statistics</em>, <b>32</b>, 594&ndash;1649.
<a href="https://doi.org/10.1214/009053604000000030">doi:10.1214/009053604000000030</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gextrema">gextrema</a></code>, <code><a href="#topic+ginterpolating">ginterpolating</a></code>, <code><a href="#topic+sgemd">sgemd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies

## define vertex coordinate
x &lt;- y &lt;- seq(0, 1, length=30)
xy &lt;- expand.grid(x=x, y=y)

## weighted adjacency matrix by Gaussian kernel 
## for connecting vertices within distance 0.04
A &lt;- adjmatrix(xy, method = "dist", 0.04) 

## signal
# high-frequency component
signal1 &lt;- rep(sin(12.5*pi*x - 1.25*pi), 30)

# low-frequency component
signal2 &lt;- rep(sin(5*pi*x - 0.5*pi), 30)

# composite signal
signal0 &lt;- signal1 + signal2

# noisy signal with SNR(signal-to-noise ratio)=5
signal &lt;- signal0 + rnorm(900, 0, sqrt(var(signal0) / 5)) 

# graph with signal
gsig &lt;- gsignal(vertex = cbind(xy, signal), edge = A, edgetype = "matrix")

# local extrema using graph object
extremaout &lt;- gextrema(as_adjacency_matrix(gsig, attr="weight"), V(gsig)$z)
maxima &lt;- extremaout$maxima_list; minima &lt;- extremaout$minima_list

# Interpolation of upper, lower and mean envelope
uenvelope &lt;- ginterpolating(as_adjacency_matrix(gsig, attr="weight"), 
  V(gsig)$z, maxima)
lenvelope &lt;- ginterpolating(as_adjacency_matrix(gsig, attr="weight"), 
  V(gsig)$z, minima) 

# smoothing upper, lower and mean envelope
suenvelope &lt;- gsmoothing(A, uenvelope)
slenvelope &lt;- gsmoothing(A, lenvelope) 

smenvelope &lt;- (suenvelope + slenvelope) / 2

# display a graph signal
gplot(gsig, size=3, legend=FALSE) 

# display mean envelope
gplot(gsig, smenvelope, size=3, legend=FALSE) 
</code></pre>

<hr>
<h2 id='gsubway'>Seoul Subway Ridership Data</h2><span id='topic+gsubway'></span>

<h3>Description</h3>

<p>This <span class="pkg">igraph</span> graph object represents the number of subway passengers in Seoul, Korea for January 2021.
Consider the subway stations as vertices and railroads between the stations as the edges. 
The number of passengers for each station is regarded as the graph signal.
Seoul subway ridership data can be obtained at <code>https://www.seoulmetro.co.kr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gsubway)
</code></pre>


<h3>Format</h3>

<p><span class="pkg">igraph</span> graph object. The vertex attributes are longitude <code>x</code>, latitude <code>y</code>, and the number of passengers <code>z</code> for each station.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gsubway)

# attributes
names(vertex_attr(gsubway)); names(edge_attr(gsubway)); names(graph_attr(gsubway))

# standardizing the graph signal
V(gsubway)$z &lt;- c(scale(V(gsubway)$z))
 
# statistical graph empirical mode decomposition (SGEMD) with boundary treatment
out &lt;- sgemd(gsubway, nimf=1, smoothing=TRUE, boundary=TRUE, connweight="graph")

# display of a signal, denoised signal by SGEMD
gplot(gsubway, size=3) 
gplot(gsubway, out$residue, size=3) 
</code></pre>

<hr>
<h2 id='sgemd'>Statistical Graph Empirical Mode Decomposition</h2><span id='topic+sgemd'></span>

<h3>Description</h3>

<p>This function performs statistical graph empirical mode decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgemd(graph, nimf, smoothing = FALSE, smlevels = c(1),  
    boundary = FALSE, reflperc = 0.3, reflaver = FALSE, 
    connperc = 0.05, connweight = "boundary", 
    tol = 0.1^3, max.sift = 50, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sgemd_+3A_graph">graph</code></td>
<td>
<p>an <span class="pkg">igraph</span> graph object with vertex attributes of coordinates <code>x</code>, <code>y</code>, a signal <code>z</code>, and edge attribute of <code>weight</code>.</p>
</td></tr>
<tr><td><code id="sgemd_+3A_nimf">nimf</code></td>
<td>
<p>specifies the maximum number of intrinsic mode functions (IMF).</p>
</td></tr>
<tr><td><code id="sgemd_+3A_smoothing">smoothing</code></td>
<td>
<p>specifies whether intrinsic mode functions are constructed by interpolating or smoothing envelopes. 
When <code>smoothing =TRUE</code>, denoise envelopes utilizing the graph Fourier transform and empirical Bayes thresholding.</p>
</td></tr>
<tr><td><code id="sgemd_+3A_smlevels">smlevels</code></td>
<td>
<p>specifies which level of the IMF is obtained by smoothing other than interpolation.</p>
</td></tr>
<tr><td><code id="sgemd_+3A_boundary">boundary</code></td>
<td>
<p>When <code>boundary=TRUE</code>, a given graph is reflected for boundary treatment.</p>
</td></tr> 
<tr><td><code id="sgemd_+3A_reflperc">reflperc</code></td>
<td>
<p>expand a graph by adding specified percentage of a graph at the boundary when <code>boundary=TRUE</code>.</p>
</td></tr>
<tr><td><code id="sgemd_+3A_reflaver">reflaver</code></td>
<td>
<p>specifies the method assigning signal to reflected vertices. 
When <code>reflaver=TRUE</code>, the signal on reflected vertices is produced by averaging signals on neighboring vertices on a given graph.
Otherwise, signal on reflected vertices is the same to the signal on a given graph.</p>
</td></tr>
<tr><td><code id="sgemd_+3A_connperc">connperc</code></td>
<td>
<p>specifies percentage of a graph for connecting a given graph and reflected graph when <code>boundary=TRUE</code>.</p>
</td></tr> 
<tr><td><code id="sgemd_+3A_connweight">connweight</code></td>
<td>
<p>specifies the method assigning the edge weights for connecting a given graph and reflected graph 
when <code>boundary=TRUE</code>.
The edge weights are calculated by Gaussian kernel considering the relative distance between vertices.
When <code>connweight="graph"</code>, the relative distance is calculated based on the maximum distance of all the neighboring edges 
of a given graph.
When <code>connweight="boundary"</code>, the relative distance is calculated based on the maximum distance of the connected vertices 
between a given graph and reflected graph.</p>
</td></tr>
<tr><td><code id="sgemd_+3A_tol">tol</code></td>
<td>
<p>tolerance for stopping rule of sifting.</p>
</td></tr>
<tr><td><code id="sgemd_+3A_max.sift">max.sift</code></td>
<td>
<p>the maximum number of sifting.</p>
</td></tr> 
<tr><td><code id="sgemd_+3A_verbose">verbose</code></td>
<td>
<p>specifies whether sifting steps are displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs statistical graph empirical mode decomposition utilizing extrema detection of a graph signal.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>imf</code></td>
<td>
<p>list of IMF's according to the frequencies with <code>imf[[1]]</code> the highest-frequency IMF.</p>
</td></tr>
<tr><td><code>residue</code></td>
<td>
<p>residue signal after extracting IMF's.</p>
</td></tr>
<tr><td><code>nimf</code></td>
<td>
<p>the number of IMF's.</p>
</td></tr> 
<tr><td><code>n_extrema</code></td>
<td>
<p>Each row specifies the number of local maxima and local minima of the remaining signal after extracting the i-th IMF. 
The first row represents the number of local maxima and local minima of a given signal.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Huang, N. E., Shen, Z., Long, S. R., Wu, M. C., Shih, H. H., Zheng, Q., Yen, N.- C., Tung, C. C., and Liu, H. H. (1998). The empirical mode decomposition and the Hilbert spectrum for nonlinear and non-stationary time series analysis. <em>Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences</em>, <b>454(1971)</b>, 903–-995.
<a href="https://doi.org/10.1098/rspa.1998.0193">doi:10.1098/rspa.1998.0193</a>
</p>
<p>Johnstone, I. and Silverman, B.~W. (2004).
Needles and straw in haystacks: empirical Bayes estimates of possibly sparse sequences. <em>The Annals of Statistics</em>, <b>32</b>, 594&ndash;1649.
<a href="https://doi.org/10.1214/009053604000000030">doi:10.1214/009053604000000030</a>
</p>
<p>Kim, D., Kim, K. O., and Oh, H.-S. (2012a). Extending the scope of empirical mode decomposition by smoothing. <em>EURASIP Journal on Advances in Signal Processing</em>, <b>2012</b>, 1&ndash;17.
<a href="https://doi.org/10.1186/1687-6180-2012-168">doi:10.1186/1687-6180-2012-168</a>
</p>
<p>Kim, D., Park, M., and Oh, H.-S. (2012b). Bidimensional statistical empirical mode decomposition. <em>IEEE Signal Processing Letters</em>, <b>19(4)</b>, 191&ndash;194.
<a href="https://doi.org/10.1109/LSP.2012.2186566">doi:10.1109/LSP.2012.2186566</a>
</p>
<p>Ortega, A., Frossard, P., Kovačević, J., Moura, J. M. F., and Vandergheynst, P. (2018).
Graph signal processing: overview, challenges, and applications. <em>Proceedings of the IEEE 106</em>, 808&ndash;828.
<a href="https://doi.org/10.1109/JPROC.2018.2820126">doi:10.1109/JPROC.2018.2820126</a>
</p>
<p>Shuman, D. I., Narang, S. K., Frossard, P., Ortega, A., and Vandergheynst, P. (2013). The emerging field of signal processing on graphs: Extending high-dimensional data analysis to networks and other irregular domains. <em>IEEE Signal Processing Magazine</em>, <b>30(3)</b>, 83&ndash;98.
<a href="https://doi.org/10.1109/MSP.2012.2235192">doi:10.1109/MSP.2012.2235192</a>
</p>
<p>Tremblay, N., Borgnat, P., and Flandrin, P. (2014). Graph empirical mode decomposition. <em>22nd European Signal Processing Conference (EUSIPCO)</em>, 2350&ndash;2354
</p>
<p>Zeng, J., Cheung, G., and Ortega, A. (2017). Bipartite approximation for graph wavelet signal decomposition. <em>IEEE Transactions on Signal Processing</em>, <b>65(20)</b>, 5466&ndash;5480.
<a href="https://doi.org/10.1109/TSP.2017.2733489">doi:10.1109/TSP.2017.2733489</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gextrema">gextrema</a></code>, <code><a href="#topic+gsmoothing">gsmoothing</a></code>, <code><a href="#topic+ginterpolating">ginterpolating</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies

## define vertex coordinate
x &lt;- y &lt;- seq(0, 1, length=30)
xy &lt;- expand.grid(x=x, y=y)

## weighted adjacency matrix by Gaussian kernel 
## for connecting vertices within distance 0.04
A &lt;- adjmatrix(xy, method = "dist", 0.04) 

## signal
# high-frequency component
signal1 &lt;- rep(sin(12.5*pi*x - 1.25*pi), 30)

# low-frequency component
signal2 &lt;- rep(sin(5*pi*x - 0.5*pi), 30)

# composite signal
signal0 &lt;- signal1 + signal2

# noisy signal with SNR(signal-to-noise ratio)=5
signal &lt;- signal0 + rnorm(900, 0, sqrt(var(signal0) / 5)) 

# graph with signal
gsig &lt;- gsignal(vertex = cbind(xy, signal), edge = A, edgetype = "matrix")

# graph empirical mode decomposition (GEMD) without boundary treatment
out1 &lt;- sgemd(gsig, nimf=3, smoothing=FALSE, boundary=FALSE)

# denoised signal by GEMD 
dsignal1 &lt;- out1$imf[[2]] + out1$imf[[3]] + out1$residue


# statistical graph empirical mode decomposition (SGEMD) with boundary treatment
out2 &lt;- sgemd(gsig, nimf=3, smoothing=TRUE, boundary=TRUE)
names(out2)

# denoised signal by SGEMD 
dsignal2 &lt;- out2$imf[[2]] + out2$imf[[3]] + out2$residue

# display of a signal, denoised signal, imf2, imf3 and residue by SGEMD
gplot(gsig, size=3) 
gplot(gsig, dsignal2, size=3) 
gplot(gsig, out2$imf[[2]], size=3) 
gplot(gsig, out2$imf[[3]], size=3) 
gplot(gsig, out2$residue, size=3) 

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
