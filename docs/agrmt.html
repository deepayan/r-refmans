<!DOCTYPE html><html lang="en"><head><title>Help for package agrmt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {agrmt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agrmt-package'><p>Calculate Concentration and Dispersion in Ordered Rating Scales</p></a></li>
<li><a href='#agreement'><p>Calculate van der Eijk's measure of agreement A</p></a></li>
<li><a href='#agreementError'><p>Simulated coding error for agreement A</p></a></li>
<li><a href='#ajus'><p>Classify distributions</p></a></li>
<li><a href='#ajusCheck'><p>Sensitivity test for AJUS</p></a></li>
<li><a href='#ajusPlot'><p>Plot vector with AJUS type</p></a></li>
<li><a href='#BerryMielke'><p>Calculate IOV</p></a></li>
<li><a href='#BlairLacy'><p>Calculate l</p></a></li>
<li><a href='#censor'><p>Censor helper function</p></a></li>
<li><a href='#collapse'><p>Reduces a vector to a frequency vector</p></a></li>
<li><a href='#compareAgreement'><p>Compare agreement A with and without simulated coding error</p></a></li>
<li><a href='#compareValues'><p>Compares two values</p></a></li>
<li><a href='#concentration'><p>Measures concentration</p></a></li>
<li><a href='#consensus'><p>Calculate Tastle and Wierman's measure of consensus</p></a></li>
<li><a href='#consensus.variance'><p>Approximate variance of consensus</p></a></li>
<li><a href='#D.variance'><p>Approximate variance of Leik's D</p></a></li>
<li><a href='#disper'><p>Measures distance</p></a></li>
<li><a href='#dispersion'><p>Measures dispersion</p></a></li>
<li><a href='#dsquared'><p>Calculate d-squared</p></a></li>
<li><a href='#entropy'><p>Calculate Shannon entropy</p></a></li>
<li><a href='#expand'><p>Expands a frequency vector to a vector</p></a></li>
<li><a href='#isd'><p>Classify changes over time</p></a></li>
<li><a href='#Kvalseth'><p>Calculate Kvalseth's COV</p></a></li>
<li><a href='#l.variance'><p>Approximate variance of Blair and Lacy's l</p></a></li>
<li><a href='#Leik'><p>Calculate ordinal dispersion</p></a></li>
<li><a href='#lsquared'><p>Calculate l-squared</p></a></li>
<li><a href='#lsquared.variance'><p>Approximate variance of Blair and Lacy's lsquared</p></a></li>
<li><a href='#minnz'><p>Non-zero minimum</p></a></li>
<li><a href='#modes'><p>Identify multiple modes</p></a></li>
<li><a href='#MRQ'><p>Calculates MRQ polarization index</p></a></li>
<li><a href='#patternAgreement'><p>Calculates patterns agreement</p></a></li>
<li><a href='#patternVector'><p>Creates pattern vector</p></a></li>
<li><a href='#polarization'><p>Calculate polarization</p></a></li>
<li><a href='#Reardon'><p>Reardon's entropy</p></a></li>
<li><a href='#reduceVector'><p>Remove zeros and repeated values</p></a></li>
<li><a href='#sd.variance'><p>Approximate variance of the categorical standard deviation</p></a></li>
<li><a href='#secondModes'><p>Most common and second most common values</p></a></li>
<li><a href='#truncatevector'><p>Truncate helper function</p></a></li>
<li><a href='#var.variance'><p>Approximate variance of the consensus (Cns) estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculate Concentration and Dispersion in Ordered Rating Scales</td>
</tr>
<tr>
<td>Version:</td>
<td>1.42.12</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Didier Ruedin [aut, cre]
    Clem Aeppli [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Didier Ruedin &lt;didier.ruedin@unine.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates concentration and dispersion in ordered rating scales. It implements various measures of concentration and dispersion to describe what researchers variably call agreement, concentration, consensus, dispersion, or polarization among respondents in ordered data. It also implements other related measures to classify distributions. In addition to a generic city-block based concentration measure and a generic dispersion measure, the package implements various measures, including van der Eijk's (2001) &lt;<a href="https://doi.org/10.1023%2FA%3A1010374114305">doi:10.1023/A:1010374114305</a>&gt; measure of agreement A, measures of concentration by Leik, Tatsle and Wierman, Blair and Lacy, Kvalseth, Berry and Mielke, Reardon, and Garcia-Montalvo and Reynal-Querol. Furthermore, the package provides an implementation of Galtungs AJUS-system to classify distributions, as well as a function to identify the position of multiple modes.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://agrmt.r-forge.r-project.org">http://agrmt.r-forge.r-project.org</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-22 17:13:38 UTC; didier</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-22 17:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='agrmt-package'>Calculate Concentration and Dispersion in Ordered Rating Scales</h2><span id='topic+agrmt-package'></span><span id='topic+agrmt'></span>

<h3>Description</h3>

<p>This package calculates concentration and dispersion in ordered rating scales. It implements various measures of concentration and dispersion to describe what researchers variably call agreement, concentration, consensus, dispersion, or polarization among respondents in ordered data. It also implements other related measures to classify distributions.</p>


<h3>Details</h3>

<p>In ordered rating scales, concentration occurs if many values on the scale cluster around one value. Dispersion describes the absense of concentration. Various measures exist to calculate concentration and dispersion.
</p>
<p>The package provides a generic city-block based (<code><a href="#topic+concentration">concentration</a></code>) measure, and a generic measure of dispersion (<code><a href="#topic+disper">disper</a></code>). To use Van der Eijk's (2001) algorithmic approach agreement &quot;A&quot;, call <code><a href="#topic+agreement">agreement</a></code>. The derived <code><a href="#topic+polarization">polarization</a></code> lets you calculate a polarization score based on agreement A. Values are inverted and standardized to [0, 1]. Other specific measures: Leik's measure of ordinal dispersion (<code><a href="#topic+Leik">Leik</a></code>), Tatsle and Wierman's (<code><a href="#topic+consensus">consensus</a></code>), Blair and Lacy's (<code><a href="#topic+dsquared">dsquared</a></code>, <code><a href="#topic+lsquared">lsquared</a></code>, and <code><a href="#topic+BlairLacy">BlairLacy</a></code>), the measure by Kvalseth (<code><a href="#topic+Kvalseth">Kvalseth</a></code>), Berry and Mielke's IOV (<code><a href="#topic+BerryMielke">BerryMielke</a></code>), Reardon (<code><a href="#topic+Reardon">Reardon</a></code>) or Garcia-Montalvo and Reynal-Querol's (<code><a href="#topic+MRQ">MRQ</a></code>).
</p>
<p>The package also includes functions to classify distributions according to Galtung's (1969) AJUS-system (<code><a href="#topic+ajus">ajus</a></code>), and changes over time according to Galtung's (1969) ISD-system (<code><a href="#topic+isd">isd</a></code>). Moreover, the function <code><a href="#topic+modes">modes</a></code> can identify the position of multiple modes.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin
</p>
<p>Contributor: Clem Aeppli
</p>
<p>Maintainer: Didier Ruedin &lt;didier.ruedin@unine.ch&gt;
</p>


<h3>References</h3>

<p>van der Eijk, C. (2001) Measuring agreement in ordered rating scales, Quality and Quantity 35(3):325-341.
</p>
<p>Galtung, J. (1969) Theory and Methods of Social Research. Oslo: Universitetsforlaget.</p>

<hr>
<h2 id='agreement'>Calculate van der Eijk's measure of agreement A</h2><span id='topic+agreement'></span>

<h3>Description</h3>

<p>Calculate agreement in ordered rating scales. This function implements van der Eijk's (2001) measure of agreement A, which can be used to describe agreement or consensus among respondents.</p>


<h3>Usage</h3>

<pre><code class='language-R'>agreement(V, old = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agreement_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
<tr><td><code id="agreement_+3A_old">old</code></td>
<td>
<p>Optional argument if you wish to use the deprecated algorithm for agreement A, as outlined in van der Eijk's article. There is normally no reason to set the <code>old</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function to calculate agreement. A frequency vector describes the number of observations in a given category. For example, the vector [10,20,30,15,4] describes 10 observations with position 1, 20 observations with position 2, 30 observations with position 3, 15 observations with position 4, and 4 observations with position 5. At least three categories are required to calculate agreement.
</p>
<p>Polarization can be measured by extension. A convenience function <code><a href="#topic+polarization">polarization</a></code> is provided.</p>


<h3>Value</h3>

<p>The function returns the measure of agreement A. A is 1 if there is perfect unimodality (=agreement); A is 0 if there is perfect uniformity; A is -1 if there is perfect bimodality (=lack of agreement)</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>van der Eijk, C. 2001. Measuring agreement in ordered rating scales. Quality and Quantity 35(3):325-341. &lt;DOI: 10.1023/A:1010374114305&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+polarization">polarization</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
V &lt;- c(30,40,210,130,530,50,10)
# Calculate agreement A
agreement(V)
# The rate of agreement is given as 0.6113333
</code></pre>

<hr>
<h2 id='agreementError'>Simulated coding error for agreement A</h2><span id='topic+agreementError'></span>

<h3>Description</h3>

<p>Calculate agreement in ordered rating scales, but simulates coding error.</p>


<h3>Usage</h3>

<pre><code class='language-R'>agreementError(V, n=500, e=0.01, pos=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agreementError_+3A_v">V</code></td>
<td>
<p>A vector with an entry for each individual, not a frequency vector</p>
</td></tr>
<tr><td><code id="agreementError_+3A_n">n</code></td>
<td>
<p>Number of samples in the simulation</p>
</td></tr>
<tr><td><code id="agreementError_+3A_e">e</code></td>
<td>
<p>Proportion of samples for which errors are simulated</p>
</td></tr>
<tr><td><code id="agreementError_+3A_pos">pos</code></td>
<td>
<p>Vector of possible positions. If FALSE (default), the values occurring in V are set as the possible values</p>
</td></tr></table>


<h3>Details</h3>

<p>This function calculates agreement A, but simulates coding error. This can be useful to estimate standard errors and central tendency if certain positions are not observed. If all positions are observed in the vector V, bootstrapping can be used to estimate standard errors. If certain positions are not observed, bootstrapping is limited. Take an extreme example: [3 0 0 0 0]. Here we have three observations at the first position, but none at the others. Bootstrapping will always lead to the same agreement score. This can be misleading if coding error can be assumed. For example, if these three observations refer to a &lsquo;strongly agree&rsquo; answer, it is usually conceivable that some or all of these answers could refer to &lsquo;somewhat agree&rsquo;. This function lets you specify how many of the observations should be assumed to be potentially mis-coded, and calculates agreement accordingly. If an observation is assumed to be potentially mis-coded, it is randomly set to the position to the left, the position to the right, or the position itself. If the first or last observation is chosen, the simulation takes care not to suggest values that could not occur.
</p>
<p>You can run the function a few (hundred) times to get summary statistics of the result (mean, median, standard deviation, etc.). The function <code><a href="#topic+compareAgreement">compareAgreement</a></code> does just this, and compares the result with the agreement score if no coding error is assumed.
</p>


<h3>Value</h3>

<p>The function returns the measure of agreement A.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+agreement">agreement</a></code>, <code><a href="#topic+compareAgreement">compareAgreement</a></code>, <code><a href="#topic+collapse">collapse</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data:
V &lt;- c(1,1,1,1,2,3,3,3,3,4,4,4,4,4,4)
# calculate agreement; using collapse() to create the frequency vector
agreement(collapse(V))
# Calculate agreement A with coding error:
agreementError(V)
# Assume that all values could have coding error:
agreementError(V, e=1)
# Run the function a few times and show the mean:
z &lt;- replicate(1000, agreementError(V))
mean(z) 
hist(z) # etc.
# the example mentioned, population vector [3 0 0 0 0]:
V2 &lt;- c(1,1,1)
agreementError(V2, pos=1:5)
# you can also use the compareAgreement function
compareAgreement(V2, pos=1:5)
</code></pre>

<hr>
<h2 id='ajus'>Classify distributions</h2><span id='topic+ajus'></span>

<h3>Description</h3>

<p>Classify distributions using the AJUS-system introduced by Galtung (1969).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ajus(V, tolerance=0.1, variant="modified")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ajus_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
<tr><td><code id="ajus_+3A_tolerance">tolerance</code></td>
<td>
<p>Specify how similar values have to be to be treated as different (optional). Differences smaller than or equal to the tolerance are ignored.</p>
</td></tr>
<tr><td><code id="ajus_+3A_variant">variant</code></td>
<td>
<p>Strict AJUS following Galtung, or modified to include F and L types (default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the AJUS-system introduced by Galtung (1969). The input is a frequency vector; the output is a classification of the distribution.
</p>
<p>Distributions are classified as A if they are unimodal with a peak in the centre, as J if they are unimodal with a peak at either end, as U if they are bimodal with a peak at both ends, and as S if they are multimodal. In addition to Galtung's classification, the function classifies distributions as F if there is no peak and all values are more or less the same (flat). Furthermore, a distinction is drawn between J and L distributions, depending on whether they increase or decrease: J types have a peak on the right, L types have the peak on the left. The skew is given as +1 for a positive skew, as 0 for no skew, and -1 for a negative skew.
</p>
<p>The skew is identified by comparing the sum of values left and right of the midpoint respectively. For J-type of distributions, the skew is identified on the basis of the changes between values. This way, long tails cannot influence the skew, and a single peak at the left and right-hand end can be differentiated in all cases.
</p>
<p>The aim of the AJUS system is to reduce complexity. Initially the intuition was to classify distributions on an ad-hoc basis (i.e. eye-balling). Using an algorithm is certainly more reliable, and useful if one is interested in classifying (and comparing) a large number of distributions. The argument <code>tolerance</code>, however is not a trivial choice and can affect results. Use the helper function <code>ajusCheck</code> to check sensitivity to different values of the tolerance parameter.
</p>
<p>You can choose between a strict AJUS classification and a modified AJUSFL classification (default). The AJUS classification does not include a type for distributions without peaks (F type), and NA is returned instead. The AJUS classification does not draw a distinction between unimodal distributions with a peak at the end: the skew needs to be considered to distinguish between increasing and decreasing cases. The modified variant (default) includes the F type and the L type along with the original AJUS types.</p>


<h3>Value</h3>

<p>The function returns a list. The <code>type</code> returns a string corresponding to the pattern described by Galtung (A,J,U,S) or (F,L). The <code>skew</code> returns a number to describe the direction of the skew. The <code>pattern</code> returns the simplified pattern of the distribution. It indicates whether two values were considered the same (0), or if there was an increase (1) or decrease (-1) between two consecutive values. The length of the pattern is equal to the length of the frequency vector minus one.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>Galtung, J. (1969) Theory and Methods of Social Research. Oslo: Universitetsforlaget.</p>


<h3>See Also</h3>

<p><code><a href="#topic+isd">isd</a></code>, <code><a href="#topic+ajusCheck">ajusCheck</a></code>, <code><a href="#topic+ajusPlot">ajusPlot</a></code></p>

<hr>
<h2 id='ajusCheck'>Sensitivity test for AJUS</h2><span id='topic+ajusCheck'></span>

<h3>Description</h3>

<p>Check sensitivity of AJUS to different tolerance parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ajusCheck(V, t=seq(from=0.05, to=0.2, by=0.05), variant="modified")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ajusCheck_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
<tr><td><code id="ajusCheck_+3A_t">t</code></td>
<td>
<p>A vector of tolerance parameters to check. Differences smaller than or equal to the tolerance are ignored.</p>
</td></tr>
<tr><td><code id="ajusCheck_+3A_variant">variant</code></td>
<td>
<p>Strict AJUS following Galtung, or modified to include F and L types (default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs the AJUS system with a range of tolerance parameters. This way, you can easily check how sensitive the classification of the distribution is to the tolerance parameter.</p>


<h3>Value</h3>

<p>The function returns a list. The <code>tolerance</code> returns the tolerance parameters tested. The <code>type</code> returns a series of strings corresponding to the pattern described by Galtung (A,J,U,S) or (F, L) for each tolerance parameter. The <code>skew</code> returns a number to describe the direction of the skew. See <code><a href="#topic+ajus">ajus</a></code> for a description of the different arguments and the AJUS types.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ajus">ajus</a></code></p>

<hr>
<h2 id='ajusPlot'>Plot vector with AJUS type</h2><span id='topic+ajusPlot'></span>

<h3>Description</h3>

<p>Plot a frequency vector among with its AJUS type.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ajusPlot(V, tolerance=0.1, variant="modified", ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ajusPlot_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
<tr><td><code id="ajusPlot_+3A_tolerance">tolerance</code></td>
<td>
<p>Specify how similar values have to be to be treated as different (optional). Differences smaller than or equal to the tolerance are ignored.</p>
</td></tr>
<tr><td><code id="ajusPlot_+3A_...">...</code></td>
<td>
<p>Arguments to pass to the plotting function</p>
</td></tr>
<tr><td><code id="ajusPlot_+3A_variant">variant</code></td>
<td>
<p>Strict AJUS following Galtung, or modified to include F and L types (default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the frequency vector along with its AJUS classification and skew. See <code><a href="#topic+ajus">ajus</a></code> for a description of the AJUS system and the different parameters. In contrast to the <code>ajus</code> function, <code>ajusPlot</code> can deal with missing values. Missing values are removed when calculating the AJUS type (because AJUS does not handle missing values), but they are considered in the plot. This makes <code>ajusPlot</code> useful for classifying time series where missing values may occur. Additional arguments can be passed to the underlying <code>plot</code> function.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ajus">ajus</a></code></p>

<hr>
<h2 id='BerryMielke'>Calculate IOV</h2><span id='topic+BerryMielke'></span>

<h3>Description</h3>

<p>Calculate Berry and Mielke's IOV.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BerryMielke(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BerryMielke_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates Berry and Mielke's IOV, a measure of dispersion based on squared Euclidean distances. This function follows the presentation by Blair and Lacy 2000, but includes the adjustment for Tmax omitted by Blair and Lacy as there is no reason to leave it out. The derived measure COV by Kvalseth is implemented as <code><a href="#topic+Kvalseth">Kvalseth</a></code>. Usually, the IOV is equivalent to 1-<code><a href="#topic+lsquared">lsquared</a></code>.</p>


<h3>Value</h3>

<p>The function returns the IOV.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>Blair, J., and M. Lacy. 2000. Statistics of Ordinal Variation. Sociological Methods &amp; Research 28 (3): 251-280.
</p>
<p>Berry, K., and P. Mielke. 1992. Assessment of Variation in Ordinal Data. Perceptual and Motor Skills 74 (1): 63-66.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsquared">lsquared</a></code>, <code><a href="#topic+Kvalseth">Kvalseth</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
V &lt;- c(30,40,210,130,530,50,10)
BerryMielke(V)
</code></pre>

<hr>
<h2 id='BlairLacy'>Calculate l</h2><span id='topic+BlairLacy'></span>

<h3>Description</h3>

<p>Calculate Blair and Lacy's l.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BlairLacy(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BlairLacy_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates Blair and Lacy's l, a measure of concentration based on linear Euclidean distances. This function follows the presentation by Blair and Lacy 2000. The measure l-squared by Blair and Lacy is implemented as <code><a href="#topic+lsquared">lsquared</a></code>.</p>


<h3>Value</h3>

<p>The function returns the l.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>Blair, J., and M. Lacy. 2000. Statistics of Ordinal Variation. Sociological Methods &amp; Research 28 (3): 251-280.</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsquared">lsquared</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
V &lt;- c(30,40,210,130,530,50,10)
BlairLacy(V)
</code></pre>

<hr>
<h2 id='censor'>Censor helper function</h2><span id='topic+censor'></span>

<h3>Description</h3>

<p>Helper function to censor frequency vectors</p>


<h3>Usage</h3>

<pre><code class='language-R'>censor(V, left=0, right=100)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="censor_+3A_v">V</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="censor_+3A_left">left</code></td>
<td>
<p>left to censor</p>
</td></tr>
<tr><td><code id="censor_+3A_right">right</code></td>
<td>
<p>right to censor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helper function to censor frequency vectors</p>


<h3>Value</h3>

<p>censored frequency vector</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+truncate">truncate</a></code></p>

<hr>
<h2 id='collapse'>Reduces a vector to a frequency vector</h2><span id='topic+collapse'></span>

<h3>Description</h3>

<p>Takes a vector and reduces it to a frequency vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(D,pos=FALSE, na.rm=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_+3A_d">D</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="collapse_+3A_pos">pos</code></td>
<td>
<p>Optional: position of categories</p>
</td></tr>
<tr><td><code id="collapse_+3A_na.rm">na.rm</code></td>
<td>
<p>Optional: should NA be removed (TRUE by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reduces a vector to a frequency vector. This function is very similar to the way <code>table</code> summarizes vectors, but this function can deal with categories of frequency 0 if the argument <code>pos</code> is specified. Here we assume a vector with an entry for each individual (the order of the values is ignored). Each entry states the position of an individual. When the number of positions is naturally limited, such as when categorical positions are used, frequency vectors can summarize this information: how many individuals have position 1, how many individuals have position 2, etc. A frequency vector has an entry for each position in the population (sorted in ascending order). Each entry states the number of individuals in the population with this position.
</p>
<p>The argument <code>pos</code> is required if certain positions do not occur in the population (or if there is a chance that they do not occur in a specific sub-population). For example, if we have positions on a 7-point scale, and position 3 never occurs in the population, the argument <code>pos</code> must be specified. In this case, the argument may be <code>pos=1:7</code>. We can also use categories more generally, as in <code>c(-3, -1, 0, 0.5, 1, 2, 5)</code>. Specifying the positions of categories when all positions occur in the population has no side-effects. See the example for an illustration.
</p>
<p>By default, missing values (NA) are removed with <code>as.numeric(na.omit())</code>. This helps with some vectors that include NA that fail otherwise. If NA are maintained with <code>na.rm=FALSE</code>, they are included as the last category. The argument <code>pos</code> cannot include NA as a position; NA are removed if the argument <code>pos</code> is used.</p>


<h3>Value</h3>

<p>A frequency vector</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+expand">expand</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>V = c(1,1,1,1,1,1,3,3,3,3,4,5,5,5,5)
# summarize using table()
table(V)
# summarize using collapse()
collapse(V)
# assuming possible values (1,2,3,4,5), we get that zero times 2 included:
collapse(V, pos=c(1,2,3,4,5))
</code></pre>

<hr>
<h2 id='compareAgreement'>Compare agreement A with and without simulated coding error</h2><span id='topic+compareAgreement'></span>

<h3>Description</h3>

<p>Calculate agreement in ordered rating scales, and compares this to agreement with simulated coding error.</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareAgreement(V, n=500, e=0.01, N=500, pos=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareAgreement_+3A_v">V</code></td>
<td>
<p>A vector with an entry for each individual</p>
</td></tr>
<tr><td><code id="compareAgreement_+3A_n">n</code></td>
<td>
<p>Number of samples in the simulation of coding errors</p>
</td></tr>
<tr><td><code id="compareAgreement_+3A_e">e</code></td>
<td>
<p>Proportion of samples for which errors are simulated</p>
</td></tr>
<tr><td><code id="compareAgreement_+3A_n">N</code></td>
<td>
<p>Number of replications for calculating mean and standard deviation</p>
</td></tr>
<tr><td><code id="compareAgreement_+3A_pos">pos</code></td>
<td>
<p>Vector of possible positions. If FALSE, the values occurring in V are set as the possible values</p>
</td></tr></table>


<h3>Details</h3>

<p>This function calculates agreement on a vector, and compares the value with agreement with simulated coding error. It runs the function <code><a href="#topic+agreementError">agreementError</a></code> N times. The other arguments (n, e, pos) are passed down to the <code>agreementError</code> function.</p>


<h3>Value</h3>

<p>The function returns a list with agreement A without simulated coding errors, the mean of agreement with simulated coding error, and the standard deviation of agreement with simulated coding error.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+agreement">agreement</a></code>, <code><a href="#topic+agreementError">agreementError</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data:
V &lt;- c(1,1,1,1,2,3,3,3,3,4,4,4,4,4,4)
compareAgreement(V)
</code></pre>

<hr>
<h2 id='compareValues'>Compares two values</h2><span id='topic+compareValues'></span>

<h3>Description</h3>

<p>This is a helper function to compare two values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareValues(A,B,tolerance=0.1)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareValues_+3A_a">A</code></td>
<td>
<p>A number</p>
</td></tr>
<tr><td><code id="compareValues_+3A_b">B</code></td>
<td>
<p>A number</p>
</td></tr>
<tr><td><code id="compareValues_+3A_tolerance">tolerance</code></td>
<td>
<p>Specify how similar values have to be to be treated as different. Differences smaller than or equal to the tolerance are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function compare two values. Two values are more or less the same, or one of the two is bigger.</p>


<h3>Value</h3>

<p>The function returns number to describe the relationship: -1 if A is bigger, 1 if B is bigger, and 0 if the two are more or less the same.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>

<hr>
<h2 id='concentration'>Measures concentration</h2><span id='topic+concentration'></span>

<h3>Description</h3>

<p>This function measures concentration in a frequency vector</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentration(V, metric=2)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concentration_+3A_v">V</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="concentration_+3A_metric">metric</code></td>
<td>
<p>city block metric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function measures concentration in a frequency vector in city blocks. The default metric is 2.</p>


<h3>Value</h3>

<p>measure of concentration</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
V &lt;- c(30,40,210,130,530,50,10)
concentration(V)
</code></pre>

<hr>
<h2 id='consensus'>Calculate Tastle and Wierman's measure of consensus</h2><span id='topic+consensus'></span>

<h3>Description</h3>

<p>Calculate consensus in ordered rating scales. This function implements Tastle and Wierman's (2007) measure of consensus (ordinal dispersion), which can be used to describe agreement, consensus, dispersion, or polarization among respondents.</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consensus_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates consensus following Tastle and Wierman (2007). The measure of consensus is based on the Shannon entropy. A frequency vector describes the number of observations in a given category. For example, the vector [10,20,30,15,4] describes 10 observations with position 1, 20 observations with position 2, 30 observations with position 3, 15 observations with position 4, and 4 observations with position 5.
</p>
<p>If you come across an error that the vector supplied does not contain whole numbers, try <code>round(V,0)</code> to remove any detritus from calculating the frequency vector.</p>


<h3>Value</h3>

<p>The function returns the measure of consensus. It is 1 if there is perfect uniformity; it is 0 if there is perfect bimodality (=lack of agreement)</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>Tastle, W., and M. Wierman. 2007. Consensus and dissention: A measure of ordinal dispersion. International Journal of Approximate Reasoning 45(3): 531-545.</p>


<h3>See Also</h3>

<p><code><a href="#topic+agreement">agreement</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
V &lt;- c(30,40,210,130,530,50,10)
# Calculate consensus
consensus(V)
# The degree of consensus is given as 0.7256876
</code></pre>

<hr>
<h2 id='consensus.variance'>Approximate variance of consensus</h2><span id='topic+consensus.variance'></span>

<h3>Description</h3>

<p>Calculate approximate variance of Blair and Lacy's consensus Cns</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus.variance(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consensus.variance_+3A_v">V</code></td>
<td>
<p>Frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helper function to calculate approximate variance of Blair and Lacy's (2000) consensus Cns.</p>


<h3>Value</h3>

<p>Approximate variance of Blair and Lacy's consensus Cns</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>References</h3>

<p>Blair, J., and M. Lacy. 2000. Statistics of Ordinal Variation. Sociological Methods &amp; Research 28 (3): 251-280.</p>


<h3>See Also</h3>

<p><code><a href="#topic+consensus">consensus</a></code></p>

<hr>
<h2 id='D.variance'>Approximate variance of Leik's D</h2><span id='topic+D.variance'></span>

<h3>Description</h3>

<p>Calculate approximate variance of Leik's D</p>


<h3>Usage</h3>

<pre><code class='language-R'>D.variance(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D.variance_+3A_v">V</code></td>
<td>
<p>Frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helper function to calculate approximate variance of Leik's (1966) D.</p>


<h3>Value</h3>

<p>Approximate variance of D</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>References</h3>

<p>Leik, R. (1966) A measure of ordinal consensus, Pacific Sociological Review 9(2):85-90.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Leik">Leik</a></code></p>

<hr>
<h2 id='disper'>Measures distance</h2><span id='topic+disper'></span>

<h3>Description</h3>

<p>This function measures distance between two frequency vectors</p>


<h3>Usage</h3>

<pre><code class='language-R'>disper(A, B, metric=2)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disper_+3A_a">A</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="disper_+3A_b">B</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="disper_+3A_metric">metric</code></td>
<td>
<p>city block metric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the distance between two frequency vectors.</p>


<h3>Value</h3>

<p>measure of distance</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>See Also</h3>

<p><code><a href="#topic+concentration">concentration</a></code></p>

<hr>
<h2 id='dispersion'>Measures dispersion</h2><span id='topic+dispersion'></span>

<h3>Description</h3>

<p>This function measures dispersion in a frequency vector</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispersion(V, metric=2)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dispersion_+3A_v">V</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="dispersion_+3A_metric">metric</code></td>
<td>
<p>city block metric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dispersion is 1-concentration</p>


<h3>Value</h3>

<p>measure of dispersion</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>See Also</h3>

<p><code><a href="#topic+concentration">concentration</a></code></p>

<hr>
<h2 id='dsquared'>Calculate d-squared</h2><span id='topic+dsquared'></span>

<h3>Description</h3>

<p>Calculate Blair and Lacy's d-squared.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsquared(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsquared_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates Blair and Lacy's d-squared, a measure of concentration based on squared Euclidean distances. This function follows the presentation by Blair and Lacy 2000. The measure l-squared normalizes the values and is implemented as <code><a href="#topic+lsquared">lsquared</a></code>.</p>


<h3>Value</h3>

<p>The function returns the d-squared.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>Blair, J., and M. Lacy. 2000. Statistics of Ordinal Variation. Sociological Methods &amp; Research 28 (3): 251-280.</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsquared">lsquared</a></code>, <code><a href="#topic+BlairLacy">BlairLacy</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
V &lt;- c(30,40,210,130,530,50,10)
dsquared(V)
</code></pre>

<hr>
<h2 id='entropy'>Calculate Shannon entropy</h2><span id='topic+entropy'></span>

<h3>Description</h3>

<p>Calculate Shannon entropy, following Tastle and Wierman.</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="entropy_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the Shannon entropy following Tastle and Wierman (2007). A frequency vector describes the number of observations in a given category. For example, the vector [10,20,30,15,4] describes 10 observations with position 1, 20 observations with position 2, 30 observations with position 3, 15 observations with position 4, and 4 observations with position 5.
</p>
<p>This function follows Tastle and Wierman and ignores categories with zero observations. This does not follow the formula indicated.
</p>
<p>See <code><a href="#topic+consensus">consensus</a></code> for a function that considers the order of categories.</p>


<h3>Value</h3>

<p>The function returns the Shannon entropy.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>Tastle, W., and M. Wierman. 2007. Consensus and dissention: A measure of ordinal dispersion. International Journal of Approximate Reasoning 45 (3): 531-545.</p>


<h3>See Also</h3>

<p><code><a href="#topic+consensus">consensus</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
V &lt;- c(30,40,210,130,530,50,10)
# Calculate entropy
entropy(V)
</code></pre>

<hr>
<h2 id='expand'>Expands a frequency vector to a vector</h2><span id='topic+expand'></span>

<h3>Description</h3>

<p>This function expands a frequency vector to a vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(F)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_+3A_f">F</code></td>
<td>
<p>Frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a frequency vector and expands it to a longer vector with one entr for each observation. It is reverses the <code><a href="#topic+collapse">collapse</a></code> function. A frequency vector has an entry for each position in the population. Each entry states the number of individuals in the population with this position. Here we create a vector with an entry for each individual.</p>


<h3>Value</h3>

<p>A vector</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+collapse">collapse</a></code></p>

<hr>
<h2 id='isd'>Classify changes over time</h2><span id='topic+isd'></span>

<h3>Description</h3>

<p>Classify changes over time using the ISD-system introduced by Galtung (1969).</p>


<h3>Usage</h3>

<pre><code class='language-R'>isd(V, tolerance=0.1)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isd_+3A_v">V</code></td>
<td>
<p>A vector with length 3</p>
</td></tr>
<tr><td><code id="isd_+3A_tolerance">tolerance</code></td>
<td>
<p>Specify how similar values have to be to be treated as different (optional). Differences smaller than or equal to the tolerance are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the ISD-system introduced by Galtung (1969). The input is a vector of length 3. Each value stands for a different point in time. The ISD-system examines the two transition points, and classifies the changes over time.</p>


<h3>Value</h3>

<p>The function returns a list. The <code>type</code> returns a number corresponding to the pattern described by Galtung. The <code>description</code> returns a string where the two transitions are spelled out (increase, flat, decrease).</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>Galtung, J. (1969) Theory and Methods of Social Research. Oslo: Universitetsforlaget.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ajus">ajus</a></code></p>

<hr>
<h2 id='Kvalseth'>Calculate Kvalseth's COV</h2><span id='topic+Kvalseth'></span>

<h3>Description</h3>

<p>Calculate Kvalseth's COV.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kvalseth(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kvalseth_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates Kvalseth's COV, a measure of dispersion based on linear Euclidean distances. It is based on the IOV measure, implemented as <code><a href="#topic+BerryMielke">BerryMielke</a></code>. This function follows the presentation by Blair and Lacy 2000.</p>


<h3>Value</h3>

<p>The function returns the COV.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>Blair, J., and M. Lacy. 2000. Statistics of Ordinal Variation. Sociological Methods &amp; Research 28 (3): 251-280.</p>


<h3>See Also</h3>

<p><code><a href="#topic+BerryMielke">BerryMielke</a></code>, <code><a href="#topic+lsquared">lsquared</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
V &lt;- c(30,40,210,130,530,50,10)
Kvalseth(V)
</code></pre>

<hr>
<h2 id='l.variance'>Approximate variance of Blair and Lacy's l</h2><span id='topic+l.variance'></span>

<h3>Description</h3>

<p>Calculate approximate variance of Blair and Lacy's (2000) l</p>


<h3>Usage</h3>

<pre><code class='language-R'>l.variance(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="l.variance_+3A_v">V</code></td>
<td>
<p>Frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helper function to calculate approximate variance of Blair and Lacy's (2000) l.</p>


<h3>Value</h3>

<p>Approximate variance of Blair and Lacy's l</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>References</h3>

<p>Blair, J., and M. Lacy. 2000. Statistics of Ordinal Variation. Sociological Methods &amp; Research 28 (3): 251-280.</p>


<h3>See Also</h3>

<p><code><a href="#topic+BlairLacy">BlairLacy</a></code></p>

<hr>
<h2 id='Leik'>Calculate ordinal dispersion</h2><span id='topic+Leik'></span>

<h3>Description</h3>

<p>Calculates ordinal dispersion as introduced by Leik (1966)</p>


<h3>Usage</h3>

<pre><code class='language-R'>Leik(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Leik_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates ordinal dispersion as introduced by Robert K. Leik (1966). It uses the cumulative frequency distribution to determine ordinal dispersion. The extremes (agreement, polarization) largely correspond to the types used by Cees van der Eijk. By contrast, the mid-point depends on the number of categories: it tends toward 0.5 as the number of categories increases. Leik defends this difference by highlighting the increased probability of falling into polarized patterns when there are fewer categories. If all observations are in the same category, ordinal dispersion is 0. With half the observations in one extreme category, and half the observations in the other extreme, Leik's measure gives a value of 1.
</p>
<p>The dispersion measure is a percentage, and can be interpreted accordingly. Ordinal dispersion can be used to express consensus or agreement, simply by taking: 1 - ordinal dispersion.</p>


<h3>Value</h3>

<p>The function returns the ordinal dispersion</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>Leik, R. (1966) A measure of ordinal consensus, Pacific Sociological Review 9(2):85-90.</p>


<h3>See Also</h3>

<p><code><a href="#topic+polarization">polarization</a></code>, <code><a href="#topic+agreement">agreement</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1:
V &lt;- c(30,40,210,130,530,50,10)
# Calculate polarization
Leik(V)
# The ordinal dispersion is given as 0.287
polarization(V)
# Polarization is given as 0.194 (as contrast)
</code></pre>

<hr>
<h2 id='lsquared'>Calculate l-squared</h2><span id='topic+lsquared'></span>

<h3>Description</h3>

<p>Calculate Blair and Lacy's l-squared.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsquared(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lsquared_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates Blair and Lacy's l-squared, a measure of concentration based on squared Euclidean distances. This function follows the presentation by Blair and Lacy 2000. The measure &lsquo;l&rsquo; by Blair and Lacy is implemented as <code><a href="#topic+BlairLacy">BlairLacy</a></code>.</p>


<h3>Value</h3>

<p>The function returns the l-squared.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>Blair, J., and M. Lacy. 2000. Statistics of Ordinal Variation. Sociological Methods &amp; Research 28 (3): 251-280.</p>


<h3>See Also</h3>

<p><code><a href="#topic+BerryMielke">BerryMielke</a></code>, <code><a href="#topic+BlairLacy">BlairLacy</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
V &lt;- c(30,40,210,130,530,50,10)
lsquared(V)
</code></pre>

<hr>
<h2 id='lsquared.variance'>Approximate variance of Blair and Lacy's lsquared</h2><span id='topic+lsquared.variance'></span>

<h3>Description</h3>

<p>Calculate approximate variance of Blair and Lacy's (2000) lsquared</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsquared.variance(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lsquared.variance_+3A_v">V</code></td>
<td>
<p>Frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helper function to calculate approximate variance of Blair and Lacy's (2000) lsquared.</p>


<h3>Value</h3>

<p>Approximate variance of Blair and Lacy's lsquared</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>References</h3>

<p>Blair, J., and M. Lacy. 2000. Statistics of Ordinal Variation. Sociological Methods &amp; Research 28 (3): 251-280.</p>


<h3>See Also</h3>

<p><code><a href="#topic+BlairLacy">BlairLacy</a></code></p>

<hr>
<h2 id='minnz'>Non-zero minimum</h2><span id='topic+minnz'></span>

<h3>Description</h3>

<p>Helper function to calculate the smallest value of the vector except for 0 (non-zero minimum).</p>


<h3>Usage</h3>

<pre><code class='language-R'>minnz(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minnz_+3A_v">V</code></td>
<td>
<p>A vector</p>
</td></tr></table>


<h3>Details</h3>

<p>This is a helper function to calculate the non-zero minimum of a vector. The result is the smallest value of the vector, but cannot be zero.</p>


<h3>Value</h3>

<p>The function returns the non-zero minimum</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>

<hr>
<h2 id='modes'>Identify multiple modes</h2><span id='topic+modes'></span>

<h3>Description</h3>

<p>Identifies (multiple) modes in a frequency vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>modes(V, pos=FALSE, tolerance=0.1)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modes_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
<tr><td><code id="modes_+3A_pos">pos</code></td>
<td>
<p>Categories of frequency vector (optional)</p>
</td></tr>
<tr><td><code id="modes_+3A_tolerance">tolerance</code></td>
<td>
<p>Specify how similar values have to be to be treated as different (optional).  Differences smaller than or equal to the tolerance are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies which positions of a frequency vector correspond to the mode. If there are multiple modes of the same value, all matching positions will be reported. Use the function <code><a href="#topic+collapse">collapse</a></code> to create frequency vectors if necessary.</p>


<h3>Value</h3>

<p>The function returns a list. The <code>at</code> returns the categories of the frequency vector. Either these categories were specified using the argument pos, or we assume it to be 1:k (with k the number of categories in the frequency vector). If the length of the <code>pos</code> argument does not match the length of the frequency vector, a warning is shown, and the <code>pos</code> argument is ignored. The <code>frequencies</code> returns the frequency vector. The <code>mode</code> returns the value of the mode(s). If there are multiple modes, they are listed. Similar frequencies are counted as equal, using the tolerance argument. To prevent similar frequencies to be considered the same, set <code>tolerance</code> to 0. The <code>positions</code> returns the positions of the vector that correspond to the mode. This will differ from the <code>mode</code> if <code>pos</code> is provided.The <code>contiguous</code> returns TRUE of all modes are contiguous, and FALSE if there are different values in between. If there is only one mode, it is defined as contiguous (i.e. TRUE).</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+secondModes">secondModes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: finding the mode
V1 &lt;- c(30,40,210,130,530,50,10)
modes(V1) # will find position 5
# Example 2:
V2 &lt;- c(3,0,4,1)
modes(V2) # will find position 3
# Example 3: providing categories
modes(V2,pos=-1:2) # will still find position 3, but give the value of 1 as mode
# Example 4: similar values
V3 &lt;- c(30,40,500,130,530,50,10) 
modes(V3, tolerance=30) # will find positions 3 and 5 (500 and 530 are nearly the same)
</code></pre>

<hr>
<h2 id='MRQ'>Calculates MRQ polarization index</h2><span id='topic+MRQ'></span>

<h3>Description</h3>

<p>This function calculates the MRQ polarization index from a population vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRQ(Z)</code></pre>


<h3>Arguments</h3>

 <table role = "presentation">
<tr><td><code id="MRQ_+3A_z">Z</code></td>
<td>
<p>(Standardized) frequency vector</p>
</td></tr></table>


<h3>Details</h3>

<p>This function implements the polarization index introduced by Garcia-Montalvo
and Reynal-Querol (2005), also known as the Reynal-Querol index of polarization (RQ). It is a measure of dispersion based on squared Euclidean distances. The frequency vector needs to be standardized for the Reynal-Querol index to work; if the sum of the frequency vector is not 1 (i.e. it is not standardized), the function automatically standardizes the frequency vector by dividing each element of the vector by the sum of the vector. The assumption is that the frequencies are complete.</p>


<h3>Value</h3>

<p>Index of polarization (RQ).</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>References</h3>

<p>Garcia-Montalvo, Jose, and Marta Reynal-Querol. 2005. Ethnic Polarization, Potential Conflict, and Civil Wars. American Economic Review 95(3): 796-816.
</p>
<p>Reynal-Querol, Marta. 2002. Ethnicity, Political Systems, and Civil Wars. Journal of Conflict Resolution 46(1): 29-54.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
V &lt;- c(30,40,210,130,530,50,10)
MRQ(V)
</code></pre>

<hr>
<h2 id='patternAgreement'>Calculates patterns agreement</h2><span id='topic+patternAgreement'></span>

<h3>Description</h3>

<p>Helper function to calculate agreement A from a pattern vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>patternAgreement(P, old=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patternAgreement_+3A_p">P</code></td>
<td>
<p>A pattern vector</p>
</td></tr>
<tr><td><code id="patternAgreement_+3A_old">old</code></td>
<td>
<p>Optional argument if the old algorithm for agreement A is to be used. There is normally no reason to set the <code>old</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function to calculate agreement A from a pattern vector.</p>


<h3>Value</h3>

<p>The function returns the measure of agreement A</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+agreement">agreement</a></code></p>

<hr>
<h2 id='patternVector'>Creates pattern vector</h2><span id='topic+patternVector'></span>

<h3>Description</h3>

<p>Helper function to create a pattern vector from a frequency vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>patternVector(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patternVector_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr></table>


<h3>Details</h3>

<p>This is a helper function to create a pattern vector from a frequency vector. A pattern vector reduced all values greater or equal to 1 to 1, and values of 0 remain 0. A frequency vector (0,0,18,59,0,34,2) is turned into a pattern vector (0,0,1,1,0,1,1).</p>


<h3>Value</h3>

<p>The function returns a pattern vector.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+agreement">agreement</a></code></p>

<hr>
<h2 id='polarization'>Calculate polarization</h2><span id='topic+polarization'></span>

<h3>Description</h3>

<p>Calculates polarization, based on measure of agreement A</p>


<h3>Usage</h3>

<pre><code class='language-R'>polarization(V, old = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polarization_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
<tr><td><code id="polarization_+3A_old">old</code></td>
<td>
<p>Specify <code>old=TRUE</code> to use the deprecated algorithm for agreement A</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates polarization by re-scaling agreement A introduced by Cees van der Eijk. Whereas agreement A ranges from -1 to 1, polarization ranges from 0 to 1. If all observations are in the same category, polarization is 0. With half the observations in one category, and half the observations in a different (non-neighbouring) category, polarization is 1. Polarization is 0.5 for a uniform distribution over all categories.</p>


<h3>Value</h3>

<p>The function returns a polarization score</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+agreement">agreement</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- c(30,40,210,130,530,50,10)
# Calculate polarization
polarization(V)
# The rate of polarization is given as 0.1943333
</code></pre>

<hr>
<h2 id='Reardon'>Reardon's entropy</h2><span id='topic+Reardon'></span>

<h3>Description</h3>

<p>This function calculates Reardon's (2009) entropy from a frequency vector</p>


<h3>Usage</h3>

<pre><code class='language-R'>Reardon(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Reardon_+3A_v">V</code></td>
<td>
<p>Frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate Reardon's (2009) entropy.
</p>


<h3>Value</h3>

<p>measure of entropy</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>References</h3>

<p>Reardon, S. 2009. Measures of Ordinal Segregation. Research on Economic Inequality 17:129-55. &lt;DOI: 10.1108/S1049-2585(2009)0000017011&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+disper">disper</a></code></p>

<hr>
<h2 id='reduceVector'>Remove zeros and repeated values</h2><span id='topic+reduceVector'></span>

<h3>Description</h3>

<p>This is a helper function to remove all zeros and repeated values from a vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceVector(X)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduceVector_+3A_x">X</code></td>
<td>
<p>A (frequency) vector</p>
</td></tr></table>


<h3>Details</h3>

<p>This is a helper function to strip all zeros and repeated values from a vector.</p>


<h3>Value</h3>

<p>The function returns vector</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+agreement">agreement</a></code></p>

<hr>
<h2 id='sd.variance'>Approximate variance of the categorical standard deviation</h2><span id='topic+sd.variance'></span>

<h3>Description</h3>

<p>Calculate approximate variance of the categorical standard deviation</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd.variance(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd.variance_+3A_v">V</code></td>
<td>
<p>Frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helper function to calculate approximate variance of the categorical standard deviation.</p>


<h3>Value</h3>

<p>Approximate variance of the categorical standard deviation</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+truncate">truncate</a></code></p>

<hr>
<h2 id='secondModes'>Most common and second most common values</h2><span id='topic+secondModes'></span>

<h3>Description</h3>

<p>Identifies the most common (multiple) modes for frequency vectors as well as the second most common values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>secondModes(V, pos=FALSE, tolerance=0.1)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secondModes_+3A_v">V</code></td>
<td>
<p>A frequency vector</p>
</td></tr>
<tr><td><code id="secondModes_+3A_pos">pos</code></td>
<td>
<p>Categories of frequency vector (optional)</p>
</td></tr>
<tr><td><code id="secondModes_+3A_tolerance">tolerance</code></td>
<td>
<p>Specify how similar values have to be to be treated as different (optional).  Differences smaller than or equal to the tolerance are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies which positions of a frequency vector correspond to the mode(s) as implemented in the <code><a href="#topic+modes">modes</a></code> function. It also reports the second most common position in the same manner.</p>


<h3>Value</h3>

<p>The function returns a list for the most common and the second most common value(s). The output corresponds to that of the <code><a href="#topic+modes">modes</a></code> function.</p>


<h3>Author(s)</h3>

<p>Didier Ruedin</p>


<h3>See Also</h3>

<p><code><a href="#topic+modes">modes</a></code></p>

<hr>
<h2 id='truncatevector'>Truncate helper function</h2><span id='topic+truncatevector'></span>

<h3>Description</h3>

<p>Helper function to truncate frequency vectors</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncatevector(V, left=0, right=100)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="truncatevector_+3A_v">V</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="truncatevector_+3A_left">left</code></td>
<td>
<p>left to truncate</p>
</td></tr>
<tr><td><code id="truncatevector_+3A_right">right</code></td>
<td>
<p>right to truncate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helper function to truncate frequency vectors</p>


<h3>Value</h3>

<p>truncated frequency vector</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>See Also</h3>

<p><code><a href="#topic+censor">censor</a></code></p>

<hr>
<h2 id='var.variance'>Approximate variance of the consensus (Cns) estimator</h2><span id='topic+var.variance'></span>

<h3>Description</h3>

<p>Calculate approximate variance of the consensus (Cns) estimator</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.variance(V)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.variance_+3A_v">V</code></td>
<td>
<p>Frequency vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helper function to calculate approximate variance of the Consensus (Cns) estimator.</p>


<h3>Value</h3>

<p>Approximate variance of Blair and Lacy's l</p>


<h3>Author(s)</h3>

<p>Clem Aeppli</p>


<h3>References</h3>

<p>Blair, J., and M. Lacy. 2000. Statistics of Ordinal Variation. Sociological Methods &amp; Research 28 (3): 251-280.</p>


<h3>See Also</h3>

<p><code><a href="#topic+consensus">consensus</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
