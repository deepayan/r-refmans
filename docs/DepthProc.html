<!DOCTYPE html><html><head><title>Help for package DepthProc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DepthProc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abline,RobReg-method'><p>Add line to plot</p></a></li>
<li><a href='#as.matrix'><p>as.matrix method for DepthCurveList.</p></a></li>
<li><a href='#asymmetryCurve'><p>Asymmetry curve based on depths</p></a></li>
<li><a href='#AsymmetryCurve-class'><p>AsymmetryCurve and AsymmetryCurveList</p></a></li>
<li><a href='#BinnDepth2d-class'><p>BinnDepth2d</p></a></li>
<li><a href='#binningDepth2D'><p>2d Binning</p></a></li>
<li><a href='#combineDepthCurves'><p>Adds plots</p></a></li>
<li><a href='#CovDepthWeighted-class'><p>CovLP</p></a></li>
<li><a href='#CovLP'><p>CovLp</p></a></li>
<li><a href='#cracow.airpollution'><p>Air pollution with PM10 in Cracow within day and night in December 2016</p></a></li>
<li><a href='#ddmvnorm'><p>Normal depth versus depth plot</p></a></li>
<li><a href='#ddPlot'><p>Depth versus depth plot</p></a></li>
<li><a href='#DDPlot-class'><p>DDPlot</p></a></li>
<li><a href='#deepReg2d'><p>Simple deepest regression method.</p></a></li>
<li><a href='#DeepReg2d-class'><p>DeepReg2d</p></a></li>
<li><a href='#depth'><p>Depth calculation</p></a></li>
<li><a href='#Depth-class'><p>Depth</p></a></li>
<li><a href='#depthContour'><p>Approximate depth contours</p></a></li>
<li><a href='#DepthCurve-class'><p>DepthCurve</p></a></li>
<li><a href='#DepthCurveList-class'><p>DepthCurveList</p></a></li>
<li><a href='#depthDensity'><p>Depth weighted density estimator</p></a></li>
<li><a href='#DepthDensity-class'><p>DepthDensity</p></a></li>
<li><a href='#depthEuclid'><p>Euclidean Depth</p></a></li>
<li><a href='#depthLocal'><p>Local depth</p></a></li>
<li><a href='#depthLP'><p>LP Depth</p></a></li>
<li><a href='#depthMah'><p>Mahalanobis Depth</p></a></li>
<li><a href='#depthMedian'><p>Depth median</p></a></li>
<li><a href='#depthPersp'><p>Perspective plot for depth functions</p></a></li>
<li><a href='#depthProjection'><p>Projection Depth</p></a></li>
<li><a href='#depthTukey'><p>Tukey Depth</p></a></li>
<li><a href='#fncBoxPlot'><p>Functional boxplot based on Modified Band Depth</p></a></li>
<li><a href='#fncDepth'><p>Basic function for functional depths</p></a></li>
<li><a href='#fncDepthFM'><p>FM Depth</p></a></li>
<li><a href='#fncDepthMBD'><p>Modified band depth</p></a></li>
<li><a href='#fncDepthMedian'><p>Functional median</p></a></li>
<li><a href='#fncGetBand'><p>Functional bands</p></a></li>
<li><a href='#france'><p>Relation between minimum wage (MW) and unemployment rate (UR) in France.</p></a></li>
<li><a href='#FunctionalDepth-class'><p>Functional Depth</p></a></li>
<li><a href='#getPlot'><p>Create ggplot object from DepthCurve, DepthCurveList and DDPlot classes.</p></a></li>
<li><a href='#inf.mort'><p>Infant mortality rate (0&ndash;1 year) per 1,000 live births</p></a></li>
<li><a href='#internet.users'><p>Internet view data</p></a></li>
<li><a href='#katowice.airpollution'><p>Air pollution in Katowice city by hour.</p></a></li>
<li><a href='#lsdAddContour'><p>Adds location scale depth contour to the existing plot.</p></a></li>
<li><a href='#LSDepth-class'><p>Location-Scale depth class</p></a></li>
<li><a href='#LSDepthContour-class'><p>Location-Scale depth contour class</p></a></li>
<li><a href='#lsdGetContour'><p>Get location-scale contour from LSDepthContour object.</p></a></li>
<li><a href='#lsdSampleDepthContours'><p>Calculate sample Mizera and Muller Student depth contours</p></a></li>
<li><a href='#lsdSampleMaxDepth'><p>Calculates the maximum sample location-scale depth</p></a></li>
<li><a href='#maesles.imm'><p>Children 1 year old immunized against measles, percentage</p></a></li>
<li><a href='#mWilcoxonTest'><p>Multivariate Wilcoxon test for equality of dispersion.</p></a></li>
<li><a href='#plot'><p>Method for plotting DepthCurve and DDPlot object.</p></a></li>
<li><a href='#plot,BinnDepth2d,ANY-method'><p>2d Binning plot</p></a></li>
<li><a href='#plot,DepthDensity,ANY-method'><p>Plot function for DepthDensity.</p></a></li>
<li><a href='#plot,LSDepthContour,ANY-method'><p>Plot Location-Scale depth contours.</p></a></li>
<li><a href='#RobReg-class'><p>RobReg</p></a></li>
<li><a href='#runifsphere'><p>Random number generation from unit sphere.</p></a></li>
<li><a href='#scaleCurve'><p>Scale curve</p></a></li>
<li><a href='#ScaleCurve-class'><p>ScaleCurve and ScaleCurveList</p></a></li>
<li><a href='#trimProjReg2d'><p>trimProjReg2d</p></a></li>
<li><a href='#TrimReg2d-class'><p>TrimReg2d</p></a></li>
<li><a href='#under5.mort'><p>Children under 5 months mortality rate per 1,000 live births</p></a></li>
<li><a href='#USLABOUR'><p>US Labour dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1.5</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Depth Functions for Multivariate Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Data depth concept offers a variety of powerful and user friendly
    tools for robust exploration and inference for multivariate data. The offered
    techniques may be successfully used in cases of lack of our knowledge on
    parametric models generating data due to their nature. The
    package consist of among others implementations of several data depth techniques
    involving multivariate quantile-quantile plots, multivariate scatter estimators,
    multivariate Wilcoxon tests and robust regressions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), ggplot2, Rcpp (&ge; 0.11.2), rrcov, methods, MASS,
np</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, sm, geometry, colorspace, zoo, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm, rgl, sn, robustbase, dplyr, RcppArmadillo, xts,
covr, testthat, fda, lintr, roxygen2, pkgbuild</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.depthproc.zstat.pl/">https://www.depthproc.zstat.pl/</a>,
<a href="https://github.com/zzawadz/DepthProc">https://github.com/zzawadz/DepthProc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zzawadz/DepthProc/issues">https://github.com/zzawadz/DepthProc/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-03 19:49:59 UTC; zzawadz</td>
</tr>
<tr>
<td>Author:</td>
<td>Zygmunt Zawadzki [aut, cre],
  Daniel Kosiorowski [aut],
  Krzysztof Slomczynski [ctb],
  Mateusz Bocian [ctb],
  Anna Wegrzynkiewicz [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zygmunt Zawadzki &lt;zygmunt@zstat.pl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-03 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abline+2CRobReg-method'>Add line to plot</h2><span id='topic+abline+2CRobReg-method'></span><span id='topic+abline+2CRobReg+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Add fitted line to a plot. This is overloaded function for robust regression methods from package depthproc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RobReg'
abline(
  a = NULL,
  b = NULL,
  h = NULL,
  v = NULL,
  reg = NULL,
  coef = NULL,
  untf = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abline+2B2CRobReg-method_+3A_a">a</code></td>
<td>
<p>an object of class RobReg</p>
</td></tr>
<tr><td><code id="abline+2B2CRobReg-method_+3A_b">b</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="abline+2B2CRobReg-method_+3A_h">h</code></td>
<td>
<p>not supported.</p>
</td></tr>
<tr><td><code id="abline+2B2CRobReg-method_+3A_v">v</code></td>
<td>
<p>not supported.</p>
</td></tr>
<tr><td><code id="abline+2B2CRobReg-method_+3A_reg">reg</code></td>
<td>
<p>not supported.</p>
</td></tr>
<tr><td><code id="abline+2B2CRobReg-method_+3A_coef">coef</code></td>
<td>
<p>not supported.</p>
</td></tr>
<tr><td><code id="abline+2B2CRobReg-method_+3A_untf">untf</code></td>
<td>
<p>not supported.</p>
</td></tr>
<tr><td><code id="abline+2B2CRobReg-method_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see par).</p>
</td></tr>
</table>

<hr>
<h2 id='as.matrix'>as.matrix method for DepthCurveList.</h2><span id='topic+as.matrix'></span><span id='topic+as.matrix+2CDepthCurveList-method'></span>

<h3>Description</h3>

<p>Create a matrix from DepthCurve and DepthCurveList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.matrix(x, ...)

## S4 method for signature 'DepthCurveList'
as.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix_+3A_x">x</code></td>
<td>
<p>an object of class that inherits from DepthCurveList (ScaleCurveList or AsymmetryCurveList).</p>
</td></tr>
<tr><td><code id="as.matrix_+3A_...">...</code></td>
<td>
<p>other arguments passed to standard as.matrix function.</p>
</td></tr>
</table>

<hr>
<h2 id='asymmetryCurve'>Asymmetry curve based on depths</h2><span id='topic+asymmetryCurve'></span>

<h3>Description</h3>

<p>Produces an asymmetry curve estimated from given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymmetryCurve(
  x,
  y = NULL,
  alpha = seq(0, 1, 0.01),
  movingmedian = FALSE,
  name = "X",
  name_y = "Y",
  depth_params = list(method = "Projection")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asymmetryCurve_+3A_x">x</code></td>
<td>
<p>The data as a matrix or data frame. If it is a matrix or data frame, then each row is viewed as one multivariate observation.</p>
</td></tr>
<tr><td><code id="asymmetryCurve_+3A_y">y</code></td>
<td>
<p>Additional matrix of multivariate data.</p>
</td></tr>
<tr><td><code id="asymmetryCurve_+3A_alpha">alpha</code></td>
<td>
<p>An ordered vector containing indices of central regins used for asymmetry curve calculation.</p>
</td></tr>
<tr><td><code id="asymmetryCurve_+3A_movingmedian">movingmedian</code></td>
<td>
<p>Logical. For default FALSE only one depth median is used to compute asymmetry norm. If TRUE &mdash; for every central area, a new depth median will be used &mdash; this approach needs much more time.</p>
</td></tr>
<tr><td><code id="asymmetryCurve_+3A_name">name</code></td>
<td>
<p>Name of set X &mdash; used in plot legend</p>
</td></tr>
<tr><td><code id="asymmetryCurve_+3A_name_y">name_y</code></td>
<td>
<p>Name of set Y &mdash; used in plot legend</p>
</td></tr>
<tr><td><code id="asymmetryCurve_+3A_depth_params">depth_params</code></td>
<td>
<p>list of parameters for function depth (method, threads, ndir, la, lb, pdim, mean, cov, exact).</p>
</td></tr>
<tr><td><code id="asymmetryCurve_+3A_method">method</code></td>
<td>
<p>Character string which determines the depth function used. The method can be &quot;Projection&quot; (the default), &quot;Mahalanobis&quot;, &quot;Euclidean&quot;, &quot;Tukey&quot; or &quot;LP&quot;. For details see <code><a href="#topic+depth">depth</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For sample depth function <code class="reqn"> D({x}, {{{Z}} ^ {n}}) </code>, <code class="reqn"> {x} \in {{{R}} ^ {d}} </code>, <code class="reqn"> d \ge 2 </code>, <code class="reqn"> {Z} ^ {n} = \{{{{z}}_{1}}, ..., {{{z}}_{n}}\} \subset {{{R}} ^ {d}} </code>, <code class="reqn"> {{D}_{\alpha}}({{{Z}} ^ {n}}) </code> denoting <code class="reqn"> \alpha </code> &mdash; central region, we can define the asymmetry curve <code class="reqn"> AC(\alpha) = \left(\alpha, \left\| {{c} ^ {-1}}(\{{\bar{z}} - med|{{D}_{\alpha}}({{{Z}} ^ {n}})\}) \right\|\right) \subset {{{R}} ^ {2}} </code>, for <code class="reqn"> \alpha \in [0, 1] </code> being nonparametric scale and asymmetry functional correspondingly, where <code class="reqn"> c </code> &mdash; denotes constant, <code class="reqn"> {\bar{z}} </code> &mdash; denotes mean vector, denotes multivariate median induced by depth function and <code class="reqn"> vol </code> &mdash; denotes a volume.
</p>
<p>Asymmetry curve takes uses function convhulln from package geometry for computing a volume of convex hull containing central region.
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>References</h3>

<p>Serfling R. J. Multivariate Symmetry and Asymmetry, <em>Encyclopedia of Statistical Science</em>, S Kotz, C.B. Read, N. Balakrishnan, B. Vidakovic (eds), 2nd, ed., John Wiley.
</p>
<p>Liu, R.Y., Parelius, J.M. and Singh, K. (1999), Multivariate analysis by data depth: Descriptive statistics, graphics and inference (with discussion), <em>Ann. Statist.</em>, <b>27</b>, 783&ndash;858.
</p>
<p>Chaudhuri, P. (1996), On a Geometric Notion of Quantiles for Multivariate Data, <em>Journal of the American Statistical Association</em>, 862&ndash;872.
</p>
<p>Dyckerhoff, R. (2004), Data Depths Satisfying the Projection Property, <em>Allgemeines Statistisches Archiv.</em>, <b>88</b>, 163&ndash;190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scaleCurve">scaleCurve</a></code>, <code><a href="#topic+depth">depth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1
library(sn)
xi &lt;- c(0, 0)
alpha &lt;- c(2, -5)
Omega &lt;- diag(2) * 5

n &lt;- 500
X &lt;- mvrnorm(n, xi, Omega) # normal distribution
Y &lt;- rmst(n, xi, Omega, alpha, nu = 1)
asymmetryCurve(X, Y, name = "NORM", name_y = "S_T(2, -5, 10)")

# EXAMPLE 2
data(under5.mort)
data(inf.mort)
data(maesles.imm)
data1990 &lt;- cbind(under5.mort[, 1], inf.mort[, 1], maesles.imm[, 1])
data2011 &lt;- cbind(under5.mort[, 22], inf.mort[, 22], maesles.imm[, 22])
as1990 &lt;- asymmetryCurve(data1990, name = "scale curve 1990")
as2011 &lt;- asymmetryCurve(data2011, name = "scale curve 2011")
figure &lt;- getPlot(combineDepthCurves(as1990, as2011)) +
  ggtitle("Scale curves")
figure

</code></pre>

<hr>
<h2 id='AsymmetryCurve-class'>AsymmetryCurve and AsymmetryCurveList</h2><span id='topic+AsymmetryCurve-class'></span>

<h3>Description</h3>

<p>AsymmetryCurve is a class that stores results of <a href="#topic+asymmetryCurve">asymmetryCurve</a> function.
</p>


<h3>Details</h3>

<p>The mechanism of creating plots with multiple curves is shown in <a href="#topic+DepthCurve-class">DepthCurve-class</a> (same mechanism is applied for ScaleCurve).
</p>

<hr>
<h2 id='BinnDepth2d-class'>BinnDepth2d</h2><span id='topic+BinnDepth2d-class'></span>

<h3>Description</h3>

<p>Class that stores result of function binningDepth2D(...)
</p>


<h3>Slots</h3>


<dl>
<dt><code>freq</code></dt><dd><p>Matrix with number of elements in certain bin.</p>
</dd>
<dt><code>mid_x</code></dt><dd><p>Middle values on x-axis.</p>
</dd>
<dt><code>mid_y</code></dt><dd><p>Middle values on y-axis.</p>
</dd>
<dt><code>breaks_x</code></dt><dd><p>Boundaries of bins.</p>
</dd>
<dt><code>breaks_y</code></dt><dd><p>Boundaries of bins.</p>
</dd>
<dt><code>input_data</code></dt><dd><p>Binned data.</p>
</dd>
<dt><code>max_depth_x</code></dt><dd><p>Point with maximum depth on x-axis.</p>
</dd>
<dt><code>max_depth_y</code></dt><dd><p>Point with maximum depth on y-axis.</p>
</dd>
</dl>

<hr>
<h2 id='binningDepth2D'>2d Binning</h2><span id='topic+binningDepth2D'></span>

<h3>Description</h3>

<p>A robust method of decreasing a sample size and therefore a complexity of a statistical procedure. The method may be used within a kernel density or a predictive distribution estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binningDepth2D(
  x,
  binmethod = "LocDepth",
  nbins = 8,
  k = 1,
  remove_borders = FALSE,
  depth_params = list(method = "LP")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binningDepth2D_+3A_x">x</code></td>
<td>
<p>bivariate matrix containing data. Each row is viewed as one two-dimensional observation.</p>
</td></tr>
<tr><td><code id="binningDepth2D_+3A_binmethod">binmethod</code></td>
<td>
<p>A method for calculation center and dispersion measures. &quot;LocDepth&quot; uses location-scale depth, MAD uses median and MAD in each dimension.</p>
</td></tr>
<tr><td><code id="binningDepth2D_+3A_nbins">nbins</code></td>
<td>
<p>number of bins in each dimension</p>
</td></tr>
<tr><td><code id="binningDepth2D_+3A_k">k</code></td>
<td>
<p>responsible for tightness of bins.</p>
</td></tr>
<tr><td><code id="binningDepth2D_+3A_remove_borders">remove_borders</code></td>
<td>
<p>Logical, include or not marginal bins</p>
</td></tr>
<tr><td><code id="binningDepth2D_+3A_depth_params">depth_params</code></td>
<td>
<p>other arguments passed to depthMedian</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let us recall, that binning is a popular method of decreasing a sample size. To bin a window of <code class="reqn"> n </code> points <code class="reqn"> {W}_{i, n} = \left\{ {X}_{i - n + 1}, ..., {X}_{i} \right\} </code> to a grid <code class="reqn"> {{{X}'}_{1}}, ..., {{{X}'}_{m}} </code> we simply assign each sample point <code class="reqn"> {{X}_{i}} </code> to the nearest grid point <code class="reqn"> {{{X}'}_{j}} </code>. When binning is completed, each grid point <code class="reqn"> {{X}'}_{j} </code> has an associated number <code class="reqn"> {c}_{i} </code>, which is the sum of all the points that have been assigned to <code class="reqn"> {{X}'}_{j} </code>. This procedure replaces the data <code class="reqn"> {W}_{i, n} = \left\{ {X}_{i - n + 1}, ..., {X}_{i} \right\} </code> with the smaller set <code class="reqn"> {{W}'}_{j, m} = \left\{ {{X}'}_{j - m + 1}, ..., {{X}'}_{j} \right\} </code>. Although simple binning can speed up the computation, it is criticized for a lack of precise approximate control over the accuracy of the approximation. Robust binning however stresses properties of the majority of the data and decreases the computational complexity of the DSA at the same time.
</p>
<p>For a 1D window <code class="reqn"> {W}_{i, n} </code>, let <code class="reqn"> {Z}_{i, n - k} </code> denote a 2D window created basing on <code class="reqn"> {W}_{i, n} </code> and consisted of <code class="reqn"> n - k </code> pairs of observations and the <code class="reqn"> k </code> lagged observations <code class="reqn"> {Z}_{i, n - k} = \left\{\left( {X}_{i - n - k}, {X}_{i - n + 1} \right)\right\}, 1\le i\le n - k </code>. Robust 2D binning of the <code class="reqn"> {Z}_{i, n - p} </code> is a very useful technique in a context of robust estimation of the predictive distribution of a time series (see <cite>Kosiorowski:2013b</cite>).
</p>
<p>Assume we analyze a data stream <code class="reqn"> \{{X}_{t}\} </code> using a moving window of a fixed length <code class="reqn"> n </code>, i.e., <code class="reqn"> {W}_{i, n} </code> and the derivative window <code class="reqn"> {Z}_{i, n - 1} </code>. In a first step we calculate the weighted sample <code class="reqn"> L ^ p </code> depth for <code class="reqn"> {W}_{i, n} </code>. Next we choose equally spaced grid of points <code class="reqn"> {l}_{1}, ..., {l}_{m} </code> in this way that <code class="reqn"> [{{l}_{1}}, {{l}_{m}}] \times [{{l}_{1}}, {{l}_{m}}] </code> covers fraction of the <code class="reqn"> \beta </code> central points of <code class="reqn"> {Z}_{i, n - 1} </code> w.r.t. the calculated <code class="reqn"> L ^ p </code> depth, i.e., it covers <code class="reqn"> {R} ^ {\beta}({Z}_{i, n - 1}) </code> for certain prefixed threshold <code class="reqn"> \beta \in (0, 1) </code>. For both <code class="reqn"> {X}_{t} </code> and <code class="reqn"> {X}_{t - 1} </code> we perform a simple binning using following bins: <code class="reqn"> (-\infty, {l}_{1}) </code>, <code class="reqn"> ({l}_{1}, {l}_{2}) </code>, ..., <code class="reqn"> ({l}_{m}, \infty) </code>. For robust binning we reject &quot;border&quot; classes and further use only midpoints and binned frequencies for classes <code class="reqn"> ({l}_{1}, {l}_{2}) </code>, <code class="reqn"> ({l}_{2}, {l}_{3}) </code>, ..., <code class="reqn"> ({l}_{m - 1}, {l}_{m}) </code>.
</p>


<h3>Value</h3>

<p>freq: a matrix containing the binned frequencies
</p>
<p>mid_x: mid points for x
</p>
<p>mid_y: mid points for y
</p>
<p>breaks_x: breaks for x
</p>
<p>breaks_y: breaks for y
</p>
<p>input_data: max_depth_x and max_depth_y:
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>References</h3>

<p>Hall, P., Wand, M. P. (1996) On the Accuracy of Binned Kernel Density Estimators, Journal of Multivariate Analysis archive, Volume 56 Issue 2, 165&ndash;184
</p>
<p>Holmstrom, L. (2000) The Accuracy and the Computational Complexity of a Multivariate Binned Kernel Density Estimator, Journal of Multivariate Analysis, Volume 72, Issue 2, 264&ndash;309, doi: <a href="https://doi.org/10.1006/jmva.1999.1863">10.1006/jmva.1999.1863</a>. (<a href="https://www.sciencedirect.com/science/article/pii/S0047259X99918638">https://www.sciencedirect.com/science/article/pii/S0047259X99918638</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+depth">depth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1
Sigma1 &lt;- matrix(c(10, 3, 3, 2), 2, 2)
X1 &lt;- mvrnorm(n = 8500, mu = c(0, 0), Sigma1)
Sigma2 &lt;- matrix(c(10, 0, 0, 2), 2, 2)
X2 &lt;- mvrnorm(n = 1500, mu = c(-10, 6), Sigma2)
BALLOT &lt;- rbind(X1, X2)
train &lt;- sample(1:10000, 500)
data &lt;- BALLOT[train, ]
plot(data)

b1 &lt;- binningDepth2D(data, remove_borders = FALSE, nbins = 12, k = 1)
b2 &lt;- binningDepth2D(data, nbins = 12, k = 1, remove_borders = TRUE)
plot(b1)
plot(b2)

# EXAMPLE 2
data(under5.mort)
data(maesles.imm)
data2011 &lt;- cbind(under5.mort[, 22], maesles.imm[, 22])
plot(binningDepth2D(data2011, nbins = 8, k = 0.5, remove_borders = TRUE))

</code></pre>

<hr>
<h2 id='combineDepthCurves'>Adds plots</h2><span id='topic+combineDepthCurves'></span><span id='topic+combineDepthCurves+2CANY+2CANY+2Clist-method'></span><span id='topic+combineDepthCurves+2CDepthCurveList+2CDepthCurve+2CANY-method'></span><span id='topic+combineDepthCurves+2CDepthCurve+2CDepthCurveList+2CANY-method'></span><span id='topic+combineDepthCurves+2CDepthCurve+2CDepthCurve+2CANY-method'></span>

<h3>Description</h3>

<p>Adds plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineDepthCurves(x, y, .list = NULL)

## S4 method for signature 'ANY,ANY,list'
combineDepthCurves(x, y, .list = NULL)

## S4 method for signature 'DepthCurveList,DepthCurve,ANY'
combineDepthCurves(x, y, .list = NULL)

## S4 method for signature 'DepthCurve,DepthCurveList,ANY'
combineDepthCurves(x, y, .list = NULL)

## S4 method for signature 'DepthCurve,DepthCurve,ANY'
combineDepthCurves(x, y, .list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineDepthCurves_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="combineDepthCurves_+3A_y">y</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="combineDepthCurves_+3A_.list">.list</code></td>
<td>
<p>list of plots to combine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+DepthCurve-class">DepthCurve-class</a></code> for description.
</p>

<hr>
<h2 id='CovDepthWeighted-class'>CovLP</h2><span id='topic+CovDepthWeighted-class'></span>

<h3>Description</h3>

<p>This class, derived from the virtual class &quot;CovRobust&quot; accomodates weighted by <code class="reqn"> L ^ p </code> depth multivariate location and scatter estimator.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+CovLP">CovLP</a></code> for the function used to calculate weighted by <code class="reqn"> L ^ p </code> depth covariance matrix.
</p>

<hr>
<h2 id='CovLP'>CovLp</h2><span id='topic+CovLP'></span>

<h3>Description</h3>

<p>Weighted by <code class="reqn"> L ^ p </code> depth (outlyingness) multivariate location and scatter estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovLP(x, pdim = 2, la = 1, lb = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovLP_+3A_x">x</code></td>
<td>
<p>The data as a matrix or data frame. If it is a matrix or data frame, then each row is viewed as one multivariate observation.</p>
</td></tr>
<tr><td><code id="CovLP_+3A_pdim">pdim</code></td>
<td>
<p>The parameter of the weighted <code class="reqn"> {L} ^ {p} dim </code> depth</p>
</td></tr>
<tr><td><code id="CovLP_+3A_la">la</code></td>
<td>
<p>parameter of a simple weight function <code class="reqn"> w = ax + b </code></p>
</td></tr>
<tr><td><code id="CovLP_+3A_lb">lb</code></td>
<td>
<p>parameter of a simple weight function <code class="reqn"> w = ax + b </code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using depth function one can define a depth-weighted location and scatter estimators. In case of location estimator we have </p>
<p style="text-align: center;"><code class="reqn"> L(F) = {\int {{x}{{w}_{1}}(D({x}, F))dF({x})}} / {{{w}_{1}}(D({x}, F))dF({x})} </code>
</p>
<p> Subsequently, a depth-weighted scatter estimator is defined as </p>
<p style="text-align: center;"><code class="reqn"> S(F) = \frac{ \int {({x} - L(F)){{({x} - L(F))} ^ {T}}{{w}_{2}}(D({x}, F))dF({x})} }{ \int {{{w}_{2}}(D({x}, F))dF({x})}}, </code>
</p>
<p> where <code class="reqn"> {{w}_{2}}(\cdot) </code> is a suitable weight function that can be different from <code class="reqn"> {{w}_{1}}(\cdot) </code>.
</p>
<p>The <span class="pkg">DepthProc</span> package offers these estimators for weighted <code class="reqn"> {L} ^ {p} </code> depth. Note that <code class="reqn"> L(\cdot) </code> and <code class="reqn"> S(\cdot) </code> include multivariate versions of trimmed means and covariance matrices. Their sample counterparts take the form </p>
<p style="text-align: center;"><code class="reqn"> {{T}_{WD}}({{{X}} ^ {n}}) = {\sum\limits_{i = 1} ^ {n} {{{d}_{i}}{{X}_{i}}}} / {\sum\limits_{i = 1} ^ {n} {{{d}_{i}}}}, </code>
</p>
 <p style="text-align: center;"><code class="reqn"> DIS({{{X}}^{n}}) = \frac{ \sum\limits_{i = 1} ^ {n} {{{d}_{i}}\left( {{{X}}_{i}} - {{T}_{WD}}({{{X}} ^ {n}}) \right){{\left( {{{X}}_{i}} - {{T}_{WD}}({{{X}} ^ {n}}) \right)} ^ {T}}} }{ \sum\limits_{i = 1} ^ {n} {{{d}_{i}}}}, </code>
</p>
<p> where <code class="reqn"> {{d}_{i}} </code> are sample depth weights, <code class="reqn"> {{w}_{1}}(x) = {{w}_{2}}(x) = x </code>.
</p>


<h3>Value</h3>

<p>loc: Robust Estimate of Location:
</p>
<p>cov: Robust Estimate of Covariance:
</p>
<p>Returns depth weighted covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+depthContour">depthContour</a></code> and <code><a href="#topic+depthPersp">depthPersp</a></code> for depth graphics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1
x &lt;- mvrnorm(n = 100, mu = c(0, 0), Sigma = 3 * diag(2))
cov_x &lt;- CovLP(x, 2, 1, 1)

# EXAMPLE 2
data(under5.mort, inf.mort, maesles.imm)
data1990 &lt;- na.omit(cbind(under5.mort[, 1], inf.mort[, 1], maesles.imm[, 1]))
CovLP(data1990)

</code></pre>

<hr>
<h2 id='cracow.airpollution'>Air pollution with PM10 in Cracow within day and night in December 2016</h2><span id='topic+cracow.airpollution'></span>

<h3>Description</h3>

<p>Air pollution with PM10 in Cracow within day and night in December 2016
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("cracow.airpollution")
</code></pre>


<h3>Format</h3>

<p>data frame containing 744 rows.
</p>


<h3>References</h3>

<p>1. Kosiorowski D, Rydlewski J P, Zawadzki Z (2017). 'Functional Outliers Detection By The Example Of Air Quality Monitoring.' submitted.
</p>
<p>2. Kosiorowski D, Szlachtowska E (2017). 'K- local Median Algorithm for Functional Data in Empirical Analysis of Air Pollution Data.' Proceedings from the 11th Professor A. Zelias International Conference, pp. 153-162. Cracow University of Economics.
</p>

<hr>
<h2 id='ddmvnorm'>Normal depth versus depth plot</h2><span id='topic+ddmvnorm'></span><span id='topic+ddMvnorm'></span>

<h3>Description</h3>

<p>Produces a normal DD plot of a multivariate dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddMvnorm(
  x,
  size = nrow(x),
  robust = FALSE,
  alpha = 0.05,
  title = "ddMvnorm",
  depth_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddmvnorm_+3A_x">x</code></td>
<td>
<p>The data sample for DD plot.</p>
</td></tr>
<tr><td><code id="ddmvnorm_+3A_size">size</code></td>
<td>
<p>size of theoretical set</p>
</td></tr>
<tr><td><code id="ddmvnorm_+3A_robust">robust</code></td>
<td>
<p>Logical. Default <code>FALSE</code>. If <code>TRUE</code>, robust measures are used to specify the parameters of theoretical distribution.</p>
</td></tr>
<tr><td><code id="ddmvnorm_+3A_alpha">alpha</code></td>
<td>
<p>cutoff point for robust measure of covariance.</p>
</td></tr>
<tr><td><code id="ddmvnorm_+3A_title">title</code></td>
<td>
<p>title of a plot.</p>
</td></tr>
<tr><td><code id="ddmvnorm_+3A_depth_params">depth_params</code></td>
<td>
<p>list of parameters for function depth (method, threads, ndir, la, lb, pdim, mean, cov, exact).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the first step the location and scale of x are estimated and theoretical sample from normal distribution with those parameters is generated. The plot presents the depth of empirical points with respect to dataset x and with respect to the theoretical sample.
</p>


<h3>Value</h3>

<p>Returns the normal depth versus depth plot of multivariate dataset <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>References</h3>

<p>Liu, R.Y., Parelius, J.M. and Singh, K. (1999), Multivariate analysis by data depth: Descriptive statistics, graphics and inference (with discussion), Ann. Statist., 27, 783&ndash;858.
</p>
<p>Liu, R.Y., Singh K. (1993), A Quality Index Based on Data Depth and Multivariate Rank Test, <em>Journal of the American Statistical Association</em> vol. 88.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddPlot">ddPlot</a></code> to generate ddPlot to compare to datasets or to compare a dataset with other distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1
norm &lt;- mvrnorm(1000, c(0, 0, 0), diag(3))
con &lt;- mvrnorm(100, c(1, 2, 5), 3 * diag(3))
sample &lt;- rbind(norm, con)
ddMvnorm(sample, robust = TRUE)

# EXAMPLE 2
data(under5.mort, inf.mort, maesles.imm)
data1990 &lt;- na.omit(cbind(under5.mort[, 1], inf.mort[, 1], maesles.imm[, 1]))
ddMvnorm(data1990, robust = FALSE)

</code></pre>

<hr>
<h2 id='ddPlot'>Depth versus depth plot</h2><span id='topic+ddPlot'></span>

<h3>Description</h3>

<p>Produces a DD plot which allows to compare two multivariate datasets or to compare a subject dataset with theoretical distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddPlot(
  x,
  y,
  scale = FALSE,
  location = FALSE,
  name = "X",
  name_y = "Y",
  title = "Depth vs. depth plot",
  depth_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddPlot_+3A_x">x</code></td>
<td>
<p>The first or only data sample for ddPlot.</p>
</td></tr>
<tr><td><code id="ddPlot_+3A_y">y</code></td>
<td>
<p>The second data sample. <code>x</code> and <code>y</code> must be of the same space.</p>
</td></tr>
<tr><td><code id="ddPlot_+3A_scale">scale</code></td>
<td>
<p>logical. determines whether the dispersion is to be aligned.</p>
</td></tr>
<tr><td><code id="ddPlot_+3A_location">location</code></td>
<td>
<p>determines whether the location is to be aligned to 0 vector with depth median.</p>
</td></tr>
<tr><td><code id="ddPlot_+3A_name">name</code></td>
<td>
<p>name for data set x. It will be passed to drawing function.</p>
</td></tr>
<tr><td><code id="ddPlot_+3A_name_y">name_y</code></td>
<td>
<p>as above for y</p>
</td></tr>
<tr><td><code id="ddPlot_+3A_title">title</code></td>
<td>
<p>title of the plot.</p>
</td></tr>
<tr><td><code id="ddPlot_+3A_depth_params">depth_params</code></td>
<td>
<p>list of parameters for function depth (method, threads, ndir, la, lb, pdim, mean, cov, exact).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two probability distributions <code class="reqn"> F </code> and <code class="reqn"> G </code>, both in <code class="reqn"> {{{R}} ^ {d}} </code>, we can define <code>depth vs. depth</code> plot being very useful generalization of the one dimensional quantile-quantile plot: </p>
<p style="text-align: center;"><code class="reqn"> DD(F, G) = \left\{\left( D({z}, F), D({z}, G) \right), {z} \in {{{R}} ^ {d}} \right\} </code>
</p>

<p>Its sample counterpart calculated for two samples <code class="reqn"> {{{X}} ^ {n}} = \{{{X}_{1}}, ..., {{X}_{n}}\} </code> from <code class="reqn"> F </code>, and <code class="reqn"> {{Y} ^ {m}} = \{{{Y}_{1}}, ..., {{Y}_{m}}\} </code> from <code class="reqn"> G </code> is defined as </p>
<p style="text-align: center;"><code class="reqn"> DD({{F}_{n}}, {{G}_{m}}) = \left\{\left( D({z}, {{F}_{n}}), D({z}, {{G}_{m}}) \right), {z} \in \{{{{X}} ^ {n}} \cup {{{Y}} ^ {m}}\} \right\} </code>
</p>



<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>References</h3>

<p>Liu, R.Y., Parelius, J.M. and Singh, K. (1999), Multivariate analysis by data depth: Descriptive statistics, graphics and inference (with discussion), <em>Ann. Statist.</em>, <b>27</b>, 822&ndash;831.
</p>
<p>Liu, R.Y., Singh K. (1993), A Quality Index Based on Data Depth and Multivariate Rank Test, <em>Journal of the American Statistical Association</em> vol. 88.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sn)
library(mvtnorm)

# EXAMPLE 1: Location difference
standard &lt;- mvrnorm(1000, c(0, 0), diag(2))
shift &lt;- mvrnorm(1000, c(0.5, 0), diag(2))
ddPlot(x = standard, y = shift, title = "Difference in position")
ddPlot(x = standard, y = shift, location = TRUE, title = "Location aligned")

# EXAMPLE 2: Scale difference
standard &lt;- mvrnorm(1000, c(0, 0), diag(2))
scale &lt;- mvrnorm(1000, c(0, 0), 4 * diag(2))
ddPlot(x = standard, y = scale)
ddPlot(x = standard, y = scale, scale = TRUE)

</code></pre>

<hr>
<h2 id='DDPlot-class'>DDPlot</h2><span id='topic+DDPlot-class'></span>

<h3>Description</h3>

<p>Class fro DDPlot
</p>


<h3>Slots</h3>


<dl>
<dt><code>X</code></dt><dd><p>Object of class <a href="#topic+Depth-class">Depth-class</a>.</p>
</dd>
<dt><code>Y</code></dt><dd><p>Object of class <a href="#topic+Depth-class">Depth-class</a>.</p>
</dd>
<dt><code>title</code></dt><dd><p>title of a plot.</p>
</dd>
</dl>

<hr>
<h2 id='deepReg2d'>Simple deepest regression method.</h2><span id='topic+deepReg2d'></span>

<h3>Description</h3>

<p>This function calculates deepest regression estimator for simple regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deepReg2d(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deepReg2d_+3A_x">x</code></td>
<td>
<p>Independent variable.</p>
</td></tr>
<tr><td><code id="deepReg2d_+3A_y">y</code></td>
<td>
<p>Dependent variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function originates from an original algorithm proposed by Rousseeuw and Hubert. Let <code class="reqn"> {Z} ^ {n} = {(x_1, y_1), ..., (x_n, y_n)} \subset {{R} ^ {d}} </code> denotes a sample considered from a following semiparametric model: <code class="reqn"> {{y}_{l}} = {{a}_{0}} + {{a}_{1}}{{x}_{1l}} + ... + {{a}_{(d - 1)l}}{{x}_{(d - 1)l}} + {{\varepsilon }_{l}}, {l = 1, ..., n} </code>, we calculate a depth of a fit <code class="reqn"> \alpha = (a_{0}, ..., a_{d - 1}) </code> as <code class="reqn"> RD(\alpha, {{Z} ^ {n}}) = {u \ne 0}\min\sharp {l: \frac{ {{r}_{l}}(\alpha) }{ {{u} ^ {T}}{{x}_{l}} } &lt; 0, l = 1, ..., n} </code>, where <code class="reqn"> r(\cdot) </code> denotes the regression residual, <code class="reqn"> \alpha = (a_{0}, ..., a_{d - 1}) </code>, <code class="reqn"> {u} ^ {T}{x}_{l} \ne 0 </code>. <code>The deepest regression estimator</code> <code class="reqn"> DR(\alpha, {{Z} ^ {n}}) </code> is defined as <code class="reqn"> DR(\alpha, {{Z} ^ {n}}) = {\alpha \ne 0}\,\arg\max\,RD(\alpha, {{Z} ^ {n}}) </code>
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>References</h3>

<p>Rousseeuw J.P., Hubert M. (1998), Regression Depth, <em>Journal of The American Statistical Association</em>, vol.94.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1
data(pension)
plot(pension)
abline(
  lm(Reserves ~ Income, data = pension),
  lty = 3,
  lwd = 2) # lm
abline(
  deepReg2d(pension[, 1], pension[, 2]),
  lwd = 2) # deepreg2d

# EXAMPLE 2
data(under5.mort)
data(inf.mort)
data(maesles.imm)
data2011 &lt;- na.omit(
    cbind(under5.mort[, 22], inf.mort[, 22],
    maesles.imm[, 22]))

x &lt;- data2011[, 3]
y &lt;- data2011[, 2]
plot(
  x, y,
  cex = 1.2,
  ylab = "infant mortality rate per 1000 live birth",
  xlab = "against masles immunized percentage",
  main = "Projection Depth Trimmed vs. LS regressions"
)
abline(lm(x ~ y), lwd = 2, col = "black") # lm
abline(
  deepReg2d (x, y),
  lwd = 2, col = "red"
) # trimmed reg

legend(
  "bottomleft",
  c("LS", "DeepReg"),
  fill = c("black", "red"),
  cex = 1.4,
  bty = "n"
)
</code></pre>

<hr>
<h2 id='DeepReg2d-class'>DeepReg2d</h2><span id='topic+DeepReg2d-class'></span>

<h3>Description</h3>

<p>Class for robust regression methods from depthproc package
</p>


<h3>Slots</h3>


<dl>
<dt><code>coef</code></dt><dd><p>coefficients of fitted model</p>
</dd>
<dt><code>depth</code></dt><dd><p>regression depth of the fitted values</p>
</dd>
</dl>

<hr>
<h2 id='depth'>Depth calculation</h2><span id='topic+depth'></span>

<h3>Description</h3>

<p>Calculate depth functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth(u, X, method = "Projection", threads = -1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_+3A_u">u</code></td>
<td>
<p>Numerical vector or matrix whose depth is to be calculated. Dimension has to be the same as that of the observations.</p>
</td></tr>
<tr><td><code id="depth_+3A_x">X</code></td>
<td>
<p>The data as a matrix, data frame or list. If it is a matrix or data frame, then each row is viewed as one multivariate observation. If it is a list, all components must be numerical vectors of equal length (coordinates of observations).</p>
</td></tr>
<tr><td><code id="depth_+3A_method">method</code></td>
<td>
<p>Character string which determines the depth function. <code>method</code> can be &quot;Projection&quot; (the default), &quot;Mahalanobis&quot;, &quot;Euclidean&quot; or &quot;Tukey&quot;. For details see <code><a href="#topic+depth">depth</a></code>.</p>
</td></tr>
<tr><td><code id="depth_+3A_threads">threads</code></td>
<td>
<p>number of threads used in parallel computations. Default value -1 means that all possible cores will be used.</p>
</td></tr>
<tr><td><code id="depth_+3A_...">...</code></td>
<td>
<p>parameters specific to method &mdash; see <code><a href="#topic+depthEuclid">depthEuclid</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Mahalanobis depth </p>
<p style="text-align: center;"><code class="reqn"> {D}_{MAH}(y, {X} ^ {n}) = \frac{ 1 }{ 1 + {{(y - \bar{x})} ^ {T}}{{S} ^ {-1}}(y - \bar{x}) }, </code>
</p>
<p> where <code class="reqn"> S </code> denotes the sample covariance matrix <code class="reqn"> {X} ^ {n} </code>.
</p>
<p>A symmetric projection depth <code class="reqn"> D\left( x, X\right) </code> of a point <code class="reqn"> x \in {{{R}} ^ {d}} </code>, <code class="reqn"> d \ge 1 </code> is defined as
</p>
<p style="text-align: center;"><code class="reqn"> D\left( x, X\right)_{PRO} = {{\left[ 1 + su{{p}_{\left\| u \right\| = 1}}\frac{ \left| {{u} ^ {T}}x - Med\left( {{u} ^ {T}}X\right)\right| }{ MAD\left( {{u} ^ {T}}X\right) }\right]} ^ {-1}}, </code>
</p>

<p>where Med denotes the univariate median, <code class="reqn"> MAD\left( Z \right) </code> = <code class="reqn"> Med\left(\left| Z - Med\left( Z \right)\right|\right) </code>. Its sample version denoted by <code class="reqn"> D\left( x, {X} ^ {n} \right) </code> or <code class="reqn"> D\left( x, {X} ^ {n} \right) </code> is obtained by replacing <code class="reqn"> F </code> by its empirical counterpart <code class="reqn"> {{F}_{n}} </code> calculated from the sample <code class="reqn"> {X} ^ {n} </code> .
</p>
<p>Next interesting depth is the weighted <code class="reqn"> {L} ^ {p} </code> depth. The weighted <code class="reqn"> {L} ^ {p} </code> depth <code class="reqn"> D({x}, F) </code> of a point <code class="reqn"> {x} \in {R} ^ {d} </code>, <code class="reqn"> d \ge 1 </code> generated by <code class="reqn"> d </code> dimensional random vector <code class="reqn"> {X} </code> with distribution <code class="reqn"> F </code>, is defined as <code class="reqn"> D({x}, F) = \frac{1 }{ 1 + Ew({{\left\| x - X \right\| }_{p}}) }, </code> where <code class="reqn"> w </code> is a suitable weight function on <code class="reqn"> [0, \infty) </code>, and <code class="reqn"> {{\left\| \cdot \right\| }_{p}} </code> stands for the <code class="reqn"> {L} ^ {p} </code> norm (when p = 2 we have usual Euclidean norm). We assume that <code class="reqn"> w </code> is non-decreasing and continuous on <code class="reqn"> [0, \infty) </code> with <code class="reqn"> w(\infty-) = \infty </code>, and for <code class="reqn"> a, b \in {{{R}} ^ {d}} </code> satisfying <code class="reqn"> w(\left\| a + b \right\|) \le w(\left\| a \right\|) + w(\left\| b \right\|) </code>. Examples of the weight functions are: <code class="reqn"> w(x) = a + bx </code>, <code class="reqn"> a, b &gt; 0 </code> or <code class="reqn"> w(x) = {x} ^ {\alpha} </code>. The empirical version of the weighted <code class="reqn"> {L} ^ {p} </code> depth is obtained by replacing distribution <code class="reqn"> F </code> of <code class="reqn"> {X} </code> in <code class="reqn"> Ew({{\left\| {x} - {X} \right\| }_{p}}) = \int {w({{\left\| x - t \right\| }_{p}})}dF(t) </code> by its empirical counterpart calculated from the sample <code class="reqn"> {{{X}} ^ {n}} </code>...
</p>
<p>The Projection and Tukey's depths are calculated using an approximate algorithm. Calculations of Mahalanobis, Euclidean and <code class="reqn"> L ^ p </code> depths are exact. Returns the depth of multivariate point u with respect to data set X.
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>References</h3>

<p>Liu, R.Y., Parelius, J.M. and Singh, K. (1999), Multivariate analysis by data depth: Descriptive statistics, graphics and inference (with discussion), Ann. Statist., 27, 783&ndash;858.
</p>
<p>Mosler K (2013). Depth statistics. In C Becker, R Fried, K S (eds.), Robustness and Complex Data Structures, Festschrift in Honour of Ursula Gather, pp. 17&ndash;34. Springer.
</p>
<p>Rousseeuw, P.J. and Struyf, A. (1998), Computing location depth and regression depth in higher dimensions, Stat. Comput., 8, 193&ndash;203.
</p>
<p>Zuo, Y. and Serfling, R. (2000), General Notions of Statistical Depth Functions, Ann. Statist., 28, no. 2, 461&ndash;482.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+depthContour">depthContour</a></code> and <code><a href="#topic+depthPersp">depthPersp</a></code> for depth graphics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(robustbase)

# Calculation of Projection depth
data(starsCYG, package = "robustbase")
depth(t(colMeans(starsCYG)), starsCYG)

# Also for matrices
depth(starsCYG, starsCYG)

# Projection depth applied to a large bivariate data set
x &lt;- matrix(rnorm(9999), nc = 3)
depth(x, x)

</code></pre>

<hr>
<h2 id='Depth-class'>Depth</h2><span id='topic+Depth-class'></span>

<h3>Description</h3>

<p>Virtual class with structure for every depth class from depthproc package.
</p>


<h3>Slots</h3>


<dl>
<dt><code>u</code></dt><dd><p>data set.</p>
</dd>
<dt><code>X</code></dt><dd><p>reference set.</p>
</dd>
<dt><code>method</code></dt><dd><p>depth type.</p>
</dd>
</dl>

<hr>
<h2 id='depthContour'>Approximate depth contours</h2><span id='topic+depthContour'></span>

<h3>Description</h3>

<p>Draws an approximate contours of depth for bivariate data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthContour(
  x,
  xlim = extendrange(x[, 1], f = 0.1),
  ylim = extendrange(x[, 2], f = 0.1),
  n = 50,
  pmean = TRUE,
  mcol = "blue",
  pdmedian = TRUE,
  mecol = "brown",
  legend = TRUE,
  points = FALSE,
  colors = heat_hcl,
  levels = 10,
  depth_params = list(),
  graph_params = list(),
  contour_method = c("auto", "convexhull", "contour")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthContour_+3A_x">x</code></td>
<td>
<p>Bivariate data</p>
</td></tr>
<tr><td><code id="depthContour_+3A_xlim">xlim</code></td>
<td>
<p>Determines the width of x-axis.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_ylim">ylim</code></td>
<td>
<p>Determines the width of y-axis.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_n">n</code></td>
<td>
<p>Number of points in each coordinate direction to be used in contour plot.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_pmean">pmean</code></td>
<td>
<p>Logical. If TRUE mean will be marked.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_mcol">mcol</code></td>
<td>
<p>Determines the color of lines describing the mean.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_pdmedian">pdmedian</code></td>
<td>
<p>Logical. If TRUE depth median will be marked.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_mecol">mecol</code></td>
<td>
<p>Determines the color of lines describing the depth median.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_legend">legend</code></td>
<td>
<p>Logical. If TRUE legend for mean and depth median will be drawn.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_points">points</code></td>
<td>
<p>Logical. If TRUE points from matrix x will be drawn.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_colors">colors</code></td>
<td>
<p>function for colors pallete (e.g. gray.colors).</p>
</td></tr>
<tr><td><code id="depthContour_+3A_levels">levels</code></td>
<td>
<p>number of levels for color scale.</p>
</td></tr>
<tr><td><code id="depthContour_+3A_depth_params">depth_params</code></td>
<td>
<p>list of parameters for function depth (method, threads, ndir, la, lb, pdim, mean, cov, exact).</p>
</td></tr>
<tr><td><code id="depthContour_+3A_graph_params">graph_params</code></td>
<td>
<p>list of graphical parameters for functions filled.contour and contour (e.g. lwd, lty, main).</p>
</td></tr>
<tr><td><code id="depthContour_+3A_contour_method">contour_method</code></td>
<td>
<p>determines the method used to draw the contour lines. The default value (&quot;auto&quot;) tries
to determine the best method for given depth function.
&quot;convexhull&quot; uses a convex hull algorithm to determine boundaries.
&quot;contour&quot; uses the algorithm from <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The set of all points that have depth at least <code class="reqn"> \alpha </code> is called <code class="reqn"> \alpha </code>-trimmed region. The <code class="reqn"> \alpha </code>-trimmed region w.r.t. <code class="reqn"> F </code> is denoted by <code class="reqn"> {D}_{\alpha}(F) </code>, i.e., </p>
<p style="text-align: center;"><code class="reqn"> {D}_{\alpha}(F) = \left\{ z \in {{{R}} ^ {d}}:D(z, F) \ge \alpha\right\}. </code>
</p>



<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+depthPersp">depthPersp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1
set.seed(123)
x &lt;- mvrnorm(1000, c(0, 0), diag(2))
depthContour(x, colors = gray.colors)
# with points
depthContour(x, points = TRUE)
depthContour(x, points = FALSE, levels = 10)

# EXAMPLE 2
data(inf.mort, maesles.imm)
data1990 &lt;- na.omit(cbind(inf.mort[, 1], maesles.imm[, 1]))
depthContour(data1990, n = 50, pmean = TRUE, mcol = "blue",
             pdmedian = TRUE, mecol = "brown", legend = TRUE, points = TRUE,
             depth_params = list(method = "LP"),
             graph_params = list(
               xlab = "infant mortality rate per 1000 live birth",
               ylab = "against masles immunized percentage",
               main = "L2 depth, UN Fourth Goal 2011 year"))


#EXAMPLE 3
data("france")
depthContour(france,
    depth_params = list(method = "Tukey"),
    points = TRUE
)


</code></pre>

<hr>
<h2 id='DepthCurve-class'>DepthCurve</h2><span id='topic+DepthCurve-class'></span>

<h3>Description</h3>

<p>This page describes mechanism behavior of ScaleCurve and AsymmetryCurve
</p>


<h3>Details</h3>

<p>DepthCurve is a virtual class that contains methods (getPlot(...) and plot(...)) for rendering single curve such as ScaleCurve or AsymmetryCurve. Such object can be combined by overloaded operator '
</p>


<h3>Slots</h3>


<dl>
<dt><code>depth</code></dt><dd><p>object of <a href="#topic+Depth-class">Depth-class</a></p>
</dd>
<dt><code>name</code></dt><dd><p>name of dataset used on plot</p>
</dd>
<dt><code>title</code></dt><dd><p>title of a plot</p>
</dd>
<dt><code>alpha</code></dt><dd><p>central area values</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)
x &lt;- mvrnorm(n = 100, mu = c(0, 0), Sigma = 2 * diag(2))
y &lt;- rmvt(n = 100, sigma = diag(2), df = 4)
s1 &lt;- scaleCurve(x, depth_params = list(method = "Projection"))
s2 &lt;- scaleCurve(y, depth_params = list(method = "Projection"), name = "Set2")

sc_list &lt;- combineDepthCurves(s1, s2) # Add one curve to another

plot(sc_list) # Draw plot with two curves

z &lt;- mvrnorm(n = 100, mu = c(0, 0), Sigma = 1 * diag(2))
s3 &lt;- scaleCurve(z, depth_params = list(method = "Projection"))
plot(combineDepthCurves(sc_list, s3)) # Add third curve and draw a plot

</code></pre>

<hr>
<h2 id='DepthCurveList-class'>DepthCurveList</h2><span id='topic+DepthCurveList-class'></span>

<h3>Description</h3>

<p>DepthCurveList is a special container for DepthCurve objects. See <a href="#topic+DepthCurve-class">DepthCurve-class</a>
</p>

<hr>
<h2 id='depthDensity'>Depth weighted density estimator</h2><span id='topic+depthDensity'></span>

<h3>Description</h3>

<p>Experimental function used to fit depth weighted density estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthDensity(x, y, nx = 5, ny = 32, xg = NULL, yg = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthDensity_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="depthDensity_+3A_y">y</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="depthDensity_+3A_nx">nx</code></td>
<td>
<p>the number of equally spaced points at which the density is to be estimated in x-dimension.</p>
</td></tr>
<tr><td><code id="depthDensity_+3A_ny">ny</code></td>
<td>
<p>the number of equally spaced points at which the density is to be estimated in x-dimension.</p>
</td></tr>
<tr><td><code id="depthDensity_+3A_xg">xg</code></td>
<td>
<p>vector of point at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="depthDensity_+3A_yg">yg</code></td>
<td>
<p>vector of point at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="depthDensity_+3A_...">...</code></td>
<td>
<p>arguments passed to depthLocal.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kosiorowski D. and Zawadzki Z. (2014) Notes on optimality of predictive distribution pseudo-estimators in the CHARME models and automatic trading strategies, FindEcon2014, submitted
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# .sampleData is special function for creating
# data for testing conditional denisty estimators
data &lt;- DepthProc:::.sampleData(1:5, 100)
x &lt;- data[, 1]
y &lt;- data[, 2]
plot(x, y)
dep &lt;- depthDensity(x, y)
plot(dep, type = "raw")
plot(dep, type = "depth")

## End(Not run)

</code></pre>

<hr>
<h2 id='DepthDensity-class'>DepthDensity</h2><span id='topic+DepthDensity-class'></span>

<h3>Description</h3>

<p>Class for depth based density estimator.
</p>


<h3>Details</h3>

<p><code><a href="#topic+depthDensity">depthDensity</a></code>
</p>

<hr>
<h2 id='depthEuclid'>Euclidean Depth</h2><span id='topic+depthEuclid'></span>

<h3>Description</h3>

<p>Computes the euclidean depth of a point or vectors of points with respect to a multivariate data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthEuclid(u, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthEuclid_+3A_u">u</code></td>
<td>
<p>Numerical vector or matrix whose depth is to be calculated. Dimension has to be the same as that of the observations.</p>
</td></tr>
<tr><td><code id="depthEuclid_+3A_x">X</code></td>
<td>
<p>The data as a matrix, data frame or list. If it is a matrix or data frame, then each row is viewed as one multivariate observation. If it is a list, all components must be numerical vectors of equal length (coordinates of observations).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of Euclidean depth is exact.
</p>
<p>Returns the depth of multivariate point <code>u</code> with respect to data set <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(9999), nc = 3)
depthEuclid(x, x)

</code></pre>

<hr>
<h2 id='depthLocal'>Local depth</h2><span id='topic+depthLocal'></span>

<h3>Description</h3>

<p>Computes local version of depth according to proposals of Paindaveine and Van Bever &mdash; see referencess.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthLocal(
  u,
  X,
  beta = 0.5,
  depth_params1 = list(method = "Projection"),
  depth_params2 = depth_params1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthLocal_+3A_u">u</code></td>
<td>
<p>Numerical vector or matrix whose depth is to be calculated. Dimension has to be the same as that of the observations.</p>
</td></tr>
<tr><td><code id="depthLocal_+3A_x">X</code></td>
<td>
<p>The data as a matrix, data frame. If it is a matrix or data frame, then each row is viewed as one multivariate observation.</p>
</td></tr>
<tr><td><code id="depthLocal_+3A_beta">beta</code></td>
<td>
<p>cutoff value for neighbourhood</p>
</td></tr>
<tr><td><code id="depthLocal_+3A_depth_params1">depth_params1</code></td>
<td>
<p>list of parameters for function depth (method, threads, ndir, la, lb, pdim, mean, cov, exact).</p>
</td></tr>
<tr><td><code id="depthLocal_+3A_depth_params2">depth_params2</code></td>
<td>
<p>as above &mdash; default is depth_params1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A successful concept of local depth was proposed by Paindaveine and Van Bever (2012). For defining a neighbourhood of a point authors proposed using idea of symmetrisation of a distribution (a sample) with respect to a point in which depth is calculated. In their approach instead of a distribution <code class="reqn"> {P} ^ {X} </code>, a distribution <code class="reqn"> {{P}_{x}} = \frac{ 1 }{ 2 }{{P} ^ {X}} + \frac{ 1 }{ 2 }{{P} ^ {2x - X}} </code> is used. For any <code class="reqn"> \beta \in [0, 1] </code>, let us introduce the smallest depth region bigger or equal to <code class="reqn"> \beta </code>, </p>
<p style="text-align: center;"><code class="reqn"> {R} ^ {\beta}(F) = \bigcap\limits_{\alpha \in A(\beta)} {{{D}_{\alpha}}}(F), </code>
</p>
<p> where <code class="reqn"> A(\beta) = \left\{ \alpha \ge 0:P\left[ {{D}_{\alpha}}(F)\right] \ge \beta\right\} </code>. Then for a locality parameter <code class="reqn"> \beta </code> we can take a neighbourhood of a point <code class="reqn"> x </code> as <code class="reqn"> R_{x} ^ {\beta}(P) </code>.
</p>
<p>Formally, let <code class="reqn"> D(\cdot, P) </code> be a depth function. Then the local depth with the locality parameter <code class="reqn"> \beta </code> and w.r.t. a point <code class="reqn"> x </code> is defined as </p>
<p style="text-align: center;"><code class="reqn"> L{{D} ^ {\beta}}(z, P):z \to D(z, P_{x} ^ {\beta}), </code>
</p>
<p> where <code class="reqn"> P_{x} ^ {\beta}(\cdot) = P\left( \cdot |R_{x} ^ {\beta}(P)\right) </code> is cond. distr. of <code class="reqn"> P </code> conditioned on <code class="reqn"> R_{x} ^ {\beta}(P) </code>.
</p>


<h3>References</h3>

<p>Paindaveine, D., Van Bever, G. (2013) From depth to local depth : a focus on centrality. Journal of the American Statistical Association 105, 1105&ndash;1119.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# EXAMPLE 1
data &lt;- mvrnorm(100, c(0, 5), diag(2) * 5)
# By default depth_params2 = depth_params1
depthLocal(data, data, depth_params1 = list(method = "LP"))
depthLocal(data, data, depth_params1 = list(method = "LP"),
           depth_params2 = list(method = "Projection"))
# Depth contour
depthContour(data, depth_params = list(method = "Local", depth_params1 = list(method = "LP")))

# EXAMPLE 2
data(inf.mort, maesles.imm)
data1990 &lt;- na.omit(cbind(inf.mort[, 1], maesles.imm[, 1]))
depthContour(data1990,
             depth_params = list(
               method = "Local",
               depth_params1 = list(method = "LP"),
               beta = 0.3
             ))

# EXAMPLE 3
Sigma1 &lt;- matrix(c(10, 3, 3, 2), 2, 2)
X1 &lt;- mvrnorm(n = 8500, mu = c(0, 0), Sigma1)
Sigma2 &lt;- matrix(c(10, 0, 0, 2), 2, 2)
X2 &lt;- mvrnorm(n = 1500, mu = c(-10, 6), Sigma2)
BALLOT &lt;- rbind(X1, X2)

train &lt;- sample(1:10000, 100)
data &lt;- BALLOT[train, ]
depthContour(data,
            depth_params = list(
              method = "Local",
              beta = 0.3,
              depth_params1 = list(method = "Projection")
            ))

## End(Not run)

</code></pre>

<hr>
<h2 id='depthLP'>LP Depth</h2><span id='topic+depthLP'></span>

<h3>Description</h3>

<p>Computes the LP depth of a point or vectors of points with respect to a multivariate data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthLP(u, X, pdim = 2, la = 1, lb = 1, threads = -1, func = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthLP_+3A_u">u</code></td>
<td>
<p>Numerical vector or matrix whose depth is to be calculated. Dimension has to be the same as that of the observations.</p>
</td></tr>
<tr><td><code id="depthLP_+3A_x">X</code></td>
<td>
<p>The data as a matrix, data frame or list. If it is a matrix or data frame, then each row is viewed as one multivariate observation. If it is a list, all components must be numerical vectors of equal length (coordinates of observations).</p>
</td></tr>
<tr><td><code id="depthLP_+3A_pdim">pdim</code></td>
<td>
<p>dimension used in calculating depth function.</p>
</td></tr>
<tr><td><code id="depthLP_+3A_la">la</code></td>
<td>
<p>slope the weighing function.</p>
</td></tr>
<tr><td><code id="depthLP_+3A_lb">lb</code></td>
<td>
<p>intercept in the weighing function.</p>
</td></tr>
<tr><td><code id="depthLP_+3A_threads">threads</code></td>
<td>
<p>number of threads used in parallel computations. Default value -1 means that all possible cores will be used.</p>
</td></tr>
<tr><td><code id="depthLP_+3A_func">func</code></td>
<td>
<p>the weighing function. Currently it is not supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the depth of multivariate point <code>u</code> with respect to data set <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(3000), ncol = 3)

# Same results
depthLP(x, x, pdim = 2)

</code></pre>

<hr>
<h2 id='depthMah'>Mahalanobis Depth</h2><span id='topic+depthMah'></span>

<h3>Description</h3>

<p>Computes the mahalanobis depth of a point or vectors of points with respect to a multivariate data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthMah(u, X, cov = NULL, mean = NULL, threads = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthMah_+3A_u">u</code></td>
<td>
<p>Numerical vector or matrix whose depth is to be calculated. Dimension has to be the same as that of the observations.</p>
</td></tr>
<tr><td><code id="depthMah_+3A_x">X</code></td>
<td>
<p>The data as a matrix, data frame or list. If it is a matrix or data frame, then each row is viewed as one multivariate observation. If it is a list, all components must be numerical vectors of equal length (coordinates of observations).</p>
</td></tr>
<tr><td><code id="depthMah_+3A_cov">cov</code></td>
<td>
<p>custom covariance matrix passed. If NULL standard calculations will be based on standard covariance estimator.</p>
</td></tr>
<tr><td><code id="depthMah_+3A_mean">mean</code></td>
<td>
<p>custom mean vector. If null &mdash; mean average will be used.</p>
</td></tr>
<tr><td><code id="depthMah_+3A_threads">threads</code></td>
<td>
<p>number of threads used in parallel computations. Default value -1 means that all possible cores will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of Mahalanobis depth is exact.
</p>
<p>Returns the depth of multivariate point <code>u</code> with respect to data set <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(9999), nc = 3)
depthMah(x, x)

</code></pre>

<hr>
<h2 id='depthMedian'>Depth median</h2><span id='topic+depthMedian'></span><span id='topic+depthMedian+2Cmatrix-method'></span><span id='topic+depthMedian+2Cdata.frame-method'></span><span id='topic+depthMedian+2CDepth-method'></span>

<h3>Description</h3>

<p>Return point with maximum depth function value. If multiple points have the same value, mean average of them will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthMedian(x, depth_params = list(), convex = FALSE)

## S4 method for signature 'matrix'
depthMedian(x, depth_params = list(), convex = FALSE)

## S4 method for signature 'data.frame'
depthMedian(x, depth_params = list(), convex = FALSE)

## S4 method for signature 'Depth'
depthMedian(x, convex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthMedian_+3A_x">x</code></td>
<td>
<p>object of class Depth or matrix.</p>
</td></tr>
<tr><td><code id="depthMedian_+3A_depth_params">depth_params</code></td>
<td>
<p>list of parameters for function depth (method, threads, ndir, la, lb, pdim, mean, cov, exact).</p>
</td></tr>
<tr><td><code id="depthMedian_+3A_convex">convex</code></td>
<td>
<p>logical. If true, than centroid of the convex hull created from deepest points is returned.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# depthMedian for matrix
x &lt;- matrix(rnorm(600), nc = 3)
depthMedian(x)

# depthMedian works with object of class Depth
dp &lt;- depth(x)
depthMedian(dp)

</code></pre>

<hr>
<h2 id='depthPersp'>Perspective plot for depth functions</h2><span id='topic+depthPersp'></span>

<h3>Description</h3>

<p>Draws a perspective plot of depth function over x-y plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthPersp(
  x,
  plot_method = "lattice",
  xlim = extendrange(x[, 1], f = 0.1),
  ylim = extendrange(x[, 2], f = 0.1),
  n = 50,
  xlab = "x",
  ylab = "y",
  plot_title = NULL,
  colors = heat_hcl,
  depth_params = list(),
  graph_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthPersp_+3A_x">x</code></td>
<td>
<p>bivariate data</p>
</td></tr>
<tr><td><code id="depthPersp_+3A_plot_method">plot_method</code></td>
<td>
<p>there are two options &quot;lattice&quot;, and &quot;rgl&quot; &mdash; see details</p>
</td></tr>
<tr><td><code id="depthPersp_+3A_xlim">xlim</code></td>
<td>
<p>limits for x-axis</p>
</td></tr>
<tr><td><code id="depthPersp_+3A_ylim">ylim</code></td>
<td>
<p>limits for y-axis</p>
</td></tr>
<tr><td><code id="depthPersp_+3A_n">n</code></td>
<td>
<p>number of points that will be used to create plot (<code class="reqn"> n ^ 2 </code>)</p>
</td></tr>
<tr><td><code id="depthPersp_+3A_xlab">xlab</code></td>
<td>
<p>description of x-axis</p>
</td></tr>
<tr><td><code id="depthPersp_+3A_ylab">ylab</code></td>
<td>
<p>description of y-axis</p>
</td></tr>
<tr><td><code id="depthPersp_+3A_plot_title">plot_title</code></td>
<td>
<p>plot title (default NULL means paste(depth_params$method, &quot;depth&quot;))</p>
</td></tr>
<tr><td><code id="depthPersp_+3A_colors">colors</code></td>
<td>
<p>function for colors pallete (e.g. gray.colors).</p>
</td></tr>
<tr><td><code id="depthPersp_+3A_depth_params">depth_params</code></td>
<td>
<p>list of parameters for function depth (&quot;method&quot;, &quot;threads&quot;, &quot;ndir&quot;, &quot;la&quot;, &quot;lb&quot;, &quot;pdim&quot;, &quot;mean&quot;, &quot;cov&quot;, &quot;exact&quot;).</p>
</td></tr>
<tr><td><code id="depthPersp_+3A_graph_params">graph_params</code></td>
<td>
<p>list of graphical parameters for functions rgl::persp3d and lattice::wireframe.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plot_method &mdash; rgl package is not in depends list beacuse it may cause problems when OpenGL is not supported. To use plot_method = &quot;rgl&quot; you must load this package on your own.
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1
x &lt;- mvrnorm(100, c(0, 0), diag(2))
depthPersp(x, depth_params = list(method = "Euclidean"))

# EXAMPLE 2
data(inf.mort, maesles.imm)
data1990 &lt;- na.omit(cbind(inf.mort[, 1], maesles.imm[, 1]))

## Not run: 
library(rgl)
depthPersp(data1990, plot_method = "rgl",
           depth_params = list(method = "Projection"))

## End(Not run)

</code></pre>

<hr>
<h2 id='depthProjection'>Projection Depth</h2><span id='topic+depthProjection'></span>

<h3>Description</h3>

<p>Computes the Projection depth of a point or vectors of points with respect to a multivariate data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthProjection(u, X, ndir = 1000, threads = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthProjection_+3A_u">u</code></td>
<td>
<p>Numerical vector or matrix whose depth is to be calculated. Dimension has to be the same as that of the observations.</p>
</td></tr>
<tr><td><code id="depthProjection_+3A_x">X</code></td>
<td>
<p>The data as a matrix, data frame or list. If it is a matrix or data frame, then each row is viewed as one multivariate observation. If it is a list, all components must be numerical vectors of equal length (coordinates of observations).</p>
</td></tr>
<tr><td><code id="depthProjection_+3A_ndir">ndir</code></td>
<td>
<p>number of directions used in computations</p>
</td></tr>
<tr><td><code id="depthProjection_+3A_threads">threads</code></td>
<td>
<p>number of threads used in parallel computations. Default value -1 means that all possible cores will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Irrespective of dimension, Projection and Tukey's depth is obtained by approximate calculation.
</p>
<p>Returns the depth of multivariate point <code>u</code> with respect to data set <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(3000), nc = 3)
a &lt;- depthProjection(x, x, ndir = 2000)

</code></pre>

<hr>
<h2 id='depthTukey'>Tukey Depth</h2><span id='topic+depthTukey'></span>

<h3>Description</h3>

<p>Computes the Tukey depth of a point or vectors of points with respect to a multivariate data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthTukey(u, X, ndir = 1000, threads = -1, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthTukey_+3A_u">u</code></td>
<td>
<p>Numerical vector or matrix whose depth is to be calculated. Dimension has to be the same as that of the observations.</p>
</td></tr>
<tr><td><code id="depthTukey_+3A_x">X</code></td>
<td>
<p>The data as a matrix, data frame or list. If it is a matrix or data frame, then each row is viewed as one multivariate observation. If it is a list, all components must be numerical vectors of equal length (coordinates of observations).</p>
</td></tr>
<tr><td><code id="depthTukey_+3A_ndir">ndir</code></td>
<td>
<p>number of directions used in computations</p>
</td></tr>
<tr><td><code id="depthTukey_+3A_threads">threads</code></td>
<td>
<p>number of threads used in parallel computations. Default value -1 means that all possible cores will be used.</p>
</td></tr>
<tr><td><code id="depthTukey_+3A_exact">exact</code></td>
<td>
<p>if TRUE exact alhorithm will be used . Currently it works only for 2 dimensional data set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Irrespective of dimension, Projection and Tukey's depth is obtained by approximate calculation.
</p>
<p>Returns the depth of multivariate point <code>u</code> with respect to data set <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- matrix(rnorm(3000), nc = 3)
depthTukey(x, ndir = 2000)

## End(Not run)

# Exact algorithm in 2d
x &lt;- matrix(rnorm(2000), nc = 2)
depthTukey(x, exact = TRUE)

</code></pre>

<hr>
<h2 id='fncBoxPlot'>Functional boxplot based on Modified Band Depth</h2><span id='topic+fncBoxPlot'></span>

<h3>Description</h3>

<p>Functional boxplot based on Modified Band Depth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fncBoxPlot(u, X = NULL, bands = c(0, 0.5), method = "MBD", byrow = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fncBoxPlot_+3A_u">u</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="fncBoxPlot_+3A_x">X</code></td>
<td>
<p>reference set. If null u will be used as reference.</p>
</td></tr>
<tr><td><code id="fncBoxPlot_+3A_bands">bands</code></td>
<td>
<p>limits for bands</p>
</td></tr>
<tr><td><code id="fncBoxPlot_+3A_method">method</code></td>
<td>
<p>depth method</p>
</td></tr>
<tr><td><code id="fncBoxPlot_+3A_byrow">byrow</code></td>
<td>
<p>byrow</p>
</td></tr>
<tr><td><code id="fncBoxPlot_+3A_...">...</code></td>
<td>
<p>other arguments passed to fncDepth</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# some data:
x &lt;- matrix(rnorm(200), ncol = 10)

fncBoxPlot(x, bands = c(0, 0.5, 1), method = "FM")
fncBoxPlot(x, bands = c(0, 0.5, 1), method = "FM", byrow = FALSE)

colnames(x) &lt;- paste0("f", 1:ncol(x))
fncBoxPlot(x, bands = c(0, 0.5, 1), method = "FM")

# fncBoxPlot handles zoo and xts objects
library(xts)
x &lt;- matrix(rnorm(200), ncol = 10)
time &lt;- as.POSIXct(1:ncol(x) * 86400, origin = "1970-01-01")
x_xts &lt;- xts(t(x), order.by = time)
fncBoxPlot(x_xts, bands = c(0, 0.5, 1), method = "FM")

data("katowice.airpollution")
pl &lt;- fncBoxPlot(katowice.airpollution, bands = c(0, 0.5, 1), method = "MBD")
pl + ggtitle("Air pollution in Katowice") + labs(y= "pollination ", x = "hour ")

</code></pre>

<hr>
<h2 id='fncDepth'>Basic function for functional depths</h2><span id='topic+fncDepth'></span><span id='topic+fncDepth.matrix'></span><span id='topic+fncDepth.zoo'></span>

<h3>Description</h3>

<p>Calculates depth functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fncDepth(u, X = NULL, method = "MBD", byrow = NULL, ...)

## S3 method for class 'matrix'
fncDepth(u, X = NULL, method = "MBD", byrow = NULL, ...)

## S3 method for class 'zoo'
fncDepth(u, X = NULL, method = "MBD", byrow = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fncDepth_+3A_u">u</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="fncDepth_+3A_x">X</code></td>
<td>
<p>reference set. If null u will be used as reference.</p>
</td></tr>
<tr><td><code id="fncDepth_+3A_method">method</code></td>
<td>
<p>depth method - &quot;MBD&quot; (default), or &quot;FM&quot; (Frainman-Muniz depth)</p>
</td></tr>
<tr><td><code id="fncDepth_+3A_byrow">byrow</code></td>
<td>
<p>logical or character.</p>
</td></tr>
<tr><td><code id="fncDepth_+3A_...">...</code></td>
<td>
<p>additional arguments passed to fncDepthFM.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(rnorm(60), ncol = 20)
fncDepth(x, method = "FM", dep1d = "Mahalanobis")
fncDepth(x, byrow = FALSE)

# zoo and xts
library(xts)
data(sample_matrix)
sample.xts &lt;- as.xts(sample_matrix, descr = "my new xts object")
fncDepth(sample.xts)

</code></pre>

<hr>
<h2 id='fncDepthFM'>FM Depth</h2><span id='topic+fncDepthFM'></span>

<h3>Description</h3>

<p>Computes Frainman-Muniz depth for functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fncDepthFM(u, X, dep1d_params = list(method = "Projection"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fncDepthFM_+3A_u">u</code></td>
<td>
<p>Numerical vector or matrix whose depth is to be calculated. Dimension has to be the same as that of the observations.</p>
</td></tr>
<tr><td><code id="fncDepthFM_+3A_x">X</code></td>
<td>
<p>The data as a matrix. If it is a matrix or data frame, then each row is viewed as one multivariate observation.</p>
</td></tr>
<tr><td><code id="fncDepthFM_+3A_dep1d_params">dep1d_params</code></td>
<td>
<p>parameters passed to depth function used in one dimension.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(60), nc = 20)
fncDepthFM(x)

</code></pre>

<hr>
<h2 id='fncDepthMBD'>Modified band depth</h2><span id='topic+fncDepthMBD'></span>

<h3>Description</h3>

<p>Computes the modified band depth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fncDepthMBD(u, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fncDepthMBD_+3A_u">u</code></td>
<td>
<p>Numerical vector or matrix whose depth is to be calculated. Dimension has to be the same as that of the observations.</p>
</td></tr>
<tr><td><code id="fncDepthMBD_+3A_x">X</code></td>
<td>
<p>The data as a matrix. If it is a matrix or data frame, then each row is viewed as one multivariate observation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(rnorm(60), nc = 20)
fncDepthMBD(x)
fncDepthMBD(x, x)

</code></pre>

<hr>
<h2 id='fncDepthMedian'>Functional median</h2><span id='topic+fncDepthMedian'></span>

<h3>Description</h3>

<p>Calculate functional median based on data depth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fncDepthMedian(u, X = NULL, method = "MBD", byrow = NULL, unique = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fncDepthMedian_+3A_u">u</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="fncDepthMedian_+3A_x">X</code></td>
<td>
<p>reference set. If null u will be used as reference.</p>
</td></tr>
<tr><td><code id="fncDepthMedian_+3A_method">method</code></td>
<td>
<p>depth method</p>
</td></tr>
<tr><td><code id="fncDepthMedian_+3A_byrow">byrow</code></td>
<td>
<p>byrow</p>
</td></tr>
<tr><td><code id="fncDepthMedian_+3A_unique">unique</code></td>
<td>
<p>if true</p>
</td></tr>
<tr><td><code id="fncDepthMedian_+3A_...">...</code></td>
<td>
<p>other arguments passed to fncDepth</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(rnorm(600), nc = 20)
md &lt;- fncDepthMedian(x, method = "FM", dep1d = "Mahalanobis")

</code></pre>

<hr>
<h2 id='fncGetBand'>Functional bands</h2><span id='topic+fncGetBand'></span>

<h3>Description</h3>

<p>Extract bands from functional depth object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fncGetBand(obj, band = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fncGetBand_+3A_obj">obj</code></td>
<td>
<p>object that inherits from FunctionalDepth.</p>
</td></tr>
<tr><td><code id="fncGetBand_+3A_band">band</code></td>
<td>
<p>single numeric value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(rnorm(600), nc = 20)
obj &lt;- fncDepth(x, method = "FM", dep1d = "Mahalanobis")
fncGetBand(obj)

</code></pre>

<hr>
<h2 id='france'>Relation between minimum wage (MW) and unemployment rate (UR) in France.</h2><span id='topic+france'></span>

<h3>Description</h3>

<p>Relation between minimum wage (MW) and unemployment rate (UR) in France.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(france)
</code></pre>


<h3>Format</h3>

<p>data frame containing 17 rows and two column. MW is a minimum wage, and UR is an unemployment rate.
</p>

<hr>
<h2 id='FunctionalDepth-class'>Functional Depth</h2><span id='topic+FunctionalDepth-class'></span>

<h3>Description</h3>

<p>Virtual class with structure for every functional depth class from depthproc package. Inherits from <code><a href="#topic+Depth-class">Depth-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>index</code></dt><dd><p>numeric, or time-based object.</p>
</dd>
</dl>

<hr>
<h2 id='getPlot'>Create ggplot object from DepthCurve, DepthCurveList and DDPlot classes.</h2><span id='topic+getPlot'></span><span id='topic+getPlot+2CAsymmetryCurveList-method'></span><span id='topic+getPlot+2CDDPlot-method'></span><span id='topic+getPlot+2CScaleCurveList-method'></span>

<h3>Description</h3>

<p>Create an object of class ggplot from DepthCurve and DepthCurveList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPlot(object)

## S4 method for signature 'AsymmetryCurveList'
getPlot(object)

## S4 method for signature 'DDPlot'
getPlot(object)

## S4 method for signature 'ScaleCurveList'
getPlot(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPlot_+3A_object">object</code></td>
<td>
<p>a DDPlot ScaleCurve or AsymmetryCurve object class.</p>
</td></tr>
</table>

<hr>
<h2 id='inf.mort'>Infant mortality rate (0&ndash;1 year) per 1,000 live births</h2><span id='topic+inf.mort'></span>

<h3>Description</h3>

<p>Infant mortality rate (0&ndash;1 year) per 1,000 live births
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(inf.mort)
</code></pre>


<h3>Format</h3>

<p>A data frame with 654 rows and 4 variables
</p>


<h3>Source</h3>

<p>http://mdgs.un.org/unsd/mdg/Data.aspx
</p>

<hr>
<h2 id='internet.users'>Internet view data</h2><span id='topic+internet.users'></span>

<h3>Description</h3>

<p>Internet view data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(internet.users)
</code></pre>


<h3>Format</h3>

<p>data frame containing 17518 rows and 6 columns &mdash; 17518 working days of the
Internet service considered with respect to variables:
service, month, day, hour, unique users and page views.
</p>


<h3>References</h3>

<p>Kosiorowski, Rydlewski, Snarska (2016), Detecting a Structural Change in Functional Time Series Using Local Wilcoxon Statistic, arXiv: 1604.03776v2
</p>

<hr>
<h2 id='katowice.airpollution'>Air pollution in Katowice city by hour.</h2><span id='topic+katowice.airpollution'></span>

<h3>Description</h3>

<p>Air pollution in Katowice city by hour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("katowice.airpollution")
</code></pre>


<h3>Format</h3>

<p>data frame containing 181 rows (days) and 24 columns. Each column is an air pollination for given hour.
</p>

<hr>
<h2 id='lsdAddContour'>Adds location scale depth contour to the existing plot.</h2><span id='topic+lsdAddContour'></span><span id='topic+lsdAddContour+2CLSDepthContour-method'></span>

<h3>Description</h3>

<p>This function add one location-scale contour to the existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsdAddContour(x, cont = NULL, ...)

## S4 method for signature 'LSDepthContour'
lsdAddContour(x, cont = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsdAddContour_+3A_x">x</code></td>
<td>
<p>object of class LSDepthContour</p>
</td></tr>
<tr><td><code id="lsdAddContour_+3A_cont">cont</code></td>
<td>
<p>depth of contour to plot</p>
</td></tr>
<tr><td><code id="lsdAddContour_+3A_...">...</code></td>
<td>
<p>other arguments passed to polygon function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>smp &lt;- rf(100, 5, 10)
x &lt;- lsdSampleDepthContours(smp)
plot(x)
lsdAddContour(x, 0.1, col = "grey50")
lsdAddContour(x, 0.3, col = "grey10", border = "red", lwd = 4)
</code></pre>

<hr>
<h2 id='LSDepth-class'>Location-Scale depth class</h2><span id='topic+LSDepth-class'></span>

<h3>Description</h3>

<p>Class used to store maximum location-scale depth results.
</p>


<h3>Slots</h3>


<dl>
<dt><code>max_depth</code></dt><dd><p>maximum Student depth value.</p>
</dd>
<dt><code>mu</code></dt><dd><p>location estimate in the deepest point.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>scale estimate in the deepest point.</p>
</dd>
</dl>

<hr>
<h2 id='LSDepthContour-class'>Location-Scale depth contour class</h2><span id='topic+LSDepthContour-class'></span>

<h3>Description</h3>

<p>Class used to store result of location-scale depth contours.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cont_depth</code></dt><dd><p>depth values used to calculate contours.</p>
</dd>
<dt><code>sample</code></dt><dd><p>original sample used to calculate depth contours.</p>
</dd>
<dt><code>.Data</code></dt><dd><p>list with estimated values of scale-depth contours.</p>
</dd>
</dl>

<hr>
<h2 id='lsdGetContour'>Get location-scale contour from LSDepthContour object.</h2><span id='topic+lsdGetContour'></span><span id='topic+lsdGetContour+2CLSDepthContour-method'></span>

<h3>Description</h3>

<p>Get numeric values of the location-scale depth contour from existing object of LSDepthContour class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsdGetContour(x, cont)

## S4 method for signature 'LSDepthContour'
lsdGetContour(x, cont)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsdGetContour_+3A_x">x</code></td>
<td>
<p>object of class LSDepthContour</p>
</td></tr>
<tr><td><code id="lsdGetContour_+3A_cont">cont</code></td>
<td>
<p>single numeric &mdash; depth of contour to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculations are based on lsdepth algorithm written by Ch. Muller.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dcont &lt;- lsdSampleDepthContours(rf(200, 4, 7), depth = c(0.1, 0.2))

# get contour that is present in dcont object
lsdGetContour(dcont, 0.1)

# get contour that is not present in dcont
# it will be automatically calculated
lsdGetContour(dcont, 0.3)
</code></pre>

<hr>
<h2 id='lsdSampleDepthContours'>Calculate sample Mizera and Muller Student depth contours</h2><span id='topic+lsdSampleDepthContours'></span>

<h3>Description</h3>

<p>Calculate sample one-dimensional Mizera and Muller Student depth contours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsdSampleDepthContours(x, depth = c(0.1, 0.2, 0.3, 0.4), lengthmu = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsdSampleDepthContours_+3A_x">x</code></td>
<td>
<p>one dimensional vector with sample</p>
</td></tr>
<tr><td><code id="lsdSampleDepthContours_+3A_depth">depth</code></td>
<td>
<p>depth level for contours</p>
</td></tr>
<tr><td><code id="lsdSampleDepthContours_+3A_lengthmu">lengthmu</code></td>
<td>
<p>number of points to evalute depth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculations are based on lsdepth algorithm written by Ch. Muller.
</p>


<h3>References</h3>

<p>Mizera, I., Muller, C. H., 2004. Location-scale depth (with discussion). Journal of the American Statistical Association 99, 949&ndash;966.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1
# F-distribution
dcont &lt;- lsdSampleDepthContours(rf(200, 4, 7))
plot(dcont)

# EXAMPLE 2
# normal distribution - more contours calculated
dcont_norm &lt;- lsdSampleDepthContours(rnorm(100), seq(0.05, 0.4, 0.05))
plot(dcont_norm)

</code></pre>

<hr>
<h2 id='lsdSampleMaxDepth'>Calculates the maximum sample location-scale depth</h2><span id='topic+lsdSampleMaxDepth'></span>

<h3>Description</h3>

<p>Calculates the maximum Student depth estimator of location and scale for one dimensional data (an alternative for MED and MAD or for the mean and standard deviation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsdSampleMaxDepth(x, iter = 100, eps = 1e-04, p_length = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsdSampleMaxDepth_+3A_x">x</code></td>
<td>
<p>one dimensional vector with sample</p>
</td></tr>
<tr><td><code id="lsdSampleMaxDepth_+3A_iter">iter</code></td>
<td>
<p>maximum number of iterations in algorith for calculation Location-Scale Depth</p>
</td></tr>
<tr><td><code id="lsdSampleMaxDepth_+3A_eps">eps</code></td>
<td>
<p>tolerance level</p>
</td></tr>
<tr><td><code id="lsdSampleMaxDepth_+3A_p_length">p_length</code></td>
<td>
<p>is the maximum length of the precision step at the end</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculations are based on lsdepth algorithm written by Ch. Muller.
</p>


<h3>References</h3>

<p>Mizera, I., Muller, C. H., 2004. Location-scale depth (with discussion). Journal of the American Statistical Association 99, 949&ndash;966.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
lsdSampleMaxDepth(x)
y &lt;- rf(100, 4, 10)
lsdSampleMaxDepth(y)

</code></pre>

<hr>
<h2 id='maesles.imm'>Children 1 year old immunized against measles, percentage</h2><span id='topic+maesles.imm'></span>

<h3>Description</h3>

<p>Children 1 year old immunized against measles, percentage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(maesles.imm)
</code></pre>


<h3>Format</h3>

<p>A data frame with 654 rows and 4 variables
</p>


<h3>Source</h3>

<p>http://mdgs.un.org/unsd/mdg/Data.aspx
</p>

<hr>
<h2 id='mWilcoxonTest'>Multivariate Wilcoxon test for equality of dispersion.</h2><span id='topic+mWilcoxonTest'></span>

<h3>Description</h3>

<p>Depth based multivariate Wilcoxon test for a scale difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mWilcoxonTest(x, y, alternative = "two.sided", depth_params = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mWilcoxonTest_+3A_x">x</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="mWilcoxonTest_+3A_y">y</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="mWilcoxonTest_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="mWilcoxonTest_+3A_depth_params">depth_params</code></td>
<td>
<p>list of parameters for function depth (method, threads, ndir, la, lb, pdim, mean, cov, exact).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Having two samples <code class="reqn"> {X} ^ {n} </code> and <code class="reqn"> {Y} ^ {m} </code> using any depth function, we can compute depth values in a combined sample <code class="reqn"> {Z} ^ {n + m} = {X} ^ {n} \cup {Y} ^ {m} </code>, assuming the empirical distribution calculated basing on all observations, or only on observations belonging to one of the samples <code class="reqn"> {X} ^ {n} </code> or <code class="reqn"> {Y} ^ {m} </code>.
</p>
<p>For example if we observe <code class="reqn"> {X}_{l}'s </code> depths are more likely to cluster tightly around the center of the combined sample, while <code class="reqn"> {Y}_{l}'s </code> depths are more likely to scatter outlying positions, then we conclude <code class="reqn"> {Y} ^ {m} </code> was drawn from a distribution with larger scale.
</p>
<p>Properties of the DD plot based statistics in the i.i.d setting were studied by Li &amp; Liu (2004). Authors proposed several DD-plot based statistics and presented bootstrap arguments for their consistency and good effectiveness in comparison to Hotelling <code class="reqn"> T ^ 2 </code> and multivariate analogues of Ansari-Bradley and Tukey-Siegel statistics. Asymptotic distributions of depth based multivariate Wilcoxon rank-sum test statistic under the null and general alternative hypotheses were obtained by Zuo &amp; He (2006). Several properties of the depth based rang test involving its unbiasedness was critically discussed by Jureckova &amp; Kalina (2012). Basing on DD-plot object, which is available within the <span class="pkg">DepthProc</span> it is possible to define several multivariate generalizations of one-dimensional rank and order statistics in an easy way. These generalizations cover well known Wilcoxon rang-sum statistic.
</p>
<p>The depth based multivariate Wilcoxon rang sum test is especially useful for the multivariate scale changes detection and was introduced among other by Liu &amp; Singh (2003) and intensively studied by Jureckowa &amp; Kalina (2012) and Zuo &amp; He (2006) in the i.i.d. setting.
</p>
<p>For the samples <code class="reqn"> {{{X}} ^ {m}} = \{{{{X}}_{1}}, ..., {{{X}}_{m}}\} </code>, <code class="reqn"> {{{Y}} ^ {n}} = \{{{{Y}}_{1}}, ..., {{{Y}}_{n}}\} </code>, their <code class="reqn"> d_{1} ^ {X}, ..., d_{m} ^ {X} </code>, <code class="reqn"> d_{1} ^ {Y}, ..., d_{n} ^ {Y} </code>, depths w.r.t. a combined sample <code class="reqn"> {{Z}} = {{{X}} ^ {n}} \cup {{{Y}} ^ {m}} </code> the Wilcoxon statistic is defined as <code class="reqn"> S = \sum\limits_{i = 1} ^ {m}{{{R}_{i}}} </code>, where <code class="reqn"> {R}_{i} </code> denotes the rang of the i-th observation, <code class="reqn"> i = 1, ..., m </code> in the combined sample <code class="reqn"> R({{{y}}_{l}}) = \sharp\left\{ {{{z}}_{j}} \in {{{Z}}}:D({{{z}}_{j}}, {{Z}}) \le D({{{y}}_{l}}, {{Z}}) \right\}, l = 1, ..., m </code>.
</p>
<p>The distribution of <code class="reqn"> S </code> is symmetric about <code class="reqn"> E(S) = \frac{ 1 }{ 2 }m(m + n + 1) </code>, its variance is <code class="reqn"> {{D} ^ {2}}(S) = \frac{ 1 }{ 12 }mn(m + n + 1) </code>.
</p>


<h3>References</h3>

<p>Jureckova J, Kalina J (2012). Nonparametric multivariate rank tests and their unbiasedness. Bernoulli, 18(1), 229&ndash;251.
Li J, Liu RY (2004). New nonparametric tests of multivariate locations and scales using data depth. Statistical Science, 19(4), 686&ndash;696.
Liu RY, Singh K (1995). A quality index based on data depth and multivariate rank tests. Journal of American Statistical Association, 88, 252&ndash;260.
Zuo Y, He X (2006). On the limiting distributions of multivariate depth-based rank sum statistics and related tests. The Annals of Statistics, 34, 2879&ndash;2896.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1
x &lt;- mvrnorm(100, c(0, 0), diag(2))
y &lt;- mvrnorm(100, c(0, 0), diag(2) * 1.4)
mWilcoxonTest(x, y)
mWilcoxonTest(x, y, depth_params = list(method = "LP"))

# EXAMPLE 2
data(under5.mort)
data(inf.mort)
data(maesles.imm)
data2011 &lt;- na.omit(cbind(under5.mort[, 22], inf.mort[, 22],
                          maesles.imm[, 22]))
data1990 &lt;- na.omit(cbind(under5.mort[, 1], inf.mort[, 1], maesles.imm[, 1]))
mWilcoxonTest(data2011, data1990)

</code></pre>

<hr>
<h2 id='plot'>Method for plotting DepthCurve and DDPlot object.</h2><span id='topic+plot'></span><span id='topic+plot+2CDDPlot+2CANY-method'></span><span id='topic+plot+2CDepthCurve+2CANY-method'></span><span id='topic+plot+2CDepthCurveList+2CANY-method'></span>

<h3>Description</h3>

<p>Plot Depth curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot(x, y, ...)

## S4 method for signature 'DDPlot,ANY'
plot(x)

## S4 method for signature 'DepthCurve,ANY'
plot(x)

## S4 method for signature 'DepthCurveList,ANY'
plot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>object that inherits from DepthCurve class (ScaleCurve or AsymmetryCurve), or DDPlot class.</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>not supported.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>not supported.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- mvrnorm(n = 100, mu = c(0, 0), Sigma = 3 * diag(2))
sc &lt;- scaleCurve(x)
plot(sc)

</code></pre>

<hr>
<h2 id='plot+2CBinnDepth2d+2CANY-method'>2d Binning plot</h2><span id='topic+plot+2CBinnDepth2d+2CANY-method'></span>

<h3>Description</h3>

<p>Binning 2d
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BinnDepth2d,ANY'
plot(x, ..., alpha = 0.1, bg_col = "red", add_mid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CBinnDepth2d+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>object of class BinnDepth2d</p>
</td></tr>
<tr><td><code id="plot+2B2CBinnDepth2d+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to plot</p>
</td></tr>
<tr><td><code id="plot+2B2CBinnDepth2d+2B2CANY-method_+3A_alpha">alpha</code></td>
<td>
<p>alpha value for rgb function</p>
</td></tr>
<tr><td><code id="plot+2B2CBinnDepth2d+2B2CANY-method_+3A_bg_col">bg_col</code></td>
<td>
<p>backgroud color</p>
</td></tr>
<tr><td><code id="plot+2B2CBinnDepth2d+2B2CANY-method_+3A_add_mid">add_mid</code></td>
<td>
<p>logical. If TRUE centers of binns will be marked.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+depth">depth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp &lt;- binningDepth2D(x = mvrnorm(100, rep(0, 2), diag(2)))
plot(tmp)

</code></pre>

<hr>
<h2 id='plot+2CDepthDensity+2CANY-method'>Plot function for DepthDensity.</h2><span id='topic+plot+2CDepthDensity+2CANY-method'></span>

<h3>Description</h3>

<p>Create plot for DepthDensity. See <code><a href="#topic+depthDensity">depthDensity</a></code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DepthDensity,ANY'
plot(x, type = "depth", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CDepthDensity+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>object of class DepthDensity</p>
</td></tr>
<tr><td><code id="plot+2B2CDepthDensity+2B2CANY-method_+3A_type">type</code></td>
<td>
<p>type of density that will be plotted. &quot;depth&quot; is a depth scaled density, and &quot;raw&quot; is denisty without scaling.</p>
</td></tr>
<tr><td><code id="plot+2B2CDepthDensity+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>graphical arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CLSDepthContour+2CANY-method'>Plot Location-Scale depth contours.</h2><span id='topic+plot+2CLSDepthContour+2CANY-method'></span>

<h3>Description</h3>

<p>Create location-scale depth plot. See <code><a href="#topic+lsdSampleDepthContours">lsdSampleDepthContours</a></code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LSDepthContour,ANY'
plot(
  x,
  cont = NULL,
  ratio = 1,
  mu_min = NULL,
  mu_max = NULL,
  col = NULL,
  border = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CLSDepthContour+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>object of class LSDepthContour</p>
</td></tr>
<tr><td><code id="plot+2B2CLSDepthContour+2B2CANY-method_+3A_cont">cont</code></td>
<td>
<p>plotted contours. Default NULL means that all contours stored in x will be plotted.</p>
</td></tr>
<tr><td><code id="plot+2B2CLSDepthContour+2B2CANY-method_+3A_ratio">ratio</code></td>
<td>
<p>ratio</p>
</td></tr>
<tr><td><code id="plot+2B2CLSDepthContour+2B2CANY-method_+3A_mu_min">mu_min</code></td>
<td>
<p>mu_min</p>
</td></tr>
<tr><td><code id="plot+2B2CLSDepthContour+2B2CANY-method_+3A_mu_max">mu_max</code></td>
<td>
<p>mu_max</p>
</td></tr>
<tr><td><code id="plot+2B2CLSDepthContour+2B2CANY-method_+3A_col">col</code></td>
<td>
<p>vectors with area colors passed to polygon function</p>
</td></tr>
<tr><td><code id="plot+2B2CLSDepthContour+2B2CANY-method_+3A_border">border</code></td>
<td>
<p>vector with colors for borders</p>
</td></tr>
<tr><td><code id="plot+2B2CLSDepthContour+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>other parameters passed to polygon</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
smp &lt;- rf(100, 5, 10)
x &lt;- lsdSampleDepthContours(smp)
plot(x, col = paste0("grey", col = rev(seq(10, 40, 10))))

</code></pre>

<hr>
<h2 id='RobReg-class'>RobReg</h2><span id='topic+RobReg-class'></span>

<h3>Description</h3>

<p>Virtual class for robust regression methods from depthproc package
</p>


<h3>Slots</h3>


<dl>
<dt><code>coef</code></dt><dd><p>coefficients of fitted model</p>
</dd>
</dl>

<hr>
<h2 id='runifsphere'>Random number generation from unit sphere.</h2><span id='topic+runifsphere'></span>

<h3>Description</h3>

<p>This function generates random numbers from p-dimensional unit sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runifsphere(n, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifsphere_+3A_n">n</code></td>
<td>
<p>number of random samples.</p>
</td></tr>
<tr><td><code id="runifsphere_+3A_p">p</code></td>
<td>
<p>dimension of the unit sphere.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- runifsphere(n = 100)
plot(x)

</code></pre>

<hr>
<h2 id='scaleCurve'>Scale curve</h2><span id='topic+scaleCurve'></span>

<h3>Description</h3>

<p>Draws a scale curve: measure of dispersion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleCurve(
  x,
  y = NULL,
  alpha = seq(0, 1, 0.01),
  name = "X",
  name_y = "Y",
  title = "Scale Curve",
  depth_params = list(method = "Projection")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleCurve_+3A_x">x</code></td>
<td>
<p>Multivariate data as a matrix.</p>
</td></tr>
<tr><td><code id="scaleCurve_+3A_y">y</code></td>
<td>
<p>Additional matrix with multivariate data.</p>
</td></tr>
<tr><td><code id="scaleCurve_+3A_alpha">alpha</code></td>
<td>
<p>Vector with values of central area to be used in computation.</p>
</td></tr>
<tr><td><code id="scaleCurve_+3A_name">name</code></td>
<td>
<p>Name of matrix X used in legend.</p>
</td></tr>
<tr><td><code id="scaleCurve_+3A_name_y">name_y</code></td>
<td>
<p>Name of matrix Y used in legend.</p>
</td></tr>
<tr><td><code id="scaleCurve_+3A_title">title</code></td>
<td>
<p>title of the plot.</p>
</td></tr>
<tr><td><code id="scaleCurve_+3A_depth_params">depth_params</code></td>
<td>
<p>list of parameters for function depth (method, threads, ndir, la, lb, pdim, mean, cov, exact).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For sample depth function <code class="reqn"> D({x}, {{{Z}} ^ {n}}) </code>, <code class="reqn"> {x} \in {{{R}} ^ {d}} </code>, <code class="reqn"> d \ge 2 </code>, <code class="reqn"> {Z} ^ {n} = \{{{{z}}_{1}}, ..., {{{z}}_{n}}\} \subset {{{R}} ^ {d}} </code>, <code class="reqn"> {{D}_{\alpha}}({{{Z}} ^ {n}}) </code> denoting <code class="reqn">\alpha</code> &mdash; central region, we can define the scale curve <code class="reqn"> SC(\alpha) = \left(\alpha, vol({{D}_{\alpha}}({{{Z}} ^ {n}})\right) \subset {{{R}} ^ {2}} </code>, for <code class="reqn"> \alpha \in [0, 1] </code>
</p>
<p>The scale curve is a two-dimensional method of describing the dispersion of random vector around the depth induced median.
</p>
<p>Function scalecurve for determining the volumes of the convex hull containing points from alpha central regions, uses function convhulln from geometry package.
</p>
<p>The minimal dimension of data in X or Y is 2.
</p>
<p>ggplot2 package is used to draw a plot.
</p>


<h3>Value</h3>

<p>Returns the volume of the convex hull containing subsequent central points of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>References</h3>

<p>Liu, R.Y., Parelius, J.M. and Singh, K. (1999), Multivariate analysis by data depth: Descriptive statistics, graphics and inference (with discussion), <em>Ann. Statist.</em>, <b>27</b>, 783&ndash;858.
</p>
<p>Chaudhuri, P. (1996), On a Geometric Notion of Quantiles for Multivariate Data, <em>Journal of the American Statistical Association</em>, 862&ndash;872.
</p>
<p>Dyckerhoff, R. (2004), Data Depths Satisfying the Projection Property, <em>Allgemeines Statistisches Archiv.</em>, <b>88</b>, 163&ndash;190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+depthContour">depthContour</a></code> and <code><a href="#topic+depthPersp">depthPersp</a></code> for depth graphics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)
x &lt;- mvrnorm(n = 100, mu = c(0, 0), Sigma = 3 * diag(2))
y &lt;- rmvt(n = 100, sigma = diag(2), df = 2)
scaleCurve(x, y, depth_params = list(method = "Projection"))
# Comparing two scale curves
# normal distribution and mixture of normal distributions
x &lt;- mvrnorm(100, c(0, 0), diag(2))
y &lt;- mvrnorm(80, c(0, 0), diag(2))
z &lt;- mvrnorm(20, c(5, 5), diag(2))
scaleCurve(x, rbind(y, z), name = "N", name_y = "Mixture of N",
           depth_params = list(method = "Projection"))

</code></pre>

<hr>
<h2 id='ScaleCurve-class'>ScaleCurve and ScaleCurveList</h2><span id='topic+ScaleCurve-class'></span>

<h3>Description</h3>

<p>ScaleCurve is a class that stores results of <a href="#topic+scaleCurve">scaleCurve</a> function.
</p>


<h3>Details</h3>

<p>ScaleCurve intherits behviour from numeric vector, so raw values of ScaleCurve can be accessed via as.numeric(...).
</p>
<p>The mechanism of creating plots with multiple curves is shown in <a href="#topic+DepthCurve-class">DepthCurve-class</a> (same mechanism is applied for AsymmetryCurve).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)
x &lt;- mvrnorm(n = 100, mu = c(0, 0), Sigma = 2 * diag(2))
y &lt;- rmvt(n = 100, sigma = diag(2), df = 4)
s1 &lt;- scaleCurve(x, depth_params = list(method = "Projection"))
s2 &lt;- scaleCurve(y, depth_params = list(method = "Projection"), name = "Set2")

sc_list &lt;- combineDepthCurves(s1, s2) # Add one curve to another

plot(sc_list) # Draw plot with two curves

z &lt;- mvrnorm(n = 100, mu = c(0, 0), Sigma = 1 * diag(2))
s3 &lt;- scaleCurve(z, depth_params = list(method = "Projection"))
plot(combineDepthCurves(sc_list, s3)) # Add third curve and draw a plot

</code></pre>

<hr>
<h2 id='trimProjReg2d'>trimProjReg2d</h2><span id='topic+trimProjReg2d'></span>

<h3>Description</h3>

<p>Computes projection trimmed regression in 2 dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimProjReg2d(x, y, alpha = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimProjReg2d_+3A_x">x</code></td>
<td>
<p>Independent variable</p>
</td></tr>
<tr><td><code id="trimProjReg2d_+3A_y">y</code></td>
<td>
<p>Dependent variable</p>
</td></tr>
<tr><td><code id="trimProjReg2d_+3A_alpha">alpha</code></td>
<td>
<p>Percentage of trimmed observations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zygmunt Zawadzki from Cracow University of Economics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1
data(pension)
plot(pension)
abline(lm(Reserves ~ Income, data = pension), lty = 3, lwd = 2) # lm
abline(trimProjReg2d(pension[, 1], pension[, 2]), lwd = 2) # trimprojreg2d
legend("bottomright", c("OLS", "TrimLS"), lty = 1:2)

# EXAMPLE 2
data(under5.mort)
data(inf.mort)
data(maesles.imm)

data2011 &lt;- na.omit(cbind(under5.mort[, 22], inf.mort[, 22],
                          maesles.imm[, 22]))
x &lt;- data2011[, 3]
y &lt;- data2011[, 2]
plot(x, y, cex = 1.2, ylab = "infant mortality rate per 1000 live birth",
     xlab = "against masles immunized percentage",
     main = "Projection Depth Trimmed vs. LS regressions")
abline(lm(x ~ y), lwd = 2, col = "black") # lm
abline(trimProjReg2d(x, y), lwd = 2, col = "red") # trimmed reg
legend("bottomleft", c("LS", "TrimReg"), fill = c("black", "red"), cex = 1.4,
       bty = "n")

##### Comparsion of a few regression methods #####
library(DepthProc)
library(MASS)

data("france")
plot(UR ~ MW, pch = 19, data = france)

# linear regression
lm.fit &lt;- lm(UR ~ MW, data = france)
abline(lm.fit, lwd=2, cex=3, col='red')

# M-estimator
rlm.fit &lt;- rlm(UR ~ MW, data = france)
abline(rlm.fit, lwd = 2,col = "blue")

# LMS
lqs.lms &lt;- lqs(UR ~ MW, method = "lms", data = france) #least median of squares#
lqs.lts &lt;- lqs(UR ~ MW, method = "lts", data = france) #least trimmed squares#
abline(lqs.lms, lwd = 2, col="green")
abline(lqs.lts, lwd = 2, col="pink")

# Lowess
lines(lowess(france$MW, france$UR, f = 0.5, iter = 0), lwd = 2) # loess

# Depth trimmed regression
trim.reg &lt;- trimProjReg2d(france$MW, france$UR) #trimprojreg2d
abline(trim.reg, lwd = 4, col = 'orange')

</code></pre>

<hr>
<h2 id='TrimReg2d-class'>TrimReg2d</h2><span id='topic+TrimReg2d-class'></span>

<h3>Description</h3>

<p>Class for robust regression methods from depthproc package
</p>

<hr>
<h2 id='under5.mort'>Children under 5 months mortality rate per 1,000 live births</h2><span id='topic+under5.mort'></span>

<h3>Description</h3>

<p>Children under 5 months mortality rate per 1,000 live births
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(under5.mort)
</code></pre>


<h3>Format</h3>

<p>A data frame with 654 rows and 4 variables
</p>


<h3>Source</h3>

<p>http://mdgs.un.org/unsd/mdg/Data.aspx
</p>

<hr>
<h2 id='USLABOUR'>US Labour dataset</h2><span id='topic+USLABOUR'></span>

<h3>Description</h3>

<p>US Labour dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USLABOUR)
</code></pre>


<h3>Format</h3>

<p>A data frame with 654 rows and 4 variables
</p>


<h3>Source</h3>

<p>U.S.Department of Labor &mdash; Bureau of Labour Statistics FRED
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
