<!DOCTYPE html><html><head><title>Help for package gldrm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gldrm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beta.control'><p>Control arguments for <code class="reqn">\beta</code> update algorithm</p></a></li>
<li><a href='#f0.control'><p>Control arguments for f0 update algorithm</p></a></li>
<li><a href='#getBeta'><p>Beta optimization routing</p></a></li>
<li><a href='#getf0'><p>f0 optimization routine</p></a></li>
<li><a href='#getTheta'><p>getTheta</p>
Updates theta. Vectorized but only updates observations that have not converged.</a></li>
<li><a href='#gldrm'><p>Fits a generalized linear density ratio model (GLDRM)</p></a></li>
<li><a href='#gldrm.control'><p>Control arguments for <code>gldrm</code> algorithm</p></a></li>
<li><a href='#gldrmCI'><p>Confidence intervals for gldrm coefficients</p></a></li>
<li><a href='#gldrmFit'><p>Main optimization function</p></a></li>
<li><a href='#gldrmLRT'><p>Likelihood ratio test for nested models</p></a></li>
<li><a href='#gldrmPIT'><p>Confidence intervals for gldrm coefficients</p></a></li>
<li><a href='#predict.gldrm'><p>Predict method for a gldrm object</p></a></li>
<li><a href='#print.gldrm'><p>Print summary of gldrm fit</p></a></li>
<li><a href='#print.gldrmCI'><p>Print confidence interval</p></a></li>
<li><a href='#print.gldrmLRT'><p>Print likelihood ratio test results</p></a></li>
<li><a href='#theta.control'><p>Control arguments for <code class="reqn">\theta</code> update algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Linear Density Ratio Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits a generalized linear density ratio model (GLDRM).
    A GLDRM is a semiparametric generalized linear model.
    In contrast to a GLM, which assumes a particular exponential family distribution, 
    the GLDRM uses a semiparametric likelihood to estimate the reference distribution. 
    The reference distribution may be any discrete, continuous, or mixed exponential 
    family distribution. The model parameters, which include both the regression 
    coefficients and the cdf of the unspecified reference distribution, are estimated 
    by maximizing a semiparametric likelihood. Regression coefficients are estimated 
    with no loss of efficiency, i.e. the asymptotic variance is the same as if the 
    true exponential family distribution were known.
    Huang (2014) &lt;<a href="https://doi.org/10.1080%2F01621459.2013.824892">doi:10.1080/01621459.2013.824892</a>&gt;.
    Huang and Rathouz (2012) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasr075">doi:10.1093/biomet/asr075</a>&gt;.
    Rathouz and Gao (2008) &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxn030">doi:10.1093/biostatistics/kxn030</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats (&ge; 3.2.2), graphics (&ge; 3.2.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 1.0.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 22:48:55 UTC; mike</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Wurm [aut, cre],
  Paul Rathouz [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Wurm &lt;wurm@uwalumni.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 23:10:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='beta.control'>Control arguments for <code class="reqn">\beta</code> update algorithm</h2><span id='topic+beta.control'></span>

<h3>Description</h3>

<p>This function returns control arguments for the <code class="reqn">\beta</code> update algorithm.
Each argument has a default value, which will be used unless a different
value is provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.control(eps = 1e-10, maxiter = 1, maxhalf = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.control_+3A_eps">eps</code></td>
<td>
<p>Convergence threshold. The update has converged when the relative
change in log-likelihood between iterations is less than <code>eps</code>.
Only applies if <code>maxiter&gt;1</code>.</p>
</td></tr>
<tr><td><code id="beta.control_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="beta.control_+3A_maxhalf">maxhalf</code></td>
<td>
<p>Maximum number of half steps allowed per iteration if
log-likelihood does not improve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of S3 class &quot;betaControl&quot;, which is a list of control arguments.
</p>

<hr>
<h2 id='f0.control'>Control arguments for f0 update algorithm</h2><span id='topic+f0.control'></span>

<h3>Description</h3>

<p>This function returns control arguments for the <code class="reqn">f_0</code> update algorithm.
Each argument has a default value, which will be used unless a different
value is provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f0.control(eps = 1e-10, maxiter = 1000, maxhalf = 20, maxlogstep = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f0.control_+3A_eps">eps</code></td>
<td>
<p>Convergence threshold. The update has converged when the relative
change in log-likelihood between iterations is less than <code>eps</code>.
absolute change is less than <code>thesh</code>.</p>
</td></tr>
<tr><td><code id="f0.control_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="f0.control_+3A_maxhalf">maxhalf</code></td>
<td>
<p>Maximum number of half steps allowed per iteration if
log-likelihood does not improve between iterations.</p>
</td></tr>
<tr><td><code id="f0.control_+3A_maxlogstep">maxlogstep</code></td>
<td>
<p>Maximum optimization step size allowed on the
<code>log(f0)</code> scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of S3 class &quot;f0Control&quot;, which is a list of control arguments.
</p>

<hr>
<h2 id='getBeta'>Beta optimization routing</h2><span id='topic+getBeta'></span>

<h3>Description</h3>

<p>Beta optimization routing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBeta(
  x,
  y,
  spt,
  ySptIndex,
  f0,
  linkinv,
  mu.eta,
  offset,
  sampprobs,
  betaStart,
  thStart,
  thetaControl = theta.control(),
  betaControl = beta.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBeta_+3A_x">x</code></td>
<td>
<p>Covariate matrix.</p>
</td></tr>
<tr><td><code id="getBeta_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="getBeta_+3A_spt">spt</code></td>
<td>
<p>Vector of unique observed support points in the response.</p>
</td></tr>
<tr><td><code id="getBeta_+3A_ysptindex">ySptIndex</code></td>
<td>
<p>Index of each <code>y</code> value within the <code>spt</code> vector.</p>
</td></tr>
<tr><td><code id="getBeta_+3A_f0">f0</code></td>
<td>
<p>Current values of f0.</p>
</td></tr>
<tr><td><code id="getBeta_+3A_linkinv">linkinv</code></td>
<td>
<p>Inverse link function.</p>
</td></tr>
<tr><td><code id="getBeta_+3A_mu.eta">mu.eta</code></td>
<td>
<p>Derivative of inverse link function.</p>
</td></tr>
<tr><td><code id="getBeta_+3A_offset">offset</code></td>
<td>
<p>Vector of known offset values to be added to the linear
combination (x' beta) for each observation. Mostly intended for likelihood ratio
and score confidence intervals.</p>
</td></tr>
<tr><td><code id="getBeta_+3A_sampprobs">sampprobs</code></td>
<td>
<p>Optional matrix of sampling probabilities.</p>
</td></tr>
<tr><td><code id="getBeta_+3A_betastart">betaStart</code></td>
<td>
<p>Starting values for beta (typically the estimates from the
previous iteration).</p>
</td></tr>
<tr><td><code id="getBeta_+3A_thstart">thStart</code></td>
<td>
<p>Starting theta values. Needs to be a list of values matching
the output of the <code>getTheta</code> function.</p>
</td></tr>
<tr><td><code id="getBeta_+3A_thetacontrol">thetaControl</code></td>
<td>
<p>A &quot;thetaControl&quot; object returned from the <code>theta.control</code>
function.</p>
</td></tr>
<tr><td><code id="getBeta_+3A_betacontrol">betaControl</code></td>
<td>
<p>A &quot;betaControl&quot; object returned from the <code>beta.control</code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>

<ul>
<li> <p><code>beta</code> Updated values.
</p>
</li>
<li> <p><code>mu</code> Updated mean for each observation.
</p>
</li>
<li> <p><code>th</code> Updated list returned from the <code>getTheta</code> function.
</p>
</li>
<li> <p><code>llik</code> Updated log-likelihood.
</p>
</li>
<li> <p><code>iter</code> Number of iterations until convergence. (Will always be
one unless <code>maxiter</code> is increased to something greater than one using the
<code>betaControl</code> argument.)
</p>
</li>
<li> <p><code>conv</code> Convergence indicator. (Will always be FALSE unless
<code>maxiter</code> is increased to something greater than one using the
<code>betaControl</code> argument.)
</p>
</li></ul>


<hr>
<h2 id='getf0'>f0 optimization routine</h2><span id='topic+getf0'></span>

<h3>Description</h3>

<p>f0 optimization routine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getf0(
  y,
  spt,
  ySptIndex,
  sptFreq,
  sampprobs,
  mu,
  mu0,
  f0Start,
  thStart,
  thetaControl = theta.control(),
  f0Control = f0.control(),
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getf0_+3A_y">y</code></td>
<td>
<p>Vector of response values.</p>
</td></tr>
<tr><td><code id="getf0_+3A_spt">spt</code></td>
<td>
<p>Vector of unique observed support points in the response.</p>
</td></tr>
<tr><td><code id="getf0_+3A_ysptindex">ySptIndex</code></td>
<td>
<p>Index of each <code>y</code> value within <code>spt</code>.</p>
</td></tr>
<tr><td><code id="getf0_+3A_sptfreq">sptFreq</code></td>
<td>
<p>Vector containing frequency of each <code>spt</code> value.</p>
</td></tr>
<tr><td><code id="getf0_+3A_sampprobs">sampprobs</code></td>
<td>
<p>Optional matrix of sampling probabilities.</p>
</td></tr>
<tr><td><code id="getf0_+3A_mu">mu</code></td>
<td>
<p>Fitted mean for each observation. Only used if <code>sampprobs=NULL</code>.</p>
</td></tr>
<tr><td><code id="getf0_+3A_mu0">mu0</code></td>
<td>
<p>Mean constraing for f0.</p>
</td></tr>
<tr><td><code id="getf0_+3A_f0start">f0Start</code></td>
<td>
<p>Starting f0 values. (Typically the estimate from the previous
iteration.)</p>
</td></tr>
<tr><td><code id="getf0_+3A_thstart">thStart</code></td>
<td>
<p>Starting theta values. Needs to be a list of values matching
the output of the <code>getTheta</code> function.</p>
</td></tr>
<tr><td><code id="getf0_+3A_thetacontrol">thetaControl</code></td>
<td>
<p>A &quot;thetaControl&quot; object returned from the <code>theta.control</code>
function.</p>
</td></tr>
<tr><td><code id="getf0_+3A_f0control">f0Control</code></td>
<td>
<p>An &quot;f0Control&quot; object returned from the <code>f0.control</code>
function.
trace Logical. If TRUE, then progress is printed to terminal at each iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>

<ul>
<li> <p><code>f0</code> Updated values.
</p>
</li>
<li> <p><code>llik</code> Updated log-likelihood.
</p>
</li>
<li> <p><code>th</code> Updated list returned from the <code>getTheta</code> function.
</p>
</li>
<li> <p><code>conv</code> Convergence indicator.
</p>
</li>
<li> <p><code>iter</code> Number of iterations until convergence.
</p>
</li>
<li> <p><code>nhalf</code> The number of half steps taken on the last iteration if the
initial BFGS update did not improve the log-likelihood.
</p>
</li>
<li> <p><code>score.log</code> Score function with respect to log(f0) at convergence.
</p>
</li>
<li> <p><code>info.log</code> Information matrix with respect to log(f0) at convergence.
</p>
</li></ul>


<hr>
<h2 id='getTheta'>getTheta
Updates theta. Vectorized but only updates observations that have not converged.</h2><span id='topic+getTheta'></span>

<h3>Description</h3>

<p>getTheta
Updates theta. Vectorized but only updates observations that have not converged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTheta(
  spt,
  f0,
  mu,
  sampprobs,
  ySptIndex,
  thetaStart = NULL,
  thetaControl = theta.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTheta_+3A_spt">spt</code></td>
<td>
<p>Support of the observed response variable. (This is the set of
unique values observed, not the set of all possible values.)</p>
</td></tr>
<tr><td><code id="getTheta_+3A_f0">f0</code></td>
<td>
<p>Values of the baseline distribution corresponding to the values of spt</p>
</td></tr>
<tr><td><code id="getTheta_+3A_mu">mu</code></td>
<td>
<p>The fitted mean for each observation. Note these values must lie
strictly within the range of the support.</p>
</td></tr>
<tr><td><code id="getTheta_+3A_sampprobs">sampprobs</code></td>
<td>
<p>Matrix of sampling probabilities. The number of rows should
equal the number of observations, and the number of columns should equal
the number of unique observed support points.</p>
</td></tr>
<tr><td><code id="getTheta_+3A_ysptindex">ySptIndex</code></td>
<td>
<p>Vector containing index of each obervation's response value
within the <code>spt</code> vector. This is only needed to calculate the log-likelihood
after each update.</p>
</td></tr>
<tr><td><code id="getTheta_+3A_thetastart">thetaStart</code></td>
<td>
<p>Vector of starting values. One value per observation. If
<code>NULL</code>, zero is used as the starting value for each observation.</p>
</td></tr>
<tr><td><code id="getTheta_+3A_thetacontrol">thetaControl</code></td>
<td>
<p>Object of class <code>thetaControl</code>, which is a list of
control arguments returned by the <code>thetaControl</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the following:
</p>

<ul>
<li> <p><code>theta</code> Updated values.
</p>
</li>
<li> <p><code>fTilt</code> Matrix containing the exponentially tilted distribution for each
observation, i.e. f(y|X=x). Each column corresponds to an observation and sums to one.
</p>
</li>
<li> <p><code>bPrime</code> Vector containing the mean of the exponentially tilted distribution
for each observation. Should match <code>mu</code> argument very closely.
</p>
</li>
<li> <p><code>bPrime2</code> Vector containing the variance of the exponentially tilted
distribution for each observation.
</p>
</li>
<li> <p><code>fTiltSW</code> Matrix containing the exponentially tilted distribution for each
observation, conditional on that observation being sampled, i.e. f(y|X=x, S=1).
If <code>sampprobs=NULL</code>, then <code>fTiltSW</code> matches <code>fTilt</code>.
</p>
</li>
<li> <p><code>bPrimeSW</code> Vector containing the mean for each observation, conditional
on that observation being sampled. If <code>sampprobs=NULL</code>, then <code>bPrimeSW</code>
matches <code>bPrime</code>.
</p>
</li>
<li> <p><code>bPrime2SW</code> Vector containing the variance for each observation, conditional
on that observation being sampled. If <code>sampprobs=NULL</code>, then <code>bPrime2SW</code>
matches <code>bPrime2</code>.
</p>
</li>
<li> <p><code>llik</code> Semiparametric log-likelihood, evaluated at the current beta
and f0 values. If sampling weights are used, then the log-likelihood is conditional
on each observation being sampled.
</p>
</li>
<li> <p><code>conv</code> Convergence indicator.
</p>
</li>
<li> <p><code>iter</code> Number of iterations until convergence was reached.
</p>
</li></ul>


<hr>
<h2 id='gldrm'>Fits a generalized linear density ratio model (GLDRM)</h2><span id='topic+gldrm'></span>

<h3>Description</h3>

<p>A GLDRM is a semiparametric generalized linear model.
In contrast to a GLM, which assumes a particular exponential family distribution,
the GLDRM uses a semiparametric likelihood to estimate the reference distribution.
The reference distribution may be any discrete, continuous, or mixed exponential
family distribution. The model parameters, which include both the regression
coefficients and the cdf of the unspecified reference distribution, are estimated
by maximizing a semiparametric likelihood. Regression coefficients are estimated
with no loss of efficiency, i.e. the asymptotic variance is the same as if the
true exponential family distribution were known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gldrm(
  formula,
  data = NULL,
  link = "identity",
  mu0 = NULL,
  offset = NULL,
  gldrmControl = gldrm.control(),
  thetaControl = theta.control(),
  betaControl = beta.control(),
  f0Control = f0.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gldrm_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;formula&quot;.</p>
</td></tr>
<tr><td><code id="gldrm_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="gldrm_+3A_link">link</code></td>
<td>
<p>Link function. Can be a character string to be passed to the
<code>make.link</code> function in the <code>stats</code> package (e.g. &quot;identity&quot;,
&quot;logit&quot;, or &quot;log&quot;).
Alternatively, <code>link</code> can be a list containing three functions named
<code>linkfun</code>, <code>linkinv</code>, and <code>mu.eta</code>. The first is the link
function. The second is the inverse link function. The third is the derivative
of the inverse link function. All three functions must be vectorized.</p>
</td></tr>
<tr><td><code id="gldrm_+3A_mu0">mu0</code></td>
<td>
<p>Mean of the reference distribution. The reference distribution is
not unique unless its mean is restricted to a specific value. This value can
be any number within the range of observed values, but values near the boundary
may cause numerical instability. This is an optional argument with <code>mean(y)</code>
being the default value.</p>
</td></tr>
<tr><td><code id="gldrm_+3A_offset">offset</code></td>
<td>
<p>Known component of the linear term. Offset must be passed through
this argument - offset terms in the formula will be ignored.
value and covariate values. If sampling weights are a function of both the
response value and covariates, then <code>sampprobs</code> must be a <code class="reqn">n \times q</code>
matrix, where <code class="reqn">n</code> is the number of observations and <code class="reqn">q</code> is the number
of unique observed values in the response vector. If sampling weights do not
depend on the covariate values, then <code>sampprobs</code> may alternatively be passed
as a vector of length <code class="reqn">n</code>. All values must be nonnegative and are assumed to
correspond to the sorted response values in increasing order.</p>
</td></tr>
<tr><td><code id="gldrm_+3A_gldrmcontrol">gldrmControl</code></td>
<td>
<p>Optional control arguments.
Passed as an object of class &quot;gldrmControl&quot;, which is constructed by the
<code>gldrm.control</code> function.
See <code>gldrm.control</code> documentation for details.</p>
</td></tr>
<tr><td><code id="gldrm_+3A_thetacontrol">thetaControl</code></td>
<td>
<p>Optional control arguments for the theta update procedure.
Passed as an object of class &quot;thetaControl&quot;, which is constructed by the
<code>theta.control</code> function.
See <code>theta.control</code> documentation for details.</p>
</td></tr>
<tr><td><code id="gldrm_+3A_betacontrol">betaControl</code></td>
<td>
<p>Optional control arguments for the beta update procedure.
Passed as an object of class &quot;betaControl&quot;, which is constructed by the
<code>beta.control</code> function.
See <code>beta.control</code> documentation for details.</p>
</td></tr>
<tr><td><code id="gldrm_+3A_f0control">f0Control</code></td>
<td>
<p>Optional control arguments for the <code>f0</code> update procedure.
Passed as an object of class &quot;f0Control&quot;, which is constructed by the
<code>f0.control</code> function.
See <code>f0.control</code> documentation for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>linkfun</code>, <code>linkinv</code>, and <code>mu.eta</code>
mirror the &quot;link-glm&quot; class. Objects of this class can be created with the
<code>stats::make.link</code> function.
</p>
<p>The &quot;gldrm&quot; class is a list of the following items.
</p>

<ul>
<li> <p><code>conv</code> Logical indicator for whether the gldrm algorithm
converged within the iteration limit.
</p>
</li>
<li> <p><code>iter</code> Number of iterations used. A single iteration is a <code>beta</code>
update, followed by an <code>f0</code> update.
</p>
</li>
<li> <p><code>llik</code> Semiparametric log-likelihood of the fitted model.
</p>
</li>
<li> <p><code>beta</code> Vector containing the regression coefficient estimates.
</p>
</li>
<li> <p><code>mu</code> Vector containing the estimated mean response value for each
observation in the training data.
</p>
</li>
<li> <p><code>eta</code> Vector containing the estimated linear combination of
covariates for each observation.
</p>
</li>
<li> <p><code>f0</code> Vector containing the semiparametric estimate of the reference
distribution, evaluated at the observed response values. The values of correspond
to the support values, sorted in increasing order.
</p>
</li>
<li> <p><code>spt</code> Vector containing the unique observed response values, sorted in
increasing order.
</p>
</li>
<li> <p><code>mu0</code> Mean of the estimated semiparametric reference distribution.
The mean of the reference distribution must be fixed at a value in order for
the model to be identifiable. It can be fixed at any value within the range
of observed response values, but the <code>gldrm</code> function assigns <code>mu0</code>
to be the mean of the observed response values.
</p>
</li>
<li> <p><code>varbeta</code> Estimated variance matrix of the regression coefficients.
</p>
</li>
<li> <p><code>seBeta</code> Standard errors for <code class="reqn">\hat{\beta}</code>. Equal to
<code>sqrt(diag(varbeta))</code>.
</p>
</li>
<li> <p><code>seMu</code> Standard errors for <code class="reqn">\hat{\mu}</code> computed from <code>varbeta</code>.
</p>
</li>
<li> <p><code>seEta</code> Standard errors for <code class="reqn">\hat{\eta}</code> computed from <code>varbeta</code>.
</p>
</li>
<li> <p><code>theta</code> Vector containing the estimated tilt parameter for each observation.
The tilted density function of the response variable is given by
</p>
<p style="text-align: center;"><code class="reqn">f(y|x_i) = f_0(y) \exp(\theta_i y) / \int f_0(u) \exp(\theta_i u) du.</code>
</p>

</li>
<li> <p><code>bPrime</code> is a vector containing the mean of the tilted distribution,
<code class="reqn">b'(\theta_i)</code>, for each observation. <code>bPrime</code> should match <code>mu</code>,
except in cases where <code>theta</code> is capped for numerical stability.
</p>
<p style="text-align: center;"><code class="reqn">b'(\theta_i) = \int u f(u|x_i) du</code>
</p>

</li>
<li> <p><code>bPrime2</code> is a vector containing the variance of the tilted
distribution, <code class="reqn">b''(\theta_i)</code>, for each observation.
</p>
<p style="text-align: center;"><code class="reqn">b''(\theta_i) = \int (u - b'(\theta_i))^2 f(u|x_i) du</code>
</p>

</li>
<li> <p><code>fTilt</code> is a vector containing the semiparametric fitted probability,
<code class="reqn">\hat{f}(y_i | x_i)</code>, for each observation. The semiparametric
log-likelihood is equal to
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^n \log \hat{f}(y_i | x_i).</code>
</p>

</li>
<li> <p><code>sampprobs</code> If sampling probabilities were passed through the
<code>sampprobs</code> argument, then they are returned here in matrix form.
Each row corresponds to an observation.
</p>
</li>
<li> <p><code>llikNull</code> Log-likelihood of the null model with no covariates.
</p>
</li>
<li> <p><code>lr.stat</code> Likelihood ratio test statistic comparing fitted model to
the null model. It is calculated as <code class="reqn">2 \times (llik - llik_0) / (p-1)</code>.
The asymptotic distribution is F(p-1, n-p) under the null hypothesis.
</p>
</li>
<li> <p><code>lr.pval</code> P-value of the likelihood ratio statistic.
</p>
</li>
<li> <p><code>fTiltMatrix</code> is a matrix containing the semiparametric density for
each observation, i.e. <code class="reqn">\hat{f}(y | x_i)</code> for each unique <code>y</code> value.
This is a matrix with nrow equal to the number of observations and ncol equal
to the number of unique response values observed.
Only returned if <code>returnfTilt = TRUE</code> in the gldrmControl arguments.
</p>
</li>
<li> <p><code>score.logf0</code> Score function for <code>log(f0)</code>.
Only returned if <code>returnf0ScoreInfo = TRUE</code> in the gldrmControl arguments.
</p>
</li>
<li> <p><code>info.logf0</code> Information matrix for <code>log(f0)</code>.
Only returned if <code>returnf0ScoreInfo = TRUE</code> in the gldrmControl arguments.
</p>
</li>
<li> <p><code>formula</code> Model formula.
</p>
</li>
<li> <p><code>data</code> Model data frame.
</p>
</li>
<li> <p><code>link</code> Link function. If a character string was passed to the
<code>link</code> argument, then this will be an object of class &quot;link-glm&quot;.
Otherwise, it will be the list of three functions passed to the <code>link</code> argument.
</p>
</li></ul>



<h3>Value</h3>

<p>An S3 object of class &quot;gldrm&quot;. See details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package="datasets")

# Fit a gldrm with log link
fit &lt;- gldrm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + Species,
             data=iris, link="log")
fit

# Fit a gldrm with custom link function
link &lt;- list()
link$linkfun &lt;- function(mu) log(mu)^3
link$linkinv &lt;- function(eta) exp(eta^(1/3))
link$mu.eta &lt;- function(eta) exp(eta^(1/3)) * 1/3 * eta^(-2/3)
fit2 &lt;- gldrm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + Species,
              data=iris, link=link)
fit2

</code></pre>

<hr>
<h2 id='gldrm.control'>Control arguments for <code>gldrm</code> algorithm</h2><span id='topic+gldrm.control'></span>

<h3>Description</h3>

<p>This function returns control arguments for the <code>gldrm</code> algorithm.
Each argument has a default value, which will be used unless a different
value is provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gldrm.control(
  eps = 1e-10,
  maxiter = 100,
  returnfTiltMatrix = TRUE,
  returnf0ScoreInfo = FALSE,
  print = FALSE,
  betaStart = NULL,
  f0Start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gldrm.control_+3A_eps">eps</code></td>
<td>
<p>Convergence threshold. The fitting algorithm has converged when the
relative change in log-likelihood between iterations is less than <code>eps</code>.
A single iteration consists of a <code>beta</code> update followed by an <code>f0</code>
update.</p>
</td></tr>
<tr><td><code id="gldrm.control_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="gldrm.control_+3A_returnftiltmatrix">returnfTiltMatrix</code></td>
<td>
<p>Logical. Return nonparametric fitted probabilities for
each observation. This is a matrix with nrow equal to the number of
observations and ncol equal to the number of unique response values observed.</p>
</td></tr>
<tr><td><code id="gldrm.control_+3A_returnf0scoreinfo">returnf0ScoreInfo</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the score and information for
<code>log(f0)</code> are returned as components of the &quot;gldrm&quot; object.</p>
</td></tr>
<tr><td><code id="gldrm.control_+3A_print">print</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the relative change in the log-likelihood
will be printed after each iteration.</p>
</td></tr>
<tr><td><code id="gldrm.control_+3A_betastart">betaStart</code></td>
<td>
<p>Optional vector of starting values for <code>beta</code>. If the
call to gldrm contains a formula, the values of betaStart should correspond to
the columns of the model matrix.</p>
</td></tr>
<tr><td><code id="gldrm.control_+3A_f0start">f0Start</code></td>
<td>
<p>Optional vector of starting values for <code>f0</code>. The length
of the vector should be the number of unique values in the response, and the
vector should correspond to these values sorted in increasing order. The starting
values will be scaled to sum to one and tilted to have mean <code>mu0</code>. All values
should be strictly positive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of S3 class &quot;gldrmControl&quot;, which is a list of control arguments.
</p>

<hr>
<h2 id='gldrmCI'>Confidence intervals for gldrm coefficients</h2><span id='topic+gldrmCI'></span>

<h3>Description</h3>

<p>Calculates a Wald, likelihood ratio, or score confidence interval for a single gldrm
coefficient. Also calculates upper or lower confidence bounds. Wald confidence
intervals and bounds are calculated from the standard errors which are available
from the gldrm model fit. For likelihood ratio and score intervals and bounds,
a bisection search method is used, which takes longer to run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gldrmCI(
  gldrmFit,
  term,
  test = c("Wald", "LRT", "Score"),
  level = 0.95,
  type = c("2-sided", "lb", "ub"),
  eps = 1e-10,
  maxiter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gldrmCI_+3A_gldrmfit">gldrmFit</code></td>
<td>
<p>A gldrm model fit. Must be an S3 object of class &quot;gldrm&quot;,
returned from the <code>gldrm</code> function.</p>
</td></tr>
<tr><td><code id="gldrmCI_+3A_term">term</code></td>
<td>
<p>Character string containing the name of the coefficient of interest.
The coefficient names are the names of the beta component of the fitted model
object. They can also be obtained from the printed model output. Usually the
names match the formula syntax, but can be more complicated for categorical
variables and interaction terms.</p>
</td></tr>
<tr><td><code id="gldrmCI_+3A_test">test</code></td>
<td>
<p>Character string for the type confidence interval. Options are
&quot;Wald&quot;, &quot;LRT&quot; (for likelihood ratio), and &quot;Score&quot;.</p>
</td></tr>
<tr><td><code id="gldrmCI_+3A_level">level</code></td>
<td>
<p>Confidence level of the interval. Should be between zero and one.</p>
</td></tr>
<tr><td><code id="gldrmCI_+3A_type">type</code></td>
<td>
<p>Character string containing &quot;2-sided&quot; for a two-sided confidence interval,
&quot;lb&quot; for a lower bound, or &quot;ub&quot; for an upper bound.</p>
</td></tr>
<tr><td><code id="gldrmCI_+3A_eps">eps</code></td>
<td>
<p>Convergence threshold. Only applies for
<code>test = "LRT"</code> and <code>test = "Score"</code>.
Convergence is reached when likelihood ratio p-value is within <code>eps</code> of
the target p-value, based on the level of the test. For example, a two-sided
95% confidence interval has target p-value of 0.025 for both the upper and
lower bounds. A 95% confidence bound has target p-value 0.05.</p>
</td></tr>
<tr><td><code id="gldrmCI_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of bisection method iterations for likelihood
ratio intervals or bounds. For two-sided intervals, <code>maxiter</code> iterations
are allowed for each bound.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class 'gldrmCI', which is a list of the following items.
</p>

<ul>
<li> <p><code>term</code> Coefficient name.
</p>
</li>
<li> <p><code>test</code> Type of interval or bound - Wald or likelihood ratio.
</p>
</li>
<li> <p><code>level</code> Confidence level.
</p>
</li>
<li> <p><code>type</code> Type of interval or bound - two-sided, upper bound, or lower
bound.
</p>
</li>
<li> <p><code>cilo</code>/<code>cihi</code> Upper and lower interval bounds. One one of the
two applies for confidence bounds.
</p>
</li>
<li> <p><code>iterlo</code>/<code>iterhi</code> Number of bisection iterations used. Only
applies for likelihood ratio intervals and bounds.
</p>
</li>
<li> <p><code>pvallo</code>/<code>pvalhi</code> For likelihood ratio intervals and bounds,
the p-value at convergence is reported.
</p>
</li>
<li> <p><code>conv</code> Indicator for whether the confidence interval limit or bound
converged.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package="datasets")

### Fit gldrm with all variables
fit &lt;- gldrm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + Species,
             data=iris, link="log")

### Wald 95% confidence interval for Sepal.Width
ci &lt;- gldrmCI(fit, "Sepal.Width", test="Wald", level=.95, type="2-sided")
ci

</code></pre>

<hr>
<h2 id='gldrmFit'>Main optimization function</h2><span id='topic+gldrmFit'></span>

<h3>Description</h3>

<p>This function is called by the main <code>gldrm</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gldrmFit(
  x,
  y,
  linkfun,
  linkinv,
  mu.eta,
  mu0 = NULL,
  offset = NULL,
  sampprobs = NULL,
  gldrmControl = gldrm.control(),
  thetaControl = theta.control(),
  betaControl = beta.control(),
  f0Control = f0.control()
)
</code></pre>

<hr>
<h2 id='gldrmLRT'>Likelihood ratio test for nested models</h2><span id='topic+gldrmLRT'></span>

<h3>Description</h3>

<p>Performs a likelihood ratio F-test between nested gldrm models.
The F-statistic is calculated as <code class="reqn">2 \times (llik - llik_0) / r</code>, where
<code class="reqn">r</code> is the difference is the number of parameters between the full and null
models. The F-statistic has degrees of freedom <code class="reqn">r</code> and <code class="reqn">n-p</code>, where
<code class="reqn">n</code> is the number of observations and <code class="reqn">p</code> is the number of parameters
in the full model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gldrmLRT(gldrmFit, gldrmNull)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gldrmLRT_+3A_gldrmfit">gldrmFit</code></td>
<td>
<p>The full model. Must be an object of S3 class 'gldrm' returned from
the <code>gldrm</code> function.</p>
</td></tr>
<tr><td><code id="gldrmLRT_+3A_gldrmnull">gldrmNull</code></td>
<td>
<p>The sub-model being tested under the null hypotheses.
Must be an object of S3 class 'gldrm' returned from the <code>gldrm</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class 'gldrmLRT', containing numerator and denominator
degrees of freedom, an F-statistic, and a p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package="datasets")

### Fit gldrm with all variables
fit &lt;- gldrm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + Species,
             data=iris, link="log")

### Fit gldrm without the categorical variable "Species"
fit0 &lt;- gldrm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width,
              data=iris, link="log")

### Likelihood ratio test for the nested models
lrt &lt;- gldrmLRT(fit, fit0)
lrt

</code></pre>

<hr>
<h2 id='gldrmPIT'>Confidence intervals for gldrm coefficients</h2><span id='topic+gldrmPIT'></span>

<h3>Description</h3>

<p>Plots and returns the randomized probability inverse transform of a 
fitted gldrm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gldrmPIT(
  gldrmFit,
  nbreaks = 7,
  cex.main = NULL,
  cex.lab = NULL,
  cex.axis = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gldrmPIT_+3A_gldrmfit">gldrmFit</code></td>
<td>
<p>A gldrm model fit. Must be an S3 object of class &quot;gldrm&quot;,
returned from the <code>gldrm</code> function. The matrix of semiparametric
tilted probabilities must be returned, which is done by fitting gldrm with
<code>gldrmControl = gldrm.control(returnfTiltMatrix = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="gldrmPIT_+3A_nbreaks">nbreaks</code></td>
<td>
<p>Number of breaks in the histogram.</p>
</td></tr>
<tr><td><code id="gldrmPIT_+3A_cex.main">cex.main</code></td>
<td>
<p>Text size for main titles.</p>
</td></tr>
<tr><td><code id="gldrmPIT_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Text size for axis labels.</p>
</td></tr>
<tr><td><code id="gldrmPIT_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Text size for axis numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability inverse transform is defined generally as <code class="reqn">\hat{F}(y|x)</code>,
which is the fitted conditional cdf of each observation evaluated at the
observed response value. In the case of gldrm, the fitted cdf is descrete, so
we draw a random value from a uniform distribution on the interval 
(<code class="reqn">\hat{F}(y|x)</code>, <code class="reqn">\hat{F}(y-|x)</code>), where <code class="reqn">y-</code> is the next largest 
observed support less than <code class="reqn">y</code> (or -Infinity if <code class="reqn">y</code> is the minimum 
support value). The output and plots generated by this function will vary
slightly each time it is called (unless the random number generator seed is 
set beforehand).
</p>


<h3>Value</h3>

<p>Randomized robability inverse transform as a vector. Also plots the 
histogram and uniform QQ plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris, package="datasets")

### Fit gldrm and return fTiltMatrix
fit &lt;- gldrm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + Species,
             data=iris, link="log")
             
# Probability inverse transform plot
gldrmPIT(fit)

</code></pre>

<hr>
<h2 id='predict.gldrm'>Predict method for a gldrm object</h2><span id='topic+predict.gldrm'></span>

<h3>Description</h3>

<p>Obtains predicted probabilities, predicted class, or linear predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gldrm'
predict(
  object,
  newdata = NULL,
  type = c("link", "response", "terms", "fTilt"),
  se.fit = FALSE,
  offset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gldrm_+3A_object">object</code></td>
<td>
<p>S3 object of class &quot;gldrm&quot;, returned from the <code>gldrm</code> function.</p>
</td></tr>
<tr><td><code id="predict.gldrm_+3A_newdata">newdata</code></td>
<td>
<p>Optional data frame. If NULL, fitted values will be obtained
for the training data.</p>
</td></tr>
<tr><td><code id="predict.gldrm_+3A_type">type</code></td>
<td>
<p>The type of prediction required.  Type &quot;link&quot; returns the linear
predictor. Type &quot;response&quot; returns the fitted mean. Type &quot;terms&quot; returns
a matrix giving the fitted values of each term in the model formula on the
linear predictor scale. Type &quot;fTilt&quot; returns a matrix containing the
fitted nonparametric distribution for each observation. Each row of the matrix
corresponds to an observation in <code>newdata</code>, and each column corresponds
to a unique response value in the training data.</p>
</td></tr>
<tr><td><code id="predict.gldrm_+3A_se.fit">se.fit</code></td>
<td>
<p>Logical. If TRUE, standard errors are also returned. Does not apply
for <code>type = "fTilt"</code>.</p>
</td></tr>
<tr><td><code id="predict.gldrm_+3A_offset">offset</code></td>
<td>
<p>Optional offset vector. Only used if <code>newdata</code> is not NULL.</p>
</td></tr>
<tr><td><code id="predict.gldrm_+3A_...">...</code></td>
<td>
<p>Not used. Additional predict arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned depends on <code>type</code>.
</p>

<hr>
<h2 id='print.gldrm'>Print summary of gldrm fit</h2><span id='topic+print.gldrm'></span>

<h3>Description</h3>

<p>Prints fitted coefficients and standard errors, along with a likelihood ratio
test against the null model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gldrm'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gldrm_+3A_x">x</code></td>
<td>
<p>S3 object of class &quot;gldrm&quot;, returned from the <code>gldrm</code> function.</p>
</td></tr>
<tr><td><code id="print.gldrm_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding.</p>
</td></tr>
<tr><td><code id="print.gldrm_+3A_...">...</code></td>
<td>
<p>Unused. Additional arguments for print method.</p>
</td></tr>
</table>

<hr>
<h2 id='print.gldrmCI'>Print confidence interval</h2><span id='topic+print.gldrmCI'></span>

<h3>Description</h3>

<p>Print method for gldrmCI objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gldrmCI'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gldrmCI_+3A_x">x</code></td>
<td>
<p>An S3 object of class 'gldrmCI'.</p>
</td></tr>
<tr><td><code id="print.gldrmCI_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding.</p>
</td></tr>
<tr><td><code id="print.gldrmCI_+3A_...">...</code></td>
<td>
<p>Not used. Additional arguments for print method.</p>
</td></tr>
</table>

<hr>
<h2 id='print.gldrmLRT'>Print likelihood ratio test results</h2><span id='topic+print.gldrmLRT'></span>

<h3>Description</h3>

<p>Print method for gldrmLRT objects. Prints results of a likelihood ratio F-test
between nested models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gldrmLRT'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gldrmLRT_+3A_x">x</code></td>
<td>
<p>S3 object of class 'gldrmLRT', returned from the <code>gldrmLRT</code> function.</p>
</td></tr>
<tr><td><code id="print.gldrmLRT_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding.</p>
</td></tr>
<tr><td><code id="print.gldrmLRT_+3A_...">...</code></td>
<td>
<p>Not used. Additional arguments for print method.</p>
</td></tr>
</table>

<hr>
<h2 id='theta.control'>Control arguments for <code class="reqn">\theta</code> update algorithm</h2><span id='topic+theta.control'></span>

<h3>Description</h3>

<p>This function returns control arguments for the <code class="reqn">\theta</code> update algorithm.
Each argument has a default value, which will be used unless a different
value is provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta.control(
  eps = 1e-10,
  maxiter = 100,
  maxhalf = 20,
  maxtheta = 500,
  logit = TRUE,
  logsumexp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta.control_+3A_eps">eps</code></td>
<td>
<p>Convergence threshold for theta updates. Convergence is
evaluated separately for each observation. An observation has converged when
the difference between <code class="reqn">b'(\theta)</code> and <code class="reqn">\mu</code> is less than <code>epsTheta</code>.</p>
</td></tr>
<tr><td><code id="theta.control_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="theta.control_+3A_maxhalf">maxhalf</code></td>
<td>
<p>Maximum number of half steps allowed per iteration if the
convergence criterion does not improve.</p>
</td></tr>
<tr><td><code id="theta.control_+3A_maxtheta">maxtheta</code></td>
<td>
<p>Absolute value of theta is not allowed to exceed <code>maxtheta</code>.</p>
</td></tr>
<tr><td><code id="theta.control_+3A_logit">logit</code></td>
<td>
<p>Logical for whether logit transformation should be used. Use of
this stabilizing transformation appears to be faster in general. Default is TRUE.</p>
</td></tr>
<tr><td><code id="theta.control_+3A_logsumexp">logsumexp</code></td>
<td>
<p>Logical argument for whether log-sum-exp trick should be used.
This may improve numerical stability at the expense of computational time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of S3 class &quot;thetaControl&quot;, which is a list of control arguments.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
