<!DOCTYPE html><html><head><title>Help for package kalmanfilter</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kalmanfilter}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#contains'><p>Check if list contains a name</p></a></li>
<li><a href='#gen_inv'><p>Generalized matrix inverse</p></a></li>
<li><a href='#kalman_filter'><p>Kalman Filter</p></a></li>
<li><a href='#kalman_filter_cpp'><p>Kalman Filter</p></a></li>
<li><a href='#kalmanfilter-package'><p>kalmanfilter: Kalman Filter</p></a></li>
<li><a href='#Rginv'><p>R's implementation of the Moore-Penrose pseudo matrix inverse</p></a></li>
<li><a href='#sw_dcf'><p>Stock and Watson Dynamic Common Factor Data Set</p></a></li>
<li><a href='#treasuries'><p>Treasuries</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kalman Filter</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-01</td>
</tr>
<tr>
<td>Description:</td>
<td>'Rcpp' implementation of the multivariate Kalman filter for state space models that can handle missing values and exogenous data in the observation and state equations. There is also a function to handle time varying parameters.
  Kim, Chang-Jin and Charles R. Nelson (1999) "State-Space Models with Regime Switching: Classical and Gibbs-Sampling Approaches with Applications" &lt;<a href="https://doi.org/10.7551%2Fmitpress%2F6444.001.0001">doi:10.7551/mitpress/6444.001.0001</a>&gt;<a href="http://econ.korea.ac.kr/~cjkim/">http://econ.korea.ac.kr/~cjkim/</a>. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>data.table (&ge; 1.14.2), maxLik (&ge; 1.5-2), ggplot2 (&ge;
3.3.6), gridExtra (&ge; 2.3), knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-08 03:09:43 UTC; alex.hubbard</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Hubbard [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Hubbard &lt;hubbard.alex@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-08 05:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='contains'>Check if list contains a name</h2><span id='topic+contains'></span>

<h3>Description</h3>

<p>Check if list contains a name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contains(s, L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contains_+3A_s">s</code></td>
<td>
<p>a string name</p>
</td></tr>
<tr><td><code id="contains_+3A_l">L</code></td>
<td>
<p>a list object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean
</p>

<hr>
<h2 id='gen_inv'>Generalized matrix inverse</h2><span id='topic+gen_inv'></span>

<h3>Description</h3>

<p>Generalized matrix inverse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_inv(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_inv_+3A_m">m</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix inverse of m
</p>

<hr>
<h2 id='kalman_filter'>Kalman Filter</h2><span id='topic+kalman_filter'></span>

<h3>Description</h3>

<p>Kalman Filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kalman_filter(ssm, yt, Xo = NULL, Xs = NULL, weight = NULL, smooth = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kalman_filter_+3A_ssm">ssm</code></td>
<td>
<p>list describing the state space model, must include names
B0 - N_b x 1 matrix (or array of length yt), initial guess for the unobserved components 
P0 - N_b x N_b matrix (or array of length yt), initial guess for the covariance matrix of the unobserved components
Dm - N_b x 1 matrix (or array of length yt), constant matrix for the state equation
Am - N_y x 1 matrix (or array of length yt), constant matrix for the observation equation
Fm - N_b X p matrix (or array of length yt), state transition matrix
Hm - N_y x N_b matrix (or array of length yt), observation matrix
Qm - N_b x N_b matrix (or array of length yt), state error covariance matrix
Rm - N_y x N_y matrix (or array of length yt), state error covariance matrix
betaO - N_y x N_o matrix (or array of length yt), coefficient matrix for the observation exogenous data
betaS - N_b x N_s matrix (or array of length yt), coefficient matrix for the state exogenous data</p>
</td></tr>
<tr><td><code id="kalman_filter_+3A_yt">yt</code></td>
<td>
<p>N x T matrix of data</p>
</td></tr>
<tr><td><code id="kalman_filter_+3A_xo">Xo</code></td>
<td>
<p>N_o x T matrix of exogenous observation data</p>
</td></tr>
<tr><td><code id="kalman_filter_+3A_xs">Xs</code></td>
<td>
<p>N_s x T matrix of exogenous state</p>
</td></tr>
<tr><td><code id="kalman_filter_+3A_weight">weight</code></td>
<td>
<p>column matrix of weights, T x 1</p>
</td></tr>
<tr><td><code id="kalman_filter_+3A_smooth">smooth</code></td>
<td>
<p>boolean indication whether to run the backwards smoother</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of cubes and matrices output by the Kalman filter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Stock and Watson Markov switching dynamic common factor
library(kalmanfilter)
library(data.table)
data(sw_dcf)
data = sw_dcf[, colnames(sw_dcf) != "dcoinc", with = FALSE]
vars = colnames(data)[colnames(data) != "date"]

#Set up the state space model
ssm = list()
ssm[["Fm"]] = rbind(c(0.8760, -0.2171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 
                  c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 
                  c(0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                  c(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0), 
                  c(0, 0, 0, 0, 0.0364, -0.0008, 0, 0, 0, 0, 0, 0), 
                  c(0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0), 
                  c(0, 0, 0, 0, 0, 0, -0.2965, -0.0657, 0, 0, 0, 0), 
                  c(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0), 
                  c(0, 0, 0, 0, 0, 0, 0, 0, -0.3959, -0.1903, 0, 0),
                  c(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0), 
                  c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.2436, 0.1281), 
                  c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0))
ssm[["Fm"]] = array(ssm[["Fm"]], dim = c(dim(ssm[["Fm"]]), 2))
ssm[["Dm"]] = matrix(c(-1.5700, rep(0, 11)), nrow = nrow(ssm[["Fm"]]), ncol = 1)
ssm[["Dm"]] = array(ssm[["Dm"]], dim = c(dim(ssm[["Dm"]]), 2))
ssm[["Dm"]][1,, 2] = 0.2802
ssm[["Qm"]] = diag(c(1, 0, 0, 0, 0.0001, 0, 0.0001, 0, 0.0001, 0, 0.0001, 0))
ssm[["Qm"]] = array(ssm[["Qm"]], dim = c(dim(ssm[["Qm"]]), 2))
ssm[["Hm"]] = rbind(c(0.0058, -0.0033, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0), 
                  c(0.0011, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0), 
                  c(0.0051, -0.0033, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0), 
                  c(0.0012, -0.0005, 0.0001, 0.0002, 0, 0, 0, 0, 0, 0, 1, 0))
ssm[["Hm"]] = array(ssm[["Hm"]], dim = c(dim(ssm[["Hm"]]), 2))
ssm[["Am"]] = matrix(0, nrow = nrow(ssm[["Hm"]]), ncol = 1)
ssm[["Am"]] = array(ssm[["Am"]], dim = c(dim(ssm[["Am"]]), 2))
ssm[["Rm"]] = matrix(0, nrow = nrow(ssm[["Am"]]), ncol = nrow(ssm[["Am"]]))
ssm[["Rm"]] = array(ssm[["Rm"]], dim = c(dim(ssm[["Rm"]]), 2))
ssm[["B0"]] = matrix(c(rep(-4.60278, 4), 0, 0, 0, 0, 0, 0, 0, 0)) 
ssm[["B0"]] = array(ssm[["B0"]], dim = c(dim(ssm[["B0"]]), 2))
ssm[["B0"]][1:4,, 2] = rep(0.82146, 4)
ssm[["P0"]] = rbind(c(2.1775, 1.5672, 0.9002, 0.4483, 0, 0, 0, 0, 0, 0, 0, 0), 
                    c(1.5672, 2.1775, 1.5672, 0.9002, 0, 0, 0, 0, 0, 0, 0, 0), 
                    c(0.9002, 1.5672, 2.1775, 1.5672, 0, 0, 0, 0, 0, 0, 0, 0), 
                    c(0.4483, 0.9002, 1.5672, 2.1775, 0, 0, 0, 0, 0, 0, 0, 0), 
                    c(0, 0, 0, 0, 0.0001, 0, 0, 0, 0, 0, 0, 0), 
                    c(0, 0, 0, 0, 0, 0.0001,  0, 0, 0, 0, 0, 0), 
                    c(0, 0, 0, 0, 0, 0, 0.0001, -0.0001, 0, 0, 0, 0),
                    c(0, 0, 0, 0, 0, 0, -0.0001, 0.0001, 0, 0, 0, 0), 
                    c(0, 0, 0, 0, 0, 0, 0, 0, 0.0001, -0.0001, 0, 0), 
                    c(0, 0, 0, 0, 0, 0, 0, 0, -0.0001, 0.0001, 0, 0), 
                    c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0001, -0.0001), 
                    c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.0001, 0.0001))
ssm[["P0"]] = array(ssm[["P0"]], dim = c(dim(ssm[["P0"]]), 2))
  
#Log, difference and standardize the data
data[, c(vars) := lapply(.SD, log), .SDcols = c(vars)]
data[, c(vars) := lapply(.SD, function(x){
  x - shift(x, type = "lag", n = 1)
}), .SDcols = c(vars)]
data[, c(vars) := lapply(.SD, scale), .SDcols = c(vars)]
  
#Convert the data to an NxT matrix
yt = t(data[, c(vars), with = FALSE])
kf = kalman_filter(ssm, yt, smooth = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='kalman_filter_cpp'>Kalman Filter</h2><span id='topic+kalman_filter_cpp'></span>

<h3>Description</h3>

<p>Kalman Filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kalman_filter_cpp(ssm, yt, Xo = NULL, Xs = NULL, weight = NULL, smooth = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kalman_filter_cpp_+3A_ssm">ssm</code></td>
<td>
<p>list describing the state space model, must include names
B0 - N_b x 1 matrix, initial guess for the unobserved components 
P0 - N_b x N_b matrix, initial guess for the covariance matrix of the unobserved components
Dm - N_b x 1 matrix, constant matrix for the state equation
Am - N_y x 1 matrix, constant matrix for the observation equation
Fm - N_b X p matrix, state transition matrix
Hm - N_y x N_b matrix, observation matrix
Qm - N_b x N_b matrix, state error covariance matrix
Rm - N_y x N_y matrix, state error covariance matrix
betaO - N_y x N_o matrix, coefficient matrix for the observation exogenous data
betaS - N_b x N_s matrix, coefficient matrix for the state exogenous data</p>
</td></tr>
<tr><td><code id="kalman_filter_cpp_+3A_yt">yt</code></td>
<td>
<p>N x T matrix of data</p>
</td></tr>
<tr><td><code id="kalman_filter_cpp_+3A_xo">Xo</code></td>
<td>
<p>N_o x T matrix of exogenous observation data</p>
</td></tr>
<tr><td><code id="kalman_filter_cpp_+3A_xs">Xs</code></td>
<td>
<p>N_s x T matrix of exogenous state</p>
</td></tr>
<tr><td><code id="kalman_filter_cpp_+3A_weight">weight</code></td>
<td>
<p>column matrix of weights, T x 1</p>
</td></tr>
<tr><td><code id="kalman_filter_cpp_+3A_smooth">smooth</code></td>
<td>
<p>boolean indication whether to run the backwards smoother</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of matrices and cubes output by the Kalman filter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Nelson-Siegel dynamic factor yield curve
library(kalmanfilter)
library(data.table)
data(treasuries)
tau = unique(treasuries$maturity)

#Set up the state space model
ssm = list()
ssm[["Fm"]] = rbind(c(0.9720, -0.0209, -0.0061), 
                    c(0.1009 , 0.8189, -0.1446), 
                    c(-0.1226, 0.0192, 0.8808))
ssm[["Dm"]] = matrix(c(0.1234, -0.2285, 0.2020), nrow = nrow(ssm[["Fm"]]), ncol = 1)
ssm[["Qm"]] = rbind(c(0.1017, 0.0937, 0.0303), 
                    c(0.0937, 0.2267, 0.0351), 
                    c(0.0303, 0.0351, 0.7964))
ssm[["Hm"]] = cbind(rep(1, 11),
                    -(1 - exp(-tau*0.0423))/(tau*0.0423), 
                    (1 - exp(-tau*0.0423))/(tau*0.0423) - exp(-tau*0.0423))
ssm[["Am"]] = matrix(0, nrow = length(tau), ncol = 1)
ssm[["Rm"]] = diag(c(0.0087, 0, 0.0145, 0.0233, 0.0176, 0.0073, 
                     0, 0.0016, 0.0035, 0.0207, 0.0210))
ssm[["B0"]] = matrix(c(5.9030, -0.7090, 0.8690), nrow = nrow(ssm[["Fm"]]), ncol = 1)
ssm[["P0"]] = diag(rep(0.0001, nrow(ssm[["Fm"]])))
    
#Convert to an NxT matrix
yt = dcast(treasuries, "date ~ maturity", value.var = "value")
yt = t(yt[, 2:ncol(yt)])
kf = kalman_filter(ssm, yt, smooth = TRUE)   
</code></pre>

<hr>
<h2 id='kalmanfilter-package'>kalmanfilter: Kalman Filter</h2><span id='topic+kalmanfilter'></span><span id='topic+kalmanfilter-package'></span>

<h3>Description</h3>

<p>'Rcpp' implementation of the multivariate Kalman filter for state space models that can handle missing values and exogenous data in the observation and state equations. There is also a function to handle time varying parameters. Kim, Chang-Jin and Charles R. Nelson (1999) &quot;State-Space Models with Regime Switching: Classical and Gibbs-Sampling Approaches with Applications&quot; <a href="https://doi.org/10.7551/mitpress/6444.001.0001">doi:10.7551/mitpress/6444.001.0001</a><a href="http://econ.korea.ac.kr/~cjkim/">http://econ.korea.ac.kr/~cjkim/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alex Hubbard <a href="mailto:hubbard.alex@gmail.com">hubbard.alex@gmail.com</a>
</p>

<hr>
<h2 id='Rginv'>R's implementation of the Moore-Penrose pseudo matrix inverse</h2><span id='topic+Rginv'></span>

<h3>Description</h3>

<p>R's implementation of the Moore-Penrose pseudo matrix inverse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rginv(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rginv_+3A_m">m</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix inverse of m
</p>

<hr>
<h2 id='sw_dcf'>Stock and Watson Dynamic Common Factor Data Set</h2><span id='topic+sw_dcf'></span>

<h3>Description</h3>

<p>Stock and Watson Dynamic Common Factor Data Set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sw_dcf)
</code></pre>


<h3>Format</h3>

<p>data.table with columns DATE, VARIABLE, VALUE, and MATURITY 
The data is monthly frequency with variables ip (industrial production), 
gmyxpg (total personal income less transfer payments in 1987 dollars), 
mtq (total manufacturing and trade sales in 1987 dollars), 
lpnag (employees on non-agricultural payrolls), and
dcoinc (the coincident economic indicator)
</p>


<h3>Source</h3>

<p>Kim, Chang-Jin and Charles R. Nelson (1999) &quot;State-Space Models with Regime Switching: Classical and Gibbs-Sampling Approaches with Applications&quot; &lt;doi:10.7551/mitpress/6444.001.0001&gt;&lt;http://econ.korea.ac.kr/~cjkim/&gt;.
</p>

<hr>
<h2 id='treasuries'>Treasuries</h2><span id='topic+treasuries'></span>

<h3>Description</h3>

<p>Treasuries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(treasuries)
</code></pre>


<h3>Format</h3>

<p>data.table with columns DATE, VARIABLE, VALUE, and MATURITY 
The data is quarterly frequency with variables DGS1MO, DGS3MO, DGS6MO, DGS1, 
DGS2, DGS3, DGS5, DGS7, DGS10, DGS20, and DGS30
</p>


<h3>Source</h3>

<p>FRED
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
