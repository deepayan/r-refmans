<!DOCTYPE html><html><head><title>Help for package mnormt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mnormt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mnormt-package'><p>The 'mnormt' package: summary information</p></a></li>
<li><a href='#mnorm'><p>The multivariate normal distribution</p></a></li>
<li><a href='#mom.mtruncnorm'><p>Moments and other quantities of a (possibly) truncated multivariate</p>
normal distribution</a></li>
<li><a href='#mom2cum'>
<p>Conversion of an array of moments to cumulants</p></a></li>
<li><a href='#mt'><p>The multivariate Student's <em>t</em> distribution</p></a></li>
<li><a href='#mtruncnorm'><p>The multivariate truncated normal distribution</p></a></li>
<li><a href='#mtrunct'><p>The multivariate truncated Student's <em>t</em> distribution</p></a></li>
<li><a href='#pd.solve'><p>Inverse of a symmetric positive-definite matrix</p></a></li>
<li><a href='#plot_fxy'><p>Plotting a function of two variables</p></a></li>
<li><a href='#recintab'>
<p>Moments of arbitrary order of a (possibly) truncated multivariate normal variable</p></a></li>
<li><a href='#sample_Mardia_measures'>
<p>The Mardia measures of multivariate skewness and kurtosis for a given sample</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-26</td>
</tr>
<tr>
<td>Title:</td>
<td>The Multivariate Normal and t Distributions, and Their Truncated
Versions</td>
</tr>
<tr>
<td>Author:</td>
<td>Adelchi Azzalini [aut, cre],
   Alan Genz [aut] (most Fortran code),
   Alan Miller [ctb] (Fortran routine PHI),
   Michael J. Wichura  [ctb] (Fortran routine PHINV),
   G. W. Hill [ctb] (Fortran routine STDINV),
   Yihong Ge [ctb] (Fortran routines BNVU and MVBVU).</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adelchi Azzalini &lt;adelchi.azzalini@unipd.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.2.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions are provided for computing the density and the
  distribution function of d-dimensional normal and "t" random variables,
  possibly truncated (on one side or two sides),  and for generating random 
  vectors sampled from these distributions, except sampling from the truncated
  "t". Moments of arbitrary order of a multivariate truncated normal are
  computed, and converted to cumulants up to order 4. 
  Probabilities are computed via non-Monte Carlo methods; different routines 
  are used in the case d=1, d=2, d=3, d&gt;3, if d denotes the dimensionality.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://azzalini.stat.unipd.it/SW/Pkg-mnormt/">http://azzalini.stat.unipd.it/SW/Pkg-mnormt/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-26 08:42:55 UTC; aa</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-26 10:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='mnormt-package'>The 'mnormt' package: summary information</h2><span id='topic+mnormt-package'></span>

<h3>Description</h3>

<p>Functions are provided for computing the density and the  distribution 
function of d-dimensional normal and <em>t</em> random variables,
possibly truncated (on one side or two sides, with componentwise choice),
and for generating random vectors sampled from these distributions,
except sampling from the truncated <em>t</em>. Moments of arbitrary order of 
a truncated normal are computed, and converted to cumulants up to order 4. </p>


<h3>Details</h3>

 
<p>Probabilities are computed via non-Monte Carlo methods; different routines 
are used in the case <code>d=1, d=2, d=3, d&gt;2</code>, if <code>d</code> denotes the
dimensionality. </p>


<h3>Licence</h3>

<p>This package and its documentation are usable under the terms of the 
&ldquo;GNU General Public License&rdquo; version 3 or version 2, as you prefer; 
a copy of them is available from 
<a href="https://www.R-project.org/Licenses/">https://www.R-project.org/Licenses/</a>.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini (R code and package creation) and Alan Genz (Fortran code, 
see the references below; this code incorporates routines of other authors).
</p>


<h3>References</h3>

<p>Genz, A. (1992).
Numerical Computation of Multivariate Normal Probabilities.
<em>J. Computational and Graphical Statist.</em> <b>1</b>, 141-149.
</p>
<p>Genz, A. (1993).  Comparison of methods for the computation of
multivariate normal probabilities. 
<em>Computing Science and Statistics</em>, <b>25</b>, 400-405.
</p>
<p>Genz, A.:  Fortran code downloaded in 2006 from the author web page, 
located at <a href="https://www.math.wsu.edu/faculty/genz/software/software.html">https://www.math.wsu.edu/faculty/genz/software/software.html</a>,
as of 2020-06-01.
</p>

<hr>
<h2 id='mnorm'>The multivariate normal distribution</h2><span id='topic+dmnorm'></span><span id='topic+pmnorm'></span><span id='topic+rmnorm'></span><span id='topic+sadmvn'></span>

<h3>Description</h3>

<p>The probability density function, the distribution function and random
number generation for a <code>d</code>-dimensional multivariate normal (Gaussian) 
random variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmnorm(x, mean = rep(0, d), varcov, log = FALSE) 
pmnorm(x, mean = rep(0, d), varcov, ...) 
rmnorm(n = 1, mean = rep(0, d), varcov, sqrt=NULL) 
sadmvn(lower, upper, mean, varcov, maxpts = 2000*d, abseps = 1e-06, releps = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mnorm_+3A_x">x</code></td>
<td>
<p>either a vector of length <code>d</code> or a matrix with <code>d</code>
columns representing  the coordinates of the
point(s) where the density must be evaluated; 
see also &lsquo;Details&rsquo; for restrictions on <code>d</code>.</p>
</td></tr>
<tr><td><code id="mnorm_+3A_mean">mean</code></td>
<td>
<p>either a vector of length <code>d</code>, representing the mean value,
or (except for <code>rmnorm</code>) a matrix whose rows represent different 
mean vectors; in the matrix case, only allowed for <code>dmnorm</code> and 
<code>pmnorm</code>, its dimensions must match those of <code>x</code>.</p>
</td></tr>
<tr><td><code id="mnorm_+3A_varcov">varcov</code></td>
<td>
<p>a symmetric positive-definite matrix representing the 
variance-covariance  matrix of the distribution; 
a vector of length 1 is also allowed (in this case, <code>d=1</code> is set).</p>
</td></tr> 
<tr><td><code id="mnorm_+3A_sqrt">sqrt</code></td>
<td>
<p>if not <code>NULL</code> (default value is <code>NULL</code>), 
a square root of the  intended <code>varcov</code> matrix; 
see &lsquo;Details&rsquo; for a full description.</p>
</td></tr>
<tr><td><code id="mnorm_+3A_log">log</code></td>
<td>
<p>a logical value (default value is <code>FALSE</code>);
if <code>TRUE</code>, the logarithm of the density is computed.</p>
</td></tr>
<tr><td><code id="mnorm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sadmvn</code>, 
among <code>maxpts</code>, <code>abseps</code>, <code>releps</code>.</p>
</td></tr>
<tr><td><code id="mnorm_+3A_n">n</code></td>
<td>
<p>the number of (pseudo) random  vectors to be generated.</p>
</td></tr>
<tr><td><code id="mnorm_+3A_lower">lower</code></td>
<td>
<p>a numeric vector of lower integration limits of 
the density function; must be of maximal length <code>20</code>; 
<code>+Inf</code> and <code>-Inf</code> entries are allowed.</p>
</td></tr>
<tr><td><code id="mnorm_+3A_upper">upper</code></td>
<td>
<p> a numeric vector of upper integration limits 
of the density function; must be of maximal length <code>20</code>; 
<code>+Inf</code> and <code>-Inf</code> entries are allowed.</p>
</td></tr>
<tr><td><code id="mnorm_+3A_maxpts">maxpts</code></td>
<td>
<p>the maximum number of function evaluations 
(default value: <code>2000*d</code>).</p>
</td></tr>
<tr><td><code id="mnorm_+3A_abseps">abseps</code></td>
<td>
<p>absolute error tolerance (default value: <code>1e-6</code>).</p>
</td></tr>
<tr><td><code id="mnorm_+3A_releps">releps</code></td>
<td>
<p>relative error tolerance (default value: <code>0</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dimension <code>d</code> cannot exceed <code>20</code> for <code>pmnorm</code> and 
<code>sadmvn</code>. If this threshold is exceeded, <code>NA</code> is returned.
</p>
<p>The function <code>pmnorm</code> works by making a suitable call to
<code>sadmvn</code> if <code>d&gt;3</code>,  or to <code>ptriv.nt</code> if <code>d=3</code>,
or to <code>biv.nt.prob</code> if <code>d=2</code>,  or to <code>pnorm</code> if <code>d=1</code>.
The <span class="rlang"><b>R</b></span> functions <code>sadmvn</code>, <code>ptriv.nt</code> and <code>biv.nt.prob</code> are,
in essence, interfaces to underlying <abbr><span class="acronym">Fortran 77</span></abbr> routines by Alan 
Genz; see the references below.  
These routines use adaptive numerical quadrature and other non-random 
type techniques.
</p>
<p>If <code>sqrt=NULL</code> (default value), the working of <code>rmnorm</code> involves 
computation of a square root of <code>varcov</code> via the Cholesky decomposition.
If a non-<code>NULL</code> value of <code>sqrt</code> is supplied, it  is  assumed 
that it represents a matrix, <code class="reqn">R</code> say, such that <code class="reqn">R' R</code>
represents the required variance-covariance matrix of the distribution;
in this case, the argument <code>varcov</code> is ignored.  
This mechanism is intended primarily for use in a sequence of calls to
<code>rmnorm</code>, all sampling from a distribution with fixed variance matrix;
a suitable matrix <code>sqrt</code> can then be computed only once beforehand, 
avoiding that the same operation is repeated multiple times along the 
sequence of calls; see the examples below.
Another use of <code>sqrt</code> is to supply a different form of square root 
of the variance-covariance matrix, in place of the Cholesky factor.
</p>
<p>For efficiency reasons, <code>rmnorm</code> does not perform checks on the supplied  
arguments.
</p>
<p>If, after setting the same seed value to <code><a href="base.html#topic+Random">set.seed</a></code>,
two calls to <code>rmnorm</code> are made with the same arguments except that one
generates <code>n1</code> vectors and the other <code>n2</code> vectors, with
<code>n1&lt;n2</code>, then the <code>n1</code> vectors of the first call coincide with the
initial <code>n2</code> vectors of the second call.  
</p>


<h3>Value</h3>

<p><code>dmnorm</code> returns a vector of density values (possibly log-transformed);
<code>pmnorm</code> returns a vector of probabilities, possibly with attributes
on the accuracy in case <code>x</code>  is a vector;
<code>sadmvn</code> return a single probability with 
attributes giving details on the achieved accuracy;
<code>rmnorm</code> returns a matrix of <code>n</code> rows of random vectors,
or a vector in case <code>n=1</code> or <code>d=1</code>.
</p>


<h3>Note</h3>

 
<p>The attributes <code>error</code> and <code>status</code> of the probability
returned by <code>pmnorm</code> and <code>sadmvn</code> indicate whether the function 
had a normal termination, achieving the required accuracy. 
If this is not the case, re-run the function with a higher value of
<code>maxpts</code>
</p>


<h3>Author(s)</h3>

<p><abbr><span class="acronym">FORTRAN 77</span></abbr> code of <code>SADMVN</code>, package <code>mvtdstpack.f</code>, 
package <code>tvpack</code>  and most auxiliary functions by Alan Genz; 
some additional auxiliary functions by people referred to within his programs;  
interface to <span class="rlang"><b>R</b></span> and additional <span class="rlang"><b>R</b></span> code (for <code>dmnormt</code>, 
<code>rmnormt</code>, etc.)  by Adelchi Azzalini.</p>


<h3>References</h3>

<p>Genz, A. (1992).
Numerical Computation of multivariate normal probabilities.
<em>J. Computational and Graphical Statist.</em>, <b>1</b>, 141-149.
</p>
<p>Genz, A. (1993).  Comparison of methods for the computation of
multivariate normal probabilities. 
<em>Computing Science and Statistics</em>, <b>25</b>, 400-405.
</p>
<p>Genz, A.:  Fortran 77 code downloaded in 2005 and again in 2007 
from his web-page,  whose <abbr><span class="acronym">URL</span></abbr> as of 2020-04-28 was
<a href="https://www.math.wsu.edu/faculty/genz/software/software.html">https://www.math.wsu.edu/faculty/genz/software/software.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">dnorm</a></code>, <code><a href="#topic+dmt">dmt</a></code>, 
<code><a href="#topic+biv.nt.prob">biv.nt.prob</a></code>, <code><a href="#topic+ptriv.nt">ptriv.nt</a></code>,
<code><a href="#topic+plot_fxy">plot_fxy</a></code> for plotting examples</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-2, 4, length=21)
y &lt;- cos(2*x) + 10
z &lt;- x + sin(3*y) 
mu &lt;- c(1,12,2)
Sigma &lt;- matrix(c(1,2,0,2,5,0.5,0,0.5,3), 3, 3)
f &lt;- dmnorm(cbind(x,y,z), mu, Sigma)
f0 &lt;- dmnorm(mu, mu, Sigma)
p1 &lt;- pmnorm(c(2,11,3), mu, Sigma)
p2 &lt;- pmnorm(c(2,11,3), mu, Sigma, maxpts=10000, abseps=1e-10)
p &lt;- pmnorm(cbind(x,y,z), mu, Sigma)
#
set.seed(123)
x1 &lt;- rmnorm(5, mu, Sigma)
set.seed(123)
x2 &lt;- rmnorm(5, mu, sqrt=chol(Sigma)) # x1=x2
eig &lt;- eigen(Sigma, symmetric = TRUE)
R &lt;- t(eig$vectors %*% diag(sqrt(eig$values)))
for(i in 1:50) x &lt;- rmnorm(5, mu, sqrt=R)
#
p &lt;- sadmvn(lower=c(2,11,3), upper=rep(Inf,3), mu, Sigma) # upper tail
#
p0 &lt;- pmnorm(c(2,11), mu[1:2], Sigma[1:2,1:2])
p1 &lt;- biv.nt.prob(0, lower=rep(-Inf,2), upper=c(2, 11), mu[1:2], Sigma[1:2,1:2])
p2 &lt;- sadmvn(lower=rep(-Inf,2), upper=c(2, 11), mu[1:2], Sigma[1:2,1:2]) 
c(p0, p1, p2, p0-p1, p0-p2)
#
p1 &lt;- pnorm(0, 1, 3)
p2 &lt;- pmnorm(0, 1, 3^2)
</code></pre>

<hr>
<h2 id='mom.mtruncnorm'>Moments and other quantities of a (possibly) truncated multivariate 
normal distribution
</h2><span id='topic+mom.mtruncnorm'></span>

<h3>Description</h3>

<p>Moments up to the specified orders of a possibly truncated <code>d</code>-dimensional
normal distribution; the distribution must be non-degenerate. 
Each component variable can be truncated on one side (to the left or 
to the right) or on two sides or not truncated.
After the initial stage, cumulants up to the fourth order and other
quantities are computed, provided all moments of the required order 
had been computed in the first stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mom.mtruncnorm(powers=4, mean, varcov, lower, upper, cum = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mom.mtruncnorm_+3A_powers">powers</code></td>
<td>
<p>a vector of non-negative integer values representing the 
required order of moments for each component variable, or a single
such value, in which case this value is repeated for all component 
variables.</p>
</td></tr>
<tr><td><code id="mom.mtruncnorm_+3A_mean">mean</code></td>
<td>
<p>a <code>d</code>-length vector representing the mean value of 
the pre-truncation normal random variable.  If <code>d=length(mean)</code>, 
see &lsquo;Details&rsquo; for restrictions on <code>d</code>.</p>
</td></tr>
<tr><td><code id="mom.mtruncnorm_+3A_varcov">varcov</code></td>
<td>
<p>a symmetric positive definite matrix with dimensions <code>(d,d)</code>
representing the variance  matrix of the pre-truncation normal random variable.</p>
</td></tr>
<tr><td><code id="mom.mtruncnorm_+3A_lower">lower</code></td>
<td>
<p>a <code>d</code>-vector representing the lower truncation values    
of the component variables; <code>-Inf</code> values are allowed. 
If missing, it is set equal to <code>rep(-Inf, d)</code>.</p>
</td></tr>
<tr><td><code id="mom.mtruncnorm_+3A_upper">upper</code></td>
<td>
<p>a <code>d</code>-vector representing the upper truncation values  
of the component variables; <code>Inf</code> values are allowed.
If missing, it is set equal to <code>rep(Inf, d)</code>.</p>
</td></tr>
<tr><td><code id="mom.mtruncnorm_+3A_cum">cum</code></td>
<td>
<p>a logical value; if  codeTRUE  (default value), cumulants 
are other quantities are computed up to the minimum between the fourth
order and the maximum possible order, given the available moments.</p>
</td></tr>
<tr><td><code id="mom.mtruncnorm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>sadmvn</code>; 
see &lsquo;Details&rsquo; for a description.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximal value of d is <code>20</code>. If this threshold is exceeded, <code>NA</code>s
are returned. The constraint originates from the underlying function 
<code><a href="#topic+sadmvn">sadmvn</a></code>.
</p>
<p>This function makes use of two workhorses, <code>recintab</code> and <code>mom2cum</code>, 
providing a user-friendly interface to these more basic tools. 
The first function computes an array of raw moments of the truncated normal; 
the second function translates them into cumulants and other quantities
such as the Mardia's measures of skewness and kurtosis, unless <code>cum=FALSE</code>.
See the documentation of these two underlying functions for additional 
information about the arguments and the returned quantities. 
The argument <code>...</code> is passed, via <code>recintab</code>, to <code>sadmvn</code> 
for regulation of its working.
</p>
<p>Not all <code>d</code> component variables need to be truncated. 
In fact, the function works also with no truncated components 
(just omit <code>lower</code> and <code>upper</code>),
although for this case there exist known formulae to do the job.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>mom</code></td>
<td>
<p>an array with raw moments as produced by <code>recintab</code>,
followed by normalization; see its documentation for a description.</p>
</td></tr>
<tr><td><code>cum1</code></td>
<td>
<p>the vector of first-order cumulants, 
<abbr><span class="acronym">AKA</span></abbr> the expected value or  the mean value, 
which will be there  provided <code>cum=TRUE</code> and all 
elements of <code>powers</code> are not less than 1.</p>
</td></tr>
<tr><td><code>order2</code>, <code>...</code></td>
<td>
<p>additional lists with higher order terms up to order 4;
these lists only exist when the available moments are of sufficiently 
high order. See <code><a href="#topic+mom2cum">mom2cum</a></code> for a more detailed description.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

<p><code><a href="#topic+recintab">recintab</a></code>,  <code><a href="#topic+mom2cum">mom2cum</a></code>,  <code><a href="#topic+sadmvn">sadmvn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(1, -0.5, 0)
Sigma &lt;- toeplitz(1/(1:3))
lower &lt;- c(-Inf, -3, -4)
upper &lt;- c(1.5, Inf, 2)
m &lt;- mom.mtruncnorm(1, mu, Sigma, lower, upper)
print(m$cum1)
# 
m &lt;- mom.mtruncnorm(3, mu, Sigma, lower, upper)
print(m$order3$gamma1.marginal)
print(m$order3$gamma1.Mardia)
#
#--
# Example 2 of Leppard &amp; Tallis (1989, Appl.Stat. vol.38, p.547)
truncp &lt;- c(0, 1, 2)
U &lt;- c(0, 0, 0)
V &lt;- 0.5*(diag(3) + matrix(1, 3, 3))
m &lt;- mom.mtruncnorm(2, U, V, truncp)
print(m$cum1, digits=9)
print(m$order2$cum2, digits=9)
</code></pre>

<hr>
<h2 id='mom2cum'>
Conversion of an array of moments to cumulants  
</h2><span id='topic+mom2cum'></span>

<h3>Description</h3>

<p>Given an array of moments of a multivariate distribution, the corresponding
cumulants up to the 4th order and other connected quantities are computed,
notably the Mardia's measures of multivariate skewness and kurtosis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mom2cum(mom)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mom2cum_+3A_mom">mom</code></td>
<td>
<p>an array whose entries are assumed to represent moments of a
multivariate distribution; see &lsquo;Details&rsquo; for an extended
description.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The structure of the input array <code>mom</code> is of type <code>M/M[1]</code>
where <code>M</code> represents the output from function <code><a href="#topic+recintab">recintab</a></code>. 
For a <code>d</code>-dimensional random variable, <code>mom</code> is a <code>k</code>-fold 
<code>d</code>-dimensional array, where <code>k</code> is the highest order of moments 
being considered;
see the documentation of <code>recintab</code> for a more detailed description. 
However, it is not necessary that <code>mom</code> originates from <code>recintab</code>;
the moments can refer to any distribution, as long as <code>mom</code> has the 
appropriate structure and content.
</p>
<p>Also, it is not necessary that all entries of <code>mom</code> are there;
values not required for the processing can be left as <code>NA</code>.
For computing cumulants of order <code>k</code>, say, we only need  cross moments 
whose exponents add up to <code>k</code> or less.
</p>
<p>Conversion from moments to cumulants is performed by using formulae (2.7)
of McCullagh (1987). See also <code class="reqn">\rho_{23}^2</code> in his (2.15) and 
<code class="reqn">\rho_4</code> in (2.16) for computing the Mardia's (1970, 1974) measures of 
multivariate skewness and kurtosis.
</p>
<p>In some cases,
the function may report inconsistencies detected in the argument <code>mom</code>.
A typical origin of this situation is in numerical inaccuracies of the 
returned value of <code><a href="#topic+recintab">recintab</a></code>,
as explained in more detail in its documentation.
When detected, cases of these sort are flagged in the returned <code>$message</code> 
string, and a warning message is issued.
The absence of such string does not represent a guarantee of perfect input.
</p>


<h3>Value</h3>

<p>In the multivariate case, 
a list with the following elements, provided moments of the required order are
available, up to the maximal order 4. 
</p>
<table>
<tr><td><code>cum1</code></td>
<td>
<p>the <code>d</code>-vector of first-order cumulants, 
<abbr><span class="acronym">AKA</span></abbr> the expected value or the mean value; 
this will be there if <code>mom</code> contains all moments of order 1.</p>
</td></tr>
<tr><td><code>order2</code></td>
<td>
<p>a list with the following components: 
<code>m2</code>, the <code>(d,d)</code> matrix of second order moments; 
<code>cum2</code>, the <code>(d,d)</code> matrix of second order cumulants, 
<abbr><span class="acronym">AKA</span></abbr> the variance-covariance matrix, the variance matrix, 
the covariance matrix, the dispersion matrix; 
<code>conc.matrix</code>, the concentration matrix, that is, the inverse of <code>cum2</code>;
<code>log.det.cum2</code>, the logarithm of the determinant of <code>cum2</code>.
</p>
</td></tr> 
<tr><td><code>order3</code></td>
<td>
<p>a list with the following components: 
<code>m3</code>, array of third order moments, having dimension <code>(d,d,d)</code>; 
<code>cum3</code>, array of third order cumulants, having dimension <code>(d,d,d)</code>;
<code>m3.marginal</code>, vector of third order marginal moments;
<code>centr.mom3.marginal</code>, vector of third order marginal central moments; 
<code>gamma1.marginal</code>, vector of third order marginal standardized cumulants;
<code>gamma1.Mardia</code>, the Mardia measure of multivariate skewness;
<code>beta1.Mardia</code>, the Mardia measure of multivariate skewness, again.
</p>
</td></tr> 
<tr><td><code>order4</code></td>
<td>
<p>a list with the following components:
<code>m4</code>, array of fourth order moments, with dimension <code>(d,d,d,d)</code>; 
<code>cum4</code>, array of fourth order cumulants, with dimension <code>(d,d,d,d)</code>;
<code>m4.marginal</code>, vector of fourth order marginal moments;
<code>centr.mom4.marginal</code>, vector of fourth order marginal central moments; 
<code>gamma2.marginal</code>, vector of fourth order marginal standardized cumulants;
<code>gamma2.Mardia</code>, the Mardia measure of multivariate kurtosis, <code class="reqn">\gamma_{2,d}</code>;
<code>beta2.Mardia</code>, the Mardia measure of multivariate kurtosis, <code class="reqn">\beta_{2,d}</code>. 
</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>possibly, a character string indicating that some inconsistency
has been detected in the argument <code>mom</code>; see &lsquo;Details&rsquo;.</p>
</td></tr>
</table>
<p>In the univariate case a list with elements:
</p>
<table>
<tr><td><code>cum</code></td>
<td>
<p>a vector of cumulants,</p>
</td></tr>
<tr><td><code>centr.mom</code></td>
<td>
<p>a vector of central moments,</p>
</td></tr>
<tr><td><code>std.cum</code></td>
<td>
<p>a vector with the third and the fourth standardized cumulants
(when enough moments are available), representing 
common measures of skewness and kurtosis.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>possibly, a character string indicating that some inconsistency
has been detected in the argument <code>mom</code>; see &lsquo;Details&rsquo;.</p>
</td></tr>   
</table>


<h3>Note</h3>

<p>In the case of a multivariate truncated normal distribution, 
a user does not need to call this function; <code><a href="#topic+mom.mtruncnorm">mom.mtruncnorm</a></code> 
provides a more convenient interface for the same computations.
The present function needs to be called only if the array <code>mom</code> 
represents the moments of some other distribution.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Mardia, K. V. (1970). 
Measures of multivariate skewness and kurtosis with applications
<em>Biometrika</em>, 57, 519-530.
</p>
<p>Mardia, K. V. (1974).
Applications of some measures of multivariate skewness and kurtosis 
in testing normality and robustness studies.
<em>Sankhya ser.B</em>, 36, 115-128.
</p>
<p>McCullagh, Peter (1987).
<em>Tensor Methods in Statistics</em>.
Chapman &amp; Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recintab">recintab</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(1, -0.5)
Sigma &lt;- toeplitz(1/(1:2))
low &lt;- c(-Inf, -3)
hi &lt;- c(1.5, Inf)
mom &lt;- recintab(c(3,3), low, hi, mu, Sigma)
cum &lt;- mom2cum(mom)
print(cum$order3$gamma1.marginal)
print(cum$order3$gamma1.Mardia)
</code></pre>

<hr>
<h2 id='mt'>The multivariate Student's <em>t</em> distribution</h2><span id='topic+dmt'></span><span id='topic+pmt'></span><span id='topic+rmt'></span><span id='topic+sadmvt'></span><span id='topic+biv.nt.prob'></span><span id='topic+ptriv.nt'></span>

<h3>Description</h3>

<p>The probability density function, the distribution function and random number 
generation for a <code>d</code>-dimensional Student's <em>t</em> random variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmt(x, mean = rep(0, d), S, df=Inf, log = FALSE) 
pmt(x, mean = rep(0, d), S, df=Inf, ...) 
rmt(n = 1, mean = rep(0, d), S, df=Inf, sqrt=NULL) 
sadmvt(df, lower, upper, mean, S, maxpts = 2000*d, abseps = 1e-06, releps = 0) 
biv.nt.prob(df, lower, upper, mean, S)
ptriv.nt(df, x, mean, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_+3A_x">x</code></td>
<td>
<p> either a vector of length <code>d</code> or (for <code>dmt</code> and <code>pmt</code>) 
a matrix with <code>d</code> columns representing the coordinates of the 
point(s) where the density must be evaluated; see also &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="mt_+3A_mean">mean</code></td>
<td>
<p>either a vector of length <code>d</code>, representing the location
parameter (equal to the mean vector when <code>df&gt;1</code>),  
or (for <code>dmt</code> and <code>pmt</code>) a matrix 
whose rows represent different mean vectors; 
in the matrix case, its dimensions must match those of <code>x</code>.</p>
</td></tr>
<tr><td><code id="mt_+3A_s">S</code></td>
<td>
<p>a symmetric positive definite matrix with dimensions <code>(d,d)</code> 
representing the  scale matrix of the distribution, 
such that <code>S*df/(df-2)</code> is  the variance-covariance matrix 
when <code>df&gt;2</code>;  a vector of
length <code>1</code> is also allowed (in this case, <code>d=1</code> is set).</p>
</td></tr>
<tr><td><code id="mt_+3A_df">df</code></td>
<td>
<p>the degrees of freedom.  
For <code>rmt</code>, it must be a positive real value or <code>Inf</code>. 
For all other functions, it must be a positive integer or <code>Inf</code>.
A value <code>df=Inf</code> is translated to a call to a suitable function
for the the multivariate normal distribution. 
See &lsquo;Details&rsquo; for its effect for the evaluation of distribution  
functions and other probabilities.</p>
</td></tr> 
<tr><td><code id="mt_+3A_log">log</code></td>
<td>
<p>a logical value(default value is <code>FALSE</code>); if <code>TRUE</code>, 
the logarithm of the density is computed.</p>
</td></tr>    
<tr><td><code id="mt_+3A_sqrt">sqrt</code></td>
<td>
<p>if not <code>NULL</code> (default value is <code>NULL</code>), 
a square root of the intended scale matrix <code>S</code>; 
see &lsquo;Details&rsquo; for a full description.</p>
</td></tr>   
<tr><td><code id="mt_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sadmvt</code>, 
among <code>maxpts</code>, <code>absrel</code>, <code>releps</code>.</p>
</td></tr>
<tr><td><code id="mt_+3A_n">n</code></td>
<td>
<p>the number of random  vectors to be generated</p>
</td></tr>
<tr><td><code id="mt_+3A_lower">lower</code></td>
<td>
<p>a numeric vector of lower integration limits of 
the density function; must be of maximal length <code>20</code>; 
<code>+Inf</code> and <code>-Inf</code> entries are allowed.</p>
</td></tr>
<tr><td><code id="mt_+3A_upper">upper</code></td>
<td>
<p> a numeric vector of upper integration limits 
of the density function; must be of maximal length <code>20</code>; 
<code>+Inf</code> and <code>-Inf</code> entries are allowed </p>
</td></tr>
<tr><td><code id="mt_+3A_maxpts">maxpts</code></td>
<td>
<p>the maximum number of function evaluations 
(default value: <code>2000*d</code>)</p>
</td></tr>
<tr><td><code id="mt_+3A_abseps">abseps</code></td>
<td>
<p>absolute error tolerance (default value: <code>1e-6</code>).</p>
</td></tr>
<tr><td><code id="mt_+3A_releps">releps</code></td>
<td>
<p>relative error tolerance (default value: <code>0</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dimension <code>d</code> cannot exceed <code>20</code> for <code>pmt</code> and 
<code>sadmvt</code>. If this threshold is exceeded, <code>NA</code> is returned.
</p>
<p>The functions <code>sadmvt</code>, <code>ptriv.mt</code> and <code>biv.nt.prob</code> are
interfaces to Fortran 77 routines by Alan Genz, available from his web page; 
they makes use of some auxiliary functions whose authors are indicated
in the Fortran code itself. 
The routine <code>sadmvt</code> uses an adaptive  integration method. 
If <code>df=3</code>, a call to <code>pmt</code> activates a call to <code>ptriv.nt</code> 
which  is specific for the  trivariate case, and uses Genz's  Fortran
code <code>tvpack.f</code>;  see Genz (2004) for the  background methodology.
A similar fact takes place when <code>df=2</code> with function <code>biv.nt.prob</code>;
note however that the underlying Fortran code is taken from 
<code>mvtdstpack.f</code>, not from <code>tvpack.f</code>.
If <code>pmt</code> is called  with <code>d&gt;3</code>, this is converted into
a suitable call to <code>sadmvt</code>.
</p>
<p>If <code>sqrt=NULL</code> (default value), the working of <code>rmt</code> involves 
computation of a square root of <code>S</code> via the Cholesky decomposition.
If a non-<code>NULL</code> value of <code>sqrt</code> is supplied, it is assumed that
it represents a square root of the scale matrix,  
otherwise represented by <code>S</code>, whose value is ignored in this case.  
This mechanism is intended primarily for use in a sequence of calls to
<code>rmt</code>, all sampling from a distribution with fixed scale matrix;
a suitable matrix <code>sqrt</code> can then be computed only once beforehand, 
avoiding that the same operation is repeated multiple times along the 
sequence of calls. For examples of use of this argument, see those in the 
documentation of <code><a href="#topic+rmnorm">rmnorm</a></code>.  
Another use of <code>sqrt</code> is to supply a different form of square root 
of the scale matrix, in place of the Cholesky factor.
</p>
<p>For efficiency reasons, <code>rmt</code> does not perform checks on the supplied  
arguments.  
</p>


<h3>Value</h3>

<p><code>dmt</code> returns a vector of density values (possibly log-transformed);
<code>pmt</code> and <code>sadmvt</code> return a single probability with 
attributes giving details on the achieved accuracy,  provided <code>x</code> 
of <code>pmnorm</code> is a vector;
<code>rmt</code> returns a matrix of <code>n</code> rows of random vectors,
or a vector in case <code>n=1</code> or <code>d=1</code>.
</p>


<h3>Note</h3>

 
<p>The attributes <code>error</code> and <code>status</code> of the probability returned 
by <code>sadmvt</code> and by <code>pmt</code> (the latter only if <code>x</code> is a vector 
and <code>d&gt;2</code>) indicate whether the function 
had a normal termination, achieving the required accuracy. 
If this is not the case, re-run the function with a higher value of
<code>maxpts</code>.
</p>


<h3>Author(s)</h3>

<p><abbr><span class="acronym">FORTRAN 77</span></abbr> code of <code>SADMVT</code>, <code>MVTDSTPACK</code>, <code>TVPACK</code>
and many  auxiliary functions by Alan Genz;
some additional auxiliary functions by people referred to within his 
programs; interface to <span class="rlang"><b>R</b></span> and additional <span class="rlang"><b>R</b></span> code (for <code>dmt</code>, <code>rmt</code>
etc.) by Adelchi Azzalini.</p>


<h3>References</h3>

<p>Genz, A.:  Fortran 77 code in files <code>mvt.f</code>, <code>mvtdstpack.f</code>  
and codetvpack, downloaded in 2005 and again in 2007 from his webpage, 
whose URL as of 2020-06-01 is 
<a href="https://www.math.wsu.edu/faculty/genz/software/software.html">https://www.math.wsu.edu/faculty/genz/software/software.html</a>
</p>
<p>Genz, A. (2004). 
Numerical computation of rectangular bivariate and trivariate normal
and <em>t</em> probabilities.
<em>Statistics and Computing</em> 14, 251-260.
</p>
<p>Dunnett, C.W. and Sobel, M. (1954).
A bivariate generalization of Student's <em>t</em>-distribution with tables  
for certain special cases. <em>Biometrika</em> 41, 153&ndash;169.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+TDist">dt</a></code>, 
<code><a href="#topic+rmnorm">rmnorm</a></code> for use of argument <code>sqrt</code>,
<code><a href="#topic+plot_fxy">plot_fxy</a></code> for plotting examples</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-2,4,length=21)
y &lt;- 2*x+10
z &lt;- x+cos(y) 
mu &lt;- c(1,12,2)
Sigma &lt;- matrix(c(1,2,0,2,5,0.5,0,0.5,3), 3, 3)
df &lt;- 4
f  &lt;- dmt(cbind(x,y,z), mu, Sigma,df)
p1 &lt;- pmt(c(2,11,3), mu, Sigma, df)
p2 &lt;- pmt(c(2,11,3), mu, Sigma, df, maxpts=10000, abseps=1e-8)
x  &lt;- rmt(10, mu, Sigma, df)
p  &lt;- sadmvt(df, lower=c(2,11,3), upper=rep(Inf,3), mu, Sigma) # upper tail
#
p0 &lt;- pmt(c(2,11), mu[1:2], Sigma[1:2,1:2], df=5)
p1 &lt;- biv.nt.prob(5, lower=rep(-Inf,2), upper=c(2, 11), mu[1:2], Sigma[1:2,1:2])
p2 &lt;- sadmvt(5, lower=rep(-Inf,2), upper=c(2, 11), mu[1:2], Sigma[1:2,1:2]) 
c(p0, p1, p2, p0-p1, p0-p2)
</code></pre>

<hr>
<h2 id='mtruncnorm'>The multivariate truncated normal distribution</h2><span id='topic+dmtruncnorm'></span><span id='topic+pmtruncnorm'></span><span id='topic+rmtruncnorm'></span>

<h3>Description</h3>

<p>The probability density function, the distribution function and random
number generation for the <code>d</code>-dimensional truncated normal (Gaussian)
random variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmtruncnorm(x, mean, varcov, lower, upper, log = FALSE, ...)
pmtruncnorm(x, mean, varcov, lower, upper, ...)
rmtruncnorm(n, mean, varcov, lower, upper, start, burnin=5, thinning=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtruncnorm_+3A_x">x</code></td>
<td>
<p>either a vector of length <code>d</code> or a matrix with <code>d</code>
columns,representing  the coordinates of the point(s) where the density 
must be evaluated.  
Here we denote <code>d=ncol(varcov)</code>; see &lsquo;Details&rsquo; for restrictions.</p>
</td></tr>
<tr><td><code id="mtruncnorm_+3A_mean">mean</code></td>
<td>
<p>a <code>d</code>-vector representing the mean value of the pre-truncation normal 
distribution.</p>
</td></tr>
<tr><td><code id="mtruncnorm_+3A_varcov">varcov</code></td>
<td>
<p>a symmetric positive definite matrix with dimensions <code>(d,d)</code> 
representing the variance matrix of the pre-truncation normal distribution.</p>
</td></tr>
<tr><td><code id="mtruncnorm_+3A_lower">lower</code></td>
<td>
<p>a <code>d</code>-vector representing the lower truncation values of the   
component variables; <code>-Inf</code> values are allowed. 
If missing, it is set equal to <code>rep(-Inf, d)</code>.</p>
</td></tr>
<tr><td><code id="mtruncnorm_+3A_upper">upper</code></td>
<td>
<p>a <code>d</code>-vector representing the upper truncation values of the 
component variables; <code>Inf</code> values are allowed.
If missing, it is set equal to <code>rep(Inf, d)</code>.</p>
</td></tr>
<tr><td><code id="mtruncnorm_+3A_log">log</code></td>
<td>
<p>a logical value (default value is <code>FALSE</code>);
if <code>TRUE</code>, the logarithm of the density is computed.</p>
</td></tr>
<tr><td><code id="mtruncnorm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sadmvn</code>, 
among <code>maxpts</code>, <code>abseps</code>, <code>releps</code>.</p>
</td></tr>
<tr><td><code id="mtruncnorm_+3A_n">n</code></td>
<td>
<p>the number of (pseudo) random vectors to be generated.</p>
</td></tr>
<tr><td><code id="mtruncnorm_+3A_start">start</code></td>
<td>
<p>an optional vector of initial values; see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="mtruncnorm_+3A_burnin">burnin</code></td>
<td>
<p>the number of burnin iterations of the Gibbs sampler 
(default: <code>5</code>); see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="mtruncnorm_+3A_thinning">thinning</code></td>
<td>
<p>a positive integer representing the thinning factor of the 
internally generated Gibbs sequence (default: <code>1</code>); see &lsquo;Details&rsquo;.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>For <code>dmtruncnorm</code> and <code>pmtruncnorm</code>,  
the dimension <code>d</code> cannot exceed <code>20</code>.
If this threshold is exceeded, <code>NA</code>s are returned. 
The constraint originates from the underlying function  <code><a href="#topic+sadmvn">sadmvn</a></code>.
</p>
<p>If <code>d&gt;1</code>, <code>rmtruncnorm</code> uses a Gibbs sampling scheme as described by
Breslaw (1994) and by Kotecha &amp; Djurić (1999), 
Detailed algebraic expressions are provided by Wilhelm (2022).
After some initial settings in <span class="rlang"><b>R</b></span>, the core iteration is performed by 
a compiled <abbr><span class="acronym">FORTRAN 77</span></abbr> subroutine, for numerical efficiency. 
</p>
<p>If the <code>start</code> vector is not supplied, the mean value of the truncated
distribution is used. This choice should provide a good starting point for the
Gibbs iteration, which explains why the default value for the <code>burnin</code>
stage is so small. Since successive random vectors generated by a Gibbs
sampler are not independent, which can be a problem in certain applications.
This dependence is typically ameliorated by generating a larger-than-required
number of random vectors, followed by a  &lsquo;thinning&rsquo; stage; this can
be obtained by setting the <code>thinning</code> argument larger that <code>1</code>.
The overall number of generated points is <code>burnin+n*thinning</code>, and the 
returned object is formed by those with index in <code>burnin+(1:n)*thinning</code>.
</p>
<p>If <code>d=1</code>, the values are sampled using a non-iterative procedure, 
essentially as in equation (4) of Breslaw (1994), except that in this case 
the  mean and the variance do not refer to a conditional distribution, 
but are the arguments supplied in the calling statement. 
</p>


<h3>Value</h3>

<p><code>dmtruncnorm</code> and <code>pmtruncnorm</code> return a numeric vector;
<code>rmtruncnorm</code> returns a matrix, unless either <code>n=1</code> or <code>d=1</code>, 
in which case it returns a vector.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Breslaw, J.A. (1994)
Random sampling from a truncated multivariate normal distribution.
<em>Appl. Math. Lett.</em>  vol.7, pp.1-6.
</p>
<p>Kotecha, J.H. and  Djurić, P.M. (1999).
Gibbs sampling approach for generation of truncated multivariate 
Gaussian random variables.
In <em>ICASSP'99: Proceedings of IEEE International Conference on 
Acoustics, Speech, and Signal Processing</em>, 
vol.3, pp.1757-1760. <a href="https://doi.org/10.1109/ICASSP.1999.756335">doi:10.1109/ICASSP.1999.756335</a>. 
</p>
<p>Wilhelm, S. (2022).
Gibbs sampler for the truncated multivariate normal distribution.
Vignette of R package <a href="https://cran.r-project.org/package=tmvtnorm">https://cran.r-project.org/package=tmvtnorm</a>, 
version 1.5.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_fxy">plot_fxy</a></code> for additional plotting examples,
<code><a href="#topic+sadmvn">sadmvn</a></code> for regulating accuracy via <code>...</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># example with d=2
m2 &lt;- c(0.5, -1)
V2 &lt;- matrix(c(3, 3, 3, 6), 2, 2)
low &lt;- c(-1, -2.8)
up &lt;- c(1.5, 1.5)
# plotting truncated normal density using 'dmtruncnorm' and 'contour' functions 
plot_fxy(dmtruncnorm, xlim=c(-2, 2), ylim=c(-3, 2), mean=m2, varcov=V2, 
      lower=low, upper=up,  npt=101)   
set.seed(1)    
x &lt;-  rmtruncnorm(n=500, mean=m2, varcov=V2, lower=low, upper=up) 
points(x, cex=0.2, col="red")
#------
# example with d=1
set.seed(1) 
low &lt;- -4
hi &lt;- 3
x &lt;- rmtruncnorm(1e5, mean=2, varcov=5, lower=low, upper=hi)
hist(x, prob=TRUE, xlim=c(-8, 12), main="Truncated univariate N(2, sqrt(5))")
rug(c(low, hi), col=2)
x0 &lt;- seq(-8, 12, length=251)
pdf &lt;- dnorm(x0, 2, sqrt(5))
p &lt;- pnorm(c(low, hi), 2, sqrt(5))
lines(x0, pdf/diff(p), col=4, lty=2)
lines(x0, dmtruncnorm(x0, 2, 5, low, hi), col=2, lwd=2)
</code></pre>

<hr>
<h2 id='mtrunct'>The multivariate truncated Student's <em>t</em> distribution</h2><span id='topic+dmtrunct'></span><span id='topic+pmtrunct'></span>

<h3>Description</h3>

<p>The probability density function and the distribution function  of the
multivariate truncated  Student's <em>t</em>  distribution 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmtrunct(x, mean, S, df, lower, upper, log = FALSE, ...)
pmtrunct(x, mean, S, df, lower, upper, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtrunct_+3A_x">x</code></td>
<td>
<p> either a vector of length <code>d</code> 
or a matrix with <code>d</code> columns, where <code>d=ncol(S)</code>, giving
the coordinates of the point(s) where the density must be evaluated. </p>
</td></tr>
<tr><td><code id="mtrunct_+3A_mean">mean</code></td>
<td>
<p>either a vector of length <code>d</code>, representing the location
parameter (equal to the mean vector when <code>df&gt;1</code>) of the pre-truncation
distribution or a matrix whose rows represent different mean vectors; 
in the matrix case, its dimensions must match those of <code>x</code>.</p>
</td></tr>
<tr><td><code id="mtrunct_+3A_s">S</code></td>
<td>
<p>a symmetric positive-definite matrix representing the 
scale matrix, such that <code>S*df/(df-2)</code> is the variance-covariance
matrix of the pre-truncation distribution  when <code>df&gt;2</code>.</p>
</td></tr>
<tr><td><code id="mtrunct_+3A_df">df</code></td>
<td>
<p>degrees of freedom; it must be a positive integer</p>
</td></tr> 
<tr><td><code id="mtrunct_+3A_lower">lower</code></td>
<td>
<p>a vector representing the lower truncation values of the   
component variables; <code>-Inf</code> values are allowed. 
If missing, it is set equal to <code>rep(-Inf, d)</code>.</p>
</td></tr>
<tr><td><code id="mtrunct_+3A_upper">upper</code></td>
<td>
<p>a vector representing the upper truncation values of the 
component variables; <code>Inf</code> values are allowed.
If missing, it is set equal to <code>rep(Inf, d)</code>.</p>
</td></tr>
<tr><td><code id="mtrunct_+3A_log">log</code></td>
<td>
<p>a logical value (default value is <code>FALSE</code>);
if <code>TRUE</code>, the logarithm of the density is computed.</p>
</td></tr>
<tr><td><code id="mtrunct_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sadmvt</code>, 
among <code>maxpts</code>, <code>absrel</code>, <code>releps</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dimension <code>d</code> cannot exceed <code>20</code>.</p>


<h3>Value</h3>

<p>a numeric vector</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sadmvt">sadmvt</a></code> for regulating accuracy</p>


<h3>Examples</h3>

<pre><code class='language-R'>m2 &lt;- c(0.5, -1)
V2 &lt;- matrix(c(1.5, -1.75, -1.75, 3), 2, 2)
lower &lt;- a &lt;- c(-1, -2.5)
upper &lt;- b &lt;- c(2, 1)
set.seed(1) 
points &lt;- matrix(runif(10, -3, 3), nrow=5, ncol=2)
pdf &lt;- dmtrunct(points, mean=m2, S=V2, df=4, lower, upper) 
cdf &lt;- pmtrunct(points, mean=m2, S=V2, df=4, lower, upper) 
</code></pre>

<hr>
<h2 id='pd.solve'>Inverse of a symmetric positive-definite matrix</h2><span id='topic+pd.solve'></span>

<h3>Description</h3>

<p>The inverse of a symmetric positive-definite matrix and its log-determinant
</p>


<h3>Usage</h3>

<pre><code class='language-R'> pd.solve(x, silent = FALSE, log.det=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pd.solve_+3A_x">x</code></td>
<td>
<p>a symmetric positive-definite matrix.</p>
</td></tr>
<tr><td><code id="pd.solve_+3A_silent">silent</code></td>
<td>
<p>a logical value which indicates the action to take in case of 
an error. If <code>silent==TRUE</code> and an error occurs, the function
silently returns a <code>NULL</code> value; if <code>silent==FALSE</code> (default), 
an error generates a <code>stop</code> with an error message.</p>
</td></tr>
<tr><td><code id="pd.solve_+3A_log.det">log.det</code></td>
<td>
<p> a logical value to indicate whether the log-determinant
of <code>x</code> is required (default is <code>FALSE</code>).</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The function checks that <code>x</code> is a symmetric positive-definite 
matrix. If an error is detected, an action is taken which depends on the
value of the argument <code>silent</code>. 
</p>


<h3>Value</h3>

<p>the inverse matrix of <code>x</code>;  if <code>log.det=TRUE</code>, this inverse has an
attribute which contains the logarithm of the determinant of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- toeplitz(rev(1:4))
  x.inv &lt;- pd.solve(x)
  print(x.inv %*% x)
  x.inv &lt;- pd.solve(x, log.det=TRUE)
  logDet &lt;- attr(x.inv, "log.det")
  print(abs(logDet - determinant(x, logarithm=TRUE)$modulus))
</code></pre>

<hr>
<h2 id='plot_fxy'>Plotting a function of two variables</h2><span id='topic+plot_fxy'></span>

<h3>Description</h3>

<p>Plot a real-valued function <code>f</code> evaluated on a grid of points 
of the Cartesian plane, possibly with parameters specified by <code>...</code>. 
The type of graphical display can be regulated by selecting the plotting
function among a set of available options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_fxy(f, xlim, ylim, ..., npt=51, grf, grpar) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_fxy_+3A_f">f</code></td>
<td>
<p>either a function or a character string with the name of a 
real-valued function  whose first argument  represents the 
coordinates of points where <code>f</code> is evaluated;
see &lsquo;Details&rsquo; for additional information.</p>
</td></tr>
<tr><td><code id="plot_fxy_+3A_xlim">xlim</code></td>
<td>
<p>either a vector of abscissae where the <code>f</code> must be evaluated, 
or a length-two vector with the endpoints of such an interval, 
in which case <code>npt[1]</code> equally spaced points will be considered. </p>
</td></tr>
<tr><td><code id="plot_fxy_+3A_ylim">ylim</code></td>
<td>
<p>either a vector of ordinates where the <code>f</code> must be evaluated, 
or a length-two vector with the endpoints of such an interval, 
in which case <code>npt[2]</code> equally spaced points will be considered. </p>
</td></tr>   
<tr><td><code id="plot_fxy_+3A_...">...</code></td>
<td>
<p>additional parameters to be supplied to <code>f</code>; these must be
named as expected by the specification of <code>f</code>.</p>
</td></tr>    
<tr><td><code id="plot_fxy_+3A_npt">npt</code></td>
<td>
<p>either an integer value or a two-element integer vector with
the number of equally-spaced points, within the endpoints of <code>xlim</code> 
and <code>ylim</code>, used to set up the grid of points 
where <code>f</code> is evaluated; default value: <code>51</code>.
When a single value is supplied, this is expanded into a length-2 vector.
If <code>length(xlim)&gt;2</code> and <code>length(ylim)&gt;2</code>, <code>npt</code> is ignored.
</p>
</td></tr>     
<tr><td><code id="plot_fxy_+3A_grf">grf</code></td>
<td>
<p>an optional character string with the name of the function  
which produces the graphical display, selectable among 
<code>"contour", "filled.contour", "persp", "image" </code> 
of package <code>graphics</code>;
if <code>grf</code> is unset, <code>"contour"</code> is used.</p>
</td></tr>
<tr><td><code id="plot_fxy_+3A_grpar">grpar</code></td>
<td>
<p>an optional character string with arguments supplied to the
selected <code>grf</code> function, with items separated by <code>,</code> 
as in a regular call.</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>Function <code>f</code> will be called with the first argument represented by a 
two-column matrix, where each row represents a point of the grid on the 
Cartesian plane identified by <code>xlim</code> and <code>ylim</code>;
this set of coordinates is stored in matrix <code>pts</code> of the returned list. 
If present, arguments supplied as <code>...</code> are also passed  to <code>f</code>.
It is assumed that <code>f</code> accepts this type of call.
</p>
<p>The original motivation of <code>plot_fxy</code> was to plot instances of bivariate 
probability density functions specified by package <code>mnormt</code>, 
but it can be used for plotting any function fulfilling the above requirements,
as illustrated by some of the examples below. 
</p>


<h3>Value</h3>

<p>an invisible list with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>x</code></td><td style="text-align: left;"> a vector of coordinates on the <code class="reqn">x</code> axis</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>y</code></td><td style="text-align: left;"> a vector of coordinates on the <code class="reqn">y</code> axis</td>
</tr>
<tr>
 <td style="text-align: left;">  
  <code>pts</code></td><td style="text-align: left;"> a matrix of dimension <code>(npt[1]*npt[2],2)</code>
            with the coordinates of the evaluation points <code class="reqn">(x,y)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>f.values</code> </td><td style="text-align: left;"> the vector of <code>f</code> values at the <code>pts</code> points.             
  </td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>,
<code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="graphics.html#topic+image">image</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma &lt;- matrix(c(1,1,1,2), 2, 2)
mean &lt;- c(0, -1)
xlim &lt;- c(-3, 5) 
ylim &lt;- c(-5, 3)
#
# multivariate normal density, contour-level plot
gp &lt;- 'col="blue", nlevels=6, main="bivariate normal density"'
u &lt;- plot_fxy(dmnorm, xlim, ylim, mean=mean, varcov=Sigma,  grpar=gp)
cat(str(u))
#---
# multivariate normal density, filled-contour plot
plot_fxy(dmnorm,  xlim, ylim, mean=mean, varcov=Sigma,grf="filled.contour")
#---
# multivariate normal density, perspective plot
gp &lt;- "theta = 10, phi = 25, r = 2.5"
plot_fxy(dmnorm, xlim, ylim, mean=mean, varcov=Sigma, grf="persp", grpar=gp)
#---
# multivariate Student's "t" density;
# the xlim argument passed to function 'grf' overrides the earlier xlim;
# xlim and ylim can be placed after the arguments of 'f', if one prefers so
grp &lt;- 'xlim=c(-1, 3)'
plot_fxy(dmt, mean=mean, S=Sigma, df=8, xlim, ylim, npt=101, 
        grf="filled.contour", grpar=grp)
#---
# multivariate truncated normal density, 'image' plot
low &lt;- c(-3, -5)
hi &lt;- c(1, 0)
plot_fxy(dmtruncnorm, mean=mean, varcov=Sigma, lower=low, upper=hi,
        xlim, ylim, npt=81, grf="image")
#---
# multivariate truncated normal distribution function, 'image' plot;
# hence not a density function 
low &lt;- c(-3, -5)
hi &lt;- c(1, 0)
v &lt;- plot_fxy(pmtruncnorm, mean=mean, varcov=Sigma, lower=low, upper=hi, 
              xlim, ylim, npt=c(61, 81), grf="image")        
#---
# a different sort of 'f' function (lbeta), not a component of this package
funct &lt;- function(z) lbeta(a=z[,1], b=z[,2])
plot_fxy(funct, xlim=c(0.1, 2), ylim=c(0.1, 2), npt=41, 
         grpar='main="function log-beta(a,b)", xlab="a", ylab="b"')
</code></pre>

<hr>
<h2 id='recintab'>
Moments of arbitrary order of a (possibly) truncated multivariate normal variable
</h2><span id='topic+recintab'></span>

<h3>Description</h3>

<p>Produces an array with the moments up to specified orders of a (possibly)
truncated multivariate normal distribution. 
Each component variable can be truncated on one side (to the left or 
to the right) or on two sides or not truncated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recintab(kappa, a, b, mu, S, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recintab_+3A_kappa">kappa</code></td>
<td>
<p>a vector of non-negative integer values representing the 
required order of moments for each component variable.</p>
</td></tr>
<tr><td><code id="recintab_+3A_a">a</code></td>
<td>
<p>a vector representing the lower truncation values of the component 
variables; <code>-Inf</code> values are allowed.</p>
</td></tr>
<tr><td><code id="recintab_+3A_b">b</code></td>
<td>
<p>a vector representing the upper truncation values of the component  
variables; <code>Inf</code> values are allowed.</p>
</td></tr>
<tr><td><code id="recintab_+3A_mu">mu</code></td>
<td>
<p>a vector representing the mean value of the pre-truncation normal 
random variable.</p>
</td></tr>
<tr><td><code id="recintab_+3A_s">S</code></td>
<td>
<p>a symmetric positive-definite matrix representing the variance
matrix of the pre-truncation normal random variable.</p>
</td></tr>
<tr><td><code id="recintab_+3A_...">...</code></td>
<td>
<p>parameters passed to <code>sadmvn</code>; see the &lsquo;Details&rsquo;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximal dimension of the multivariate normal variable is 20.
If this threshold is exceeded <code>NA</code>s are returned. 
</p>
<p>This function is the <span class="rlang"><b>R</b></span> translation of the Matlab function with the same name
belonging to the package <code>ftnorm</code>, 
which is associated to the paper of Kan and Robotti (2017).
The Matlab package <code>ftnorm</code> has been downloaded from
<a href="http://www-2.rotman.utoronto.ca/~kan/research.htm">http://www-2.rotman.utoronto.ca/~kan/research.htm</a>, 
on 2020-04-23.
</p>
<p>The function returns an array, <code>M</code> say, whose entries represent integrals 
of type  <code class="reqn">\int_a^b x^\kappa f(x) dx</code>, where <code class="reqn">f(x)</code> denotes the 
<code class="reqn">d</code>-dimensional normal density function. 
Typically, interest is in the scaled array <code>M/M[1]</code> whose entries 
represent the moments of the truncated distribution.
</p>
<p>The algorithm is based on a recursion starting from the integral of the normal 
distribution over the specified hyper-rectangle. This integral is evaluated 
by <code>sadmvn</code>, whose tuning parameters  <code>maxpts, abseps, releps</code> 
can be regulated via the <code>...</code> argument.       
</p>


<h3>Value</h3>

<p>In the multivariate case, for an input vector <code>kappa=c(k1,..., kd)</code>, 
the functions returns  an array of dimension <code>c((k1+1),...,(kd+1))</code> 
whose entries represent integrals described in section &lsquo;Details&rsquo;.
In other words, the array element <code>M[i+1, j+1, k+1,...]</code> contains the 
<em>unnormalized</em>  cross moment of order <code>(i, j, k,...)</code>; 
this must be divided by <code>M[1]</code> to obtain the regular cross moment.
</p>
<p>In the univariate case, a vector is returned with similar meaning.
</p>


<h3>Warning</h3>

<p>Although the underlying algorithm is exact in principle, the actual 
computation hinges crucially on the initial integration of the multivariate 
normal density over the truncation hyper-cube.
This integration may result in numerical inaccuracies, whose amount depends 
on the supplied arguments. Moreover, the recursion employed by the algorithm
propagates the initial error to other terms.  
</p>
<p>When problematic cases have been processed by the original Matlab function,
the same issues have occurred, up to minor variations.
</p>
<p>Instances of such errors may be detected when the array <code>M/M[1]</code> is 
passed to <code><a href="#topic+mom2cum">mom2cum</a></code>, but there is no guarantee that all such 
problems are detected.
</p>


<h3>Note</h3>

<p>This function is not intended for direct call by a user, at least in
commonly encountered situations.
Function <code><a href="#topic+mom.mtruncnorm">mom.mtruncnorm</a></code> represents a more user-friendly tool.</p>


<h3>Author(s)</h3>

<p>Original Matlab code by Raymond Kan and Cesare Robotti,
porting to R by Adelchi Azzalini.
</p>


<h3>References</h3>

<p>Kan, Raymond and Robotti, Cesare (2017).
On moments of folded and truncated multivariate normal distributions.
<em>Journal of Computational and Graphical Statistics</em>, 26, 930-934, 
DOI: 10.1080/10618600.2017.1322092
</p>
<p>Leppard, P. and Tallis, G. M. (1989).
Algorithm AS249:  Evaluation of the mean and covariance of the 
truncated multinormal distribution
<em>Applied Statistics</em> 38, 543-553)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mom.mtruncnorm">mom.mtruncnorm</a></code> for a more user-friendly function,
<code><a href="#topic+mom2cum">mom2cum</a></code> for transformation to cumulants,
<code><a href="#topic+sadmvn">sadmvn</a></code> for regulating accuracy if <code>d&gt;2</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(1, -0.5, 0)
Sigma &lt;- toeplitz(1/(1:3))
low &lt;- c(-Inf, -3, -4)
hi &lt;- c(1.5, Inf, 2)
M &lt;- recintab(c(2,3,1), low, hi, mu, Sigma)
M/M[1]
# cross-moments up to order 2 for X1, up to the 3 for X2, up to 1 for X3,
# if the components of the trivariate variable are denoted (X1,X2,X3)
#--
# Example 2 of Leppard &amp; Tallis (1989, Appl.Stat. vol.38, p.547)
truncp &lt;- c(0, 1, 2)
U &lt;- c(0, 0, 0)
V &lt;- 0.5*(diag(3) + matrix(1, 3, 3))
M &lt;- recintab(c(2,2,2), truncp, rep(Inf,3), U, V)
mom &lt;- M/M[1]
EX &lt;-  c(mom[2,1,1], mom[1,2,1], mom[1,1,2])
print(EX, digits=9)
EX2 &lt;- matrix(c(
          mom[3,1,1], mom[2,2,1], mom[2,1,2],
          mom[2,2,1], mom[1,3,1], mom[1,2,2],
          mom[2,1,2], mom[1,2,2], mom[1,1,3]), 
          3, 3, byrow=TRUE)
varX &lt;- EX2 - outer(EX ,EX)       
print(varX, digits=9)


</code></pre>

<hr>
<h2 id='sample_Mardia_measures'>
The Mardia measures of multivariate skewness and kurtosis for a given sample
</h2><span id='topic+sample_Mardia_measures'></span>

<h3>Description</h3>

<p>Given a multivariate sample, the Mardia measures of skewness and kurtosis are
computed, along with their <em>p</em>-values for testing normality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_Mardia_measures(data, correct = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_Mardia_measures_+3A_data">data</code></td>
<td>
<p>a data matrix</p>
</td></tr>
<tr><td><code id="sample_Mardia_measures_+3A_correct">correct</code></td>
<td>
<p>(logical) if <code>correct=TRUE</code>, the &lsquo;corrected&rsquo; 
sample variance matrix is used, otherwise the &lsquo;uncorrected&rsquo; version
is used (default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given a data matrix, the multivariate  measures of skewness and 
kurtosis  introduced by Mardia (1970, 1974) are computed, 
along with some associated quantities. 
We follow the notation of the 1974 paper.
</p>
<p>If <code>n</code> denotes the number of complete cases, the condition <code>n&gt;3</code>
is required for numerical computation. Clearly, a much larger <code>n</code> is
required for meaningful statistical work.
</p>
<p>The  sample variance matrix <code class="reqn">S</code> appearing  in (2.2) and (2.4) 
is computed here (in the dafault setting) with the <code class="reqn">n</code> denominator, 
at variance from the commonly employed <code>n-1</code> denominator. 
With this definition of <code class="reqn">S</code>, one obtains the same numerical outcome 
of the example on p.127 of Mardia (1974).
</p>
<p>The approximate observed significance levels for testing normality, 
<code>p.b1</code> and <code>p.b2</code>, are computed using expressions (5.5) and
(5.6) in Section 5 of Mardia (1974).
For  <code>p.b2</code>, the condition <code>(n-d-1)&gt;0</code> is required, where
<code>d</code> denotes the number of variables.
</p>


<h3>Value</h3>

<p>A named vector with the following components:
</p>
<table>
<tr><td><code>b1</code></td>
<td>
<p>the measure of asymmetry as given in (2.2)</p>
</td></tr>
<tr><td><code>b2</code></td>
<td>
<p>the measure of kurtosis as given in (2.4)</p>
</td></tr>
<tr><td><code>g1</code></td>
<td>
<p>the measure of asymmetry as given in (2.10)</p>
</td></tr>
<tr><td><code>g2</code></td>
<td>
<p>the measure of kurtosis as given in (2.11)</p>
</td></tr>
<tr><td><code>p.b1</code></td>
<td>
<p>observed significance level of <code>b1</code></p>
</td></tr>
<tr><td><code>p.b2</code></td>
<td>
<p>observed significance level of <code>b2</code></p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of complete cases in the input data matrix</p>
</td></tr>
</table>
<p>where the quoted formulae are those of Mardia (1974).
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini
</p>


<h3>References</h3>

<p>Mardia, K. V. (1970). 
Measures of multivariate skewness and kurtosis with applications
<em>Biometrika</em>, 57, 519-530.
</p>
<p>Mardia, K. V. (1974).
Applications of some measures of multivariate skewness and kurtosis 
in testing normality and robustness studies.
<em>Sankhya ser.B</em>, 36, 115-128.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rmnorm(100, mean=1:3, varcov=toeplitz(1/(1:3)))
sample_Mardia_measures(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
