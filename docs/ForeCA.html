<!DOCTYPE html><html><head><title>Help for package ForeCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ForeCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#common-arguments'><p>List of common arguments</p></a></li>
<li><a href='#complete-controls'><p>Completes several control settings</p></a></li>
<li><a href='#continuous_entropy'><p>Shannon entropy for a continuous pdf</p></a></li>
<li><a href='#discrete_entropy'><p>Shannon entropy for discrete pmf</p></a></li>
<li><a href='#foreca'><p>Forecastable Component Analysis</p></a></li>
<li><a href='#ForeCA-package'><p>Implementation of Forecastable Component Analysis (ForeCA)</p></a></li>
<li><a href='#foreca-utils'><p>Plot, summary, and print methods for class 'foreca'</p></a></li>
<li><a href='#foreca.EM-aux'><p>ForeCA EM auxiliary functions</p></a></li>
<li><a href='#foreca.EM.one_weightvector'><p>EM-like algorithm to estimate optimal ForeCA transformation</p></a></li>
<li><a href='#foreca.one_weightvector-utils'><p>Plot, summary, and print methods for class 'foreca.one_weightvector'</p></a></li>
<li><a href='#initialize_weightvector'><p>Initialize weightvector for iterative ForeCA algorithms</p></a></li>
<li><a href='#mvspectrum'><p>Estimates spectrum of multivariate time series</p></a></li>
<li><a href='#mvspectrum-utils'><p>S3 methods for class 'mvspectrum'</p></a></li>
<li><a href='#mvspectrum2wcov'><p>Compute (weighted) covariance matrix from frequency spectrum</p></a></li>
<li><a href='#Omega'><p>Estimate forecastability of a time series</p></a></li>
<li><a href='#quadratic_form'><p>Computes quadratic form x' A x</p></a></li>
<li><a href='#sfa'><p>Slow Feature Analysis</p></a></li>
<li><a href='#spectral_entropy'><p>Estimates spectral entropy of a time series</p></a></li>
<li><a href='#whiten'><p>whitens multivariate data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forecastable Component Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-06-21</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gmgeorg/ForeCA">https://github.com/gmgeorg/ForeCA</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of Forecastable Component Analysis ('ForeCA'),
    including main algorithms and auxiliary function (summary, plotting, etc.) to
    apply 'ForeCA' to multivariate time series data. 'ForeCA' is a novel dimension
    reduction (DR) technique for temporally dependent signals. Contrary to other
    popular DR methods, such as 'PCA' or 'ICA', 'ForeCA' takes time dependency
    explicitly into account and searches for the most &rdquo;forecastable&rdquo; signal.
    The measure of forecastability is based on the Shannon entropy of the spectral
    density of the transformed signal.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>astsa (&ge; 1.10), MASS, graphics, reshape2 (&ge; 1.4.4), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>psd, fBasics, knitr, markdown, mgcv, nlme (&ge; 3.1-64),
testthat (&ge; 2.0.0), rSFA,</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-29 01:43:22 UTC; georg</td>
</tr>
<tr>
<td>Author:</td>
<td>Georg M. Goerg [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georg M. Goerg &lt;im@gmge.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-29 12:40:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='common-arguments'>List of common arguments</h2><span id='topic+common-arguments'></span>

<h3>Description</h3>

<p>Common arguments used in several functions in this package.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="common-arguments_+3A_series">series</code></td>
<td>
<p>a <code class="reqn">T \times K</code> array with <code>T</code> observations from the 
<code class="reqn">K</code>-dimensional time series <code class="reqn">\mathbf{X}_t</code>. Can be a <code>matrix</code>, <code>data.frame</code>, 
or a multivariate <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_u">U</code></td>
<td>
<p>a <code class="reqn">T \times K</code> array with <code>T</code> observations from the 
<code class="reqn">K</code>-dimensional <strong>whitened</strong> (<code><a href="#topic+whiten">whiten</a></code>) 
time series <code class="reqn">\mathbf{U}_t</code>. Can be a <code>matrix</code>, <code>data.frame</code>, or a 
multivariate <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_mvspectrum.output">mvspectrum.output</code></td>
<td>
<p>an object of class <code>"mvspectrum"</code> representing
the multivariate spectrum of <code class="reqn">\mathbf{X}_t</code> (not necessarily <code>normalize</code>d).</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_f.u">f.U</code></td>
<td>
<p>multivariate spectrum of class <code>'mvspectrum'</code> with 
<code>normalize = TRUE</code>.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_algorithm.control">algorithm.control</code></td>
<td>
<p>list; control settings for any <em>iterative</em> ForeCA 
algorithm. See <code><a href="#topic+complete_algorithm_control">complete_algorithm_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_entropy.control">entropy.control</code></td>
<td>
<p>list; control settings for entropy estimation.
See <code><a href="#topic+complete_entropy_control">complete_entropy_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_spectrum.control">spectrum.control</code></td>
<td>
<p>list; control settings for spectrum estimation. 
See <code><a href="#topic+complete_spectrum_control">complete_spectrum_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_entropy.method">entropy.method</code></td>
<td>
<p>string; method to estimate the entropy from discrete
probabilities <code class="reqn">p_i</code>; here <em>probabilities</em> are the spectral density
evaluated at the Fourier frequencies, 
<code class="reqn">\widehat{p}_i = \widehat{f}(\omega_i)</code>.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_spectrum.method">spectrum.method</code></td>
<td>
<p>string; method for spectrum estimation; see <code>method</code>
argument in <code><a href="#topic+mvspectrum">mvspectrum</a></code>.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_threshold">threshold</code></td>
<td>
<p>numeric; values of spectral density below <code>threshold</code> are set to
<code class="reqn">0</code>; default <code>threshold = 0</code>.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_smoothing">smoothing</code></td>
<td>
<p>logical; if <code>TRUE</code> the spectrum will be
smoothed with a nonparametric estimate using <code><a href="mgcv.html#topic+gam">gam</a></code> 
and an exponential family (with <code>link = log</code>). Only works
for univariate spectrum. The smoothing
parameter is chosen automatically using generalized cross-validation 
(see <code><a href="mgcv.html#topic+gam">gam</a></code> for details). Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_base">base</code></td>
<td>
<p>logarithm base; entropy is measured in &ldquo;nats&rdquo; for 
<code>base = exp(1)</code>; in &ldquo;bits&rdquo; if <code>base = 2</code> (default).</p>
</td></tr>
</table>

<hr>
<h2 id='complete-controls'>Completes several control settings</h2><span id='topic+complete-controls'></span><span id='topic+complete_algorithm_control'></span><span id='topic+complete_entropy_control'></span><span id='topic+complete_spectrum_control'></span>

<h3>Description</h3>

<p>Completes algorithm, entropy, and spectrum control lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_algorithm_control(
  algorithm.control = list(max.iter = 50, num.starts = 10, tol = 0.001, type = "EM")
)

complete_entropy_control(
  entropy.control = list(base = NULL, method = "MLE", prior.probs = NULL, prior.weight
    = 0.001, threshold = 0),
  num.outcomes
)

complete_spectrum_control(
  spectrum.control = list(kernel = NULL, method = c("mvspec", "pspectrum", "ar",
    "pgram"), smoothing = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete-controls_+3A_algorithm.control">algorithm.control</code></td>
<td>
<p>list; control parameters for any <em>iterative</em> ForeCA 
algorithm.</p>
</td></tr>
<tr><td><code id="complete-controls_+3A_entropy.control">entropy.control</code></td>
<td>
<p>list; control settings for entropy estimation.</p>
</td></tr>
<tr><td><code id="complete-controls_+3A_num.outcomes">num.outcomes</code></td>
<td>
<p>positive integer; number of outcomes for the discrete probability
distribution. Must be specified (no default value).</p>
</td></tr>
<tr><td><code id="complete-controls_+3A_spectrum.control">spectrum.control</code></td>
<td>
<p>list; control settings for spectrum estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with fully specified algorithm, entropy, or spectrum controls. 
Default values are only added if the input <code>{spectrum,entropy,algorithm}.control</code> 
list does not already set this value.
</p>
<p><code>complete_algorithm_control</code> returns a list containing:
</p>
<table>
<tr><td><code>max.iter</code></td>
<td>
<p>maximum number of iterations; default: <code>50</code>.</p>
</td></tr>
<tr><td><code>num.starts</code></td>
<td>
<p>number of random starts to avoid local optima; default: <code>10</code>.</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>tolerance for when convergence is reached in any <em>iterative</em> 
ForeCA algorithm;  default: <code>1e-03</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>string; type of algorithm. Default: <code>'EM'</code>.</p>
</td></tr>
</table>
<p><code>complete_entropy_control</code> returns a list with:
</p>
<table>
<tr><td><code>base</code></td>
<td>
<p>logarithm base for the entropy.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>string; method to estimate entropy; default: <code>"MLE"</code>.</p>
</td></tr>
<tr><td><code>prior.probs</code></td>
<td>
<p>prior distribution; default: uniform 
<code>rep(1 / num.outcomes, num.outcomes)</code>.</p>
</td></tr>
<tr><td><code>prior.weight</code></td>
<td>
<p>weight of the prior distribution; default: <code>1e-3</code>.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>non-negative float; set probabilities below threshold to 
zero;  default: <code>0</code>.</p>
</td></tr>
</table>
<p><code>complete_spectrum_control</code> returns a list containing:
</p>
<table>
<tr><td><code>kernel</code></td>
<td>
<p>R function; function to weigh each Fourier frequency <code class="reqn">\lambda</code>; 
default: <code>NULL</code> (no re-weighting).</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>string; method to estimate the spectrum; default: 
<code>'mvspec'</code> if <span class="pkg">sapa</span> is installed, <code>'mvspec'</code> 
if only <span class="pkg">astsa</span> is installed, and <code>'pgram'</code> if
neither is installed.</p>
</td></tr>
<tr><td><code>smoothing</code></td>
<td>
<p>logical; default: <code>FALSE</code>.</p>
</td></tr>
</table>
<p>Available methods for spectrum estimation are (alphabetical order)
</p>
<table>
<tr><td><code>"ar"</code></td>
<td>
<p> autoregressive spectrum fit via <code><a href="stats.html#topic+spec.ar">spec.ar</a></code>; 
only for univariate time series.</p>
</td></tr>
<tr><td><code>"mvspec"</code></td>
<td>
<p> smoothed estimate using <code><a href="astsa.html#topic+mvspec">mvspec</a></code>; many tuning parameters
are available &ndash; they can be passed as additional arguments (<code>...</code>) 
to <code>mvspectrum</code>.</p>
</td></tr>
<tr><td><code>"pgram"</code></td>
<td>
<p> raw periodogram using <code>spectrum</code></p>
</td></tr>
<tr><td><code>"pspectrum"</code></td>
<td>
<p> advanced non-parametric estimation of a tapered power 
spectrum using <code><a href="psd.html#topic+pspectrum">pspectrum</a></code>.</p>
</td></tr>
</table>
<p>Setting <code>smoothing  = TRUE</code> will smooth the estimated spectrum
(again); this option is only available for univariate time series/spectra.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvspectrum">mvspectrum</a></code>, <code><a href="#topic+discrete_entropy">discrete_entropy</a></code>, 
<code><a href="#topic+continuous_entropy">continuous_entropy</a></code>
</p>

<hr>
<h2 id='continuous_entropy'>Shannon entropy for a continuous pdf</h2><span id='topic+continuous_entropy'></span>

<h3>Description</h3>

<p>Computes the Shannon entropy <code class="reqn">\mathcal{H}(p)</code> for a continuous 
probability density function (pdf) <code class="reqn">p(x)</code> using numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous_entropy(pdf, lower, upper, base = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuous_entropy_+3A_pdf">pdf</code></td>
<td>
<p>R function for the pdf <code class="reqn">p(x)</code> of a RV <code class="reqn">X \sim p(x)</code>. This function must
be non-negative and integrate to <code class="reqn">1</code> over the interval [<code>lower</code>, <code>upper</code>].</p>
</td></tr>
<tr><td><code id="continuous_entropy_+3A_lower">lower</code>, <code id="continuous_entropy_+3A_upper">upper</code></td>
<td>
<p>lower and upper integration limit. <code>pdf</code> must integrate to 
<code>1</code> on this interval.</p>
</td></tr>
<tr><td><code id="continuous_entropy_+3A_base">base</code></td>
<td>
<p>logarithm base; entropy is measured in &ldquo;nats&rdquo; for 
<code>base = exp(1)</code>; in &ldquo;bits&rdquo; if <code>base = 2</code> (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Shannon entropy of a continuous random variable (RV) <code class="reqn">X \sim p(x)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
\mathcal{H}(p) = -\int_{-\infty}^{\infty} p(x) \log p(x) d x.
</code>
</p>

<p>Contrary to discrete RVs, continuous RVs can have negative entropy (see Examples).
</p>


<h3>Value</h3>

<p>scalar; entropy value (real). 
</p>
<p>Since <code>continuous_entropy</code> uses numerical integration (<code>integrate()</code>) convergence
is not garantueed (even if integral in definition of <code class="reqn">\mathcal{H}(p)</code> exists).
Issues a warning if <code>integrate()</code> does not converge.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete_entropy">discrete_entropy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># entropy of U(a, b) = log(b - a). Thus not necessarily positive anymore, e.g.
continuous_entropy(function(x) dunif(x, 0, 0.5), 0, 0.5) # log2(0.5)

# Same, but for U(-1, 1)
my_density &lt;- function(x){
  dunif(x, -1, 1)
}
continuous_entropy(my_density, -1, 1) # = log(upper - lower)

# a 'triangle' distribution
continuous_entropy(function(x) x, 0, sqrt(2))

</code></pre>

<hr>
<h2 id='discrete_entropy'>Shannon entropy for discrete pmf</h2><span id='topic+discrete_entropy'></span>

<h3>Description</h3>

<p>Computes the Shannon entropy <code class="reqn">\mathcal{H}(p) = -\sum_{i=1}^{n} p_i \log p_i</code>
of a discrete RV <code class="reqn">X</code> taking
values in <code class="reqn">\lbrace x_1, \ldots, x_n \rbrace</code> with probability
mass function (pmf) <code class="reqn">P(X = x_i) = p_i</code> with
<code class="reqn">p_i \geq 0</code> for all <code class="reqn">i</code> and <code class="reqn">\sum_{i=1}^{n} p_i = 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete_entropy(
  probs,
  base = 2,
  method = c("MLE"),
  threshold = 0,
  prior.probs = NULL,
  prior.weight = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete_entropy_+3A_probs">probs</code></td>
<td>
<p>numeric; probabilities (empirical frequencies). Must be non-negative and add up to <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="discrete_entropy_+3A_base">base</code></td>
<td>
<p>logarithm base; entropy is measured in &ldquo;nats&rdquo; for 
<code>base = exp(1)</code>; in &ldquo;bits&rdquo; if <code>base = 2</code> (default).</p>
</td></tr>
<tr><td><code id="discrete_entropy_+3A_method">method</code></td>
<td>
<p>string; method to estimate entropy; see Details below.</p>
</td></tr>
<tr><td><code id="discrete_entropy_+3A_threshold">threshold</code></td>
<td>
<p>numeric; frequencies below <code>threshold</code> are set to <code class="reqn">0</code>;
default <code>threshold = 0</code>, i.e., no thresholding.
If <code>prior.weight &gt; 0</code> then thresholding will be done <em>before</em> smoothing.</p>
</td></tr>
<tr><td><code id="discrete_entropy_+3A_prior.probs">prior.probs</code></td>
<td>
<p>optional; only used if <code>prior.weight &gt; 0</code>.
Add a prior probability distribution to <code>probs</code>. By default it uses a
uniform distribution putting equal probability on each outcome.</p>
</td></tr>
<tr><td><code id="discrete_entropy_+3A_prior.weight">prior.weight</code></td>
<td>
<p>numeric; how much weight does the prior distribution get in a mixture
model between data and prior distribution? Must be between <code>0</code> and <code>1</code>.
Default: <code>0</code> (no prior).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>discrete_entropy</code> uses a plug-in estimator (<code>method = "MLE"</code>):
</p>
<p style="text-align: center;"><code class="reqn">
\widehat{\mathcal{H}}(p) = - \sum_{i=1}^{n} \widehat{p}_i \log \widehat{p}_i.
</code>
</p>

<p>If <code>prior.weight &gt; 0</code>, then it mixes the observed proportions <code class="reqn">\widehat{p}_i</code>
with a prior distribution
</p>
<p style="text-align: center;"><code class="reqn">
\widehat{p}_i \leftarrow (1-\lambda) \cdot \widehat{p_i} + \lambda \cdot prior_i, \quad i=1, \ldots, n,
</code>
</p>

<p>where <code class="reqn">\lambda \in [0, 1]</code> is the <code>prior.weight</code> parameter.  By default
the prior is a uniform distribution, i.e., <code class="reqn">prior_i = \frac{1}{n}</code> for all i.
</p>
<p>Note that this plugin estimator is biased. See References for an overview of alternative
methods.
</p>


<h3>Value</h3>

<p>numeric; non-negative real value.
</p>


<h3>References</h3>

<p>Archer E., Park I. M., Pillow J.W. (2014). &ldquo;Bayesian Entropy Estimation for
Countable Discrete Distributions&rdquo;. Journal of Machine Learning Research (JMLR) 15,
2833-2868. Available at <a href="http://jmlr.org/papers/v15/archer14a.html">http://jmlr.org/papers/v15/archer14a.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+continuous_entropy">continuous_entropy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
probs.tmp &lt;- rexp(5)
probs.tmp &lt;- sort(probs.tmp / sum(probs.tmp))

unif.distr &lt;- rep(1/length(probs.tmp), length(probs.tmp))

matplot(cbind(probs.tmp, unif.distr), pch = 19,
        ylab = "P(X = k)", xlab = "k")
matlines(cbind(probs.tmp, unif.distr))
legend("topleft", c("non-uniform", "uniform"), pch = 19,
       lty = 1:2, col = 1:2, box.lty = 0)

discrete_entropy(probs.tmp)
# uniform has largest entropy among all bounded discrete pmfs
# (here = log(5))
discrete_entropy(unif.distr)
# no uncertainty if one element occurs with probability 1
discrete_entropy(c(1, 0, 0))

</code></pre>

<hr>
<h2 id='foreca'>Forecastable Component Analysis</h2><span id='topic+foreca'></span><span id='topic+foreca.one_weightvector'></span><span id='topic+foreca.multiple_weightvectors'></span>

<h3>Description</h3>

<p><code>foreca</code> performs Forecastable Component Analysis (ForeCA) on
<code class="reqn">\mathbf{X}_t</code> &ndash; a <code class="reqn">K</code>-dimensional time series with <code class="reqn">T</code>
observations. Users should only call
<code>foreca</code>, rather than <code>foreca.one_weightvector</code> or
<code>foreca.multiple_weightvectors</code>.
</p>
<p><code>foreca.one_weightvector</code> is a wrapper around several algorithms that
solve the ForeCA optimization problem for a single weightvector <code class="reqn">\mathbf{w}_i</code>
and whitened time series <code class="reqn">\mathbf{U}_t</code>.
</p>
<p><code>foreca.multiple_weightvectors</code> applies <code>foreca.one_weightvector</code>
iteratively to <code class="reqn">\mathbf{U}_t</code> in order to obtain multiple weightvectors
that yield most forecastable, uncorrelated signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foreca(series, n.comp = 2, algorithm.control = list(type = "EM"), ...)

foreca.one_weightvector(
  U,
  f.U = NULL,
  spectrum.control = list(),
  entropy.control = list(),
  algorithm.control = list(),
  keep.all.optima = FALSE,
  dewhitening = NULL,
  ...
)

foreca.multiple_weightvectors(
  U,
  spectrum.control = list(),
  entropy.control = list(),
  algorithm.control = list(),
  n.comp = 2,
  plot = FALSE,
  dewhitening = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreca_+3A_series">series</code></td>
<td>
<p>a <code class="reqn">T \times K</code> array with <code>T</code> observations from the 
<code class="reqn">K</code>-dimensional time series <code class="reqn">\mathbf{X}_t</code>. Can be a <code>matrix</code>, <code>data.frame</code>, 
or a multivariate <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="foreca_+3A_n.comp">n.comp</code></td>
<td>
<p>positive integer; number of components to be extracted.
Default: <code>2</code>.</p>
</td></tr>
<tr><td><code id="foreca_+3A_algorithm.control">algorithm.control</code></td>
<td>
<p>list; control settings for any <em>iterative</em> ForeCA 
algorithm. See <code><a href="#topic+complete_algorithm_control">complete_algorithm_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="foreca_+3A_...">...</code></td>
<td>
<p>additional arguments passed to available ForeCA algorithms.</p>
</td></tr>
<tr><td><code id="foreca_+3A_u">U</code></td>
<td>
<p>a <code class="reqn">T \times K</code> array with <code>T</code> observations from the 
<code class="reqn">K</code>-dimensional <strong>whitened</strong> (<code><a href="#topic+whiten">whiten</a></code>) 
time series <code class="reqn">\mathbf{U}_t</code>. Can be a <code>matrix</code>, <code>data.frame</code>, or a 
multivariate <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="foreca_+3A_f.u">f.U</code></td>
<td>
<p>multivariate spectrum of class <code>'mvspectrum'</code> with 
<code>normalize = TRUE</code>.</p>
</td></tr>
<tr><td><code id="foreca_+3A_spectrum.control">spectrum.control</code></td>
<td>
<p>list; control settings for spectrum estimation. 
See <code><a href="#topic+complete_spectrum_control">complete_spectrum_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="foreca_+3A_entropy.control">entropy.control</code></td>
<td>
<p>list; control settings for entropy estimation.
See <code><a href="#topic+complete_entropy_control">complete_entropy_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="foreca_+3A_keep.all.optima">keep.all.optima</code></td>
<td>
<p>logical; if <code>TRUE</code>, it keeps the optimal
solutions of each random start. Default: <code>FALSE</code> (only returns the best solution).</p>
</td></tr>
<tr><td><code id="foreca_+3A_dewhitening">dewhitening</code></td>
<td>
<p>optional; if provided (returned by <code><a href="#topic+whiten">whiten</a></code>)
then it uses the dewhitening transformation to obtain the original
series <code class="reqn">\mathbf{X}_t</code> and it uses that vector (normalized) as the initial
weightvector which corresponds to the series <code class="reqn">\mathbf{X}_{t,i}</code>
with larges <code><a href="#topic+Omega">Omega</a></code>.</p>
</td></tr>
<tr><td><code id="foreca_+3A_plot">plot</code></td>
<td>
<p>logical; if <code>TRUE</code> a plot of the current optimal
solution <code class="reqn">\mathbf{w}_i^*</code> will be shown and updated for each iteration
<code class="reqn">i = 1, ..., </code> <code>n.comp</code> of any iterative algorithm. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>foreca</code>, which is similar to the output from <code><a href="stats.html#topic+princomp">princomp</a></code>,
with the following components (amongst others):
</p>

<ul>
<li><p><code>center</code>: sample mean <code class="reqn">\widehat{\mu}_X</code> of each <code>series</code>,
</p>
</li>
<li><p><code>whitening</code>: whitening matrix of size <code class="reqn">K \times K</code>
from <code><a href="#topic+whiten">whiten</a></code>: <code class="reqn">\mathbf{U}_t = (\mathbf{X}_t - \widehat{\mu}_X) \cdot whitening</code>;
note that <code class="reqn">\mathbf{X}_t</code> is centered prior to the whitening transformation,
</p>
</li>
<li><p><code>weightvectors</code>: orthonormal matrix of size <code class="reqn">K \times n.comp</code>,
which converts whitened data to <code>n.comp</code> forecastable components (ForeCs)
<code class="reqn">\mathbf{F}_t = \mathbf{U}_t \cdot weightvectors</code>, 
</p>
</li>
<li><p><code>loadings</code>: combination of whitening <code class="reqn">\times</code> weightvectors to obtain the final
loadings for the original data:
<code class="reqn">\mathbf{F}_t = (\mathbf{X}_t - \widehat{\mu}_X) \cdot whitening \cdot
weightvectors</code>; again, it centers <code class="reqn">\mathbf{X}_t</code> first,
</p>
</li>
<li><p><code>loadings.normalized</code>: normalized loadings (unit norm).  Note
though that if you use these normalized loadings the resulting
signals do not have variance 1 anymore.
</p>
</li>
<li><p><code>scores</code>: <code>n.comp</code> forecastable components <code class="reqn">\mathbf{F}_t</code>.
They have mean 0, variance 1, and are uncorrelated.
</p>
</li>
<li><p><code>Omega</code>: forecastability score of each ForeC of <code class="reqn">\mathbf{F}_t</code>.
</p>
</li></ul>

<p>ForeCs are ordered from most to least forecastable (according to
<code><a href="#topic+Omega">Omega</a></code>).
</p>


<h3>Warning</h3>

<p>Estimating Omega directly from the ForeCs <code class="reqn">\mathbf{F}_t</code> can be different
to the reported <code>$Omega</code> estimates from <code>foreca</code>.  Here is why:
</p>
<p>In theory <code class="reqn">f_y(\lambda)</code> of a linear combination
<code class="reqn">y_t = \mathbf{X}_t \mathbf{w}</code> can be analytically computed from
the multivariate spectrum <code class="reqn">f_{\mathbf{X}}(\lambda)</code> by the
quadratic form
<code class="reqn">f_y(\lambda) = \mathbf{w}' f_{\mathbf{X}}(\lambda) \mathbf{w}</code> for all
<code class="reqn">\lambda</code> (see <code><a href="#topic+spectrum_of_linear_combination">spectrum_of_linear_combination</a></code>).
</p>
<p>In practice, however, this identity does not hold always exactly since
(often data-driven) control setting for spectrum estimation are not identical
for the high-dimensional, noisy
<code class="reqn">\mathbf{X}_t</code> and the combined univariate time series <code class="reqn">y_t</code>
(which is usually more smooth, less variable). Thus estimating
<code class="reqn">\widehat{f}_y</code> directly  from <code class="reqn">y_t</code> can give slightly different
estimates to computing it as <code class="reqn">\mathbf{w}'\widehat{f}_{\mathbf{X}}\mathbf{w}</code>.  Consequently also <code>Omega</code> estimates
can be different.
</p>
<p>In general, these differences are small and have no relevant implications
for estimating ForeCs.  However, in rare occasions the obtained ForeCs can have
smaller <code>Omega</code> than the maximum <code>Omega</code> across all original series.
In such a case users should not re-estimate <code class="reqn">\Omega</code> from the resulting
ForeCs <code class="reqn">\mathbf{F}_t</code>, but access them via <code>$Omega</code> provided
by <code>'foreca'</code> output (the univariate estimates are stored in <code>$Omega.univ</code>).
</p>


<h3>References</h3>

<p>Goerg, G. M. (2013). &ldquo;Forecastable Component Analysis&rdquo;.
Journal of Machine Learning Research (JMLR) W&amp;CP 28 (2): 64-72, 2013.
Available at <a href="http://jmlr.org/proceedings/papers/v28/goerg13.html">http://jmlr.org/proceedings/papers/v28/goerg13.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XX &lt;- diff(log(EuStockMarkets)) * 100
plot(ts(XX))
## Not run: 
ff &lt;- foreca(XX[,1:4], n.comp = 4, plot = TRUE, spectrum.control=list(method="pspectrum"))
ff
summary(ff)
plot(ff)

## End(Not run)


## Not run: 
PW &lt;- whiten(XX)
one.weight.em &lt;- foreca.one_weightvector(U = PW$U,
                                        dewhitening = PW$dewhitening,
                                        algorithm.control =
                                          list(num.starts = 2,
                                               type = "EM"),
                                        spectrum.control =
                                          list(method = "mvspec"))
plot(one.weight.em)

## End(Not run)
## Not run: 

PW &lt;- whiten(XX)
ff &lt;- foreca.multiple_weightvectors(PW$U, n.comp = 2,
                                    dewhitening = PW$dewhitening)
ff
plot(ff$scores)

## End(Not run)
</code></pre>

<hr>
<h2 id='ForeCA-package'>Implementation of Forecastable Component Analysis (ForeCA)</h2><span id='topic+ForeCA-package'></span><span id='topic+ForeCA'></span>

<h3>Description</h3>

<p>Forecastable Component Analysis (ForeCA) is a novel dimension reduction
technique for multivariate time series <code class="reqn">\mathbf{X}_t</code>.
ForeCA finds a linar combination
<code class="reqn">y_t = \mathbf{X}_t \mathbf{v}</code> that is easy to forecast. The measure of
forecastability <code class="reqn">\Omega(y_t)</code> (<code><a href="#topic+Omega">Omega</a></code>) is based on the entropy
of the spectral density <code class="reqn">f_y(\lambda)</code> of <code class="reqn">y_t</code>: higher entropy means
less forecastable, lower entropy is more forecastable.
</p>
<p>The main function <code><a href="#topic+foreca">foreca</a></code> runs ForeCA on a
multivariate time series  <code class="reqn">\mathbf{X}_t</code>.
</p>
<p>Consult <code>NEWS.md</code> for a history of release notes.
</p>


<h3>Author(s)</h3>

<p>Author and maintainer: Georg M. Goerg &lt;im@gmge.org&gt;
</p>


<h3>References</h3>

<p>Goerg, G. M. (2013). &ldquo;Forecastable Component Analysis&rdquo;.
Journal of Machine Learning Research (JMLR) W&amp;CP 28 (2): 64-72, 2013.
Available at <a href="http://jmlr.org/proceedings/papers/v28/goerg13.html">http://jmlr.org/proceedings/papers/v28/goerg13.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XX &lt;- ts(diff(log(EuStockMarkets)))
Omega(XX)

plot(log10(lynx))
Omega(log10(lynx))

## Not run: 
ff &lt;- foreca(XX, n.comp = 4)
ff
plot(ff)
summary(ff)

## End(Not run)

</code></pre>

<hr>
<h2 id='foreca-utils'>Plot, summary, and print methods for class 'foreca'</h2><span id='topic+foreca-utils'></span><span id='topic+summary.foreca'></span><span id='topic+print.foreca'></span><span id='topic+biplot.foreca'></span><span id='topic+plot.foreca'></span>

<h3>Description</h3>

<p>A collection of S3 methods for estimated ForeCA results 
(class <code>"foreca"</code>).
</p>
<p><code>summary.foreca</code> computes summary statistics.
</p>
<p><code>print.foreca</code> prints a human-readable summary in the console.
</p>
<p><code>biplot.foreca</code> shows a biplot of the ForeCA loadings
(wrapper around <code><a href="stats.html#topic+biplot.princomp">biplot.princomp</a></code>).
</p>
<p><code>plot.foreca</code> shows biplots, screeplots, and white noise tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foreca'
summary(object, lag = 10, alpha = 0.05, ...)

## S3 method for class 'foreca'
print(x, ...)

## S3 method for class 'foreca'
biplot(x, ...)

## S3 method for class 'foreca'
plot(x, lag = 10, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreca-utils_+3A_lag">lag</code></td>
<td>
<p>integer; how many lags to test in <code>Box.test</code>; 
default: <code class="reqn">10</code>.</p>
</td></tr>
<tr><td><code id="foreca-utils_+3A_alpha">alpha</code></td>
<td>
<p>significance level for testing white noise in 
<code>Box.test</code>; default: <code class="reqn">0.05</code>.</p>
</td></tr>
<tr><td><code id="foreca-utils_+3A_...">...</code></td>
<td>
<p>additional arguments passed to 
<code><a href="stats.html#topic+biplot.princomp">biplot.princomp</a></code>, <code><a href="stats.html#topic+biplot">biplot</a></code>,
<code><a href="base.html#topic+plot">plot</a></code>, or <code><a href="base.html#topic+summary">summary</a></code>.</p>
</td></tr>
<tr><td><code id="foreca-utils_+3A_x">x</code>, <code id="foreca-utils_+3A_object">object</code></td>
<td>
<p>an object of class <code>"foreca"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># see examples in 'foreca'

</code></pre>

<hr>
<h2 id='foreca.EM-aux'>ForeCA EM auxiliary functions</h2><span id='topic+foreca.EM-aux'></span><span id='topic+foreca.EM.E_step'></span><span id='topic+foreca.EM.M_step'></span><span id='topic+foreca.EM.E_and_M_step'></span><span id='topic+foreca.EM.h'></span>

<h3>Description</h3>

<p><code>foreca.EM.one_weightvector</code> relies on several auxiliary functions:
</p>
<p><code>foreca.EM.E_step</code> computes the spectral density of 
<code class="reqn">y_t=\mathbf{U}_t \mathbf{w}</code> given the weightvector <code class="reqn">\mathbf{w}</code> 
and the normalized spectrum estimate <code class="reqn">f_{\mathbf{U}}</code>.
A wrapper around <code><a href="#topic+spectrum_of_linear_combination">spectrum_of_linear_combination</a></code>.
</p>
<p><code>foreca.EM.M_step</code> computes the minimizing eigenvector 
(<code class="reqn">\rightarrow \widehat{\mathbf{w}}_{i+1}</code>) of the weighted
covariance matrix, where the weights equal the negative logarithm of the 
spectral density at the current <code class="reqn">\widehat{\mathbf{w}}_i</code>.
</p>
<p><code>foreca.EM.E_and_M_step</code> is a wrapper around <code>foreca.EM.E_step</code>
followed by <code>foreca.EM.M_step</code>.
</p>
<p><code>foreca.EM.h</code> evaluates (an upper bound of) the entropy of the spectral density as a function
of <code class="reqn">\mathbf{w}_i</code> (or <code class="reqn">\mathbf{w}_{i+1}</code>). This is the objective funcion that should be 
<code>minimize</code>d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foreca.EM.E_step(f.U, weightvector)

foreca.EM.M_step(f.U, f.current, minimize = TRUE, entropy.control = list())

foreca.EM.E_and_M_step(
  weightvector,
  f.U,
  minimize = TRUE,
  entropy.control = list()
)

foreca.EM.h(
  weightvector.new,
  f.U,
  weightvector.current = weightvector.new,
  f.current = NULL,
  entropy.control = list(),
  return.negative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreca.EM-aux_+3A_f.u">f.U</code></td>
<td>
<p>multivariate spectrum of class <code>'mvspectrum'</code> with 
<code>normalize = TRUE</code>.</p>
</td></tr>
<tr><td><code id="foreca.EM-aux_+3A_weightvector">weightvector</code></td>
<td>
<p>numeric; weights <code class="reqn">\mathbf{w}</code> for 
<code class="reqn">y_t = \mathbf{U}_t \mathbf{w}</code>. Must have unit norm in <code class="reqn">\ell^2</code>.</p>
</td></tr>
<tr><td><code id="foreca.EM-aux_+3A_f.current">f.current</code></td>
<td>
<p>numeric; spectral density estimate of 
<code class="reqn">y_t=\mathbf{U}_t \mathbf{w}</code> for the current estimate 
<code class="reqn">\widehat{\mathbf{w}}_i</code> (required for 
<code>foreca.EM.M_step</code>; optional for <code>foreca.EM.h</code>).</p>
</td></tr>
<tr><td><code id="foreca.EM-aux_+3A_minimize">minimize</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) it returns the eigenvector
corresponding to the smallest eigenvalue; otherwise to the largest eigenvalue.</p>
</td></tr>
<tr><td><code id="foreca.EM-aux_+3A_entropy.control">entropy.control</code></td>
<td>
<p>list; control settings for entropy estimation.
See <code><a href="#topic+complete_entropy_control">complete_entropy_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="foreca.EM-aux_+3A_weightvector.new">weightvector.new</code></td>
<td>
<p>weightvector <code class="reqn">\widehat{\mathbf{w}}_{i+1}</code> of the new 
iteration (i+1).</p>
</td></tr>
<tr><td><code id="foreca.EM-aux_+3A_weightvector.current">weightvector.current</code></td>
<td>
<p>weightvector <code class="reqn">\widehat{\mathbf{w}}_{i}</code> of the 
current iteration (i).</p>
</td></tr>
<tr><td><code id="foreca.EM-aux_+3A_return.negative">return.negative</code></td>
<td>
<p>logical; if <code>TRUE</code> it returns the negative 
spectral entropy. This is useful when maximizing forecastibility which is 
equivalent (up to an additive constant) to maximizing negative entropy. 
Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>foreca.EM.E_step</code> returns the normalized univariate spectral 
density (normalized such that its <code>sum</code> equals <code class="reqn">0.5</code>).
</p>
<p><code>foreca.EM.M_step</code> returns a list with three elements:
</p>

<ul>
<li> <p><code>matrix</code>: weighted covariance matrix, where the weights are 
the negative log of the spectral density.  If density is estimated 
by discrete probabilities, 
then this <code>matrix</code> is positive semi-definite, since 
<code class="reqn">-\log(p) \geq 0</code> for <code class="reqn">p \in [0, 1]</code>. 
See <code><a href="#topic+weightvector2entropy_wcov">weightvector2entropy_wcov</a></code>.
</p>
</li>
<li> <p><code>vector</code>: minimizing (or maximizing if 
<code>minimize = FALSE</code>) eigenvector of <code>matrix</code>,
</p>
</li>
<li> <p><code>value</code>: corresponding eigenvalue.
</p>
</li></ul>

<p>Contrary to <code>foreca.EM.M_step</code>, <code>foreca.EM.E_and_M_step</code> only returns the optimal 
weightvector as a numeric.
</p>
<p><code>foreca.EM.h</code> returns non-negative real value (see References for details):
</p>

<ul>
<li><p> entropy, if <code>weightvector.new = weightvector.current</code>,
</p>
</li>
<li><p> an upper bound of that entropy for <code>weightvector.new</code>,
otherwise.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+weightvector2entropy_wcov">weightvector2entropy_wcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
XX &lt;- diff(log(EuStockMarkets)) * 100
UU &lt;- whiten(XX)$U
ff &lt;- mvspectrum(UU, 'mvspec', normalize = TRUE)

ww0 &lt;- initialize_weightvector(num.series = ncol(XX), method = 'rnorm')

f.ww0 &lt;- foreca.EM.E_step(ff, ww0)
plot(f.ww0, type = "l")

## End(Not run)
## Not run: 
one.step &lt;- foreca.EM.M_step(ff, f.ww0, 
                             entropy.control = list(prior.weight = 0.1))
image(one.step$matrix)

requireNamespace(LICORS)
# if you have the 'LICORS' package use
LICORS::image2(one.step$matrix)

ww1 &lt;- one.step$vector
f.ww1 &lt;- foreca.EM.E_step(ff, ww1)

layout(matrix(1:2, ncol = 2))
matplot(seq(0, pi, length = length(f.ww0)), cbind(f.ww0, f.ww1), 
        type = "l", lwd =2, xlab = "omega_j", ylab = "f(omega_j)")
plot(f.ww0, f.ww1, pch = ".", cex = 3, xlab = "iteration 0", 
     ylab = "iteration 1", main = "Spectral density")
abline(0, 1, col = 'blue', lty = 2, lwd = 2)

Omega(mvspectrum.output = f.ww0) # start
Omega(mvspectrum.output = f.ww1) # improved after one iteration

## End(Not run)
## Not run: 
ww0 &lt;- initialize_weightvector(NULL, ff, method = "rnorm")
ww1 &lt;- foreca.EM.E_and_M_step(ww0, ff)
ww0
ww1
barplot(rbind(ww0, ww1), beside = TRUE)
abline(h = 0, col = "blue", lty = 2)

## End(Not run)
## Not run: 
foreca.EM.h(ww0, ff)       # iteration 0
foreca.EM.h(ww1, ff, ww0)  # min eigenvalue inequality
foreca.EM.h(ww1, ff)       # KL divergence inequality
one.step$value

# by definition of Omega, they should equal 1 (modulo rounding errors)
Omega(mvspectrum.output = f.ww0) / 100 + foreca.EM.h(ww0, ff)
Omega(mvspectrum.output = f.ww1) / 100 + foreca.EM.h(ww1, ff)

## End(Not run)
</code></pre>

<hr>
<h2 id='foreca.EM.one_weightvector'>EM-like algorithm to estimate optimal ForeCA transformation</h2><span id='topic+foreca.EM.one_weightvector'></span>

<h3>Description</h3>

<p><code>foreca.EM.one_weightvector</code> finds the optimal weightvector <code class="reqn">\mathbf{w}^*</code>
that gives the most forecastable signal <code class="reqn">y_t^* = \mathbf{U}_t \mathbf{w}^*</code>
using an EM-like algorithm (see References).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foreca.EM.one_weightvector(
  U,
  f.U = NULL,
  spectrum.control = list(),
  entropy.control = list(),
  algorithm.control = list(),
  init.weightvector = initialize_weightvector(num.series = ncol(U), method = "rnorm"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreca.EM.one_weightvector_+3A_u">U</code></td>
<td>
<p>a <code class="reqn">T \times K</code> array with <code>T</code> observations from the 
<code class="reqn">K</code>-dimensional <strong>whitened</strong> (<code><a href="#topic+whiten">whiten</a></code>) 
time series <code class="reqn">\mathbf{U}_t</code>. Can be a <code>matrix</code>, <code>data.frame</code>, or a 
multivariate <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="foreca.EM.one_weightvector_+3A_f.u">f.U</code></td>
<td>
<p>multivariate spectrum of class <code>'mvspectrum'</code> with 
<code>normalize = TRUE</code>.</p>
</td></tr>
<tr><td><code id="foreca.EM.one_weightvector_+3A_spectrum.control">spectrum.control</code></td>
<td>
<p>list; control settings for spectrum estimation. 
See <code><a href="#topic+complete_spectrum_control">complete_spectrum_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="foreca.EM.one_weightvector_+3A_entropy.control">entropy.control</code></td>
<td>
<p>list; control settings for entropy estimation.
See <code><a href="#topic+complete_entropy_control">complete_entropy_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="foreca.EM.one_weightvector_+3A_algorithm.control">algorithm.control</code></td>
<td>
<p>list; control settings for any <em>iterative</em> ForeCA 
algorithm. See <code><a href="#topic+complete_algorithm_control">complete_algorithm_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="foreca.EM.one_weightvector_+3A_init.weightvector">init.weightvector</code></td>
<td>
<p>numeric; starting point <code class="reqn">\mathbf{w}_0</code> for several
iterative algorithms.  By default it uses a (normalized) random vector from a
standard Normal distribution (see <code><a href="#topic+initialize_weightvector">initialize_weightvector</a></code>).</p>
</td></tr>
<tr><td><code id="foreca.EM.one_weightvector_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+mvspectrum">mvspectrum</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with useful quantities like the optimal weighvector, the corresponding
signal, and its forecastability.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreca.one_weightvector">foreca.one_weightvector</a></code>, <code><a href="#topic+foreca.EM-aux">foreca.EM-aux</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
XX &lt;- diff(log(EuStockMarkets)[100:200,]) * 100
one.weight &lt;- foreca.EM.one_weightvector(whiten(XX)$U,
                                         spectrum.control =
                                            list(method = "mvspec"))

## End(Not run)

</code></pre>

<hr>
<h2 id='foreca.one_weightvector-utils'>Plot, summary, and print methods for class 'foreca.one_weightvector'</h2><span id='topic+foreca.one_weightvector-utils'></span><span id='topic+summary.foreca.one_weightvector'></span><span id='topic+plot.foreca.one_weightvector'></span>

<h3>Description</h3>

<p>S3 methods for the one weightvector optimization in ForeCA 
(class <code>"foreca.one_weightvector"</code>).
</p>
<p><code>summary.foreca.one_weightvector</code> computes summary statistics.
</p>
<p><code>plot.foreca.one_weightvector</code> shows the results of an (iterative) 
algorithm that obtained the i-th optimal a weightvector 
<code class="reqn">\mathbf{w}_i^*</code>.  It 
shows trace plots of the objective function and the weightvector, and a time series
plot of the transformed signal <code class="reqn">y_t^*</code> along with its spectral density estimate 
<code class="reqn">\widehat{f}_y(\omega_j)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foreca.one_weightvector'
summary(object, lag = 10, alpha = 0.05, ...)

## S3 method for class 'foreca.one_weightvector'
plot(x, main = "", cex.lab = 1.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreca.one_weightvector-utils_+3A_lag">lag</code></td>
<td>
<p>integer; how many lags to test in <code>Box.test</code>; 
default: <code class="reqn">10</code>.</p>
</td></tr>
<tr><td><code id="foreca.one_weightvector-utils_+3A_alpha">alpha</code></td>
<td>
<p>significance level for testing white noise in 
<code>Box.test</code>; default: <code class="reqn">0.05</code>.</p>
</td></tr>
<tr><td><code id="foreca.one_weightvector-utils_+3A_...">...</code></td>
<td>
<p>additional arguments passed to 
<code><a href="base.html#topic+plot">plot</a></code>, or <code><a href="base.html#topic+summary">summary</a></code>.</p>
</td></tr>
<tr><td><code id="foreca.one_weightvector-utils_+3A_x">x</code>, <code id="foreca.one_weightvector-utils_+3A_object">object</code></td>
<td>
<p>an object of class <code>"foreca.one_weightvector"</code>.</p>
</td></tr>
<tr><td><code id="foreca.one_weightvector-utils_+3A_main">main</code></td>
<td>
<p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="foreca.one_weightvector-utils_+3A_cex.lab">cex.lab</code></td>
<td>
<p>size of the axes labels.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># see examples in 'foreca.one_weightvector'

</code></pre>

<hr>
<h2 id='initialize_weightvector'>Initialize weightvector for iterative ForeCA algorithms</h2><span id='topic+initialize_weightvector'></span>

<h3>Description</h3>

<p><code>initialize_weightvector</code> returns a unit norm (in <code class="reqn">\ell^2</code>)
vector <code class="reqn">\mathbf{w}_0 \in R^K</code> that can be used as the starting
point for any iterative ForeCA algorithm, e.g., 
<code><a href="#topic+foreca.EM.one_weightvector">foreca.EM.one_weightvector</a></code>. Several 
quickly computable heuristics are available via the <code>method</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize_weightvector(
  U = NULL,
  f.U = NULL,
  num.series = ncol(U),
  method = c("rnorm", "max", "SFA", "PCA", "rcauchy", "runif", "SFA.slow", "SFA.fast",
    "PCA.large", "PCA.small"),
  seed = sample(1e+06, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_weightvector_+3A_u">U</code></td>
<td>
<p>a <code class="reqn">T \times K</code> array with <code>T</code> observations from the 
<code class="reqn">K</code>-dimensional <strong>whitened</strong> (<code><a href="#topic+whiten">whiten</a></code>) 
time series <code class="reqn">\mathbf{U}_t</code>. Can be a <code>matrix</code>, <code>data.frame</code>, or a 
multivariate <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="initialize_weightvector_+3A_f.u">f.U</code></td>
<td>
<p>multivariate spectrum of class <code>'mvspectrum'</code> with 
<code>normalize = TRUE</code>.</p>
</td></tr>
<tr><td><code id="initialize_weightvector_+3A_num.series">num.series</code></td>
<td>
<p>positive integer; number of time series <code class="reqn">K</code> (determines the length 
of the weightvector). If <code>num.series = 1</code> it simply returns
a 1 <code class="reqn">\times</code> 1 array equal to <code>1</code>.</p>
</td></tr>
<tr><td><code id="initialize_weightvector_+3A_method">method</code></td>
<td>
<p>string; which heuristics should be used to generate a good starting <code class="reqn">\mathbf{w}_0</code>?
Default: <code>"rnorm"</code>; see Details.</p>
</td></tr>
<tr><td><code id="initialize_weightvector_+3A_seed">seed</code></td>
<td>
<p>non-negative integer; seed for random initialization which will be 
returned for reproducibility. By default it sets a random seed.</p>
</td></tr>
<tr><td><code id="initialize_weightvector_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>method</code> argument specifies the heuristics that is used to get a good
starting vector <code class="reqn">\mathbf{w}_0</code>:
</p>

<ul>
<li><p><code>"max"</code> vector with all <code class="reqn">0</code>s, but a <code class="reqn">1</code> at the position
of the maximum forecastable series in <code>U</code>.
</p>
</li>
<li><p><code>"rcauchy"</code> random start using <code>rcauchy(k)</code>.
</p>
</li>
<li><p><code>"rnorm"</code> random start using <code>rnorm(k, 0, 1)</code>.
</p>
</li>
<li><p><code>"runif"</code> random start using <code>runif(k, -1, 1)</code>.
</p>
</li>
<li><p><code>"PCA.large"</code> first eigenvector of PCA (largest variance signal).
</p>
</li>
<li><p><code>"PCA.small"</code> last eigenvector of PCA (smallest variance signal).
</p>
</li>
<li><p><code>"PCA"</code> checks both small and large, and chooses the one with higher
forecastability as computed by <code><a href="#topic+Omega">Omega</a></code>..
</p>
</li>
<li><p><code>"SFA.fast"</code> last eigenvector of SFA (fastest signal).
</p>
</li>
<li><p><code>"SFA.slow"</code> first eigenvector of SFA (slowest signal).
</p>
</li>
<li><p><code>"SFA"</code> checks both slow and fast, and chooses the one with higher
forecastability as computed by <code><a href="#topic+Omega">Omega</a></code>.
</p>
</li></ul>
 
<p>Each vector has length K and is automatically normalized to have unit norm 
in <code class="reqn">\ell^2</code>.
</p>
<p>For the <code>'SFA*'</code> methods see <code><a href="#topic+sfa">sfa</a></code>. 
Note that maximizing (or minimizing) the lag <code class="reqn">1</code> auto-correlation does 
not necessarily yield the most forecastable signal, but it's a good start.
</p>


<h3>Value</h3>

<p>numeric; a vector of length <code class="reqn">K</code> with unit norm in <code class="reqn">\ell^2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XX &lt;- diff(log(EuStockMarkets))
## Not run: 
initialize_weightvector(U = XX, method = "SFA")

## End(Not run)
initialize_weightvector(num.series = ncol(XX), method = "rnorm")
</code></pre>

<hr>
<h2 id='mvspectrum'>Estimates spectrum of multivariate time series</h2><span id='topic+mvspectrum'></span><span id='topic+normalize_mvspectrum'></span><span id='topic+check_mvspectrum_normalized'></span><span id='topic+mvpgram'></span><span id='topic+get_spectrum_from_mvspectrum'></span><span id='topic+spectrum_of_linear_combination'></span>

<h3>Description</h3>

<p>The spectrum of a multivariate time series is a matrix-valued function of the 
frequency <code class="reqn">\lambda \in [-\pi, \pi]</code>, which is symmetric/Hermitian around 
<code class="reqn">\lambda = 0</code>.
</p>
<p><code>mvspectrum</code> estimates it and returns a 3D array of dimension 
<code class="reqn">num.freqs \times K \times K</code>.  Since the spectrum is symmetric/Hermitian around
<code class="reqn">\lambda = 0</code> it is sufficient to store only positive frequencies.  
In the implementation in this package we thus usually 
consider only positive frequencies (omitting <code class="reqn">0</code>); <code>num.freqs</code> refers
to the number of positive frequencies only.
</p>
<p><code>normalize_mvspectrum</code> normalizes the spectrum such that
it adds up to <code class="reqn">0.5</code> over all positive frequencies (by symmetry it will 
add up to 1 over the whole range &ndash; thus the name <em>normalize</em>). 
</p>
<p>For a <code class="reqn">K</code>-dimensional time series it adds
up to a Hermitian <code class="reqn">K \times K</code> matrix with 0.5 in the diagonal and
imaginary elements (real parts equal to <code class="reqn">0</code>) in the off-diagonal. 
Since it is Hermitian the mvspectrum will add up to the identity matrix
over the whole range of frequencies, since the off-diagonal elements
are purely imaginary (real part equals 0) and thus add up to 0.
</p>
<p><code>check_mvspectrum_normalized</code> checks if the spectrum is normalized 
(see <code><a href="#topic+normalize_mvspectrum">normalize_mvspectrum</a></code> for the requirements).
</p>
<p><code>mvpgram</code> computes the multivariate periodogram estimate using
bare-bone multivariate fft (<code><a href="stats.html#topic+fft">mvfft</a></code>). Use
<code>mvspectrum(..., method = 'pgram')</code> instead of <code>mvpgram</code> directly.
</p>
<p>This function is merely included to have one method that does not
require the <span class="pkg">astsa</span> nor the <span class="pkg">sapa</span> R packages.  However, 
it is strongly encouraged to install either one of them to get (much)
better estimates.  See Details.
</p>
<p><code>get_spectrum_from_mvspectrum</code> extracts the spectrum of one time series from an
<code>"mvspectrum"</code> object by taking the i-th diagonal entry for each frequency.
</p>
<p><code>spectrum_of_linear_combination</code> computes the spectrum of the linear
combination  <code class="reqn">\mathbf{y}_t = \mathbf{X}_t \boldsymbol \beta</code> of <code class="reqn">K</code> 
time series <code class="reqn">\mathbf{X}_t</code>.  This can be efficiently computed by the 
quadratic form
</p>
<p style="text-align: center;"><code class="reqn">
  f_{y}(\lambda) = \boldsymbol \beta' f_{\mathbf{X}}(\lambda) \boldsymbol \beta \geq 0,
</code>
</p>

<p>for each <code class="reqn">\lambda</code>. This holds for any <code class="reqn">\boldsymbol \beta</code> 
(even <code class="reqn">\boldsymbol \beta = \boldsymbol 0</code> &ndash; not only for 
<code class="reqn">||\boldsymbol \beta ||_2 = 1</code>.
For <code class="reqn">\boldsymbol \beta = \boldsymbol e_i</code> (the i-th basis vector) 
this is equivalent to <code>get_spectrum_from_mvspectrum(..., which = i)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvspectrum(
  series,
  method = c("mvspec", "pgram", "pspectrum", "ar"),
  normalize = FALSE,
  smoothing = FALSE,
  ...
)

normalize_mvspectrum(mvspectrum.output)

check_mvspectrum_normalized(f.U, check.attribute.only = TRUE)

mvpgram(series)

get_spectrum_from_mvspectrum(
  mvspectrum.output,
  which = seq_len(dim(mvspectrum.output)[2])
)

spectrum_of_linear_combination(mvspectrum.output, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvspectrum_+3A_series">series</code></td>
<td>
<p>a <code class="reqn">T \times K</code> array with <code>T</code> observations from the 
<code class="reqn">K</code>-dimensional time series <code class="reqn">\mathbf{X}_t</code>. Can be a <code>matrix</code>, <code>data.frame</code>, 
or a multivariate <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="mvspectrum_+3A_method">method</code></td>
<td>
<p>string; method for spectrum estimation: use <code>"pspectrum"</code> for
<code><a href="psd.html#topic+pspectrum">pspectrum</a></code>; use 
<code>"mvspec"</code> to use <code><a href="astsa.html#topic+mvspec">mvspec</a></code> (<span class="pkg">astsa</span> package); or
use <code>"pgram"</code> to use <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>.</p>
</td></tr>
<tr><td><code id="mvspectrum_+3A_normalize">normalize</code></td>
<td>
<p>logical; if <code>TRUE</code> the spectrum will be normalized (see 
Value below for details).</p>
</td></tr>
<tr><td><code id="mvspectrum_+3A_smoothing">smoothing</code></td>
<td>
<p>logical; if <code>TRUE</code> the spectrum will be
smoothed with a nonparametric estimate using <code><a href="mgcv.html#topic+gam">gam</a></code> 
and an exponential family (with <code>link = log</code>). Only works
for univariate spectrum. The smoothing
parameter is chosen automatically using generalized cross-validation 
(see <code><a href="mgcv.html#topic+gam">gam</a></code> for details). Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mvspectrum_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="psd.html#topic+pspectrum">pspectrum</a></code> or 
<code><a href="astsa.html#topic+mvspec">mvspec</a></code> (e.g., <code>taper</code>)</p>
</td></tr>
<tr><td><code id="mvspectrum_+3A_mvspectrum.output">mvspectrum.output</code></td>
<td>
<p>an object of class <code>"mvspectrum"</code> representing
the multivariate spectrum of <code class="reqn">\mathbf{X}_t</code> (not necessarily <code>normalize</code>d).</p>
</td></tr>
<tr><td><code id="mvspectrum_+3A_f.u">f.U</code></td>
<td>
<p>multivariate spectrum of class <code>'mvspectrum'</code> with 
<code>normalize = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mvspectrum_+3A_check.attribute.only">check.attribute.only</code></td>
<td>
<p>logical; if <code>TRUE</code> it checks the 
attribute only.  This is much faster (it just needs to look up one attribute
value), but it might not surface silent bugs.  For sake of performance
the package uses the attribute version by default.  However, for 
testing/debugging the full computational version can be used.</p>
</td></tr>
<tr><td><code id="mvspectrum_+3A_which">which</code></td>
<td>
<p>integer(s); the spectrum of which series whould be extracted. By default,
it returns all univariate spectra as a matrix (frequencies in rows).</p>
</td></tr>
<tr><td><code id="mvspectrum_+3A_beta">beta</code></td>
<td>
<p>numeric; vector <code class="reqn">\boldsymbol \beta</code> that defines the linear
combination.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an orthonormal time series <code class="reqn">\mathbf{U}_t</code> the raw periodogram adds up 
to <code class="reqn">I_K</code> 
over all (negative and positive) frequencies.  Since we only consider
positive frequencies, the normalized multivariate spectrum should add up to
<code class="reqn">0.5 \cdot I_K</code> plus a Hermitian imaginary matrix (which will add up to zero
when combined with its symmetric counterpart.)
As we often use non-parametric smoothing for less variance, the spectrum estimates
do not satisfy this identity exactly. <code>normalize_mvspectrum</code> thus adjust the 
estimates so they satisfy it again exactly.
</p>
<p><code>mvpgram</code> has no options for improving spectrum estimation whatsoever.
It thus yields very noisy (in fact, inconsistent) estimates of the 
multivariate spectrum <code class="reqn">f_{\mathbf{X}}(\lambda)</code>. 
If you want to obtain better estimates then please use other <code>method</code>s in
<code><a href="#topic+mvspectrum">mvspectrum</a></code> (this is highly recommended to obtain more 
reasonable/stable estimates).
</p>


<h3>Value</h3>

<p><code>mvspectrum</code> returns a 3D array of dimension <code class="reqn">num.freqs \times K \times K</code>, where
</p>

<ul>
<li><p> num.freqs is the number of frequencies
</p>
</li>
<li><p> K is the number of series (columns in <code>series</code>).
</p>
</li></ul>

<p>It also has an <code>"normalized"</code> attribute, which is
<code>FALSE</code> if <code>normalize = FALSE</code>; otherwise <code>TRUE</code>.
See <code>normalize_mvspectrum</code> for details.
</p>
<p><code>normalize_mvspectrum</code> returns a normalized spectrum over 
positive frequencies, which:
</p>

<dl>
<dt>univariate:</dt><dd><p>adds up to <code class="reqn">0.5</code>,</p>
</dd>
<dt>multivariate:</dt><dd><p>adds up to Hermitian <code class="reqn">K \times K</code> matrix
with 0.5 in the diagonal and purely imaginary elements in the off-diagonal.</p>
</dd> 
</dl>

<p><code>check_mvspectrum_normalized</code> throws an error if spectrum is not
normalized correctly.
</p>
<p><code>get_spectrum_from_mvspectrum</code> returns either a matrix of all univariate spectra,
or one single column (if <code>which</code> is specified.)
</p>
<p><code>spectrum_of_linear_combination</code> returns a vector with length equal to 
the number of rows of <code>mvspectrum.output</code>.
</p>


<h3>References</h3>

<p>See References in <code><a href="stats.html#topic+spectrum">spectrum</a></code>, <code><a href="psd.html#topic+pspectrum">pspectrum</a></code>, 
<code><a href="astsa.html#topic+mvspec">mvspec</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
XX &lt;- cbind(rnorm(100), arima.sim(n = 100, list(ar = 0.9)))
ss3d &lt;- mvspectrum(XX)
dim(ss3d)

ss3d[2,,] # at omega_1; in general complex-valued, but Hermitian
identical(ss3d[2,,], Conj(t(ss3d[2,,]))) # is Hermitian
## Not run: 
  ss &lt;- mvspectrum(XX[, 1], method="pspectrum", smoothing = TRUE)
  mvspectrum(XX, normalize = TRUE)

## End(Not run)
ss &lt;- mvspectrum(whiten(XX)$U, normalize = TRUE)

xx &lt;- scale(rnorm(100), center = TRUE, scale = FALSE)
var(xx)
sum(mvspectrum(xx, normalize = FALSE, method = "pgram")) * 2
sum(mvspectrum(xx, normalize = FALSE, method = "mvspec")) * 2
## Not run: 
  sum(mvspectrum(xx, normalize = FALSE, method = "pspectrum")) * 2

## End(Not run)
## Not run: 
xx &lt;- scale(rnorm(100), center = TRUE, scale = FALSE)
ss &lt;- mvspectrum(xx)
ss.n &lt;- normalize_mvspectrum(ss)
sum(ss.n)
# multivariate
UU &lt;- whiten(matrix(rnorm(40), ncol = 2))$U
S.U &lt;- mvspectrum(UU, method = "mvspec")
mvspectrum2wcov(normalize_mvspectrum(S.U))

## End(Not run)

XX &lt;- matrix(rnorm(1000), ncol = 2)
SS &lt;- mvspectrum(XX, "mvspec")
ss1 &lt;- mvspectrum(XX[, 1], "mvspec")

SS.1 &lt;- get_spectrum_from_mvspectrum(SS, 1)
plot.default(ss1, SS.1)
abline(0, 1, lty = 2, col = "blue")


XX &lt;- matrix(arima.sim(n = 1000, list(ar = 0.9)), ncol = 4)
beta.tmp &lt;- rbind(1, -1, 2, 0)
yy &lt;- XX %*% beta.tmp

SS &lt;- mvspectrum(XX, "mvspec")
ss.yy.comb &lt;- spectrum_of_linear_combination(SS, beta.tmp)
ss.yy &lt;- mvspectrum(yy, "mvspec")

plot(ss.yy, log = TRUE) # using plot.mvspectrum()
lines(ss.yy.comb, col = "red", lty = 1, lwd = 2) 

</code></pre>

<hr>
<h2 id='mvspectrum-utils'>S3 methods for class 'mvspectrum'</h2><span id='topic+mvspectrum-utils'></span><span id='topic+plot.mvspectrum'></span>

<h3>Description</h3>

<p>S3 methods for multivariate spectrum estimation.
</p>
<p><code>plot.mvspectrum</code> plots all univariate spectra. Analogouos to 
<code><a href="stats.html#topic+spectrum">spectrum</a></code> when <code>plot = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvspectrum'
plot(x, log = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvspectrum-utils_+3A_x">x</code></td>
<td>
<p>an object of class <code>"foreca.one_weightvector"</code>.</p>
</td></tr>
<tr><td><code id="mvspectrum-utils_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), it plots the spectra on 
log-scale.</p>
</td></tr>
<tr><td><code id="mvspectrum-utils_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+get_spectrum_from_mvspectrum">get_spectrum_from_mvspectrum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see examples in 'mvspectrum'

SS &lt;- mvspectrum(diff(log(EuStockMarkets)) * 100, 
                 spectrum.control = list(method = "mvspec"))
plot(SS, log = FALSE)

</code></pre>

<hr>
<h2 id='mvspectrum2wcov'>Compute (weighted) covariance matrix from frequency spectrum</h2><span id='topic+mvspectrum2wcov'></span><span id='topic+weightvector2entropy_wcov'></span>

<h3>Description</h3>

<p><code>mvspectrum2wcov</code> computes a (weighted) covariance matrix estimate 
from the frequency spectrum (see Details).
</p>
<p><code>weightvector2entropy_wcov</code> computes the weighted covariance
matrix using the negative entropy of the univariate spectrum (given the
weightvector) as kernel weights.  This matrix is the objective matrix
for many <code>foreca.*</code> algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvspectrum2wcov(mvspectrum.output, kernel.weights = 1)

weightvector2entropy_wcov(
  weightvector = NULL,
  f.U,
  f.current = NULL,
  entropy.control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvspectrum2wcov_+3A_mvspectrum.output">mvspectrum.output</code></td>
<td>
<p>an object of class <code>"mvspectrum"</code> representing
the multivariate spectrum of <code class="reqn">\mathbf{X}_t</code> (not necessarily <code>normalize</code>d).</p>
</td></tr>
<tr><td><code id="mvspectrum2wcov_+3A_kernel.weights">kernel.weights</code></td>
<td>
<p>numeric; weights for each frequency. By default uses 
weights that average out to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mvspectrum2wcov_+3A_weightvector">weightvector</code></td>
<td>
<p>numeric; weights <code class="reqn">\mathbf{w}</code> for 
<code class="reqn">y_t = \mathbf{U}_t \mathbf{w}</code>. Must have unit norm in <code class="reqn">\ell^2</code>.</p>
</td></tr>
<tr><td><code id="mvspectrum2wcov_+3A_f.u">f.U</code></td>
<td>
<p>multivariate spectrum of class <code>'mvspectrum'</code> with 
<code>normalize = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mvspectrum2wcov_+3A_f.current">f.current</code></td>
<td>
<p>numeric; spectral density estimate of 
<code class="reqn">y_t=\mathbf{U}_t \mathbf{w}</code> for the current estimate 
<code class="reqn">\widehat{\mathbf{w}}_i</code> (required for 
<code>foreca.EM.M_step</code>; optional for <code>foreca.EM.h</code>).</p>
</td></tr>
<tr><td><code id="mvspectrum2wcov_+3A_entropy.control">entropy.control</code></td>
<td>
<p>list; control settings for entropy estimation.
See <code><a href="#topic+complete_entropy_control">complete_entropy_control</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance matrix of a multivariate time series satisfies the identity
</p>
<p style="text-align: center;"><code class="reqn">
\Sigma_{X} \equiv \int_{-\pi}^{\pi} S_{X}(\lambda) d \lambda.
</code>
</p>

<p>A generalized covariance matrix estimate can thus be obtained using a weighted average
</p>
<p style="text-align: center;"><code class="reqn">
\tilde{\Sigma}_X = \int_{-\pi}^{\pi} K(\lambda) S_{X}(\lambda) d \lambda,
</code>
</p>

<p>where <code class="reqn">K(\lambda)</code> is a kernel symmetric around <code class="reqn">0</code> which averages out to
<code class="reqn">1</code> over the interval <code class="reqn">[-\pi, \pi]</code>, i.e.,
<code class="reqn">\frac{1}{2 \pi} \int_{-\pi}^{\pi} K(\lambda) d \lambda = 1</code>. 
This allows one to remove or amplify specific frequencies in the covariance matrix 
estimation.
</p>
<p>For ForeCA <code>mvspectrum2wcov</code> is especially important as we use
</p>
<p style="text-align: center;"><code class="reqn">
K(\lambda) = -\log f_y(\lambda),
</code>
</p>

<p>as the <em>weights</em> (their average is not <code class="reqn">1</code>!).  This particular kernel
weight is implemented as a wrapper in <code>weightvector2entropy_wcov</code>.
</p>


<h3>Value</h3>

<p>A symmetric <code class="reqn">n \times n</code> matrix.
</p>
<p>If <code>kernel.weights</code> <code class="reqn">\geq 0</code>, then it is positive semi-definite;
otherwise, it is symmetric but not necessarily positive semi-definite.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvspectrum">mvspectrum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nn &lt;- 50
YY &lt;- cbind(rnorm(nn), arima.sim(n = nn, list(ar = 0.9)), rnorm(nn))
XX &lt;- YY %*% matrix(rnorm(9), ncol = 3)  # random mix
XX &lt;- scale(XX, scale = FALSE, center = TRUE)

# sample estimate of covariance matrix
Sigma.hat &lt;- cov(XX)
dimnames(Sigma.hat) &lt;- NULL

# using the frequency spectrum
SS &lt;- mvspectrum(XX, "mvspec")
Sigma.hat.freq &lt;- mvspectrum2wcov(SS)

layout(matrix(1:4, ncol = 2))
par(mar = c(2, 2, 1, 1))
plot(c(Sigma.hat/Sigma.hat.freq))
abline(h = 1)

image(Sigma.hat)
image(Sigma.hat.freq)
image(Sigma.hat / Sigma.hat.freq)

# examples for entropy wcov
XX &lt;- diff(log(EuStockMarkets)) * 100
UU &lt;- whiten(XX)$U
ff &lt;- mvspectrum(UU, "mvspec", normalize = TRUE)

ww0 &lt;- initialize_weightvector(num.series = ncol(XX), method = 'rnorm')

weightvector2entropy_wcov(ww0, ff,
                          entropy.control = 
                            list(prior.weight = 0.1))
</code></pre>

<hr>
<h2 id='Omega'>Estimate forecastability of a time series</h2><span id='topic+Omega'></span>

<h3>Description</h3>

<p>An estimator for the forecastability <code class="reqn">\Omega(x_t)</code> of a univariate time series <code class="reqn">x_t</code>.
Currently it uses a discrete plug-in estimator given the empirical spectrum (periodogram).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Omega(
  series = NULL,
  spectrum.control = list(),
  entropy.control = list(),
  mvspectrum.output = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Omega_+3A_series">series</code></td>
<td>
<p>a univariate time series; if it is multivariate, then
<code><a href="#topic+Omega">Omega</a></code> works component-wise (i.e., same as <code>apply(series, 2, Omega)</code>).</p>
</td></tr>
<tr><td><code id="Omega_+3A_spectrum.control">spectrum.control</code></td>
<td>
<p>list; control settings for spectrum estimation. 
See <code><a href="#topic+complete_spectrum_control">complete_spectrum_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="Omega_+3A_entropy.control">entropy.control</code></td>
<td>
<p>list; control settings for entropy estimation.
See <code><a href="#topic+complete_entropy_control">complete_entropy_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="Omega_+3A_mvspectrum.output">mvspectrum.output</code></td>
<td>
<p>an object of class <code>"mvspectrum"</code> representing
the multivariate spectrum of <code class="reqn">\mathbf{X}_t</code> (not necessarily <code>normalize</code>d).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>forecastability</em> of a stationary process <code class="reqn">x_t</code> is defined as
(see References)
</p>
<p style="text-align: center;"><code class="reqn">
\Omega(x_t) = 1 - \frac{ - \int_{-\pi}^{\pi} f_x(\lambda) \log f_x(\lambda) d \lambda }{\log 2 \pi} \in [0, 1]
</code>
</p>

<p>where <code class="reqn">f_x(\lambda)</code> is the normalized spectral <em>density</em> of <code class="reqn">x_t</code>.
In particular <code class="reqn"> \int_{-\pi}^{\pi} f_x(\lambda) d\lambda = 1</code>.
</p>
<p>For white noise <code class="reqn">\varepsilon_t</code> forecastability
<code class="reqn">\Omega(\varepsilon_t) = 0</code>; for a sum of sinusoids it equals <code class="reqn">100</code> %.
However, empirically it reaches <code class="reqn">100\%</code> only if the estimated spectrum has
exactly one peak at some <code class="reqn">\omega_j</code> and <code class="reqn">\widehat{f}(\omega_k) = 0</code>
for all <code class="reqn">k\neq j</code>.
</p>
<p>In practice, a time series of length <code>T</code> has <code class="reqn">T</code> Fourier frequencies
which represent a discrete
probability distribution.  Hence entropy of <code class="reqn">f_x(\lambda)</code> must be
normalized by <code class="reqn">\log T</code>, not by <code class="reqn">\log 2 \pi</code>.
</p>
<p>Also we can use several smoothing techniques to obtain a less variance estimate of
<code class="reqn">f_x(\lambda)</code>.
</p>


<h3>Value</h3>

<p>A real-value between <code class="reqn">0</code> and <code class="reqn">100</code> (%). <code class="reqn">0</code> means not
forecastable (white noise); <code class="reqn">100</code> means perfectly forecastable (a
sinusoid).
</p>


<h3>References</h3>

<p>Goerg, G. M. (2013). &ldquo;Forecastable Component
Analysis&rdquo;. Journal of Machine Learning Research (JMLR) W&amp;CP 28 (2): 64-72, 2013.
Available at <a href="http://jmlr.org/proceedings/papers/v28/goerg13.html">http://jmlr.org/proceedings/papers/v28/goerg13.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectral_entropy">spectral_entropy</a></code>, <code><a href="#topic+discrete_entropy">discrete_entropy</a></code>,
<code><a href="#topic+continuous_entropy">continuous_entropy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nn &lt;- 100
eps &lt;- rnorm(nn)  # white noise has Omega() = 0 in theory
Omega(eps, spectrum.control = list(method = "pgram"))
# smoothing makes it closer to 0
Omega(eps, spectrum.control = list(method = "mvspec"))

xx &lt;- sin(seq_len(nn) * pi / 10)
Omega(xx, spectrum.control = list(method = "pgram"))
Omega(xx, entropy.control = list(threshold = 1/40))
Omega(xx, spectrum.control = list(method = "mvspec"),
      entropy.control = list(threshold = 1/20))

# an AR(1) with phi = 0.5
yy &lt;- arima.sim(n = nn, model = list(ar = 0.5))
Omega(yy, spectrum.control = list(method = "mvspec"))

# an AR(1) with phi = 0.9 is more forecastable
yy &lt;- arima.sim(n = nn, model = list(ar = 0.9))
Omega(yy, spectrum.control = list(method = "mvspec"))

</code></pre>

<hr>
<h2 id='quadratic_form'>Computes quadratic form x' A x</h2><span id='topic+quadratic_form'></span><span id='topic+fill_hermitian'></span>

<h3>Description</h3>

<p><code>quadratic_form</code> computes the quadratic form <code class="reqn">\mathbf{x}' \mathbf{A} \mathbf{x}</code> for an
<code class="reqn">n \times n</code> matrix <code class="reqn">\mathbf{A}</code> and an <code class="reqn">n</code>-dimensional vector
<code class="reqn">\mathbf{x}</code>, i.e., a wrapper for <code>t(x) %*% A %*% x</code>. 
</p>
<p><code>fill_symmetric</code> and <code>quadratic_form</code> work with 
real and complex valued matrices/vectors.
</p>
<p><code>fill_hermitian</code> fills up the lower triangular part (<code>NA</code>)
of an upper triangular matrix to its
Hermitian (symmetric if real matrix) version, such that it satisfies 
<code class="reqn">\mathbf{A} = \bar{\mathbf{A}}'</code>, where <code class="reqn">\bar{z}</code> is the complex
conjugate of <code class="reqn">z</code>.  If the matrix is real-valued this makes it 
simply symmetric.
</p>
<p>Note that the input matrix must have a <strong>real-valued</strong> diagonal and 
<code>NA</code>s in the lower triangular part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadratic_form(mat, vec)

fill_hermitian(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadratic_form_+3A_mat">mat</code></td>
<td>
<p>numeric; <code class="reqn">n \times n</code> matrix (real or complex).</p>
</td></tr>
<tr><td><code id="quadratic_form_+3A_vec">vec</code></td>
<td>
<p>numeric; <code class="reqn">n \times 1</code> vector (real or complex).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real/complex value <code class="reqn">\mathbf{x}' \mathbf{A} \mathbf{x}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 set.seed(1)
 AA &lt;- matrix(1:4, ncol = 2)
 bb &lt;- matrix(rnorm(2))
 t(bb) %*% AA %*% bb
 quadratic_form(AA, bb)

## End(Not run)


AA &lt;- matrix(1:16, ncol = 4)
AA[lower.tri(AA)] &lt;- NA
AA

fill_hermitian(AA)

</code></pre>

<hr>
<h2 id='sfa'>Slow Feature Analysis</h2><span id='topic+sfa'></span>

<h3>Description</h3>

<p><code>sfa</code> performs Slow Feature Analysis (SFA) on a 
<code class="reqn">K</code>-dimensional time series with <code class="reqn">T</code> observations.
</p>
<p><strong>Important:</strong> This implementation of SFA is just the most basic
version; it is merely included here for convenience in 
<code><a href="#topic+initialize_weightvector">initialize_weightvector</a></code>.  If you want to actually use full functionality of SFA in R 
use the <span class="pkg">rSFA</span> package, which has a much more advanced and efficient implementations.
<code>sfa()</code> here corresponds to <code><a href="rSFA.html#topic+sfa1">sfa1</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfa(series, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfa_+3A_series">series</code></td>
<td>
<p>a <code class="reqn">T \times K</code> array with <code>T</code> observations from the 
<code class="reqn">K</code>-dimensional time series <code class="reqn">\mathbf{X}_t</code>. Can be a <code>matrix</code>, <code>data.frame</code>, 
or a multivariate <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="sfa_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Slow Feature Analysis (SFA) finds <em>slow</em> signals (see References below). The problem has an
analytic solution and thus can be computed quickly using generalized eigen-value solvers.
For ForeCA it is important to know that SFA is equivalent to
finding a linear combination signal with largest lag <code class="reqn">1</code> autocorrelation.
</p>
<p>The disadvantage of SFA for forecasting is that, e.g., white noise (WN) 
is ranked higher than an AR(1) with negative autocorrelation coefficient 
<code class="reqn">\rho_1 &lt; 0</code>.  While it is true that WN is slower, it is not more 
forecastable.  Thus we are also interested in the fastest signal, i.e.,
the last eigenvector. The so obtained fastest signal corresponds to minimizing
the lag 1 auto-correlation (possibly <code class="reqn">\rho_1 &lt; 0</code>).
</p>
<p>Note though that maximizing (or minimizing) the lag <code class="reqn">1</code> auto-correlation does 
not necessarily yield the most forecastable signal (as measured 
by <code><a href="#topic+Omega">Omega</a></code>), but it is a good start.
</p>


<h3>Value</h3>

<p>An object of class <code>sfa</code> which inherits methods from <code><a href="stats.html#topic+princomp">princomp</a></code>.
Signals are ordered from slowest to fastest.
</p>


<h3>References</h3>

<p>Laurenz Wiskott and Terrence J. Sejnowski (2002). 
&ldquo;Slow Feature Analysis: Unsupervised Learning of Invariances&rdquo;, 
Neural Computation 14:4, 715-770.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initialize_weightvector">initialize_weightvector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XX &lt;- diff(log(EuStockMarkets[-c(1:100),])) * 100
plot(ts(XX))
ss &lt;- sfa(XX[,1:4])

summary(ss)
plot(ss)
plot(ts(ss$scores))
apply(ss$scores, 2, function(x) acf(x, plot = FALSE)$acf[2])
biplot(ss)

</code></pre>

<hr>
<h2 id='spectral_entropy'>Estimates spectral entropy of a time series</h2><span id='topic+spectral_entropy'></span>

<h3>Description</h3>

<p>Estimates <em>spectral entropy</em> from a univariate (or multivariate) 
normalized spectral density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_entropy(
  series = NULL,
  spectrum.control = list(),
  entropy.control = list(),
  mvspectrum.output = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_entropy_+3A_series">series</code></td>
<td>
<p>univariate time series of length <code class="reqn">T</code>.  In the rare case
that users want to call this for a multivariate time <code>series</code>, note 
that the estimated spectrum is in general <em>not</em> normalized for the computation. 
Only if the original data is whitened, then it is normalized.</p>
</td></tr>
<tr><td><code id="spectral_entropy_+3A_spectrum.control">spectrum.control</code></td>
<td>
<p>list; control settings for spectrum estimation. 
See <code><a href="#topic+complete_spectrum_control">complete_spectrum_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="spectral_entropy_+3A_entropy.control">entropy.control</code></td>
<td>
<p>list; control settings for entropy estimation.
See <code><a href="#topic+complete_entropy_control">complete_entropy_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="spectral_entropy_+3A_mvspectrum.output">mvspectrum.output</code></td>
<td>
<p>optional; one can directly provide an estimate of 
the spectrum of <code>series</code>. Usually the output of <code><a href="#topic+mvspectrum">mvspectrum</a></code>.</p>
</td></tr>
<tr><td><code id="spectral_entropy_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+mvspectrum">mvspectrum</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>spectral entropy</em> equals the Shannon entropy of the spectral density
<code class="reqn">f_x(\lambda)</code> of a stationary process <code class="reqn">x_t</code>: 
</p>
<p style="text-align: center;"><code class="reqn"> 
H_s(x_t) = - \int_{-\pi}^{\pi} f_x(\lambda) \log f_x(\lambda) d \lambda, 
</code>
</p>

<p>where the density is normalized such that 
<code class="reqn">\int_{-\pi}^{\pi} f_x(\lambda) d \lambda = 1</code>. An estimate of <code class="reqn">f(\lambda)</code>
can be obtained 
by the (smoothed) periodogram (see <code><a href="#topic+mvspectrum">mvspectrum</a></code>); thus using discrete, and 
not continuous entropy.
</p>


<h3>Value</h3>

<p>A non-negative real value for the spectral entropy <code class="reqn">H_s(x_t)</code>.
</p>


<h3>References</h3>

<p>Jerry D. Gibson and Jaewoo Jung (2006). &ldquo;The
Interpretation of Spectral Entropy Based Upon Rate Distortion Functions&rdquo;.
IEEE International Symposium on Information Theory, pp. 277-281.
</p>
<p>L. L. Campbell, &ldquo;Minimum coefficient rate for stationary random processes&rdquo;, 
Information and Control, vol. 3, no. 4, pp. 360 - 371, 1960.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Omega">Omega</a></code>, <code><a href="#topic+discrete_entropy">discrete_entropy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
eps &lt;- rnorm(100)
spectral_entropy(eps)

phi.v &lt;- seq(-0.95, 0.95, by = 0.1)
kMethods &lt;- c("mvspec", "pgram")
SE &lt;- matrix(NA, ncol = length(kMethods), nrow = length(phi.v))
for (ii in seq_along(phi.v)) {
  xx.tmp &lt;- arima.sim(n = 200, list(ar = phi.v[ii]))
  for (mm in seq_along(kMethods)) {
    SE[ii, mm] &lt;- spectral_entropy(xx.tmp, spectrum.control = 
                                     list(method = kMethods[mm]))
  }
}

matplot(phi.v, SE, type = "l", col = seq_along(kMethods))
legend("bottom", kMethods, lty = seq_along(kMethods), 
       col = seq_along(kMethods))
       
# AR vs MA
SE.arma &lt;- matrix(NA, ncol = 2, nrow = length(phi.v))
SE.arma[, 1] &lt;- SE[, 2]

for (ii in seq_along(phi.v)){
  yy.temp &lt;- arima.sim(n = 1000, list(ma = phi.v[ii]))
  SE.arma[ii, 2] &lt;- 
    spectral_entropy(yy.temp, spectrum.control = list(method = "mvspec"))
}

matplot(phi.v, SE.arma, type = "l", col = 1:2, xlab = "parameter (phi or theta)",
        ylab = "Spectral entropy")
abline(v = 0, col = "blue", lty = 3)
legend("bottom", c("AR(1)", "MA(1)"), lty = 1:2, col = 1:2)

</code></pre>

<hr>
<h2 id='whiten'>whitens multivariate data</h2><span id='topic+whiten'></span><span id='topic+check_whitened'></span><span id='topic+sqrt_matrix'></span>

<h3>Description</h3>

<p><code>whiten</code> transforms a multivariate K-dimensional signal <code class="reqn">\mathbf{X}</code> with mean
<code class="reqn">\boldsymbol \mu_X</code> and covariance matrix <code class="reqn">\Sigma_{X}</code> to a <em>whitened</em>
signal <code class="reqn">\mathbf{U}</code> with mean <code class="reqn">\boldsymbol 0</code> and <code class="reqn">\Sigma_U = I_K</code>.
Thus it centers the signal and makes it contemporaneously uncorrelated.
See Details.
</p>
<p><code>check_whitened</code> checks if data has been whitened; i.e., if it has
zero mean, unit variance, and is uncorrelated.
</p>
<p><code>sqrt_matrix</code> computes the square root <code class="reqn">\mathbf{B}</code> of a square matrix
<code class="reqn">\mathbf{A}</code>. The matrix <code class="reqn">\mathbf{B}</code> satisfies
<code class="reqn">\mathbf{B} \mathbf{B} = \mathbf{A}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whiten(data)

check_whitened(data, check.attribute.only = TRUE)

sqrt_matrix(mat, return.sqrt.only = TRUE, symmetric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whiten_+3A_data">data</code></td>
<td>
<p><code class="reqn">n \times K</code> array representing <code>n</code> observations of
<code>K</code> variables.</p>
</td></tr>
<tr><td><code id="whiten_+3A_check.attribute.only">check.attribute.only</code></td>
<td>
<p>logical; if <code>TRUE</code> it checks the 
attribute only.  This is much faster (it just needs to look up one attribute
value), but it might not surface silent bugs.  For sake of performance
the package uses the attribute version by default.  However, for 
testing/debugging the full computational version can be used.</p>
</td></tr>
<tr><td><code id="whiten_+3A_mat">mat</code></td>
<td>
<p>a square <code class="reqn">K \times K</code> matrix.</p>
</td></tr>
<tr><td><code id="whiten_+3A_return.sqrt.only">return.sqrt.only</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) it returns only the square root matrix;
if <code>FALSE</code> it returns other auxiliary results (eigenvectors and
eigenvalues, and inverse of the square root matrix).</p>
</td></tr>
<tr><td><code id="whiten_+3A_symmetric">symmetric</code></td>
<td>
<p>logical; if <code>TRUE</code> the <code>eigen</code>-solver assumes
that the matrix is symmetric (which makes it much faster).  This is in particular
useful for a covariance matrix (which is used in <code>whiten</code>). Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>whiten</code> uses zero component analysis (ZCA) (aka zero-phase whitening filters)
to whiten the data; i.e., it uses the
inverse square root of the covariance matrix of <code class="reqn">\mathbf{X}</code> (see
<code><a href="#topic+sqrt_matrix">sqrt_matrix</a></code>) as the whitening transformation.
This means that on top of PCA, the uncorrelated principal components are
back-transformed to the original space using the
transpose of the eigenvectors. The advantage is that this makes them comparable
to the original <code class="reqn">\mathbf{X}</code>.  See References for details.
</p>
<p>The <em>square root</em> of a quadratic <code class="reqn">n \times n</code> matrix <code class="reqn">\mathbf{A}</code>
can be computed by using the eigen-decomposition of <code class="reqn">\mathbf{A}</code>
</p>
<p style="text-align: center;"><code class="reqn">
 \mathbf{A} = \mathbf{V} \Lambda \mathbf{V}',
</code>
</p>

<p>where <code class="reqn">\Lambda</code> is an <code class="reqn">n \times n</code> matrix with the eigenvalues
<code class="reqn">\lambda_1, \ldots, \lambda_n</code> in the diagonal.
The square root is simply <code class="reqn">\mathbf{B} = \mathbf{V} \Lambda^{1/2} \mathbf{V}'</code> where
<code class="reqn">\Lambda^{1/2} = diag(\lambda_1^{1/2}, \ldots, \lambda_n^{1/2})</code>.
</p>
<p>Similarly, the <em>inverse square root</em> is defined as
<code class="reqn">\mathbf{A}^{-1/2} = \mathbf{V} \Lambda^{-1/2} \mathbf{V}'</code>, where
<code class="reqn">\Lambda^{-1/2} = diag(\lambda_1^{-1/2}, \ldots, \lambda_n^{-1/2})</code>
(provided that <code class="reqn">\lambda_i \neq 0</code>).
</p>


<h3>Value</h3>

<p><code>whiten</code> returns a list with the whitened data, the transformation,
and other useful quantities.
</p>
<p><code>check_whitened</code> throws an error if the input is not
<code><a href="#topic+whiten">whiten</a></code>ed, and returns (invisibly) the data with an attribute <code>'whitened'</code>
equal to <code>TRUE</code>.  This allows to simply update data to have the
attribute and thus only check it once on the actual data (slow) but then
use the attribute lookup (fast).
</p>
<p><code>sqrt_matrix</code> returns an <code class="reqn">n \times n</code>  matrix.  If <code class="reqn">\mathbf{A}</code>
is not semi-positive definite it returns a complex-valued <code class="reqn">\mathbf{B}</code>
(since square root of negative eigenvalues are complex).
</p>
<p>If <code>return.sqrt.only = FALSE</code> then it returns a list with:
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>eigenvalues of <code class="reqn">\mathbf{A}</code>,</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>eigenvectors of <code class="reqn">\mathbf{A}</code>,</p>
</td></tr>
<tr><td><code>sqrt</code></td>
<td>
<p>square root matrix <code class="reqn">\mathbf{B}</code>,</p>
</td></tr>
<tr><td><code>sqrt.inverse</code></td>
<td>
<p>inverse of <code class="reqn">\mathbf{B}</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>See appendix in <a href="http://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf">http://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf</a>.
</p>
<p>See <a href="http://ufldl.stanford.edu/wiki/index.php/Implementing_PCA/Whitening">http://ufldl.stanford.edu/wiki/index.php/Implementing_PCA/Whitening</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
XX &lt;- matrix(rnorm(100), ncol = 2) %*% matrix(runif(4), ncol = 2)
cov(XX)
UU &lt;- whiten(XX)$U
cov(UU)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
