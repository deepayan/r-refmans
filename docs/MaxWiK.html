<!DOCTYPE html><html lang="en"><head><title>Help for package MaxWiK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MaxWiK}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MaxWiK-package'><p>MaxWiK: Machine Learning Method Based on Isolation Kernel Mean Embedding</p></a></li>
<li><a href='#apply_range'><p>Function to restrict values of the data according with the range for each dimension</p></a></li>
<li><a href='#check_numeric_format'><p>Function to check DATA.FRAME</p></a></li>
<li><a href='#check_packages'><p>Check the installation of packages and attach them with corresponding functions</p></a></li>
<li><a href='#check_pkg'><p>Check the installation of a package for some functions</p></a></li>
<li><a href='#Data.2D'><p>List of the objects for the 2D example of the MaxWiK methods usage</p></a></li>
<li><a href='#get_inverse_GRAM'><p>The function to get inverse Gram matrix</p></a></li>
<li><a href='#get_kernel_mean_embedding'><p>The function to calculate Maxima weighted kernel mean mapping for Isolation Kernel in RKHS related to parameters space</p></a></li>
<li><a href='#GET_SUBSET'><p>The function to get subset with size psi for Voronoi diagram</p></a></li>
<li><a href='#get_subset_of_feature_map'><p>The function to get subset of points based on feature mapping</p></a></li>
<li><a href='#get_voronoi_feature'><p>The function to get feature representation in RKHS based on Voronoi diagram for WHOLE dataset</p></a></li>
<li><a href='#get_voronoi_feature_PART_dataset'><p>The function to get feature representation in RKHS based on Voronoi diagram for PART of dataset</p></a></li>
<li><a href='#iKernel'><p>Function returns the value of similarity or Isolation KERNEL for TWO points</p></a></li>
<li><a href='#MaxWiK_templates'><p>Function to copy the templates from extdata folder in the library to /Templates/ folder in the working directory</p></a></li>
<li><a href='#MaxWiK.ggplot.density'><p>Density plot</p></a></li>
<li><a href='#meta_sampling'><p>Function to get Approximate Bayesian Computation based on Maxima Weighted Isolation Kernel mapping</p></a></li>
<li><a href='#MSE_sim'><p>The function to get the mean square error values for statistics of simulations</p></a></li>
<li><a href='#norm_vec'><p>The norm function for vector</p></a></li>
<li><a href='#read_file'><p>Function to read file</p></a></li>
<li><a href='#read_hyperparameters'><p>Function to read hyperparameters and their values from the file</p></a></li>
<li><a href='#restrict_data'><p>Function to restrict data in the size to accelerate the calculations</p></a></li>
<li><a href='#sampler_MaxWiK'><p>Function to generate parameters and simulate a model based on MaxWiK algorithm</p></a></li>
<li><a href='#sudoku'><p>The function to get the best tracer bullets related to kernel mean embedding</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Machine Learning Method Based on Isolation Kernel Mean Embedding</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Incorporates Approximate Bayesian Computation to get a posterior distribution and to select a model optimal parameter for an observation point. Additionally, the meta-sampling heuristic algorithm is realized for parameter estimation, which requires no model runs and is dimension-independent. A sampling scheme is also presented that allows model runs and uses the meta-sampling for point generation. A predictor is realized as the meta-sampling for the model output. All the algorithms leverage a machine learning method utilizing the maxima weighted Isolation Kernel approach, or 'MaxWiK'. The method involves transforming raw data to a Hilbert space (mapping) and measuring the similarity between simulated points and the maxima weighted Isolation Kernel mapping corresponding to the observation point. Comprehensive details of the methodology can be found in the papers Iurii Nagornov (2024) &lt;<a href="https://doi.org/10.1007%2F978-3-031-66431-1_16">doi:10.1007/978-3-031-66431-1_16</a>&gt; and Iurii Nagornov (2023) &lt;<a href="https://doi.org/10.1007%2F978-3-031-29168-5_18">doi:10.1007/978-3-031-29168-5_18</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, utils, scales, parallel, abc, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-22 22:13:56 UTC; nagornov</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuri Nagornov <a href="https://orcid.org/0000-0002-7935-6776"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yuri Nagornov &lt;nagornov.yuri@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-25 11:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='MaxWiK-package'>MaxWiK: Machine Learning Method Based on Isolation Kernel Mean Embedding</h2><span id='topic+MaxWiK'></span><span id='topic+MaxWiK-package'></span>

<h3>Description</h3>

<p>Incorporates Approximate Bayesian Computation to get a posterior distribution and to select a model optimal parameter for an observation point. Additionally, the meta-sampling heuristic algorithm is realized for parameter estimation, which requires no model runs and is dimension-independent. A sampling scheme is also presented that allows model runs and uses the meta-sampling for point generation. A predictor is realized as the meta-sampling for the model output. All the algorithms leverage a machine learning method utilizing the maxima weighted Isolation Kernel approach, or 'MaxWiK'. The method involves transforming raw data to a Hilbert space (mapping) and measuring the similarity between simulated points and the maxima weighted Isolation Kernel mapping corresponding to the observation point. Comprehensive details of the methodology can be found in the papers Iurii Nagornov (2024) <a href="https://doi.org/10.1007/978-3-031-66431-1_16">doi:10.1007/978-3-031-66431-1_16</a> and Iurii Nagornov (2023) <a href="https://doi.org/10.1007/978-3-031-29168-5_18">doi:10.1007/978-3-031-29168-5_18</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Yuri Nagornov <a href="mailto:nagornov.yuri@gmail.com">nagornov.yuri@gmail.com</a> (<a href="https://orcid.org/0000-0002-7935-6776">ORCID</a>) [copyright holder]
</p>

<hr>
<h2 id='apply_range'>Function to restrict values of the data according with the range for each dimension</h2><span id='topic+apply_range'></span>

<h3>Description</h3>

<p>Function to restrict values of the data according with the range for each dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_range(diapason, input.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_range_+3A_diapason">diapason</code></td>
<td>
<p>Vector of min and max values or data frame with two rows (min and max) for each dimension of input data</p>
</td></tr>
<tr><td><code id="apply_range_+3A_input.data">input.data</code></td>
<td>
<p>Data frame of input where values will be corrected</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same data frame with corrected values according to the diapason
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MaxWiK::MaxWiK_templates(dir = tempdir()) # See the templates and vignettes for usage.
</code></pre>

<hr>
<h2 id='check_numeric_format'>Function to check DATA.FRAME</h2><span id='topic+check_numeric_format'></span>

<h3>Description</h3>

<p>Check that DATA.FRAME has numeric format for ALL the columns and it has NO 'NA' values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_numeric_format(l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_numeric_format_+3A_l">l</code></td>
<td>
<p>DATA.FRAME that should have data of numeric type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if data.frame has ONLY numeric data and FALSE vice verse
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='check_packages'>Check the installation of packages and attach them with corresponding functions</h2><span id='topic+check_packages'></span>

<h3>Description</h3>

<p>Check the installation of packages and attach them with corresponding functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_packages(pkgs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_packages_+3A_pkgs">pkgs</code></td>
<td>
<p>List of package names with related function names,
by default (or when pkgs = NULL) the list of packages are described in Namespace file of the package or
'R/MaxWiK-package.R' file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if the packages are installed then it returns NULL else it returns error message
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='check_pkg'>Check the installation of a package for some functions</h2><span id='topic+check_pkg'></span>

<h3>Description</h3>

<p>Check the installation of a package for some functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pkg(pkg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_pkg_+3A_pkg">pkg</code></td>
<td>
<p>Package name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if the package is installed then it returns NULL else it returns error message
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='Data.2D'>List of the objects for the 2D example of the MaxWiK methods usage</h2><span id='topic+Data.2D'></span>

<h3>Description</h3>

<p>A list containing input and output data for 2D example for Approximate Bayesian Computation,
including sampling scheme, meta-sampling, and prediction. To understand all details of the dataset, please,
be kind to see vignette of the package. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Data.2D
</code></pre>


<h3>Format</h3>

<p>A list of:
</p>

<dl>
<dt>X</dt><dd><p> Input data frame of the model </p>
</dd>
<dt>Y</dt><dd><p> Output data frame of the model </p>
</dd>
<dt>observation</dt><dd><p> Data frame with observation info </p>
</dd>
<dt>ABC</dt><dd><p> List of hyperparameters, the matrix of Voronoi sites, posteriori distribution, and results of MaxWiK algorithm </p>
</dd>
<dt>metasampling</dt><dd><p> List of results of meta-sampling algorithm, and the network of points during meta-sampling </p>
</dd>
<dt>sampling</dt><dd><p> List of object which are necessary for sampling algorithm like
function for simulation, parameters of the model, MSE (mean squared error), and X12 - generated points </p>
</dd>
<dt>predictor</dt><dd><p> List of object which are necessary for predictor algorithm like
posteriori.MaxWiK, result of the algorithm, and network of points during meta-sampling </p>
</dd>
</dl>


<hr>
<h2 id='get_inverse_GRAM'>The function to get inverse Gram matrix</h2><span id='topic+get_inverse_GRAM'></span><span id='topic+check_positive_definite'></span>

<h3>Description</h3>

<p>Function <code>get_inverse_GRAM()</code> allows to get inverse Gram matrix based on given
positive regularization constant lambda
</p>
<p>Function <code>check_positive_definite()</code> returns logical value about n trials on
'is Gram matrix positive definite or not?' Just incorrect trial returns FALSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_inverse_GRAM(G, l = 1e-06, check_pos_def = FALSE)

check_positive_definite(G, n = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_inverse_GRAM_+3A_g">G</code></td>
<td>
<p>Gram matrix gotten via <code>GRAM_iKernel()</code> function</p>
</td></tr>
<tr><td><code id="get_inverse_GRAM_+3A_l">l</code></td>
<td>
<p>Lambda parameter or positive regularization constant</p>
</td></tr>
<tr><td><code id="get_inverse_GRAM_+3A_check_pos_def">check_pos_def</code></td>
<td>
<p>Logical parameter to check the Gram matrix is positive definite or do not check</p>
</td></tr>
<tr><td><code id="get_inverse_GRAM_+3A_n">n</code></td>
<td>
<p>Number of iterations to check the positive definite property</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>get_inverse_GRAM()</code> returns the inverse Gram matrix
based on the given positive regularization constant lambda l
</p>
<p>Function <code>check_positive_definite()</code> returns logical value: <br />
TRUE if Gram matrix is positive definite, and FALSE if it is not
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>check_positive_definite()</code>: The function to check the positive definite property of Gram matrix
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
NULL
</code></pre>

<hr>
<h2 id='get_kernel_mean_embedding'>The function to calculate Maxima weighted kernel mean mapping for Isolation Kernel in RKHS related to parameters space</h2><span id='topic+get_kernel_mean_embedding'></span>

<h3>Description</h3>

<p>The function to calculate Maxima weighted kernel mean mapping for Isolation Kernel in RKHS related to parameters space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_kernel_mean_embedding(parameters_Matrix_iKernel, Hilbert_weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_kernel_mean_embedding_+3A_parameters_matrix_ikernel">parameters_Matrix_iKernel</code></td>
<td>
<p>Matrix of all the points represented in RKHS related to parameters space</p>
</td></tr>
<tr><td><code id="get_kernel_mean_embedding_+3A_hilbert_weights">Hilbert_weights</code></td>
<td>
<p>Maximal weights in RKHS to get related part of kernel mean embedding from parameters_Matrix_iKernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maxima weighted kernel mean mapping in the form of integer vector with length t (number of trees).
Each element of the vector is index of Voronoi cell with maximal weight in the Voronoi diagram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='GET_SUBSET'>The function to get subset with size psi for Voronoi diagram</h2><span id='topic+GET_SUBSET'></span>

<h3>Description</h3>

<p>The function to get subset with size psi for Voronoi diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GET_SUBSET(data_set, pnts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GET_SUBSET_+3A_data_set">data_set</code></td>
<td>
<p>Data.frame of Voronoi diagram</p>
</td></tr>
<tr><td><code id="GET_SUBSET_+3A_pnts">pnts</code></td>
<td>
<p>Integer vector of indexes of columns of the data_set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Subset of data_set with columns pnts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL

</code></pre>

<hr>
<h2 id='get_subset_of_feature_map'>The function to get subset of points based on feature mapping</h2><span id='topic+get_subset_of_feature_map'></span>

<h3>Description</h3>

<p>The function to get subset of points based on feature mapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subset_of_feature_map(dtst, Matrix_Voronoi, iFeature_point)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_subset_of_feature_map_+3A_dtst">dtst</code></td>
<td>
<p>Dataset of all the original points</p>
</td></tr>
<tr><td><code id="get_subset_of_feature_map_+3A_matrix_voronoi">Matrix_Voronoi</code></td>
<td>
<p>Matrix of Voronoi diagrams based on the Isolation Kernel algorithm</p>
</td></tr>
<tr><td><code id="get_subset_of_feature_map_+3A_ifeature_point">iFeature_point</code></td>
<td>
<p>Feature mapping in RKHS for a point,
that can be gotten via <code>add_new_point_iKernel()</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The subset of dtst that has points
extracted with feature mapping of an observation point (iFeature_point)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='get_voronoi_feature'>The function to get feature representation in RKHS based on Voronoi diagram for WHOLE dataset</h2><span id='topic+get_voronoi_feature'></span><span id='topic+add_new_point_iKernel'></span>

<h3>Description</h3>

<p>The function to get feature representation in RKHS based on Voronoi diagram for WHOLE dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_voronoi_feature(
  psi = 40,
  t = 350,
  data,
  talkative = FALSE,
  Matrix_Voronoi = NULL
)

add_new_point_iKernel(data, d1, Matrix_Voronoi, dissim, t, psi, nr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_voronoi_feature_+3A_psi">psi</code></td>
<td>
<p>Integer number related to the size of each Voronoi diagram</p>
</td></tr>
<tr><td><code id="get_voronoi_feature_+3A_t">t</code></td>
<td>
<p>Integer number of trees in Isolation Kernel or dimension of RKHS</p>
</td></tr>
<tr><td><code id="get_voronoi_feature_+3A_data">data</code></td>
<td>
<p>dataset of points, rows - points, columns - dimensions of a point</p>
</td></tr>
<tr><td><code id="get_voronoi_feature_+3A_talkative">talkative</code></td>
<td>
<p>logical. If TRUE then print messages, FALSE for the silent execution</p>
</td></tr>
<tr><td><code id="get_voronoi_feature_+3A_matrix_voronoi">Matrix_Voronoi</code></td>
<td>
<p>Matrix of Voronoi diagrams, if it is NULL then the function will calculate Matrix_Voronoi</p>
</td></tr>
<tr><td><code id="get_voronoi_feature_+3A_d1">d1</code></td>
<td>
<p>Data point - usually it is an observation data point</p>
</td></tr>
<tr><td><code id="get_voronoi_feature_+3A_dissim">dissim</code></td>
<td>
<p>Matrix of dissimilarity or distances between all points.</p>
</td></tr>
<tr><td><code id="get_voronoi_feature_+3A_nr">nr</code></td>
<td>
<p>Integer number of rows in matrix of distances (dissim) and also the size of dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Feature representation in RKHS based on Voronoi diagram for WHOLE dataset
</p>
<p>RKHS mapping for a new point based on Isolation Kernel mapping
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>add_new_point_iKernel()</code>: The function to get RKHS mapping based on Isolation Kernel for a new point
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
NULL
</code></pre>

<hr>
<h2 id='get_voronoi_feature_PART_dataset'>The function to get feature representation in RKHS based on Voronoi diagram for PART of dataset</h2><span id='topic+get_voronoi_feature_PART_dataset'></span>

<h3>Description</h3>

<p><code>get_voronoi_feature_PART_dataset()</code> function returns
the feature (mapping) representation in RKHS based on Voronoi diagram for NEW PART of dataset.
The <code>Matrix_Voronoi</code> is based on the PREVIOUS dataset.
The NEW PART of dataset will appear at the end of PREVIOUS dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_voronoi_feature_PART_dataset(
  data,
  talkative = FALSE,
  start_row,
  Matrix_Voronoi
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_voronoi_feature_PART_dataset_+3A_data">data</code></td>
<td>
<p>Data.frame of new points</p>
</td></tr>
<tr><td><code id="get_voronoi_feature_PART_dataset_+3A_talkative">talkative</code></td>
<td>
<p>Logical parameter to print or do not print messages</p>
</td></tr>
<tr><td><code id="get_voronoi_feature_PART_dataset_+3A_start_row">start_row</code></td>
<td>
<p>Row number from which a new data should be added</p>
</td></tr>
<tr><td><code id="get_voronoi_feature_PART_dataset_+3A_matrix_voronoi">Matrix_Voronoi</code></td>
<td>
<p>Matrix of Voronoi diagrams based on the PREVIOUS dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of three matrices: Matrix_Voronoi, Matrix_iKernel and dissim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='iKernel'>Function returns the value of similarity or Isolation KERNEL for TWO points</h2><span id='topic+iKernel'></span><span id='topic+iKernel_point_dataset'></span><span id='topic+get_weights_iKernel'></span><span id='topic+GRAM_iKernel'></span>

<h3>Description</h3>

<p><code>iKernel()</code> function returns value of similarity or Isolation KERNEL
for TWO points that is number in the range <code>[0,1]</code>
</p>
<p><code>iKernel_point_dataset()</code> function returns vector of values of similarity based on Isolation Kernel between a new point and all the points of dataset
</p>
<p><code>get_weights_iKernel()</code> function returns list of two objects:
the first object is numeric vector of weights for RKHS space, and
the second object is numeric vector of weights of similarity for iFeature_point
corresponding observation point
</p>
<p><code>GRAM_iKernel()</code> is the function to calculate Gram matrix for Isolation Kernel method based on Voronoi diagrams
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iKernel(Matrix_iKernel, pnt_1, pnt_2, t)

iKernel_point_dataset(Matrix_iKernel, t, nr, iFeature_point)

get_weights_iKernel(GI, Matrix_iKernel, t, nr, iFeature_point)

GRAM_iKernel(Matrix_iKernel, check_pos_def = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iKernel_+3A_matrix_ikernel">Matrix_iKernel</code></td>
<td>
<p>Matrix of indexes of Voronoi cells for each point and each tree based on Isolation Kernel calculation</p>
</td></tr>
<tr><td><code id="iKernel_+3A_pnt_1">pnt_1</code></td>
<td>
<p>The first point of dataset</p>
</td></tr>
<tr><td><code id="iKernel_+3A_pnt_2">pnt_2</code></td>
<td>
<p>The second point of dataset</p>
</td></tr>
<tr><td><code id="iKernel_+3A_t">t</code></td>
<td>
<p>is a number of columns of Matrix_iKernel or dimension of Matrix_iKernel (corresponding to the number of trees t)</p>
</td></tr>
<tr><td><code id="iKernel_+3A_nr">nr</code></td>
<td>
<p>is number of rows in Matrix_iKernel or size of dataset</p>
</td></tr>
<tr><td><code id="iKernel_+3A_ifeature_point">iFeature_point</code></td>
<td>
<p>Feature mapping in RKHS for a new point, that can be gotten via <code>add_new_point_iKernel()</code> function</p>
</td></tr>
<tr><td><code id="iKernel_+3A_gi">GI</code></td>
<td>
<p>The inverse Gram matrix</p>
</td></tr>
<tr><td><code id="iKernel_+3A_check_pos_def">check_pos_def</code></td>
<td>
<p>Logical parameter to check the Gram matrix is positive definite or do not check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>iKernel()</code> returns a value of similarity or Isolation KERNEL for TWO points
</p>
<p>The function <code>iKernel_point_dataset()</code> returns a value of Isolation Kernel between a new point and dataset represented via Matrix_iKernel
</p>
<p>The function <code>get_weights_iKernel()</code> returns the
list of weights for RKHS space and weights of similarity for iFeature_point
</p>
<p>The function <code>GRAM_iKernel()</code> returns Gram matrix of Isolation Kernel
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>iKernel_point_dataset()</code>: The function to get Isolation Kernel between a new point and dataset
</p>
</li>
<li> <p><code>get_weights_iKernel()</code>: The function to get weights from Feature mapping
</p>
</li>
<li> <p><code>GRAM_iKernel()</code>: The function to calculate Gram matrix for Isolation Kernel method
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
NULL
NULL 
NULL
</code></pre>

<hr>
<h2 id='MaxWiK_templates'>Function to copy the templates from extdata folder in the library to /Templates/ folder in the working directory</h2><span id='topic+MaxWiK_templates'></span>

<h3>Description</h3>

<p>Function to copy the templates from extdata folder in the library to /Templates/ folder in the working directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxWiK_templates(dir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaxWiK_templates_+3A_dir">dir</code></td>
<td>
<p>Folder to where files should be save, by default dir = './'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of logic numbers for each copied file, TRUE - success, FALSE - not success
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MaxWiK_templates( dir = tempdir() )
</code></pre>

<hr>
<h2 id='MaxWiK.ggplot.density'>Density plot</h2><span id='topic+MaxWiK.ggplot.density'></span>

<h3>Description</h3>

<p>Density plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxWiK.ggplot.density(
  title = "",
  datafr1,
  datafr2,
  var.df,
  obs.true = NULL,
  best.sim = NULL,
  clrs = c("#a9b322", "#f9b3a2", "red", "blue"),
  alpha = c(0.1, 0.4),
  lw = c(0.7, 0.7),
  lt = c("dashed", "dotted")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaxWiK.ggplot.density_+3A_title">title</code></td>
<td>
<p>Title of the plot</p>
</td></tr>
<tr><td><code id="MaxWiK.ggplot.density_+3A_datafr1">datafr1</code></td>
<td>
<p>data frame 1</p>
</td></tr>
<tr><td><code id="MaxWiK.ggplot.density_+3A_datafr2">datafr2</code></td>
<td>
<p>data frame 2</p>
</td></tr>
<tr><td><code id="MaxWiK.ggplot.density_+3A_var.df">var.df</code></td>
<td>
<p>Variables to show</p>
</td></tr>
<tr><td><code id="MaxWiK.ggplot.density_+3A_obs.true">obs.true</code></td>
<td>
<p>True observation if so, NULL by default</p>
</td></tr>
<tr><td><code id="MaxWiK.ggplot.density_+3A_best.sim">best.sim</code></td>
<td>
<p>The best point from a simulation if so, NULL by default</p>
</td></tr>
<tr><td><code id="MaxWiK.ggplot.density_+3A_clrs">clrs</code></td>
<td>
<p>Colors to plot, by default it is c( &quot;#a9b322&quot;, &quot;#f9b3a2&quot;, 'red', 'blue' )</p>
</td></tr>
<tr><td><code id="MaxWiK.ggplot.density_+3A_alpha">alpha</code></td>
<td>
<p>Transparency values for density plots</p>
</td></tr>
<tr><td><code id="MaxWiK.ggplot.density_+3A_lw">lw</code></td>
<td>
<p>Line widths</p>
</td></tr>
<tr><td><code id="MaxWiK.ggplot.density_+3A_lt">lt</code></td>
<td>
<p>Line types</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Make and return the ggplot object of the densities of the data frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MaxWiK::MaxWiK_templates(dir = tempdir()) # See the templates and vignettes for usage. 
# Function 'MaxWiK.ggplot.density()' is used in the MaxWiK.ABC.R and 
# MaxWiK.Predictor.R templates.
</code></pre>

<hr>
<h2 id='meta_sampling'>Function to get Approximate Bayesian Computation based on Maxima Weighted Isolation Kernel mapping</h2><span id='topic+meta_sampling'></span><span id='topic+MaxWiK.predictor'></span><span id='topic+get.MaxWiK'></span>

<h3>Description</h3>

<p>The function <code>meta_sampling()</code> iteratively generates tracer based on the simple procedure: <br />
</p>

<ul>
<li><p> making a reflection of the top points from the best point, <br />
</p>
</li>
<li><p> and then generating the point tracers between them, <br />
</p>
</li>
<li><p> finally, the algorithm chooses again the top points and the best point (<code>sudoku()</code> function is used),
</p>
</li>
<li><p> repeat all the steps until condition to be <code>TRUE</code>: <br />
<code>abs( min( sim_tracers ) - sim_previous ) &lt; epsilon </code>
</p>
</li></ul>

<p>The function <code>MaxWiK.predictor()</code> uses the meta-sampling for a prediction
</p>
<p>The function <code>get.MaxWiK()</code> is used to get Approximate Bayesian Computation
based on Maxima Weighted Isolation Kernel mapping.
On given data frame of parameters, statistics of the simulations and an observation,
using the internal parameters psi and t,
the function <code>get.MaxWiK()</code> returns the estimation of a parameter corresponding to
Maxima weighted Isolation Kernel ABC method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta_sampling(
  psi = 4,
  t = 35,
  param,
  stat.sim,
  stat.obs,
  talkative = FALSE,
  check_pos_def = FALSE,
  n_bullets = 16,
  n_best = 10,
  halfwidth = 0.5,
  epsilon = 0.001,
  rate = 0.1,
  max_iteration = 15,
  save_web = TRUE,
  use.iKernelABC = NULL
)

MaxWiK.predictor(
  psi = 4,
  t = 35,
  param,
  stat.sim,
  new.param,
  talkative = FALSE,
  check_pos_def = FALSE,
  n_bullets = 16,
  n_best = 10,
  halfwidth = 0.5,
  epsilon = 0.001,
  rate = 0.1,
  max_iteration = 15,
  save_web = TRUE,
  use.iKernelABC = NULL
)

get.MaxWiK(
  psi = 40,
  t = 350,
  param,
  stat.sim,
  stat.obs,
  talkative = FALSE,
  check_pos_def = TRUE,
  Matrix_Voronoi = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meta_sampling_+3A_psi">psi</code></td>
<td>
<p>Integer number. Size of each Voronoi diagram or number of areas/points in the Voronoi diagrams</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_t">t</code></td>
<td>
<p>Integer number of trees in the Isolation Forest</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_param">param</code></td>
<td>
<p>or <code>par.sim</code> - data frame of parameters of the model</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_stat.sim">stat.sim</code></td>
<td>
<p>Summary statistics of the simulations (model output)</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_stat.obs">stat.obs</code></td>
<td>
<p>Summary statistics of the observation point</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_talkative">talkative</code></td>
<td>
<p>Logical parameter to print or do not print messages</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_check_pos_def">check_pos_def</code></td>
<td>
<p>Logical parameter to check the Gram matrix is positive definite or do not check</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_n_bullets">n_bullets</code></td>
<td>
<p>Number of generating points between two</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_n_best">n_best</code></td>
<td>
<p>Number of the best points to construct the next web net</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_halfwidth">halfwidth</code></td>
<td>
<p>Parameter for the algorithm of deleting of generated points</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_epsilon">epsilon</code></td>
<td>
<p>Criterion to stop meta-sampling</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_rate">rate</code></td>
<td>
<p>Rate to renew points in the web net of generated points</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_max_iteration">max_iteration</code></td>
<td>
<p>Maximum of iterations during meta-sampling</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_save_web">save_web</code></td>
<td>
<p>Logical to save all the generated points (web net)</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_use.ikernelabc">use.iKernelABC</code></td>
<td>
<p>The iKernelABC object to use for meta-sampling. By default it is NULL and is generated.</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_new.param">new.param</code></td>
<td>
<p>New parameter for the predictor input</p>
</td></tr>
<tr><td><code id="meta_sampling_+3A_matrix_voronoi">Matrix_Voronoi</code></td>
<td>
<p>is a predefined matrix of information about Voronoi trees
(rows - trees, columns - Voronoi points/areas IDs). By default it is NULL and is generated randomly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>meta_sampling()</code> returns the list of the next objects:
</p>

<ul>
<li><p> input.parameters that is the list of all the input parameters for Isolation Kernel ABC method;
</p>
</li>
<li><p> iteration that is iteration value when algorithm stopped;
</p>
</li>
<li><p> network that is network points when algorithm stopped;
</p>
</li>
<li><p> par.best that is data frame of one point that is the best from all the generated tracer points;
</p>
</li>
<li><p> sim.best that is numeric value of the similarity of the best tracer point;
</p>
</li>
<li><p> iKernelABC that is result of the function <code>get.MaxWiK()</code> given on <code>input parameters</code>;
</p>
</li>
<li><p> spiderweb that is the list of all the networks during the meta-sampling.
</p>
</li></ul>

<p>The function <code>MaxWiK.predictor()</code> returns the list of the next objects:
</p>

<ul>
<li><p> input.parameters that is the list of all the input parameters for Isolation Kernel ABC method;
</p>
</li>
<li><p> iteration that is iteration value when algorithm stopped;
</p>
</li>
<li><p> network that is network points when algorithm stopped;
</p>
</li>
<li><p> prediction.best that is data frame of one point that is the best from all the generated tracer points;
</p>
</li>
<li><p> sim.best that is numeric value of the similarity of the best tracer point;
</p>
</li>
<li><p> iKernelABC that is result of the function <code>get.MaxWiK()</code> given on <code>input parameters</code>;
</p>
</li>
<li><p> spiderweb that is the list of all the networks during the meta-sampling.
</p>
</li></ul>

<p>The function <code>get.MaxWiK()</code> returns the list of :
</p>

<ul>
<li><p> kernel_mean_embedding is a maxima weighted kernel mean embedding (mapping) related to the observation point;
</p>
</li>
<li><p> parameters_Matrix_Voronoi is a matrix of information about Voronoi trees (rows - trees, columns - Voronoi points/areas IDs) for parameters data set;
</p>
</li>
<li><p> parameters_Matrix_iKernel is a matrix of of all points of PARAMETERS in a Hilbert space (rows - points, columns - isolation trees);
</p>
</li>
<li><p> Hilbert_weights is a weights in Hilbert space to get maxima weighted kernel mean embedding for parameters_Matrix_iKernel;
</p>
</li>
<li><p> Matrix_iKernel is a matrix of all points of simulations in a Hilbert space (rows - points, columns - isolation trees);
</p>
</li>
<li><p> iFeature_point is a feature embedding mapping for the OBSERVATION point;
</p>
</li>
<li><p> similarity is a vector of similarities between the simulation points and observation point;
</p>
</li>
<li><p> Matrix_Voronoi is a matrix of information about Voronoi trees (rows - trees, columns - Voronoi points/areas IDs);
</p>
</li>
<li><p> t is a number of trees in the Isolation Forest;
</p>
</li>
<li><p> psi is a number of areas/points in the Voronoi diagrams
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>meta_sampling()</code>: The function to get the best value of parameter corresponding to
Maxima Weighted Isolation Kernel mapping which is related to an observation point
</p>
</li>
<li> <p><code>MaxWiK.predictor()</code>: The function to get the prediction of output based on a new parameter and MaxWiK
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>MaxWiK::MaxWiK_templates(dir = tempdir()) # See the template 'MaxWiK.ABC.R' and 
# vignettes for usage.
MaxWiK::MaxWiK_templates(dir = tempdir()) # See the template 'MaxWiK.Predictor.R' 
# and vignettes for usage. 
MaxWiK::MaxWiK_templates(dir = tempdir()) # See the template 'MaxWiK.ABC.R' and 
# vignettes for usage.
</code></pre>

<hr>
<h2 id='MSE_sim'>The function to get the mean square error values for statistics of simulations</h2><span id='topic+MSE_sim'></span><span id='topic+MSE_parameters'></span>

<h3>Description</h3>

<p>The function <code>MSE_sim()</code> allows to get
the mean square error values for statistics of simulations
</p>
<p>The function <code>MSE_parameters()</code> allows to get MSE for parameters if the truth parameter is known
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSE_sim(stat.obs, stat.sim)

MSE_parameters(par.truth, par.top = NULL, par.best)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSE_sim_+3A_stat.obs">stat.obs</code></td>
<td>
<p>Summary statistics of the observation point</p>
</td></tr>
<tr><td><code id="MSE_sim_+3A_stat.sim">stat.sim</code></td>
<td>
<p>Summary statistics of the simulations (model output)</p>
</td></tr>
<tr><td><code id="MSE_sim_+3A_par.truth">par.truth</code></td>
<td>
<p>The truth parameter</p>
</td></tr>
<tr><td><code id="MSE_sim_+3A_par.top">par.top</code></td>
<td>
<p>Parameters from the top of similarities of <code>get.MaxWiK()</code> algorithm</p>
</td></tr>
<tr><td><code id="MSE_sim_+3A_par.best">par.best</code></td>
<td>
<p>The best parameter from <code>get.MaxWiK()</code> algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>MSE_sim()</code> returns numeric vector of
the mean square error values for statistics of simulations
</p>
<p>The function <code>MSE_parameters()</code> returns list of two numbers: <br />
</p>

<ul>
<li><p> mean of MSE values for all the points from par.top; <br />
</p>
</li>
<li><p> MSE value for the point of par.best
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>MSE_parameters()</code>: The function calculates mean square error (MSE) value
for parameters as differences between them and already the known truth parameter
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
NULL 
</code></pre>

<hr>
<h2 id='norm_vec'>The norm function for vector</h2><span id='topic+norm_vec'></span><span id='topic+norm_vec_sq'></span>

<h3>Description</h3>

<p>The norm function for vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_vec(x)

norm_vec_sq(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_vec_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The squared root of sum of squared elements of the vector x or Euclid length of the vector x
</p>
<p>The squared Euclid norm or the sum of squared elements of the vector x
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>norm_vec_sq()</code>: The squared norm or the sum of squared elements of the vector x
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
NULL
</code></pre>

<hr>
<h2 id='read_file'>Function to read file</h2><span id='topic+read_file'></span>

<h3>Description</h3>

<p>Function to read file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_file(file_name = "", stringsAsFactors = FALSE, header = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_file_+3A_file_name">file_name</code></td>
<td>
<p>Name of file to read</p>
</td></tr>
<tr><td><code id="read_file_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>Parameter for read.table function, by default stringsAsFactors = FALSE</p>
</td></tr>
<tr><td><code id="read_file_+3A_header">header</code></td>
<td>
<p>Logical type to read or do not read head of a file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of data from a file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='read_hyperparameters'>Function to read hyperparameters and their values from the file</h2><span id='topic+read_hyperparameters'></span>

<h3>Description</h3>

<p>Function to read hyperparameters and their values from the file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_hyperparameters(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_hyperparameters_+3A_input">input</code></td>
<td>
<p>File name to input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameters and their values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MaxWiK::MaxWiK_templates(dir = tempdir()) # See the templates and vignettes for usage.
</code></pre>

<hr>
<h2 id='restrict_data'>Function to restrict data in the size to accelerate the calculations</h2><span id='topic+restrict_data'></span>

<h3>Description</h3>

<p><code>restrict_data()</code> is based on rejection ABC method to restrict original dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict_data(par.sim, stat.sim, stat.obs, size = 300)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="restrict_data_+3A_par.sim">par.sim</code></td>
<td>
<p>Data frame of parameters</p>
</td></tr>
<tr><td><code id="restrict_data_+3A_stat.sim">stat.sim</code></td>
<td>
<p>Data frame of outputs of simulations</p>
</td></tr>
<tr><td><code id="restrict_data_+3A_stat.obs">stat.obs</code></td>
<td>
<p>Data frame of observation point</p>
</td></tr>
<tr><td><code id="restrict_data_+3A_size">size</code></td>
<td>
<p>Integer number of points to leave from original dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>restrict_data()</code> returns the list of: <br />
par.sim - restricted parameters which are close to observation point <br />
stat.sim - restricted stat.sim which are close to observation point
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MaxWiK::MaxWiK_templates(dir = tempdir()) # See the templates and vignettes for usage.
</code></pre>

<hr>
<h2 id='sampler_MaxWiK'>Function to generate parameters and simulate a model based on MaxWiK algorithm</h2><span id='topic+sampler_MaxWiK'></span><span id='topic+sampler_MaxWiK_parallel'></span>

<h3>Description</h3>

<p>Function to generate parameters and simulate a model based on MaxWiK algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler_MaxWiK(
  stat.obs,
  stat.sim,
  par.sim,
  model,
  arg0 = list(),
  size = 500,
  psi_t,
  epsilon,
  nmax = 100,
  include_top = FALSE,
  slowly = FALSE,
  rate = 0.2,
  n_simulation_stop = NA,
  check_err = TRUE,
  include_web_rings = TRUE,
  number_of_nodes_in_ring = 2
)

sampler_MaxWiK_parallel(
  stat.obs,
  stat.sim,
  par.sim,
  model,
  arg0 = list(),
  size = 500,
  psi_t,
  epsilon,
  nmax = 100,
  include_top = FALSE,
  slowly = FALSE,
  rate = 0.2,
  n_simulation_stop = NA,
  check_err = TRUE,
  include_web_rings = TRUE,
  number_of_nodes_in_ring = 2,
  cores = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampler_MaxWiK_+3A_stat.obs">stat.obs</code></td>
<td>
<p>Summary statistics of the observation point</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_stat.sim">stat.sim</code></td>
<td>
<p>Summary statistics of the simulations (model output)</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_par.sim">par.sim</code></td>
<td>
<p>Data frame of parameters of the model</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_model">model</code></td>
<td>
<p>Function to get output of simulation during sampling</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_arg0">arg0</code></td>
<td>
<p>List with arguments for a model function, so that arg0 is NOT changed during sampling</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_size">size</code></td>
<td>
<p>Number of points in the simulation based on MaxWiK algorithm</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_psi_t">psi_t</code></td>
<td>
<p>Vector of psi and t hyperparameters.</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_epsilon">epsilon</code></td>
<td>
<p>Criterion to stop simulation when <code>MSE_current - MSE_previous &lt; epsilon</code></p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_nmax">nmax</code></td>
<td>
<p>Maximal number of iterations</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_include_top">include_top</code></td>
<td>
<p>Logical to include top points (network) from <code>spider_web()</code> function to simulate or do not</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_slowly">slowly</code></td>
<td>
<p>Logical for two algorithms: slow and fast seekers in sampling</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_rate">rate</code></td>
<td>
<p>Rate value in the range <code>[0,1]</code> to define
the rate of changing in the original top of sampled points for slow scheme (if slowly = TRUE)</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_n_simulation_stop">n_simulation_stop</code></td>
<td>
<p>Maximal number of simulations to stop sampling.
If <code>n_simulation_stop = NA</code> then there is no restriction (by default)</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_check_err">check_err</code></td>
<td>
<p>Logical parameter to check epsilon or do not</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_include_web_rings">include_web_rings</code></td>
<td>
<p>Logical to include or do not include the cobweb rings to the simulations</p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_number_of_nodes_in_ring">number_of_nodes_in_ring</code></td>
<td>
<p>Number of points/nodes between two points in the web ring. By default <code>number_of_nodes_in_ring = 2</code></p>
</td></tr>
<tr><td><code id="sampler_MaxWiK_+3A_cores">cores</code></td>
<td>
<p>Number of cores for parallel calculations of a model (4 by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sampler_MaxWiK()</code> returns the list: <br />
</p>

<ul>
<li><p> results: results of all the simulations; <br />
</p>
</li>
<li><p> best: the best value of parameter; <br />
</p>
</li>
<li><p> MSE_min: minimum of MSE; <br />
</p>
</li>
<li><p> number_of_iterations: number of iterations; <br />
</p>
</li>
<li><p> time: time of sampling in seconds, <br />
</p>
</li>
<li><p> n_simulations: the total number of simulations.
</p>
</li></ul>

<p><code>sampler_MaxWiK_parallel()</code> returns the same output as in <code>sampler_MaxWiK()</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>sampler_MaxWiK_parallel()</code>: Function to generate parameters and simulate a model based on MaxWiK algorithm
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>MaxWiK::MaxWiK_templates(dir = tempdir()) # See the template 'MaxWiK.Sampling.R' 
# and vignettes for usage.
MaxWiK::MaxWiK_templates(dir = tempdir()) # See the template 'MaxWiK.Sampling.R' 
# and vignettes for usage. For parallel implementation 
# change the function 'sampler_MaxWiK()' to 'sampler_MaxWiK_parallel()'.
</code></pre>

<hr>
<h2 id='sudoku'>The function to get the best tracer bullets related to kernel mean embedding</h2><span id='topic+sudoku'></span><span id='topic+get_pairs_of_data_frame'></span><span id='topic+generate_points_between_two_points'></span><span id='topic+get_tracer_bullets'></span>

<h3>Description</h3>

<p>The function <code>sudoku()</code> allows to get the best tracer bullets related to kernel mean embedding.
The calculation performs ONLY for parameters dataset DT = par.sim.
This function performs a heuristic algorithm to seek a space/area related to
the feature mapping in Hilbert space for the dataset of the parameters. <br />
The main idea of the algorithm is just: <br />
</p>

<ol>
<li><p> Generate points between the centers of Voronoi diagrams related to
the Maxima weighted feature mapping based on Isolation Kernel <br />
</p>
</li>
<li><p> Following strategy to puzzle out of SUDOKU: delete all points that do not match feature mapping <br />
</p>
</li>
<li><p> Output: The remaining points should be corresponding to the feature mapping.
</p>
</li></ol>

<p>The function <code>get_pairs_of_data_frame()</code> is used to get pairs of points
from the Data Frame that is the most distant each other.
In other words, the algorithm seeks the most distant coupled point to each point from the data frame
</p>
<p>The function <code>generate_points_between_two_points()</code> is used to generate
points between two given points
</p>
<p>The function <code>get_tracer_bullets()</code> is used to to get 'tracer bullets' or tracer points
generated between all the pairs of the most distant points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sudoku(DT, iKernelABC, n_bullets = 20, n_best = 10, halfwidth = 0.5)

get_pairs_of_data_frame(DF)

generate_points_between_two_points(pair, n = 10)

get_tracer_bullets(DF, n_bullets = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sudoku_+3A_dt">DT</code></td>
<td>
<p>Whole dataset of parameters</p>
</td></tr>
<tr><td><code id="sudoku_+3A_ikernelabc">iKernelABC</code></td>
<td>
<p>Result of calculations based on Isolation Kernel ABC
that can be gotten by the function <code>get.MaxWiK()</code></p>
</td></tr>
<tr><td><code id="sudoku_+3A_n_bullets">n_bullets</code></td>
<td>
<p>Integer number of tracer points between each pair of points from DF</p>
</td></tr>
<tr><td><code id="sudoku_+3A_n_best">n_best</code></td>
<td>
<p>Integer number of the best tracer bullets / points
to consider them at the next algorithmic step</p>
</td></tr>
<tr><td><code id="sudoku_+3A_halfwidth">halfwidth</code></td>
<td>
<p>Criterion to choose the best tracer points like: <br />
<code>if similarity_of_point &gt;= halfwidth</code> then it is the point to be included to the pool of the best points</p>
</td></tr>
<tr><td><code id="sudoku_+3A_df">DF</code></td>
<td>
<p>Data frame of oints that is used for generation of tracer points,
so it is usually a subset of points corresponding to Voronoi sites/seeds</p>
</td></tr>
<tr><td><code id="sudoku_+3A_pair">pair</code></td>
<td>
<p>Data frame of two points</p>
</td></tr>
<tr><td><code id="sudoku_+3A_n">n</code></td>
<td>
<p>Integer number of points that should be located between two input points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>sudoku()</code> returns the list of next objects:
</p>

<ul>
<li><p> tracer_bullets that is all the points generated during the run of the algorithm,
</p>
</li>
<li><p> criterion that is a value of the similarity that is used to choose the best tracer points,
</p>
</li>
<li><p> best_tracer_bullets that is the best tracer points that have similarity more or equal than <strong>criterion</strong> value,
</p>
</li>
<li><p> surroundings_best_points that is the best tracer points that have similarity more or equal than <strong>halfwidth</strong> value,
</p>
</li>
<li><p> feature_tracers that is results of the function <code>get_voronoi_feature_PART_dataset()</code> applied to the new tracer points,
</p>
</li>
<li><p> similarity_to_mean that is numeric vector of similarities of all the tracers points.
</p>
</li></ul>

<p>The function <code>get_pairs_of_data_frame()</code> returns the list of the pairs of points
</p>
<p>The function <code>generate_points_between_two_points()</code>
returns data frame of generated points between two given points,
including given points as the first and the last rows
</p>
<p>The function <code>get_tracer_bullets()</code> returns data frame of generated tracer points
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_pairs_of_data_frame()</code>: The function to get pairs from Data Frame
</p>
</li>
<li> <p><code>generate_points_between_two_points()</code>: The function to generate points between the pair of given points
</p>
</li>
<li> <p><code>get_tracer_bullets()</code>: The function to get 'tracer bullets' or tracer points
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>NULL

NULL 
NULL
NULL 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
