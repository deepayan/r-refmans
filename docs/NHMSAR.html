<!DOCTYPE html><html><head><title>Help for package NHMSAR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NHMSAR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NH-MSAR-package'>
<p>(Non) Homogeneous Markov switching autoregressive model</p></a></li>
<li><a href='#Cond.prob.MSAR'>
<p>Conditional probabilities for (non) homogeneous MSAR models</p></a></li>
<li><a href='#cor.MSAR'>
<p>Empirical correlation functions comparison .</p></a></li>
<li><a href='#cross.cor.MSAR'>
<p>empirical cross-correlation for multivariate MSAR time series</p></a></li>
<li><a href='#emisprob.MSAR.VM'><p>Emission probabilities for von Mises MSAR</p>
</a></li>
<li><a href='#ENu_graph'>
<p>Plots empirical expected number of upcrossings of level u with respect to P(Y&lt;u)</p></a></li>
<li><a href='#Estep.MSAR'>
<p>Estep of the EM algorithm for fitting (non) homogeneous Markov switching auto-regressive models.</p></a></li>
<li><a href='#Estep.MSAR.VM'>
<p>Estep of the EM algorithm for fitting von Mises (non) homogeneous Markov switching auto-regressive models.</p></a></li>
<li><a href='#fit.MSAR+20+28NH-MSAR+29'>
<p>Fit (non) homogeneous Markov switching autoregressive models</p></a></li>
<li><a href='#fit.MSAR.VM'>
<p>Fit von Mises (non) homogeneous Markov switching autoregressive models</p></a></li>
<li><a href='#forecast.prob.MSAR'>
<p>Forecast probabilities for (non) homogeneous MSAR models</p></a></li>
<li><a href='#forwards_backwards'>
<p>Forward Backward for homogeneous MSAR models</p></a></li>
<li><a href='#init.theta.MSAR+20+28NH-MSAR+29'>
<p>Initialisation function for MSAR model fitting</p></a></li>
<li><a href='#init.theta.MSAR.VM'>
<p>Initialisation function for von Mises MSAR model fitting</p></a></li>
<li><a href='#log_dens_Von_Mises'><p>von Mises log likelihood.</p></a></li>
<li><a href='#MeanDurOver'>
<p>Mean Duration of sojourn over a treshold</p></a></li>
<li><a href='#MeanDurUnder'>
<p>Mean Duration of sojourn under a treshold</p></a></li>
<li><a href='#meteo.data'>
<p>Meteorological at Brest (France) for January month from 1973 to 2013</p></a></li>
<li><a href='#Mstep.classif'>
<p>fit an AR model for each class of C</p></a></li>
<li><a href='#Mstep.hh.lasso.MSAR'>
<p>M step of the EM algorithm for fitting  homogeneous multivariate Markov switching auto-regressive models with penalization of parameters of the VAR(1) models.</p></a></li>
<li><a href='#Mstep.hh.MSAR'>
<p>M step of the EM algorithm for fitting  homogeneous Markov switching auto-regressive models.</p></a></li>
<li><a href='#Mstep.hh.MSAR.VM'>
<p>M step of the EM algorithm for fitting  von Mises Markov switching auto-regressive models.</p></a></li>
<li><a href='#Mstep.hh.MSAR.with.constraints'>
<p>M step of the EM algorithm for fitting  homogeneous multivariate Markov switching auto-regressive models with constraints on VAR models.</p></a></li>
<li><a href='#Mstep.hh.reduct.MSAR'>
<p>M step of the EM algorithm for fitting homogeneous Markov switching auto-regressive models with constraints on the matrices.</p></a></li>
<li><a href='#Mstep.hh.ridge.MSAR'>
<p>M step of the EM algorithm for fitting  homogeneous multivariate Markov switching auto-regressive models with penalization of parameters of the VAR(1) models.</p></a></li>
<li><a href='#Mstep.hh.SCAD.cw.MSAR'>
<p>M step of the EM algorithm for fitting  homogeneous multivariate Markov switching auto-regressive models with SCAD penalization of parameters of the VAR(1) models.</p></a></li>
<li><a href='#Mstep.hh.SCAD.MSAR'>
<p>M step of the EM algorithm for fitting  homogeneous multivariate Markov switching auto-regressive models with penalization of parameters of the VAR(1) models.</p></a></li>
<li><a href='#Mstep.hn.MSAR'>
<p>M step of the EM algorithm for fitting Markov switching auto-regressive models with non homogeneous emissions.</p></a></li>
<li><a href='#Mstep.nh.MSAR'>
<p>M step of the EM algorithm.</p></a></li>
<li><a href='#Mstep.nh.MSAR.VM'>
<p>M step of the EM algorithm for von Mises MSAR models</p></a></li>
<li><a href='#Mstep.nn.MSAR'>
<p>M step of the EM algorithm.</p></a></li>
<li><a href='#nhforwards_backwards'>
<p>Forward Backward for MSAR models with non homogeneous transitions</p></a></li>
<li><a href='#PibDetteDemoc'>
<p>Annual GDP and Debt data 1970-2010</p></a></li>
<li><a href='#prediction.MSAR'>
<p>One step ahead predict for (non) homogeneous MSAR models</p></a></li>
<li><a href='#regimes.plot.MSAR'>
<p>Plot MSAR time series with regimes</p></a></li>
<li><a href='#simule_MC'>
<p>Simulates Markov chain of length T</p></a></li>
<li><a href='#simule.nh.MSAR'>
<p>Simulation of (non) homogeneous Markov Stiwtching autoregressive models</p></a></li>
<li><a href='#simule.nh.MSAR.VM'>
<p>Simulation of (non) homogeneous Markov Stiwtching autoregressive models von Mises innovations</p></a></li>
<li><a href='#test.model.MSAR'>
<p>Performs bootstrap statistical tests to validate MSAR models.</p></a></li>
<li><a href='#test.model.vect.MSAR'>
<p>Performs bootstrap statistical tests on covariance to validate MSVAR models.</p></a></li>
<li><a href='#valid_all.MSAR'>
<p>Statistics plotting for validation of MSAR models</p></a></li>
<li><a href='#viterbi_path'>
<p>Viterbi path homogeneous MSAR models</p></a></li>
<li><a href='#Wind'>
<p>Winter wind data at 18 locations offshore of France</p></a></li>
<li><a href='#WindDir'>
<p>January wind direction at Ouessant</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Non-Homogeneous Markov Switching Autoregressive Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.19</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Valerie Monbet</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Valerie Monbet &lt;valerie.monbet@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calibration, simulation, validation of (non-)homogeneous Markov switching autoregressive models with Gaussian or von Mises innovations.  Penalization methods are implemented for Markov Switching Vector Autoregressive Models of order 1 only. Most functions of the package handle missing values.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Imports:</td>
<td>ucminf, lars, glasso, ncvreg</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-09 06:15:17 UTC; valerie</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-09 07:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='NH-MSAR-package'>
(Non) Homogeneous Markov switching autoregressive model
</h2><span id='topic+NH-MSAR-package'></span><span id='topic+NH-MSAR'></span>

<h3>Description</h3>

<p>NH-MSAR-package is a set of functions to fit, simulate and validate (non) homogeneous Markov Switching Autoregressive models with Gaussian or von Mises innovations.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> NH-MSAR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-08-11</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> What license is it under?</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>~~ An overview of how to use the package, including the most important ~~
~~ functions ~~
</p>


<h3>Author(s)</h3>

<p>Val\'e'rie Monbet, valerie.monbet@univ-rennes1.fr </p>


<h3>References</h3>

<p>Hamilton J.D. (1989). A New Approach to the Economic Analysis of Nonstionary Time Series and
the Business Cycle. Econometrica 57: 357-384.
Ailliot P., Monbet V., (2012), Markov-switching autoregressive models for wind time series. Environmental Modelling &amp; Software, 30, pp 92-101.
Ailliot P., Bessac J., Monbet V., Pene F., (2014) Non-homogeneous hidden Markov-switching models for wind time series. JSPI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# Fit Homogeneous MS-AR models - univariate time series
data(meteo.data)
data = array(meteo.data$temperature,c(31,41,1)) 
k = 40
T = dim(data)[1]
N.samples = dim(data)[2]
d = dim(data)[3]
M = 2
order = 2
theta.init = init.theta.MSAR(data,M=M,order=order,label="HH") 
mod.hh = fit.MSAR(data,theta.init,verbose=TRUE,MaxIter=20)
regimes.plot.MSAR(mod.hh,data,ylab="temperatures") 
#Y0 = array(data[1:2,sample(1:dim(data)[2],1),],c(2,1,1))
#Y.sim = simule.nh.MSAR(mod.hh$theta,Y0 = Y0,T,N.samples = 1)

## Not run
# Fit Non Homogeneous MS-AR models - univariate time series
#data(lynx)
#T = length(lynx)
#data = array(log10(lynx),c(T,1,1))
#theta.init = init.theta.MSAR(data,M=2,order=2,label="HH")
#mod.lynx.hh = fit.MSAR(data,theta.init,verbose=TRUE,MaxIter=200)
#regimes.plot.MSAR(mod.lynx.hh,data,ylab="Captures number")
## End (not run)
</code></pre>

<hr>
<h2 id='Cond.prob.MSAR'>
Conditional probabilities for (non) homogeneous MSAR models</h2><span id='topic+Cond.prob.MSAR'></span>

<h3>Description</h3>

<p>Computes, for each time <code class="reqn">t</code>, the conditional probabilities for MSAR models <code class="reqn">P(Y_t|y_{1:(t-1)},y_{(t+1):T})</code> where  <code class="reqn">Y</code> is the observed process and <code class="reqn">y</code> the observed time series.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cond.prob.MSAR(data, theta, yrange = NULL, covar.emis = NULL, covar.trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cond.prob.MSAR_+3A_data">data</code></td>
<td>

<p>observed time series, array of dimension T*N.samples*d 
</p>
</td></tr>
<tr><td><code id="Cond.prob.MSAR_+3A_theta">theta</code></td>
<td>

<p>object of class MSAR including the model's parameter and description. See init.theta.MSAR for more details. </p>
</td></tr>
<tr><td><code id="Cond.prob.MSAR_+3A_yrange">yrange</code></td>
<td>

<p>values at which to compute the conditional probabilities
</p>
</td></tr>
<tr><td><code id="Cond.prob.MSAR_+3A_covar.emis">covar.emis</code></td>
<td>

<p>emission covariate if any.</p>
</td></tr>
<tr><td><code id="Cond.prob.MSAR_+3A_covar.trans">covar.trans</code></td>
<td>

<p>transition covariate if any.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including
</p>
<table>
<tr><td><code>..$yrange</code></td>
<td>
<p>values at which the conditional probabilities are computed</p>
</td></tr>
<tr><td><code>..$prob</code></td>
<td>
<p>conditional probabilities for each time t and each values of yrange</p>
</td></tr>
<tr><td><code>..$Yhat</code></td>
<td>
<p>mode of the conditinal distribution for each time t</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>predict.MSAR</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lynx)
data = array(log10(lynx),c(length(lynx),1,1))
T = length(data)
theta.init = init.theta.MSAR(data,M=2,order=2,label="HH")
mod.lynx.hh = fit.MSAR(data,theta.init,verbose=TRUE,MaxIter=200)
ex = 100:114
lex = length(ex)
tps = (1821:1934)[ex] 
CP = Cond.prob.MSAR(array(data[ex,,],c(lex,1,1)), mod.lynx.hh$theta)
par(mfrow=c(2,1))
plot(tps,data[ex],typ="l",main="Homogeneous MSAR model",xlab="Time",ylab="Captured")
lines(tps,CP$Yhat,col="red")
alpha = .05
IC.emp = matrix(0,2,lex)
for (k in 1:lex) {
	tmp = cumsum(CP$prob[,k,])/sum(CP$prob[,k,])
	IC.emp[1,k] = CP$yrange[max(c(which(tmp&lt;alpha/2),1))]
	IC.emp[2,k] = CP$yrange[min(max(which(tmp&lt;(1-alpha/2))),length(CP$yrange))]
}
lines(tps,IC.emp[1,],lty=2,col="red")
lines(tps,IC.emp[2,],lty=2,col="red")

## Not run
#order = 2
#theta.init = init.theta.MSAR(data,M=2,order=2,label="NH",nh.transitions="logistic")
#theta.init$A0 = mod.lynx.hh$theta$A0
#theta.init$A = mod.lynx.hh$theta$A
#theta.init$sigma = mod.lynx.hh$theta$sigma
#theta.init$transmat = mod.lynx.hh$theta$transmat
#theta.init$prior = mod.lynx.hh$theta$prior
Y = array(data[2:T,,],c(T-1,1,1))
Z = array(data[1:(T-1),,],c(T-1,1,1))
#mod.lynx = fit.MSAR(array(Y,theta.init,covar.trans=Z)
Y.ex = array(data[ex,,],c(lex,1,1))
Z.ex = array(data[ex-1,,],c(lex,1,1))
#CPnh = Cond.prob.MSAR(Y.ex,mod.lynx$theta,covar.trans = Z.ex)
#
#plot(tps,data[ex],typ="l",main="Non Homogeneous MSAR model",xlab="Time",ylab="Captured")
#lines(tps,CPnh$Yhat,col="red")
#IC.emp = matrix(0,2,lex)
#for (k in 1:lex) {
#	tmp = cumsum(CPnh$prob[,k,])/sum(CPnh$prob[,k,])
#	IC.emp[1,k] = CPnh$yrange[max(c(which(tmp&lt;alpha/2),1))]
#	IC.emp[2,k] = CPnh$yrange[min(max(which(tmp&lt;(1-alpha/2))),length(CP$yrange))]
#}
#lines(tps,IC.emp[1,],lty=2,col="red")
#lines(tps,IC.emp[2,],lty=2,col="red")

</code></pre>

<hr>
<h2 id='cor.MSAR'>
Empirical correlation functions comparison .</h2><span id='topic+cor.MSAR'></span>

<h3>Description</h3>

<p>Empirical correlation function of observed data and simulated data are plotted on the same figure. 
A fluctuation interval of simulations is added to help the comparison. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.MSAR(data,data.sim,lag=NULL,nc=1,alpha=.05,plot=FALSE,
   xlab="Time (days)",dt=1,ylab="Correlation",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor.MSAR_+3A_data">data</code></td>
<td>

<p>observed (or reference) time series, array of dimension T*N.samples*d </p>
</td></tr>
<tr><td><code id="cor.MSAR_+3A_data.sim">data.sim</code></td>
<td>

<p>simulated time series, array of dimension T*N.sim*d.
N.sim have to be  K*N.samples with K large enough (for instance, K=100) </p>
</td></tr>
<tr><td><code id="cor.MSAR_+3A_lag">lag</code></td>
<td>

<p>maximum lag at which to calculate the empirical auto-correlation function. 
Default floor(T/2) with T the length of each data sample. </p>
</td></tr>
<tr><td><code id="cor.MSAR_+3A_nc">nc</code></td>
<td>

<p>number of component for which to calculate the empirical auto-correlation function. </p>
</td></tr>
<tr><td><code id="cor.MSAR_+3A_alpha">alpha</code></td>
<td>

<p>confidence level for computation of the fluctuation interval. Default= 0.05.</p>
</td></tr>
<tr><td><code id="cor.MSAR_+3A_plot">plot</code></td>
<td>
<p>if plot is TRUE plots are drawn (default is FALSE).</p>
</td></tr>
<tr><td><code id="cor.MSAR_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="cor.MSAR_+3A_dt">dt</code></td>
<td>
<p>default time step is equal to 1</p>
</td></tr>
<tr><td><code id="cor.MSAR_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="cor.MSAR_+3A_...">...</code></td>
<td>
<p>for optional plot arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The auto-correlation functions are computed from one or several independent realizations of the same length. 
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>C.data</code></td>
<td>
<p>observed data acf</p>
</td></tr>
<tr><td><code>C.sim</code></td>
<td>
<p>simulated data acf</p>
</td></tr>
<tr><td><code>CI.sim</code></td>
<td>
<p>fluctuation interval for each lag</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>abscissa for acfs</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Bessac, J., Ailliot, P., Monbet, V. (2015). Gaussian linear state-space model for wind fields in the North-East Atlantic. 
Environmetrics, 26(1), 29-38.</p>


<h3>See Also</h3>

<p>cross.cor.MSAR, cor 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run
#data(Wind)
#T = dim(U)[1]
#N.samples = dim(U)[2]
#Y = array(U[,,1],c(T,N.samples,1))

#theta.init=init.theta.MSAR(Y,M=2,order=1,label="HH")
#res.hh = fit.MSAR(Y,theta.init,verbose=TRUE,MaxIter=10)
#Bsim = 2
#Ksim = Bsim*N.samples
#Y0 = array(Y[1,sample(1:dim(Y)[2],1,replace=T),],c(2,Ksim,1))
#Y.sim = simule.nh.MSAR(res.hh$theta,Y0 = Y0,T,N.samples = Ksim) 
#c = cor.MSAR(Y,Y.sim$Y)
#plot(c$lags/4,c$C.data,typ="l",xlab="Time (days)",ylab="ACF",xlim=c(0,8))
#abline(h=0,lty=3,col="gray")
#lines(c$lags/4,c$C.sim,col="red")
#lines(c$lags/4,c$CI.sim[1,],col="red",lty=2)
#lines(c$lags/4,c$CI.sim[2,],col="red",lty=2)
</code></pre>

<hr>
<h2 id='cross.cor.MSAR'>
empirical cross-correlation for multivariate MSAR time series </h2><span id='topic+cross.cor.MSAR'></span>

<h3>Description</h3>

<p>cross.cor.MSAR computes the cross-correlation between two components. The cross-corelation can be estimted for the whole time series or regime by regime. </p>


<h3>Usage</h3>

<pre><code class='language-R'>cross.cor.MSAR(data, X=NULL, nc1 = 1, nc2 = 2, lag = 10, regime = 0, 
CI = FALSE, Bsim = 0, N.samples = 1, add = FALSE, 
col = 1, names = NULL, alpha = 0.1,ylab="Cross-Correlation", dt = 1, ylim = c(-0.1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross.cor.MSAR_+3A_data">data</code></td>
<td>

<p>observed (or reference) time series, array of dimension T*N.samples*d </p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_x">X</code></td>
<td>

<p>time series of regimes associated to data</p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_nc1">nc1</code></td>
<td>

<p>first component to be considered</p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_nc2">nc2</code></td>
<td>

<p>second component to be considered</p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_lag">lag</code></td>
<td>

<p>maximum lag (default=10). The cross-correlation is estimated for lags -lag:lag.
</p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_regime">regime</code></td>
<td>

<p>has to be an integer between 0 and M, with M the number of regimes. If regime=0, the cross correlaiton is computed for the whole time series. If regime=m&gt;0, the corss corelation is computed considereing only the sub-sequences in regime m.  </p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_ci">CI</code></td>
<td>

<p>If CI=TRUE fluctuation intervals are computed, default is FALSE</p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_bsim">Bsim</code></td>
<td>

<p>useful for computation of confidence intervals. When observed and simulated data are compared, one expects that the number of simulated time series is Bsim*N.samples </p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_n.samples">N.samples</code></td>
<td>

<p>useful for computation of confidence intervals. N.sample describes the number of independant time series in the observed (or reference) data </p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_dt">dt</code></td>
<td>
<p>default time step is equal to 1</p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_add">add</code></td>
<td>

<p>if add=TRUE the empirical cross-correlation is added to the current plot.</p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_col">col</code></td>
<td>

<p>color of the line</p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_names">names</code></td>
<td>

<p>list with the names of components of data</p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_alpha">alpha</code></td>
<td>

<p>level for the computation of the fluctuation intervals. default=0.1</p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_ylab">ylab</code></td>
<td>

<p>legend for y axis</p>
</td></tr>
<tr><td><code id="cross.cor.MSAR_+3A_ylim">ylim</code></td>
<td>

<p>limit for y axis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cross-correlation functions are computed from one or several independent realizations of the same length.
</p>


<h3>Value</h3>

<p>returns a list including:
</p>
<table>
<tr><td><code>..$ccf</code></td>
<td>
<p>empirical cross-correlation</p>
</td></tr>
<tr><td><code>..$lag</code></td>
<td>
<p>abscissa for the cross-correlation</p>
</td></tr>
<tr><td><code>..$CI</code></td>
<td>
<p>fluctuation intervals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Bessac, J., Ailliot, P., &amp; Monbet, V. (2013). Gaussian linear state-space model for wind fields in the North-East Atlantic. arXiv preprint arXiv:1312.5530.</p>


<h3>See Also</h3>

<p>cor.MSAR, cor, valid_all</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Wind)
T = dim(U)[1]
c = cross.cor.MSAR(U,nc1=1,nc2=18,names=1:18)
## Not run
#Y = U[,,c(1,18)]
#theta.init=init.theta.MSAR(Y,M=2,order=2,label="HH")
#res.hh = fit.MSAR(Y,theta.init,verbose=TRUE,MaxIter=200)
#Bsim = 20
#N.samples = dim(U)[2]
#Ksim = Bsim*N.samples
#Y0 = Y0
#Y.sim = simule.nh.MSAR(res.hh$theta,Y0 = Y0,T,N.samples = Ksim) 
#c.sim = cross.cor.MSAR(Y.sim$Y,nc1=1,nc2=2,names=c(1,18),
#   CI=TRUE,Bsim=Bsim,N.samples=N.samples,add=TRUE,col="red")
</code></pre>

<hr>
<h2 id='emisprob.MSAR.VM'>Emission probabilities for von Mises MSAR

</h2><span id='topic+emisprob.MSAR.VM'></span>

<h3>Description</h3>

<p>Computes emission probabilities for von Mises MSAR models</p>


<h3>Usage</h3>

<pre><code class='language-R'>emisprob.MSAR.VM(data, theta, covar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emisprob.MSAR.VM_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.</p>
</td></tr>
<tr><td><code id="emisprob.MSAR.VM_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.VM.</p>
</td></tr>
<tr><td><code id="emisprob.MSAR.VM_+3A_covar">covar</code></td>
<td>

<p>covariables for emission probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prob : emission probabilities for each observation and each regime</p>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Bessac J., Monbet V., Pene F., (2014) Non-homogeneous hidden Markov-switching models for wind time series. JSPI. </p>


<h3>See Also</h3>

<p>emisprob.MSAR</p>

<hr>
<h2 id='ENu_graph'>
Plots empirical expected number of upcrossings of level u with respect to P(Y&lt;u) </h2><span id='topic+ENu_graph'></span>

<h3>Description</h3>

<p>Plots empirical expected number of upcrossings of level u with respect to P(Y&lt;u) </p>


<h3>Usage</h3>

<pre><code class='language-R'>ENu_graph(data, u, lty = 1, col = 1, add = FALSE, CI = FALSE, alpha = 0.05,
 N.s.data = NULL, xlab = "P(Y&lt;u)", 
 ylab = "Intensity of upcrossings", ylim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ENu_graph_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.</p>
</td></tr>
<tr><td><code id="ENu_graph_+3A_u">u</code></td>
<td>

<p>sequence of levels to be considered</p>
</td></tr>
<tr><td><code id="ENu_graph_+3A_lty">lty</code></td>
<td>

<p>type of line</p>
</td></tr>
<tr><td><code id="ENu_graph_+3A_col">col</code></td>
<td>

<p>color of line</p>
</td></tr>
<tr><td><code id="ENu_graph_+3A_add">add</code></td>
<td>

<p>if add=TRUE lines is added to current plot</p>
</td></tr>
<tr><td><code id="ENu_graph_+3A_ci">CI</code></td>
<td>

<p>if CI=TRUE a fluctuation interval at 1-alpha level of confidence is computed and plotted</p>
</td></tr>
<tr><td><code id="ENu_graph_+3A_alpha">alpha</code></td>
<td>

<p>confidence level</p>
</td></tr>
<tr><td><code id="ENu_graph_+3A_n.s.data">N.s.data</code></td>
<td>

</td></tr>
<tr><td><code id="ENu_graph_+3A_xlab">xlab</code></td>
<td>

<p>a title for the x axis</p>
</td></tr>
<tr><td><code id="ENu_graph_+3A_ylab">ylab</code></td>
<td>

<p>a title for the y axis</p>
</td></tr>
<tr><td><code id="ENu_graph_+3A_ylim">ylim</code></td>
<td>

<p>numeric vectors of length 2, giving the  y coordinates ranges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list including
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>sequence of levels</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>empirical cdf: P(data&lt;u)</p>
</td></tr>
<tr><td><code>Nu</code></td>
<td>
<p>number of upcrossings</p>
</td></tr>
<tr><td><code>CI.</code></td>
<td>
<p>fluctuation interval</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>valid_all</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meteo.data)
data = array(meteo.data$temperature,c(31,41,1)) 
T = dim(data)[1]
N.samples = dim(data)[2]
d = dim(data)[3]
M = 2
order = 1
theta.init = init.theta.MSAR(data,M=M,order=order,label="HH")
mod.hh= NULL
mod.hh$theta = theta.init
mod.hh$theta$A = matrix(c(0.40,0.88,-.09,-.13),2,2)
mod.hh$theta$A0 = matrix(c(6.75,1.08),2,1)
mod.hh$theta$sigma = matrix(c(1.76,3.40),2,1)
mod.hh$theta$prior = matrix(c(0.37,0.63),2,1)
mod.hh$theta$transmat = matrix(c(0.82,0.09,0.18,0.91),2,2)
#B.sim = 100*N.samples
#Y0 = array(data[1:2,sample(1:dim(data)[2],B.sim,replace=TRUE),],c(2,B.sim,1))
#Y.sim = simule.nh.MSAR(mod.hh$theta,Y0=Y0,T,N.samples=B.sim)
u = seq(min(data),max(data),by=.3)
gr.d = ENu_graph(data,u)
#gr = ENu_graph(Y.sim$Y,u,col=2,add=TRUE,CI = TRUE,N.s.data=dim(data)[2])
</code></pre>

<hr>
<h2 id='Estep.MSAR'>
Estep of the EM algorithm for fitting (non) homogeneous Markov switching auto-regressive models. </h2><span id='topic+Estep.MSAR'></span>

<h3>Description</h3>

<p>Forward-backward algorithm called in fit.MSAR. </p>


<h3>Usage</h3>

<pre><code class='language-R'>Estep.MSAR(data, theta, smth = FALSE, 
           verbose = FALSE, 
           covar.emis = covar.emis, covar.trans = covar.trans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Estep.MSAR_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Estep.MSAR_+3A_theta">theta</code></td>
<td>
<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
.</p>
</td></tr>
<tr><td><code id="Estep.MSAR_+3A_smth">smth</code></td>
<td>

<p>If smth=FALSE, only the forward step is computed for forecasting probabilities. 
If smth=TRUE, the smoothing probabilities are computed too. </p>
</td></tr>
<tr><td><code id="Estep.MSAR_+3A_verbose">verbose</code></td>
<td>

<p>if verbose=TRUE some results are printed at each iteration. </p>
</td></tr>
<tr><td><code id="Estep.MSAR_+3A_covar.emis">covar.emis</code></td>
<td>

<p>covariables for emission probabilities.</p>
</td></tr>
<tr><td><code id="Estep.MSAR_+3A_covar.trans">covar.trans</code></td>
<td>

<p>covariables for transition probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>log likelihood</p>
</td></tr>
<tr><td><code>probS</code></td>
<td>
<p>smoothing probabilities: <code class="reqn">P(S_t=s|y_0,\cdots,y_T)</code></p>
</td></tr>
<tr><td><code>probSS</code></td>
<td>
<p>one step smoothing probabilities: <code class="reqn">P(S_t=s,S_{t+1}|y_0,\cdots,y_T)</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Monbet V., (2012), Markov switching autoregressive models for wind time series. Environmental Modelling &amp; Software, 30, pp 92-101.</p>


<h3>See Also</h3>

<p>fit.MSAR, Mstep.hh.MSAR</p>


<h3>Examples</h3>

<pre><code class='language-R'>#see fit.MSAR</code></pre>

<hr>
<h2 id='Estep.MSAR.VM'>
Estep of the EM algorithm for fitting von Mises (non) homogeneous Markov switching auto-regressive models.</h2><span id='topic+Estep.MSAR.VM'></span>

<h3>Description</h3>

<p>Forward-backward algorithm called in fit.MSAR.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Estep.MSAR.VM(data, theta, smth = FALSE, verbose = FALSE, 
   covar.emis = NULL, covar.trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Estep.MSAR.VM_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Estep.MSAR.VM_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.</p>
</td></tr>
<tr><td><code id="Estep.MSAR.VM_+3A_smth">smth</code></td>
<td>

<p>If smth=FALSE, only the forward step is computed for forecasting probabilities. If smth=TRUE, the smoothing probabilities are computed too. </p>
</td></tr>
<tr><td><code id="Estep.MSAR.VM_+3A_verbose">verbose</code></td>
<td>

</td></tr>
<tr><td><code id="Estep.MSAR.VM_+3A_covar.emis">covar.emis</code></td>
<td>

<p>covariables for emission probabilities.</p>
</td></tr>
<tr><td><code id="Estep.MSAR.VM_+3A_covar.trans">covar.trans</code></td>
<td>

<p>covariables for transition probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list including
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>log likelihood</p>
</td></tr>
<tr><td><code>probS</code></td>
<td>
<p>smoothing probabilities: <code class="reqn">P(S_t=s|y_0,\cdots,y_T)</code></p>
</td></tr>
<tr><td><code>probSS</code></td>
<td>
<p>one step smoothing probabilities: <code class="reqn">P(S_t=s,S_{t+1}|y_0,\cdots,y_T)</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Bessac J., Monbet V., Pene F., (2014) Non-homogeneous hidden Markov-switching models for wind time series. JSPI.</p>


<h3>See Also</h3>

<p>fit.MSAR.VM, Mstep.hh.MSAR.VM,Estep.MSAR</p>

<hr>
<h2 id='fit.MSAR+20+28NH-MSAR+29'>
Fit (non) homogeneous Markov switching autoregressive models</h2><span id='topic+fit.MSAR'></span>

<h3>Description</h3>

<p>Fit (non) homogeneous Markov switching autoregressive models by EM algorithm. Non homogeneity may be introduced at the intercept level or in the probability transitions. The link functions are defined in the initialisation step (running init.theta.MSAR.R). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.MSAR(data, theta, MaxIter = 100, eps = 1e-05, verbose = FALSE, 
   covar.emis = NULL, covar.trans = NULL, method = NULL, 
   constraints = FALSE, reduct=FALSE, K = NULL, d.y = NULL, 
   ARfix = FALSE,penalty=FALSE,sigma.diag=FALSE, sigma.equal=FALSE,
   lambda1=.1,lambda2=.1,a=3.7,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_theta">theta</code></td>
<td>

<p>initial parameter obtained running function init.theta.MSAR.R; object of class MSAR.
</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_maxiter">MaxIter</code></td>
<td>

<p>maximum number of iteration for EM algorithm (default : 100)</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_eps">eps</code></td>
<td>
<p> Tolerance for likelihood.
</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_verbose">verbose</code></td>
<td>

<p>if verbose=TRUE, the value of log-likelihood is printed at each EM-algorithm's iteration</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_covar.emis">covar.emis</code></td>
<td>

<p>array of univariate or multivariate series of covariate to take into account in the intercept of the autoregressive models. 
The link function is defined in the initialisation step (running init.theta.MSAR.R). </p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_covar.trans">covar.trans</code></td>
<td>

<p>array of univariate or multivariate series of covariate to take into account in the transition probabilities.
The link function is defined in the initialisation step (running init.theta.MSAR.R).</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_method">method</code></td>
<td>

<p>permits to choice the optimization algorithm if numerical optimisation is required in M step. Default : &quot;ucminf&quot;. Other choices : &quot;L-BFGS-B&quot;, &quot;BFGS&quot;</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_constraints">constraints</code></td>
<td>

<p>if constraints = TRUE constraints are added to theta in order that matrices A and sigma are diagonal by blocks. </p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_k">K</code></td>
<td>

<p>number of sites. For instance, if one considers wind at k locations, K=k. Or more generally number of independent groups of components.  </p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_d.y">d.y</code></td>
<td>

<p>dimension in each sites. For instance, if one considers only wind intensity than d.y = 1; but, if one considers cartesian components of wind, then d.y =2.</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_arfix">ARfix</code></td>
<td>
<p>if TRUE the AR parameters are not estimated, they stay fixed at their initial value.</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_reduct">reduct</code></td>
<td>
<p>if TRUE, autoregressive matrices and innovation covariance matrices are constrained to have the same pattern (zero and non zero coefficients) as the one of initial matrices.   </p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_sigma.diag">sigma.diag</code></td>
<td>
<p>If sigma.diag==TRUE the estimated covariance of the innovation will be diagonal 
(default is FALSE) -  available only for HH models 
</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_sigma.equal">sigma.equal</code></td>
<td>
<p>If sigma.equal==TRUE the estimated covariance of the innovation will be the same in all regimes -  available only for models with homogeneous emission probabilities
(default is FALSE)</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_penalty">penalty</code></td>
<td>
<p>choice of the penalty for the autoregressive matrices. Possible values are ridge (available for regression matrices only), lasso or SCAD (default). </p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_lambda1">lambda1</code></td>
<td>

<p>penalization constant for the precision matrices. It may be a scalar or a vector of length M (with M the number of regimes). If it is equal to 0 no penalization is introduced for the precision matrices. </p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_lambda2">lambda2</code></td>
<td>

<p>penalization constant for the autoregressive matrices (available only for MSAR of order 1). It may be a scalar or a vector of length M (with M the number of regimes). If lambda2 is a scalar, it is weighted by the prior in each regime.  </p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_a">a</code></td>
<td>
<p>fixed penalisation constant for SCAD penalty</p>
</td></tr>
<tr><td><code id="fit.MSAR+2B20+2B28NH-MSAR+2B29_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The homogeneous MSAR model is labeled &quot;HH&quot; and it is written
</p>
<p style="text-align: center;"><code class="reqn">
P(X_t|X_{t-1}=x_{t-1}) = Q_{x_{t-1},x_t}</code>
</p>
<p> with <code class="reqn">X_t</code> the hidden univariate process defined on <code class="reqn">\{1,\cdots,M \}</code>
</p>
<p style="text-align: center;"><code class="reqn">
Y_t|X_t=x_t,y_{t-1},...,y_{t-p} = \alpha_0^{x_t}+\alpha_1^{x_t}y_{t-1}+...+\alpha_p^{x_t}y_{t-p}+\sigma \epsilon_t</code>
</p>
<p> with <code class="reqn">Y_t</code> the observed process and <code class="reqn">\epsilon</code> a Gaussian white noise. <code class="reqn">Y_t</code> may be mutivariate. 
</p>
<p>The model with non homogeneous emissions is labeled &quot;HN&quot; and it is written
</p>
<p style="text-align: center;"><code class="reqn">P(X_t|X_{t-1}=x_{t-1}) = Q_{x_{t-1},x_t}</code>
</p>
<p> with <code class="reqn">X_t</code> the hidden process
</p>
<p style="text-align: center;"><code class="reqn">Y_t|X_t=x_t,y_{t-1},...,y_{t-p} = f(z_t,\theta_z^{x_t})+\alpha_1^{x_t}y_{t-1}+...+\alpha_p^{x_t}y_{t-p}+\sigma \epsilon_t</code>
</p>
<p> with <code class="reqn">Y_t</code> the observed process, <code class="reqn">\epsilon</code> a Gaussian white noise and <code class="reqn">Z_t</code> a covariate. 
</p>
<p>The model with non homogeneous transitions is labeled &quot;NH&quot; and it is written
</p>
<p style="text-align: center;"><code class="reqn">P(X_t|X_{t-1}=x_{t-1}) = q(z_t,\theta_{z_t})</code>
</p>
<p> with <code class="reqn">X_t</code> the hidden process and <code class="reqn">q</code> a link function which has a Gaussian shape by default. 
</p>
<p style="text-align: center;"><code class="reqn">Y_t|X_t=x_t,y_{t-1},...,y_{t-p} = \alpha_0^{x_t}+\alpha_1^{x_t}y_{t-1}+...+\alpha_p^{x_t}y_{t-p}+\sigma \epsilon_t</code>
</p>
<p> with <code class="reqn">Y_t</code> the observed process, <code class="reqn">\epsilon</code> a Gaussian white noise and <code class="reqn">Z_t</code> a covariate.</p>


<h3>Value</h3>

<p>For fit.MSAR and its methods a list of class &quot;MSAR&quot; with the following elements:
</p>
<p>Returns a list including:
</p>
<table>
<tr><td><code>..$theta</code></td>
<td>
<p>object of class MSAR containing the estimated values of the parameter and some descriptors of the fitted model. See init.theta.MSAR for a detailled description.   </p>
</td></tr>
<tr><td><code>..$ll_history</code></td>
<td>
<p>log-likelihood for each iterations of the EM algorithm. </p>
</td></tr>
<tr><td><code>..$Iter</code></td>
<td>
<p>number of iterations run before EM converged</p>
</td></tr>
<tr><td><code>..$Npar</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code>..$BIC</code></td>
<td>
<p>Bayes Information Criterion</p>
</td></tr>
<tr><td><code>..$smoothedprob</code></td>
<td>
<p>smoothing probabilities <code class="reqn">P(X_t|y_0,\cdots,y_T)</code></p>
</td></tr>
</table>
<p>Penalized likelihood is considered if at least one of the lambdas parameters are non zero. When LASSO penalty is chosen, the LARS algorithm is used. When SCAD is chosen, a Newton-Raphson algorithm is run with a quadratic approximation of the penalized likelihood. 
For the precision matrices penalization, the package glasso is used. 
Limit of this function: likelihood penalization only works for VAR(1) models
</p>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet at univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Monbet V., (2012), Markov-switching autoregressive models for wind time series. Environmental Modelling &amp; Software, 30, pp 92-101. 
Efron, B., Hastie, T., Johnstone, I., Tibshirani, R., et al. (2004). Least angle regression. The Annals of statistics, 32(2):407-499.
</p>
<p>Fan, J. and Li, R. (2001). Variable selection via nonconcave penalized likelihood and its oracle properties. Journal of the American statistical Association, 96(456):1348-1360. 
Hamilton J.D. (1989). A New Approach to the Economic Analysis of Nonstionary Time Series and the Business Cycle. Econometrica 57: 357-384.
</p>


<h3>See Also</h3>

<p>init.theta.MSAR, regimes.plot.MSAR, simule.nh.ex.MSAR, depmixS4, MSBVAR
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit Homogeneous MS-AR models - univariate time series
data(meteo.data)
data = array(meteo.data$temperature,c(31,41,1)) 
k = 40
T = dim(data)[1]
N.samples = dim(data)[2]
d = dim(data)[3]
M = 2
order = 2 # MSAR of order 2
theta.init = init.theta.MSAR(data,M=M,order=order,label="HH") 
mod.hh = fit.MSAR(data,theta.init,verbose=TRUE,MaxIter=20)
#regimes.plot.MSAR(mod.hh,data,ylab="temperatures") 
#Y0 = array(data[1:2,sample(1:dim(data)[2],1),],c(2,1,1))
#Y.sim = simule.nh.MSAR(mod.hh$theta,Y0 = Y0,T,N.samples = 1)

## Not run
# Fit Non Homogeneous MS-AR models - univariate time series
#data(lynx)
#T = length(lynx)
#data = array(log10(lynx),c(T,1,1))
#theta.init = init.theta.MSAR(data,M=2,order=2,label="HH")
#mod.lynx.hh = fit.MSAR(data,theta.init,verbose=TRUE,MaxIter=200)
#regimes.plot.MSAR(mod.lynx.hh,data,ylab="Captures number")

#theta.init = init.theta.MSAR(data,M=2,order=2,label="NH",nh.transitions="logistic")
attributes(theta.init)
#theta.init$A0 = mod.lynx.hh$theta$A0
#theta.init$A = mod.lynx.hh$theta$A
#theta.init$sigma = mod.lynx.hh$theta$sigma
#theta.init$transmat = mod.lynx.hh$theta$transmat
#theta.init$prior = mod.lynx.hh$theta$prior
#Y = array(data[2:T,,],c(T-1,1,1))
#Z = array(data[1:(T-1),,],c(T-1,1,1))
#mod.lynx = fit.MSAR(Y,theta.init,verbose=TRUE,MaxIter=200,covar.trans=Z)
#regimes.plot.MSAR(mod.lynx,Y),ylab="Captures number")

# Fit Homogeneous MS-AR models - multivariate time series
#data(PibDetteDemoc)
#T = length(unique(PibDetteDemoc$year))-1
#N.samples = length(unique(PibDetteDemoc$country))
#PIB = matrix(PibDetteDemoc$PIB,N.samples,T+1)
#Dette = matrix(PibDetteDemoc$Dette,N.samples,T+1)
#Democratie = matrix(PibDetteDemoc$Democratie,N.samples,T+1)

#d = 2
#Y = array(0,c(T,N.samples,2))
#for (k in 1:N.samples) {
#   Y[,k,1] = diff(log(PIB[k,]))
#   Y[,k,2] = diff(log(Dette[k,]))
#}
#Democ = Democratie[,2:(T+1)] 
#theta.hh = init.theta.MSAR(Y,M=M,order=1,label="HH")
#res.hh = fit.MSAR(Y,theta.hh,verbose=TRUE,MaxIter=200)
#regime.hh = apply(res.hh$smoothedprob,c(1,2),which.max)

## Not run
# Fit Non Homogeneous (emission) MS-AR models - multivariate time series
#theta.hn = init.theta.MSAR(Y,M=M,order=1,label="HN",ncov.emis=1)
#theta.hn$A0 = res.hh$theta$A0
#theta.hn$A = res.hh$theta$A
#theta.hn$sigma = res.hh$theta$sigma
#theta.hn$transmat = res.hh$theta$transmat
#theta.hn$prior = res.hh$theta$prior
#Z = array(t(Democ[,2:T]),c(T,N.samples,1))
#res.hn = fit.MSAR(Y,theta.hn,verbose=TRUE,MaxIter=200,covar.emis=Z)

# Fit Non Homogeneous (transitions) MS-AR models - multivariate time series
#theta.nh = init.theta.MSAR(Y,M=M,order=1,label="NH",nh.transitions="gauss",ncov.trans=1)
#theta.nh$A0 = res.hh$theta$A0
#theta.nh$A = res.hh$theta$A
#theta.nh$sigma = res.hh$theta$sigma
#theta.nh$transmat = res.hh$theta$transmat
#theta.nh$prior = res.hh$theta$prior
#theta.nh$par.trans[1:2,1] = 10
#theta.nh$par.trans[3:4,1] = 0
#theta.nh$par.trans[,2] = 2
#Z = array(t(Democ[,2:T]),c(T,N.samples,1))
#res.nh = fit.MSAR(Y,theta.nh,verbose=TRUE,MaxIter=200,covar.trans=Z)
</code></pre>

<hr>
<h2 id='fit.MSAR.VM'>
Fit von Mises (non) homogeneous Markov switching autoregressive models</h2><span id='topic+fit.MSAR.VM'></span>

<h3>Description</h3>

<p>Fit von Mises (non) homogeneous Markov switching autoregressive models by EM algorithm. Non homogeneity may be introduced at the intercept level or in the probability transitions. The link functions are defined in the initialisation step (running init.theta.MSAR.VM.R). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.MSAR.VM(data, theta, 
           MaxIter = 100, eps = 1e-05, verbose = FALSE, 
           covar.emis = NULL, covar.trans = NULL, 
           method = NULL, constr = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.MSAR.VM_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="fit.MSAR.VM_+3A_theta">theta</code></td>
<td>

<p>initial parameter obtained running function init.theta.MSAR.R; object of class MSAR.
</p>
</td></tr>
<tr><td><code id="fit.MSAR.VM_+3A_maxiter">MaxIter</code></td>
<td>

<p>maximum number of iteration for EM algorithm (default : 100)</p>
</td></tr>
<tr><td><code id="fit.MSAR.VM_+3A_eps">eps</code></td>
<td>
<p> Tolerance for likelihood.
</p>
</td></tr>
<tr><td><code id="fit.MSAR.VM_+3A_verbose">verbose</code></td>
<td>

<p>if verbose=TRUE, the value of log-likelihood is printed at each EM-algorithm's iteration</p>
</td></tr>
<tr><td><code id="fit.MSAR.VM_+3A_covar.emis">covar.emis</code></td>
<td>

<p>array of univariate or multivariate series of covariate to take into account in the intercept of the autoregressive models. 
The link function is defined in the initialisation step (running init.theta.MSAR.R). </p>
</td></tr>
<tr><td><code id="fit.MSAR.VM_+3A_covar.trans">covar.trans</code></td>
<td>

<p>array of univariate or multivariate series of covariate to take into account in the transition probabilities.
The link function is defined in the initialisation step (running init.theta.MSAR.R).</p>
</td></tr>
<tr><td><code id="fit.MSAR.VM_+3A_method">method</code></td>
<td>

<p>permits to choice the optimization algorithm if numerical optimisation is required in M step. Default : &quot;ucminf&quot;. Other choices : &quot;L-BFGS-B&quot;, &quot;BFGS&quot;</p>
</td></tr>
<tr><td><code id="fit.MSAR.VM_+3A_constr">constr</code></td>
<td>

<p>if constr = 1 constraints are added to theta  </p>
</td></tr>
<tr><td><code id="fit.MSAR.VM_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The homogeneous MSAR model is labeled &quot;HH&quot; and it is written
</p>
<p style="text-align: center;"><code class="reqn">
P(X_t|X_{t-1}=x_{t-1}) = Q_{x_{t-1},x_t}</code>
</p>
<p> with <code class="reqn">X_t</code> the hidden univariate process defined on <code class="reqn">\{1,\cdots,M \}</code>
</p>
<p style="text-align: center;"><code class="reqn">
Y_t|X_t=x_t,y_{t-1},...,y_{t-p}</code>
</p>
<p> has a von Mises distribution with density </p>
<p style="text-align: center;"><code class="reqn"> p_2(y_t|x_t,y_{t-s}^{t-1}) = \frac {1}{b(x_t,y_{t-s}^{t-1})} \exp\left(\kappa_0^{(x_t)} \cos(y_t-\phi_0^{(x_t)})+
    \sum_{\ell=1}^s\kappa_\ell^{(x_t)} \cos(y_t-y_{t-\ell}-\phi_\ell^{(x)})\right)</code>
</p>

<p>which is equivalent to
</p>
<p style="text-align: center;"><code class="reqn"> p_2(y_t|x_t,y_{t-s}^{t-1}) =\frac{1}{b(x_t,y_{t-s}^{t-1})} \left|\exp\left([\gamma_0^{(x_t)} +
    \sum_{\ell=1}^s\gamma_\ell^{(x_t)} e^{iy_{t-\ell}}]e^{-iy_t}\right)\right|</code>
</p>

<p><code class="reqn">b(x_t,y_{t-s}^{t-1})</code> is a normalization constant. 
</p>
<p>Both the real and the complex formulation are implemented. In practice, the complex version is used if the initial <code class="reqn">\kappa</code> is complex. 
</p>
<p>The model with non homogeneous transitions is labeled &quot;NH&quot; and it is written
</p>
<p style="text-align: center;"><code class="reqn">P(X_t|X_{t-1}=x_{t-1}) = q(z_t,\theta_{z_t})</code>
</p>
<p> with <code class="reqn">X_t</code> the hidden process and <code class="reqn">q</code> von Mises link function such that </p>
<p style="text-align: center;"><code class="reqn">p_1(x_t|x_{t-1},z_{t}) =\frac{  q_{x_{t-1},x_t}\left|\exp 
   \left(\tilde\lambda_{x_{t-1},x_t} e^{-iz_{t}} \right)\right|}
    {\sum_{x'=1}^M q_{x_{t-1},x'}\left|\exp 
   \left(\tilde\lambda_{x_{t-1},x'} e^{-iz_{t}} \right)\right|},
</code>
</p>
 
<p>with <code class="reqn">\tilde\lambda_{x,x'}</code> a complex parameter (by taking <code class="reqn">\tilde\lambda_{x,x'}=\lambda_{x,x'}
    e^{i\psi_{x,x'}}</code>). 
</p>


<h3>Value</h3>

<p>For fit.MSAR and its methods a list of class &quot;MSAR&quot; with the following elements:
</p>
<p>Returns a list including:
</p>
<table>
<tr><td><code>..$theta</code></td>
<td>
<p>object of class MSAR containing the estimated values of the parameter and some descriptors of the fitted model. See init.theta.MSAR.VM for a detailled description.   </p>
</td></tr>
<tr><td><code>..$ll_history</code></td>
<td>
<p>log-likelihood for each iterations of the EM algorithm. </p>
</td></tr>
<tr><td><code>..$Iter</code></td>
<td>
<p>number of iterations run before EM converged</p>
</td></tr>
<tr><td><code>..$Npar</code></td>
<td>
<p>number of parameters in the model</p>
</td></tr>
<tr><td><code>..$BIC</code></td>
<td>
<p>Bayes Information Criterion</p>
</td></tr>
<tr><td><code>..$smoothedprob</code></td>
<td>
<p>smoothing probabilities <code class="reqn">P(X_t|y_0,\cdots,y_T)</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet at univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Bessac J., Monbet V., Pene F., (2014) Non-homogeneous hidden Markov-switching models for wind time series. JSPI.</p>


<h3>See Also</h3>

<p>init.theta.MSAR.VM, regimes.plot.MSAR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run
# data(WindDir)
# T = dim(WindDir)[1]
# N.samples = dim(WindDir)[2]
# Y = array(WindDir,c(T,N.samples,1))
# von Mises homogeneous MSAR
# M = 2
# order = 2
# theta.init = init.theta.MSAR.VM(Y,M=M,order=order,label="HH")
# res.hh = fit.MSAR.VM(Y,theta.init,MaxIter=3,verbose=TRUE,eps=1e-8)
## von Mises non homogeneous MSA
# theta.init = init.theta.MSAR.VM(Y,M=M,order=order,label="NH",ncov=1,nh.transitions="VM")
#theta.init$mu = res.hh$theta$mu
#theta.init$kappa = res.hh$theta$kappa
#theta.init$prior = res.hh$theta$prior
#theta.init$transmat = res.hh$theta$transmat
#theta.init$par.trans = matrix(c(res.hh[[M]][[order+1]]$theta$mu,.1*matrix(1,M,1)),2,2)
#Y.tmp = array(Y[2:T,,],c(T-1,N.samples,1))
#Z = array(Y[1:(T-1),,],c(T-1,N.samples,1))
#res.nh = fit.MSAR.VM(Y.tmp,theta.init,MaxIter=10,verbose=T,eps=1e-8,covar.trans=Z)
</code></pre>

<hr>
<h2 id='forecast.prob.MSAR'>
Forecast probabilities for (non) homogeneous MSAR models</h2><span id='topic+forecast.prob.MSAR'></span>

<h3>Description</h3>

<p>Computes, for each time <code class="reqn">t</code>, the conditional probabilities for MSAR models <code class="reqn">P(Y_t|y_{1:(t-1)})</code> where  <code class="reqn">Y</code> is the observed process and <code class="reqn">y</code> the observed time series.</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast.prob.MSAR(data, theta, yrange = NULL, covar.emis = NULL, covar.trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.prob.MSAR_+3A_data">data</code></td>
<td>

<p>observed time series, array of dimension T*N.samples*d 
</p>
</td></tr>
<tr><td><code id="forecast.prob.MSAR_+3A_theta">theta</code></td>
<td>

<p>object of class MSAR including the model's parameter and description. See init.theta.MSAR for more details.</p>
</td></tr>
<tr><td><code id="forecast.prob.MSAR_+3A_yrange">yrange</code></td>
<td>

<p>values at which to compute the forecast probabilities
</p>
</td></tr>
<tr><td><code id="forecast.prob.MSAR_+3A_covar.emis">covar.emis</code></td>
<td>

<p>emission covariate if any.</p>
</td></tr>
<tr><td><code id="forecast.prob.MSAR_+3A_covar.trans">covar.trans</code></td>
<td>

<p>array of univariate or multivariate series of covariate to take into account in the transition probabilities.
The link function is defined in the initialisation step (running init.theta.MSAR.R).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>..$yrange</code></td>
<td>
<p>abscissa for the forecast probabilities</p>
</td></tr>
<tr><td><code>..$prob</code></td>
<td>
<p>forecast probabilities</p>
</td></tr>
<tr><td><code>Yhat</code></td>
<td>
<p>forecasted value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>prediction.MSAR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run
#data(meteo.data)
#data = array(meteo.data$temperature,c(31,41,1)) 
#T = dim(data)[1]
#N.samples = dim(data)[2]
#d = dim(data)[3]
#M = 2
#theta.init = init.theta.MSAR(data,M=M,order=2,label="HH")
#res.hh.2 = fit.MSAR(data,theta.init,verbose=TRUE,MaxIter=200)
#FP = forecast.prob.MSAR(data,res.hh.2$theta)
#plot(data[,1,],typ="l")
#lines(FP$Yhat[,1],col="red")
#alpha = .1
#IC.emp = matrix(0,2,T)
#for (k in 1:length(data[,1,])) {
#	tmp = cumsum(FP$prob[,k,1])/sum(FP$prob[,k,1])
#	IC.emp[1,k] = FP$yrange[max(which(tmp&lt;alpha/2))]
#	IC.emp[2,k] = FP$yrange[max(which(tmp&lt;(1-alpha/2)))]
#}
#lines(IC.emp[1,],lty=2,col="red")
#lines(IC.emp[2,],lty=2,col="red")
</code></pre>

<hr>
<h2 id='forwards_backwards'>
Forward Backward for homogeneous MSAR models</h2><span id='topic+forwards_backwards'></span>

<h3>Description</h3>

<p>Computes the posterior (or smoothing) probabilities in an homogenenous HMM or MSAR model using the forwards backwards algo.
'filter_only' is an optional argument (default: 0). If 1, we do filtering, if 0, smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forwards_backwards(prior, transmat, obslik, filter_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forwards_backwards_+3A_prior">prior</code></td>
<td>
<p> prior probabilities
PRIOR(I) = Pr(X(1) = I)
</p>
</td></tr>
<tr><td><code id="forwards_backwards_+3A_transmat">transmat</code></td>
<td>
<p> transition matrice
TRANSMAT(I,J) = Pr(X(T+1)=J | X(T)=I)
</p>
</td></tr>
<tr><td><code id="forwards_backwards_+3A_obslik">obslik</code></td>
<td>
<p>emission probabilities
OBSLIK(I,t) = Pr(Y(t) | X(t)=I)</p>
</td></tr>
<tr><td><code id="forwards_backwards_+3A_filter_only">filter_only</code></td>
<td>

<p>optional argument (default: 0). If TRUE, we do filtering, if FALSE, smoothing (default).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List including
</p>
<table>
<tr><td><code>..$gamma</code></td>
<td>
<p>smoothing probabilities 
P(X(t)|Y(0),...,Y(T))</p>
</td></tr>
<tr><td><code>..$xi</code></td>
<td>
<p>two steps smoothing probabilities 
P(X(t),X(t+1)|Y(0),...,Y(T))</p>
</td></tr>
<tr><td><code>..$loglik</code></td>
<td>
<p>log likelihood</p>
</td></tr>
<tr><td><code>..$M</code></td>
<td>
<p>Number of regimes</p>
</td></tr>
<tr><td><code>..$alpha</code></td>
<td>
<p>intermediate component in the FB algorithm (forward)</p>
</td></tr>
<tr><td><code>..$beta</code></td>
<td>
<p>intermediate component in the FB algorithm (backward)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>fit.MSAR, Estep.MSAR
</p>

<hr>
<h2 id='init.theta.MSAR+20+28NH-MSAR+29'>
Initialisation function for MSAR model fitting</h2><span id='topic+init.theta.MSAR'></span>

<h3>Description</h3>

<p>Initialization before fitting (non) homogeneous Markov switching autoregressive models by EM algorithm. Non homogeneity may be introduce at the intercept level or in the probability transitions. The link functions are defined here.</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.theta.MSAR(data, ..., M, order, regime_names = NULL, nh.emissions = NULL, 
nh.transitions = NULL, label = NULL, ncov.emis = 0, ncov.trans = 0,cl.init="mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.theta.MSAR+2B20+2B28NH-MSAR+2B29_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d with 
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension</p>
</td></tr>
<tr><td><code id="init.theta.MSAR+2B20+2B28NH-MSAR+2B29_+3A_m">M</code></td>
<td>

<p>number of regimes</p>
</td></tr>
<tr><td><code id="init.theta.MSAR+2B20+2B28NH-MSAR+2B29_+3A_order">order</code></td>
<td>

<p>order of AR processes</p>
</td></tr>
<tr><td><code id="init.theta.MSAR+2B20+2B28NH-MSAR+2B29_+3A_label">label</code></td>
<td>

<p>&quot;HH&quot; (default) for homogeneous MS AR model \
&quot;HN&quot; for non homogeneous emissions \
&quot;NH&quot; for non homogeneous transitions  \
&quot;NN&quot; for non homogeneous emissions and non homogeneous transitions </p>
</td></tr>
<tr><td><code id="init.theta.MSAR+2B20+2B28NH-MSAR+2B29_+3A_regime_names">regime_names</code></td>
<td>

<p>(optional) regime's names may be chosen</p>
</td></tr>
<tr><td><code id="init.theta.MSAR+2B20+2B28NH-MSAR+2B29_+3A_nh.emissions">nh.emissions</code></td>
<td>

<p>link function for non homogeneous emissions. If nh.emissions=&quot;linear&quot; (default) linear link is used. If you define an other function it should follow the sample nh.emissions &lt;- function(covar,par.emis) with par.emis of dimension M by ncov.emis+1.   </p>
</td></tr>
<tr><td><code id="init.theta.MSAR+2B20+2B28NH-MSAR+2B29_+3A_nh.transitions">nh.transitions</code></td>
<td>

<p>link function for non homogeneous transitions. If nh.transitions=&quot;gauss&quot; (default) gaussian link is used. If M=2, &quot;logistic&quot; may be chosen. If you define an other function it should follow the sample nh.transitions &lt;- function(covar,par.trans,transma) with par.emis of dimension M by ncov.trans+1.  </p>
</td></tr>
<tr><td><code id="init.theta.MSAR+2B20+2B28NH-MSAR+2B29_+3A_ncov.emis">ncov.emis</code></td>
<td>

<p>number of covariates in HN model</p>
</td></tr>
<tr><td><code id="init.theta.MSAR+2B20+2B28NH-MSAR+2B29_+3A_ncov.trans">ncov.trans</code></td>
<td>

<p>number of covariates in NH model
</p>
</td></tr>
<tr><td><code id="init.theta.MSAR+2B20+2B28NH-MSAR+2B29_+3A_cl.init">cl.init</code></td>
<td>
<p>allows to choose the initialization method. </p>
</td></tr>
<tr><td><code id="init.theta.MSAR+2B20+2B28NH-MSAR+2B29_+3A_...">...</code></td>
<td>

</td></tr>
</table>


<h3>Details</h3>

<p>The default implemented link function for non homogneneous intercept is the linear function </p>
<p style="text-align: center;"><code class="reqn">A0_t^{(x)} = \theta_{A0}^{(x)} Z(t)</code>
</p>

<p><code class="reqn">\theta_{A0}^{(x)}</code> denotes a line vector here.
Other link functions can be defined using nh.emissions (see above).
</p>
<p>The default implemented link function for non homogneneous transitions is the Gauss function. Transition from  <code class="reqn">i</code> to <code class="reqn">j</code> is defined as follows. 
</p>
<p style="text-align: center;"><code class="reqn">f(Z,\theta_Q,Q;i,j) = Q_{ij} \exp\left(-\frac{1}{2}\frac{(Z-\theta_Q^{(j)}(1))^2}{\theta_Q^{(j)}(2)}\right)</code>
</p>
<p> then <code class="reqn">f</code> is normalized in order to define a stochastic matrix. 
</p>
<p>When, only two regimes are considered, the logistic link can be used. Probability of staying in state <code class="reqn">i</code> is defined as follows 
</p>
<p style="text-align: center;"><code class="reqn">f(Z,\theta_Q,Q;i,i) = \epsilon+(-2-\epsilon)/(1+\exp(\theta_Q^{(i)}(1)+\theta_Q^{(i)}[2:(d_Z+1)] Z)) </code>
</p>

<p style="text-align: center;"><code class="reqn">f(Z,\theta_Q,Q;i,j) = 1-f(Z,\theta_Q,Q;i,i)</code>
</p>

<p>with <code class="reqn">Z</code> the covariate and eqnd_Z its dimension (number of covariates)
</p>


<h3>Value</h3>

<p>return a list of class MSAR including 
</p>
<table>
<tr><td><code>theta</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code>..$transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
<tr><td><code>..$prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>..$A</code></td>
<td>
<p>list including the autoregressive coefficients (or matrices)</p>
</td></tr>
<tr><td><code>..$A0</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>..$sigma</code></td>
<td>
<p>variances of innovations</p>
</td></tr>
<tr><td><code>..$par.emis</code></td>
<td>
<p>parameters of non homogeneous emissions</p>
</td></tr> 
<tr><td><code>..$par.trans</code></td>
<td>
<p>parameters of non homogeneous transitions</p>
</td></tr> 
<tr><td><code>label</code></td>
<td>
<p>model's label</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Val\'erie Monbet, valerie.monbet at univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot, Monbet</p>


<h3>See Also</h3>

<p>fit.MSAR</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(meteo.data)
data = array(meteo.data$temperature,c(31,41,1)) 
k = 40
T = dim(data)[1]
N.samples = dim(data)[2]
d = dim(data)[3]

# Fit Homogeneous MS-AR models
M = 2
order = 2
theta.init = init.theta.MSAR(data,M=M,order=order,label="HH") 
mod.hh = fit.MSAR(data,theta.init,verbose=TRUE,MaxIter=10)
regimes.plot.MSAR(mod.hh,data,ylab="temperatures") 

## Not run
# Fit Non Homogeneous MS-AR models
#theta.init = init.theta.MSAR(data,M=M,order=order,label="NH",nh.transitions="gauss")
#attributes(theta.init)
#mod.nh = fit.MSAR(array(data[2:T,,],c(T-1,N.samples,1)),theta.init,verbose=TRUE,MaxIter=50,
#covar.trans=array(data[1:(T-1),,],c(T-1,N.samples,1)))
#regimes.plot.MSAR(mod.nh,data,ex=40,ylab="temperature (deg. C)")

## Not run
# Fit Non Homogeneous MS-AR models to lynx data
#data(lynx)
#data = array(lynx,c(length(lynx),1,1))
#theta.init = init.theta.MSAR(data,M=2,order=2,label="NH",nh.transitions="logistic")
#attributes(theta.init)
#mod.lynx = fit.MSAR(array(data[2:T,,],c(T-1,1,1)),theta.init,verbose=TRUE,MaxIter=200,
#covar.trans=array(data[1:(T-1),,],c(T-1,1,1)))
#regimes.plot.MSAR(mod.lynx,data,ylab="Captures number")
</code></pre>

<hr>
<h2 id='init.theta.MSAR.VM'>
Initialisation function for von Mises MSAR model fitting</h2><span id='topic+init.theta.MSAR.VM'></span>

<h3>Description</h3>

<p>Initialization before fitting von Mises (non) homogeneous Markov switching autoregressive models by EM algorithm. Non homogeneity may be introduce in the probability transitions. The link function is defined here.</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.theta.MSAR.VM(data, ..., M, order, 
                  regime_names = NULL, 
                  nh.emissions = NULL, nh.transitions = NULL, 
                  label = NULL, ncov.emis = 0, ncov.trans = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.theta.MSAR.VM_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d with 
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension</p>
</td></tr>
<tr><td><code id="init.theta.MSAR.VM_+3A_m">M</code></td>
<td>

<p>number of regimes</p>
</td></tr>
<tr><td><code id="init.theta.MSAR.VM_+3A_order">order</code></td>
<td>

<p>order of AR processes</p>
</td></tr>
<tr><td><code id="init.theta.MSAR.VM_+3A_label">label</code></td>
<td>

<p>&quot;HH&quot; (default) for homogeneous MS AR model 
&quot;NH&quot; for non homogeneous transitions  </p>
</td></tr>
<tr><td><code id="init.theta.MSAR.VM_+3A_regime_names">regime_names</code></td>
<td>

<p>(optional) regime's names may be chosen</p>
</td></tr>
<tr><td><code id="init.theta.MSAR.VM_+3A_nh.emissions">nh.emissions</code></td>
<td>

<p>not available - under development.   </p>
</td></tr>
<tr><td><code id="init.theta.MSAR.VM_+3A_nh.transitions">nh.transitions</code></td>
<td>

<p>link function for non homogeneous transitions. Default: von Mises (see details).   </p>
</td></tr>
<tr><td><code id="init.theta.MSAR.VM_+3A_ncov.emis">ncov.emis</code></td>
<td>

<p>not available - under development. </p>
</td></tr>
<tr><td><code id="init.theta.MSAR.VM_+3A_ncov.trans">ncov.trans</code></td>
<td>

<p>number of covariates in NH model
</p>
</td></tr>
<tr><td><code id="init.theta.MSAR.VM_+3A_...">...</code></td>
<td>

</td></tr>
</table>


<h3>Details</h3>

<p>The model with non homogeneous transitions is labeled &quot;NH&quot; and it is written
</p>
<p style="text-align: center;"><code class="reqn">P(X_t|X_{t-1}=x_{t-1}) = q(z_t,\theta_{z_t})</code>
</p>
<p> with <code class="reqn">X_t</code> the hidden process and <code class="reqn">q</code> von Mises link function such that </p>
<p style="text-align: center;"><code class="reqn">p_1(x_t|x_{t-1},z_{t}) =\frac{  q_{x_{t-1},x_t}\left|\exp 
   \left(\tilde\lambda_{x_{t-1},x_t} e^{-iz_{t}} \right)\right|}
    {\sum_{x'=1}^M q_{x_{t-1},x'}\left|\exp 
   \left(\tilde\lambda_{x_{t-1},x'} e^{-iz_{t}} \right)\right|},
</code>
</p>
 
<p>with <code class="reqn">\tilde\lambda_{x,x'}</code> a complex parameter (by taking <code class="reqn">\tilde\lambda_{x,x'}=\lambda_{x,x'}
    e^{i\psi_{x,x'}}</code>). 
</p>


<h3>Value</h3>

<p>return a list of class MSAR including 
</p>
<table>
<tr><td><code>theta</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code>..$transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
<tr><td><code>..$prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>..$mu</code></td>
<td>
<p>vector of intercepts</p>
</td></tr>
<tr><td><code>..$kappa</code></td>
<td>
<p>matrix of 'AR' coefficients (not complex by default)</p>
</td></tr>
<tr><td><code>..$par.emis</code></td>
<td>
<p>parameters of non homogeneous emissions (not used)</p>
</td></tr> 
<tr><td><code>..$par.trans</code></td>
<td>
<p>parameters of non homogeneous transitions</p>
</td></tr> 
<tr><td><code>label</code></td>
<td>
<p>model's label</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Val\'erie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Bessac J., Monbet V., Pene F., (2014) Non-homogeneous hidden Markov-switching models for wind time series. JSPI.</p>


<h3>See Also</h3>

<p>fit.MSAR.VM</p>

<hr>
<h2 id='log_dens_Von_Mises'>von Mises log likelihood.</h2><span id='topic+log_dens_Von_Mises'></span>

<h3>Description</h3>

<p>von Mises log likelihood.</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_dens_Von_Mises(x, m, k)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_dens_Von_Mises_+3A_x">x</code></td>
<td>
<p>vector of data</p>
</td></tr>
<tr><td><code id="log_dens_Von_Mises_+3A_m">m</code></td>
<td>
<p>location parameter</p>
</td></tr>
<tr><td><code id="log_dens_Von_Mises_+3A_k">k</code></td>
<td>
<p>dispersion parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Log-likelihood of von Mises distribution with density 
</p>
<p style="text-align: center;"><code class="reqn">\frac{exp(k cos(x-m))}{2 \pi I_0(k)}</code>
</p>

<p>where <code class="reqn">I_0</code> is the modified Bessel function of order 0. </p>


<h3>Value</h3>

<p>log likelihood</p>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet at univ-rennes1.fr</p>


<h3>References</h3>

<p>Mardia, K.; Jupp, P. E. (1999). Directional Statistics. Wiley.</p>


<h3>See Also</h3>

<p>circular package</p>

<hr>
<h2 id='MeanDurOver'>
Mean Duration of sojourn over a treshold
</h2><span id='topic+MeanDurOver'></span>

<h3>Description</h3>

<p>Plot the mean duration of sojourn over thresholds for an observed time series and a simulated one with respect to the empirical cumulative distribution function. Fluctuation intervals are plotted too.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanDurOver(data, data.sim, u, alpha = 0.05,col="red",plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MeanDurOver_+3A_data">data</code></td>
<td>

<p>observed (or reference) time series, array of dimension T*N.samples*1 </p>
</td></tr>
<tr><td><code id="MeanDurOver_+3A_data.sim">data.sim</code></td>
<td>

<p>simulated time series, array of dimension T*N.sim*1.
N.sim have to be  K*N.samples with K large enough (for instance, K=100) </p>
</td></tr>
<tr><td><code id="MeanDurOver_+3A_u">u</code></td>
<td>
<p>vector of 
thresholds</p>
</td></tr>
<tr><td><code id="MeanDurOver_+3A_alpha">alpha</code></td>
<td>
<p>1-confidence level for fluctuation intervals. Default = 0.05</p>
</td></tr>
<tr><td><code id="MeanDurOver_+3A_col">col</code></td>
<td>
<p>color of the lines for simulated data</p>
</td></tr>
<tr><td><code id="MeanDurOver_+3A_plot">plot</code></td>
<td>
<p>statistic are plotted if TRUE (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot and a list including
..$F : empirical cdf of data for levels u
..$mdo.data : mean duration over levels u for data
..$F.sim : empirical cdf of simulations for levels u
..$mdo.sim : mean duration over levels u for simulations
..$CI : confidence intervals of mean duration over levels u for simulations
..$mod.sim.all : mean duration over levels u for all simulations
</p>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>valid_all.MSAR, MeanDurUnder</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meteo.data)
data = array(meteo.data$temperature,c(31,41,1)) 
k = 40
T = dim(data)[1]
N.samples = dim(data)[2]
d = dim(data)[3]
M = 2
order = 2
theta.init = init.theta.MSAR(data,M=M,order=order,label="HH")
mod.hh= NULL
mod.hh$theta = theta.init
mod.hh$theta$A = matrix(c(0.40,0.88,-.09,-.13),2,2)
mod.hh$theta$A0 = matrix(c(6.75,1.08),2,1)
mod.hh$theta$sigma = matrix(c(1.76,3.40),2,1)
mod.hh$theta$prior = matrix(c(0.37,0.63),2,1)
mod.hh$theta$transmat = matrix(c(0.82,0.09,0.18,0.91),2,2)
B.sim = 20*N.samples
Y0 = array(data[1:2,sample(1:dim(data)[2],B.sim,replace=TRUE),],c(2,B.sim,1))
Y.sim = simule.nh.MSAR(mod.hh$theta,Y0=Y0,T,N.samples=B.sim)
u = seq(min(data),max(data),length.out=30)
MDO = MeanDurOver(data,Y.sim$Y,u)
</code></pre>

<hr>
<h2 id='MeanDurUnder'>
Mean Duration of sojourn under a treshold
</h2><span id='topic+MeanDurUnder'></span>

<h3>Description</h3>

<p>Plot the mean duration of sojourn under thresholds for an observed time series and a simulated one with respect to teh empirical cumulative distribution function (cdf).  Confidence intervals are plotted too.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanDurUnder(data, data.sim, u, alpha = 0.05,col="red",plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MeanDurUnder_+3A_data">data</code></td>
<td>

<p>observed (or reference) time series, array of dimension T*N.samples*1 </p>
</td></tr>
<tr><td><code id="MeanDurUnder_+3A_data.sim">data.sim</code></td>
<td>

<p>simulated time series, array of dimension T*N.sim*1.
N.sim have to be  K*N.samples with K large enough (for instance, K=100) </p>
</td></tr>
<tr><td><code id="MeanDurUnder_+3A_u">u</code></td>
<td>

<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="MeanDurUnder_+3A_alpha">alpha</code></td>
<td>

<p>1-confidence level for confidence intervals. Default = 0.05</p>
</td></tr>
<tr><td><code id="MeanDurUnder_+3A_col">col</code></td>
<td>
<p>color of the lines for simulated data, default is red</p>
</td></tr>
<tr><td><code id="MeanDurUnder_+3A_plot">plot</code></td>
<td>
<p>statistic are plotted if TRUE (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot and a list including
..$F : empirical cdf of data for levels u
..$mdu.data : mean duration under levels u for data
..$F.sim : empirical cdf of simulations for levels u
..$mdu.sim : mean duration under levels u for simulations
..$CI : confidence intervals of mean duration under levels u for simulations
</p>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>valid_all.MSAR, MeanDurOver</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meteo.data)
data = array(meteo.data$temperature,c(31,41,1)) 
k = 40
T = dim(data)[1]
N.samples = dim(data)[2]
d = dim(data)[3]
M = 2
order = 2
theta.init = init.theta.MSAR(data,M=M,order=order,label="HH")
mod.hh= NULL
mod.hh$theta = theta.init
mod.hh$theta$A = matrix(c(0.40,0.88,-.09,-.13),2,2)
mod.hh$theta$A0 = matrix(c(6.75,1.08),2,1)
mod.hh$theta$sigma = matrix(c(1.76,3.40),2,1)
mod.hh$theta$prior = matrix(c(0.37,0.63),2,1)
mod.hh$theta$transmat = matrix(c(0.82,0.09,0.18,0.91),2,2)
B.sim = 20*N.samples
Y0 = array(data[1:2,sample(1:dim(data)[2],B.sim,replace=TRUE),],c(2,B.sim,1))
Y.sim = simule.nh.MSAR(mod.hh$theta,Y0=Y0,T,N.samples=B.sim)
u = seq(min(data),max(data),length.out=30)
MeanDurUnder(data,Y.sim$Y,u)
</code></pre>

<hr>
<h2 id='meteo.data'>
Meteorological at Brest (France) for January month from 1973 to 2013</h2><span id='topic+meteo.data'></span>

<h3>Description</h3>

<p>The data sets contains daily temperatures (degrees), daily precipitations (mm), mean wind (m/s) and mean pressure. Some data are missing. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meteo.data)</code></pre>


<h3>Source</h3>

<p> http://eca.knmi.nl/dailydata/index.php</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meteo.data)
</code></pre>

<hr>
<h2 id='Mstep.classif'>
fit an AR model for each class of C</h2><span id='topic+Mstep.classif'></span>

<h3>Description</h3>

<p>fit an AR model for each class of C by maximum likelihood method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.classif(data, C, order,sigma.diag=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.classif_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.classif_+3A_c">C</code></td>
<td>

<p>Class sequence</p>
</td></tr>
<tr><td><code id="Mstep.classif_+3A_order">order</code></td>
<td>

<p>order of AR models (all models will have the same order)</p>
</td></tr>
<tr><td><code id="Mstep.classif_+3A_sigma.diag">sigma.diag</code></td>
<td>

<p>if TRUE the covariance matrices will be diagonal (default FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing
</p>
<table>
<tr><td><code>A0</code></td>
<td>
<p>intercept</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>variance of innovation</p>
</td></tr>
<tr><td><code>LL</code></td>
<td>
<p>log likelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>fit.MSAR</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(meteo.data)
data = array(meteo.data$temperature,c(31,41,1)) 
k = 40
T = dim(data)[1]
N.samples = dim(data)[2]
d = dim(data)[3]
order = 2
C = array(meteo.data&gt;0,c(31,41,1))
res = Mstep.classif(data,C,order=order)
str(res)
</code></pre>

<hr>
<h2 id='Mstep.hh.lasso.MSAR'>
M step of the EM algorithm for fitting  homogeneous multivariate Markov switching auto-regressive models with penalization of parameters of the VAR(1) models.</h2><span id='topic+Mstep.hh.lasso.MSAR'></span>

<h3>Description</h3>

<p>M step of the EM algorithm for fitting   homogeneous multivariate Markov switching auto-regressive models with penalization of parameters of the VAR(1) models, called in fit.MSAR. Penalized maximum likelihood is used. Penalization may be add to the autoregressive matrices of order 1 and to the precision matrices (inverse of variance of innovation).   </p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.hh.lasso.MSAR(data, theta, FB)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.hh.lasso.MSAR_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T x N.samples x d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.lasso.MSAR_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.lasso.MSAR_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lars algorithm of pagkage lars is used.		  </p>


<h3>Value</h3>

<table>
<tr><td><code>A0</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>variance of innovation</p>
</td></tr>
<tr><td><code>sigma.inv</code></td>
<td>
<p>inverse of variance of innovation</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr
</p>


<h3>References</h3>

<p>Efron, B., Hastie, T., Johnstone, I., Tibshirani, R., et al. (2004). Least angle regression. The Annals of statistics, 32(2):407-499.
</p>


<h3>See Also</h3>

<p>Mstep.hh.MSAR, fit.MSAR
</p>

<hr>
<h2 id='Mstep.hh.MSAR'>
M step of the EM algorithm for fitting  homogeneous Markov switching auto-regressive models.</h2><span id='topic+Mstep.hh.MSAR'></span>

<h3>Description</h3>

<p>M step of the EM algorithm for fitting   homogeneous Markov switching auto-regressive models, called in fit.MSAR.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.hh.MSAR(data, theta, FB,sigma.diag=FALSE,sigma.equal=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.hh.MSAR_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.MSAR_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.MSAR_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function
</p>
</td></tr>
<tr><td><code id="Mstep.hh.MSAR_+3A_sigma.diag">sigma.diag</code></td>
<td>
<p>If sigma.diag==TRUE the estimated covariance of the innovation will be diagonal 
(default is FALSE) -  available only for HH models 
</p>
</td></tr>
<tr><td><code id="Mstep.hh.MSAR_+3A_sigma.equal">sigma.equal</code></td>
<td>
<p>If sigma.equal==TRUE the estimated covariance of the innovation will be the same in all regimes -  available only for models with homogeneous emission probabilities
(default is FALSE)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>A0</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>variance of innovation</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Monbet V., (2012), Markov switching autoregressive models for wind time series. Environmental Modelling &amp; Software, 30, pp 92-101.</p>


<h3>See Also</h3>

<p>fit.MSAR, Estep.MSAR, Mstep.classif
</p>

<hr>
<h2 id='Mstep.hh.MSAR.VM'>
M step of the EM algorithm for fitting  von Mises Markov switching auto-regressive models.</h2><span id='topic+Mstep.hh.MSAR.VM'></span>

<h3>Description</h3>

<p>M step of the EM algorithm for fitting   homogeneous Markov switching auto-regressive models, called in fit.MSAR.VM.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.hh.MSAR.VM(data, theta, FB, constr = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.hh.MSAR.VM_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.MSAR.VM_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.MSAR.VM_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function
</p>
</td></tr>
<tr><td><code id="Mstep.hh.MSAR.VM_+3A_constr">constr</code></td>
<td>

<p>constraints are added to the <code class="reqn">\kappa</code> parameter (A preciser)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The homogeneous MSAR model is labeled &quot;HH&quot; and it is written
</p>
<p style="text-align: center;"><code class="reqn">
P(X_t|X_{t-1}=x_{t-1}) = Q_{x_{t-1},x_t}</code>
</p>
<p> with <code class="reqn">X_t</code> the hidden univariate process defined on <code class="reqn">\{1,\cdots,M \}</code>
</p>
<p style="text-align: center;"><code class="reqn">
Y_t|X_t=x_t,y_{t-1},...,y_{t-p}</code>
</p>
<p> has a von Mises distribution with density </p>
<p style="text-align: center;"><code class="reqn"> p_2(y_t|x_t,y_{t-s}^{t-1}) = \frac {1}{b(x_t,y_{t-s}^{t-1})} \exp\left(\kappa_0^{(x_t)} \cos(y_t-\phi_0^{(x_t)})+
    \sum_{\ell=1}^s\kappa_\ell^{(x_t)} \cos(y_t-y_{t-\ell}-\phi_\ell^{(x)})\right)</code>
</p>

<p>which is equivalent to
</p>
<p style="text-align: center;"><code class="reqn"> p_2(y_t|x_t,y_{t-s}^{t-1}) = \frac {1}{b(x_t,y_{t-s}^{t-1})} \left|\exp\left([\gamma_0^{(x_t)} +
    \sum_{\ell=1}^s\gamma_\ell^{(x_t)} e^{iy_{t-\ell}}]e^{-iy_t}\right)\right|</code>
</p>

<p><code class="reqn">b(x_t,y_{t-s}^{t-1})</code> is a normalisation constant. 
</p>
<p>Both the real and the complex formulation are implemented. In practice, the complex version is used if the initial <code class="reqn">\kappa</code> is complex. 
</p>


<h3>Value</h3>

<p>List containing
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>von Mises AR coefficients</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Bessac J., Monbet V., Pene F., (2014) Non-homogeneous hidden Markov-switching models for wind time series. JSPI.</p>


<h3>See Also</h3>

<p>fit.MSAR.VM, Estep.MSAR.VM
</p>

<hr>
<h2 id='Mstep.hh.MSAR.with.constraints'>
M step of the EM algorithm for fitting  homogeneous multivariate Markov switching auto-regressive models with constraints on VAR models.</h2><span id='topic+Mstep.hh.MSAR.with.constraints'></span>

<h3>Description</h3>

<p>M step of the EM algorithm for fitting   homogeneous multivariate Markov switching auto-regressive models with constraints on VAR models, called in fit.MSAR. Maximum likelihood is used. Matrices A and sigma are diagonal by blocks.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.hh.MSAR.with.constraints(data, theta, FB, K, d.y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.hh.MSAR.with.constraints_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T x N.samples x d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.MSAR.with.constraints_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.MSAR.with.constraints_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function</p>
</td></tr>
<tr><td><code id="Mstep.hh.MSAR.with.constraints_+3A_k">K</code></td>
<td>

<p>number of sites. For instance, if one considers wind at k locations, K=k. Or more generally number of independent groups of components. </p>
</td></tr>
<tr><td><code id="Mstep.hh.MSAR.with.constraints_+3A_d.y">d.y</code></td>
<td>

<p>dimension in each sites. For instance, if one considers only wind intensity than d.y = 1; but, if one considers cartesian components of wind, then d.y =2.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>A0</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>variance of innovation</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr
</p>


<h3>See Also</h3>

<p>Mstep.hh.MSAR, fit.MSAR, Mstep.hh.SCAD.MSAR
</p>

<hr>
<h2 id='Mstep.hh.reduct.MSAR'>
M step of the EM algorithm for fitting homogeneous Markov switching auto-regressive models with constraints on the matrices.</h2><span id='topic+Mstep.hh.reduct.MSAR'></span>

<h3>Description</h3>

<p>M step of the EM algorithm for fitting   homogeneous Markov switching auto-regressive model swith constraints on the matrices, called in fit.MSAR. The matrices are constrained to have the same pattern ()zeros and non zeros coefficients) as the initial matrices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.hh.reduct.MSAR(data, theta, FB, sigma.diag=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.hh.reduct.MSAR_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.reduct.MSAR_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.reduct.MSAR_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function
</p>
</td></tr>
<tr><td><code id="Mstep.hh.reduct.MSAR_+3A_sigma.diag">sigma.diag</code></td>
<td>
<p>if TRUE the innovation covariance matrices are diagonal. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>A0</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>variance of innovation</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Monbet V., (2012), Markov switching autoregressive models for wind time series. Environmental Modelling &amp; Software, 30, pp 92-101.</p>


<h3>See Also</h3>

<p>Mstep.hh.MSAR, fit.MSAR, Estep.MSAR, Mstep.classif
</p>

<hr>
<h2 id='Mstep.hh.ridge.MSAR'>
M step of the EM algorithm for fitting  homogeneous multivariate Markov switching auto-regressive models with penalization of parameters of the VAR(1) models.</h2><span id='topic+Mstep.hh.ridge.MSAR'></span>

<h3>Description</h3>

<p>M step of the EM algorithm for fitting   homogeneous multivariate Markov switching auto-regressive models with penalization of parameters of the VAR(1) models, called in fit.MSAR. Penalized maximum likelihood is used. Penalization may be add to the autoregressive matrices of order 1 and to the precision matrices (inverse of variance of innovation).   </p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.hh.ridge.MSAR(data, theta, FB,lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.hh.ridge.MSAR_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T x N.samples x d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.ridge.MSAR_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.ridge.MSAR_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function</p>
</td></tr>
<tr><td><code id="Mstep.hh.ridge.MSAR_+3A_lambda">lambda</code></td>
<td>
<p>penalisation constant</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>A0</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>variance of innovation</p>
</td></tr>
<tr><td><code>sigma.inv</code></td>
<td>
<p>inverse of variance of innovation</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr
</p>


<h3>See Also</h3>

<p>Mstep.hh.MSAR, fit.MSAR
</p>

<hr>
<h2 id='Mstep.hh.SCAD.cw.MSAR'>
M step of the EM algorithm for fitting  homogeneous multivariate Markov switching auto-regressive models with SCAD penalization of parameters of the VAR(1) models.</h2><span id='topic+Mstep.hh.SCAD.cw.MSAR'></span>

<h3>Description</h3>

<p>M step of the EM algorithm for fitting   homogeneous multivariate Markov switching auto-regressive models with penalization of parameters of the VAR(1) models, called in fit.MSAR. Penalization may be add to the autoregressive matrices of order 1 and to the precision matrices (inverse of variance of innovation). For the autoregressive matrices the ncvreg component wise procedure is used (see package ncvreg). For the precision matrices the graphcal lasso algortihm of glasso is used with the adaptative lasso of Zou.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.hh.SCAD.cw.MSAR(data, theta, FB, lambda1=.1,lambda2=.1,penalty=,par=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.hh.SCAD.cw.MSAR_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T x N.samples x d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.cw.MSAR_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.cw.MSAR_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function</p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.cw.MSAR_+3A_lambda1">lambda1</code></td>
<td>

<p>penalization constant for the precision matrices. It may be a scalar or a vector of length M (with M the number of regimes). If it is equal to0 no penalization is introduced for the precision matrices. </p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.cw.MSAR_+3A_lambda2">lambda2</code></td>
<td>

<p>penalization constant for the autoregressive matrices. It may be a scalar or a vector of length M (with M the number of regimes).  If it is equal to0 no penalization is introduced for the atoregression matrices.</p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.cw.MSAR_+3A_penalty">penalty</code></td>
<td>
<p>choice of the penalty for the autoregressive matrices. Possible values are ridge, lasso or SCAD (default). </p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.cw.MSAR_+3A_par">par</code></td>
<td>
<p>allows to give an initial value to the precision matrices. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When LASSO penalty is chosen, the LARS algorithm is used. When SCAD is chosen, a Newton-Raphson algorithm is run with a quadratic approximation of the penalized likelihood. 
For the precision matrices penalization, the package glasso is used. 
</p>
<p>Limit of this function: only works for VAR(1) models
</p>


<h3>Value</h3>

<table>
<tr><td><code>A0</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>variance of innovation</p>
</td></tr>
<tr><td><code>sigma.inv</code></td>
<td>
<p>inverse of variance of innovation</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr
</p>


<h3>References</h3>

<p>Breheny, P., &amp; Huang, J. (2011). Coordinate descent algorithms for nonconvex penalized regression, with applications to biological feature selection. The annals of applied statistics, 5(1), 232.
</p>
<p>Efron, B., Hastie, T., Johnstone, I., Tibshirani, R., et al. (2004). Least angle regression. The Annals of statistics, 32(2):407-499.
</p>
<p>Fan, J. and Li, R. (2001). Variable selection via nonconcave penalized likelihood and its oracle properties. Journal of the American statistical Association, 96(456):1348-1360.
</p>
<p>Friedman, J., Hastie, T., &amp; Tibshirani, R. (2008). Sparse inverse covariance estimation with the graphical lasso. Biostatistics, 9(3), 432-441.
</p>


<h3>See Also</h3>

<p>Mstep.hh.MSAR, fit.MSAR, Mste.hh.SCAD.MSAR
</p>

<hr>
<h2 id='Mstep.hh.SCAD.MSAR'>
M step of the EM algorithm for fitting  homogeneous multivariate Markov switching auto-regressive models with penalization of parameters of the VAR(1) models.</h2><span id='topic+Mstep.hh.SCAD.MSAR'></span>

<h3>Description</h3>

<p>M step of the EM algorithm for fitting   homogeneous multivariate Markov switching auto-regressive models with penalization of parameters of the VAR(1) models, called in fit.MSAR. Penalized maximum likelihood is used. Penalization may be add to the autoregressive matrices of order 1 and to the precision matrices (inverse of variance of innovation). Ridge, LASSO and SCAD penalization are implmented for the autoregressive matrices and only SCAD for the precision matrices.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.hh.SCAD.MSAR(data, theta, FB, lambda1=.1,lambda2=.1,penalty=,par=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.hh.SCAD.MSAR_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T x N.samples x d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.MSAR_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.MSAR_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function</p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.MSAR_+3A_lambda1">lambda1</code></td>
<td>

<p>penalization constant for the precision matrices. It may be a scalar or a vector of length M (with M the number of regimes). If it is equal to0 no penalization is introduced for the precision matrices. </p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.MSAR_+3A_lambda2">lambda2</code></td>
<td>

<p>penalization constant for the autoregressive matrices. It may be a scalar or a vector of length M (with M the number of regimes).  If it is equal to0 no penalization is introduced for the atoregression matrices.</p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.MSAR_+3A_penalty">penalty</code></td>
<td>
<p>choice of the penalty for the autoregressive matrices. Possible values are ridge, lasso or SCAD (default). </p>
</td></tr>
<tr><td><code id="Mstep.hh.SCAD.MSAR_+3A_par">par</code></td>
<td>
<p>allows to give an initial value to the precision matrices. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When LASSO penalty is chosen, the LARS algorithm is used. When SCAD is chosen, a Newton-Raphson algorithm is run with a quadratic approximation of the penalized likelihood. 
For the precision matrices penalization, the package glasso is used. 
</p>
<p>Limit of this function: only works for VAR(1) models
</p>


<h3>Value</h3>

<table>
<tr><td><code>A0</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>variance of innovation</p>
</td></tr>
<tr><td><code>sigma.inv</code></td>
<td>
<p>inverse of variance of innovation</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr
</p>


<h3>References</h3>

<p>Efron, B., Hastie, T., Johnstone, I., Tibshirani, R., et al. (2004). Least angle regression. The Annals of statistics, 32(2):407-499.
</p>
<p>Fan, J. and Li, R. (2001). Variable selection via nonconcave penalized likelihood and its oracle properties. Journal of the American statistical Association, 96(456):1348-1360.</p>


<h3>See Also</h3>

<p>Mstep.hh.MSAR, fit.MSAR
</p>

<hr>
<h2 id='Mstep.hn.MSAR'>
M step of the EM algorithm for fitting Markov switching auto-regressive models with non homogeneous emissions.</h2><span id='topic+Mstep.hn.MSAR'></span>

<h3>Description</h3>

<p>The M step contains two parts. One for the estimation of the parameters of the hidden Markov chain and the other for the parameters of the auto-regressive models. A numerical algortihm is used for the emission parameters. </p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.hn.MSAR(data, theta, FB, covar = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.hn.MSAR_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.hn.MSAR_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.hn.MSAR_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function</p>
</td></tr>
<tr><td><code id="Mstep.hn.MSAR_+3A_covar">covar</code></td>
<td>

<p>emissions covariates (the covariables act on the intercepts)</p>
</td></tr>
<tr><td><code id="Mstep.hn.MSAR_+3A_verbose">verbose</code></td>
<td>
<p>if verbose is TRUE some iterations of the numerical optimisation are print on the console. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default numerical optimization method is ucminf (see ucminf). 
</p>


<h3>Value</h3>

<p>List containing
</p>
<table>
<tr><td><code>..$A0</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>..$A</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code>..$sigma</code></td>
<td>
<p>variance of innovation</p>
</td></tr>
<tr><td><code>..$prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>..$transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
<tr><td><code>..$par_emis</code></td>
<td>
<p>emission parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Monbet V., (2012), Markov switching autoregressive models for wind time series. Environmental Modelling &amp; Software, 30, pp 92-101.</p>


<h3>See Also</h3>

<p>fit.MSAR, init.theta.MSAR, Mstep.hh.MSAR</p>

<hr>
<h2 id='Mstep.nh.MSAR'>
M step of the EM algorithm.</h2><span id='topic+Mstep.nh.MSAR'></span>

<h3>Description</h3>

<p>M step of the EM algorithm for fitting Markov switching auto-regressive models with non homogeneous transitions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.nh.MSAR(data,theta,FB,covar=NULL,method=method,
ARfix=FALSE,reduct=FALSE,penalty=FALSE,sigma.diag=FALSE,sigma.equal=FALSE,
lambda1=lambda1,lambda2=lambda2,par = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.nh.MSAR_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_covar">covar</code></td>
<td>

<p>transitions covariates</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_method">method</code></td>
<td>

<p>permits to choice the optimization algorithm. default is &quot;ucminf&quot;, other possible choices are &quot;BFGS&quot; or &quot;L-BFGS-B&quot;</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_sigma.diag">sigma.diag</code></td>
<td>
<p>if TRUE the innovation covariance matrices are diagonal.</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_sigma.equal">sigma.equal</code></td>
<td>
<p>If sigma.equal==TRUE the estimated covariance of the innovation will be the same in all regimes -  available only for models with homogeneous emission probabilities
(default is FALSE)</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_reduct">reduct</code></td>
<td>
<p>if TRUE, autoregressive matrices and innovation covariance matrices are constrained to have the same pattern (zero and non zero coefficients) as the one of initial matrices.   </p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_arfix">ARfix</code></td>
<td>

<p>if TRUE the AR parameters are not estimated, they stay fixed at their initial value. </p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_lambda1">lambda1</code></td>
<td>

<p>penalization constant for the precision matrices. It may be a scalar or a vector of length M (with M the number of regimes). If it is equal to0 no penalization is introduced for the precision matrices. </p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_lambda2">lambda2</code></td>
<td>

<p>penalization constant for the autoregressive matrices. It may be a scalar or a vector of length M (with M the number of regimes).  If it is equal to0 no penalization is introduced for the atoregression matrices.</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_penalty">penalty</code></td>
<td>
<p>choice of the penalty for the autoregressive matrices. Possible values are ridge, lasso or SCAD (default). </p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR_+3A_par">par</code></td>
<td>
<p>allows to give an initial value to the precision matrices. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing
</p>
<table>
<tr><td><code>..$A0</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>..$A</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code>..$sigma</code></td>
<td>
<p>variance of innovation</p>
</td></tr>
<tr><td><code>..$prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>..$transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
<tr><td><code>..$par.trans</code></td>
<td>
<p>transitions parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Monbet V., (2012), Markov switching autoregressive models for wind time series. Environmental Modelling &amp; Software, 30, pp 92-101.</p>


<h3>See Also</h3>

<p>fit.MSAR, init.theta.MSAR, Mstep.hh.MSAR</p>

<hr>
<h2 id='Mstep.nh.MSAR.VM'>
M step of the EM algorithm for von Mises MSAR models</h2><span id='topic+Mstep.nh.MSAR.VM'></span>

<h3>Description</h3>

<p>M step of the EM algorithm for fitting von Mises Markov switching auto-regressive models with non homogeneous transitions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.nh.MSAR.VM(data, theta, FB, covar.trans = NULL, method = method, constr = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.nh.MSAR.VM_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR.VM_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR.VM_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR.VM_+3A_covar.trans">covar.trans</code></td>
<td>

<p>transitions covariates</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR.VM_+3A_method">method</code></td>
<td>

<p>permits to choice the optimization algorithm. default is &quot;ucminf&quot;, other possible choices are &quot;BFGS&quot; or &quot;L-BFGS-B&quot;</p>
</td></tr>
<tr><td><code id="Mstep.nh.MSAR.VM_+3A_constr">constr</code></td>
<td>

<p>if constr=1 contraints are added the the <code class="reqn">kappa</code> parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>von Mises AR coefficients</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
<tr><td><code>..$par.trans</code></td>
<td>
<p>transitions parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Bessac J., Monbet V., Pene F., (2014) Non-homogeneous hidden Markov-switching models for wind time series. JSPI.</p>


<h3>See Also</h3>

<p>fit.MSAR.VM, init.theta.MSAR.VM, Mstep.hh.MSAR.VM</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data, theta, FB, covar = covar.trans, method = method, 
    constr = 0) 
{
    order = attributes(theta)$order
    d = dim(data)[3]
    if (is.na(d) | is.null(d)) {
        d = 1
    }
    M = attributes(theta)$NbRegimes
    if (length(covar) == 1) {
        Lag = covar
        covar = array(data[(1):(T - Lag + 1), , ], c(T - Lag + 
            1, N.samples, d))
        data = array(data[Lag:T, , ], c(T - Lag + 1, N.samples, 
            d))
    }
    N.samples = dim(covar)[2]
    ncov.trans = dim(covar)[3]
    par.hh = Mstep.hh.MSAR.VM(data, theta, FB, constr)
    theta$transmat[which(theta$transmat &lt; 1e-15)] = 1e-15
    theta$transmat = mk_stochastic(theta$transmat)
    trans = para_trans(theta$transmat)
    par.trans = theta$par.trans
    nh_transition = attributes(theta)$nh.transitions
    par.init = plie2(trans, par.trans)
    lxi = dim(FB$probSS)[3]
    if (order &gt; 0) {
        deb = order + 1
    }
    else {
        deb = 1
    }
    resopt = ucminf(par.init, fn = loglik_nh_inp.VM, gr = NULL, 
        covar = array(covar[deb + (1:(lxi)), , ], c(lxi, N.samples, 
            ncov.trans)), xi = FB$probSS, nh_transition = nh_transition, 
        hessian = 0, control = list(trace = FALSE))
    res = deplie2(resopt$par)
    trans = res$trans
    par.trans = res$par
    transmat = para_trans_inv(trans)
    list(mu = par.hh$mu, kappa = par.hh$kappa, prior = par.hh$prior, 
        transmat = transmat, par.trans = par.trans)
  }
</code></pre>

<hr>
<h2 id='Mstep.nn.MSAR'>
M step of the EM algorithm.</h2><span id='topic+Mstep.nn.MSAR'></span>

<h3>Description</h3>

<p>M step of the EM algorithm for fitting Markov switching auto-regressive models with non homogeneous emissions and non homogeneous transitions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep.nn.MSAR(data, theta, FB, 
   covar.trans = covar.trans, covar.emis = covar.emis, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep.nn.MSAR_+3A_data">data</code></td>
<td>

<p>array of univariate or multivariate series with dimension T*N.samples*d.
T: number of time steps of each sample, N.samples: number of realisations of the same stationary process, d: dimension.
</p>
</td></tr>
<tr><td><code id="Mstep.nn.MSAR_+3A_theta">theta</code></td>
<td>

<p>model's parameter; object of class MSAR. See also init.theta.MSAR.
</p>
</td></tr>
<tr><td><code id="Mstep.nn.MSAR_+3A_fb">FB</code></td>
<td>

<p>Forward-Backward results, obtained by calling Estep.MSAR function</p>
</td></tr>
<tr><td><code id="Mstep.nn.MSAR_+3A_covar.trans">covar.trans</code></td>
<td>

<p>transitions covariates</p>
</td></tr>
<tr><td><code id="Mstep.nn.MSAR_+3A_covar.emis">covar.emis</code></td>
<td>

<p>emissions covariates (the covariates act on the intercepts)</p>
</td></tr>
<tr><td><code id="Mstep.nn.MSAR_+3A_method">method</code></td>
<td>

<p>permits to choice the optimization algorithm. default is &quot;ucminf&quot;, other possible choices are &quot;BFGS&quot; or &quot;L-BFGS-B</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>A0</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>variance of innovation</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
<tr><td><code>transmat</code></td>
<td>
<p>transition matrix</p>
</td></tr>
<tr><td><code>par_emis</code></td>
<td>
<p>emission parameters</p>
</td></tr>
<tr><td><code>par.trans</code></td>
<td>
<p>transitions parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Monbet V., (2012), Markov switching autoregressive models for wind time series. Environmental Modelling &amp; Software, 30, pp 92-101.</p>


<h3>See Also</h3>

<p>Mstep.hh.MSAR</p>

<hr>
<h2 id='nhforwards_backwards'>
Forward Backward for MSAR models with non homogeneous transitions </h2><span id='topic+nhforwards_backwards'></span>

<h3>Description</h3>

<p>Computes the posterior (or smoothing) probabilities in an homogenenous HMM or MSAR model using the forwards backwards algo.
'filter_only' is an optional argument (default: 0). If 1, we do filtering, if 0, smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhforwards_backwards(prior, transition, obslik, filter_only = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nhforwards_backwards_+3A_prior">prior</code></td>
<td>

<p>rior probabilities
PRIOR(I) = Pr(X(1) = I)</p>
</td></tr>
<tr><td><code id="nhforwards_backwards_+3A_transition">transition</code></td>
<td>

<p>non homogeneous transitions, one transition matrix for each time</p>
</td></tr>
<tr><td><code id="nhforwards_backwards_+3A_obslik">obslik</code></td>
<td>

<p>emission probabilities
OBSLIK(I,t) = Pr(Y(t) | X(t)=I)</p>
</td></tr>
<tr><td><code id="nhforwards_backwards_+3A_filter_only">filter_only</code></td>
<td>

<p>optional argument (default: 0). If TRUE, we do filtering, if FALSE, smoothing (default).
</p>
</td></tr>
</table>


<h3>Value</h3>

 <table>
<tr><td><code>..$gamma</code></td>
<td>
<p>smoothing probabilities 
P(X(t)|Y(0),...,Y(T))</p>
</td></tr>
<tr><td><code>..$xi</code></td>
<td>
<p>two steps smoothing probabilities 
P(X(t),X(t+1)|Y(0),...,Y(T))</p>
</td></tr>
<tr><td><code>..$loglik</code></td>
<td>
<p>log likelihood</p>
</td></tr>
<tr><td><code>..$M</code></td>
<td>
<p>Number of regimes</p>
</td></tr>
<tr><td><code>..$alpha</code></td>
<td>
<p>intermediate component in the FB algorithm (forward)</p>
</td></tr>
<tr><td><code>..$beta</code></td>
<td>
<p>intermediate component in the FB algorithm (backward)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>fit.MSAR, Estep.MSAR</p>

<hr>
<h2 id='PibDetteDemoc'>
Annual GDP and Debt data 1970-2010</h2><span id='topic+PibDetteDemoc'></span>

<h3>Description</h3>

<p>Annual GDP and Debt data 1970-2010</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PibDetteDemoc)</code></pre>


<h3>Format</h3>

<p>A data frame with 3198 observations on the following 5 variables.
</p>

<dl>
<dt><code>year</code></dt><dd><p> year </p>
</dd>
<dt><code>PIB</code></dt><dd><p>GDP</p>
</dd>
<dt><code>Dette</code></dt><dd><p>debt</p>
</dd>
<dt><code>Democratie</code></dt><dd><p>democratie indice</p>
</dd>
<dt><code>country</code></dt><dd><p>country</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(PibDetteDemoc)
## maybe str(PibDetteDemoc) 
</code></pre>

<hr>
<h2 id='prediction.MSAR'>
One step ahead predict for (non) homogeneous MSAR models</h2><span id='topic+prediction.MSAR'></span>

<h3>Description</h3>

<p>computes one step ahead predict for (non) homogeneous MSAR models. A time series is given as input and a prediction is return for each time. These function is mainly usefull for cross-validation.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>prediction.MSAR(data, theta, covar.emis = NULL, covar.trans = NULL, ex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prediction.MSAR_+3A_data">data</code></td>
<td>

<p>observed time series, array of dimension T*N.samples*d</p>
</td></tr>
<tr><td><code id="prediction.MSAR_+3A_theta">theta</code></td>
<td>

<p>object of class MSAR including the model's parameter</p>
</td></tr>
<tr><td><code id="prediction.MSAR_+3A_covar.emis">covar.emis</code></td>
<td>

<p>covariate for emissions (if needed)</p>
</td></tr>
<tr><td><code id="prediction.MSAR_+3A_covar.trans">covar.trans</code></td>
<td>

<p>covariate for transitions (if needed)</p>
</td></tr>
<tr><td><code id="prediction.MSAR_+3A_ex">ex</code></td>
<td>

<p>numbers of samples for which prediction has to be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>
<table>
<tr><td><code>y.p</code></td>
<td>
<p>the one step ahead prediction for each time of data time series</p>
</td></tr>
<tr><td><code>var.p</code></td>
<td>
<p>the associated variance</p>
</td></tr>
<tr><td><code>pr</code></td>
<td>
<p>the prediction probabilities for each regime </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>Cond.prob.MSAR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run
#data(meteo.data)
#data = array(meteo.data$temperature,c(31,41,1)) 
#T = dim(data)[1]
#N.samples = dim(data)[2]
#d = dim(data)[3]
#M = 2
#theta.init = init.theta.MSAR(data,M=M,order=2,label="HH")
#res.hh.2 = fit.MSAR(data,theta.init,verbose=TRUE,MaxIter=200)
#y.p.2 = prediction.MSAR(data,res.hh.2$theta,ex=1:N.samples)
#RMSE.2 = mean((data-y.p.2$y.p)^2)
</code></pre>

<hr>
<h2 id='regimes.plot.MSAR'>
Plot MSAR time series with regimes 
</h2><span id='topic+regimes.plot.MSAR'></span>

<h3>Description</h3>

<p>Plot MSAR time series with regimes materialized by gray boxes. </p>


<h3>Usage</h3>

<pre><code class='language-R'>regimes.plot.MSAR(res, data, ex = 1, col.l = "red", nc = 1, 
ylim = NULL, xlab = "time", ylab = "series", d = NULL, dt = 1, lwd = 1, cex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regimes.plot.MSAR_+3A_res">res</code></td>
<td>

<p>list obtained from fit.MSAR fonction as result of MSAR fitting</p>
</td></tr>
<tr><td><code id="regimes.plot.MSAR_+3A_data">data</code></td>
<td>

<p>data to plot</p>
</td></tr>
<tr><td><code id="regimes.plot.MSAR_+3A_ex">ex</code></td>
<td>

<p>number of sample</p>
</td></tr>
<tr><td><code id="regimes.plot.MSAR_+3A_nc">nc</code></td>
<td>
<p>component number (useful for multivariate time series)
</p>
</td></tr>
<tr><td><code id="regimes.plot.MSAR_+3A_col.l">col.l</code></td>
<td>
<p>color of time series (default is red)
</p>
</td></tr>
<tr><td><code id="regimes.plot.MSAR_+3A_ylim">ylim</code></td>
<td>

<p>range for the plotted 'y' values, defaulting to the range of the finite values of 'y'</p>
</td></tr>
<tr><td><code id="regimes.plot.MSAR_+3A_xlab">xlab</code></td>
<td>

<p>a title for the x axis</p>
</td></tr>
<tr><td><code id="regimes.plot.MSAR_+3A_ylab">ylab</code></td>
<td>

<p>a title for the y axis</p>
</td></tr>
<tr><td><code id="regimes.plot.MSAR_+3A_d">d</code></td>
<td>
<p>dimension to be plot (for multivariate cases). Default is 1. 
</p>
</td></tr>
<tr><td><code id="regimes.plot.MSAR_+3A_dt">dt</code></td>
<td>

<p>time step (default=1)</p>
</td></tr>
<tr><td><code id="regimes.plot.MSAR_+3A_lwd">lwd</code></td>
<td>

<p>width of the line</p>
</td></tr>
<tr><td><code id="regimes.plot.MSAR_+3A_cex">cex</code></td>
<td>

<p>symbols/text size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot and the regimes time series. 
</p>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lynx)
T = length(lynx)
data = array(log(lynx),c(T,1,1))
theta.init = init.theta.MSAR(data,M=2,order=2,label="HH")
mod.lynx = fit.MSAR(data,theta.init)
regimes.plot.MSAR(mod.lynx,data,ylab="Captures number")

theta.init = init.theta.MSAR(data,M=2,order=2,label="NH",nh.transitions="logistic")
attributes(theta.init)
theta.init$A0 = mod.lynx$theta$A0
theta.init$A = mod.lynx$theta$A
theta.init$sigma = mod.lynx$theta$sigma
theta.init$prior = mod.lynx$theta$prior
theta.init$transmat = mod.lynx$theta$transmat
theta.init$par.trans = matrix(c(1,-1,-.2,.2),2,2)
Y = array(data[2:T,,],c(T-1,1,1))
Z = array(data[2:T,,],c(T-1,1,1))
mod.lynx = fit.MSAR(Y,theta.init,verbose=TRUE,MaxIter=20,covar.trans=Z)
regimes.plot.MSAR(mod.lynx,data,ylab="Captures number")

## Not run
# Fit Homogeneous MS-AR models - multivariate time series
#data(PibDetteDemoc)
#T = length(unique(PibDetteDemoc$year))-1
#N.samples = length(unique(PibDetteDemoc$country))
#PIB = matrix(PibDetteDemoc$PIB,N.samples,T+1)
#Dette = matrix(PibDetteDemoc$Dette,N.samples,T+1)
#Democratie = matrix(PibDetteDemoc$Democratie,N.samples,T+1)

#d = 2
#Y = array(0,c(T,N.samples,2))
#for (k in 1:N.samples) {
#   Y[,k,1] = diff(log(PIB[k,]))
#   Y[,k,2] = diff(log(Dette[k,]))
#}
#Democ = Democratie[,2:(T+1)] 
#theta.hh.1 = init.theta.MSAR(Y,M=4,order=1,label="HH")
#res.hh = fit.MSAR(Y,theta.hh.1,verbose=TRUE,MaxIter=200)
#par(mfrow=c(2,1))
#regimes.plot.MSAR(res.hh,Y,ex=30,ylab="GDP")
#regimes.plot.MSAR(res.hh,Y,ex=30,nc=2,ylab="Debt")

</code></pre>

<hr>
<h2 id='simule_MC'>
Simulates Markov chain of length T</h2><span id='topic+simule_MC'></span>

<h3>Description</h3>

<p>Simulates Markov chain of length T, given a transition matrix and a prior distribution. </p>


<h3>Usage</h3>

<pre><code class='language-R'>simule_MC(transmat, prior, T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simule_MC_+3A_transmat">transmat</code></td>
<td>

<p>transition matrix</p>
</td></tr>
<tr><td><code id="simule_MC_+3A_prior">prior</code></td>
<td>

<p>prior distribution</p>
</td></tr>
<tr><td><code id="simule_MC_+3A_t">T</code></td>
<td>

<p>simulation length</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>Markov chain sequence</p>
</td></tr> </table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>simule_MC.nh, simule.nh.MSAR</p>

<hr>
<h2 id='simule.nh.MSAR'>
Simulation of (non) homogeneous Markov Stiwtching autoregressive models
</h2><span id='topic+simule.nh.MSAR'></span>

<h3>Description</h3>

<p>simule.nh.MSAR simulates realisations of (non) homogeneous Markov Switching autoregressive models with Gaussian innovations</p>


<h3>Usage</h3>

<pre><code class='language-R'>simule.nh.MSAR(theta, Y0, T, N.samples = 1, covar.emis = NULL, covar.trans = NULL,
link.ct = NULL,nc = 1,S0 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simule.nh.MSAR_+3A_theta">theta</code></td>
<td>

<p>list of class MSAR including model parameters and a description of the model. See init.theta.MSAR for more details. 
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR_+3A_y0">Y0</code></td>
<td>

<p>Initial value. Array of dimension order*N.samples*d with order the AR order, N.samples the number of samples to be simulated and d the dimension of the considered data.
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR_+3A_t">T</code></td>
<td>
<p>Length of each realisation to be simulated
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR_+3A_n.samples">N.samples</code></td>
<td>
<p> number of samples to be simulated
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR_+3A_covar.emis">covar.emis</code></td>
<td>
<p> emission covariate or lag for non homogeneous models. Lag is used if the covariate is the lagged time series.
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR_+3A_covar.trans">covar.trans</code></td>
<td>
<p>transition covariate or lag for non homogeneous models. Lag is used if the covariate is the lagged time series.</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR_+3A_link.ct">link.ct</code></td>
<td>
<p>allows to specify a link function for non homogeneous transitions.  
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR_+3A_nc">nc</code></td>
<td>
<p>allows to specify the components of the  vector to be considered as covariates  in the non homogeneous transitions   (default is the first component).
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR_+3A_s0">S0</code></td>
<td>
<p>initial state of the Markov chain if not null
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List including
</p>
<table>
<tr><td><code>..$Y</code></td>
<td>
<p>simulated observation time series</p>
</td></tr>
<tr><td><code>..$S</code></td>
<td>
<p>simulated Markov chain</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Val\'erie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>fit.MSAR, init.theta.MSAR,valid_all</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meteo.data)
data = array(meteo.data$temperature,c(31,41,1)) 
k = 40
plot(data[,k,1],typ="l",xlab=("time (days)"),ylab=("temperature (Celsius degrees)"))
T = dim(data)[1]
N.samples = dim(data)[2]
d = dim(data)[3]
# Fit Homogeneous MS-AR models
M = 2
order = 2
theta.init = init.theta.MSAR(data,M=M,order=order,label="HH") 
mod.hh = fit.MSAR(data,theta.init,verbose=TRUE,MaxIter=20)
# Simulation
yT = 31
Bsim = 1
Ksim = Bsim*N.samples
Y0 = array(data[1:2,sample(1:dim(data)[2],Ksim,replace=T),],c(2,Ksim,1))
Y.sim = simule.nh.MSAR(mod.hh$theta,Y0 = Y0,T,N.samples = Ksim) 
# Validation
# valid_all(data,Y.sim$Y,id=1,alpha=.05)

## Not run
#data(lynx)
#lyt &lt;- log10(lynx)
#T = length(lynx)
#Y = array(lyt,c(T,1,1))
#theta = init.theta.MSAR(Y,M=2,order=2,label='NH',nh.transitions="logistic",ncov.trans=1)
#Z = array(lyt[1:(T-2)],c(T-2,1,1))
#res=fit.MSAR(lyt[3:T],theta,covar.trans=Z,verbose=TRUE)
#Y0 = lyt[1:2]
#Bsim = 20
#Y0 = array(data[1:2,sample(1:dim(data)[2],Bsim,replace=TRUE),],c(2,Bsim,1))
#Y.sim = simule.nh.MSAR(res$theta,Y0 = Y0,T,N.samples = Bsim,covar.trans=2)</code></pre>

<hr>
<h2 id='simule.nh.MSAR.VM'>
Simulation of (non) homogeneous Markov Stiwtching autoregressive models von Mises innovations
</h2><span id='topic+simule.nh.MSAR.VM'></span>

<h3>Description</h3>

<p>simule.nh.MSAR.VM simulates realisations of (non) homogeneous Markov Switching autoregressive models with  von Mises innovations</p>


<h3>Usage</h3>

<pre><code class='language-R'>simule.nh.MSAR.VM(theta, Y0, T, N.samples = 1, covar.emis = NULL, covar.trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simule.nh.MSAR.VM_+3A_theta">theta</code></td>
<td>

<p>list of class MSAR including model parameters and a description of the model. See init.theta.MSAR.VM for more details. 
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR.VM_+3A_y0">Y0</code></td>
<td>

<p>Initial value. Array of dimension order*N.samples*d with order the AR order, N.samples the number of samples to be simulated and d the dimension of the considered data.
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR.VM_+3A_t">T</code></td>
<td>
<p>Length of each realisation to be simulated
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR.VM_+3A_n.samples">N.samples</code></td>
<td>
<p> number of samples to be simulated
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR.VM_+3A_covar.emis">covar.emis</code></td>
<td>
<p> emission covariate or lag for non homogeneous models. Lag is used if the covariate is the lagged time series.
</p>
</td></tr>
<tr><td><code id="simule.nh.MSAR.VM_+3A_covar.trans">covar.trans</code></td>
<td>
<p>transition covariate or lag for non homogeneous models. Lag is used if the covariate is the lagged time series.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List including
</p>
<table>
<tr><td><code>..$Y</code></td>
<td>
<p>simulated observation time series</p>
</td></tr>
<tr><td><code>..$S</code></td>
<td>
<p>simulated Markov chain</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Val\'erie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>References</h3>

<p>Ailliot P., Bessac J., Monbet V., P\'ene F., (2014) Non-homogeneous hidden Markov-switching models for wind time series. JSPI. 
</p>


<h3>See Also</h3>

<p>fit.MSAR.VM, init.theta.MSAR.VM</p>


<h3>Examples</h3>

<pre><code class='language-R'>	##Not run
#data(WindDir)
#T = dim(WindDir)[1]
#N.samples = dim(WindDir)[2]
#Y = array(WindDir,c(T,N.samples,1))
# von Mises homogeneous MSAR
#M = 2
#order = 1
#theta.init = init.theta.MSAR.VM(Y,M=M,order=order,label="HH")
#polar.hh = fit.MSAR.VM(Y,theta.init,MaxIter=50,verbose=TRUE,eps=1e-8)

#K.sim = 1
#Y0 = array(Y[1:2,sample(1:N.samples,K.sim,replace=T),],c(2,K.sim,1))
#sim.dir = simule.nh.MSAR.VM(polar.hh$theta,Y0=Y0,T,N.samples=K.sim)

## Not run
#theta.init$mu = polar.hh$theta$mu
# theta.init$kappa = polar.hh$theta$kappa+1i*0 # kappa complex
# theta.init$prior = polar.hh$theta$prior
# theta.init$transmat = polar.hh$theta$transmat
# polar.hh.c = fit.MSAR.VM(Y,theta.init,MaxIter=50,verbose=TRUE,eps=1e-8)
	
# theta.init = init.theta.MSAR.VM(Y,M=M,order=order,label="NH",ncov=1,nh.transitions="VM")
# theta.init$mu = polar.hh.c$theta$mu
# theta.init$kappa = polar.hh.c$theta$kappa # kappa complex
# theta.init$prior = polar.hh.c$theta$prior
# theta.init$transmat = polar.hh.c$theta$transmat
# theta.init$par.trans =  matrix(c(polar.hh.c$theta$mu,.1*matrix(1,M,1)),M,2)+1i
#Y.tmp = array(Y[2:T,,],c(T-1,N.samples,1))
#Z = array(Y[1:(T-1),,],c(T-1,N.samples,1))
# polar.nh.c = fit.MSAR.VM(Y.tmp,theta.init,MaxIter=1,verbose=T,eps=1e-8,covar.trans=Z)
#K.sim = 100
#Y0 = array(Y[1:2,sample(1:N.samples,K.sim,replace=T),],c(2,K.sim,1))
#sim.dir = simule.nh.MSAR.VM(polar.nh.c$theta,Y0=Y0,T,N.samples=K.sim,covar.trans=1)


</code></pre>

<hr>
<h2 id='test.model.MSAR'>
Performs bootstrap statistical tests to validate MSAR models. </h2><span id='topic+test.model.MSAR'></span>

<h3>Description</h3>

<p>Performs bootstrap statistical tests to validate MSAR models. Marginal distribution, auto correlation function and up-crossings are considered. For each of them the tests statistic computed from observations is compared to the distribution of the satistics corresponding to the MSAR model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.model.MSAR(data,simu,lag=NULL,id=1,u=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.model.MSAR_+3A_data">data</code></td>
<td>

<p>observed (or reference) time series, array of dimension T*N.samples*d </p>
</td></tr>
<tr><td><code id="test.model.MSAR_+3A_simu">simu</code></td>
<td>

<p>simulated time series, array of dimension T*N.sim*d.
N.sim have to be  K*N.samples with K large enough (for instance, K=100) </p>
</td></tr>
<tr><td><code id="test.model.MSAR_+3A_lag">lag</code></td>
<td>
<p>maximum lag for auto-correlation functions. </p>
</td></tr>
<tr><td><code id="test.model.MSAR_+3A_id">id</code></td>
<td>
<p>considered component. It is usefull when data is multivariate. </p>
</td></tr>
<tr><td><code id="test.model.MSAR_+3A_u">u</code></td>
<td>
<p>considered levels for up crossings</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Test statistics
Marginal distribution: </p>
<p style="text-align: center;"><code class="reqn"> S = \int_{-\infty}^{\infty} \left| F_n(x)-F(x) \right| dx</code>
</p>
  
<p>Marginal distribution, based on Anderson Darling statistic: </p>
<p style="text-align: center;"><code class="reqn"> S = \int_{-\infty}^{\infty} \left| \frac{F_n(x)-F(x)}{F(x)(1-F(x))} \right| dx</code>
</p>
  
<p>Correlation function: </p>
<p style="text-align: center;"><code class="reqn"> S = \int_0^L\left|C_n(l)-C(l)\right|dl</code>
</p>
  
<p>Number of up crossings: </p>
<p style="text-align: center;"><code class="reqn"> S = \int_{-\infty}^{\infty}\left|E_n(N_u)-E(N_u)\right|du</code>
</p>



<h3>Value</h3>

<p>Returns a list including
</p>
<table>
<tr><td><code>StaDist</code></td>
<td>
<p>statistics of marginal distributions, based on Smirnov like statistics</p>
</td></tr>
<tr><td><code>..$dd</code></td>
<td>
<p>test statistic</p>
</td></tr> 
<tr><td><code>..$q.dd</code></td>
<td>
<p>quantiles .05 and .95 of the distribution of the test statistic under the null  hypothesis </p>
</td></tr> 
<tr><td><code>..$p.value</code></td>
<td>
<p>p value</p>
</td></tr> 
<tr><td><code>Cor</code></td>
<td>
<p>statistics of correlation functions</p>
</td></tr>
<tr><td><code>..$dd</code></td>
<td>
<p>test statistic</p>
</td></tr> 
<tr><td><code>..$q.dd</code></td>
<td>
<p>quantiles .05 and .95 of the distribution of the test statistic under the null  hypothesis </p>
</td></tr> 
<tr><td><code>..$p.value</code></td>
<td>
<p>p value</p>
</td></tr> 
<tr><td><code>ENu</code></td>
<td>
<p>statistics of  intensity of up crossings </p>
</td></tr>
<tr><td><code>..$dd</code></td>
<td>
<p>test statistic</p>
</td></tr> 
<tr><td><code>..$q.dd</code></td>
<td>
<p>quantiles .05 and .95 of the distribution of the test statistic under the null  hypothesis </p>
</td></tr> 
<tr><td><code>..$p.value</code></td>
<td>
<p>p value</p>
</td></tr> 
<tr><td><code>AD</code></td>
<td>
<p>statistics of marginal distributions, based on Anderson Darling statistics</p>
</td></tr>
<tr><td><code>..$dd</code></td>
<td>
<p>test statistic</p>
</td></tr> 
<tr><td><code>..$q.dd</code></td>
<td>
<p>quantiles .05 and .95 of the distribution of the test statistic under the null  hypothesis </p>
</td></tr> 
<tr><td><code>..$p.value</code></td>
<td>
<p>p value</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>valid_all, test.model.MSAR</p>

<hr>
<h2 id='test.model.vect.MSAR'>
Performs bootstrap statistical tests on covariance to validate MSVAR models. </h2><span id='topic+test.model.vect.MSAR'></span>

<h3>Description</h3>

<p>Performs bootstrap statistical on covariance to validate MSVAR models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.model.vect.MSAR(data,simu,lag=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.model.vect.MSAR_+3A_data">data</code></td>
<td>

<p>observed (or reference) time series, array of dimension T*N.samples*d </p>
</td></tr>
<tr><td><code id="test.model.vect.MSAR_+3A_simu">simu</code></td>
<td>

<p>simulated time series, array of dimension T*N.sim*d.
N.sim have to be  K*N.samples with K large enough (for instance, K=100) </p>
</td></tr>
<tr><td><code id="test.model.vect.MSAR_+3A_lag">lag</code></td>
<td>
<p> to be considered (usefull for state space models)</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Test statistics
</p>
<p style="text-align: center;"><code class="reqn"> S = || C_n-C ||</code>
</p>
 

<h3>Value</h3>

<p>Returns a list including
</p>
<table>
<tr><td><code>Cvect</code></td>
<td>
<p>statistics of covariance</p>
</td></tr>
<tr><td><code>..$dd</code></td>
<td>
<p>test statistic</p>
</td></tr> 
<tr><td><code>..$q.dd</code></td>
<td>
<p>quantiles .05 and .95 of the distribution of the test statistic underthe null  hypothesis </p>
</td></tr> 
<tr><td><code>..$p.value</code></td>
<td>
<p>p value</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>valid_all, test.model.MSAR</p>

<hr>
<h2 id='valid_all.MSAR'>
Statistics plotting for validation of MSAR models
</h2><span id='topic+valid_all.MSAR'></span>

<h3>Description</h3>

<p>plots some functional statistics to help to valid  MSAR models: qqplot, covariance function, mean duration of sojourn over and under a threshold. For each of them the empirical statistic of the observed time series is plotted as well as the simulated one with <code class="reqn">(1-\alpha)</code>-fluctuation intervals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_all.MSAR(data,simu,title="",id=1,alpha=.05,spaghetti=TRUE,
mfrow=NULL,save=FALSE,output=FALSE,
root.filename=" ",path=NULL,col="red",width=4,height=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid_all.MSAR_+3A_data">data</code></td>
<td>

<p>observed (or reference) time series, array of dimension T*N.samples*d </p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_simu">simu</code></td>
<td>

<p>simulated time series, array of dimension T*N.sim*d.
N.sim have to be  K*N.samples with K large enough (for instance, K=100) </p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_title">title</code></td>
<td>

<p>title of plots</p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_id">id</code></td>
<td>

<p>component to be considered when the data is multivariate (d&gt;1). Default d=1.</p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_alpha">alpha</code></td>
<td>

<p>level for the <code class="reqn">(1-\alpha)</code>-fluctuation intervals</p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_spaghetti">spaghetti</code></td>
<td>
<p>statistics of every simulation batch are plotted instead of fluctuation intervals. A batch is a simulation block of the same size as the observations. Default spaghetti=TRUE</p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_mfrow">mfrow</code></td>
<td>
<p>if NULL, each plot is done in a new window</p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_save">save</code></td>
<td>
<p>if save=TRUE plots are saved into .eps files</p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_root.filename">root.filename</code></td>
<td>

<p>root file name for saving plots</p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_path">path</code></td>
<td>

<p>path of folder where to save the files</p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_output">output</code></td>
<td>

<p>if TRUE some statistics are returned.  </p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_col">col</code></td>
<td>
<p>color of the lines for simulated data, default is red</p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_width">width</code></td>
<td>
<p>width of the figure when is it save by dev.copy2eps</p>
</td></tr>
<tr><td><code id="valid_all.MSAR_+3A_height">height</code></td>
<td>
<p>height of the figure when is it save by dev.copy2eps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns plots and
</p>
<table>
<tr><td><code>qqp</code></td>
<td>
<p>statistics of marginal distributions</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>statistics of correlation functions</p>
</td></tr>
<tr><td><code>ENu.data</code></td>
<td>
<p>statistics of  intensity of up crossings of the data</p>
</td></tr>
<tr><td><code>ENu.simu</code></td>
<td>
<p>statistics of  intensity of up crossings of the simulations</p>
</td></tr>
<tr><td><code>MDO</code></td>
<td>
<p>statistics of  mean duration over a level</p>
</td></tr>
<tr><td><code>MDU</code></td>
<td>
<p>statistics of  mean duration under a level</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meteo.data)
data = array(meteo.data$temperature,c(31,41,1)) 
k = 40
plot(data[,k,1],typ="l",xlab=("time (days)"),ylab=("temperature (degrees C)"))
T = dim(data)[1]
N.samples = dim(data)[2]
d = dim(data)[3]
# Fit Homogeneous MS-AR models
M = 2
order = 1
theta.init = init.theta.MSAR(data,M=M,order=order,label="HH") 
mod.hh = fit.MSAR(data,theta.init,verbose=TRUE,MaxIter=10)
# Simulation
yT = 31
Bsim = 10
Ksim = Bsim*N.samples
Y0 = array(data[1:2,sample(1:dim(data)[2],Ksim,replace=T),],c(2,Ksim,1))
Y.sim = simule.nh.MSAR(mod.hh$theta,Y0 = Y0,T,N.samples = Ksim) 
valid_all.MSAR(data,Y.sim$Y)
</code></pre>

<hr>
<h2 id='viterbi_path'>
Viterbi path homogeneous MSAR models</h2><span id='topic+viterbi_path'></span>

<h3>Description</h3>

<p>Computes the Viterbi path associated to  an homogenenous HMM or MSAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viterbi_path(prior, transmat, obsmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viterbi_path_+3A_prior">prior</code></td>
<td>
<p> prior probabilities
PRIOR(I) = Pr(X(1) = I)
</p>
</td></tr>
<tr><td><code id="viterbi_path_+3A_transmat">transmat</code></td>
<td>
<p> transition matrice
TRANSMAT(I,J) = Pr(X(T+1)=J | X(T)=I)
</p>
</td></tr>
<tr><td><code id="viterbi_path_+3A_obsmat">obsmat</code></td>
<td>
<p>emission probabilities
OBSMAT(I,t) = Pr(Y(t) | X(t)=I)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List including
</p>
<table>
<tr><td><code>..$gamma</code></td>
<td>
<p>smoothing probabilities 
P(X(t)|Y(0),...,Y(T))</p>
</td></tr>
<tr><td><code>..$xi</code></td>
<td>
<p>two steps smoothing probabilities 
P(X(t),X(t+1)|Y(0),...,Y(T))</p>
</td></tr>
<tr><td><code>..$loglik</code></td>
<td>
<p>log likelihood</p>
</td></tr>
<tr><td><code>..$M</code></td>
<td>
<p>Number of regimes</p>
</td></tr>
<tr><td><code>..$alpha</code></td>
<td>
<p>intermediate component in the FB algorithm (forward)</p>
</td></tr>
<tr><td><code>..$beta</code></td>
<td>
<p>intermediate component in the FB algorithm (backward)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valerie Monbet, valerie.monbet@univ-rennes1.fr</p>


<h3>See Also</h3>

<p>forwards_backwards.R, fit.MSAR, Estep.MSAR
</p>

<hr>
<h2 id='Wind'>
Winter wind data at 18 locations offshore of France</h2><span id='topic+U'></span>

<h3>Description</h3>

<p>Wind intensity at 18 locations offshore of France for months january and february. 32 years of data.  Time step is 6 hours. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meteo.data)</code></pre>


<h3>Format</h3>

<p>An array of dimension 248*32*18
</p>

<dl>
<dt><code>U</code></dt><dd><p>wind intensity</p>
</dd>
</dl>



<h3>Source</h3>

<p>ERA-Interim</p>


<h3>References</h3>

<p>Bessac, J., Ailliot, P., &amp; Monbet, V. (2013). Gaussian linear state-space model for wind fields in the North-East Atlantic. arXiv preprint arXiv:1312.5530.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Wind)
</code></pre>

<hr>
<h2 id='WindDir'>
January wind direction at Ouessant</h2><span id='topic+WindDir'></span>

<h3>Description</h3>

<p>Wind direction at Ouessant. 49 independant january month (one per column). Time step is 6 hours. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meteo.data)</code></pre>


<h3>Format</h3>

<p>A matrix of dimension 124*32
</p>

<dl>
<dt><code>WindDir</code></dt><dd><p>wind direction</p>
</dd>
</dl>



<h3>Source</h3>

<p>ERA-Interim</p>


<h3>References</h3>

<p>Ailliot P., Bessac J., Monbet V., Pene F., (2014) Non-homogeneous hidden Markov-switching models for wind time series. JSPI.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WindDir)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
