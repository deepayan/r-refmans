<!DOCTYPE html><html><head><title>Help for package posterior</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {posterior}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#posterior-package'><p>Tools for working with posterior (and prior) distributions</p></a></li>
<li><a href='#+5B.draws_array'><p>Extract parts of a <code>draws_array</code> object</p></a></li>
<li><a href='#+5B.draws_matrix'><p>Extract parts of a <code>draws_matrix</code> object</p></a></li>
<li><a href='#as_rvar'><p>Coerce to a random variable</p></a></li>
<li><a href='#as_rvar_factor'><p>Coerce to a factor random variable</p></a></li>
<li><a href='#autocorrelation'><p>Autocorrelation estimates</p></a></li>
<li><a href='#autocovariance'><p>Autocovariance estimates</p></a></li>
<li><a href='#bind_draws'><p>Bind <code>draws</code> objects together</p></a></li>
<li><a href='#chol.rvar'><p>Cholesky decomposition of random matrix</p></a></li>
<li><a href='#diag+2Crvar-method'><p>Matrix diagonals (including for random variables)</p></a></li>
<li><a href='#diagnostics'><p>List of available convergence diagnostics</p></a></li>
<li><a href='#dissent'><p>Dissention</p></a></li>
<li><a href='#draws'><p>Transform to <code>draws</code> objects</p></a></li>
<li><a href='#draws_array'><p>The <code>draws_array</code> format</p></a></li>
<li><a href='#draws_df'><p>The <code>draws_df</code> format</p></a></li>
<li><a href='#draws_list'><p>The <code>draws_list</code> format</p></a></li>
<li><a href='#draws_matrix'><p>The <code>draws_matrix</code> format</p></a></li>
<li><a href='#draws_of'><p>Get/set array of draws underlying a random variable</p></a></li>
<li><a href='#draws_rvars'><p>The <code>draws_rvars</code> format</p></a></li>
<li><a href='#draws_summary'><p>Summaries of <code>draws</code> objects</p></a></li>
<li><a href='#draws-index'><p>Index <code>draws</code> objects</p></a></li>
<li><a href='#drop+2Crvar-method'><p>Drop redundant dimensions</p></a></li>
<li><a href='#entropy'><p>Normalized entropy</p></a></li>
<li><a href='#ess_basic'><p>Basic version of the effective sample size</p></a></li>
<li><a href='#ess_bulk'><p>Bulk effective sample size (bulk-ESS)</p></a></li>
<li><a href='#ess_mean'><p>Effective sample size for the mean</p></a></li>
<li><a href='#ess_quantile'><p>Effective sample sizes for quantiles</p></a></li>
<li><a href='#ess_sd'><p>Effective sample size for the standard deviation</p></a></li>
<li><a href='#ess_tail'><p>Tail effective sample size (tail-ESS)</p></a></li>
<li><a href='#example_draws'><p>Example <code>draws</code> objects</p></a></li>
<li><a href='#extract_variable'><p>Extract draws of a single variable</p></a></li>
<li><a href='#extract_variable_matrix'><p>Extract matrix of a single variable</p></a></li>
<li><a href='#for_each_draw'><p>Loop over draws</p></a></li>
<li><a href='#is_rvar'><p>Is <code>x</code> a random variable?</p></a></li>
<li><a href='#is_rvar_factor'><p>Is <code>x</code> a factor random variable?</p></a></li>
<li><a href='#match'><p>Value Matching</p></a></li>
<li><a href='#mcse_mean'><p>Monte Carlo standard error for the mean</p></a></li>
<li><a href='#mcse_quantile'><p>Monte Carlo standard error for quantiles</p></a></li>
<li><a href='#mcse_sd'><p>Monte Carlo standard error for the standard deviation</p></a></li>
<li><a href='#merge_chains'><p>Merge chains of <code>draws</code> objects</p></a></li>
<li><a href='#modal_category'><p>Modal category</p></a></li>
<li><a href='#mutate_variables'><p>Mutate variables in <code>draws</code> objects</p></a></li>
<li><a href='#order_draws'><p>Order <code>draws</code> objects</p></a></li>
<li><a href='#pareto_diags'><p>Pareto smoothing diagnostics</p></a></li>
<li><a href='#pareto_khat'><p>Pareto khat diagnostic</p></a></li>
<li><a href='#pareto_smooth'><p>Pareto smoothing</p></a></li>
<li><a href='#print.draws_array'><p>Print <code>draws_array</code> objects</p></a></li>
<li><a href='#print.draws_df'><p>Print <code>draws_df</code> objects</p></a></li>
<li><a href='#print.draws_list'><p>Print <code>draws_list</code> objects</p></a></li>
<li><a href='#print.draws_matrix'><p>Print <code>draws_matrix</code> objects</p></a></li>
<li><a href='#print.draws_rvars'><p>Print <code>draws_rvars</code> objects</p></a></li>
<li><a href='#print.draws_summary'><p>Print summaries of <code>draws</code> objects</p></a></li>
<li><a href='#print.rvar'><p>Print or format a random variable</p></a></li>
<li><a href='#quantile2'><p>Compute Quantiles</p></a></li>
<li><a href='#r_scale'><p>Rank values</p></a></li>
<li><a href='#rdo'><p>Execute expressions of random variables</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rename_variables'><p>Rename variables in <code>draws</code> objects</p></a></li>
<li><a href='#repair_draws'><p>Repair indices of <code>draws</code> objects</p></a></li>
<li><a href='#resample_draws'><p>Resample <code>draws</code> objects</p></a></li>
<li><a href='#reserved_variables'><p>Reserved variables</p></a></li>
<li><a href='#rfun'><p>Create functions of random variables</p></a></li>
<li><a href='#rhat'><p>Rhat convergence diagnostic</p></a></li>
<li><a href='#rhat_basic'><p>Basic version of the Rhat convergence diagnostic</p></a></li>
<li><a href='#rhat_nested'><p>Nested Rhat convergence diagnostic</p></a></li>
<li><a href='#rstar'><p>Calculate R* convergence diagnostic</p></a></li>
<li><a href='#rvar'><p>Random variables of arbitrary dimension</p></a></li>
<li><a href='#rvar_apply'><p>Random variable resulting from a function applied over margins of an array or random variable</p></a></li>
<li><a href='#rvar_factor'><p>Factor random variables of arbitrary dimension</p></a></li>
<li><a href='#rvar_ifelse'><p>Random variable ifelse</p></a></li>
<li><a href='#rvar_is_finite'><p>Special value predicates for random variables</p></a></li>
<li><a href='#rvar_rng'><p>Create random variables from existing random number generators</p></a></li>
<li><a href='#rvar-dist'><p>Density, CDF, and quantile functions of random variables</p></a></li>
<li><a href='#rvar-matmult'><p>Matrix multiplication of random variables</p></a></li>
<li><a href='#rvar-slice'><p>Random variable slicing</p></a></li>
<li><a href='#rvar-summaries-over-draws'><p>Summaries of random variables within array elements, over draws</p></a></li>
<li><a href='#rvar-summaries-within-draws'><p>Summaries of random variables over array elements, within draws</p></a></li>
<li><a href='#set_variables'><p>Set variable names in <code>draws</code> objects</p></a></li>
<li><a href='#split_chains'><p>Split Chains</p></a></li>
<li><a href='#subset_draws'><p>Subset <code>draws</code> objects</p></a></li>
<li><a href='#thin_draws'><p>Thin <code>draws</code> objects</p></a></li>
<li><a href='#u_scale'><p>Rank uniformization</p></a></li>
<li><a href='#weight_draws'><p>Weight <code>draws</code> objects</p></a></li>
<li><a href='#weights.draws'><p>Extract Weights from Draws Objects</p></a></li>
<li><a href='#z_scale'><p>Rank normalization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Working with Posterior Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-31</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides useful tools for both users and developers of packages 
  for fitting Bayesian models or working with output from Bayesian models. 
  The primary goals of the package are to: 
  (a) Efficiently convert between many different useful formats of
  draws (samples) from posterior or prior distributions.
  (b) Provide consistent methods for operations commonly performed on draws, 
  for example, subsetting, binding, or mutating draws.
  (c) Provide various summaries of draws in convenient formats.
  (d) Provide lightweight implementations of state of the art posterior 
  inference diagnostics. References: Vehtari et al. (2021) 
  &lt;<a href="https://doi.org/10.1214%2F20-BA1221">doi:10.1214/20-BA1221</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, abind, checkmate, rlang (&ge; 1.0.6), stats, tibble (&ge;
3.1.0), vctrs (&ge; 0.5.0), tensorA, pillar, distributional,
parallel, matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), caret (&ge; 6.0.84), gbm (&ge; 2.1.8),
randomForest (&ge; 4.6.14), e1071 (&ge; 1.7.3), dplyr, tidyr,
knitr, ggplot2, ggdist, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mc-stan.org/posterior/">https://mc-stan.org/posterior/</a>, <a href="https://discourse.mc-stan.org/">https://discourse.mc-stan.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stan-dev/posterior/issues">https://github.com/stan-dev/posterior/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-31 07:26:08 UTC; paul.buerkner</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul-Christian Bürkner [aut, cre],
  Jonah Gabry [aut],
  Matthew Kay [aut],
  Aki Vehtari [aut],
  Måns Magnusson [ctb],
  Rok Češnovar [ctb],
  Ben Lambert [ctb],
  Ozan Adıgüzel [ctb],
  Jacob Socolar [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul-Christian Bürkner &lt;paul.buerkner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-31 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='posterior-package'>Tools for working with posterior (and prior) distributions</h2><span id='topic+posterior-package'></span><span id='topic+posterior'></span>

<h3>Description</h3>


<p><img src="../help/figures/stanlogo.png" width="50" alt="stanlogo.png" />
<a href="https://mc-stan.org/posterior/">https://mc-stan.org/posterior/</a>

</p>
<p>The <span class="pkg">posterior</span> package is intended to provide useful tools
for both users and developers of packages for fitting Bayesian models or
working with output from Bayesian models. The primary goals of the package
are to:
</p>

<ul>
<li><p> Efficiently convert between many different useful formats of
draws (samples) from posterior or prior distributions.
</p>
</li>
<li><p> Provide consistent methods for operations commonly performed on draws,
for example, subsetting, binding, or mutating draws.
</p>
</li>
<li><p> Provide various summaries of draws in convenient formats.
</p>
</li>
<li><p> Provide lightweight implementations of state of the art posterior inference
diagnostics.
</p>
</li></ul>



<h3>Package options</h3>

<p>The following options are used to format and print <code><a href="#topic+draws">draws</a></code> objects,
as in <code>print.draws_array()</code>, <code>print.draws_df()</code>, <code>print.draws_list()</code>,
<code>print.draws_matrix()</code>, and <code>print.draws_rvars()</code>:
</p>

<ul>
<li> <p><code>posterior.max_draws</code>: Maximum number of draws to print.
</p>
</li>
<li> <p><code>posterior.max_iterations</code>: Maximum number of iterations to print.
</p>
</li>
<li> <p><code>posterior.max_chains</code>: Maximum number of chains to print.
</p>
</li>
<li> <p><code>posterior.max_variables</code>: Maximum number of variables to print.
</p>
</li></ul>

<p>The following options are used for formatting the output of
<code><a href="#topic+summarize_draws">summarize_draws</a></code>:
</p>

<ul>
<li> <p><code>posterior.num_args</code>: Arguments passed to <a href="tibble.html#topic+num">num()</a>
for pretty printing of summaries.
</p>
</li></ul>

<p>The following options are used to format and print <code><a href="#topic+rvar">rvar</a></code> objects,
as in <code>print.rvar()</code> and <code>print.draws_rvars()</code>:
</p>

<ul>
<li> <p><code>posterior.rvar_summary</code>: What style of summary to display:
<code>"mean_sd"</code> displays <code style="white-space: pre;">&#8288;mean ± sd&#8288;</code>, <code>"median_mad"</code> displays <code style="white-space: pre;">&#8288;median ± mad&#8288;</code>.
</p>
</li>
<li> <p><code>posterior.digits</code>: How many significant digits are displayed. This
defaults to a smaller value (<code>2</code>) than <code>getOption("digits")</code> because
<code><a href="#topic+rvar">rvar</a></code>s print two numbers (point summary and uncertainty) next to
each other.
</p>
</li></ul>

<p>The following option is used to construct new <code><a href="#topic+rvar">rvar</a></code> objects,
as in <code>rfun()</code> and <code>rdo()</code>:
</p>

<ul>
<li> <p><code>posterior.rvar_ndraws</code>: The number of draws used to construct
new random variables when this number cannot be determined
from existing arguments (e.g., other <code><a href="#topic+rvar">rvar</a></code>s passed to a function).
</p>
</li></ul>

<p>The following options are used to control warning messages:
</p>

<ul>
<li> <p><code>posterior.warn_on_merge_chains</code>: (logical) Some operations will
trigger an automatic merging of chains, for example, because chains do not
match between two objects involved in a binary operation. Whether this
causes a warning can be controlled by this option.
</p>
</li></ul>


<hr>
<h2 id='+5B.draws_array'>Extract parts of a <code>draws_array</code> object</h2><span id='topic++5B.draws_array'></span>

<h3>Description</h3>

<p>Extract parts of a <code>draws_array</code> object. They are strictly defined as arrays
of 3 dimensions (iteration x chain x variable) so dropping any of the
dimensions breaks the expected structure of the object. Accordingly, no
dropping of dimensions is done by default even if the extracted slices are of
length 1. If <code>drop</code> is manually set to <code>TRUE</code> and any of the dimensions is
actually dropped, this will lead to dropping the <code>"draws_array"</code> class as
well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'draws_array'
x[i, j, ..., drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.draws_array_+3A_x">x</code>, <code id="+2B5B.draws_array_+3A_i">i</code>, <code id="+2B5B.draws_array_+3A_j">j</code>, <code id="+2B5B.draws_array_+3A_...">...</code>, <code id="+2B5B.draws_array_+3A_drop">drop</code></td>
<td>
<p>Same as in the default extraction method but with
<code>drop</code> being set to <code>FALSE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"draws_array"</code> unless any of the dimensions
was dropped during the extraction.
</p>

<hr>
<h2 id='+5B.draws_matrix'>Extract parts of a <code>draws_matrix</code> object</h2><span id='topic++5B.draws_matrix'></span>

<h3>Description</h3>

<p>Extract parts of a <code>draws_matrix</code> object. They are strictly defined as
matrices (draws x variable) so dropping any of the
dimensions breaks the expected structure of the object. Accordingly, no
dropping of dimensions is done by default even if the extracted slices are of
length 1. If <code>drop</code> is manually set to <code>TRUE</code> and any of the dimensions is
actually dropped, this will lead to dropping the <code>"draws_matrix"</code> class as
well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'draws_matrix'
x[i, j, ..., drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.draws_matrix_+3A_x">x</code>, <code id="+2B5B.draws_matrix_+3A_i">i</code>, <code id="+2B5B.draws_matrix_+3A_j">j</code>, <code id="+2B5B.draws_matrix_+3A_...">...</code>, <code id="+2B5B.draws_matrix_+3A_drop">drop</code></td>
<td>
<p>Same as in the default extraction method but with
<code>drop</code> being set to <code>FALSE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"draws_matrix"</code> unless any of the dimensions
was dropped during the extraction.
</p>

<hr>
<h2 id='as_rvar'>Coerce to a random variable</h2><span id='topic+as_rvar'></span><span id='topic+as_rvar_numeric'></span><span id='topic+as_rvar_integer'></span><span id='topic+as_rvar_logical'></span>

<h3>Description</h3>

<p>Convert <code>x</code> to an <code><a href="#topic+rvar">rvar</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_rvar(x, dim = NULL, dimnames = NULL, nchains = NULL)

as_rvar_numeric(x, dim = NULL, dimnames = NULL, nchains = NULL)

as_rvar_integer(x, dim = NULL, dimnames = NULL, nchains = NULL)

as_rvar_logical(x, dim = NULL, dimnames = NULL, nchains = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_rvar_+3A_x">x</code></td>
<td>
<p>(multiple options) An object that can be converted to an <code><a href="#topic+rvar">rvar</a></code>,
such as a vector, array, or an <code><a href="#topic+rvar">rvar</a></code> itself.</p>
</td></tr>
<tr><td><code id="as_rvar_+3A_dim">dim</code></td>
<td>
<p>(integer vector) One or more integers giving the maximal indices
in each dimension to override the dimensions of the <code><a href="#topic+rvar">rvar</a></code> to be created
(see <code><a href="base.html#topic+dim">dim()</a></code>). If <code>NULL</code> (the default), <code>dim</code> is determined by the input.
<strong>NOTE:</strong> This argument controls the dimensions of the <code><a href="#topic+rvar">rvar</a></code>, not the
underlying array, so you cannot change the number of draws using this
argument.</p>
</td></tr>
<tr><td><code id="as_rvar_+3A_dimnames">dimnames</code></td>
<td>
<p>(list) Character vectors giving the names in each dimension
to override the names of the dimensions of the <code><a href="#topic+rvar">rvar</a></code> to be created (see
<code><a href="base.html#topic+dimnames">dimnames()</a></code>). If <code>NULL</code> (the default), this is determined by the input.
<strong>NOTE:</strong> This argument controls the names of the dimensions of the
<code><a href="#topic+rvar">rvar</a></code>, not the underlying array.</p>
</td></tr>
<tr><td><code id="as_rvar_+3A_nchains">nchains</code></td>
<td>
<p>(positive integer) The number of chains. The default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For objects that are already <code><a href="#topic+rvar">rvar</a></code>s, returns them (with modified dimensions
if <code>dim</code> is not <code>NULL</code>).
</p>
<p>For numeric or logical vectors or arrays, returns an <code><a href="#topic+rvar">rvar</a></code> with a single draw and
the same dimensions as <code>x</code>. This is in contrast to the <code><a href="#topic+rvar">rvar()</a></code> constructor, which
treats the first dimension of <code>x</code> as the draws dimension. As a result, <code>as_rvar()</code>
is useful for creating constants.
</p>
<p>While <code>as_rvar()</code> attempts to pick the most suitable subtype of <code><a href="#topic+rvar">rvar</a></code> based on the
type of <code>x</code> (possibly returning an <code><a href="#topic+rvar_factor">rvar_factor</a></code> or <code><a href="#topic+rvar_ordered">rvar_ordered</a></code>),
<code>as_rvar_numeric()</code>, <code>as_rvar_integer()</code>, and <code>as_rvar_logical()</code> always coerce
the draws of the output <code><a href="#topic+rvar">rvar</a></code> to be <code><a href="base.html#topic+numeric">numeric</a></code>, <code><a href="base.html#topic+integer">integer</a></code>, or <code><a href="base.html#topic+logical">logical</a></code>
(respectively), and always return a base <code><a href="#topic+rvar">rvar</a></code>, never a subtype.
</p>


<h3>Value</h3>

<p>An object of class <code>"rvar"</code> (or one of its subtypes) representing a random variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvar">rvar()</a></code> to construct <code><a href="#topic+rvar">rvar</a></code>s directly.  See <code><a href="#topic+rdo">rdo()</a></code>, <code><a href="#topic+rfun">rfun()</a></code>, and
<code><a href="#topic+rvar_rng">rvar_rng()</a></code> for higher-level interfaces for creating <code>rvar</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# You can use as_rvar() to create "constant" rvars (having only one draw):
x &lt;- as_rvar(1)
x

# Such constants can be of arbitrary shape:
as_rvar(1:4)
as_rvar(matrix(1:10, nrow = 5))
as_rvar(array(1:12, dim = c(2, 3, 2)))

# as_rvar_numeric() coerces subtypes of rvar to the base rvar type
y &lt;- as_rvar_factor(c("a", "b", "c"))
y
as_rvar_numeric(y)

</code></pre>

<hr>
<h2 id='as_rvar_factor'>Coerce to a factor random variable</h2><span id='topic+as_rvar_factor'></span><span id='topic+as_rvar_ordered'></span>

<h3>Description</h3>

<p>Convert <code>x</code> to an <code><a href="#topic+rvar_factor">rvar_factor</a></code> or <code><a href="#topic+rvar_ordered">rvar_ordered</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_rvar_factor(x, dim = NULL, dimnames = NULL, nchains = NULL, ...)

as_rvar_ordered(x, dim = NULL, dimnames = NULL, nchains = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_rvar_factor_+3A_x">x</code></td>
<td>
<p>(multiple options) An object that can be converted to an <code><a href="#topic+rvar">rvar</a></code>,
such as a vector, array, or an <code><a href="#topic+rvar">rvar</a></code> itself.</p>
</td></tr>
<tr><td><code id="as_rvar_factor_+3A_dim">dim</code></td>
<td>
<p>(integer vector) One or more integers giving the maximal indices
in each dimension to override the dimensions of the <code><a href="#topic+rvar">rvar</a></code> to be created
(see <code><a href="base.html#topic+dim">dim()</a></code>). If <code>NULL</code> (the default), <code>dim</code> is determined by the input.
<strong>NOTE:</strong> This argument controls the dimensions of the <code><a href="#topic+rvar">rvar</a></code>, not the
underlying array, so you cannot change the number of draws using this
argument.</p>
</td></tr>
<tr><td><code id="as_rvar_factor_+3A_dimnames">dimnames</code></td>
<td>
<p>(list) Character vectors giving the names in each dimension
to override the names of the dimensions of the <code><a href="#topic+rvar">rvar</a></code> to be created (see
<code><a href="base.html#topic+dimnames">dimnames()</a></code>). If <code>NULL</code> (the default), this is determined by the input.
<strong>NOTE:</strong> This argument controls the names of the dimensions of the
<code><a href="#topic+rvar">rvar</a></code>, not the underlying array.</p>
</td></tr>
<tr><td><code id="as_rvar_factor_+3A_nchains">nchains</code></td>
<td>
<p>(positive integer) The number of chains. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="as_rvar_factor_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+factor">base::factor</a></code>
</p>

<dl>
<dt><code>levels</code></dt><dd><p>an optional vector of the unique values (as character strings)
that <code>x</code> might have taken.  The default is the unique set of
values taken by <code><a href="base.html#topic+as.character">as.character</a>(x)</code>, sorted into
increasing order <em>of <code>x</code></em>.  Note that this set can be
specified as smaller than <code>sort(unique(x))</code>.</p>
</dd>
<dt><code>labels</code></dt><dd><p><em>either</em> an optional character vector of
labels for the levels (in the same order as <code>levels</code> after
removing those in <code>exclude</code>), <em>or</em> a character string of
length 1.  Duplicated values in <code>labels</code> can be used to map
different values of <code>x</code> to the same factor level.</p>
</dd>
<dt><code>exclude</code></dt><dd><p>a vector of values to be excluded when forming the
set of levels.  This may be factor with the same level set as <code>x</code>
or should be a <code>character</code>.</p>
</dd>
<dt><code>ordered</code></dt><dd><p>logical flag to determine if the levels should be regarded
as ordered (in the order given).</p>
</dd>
<dt><code>nmax</code></dt><dd><p>an upper bound on the number of levels; see &lsquo;Details&rsquo;.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>For objects that are already <code><a href="#topic+rvar">rvar</a></code>s, returns them (with modified dimensions
if <code>dim</code> is not <code>NULL</code>), possibly adding levels using the unique values of the draws of
the <code>rvar</code> (if the object is not already factor-like).
</p>
<p>For numeric, logical, factor, or character vectors or arrays, returns an <code><a href="#topic+rvar_factor">rvar_factor</a></code>
or <code><a href="#topic+rvar_ordered">rvar_ordered</a></code> with a single draw and the same dimensions as <code>x</code>. This is in contrast
to the <code><a href="#topic+rvar_factor">rvar_factor()</a></code> and <code><a href="#topic+rvar_ordered">rvar_ordered()</a></code> constructors, which treats the first dimension
of <code>x</code> as the draws dimension. As a result, <code>as_rvar_factor()</code> and <code>as_rvar_ordered()</code>
are useful for creating constants.
</p>


<h3>Value</h3>

<p>An object of class <code>"rvar_factor"</code> or <code>"rvar_ordered"</code> representing a random variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvar">rvar()</a></code>, <code><a href="#topic+rvar_factor">rvar_factor()</a></code>, and <code><a href="#topic+rvar_ordered">rvar_ordered()</a></code> to construct <code><a href="#topic+rvar">rvar</a></code>s directly.
See <code><a href="#topic+rdo">rdo()</a></code>, <code><a href="#topic+rfun">rfun()</a></code>, and <code><a href="#topic+rvar_rng">rvar_rng()</a></code> for higher-level interfaces for creating <code>rvar</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# You can use as_rvar_factor() to create "constant" rvars (having only one draw):
x &lt;- as_rvar_factor("a")
x

# Such constants can be of arbitrary shape:
as_rvar_factor(letters[1:4])
as_rvar_ordered(matrix(letters[1:10], nrow = 5))
as_rvar_factor(array(letters[1:12], dim = c(2, 3, 2)))

</code></pre>

<hr>
<h2 id='autocorrelation'>Autocorrelation estimates</h2><span id='topic+autocorrelation'></span>

<h3>Description</h3>

<p>Compute autocorrelation estimates for every lag for the specified
input sequence using a fast Fourier transform approach. The estimate
for lag t is scaled by N-t where N is the length of the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorrelation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorrelation_+3A_x">x</code></td>
<td>
<p>(numeric vector) A sequence of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of autocorrelations at every lag (scaled by N-lag).
</p>

<hr>
<h2 id='autocovariance'>Autocovariance estimates</h2><span id='topic+autocovariance'></span>

<h3>Description</h3>

<p>Compute autocovariance estimates for every lag for the specified
input sequence using a fast Fourier transform approach. The estimate
for lag t is scaled by N-t where N is the length of the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocovariance(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocovariance_+3A_x">x</code></td>
<td>
<p>(numeric vector) A sequence of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of autocovariances at every lag (scaled by N-lag).
</p>

<hr>
<h2 id='bind_draws'>Bind <code>draws</code> objects together</h2><span id='topic+bind_draws'></span><span id='topic+bind_draws.draws_matrix'></span><span id='topic+bind_draws.draws_array'></span><span id='topic+bind_draws.draws_df'></span><span id='topic+bind_draws.draws_list'></span><span id='topic+bind_draws.draws_rvars'></span>

<h3>Description</h3>

<p>Bind multiple <code><a href="#topic+draws">draws</a></code> objects together to form a single <code>draws</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_draws(x, ...)

## S3 method for class 'draws_matrix'
bind_draws(x, ..., along = "variable")

## S3 method for class 'draws_array'
bind_draws(x, ..., along = "variable")

## S3 method for class 'draws_df'
bind_draws(x, ..., along = "variable")

## S3 method for class 'draws_list'
bind_draws(x, ..., along = "variable")

## S3 method for class 'draws_rvars'
bind_draws(x, ..., along = "variable")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_draws_+3A_x">x</code></td>
<td>
<p>(draws) A <code><a href="#topic+draws">draws</a></code> object. The draws format of <code>x</code> will define the
format of the returned draws object.</p>
</td></tr>
<tr><td><code id="bind_draws_+3A_...">...</code></td>
<td>
<p>(draws) Additional <code><a href="#topic+draws">draws</a></code> objects to bind to <code>x</code>.</p>
</td></tr>
<tr><td><code id="bind_draws_+3A_along">along</code></td>
<td>
<p>(string) The dimension along which draws objects should be bound
together. Possible values are <code>"variable"</code> (the default), <code>"chain"</code>,
<code>"iteration"</code>, and <code>"draw"</code>. Not all options are supported for all input
formats.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- draws_matrix(alpha = rnorm(5), beta = rnorm(5))
x2 &lt;- draws_matrix(alpha = rnorm(5), beta = rnorm(5))
ndraws(x1)
ndraws(x2)
x3 &lt;- bind_draws(x1, x2, along = "draw")
ndraws(x3)

x4 &lt;- draws_matrix(theta = rexp(5))
x5 &lt;- bind_draws(x1, x4, along = "variable")
variables(x5)

</code></pre>

<hr>
<h2 id='chol.rvar'>Cholesky decomposition of random matrix</h2><span id='topic+chol.rvar'></span>

<h3>Description</h3>

<p>Cholesky decomposition of an <code><a href="#topic+rvar">rvar</a></code> containing a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rvar'
chol(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chol.rvar_+3A_x">x</code></td>
<td>
<p>(rvar) A 2-dimensional <code><a href="#topic+rvar">rvar</a></code>.</p>
</td></tr>
<tr><td><code id="chol.rvar_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to <code>chol.tensor()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+rvar">rvar</a></code> containing the upper triangular factor of the Cholesky
decomposition, i.e., the matrix <code class="reqn">R</code> such that <code class="reqn">R'R = x</code>.
</p>

<hr>
<h2 id='diag+2Crvar-method'>Matrix diagonals (including for random variables)</h2><span id='topic+diag+2Crvar-method'></span>

<h3>Description</h3>

<p>Extract the diagonal of a matrix or construct a matrix, including random
matrices (2-dimensional <code><a href="#topic+rvar">rvar</a></code>s). Makes <code><a href="base.html#topic+diag">base::diag()</a></code> generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'rvar'
diag(x = 1, nrow, ncol, names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag+2B2Crvar-method_+3A_x">x</code></td>
<td>
<p>(numeric,rvar) a matrix, vector, 1D array, missing, or a 1- or
2-dimensional <code><a href="#topic+rvar">rvar</a></code>.</p>
</td></tr>
<tr><td><code id="diag+2B2Crvar-method_+3A_nrow">nrow</code>, <code id="diag+2B2Crvar-method_+3A_ncol">ncol</code></td>
<td>
<p>optional dimensions for the result when <code>x</code> is
not a matrix.</p>
</td></tr>
<tr><td><code id="diag+2B2Crvar-method_+3A_names">names</code></td>
<td>
<p>(when <code>x</code> is a matrix) logical indicating if the
resulting vector, the diagonal of <code>x</code>, should inherit
<code><a href="base.html#topic+names">names</a></code> from <code>dimnames(x)</code> if available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Makes <code><a href="base.html#topic+diag">base::diag()</a></code> into a generic function. See that function's documentation
for usage with <code><a href="base.html#topic+numeric">numeric</a></code>s and for usage of <code><a href="base.html#topic+diag+3C-">diag&lt;-</a></code>, which is also supported
by <code><a href="#topic+rvar">rvar</a></code>.
</p>


<h3>Value</h3>

<p>For <code><a href="#topic+rvar">rvar</a></code>s, has two modes:
</p>

<ol>
<li> <p><code>x</code> is a matrix-like <code><a href="#topic+rvar">rvar</a></code>: it returns the diagonal as a vector-like <code><a href="#topic+rvar">rvar</a></code>
</p>
</li>
<li> <p><code>x</code> is a vector-like <code><a href="#topic+rvar">rvar</a></code>: it returns a matrix-like <code><a href="#topic+rvar">rvar</a></code> with <code>x</code> as
the diagonal and zero for off-diagonal entries.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="base.html#topic+diag">base::diag()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sigma is a 3x3 covariance matrix
Sigma &lt;- as_draws_rvars(example_draws("multi_normal"))$Sigma
Sigma

diag(Sigma)

diag(Sigma) &lt;- 1:3
Sigma

diag(as_rvar(1:3))

</code></pre>

<hr>
<h2 id='diagnostics'>List of available convergence diagnostics</h2><span id='topic+diagnostics'></span><span id='topic+convergence'></span>

<h3>Description</h3>

<p>A list of available diagnostics and links to their individual help pages.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>Function</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+ess_basic">ess_basic()</a></code> </td><td style="text-align: left;"> Basic version of effective sample size </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+ess_bulk">ess_bulk()</a></code> </td><td style="text-align: left;"> Bulk effective sample size </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+ess_tail">ess_tail()</a></code> </td><td style="text-align: left;"> Tail effective sample size </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+ess_quantile">ess_quantile()</a></code> </td><td style="text-align: left;"> Effective sample sizes for quantiles </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+ess_sd">ess_sd()</a></code> </td><td style="text-align: left;"> Effective sample sizes for standard deviations </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+mcse_mean">mcse_mean()</a></code> </td><td style="text-align: left;"> Monte Carlo standard error for the mean </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+mcse_quantile">mcse_quantile()</a></code> </td><td style="text-align: left;"> Monte Carlo standard error for quantiles </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+mcse_sd">mcse_sd()</a></code> </td><td style="text-align: left;"> Monte Carlo standard error for standard deviations </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+rhat_basic">rhat_basic()</a></code> </td><td style="text-align: left;"> Basic version of Rhat </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+rhat">rhat()</a></code> </td><td style="text-align: left;"> Improved, rank-based version of Rhat </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+rhat_nested">rhat_nested()</a></code> </td><td style="text-align: left;"> Rhat for use with many short chains </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+rstar">rstar()</a></code> </td><td style="text-align: left;"> R* diagnostic </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>See individual functions for a description of return types.
</p>

<hr>
<h2 id='dissent'>Dissention</h2><span id='topic+dissent'></span><span id='topic+dissent.default'></span><span id='topic+dissent.rvar'></span>

<h3>Description</h3>

<p>Dissention, for measuring dispersion in draws from ordinal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissent(x)

## Default S3 method:
dissent(x)

## S3 method for class 'rvar'
dissent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissent_+3A_x">x</code></td>
<td>
<p>(multiple options) A vector to be interpreted as draws from
an ordinal distribution, such as:
</p>

<ul>
<li><p> A <a href="base.html#topic+factor">factor</a>
</p>
</li>
<li><p> A <a href="base.html#topic+numeric">numeric</a> (should be <a href="base.html#topic+integer">integer</a> or integer-like)
</p>
</li>
<li><p> An <a href="#topic+rvar">rvar</a>, <a href="#topic+rvar_factor">rvar_factor</a>, or <a href="#topic+rvar_ordered">rvar_ordered</a>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates Tastle and Wierman's (2007) <em>dissention</em> measure:
</p>
<p style="text-align: center;"><code class="reqn">-\sum_{i = 1}^{n} p_i \log_2 \left(1 - \frac{|x_i - \mathrm{E}(x)| }{\max(x) - \min(x)} \right)</code>
</p>

<p>This ranges from 0 (all probability in one category) through 0.5 (uniform) to
1 (bimodal: all probability split equally between the first and last category).
</p>


<h3>Value</h3>

<p>If <code>x</code> is a <a href="base.html#topic+factor">factor</a> or <a href="base.html#topic+numeric">numeric</a>, returns a length-1 numeric vector with a value
between 0 and 1 (inclusive) giving the dissention of <code>x</code>.
</p>
<p>If <code>x</code> is an <a href="#topic+rvar">rvar</a>, returns an array of the same shape as <code>x</code>, where each
cell is the dissention of the draws in the corresponding cell of <code>x</code>.
</p>


<h3>References</h3>

<p>William J. Tastle, Mark J. Wierman (2007). Consensus and dissention: A measure
of ordinal dispersion. <em>International Journal of Approximate Reasoning</em>.
45(3), 531&ndash;545.
<a href="https://doi.org/10.1016/j.ijar.2006.06.024">doi:10.1016/j.ijar.2006.06.024</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

levels &lt;- c("lowest", "low", "neutral", "high", "highest")

# a bimodal distribution: high dissention
x &lt;- ordered(
  sample(levels, 4000, replace = TRUE, prob = c(0.45, 0.04, 0.02, 0.04, 0.45)),
  levels = levels
)
dissent(x)

# a unimodal distribution: low dissention
y &lt;- ordered(
  sample(levels, 4000, replace = TRUE, prob = c(0.95, 0.02, 0.015, 0.01, 0.005)),
  levels = levels
)
dissent(y)

# both together, as an rvar
xy &lt;- c(rvar(x), rvar(y))
xy
dissent(xy)
</code></pre>

<hr>
<h2 id='draws'>Transform to <code>draws</code> objects</h2><span id='topic+draws'></span><span id='topic+as_draws'></span><span id='topic+is_draws'></span>

<h3>Description</h3>

<p>Try to transform an <span class="rlang"><b>R</b></span> object to a format supported by the <span class="pkg">posterior</span>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_draws(x, ...)

is_draws(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="draws_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"draws"</code> is the parent class of all supported formats,
which also have their own subclasses of the form <code>"draws_{format}"</code> (e.g.
<code>"draws_array"</code>).
</p>


<h3>Value</h3>

<p>If possible, a <code>draws</code> object in the closest supported format to <code>x</code>.
The formats are linked to in the <strong>See Also</strong> section below.
</p>


<h3>See Also</h3>

<p>Other formats: 
<code><a href="#topic+draws_array">draws_array</a>()</code>,
<code><a href="#topic+draws_df">draws_df</a>()</code>,
<code><a href="#topic+draws_list">draws_list</a>()</code>,
<code><a href="#topic+draws_matrix">draws_matrix</a>()</code>,
<code><a href="#topic+draws_rvars">draws_rvars</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some random draws
x &lt;- matrix(rnorm(30), nrow = 10)
colnames(x) &lt;- c("a", "b", "c")
str(x)

# transform to a draws object
y &lt;- as_draws(x)
str(y)

# remove the draws classes from the object
class(y) &lt;- class(y)[-(1:2)]
str(y)

</code></pre>

<hr>
<h2 id='draws_array'>The <code>draws_array</code> format</h2><span id='topic+draws_array'></span><span id='topic+as_draws_array'></span><span id='topic+as_draws_array.default'></span><span id='topic+as_draws_array.draws_array'></span><span id='topic+as_draws_array.draws_matrix'></span><span id='topic+as_draws_array.draws_df'></span><span id='topic+as_draws_array.draws_list'></span><span id='topic+as_draws_array.draws_rvars'></span><span id='topic+as_draws_array.mcmc'></span><span id='topic+as_draws_array.mcmc.list'></span><span id='topic+is_draws_array'></span>

<h3>Description</h3>

<p>The <code>as_draws_array()</code> methods convert
objects to the <code>draws_array</code> format.
The <code>draws_array()</code> function creates an object of the
<code>draws_array</code> format based on a set of numeric vectors.
See <strong>Details</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_draws_array(x, ...)

## Default S3 method:
as_draws_array(x, ...)

## S3 method for class 'draws_array'
as_draws_array(x, ...)

## S3 method for class 'draws_matrix'
as_draws_array(x, ...)

## S3 method for class 'draws_df'
as_draws_array(x, ...)

## S3 method for class 'draws_list'
as_draws_array(x, ...)

## S3 method for class 'draws_rvars'
as_draws_array(x, ...)

## S3 method for class 'mcmc'
as_draws_array(x, ...)

## S3 method for class 'mcmc.list'
as_draws_array(x, ...)

draws_array(..., .nchains = 1)

is_draws_array(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws_array_+3A_x">x</code></td>
<td>
<p>An object to convert to a <code>draws_array</code> object.</p>
</td></tr>
<tr><td><code id="draws_array_+3A_...">...</code></td>
<td>
<p>For <code>as_draws_array()</code>:
Arguments passed to individual methods (if applicable).
For <code>draws_array()</code>: Named
arguments containing numeric vectors each defining a separate variable.</p>
</td></tr>
<tr><td><code id="draws_array_+3A_.nchains">.nchains</code></td>
<td>
<p>(positive integer) The number of chains. The default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>"draws_array"</code> are 3-D arrays with dimensions
<code>"iteration"</code>, <code>"chain"</code>, and <code>"variable"</code>. See <strong>Examples</strong>.
</p>


<h3>Value</h3>

<p>A <code>draws_array</code> object, which has classes
<code>c("draws_array", "draws", "array")</code>.
</p>


<h3>See Also</h3>

<p>Other formats: 
<code><a href="#topic+draws_df">draws_df</a>()</code>,
<code><a href="#topic+draws_list">draws_list</a>()</code>,
<code><a href="#topic+draws_matrix">draws_matrix</a>()</code>,
<code><a href="#topic+draws_rvars">draws_rvars</a>()</code>,
<code><a href="#topic+draws">draws</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- as_draws_array(example_draws())
class(x1)
print(x1)
str(x1)

x2 &lt;- draws_array(a = rnorm(10), b = rnorm(10), c = 1)
class(x2)
print(x2)
str(x2)
</code></pre>

<hr>
<h2 id='draws_df'>The <code>draws_df</code> format</h2><span id='topic+draws_df'></span><span id='topic+as_draws_df'></span><span id='topic+as_draws_df.default'></span><span id='topic+as_draws_df.data.frame'></span><span id='topic+as_draws_df.draws_df'></span><span id='topic+as_draws_df.draws_matrix'></span><span id='topic+as_draws_df.draws_array'></span><span id='topic+as_draws_df.draws_list'></span><span id='topic+as_draws_df.draws_rvars'></span><span id='topic+as_draws_df.mcmc'></span><span id='topic+as_draws_df.mcmc.list'></span><span id='topic+is_draws_df'></span>

<h3>Description</h3>

<p>The <code>as_draws_df()</code> methods convert
objects to the <code>draws_df</code> format.
The <code>draws_df()</code> function creates an object of the
<code>draws_df</code> format based on a set of numeric vectors.
See <strong>Details</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_draws_df(x, ...)

## Default S3 method:
as_draws_df(x, ...)

## S3 method for class 'data.frame'
as_draws_df(x, ...)

## S3 method for class 'draws_df'
as_draws_df(x, ...)

## S3 method for class 'draws_matrix'
as_draws_df(x, ...)

## S3 method for class 'draws_array'
as_draws_df(x, ...)

## S3 method for class 'draws_list'
as_draws_df(x, ...)

## S3 method for class 'draws_rvars'
as_draws_df(x, ...)

## S3 method for class 'mcmc'
as_draws_df(x, ...)

## S3 method for class 'mcmc.list'
as_draws_df(x, ...)

draws_df(..., .nchains = 1)

is_draws_df(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws_df_+3A_x">x</code></td>
<td>
<p>An object to convert to a <code>draws_df</code> object.</p>
</td></tr>
<tr><td><code id="draws_df_+3A_...">...</code></td>
<td>
<p>For <code>as_draws_df()</code>:
Arguments passed to individual methods (if applicable).
For <code>draws_df()</code>: Named
arguments containing numeric vectors each defining a separate variable.</p>
</td></tr>
<tr><td><code id="draws_df_+3A_.nchains">.nchains</code></td>
<td>
<p>(positive integer) The number of chains. The default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>"draws_df"</code> are <a href="tibble.html#topic+tibble">tibble</a> data
frames. They have one column per variable as well as additional metadata
columns <code>".iteration"</code>, <code>".chain"</code>, and <code>".draw"</code>. The difference between
the <code>".iteration"</code> and <code>".draw"</code> columns is that the former is relative to
the MCMC chain while the latter ignores the chain information and has all
unique values. See <strong>Examples</strong>.
</p>
<p>If a <code>data.frame</code>-like object is supplied to <code>as_draws_df</code> that contains
columns named <code>".iteration"</code> or <code>".chain"</code>, they will be treated as
iteration and chain indices, respectively. See <strong>Examples</strong>.
</p>


<h3>Value</h3>

<p>A <code>draws_df</code> object, which has classes
<code>c("draws_df", "draws", class(tibble::tibble()))</code>.
</p>


<h3>See Also</h3>

<p>Other formats: 
<code><a href="#topic+draws_array">draws_array</a>()</code>,
<code><a href="#topic+draws_list">draws_list</a>()</code>,
<code><a href="#topic+draws_matrix">draws_matrix</a>()</code>,
<code><a href="#topic+draws_rvars">draws_rvars</a>()</code>,
<code><a href="#topic+draws">draws</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- as_draws_df(example_draws())
class(x1)
print(x1)
str(x1)

x2 &lt;- draws_df(a = rnorm(10), b = rnorm(10), c = 1)
class(x2)
print(x2)
str(x2)

# the difference between iteration and draw is clearer when contrasting
# the head and tail of the data frame
print(head(x1), reserved = TRUE, max_variables = 2)
print(tail(x1), reserved = TRUE, max_variables = 2)

# manually supply chain information
xnew &lt;- data.frame(mu = rnorm(10), .chain = rep(1:2, each = 5))
xnew &lt;- as_draws_df(xnew)
print(xnew)

</code></pre>

<hr>
<h2 id='draws_list'>The <code>draws_list</code> format</h2><span id='topic+draws_list'></span><span id='topic+as_draws_list'></span><span id='topic+as_draws_list.default'></span><span id='topic+as_draws_list.draws_list'></span><span id='topic+as_draws_list.draws_matrix'></span><span id='topic+as_draws_list.draws_array'></span><span id='topic+as_draws_list.draws_df'></span><span id='topic+as_draws_list.draws_rvars'></span><span id='topic+as_draws_list.mcmc'></span><span id='topic+as_draws_list.mcmc.list'></span><span id='topic+is_draws_list'></span>

<h3>Description</h3>

<p>The <code>as_draws_list()</code> methods convert
objects to the <code>draws_list</code> format.
The <code>draws_list()</code> function creates an object of the
<code>draws_list</code> format based on a set of numeric vectors.
See <strong>Details</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_draws_list(x, ...)

## Default S3 method:
as_draws_list(x, ...)

## S3 method for class 'draws_list'
as_draws_list(x, ...)

## S3 method for class 'draws_matrix'
as_draws_list(x, ...)

## S3 method for class 'draws_array'
as_draws_list(x, ...)

## S3 method for class 'draws_df'
as_draws_list(x, ...)

## S3 method for class 'draws_rvars'
as_draws_list(x, ...)

## S3 method for class 'mcmc'
as_draws_list(x, ...)

## S3 method for class 'mcmc.list'
as_draws_list(x, ...)

draws_list(..., .nchains = 1)

is_draws_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws_list_+3A_x">x</code></td>
<td>
<p>An object to convert to a <code>draws_list</code> object.</p>
</td></tr>
<tr><td><code id="draws_list_+3A_...">...</code></td>
<td>
<p>For <code>as_draws_list()</code>:
Arguments passed to individual methods (if applicable).
For <code>draws_list()</code>: Named
arguments containing numeric vectors each defining a separate variable.</p>
</td></tr>
<tr><td><code id="draws_list_+3A_.nchains">.nchains</code></td>
<td>
<p>(positive integer) The number of chains. The default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>"draws_list"</code> are lists with one element per MCMC
chain. Each of these elements is itself a named list of numeric vectors
with one vector per variable. The length of each vector is equal to the
number of saved iterations per chain. See <strong>Examples</strong>.
</p>


<h3>Value</h3>

<p>A <code>draws_list</code> object, which has classes
<code>c("draws_list", "draws", "list")</code>.
</p>


<h3>See Also</h3>

<p>Other formats: 
<code><a href="#topic+draws_array">draws_array</a>()</code>,
<code><a href="#topic+draws_df">draws_df</a>()</code>,
<code><a href="#topic+draws_matrix">draws_matrix</a>()</code>,
<code><a href="#topic+draws_rvars">draws_rvars</a>()</code>,
<code><a href="#topic+draws">draws</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- as_draws_list(example_draws())
class(x1)
print(x1)
str(x1)

x2 &lt;- draws_list(a = rnorm(10), b = rnorm(10), c = 1)
class(x2)
print(x2)
str(x2)
</code></pre>

<hr>
<h2 id='draws_matrix'>The <code>draws_matrix</code> format</h2><span id='topic+draws_matrix'></span><span id='topic+as_draws_matrix'></span><span id='topic+as_draws_matrix.default'></span><span id='topic+as_draws_matrix.draws_matrix'></span><span id='topic+as_draws_matrix.draws_array'></span><span id='topic+as_draws_matrix.draws_df'></span><span id='topic+as_draws_matrix.draws_list'></span><span id='topic+as_draws_matrix.draws_rvars'></span><span id='topic+as_draws_matrix.mcmc'></span><span id='topic+as_draws_matrix.mcmc.list'></span><span id='topic+is_draws_matrix'></span>

<h3>Description</h3>

<p>The <code>as_draws_matrix()</code> methods convert
objects to the <code>draws_matrix</code> format.
The <code>draws_matrix()</code> function creates an object of the
<code>draws_matrix</code> format based on a set of numeric vectors.
See <strong>Details</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_draws_matrix(x, ...)

## Default S3 method:
as_draws_matrix(x, ...)

## S3 method for class 'draws_matrix'
as_draws_matrix(x, ...)

## S3 method for class 'draws_array'
as_draws_matrix(x, ...)

## S3 method for class 'draws_df'
as_draws_matrix(x, ...)

## S3 method for class 'draws_list'
as_draws_matrix(x, ...)

## S3 method for class 'draws_rvars'
as_draws_matrix(x, ...)

## S3 method for class 'mcmc'
as_draws_matrix(x, ...)

## S3 method for class 'mcmc.list'
as_draws_matrix(x, ...)

draws_matrix(..., .nchains = 1)

is_draws_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws_matrix_+3A_x">x</code></td>
<td>
<p>An object to convert to a <code>draws_matrix</code> object.</p>
</td></tr>
<tr><td><code id="draws_matrix_+3A_...">...</code></td>
<td>
<p>For <code>as_draws_matrix()</code>:
Arguments passed to individual methods (if applicable).
For <code>draws_matrix()</code>: Named
arguments containing numeric vectors each defining a separate variable.</p>
</td></tr>
<tr><td><code id="draws_matrix_+3A_.nchains">.nchains</code></td>
<td>
<p>(positive integer) The number of chains. The default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>"draws_matrix"</code> are matrices (2-D arrays) with
dimensions <code>"draw"</code> and <code>"variable"</code>. See <strong>Examples</strong>.
</p>


<h3>Value</h3>

<p>A <code>draws_matrix</code> object, which has classes
<code>c("draws_matrix", "draws", "matrix")</code>.
</p>


<h3>See Also</h3>

<p>Other formats: 
<code><a href="#topic+draws_array">draws_array</a>()</code>,
<code><a href="#topic+draws_df">draws_df</a>()</code>,
<code><a href="#topic+draws_list">draws_list</a>()</code>,
<code><a href="#topic+draws_rvars">draws_rvars</a>()</code>,
<code><a href="#topic+draws">draws</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- as_draws_matrix(example_draws())
class(x1)
print(x1)
str(x1)

x2 &lt;- draws_matrix(a = rnorm(10), b = rnorm(10), c = 1)
class(x2)
print(x2)
str(x2)
</code></pre>

<hr>
<h2 id='draws_of'>Get/set array of draws underlying a random variable</h2><span id='topic+draws_of'></span><span id='topic+draws_of+3C-'></span>

<h3>Description</h3>

<p>Gets/sets the array-representation that backs an <code><a href="#topic+rvar">rvar</a></code>. Should be used rarely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draws_of(x, with_chains = FALSE)

draws_of(x, with_chains = FALSE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws_of_+3A_x">x</code></td>
<td>
<p>(rvar) An <code><a href="#topic+rvar">rvar</a></code> object.</p>
</td></tr>
<tr><td><code id="draws_of_+3A_with_chains">with_chains</code></td>
<td>
<p>(logical) Should the array of draws include a dimension for chains?
If <code>FALSE</code> (the default), chains are not included and the array has dimension
<code>c(ndraws(x), dim(x))</code>. If <code>TRUE</code>, chains are included and the array has
dimension <code>c(niterations(x), nchains(x), dim(x))</code>.</p>
</td></tr>
<tr><td><code id="draws_of_+3A_value">value</code></td>
<td>
<p>(array) An array of values to use as the backing array of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While <code><a href="#topic+rvar">rvar</a></code>s implement fast versions of basic math operations (including
<a href="#topic+rvar-matmult">matrix multiplication</a>), sometimes you may need to bypass
the <code><a href="#topic+rvar">rvar</a></code> abstraction to do what you need to do more efficiently.
<code>draws_of()</code> allows you to get / set the underlying array of draws in
order to do that.
</p>
<p><code><a href="#topic+rvar">rvar</a></code>s represent draws internally using arrays of arbitrary dimension, which
is returned by <code>draws_of(x)</code> and can be set using <code>draws_of(x) &lt;- value</code>.
The <strong>first</strong> dimension of these arrays is the index of the draws. If
<code>with_chains = TRUE</code>, then the dimensions of the returned array are modified
so that the first dimension is the index of the iterations and the second
dimension is the index of the chains.
</p>


<h3>Value</h3>

<p>If <code>with_chains = FALSE</code>, an array with dimensions <code>c(ndraws(x), dim(x))</code>.
</p>
<p>If <code>with_chains = TRUE</code>, an array with dimensions
<code>c(niterations(x), nchains(x), dim(x))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rvar(1:10, nchains = 2)
x

# draws_of() without arguments will return the array of draws without
# chain information (first dimension is draw)
draws_of(x)

# draws_of() with with_chains = TRUE will reshape the returned array to
# include chain information in the second dimension
draws_of(x, with_chains = TRUE)

# you can also set draws using draws_of(). When with_chains = FALSE the
# existing chain information will be retained ...
draws_of(x) &lt;- 2:11
x

# when with_chains = TRUE the chain information will be set by the
# second dimension of the assigned array
draws_of(x, with_chains = TRUE) &lt;- array(2:11, dim = c(2,5))
x

</code></pre>

<hr>
<h2 id='draws_rvars'>The <code>draws_rvars</code> format</h2><span id='topic+draws_rvars'></span><span id='topic+as_draws_rvars'></span><span id='topic+as_draws_rvars.default'></span><span id='topic+as_draws_rvars.draws_rvars'></span><span id='topic+as_draws_rvars.list'></span><span id='topic+as_draws_rvars.draws_matrix'></span><span id='topic+as_draws_rvars.draws_array'></span><span id='topic+as_draws_rvars.draws_df'></span><span id='topic+as_draws_rvars.draws_list'></span><span id='topic+as_draws_rvars.mcmc'></span><span id='topic+as_draws_rvars.mcmc.list'></span><span id='topic+is_draws_rvars'></span>

<h3>Description</h3>

<p>The <code>as_draws_rvars()</code> methods convert
objects to the <code>draws_rvars</code> format.
The <code>draws_rvars()</code> function creates an object of the
<code>draws_rvars</code> format based on a set of numeric vectors.
See <strong>Details</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_draws_rvars(x, ...)

## Default S3 method:
as_draws_rvars(x, ...)

## S3 method for class 'draws_rvars'
as_draws_rvars(x, ...)

## S3 method for class 'list'
as_draws_rvars(x, ...)

## S3 method for class 'draws_matrix'
as_draws_rvars(x, ...)

## S3 method for class 'draws_array'
as_draws_rvars(x, ...)

## S3 method for class 'draws_df'
as_draws_rvars(x, ...)

## S3 method for class 'draws_list'
as_draws_rvars(x, ...)

## S3 method for class 'mcmc'
as_draws_rvars(x, ...)

## S3 method for class 'mcmc.list'
as_draws_rvars(x, ...)

draws_rvars(..., .nchains = 1)

is_draws_rvars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws_rvars_+3A_x">x</code></td>
<td>
<p>An object to convert to a <code>draws_rvars</code> object.</p>
</td></tr>
<tr><td><code id="draws_rvars_+3A_...">...</code></td>
<td>
<p>For <code>as_draws_rvars()</code>:
Arguments passed to individual methods (if applicable).
For <code>draws_rvars()</code>: Named
arguments containing numeric vectors each defining a separate variable.</p>
</td></tr>
<tr><td><code id="draws_rvars_+3A_.nchains">.nchains</code></td>
<td>
<p>(positive integer) The number of chains. The default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>"draws_rvars"</code> are lists of <code><a href="#topic+rvar">rvar</a></code> objects.
See <strong>Examples</strong>.
</p>


<h3>Value</h3>

<p>A <code>draws_rvars</code> object, which has classes
<code>c("draws_rvars", "draws", "list")</code>.
</p>


<h3>See Also</h3>

<p>Other formats: 
<code><a href="#topic+draws_array">draws_array</a>()</code>,
<code><a href="#topic+draws_df">draws_df</a>()</code>,
<code><a href="#topic+draws_list">draws_list</a>()</code>,
<code><a href="#topic+draws_matrix">draws_matrix</a>()</code>,
<code><a href="#topic+draws">draws</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- as_draws_rvars(example_draws())
class(x1)
print(x1)
str(x1)

x2 &lt;- draws_rvars(a = rnorm(10), b = rnorm(10), c = 1)
class(x2)
print(x2)
str(x2)
</code></pre>

<hr>
<h2 id='draws_summary'>Summaries of <code>draws</code> objects</h2><span id='topic+draws_summary'></span><span id='topic+summarise_draws'></span><span id='topic+summarize_draws'></span><span id='topic+summarise_draws.draws'></span><span id='topic+summary.draws'></span><span id='topic+summarise_draws.rvar'></span><span id='topic+summary.rvar'></span><span id='topic+default_summary_measures'></span><span id='topic+default_convergence_measures'></span><span id='topic+default_mcse_measures'></span>

<h3>Description</h3>

<p>The <code>summarise_draws()</code> (and <code>summarize_draws()</code>) methods provide a quick way
to get a table of summary statistics and diagnostics. These methods will
convert an object to a <code>draws</code> object if it isn't already. For convenience, a
<a href="base.html#topic+summary">summary()</a> method for <code>draws</code> and <code>rvar</code> objects are also
provided as an alias for <code>summarise_draws()</code> if the input object is a <code>draws</code>
or <code>rvar</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_draws(.x, ...)

summarize_draws(.x, ...)

## S3 method for class 'draws'
summarise_draws(
  .x,
  ...,
  .args = list(),
  .num_args = getOption("posterior.num_args", list()),
  .cores = 1
)

## S3 method for class 'draws'
summary(object, ...)

## S3 method for class 'rvar'
summarise_draws(.x, ...)

## S3 method for class 'rvar'
summary(object, ...)

default_summary_measures()

default_convergence_measures()

default_mcse_measures()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws_summary_+3A_.x">.x</code>, <code id="draws_summary_+3A_object">object</code></td>
<td>
<p>(draws) A <code>draws</code> object or one coercible to a <code>draws</code> object.</p>
</td></tr>
<tr><td><code id="draws_summary_+3A_...">...</code></td>
<td>
<p>Name-value pairs of summary or <a href="#topic+diagnostics">diagnostic</a>
functions. The provided names will be used as the names of the columns in
the result <em>unless</em> the function returns a named vector, in which case the
latter names are used. The functions can be specified in any format
supported by <a href="rlang.html#topic+as_function">as_function()</a>. See <strong>Examples</strong>.</p>
</td></tr>
<tr><td><code id="draws_summary_+3A_.args">.args</code></td>
<td>
<p>(named list) Optional arguments passed to the summary functions.</p>
</td></tr>
<tr><td><code id="draws_summary_+3A_.num_args">.num_args</code></td>
<td>
<p>(named list) Optional arguments passed to
<a href="tibble.html#topic+num">num()</a> for pretty printing of summaries. Can be controlled
globally via the <code>posterior.num_args</code> <a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="draws_summary_+3A_.cores">.cores</code></td>
<td>
<p>(positive integer) The number of cores to use for computing
summaries for different variables in parallel. Coerced to integer if
possible, otherwise errors. The default is <code>.cores = 1</code>, in which case no
parallelization is implemented. By default, a socket cluster is used on
Windows and forks otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default summary functions used are the ones specified by
<code>default_summary_measures()</code> and <code>default_convergence_measures()</code>:
</p>
<p><code>default_summary_measures()</code>
</p>

<ul>
<li> <p><code><a href="base.html#topic+mean">mean()</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+median">median()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+sd">sd()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mad">mad()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+quantile2">quantile2()</a></code>
</p>
</li></ul>

<p><code>default_convergence_measures()</code>
</p>

<ul>
<li> <p><code><a href="#topic+rhat">rhat()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+ess_bulk">ess_bulk()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+ess_tail">ess_tail()</a></code>
</p>
</li></ul>

<p>The <code>var()</code> function should not be used to compute variances due
to its inconsistent behavior with matrices. Instead, please use
<code>distributional::variance()</code>.
</p>


<h3>Value</h3>

<p>The <code>summarise_draws()</code> methods return a <a href="tibble.html#topic+tibble">tibble</a> data frame.
The first column (<code>"variable"</code>) contains the variable names and the remaining
columns contain summary statistics and diagnostics.
</p>
<p>The functions <code>default_summary_measures()</code>, <code>default_convergence_measures()</code>,
and <code>default_mcse_measures()</code> return character vectors of names of the
default measures.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> for a list of available diagnostics and links to
their individual help pages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_draws("eight_schools")
class(x)
str(x)

summarise_draws(x)
summarise_draws(x, "mean", "median")
summarise_draws(x, mean, mcse = mcse_mean)
summarise_draws(x, ~quantile(.x, probs = c(0.4, 0.6)))

# using default_*_meaures()
summarise_draws(x, default_summary_measures())
summarise_draws(x, default_convergence_measures())
summarise_draws(x, default_mcse_measures())

# compute variance of variables
summarise_draws(x, var = distributional::variance)

# illustrate use of '.args'
ws &lt;- rexp(ndraws(x))
summarise_draws(x, weighted.mean, .args = list(w = ws))

# adjust how numerical summaries are printed
summarise_draws(x, .num_args = list(sigfig = 2, notation = "dec"))

</code></pre>

<hr>
<h2 id='draws-index'>Index <code>draws</code> objects</h2><span id='topic+draws-index'></span><span id='topic+variables'></span><span id='topic+variables+3C-'></span><span id='topic+iteration_ids'></span><span id='topic+chain_ids'></span><span id='topic+draw_ids'></span><span id='topic+nvariables'></span><span id='topic+niterations'></span><span id='topic+nchains'></span><span id='topic+ndraws'></span>

<h3>Description</h3>

<p>Index variables, iterations, chains, and draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variables(x, ...)

variables(x) &lt;- value

iteration_ids(x)

chain_ids(x)

draw_ids(x)

nvariables(x, ...)

niterations(x)

nchains(x)

ndraws(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws-index_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="draws-index_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="draws-index_+3A_value">value</code></td>
<td>
<p>(character vector) For <code>variables(x) &lt;- value</code>, the new variable
names to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods <code>variables()</code>, <code>iteration_ids()</code>, <code>chain_ids()</code>, and <code>draw_ids()</code> return
vectors of all variables, iterations, chains, and draws, respectively. In
contrast, the methods <code>nvariables()</code>, <code>niterations()</code>, <code>nchains()</code>, and
<code>ndraws()</code> return the number of variables, iterations, chains, and draws,
respectively.
</p>
<p><code>variables(x) &lt;- value</code> allows you to modify the vector of variable names,
similar to how <code>names(x) &lt;- value</code> works for vectors and lists. For renaming
specific variables, <code><a href="#topic+set_variables">set_variables()</a></code> works equivalently, but is more intuitive when using the pipe operator. <code><a href="#topic+rename_variables">rename_variables()</a></code> may offer a more convenient approach.
</p>


<h3>Value</h3>

<p>For <code>variables()</code>, a character vector.
</p>
<p>For <code>iteration_ids()</code>, <code>chain_ids()</code>, and <code>draw_ids()</code>, an integer vector.
</p>
<p>For <code>niterations()</code>, <code>nchains()</code>, and <code>ndraws()</code>, a scalar integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_draws()

variables(x)
nvariables(x)
variables(x) &lt;- letters[1:nvariables(x)]

iteration_ids(x)
niterations(x)

chain_ids(x)
nchains(x)

draw_ids(x)
ndraws(x)

</code></pre>

<hr>
<h2 id='drop+2Crvar-method'>Drop redundant dimensions</h2><span id='topic+drop+2Crvar-method'></span>

<h3>Description</h3>

<p>Delete the dimensions of an <code><a href="#topic+rvar">rvar</a></code> which are of size one. See <code><a href="base.html#topic+drop">base::drop()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'rvar'
drop(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop+2B2Crvar-method_+3A_x">x</code></td>
<td>
<p>(rvar) an <code><a href="#topic+rvar">rvar</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+rvar">rvar</a></code> with the same length as <code>x</code>, but where any entry equal to <code>1</code>
in <code>dim(x)</code> has been removed. The exception is if <code>dim(x) == 1</code>, in which
case <code>dim(drop(x)) == 1</code> as well (this is because <code><a href="#topic+rvar">rvar</a></code>s, unlike <code><a href="base.html#topic+numeric">numeric</a></code>s,
never have <code>NULL</code> dimensions).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sigma is a 3x3 covariance matrix
Sigma &lt;- as_draws_rvars(example_draws("multi_normal"))$Sigma
Sigma

Sigma[1, ]

drop(Sigma[1, ])

# equivalently ...
Sigma[1, drop = TRUE]

</code></pre>

<hr>
<h2 id='entropy'>Normalized entropy</h2><span id='topic+entropy'></span><span id='topic+entropy.default'></span><span id='topic+entropy.rvar'></span>

<h3>Description</h3>

<p>Normalized entropy, for measuring dispersion in draws from categorical distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(x)

## Default S3 method:
entropy(x)

## S3 method for class 'rvar'
entropy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_+3A_x">x</code></td>
<td>
<p>(multiple options) A vector to be interpreted as draws from
a categorical distribution, such as:
</p>

<ul>
<li><p> A <a href="base.html#topic+factor">factor</a>
</p>
</li>
<li><p> A <a href="base.html#topic+numeric">numeric</a> (should be <a href="base.html#topic+integer">integer</a> or integer-like)
</p>
</li>
<li><p> An <a href="#topic+rvar">rvar</a>, <a href="#topic+rvar_factor">rvar_factor</a>, or <a href="#topic+rvar_ordered">rvar_ordered</a>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the normalized Shannon entropy of the draws in <code>x</code>. This value is
the entropy of <code>x</code> divided by the maximum entropy of a distribution with <code>n</code>
categories, where <code>n</code> is <code>length(unique(x))</code> for numeric vectors and
<code>length(levels(x))</code> for factors:
</p>
<p style="text-align: center;"><code class="reqn">-\frac{\sum_{i = 1}^{n} p_i \log(p_i)}{\log(n)}</code>
</p>

<p>This scales the output to be between 0 (all probability in one category)
and 1 (uniform). This form of normalized entropy is referred to as
<code class="reqn">H_\mathrm{REL}</code> in Wilcox (1967).
</p>


<h3>Value</h3>

<p>If <code>x</code> is a <a href="base.html#topic+factor">factor</a> or <a href="base.html#topic+numeric">numeric</a>, returns a length-1 numeric vector with a value
between 0 and 1 (inclusive) giving the normalized Shannon entropy of <code>x</code>.
</p>
<p>If <code>x</code> is an <a href="#topic+rvar">rvar</a>, returns an array of the same shape as <code>x</code>, where each
cell is the normalized Shannon entropy of the draws in the corresponding cell of <code>x</code>.
</p>


<h3>References</h3>

<p>Allen R. Wilcox (1967). <em>Indices of Qualitative Variation</em>
(No. ORNL-TM-1919). Oak Ridge National Lab., Tenn.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

levels &lt;- c("a", "b", "c", "d", "e")

# a uniform distribution: high normalized entropy
x &lt;- factor(
  sample(levels, 4000, replace = TRUE, prob = c(0.2, 0.2, 0.2, 0.2, 0.2)),
  levels = levels
)
entropy(x)

# a unimodal distribution: low normalized entropy
y &lt;- factor(
  sample(levels, 4000, replace = TRUE, prob = c(0.95, 0.02, 0.015, 0.01, 0.005)),
  levels = levels
)
entropy(y)

# both together, as an rvar
xy &lt;- c(rvar(x), rvar(y))
xy
entropy(xy)
</code></pre>

<hr>
<h2 id='ess_basic'>Basic version of the effective sample size</h2><span id='topic+ess_basic'></span><span id='topic+ess_basic.default'></span><span id='topic+ess_basic.rvar'></span>

<h3>Description</h3>

<p>Compute the basic effective sample size (ESS) estimate for a single variable
as described in Gelman et al. (2013) with some changes according to Vehtari et
al. (2021). For practical applications, we strongly
recommend the improved ESS convergence diagnostics implemented in
<code><a href="#topic+ess_bulk">ess_bulk()</a></code> and <code><a href="#topic+ess_tail">ess_tail()</a></code>. See Vehtari (2021) for an in-depth
comparison of different effective sample size estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ess_basic(x, ...)

## Default S3 method:
ess_basic(x, split = TRUE, ...)

## S3 method for class 'rvar'
ess_basic(x, split = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_basic_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ess_basic_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="ess_basic_+3A_split">split</code></td>
<td>
<p>(logical) Should the estimate be computed on split chains? The
default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an array, returns a single numeric value. If any of the draws
is non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output
will be (numeric) <code>NA</code>. Also, if all draws within any of the chains of a
variable are the same (constant), the returned output will be (numeric) <code>NA</code>
as well. The reason for the latter is that, for constant draws, we cannot
distinguish between variables that are supposed to be constant (e.g., a
diagonal element of a correlation matrix is always 1) or variables that just
happened to be constant because of a failure of convergence or other problems
in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code>, returns an array of the same dimensions as the
<code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value that would be returned by
passing the draws array for that element of the <code><a href="#topic+rvar">rvar</a></code> to this function.
</p>


<h3>References</h3>

<p>Andrew Gelman, John B. Carlin, Hal S. Stern, David B. Dunson, Aki Vehtari and
Donald B. Rubin (2013). <em>Bayesian Data Analysis, Third Edition</em>. Chapman and
Hall/CRC.
</p>
<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian Bürkner (2021). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of
MCMC (with discussion). <em>Bayesian Data Analysis</em>. 16(2), 667-–718.
doi:10.1214/20-BA1221
</p>
<p>Aki Vehtari (2021). Comparison of MCMC effective sample size estimators.
Retrieved from https://avehtari.github.io/rhat_ess/ess_comparison.html
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_bulk">ess_bulk</a>()</code>,
<code><a href="#topic+ess_quantile">ess_quantile</a>()</code>,
<code><a href="#topic+ess_sd">ess_sd</a>()</code>,
<code><a href="#topic+ess_tail">ess_tail</a>()</code>,
<code><a href="#topic+mcse_mean">mcse_mean</a>()</code>,
<code><a href="#topic+mcse_quantile">mcse_quantile</a>()</code>,
<code><a href="#topic+mcse_sd">mcse_sd</a>()</code>,
<code><a href="#topic+rhat_basic">rhat_basic</a>()</code>,
<code><a href="#topic+rhat_nested">rhat_nested</a>()</code>,
<code><a href="#topic+rhat">rhat</a>()</code>,
<code><a href="#topic+rstar">rstar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
ess_basic(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
ess_basic(d$Sigma)

</code></pre>

<hr>
<h2 id='ess_bulk'>Bulk effective sample size (bulk-ESS)</h2><span id='topic+ess_bulk'></span><span id='topic+ess_bulk.default'></span><span id='topic+ess_bulk.rvar'></span>

<h3>Description</h3>

<p>Compute a bulk effective sample size estimate (bulk-ESS) for a single
variable. Bulk-ESS is useful as a diagnostic for the sampling efficiency in
the bulk of the posterior. It is defined as the effective sample size for
rank normalized values using split chains. For the tail effective sample size
see <code><a href="#topic+ess_tail">ess_tail()</a></code>. See Vehtari (2021) for an in-depth
comparison of different effective sample size estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ess_bulk(x, ...)

## Default S3 method:
ess_bulk(x, ...)

## S3 method for class 'rvar'
ess_bulk(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_bulk_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ess_bulk_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an array, returns a single numeric value. If any of the draws
is non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output
will be (numeric) <code>NA</code>. Also, if all draws within any of the chains of a
variable are the same (constant), the returned output will be (numeric) <code>NA</code>
as well. The reason for the latter is that, for constant draws, we cannot
distinguish between variables that are supposed to be constant (e.g., a
diagonal element of a correlation matrix is always 1) or variables that just
happened to be constant because of a failure of convergence or other problems
in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code>, returns an array of the same dimensions as the
<code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value that would be returned by
passing the draws array for that element of the <code><a href="#topic+rvar">rvar</a></code> to this function.
</p>


<h3>References</h3>

<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian Bürkner (2021). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of
MCMC (with discussion). <em>Bayesian Data Analysis</em>. 16(2), 667-–718.
doi:10.1214/20-BA1221
</p>
<p>Aki Vehtari (2021). Comparison of MCMC effective sample size estimators.
Retrieved from https://avehtari.github.io/rhat_ess/ess_comparison.html
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_basic">ess_basic</a>()</code>,
<code><a href="#topic+ess_quantile">ess_quantile</a>()</code>,
<code><a href="#topic+ess_sd">ess_sd</a>()</code>,
<code><a href="#topic+ess_tail">ess_tail</a>()</code>,
<code><a href="#topic+mcse_mean">mcse_mean</a>()</code>,
<code><a href="#topic+mcse_quantile">mcse_quantile</a>()</code>,
<code><a href="#topic+mcse_sd">mcse_sd</a>()</code>,
<code><a href="#topic+rhat_basic">rhat_basic</a>()</code>,
<code><a href="#topic+rhat_nested">rhat_nested</a>()</code>,
<code><a href="#topic+rhat">rhat</a>()</code>,
<code><a href="#topic+rstar">rstar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
ess_bulk(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
ess_bulk(d$Sigma)

</code></pre>

<hr>
<h2 id='ess_mean'>Effective sample size for the mean</h2><span id='topic+ess_mean'></span><span id='topic+ess_mean.rvar'></span>

<h3>Description</h3>

<p>Compute an effective sample size estimate for a mean (expectation)
estimate of a single variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ess_mean(x, ...)

## S3 method for class 'rvar'
ess_mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_mean_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ess_mean_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an array, returns a single numeric value. If any of the draws
is non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output
will be (numeric) <code>NA</code>. Also, if all draws within any of the chains of a
variable are the same (constant), the returned output will be (numeric) <code>NA</code>
as well. The reason for the latter is that, for constant draws, we cannot
distinguish between variables that are supposed to be constant (e.g., a
diagonal element of a correlation matrix is always 1) or variables that just
happened to be constant because of a failure of convergence or other problems
in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code>, returns an array of the same dimensions as the
<code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value that would be returned by
passing the draws array for that element of the <code><a href="#topic+rvar">rvar</a></code> to this function.
</p>


<h3>References</h3>

<p>Andrew Gelman, John B. Carlin, Hal S. Stern, David B. Dunson, Aki Vehtari and
Donald B. Rubin (2013). <em>Bayesian Data Analysis, Third Edition</em>. Chapman and
Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
ess_mean(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
ess_mean(d$Sigma)

</code></pre>

<hr>
<h2 id='ess_quantile'>Effective sample sizes for quantiles</h2><span id='topic+ess_quantile'></span><span id='topic+ess_quantile.default'></span><span id='topic+ess_quantile.rvar'></span><span id='topic+ess_median'></span><span id='topic+ess_mean.default'></span>

<h3>Description</h3>

<p>Compute effective sample size estimates for quantile estimates of a single
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ess_quantile(x, probs = c(0.05, 0.95), ...)

## Default S3 method:
ess_quantile(x, probs = c(0.05, 0.95), names = TRUE, ...)

## S3 method for class 'rvar'
ess_quantile(x, probs = c(0.05, 0.95), names = TRUE, ...)

ess_median(x, ...)

## Default S3 method:
ess_mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_quantile_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ess_quantile_+3A_probs">probs</code></td>
<td>
<p>(numeric vector) Probabilities in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="ess_quantile_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="ess_quantile_+3A_names">names</code></td>
<td>
<p>(logical) Should the result have a <code>names</code> attribute? The
default is <code>TRUE</code>, but use <code>FALSE</code> for improved speed if there are many
values in <code>probs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an array,
returns a numeric vector with one element per quantile. If any of the draws is
non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output will
be a vector of (numeric) <code>NA</code> values. Also, if all draws of a variable are
the same (constant), the returned output will be a vector of (numeric) <code>NA</code>
values as well. The reason for the latter is that, for constant draws, we
cannot distinguish between variables that are supposed to be constant (e.g.,
a diagonal element of a correlation matrix is always 1) or variables that
just happened to be constant because of a failure of convergence or other
problems in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code> and <code>length(probs) == 1</code>, returns an array of the
same dimensions as the <code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value
that would be returned by passing the draws array for that element of the
<code><a href="#topic+rvar">rvar</a></code> to this function. If <code>length(probs) &gt; 1</code>, the first dimension of the
result indexes the input probabilities; i.e. the result has dimension
<code>c(length(probs), dim(x))</code>.
</p>


<h3>References</h3>

<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian Bürkner (2021). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of
MCMC (with discussion). <em>Bayesian Data Analysis</em>. 16(2), 667-–718.
doi:10.1214/20-BA1221
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_basic">ess_basic</a>()</code>,
<code><a href="#topic+ess_bulk">ess_bulk</a>()</code>,
<code><a href="#topic+ess_sd">ess_sd</a>()</code>,
<code><a href="#topic+ess_tail">ess_tail</a>()</code>,
<code><a href="#topic+mcse_mean">mcse_mean</a>()</code>,
<code><a href="#topic+mcse_quantile">mcse_quantile</a>()</code>,
<code><a href="#topic+mcse_sd">mcse_sd</a>()</code>,
<code><a href="#topic+rhat_basic">rhat_basic</a>()</code>,
<code><a href="#topic+rhat_nested">rhat_nested</a>()</code>,
<code><a href="#topic+rhat">rhat</a>()</code>,
<code><a href="#topic+rstar">rstar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
ess_quantile(mu, probs = c(0.1, 0.9))

d &lt;- as_draws_rvars(example_draws("multi_normal"))
ess_quantile(d$mu, probs = c(0.1, 0.9))

</code></pre>

<hr>
<h2 id='ess_sd'>Effective sample size for the standard deviation</h2><span id='topic+ess_sd'></span><span id='topic+ess_sd.default'></span><span id='topic+ess_sd.rvar'></span>

<h3>Description</h3>

<p>Compute an effective sample size estimate for the standard deviation (SD)
estimate of a single variable. This is defined as the effective sample size
estimate for the absolute deviation from mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ess_sd(x, ...)

## Default S3 method:
ess_sd(x, ...)

## S3 method for class 'rvar'
ess_sd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_sd_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ess_sd_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an array, returns a single numeric value. If any of the draws
is non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output
will be (numeric) <code>NA</code>. Also, if all draws within any of the chains of a
variable are the same (constant), the returned output will be (numeric) <code>NA</code>
as well. The reason for the latter is that, for constant draws, we cannot
distinguish between variables that are supposed to be constant (e.g., a
diagonal element of a correlation matrix is always 1) or variables that just
happened to be constant because of a failure of convergence or other problems
in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code>, returns an array of the same dimensions as the
<code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value that would be returned by
passing the draws array for that element of the <code><a href="#topic+rvar">rvar</a></code> to this function.
</p>


<h3>References</h3>

<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian Bürkner (2021). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of
MCMC (with discussion). <em>Bayesian Data Analysis</em>. 16(2), 667-–718.
doi:10.1214/20-BA1221
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_basic">ess_basic</a>()</code>,
<code><a href="#topic+ess_bulk">ess_bulk</a>()</code>,
<code><a href="#topic+ess_quantile">ess_quantile</a>()</code>,
<code><a href="#topic+ess_tail">ess_tail</a>()</code>,
<code><a href="#topic+mcse_mean">mcse_mean</a>()</code>,
<code><a href="#topic+mcse_quantile">mcse_quantile</a>()</code>,
<code><a href="#topic+mcse_sd">mcse_sd</a>()</code>,
<code><a href="#topic+rhat_basic">rhat_basic</a>()</code>,
<code><a href="#topic+rhat_nested">rhat_nested</a>()</code>,
<code><a href="#topic+rhat">rhat</a>()</code>,
<code><a href="#topic+rstar">rstar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
ess_sd(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
ess_sd(d$Sigma)

</code></pre>

<hr>
<h2 id='ess_tail'>Tail effective sample size (tail-ESS)</h2><span id='topic+ess_tail'></span><span id='topic+ess_tail.default'></span><span id='topic+ess_tail.rvar'></span>

<h3>Description</h3>

<p>Compute a tail effective sample size estimate (tail-ESS) for a single
variable. Tail-ESS is useful as a diagnostic for the sampling efficiency in
the tails of the posterior. It is defined as the minimum of the effective
sample sizes for 5% and 95% quantiles. For the bulk effective sample
size see <code><a href="#topic+ess_bulk">ess_bulk()</a></code>. See Vehtari (2021) for an in-depth
comparison of different effective sample size estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ess_tail(x, ...)

## Default S3 method:
ess_tail(x, ...)

## S3 method for class 'rvar'
ess_tail(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_tail_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ess_tail_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an array, returns a single numeric value. If any of the draws
is non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output
will be (numeric) <code>NA</code>. Also, if all draws within any of the chains of a
variable are the same (constant), the returned output will be (numeric) <code>NA</code>
as well. The reason for the latter is that, for constant draws, we cannot
distinguish between variables that are supposed to be constant (e.g., a
diagonal element of a correlation matrix is always 1) or variables that just
happened to be constant because of a failure of convergence or other problems
in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code>, returns an array of the same dimensions as the
<code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value that would be returned by
passing the draws array for that element of the <code><a href="#topic+rvar">rvar</a></code> to this function.
</p>


<h3>References</h3>

<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian Bürkner (2021). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of
MCMC (with discussion). <em>Bayesian Data Analysis</em>. 16(2), 667-–718.
doi:10.1214/20-BA1221
</p>
<p>Aki Vehtari (2021). Comparison of MCMC effective sample size estimators.
Retrieved from https://avehtari.github.io/rhat_ess/ess_comparison.html
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_basic">ess_basic</a>()</code>,
<code><a href="#topic+ess_bulk">ess_bulk</a>()</code>,
<code><a href="#topic+ess_quantile">ess_quantile</a>()</code>,
<code><a href="#topic+ess_sd">ess_sd</a>()</code>,
<code><a href="#topic+mcse_mean">mcse_mean</a>()</code>,
<code><a href="#topic+mcse_quantile">mcse_quantile</a>()</code>,
<code><a href="#topic+mcse_sd">mcse_sd</a>()</code>,
<code><a href="#topic+rhat_basic">rhat_basic</a>()</code>,
<code><a href="#topic+rhat_nested">rhat_nested</a>()</code>,
<code><a href="#topic+rhat">rhat</a>()</code>,
<code><a href="#topic+rstar">rstar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
ess_tail(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
ess_tail(d$Sigma)

</code></pre>

<hr>
<h2 id='example_draws'>Example <code>draws</code> objects</h2><span id='topic+example_draws'></span>

<h3>Description</h3>

<p>Objects for use in examples, vignettes, and tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_draws(example = "eight_schools")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="example_draws_+3A_example">example</code></td>
<td>
<p>(string) The name of the example <code>draws</code> object. See
<strong>Details</strong> for available options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following example <code>draws</code> objects are available.
</p>
<p><strong>eight_schools</strong>: A <code><a href="#topic+draws_array">draws_array</a></code> object with 100 iterations
from each of 4 Markov chains obtained by fitting the eight schools model
described in Gelman et al. (2013) with <a href="https://mc-stan.org">Stan</a>. The
variables are:
</p>

<ul>
<li> <p><code>mu</code>: Overall mean of the eight schools
</p>
</li>
<li> <p><code>tau</code>: Standard deviation between schools
</p>
</li>
<li> <p><code>theta</code>: Individual means of each of the eight schools
</p>
</li></ul>

<p><strong>multi_normal</strong>: A <code><a href="#topic+draws_array">draws_array</a></code> object with 100 iterations from each of
the 4 Markov chains obtained by fitting a 3-dimensional multivariate normal
model to 100 simulated observations. The variables are:
</p>

<ul>
<li> <p><code>mu</code>: Mean parameter vector of length 3
</p>
</li>
<li> <p><code>Sigma</code>: Covariance matrix of dimension 3 x 3
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>draws</code> object.
</p>


<h3>Note</h3>

<p>These objects are only intended to be used in demonstrations and tests.
They contain fewer iterations and chains than recommended for performing
actual inference.
</p>


<h3>References</h3>

<p>Andrew Gelman, John B. Carlin, Hal S. Stern, David B. Dunson, Aki Vehtari and
Donald B. Rubin (2013). Bayesian Data Analysis, Third Edition. Chapman and
Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>draws_eight_schools &lt;- example_draws("eight_schools")
summarise_draws(draws_eight_schools)

draws_multi_normal &lt;- example_draws("multi_normal")
summarise_draws(draws_multi_normal)

</code></pre>

<hr>
<h2 id='extract_variable'>Extract draws of a single variable</h2><span id='topic+extract_variable'></span><span id='topic+extract_variable.default'></span><span id='topic+extract_variable.draws'></span><span id='topic+extract_variable.draws_rvars'></span>

<h3>Description</h3>

<p>Extract a vector of draws of a single variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_variable(x, variable, ...)

## Default S3 method:
extract_variable(x, variable, ...)

## S3 method for class 'draws'
extract_variable(x, variable, ...)

## S3 method for class 'draws_rvars'
extract_variable(x, variable, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_variable_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="extract_variable_+3A_variable">variable</code></td>
<td>
<p>(string) The name of the variable to extract.</p>
</td></tr>
<tr><td><code id="extract_variable_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length equal to the number of draws.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_draws()
mu &lt;- extract_variable(x, variable = "mu")
str(mu)

</code></pre>

<hr>
<h2 id='extract_variable_matrix'>Extract matrix of a single variable</h2><span id='topic+extract_variable_matrix'></span><span id='topic+extract_variable_matrix.default'></span><span id='topic+extract_variable_matrix.draws'></span><span id='topic+extract_variable_matrix.draws_rvars'></span>

<h3>Description</h3>

<p>Extract an iterations x chains matrix of draws of a single variable.
This is primarily used for convergence diagnostic functions such as <code><a href="#topic+rhat">rhat()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_variable_matrix(x, variable, ...)

## Default S3 method:
extract_variable_matrix(x, variable, ...)

## S3 method for class 'draws'
extract_variable_matrix(x, variable, ...)

## S3 method for class 'draws_rvars'
extract_variable_matrix(x, variable, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_variable_matrix_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="extract_variable_matrix_+3A_variable">variable</code></td>
<td>
<p>(string) The name of the variable to extract.</p>
</td></tr>
<tr><td><code id="extract_variable_matrix_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with dimension iterations x chains.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_draws()
mu &lt;- extract_variable_matrix(x, variable = "mu")
dim(mu)
rhat(mu)

</code></pre>

<hr>
<h2 id='for_each_draw'>Loop over draws</h2><span id='topic+for_each_draw'></span>

<h3>Description</h3>

<p>Executes an expression once for every draw in a <code>draws</code> object. Used
primarily for its side effects and returns the input <code>x</code> invisibly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>for_each_draw(x, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="for_each_draw_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="for_each_draw_+3A_expr">expr</code></td>
<td>
<p>(expression) A bare expression that can contain references to
variables in <code>x</code> by name. This expression will be executed once per draw
of <code>x</code>, where references to variables in <code>x</code> resolve to the value of that
variable in that draw. The expression supports <a href="rlang.html#topic+quasiquotation">quasiquotation</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is not in the <code><a href="#topic+draws_rvars">draws_rvars</a></code> format, it is first converted to that
format. This allows the variables in <code>x</code> to include their dimensions (i.e,
to act as R vectors and arrays) when being referred to in <code>expr</code>.
</p>
<p>Within <code>expr</code>, use <code>.draw</code> to refer to the draw index, which will be a value
between 1 and <code>ndraws(x)</code>. <code>expr</code> is executed in the calling environment of
<code>for_each_draw()</code>, so it can use variables in that environment (however, due
to the use of data masking, to modify variables in that environment, one
must use <code style="white-space: pre;">&#8288;&lt;&lt;-&#8288;</code>.)
</p>


<h3>Value</h3>

<p>As <code>for_each_draw()</code> is used primarily for its side effects (the expression
executed for each draw of <code>x</code>), it returns the input <code>x</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eight_schools &lt;- as_draws_rvars(example_draws())


# 1. A simple example --- looping over draws and printing each draw
# NOTE: You probably don't want to do this in practice! This example is
# just intended to show what for_each_draw() is doing. If you just want to
# print the draws of an rvar, it is probably better to use draws_of()
for_each_draw(eight_schools, {
  print(mu)
})


# 2. A more complex example --- building a parallel coordinates plot
# First, construct the plot bounds
plot(1, type = "n",
  xlim = c(1, length(eight_schools$theta)),
  ylim = range(range(eight_schools$theta)),
  xlab = "school", ylab = "theta"
)

# Then, use for_each_draw() to make a parallel coordinates plot of all draws
# of eight_schools$theta. Use resample_draws(eight_schools, n = ...)
# in place of eight_schools if a smaller sample is desired for the plot.
for_each_draw(eight_schools, {
  lines(seq_along(theta), theta, col = rgb(1, 0, 0, 0.05))
})

# Finally, add means and 90% intervals
lines(seq_along(eight_schools$theta), mean(eight_schools$theta))
with(summarise_draws(eight_schools$theta),
  segments(seq_along(eight_schools$theta), y0 = q5, y1 = q95)
)
</code></pre>

<hr>
<h2 id='is_rvar'>Is <code>x</code> a random variable?</h2><span id='topic+is_rvar'></span>

<h3>Description</h3>

<p>Test if <code>x</code> is an <code><a href="#topic+rvar">rvar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rvar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_rvar_+3A_x">x</code></td>
<td>
<p>(any object) An object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is an <code><a href="#topic+rvar">rvar</a></code>, <code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_rvar">as_rvar()</a></code> to convert objects to <code>rvar</code>s.
</p>

<hr>
<h2 id='is_rvar_factor'>Is <code>x</code> a factor random variable?</h2><span id='topic+is_rvar_factor'></span><span id='topic+is_rvar_ordered'></span>

<h3>Description</h3>

<p>Test if <code>x</code> is an <code><a href="#topic+rvar_factor">rvar_factor</a></code> or <code><a href="#topic+rvar_ordered">rvar_ordered</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rvar_factor(x)

is_rvar_ordered(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_rvar_factor_+3A_x">x</code></td>
<td>
<p>(any object) An object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is an <code><a href="#topic+rvar_factor">rvar_factor</a></code> or <code><a href="#topic+rvar_ordered">rvar_ordered</a></code>, <code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_rvar_factor">as_rvar_factor()</a></code> and <code><a href="#topic+as_rvar_ordered">as_rvar_ordered()</a></code> to convert objects to
<code>rvar_factor</code>s and <code>rvar_ordered</code>s.
</p>

<hr>
<h2 id='match'>Value Matching</h2><span id='topic+match'></span><span id='topic+match.default'></span><span id='topic+match.rvar'></span><span id='topic++25in+25'></span>

<h3>Description</h3>

<p>Generic version of <code><a href="base.html#topic+match">base::match()</a></code>. For base vectors, returns a vector of the
positions of (first) matches of its first argument in its second. For <a href="#topic+rvar">rvar</a>s,
returns an <a href="#topic+rvar">rvar</a> of the matches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match(x, table, ...)

## Default S3 method:
match(x, ...)

## S3 method for class 'rvar'
match(x, ...)

x %in% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_+3A_x">x</code></td>
<td>
<p>(multiple options) the values to be matched. Can be:
</p>

<ul>
<li><p> A base vector: see <code><a href="base.html#topic+match">base::match()</a></code>
</p>
</li>
<li><p> An <a href="#topic+rvar">rvar</a>
</p>
</li></ul>
</td></tr>
<tr><td><code id="match_+3A_table">table</code></td>
<td>
<p>(vector) the values to be matched against.</p>
</td></tr>
<tr><td><code id="match_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+match">base::match</a></code>
</p>

<dl>
<dt><code>nomatch</code></dt><dd><p>the value to be returned in the case when no match is
found.  Note that it is coerced to <code>integer</code>.</p>
</dd>
<dt><code>incomparables</code></dt><dd><p>a vector of values that cannot be matched.  Any
value in <code>x</code> matching a value in this vector is assigned the
<code>nomatch</code> value.  For historical reasons, <code>FALSE</code> is
equivalent to <code>NULL</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information on how match behaves with base vectors, see <code><a href="base.html#topic+match">base::match()</a></code>.
</p>
<p>When <code>x</code> is an <a href="#topic+rvar">rvar</a>, the draws of <code>x</code> are matched against <code>table</code> using
<code><a href="base.html#topic+match">base::match()</a></code>, and the result is returned as an <a href="#topic+rvar">rvar</a>.
</p>
<p>The implementation of <code>%in%</code> here is identical to <code>base::%in%</code>, except
it uses the generic version of <code>match()</code> so that non-base vectors (such
as <a href="#topic+rvar">rvar</a>s) are supported.
</p>


<h3>Value</h3>

<p>When <code>x</code> is a base vector, a vector of the same length as <code>x</code>.
</p>
<p>When <code>x</code> is an <a href="#topic+rvar">rvar</a>, an <a href="#topic+rvar">rvar</a> the same shape as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvar(c("a","b","b","c","d"))
x %in% c("b","d")

# for additional examples, see base::match()
</code></pre>

<hr>
<h2 id='mcse_mean'>Monte Carlo standard error for the mean</h2><span id='topic+mcse_mean'></span><span id='topic+mcse_mean.default'></span><span id='topic+mcse_mean.rvar'></span>

<h3>Description</h3>

<p>Compute the Monte Carlo standard error for the mean (expectation) of a
single variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcse_mean(x, ...)

## Default S3 method:
mcse_mean(x, ...)

## S3 method for class 'rvar'
mcse_mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcse_mean_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mcse_mean_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an array, returns a single numeric value. If any of the draws
is non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output
will be (numeric) <code>NA</code>. Also, if all draws within any of the chains of a
variable are the same (constant), the returned output will be (numeric) <code>NA</code>
as well. The reason for the latter is that, for constant draws, we cannot
distinguish between variables that are supposed to be constant (e.g., a
diagonal element of a correlation matrix is always 1) or variables that just
happened to be constant because of a failure of convergence or other problems
in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code>, returns an array of the same dimensions as the
<code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value that would be returned by
passing the draws array for that element of the <code><a href="#topic+rvar">rvar</a></code> to this function.
</p>


<h3>References</h3>

<p>Andrew Gelman, John B. Carlin, Hal S. Stern, David B. Dunson, Aki Vehtari and
Donald B. Rubin (2013). <em>Bayesian Data Analysis, Third Edition</em>. Chapman and
Hall/CRC.
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_basic">ess_basic</a>()</code>,
<code><a href="#topic+ess_bulk">ess_bulk</a>()</code>,
<code><a href="#topic+ess_quantile">ess_quantile</a>()</code>,
<code><a href="#topic+ess_sd">ess_sd</a>()</code>,
<code><a href="#topic+ess_tail">ess_tail</a>()</code>,
<code><a href="#topic+mcse_quantile">mcse_quantile</a>()</code>,
<code><a href="#topic+mcse_sd">mcse_sd</a>()</code>,
<code><a href="#topic+rhat_basic">rhat_basic</a>()</code>,
<code><a href="#topic+rhat_nested">rhat_nested</a>()</code>,
<code><a href="#topic+rhat">rhat</a>()</code>,
<code><a href="#topic+rstar">rstar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
mcse_mean(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
mcse_mean(d$Sigma)

</code></pre>

<hr>
<h2 id='mcse_quantile'>Monte Carlo standard error for quantiles</h2><span id='topic+mcse_quantile'></span><span id='topic+mcse_quantile.default'></span><span id='topic+mcse_quantile.rvar'></span><span id='topic+mcse_median'></span>

<h3>Description</h3>

<p>Compute Monte Carlo standard errors for quantile estimates of a
single variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcse_quantile(x, probs = c(0.05, 0.95), ...)

## Default S3 method:
mcse_quantile(x, probs = c(0.05, 0.95), names = TRUE, ...)

## S3 method for class 'rvar'
mcse_quantile(x, probs = c(0.05, 0.95), names = TRUE, ...)

mcse_median(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcse_quantile_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mcse_quantile_+3A_probs">probs</code></td>
<td>
<p>(numeric vector) Probabilities in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="mcse_quantile_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="mcse_quantile_+3A_names">names</code></td>
<td>
<p>(logical) Should the result have a <code>names</code> attribute? The
default is <code>TRUE</code>, but use <code>FALSE</code> for improved speed if there are many
values in <code>probs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an array,
returns a numeric vector with one element per quantile. If any of the draws is
non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output will
be a vector of (numeric) <code>NA</code> values. Also, if all draws of a variable are
the same (constant), the returned output will be a vector of (numeric) <code>NA</code>
values as well. The reason for the latter is that, for constant draws, we
cannot distinguish between variables that are supposed to be constant (e.g.,
a diagonal element of a correlation matrix is always 1) or variables that
just happened to be constant because of a failure of convergence or other
problems in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code> and <code>length(probs) == 1</code>, returns an array of the
same dimensions as the <code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value
that would be returned by passing the draws array for that element of the
<code><a href="#topic+rvar">rvar</a></code> to this function. If <code>length(probs) &gt; 1</code>, the first dimension of the
result indexes the input probabilities; i.e. the result has dimension
<code>c(length(probs), dim(x))</code>.
</p>


<h3>References</h3>

<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian Bürkner (2021). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of
MCMC (with discussion). <em>Bayesian Data Analysis</em>. 16(2), 667-–718.
doi:10.1214/20-BA1221
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_basic">ess_basic</a>()</code>,
<code><a href="#topic+ess_bulk">ess_bulk</a>()</code>,
<code><a href="#topic+ess_quantile">ess_quantile</a>()</code>,
<code><a href="#topic+ess_sd">ess_sd</a>()</code>,
<code><a href="#topic+ess_tail">ess_tail</a>()</code>,
<code><a href="#topic+mcse_mean">mcse_mean</a>()</code>,
<code><a href="#topic+mcse_sd">mcse_sd</a>()</code>,
<code><a href="#topic+rhat_basic">rhat_basic</a>()</code>,
<code><a href="#topic+rhat_nested">rhat_nested</a>()</code>,
<code><a href="#topic+rhat">rhat</a>()</code>,
<code><a href="#topic+rstar">rstar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
mcse_quantile(mu, probs = c(0.1, 0.9))

d &lt;- as_draws_rvars(example_draws("multi_normal"))
mcse_quantile(d$mu)

</code></pre>

<hr>
<h2 id='mcse_sd'>Monte Carlo standard error for the standard deviation</h2><span id='topic+mcse_sd'></span><span id='topic+mcse_sd.default'></span><span id='topic+mcse_sd.rvar'></span>

<h3>Description</h3>

<p>Compute the Monte Carlo standard error for the standard deviation (SD) of a
single variable without assuming normality using moments of moments and
first order Taylor series approximation (Kenney and Keeping, 1951, p. 141).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcse_sd(x, ...)

## Default S3 method:
mcse_sd(x, ...)

## S3 method for class 'rvar'
mcse_sd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcse_sd_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mcse_sd_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an array, returns a single numeric value. If any of the draws
is non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output
will be (numeric) <code>NA</code>. Also, if all draws within any of the chains of a
variable are the same (constant), the returned output will be (numeric) <code>NA</code>
as well. The reason for the latter is that, for constant draws, we cannot
distinguish between variables that are supposed to be constant (e.g., a
diagonal element of a correlation matrix is always 1) or variables that just
happened to be constant because of a failure of convergence or other problems
in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code>, returns an array of the same dimensions as the
<code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value that would be returned by
passing the draws array for that element of the <code><a href="#topic+rvar">rvar</a></code> to this function.
</p>


<h3>References</h3>

<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian Bürkner (2021). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of
MCMC (with discussion). <em>Bayesian Data Analysis</em>. 16(2), 667-–718.
doi:10.1214/20-BA1221
</p>
<p>J. F. Kenney &amp; E. S. Keeping (1951). <em>Mathematics of Statistics, Vol. II.</em>
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_basic">ess_basic</a>()</code>,
<code><a href="#topic+ess_bulk">ess_bulk</a>()</code>,
<code><a href="#topic+ess_quantile">ess_quantile</a>()</code>,
<code><a href="#topic+ess_sd">ess_sd</a>()</code>,
<code><a href="#topic+ess_tail">ess_tail</a>()</code>,
<code><a href="#topic+mcse_mean">mcse_mean</a>()</code>,
<code><a href="#topic+mcse_quantile">mcse_quantile</a>()</code>,
<code><a href="#topic+rhat_basic">rhat_basic</a>()</code>,
<code><a href="#topic+rhat_nested">rhat_nested</a>()</code>,
<code><a href="#topic+rhat">rhat</a>()</code>,
<code><a href="#topic+rstar">rstar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
mcse_sd(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
mcse_sd(d$Sigma)

</code></pre>

<hr>
<h2 id='merge_chains'>Merge chains of <code>draws</code> objects</h2><span id='topic+merge_chains'></span><span id='topic+merge_chains.draws_matrix'></span><span id='topic+merge_chains.draws_array'></span><span id='topic+merge_chains.draws_df'></span><span id='topic+merge_chains.draws_list'></span><span id='topic+merge_chains.rvar'></span><span id='topic+merge_chains.draws_rvars'></span>

<h3>Description</h3>

<p>Merge chains of <code><a href="#topic+draws">draws</a></code> objects into a single chain. Some operations will
trigger an automatic merging of chains, for example, because chains do not
match between two objects involved in a binary operation. By default, no
warning will be issued when this happens but you can activate one via
<code>options(posterior.warn_on_merge_chains = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_chains(x, ...)

## S3 method for class 'draws_matrix'
merge_chains(x, ...)

## S3 method for class 'draws_array'
merge_chains(x, ...)

## S3 method for class 'draws_df'
merge_chains(x, ...)

## S3 method for class 'draws_list'
merge_chains(x, ...)

## S3 method for class 'rvar'
merge_chains(x, ...)

## S3 method for class 'draws_rvars'
merge_chains(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_chains_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="merge_chains_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_draws()

# draws_array with 4 chains, 100 iters each
str(x)

# draws_array with 1 chain of 400 iterations
str(merge_chains(x))

</code></pre>

<hr>
<h2 id='modal_category'>Modal category</h2><span id='topic+modal_category'></span><span id='topic+modal_category.default'></span><span id='topic+modal_category.rvar'></span>

<h3>Description</h3>

<p>Modal category of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modal_category(x)

## Default S3 method:
modal_category(x)

## S3 method for class 'rvar'
modal_category(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modal_category_+3A_x">x</code></td>
<td>
<p>(multiple options) A vector to be interpreted as draws from
a categorical distribution, such as:
</p>

<ul>
<li><p> A <a href="base.html#topic+factor">factor</a>
</p>
</li>
<li><p> A <a href="base.html#topic+numeric">numeric</a> (should be <a href="base.html#topic+integer">integer</a> or integer-like)
</p>
</li>
<li><p> An <a href="#topic+rvar">rvar</a>, <a href="#topic+rvar_factor">rvar_factor</a>, or <a href="#topic+rvar_ordered">rvar_ordered</a>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds the modal category (i.e., most frequent value) in <code>x</code>. In the case of
ties, returns the first tie.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a <a href="base.html#topic+factor">factor</a> or <a href="base.html#topic+numeric">numeric</a>, returns a length-1 vector containing
the modal value.
</p>
<p>If <code>x</code> is an <a href="#topic+rvar">rvar</a>, returns an array of the same shape as <code>x</code>, where each
cell is the modal value of the draws in the corresponding cell of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- factor(c("a","b","b","c","d"))
modal_category(x)

# in the case of ties, the first tie is returned
y &lt;- factor(c("a","c","c","d","d"))
modal_category(y)

# both together, as an rvar
xy &lt;- c(rvar(x), rvar(y))
xy
modal_category(xy)
</code></pre>

<hr>
<h2 id='mutate_variables'>Mutate variables in <code>draws</code> objects</h2><span id='topic+mutate_variables'></span><span id='topic+mutate_variables.draws_matrix'></span><span id='topic+mutate_variables.draws_array'></span><span id='topic+mutate_variables.draws_df'></span><span id='topic+mutate_variables.draws_list'></span><span id='topic+mutate_variables.draws_rvars'></span>

<h3>Description</h3>

<p>Mutate variables in a <code><a href="#topic+draws">draws</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_variables(.x, ...)

## S3 method for class 'draws_matrix'
mutate_variables(.x, ...)

## S3 method for class 'draws_array'
mutate_variables(.x, ...)

## S3 method for class 'draws_df'
mutate_variables(.x, ...)

## S3 method for class 'draws_list'
mutate_variables(.x, ...)

## S3 method for class 'draws_rvars'
mutate_variables(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_variables_+3A_.x">.x</code></td>
<td>
<p>(draws) A <code><a href="#topic+draws">draws</a></code> object.</p>
</td></tr>
<tr><td><code id="mutate_variables_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions, each with either length 1 or the
same length as in the entire input (i.e., number of iterations or draws).
The name of each argument will be the name of a new variable, and the value
will be its corresponding value. Use a <code>NULL</code> value in <code>mutate_variables</code>
to drop a variable. New variables overwrite existing variables of the same
name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to mutate variables in <code><a href="#topic+draws_matrix">draws_matrix</a></code> and <code><a href="#topic+draws_array">draws_array</a></code> objects,
they are transformed to <code><a href="#topic+draws_df">draws_df</a></code> objects first and then transformed back
after mutation. As those transformations are quite expensive for larger
number of draws, we recommend using <code>mutate_variables</code> on <code><a href="#topic+draws_df">draws_df</a></code> and
<code><a href="#topic+draws_list">draws_list</a></code> objects if speed is an issue.
</p>
<p>In <code><a href="#topic+draws_rvars">draws_rvars</a></code> objects, the output of each expression in <code>...</code> is
coerced to an <code><a href="#topic+rvar">rvar</a></code> object if it is not already one using <code>as_rvar()</code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+draws">draws</a></code> object of the same format as <code>.x</code>, with variables mutated
according to the expressions provided in <code>...</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variables">variables</a></code>, <code><a href="#topic+rename_variables">rename_variables</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_draws_df(example_draws())
x &lt;- subset(x, variable = c("mu", "tau"))

mutate_variables(x, tau2 = tau^2)
mutate_variables(x, scale = 1.96 * tau, lower = mu - scale)

</code></pre>

<hr>
<h2 id='order_draws'>Order <code>draws</code> objects</h2><span id='topic+order_draws'></span><span id='topic+order_draws.draws_matrix'></span><span id='topic+order_draws.draws_array'></span><span id='topic+order_draws.draws_df'></span><span id='topic+order_draws.draws_list'></span><span id='topic+order_draws.draws_rvars'></span><span id='topic+order_draws.rvar'></span>

<h3>Description</h3>

<p>Order <code><a href="#topic+draws">draws</a></code> objects according to iteration and chain number. By default,
draws objects are ordered but subsetting or extracting parts of them may
leave them in an unordered state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_draws(x, ...)

## S3 method for class 'draws_matrix'
order_draws(x, ...)

## S3 method for class 'draws_array'
order_draws(x, ...)

## S3 method for class 'draws_df'
order_draws(x, ...)

## S3 method for class 'draws_list'
order_draws(x, ...)

## S3 method for class 'draws_rvars'
order_draws(x, ...)

## S3 method for class 'rvar'
order_draws(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_draws_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="order_draws_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repair_draws">repair_draws()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_draws_array(example_draws())
dimnames(x[10:5, 4:3, ])
dimnames(order_draws(x[10:5, 4:3, ]))

</code></pre>

<hr>
<h2 id='pareto_diags'>Pareto smoothing diagnostics</h2><span id='topic+pareto_diags'></span><span id='topic+pareto_diags.default'></span><span id='topic+pareto_diags.rvar'></span>

<h3>Description</h3>

<p>Compute diagnostics for Pareto smoothing the tail draws of x by
replacing tail draws by order statistics of a generalized Pareto
distribution fit to the tail(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pareto_diags(x, ...)

## Default S3 method:
pareto_diags(
  x,
  tail = c("both", "right", "left"),
  r_eff = NULL,
  ndraws_tail = NULL,
  verbose = FALSE,
  ...
)

## S3 method for class 'rvar'
pareto_diags(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pareto_diags_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pareto_diags_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="pareto_diags_+3A_tail">tail</code></td>
<td>
<p>(string) The tail to diagnose/smooth:
</p>

<ul>
<li> <p><code>"right"</code>: diagnose/smooth only the right (upper) tail
</p>
</li>
<li> <p><code>"left"</code>: diagnose/smooth only the left (lower) tail
</p>
</li>
<li> <p><code>"both"</code>: diagnose/smooth both tails and return the maximum k-hat value
</p>
</li></ul>

<p>The default is <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="pareto_diags_+3A_r_eff">r_eff</code></td>
<td>
<p>(numeric) relative effective sample size estimate. If
<code>r_eff</code> is omitted, it will be calculated assuming the draws are
from MCMC.</p>
</td></tr>
<tr><td><code id="pareto_diags_+3A_ndraws_tail">ndraws_tail</code></td>
<td>
<p>(numeric) number of draws for the tail. If
<code>ndraws_tail</code> is not specified, it will be calculated as
ceiling(3 * sqrt(length(x) / r_eff)) if length(x) &gt; 225 and
length(x) / 5 otherwise (see Appendix H in Vehtari et al. (2022)).</p>
</td></tr>
<tr><td><code id="pareto_diags_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Should diagnostic messages be printed? If
<code>TRUE</code>, messages related to Pareto diagnostics will be
printed. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the fitted Generalized Pareto Distribution is used to
smooth the tail values and these smoothed values are used to
compute expectations, the following diagnostics can give further
information about the reliability of these estimates.
</p>

<ul>
<li> <p><code>min_ss</code>: Minimum sample size for reliable Pareto smoothed
estimate. If the actual sample size is greater than <code>min_ss</code>, then
Pareto smoothed estimates can be considered reliable. If the actual
sample size is lower than <code>min_ss</code>, increasing the sample size
might result in more reliable estimates. For further details, see
Section 3.2.3, Equation 11 in Vehtari et al. (2022).
</p>
</li>
<li> <p><code>khat_threshold</code>: Threshold below which k-hat values result in
reliable Pareto smoothed estimates. The threshold is lower for
smaller effective sample sizes. If k-hat is larger than the
threshold, increasing the total sample size may improve reliability
of estimates. For further details, see Section 3.2.4, Equation 13
in Vehtari et al. (2022).
</p>
</li>
<li> <p><code>convergence_rate</code>: Relative convergence rate compared to the
central limit theorem. Applicable only if the actual sample size
is sufficiently large (greater than <code>min_ss</code>). The convergence
rate tells the rate at which the variance of an estimate reduces
when the sample size is increased, compared to the central limit
theorem convergence rate. See Appendix B in Vehtari et al. (2022).
</p>
</li></ul>



<h3>Value</h3>

<p>List of Pareto smoothing diagnostics:
</p>

<ul>
<li> <p><code>khat</code>: estimated Pareto k shape parameter,
</p>
</li>
<li> <p><code>min_ss</code>: minimum sample size for reliable Pareto smoothed estimate,
</p>
</li>
<li> <p><code>khat_threshold</code>: khat-threshold for reliable Pareto smoothed estimate,
</p>
</li>
<li> <p><code>convergence_rate</code>: Pareto smoothed estimate RMSE convergence rate.
</p>
</li></ul>



<h3>References</h3>

<p>Aki Vehtari, Daniel Simpson, Andrew Gelman, Yuling Yao and
Jonah Gabry (2022). Pareto Smoothed Importance Sampling.
arxiv:arXiv:1507.02646
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
pareto_diags(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
pareto_diags(d$Sigma)
</code></pre>

<hr>
<h2 id='pareto_khat'>Pareto khat diagnostic</h2><span id='topic+pareto_khat'></span><span id='topic+pareto_khat.default'></span><span id='topic+pareto_khat.rvar'></span>

<h3>Description</h3>

<p>Estimate Pareto k value by fitting a Generalized Pareto
Distribution to one or two tails of x. This can be used to estimate
the number of fractional moments that is useful for convergence
diagnostics. For further details see Vehtari et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pareto_khat(x, ...)

## Default S3 method:
pareto_khat(
  x,
  tail = c("both", "right", "left"),
  r_eff = NULL,
  ndraws_tail = NULL,
  verbose = FALSE,
  ...
)

## S3 method for class 'rvar'
pareto_khat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pareto_khat_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pareto_khat_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="pareto_khat_+3A_tail">tail</code></td>
<td>
<p>(string) The tail to diagnose/smooth:
</p>

<ul>
<li> <p><code>"right"</code>: diagnose/smooth only the right (upper) tail
</p>
</li>
<li> <p><code>"left"</code>: diagnose/smooth only the left (lower) tail
</p>
</li>
<li> <p><code>"both"</code>: diagnose/smooth both tails and return the maximum k-hat value
</p>
</li></ul>

<p>The default is <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="pareto_khat_+3A_r_eff">r_eff</code></td>
<td>
<p>(numeric) relative effective sample size estimate. If
<code>r_eff</code> is omitted, it will be calculated assuming the draws are
from MCMC.</p>
</td></tr>
<tr><td><code id="pareto_khat_+3A_ndraws_tail">ndraws_tail</code></td>
<td>
<p>(numeric) number of draws for the tail. If
<code>ndraws_tail</code> is not specified, it will be calculated as
ceiling(3 * sqrt(length(x) / r_eff)) if length(x) &gt; 225 and
length(x) / 5 otherwise (see Appendix H in Vehtari et al. (2022)).</p>
</td></tr>
<tr><td><code id="pareto_khat_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Should diagnostic messages be printed? If
<code>TRUE</code>, messages related to Pareto diagnostics will be
printed. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>khat</code> estimated Generalized Pareto Distribution shape parameter k
</p>


<h3>References</h3>

<p>Aki Vehtari, Daniel Simpson, Andrew Gelman, Yuling Yao and
Jonah Gabry (2022). Pareto Smoothed Importance Sampling.
arxiv:arXiv:1507.02646
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
pareto_khat(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
pareto_khat(d$Sigma)
</code></pre>

<hr>
<h2 id='pareto_smooth'>Pareto smoothing</h2><span id='topic+pareto_smooth'></span><span id='topic+pareto_smooth.rvar'></span><span id='topic+pareto_smooth.default'></span>

<h3>Description</h3>

<p>Smooth the tail draws of x by replacing tail draws by order
statistics of a generalized Pareto distribution fit to the
tail(s). For further details see Vehtari et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pareto_smooth(x, ...)

## S3 method for class 'rvar'
pareto_smooth(x, return_k = TRUE, extra_diags = FALSE, ...)

## Default S3 method:
pareto_smooth(
  x,
  tail = c("both", "right", "left"),
  r_eff = NULL,
  ndraws_tail = NULL,
  return_k = TRUE,
  extra_diags = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pareto_smooth_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pareto_smooth_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="pareto_smooth_+3A_return_k">return_k</code></td>
<td>
<p>(logical) Should the Pareto khat be included in
output? If <code>TRUE</code>, output will be a list containing of smoothed
draws and diagnostics. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pareto_smooth_+3A_extra_diags">extra_diags</code></td>
<td>
<p>(logical) Should extra Pareto khat diagnostics
be included in output? If <code>TRUE</code>, <code>min_ss</code>, <code>khat_threshold</code> and
<code>convergence_rate</code> for the estimated k value will be
returned. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pareto_smooth_+3A_tail">tail</code></td>
<td>
<p>(string) The tail to diagnose/smooth:
</p>

<ul>
<li> <p><code>"right"</code>: diagnose/smooth only the right (upper) tail
</p>
</li>
<li> <p><code>"left"</code>: diagnose/smooth only the left (lower) tail
</p>
</li>
<li> <p><code>"both"</code>: diagnose/smooth both tails and return the maximum k-hat value
</p>
</li></ul>

<p>The default is <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="pareto_smooth_+3A_r_eff">r_eff</code></td>
<td>
<p>(numeric) relative effective sample size estimate. If
<code>r_eff</code> is omitted, it will be calculated assuming the draws are
from MCMC.</p>
</td></tr>
<tr><td><code id="pareto_smooth_+3A_ndraws_tail">ndraws_tail</code></td>
<td>
<p>(numeric) number of draws for the tail. If
<code>ndraws_tail</code> is not specified, it will be calculated as
ceiling(3 * sqrt(length(x) / r_eff)) if length(x) &gt; 225 and
length(x) / 5 otherwise (see Appendix H in Vehtari et al. (2022)).</p>
</td></tr>
<tr><td><code id="pareto_smooth_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Should diagnostic messages be printed? If
<code>TRUE</code>, messages related to Pareto diagnostics will be
printed. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a vector <code>x</code> of smoothed values or a named list
containing the vector <code>x</code> and a named list <code>diagnostics</code> containing Pareto smoothing
diagnostics:
</p>

<ul>
<li> <p><code>khat</code>: estimated Pareto k shape parameter, and
optionally
</p>
</li>
<li> <p><code>min_ss</code>: minimum sample size for reliable Pareto
smoothed estimate
</p>
</li>
<li> <p><code>khat_threshold</code>: khat-threshold for reliable
Pareto smoothed estimates
</p>
</li>
<li> <p><code>convergence_rate</code>: Relative convergence rate for Pareto smoothed estimates
</p>
</li></ul>



<h3>References</h3>

<p>Aki Vehtari, Daniel Simpson, Andrew Gelman, Yuling Yao and
Jonah Gabry (2022). Pareto Smoothed Importance Sampling.
arxiv:arXiv:1507.02646
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
pareto_smooth(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
pareto_smooth(d$Sigma)
</code></pre>

<hr>
<h2 id='print.draws_array'>Print <code>draws_array</code> objects</h2><span id='topic+print.draws_array'></span>

<h3>Description</h3>

<p>Pretty printing for <code><a href="#topic+draws_array">draws_array</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'draws_array'
print(
  x,
  digits = 2,
  max_iterations = getOption("posterior.max_iterations", 5),
  max_chains = getOption("posterior.max_chains", 8),
  max_variables = getOption("posterior.max_variables", 4),
  reserved = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.draws_array_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="print.draws_array_+3A_digits">digits</code></td>
<td>
<p>(nonnegative integer) The minimum number of significant digits
to print. If <code>NULL</code>, defaults to <code>getOption("posterior.digits", 2)</code>.</p>
</td></tr>
<tr><td><code id="print.draws_array_+3A_max_iterations">max_iterations</code></td>
<td>
<p>(positive integer) The maximum number of iterations to
print. Can be controlled globally via the <code>"posterior.max_iterations"</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="print.draws_array_+3A_max_chains">max_chains</code></td>
<td>
<p>(positive integer) The maximum number of chains to print.
Can be controlled globally via the <code>"posterior.max_chains"</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="print.draws_array_+3A_max_variables">max_variables</code></td>
<td>
<p>(positive integer) The maximum number of variables to
print. Can be controlled globally via the <code>"posterior.max_variables"</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="print.draws_array_+3A_reserved">reserved</code></td>
<td>
<p>(logical) Should reserved variables be included in the
output? Defaults to <code>FALSE</code>. See <code><a href="#topic+reserved_variables">reserved_variables</a></code> for an overview of
currently reserved variable names.</p>
</td></tr>
<tr><td><code id="print.draws_array_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying <code><a href="base.html#topic+print">print()</a></code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_draws_array(example_draws())
print(x)

</code></pre>

<hr>
<h2 id='print.draws_df'>Print <code>draws_df</code> objects</h2><span id='topic+print.draws_df'></span>

<h3>Description</h3>

<p>Pretty printing for <code><a href="#topic+draws_df">draws_df</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'draws_df'
print(
  x,
  digits = 2,
  max_draws = getOption("posterior.max_draws", 10),
  max_variables = getOption("posterior.max_variables", 8),
  reserved = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.draws_df_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="print.draws_df_+3A_digits">digits</code></td>
<td>
<p>(nonnegative integer) The minimum number of significant digits
to print. If <code>NULL</code>, defaults to <code>getOption("posterior.digits", 2)</code>.</p>
</td></tr>
<tr><td><code id="print.draws_df_+3A_max_draws">max_draws</code></td>
<td>
<p>(positive integer) The maximum number of draws to print. Can
be controlled globally via the <code>"posterior.max_draws"</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="print.draws_df_+3A_max_variables">max_variables</code></td>
<td>
<p>(positive integer) The maximum number of variables to
print. Can be controlled globally via the <code>"posterior.max_variables"</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="print.draws_df_+3A_reserved">reserved</code></td>
<td>
<p>(logical) Should reserved variables be included in the
output? Defaults to <code>FALSE</code>. See <code><a href="#topic+reserved_variables">reserved_variables</a></code> for an overview of
currently reserved variable names.</p>
</td></tr>
<tr><td><code id="print.draws_df_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying <code><a href="base.html#topic+print">print()</a></code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_draws_df(example_draws())
print(x)

</code></pre>

<hr>
<h2 id='print.draws_list'>Print <code>draws_list</code> objects</h2><span id='topic+print.draws_list'></span>

<h3>Description</h3>

<p>Pretty printing for <code><a href="#topic+draws_list">draws_list</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'draws_list'
print(
  x,
  digits = 2,
  max_iterations = getOption("posterior.max_iterations", 10),
  max_chains = getOption("posterior.max_chains", 2),
  max_variables = getOption("posterior.max_variables", 4),
  reserved = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.draws_list_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="print.draws_list_+3A_digits">digits</code></td>
<td>
<p>(nonnegative integer) The minimum number of significant digits
to print. If <code>NULL</code>, defaults to <code>getOption("posterior.digits", 2)</code>.</p>
</td></tr>
<tr><td><code id="print.draws_list_+3A_max_iterations">max_iterations</code></td>
<td>
<p>(positive integer) The maximum number of iterations to
print. Can be controlled globally via the <code>"posterior.max_iterations"</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="print.draws_list_+3A_max_chains">max_chains</code></td>
<td>
<p>(positive integer) The maximum number of chains to print.
Can be controlled globally via the <code>"posterior.max_chains"</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="print.draws_list_+3A_max_variables">max_variables</code></td>
<td>
<p>(positive integer) The maximum number of variables to
print. Can be controlled globally via the <code>"posterior.max_variables"</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="print.draws_list_+3A_reserved">reserved</code></td>
<td>
<p>(logical) Should reserved variables be included in the
output? Defaults to <code>FALSE</code>. See <code><a href="#topic+reserved_variables">reserved_variables</a></code> for an overview of
currently reserved variable names.</p>
</td></tr>
<tr><td><code id="print.draws_list_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying <code><a href="base.html#topic+print">print()</a></code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_draws_list(example_draws())
print(x)

</code></pre>

<hr>
<h2 id='print.draws_matrix'>Print <code>draws_matrix</code> objects</h2><span id='topic+print.draws_matrix'></span>

<h3>Description</h3>

<p>Pretty printing for <code><a href="#topic+draws_matrix">draws_matrix</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'draws_matrix'
print(
  x,
  digits = 2,
  max_draws = getOption("posterior.max_draws", 10),
  max_variables = getOption("posterior.max_variables", 8),
  reserved = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.draws_matrix_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="print.draws_matrix_+3A_digits">digits</code></td>
<td>
<p>(nonnegative integer) The minimum number of significant digits
to print. If <code>NULL</code>, defaults to <code>getOption("posterior.digits", 2)</code>.</p>
</td></tr>
<tr><td><code id="print.draws_matrix_+3A_max_draws">max_draws</code></td>
<td>
<p>(positive integer) The maximum number of draws to print. Can
be controlled globally via the <code>"posterior.max_draws"</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="print.draws_matrix_+3A_max_variables">max_variables</code></td>
<td>
<p>(positive integer) The maximum number of variables to
print. Can be controlled globally via the <code>"posterior.max_variables"</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="print.draws_matrix_+3A_reserved">reserved</code></td>
<td>
<p>(logical) Should reserved variables be included in the
output? Defaults to <code>FALSE</code>. See <code><a href="#topic+reserved_variables">reserved_variables</a></code> for an overview of
currently reserved variable names.</p>
</td></tr>
<tr><td><code id="print.draws_matrix_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying <code><a href="base.html#topic+print">print()</a></code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_draws_matrix(example_draws())
print(x)

</code></pre>

<hr>
<h2 id='print.draws_rvars'>Print <code>draws_rvars</code> objects</h2><span id='topic+print.draws_rvars'></span>

<h3>Description</h3>

<p>Pretty printing for <code><a href="#topic+draws_rvars">draws_rvars</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'draws_rvars'
print(
  x,
  digits = 2,
  max_variables = getOption("posterior.max_variables", 8),
  summary = getOption("posterior.rvar_summary", "mean_sd"),
  reserved = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.draws_rvars_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="print.draws_rvars_+3A_digits">digits</code></td>
<td>
<p>(nonnegative integer) The minimum number of significant digits
to print. If <code>NULL</code>, defaults to <code>getOption("posterior.digits", 2)</code>.</p>
</td></tr>
<tr><td><code id="print.draws_rvars_+3A_max_variables">max_variables</code></td>
<td>
<p>(positive integer) The maximum number of variables to
print. Can be controlled globally via the <code>"posterior.max_variables"</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
<tr><td><code id="print.draws_rvars_+3A_summary">summary</code></td>
<td>
<p>(string) The style of summary to display:
</p>

<ul>
<li> <p><code>"mean_sd"</code> displays <code style="white-space: pre;">&#8288;mean ± sd&#8288;</code>
</p>
</li>
<li> <p><code>"median_mad"</code> displays <code style="white-space: pre;">&#8288;median ± mad&#8288;</code>
</p>
</li>
<li> <p><code>"mode_entropy"</code> displays <code style="white-space: pre;">&#8288;mode &lt;entropy&gt;&#8288;</code>, and is used automatically for
<code><a href="#topic+rvar_factor">rvar_factor</a></code>s. It shows normalized entropy, which ranges from
0 (all probability in one category) to 1 (uniform). See <code><a href="#topic+entropy">entropy()</a></code>.
</p>
</li>
<li> <p><code>"mode_dissent"</code> displays <code style="white-space: pre;">&#8288;mode &lt;dissent&gt;&#8288;</code>, and is used automatically for
<code><a href="#topic+rvar_ordered">rvar_ordered</a></code>s. It shows Tastle and Wierman's (2007) <em>dissention</em>
measure, which ranges from 0 (all probability in one category) through
0.5 (uniform) to 1 (bimodal: all probability split equally between the
first and last category). See <code><a href="#topic+dissent">dissent()</a></code>.
</p>
</li>
<li> <p><code>NULL</code> uses <code>getOption("posterior.rvar_summary")</code> (default <code style="white-space: pre;">&#8288;"mean_sd&#8288;</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="print.draws_rvars_+3A_reserved">reserved</code></td>
<td>
<p>(logical) Should reserved variables be included in the
output? Defaults to <code>FALSE</code>. See <code><a href="#topic+reserved_variables">reserved_variables</a></code> for an overview of
currently reserved variable names.</p>
</td></tr>
<tr><td><code id="print.draws_rvars_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying <code><a href="base.html#topic+print">print()</a></code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_draws_rvars(example_draws())
print(x)

</code></pre>

<hr>
<h2 id='print.draws_summary'>Print summaries of <code>draws</code> objects</h2><span id='topic+print.draws_summary'></span>

<h3>Description</h3>

<p>Print output from <code><a href="#topic+summarise_draws">summarise_draws()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'draws_summary'
print(x, ..., num_args = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.draws_summary_+3A_x">x</code></td>
<td>
<p>(draws_summary) A <code>"draws_summary"</code> object as output by <code><a href="#topic+summarise_draws">summarise_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="print.draws_summary_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="tibble.html#topic+formatting">tibble::print.tbl_df()</a></code></p>
</td></tr>
<tr><td><code id="print.draws_summary_+3A_num_args">num_args</code></td>
<td>
<p>(named list) Optional arguments passed to
<a href="tibble.html#topic+num">num()</a> for pretty printing of summaries. If <code>NULL</code>
(the default), uses the arguments stored in the <code>"num_args"</code> attribute of
<code>x</code>, as set by the <code>.num_args</code> argument of <code><a href="#topic+summarise_draws">summarise_draws()</a></code>, which
itself can be controlled globally via the <code>posterior.num_args</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible version of the input object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_draws("eight_schools")

# adjust how summaries are printed when calling summarise_draws()...
summarise_draws(x, .num_args = list(sigfig = 2, notation = "dec"))

# ... or when printing
s &lt;- summarise_draws(x)
print(s, num_args = list(sigfig = 2, notation = "dec"))
print(s, num_args = list(digits = 3))
</code></pre>

<hr>
<h2 id='print.rvar'>Print or format a random variable</h2><span id='topic+print.rvar'></span><span id='topic+format.rvar'></span><span id='topic+str.rvar'></span>

<h3>Description</h3>

<p>Printing and formatting methods for <code><a href="#topic+rvar">rvar</a></code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rvar'
print(
  x,
  ...,
  summary = NULL,
  digits = NULL,
  color = TRUE,
  width = getOption("width")
)

## S3 method for class 'rvar'
format(x, ..., summary = NULL, digits = NULL, color = FALSE)

## S3 method for class 'rvar'
str(
  object,
  ...,
  summary = NULL,
  vec.len = NULL,
  indent.str = paste(rep.int(" ", max(0, nest.lev + 1)), collapse = ".."),
  nest.lev = 0,
  give.attr = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rvar_+3A_x">x</code>, <code id="print.rvar_+3A_object">object</code></td>
<td>
<p>(rvar) The <code><a href="#topic+rvar">rvar</a></code> to print.</p>
</td></tr>
<tr><td><code id="print.rvar_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying <code><a href="base.html#topic+print">print()</a></code> methods.</p>
</td></tr>
<tr><td><code id="print.rvar_+3A_summary">summary</code></td>
<td>
<p>(string) The style of summary to display:
</p>

<ul>
<li> <p><code>"mean_sd"</code> displays <code style="white-space: pre;">&#8288;mean ± sd&#8288;</code>
</p>
</li>
<li> <p><code>"median_mad"</code> displays <code style="white-space: pre;">&#8288;median ± mad&#8288;</code>
</p>
</li>
<li> <p><code>"mode_entropy"</code> displays <code style="white-space: pre;">&#8288;mode &lt;entropy&gt;&#8288;</code>, and is used automatically for
<code><a href="#topic+rvar_factor">rvar_factor</a></code>s. It shows normalized entropy, which ranges from
0 (all probability in one category) to 1 (uniform). See <code><a href="#topic+entropy">entropy()</a></code>.
</p>
</li>
<li> <p><code>"mode_dissent"</code> displays <code style="white-space: pre;">&#8288;mode &lt;dissent&gt;&#8288;</code>, and is used automatically for
<code><a href="#topic+rvar_ordered">rvar_ordered</a></code>s. It shows Tastle and Wierman's (2007) <em>dissention</em>
measure, which ranges from 0 (all probability in one category) through
0.5 (uniform) to 1 (bimodal: all probability split equally between the
first and last category). See <code><a href="#topic+dissent">dissent()</a></code>.
</p>
</li>
<li> <p><code>NULL</code> uses <code>getOption("posterior.rvar_summary")</code> (default <code style="white-space: pre;">&#8288;"mean_sd&#8288;</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="print.rvar_+3A_digits">digits</code></td>
<td>
<p>(nonnegative integer) The minimum number of significant digits
to print. If <code>NULL</code>, defaults to <code>getOption("posterior.digits", 2)</code>.</p>
</td></tr>
<tr><td><code id="print.rvar_+3A_color">color</code></td>
<td>
<p>(logical) Whether or not to use color when formatting the
output. If <code>TRUE</code>, the <code><a href="pillar.html#topic+style_subtle">pillar::style_num()</a></code> functions may be used to
produce strings containing control sequences to produce colored output on
the terminal.</p>
</td></tr>
<tr><td><code id="print.rvar_+3A_width">width</code></td>
<td>
<p>The maxmimum width used to print out lists of factor levels
for <code><a href="#topic+rvar_factor">rvar_factor</a></code>s. See <code><a href="base.html#topic+format">format()</a></code>.</p>
</td></tr>
<tr><td><code id="print.rvar_+3A_vec.len">vec.len</code></td>
<td>
<p>(nonnegative integer) How many 'first few' elements are
displayed of each vector. If <code>NULL</code>, defaults to
<code>getOption("str")$vec.len</code>, which defaults to 4.</p>
</td></tr>
<tr><td><code id="print.rvar_+3A_indent.str">indent.str</code></td>
<td>
<p>(string) The indentation string to use.</p>
</td></tr>
<tr><td><code id="print.rvar_+3A_nest.lev">nest.lev</code></td>
<td>
<p>(nonnegative integer) Current nesting level in the recursive
calls to <code>str()</code>.</p>
</td></tr>
<tr><td><code id="print.rvar_+3A_give.attr">give.attr</code></td>
<td>
<p>(logical) If <code>TRUE</code> (default), show attributes as sub
structures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print()</code> and <code>str()</code> print out <code><a href="#topic+rvar">rvar</a></code> objects by summarizing each element
in the random variable with either its mean±sd or median±mad, depending on
the value of <code>summary</code>. Both functions use the <code>format()</code> implementation for
<code><a href="#topic+rvar">rvar</a></code> objects under the hood, which returns a character vector in the
mean±sd or median±mad form.
</p>


<h3>Value</h3>

<p>For <code>print()</code>, an invisible version of the input object.
</p>
<p>For <code>str()</code>, nothing; i.e. <code>invisible(NULL)</code>.
</p>
<p>For <code>format()</code>, a character vector of the same dimensions as <code>x</code> where each
entry is of the form <code>"mean±sd"</code> or <code>"median±mad"</code>, depending on the value
of <code>summary</code>.
</p>


<h3>References</h3>

<p>William J. Tastle, Mark J. Wierman (2007). Consensus and dissention: A measure
of ordinal dispersion. <em>International Journal of Approximate Reasoning</em>.
45(3), 531&ndash;545.
<a href="https://doi.org/10.1016/j.ijar.2006.06.024">doi:10.1016/j.ijar.2006.06.024</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(5678)
x = rbind(
  cbind(rvar(rnorm(1000, 1)), rvar(rnorm(1000, 2))),
  cbind(rvar(rnorm(1000, 3)), rvar(rnorm(1000, 4)))
)

print(x)
print(x, summary = "median_mad")

str(x)

format(x)

</code></pre>

<hr>
<h2 id='quantile2'>Compute Quantiles</h2><span id='topic+quantile2'></span><span id='topic+quantile2.default'></span><span id='topic+quantile2.rvar'></span>

<h3>Description</h3>

<p>Compute quantiles of a sample and return them in a format consistent
with other summary functions in the <span class="pkg">posterior</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile2(x, probs = c(0.05, 0.95), na.rm = FALSE, ...)

## Default S3 method:
quantile2(x, probs = c(0.05, 0.95), na.rm = FALSE, names = TRUE, ...)

## S3 method for class 'rvar'
quantile2(x, probs = c(0.05, 0.95), na.rm = FALSE, names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile2_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="quantile2_+3A_probs">probs</code></td>
<td>
<p>(numeric vector) Probabilities in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="quantile2_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) Should <code>NA</code> and <code>NaN</code> values be removed from <code>x</code> prior
to computing quantiles? The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="quantile2_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable) and then
on to <code><a href="stats.html#topic+quantile">stats::quantile()</a></code>.</p>
</td></tr>
<tr><td><code id="quantile2_+3A_names">names</code></td>
<td>
<p>(logical) Should the result have a <code>names</code> attribute? The
default is <code>TRUE</code>, but use <code>FALSE</code> for improved speed if there are many
values in <code>probs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>length(probs)</code>. If <code>names = TRUE</code>, it has a
<a href="base.html#topic+names">names</a> attribute with names like <code>"q5"</code>, <code>"q95"</code>, etc, based on the values
of <code>probs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
quantile2(mu)

</code></pre>

<hr>
<h2 id='r_scale'>Rank values</h2><span id='topic+r_scale'></span>

<h3>Description</h3>

<p>Compute ranks for a numeric array, that is, replace each
value by its rank. Average rank for ties are used to conserve the
number of unique values of discrete quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_scale(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_scale_+3A_x">x</code></td>
<td>
<p>(numeric) A scalar, vector, matrix, or array of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric array of ranked values with the same size
and dimension as the input.
</p>

<hr>
<h2 id='rdo'>Execute expressions of random variables</h2><span id='topic+rdo'></span>

<h3>Description</h3>

<p>Execute (nearly) arbitrary <span class="rlang"><b>R</b></span> expressions that may include <code><a href="#topic+rvar">rvar</a></code>s,
producing a new <code><a href="#topic+rvar">rvar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdo(expr, dim = NULL, ndraws = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdo_+3A_expr">expr</code></td>
<td>
<p>(expression) A bare expression that can (optionally) contain
<code><a href="#topic+rvar">rvar</a></code>s. The expression supports <a href="rlang.html#topic+quasiquotation">quasiquotation</a>.</p>
</td></tr>
<tr><td><code id="rdo_+3A_dim">dim</code></td>
<td>
<p>(integer vector) One or more integers giving the maximal indices
in each dimension to override the dimensions of the <code><a href="#topic+rvar">rvar</a></code> to be created
(see <code><a href="base.html#topic+dim">dim()</a></code>). If <code>NULL</code> (the default), <code>dim</code> is determined by the input.
<strong>NOTE:</strong> This argument controls the dimensions of the <code><a href="#topic+rvar">rvar</a></code>, not the
underlying array, so you cannot change the number of draws using this
argument.</p>
</td></tr>
<tr><td><code id="rdo_+3A_ndraws">ndraws</code></td>
<td>
<p>(positive integer) The number of draws used to construct new
random variables if no <code><a href="#topic+rvar">rvar</a></code>s are supplied in <code>expr</code>. If <code>NULL</code>,
<code>getOption("posterior.rvar_ndraws")</code> is used (default 4000). If <code>expr</code>
contains <code><a href="#topic+rvar">rvar</a></code>s, the number of draws in the provided <code><a href="#topic+rvar">rvar</a></code>s is used
instead of the value of this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates <code>expr</code> possibly multiple times, once for each draw of
the <code><a href="#topic+rvar">rvar</a></code>s it contains, then returns a new <code><a href="#topic+rvar">rvar</a></code> representing the output of those
expressions. To identify <code><a href="#topic+rvar">rvar</a></code>s, <code>rdo()</code> searches the calling environment for any variables
named in <code>expr</code> for which <code><a href="#topic+is_rvar">is_rvar()</a></code> evaluates to <code>TRUE</code>. If <code>expr</code> contains no <code><a href="#topic+rvar">rvar</a></code>s,
then it will be executed <code>ndraws</code> times and an <code><a href="#topic+rvar">rvar</a></code> with that many draws returned.
</p>
<p><code>rdo()</code> is not necessarily <em>fast</em> (in fact in some cases it may be very slow), but
it has the advantage of allowing a nearly arbitrary R expression to be executed against <code><a href="#topic+rvar">rvar</a></code>s
simply by wrapping it with <code>rdo( ... )</code>. This makes it especially useful as a prototyping
tool. If you create code with <code>rdo()</code> and it is unacceptably slow for your application,
consider rewriting it using math operations directly on <code><a href="#topic+rvar">rvar</a></code>s (which should be fast),
using <code><a href="#topic+rvar_rng">rvar_rng()</a></code>, and/or using operations directly on the arrays that back the <code><a href="#topic+rvar">rvar</a></code>s
(via <code><a href="#topic+draws_of">draws_of()</a></code>).
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+rvar">rvar</a></code>.
</p>


<h3>See Also</h3>

<p>Other rfun: 
<code><a href="#topic+rfun">rfun</a>()</code>,
<code><a href="#topic+rvar_rng">rvar_rng</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mu &lt;- rdo(rnorm(10, mean = 1:10, sd = 1))
sigma &lt;- rdo(rgamma(1, shape = 1, rate = 1))
x &lt;- rdo(rnorm(10, mu, sigma))
x

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+cdf'></span><span id='topic+variance'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>distributional</dt><dd><p><code><a href="distributional.html#topic+cdf">cdf</a></code>, <code><a href="distributional.html#topic+variance">variance</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rename_variables'>Rename variables in <code>draws</code> objects</h2><span id='topic+rename_variables'></span><span id='topic+rename_variables.draws'></span>

<h3>Description</h3>

<p>Rename variables in a <code><a href="#topic+draws">draws</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_variables(.x, ...)

## S3 method for class 'draws'
rename_variables(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_variables_+3A_.x">.x</code></td>
<td>
<p>(draws) A <code><a href="#topic+draws">draws</a></code> object.</p>
</td></tr>
<tr><td><code id="rename_variables_+3A_...">...</code></td>
<td>
<p>One or more expressions, separated by commas, indicating the
variables to rename. The variable names can be unquoted
(<code>new_name = old_name</code>) or quoted (<code>"new_name" = "old_name"</code>). For non-scalar
variables, all elements can be renamed together (<code>"new_name" = "old_name"</code>)
or they can be renamed individually (<code>"new_name[1]" = "old_name[1]"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+draws">draws</a></code> object of the same format as <code>.x</code>, with variables renamed
according to the expressions provided in <code>...</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variables">variables</a></code>, <code><a href="#topic+mutate_variables">mutate_variables</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_draws_df(example_draws())
variables(x)

x &lt;- rename_variables(x, mean = mu, sigma = tau)
variables(x)

x &lt;- rename_variables(x, b = `theta[1]`) # or b  = "theta[1]"
variables(x)

# rename all elements of 'theta' at once
x &lt;- rename_variables(x, alpha = theta)
variables(x)

</code></pre>

<hr>
<h2 id='repair_draws'>Repair indices of <code>draws</code> objects</h2><span id='topic+repair_draws'></span><span id='topic+repair_draws.draws_matrix'></span><span id='topic+repair_draws.draws_array'></span><span id='topic+repair_draws.draws_df'></span><span id='topic+repair_draws.draws_list'></span><span id='topic+repair_draws.draws_rvars'></span><span id='topic+repair_draws.rvar'></span>

<h3>Description</h3>

<p>Repair indices of <code>draws</code> objects so that iterations, chains, and draws
are continuously and consistently numbered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repair_draws(x, order = TRUE, ...)

## S3 method for class 'draws_matrix'
repair_draws(x, order = TRUE, ...)

## S3 method for class 'draws_array'
repair_draws(x, order = TRUE, ...)

## S3 method for class 'draws_df'
repair_draws(x, order = TRUE, ...)

## S3 method for class 'draws_list'
repair_draws(x, order = TRUE, ...)

## S3 method for class 'draws_rvars'
repair_draws(x, order = TRUE, ...)

## S3 method for class 'rvar'
repair_draws(x, order = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repair_draws_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="repair_draws_+3A_order">order</code></td>
<td>
<p>(logical) Should draws be ordered (via <code><a href="#topic+order_draws">order_draws()</a></code>) before
repairing indices? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="repair_draws_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+order_draws">order_draws()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_draws_array(example_draws())
(x &lt;- x[10:5, 3:4, ])
repair_draws(x)

</code></pre>

<hr>
<h2 id='resample_draws'>Resample <code>draws</code> objects</h2><span id='topic+resample_draws'></span><span id='topic+resample_draws.draws'></span><span id='topic+resample_draws.rvar'></span>

<h3>Description</h3>

<p>Resample <code><a href="#topic+draws">draws</a></code> objects according to provided weights, for example weights
obtained through importance sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_draws(x, ...)

## S3 method for class 'draws'
resample_draws(x, weights = NULL, method = "stratified", ndraws = NULL, ...)

## S3 method for class 'rvar'
resample_draws(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_draws_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="resample_draws_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="resample_draws_+3A_weights">weights</code></td>
<td>
<p>(numeric vector) A vector of positive weights of length
<code>ndraws(x)</code>. The weights will be internally normalized. If <code>weights</code> is not
specified, an attempt will be made to extract any weights already stored in
the draws object (via <code><a href="#topic+weight_draws">weight_draws()</a></code>). If no weights are stored in the
draws object, equal weight is supplied to each draw. How exactly the
weights influence the resampling depends on the <code>method</code> argument.</p>
</td></tr>
<tr><td><code id="resample_draws_+3A_method">method</code></td>
<td>
<p>(string) The resampling method to use:
</p>

<ul>
<li> <p><code>"simple"</code>: simple random resampling with replacement
</p>
</li>
<li> <p><code>"simple_no_replace"</code>: simple random resampling without replacement
</p>
</li>
<li> <p><code>"stratified"</code>: stratified resampling with replacement
</p>
</li>
<li> <p><code>"deterministic"</code>: deterministic resampling with replacement
</p>
</li></ul>

<p>Currently, <code>"stratified"</code> is the default as it has comparably low variance
and bias with respect to ideal resampling. The latter would sample perfectly
proportional to the weights, but this is not possible in practice due to the
finite number of draws available. For more details about resampling methods,
see Kitagawa (1996).</p>
</td></tr>
<tr><td><code id="resample_draws_+3A_ndraws">ndraws</code></td>
<td>
<p>(positive integer) The number of draws to be returned. By
default <code>ndraws</code> is set internally to the total number of draws in <code>x</code> if
sensible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Upon usage of <code>resample_draws()</code>, chains will automatically be merged
due to subsetting of individual draws (see <code><a href="#topic+subset_draws">subset_draws</a></code> for details).
Also, weights stored in the <code>draws</code> object will be removed in the process,
as resampling invalidates existing weights.
</p>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>References</h3>

<p>Kitagawa, G., Monte Carlo Filter and Smoother for Non-Gaussian Nonlinear '
State Space Models, <em>Journal of Computational and Graphical Statistics</em>,
5(1):1-25, 1996.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resample_draws">resample_draws()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_draws_df(example_draws())

# random weights for justr for demonstration
w &lt;- runif(ndraws(x), 0, 10)

# use default stratified sampling
x_rs &lt;- resample_draws(x, weights = w)
summarise_draws(x_rs, default_summary_measures())

# use simple random sampling
x_rs &lt;- resample_draws(x, weights = w, method = "simple")
summarise_draws(x_rs, default_summary_measures())

</code></pre>

<hr>
<h2 id='reserved_variables'>Reserved variables</h2><span id='topic+reserved_variables'></span><span id='topic+reserved_variables.default'></span><span id='topic+reserved_variables.draws_matrix'></span><span id='topic+reserved_variables.draws_array'></span><span id='topic+reserved_variables.draws_df'></span><span id='topic+reserved_variables.draws_list'></span><span id='topic+reserved_variables.draws_rvars'></span>

<h3>Description</h3>

<p>Get names of reserved variables from objects in the <span class="pkg">posterior</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reserved_variables(x, ...)

## Default S3 method:
reserved_variables(x, ...)

## S3 method for class 'draws_matrix'
reserved_variables(x, ...)

## S3 method for class 'draws_array'
reserved_variables(x, ...)

## S3 method for class 'draws_df'
reserved_variables(x, ...)

## S3 method for class 'draws_list'
reserved_variables(x, ...)

## S3 method for class 'draws_rvars'
reserved_variables(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reserved_variables_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="reserved_variables_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>reserved_variables()</code> returns the names of reserved variables in use by
an object.
</p>
<p>The following variables names are currently reserved for special use cases
in all <code><a href="#topic+draws">draws</a></code> formats:
</p>

<ul>
<li> <p><code>.log_weight</code>: Log weights per draw (see <code><a href="#topic+weight_draws">weight_draws</a></code>).
</p>
</li></ul>

<p>Further, specific for the <code><a href="#topic+draws_df">draws_df</a></code> format, there are three additional
reserved variables:
</p>

<ul>
<li> <p><code>.chain</code>: Chain index per draw
</p>
</li>
<li> <p><code>.iteration</code>: Iteration index within each chain
</p>
</li>
<li> <p><code>.draw</code>: Draw index across chains
</p>
</li></ul>

<p>More reserved variables may be added in the future.
</p>


<h3>Value</h3>

<p>A character vector of reserved variables used in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- example_draws()
reserved_variables(x)

# if we add weights, the `.log_weight` reserved variable is used
x &lt;- weight_draws(x, rexp(ndraws(x)))
reserved_variables(x)

</code></pre>

<hr>
<h2 id='rfun'>Create functions of random variables</h2><span id='topic+rfun'></span>

<h3>Description</h3>

<p>Function that create functions that can accept and/or produce <code><a href="#topic+rvar">rvar</a></code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfun(.f, rvar_args = NULL, rvar_dots = TRUE, ndraws = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfun_+3A_.f">.f</code></td>
<td>
<p>(multiple options) A function to turn into a function that accepts
and/or produces random variables:
</p>

<ul>
<li><p> A function
</p>
</li>
<li><p> A one-sided formula that can be parsed by <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="rfun_+3A_rvar_args">rvar_args</code></td>
<td>
<p>(character vector) The names of the arguments of <code>.f</code> that
should be allowed to accept <code><a href="#topic+rvar">rvar</a></code>s as arguments. If <code>NULL</code> (the
default), all arguments to <code>.f</code> are turned into arguments that accept
<code><a href="#topic+rvar">rvar</a></code>s, including arguments passed via <code>...</code> (if <code>rvar_dots</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="rfun_+3A_rvar_dots">rvar_dots</code></td>
<td>
<p>(logical) Should dots (<code>...</code>) arguments also be converted?
Only applies if <code>rvar_args</code> is <code>NULL</code> (i.e., all arguments are allowed to
be <code><a href="#topic+rvar">rvar</a></code>s).</p>
</td></tr>
<tr><td><code id="rfun_+3A_ndraws">ndraws</code></td>
<td>
<p>(positive integer). The number of draws used to construct new
random variables if no <code><a href="#topic+rvar">rvar</a></code>s are supplied as arguments to the
returned function. If <code>NULL</code>, <code>getOption("posterior.rvar_ndraws")</code> is used
(default <code>4000</code>). If any arguments to the returned function contain
<code><a href="#topic+rvar">rvar</a></code>s, the number of draws in the provided <code><a href="#topic+rvar">rvar</a></code>s is used instead of
the value of this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps an existing function (<code>.f</code>) such that it returns <code><a href="#topic+rvar">rvar</a></code>s containing
whatever type of data <code>.f</code> would normally return.
</p>
<p>The returned function, when called, executes <code>.f</code> possibly multiple times, once for each draw of
the <code><a href="#topic+rvar">rvar</a></code>s passed to it, then returns a new
<code><a href="#topic+rvar">rvar</a></code> representing the output of those function evaluations. If the arguments contain no <code><a href="#topic+rvar">rvar</a></code>s,
then <code>.f</code> will be executed <code>ndraws</code> times and an <code><a href="#topic+rvar">rvar</a></code> with that many draws returned.
</p>
<p>Functions created by <code>rfun()</code> are not necessarily <em>fast</em> (in fact in some cases they may be very slow), but
they have the advantage of allowing a nearly arbitrary R functions to be executed against <code><a href="#topic+rvar">rvar</a></code>s
simply by wrapping them with <code>rfun()</code>. This makes it especially useful as a prototyping
tool. If you create code with <code>rfun()</code> and it is unacceptably slow for your application,
consider rewriting it using math operations directly on <code><a href="#topic+rvar">rvar</a></code>s (which should be fast),
using <code><a href="#topic+rvar_rng">rvar_rng()</a></code>, and/or using operations directly on the arrays that back the <code><a href="#topic+rvar">rvar</a></code>s
(via <code><a href="#topic+draws_of">draws_of()</a></code>).
</p>


<h3>Value</h3>

<p>A function with the same argument specification as <code>.f</code>, but which can accept and return
<code><a href="#topic+rvar">rvar</a></code>s.
</p>


<h3>See Also</h3>

<p>Other rfun: 
<code><a href="#topic+rdo">rdo</a>()</code>,
<code><a href="#topic+rvar_rng">rvar_rng</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rvar_norm &lt;- rfun(rnorm)
rvar_gamma &lt;- rfun(rgamma)

mu &lt;- rvar_norm(10, mean = 1:10, sd = 1)
sigma &lt;- rvar_gamma(1, shape = 1, rate = 1)
x &lt;- rvar_norm(10, mu, sigma)
x

</code></pre>

<hr>
<h2 id='rhat'>Rhat convergence diagnostic</h2><span id='topic+rhat'></span><span id='topic+rhat.default'></span><span id='topic+rhat.rvar'></span>

<h3>Description</h3>

<p>Compute the Rhat convergence diagnostic for a single variable as the maximum
of rank normalized split-Rhat and rank normalized folded-split-Rhat as
proposed in Vehtari et al. (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhat(x, ...)

## Default S3 method:
rhat(x, ...)

## S3 method for class 'rvar'
rhat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhat_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rhat_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an array, returns a single numeric value. If any of the draws
is non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output
will be (numeric) <code>NA</code>. Also, if all draws within any of the chains of a
variable are the same (constant), the returned output will be (numeric) <code>NA</code>
as well. The reason for the latter is that, for constant draws, we cannot
distinguish between variables that are supposed to be constant (e.g., a
diagonal element of a correlation matrix is always 1) or variables that just
happened to be constant because of a failure of convergence or other problems
in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code>, returns an array of the same dimensions as the
<code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value that would be returned by
passing the draws array for that element of the <code><a href="#topic+rvar">rvar</a></code> to this function.
</p>


<h3>References</h3>

<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian Bürkner (2021). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of
MCMC (with discussion). <em>Bayesian Data Analysis</em>. 16(2), 667-–718.
doi:10.1214/20-BA1221
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_basic">ess_basic</a>()</code>,
<code><a href="#topic+ess_bulk">ess_bulk</a>()</code>,
<code><a href="#topic+ess_quantile">ess_quantile</a>()</code>,
<code><a href="#topic+ess_sd">ess_sd</a>()</code>,
<code><a href="#topic+ess_tail">ess_tail</a>()</code>,
<code><a href="#topic+mcse_mean">mcse_mean</a>()</code>,
<code><a href="#topic+mcse_quantile">mcse_quantile</a>()</code>,
<code><a href="#topic+mcse_sd">mcse_sd</a>()</code>,
<code><a href="#topic+rhat_basic">rhat_basic</a>()</code>,
<code><a href="#topic+rhat_nested">rhat_nested</a>()</code>,
<code><a href="#topic+rstar">rstar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
rhat(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
rhat(d$Sigma)

</code></pre>

<hr>
<h2 id='rhat_basic'>Basic version of the Rhat convergence diagnostic</h2><span id='topic+rhat_basic'></span><span id='topic+rhat_basic.default'></span><span id='topic+rhat_basic.rvar'></span>

<h3>Description</h3>

<p>Compute the basic Rhat convergence diagnostic for a single variable as
described in Gelman et al. (2013) with some changes according to Vehtari et
al. (2021). For practical applications, we strongly recommend the improved
Rhat convergence diagnostic implemented in <code><a href="#topic+rhat">rhat()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhat_basic(x, ...)

## Default S3 method:
rhat_basic(x, split = TRUE, ...)

## S3 method for class 'rvar'
rhat_basic(x, split = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhat_basic_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rhat_basic_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="rhat_basic_+3A_split">split</code></td>
<td>
<p>(logical) Should the estimate be computed on split chains? The
default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an array, returns a single numeric value. If any of the draws
is non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output
will be (numeric) <code>NA</code>. Also, if all draws within any of the chains of a
variable are the same (constant), the returned output will be (numeric) <code>NA</code>
as well. The reason for the latter is that, for constant draws, we cannot
distinguish between variables that are supposed to be constant (e.g., a
diagonal element of a correlation matrix is always 1) or variables that just
happened to be constant because of a failure of convergence or other problems
in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code>, returns an array of the same dimensions as the
<code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value that would be returned by
passing the draws array for that element of the <code><a href="#topic+rvar">rvar</a></code> to this function.
</p>


<h3>References</h3>

<p>Andrew Gelman, John B. Carlin, Hal S. Stern, David B. Dunson, Aki Vehtari and
Donald B. Rubin (2013). <em>Bayesian Data Analysis, Third Edition</em>. Chapman and
Hall/CRC.
</p>
<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian Bürkner (2021). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of
MCMC (with discussion). <em>Bayesian Data Analysis</em>. 16(2), 667-–718.
doi:10.1214/20-BA1221
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_basic">ess_basic</a>()</code>,
<code><a href="#topic+ess_bulk">ess_bulk</a>()</code>,
<code><a href="#topic+ess_quantile">ess_quantile</a>()</code>,
<code><a href="#topic+ess_sd">ess_sd</a>()</code>,
<code><a href="#topic+ess_tail">ess_tail</a>()</code>,
<code><a href="#topic+mcse_mean">mcse_mean</a>()</code>,
<code><a href="#topic+mcse_quantile">mcse_quantile</a>()</code>,
<code><a href="#topic+mcse_sd">mcse_sd</a>()</code>,
<code><a href="#topic+rhat_nested">rhat_nested</a>()</code>,
<code><a href="#topic+rhat">rhat</a>()</code>,
<code><a href="#topic+rstar">rstar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
rhat_basic(mu)

d &lt;- as_draws_rvars(example_draws("multi_normal"))
rhat_basic(d$Sigma)

</code></pre>

<hr>
<h2 id='rhat_nested'>Nested Rhat convergence diagnostic</h2><span id='topic+rhat_nested'></span><span id='topic+rhat_nested.default'></span><span id='topic+rhat_nested.rvar'></span>

<h3>Description</h3>

<p>Compute the nested Rhat convergence diagnostic for a single
variable as proposed in Margossian et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhat_nested(x, ...)

## Default S3 method:
rhat_nested(x, superchain_ids, ...)

## S3 method for class 'rvar'
rhat_nested(x, superchain_ids, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhat_nested_+3A_x">x</code></td>
<td>
<p>(multiple options) One of:
</p>

<ul>
<li><p> A matrix of draws for a single variable (iterations x chains). See
<code><a href="#topic+extract_variable_matrix">extract_variable_matrix()</a></code>.
</p>
</li>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rhat_nested_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="rhat_nested_+3A_superchain_ids">superchain_ids</code></td>
<td>
<p>(numeric) Vector of length nchains specifying
which superchain each chain belongs to. There should be equal
numbers of chains in each superchain. All chains within the same
superchain are assumed to have been initialized at the same
point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nested Rhat is a convergence diagnostic useful when
running many short chains. It is calculated on superchains, which
are groups of chains that have been initialized at the same
point.
</p>
<p>Note that there is a slight difference in the calculation of Rhat
and nested Rhat, as nested Rhat is lower bounded by 1. This means
that nested Rhat with one chain per superchain will not be
exactly equal to basic Rhat (see Footnote 1 in Margossian et
al. (2023)).
</p>


<h3>Value</h3>

<p>If the input is an array, returns a single numeric value. If any of the draws
is non-finite, that is, <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code>, the returned output
will be (numeric) <code>NA</code>. Also, if all draws within any of the chains of a
variable are the same (constant), the returned output will be (numeric) <code>NA</code>
as well. The reason for the latter is that, for constant draws, we cannot
distinguish between variables that are supposed to be constant (e.g., a
diagonal element of a correlation matrix is always 1) or variables that just
happened to be constant because of a failure of convergence or other problems
in the sampling process.
</p>
<p>If the input is an <code><a href="#topic+rvar">rvar</a></code>, returns an array of the same dimensions as the
<code><a href="#topic+rvar">rvar</a></code>, where each element is equal to the value that would be returned by
passing the draws array for that element of the <code><a href="#topic+rvar">rvar</a></code> to this function.
</p>


<h3>References</h3>

<p>Charles C. Margossian, Matthew D. Hoffman, Pavel Sountsov, Lionel
Riou-Durand, Aki Vehtari and Andrew Gelman (2023). Nested R-hat:
Assessing the convergence of Markov chain Monte Carlo when running
many short chains.  arxiv:arXiv:2110.13017 (version 4)
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_basic">ess_basic</a>()</code>,
<code><a href="#topic+ess_bulk">ess_bulk</a>()</code>,
<code><a href="#topic+ess_quantile">ess_quantile</a>()</code>,
<code><a href="#topic+ess_sd">ess_sd</a>()</code>,
<code><a href="#topic+ess_tail">ess_tail</a>()</code>,
<code><a href="#topic+mcse_mean">mcse_mean</a>()</code>,
<code><a href="#topic+mcse_quantile">mcse_quantile</a>()</code>,
<code><a href="#topic+mcse_sd">mcse_sd</a>()</code>,
<code><a href="#topic+rhat_basic">rhat_basic</a>()</code>,
<code><a href="#topic+rhat">rhat</a>()</code>,
<code><a href="#topic+rstar">rstar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- extract_variable_matrix(example_draws(), "mu")
rhat_nested(mu, superchain_ids = c(1, 1, 2, 2))

d &lt;- as_draws_rvars(example_draws("multi_normal"))
rhat_nested(d$Sigma, superchain_ids = c(1, 1, 2, 2))

</code></pre>

<hr>
<h2 id='rstar'>Calculate R* convergence diagnostic</h2><span id='topic+rstar'></span>

<h3>Description</h3>

<p>The <code>rstar()</code> function generates a measure of convergence for MCMC draws
based on whether it is possible to determine the Markov chain that generated
a draw with probability greater than chance. To do so, it fits a machine
learning classifier to a training set of MCMC draws and evaluates its
predictive accuracy on a testing set: giving the ratio of accuracy to
predicting a chain uniformly at random.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstar(
  x,
  split = TRUE,
  uncertainty = FALSE,
  method = "rf",
  hyperparameters = NULL,
  training_proportion = 0.7,
  nsimulations = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstar_+3A_x">x</code></td>
<td>
<p>(draws) A <code><a href="#topic+draws_df">draws_df</a></code> object or one coercible to a <code>draws_df</code> object.</p>
</td></tr>
<tr><td><code id="rstar_+3A_split">split</code></td>
<td>
<p>(logical) Should the estimate be computed on split chains? The
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rstar_+3A_uncertainty">uncertainty</code></td>
<td>
<p>(logical). Indicates whether to provide a vector of R*
values representing uncertainty in the calculated value (if <code>TRUE</code>) or a
single value (if <code>FALSE</code>). The default is <code>TRUE.</code></p>
</td></tr>
<tr><td><code id="rstar_+3A_method">method</code></td>
<td>
<p>(string) The machine learning classifier to use (must be
available in the <span class="pkg">caret</span> package). The default is <code>"rf"</code>, which calls
the random forest classifier.</p>
</td></tr>
<tr><td><code id="rstar_+3A_hyperparameters">hyperparameters</code></td>
<td>
<p>(named list) Hyperparameter settings passed to the classifier.
The default for the random forest classifier (<code>method = "rf"</code>) is
<code>list(mtry = floor(sqt(nvariables(x))))</code>.
The default for the gradient-based model (<code>method = "gbm"</code>) is
<code>list(interaction.depth = 3, n.trees = 50, shrinkage = 0.1, n.minobsinnode = 10)</code>.</p>
</td></tr>
<tr><td><code id="rstar_+3A_training_proportion">training_proportion</code></td>
<td>
<p>(positive real) The proportion (in <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>) of
iterations in used to train the classifier. The default is <code>0.7</code>.</p>
</td></tr>
<tr><td><code id="rstar_+3A_nsimulations">nsimulations</code></td>
<td>
<p>(positive integer) The number of R* values in the
returned vector if <code>uncertainty</code> is <code>TRUE</code>. The default is <code>1000.</code></p>
</td></tr>
<tr><td><code id="rstar_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>caret::train()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rstar()</code> function provides a measure of MCMC convergence based
on whether it is possible to determine the chain that generated a
particular draw with a probability greater than chance. To do so, it fits a
machine learning classifier to a subset of the original MCMC draws (the
training set) and evaluates its predictive accuracy on the remaining draws
(the testing set). If predictive accuracy exceeds chance (i.e. predicting
the chain that generated a draw uniformly at random), the diagnostic
measure R* will be above 1, indicating that convergence has yet to occur.
This statistic is recently developed, and it is currently unclear what is a
reasonable threshold for diagnosing convergence.
</p>
<p>The statistic, R*, is stochastic, meaning that each time the test is run,
unless the random seed is fixed, it will generally produce a different
result. To minimize the implications of this stochasticity, it is
recommended to repeatedly run this function to calculate a distribution of
R*; alternatively, an approximation to this distribution can be obtained by
setting <code>uncertainty = TRUE</code>, although this approximation of uncertainty
will generally have a lower mean.
</p>
<p>By default, a random forest classifier is used (<code>method = "rf"</code>), which tends
to perform best for target distributions of around 4 dimensions and above.
For lower dimensional targets, gradient boosted models (called via
<code>method = "gbm"</code>) tend to have a higher classification accuracy. On a given
MCMC sample, it is recommended to try both of these classifiers.
</p>


<h3>Value</h3>

<p>A numeric vector of length 1 (by default) or length <code>nsimulations</code>
(if <code>uncertainty = TRUE</code>).
</p>


<h3>References</h3>

<p>Ben Lambert, Aki Vehtari (2020) R*: A robust MCMC convergence
diagnostic with uncertainty using gradient-boosted machines.
<em>arXiv preprint</em> <code>arXiv:2003.07900</code>.
</p>


<h3>See Also</h3>

<p>Other diagnostics: 
<code><a href="#topic+ess_basic">ess_basic</a>()</code>,
<code><a href="#topic+ess_bulk">ess_bulk</a>()</code>,
<code><a href="#topic+ess_quantile">ess_quantile</a>()</code>,
<code><a href="#topic+ess_sd">ess_sd</a>()</code>,
<code><a href="#topic+ess_tail">ess_tail</a>()</code>,
<code><a href="#topic+mcse_mean">mcse_mean</a>()</code>,
<code><a href="#topic+mcse_quantile">mcse_quantile</a>()</code>,
<code><a href="#topic+mcse_sd">mcse_sd</a>()</code>,
<code><a href="#topic+rhat_basic">rhat_basic</a>()</code>,
<code><a href="#topic+rhat_nested">rhat_nested</a>()</code>,
<code><a href="#topic+rhat">rhat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("caret", quietly = TRUE) &amp;&amp; require("randomForest", quietly = TRUE)) {
  x &lt;- example_draws("eight_schools")
  print(rstar(x))
  print(rstar(x, split = FALSE))
  print(rstar(x, method = "gbm"))
  # can pass additional arguments to methods
  print(rstar(x, method = "gbm", verbose = FALSE))

  # with uncertainty, returns a vector of R* values
  hist(rstar(x, uncertainty = TRUE))
  hist(rstar(x, uncertainty = TRUE, nsimulations = 100))

  # can use other classification methods in caret library
  print(rstar(x, method = "knn"))
}

</code></pre>

<hr>
<h2 id='rvar'>Random variables of arbitrary dimension</h2><span id='topic+rvar'></span>

<h3>Description</h3>

<p>Random variables backed by arrays of arbitrary dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvar(
  x = double(),
  dim = NULL,
  dimnames = NULL,
  nchains = NULL,
  with_chains = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvar_+3A_x">x</code></td>
<td>
<p>(multiple options) The object to convert to an <code>rvar</code>:
</p>

<ul>
<li><p> A vector of draws from a distribution.
</p>
</li>
<li><p> An array where the first dimension represents draws from a distribution.
The resulting <code><a href="#topic+rvar">rvar</a></code> will have dimension <code>dim(x)[-1]</code>; that is,
everything except the first dimension is used for the shape of the
variable, and the first dimension is used to index draws from the
distribution (see <strong>Examples</strong>). Optionally,
if <code>with_chains == TRUE</code>, the first dimension indexes the iteration and the
second dimension indexes the chain (see <code>with_chains</code>).
</p>
</li>
<li><p> An <code>rvar</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rvar_+3A_dim">dim</code></td>
<td>
<p>(integer vector) One or more integers giving the maximal indices
in each dimension to override the dimensions of the <code><a href="#topic+rvar">rvar</a></code> to be created
(see <code><a href="base.html#topic+dim">dim()</a></code>). If <code>NULL</code> (the default), <code>dim</code> is determined by the input.
<strong>NOTE:</strong> This argument controls the dimensions of the <code><a href="#topic+rvar">rvar</a></code>, not the
underlying array, so you cannot change the number of draws using this
argument.</p>
</td></tr>
<tr><td><code id="rvar_+3A_dimnames">dimnames</code></td>
<td>
<p>(list) Character vectors giving the names in each dimension
to override the names of the dimensions of the <code><a href="#topic+rvar">rvar</a></code> to be created (see
<code><a href="base.html#topic+dimnames">dimnames()</a></code>). If <code>NULL</code> (the default), this is determined by the input.
<strong>NOTE:</strong> This argument controls the names of the dimensions of the
<code><a href="#topic+rvar">rvar</a></code>, not the underlying array.</p>
</td></tr>
<tr><td><code id="rvar_+3A_nchains">nchains</code></td>
<td>
<p>(positive integer) The number of chains. The if <code>NULL</code> (the default),
<code>1</code> is used unless <code>x</code> is already an <code><a href="#topic+rvar">rvar</a></code>, in which case the number of
chains it has is used.</p>
</td></tr>
<tr><td><code id="rvar_+3A_with_chains">with_chains</code></td>
<td>
<p>(logical) Does <code>x</code> include a dimension for chains?
If <code>FALSE</code> (the default), chains are not included, the first dimension of
the input array should index draws, and the <code>nchains</code> argument can be
used to determine the number of chains. If <code>TRUE</code>, the <code>nchains</code> argument
is ignored and the second dimension of <code>x</code> is used to index chains.
Internally, the array will be converted to a format without the chain index.
Ignored when <code>x</code> is already an <code><a href="#topic+rvar">rvar</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"rvar"</code> class internally represents random variables as arrays of arbitrary
dimension, where the first dimension is used to index draws from the distribution.
Most mathematical operators and functions are supported, including efficient matrix
multiplication and vector and array-style indexing. The intent is that an <code>rvar</code>
works as closely as possible to how a base vector/matrix/array does, with a few
differences:
</p>

<ul>
<li><p> The default behavior when subsetting is not to drop extra dimensions (i.e.
the default <code>drop</code> argument for <code>[</code> is <code>FALSE</code>, not <code>TRUE</code>).
</p>
</li>
<li><p> Rather than base R-style recycling, <code>rvar</code>s use a limited form of broadcasting:
if an operation is being performed on two vectors with different size of the same
dimension, the smaller vector will be recycled up to the size of the larger one
along that dimension so long as it has size 1.
</p>
</li></ul>

<p>For functions that expect base numeric arrays and for which <code>rvar</code>s cannot be
used directly as arguments, you can use <code><a href="#topic+rfun">rfun()</a></code> or <code><a href="#topic+rdo">rdo()</a></code> to translate your
code into code that executes across draws from one or more random variables
and returns a random variable as output. Typically <code><a href="#topic+rdo">rdo()</a></code> offers the most
straightforward translation.
</p>
<p>As <code><a href="#topic+rfun">rfun()</a></code> and <code><a href="#topic+rdo">rdo()</a></code> incur some performance cost, you can also operate directly
on the underlying array using the <code><a href="#topic+draws_of">draws_of()</a></code> function. To re-use existing
random number generator functions to efficiently create <code>rvar</code>s, use <code><a href="#topic+rvar_rng">rvar_rng()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"rvar"</code> representing a random variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_rvar">as_rvar()</a></code> to convert objects to <code>rvar</code>s. See <code><a href="#topic+rdo">rdo()</a></code>, <code><a href="#topic+rfun">rfun()</a></code>, and
<code><a href="#topic+rvar_rng">rvar_rng()</a></code> for higher-level interfaces for creating <code>rvar</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)

# To create a "scalar" `rvar`, pass a one-dimensional array or a vector
# whose length (here `4000`) is the desired number of draws:
x &lt;- rvar(rnorm(4000, mean = 1, sd = 1))
x

# Create random vectors by adding an additional dimension:
n &lt;- 4   # length of output vector
x &lt;- rvar(array(rnorm(4000 * n, mean = rep(1:n, each = 4000), sd = 1), dim = c(4000, n)))
x

# Create a random matrix:
rows &lt;- 4
cols &lt;- 3
x &lt;- rvar(array(rnorm(4000 * rows * cols, mean = 1, sd = 1), dim = c(4000, rows, cols)))
x

# If the input sample comes from multiple chains, we can indicate that using the
# nchains argument (here, 1000 draws each from 4 chains):
x &lt;- rvar(rnorm(4000, mean = 1, sd = 1), nchains = 4)
x

# Or if the input sample has chain information as its second dimension, we can
# use with_chains to create the rvar
x &lt;- rvar(array(rnorm(4000, mean = 1, sd = 1), dim = c(1000, 4)), with_chains = TRUE)
x

</code></pre>

<hr>
<h2 id='rvar_apply'>Random variable resulting from a function applied over margins of an array or random variable</h2><span id='topic+rvar_apply'></span>

<h3>Description</h3>

<p>Returns an <code><a href="#topic+rvar">rvar</a></code> obtained by applying a function to margins of an array or <code><a href="#topic+rvar">rvar</a></code>.
Acts like <code>apply()</code>, except that the function supplied (<code>.f</code>) should return an <code><a href="#topic+rvar">rvar</a></code>,
and the final result is always an <code><a href="#topic+rvar">rvar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvar_apply(.x, .margin, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvar_apply_+3A_.x">.x</code></td>
<td>
<p>An array or an <code><a href="#topic+rvar">rvar</a></code>.</p>
</td></tr>
<tr><td><code id="rvar_apply_+3A_.margin">.margin</code></td>
<td>
<p>(multiple options) The subscripts which the function will be applied over:
</p>

<ul>
<li><p> An integer vector. E.g., for a matrix <code>1</code> indicates rows, <code>2</code> indicates
columns, <code>c(1, 2)</code> indicates rows and columns.
</p>
</li>
<li><p> A character vector of dimension names if <code>.x</code> has named dimensions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rvar_apply_+3A_.f">.f</code></td>
<td>
<p>(function) The function to be applied. The function <code>.f</code> must
return an <code><a href="#topic+rvar">rvar</a></code> and the dimensions of the result of <code>.f</code> applied to each
margin of <code>.x</code> must be able to be broadcasted to a common shape (otherwise
the resulting <code><a href="#topic+rvar">rvar</a></code> cannot be simplified). See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="rvar_apply_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code>.f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function acts much like <code>apply()</code>, except that the function passed to it (<code>.f</code>)
must return <code><a href="#topic+rvar">rvar</a></code>s, and the result is simplified into an <code><a href="#topic+rvar">rvar</a></code>. Unlike
<code>apply()</code>, it also keeps the dimensions of the returned values along each margin,
rather than simplifying each margin to a vector, and if the results of <code>.f</code> do
not all have the same dimensions, it applies the <code><a href="#topic+rvar">rvar</a></code> broadcasting rules to
bind results together rather than using vector recycling.
</p>
<p>If you wish to apply functions over <code><a href="#topic+rvar">rvar</a></code>s where the result is not intended to
be simplified into an <code><a href="#topic+rvar">rvar</a></code>, you can use the standard <code>apply()</code>, <code>lapply()</code>,
<code>sapply()</code>, or <code>vapply()</code> functions.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+rvar">rvar</a></code>.
</p>
<p>If the result of each call to <code>.f</code> returns an <code><a href="#topic+rvar">rvar</a></code> of dimension <code>d</code> after
being broadcast to a common shape, then <code>rvar_apply()</code> returns an <code><a href="#topic+rvar">rvar</a></code> of
dimension <code>c(d, dim(.x)[.margin])</code>. If the last dimension of the result would
be <code>1</code>, it is dropped (other dimensions equal to <code>1</code> are retained). If <code>d</code> is
<code>0</code>, the result has length <code>0</code> but not necessarily the 'correct' dimension.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_rvar">as_rvar()</a></code> to convert objects to <code>rvar</code>s. See <code><a href="#topic+rdo">rdo()</a></code>, <code><a href="#topic+rfun">rfun()</a></code>, and
<code><a href="#topic+rvar_rng">rvar_rng()</a></code> for higher-level interfaces for creating <code>rvar</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(3456)
x &lt;- rvar_rng(rnorm, 24, mean = 1:24)
dim(x) &lt;- c(2,3,4)

# we can find the distributions of marginal means of the above array
# using rvar_mean along with rvar_apply
rvar_apply(x, 1, rvar_mean)
rvar_apply(x, 2:3, rvar_mean)

</code></pre>

<hr>
<h2 id='rvar_factor'>Factor random variables of arbitrary dimension</h2><span id='topic+rvar_factor'></span><span id='topic+rvar_ordered'></span>

<h3>Description</h3>

<p>Random variables backed by <a href="base.html#topic+factor">factor</a>-like arrays of arbitrary dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvar_factor(
  x = factor(),
  dim = NULL,
  dimnames = NULL,
  nchains = NULL,
  with_chains = FALSE,
  ...
)

rvar_ordered(
  x = ordered(NULL),
  dim = NULL,
  dimnames = NULL,
  nchains = NULL,
  with_chains = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvar_factor_+3A_x">x</code></td>
<td>
<p>(multiple options) The object to convert to an <code>rvar</code>:
</p>

<ul>
<li><p> A vector of draws from a distribution.
</p>
</li>
<li><p> An array where the first dimension represents draws from a distribution.
The resulting <code><a href="#topic+rvar">rvar</a></code> will have dimension <code>dim(x)[-1]</code>; that is,
everything except the first dimension is used for the shape of the
variable, and the first dimension is used to index draws from the
distribution (see <strong>Examples</strong>). Optionally,
if <code>with_chains == TRUE</code>, the first dimension indexes the iteration and the
second dimension indexes the chain (see <code>with_chains</code>).
</p>
</li>
<li><p> An <code>rvar</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rvar_factor_+3A_dim">dim</code></td>
<td>
<p>(integer vector) One or more integers giving the maximal indices
in each dimension to override the dimensions of the <code><a href="#topic+rvar">rvar</a></code> to be created
(see <code><a href="base.html#topic+dim">dim()</a></code>). If <code>NULL</code> (the default), <code>dim</code> is determined by the input.
<strong>NOTE:</strong> This argument controls the dimensions of the <code><a href="#topic+rvar">rvar</a></code>, not the
underlying array, so you cannot change the number of draws using this
argument.</p>
</td></tr>
<tr><td><code id="rvar_factor_+3A_dimnames">dimnames</code></td>
<td>
<p>(list) Character vectors giving the names in each dimension
to override the names of the dimensions of the <code><a href="#topic+rvar">rvar</a></code> to be created (see
<code><a href="base.html#topic+dimnames">dimnames()</a></code>). If <code>NULL</code> (the default), this is determined by the input.
<strong>NOTE:</strong> This argument controls the names of the dimensions of the
<code><a href="#topic+rvar">rvar</a></code>, not the underlying array.</p>
</td></tr>
<tr><td><code id="rvar_factor_+3A_nchains">nchains</code></td>
<td>
<p>(positive integer) The number of chains. The if <code>NULL</code> (the default),
<code>1</code> is used unless <code>x</code> is already an <code><a href="#topic+rvar">rvar</a></code>, in which case the number of
chains it has is used.</p>
</td></tr>
<tr><td><code id="rvar_factor_+3A_with_chains">with_chains</code></td>
<td>
<p>(logical) Does <code>x</code> include a dimension for chains?
If <code>FALSE</code> (the default), chains are not included, the first dimension of
the input array should index draws, and the <code>nchains</code> argument can be
used to determine the number of chains. If <code>TRUE</code>, the <code>nchains</code> argument
is ignored and the second dimension of <code>x</code> is used to index chains.
Internally, the array will be converted to a format without the chain index.
Ignored when <code>x</code> is already an <code><a href="#topic+rvar">rvar</a></code>.</p>
</td></tr>
<tr><td><code id="rvar_factor_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+factor">base::factor</a></code>
</p>

<dl>
<dt><code>levels</code></dt><dd><p>an optional vector of the unique values (as character strings)
that <code>x</code> might have taken.  The default is the unique set of
values taken by <code><a href="base.html#topic+as.character">as.character</a>(x)</code>, sorted into
increasing order <em>of <code>x</code></em>.  Note that this set can be
specified as smaller than <code>sort(unique(x))</code>.</p>
</dd>
<dt><code>labels</code></dt><dd><p><em>either</em> an optional character vector of
labels for the levels (in the same order as <code>levels</code> after
removing those in <code>exclude</code>), <em>or</em> a character string of
length 1.  Duplicated values in <code>labels</code> can be used to map
different values of <code>x</code> to the same factor level.</p>
</dd>
<dt><code>exclude</code></dt><dd><p>a vector of values to be excluded when forming the
set of levels.  This may be factor with the same level set as <code>x</code>
or should be a <code>character</code>.</p>
</dd>
<dt><code>ordered</code></dt><dd><p>logical flag to determine if the levels should be regarded
as ordered (in the order given).</p>
</dd>
<dt><code>nmax</code></dt><dd><p>an upper bound on the number of levels; see &lsquo;Details&rsquo;.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>A subtype of <code><a href="#topic+rvar">rvar()</a></code> that represents a (possibly multidimensional) sample of
a <a href="base.html#topic+factor">factor</a> or an <a href="base.html#topic+ordered">ordered</a> factor. It is otherwise very similar to the basic <code><a href="#topic+rvar">rvar()</a></code>:
it is backed by a multidimensional array with draws as the first dimension.
The primary difference is that the backing array has class <code>"factor"</code> (for <code><a href="#topic+rvar_factor">rvar_factor()</a></code>)
or <code>c("ordered", "factor")</code> (for <code><a href="#topic+rvar_ordered">rvar_ordered()</a></code>). If you
pass a <a href="base.html#topic+factor">factor</a> or <a href="base.html#topic+ordered">ordered</a> factor to <code><a href="#topic+rvar">rvar()</a></code> it will automatically return
an object with the classes <code>"rvar_factor"</code> or <code>c("rvar_ordered", "rvar_factor")</code>.
</p>
<p>See <code><a href="#topic+rvar">rvar()</a></code> for more details on the internals of the random variable datatype.
</p>


<h3>Value</h3>

<p>An object of class <code>"rvar_factor"</code> representing a <code>factor</code>-like random variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_rvar_factor">as_rvar_factor()</a></code> to convert objects to <code>rvar_factor</code>s. See <code><a href="#topic+rdo">rdo()</a></code>, <code><a href="#topic+rfun">rfun()</a></code>, and
<code><a href="#topic+rvar_rng">rvar_rng()</a></code> for higher-level interfaces for creating <code>rvar</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

# To create a "scalar" `rvar_factor`, pass a one-dimensional array or a vector
# whose length (here `4000`) is the desired number of draws:
x &lt;- rvar(sample(c("a","a","a","b","c"), 4000, replace = TRUE))
x

# Create random vectors by adding an additional dimension:
x_array &lt;- array(c(
    sample(c("a","a","a","b","c"), 4000, replace = TRUE),
    sample(c("a","a","b","c","c"), 4000, replace = TRUE),
    sample(c("b","b","b","b","c"), 4000, replace = TRUE),
    sample(c("d","d","b","b","c"), 4000, replace = TRUE)
  ), dim = c(4000, 4))
rvar_factor(x_array)

# You can also create ordered factors
rvar_ordered(x_array)

# arguments of factor() and ordered() are passed down by the constructor
# e.g. we can reorder levels of an ordered factor:
rvar_ordered(x_array, levels = c("d","c","b","a"))

# Unlike base factors, rvar factors can be matrices or arrays:
rvar_factor(x_array, dim = c(2, 2))

# If the input to rvar_factor() is an array with a `"levels"` attribute, it
# will use those as the levels of the factor
y_array &lt;- t(array(rbinom(3000, 1, c(0.1, 0.5, 0.9)) + 1, dim = c(3, 1000)))
rvar(y_array)
# with levels
attr(y_array, "levels") = c("a", "b")
rvar_factor(y_array)

</code></pre>

<hr>
<h2 id='rvar_ifelse'>Random variable ifelse</h2><span id='topic+rvar_ifelse'></span>

<h3>Description</h3>

<p>A version of <code>ifelse()</code> that returns an <code><a href="#topic+rvar">rvar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvar_ifelse(test, yes, no)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvar_ifelse_+3A_test">test</code></td>
<td>
<p>(logical <code><a href="#topic+rvar">rvar</a></code>, or castable to one) logical test determining
whether the value in <code>yes</code> or <code>no</code> is assigned in the corresponding position
of the result.</p>
</td></tr>
<tr><td><code id="rvar_ifelse_+3A_yes">yes</code></td>
<td>
<p>(<code><a href="#topic+rvar">rvar</a></code>, or castable to one) corresponding values assigned for
entries in <code>test</code> that are <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rvar_ifelse_+3A_no">no</code></td>
<td>
<p>(<code><a href="#topic+rvar">rvar</a></code>, or castable to one) corresponding values assigned for
entries in <code>test</code> that are <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+rvar">rvar</a></code> with the common type of <code>yes</code> and <code>no</code> (as determined by
<code>vctrs::vec_cast_common()</code>) and a shape determined by broadcasting <code>test</code>,
<code>yes</code>, and <code>no</code> to a common shape (see the section on broadcasting rules in
<code>vignette("rvar")</code>). For every element of <code>draws_of(test)</code>, the corresponding
element of <code>draws_of(yes)</code> or <code>draws_of(no)</code> is placed into the result,
depending on whether the element of <code>test</code> is <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvar(1:4)
y &lt;- rvar(5:8)

i &lt;- rvar(c(TRUE,FALSE,TRUE,FALSE))
z &lt;- rvar_ifelse(i, x, y)
z
draws_of(z)
</code></pre>

<hr>
<h2 id='rvar_is_finite'>Special value predicates for random variables</h2><span id='topic+rvar_is_finite'></span><span id='topic+rvar_is_infinite'></span><span id='topic+rvar_is_nan'></span><span id='topic+rvar_is_na'></span>

<h3>Description</h3>

<p>Compute special value predicates (checking for finite / infinite values, <code>NaN</code>, and <code>NA</code>)
on all draws within a random variable, returning a random variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvar_is_finite(x)

rvar_is_infinite(x)

rvar_is_nan(x)

rvar_is_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvar_is_finite_+3A_x">x</code></td>
<td>
<p>(rvar) An <code><a href="#topic+rvar">rvar</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions return a new <code><a href="#topic+rvar">rvar</a></code> that is the result of applying
<code>is.finite()</code>, <code>is.infinite()</code>, <code>is.nan()</code>, or <code>is.na()</code> to every draw
in the input random variable.
</p>


<h3>Value</h3>

<p>A logical <code><a href="#topic+rvar">rvar</a></code> of the same length as the input.
</p>


<h3>See Also</h3>

<p><a href="#topic+rvar-summaries-over-draws">rvar-summaries-over-draws</a> for summary functions across draws, including
implementations of <code>is.finite()</code>, <code>is.infinite()</code>, <code>is.nan()</code>, and <code>is.na()</code> for
<code>rvar</code>s.
</p>
<p>Other rvar-summaries: 
<code><a href="#topic+rvar-summaries-over-draws">rvar-summaries-over-draws</a></code>,
<code><a href="#topic+rvar-summaries-within-draws">rvar-summaries-within-draws</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rvar(c(1, Inf, -Inf, NaN, NA))
x

rvar_is_finite(x)
rvar_is_infinite(x)
rvar_is_nan(x)
rvar_is_na(x)

</code></pre>

<hr>
<h2 id='rvar_rng'>Create random variables from existing random number generators</h2><span id='topic+rvar_rng'></span>

<h3>Description</h3>

<p>Specialized alternative to <code>rdo()</code> or <code>rfun()</code> for creating <code><a href="#topic+rvar">rvar</a></code>s from
existing random-number generator functions (such as <code>rnorm()</code>, <code>rbinom()</code>, etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvar_rng(.f, n, ..., ndraws = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvar_rng_+3A_.f">.f</code></td>
<td>
<p>(function) A function (or string naming a function) representing a
random-number generating function that follows the pattern of base random
number generators (like <code>rnorm()</code>, <code>rbinom()</code>, etc). It must:
</p>

<ul>
<li><p> Have a first argument, <code>n</code>, giving the number of draws to take from the
distribution
</p>
</li>
<li><p> Have vectorized parameter arguments
</p>
</li>
<li><p> Return a single vector of length <code>n</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="rvar_rng_+3A_n">n</code></td>
<td>
<p>(positive integer) The length of the output <code><a href="#topic+rvar">rvar</a></code> vector (<strong>not</strong>
the number of draws).</p>
</td></tr>
<tr><td><code id="rvar_rng_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>.f</code>. These arguments may include <code><a href="#topic+rvar">rvar</a></code>s,
so long as they are vectors only (no multidimensional <code><a href="#topic+rvar">rvar</a></code>s are
allowed).</p>
</td></tr>
<tr><td><code id="rvar_rng_+3A_ndraws">ndraws</code></td>
<td>
<p>(positive integer) The number of draws used to construct the
returned random variable if no <code><a href="#topic+rvar">rvar</a></code>s are supplied in <code>...</code>. If <code>NULL</code>,
<code>getOption("posterior.rvar_ndraws")</code> is used (default 4000). If <code>...</code>
contains <code><a href="#topic+rvar">rvar</a></code>s, the number of draws in the provided <code><a href="#topic+rvar">rvar</a></code>s is used
instead of the value of this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function unwraps the arrays underlying the input <code><a href="#topic+rvar">rvar</a></code>s in
<code>...</code> and then passes them to <code>.f</code>, relying on the vectorization of <code>.f</code>
to evaluate it across draws from the input <code><a href="#topic+rvar">rvar</a></code>s. This is why the arguments
of <code>.f</code> <strong>must</strong> be vectorized. It asks for <code>n</code> times the number of draws
in the input <code><a href="#topic+rvar">rvar</a></code>s (or <code>ndraws</code> if none are given) draws from the
random number generator <code>.f</code>, then reshapes the output from <code>.f</code> into an
<code><a href="#topic+rvar">rvar</a></code> with length <code>n</code>.
</p>
<p><code>rvar_rng()</code> is a fast alternative to <code>rdo()</code> or <code>rfun()</code>, but you <strong>must</strong>
ensure that <code>.f</code> satisfies the preconditions described above for the result
to be correct. Most base random number generators satisfy these conditions.
It is advisable to test against <code>rdo()</code> or <code>rfun()</code> (which should be correct,
but slower) if you are uncertain.
</p>


<h3>Value</h3>

<p>A single-dimensional <code><a href="#topic+rvar">rvar</a></code> of length <code>n</code>.
</p>


<h3>See Also</h3>

<p>Other rfun: 
<code><a href="#topic+rdo">rdo</a>()</code>,
<code><a href="#topic+rfun">rfun</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mu &lt;- rvar_rng(rnorm, 10, mean = 1:10, sd = 1)
sigma &lt;- rvar_rng(rgamma, 1, shape = 1, rate = 1)
x &lt;- rvar_rng(rnorm, 10, mu, sigma)
x

</code></pre>

<hr>
<h2 id='rvar-dist'>Density, CDF, and quantile functions of random variables</h2><span id='topic+rvar-dist'></span><span id='topic+density.rvar'></span><span id='topic+density.rvar_factor'></span><span id='topic+cdf.rvar'></span><span id='topic+cdf.rvar_factor'></span><span id='topic+cdf.rvar_ordered'></span><span id='topic+quantile.rvar'></span><span id='topic+quantile.rvar_factor'></span><span id='topic+quantile.rvar_ordered'></span>

<h3>Description</h3>

<p>The probability density function (<code>density()</code>), cumulative distribution
function (<code>cdf()</code>), and quantile function / inverse CDF (<code>quantile()</code>) of
an <code><a href="#topic+rvar">rvar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rvar'
density(x, at, ...)

## S3 method for class 'rvar_factor'
density(x, at, ...)

## S3 method for class 'rvar'
cdf(x, q, ...)

## S3 method for class 'rvar_factor'
cdf(x, q, ...)

## S3 method for class 'rvar_ordered'
cdf(x, q, ...)

## S3 method for class 'rvar'
quantile(x, probs, ...)

## S3 method for class 'rvar_factor'
quantile(x, probs, ...)

## S3 method for class 'rvar_ordered'
quantile(x, probs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvar-dist_+3A_x">x</code></td>
<td>
<p>(rvar) An <code><a href="#topic+rvar">rvar</a></code> object.</p>
</td></tr>
<tr><td><code id="rvar-dist_+3A_...">...</code></td>
<td>
<p>Additional arguments passed onto underlying methods:
</p>

<ul>
<li><p> For <code>density()</code>, these are passed to <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li><p> For <code>cdf()</code>, these are ignored.
</p>
</li>
<li><p> For <code>quantile()</code>, these are passed to <code><a href="stats.html#topic+quantile">stats::quantile()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rvar-dist_+3A_q">q</code>, <code id="rvar-dist_+3A_at">at</code></td>
<td>
<p>(numeric vector) One or more quantiles.</p>
</td></tr>
<tr><td><code id="rvar-dist_+3A_probs">probs</code></td>
<td>
<p>(numeric vector) One or more probabilities in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a scalar <code><a href="#topic+rvar">rvar</a></code>, returns a vector of the same length as the input
(<code>q</code>, <code>at</code>, or <code>probs</code>) containing values from the corresponding function
of the given <code><a href="#topic+rvar">rvar</a></code>.
</p>
<p>If <code>x</code> has length greater than 1, returns an array with dimensions
<code>c(length(y), dim(x))</code> where <code>y</code> is <code>q</code>, <code>at</code>, or <code>probs</code>, where each
<code>result[i,...]</code> is the value of the corresponding function,<code>f(y[i])</code>, for
the corresponding cell in the input array, <code>x[...]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
x = rvar(rnorm(100))

density(x, seq(-2, 2, length.out = 10))
cdf(x, seq(-2, 2, length.out = 10))
quantile(x, ppoints(10))

x2 = c(rvar(rnorm(100, mean = -0.5)), rvar(rnorm(100, mean = 0.5)))
density(x2, seq(-2, 2, length.out = 10))
cdf(x2, seq(-2, 2, length.out = 10))
quantile(x2, ppoints(10))

</code></pre>

<hr>
<h2 id='rvar-matmult'>Matrix multiplication of random variables</h2><span id='topic+rvar-matmult'></span><span id='topic++25+2A+2A+25'></span>

<h3>Description</h3>

<p>Matrix multiplication of random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %**% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvar-matmult_+3A_x">x</code></td>
<td>
<p>(multiple options) The object to be postmultiplied by <code>y</code>:
</p>

<ul>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>
</p>
</li>
<li><p> A <code><a href="base.html#topic+numeric">numeric</a></code> vector or matrix
</p>
</li>
<li><p> A <code><a href="base.html#topic+logical">logical</a></code> vector or matrix
</p>
</li></ul>

<p>If a vector is used, it is treated as a <em>row</em> vector.</p>
</td></tr>
<tr><td><code id="rvar-matmult_+3A_y">y</code></td>
<td>
<p>(multiple options) The object to be premultiplied by <code>x</code>:
</p>

<ul>
<li><p> An <code><a href="#topic+rvar">rvar</a></code>
</p>
</li>
<li><p> A <code><a href="base.html#topic+numeric">numeric</a></code> vector or matrix
</p>
</li>
<li><p> A <code><a href="base.html#topic+logical">logical</a></code> vector or matrix
</p>
</li></ul>

<p>If a vector is used, it is treated as a <em>column</em> vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> or <code>y</code> are vectors, they are converted into matrices prior to multiplication, with <code>x</code>
converted to a row vector and <code>y</code> to a column vector. Numerics and logicals can be multiplied
by <code><a href="#topic+rvar">rvar</a></code>s and are broadcasted across all draws of the <code><a href="#topic+rvar">rvar</a></code> argument. Tensor multiplication
is used to efficiently multiply matrices across draws, so if either <code>x</code> or <code>y</code> is an <code><a href="#topic+rvar">rvar</a></code>,
<code>x %**% y</code> will be much faster than <code>rdo(x %*% y)</code>.
</p>
<p>Because <code><a href="#topic+rvar">rvar</a></code> is an S3 class and S3 classes cannot properly override <code>%*%</code>, <code><a href="#topic+rvar">rvar</a></code>s use
<code style="white-space: pre;">&#8288;%**%&#8288;</code> for matrix multiplication.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+rvar">rvar</a></code> representing the matrix product of <code>x</code> and <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# d has mu (mean vector of length 3) and Sigma (3x3 covariance matrix)
d &lt;- as_draws_rvars(example_draws("multi_normal"))
d$Sigma

# trivial example: multiplication by a non-random matrix
d$Sigma %**% diag(1:3)

# Decompose Sigma into R s.t. R'R = Sigma ...
R &lt;- chol(d$Sigma)
# ... and recreate Sigma using matrix multiplication
t(R) %**% R

</code></pre>

<hr>
<h2 id='rvar-slice'>Random variable slicing</h2><span id='topic+rvar-slice'></span><span id='topic++5B+5B.rvar'></span><span id='topic++5B+5B+3C-.rvar'></span><span id='topic++5B.rvar'></span><span id='topic++5B+3C-.rvar'></span>

<h3>Description</h3>

<p>Operations for slicing <code><a href="#topic+rvar">rvar</a></code>s and replacing parts of <code><a href="#topic+rvar">rvar</a></code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rvar'
x[[i, ...]]

## S3 replacement method for class 'rvar'
x[[i, ...]] &lt;- value

## S3 method for class 'rvar'
x[..., drop = FALSE]

## S3 replacement method for class 'rvar'
x[i, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvar-slice_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+rvar">rvar</a></code>.</p>
</td></tr>
<tr><td><code id="rvar-slice_+3A_i">i</code>, <code id="rvar-slice_+3A_...">...</code></td>
<td>
<p>indices; see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="rvar-slice_+3A_value">value</code></td>
<td>
<p>(<code>rvar</code> or coercable to <code>rvar</code>) Value to insert into
<code>x</code> at the location determined by the indices.</p>
</td></tr>
<tr><td><code id="rvar-slice_+3A_drop">drop</code></td>
<td>
<p>(logical) Should singular dimensions be dropped when slicing
array <code><a href="#topic+rvar">rvar</a></code>s? Unlike base array slicing operations, defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+rvar">rvar</a></code> slicing operators (<code>[</code> and <code>[[</code>) attempt to implement the same
semantics as the <a href="base.html#topic+Extract">base array slicing operators</a>. There are some
exceptions; most notably, <code><a href="#topic+rvar">rvar</a></code> slicing defaults to <code>drop = FALSE</code> instead
of <code>drop = TRUE</code>.
</p>


<h3>Extracting or replacing single elements with <code>[[</code></h3>

<p>The <code>[[</code> operator extracts (or replaces) single elements. It always
returns (or replaces) a scalar (length-1) <code><a href="#topic+rvar">rvar</a></code>.
</p>
<p>The <code>x[[i,...]]</code> operator can be used as follows:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;x[[&lt;numeric&gt;]]&#8288;</code> for scalar numeric <code>i</code>: gives the <code>i</code>th element of <code>x</code>. If <code>x</code> is
multidimensional (i.e. <code>length(dim(x)) &gt; 1</code>), extra dimensions are ignored
when indexing. For example, if <code>x</code> is a <code class="reqn">6 \times 2</code> <code><a href="#topic+rvar">rvar</a></code> array, the
7th element, <code>x[[7]]</code>, will be the first element of the second column, <code>x[1,2]</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;x[[&lt;numeric rvar&gt;]]&#8288;</code> for scalar numeric <code><a href="#topic+rvar">rvar</a></code> <code>i</code>: a generalization of indexing when
<code>i</code> is a scalar numeric. Within each draw of <code>x</code>, selects the element
corresponding to the value of <code>i</code> within that same draw.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;x[[&lt;character&gt;]]&#8288;</code> for scalar character <code>i</code>: gives the element of <code>x</code> with name
equal to <code>i</code>. <strong>Unlike with base arrays</strong>, does not work with
multidimensional <code><a href="#topic+rvar">rvar</a></code>s.
</p>
</li>
<li> <p><code>x[[i_1,i_2,...,i_n]]</code> for scalar numeric or character <code>i_1</code>, <code>i_2</code>, etc.
Must provide exactly the same number of indices as dimensions in <code>x</code>. Selects
the element at the corresponding position in the <code><a href="#topic+rvar">rvar</a></code> by number and/or
dimname (as a string).
</p>
</li></ul>



<h3>Extracting or replacing multiple elements with <code>[</code></h3>

<p>The <code>[</code> operator extracts (or replaces) multiple elements. It always returns
(or replaces) a possibly-multidimensional <code><a href="#topic+rvar">rvar</a></code>.
</p>
<p>The <code>x[i,...]</code> operator can be used as follows:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;x[&lt;logical&gt;]&#8288;</code> for vector logical <code>i</code>: <code>i</code> is recycled to the same length as <code>x</code>,
ignoring multiple dimensions in <code>x</code>, then an <code><a href="#topic+rvar">rvar</a></code> vector is returned
containing the elements in <code>x</code> where <code>i</code> is <code>TRUE</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;x[&lt;logical rvar&gt;]&#8288;</code> for scalar logical <code><a href="#topic+rvar">rvar</a></code> <code>i</code>: returns an <code><a href="#topic+rvar">rvar</a></code> the same shape
as <code>x</code> containing only those draws where <code>i</code> is <code>TRUE</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;x[&lt;numeric&gt;]&#8288;</code> for vector numeric <code>i</code>: an <code><a href="#topic+rvar">rvar</a></code> vector is returned
containing the <code>i</code>th elements of <code>x</code>, ignoring dimensions.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;x[&lt;matrix&gt;]&#8288;</code> for numeric matrix <code>i</code>, where <code>ncol(i) == length(dim(x))</code>: each row
of <code>i</code> should give the multidimensional index for a single element in <code>x</code>. The
result is an <code><a href="#topic+rvar">rvar</a></code> vector of length <code>nrow(i)</code> containing elements of <code>x</code>
selected by each row of <code>i</code>.
</p>
</li>
<li> <p><code>x[i_1,i_2,...,i_n]</code> for vector numeric, character, or logical <code>i_1</code>,
<code>i_2</code>, etc. Returns a slice of <code>x</code> containing all elements from the dimensions
specified in <code>i_1</code>, <code>i_2</code>, etc. If an argument is left empty, all elements
from that dimension are included. Unlike base arrays, trailing dimensions
can be omitted entirely and will still be selected; for example, if <code>x</code> has
three dimensions, both <code>x[1,,]</code> and <code>x[1,]</code> can be used to create a
slice that includes all elements from the last two dimensions. Unlike base
arrays, <code>[</code> defaults to <code>drop = FALSE</code>, so results retain the same number of
dimensions as <code>x</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvar(array(1:24, dim = c(4,2,3)))
dimnames(x) &lt;- list(c("a","b"), c("d","e","f"))
x

## Slicing single elements
# x[[&lt;numeric&gt;]]
x[[2]]

# x[[&lt;numeric rvar&gt;]]
# notice the draws of x[1:4]...
draws_of(x[1:4])
x[[rvar(c(1,3,4,4))]]
# ... x[[rvar(c(1,3,4,4))]] creates a mixures of those draws
draws_of(x[[rvar(c(1,3,4,4))]])

# x[[i_1,i_2,...]]
x[[2,"e"]]


## Slicing multiple elements
# x[&lt;logical&gt;]
x[c(TRUE,TRUE,FALSE)]

# x[&lt;logical rvar&gt;]
# select every other draw
x[rvar(c(TRUE,FALSE,TRUE,FALSE))]

# x[&lt;numeric&gt;]
x[1:3]

# x[&lt;matrix&gt;]
x[rbind(
  c(1,2),
  c(1,3),
  c(2,2)
)]

# x[i_1,i_2,...,i_n]
x[1,]
x[1,2:3]
x[,2:3]
</code></pre>

<hr>
<h2 id='rvar-summaries-over-draws'>Summaries of random variables within array elements, over draws</h2><span id='topic+rvar-summaries-over-draws'></span><span id='topic+E'></span><span id='topic+mean.rvar'></span><span id='topic+Pr'></span><span id='topic+Pr.default'></span><span id='topic+Pr.logical'></span><span id='topic+Pr.rvar'></span><span id='topic+median.rvar'></span><span id='topic+min.rvar'></span><span id='topic+max.rvar'></span><span id='topic+sum.rvar'></span><span id='topic+prod.rvar'></span><span id='topic+all.rvar'></span><span id='topic+any.rvar'></span><span id='topic+Summary.rvar'></span><span id='topic+variance.rvar'></span><span id='topic+var'></span><span id='topic+var.default'></span><span id='topic+var.rvar'></span><span id='topic+sd'></span><span id='topic+sd.default'></span><span id='topic+sd.rvar'></span><span id='topic+mad'></span><span id='topic+mad.default'></span><span id='topic+mad.rvar'></span><span id='topic+mad.rvar_ordered'></span><span id='topic+range.rvar'></span><span id='topic+is.finite.rvar'></span><span id='topic+is.infinite.rvar'></span><span id='topic+is.nan.rvar'></span><span id='topic+is.na.rvar'></span>

<h3>Description</h3>

<p>Compute summaries within elements of an <code><a href="#topic+rvar">rvar</a></code> and over draws of each element,
producing an array of the same shape as the input random variable (except in
the case of <code>range()</code>, see <strong>Details</strong>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E(x, ...)

## S3 method for class 'rvar'
mean(x, ...)

Pr(x, ...)

## Default S3 method:
Pr(x, ...)

## S3 method for class 'logical'
Pr(x, ...)

## S3 method for class 'rvar'
Pr(x, ...)

## S3 method for class 'rvar'
median(x, ...)

## S3 method for class 'rvar'
min(x, ...)

## S3 method for class 'rvar'
max(x, ...)

## S3 method for class 'rvar'
sum(x, ...)

## S3 method for class 'rvar'
prod(x, ...)

## S3 method for class 'rvar'
all(x, ...)

## S3 method for class 'rvar'
any(x, ...)

## S3 method for class 'rvar'
Summary(...)

## S3 method for class 'rvar'
variance(x, ...)

var(x, ...)

## Default S3 method:
var(x, ...)

## S3 method for class 'rvar'
var(x, ...)

sd(x, ...)

## Default S3 method:
sd(x, ...)

## S3 method for class 'rvar'
sd(x, ...)

mad(x, ...)

## Default S3 method:
mad(x, ...)

## S3 method for class 'rvar'
mad(x, ...)

## S3 method for class 'rvar_ordered'
mad(x, ...)

## S3 method for class 'rvar'
range(x, ...)

## S3 method for class 'rvar'
is.finite(x)

## S3 method for class 'rvar'
is.infinite(x)

## S3 method for class 'rvar'
is.nan(x)

## S3 method for class 'rvar'
is.na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvar-summaries-over-draws_+3A_x">x</code></td>
<td>
<p>(rvar) An <code><a href="#topic+rvar">rvar</a></code>.</p>
</td></tr>
<tr><td><code id="rvar-summaries-over-draws_+3A_...">...</code></td>
<td>
<p>Further arguments passed to underlying functions (e.g.,
<code>base::mean()</code> or <code>base::median()</code>), such as <code>na.rm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summaries include expectations (<code>E()</code> or <code>mean()</code>), probabilities (<code>Pr()</code>),
medians (<code>median()</code>), spread (<code>var()</code>, <code>variance()</code>, <code>sd()</code>, <code>mad()</code>), sums and
products (<code>sum()</code>, <code>prod()</code>), extrema and ranges (<code>min()</code>, <code>max()</code>, <code>range()</code>),
logical summaries (<code>all()</code>, <code>any()</code>), and special value predicates (<code>is.finite()</code>,
<code>is.infinite()</code>, <code>is.nan()</code>, <code>is.na()</code>).
</p>
<p>Unless otherwise stated, these functions return a numeric array with the same shape
(same dimensions) as the input <code><a href="#topic+rvar">rvar</a></code>, <code>x</code>.
</p>
<p><code>range(x)</code> returns an array with dimensions <code>c(2, dim(x))</code>, where the last
dimension contains the minimum and maximum values.
</p>
<p><code>is.infinite(x)</code>, <code>is.nan(x)</code>, and <code>is.na(x)</code> return logical arrays, where each
element is <code>TRUE</code> if <strong>any</strong> draws in its corresponding element in <code>x</code> match
the predicate. Each elements in the result of <code>is.finite(x)</code> is <code>TRUE</code> if
<strong>all</strong> draws in the corresponding element in <code>x</code> are finite.
</p>
<p>Both <code>E()</code>, <code>mean()</code>, and <code>Pr()</code> return the means of each element in the input.
<code>Pr()</code> additionally checks that the provided <code><a href="#topic+rvar">rvar</a></code>
is a logical variable (hence, taking its expectation results in a probability).
</p>
<p>For consistency, <code>E()</code> and <code>Pr()</code> are also defined for base arrays so that
they can be used as summary functions in <code>summarise_draws()</code>.
</p>


<h3>Value</h3>

<p>A numeric or logical vector with the same dimensions as the given random variable, where
each entry in the vector is the mean, median, or variance of the corresponding entry in <code>x</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+rvar-summaries-within-draws">rvar-summaries-within-draws</a> for summary functions within draws.
<a href="#topic+rvar-dist">rvar-dist</a> for density, CDF, and quantile functions of random variables.
</p>
<p>Other rvar-summaries: 
<code><a href="#topic+rvar-summaries-within-draws">rvar-summaries-within-draws</a></code>,
<code><a href="#topic+rvar_is_finite">rvar_is_finite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(5678)
x = rvar_rng(rnorm, 4, mean = 1:4, sd = 2)

# These should all be ~= c(1, 2, 3, 4)
E(x)
mean(x)
median(x)

# This ...
Pr(x &lt; 1.5)
# ... should be about the same as this:
pnorm(1.5, mean = 1:4, sd = 2)

</code></pre>

<hr>
<h2 id='rvar-summaries-within-draws'>Summaries of random variables over array elements, within draws</h2><span id='topic+rvar-summaries-within-draws'></span><span id='topic+rvar_mean'></span><span id='topic+rvar_median'></span><span id='topic+rvar_sum'></span><span id='topic+rvar_prod'></span><span id='topic+rvar_min'></span><span id='topic+rvar_max'></span><span id='topic+rvar_sd'></span><span id='topic+rvar_var'></span><span id='topic+rvar_mad'></span><span id='topic+rvar_range'></span><span id='topic+rvar_quantile'></span><span id='topic+rvar_all'></span><span id='topic+rvar_any'></span>

<h3>Description</h3>

<p>Compute summaries of random variables over array elements and within draws,
producing a new random variable of length 1 (except in the case of
<code>rvar_range()</code>, see <strong>Details</strong>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvar_mean(..., na.rm = FALSE)

rvar_median(..., na.rm = FALSE)

rvar_sum(..., na.rm = FALSE)

rvar_prod(..., na.rm = FALSE)

rvar_min(..., na.rm = FALSE)

rvar_max(..., na.rm = FALSE)

rvar_sd(..., na.rm = FALSE)

rvar_var(..., na.rm = FALSE)

rvar_mad(..., constant = 1.4826, na.rm = FALSE)

rvar_range(..., na.rm = FALSE)

rvar_quantile(..., probs, names = FALSE, na.rm = FALSE)

rvar_all(..., na.rm = FALSE)

rvar_any(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvar-summaries-within-draws_+3A_...">...</code></td>
<td>
<p>(rvar) One or more <code><a href="#topic+rvar">rvar</a></code>s.</p>
</td></tr>
<tr><td><code id="rvar-summaries-within-draws_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) Should <code>NA</code>s be removed from the input before
summaries are computed? The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rvar-summaries-within-draws_+3A_constant">constant</code></td>
<td>
<p>(scalar real) For <code>rvar_mad()</code>, a scale factor for computing
the median absolute deviation. See the details of <code>stats::mad()</code> for the
justification for the default value.</p>
</td></tr>
<tr><td><code id="rvar-summaries-within-draws_+3A_probs">probs</code></td>
<td>
<p>(numeric vector) For <code>rvar_quantile()</code>, probabilities in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="rvar-summaries-within-draws_+3A_names">names</code></td>
<td>
<p>(logical) For <code>rvar_quantile()</code>, if <code>TRUE</code>, the result has a
<code>names</code> attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions compute statistics within each draw of the random variable.
For summaries over draws (such as expectations), see <a href="#topic+rvar-summaries-over-draws">rvar-summaries-over-draws</a>.
</p>
<p>Each function defined here corresponds to the base function of the same name
without the <code>rvar_</code> prefix (e.g., <code>rvar_mean()</code> calls <code>mean()</code> under the hood, etc).
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+rvar">rvar</a></code> of length 1 (for <code>range()</code>, length 2; for <code>quantile()</code>, length
equal to <code>length(probs)</code>) with the same number
of draws as the input rvar(s) containing the summary statistic computed within
each draw of the input rvar(s).
</p>


<h3>See Also</h3>

<p><a href="#topic+rvar-summaries-over-draws">rvar-summaries-over-draws</a> for summary functions across draws (e.g. expectations).
<a href="#topic+rvar-dist">rvar-dist</a> for density, CDF, and quantile functions of random variables.
</p>
<p>Other rvar-summaries: 
<code><a href="#topic+rvar-summaries-over-draws">rvar-summaries-over-draws</a></code>,
<code><a href="#topic+rvar_is_finite">rvar_is_finite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(5678)
x = rvar_rng(rnorm, 4, mean = 1:4, sd = 2)

# These will give similar results to mean(1:4),
# median(1:4), sum(1:4), prod(1:4), etc
rvar_mean(x)
rvar_median(x)
rvar_sum(x)
rvar_prod(x)
rvar_range(x)
rvar_quantile(x, probs = c(0.25, 0.5, 0.75), names = TRUE)

</code></pre>

<hr>
<h2 id='set_variables'>Set variable names in <code>draws</code> objects</h2><span id='topic+set_variables'></span>

<h3>Description</h3>

<p>Set variable names for all variables in a <code><a href="#topic+draws">draws</a></code> object. Useful
when using pipe operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_variables(x, variables, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_variables_+3A_x">x</code></td>
<td>
<p>(draws) A <code><a href="#topic+draws">draws</a></code> object.</p>
</td></tr>
<tr><td><code id="set_variables_+3A_variables">variables</code></td>
<td>
<p>(character) new variable names.</p>
</td></tr>
<tr><td><code id="set_variables_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+draws">draws</a></code> object of the same format as <code>x</code>, with
variables named as specified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variables">variables</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_draws(matrix(rnorm(100), ncol = 2))
variables(x)

x &lt;- set_variables(x, c("theta[1]", "theta[2]"))
variables(x)

# this is equivalent to
variables(x) &lt;- c("theta[1]", "theta[2]")
variables(x)

</code></pre>

<hr>
<h2 id='split_chains'>Split Chains</h2><span id='topic+split_chains'></span>

<h3>Description</h3>

<p>Split chains by halving the number of iterations per chain and doubling the
number of chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_chains(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_chains_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="split_chains_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_draws()
niterations(x)
nchains(x)

x &lt;- split_chains(x)
niterations(x)
nchains(x)

</code></pre>

<hr>
<h2 id='subset_draws'>Subset <code>draws</code> objects</h2><span id='topic+subset_draws'></span><span id='topic+subset_draws.draws_matrix'></span><span id='topic+subset_draws.draws_array'></span><span id='topic+subset_draws.draws_df'></span><span id='topic+subset_draws.draws_list'></span><span id='topic+subset_draws.draws_rvars'></span><span id='topic+subset_draws.rvar'></span><span id='topic+subset.draws'></span>

<h3>Description</h3>

<p>Subset <code><a href="#topic+draws">draws</a></code> objects by variables, iterations, chains, and draws indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_draws(x, ...)

## S3 method for class 'draws_matrix'
subset_draws(
  x,
  variable = NULL,
  iteration = NULL,
  chain = NULL,
  draw = NULL,
  regex = FALSE,
  unique = TRUE,
  ...
)

## S3 method for class 'draws_array'
subset_draws(
  x,
  variable = NULL,
  iteration = NULL,
  chain = NULL,
  draw = NULL,
  regex = FALSE,
  unique = TRUE,
  ...
)

## S3 method for class 'draws_df'
subset_draws(
  x,
  variable = NULL,
  iteration = NULL,
  chain = NULL,
  draw = NULL,
  regex = FALSE,
  unique = TRUE,
  ...
)

## S3 method for class 'draws_list'
subset_draws(
  x,
  variable = NULL,
  iteration = NULL,
  chain = NULL,
  draw = NULL,
  regex = FALSE,
  unique = TRUE,
  ...
)

## S3 method for class 'draws_rvars'
subset_draws(
  x,
  variable = NULL,
  iteration = NULL,
  chain = NULL,
  draw = NULL,
  regex = FALSE,
  unique = TRUE,
  ...
)

## S3 method for class 'rvar'
subset_draws(x, variable = NULL, ...)

## S3 method for class 'draws'
subset(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_draws_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="subset_draws_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="subset_draws_+3A_variable">variable</code></td>
<td>
<p>(character vector) The variables to select. All elements of
non-scalar variables can be selected at once.</p>
</td></tr>
<tr><td><code id="subset_draws_+3A_iteration">iteration</code></td>
<td>
<p>(integer vector) The iteration indices to select.</p>
</td></tr>
<tr><td><code id="subset_draws_+3A_chain">chain</code></td>
<td>
<p>(integer vector) The chain indices to select.</p>
</td></tr>
<tr><td><code id="subset_draws_+3A_draw">draw</code></td>
<td>
<p>(integer vector) The draw indices to be select. Subsetting draw
indices will lead to an automatic merging of chains via <code><a href="#topic+merge_chains">merge_chains</a></code>.</p>
</td></tr>
<tr><td><code id="subset_draws_+3A_regex">regex</code></td>
<td>
<p>(logical) Should <code>variable</code> should be treated as a
(vector of) regular expressions? Any variable in <code>x</code> matching at least one
of the regular expressions will be selected. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="subset_draws_+3A_unique">unique</code></td>
<td>
<p>(logical) Should duplicated selection of chains, iterations, or
draws be allowed? If <code>TRUE</code> (the default) only unique chains, iterations,
and draws are selected regardless of how often they appear in the
respective selecting arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To ensure that multiple consecutive subsetting operations work correctly,
<code>subset()</code> <em><a href="#topic+repair_draws">repairs</a></em> the <code>draws</code> object before and after
subsetting.
</p>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_draws()
subset_draws(x, variable = c("mu", "tau"))
subset_draws(x, chain = 2)
subset_draws(x, iteration = 5:10, chain = 3:4)

# extract the first chain twice
subset_draws(x, chain = c(1, 1), unique = FALSE)

# extract all elements of 'theta'
subset_draws(x, variable = "theta")

</code></pre>

<hr>
<h2 id='thin_draws'>Thin <code>draws</code> objects</h2><span id='topic+thin_draws'></span><span id='topic+thin'></span><span id='topic+thin_draws.draws'></span><span id='topic+thin_draws.rvar'></span>

<h3>Description</h3>

<p>Thin <code><a href="#topic+draws">draws</a></code> objects to reduce their size and autocorrelation in the chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin_draws(x, thin, ...)

## S3 method for class 'draws'
thin_draws(x, thin, ...)

## S3 method for class 'rvar'
thin_draws(x, thin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin_draws_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="thin_draws_+3A_thin">thin</code></td>
<td>
<p>(positive integer) The period for selecting draws.</p>
</td></tr>
<tr><td><code id="thin_draws_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_draws()
niterations(x)

x &lt;- thin_draws(x, thin = 5)
niterations(x)

</code></pre>

<hr>
<h2 id='u_scale'>Rank uniformization</h2><span id='topic+u_scale'></span>

<h3>Description</h3>

<p>Compute rank uniformization for a numeric array. First replace each value by
its rank. Average rank for ties are used to conserve the number of unique
values of discrete quantities. Second, uniformize ranks to the scale
<code style="white-space: pre;">&#8288;[1/(2S), 1-1/(2S)]&#8288;</code>, where <code>S</code> is the number of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u_scale(x, c = 3/8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u_scale_+3A_x">x</code></td>
<td>
<p>(numeric) A scalar, vector, matrix, or array of values.</p>
</td></tr>
<tr><td><code id="u_scale_+3A_c">c</code></td>
<td>
<p>(numeric) Fractional offset used in the back-transformation of ranks.
Defaults to <code>3/8</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric array of uniformized values with the same size
and dimension as the input.
</p>

<hr>
<h2 id='weight_draws'>Weight <code>draws</code> objects</h2><span id='topic+weight_draws'></span><span id='topic+weight_draws.draws_matrix'></span><span id='topic+weight_draws.draws_array'></span><span id='topic+weight_draws.draws_df'></span><span id='topic+weight_draws.draws_list'></span><span id='topic+weight_draws.draws_rvars'></span>

<h3>Description</h3>

<p>Add weights to <code><a href="#topic+draws">draws</a></code> objects, with one weight per draw, for use in
subsequent weighting operations. For reasons of numerical accuracy, weights
are stored in the form of unnormalized log-weights (in a variable called
<code>.log_weight</code>). See <code><a href="#topic+weights.draws">weights.draws()</a></code> for details how to extract weights from
<code>draws</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_draws(x, weights, ...)

## S3 method for class 'draws_matrix'
weight_draws(x, weights, log = FALSE, ...)

## S3 method for class 'draws_array'
weight_draws(x, weights, log = FALSE, ...)

## S3 method for class 'draws_df'
weight_draws(x, weights, log = FALSE, ...)

## S3 method for class 'draws_list'
weight_draws(x, weights, log = FALSE, ...)

## S3 method for class 'draws_rvars'
weight_draws(x, weights, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_draws_+3A_x">x</code></td>
<td>
<p>(draws) A <code>draws</code> object or another <span class="rlang"><b>R</b></span> object for which the method
is defined.</p>
</td></tr>
<tr><td><code id="weight_draws_+3A_weights">weights</code></td>
<td>
<p>(numeric vector) A vector of weights of length <code>ndraws(x)</code>.
Weights will be internally stored on the log scale (in a variable called
<code>.log_weight</code>) and will not be normalized, but normalized (non-log) weights
can be returned via the <code><a href="#topic+weights.draws">weights.draws()</a></code> method later.</p>
</td></tr>
<tr><td><code id="weight_draws_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="weight_draws_+3A_log">log</code></td>
<td>
<p>(logicla) Are the weights passed already on the log scale? The
default is <code>FALSE</code>, that is, expecting <code>weights</code> to be on the standard
(non-log) scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> object of the same class as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weights.draws">weights.draws()</a></code>, <code><a href="#topic+resample_draws">resample_draws()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_draws()

# sample some random weights for illustration
wts &lt;- rexp(ndraws(x))
head(wts)

# add weights
x &lt;- weight_draws(x, weights = wts)

# extract weights
head(weights(x)) # defaults to normalized weights
head(weights(x, normalize=FALSE)) # recover original weights
head(weights(x, log=TRUE)) # get normalized log-weights

# add weights which are already on the log scale
log_wts &lt;- log(wts)
head(log_wts)

x &lt;- weight_draws(x, weights = log_wts, log = TRUE)
# extract weights
head(weights(x))
head(weights(x, log=TRUE, normalize = FALSE)) # recover original log_wts

</code></pre>

<hr>
<h2 id='weights.draws'>Extract Weights from Draws Objects</h2><span id='topic+weights.draws'></span>

<h3>Description</h3>

<p>Extract weights from <code><a href="#topic+draws">draws</a></code> objects, with one weight per draw.
See <code><a href="#topic+weight_draws">weight_draws</a></code> for details how to add weights to <code><a href="#topic+draws">draws</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'draws'
weights(object, log = FALSE, normalize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights.draws_+3A_object">object</code></td>
<td>
<p>(draws) A <code><a href="#topic+draws">draws</a></code> object.</p>
</td></tr>
<tr><td><code id="weights.draws_+3A_log">log</code></td>
<td>
<p>(logical) Should the weights be returned on the log scale?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="weights.draws_+3A_normalize">normalize</code></td>
<td>
<p>(logical) Should the weights be normalized to sum to 1 on
the standard scale? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="weights.draws_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of weights, with one weight per draw.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weight_draws">weight_draws</a></code>, <code><a href="#topic+resample_draws">resample_draws</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_draws()

# sample some random weights for illustration
wts &lt;- rexp(ndraws(x))
head(wts)

# add weights
x &lt;- weight_draws(x, weights = wts)

# extract weights
head(weights(x)) # defaults to normalized weights
head(weights(x, normalize=FALSE)) # recover original weights
head(weights(x, log=TRUE)) # get normalized log-weights

# add weights which are already on the log scale
log_wts &lt;- log(wts)
head(log_wts)

x &lt;- weight_draws(x, weights = log_wts, log = TRUE)
# extract weights
head(weights(x))
head(weights(x, log=TRUE, normalize = FALSE)) # recover original log_wts

</code></pre>

<hr>
<h2 id='z_scale'>Rank normalization</h2><span id='topic+z_scale'></span>

<h3>Description</h3>

<p>Compute rank normalization for a numeric array. First replace each
value by its rank. Average rank for ties are used to conserve the
number of unique values of discrete quantities. Second, normalize
ranks via the inverse normal transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_scale(x, c = 3/8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z_scale_+3A_x">x</code></td>
<td>
<p>(numeric) A scalar, vector, matrix, or array of values.</p>
</td></tr>
<tr><td><code id="z_scale_+3A_c">c</code></td>
<td>
<p>(numeric) Fractional offset used in the back-transformation of ranks.
Defaults to <code>3/8</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric array of rank normalized values with the same size
and dimension as the input.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
