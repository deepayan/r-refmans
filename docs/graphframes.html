<!DOCTYPE html><html><head><title>Help for package graphframes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {graphframes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gf_bfs'><p>Breadth-first search (BFS)</p></a></li>
<li><a href='#gf_cache'><p>Cache the GraphFrame</p></a></li>
<li><a href='#gf_chain'><p>Chain graph</p></a></li>
<li><a href='#gf_connected_components'><p>Connected components</p></a></li>
<li><a href='#gf_degrees'><p>Degrees of vertices</p></a></li>
<li><a href='#gf_edge_columns'><p>Edges column names</p></a></li>
<li><a href='#gf_edges'><p>Extract edges DataFrame</p></a></li>
<li><a href='#gf_find'><p>Motif finding: Searching the graph for structural patterns</p></a></li>
<li><a href='#gf_friends'><p>Graph of friends in a social network.</p></a></li>
<li><a href='#gf_graphframe'><p>Create a new GraphFrame</p></a></li>
<li><a href='#gf_grid_ising_model'><p>Generate a grid Ising model with random parameters</p></a></li>
<li><a href='#gf_in_degrees'><p>In-degrees of vertices</p></a></li>
<li><a href='#gf_lpa'><p>Label propagation algorithm (LPA)</p></a></li>
<li><a href='#gf_out_degrees'><p>Out-degrees of vertices</p></a></li>
<li><a href='#gf_pagerank'><p>PageRank</p></a></li>
<li><a href='#gf_persist'><p>Persist the GraphFrame</p></a></li>
<li><a href='#gf_register'><p>Register a GraphFrame object</p></a></li>
<li><a href='#gf_scc'><p>Strongly connected components</p></a></li>
<li><a href='#gf_shortest_paths'><p>Shortest paths</p></a></li>
<li><a href='#gf_star'><p>Generate a star graph</p></a></li>
<li><a href='#gf_triangle_count'><p>Computes the number of triangles passing through each vertex.</p></a></li>
<li><a href='#gf_triplets'><p>Triplets of graph</p></a></li>
<li><a href='#gf_two_blobs'><p>Generate two blobs</p></a></li>
<li><a href='#gf_unpersist'><p>Unpersist the GraphFrame</p></a></li>
<li><a href='#gf_vertex_columns'><p>Vertices column names</p></a></li>
<li><a href='#gf_vertices'><p>Extract vertices DataFrame</p></a></li>
<li><a href='#spark_graphframe'><p>Retrieve a GraphFrame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface for 'GraphFrames'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Kuo &lt;kevin.kuo@rstudio.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'sparklyr' <a href="https://spark.rstudio.com/">https://spark.rstudio.com/</a> extension that provides an R 
  interface for 'GraphFrames' <a href="https://graphframes.github.io/">https://graphframes.github.io/</a>. 'GraphFrames' is a package
  for 'Apache Spark' that provides a DataFrame-based API for working with graphs. Functionality
  includes motif finding and common graph algorithms, such as PageRank and Breadth-first
  search.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rstudio/graphframes">https://github.com/rstudio/graphframes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rstudio/graphframes/issues">https://github.com/rstudio/graphframes/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>sparklyr, tibble, forge</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, dplyr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-10-30 19:01:05 UTC; kevinykuo</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Kuo <a href="https://orcid.org/0000-0001-7803-7901"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-10-30 19:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='gf_bfs'>Breadth-first search (BFS)</h2><span id='topic+gf_bfs'></span>

<h3>Description</h3>

<p>Breadth-first search (BFS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_bfs(x, from_expr, to_expr, max_path_length = 10, edge_filter = NULL,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_bfs_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
<tr><td><code id="gf_bfs_+3A_from_expr">from_expr</code></td>
<td>
<p>Spark SQL expression specifying valid starting vertices for the BFS.</p>
</td></tr>
<tr><td><code id="gf_bfs_+3A_to_expr">to_expr</code></td>
<td>
<p>Spark SQL expression specifying valid target vertices for the BFS.</p>
</td></tr>
<tr><td><code id="gf_bfs_+3A_max_path_length">max_path_length</code></td>
<td>
<p>Limit on the length of paths.</p>
</td></tr>
<tr><td><code id="gf_bfs_+3A_edge_filter">edge_filter</code></td>
<td>
<p>Spark SQL expression specifying edges which may be used in the search.</p>
</td></tr>
<tr><td><code id="gf_bfs_+3A_...">...</code></td>
<td>
<p>Optional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g &lt;- gf_friends(sc)
gf_bfs(g, from_expr = "name = 'Esther'", to_expr = "age &lt; 32")

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_cache'>Cache the GraphFrame</h2><span id='topic+gf_cache'></span>

<h3>Description</h3>

<p>Cache the GraphFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_cache(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_cache_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='gf_chain'>Chain graph</h2><span id='topic+gf_chain'></span>

<h3>Description</h3>

<p>Returns a chain graph of the given size with Long ID type.
The vertex IDs are 0, 1, ..., n-1, and the edges are (0, 1), (1, 2), ...., (n-2, n-1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_chain(sc, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_chain_+3A_sc">sc</code></td>
<td>
<p>A Spark connection.</p>
</td></tr>
<tr><td><code id="gf_chain_+3A_n">n</code></td>
<td>
<p>Size of the graph to return.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gf_chain(sc, 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_connected_components'>Connected components</h2><span id='topic+gf_connected_components'></span>

<h3>Description</h3>

<p>Computes the connected component membership of each vertex and returns a DataFrame
of vertex information with each vertex assigned a component ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_connected_components(x, broadcast_threshold = 1000000L,
  algorithm = c("graphframes", "graphx"), checkpoint_interval = 2L,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_connected_components_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
<tr><td><code id="gf_connected_components_+3A_broadcast_threshold">broadcast_threshold</code></td>
<td>
<p>Broadcast threshold in propagating component assignments.</p>
</td></tr>
<tr><td><code id="gf_connected_components_+3A_algorithm">algorithm</code></td>
<td>
<p>One of 'graphframes' or 'graphx'.</p>
</td></tr>
<tr><td><code id="gf_connected_components_+3A_checkpoint_interval">checkpoint_interval</code></td>
<td>
<p>Checkpoint interval in terms of number of iterations.</p>
</td></tr>
<tr><td><code id="gf_connected_components_+3A_...">...</code></td>
<td>
<p>Optional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# checkpoint directory is required for gf_connected_components()
spark_set_checkpoint_dir(sc, tempdir())
g &lt;- gf_friends(sc)
gf_connected_components(g)

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_degrees'>Degrees of vertices</h2><span id='topic+gf_degrees'></span>

<h3>Description</h3>

<p>Degrees of vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_degrees(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_degrees_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='gf_edge_columns'>Edges column names</h2><span id='topic+gf_edge_columns'></span>

<h3>Description</h3>

<p>Edges column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_edge_columns(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_edge_columns_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='gf_edges'>Extract edges DataFrame</h2><span id='topic+gf_edges'></span>

<h3>Description</h3>

<p>Extract edges DataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_edges(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_edges_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='gf_find'>Motif finding: Searching the graph for structural patterns</h2><span id='topic+gf_find'></span>

<h3>Description</h3>

<p>Motif finding uses a simple Domain-Specific Language (DSL) for
expressing structural queries. For example,
gf_find(g, &quot;(a)-[e]-&gt;(b); (b)-[e2]-&gt;(a)&quot;) will search for
pairs of vertices a,b connected by edges in both directions.
It will return a DataFrame of all such structures in the graph,
with columns for each of the named elements (vertices or edges)
in the motif. In this case, the returned columns will be in
order of the pattern: &quot;a, e, b, e2.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_find(x, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_find_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
<tr><td><code id="gf_find_+3A_pattern">pattern</code></td>
<td>
<p>pattern specifying a motif to search for</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gf_friends(sc) %&gt;%
  gf_find("(a)-[e]-&gt;(b); (b)-[e2]-&gt;(a)")

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_friends'>Graph of friends in a social network.</h2><span id='topic+gf_friends'></span>

<h3>Description</h3>

<p>Graph of friends in a social network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_friends(sc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_friends_+3A_sc">sc</code></td>
<td>
<p>A Spark connection.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sparklyr)
sc &lt;- spark_connect(master = "local")
gf_friends(sc)

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_graphframe'>Create a new GraphFrame</h2><span id='topic+gf_graphframe'></span>

<h3>Description</h3>

<p>Create a new GraphFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_graphframe(vertices = NULL, edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_graphframe_+3A_vertices">vertices</code></td>
<td>
<p>A <code>tbl_spark</code> representing vertices.</p>
</td></tr>
<tr><td><code id="gf_graphframe_+3A_edges">edges</code></td>
<td>
<p>A <code>tbl_psark</code> representing edges.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sparklyr)
sc &lt;- spark_connect(master = "local", version = "2.3.0")
v_tbl &lt;- sdf_copy_to(
  sc, data.frame(id = 1:3, name = LETTERS[1:3])
)
e_tbl &lt;- sdf_copy_to(
  sc, data.frame(src = c(1, 2, 2), dst = c(2, 1, 3),
                 action = c("love", "hate", "follow"))
)
gf_graphframe(v_tbl, e_tbl)
gf_graphframe(edges = e_tbl)

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_grid_ising_model'>Generate a grid Ising model with random parameters</h2><span id='topic+gf_grid_ising_model'></span>

<h3>Description</h3>

<p>Generate a grid Ising model with random parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_grid_ising_model(sc, n, v_std = 1, e_std = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_grid_ising_model_+3A_sc">sc</code></td>
<td>
<p>A Spark connection.</p>
</td></tr>
<tr><td><code id="gf_grid_ising_model_+3A_n">n</code></td>
<td>
<p>Length of one side of the grid. The grid will be of size n x n.</p>
</td></tr>
<tr><td><code id="gf_grid_ising_model_+3A_v_std">v_std</code></td>
<td>
<p>Standard deviation of normal distribution used to generate vertex factors &quot;a&quot;. Default of 1.0.</p>
</td></tr>
<tr><td><code id="gf_grid_ising_model_+3A_e_std">e_std</code></td>
<td>
<p>Standard deviation of normal distribution used to generate edge factors &quot;b&quot;. Default of 1.0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method generates a grid Ising model with random parameters. Ising models
are probabilistic graphical models over binary variables xi. Each binary
variable xi corresponds to one vertex, and it may take values -1 or +1.
The probability distribution P(X) (over all xi) is parameterized by
vertex factors ai and edge factors bij:
</p>
<p style="text-align: center;"><code class="reqn">P(X) = (1/Z) * exp[ \sum_i a_i x_i + \sum_{ij} b_{ij} x_i x_j ]</code>
</p>



<h3>Value</h3>

<p>GraphFrame. Vertices have columns &quot;id&quot; and &quot;a&quot;. Edges have columns &quot;src&quot;,
&quot;dst&quot;, and &quot;b&quot;. Edges are directed, but they should be treated as undirected in
any algorithms run on this model. Vertex IDs are of the form &quot;i,j&quot;. E.g., vertex
&quot;1,3&quot; is in the second row and fourth column of the grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gf_grid_ising_model(sc, 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_in_degrees'>In-degrees of vertices</h2><span id='topic+gf_in_degrees'></span>

<h3>Description</h3>

<p>In-degrees of vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_in_degrees(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_in_degrees_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='gf_lpa'>Label propagation algorithm (LPA)</h2><span id='topic+gf_lpa'></span>

<h3>Description</h3>

<p>Run static Label Propagation for detecting communities in networks. Each node in the
network is initially assigned to its own community. At every iteration, nodes send
their community affiliation to all neighbors and update their state to the mode
community affiliation of incoming messages. LPA is a standard community detection
algorithm for graphs. It is very inexpensive
computationally, although (1) convergence is not guaranteed and (2) one can
end up with trivial solutions (all nodes are identified into a single community).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_lpa(x, max_iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_lpa_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
<tr><td><code id="gf_lpa_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="gf_lpa_+3A_...">...</code></td>
<td>
<p>Optional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g &lt;- gf_friends(sc)
gf_lpa(g, max_iter = 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_out_degrees'>Out-degrees of vertices</h2><span id='topic+gf_out_degrees'></span>

<h3>Description</h3>

<p>Out-degrees of vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_out_degrees(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_out_degrees_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='gf_pagerank'>PageRank</h2><span id='topic+gf_pagerank'></span>

<h3>Description</h3>

<p>PageRank
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_pagerank(x, tol = NULL, reset_probability = 0.15, max_iter = NULL,
  source_id = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_pagerank_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
<tr><td><code id="gf_pagerank_+3A_tol">tol</code></td>
<td>
<p>Tolerance.</p>
</td></tr>
<tr><td><code id="gf_pagerank_+3A_reset_probability">reset_probability</code></td>
<td>
<p>Reset probability.</p>
</td></tr>
<tr><td><code id="gf_pagerank_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="gf_pagerank_+3A_source_id">source_id</code></td>
<td>
<p>(Optional) Source vertex for a personalized pagerank.</p>
</td></tr>
<tr><td><code id="gf_pagerank_+3A_...">...</code></td>
<td>
<p>Optional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g &lt;- gf_friends(sc)
gf_pagerank(g, reset_probability = 0.15, tol = 0.01)

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_persist'>Persist the GraphFrame</h2><span id='topic+gf_persist'></span>

<h3>Description</h3>

<p>Persist the GraphFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_persist(x, storage_level = "MEMORY_AND_DISK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_persist_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
<tr><td><code id="gf_persist_+3A_storage_level">storage_level</code></td>
<td>
<p>The storage level to be used. Please view the
<a href="http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence">Spark Documentation</a>
for information on what storage levels are accepted.</p>
</td></tr>
</table>

<hr>
<h2 id='gf_register'>Register a GraphFrame object</h2><span id='topic+gf_register'></span>

<h3>Description</h3>

<p>Register a GraphFrame object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_register(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_register_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='gf_scc'>Strongly connected components</h2><span id='topic+gf_scc'></span>

<h3>Description</h3>

<p>Compute the strongly connected component (SCC) of each vertex and return a
DataFrame with each vertex assigned to the SCC containing that vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_scc(x, max_iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_scc_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
<tr><td><code id="gf_scc_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="gf_scc_+3A_...">...</code></td>
<td>
<p>Optional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g &lt;- gf_friends(sc)
gf_scc(g, max_iter = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_shortest_paths'>Shortest paths</h2><span id='topic+gf_shortest_paths'></span>

<h3>Description</h3>

<p>Computes shortest paths from every vertex to the given set of landmark vertices.
Note that this takes edge direction into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_shortest_paths(x, landmarks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_shortest_paths_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
<tr><td><code id="gf_shortest_paths_+3A_landmarks">landmarks</code></td>
<td>
<p>IDs of landmark vertices.</p>
</td></tr>
<tr><td><code id="gf_shortest_paths_+3A_...">...</code></td>
<td>
<p>Optional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g &lt;- gf_friends(sc)
gf_shortest_paths(g, landmarks = c("a", "d"))

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_star'>Generate a star graph</h2><span id='topic+gf_star'></span>

<h3>Description</h3>

<p>Returns a star graph with Long ID type, consisting of a central element
indexed 0 (the root) and the n other leaf vertices 1, 2, ..., n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_star(sc, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_star_+3A_sc">sc</code></td>
<td>
<p>A Spark connection.</p>
</td></tr>
<tr><td><code id="gf_star_+3A_n">n</code></td>
<td>
<p>The number of leaves.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gf_star(sc, 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_triangle_count'>Computes the number of triangles passing through each vertex.</h2><span id='topic+gf_triangle_count'></span>

<h3>Description</h3>

<p>This algorithm ignores edge direction; i.e., all edges are treated
as undirected. In a multigraph, duplicate edges will be counted only once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_triangle_count(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_triangle_count_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
<tr><td><code id="gf_triangle_count_+3A_...">...</code></td>
<td>
<p>Optional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g &lt;- gf_friends(sc)
gf_triangle_count(g)

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_triplets'>Triplets of graph</h2><span id='topic+gf_triplets'></span>

<h3>Description</h3>

<p>Triplets of graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_triplets(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_triplets_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='gf_two_blobs'>Generate two blobs</h2><span id='topic+gf_two_blobs'></span>

<h3>Description</h3>

<p>Two densely connected blobs (vertices 0-&gt;n-1 and n-&gt;2n-1)
connected by a single edge (0-&gt;n).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_two_blobs(sc, blob_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_two_blobs_+3A_sc">sc</code></td>
<td>
<p>A Spark connection.</p>
</td></tr>
<tr><td><code id="gf_two_blobs_+3A_blob_size">blob_size</code></td>
<td>
<p>The size of each blob.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gf_two_blobs(sc, 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='gf_unpersist'>Unpersist the GraphFrame</h2><span id='topic+gf_unpersist'></span>

<h3>Description</h3>

<p>Unpersist the GraphFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_unpersist(x, blocking = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_unpersist_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
<tr><td><code id="gf_unpersist_+3A_blocking">blocking</code></td>
<td>
<p>whether to block until all blocks are deleted</p>
</td></tr>
</table>

<hr>
<h2 id='gf_vertex_columns'>Vertices column names</h2><span id='topic+gf_vertex_columns'></span>

<h3>Description</h3>

<p>Vertices column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_vertex_columns(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_vertex_columns_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='gf_vertices'>Extract vertices DataFrame</h2><span id='topic+gf_vertices'></span>

<h3>Description</h3>

<p>Extract vertices DataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf_vertices(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gf_vertices_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='spark_graphframe'>Retrieve a GraphFrame</h2><span id='topic+spark_graphframe'></span>

<h3>Description</h3>

<p>Retrieve a GraphFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spark_graphframe(x, ...)

spark_graphframe(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spark_graphframe_+3A_x">x</code></td>
<td>
<p>An object coercable to a GraphFrame (typically, a
<code>gf_graphframe</code>).</p>
</td></tr>
<tr><td><code id="spark_graphframe_+3A_...">...</code></td>
<td>
<p>additional arguments, not used</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
