<!DOCTYPE html><html><head><title>Help for package ehymet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ehymet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clustering_validation'><p>Create a table containing three validation metrics for clustering: Purity, F-measure</p>
and Rand Index (RI)</a></li>
<li><a href='#clustInd_hierarch'><p>Perform hierarchical clustering for a different combinations of indices,</p>
method and distance</a></li>
<li><a href='#clustInd_kkmeans'><p>Kernel k-means clustering using indices</p></a></li>
<li><a href='#clustInd_kmeans'><p>K-means clustering with indices</p></a></li>
<li><a href='#clustInd_spc'><p>Spectral clustering using indices</p></a></li>
<li><a href='#EHyClus'><p>Clustering using Epigraph and Hypograph indices</p></a></li>
<li><a href='#EI'><p>Epigraph Index (EI) for a functional dataset</p></a></li>
<li><a href='#generate_indices'><p>Create a dataset with indices from a functional dataset in one or multiple</p>
dimensions</a></li>
<li><a href='#HI'><p>Hypograph Index (HI) for a functional dataset</p></a></li>
<li><a href='#MEI'><p>Modified Epigraph Index (MEI) for functional dataset.</p></a></li>
<li><a href='#MHI'><p>Modified Hypograph Index (MHI) for a functional dataset</p></a></li>
<li><a href='#sim_model_ex1'><p>Function for generating functional data in one dimension</p></a></li>
<li><a href='#sim_model_ex2'><p>Function for generating functional data in one or multiple dimension</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Methodologies for Functional Data Based on the Epigraph and
Hypograph Indices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements methods for functional data analysis based on the epigraph 
  and hypograph indices. These methods transform 
  functional datasets, whether in one or multiple dimensions, into multivariate 
  datasets. The transformation involves applying the epigraph, hypograph, and 
  their modified versions to both the original curves and their first and second 
  derivatives. The calculation of these indices is tailored to the dimensionality 
  of the functional dataset, with special considerations for dependencies between 
  dimensions in multidimensional cases. This approach extends traditional multivariate
  data analysis techniques to the functional data setting. A key application of 
  this package is the EHyClus method, which enhances clustering analysis for 
  functional data across one or multiple dimensions using the epigraph and 
  hypograph indices.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bpulidob/ehymet">https://github.com/bpulidob/ehymet</a>,
<a href="https://bpulidob.github.io/ehymet/">https://bpulidob.github.io/ehymet/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bpulidob/ehymet/issues">https://github.com/bpulidob/ehymet/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>kernlab, stats, tf,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, MASS, rmarkdown, testthat (&ge; 3.0.0), tidyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-13 16:34:13 UTC; belen</td>
</tr>
<tr>
<td>Author:</td>
<td>Belen Pulido <a href="https://orcid.org/0000-0003-2105-959X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jose Ignacio Diez [ctr]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Belen Pulido &lt;bpulidob4@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-14 10:10:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='clustering_validation'>Create a table containing three validation metrics for clustering: Purity, F-measure
and Rand Index (RI)</h2><span id='topic+clustering_validation'></span>

<h3>Description</h3>

<p>Create a table containing three validation metrics for clustering: Purity, F-measure
and Rand Index (RI)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering_validation(true_labels, clusters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustering_validation_+3A_true_labels">true_labels</code></td>
<td>
<p>Atomic vector with the true labels of the data.</p>
</td></tr>
<tr><td><code id="clustering_validation_+3A_clusters">clusters</code></td>
<td>
<p>The clusters predicted by the clustering method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>table</code> containing values for Purity, F-measure and RI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1221)
vars1 &lt;- c("dtaEI", "dtaMEI")
data &lt;- ehymet::sim_model_ex1()
true_labels &lt;- c(rep(1, 50), rep(2, 50))
data_ind &lt;- generate_indices(data)
clus_kmeans &lt;- ehymet::clustInd_kmeans(data_ind, list(vars1))
cluskmeans_mahalanobis_dtaEIdtaMEI &lt;- clus_kmeans$kmeans_mahalanobis_dtaEIdtaMEI$cluster
clustering_validation(true_labels, cluskmeans_mahalanobis_dtaEIdtaMEI)

</code></pre>

<hr>
<h2 id='clustInd_hierarch'>Perform hierarchical clustering for a different combinations of indices,
method and distance</h2><span id='topic+clustInd_hierarch'></span>

<h3>Description</h3>

<p>Perform hierarchical clustering for a different combinations of indices,
method and distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustInd_hierarch(
  ind_data,
  vars_combinations,
  method_list = c("single", "complete", "average", "centroid", "ward.D2"),
  dist_vector = c("euclidean", "manhattan"),
  n_cluster = 2,
  true_labels = NULL,
  n_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustInd_hierarch_+3A_ind_data">ind_data</code></td>
<td>
<p>Dataframe containing indices applied to the original data and
its first and second derivatives. See <a href="#topic+generate_indices">generate_indices</a>.</p>
</td></tr>
<tr><td><code id="clustInd_hierarch_+3A_vars_combinations">vars_combinations</code></td>
<td>
<p><code>list</code> containing one or more combinations of indices in
<code>ind_data</code>. If it is non-named, the names of the variables are set to
vars1, ..., varsk, where k is the number of elements in <code>vars_combinations</code>.</p>
</td></tr>
<tr><td><code id="clustInd_hierarch_+3A_method_list">method_list</code></td>
<td>
<p><code>list</code> of clustering methods.</p>
</td></tr>
<tr><td><code id="clustInd_hierarch_+3A_dist_vector">dist_vector</code></td>
<td>
<p><code>list</code> of distance metrics.</p>
</td></tr>
<tr><td><code id="clustInd_hierarch_+3A_n_cluster">n_cluster</code></td>
<td>
<p>number of clusters to generate.</p>
</td></tr>
<tr><td><code id="clustInd_hierarch_+3A_true_labels">true_labels</code></td>
<td>
<p>Vector of true labels for validation
(if it is not known true_labels is set to NULL)</p>
</td></tr>
<tr><td><code id="clustInd_hierarch_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores to do parallel computation. 1 by default,
which mean no parallel execution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing hierarchical clustering results
for each configuration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vars1 &lt;- c("dtaEI", "dtaMEI")
vars2 &lt;- c("dtaHI", "dtaMHI")
data &lt;- ehymet::sim_model_ex1()
data_ind &lt;- generate_indices(data)
clustInd_hierarch(data_ind, list(vars1, vars2))

</code></pre>

<hr>
<h2 id='clustInd_kkmeans'>Kernel k-means clustering using indices</h2><span id='topic+clustInd_kkmeans'></span>

<h3>Description</h3>

<p>Perform kernel kmeans clustering for a different combinations of indices
and kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustInd_kkmeans(
  ind_data,
  vars_combinations,
  kernel_list = c("rbfdot", "polydot"),
  n_cluster = 2,
  true_labels = NULL,
  n_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustInd_kkmeans_+3A_ind_data">ind_data</code></td>
<td>
<p>Dataframe containing indices applied to the original data and
its first and second derivatives. See <a href="#topic+generate_indices">generate_indices</a>.</p>
</td></tr>
<tr><td><code id="clustInd_kkmeans_+3A_vars_combinations">vars_combinations</code></td>
<td>
<p><code>list</code> containing one or more combinations of indices in
<code>ind_data</code>. If it is non-named, the names of the variables are set to
vars1, ..., varsk, where k is the number of elements in <code>vars_combinations</code>.</p>
</td></tr>
<tr><td><code id="clustInd_kkmeans_+3A_kernel_list">kernel_list</code></td>
<td>
<p>List of kernels</p>
</td></tr>
<tr><td><code id="clustInd_kkmeans_+3A_n_cluster">n_cluster</code></td>
<td>
<p>Number of clusters to create</p>
</td></tr>
<tr><td><code id="clustInd_kkmeans_+3A_true_labels">true_labels</code></td>
<td>
<p>Vector of true labels for validation
(if it is not known true_labels is set to NULL)</p>
</td></tr>
<tr><td><code id="clustInd_kkmeans_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores to do parallel computation. 1 by default,
which mean no parallel execution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing kernel-kmeans clustering results for each configuration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vars1 &lt;- c("dtaEI", "dtaMEI")
vars2 &lt;- c("dtaHI", "dtaMHI")
data &lt;- ehymet::sim_model_ex1()
data_ind &lt;- generate_indices(data)
clustInd_kkmeans(data_ind, list(vars1, vars2))

</code></pre>

<hr>
<h2 id='clustInd_kmeans'>K-means clustering with indices</h2><span id='topic+clustInd_kmeans'></span>

<h3>Description</h3>

<p>Perform k-means clustering for a different combinations of indices and
distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustInd_kmeans(
  ind_data,
  vars_combinations,
  dist_vector = c("euclidean", "mahalanobis"),
  n_cluster = 2,
  true_labels = NULL,
  n_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustInd_kmeans_+3A_ind_data">ind_data</code></td>
<td>
<p>Dataframe containing indices applied to the original data and
its first and second derivatives. See <a href="#topic+generate_indices">generate_indices</a>.</p>
</td></tr>
<tr><td><code id="clustInd_kmeans_+3A_vars_combinations">vars_combinations</code></td>
<td>
<p><code>list</code> containing one or more combinations of indices in
<code>ind_data</code>. If it is non-named, the names of the variables are set to
vars1, ..., varsk, where k is the number of elements in <code>vars_combinations</code>.</p>
</td></tr>
<tr><td><code id="clustInd_kmeans_+3A_dist_vector">dist_vector</code></td>
<td>
<p>Atomic vector of distance metrics. The possible values are,
&quot;euclidean&quot;, &quot;mahalanobis&quot; or both.</p>
</td></tr>
<tr><td><code id="clustInd_kmeans_+3A_n_cluster">n_cluster</code></td>
<td>
<p>Number of clusters to create.</p>
</td></tr>
<tr><td><code id="clustInd_kmeans_+3A_true_labels">true_labels</code></td>
<td>
<p>Vector of true labels for validation.
(if it is not known true_labels is set to NULL)</p>
</td></tr>
<tr><td><code id="clustInd_kmeans_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores to do parallel computation. 1 by default,
which mean no parallel execution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing hierarchical clustering results
for each configuration
</p>
<p>A list containing kmeans clustering results for each configuration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vars1 &lt;- c("dtaEI", "dtaMEI")
vars2 &lt;- c("dtaHI", "dtaMHI")
data &lt;- ehymet::sim_model_ex1()
data_ind &lt;- generate_indices(data)
clustInd_kmeans(data_ind, list(vars1, vars2))

</code></pre>

<hr>
<h2 id='clustInd_spc'>Spectral clustering using indices</h2><span id='topic+clustInd_spc'></span>

<h3>Description</h3>

<p>Perform spectral clustering for a different combinations of indices
and kernels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustInd_spc(
  ind_data,
  vars_combinations,
  kernel_list = c("rbfdot", "polydot"),
  n_cluster = 2,
  true_labels = NULL,
  n_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustInd_spc_+3A_ind_data">ind_data</code></td>
<td>
<p>Dataframe containing indices applied to the original data and
its first and second derivatives. See <a href="#topic+generate_indices">generate_indices</a>.</p>
</td></tr>
<tr><td><code id="clustInd_spc_+3A_vars_combinations">vars_combinations</code></td>
<td>
<p><code>list</code> containing one or more combinations of indices in
<code>ind_data</code>. If it is non-named, the names of the variables are set to
vars1, ..., varsk, where k is the number of elements in <code>vars_combinations</code>.</p>
</td></tr>
<tr><td><code id="clustInd_spc_+3A_kernel_list">kernel_list</code></td>
<td>
<p>List of kernels</p>
</td></tr>
<tr><td><code id="clustInd_spc_+3A_n_cluster">n_cluster</code></td>
<td>
<p>Number of clusters to create</p>
</td></tr>
<tr><td><code id="clustInd_spc_+3A_true_labels">true_labels</code></td>
<td>
<p>Vector of true labels for validation
(if it is not known true_labels is set to NULL)</p>
</td></tr>
<tr><td><code id="clustInd_spc_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores to do parallel computation. 1 by default,
which mean no parallel execution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing kkmeans clustering results for each configuration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vars1 &lt;- c("dtaEI", "dtaMEI")
vars2 &lt;- c("dtaHI", "dtaMHI")
data &lt;- ehymet::sim_model_ex1()
data_ind &lt;- generate_indices(data)
clustInd_spc(data_ind, list(vars1, vars2))

</code></pre>

<hr>
<h2 id='EHyClus'>Clustering using Epigraph and Hypograph indices</h2><span id='topic+EHyClus'></span>

<h3>Description</h3>

<p>It creates a multivariate dataset containing
the epigraph, hypograph and/or its modified versions on the curves and derivatives
and then perform hierarchical clustering, kmeans, kernel kmeans, and spectral clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EHyClus(
  curves,
  vars_combinations,
  k = 30,
  n_clusters = 2,
  bs = "cr",
  clustering_methods = c("hierarch", "kmeans", "kkmeans", "spc"),
  l_method_hierarch = c("single", "complete", "average", "centroid", "ward.D2"),
  l_dist_hierarch = c("euclidean", "manhattan"),
  l_dist_kmeans = c("euclidean", "mahalanobis"),
  l_kernel = c("rbfdot", "polydot"),
  grid,
  true_labels = NULL,
  only_best = FALSE,
  verbose = FALSE,
  n_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EHyClus_+3A_curves">curves</code></td>
<td>
<p>Dataset containing the curves to apply a clustering algorithm.
The functional dataset can be one dimensional (<code class="reqn">n \times p</code>) where <code class="reqn">n</code> is the number of
curves and <code>p</code> the number of time points, or multidimensional (<code class="reqn">n \times p \times q</code>) where <code class="reqn">q</code>
represents the number of dimensions in the data</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_vars_combinations">vars_combinations</code></td>
<td>
<p>If <code>list</code>,  each element of the list should be an
atomic <code>vector</code> of strings with the
names of the variables. Combinations with non-valid variable names will be discarded.
If the list is non-named, the names of the variables are set to
vars1, ..., varsk, where k is the number of elements in <code>vars_combinations</code>.
If not provided, generic combinations of variables will be used. They will not be
the same for uni-dimensional and multi-dimensional problems.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_k">k</code></td>
<td>
<p>Number of basis functions for the B-splines. If equals to <code>0</code>, the number
of basis functions will be automatically selected.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_n_clusters">n_clusters</code></td>
<td>
<p>Number of clusters to generate.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_bs">bs</code></td>
<td>
<p>A two letter character string indicating the (penalized) smoothing
basis to use. See <code>smooth.terms</code>.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_clustering_methods">clustering_methods</code></td>
<td>
<p>character vector specifying at least one of the following
clustering methods to be computed: &quot;hierarch&quot;, &quot;kmeans&quot;, &quot;kkmeans&quot; or &quot;spc&quot;.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_l_method_hierarch">l_method_hierarch</code></td>
<td>
<p><code>list</code> of clustering methods for hierarchical
clustering.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_l_dist_hierarch">l_dist_hierarch</code></td>
<td>
<p><code>list</code> of distances for hierarchical clustering.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_l_dist_kmeans">l_dist_kmeans</code></td>
<td>
<p><code>list</code> of distances for kmeans clustering.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_l_kernel">l_kernel</code></td>
<td>
<p><code>list</code> of kernels for kkmeans or spc.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_grid">grid</code></td>
<td>
<p>Atomic vector of type numeric with two elements: the lower limit and the upper
limit of the evaluation grid. If not provided, it will be selected automatically.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_true_labels">true_labels</code></td>
<td>
<p>Numeric vector of true labels for validation. If provided,
evaluation metrics are computed in the final result.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_only_best">only_best</code></td>
<td>
<p><code>logical</code> value. If <code>TRUE</code> and <code>true_labels</code>
is provided, the function will return only the result for the best clustering
method based on the Rand Index. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, the function will print logs for about the execution of
some clustering methods. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="EHyClus_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores to do parallel computation. 1 by default,
which mean no parallel execution. Must be an integer number greater than 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the clustering partition for each method and indices
combination and, if <code>true_labels</code> is provided a data frame containing the time elapsed for obtaining a
clustering partition of the indices dataset for each methodology. Also, the number of
generated clusters and the combinations of variables used can be seen as attributes
of this object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># univarariate data without labels
curves &lt;- sim_model_ex1(n = 10)
vars_combinations &lt;- list(c("dtaEI", "dtaMEI"), c("dtaHI", "dtaMHI"))
EHyClus(curves, vars_combinations = vars_combinations)

# multivariate data with labels
curves &lt;- sim_model_ex2(n = 5)
true_labels &lt;- c(rep(1, 5), rep(2, 5))
vars_combinations &lt;- list(c("dtaMEI", "ddtaMEI"), c("dtaMEI", "d2dtaMEI"))
res &lt;- EHyClus(curves, vars_combinations = vars_combinations, true_labels = true_labels)
res$cluster # clustering results

# multivariate data and generic (default) vars_combinations
curves &lt;- sim_model_ex2(n = 5)
EHyClus(curves)

</code></pre>

<hr>
<h2 id='EI'>Epigraph Index (EI) for a functional dataset</h2><span id='topic+EI'></span>

<h3>Description</h3>

<p>The Epigraph Index of a curve x is one minus the proportion of curves
in the sample that are above x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EI(curves, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EI_+3A_curves">curves</code></td>
<td>
<p><code>matrix</code> where each row represents a curve, and each column
represents values along the curve or <code>array</code> with dimension
<code class="reqn">n \times p \times q</code> with <code class="reqn">n</code> curves, <code class="reqn">p</code> values along the curve, and
<code class="reqn">q</code> dimensions.</p>
</td></tr>
<tr><td><code id="EI_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric <code>vector</code> containing the EI for each curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1, 2, 3, 3, 2, 1, 5, 2, 3, 9, 8, 7), ncol = 3, nrow = 4)
EI(x)

y &lt;- array(c(1, 2, 3, 3, 2, 1, 5, 2, 3, 9, 8, 7, -1, -5, -6, 2, 3, 0, -1, 0, 2, -1, -2, 0),
  dim = c(3, 4, 2)
)
EI(y)

</code></pre>

<hr>
<h2 id='generate_indices'>Create a dataset with indices from a functional dataset in one or multiple
dimensions</h2><span id='topic+generate_indices'></span>

<h3>Description</h3>

<p>Create a dataset with indices from a functional dataset in one or multiple
dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_indices(
  curves,
  k,
  grid,
  bs = "cr",
  indices = c("EI", "HI", "MEI", "MHI"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_indices_+3A_curves">curves</code></td>
<td>
<p><code>matrix</code> with dimension <code class="reqn">n \times p</code> in the case of a
one-dimensional functional dataset, or <code>array</code> of dimension
<code class="reqn">n \times p \times q</code> in the case of a multivariate functional dataset.
<code class="reqn">n</code> represents the number of curves, <code class="reqn">p</code> the number of values along
the curve, and in the second case, <code class="reqn">q</code> is the number of dimensions.</p>
</td></tr>
<tr><td><code id="generate_indices_+3A_k">k</code></td>
<td>
<p>Number of basis functions for the B-splines. If equals to 0, the number
of basis functions will be automatically selected.</p>
</td></tr>
<tr><td><code id="generate_indices_+3A_grid">grid</code></td>
<td>
<p>Atomic vector of type numeric with two elements: the lower limit and the upper
limit of the evaluation grid. If not provided, it will be selected automatically.</p>
</td></tr>
<tr><td><code id="generate_indices_+3A_bs">bs</code></td>
<td>
<p>A two letter character string indicating the (penalized) smoothing
basis to use. See <code>smooth.terms</code>.</p>
</td></tr>
<tr><td><code id="generate_indices_+3A_indices">indices</code></td>
<td>
<p>Set of indices to be applied to the dataset. They should be
any between EI, HI, MEI and MHI.</p>
</td></tr>
<tr><td><code id="generate_indices_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the indices provided in <code>indices</code> for
original data, first and second derivatives
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- array(c(1, 2, 3, 3, 2, 1, 5, 2, 3, 9, 8, 7, -1, -5, -6, 2, 3, 0, -1, 0, 2, -1, -2, 0),
  dim = c(3, 4, 2)
)
generate_indices(x1, k = 4)

x2 &lt;- matrix(c(1, 2, 3, 3, 2, 1, 5, 2, 3, 9, 8, 7), nrow = 3, ncol = 4)
generate_indices(x2, k = 4)

</code></pre>

<hr>
<h2 id='HI'>Hypograph Index (HI) for a functional dataset</h2><span id='topic+HI'></span>

<h3>Description</h3>

<p>The Hypograph Index of a curve x is the proportion of curves in the sample
that are below x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HI(curves, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HI_+3A_curves">curves</code></td>
<td>
<p><code>matrix</code> where each row represents a curve, and each column
represents values along the curve or <code>array</code> with dimension
<code class="reqn">n \times p \times q</code> with <code class="reqn">n</code> curves, <code class="reqn">p</code> values along the curve, and
<code class="reqn">q</code> dimensions.</p>
</td></tr>
<tr><td><code id="HI_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric vector</code> containing the HI for each curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1, 2, 3, 3, 2, 1, 5, 2, 3, 9, 8, 7), ncol = 3, nrow = 4)
HI(x)

y &lt;- array(c(1, 2, 3, 3, 2, 1, 5, 2, 3, 9, 8, 7, -1, -5, -6, 2, 3, 0, -1, 0, 2, -1, -2, 0),
  dim = c(3, 4, 2)
)
HI(y)

</code></pre>

<hr>
<h2 id='MEI'>Modified Epigraph Index (MEI) for functional dataset.</h2><span id='topic+MEI'></span>

<h3>Description</h3>

<p>The Modified Epigraph Index of a curve x is one minus the proportion of
&quot;time&quot; the curves in the sample are above x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEI(curves, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEI_+3A_curves">curves</code></td>
<td>
<p><code>matrix</code> where each row represents a curve, and each column
represents values along the curve or an <code>array</code> with dimension
<code class="reqn">n \times p \times q</code> with <code class="reqn">n</code> curves, <code class="reqn">p</code> values along the curve, and
<code class="reqn">q</code> dimensions.</p>
</td></tr>
<tr><td><code id="MEI_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric vector</code> containing the MEI for each curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1, 2, 3, 3, 2, 1, 5, 2, 3, 9, 8, 7), ncol = 3, nrow = 4)
MEI(x)
y &lt;- array(c(1, 2, 3, 3, 2, 1, 5, 2, 3, 9, 8, 7, -1, -5, -6, 2, 3, 0, -1, 0, 2, -1, -2, 0),
  dim = c(3, 4, 2)
)
MEI(y)

</code></pre>

<hr>
<h2 id='MHI'>Modified Hypograph Index (MHI) for a functional dataset</h2><span id='topic+MHI'></span>

<h3>Description</h3>

<p>The Modified Hypograph Index of a curve x is the proportion of &quot;time&quot;
the curves in the sample are below x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MHI(curves, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MHI_+3A_curves">curves</code></td>
<td>
<p><code>matrix</code> where each row represents a curve, and each column
represents values along the curve or an <code>array</code> with dimension
<code class="reqn">n \times p \times q</code> with <code class="reqn">n</code> curves, <code class="reqn">p</code> values along the curve, and
<code class="reqn">q</code> dimensions.</p>
</td></tr>
<tr><td><code id="MHI_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric vector</code> containing the MHI for each curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1, 2, 3, 3, 2, 1, 5, 2, 3, 9, 8, 7), ncol = 3, nrow = 4)
MHI(x)
y &lt;- array(c(1, 2, 3, 3, 2, 1, 5, 2, 3, 9, 8, 7, -1, -5, -6, 2, 3, 0, -1, 0, 2, -1, -2, 0),
  dim = c(3, 4, 2)
)
MHI(y)

</code></pre>

<hr>
<h2 id='sim_model_ex1'>Function for generating functional data in one dimension</h2><span id='topic+sim_model_ex1'></span>

<h3>Description</h3>

<p>Each dataset has 2 groups with <code>n</code> curves each, defined in the interval
<code class="reqn">t=[0, 1]</code> with <code>p</code> equidistant points. The first <code>n</code> curves are
generated fron the following model
<code class="reqn">X_1(t)=E_1(t)+e(t)</code> where <code class="reqn">E_1(t)=E_1(X(t))=30t^{ \frac{3}{2}}(1-t)</code>
is the mean function and <code class="reqn">e(t)</code> is a centered Gaussian process with
covariance matrix <code class="reqn">Cov(e(t_i),e(t_j))=0.3 \exp(-\frac{\lvert t_i-t_j \rvert}{0.3})</code>
The remaining 50 functions are generated from model <code>i_sim</code> with
<code>i_sim</code> <code class="reqn">\in \{1, \ldots, 8\}.</code>
The first three models contain changes in the mean, while the covariance
matrix does not change. Model 4 and 5 are obtained by multiplying the
covariance matrix by a constant. Model 6 is obtained from adding to
<code class="reqn">E_1(t)</code> a centered Gaussian process <code class="reqn">h(t)</code> whose covariance matrix
is given by <code class="reqn">Cov(e(t_i),e(t_j))=0.5 \exp (-\frac{\lvert t_i-t_j\rvert}{0.2})</code>.
Model 7 and 8 are obtained by a different mean function.
</p>

<dl>
<dt>Model 1.</dt><dd><p><code class="reqn">X_1(t)=30t^{\frac{3}{2}}(1-t)+0.5+e(t).</code></p>
</dd>
<dt>Model 2.</dt><dd><p><code class="reqn">X_2(t)=30t^{\frac{3}{2}}(1-t)+0.75+e(t).</code></p>
</dd>
<dt>Model 3.</dt><dd><p><code class="reqn">X_3(t)=30t^{\frac{3}{2}}(1-t)+1+e(t).</code></p>
</dd>
<dt>Model 4.</dt><dd><p><code class="reqn">X_4(t)=30t^{\frac{3}{2}}(1-t)+2 e(t).</code></p>
</dd>
<dt>Model 5.</dt><dd><p><code class="reqn">X_5(t)=30t^{\frac{3}{2}}(1-t)+0.25 e(t).</code></p>
</dd>
<dt>Model 6.</dt><dd><p><code class="reqn">X_6(t)=30t^{\frac{3}{2}}(1-t)+ h(t).</code></p>
</dd>
<dt>Model 7.</dt><dd><p><code class="reqn">X_7(t)=30t{(1-t)}^2+ h(t).</code></p>
</dd>
<dt>Model 8.</dt><dd><p><code class="reqn">X_8(t)=30t{(1-t)}^2+ e(t).</code></p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>sim_model_ex1(n = 50, p = 30, i_sim = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_model_ex1_+3A_n">n</code></td>
<td>
<p>Number of curves to generate for each of the two groups.
Set to 50 by default.</p>
</td></tr>
<tr><td><code id="sim_model_ex1_+3A_p">p</code></td>
<td>
<p>Number of grid points of the curves.
Curves are generated over the interval <code class="reqn">[0, 1]</code>.
Set to 30 grid point by default.</p>
</td></tr>
<tr><td><code id="sim_model_ex1_+3A_i_sim">i_sim</code></td>
<td>
<p>Integer set to <code class="reqn">1, \ldots, 8</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data matrix of size <code class="reqn">2n \times p</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sm1 &lt;- sim_model_ex1()
dim(sm1)

</code></pre>

<hr>
<h2 id='sim_model_ex2'>Function for generating functional data in one or multiple dimension</h2><span id='topic+sim_model_ex2'></span>

<h3>Description</h3>

<p>The function can generate one-dimensional or multi-dimensional curves.
For <code>i_sim</code> 1 or 2, one-dimensional curves are generated.
For <code>i_sim</code> 3 or 4, multi-dimensional curves are generated.
ADD REFERENCES
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_model_ex2(n = 50, p = 150, i_sim = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_model_ex2_+3A_n">n</code></td>
<td>
<p>Number of curves to generate for each of the two groups. Set to 50 by default.</p>
</td></tr>
<tr><td><code id="sim_model_ex2_+3A_p">p</code></td>
<td>
<p>Number of grid points of the curves.
Curves are generated over the interval <code class="reqn">[0, 1]</code>. Set to 150 grid point by default.</p>
</td></tr>
<tr><td><code id="sim_model_ex2_+3A_i_sim">i_sim</code></td>
<td>
<p>Integer set to <code class="reqn">1, \ldots, 4</code>
NULL by default in which case a seed is not set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data matrix of size <code class="reqn">2n \times p</code> if <code class="reqn">i\_sim \in {1,2}</code>
or an array of dimensions
<code class="reqn">2n \times p \times 2</code> if <code class="reqn">i\_sim \in {3, 4}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sm1 &lt;- sim_model_ex2()
dim(sm1) # This should output (100, 150) by default, since n = 50 and p = 150

sm4 &lt;- sim_model_ex2(i_sim = 4)
dim(sm4) # This should output (100, 150, 2) by default, since n = 50 and p = 150

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
