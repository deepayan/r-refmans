<!DOCTYPE html><html><head><title>Help for package rxode2random</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rxode2random}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.cbindOme'><p>cbind Ome</p></a></li>
<li><a href='#.expandPars'><p>Expand parameters</p></a></li>
<li><a href='#.vecDf'><p>Convert numeric vector to repeated data.frame</p></a></li>
<li><a href='#cvPost'><p>Sample a covariance Matrix from the Posterior Inverse Wishart</p>
distribution.</a></li>
<li><a href='#dfWishart'><p>This uses simulations to match the rse</p></a></li>
<li><a href='#invWR1d'><p>One correlation sample from the Inverse Wishart distribution</p></a></li>
<li><a href='#phi'><p>Cumulative distribution of standard normal</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rinvchisq'><p>Scaled Inverse Chi Squared distribution</p></a></li>
<li><a href='#rLKJ1'><p>One correlation sample from the LKJ distribution</p></a></li>
<li><a href='#rxbeta'><p>Simulate beta variable from threefry generator</p></a></li>
<li><a href='#rxbinom'><p>Simulate Binomial variable from threefry generator</p></a></li>
<li><a href='#rxcauchy'><p>Simulate Cauchy variable from threefry generator</p></a></li>
<li><a href='#rxchisq'><p>Simulate chi-squared variable from threefry generator</p></a></li>
<li><a href='#rxexp'><p>Simulate exponential variable from threefry generator</p></a></li>
<li><a href='#rxf'><p>Simulate F variable from threefry generator</p></a></li>
<li><a href='#rxgamma'><p>Simulate gamma variable from threefry generator</p></a></li>
<li><a href='#rxgeom'><p>Simulate geometric variable from threefry generator</p></a></li>
<li><a href='#rxGetSeed'><p>Get the rxode2 seed</p></a></li>
<li><a href='#rxnbinom'><p>Simulate Binomial variable from threefry generator</p></a></li>
<li><a href='#rxnorm'><p>Simulate random normal variable from threefry/vandercorput generator</p></a></li>
<li><a href='#rxode2randomMd5'><p>Get the MD5 hash of the current rxode2random revision</p></a></li>
<li><a href='#rxord'><p>Simulate ordinal value</p></a></li>
<li><a href='#rxpois'><p>Simulate random Poisson variable from threefry generator</p></a></li>
<li><a href='#rxPp'><p>Simulate a from a Poisson process</p></a></li>
<li><a href='#rxRmvn'><p>Simulate from a (truncated) multivariate normal</p></a></li>
<li><a href='#rxSeedEng'><p>This seeds the engine based on the number of cores used in random number generation</p></a></li>
<li><a href='#rxSetSeed'><p>Set the parallel seed for rxode2 random number generation</p></a></li>
<li><a href='#rxt'><p>Simulate student t variable from threefry generator</p></a></li>
<li><a href='#rxunif'><p>Simulate uniform variable from threefry generator</p></a></li>
<li><a href='#rxweibull'><p>Simulate Weibull variable from threefry generator</p></a></li>
<li><a href='#rxWithSeed'><p>Preserved seed and possibly set the seed</p></a></li>
<li><a href='#swapMatListWithCube'><p>Swaps the matrix list with a cube</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Random Number Generation Functions for 'rxode2'</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.13</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the random number generation (in parallel) needed for
   'rxode2' (Wang, Hallow and  James (2016) &lt;<a href="https://doi.org/10.1002%2Fpsp4.12052">doi:10.1002/psp4.12052</a>&gt;) and 'nlmixr2'
    (Fidler et al (2019) &lt;<a href="https://doi.org/10.1002%2Fpsp4.12445">doi:10.1002/psp4.12445</a>&gt;).
    This split will reduce computational burden of recompiling 'rxode2'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nlmixr2.github.io/rxode2random/">https://nlmixr2.github.io/rxode2random/</a>,
<a href="https://github.com/nlmixr2/rxode2random/">https://github.com/nlmixr2/rxode2random/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nlmixr2/rxode2random/issues/">https://github.com/nlmixr2/rxode2random/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Rcpp, checkmate, lotri, rxode2parse (&ge; 2.0.17)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>sitmo, rxode2parse (&ge; 2.0.17), Rcpp, RcppArmadillo, BH</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 01:28:49 UTC; matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew L. Fidler <a href="https://orcid.org/0000-0001-8538-6691"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Wenping Wang [ctb],
  Bill Denney <a href="https://orcid.org/0000-0002-5759-428X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew L. Fidler &lt;matthew.fidler@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.cbindOme'>cbind Ome</h2><span id='topic+.cbindOme'></span>

<h3>Description</h3>

<p>cbind Ome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cbindOme(et, mat, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cbindOme_+3A_et">et</code></td>
<td>
<p>The theta data frame</p>
</td></tr>
<tr><td><code id=".cbindOme_+3A_mat">mat</code></td>
<td>
<p>The full matrix simulation from omegas</p>
</td></tr>
<tr><td><code id=".cbindOme_+3A_n">n</code></td>
<td>
<p>number of subject simulated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with et combined with simulated omega matrix values
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.expandPars'>Expand parameters</h2><span id='topic+.expandPars'></span>

<h3>Description</h3>

<p>Expand parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.expandPars(object, params, events, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".expandPars_+3A_object">object</code></td>
<td>
<p>rxode2 model variables object</p>
</td></tr>
<tr><td><code id=".expandPars_+3A_params">params</code></td>
<td>
<p>parameters to expand</p>
</td></tr>
<tr><td><code id=".expandPars_+3A_events">events</code></td>
<td>
<p>event table to help with the expansion</p>
</td></tr>
<tr><td><code id=".expandPars_+3A_control">control</code></td>
<td>
<p>control structure to help with the parameter generation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Expanded parameters for simulation
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.vecDf'>Convert numeric vector to repeated data.frame</h2><span id='topic+.vecDf'></span>

<h3>Description</h3>

<p>Convert numeric vector to repeated data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vecDf(vec, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".vecDf_+3A_vec">vec</code></td>
<td>
<p>Named input vector</p>
</td></tr>
<tr><td><code id=".vecDf_+3A_n">n</code></td>
<td>
<p>Number of columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with repeated vec
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='cvPost'>Sample a covariance Matrix from the Posterior Inverse Wishart
distribution.</h2><span id='topic+cvPost'></span>

<h3>Description</h3>

<p>Note this Inverse wishart rescaled to match the original scale of
the covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvPost(
  nu,
  omega,
  n = 1L,
  omegaIsChol = FALSE,
  returnChol = FALSE,
  type = c("invWishart", "lkj", "separation"),
  diagXformType = c("log", "identity", "variance", "nlmixrSqrt", "nlmixrLog",
    "nlmixrIdentity")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvPost_+3A_nu">nu</code></td>
<td>
<p>Degrees of Freedom (Number of Observations) for
covariance matrix simulation.</p>
</td></tr>
<tr><td><code id="cvPost_+3A_omega">omega</code></td>
<td>
<p>Either the estimate of covariance matrix or the
estimated standard deviations in matrix form each row forming
the standard deviation simulated values</p>
</td></tr>
<tr><td><code id="cvPost_+3A_n">n</code></td>
<td>
<p>Number of Matrices to sample.  By default this is 1.
This is only useful when <code>omega</code> is a matrix.  Otherwise
it is determined by the number of rows in the input
<code>omega</code> matrix of standard deviations</p>
</td></tr>
<tr><td><code id="cvPost_+3A_omegaischol">omegaIsChol</code></td>
<td>
<p>is an indicator of if the omega matrix is in
the Cholesky decomposition. This is only used when <code>type="invWishart"</code></p>
</td></tr>
<tr><td><code id="cvPost_+3A_returnchol">returnChol</code></td>
<td>
<p>Return the Cholesky decomposition of the
covariance matrix sample. This is only used when <code>type="invWishart"</code></p>
</td></tr>
<tr><td><code id="cvPost_+3A_type">type</code></td>
<td>
<p>The type of covariance posterior that is being
simulated.  This can be:
</p>

<ul>
<li> <p><code>invWishart</code> The posterior is an inverse wishart; This allows
for correlations between parameters to be modeled.  All the
uncertainty in the parameter is captured in the degrees of freedom
parameter.
</p>
</li>
<li> <p><code>lkj</code> The posterior separates the standard deviation
estimates (modeled outside and provided in the <code>omega</code>
argument) and the correlation estimates. The correlation estimate
is simulated with the <code><a href="#topic+rLKJ1">rLKJ1()</a></code>.  This simulation uses
the relationship <code>eta=(nu-1)/2</code>.  This is relationship based
on the proof of the relationship between the restricted
LKJ-distribution and inverse wishart distribution (XXXXXX).  Once
the correlation posterior is calculated, the estimated standard
deviations are then combined with the simulated correlation matrix
to create the covariance matrix.
</p>
</li>
<li> <p><code>separation</code> Like the <code>lkj</code> option, this separates out
the estimation of the correlation and standard deviation.  Instead
of using the <code>LKJ</code> distribution to simulate the correlation,
it simulates the inverse wishart of the identity matrix and
converts the result to a correlation matrix.  This correlation
matrix is then used with the standard deviation to calculate the
simulated covariance matrix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cvPost_+3A_diagxformtype">diagXformType</code></td>
<td>
<p>Diagonal transformation type.  These could be:
</p>

<ul>
<li> <p><code>log</code> The standard deviations are log transformed, so the
actual standard deviations are exp(omega)
</p>
</li>
<li> <p><code>identity</code> The standard deviations are not transformed. The
standard deviations are not transformed;  They should be positive.
</p>
</li>
<li> <p><code>variance</code> The variances are specified in the <code>omega</code>
matrix; They are transformed into standard deviations.
</p>
</li>
<li> <p><code>nlmixrSqrt</code> These standard deviations come from an nlmixr
omega matrix where diag(chol(inv(omega))) = x^2
</p>
</li>
<li> <p><code>nlmixrLog</code> These standard deviations come from a nlmixr
omega matrix omega matrix where diag(chol(solve(omega))) = exp(x)
</p>
</li>
<li> <p><code>nlmixrIdentity</code> These standard deviations come from a nlmixr
omega matrix omega matrix where diag(chol(solve(omega))) = x
</p>
</li></ul>

<p>The nlmixr transformations only make sense when there is no
off-diagonal correlations modeled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If your covariance matrix is a 1x1 matrix, this uses an scaled
inverse chi-squared which is equivalent to the Inverse Wishart
distribution in the uni-directional case.
</p>
<p>In general, the separation strategy is preferred for diagonal
matrices.  If the dimension of the matrix is below 10, <code>lkj</code>
is numerically faster than <code>separation</code> method.  However, the
<code>lkj</code> method has densities too close to zero (XXXX) when the
dimension is above 10.  In that case, though computationally more
expensive <code>separation</code> method performs better.
</p>
<p>For matrices with modeled covariances, the easiest method to use
is the inverse Wishart which allows the simulation of correlation
matrices (XXXX).  This method is more well suited for well behaved
matrices, that is the variance components are not too low or too
high.  When modeling nonlinear mixed effects modeling matrices
with too high or low variances are considered sub-optimal in
describing a system.  With these rules in mind, it is reasonable
to use the inverse Wishart.
</p>


<h3>Value</h3>

<p>a matrix (n=1) or a list of matrices  (n &gt; 1)
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler &amp; Wenping Wang
</p>


<h3>References</h3>

<p>Alvarez I, Niemi J and Simpson M. (2014) <em>Bayesian Inference for a
Covariance Matrix</em>. Conference on Applied Statistics in Agriculture.
<a href="https://newprairiepress.org/cgi/viewcontent.cgi?article=1004&amp;context=agstatconference">https://newprairiepress.org/cgi/viewcontent.cgi?article=1004&amp;context=agstatconference</a>
</p>
<p>Wang1 Z, Wu Y, and Chu H. (2018) <em>On Equivalence of the LKJ
distribution and the restricted Wishart distribution</em>. arXiv:1809.04746
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sample a single covariance.
draw1 &lt;- cvPost(3, matrix(c(1, .3, .3, 1), 2, 2))

## Sample 3 covariances
set.seed(42)
draw3 &lt;- cvPost(3, matrix(c(1, .3, .3, 1), 2, 2), n = 3)

## Sample 3 covariances, but return the cholesky decomposition
set.seed(42)
draw3c &lt;- cvPost(3, matrix(c(1, .3, .3, 1), 2, 2), n = 3, returnChol = TRUE)

## Sample 3 covariances with lognormal standard deviations via LKJ
## correlation sample
cvPost(3, sapply(1:3, function(...) {
  rnorm(10)
}), type = "lkj")

## or return cholesky decomposition
cvPost(3, sapply(1:3, function(...) {
  rnorm(10)
}),
type = "lkj",
returnChol = TRUE
)

## Sample 3 covariances with lognormal standard deviations via separation
## strategy using inverse Wishart correlation sample
cvPost(3, sapply(1:3, function(...) {
  rnorm(10)
}), type = "separation")

## or returning the cholesky decomposition
cvPost(3, sapply(1:3, function(...) {
  rnorm(10)
}),
type = "separation",
returnChol = TRUE
)
</code></pre>

<hr>
<h2 id='dfWishart'>This uses simulations to match the rse</h2><span id='topic+dfWishart'></span>

<h3>Description</h3>

<p>This uses simulations to match the rse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfWishart(omega, n, rse, upper, totN = 1000, diag = TRUE, seed = 1234)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfWishart_+3A_omega">omega</code></td>
<td>
<p>represents the matrix for simulation</p>
</td></tr>
<tr><td><code id="dfWishart_+3A_n">n</code></td>
<td>
<p>This represents the number of subjects/samples this comes
from (used to calculate rse).  When present it assumes the rse=
sqrt(2)/sqrt(n)</p>
</td></tr>
<tr><td><code id="dfWishart_+3A_rse">rse</code></td>
<td>
<p>This is the rse that we try to match, if not specified,
it is derived from <code>n</code></p>
</td></tr>
<tr><td><code id="dfWishart_+3A_upper">upper</code></td>
<td>
<p>The upper boundary for root finding in terms of
degrees of freedom.  If not specified, it is n*200</p>
</td></tr>
<tr><td><code id="dfWishart_+3A_totn">totN</code></td>
<td>
<p>This represents the total number of simulated inverse
wishart deviates</p>
</td></tr>
<tr><td><code id="dfWishart_+3A_diag">diag</code></td>
<td>
<p>When <code>TRUE</code>, represents the rse to match is the
diagonals, otherwise it is the total matrix.</p>
</td></tr>
<tr><td><code id="dfWishart_+3A_seed">seed</code></td>
<td>
<p>to make the simulation reproducible, this represents
the seed that is used for simulating the inverse Wishart
distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output from <code>uniroot()</code> to find the right estimate
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dfWishart(lotri::lotri(a+b~c(1, 0.5, 1)), 100)

</code></pre>

<hr>
<h2 id='invWR1d'>One correlation sample from the Inverse Wishart distribution</h2><span id='topic+invWR1d'></span>

<h3>Description</h3>

<p>This correlation is constructed by transformation of the Inverse Wishart
random covariate to a correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invWR1d(d, nu, omegaIsChol = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invWR1d_+3A_d">d</code></td>
<td>
<p>The dimension of the correlation matrix</p>
</td></tr>
<tr><td><code id="invWR1d_+3A_nu">nu</code></td>
<td>
<p>Degrees of freedom of the Wishart distribution</p>
</td></tr>
<tr><td><code id="invWR1d_+3A_omegaischol">omegaIsChol</code></td>
<td>
<p>is an indicator of if the omega matrix is in
the Cholesky decomposition. This is only used when <code>type="invWishart"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>One correlation sample from the inverse wishart
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='phi'>Cumulative distribution of standard normal</h2><span id='topic+phi'></span>

<h3>Description</h3>

<p>Cumulative distribution of standard normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi(q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phi_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cumulative distribution of standard normal distribution
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# phi is equivalent to pnorm(x)
phi(3)

# See
pnorm(3)

# This is provided for NONMEM-like compatibility in rxode2 models
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+lotri'></span><span id='topic+.convertId'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>lotri</dt><dd><p><code><a href="lotri.html#topic+lotri">lotri</a></code></p>
</dd>
<dt>rxode2parse</dt><dd><p><code><a href="rxode2parse.html#topic+dot-convertId">.convertId</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rinvchisq'>Scaled Inverse Chi Squared distribution</h2><span id='topic+rinvchisq'></span>

<h3>Description</h3>

<p>Scaled Inverse Chi Squared distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rinvchisq(n = 1L, nu = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rinvchisq_+3A_n">n</code></td>
<td>
<p>Number of random samples</p>
</td></tr>
<tr><td><code id="rinvchisq_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom of inverse chi square</p>
</td></tr>
<tr><td><code id="rinvchisq_+3A_scale">scale</code></td>
<td>
<p>Scale of inverse chi squared distribution
(default is 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of inverse chi squared deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rinvchisq(3, 4, 1) ## Scale = 1, degrees of freedom = 4
rinvchisq(2, 4, 2) ## Scale = 2, degrees of freedom = 4
</code></pre>

<hr>
<h2 id='rLKJ1'>One correlation sample from the LKJ distribution</h2><span id='topic+rLKJ1'></span>

<h3>Description</h3>

<p>One correlation sample from the LKJ distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rLKJ1(d, eta = 1, cholesky = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rLKJ1_+3A_d">d</code></td>
<td>
<p>The dimension of the correlation matrix</p>
</td></tr>
<tr><td><code id="rLKJ1_+3A_eta">eta</code></td>
<td>
<p>The scaling parameter of the LKJ distribution.
Must be &gt; 1.  Also related to the degrees of freedom nu.
eta = (nu-1)/2.</p>
</td></tr>
<tr><td><code id="rLKJ1_+3A_cholesky">cholesky</code></td>
<td>
<p>boolean; If <code>TRUE</code> return the cholesky
decomposition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation sample from the LKJ distribution
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler (translated to RcppArmadillo) and Emma Schwager
</p>

<hr>
<h2 id='rxbeta'>Simulate beta variable from threefry generator</h2><span id='topic+rxbeta'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxbeta(shape1, shape2, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxbeta_+3A_shape1">shape1</code>, <code id="rxbeta_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="rxbeta_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxbeta_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>beta random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxbeta(0.5, 0.5, n = 10) # with rxbeta you have to explicitly state n
rxbeta(5, 1, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxbeta(1, 3)
</code></pre>

<hr>
<h2 id='rxbinom'>Simulate Binomial variable from threefry generator</h2><span id='topic+rxbinom'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxbinom(size, prob, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxbinom_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="rxbinom_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial.</p>
</td></tr>
<tr><td><code id="rxbinom_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxbinom_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>binomial random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxbinom(10, 0.9, n = 10) # with rxbinom you have to explicitly state n
rxbinom(3, 0.5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxbinom(4, 0.7)
</code></pre>

<hr>
<h2 id='rxcauchy'>Simulate Cauchy variable from threefry generator</h2><span id='topic+rxcauchy'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxcauchy(location = 0, scale = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxcauchy_+3A_location">location</code>, <code id="rxcauchy_+3A_scale">scale</code></td>
<td>
<p>location and scale parameters.</p>
</td></tr>
<tr><td><code id="rxcauchy_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxcauchy_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>Cauchy random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxcauchy(0, 1, n = 10) # with rxcauchy you have to explicitly state n
rxcauchy(0.5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxcauchy(3)
</code></pre>

<hr>
<h2 id='rxchisq'>Simulate chi-squared variable from threefry generator</h2><span id='topic+rxchisq'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxchisq(df, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxchisq_+3A_df">df</code></td>
<td>
<p>degrees of freedom (non-negative, but can be non-integer).</p>
</td></tr>
<tr><td><code id="rxchisq_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxchisq_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>chi squared random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxchisq(0.5, n = 10) # with rxchisq you have to explicitly state n
rxchisq(5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxchisq(1)
</code></pre>

<hr>
<h2 id='rxexp'>Simulate exponential variable from threefry generator</h2><span id='topic+rxexp'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxexp(rate, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxexp_+3A_rate">rate</code></td>
<td>
<p>vector of rates.</p>
</td></tr>
<tr><td><code id="rxexp_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxexp_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>exponential random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxexp(0.5, n = 10) # with rxexp you have to explicitly state n
rxexp(5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxexp(1)



</code></pre>

<hr>
<h2 id='rxf'>Simulate F variable from threefry generator</h2><span id='topic+rxf'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxf(df1, df2, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxf_+3A_df1">df1</code>, <code id="rxf_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom.  <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="rxf_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxf_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>f random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxf(0.5, 0.5, n = 10) # with rxf you have to explicitly state n
rxf(5, 1, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxf(1, 3)
</code></pre>

<hr>
<h2 id='rxgamma'>Simulate gamma variable from threefry generator</h2><span id='topic+rxgamma'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxgamma(shape, rate = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxgamma_+3A_shape">shape</code></td>
<td>
<p>The shape of the gamma random variable</p>
</td></tr>
<tr><td><code id="rxgamma_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="rxgamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxgamma_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>gamma random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxgamma(0.5, n = 10) # with rxgamma you have to explicitly state n
rxgamma(5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxgamma(1)
</code></pre>

<hr>
<h2 id='rxgeom'>Simulate geometric variable from threefry generator</h2><span id='topic+rxgeom'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxgeom(prob, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxgeom_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="rxgeom_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxgeom_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>geometric random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxgeom(0.5, n = 10) # with rxgeom you have to explicitly state n
rxgeom(0.25, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxgeom(0.75)
</code></pre>

<hr>
<h2 id='rxGetSeed'>Get the rxode2 seed</h2><span id='topic+rxGetSeed'></span>

<h3>Description</h3>

<p>Get the rxode2 seed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetSeed()
</code></pre>


<h3>Value</h3>

<p>rxode2 seed state or -1 when the seed isn't set
</p>


<h3>See Also</h3>

<p>rxSetSeed, rxWithSeed, rxWithPreserveSeed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# without setting seed

rxGetSeed()
# Now set the seed
rxSetSeed(42)

rxGetSeed()

rxnorm()

rxGetSeed()

# don't use the rxode2 seed again

rxSetSeed(-1)

rxGetSeed()

rxnorm()

rxGetSeed()

</code></pre>

<hr>
<h2 id='rxnbinom'>Simulate Binomial variable from threefry generator</h2><span id='topic+rxnbinom'></span><span id='topic+rxnbinomMu'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxnbinom(size, prob, n = 1L, ncores = 1L)

rxnbinomMu(size, mu, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxnbinom_+3A_size">size</code></td>
<td>
<p>target for number of successful trials, or dispersion
parameter (the shape parameter of the gamma mixing distribution).
Must be strictly positive, need not be integer.</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_n">n</code></td>
<td>
<p>number of observations.  If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_mu">mu</code></td>
<td>
<p>alternative parametrization via mean: see &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>negative binomial random deviates. Note that <code>rxbinom2</code>
uses the <code>mu</code> parameterization an the <code>rxbinom</code> uses the <code>prob</code>
parameterization (<code>mu=size/(prob+size)</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxnbinom(10, 0.9, n = 10) # with rxbinom you have to explicitly state n
rxnbinom(3, 0.5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxnbinom(4, 0.7)

# use mu parameter
rxnbinomMu(40, 40, n=10)
</code></pre>

<hr>
<h2 id='rxnorm'>Simulate random normal variable from threefry/vandercorput generator</h2><span id='topic+rxnorm'></span>

<h3>Description</h3>

<p>Simulate random normal variable from threefry/vandercorput generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxnorm(mean = 0, sd = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxnorm_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="rxnorm_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="rxnorm_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="rxnorm_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normal random number deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxnorm(n = 10) # with rxnorm you have to explicitly state n
rxnorm(n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxnorm(2, 3) ## The first 2 arguments are the mean and standard deviation

</code></pre>

<hr>
<h2 id='rxode2randomMd5'>Get the MD5 hash of the current rxode2random revision</h2><span id='topic+rxode2randomMd5'></span>

<h3>Description</h3>

<p>Get the MD5 hash of the current rxode2random revision
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2randomMd5()
</code></pre>


<h3>Value</h3>

<p>md5 hash of rxode2random revision
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxode2randomMd5()
</code></pre>

<hr>
<h2 id='rxord'>Simulate ordinal value</h2><span id='topic+rxord'></span>

<h3>Description</h3>

<p>Simulate ordinal value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxord(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxord_+3A_...">...</code></td>
<td>
<p>the probabilities to be simulated.  These should sum up to a number below one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values entered into the 'rxord' simulation will simulate the
probability of falling each group. If it falls outside of the
specified probabilities, it will simulate the group (number of
probabilities specified + 1)
</p>


<h3>Value</h3>

<p>A number from 1 to the (number of probabilities specified + 1)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This will give values 1, and 2
rxord(0.5)
rxord(0.5)
rxord(0.5)
rxord(0.5)

# This will give values 1, 2 and 3
rxord(0.3, 0.3)
rxord(0.3, 0.3)
rxord(0.3, 0.3)

</code></pre>

<hr>
<h2 id='rxpois'>Simulate random Poisson variable from threefry generator</h2><span id='topic+rxpois'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxpois(lambda, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxpois_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) means.</p>
</td></tr>
<tr><td><code id="rxpois_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
<tr><td><code id="rxpois_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>poission random number deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxpois(lambda = 3, n = 10) # with rxpois you have to explicitly state n
rxpois(lambda = 3, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxpois(4) ## The first arguments are the lambda parameter

</code></pre>

<hr>
<h2 id='rxPp'>Simulate a from a Poisson process</h2><span id='topic+rxPp'></span>

<h3>Description</h3>

<p>Simulate a from a Poisson process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxPp(
  n,
  lambda,
  gamma = 1,
  prob = NULL,
  t0 = 0,
  tmax = Inf,
  randomOrder = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxPp_+3A_n">n</code></td>
<td>
<p>Number of time points to simulate in the Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_lambda">lambda</code></td>
<td>
<p>Rate of Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_gamma">gamma</code></td>
<td>
<p>Asymmetry rate of Poisson process.  When gamma=1.0,
this simulates a homogenous Poisson process.  When gamma&lt;1.0,
the Poisson process has more events early, when gamma &gt; 1.0,
the Poisson process has more events late in the process.
</p>
<p>When gamma is non-zero, the tmax should not be infinite but indicate
the end of the Poisson process to be simulated.  In most
pharamcometric cases, this will be the end of the study.
Internally this uses a rate of:
</p>
<p>l(t) = lambda<em>gamma</em>(t/tmax)^(gamma-1)</p>
</td></tr>
<tr><td><code id="rxPp_+3A_prob">prob</code></td>
<td>
<p>When specified, this is a probability function with
one argument, time, that gives the probability that a Poisson
time t is accepted as a rejection time.</p>
</td></tr>
<tr><td><code id="rxPp_+3A_t0">t0</code></td>
<td>
<p>the starting time of the Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_tmax">tmax</code></td>
<td>
<p>the maximum time of the Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_randomorder">randomOrder</code></td>
<td>
<p>when <code>TRUE</code> randomize the order of the Poisson
events.  By default (<code>FALSE</code>) it returns the Poisson process is
in order of how the events occurred.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns a vector of the Poisson process times; If the dropout is &gt;=
tmax, then all the rest of the times are = tmax to indicate the
dropout is equal to or after tmax.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sample homogenous Poisson process of rate 1/10
rxPp(10, 1 / 10)

## Sample inhomogenous Poisson rate of 1/10

rxPp(10, 1 / 10, gamma = 2, tmax = 100)

## Typically the Poisson process times are in a sequential order,
## using randomOrder gives the Poisson process in random order

rxPp(10, 1 / 10, gamma = 2, tmax = 10, randomOrder = TRUE)

## This uses an arbitrary function to sample a non-homogenous Poisson process

rxPp(10, 1 / 10, prob = function(x) {
  1 / x
})
</code></pre>

<hr>
<h2 id='rxRmvn'>Simulate from a (truncated) multivariate normal</h2><span id='topic+rxRmvn'></span>

<h3>Description</h3>

<p>This is simulated with the fast, thread-safe threefry simulator
and can use multiple cores to generate the random deviates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxRmvn(
  n,
  mu = NULL,
  sigma,
  lower = -Inf,
  upper = Inf,
  ncores = 1,
  isChol = FALSE,
  keepNames = TRUE,
  a = 0.4,
  tol = 2.05,
  nlTol = 1e-10,
  nlMaxiter = 100L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxRmvn_+3A_n">n</code></td>
<td>
<p>Number of random row vectors to be simulated OR the
matrix to use for simulation (faster).</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_mu">mu</code></td>
<td>
<p>mean vector</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix for multivariate normal or a list
of covariance matrices. If a list of covariance matrix, each
matrix will simulate <code>n</code> matrices and combine them to a full
matrix</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_lower">lower</code></td>
<td>
<p>is a vector of the lower bound for the truncated
multivariate norm</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_upper">upper</code></td>
<td>
<p>is a vector of the upper bound for the truncated
multivariate norm</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used in the simulation</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_ischol">isChol</code></td>
<td>
<p>A boolean indicating if <code>sigma</code> is a cholesky
decomposition of the covariance matrix.</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_keepnames">keepNames</code></td>
<td>
<p>Keep the names from either the mean or covariance
matrix.</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_a">a</code></td>
<td>
<p>threshold for switching between methods; They can be
tuned for maximum speed;  There are three cases that are considered:
</p>
<p>case 1: a &lt; l &lt; u
</p>
<p>case 2: l &lt; u &lt; -a
</p>
<p>case 3: otherwise
</p>
<p>where l=lower and u = upper</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_tol">tol</code></td>
<td>
<p>When case 3 is used from the above possibilities, the
tol value controls the acceptance rejection and
inverse-transformation;
</p>
<p>When abs(u-l)&gt;tol, uses accept-reject from randn</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_nltol">nlTol</code></td>
<td>
<p>Tolerance for newton line-search</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_nlmaxiter">nlMaxiter</code></td>
<td>
<p>Maximum iterations for newton line-search</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>n==integer</code> (default) the output is an (n x d) matrix
where the i-th row is the i-th simulated vector.
</p>
<p>If <code>is.matrix(n)</code> then the random vector are store in <code>n</code>,
which is provided by the user, and the function returns
<code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler, Zdravko Botev and some from Matteo Fasiolo
</p>


<h3>References</h3>

<p>John K. Salmon, Mark A. Moraes, Ron O. Dror, and David
E. Shaw (2011). Parallel Random Numbers: As Easy as 1, 2, 3.
D. E. Shaw Research, New York, NY 10036, USA.
</p>
<p>The thread safe multivariate normal was inspired from the <code>mvnfast</code> package by Matteo Fasiolo <a href="https://CRAN.R-project.org/package=mvnfast">https://CRAN.R-project.org/package=mvnfast</a>
</p>
<p>The concept of the truncated multivariate normal was
taken from Zdravko Botev Botev (2017) <a href="https://doi.org/10.1111/rssb.12162">doi:10.1111/rssb.12162</a>
and Botev and L'Ecuyer (2015) <a href="https://doi.org/10.1109/WSC.2015.7408180">doi:10.1109/WSC.2015.7408180</a> and
converted to thread safe simulation;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## From mvnfast
## Unlike mvnfast, uses threefry simulation

d &lt;- 5
mu &lt;- 1:d

# Creating covariance matrix
tmp &lt;- matrix(rnorm(d^2), d, d)
mcov &lt;- tcrossprod(tmp, tmp)


set.seed(414)
rxRmvn(4, 1:d, mcov)

set.seed(414)
rxRmvn(4, 1:d, mcov)

set.seed(414)
rxRmvn(4, 1:d, mcov, ncores = 2) # r.v. generated on the second core are different

###### Here we create the matrix that will hold the simulated
#  random variables upfront.
A &lt;- matrix(NA, 4, d)
class(A) &lt;- "numeric" # This is important. We need the elements of A to be of class "numeric".

set.seed(414)
rxRmvn(A, 1:d, mcov, ncores = 2) # This returns NULL ...
A # ... but the result is here

## You can also simulate from a truncated normal:

rxRmvn(10, 1:d, mcov, lower = 1:d - 1, upper = 1:d + 1)


# You can also simulate from different matrices (if they match
# dimensions) by using a list of matrices.

matL &lt;- lapply(1:4, function(...) {
  tmp &lt;- matrix(rnorm(d^2), d, d)
  tcrossprod(tmp, tmp)
})


rxRmvn(4, setNames(1:d, paste0("a", 1:d)), matL)
</code></pre>

<hr>
<h2 id='rxSeedEng'>This seeds the engine based on the number of cores used in random number generation</h2><span id='topic+rxSeedEng'></span>

<h3>Description</h3>

<p>This seeds the engine based on the number of cores used in random number generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSeedEng(ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSeedEng_+3A_ncores">ncores</code></td>
<td>
<p>is the number of cores to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxSeedEng()
</code></pre>

<hr>
<h2 id='rxSetSeed'>Set the parallel seed for rxode2 random number generation</h2><span id='topic+rxSetSeed'></span>

<h3>Description</h3>

<p>This sets the seed for the rxode2 parallel random number generation.
If set, then whenever a seed is set for the threefry or
vandercorput simulation engine, it will use this seed, increment
for the number of seeds and continue with the sequence the next
time the random number generator is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetSeed(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSetSeed_+3A_seed">seed</code></td>
<td>
<p>An integer that represents the rxode2 parallel and
internal random number generator seed.  When positive, use this
seed for random number generation and increment and reseed any
parallel or new engines that are being called. When negative,
turn off the rxode2 seed and generate a seed from the R's uniform
random number generator.  Best practice is to set this seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast, when this is not called, the time that the
vandercorput or threefry simulation engines are seeded it comes
from a uniform random number generated from the standard R random
seed.  This may cause a duplicate seed based on the R seed state.
This means that there could be correlations between simulations
that do not exist This will avoid the birthday problem picking
exactly the same seed using the seed state of the R random number
generator.  The more times the seed is called, the more likely this
becomes.
</p>


<h3>Value</h3>

<p>Nothing, called for its side effects
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>References</h3>

<p>JD Cook. (2016). Random number generator seed mistakes.
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>
</p>


<h3>See Also</h3>

<p>rxGetSeed, rxWithSeed, rxWithPreserveSeed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxSetSeed(42)

# seed with generator 42
rxnorm()

# Use R's random number generator
rnorm(1)

rxSetSeed(42)

# reproduces the same number
rxnorm()

# But R's random number is not the same

rnorm(1)

# If we reset this to use the R's seed
# (internally rxode2 uses a uniform random number to span seeds)
# This can lead to duplicate sequences and seeds

rxSetSeed(-1)

# Now set seed works for both.

# This is not recommended, but illustrates the different types of
# seeds that can be generated.

set.seed(42)

rxnorm()

rnorm(1)

set.seed(42)

rxnorm()

rnorm(1)

</code></pre>

<hr>
<h2 id='rxt'>Simulate student t variable from threefry generator</h2><span id='topic+rxt'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxt(df, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxt_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt; 0</code>, maybe non-integer).  <code>df
      = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="rxt_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxt_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>t-distribution random numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxt(df = 3, n = 10) # with rxt you have to explicitly state n
rxt(df = 3, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxt(4) ## The first argument is the df parameter

</code></pre>

<hr>
<h2 id='rxunif'>Simulate uniform variable from threefry generator</h2><span id='topic+rxunif'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxunif(min = 0, max = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxunif_+3A_min">min</code>, <code id="rxunif_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the distribution.  Must be finite.</p>
</td></tr>
<tr><td><code id="rxunif_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxunif_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>uniform random numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

rxunif(min = 0, max = 4, n = 10) # with rxunif you have to explicitly state n
rxunif(min = 0, max = 4, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxunif()

</code></pre>

<hr>
<h2 id='rxweibull'>Simulate Weibull variable from threefry generator</h2><span id='topic+rxweibull'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxweibull(shape, scale = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxweibull_+3A_shape">shape</code>, <code id="rxweibull_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters, the latter defaulting to 1.</p>
</td></tr>
<tr><td><code id="rxweibull_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxweibull_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>Weibull random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use threefry engine

# with rxweibull you have to explicitly state n
rxweibull(shape = 1, scale = 4, n = 10)

# You can parallelize the simulation using openMP
rxweibull(shape = 1, scale = 4, n = 10, ncores = 2)

rxweibull(3)
</code></pre>

<hr>
<h2 id='rxWithSeed'>Preserved seed and possibly set the seed</h2><span id='topic+rxWithSeed'></span><span id='topic+rxWithPreserveSeed'></span>

<h3>Description</h3>

<p>Preserved seed and possibly set the seed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxWithSeed(
  seed,
  code,
  rxseed = rxGetSeed(),
  kind = "default",
  normal.kind = "default",
  sample.kind = "default"
)

rxWithPreserveSeed(code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxWithSeed_+3A_seed">seed</code></td>
<td>
<p>R seed to use for the session</p>
</td></tr>
<tr><td><code id="rxWithSeed_+3A_code">code</code></td>
<td>
<p>Is the code to evaluate</p>
</td></tr>
<tr><td><code id="rxWithSeed_+3A_rxseed">rxseed</code></td>
<td>
<p>is the rxode2 seed that is being preserved</p>
</td></tr>
<tr><td><code id="rxWithSeed_+3A_kind">kind</code></td>
<td>
<p>character or <code>NULL</code>.  If <code>kind</code> is a character
string, set <span class="rlang"><b>R</b></span>'s RNG to the kind desired.  Use <code>"default"</code> to
return to the <span class="rlang"><b>R</b></span> default.  See &lsquo;Details&rsquo; for the
interpretation of <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rxWithSeed_+3A_normal.kind">normal.kind</code></td>
<td>
<p>character string or <code>NULL</code>.  If it is a character
string, set the method of Normal generation.  Use <code>"default"</code>
to return to the <span class="rlang"><b>R</b></span> default.  <code>NULL</code> makes no change.</p>
</td></tr>
<tr><td><code id="rxWithSeed_+3A_sample.kind">sample.kind</code></td>
<td>
<p>character string or <code>NULL</code>.  If it is a character
string, set the method of discrete uniform generation (used in 
<code><a href="base.html#topic+sample">sample</a></code>, for instance).  Use <code>"default"</code> to return to 
the <span class="rlang"><b>R</b></span> default.  <code>NULL</code> makes no change.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns whatever the code is returning
</p>


<h3>See Also</h3>

<p>rxGetSeed, rxSetSeed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxGetSeed()
rxWithSeed(1, {
   print(rxGetSeed())
   rxnorm()
   print(rxGetSeed())
   rxnorm()
}, rxseed=3)

</code></pre>

<hr>
<h2 id='swapMatListWithCube'>Swaps the matrix list with a cube</h2><span id='topic+swapMatListWithCube'></span>

<h3>Description</h3>

<p>Swaps the matrix list with a cube
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swapMatListWithCube(matrixListOrCube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swapMatListWithCube_+3A_matrixlistorcube">matrixListOrCube</code></td>
<td>
<p>Either a list of 2-dimensional matrices or a cube of matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or a cube (opposite format as input)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create matrix list
matLst &lt;- cvPost(10, lotri::lotri(a+b~c(1, 0.25, 1)), 3)
print(matLst)

# Convert to cube
matCube &lt;- swapMatListWithCube(matLst)
print(matCube)

# Convert back to list
matLst2 &lt;- swapMatListWithCube(matCube)
print(matLst2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
