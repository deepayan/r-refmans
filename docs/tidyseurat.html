<!DOCTYPE html><html lang="en"><head><title>Help for package tidyseurat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyseurat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_class'><p>Add class to abject</p></a></li>
<li><a href='#aggregate_cells'><p>Aggregate cells</p></a></li>
<li><a href='#arrange'><p>Order rows using column values</p></a></li>
<li><a href='#as_tibble'><p>Coerce lists, matrices, and more to data frames</p></a></li>
<li><a href='#bind_rows'><p>Efficiently bind multiple data frames by row and column</p></a></li>
<li><a href='#cell_type_df'><p>Cell types of 80 PBMC single cells</p></a></li>
<li><a href='#count'><p>Count the observations in each group</p></a></li>
<li><a href='#distinct'><p>Keep distinct/unique rows</p></a></li>
<li><a href='#drop_class'><p>Remove class to abject</p></a></li>
<li><a href='#extract'><p>Extract a character column into multiple columns using regular</p>
expression groups</a></li>
<li><a href='#filter'><p>Keep rows that match a condition</p></a></li>
<li><a href='#formatting'><p>Printing tibbles</p></a></li>
<li><a href='#full_join'><p>Mutating joins</p></a></li>
<li><a href='#get_abundance_sc_long'><p>get abundance long</p></a></li>
<li><a href='#get_abundance_sc_wide'><p>get abundance wide</p></a></li>
<li><a href='#ggplot'><p>Create a new <code>ggplot</code> from a <code>tidyseurat</code></p></a></li>
<li><a href='#glimpse'><p>Get a glimpse of your data</p></a></li>
<li><a href='#group_by'><p>Group by one or more variables</p></a></li>
<li><a href='#group_split'><p>Split data frame by groups</p></a></li>
<li><a href='#inner_join'><p>Mutating joins</p></a></li>
<li><a href='#join_features'><p>join_features</p></a></li>
<li><a href='#join_transcripts'><p>(DEPRECATED) Extract and join information for transcripts.</p></a></li>
<li><a href='#left_join'><p>Mutating joins</p></a></li>
<li><a href='#mutate'><p>Create, modify, and delete columns</p></a></li>
<li><a href='#nest'><p>Nest rows into a list-column of data frames</p></a></li>
<li><a href='#pbmc_small_nested_interactions'><p>Intercellular ligand-receptor interactions for</p>
38 ligands from a single cell RNA-seq cluster.</a></li>
<li><a href='#pivot_longer'><p>Pivot data from wide to long</p></a></li>
<li><a href='#plotly'><p>Initiate a plotly visualization</p></a></li>
<li><a href='#pull'><p>Extract a single column</p></a></li>
<li><a href='#quo_names'><p>Convert array of quosure (e.g. c(col_a, col_b)) into character vector</p></a></li>
<li><a href='#rename'><p>Rename columns</p></a></li>
<li><a href='#return_arguments_of'><p>returns variables from an expression</p></a></li>
<li><a href='#right_join'><p>Mutating joins</p></a></li>
<li><a href='#rowwise'><p>Group input by rows</p></a></li>
<li><a href='#sample_n'><p>Sample n rows from a table</p></a></li>
<li><a href='#select'><p>Keep or drop columns using their names and types</p></a></li>
<li><a href='#separate'><p>Separate a character column into multiple columns with a regular</p>
expression or numeric locations</a></li>
<li><a href='#slice'><p>Subset rows using their positions</p></a></li>
<li><a href='#summarise'><p>Summarise each group down to one row</p></a></li>
<li><a href='#tbl_format_header'><p>Format the header of a tibble</p></a></li>
<li><a href='#tidy'><p>tidy for 'Seurat'</p></a></li>
<li><a href='#unite'><p>Unite multiple columns into one by pasting strings together</p></a></li>
<li><a href='#unnest'><p>Unnest a list-column of data frames into rows and columns</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Brings Seurat to the Tidyverse</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Description:</td>
<td>It creates an invisible layer that allow to see the 'Seurat' object 
    as tibble and interact seamlessly with the tidyverse.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), ttservice (&ge; 0.3.8), SeuratObject</td>
</tr>
<tr>
<td>Imports:</td>
<td>Seurat (&ge; 4.3.0), tibble, dplyr, magrittr, tidyr (&ge; 1.2.0),
ggplot2, rlang, purrr, lifecycle, methods, plotly, tidyselect,
utils, ellipsis, vctrs, pillar, stringr, cli, fansi, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, GGally, markdown, SingleR</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>biocViews:</td>
<td>AssayDomain, Infrastructure, RNASeq, DifferentialExpression,
GeneExpression, Normalization, Clustering, QualityControl,
Sequencing, Transcription, Transcriptomics</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stemangiola/tidyseurat">https://github.com/stemangiola/tidyseurat</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stemangiola/tidyseurat/issues">https://github.com/stemangiola/tidyseurat/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 23:19:30 UTC; mangiola.s</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefano Mangiola [aut, cre],
  Maria Doyle [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefano Mangiola &lt;mangiolastefano@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 04:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>void
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small %&gt;% print()
</code></pre>

<hr>
<h2 id='add_class'>Add class to abject</h2><span id='topic+add_class'></span>

<h3>Description</h3>

<p>Add class to abject
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_class(var, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_class_+3A_var">var</code></td>
<td>
<p>A tibble</p>
</td></tr>
<tr><td><code id="add_class_+3A_name">name</code></td>
<td>
<p>A character name of the attribute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with an additional attribute
</p>

<hr>
<h2 id='aggregate_cells'>Aggregate cells</h2><span id='topic+aggregate_cells'></span><span id='topic+aggregate_cells+2CSeurat-method'></span>

<h3>Description</h3>

<p>Combine cells into groups based on shared variables and aggregate feature counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Seurat'
aggregate_cells(
  .data,
  .sample = NULL,
  slot = "data",
  assays = NULL,
  aggregation_function = Matrix::rowSums,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate_cells_+3A_.data">.data</code></td>
<td>
<p>A tidyseurat object</p>
</td></tr>
<tr><td><code id="aggregate_cells_+3A_.sample">.sample</code></td>
<td>
<p>A vector of variables by which cells are aggregated</p>
</td></tr>
<tr><td><code id="aggregate_cells_+3A_slot">slot</code></td>
<td>
<p>The slot to which the function is applied</p>
</td></tr>
<tr><td><code id="aggregate_cells_+3A_assays">assays</code></td>
<td>
<p>The assay to which the function is applied</p>
</td></tr>
<tr><td><code id="aggregate_cells_+3A_aggregation_function">aggregation_function</code></td>
<td>
<p>The method of cell-feature value aggregation</p>
</td></tr>
<tr><td><code id="aggregate_cells_+3A_...">...</code></td>
<td>
<p>Used for future extendibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small_pseudo_bulk &lt;- pbmc_small |&gt;
  aggregate_cells(c(groups, letter.idents), assays="RNA")

</code></pre>

<hr>
<h2 id='arrange'>Order rows using column values</h2><span id='topic+arrange'></span><span id='topic+arrange.Seurat'></span>

<h3>Description</h3>

<p><code>arrange()</code> orders the rows of a data frame by the values of selected
columns.
</p>
<p>Unlike other dplyr verbs, <code>arrange()</code> largely ignores grouping; you
need to explicitly mention grouping variables (or use  <code>.by_group = TRUE</code>)
in order to group by them, and functions of variables are evaluated
once per data frame, not once per group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
arrange(.data, ..., .by_group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="arrange_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="arrange_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped data frames only.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Missing values</h4>

<p>Unlike base sorting with <code>sort()</code>, <code>NA</code> are:
</p>

<ul>
<li><p> always sorted to the end for local data, even when wrapped with <code>desc()</code>.
</p>
</li>
<li><p> treated differently for remote data, depending on the backend.
</p>
</li></ul>




<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> All rows appear in the output, but (usually) in a different place.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Groups are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+mutate">mutate</a>()</code>,
<code><a href="#topic+rename">rename</a>()</code>,
<code><a href="#topic+slice">slice</a>()</code>,
<code><a href="#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt;
    arrange(nFeature_RNA)

</code></pre>

<hr>
<h2 id='as_tibble'>Coerce lists, matrices, and more to data frames</h2><span id='topic+as_tibble'></span><span id='topic+as_tibble.Seurat'></span>

<h3>Description</h3>

<p><code>as_tibble()</code> turns an existing object, such as a data frame or
matrix, into a so-called tibble, a data frame with class <code><a href="tibble.html#topic+tbl_df">tbl_df</a></code>. This is
in contrast with <code><a href="tibble.html#topic+tibble">tibble()</a></code>, which builds a tibble from individual columns.
<code>as_tibble()</code> is to <code><a href="tibble.html#topic+tibble">tibble()</a></code> as <code><a href="base.html#topic+as.data.frame">base::as.data.frame()</a></code> is to
<code><a href="base.html#topic+data.frame">base::data.frame()</a></code>.
</p>
<p><code>as_tibble()</code> is an S3 generic, with methods for:
</p>

<ul>
<li> <p><code><a href="base.html#topic+data.frame">data.frame</a></code>: Thin wrapper around the <code>list</code> method
that implements tibble's treatment of <a href="tibble.html#topic+rownames">rownames</a>.
</p>
</li>
<li> <p><code><a href="base.html#topic+matrix">matrix</a></code>, <code><a href="stats.html#topic+poly">poly</a></code>,
<code><a href="stats.html#topic+ts">ts</a></code>, <code><a href="base.html#topic+table">table</a></code>
</p>
</li>
<li><p> Default: Other inputs are first coerced with <code><a href="base.html#topic+as.data.frame">base::as.data.frame()</a></code>.
</p>
</li></ul>

<p><code>as_tibble_row()</code> converts a vector to a tibble with one row.
If the input is a list, all elements must have size one.
</p>
<p><code>as_tibble_col()</code> converts a vector to a tibble with one column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
as_tibble(
  x,
  ...,
  .name_repair = c("check_unique", "unique", "universal", "minimal"),
  rownames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_tibble_+3A_x">x</code></td>
<td>
<p>A data frame, list, matrix, or other object that could reasonably be
coerced to a tibble.</p>
</td></tr>
<tr><td><code id="as_tibble_+3A_...">...</code></td>
<td>
<p>Unused, for extensibility.</p>
</td></tr>
<tr><td><code id="as_tibble_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
<tr><td><code id="as_tibble_+3A_rownames">rownames</code></td>
<td>
<p>How to treat existing row names of a data frame or matrix:
</p>

<ul>
<li> <p><code>NULL</code>: remove row names. This is the default.
</p>
</li>
<li> <p><code>NA</code>: keep row names.
</p>
</li>
<li><p> A string: the name of a new column. Existing rownames are transferred
into this column and the <code>row.names</code> attribute is deleted.
No name repair is applied to the new column name, even if <code>x</code> already contains
a column of that name.
Use <code>as_tibble(rownames_to_column(...))</code> to safeguard against this case.
</p>
</li></ul>

<p>Read more in <a href="tibble.html#topic+rownames">rownames</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'tibble'
</p>


<h3>Row names</h3>

<p>The default behavior is to silently remove row names.
</p>
<p>New code should explicitly convert row names to a new column using the
<code>rownames</code> argument.
</p>
<p>For existing code that relies on the retention of row names, call
<code>pkgconfig::set_config("tibble::rownames" = NA)</code> in your script or in your
package's <code><a href="base.html#topic+.onLoad">.onLoad()</a></code>  function.
</p>


<h3>Life cycle</h3>

<p>Using <code>as_tibble()</code> for vectors is superseded as of version 3.0.0,
prefer the more expressive <code>as_tibble_row()</code> and
<code>as_tibble_col()</code> variants for new code.
</p>


<h3>See Also</h3>

<p><code><a href="tibble.html#topic+tibble">tibble()</a></code> constructs a tibble from individual columns. <code><a href="tibble.html#topic+enframe">enframe()</a></code>
converts a named vector to a tibble with a column of names and column of
values. Name repair is implemented using <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; as_tibble()

</code></pre>

<hr>
<h2 id='bind_rows'>Efficiently bind multiple data frames by row and column</h2><span id='topic+bind_rows'></span><span id='topic+bind_rows.Seurat'></span><span id='topic+bind_cols.Seurat'></span><span id='topic+bind_cols'></span>

<h3>Description</h3>

<p>This is an efficient implementation of the common pattern of
'do.call(rbind, dfs)' or 'do.call(cbind, dfs)' for binding many
data frames into one.
</p>
<p>This is an efficient implementation of the common pattern of
'do.call(rbind, dfs)' or 'do.call(cbind, dfs)' for binding many
data frames into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
bind_rows(..., .id = NULL, add.cell.ids = NULL)

## S3 method for class 'Seurat'
bind_cols(..., .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_rows_+3A_...">...</code></td>
<td>
<p>Data frames to combine.
</p>
<p>Each argument can either be a data frame, a list that could be a data
frame, or a list of data frames.
</p>
<p>When row-binding, columns are matched by name, and any missing
columns will be filled with NA.
</p>
<p>When column-binding, rows are matched by position, so all data
frames must have the same number of rows. To match by value, not
position, see mutate-joins.</p>
</td></tr>
<tr><td><code id="bind_rows_+3A_.id">.id</code></td>
<td>
<p>Data frame identifier.
</p>
<p>When '.id' is supplied, a new column of identifiers is
created to link each row to its original data frame. The labels
are taken from the named arguments to 'bind_rows()'. When a
list of data frames is supplied, the labels are taken from the
names of the list. If no names are found a numeric sequence is
used instead.</p>
</td></tr>
<tr><td><code id="bind_rows_+3A_add.cell.ids">add.cell.ids</code></td>
<td>
<p>from Seurat 3.0 A character vector of length(x = c(x, y)). Appends the corresponding values to the start of each objects' cell names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of 'bind_rows()' will contain a column if that column
appears in any of the inputs.
</p>
<p>The output of 'bind_rows()' will contain a column if that column
appears in any of the inputs.
</p>


<h3>Value</h3>

<p>'bind_rows()' and 'bind_cols()' return the same type as
the first input, either a data frame, 'tbl_df', or 'grouped_df'.
</p>
<p>'bind_rows()' and 'bind_cols()' return the same type as
the first input, either a data frame, 'tbl_df', or 'grouped_df'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
tt &lt;- pbmc_small
ttservice::bind_rows(tt, tt)

tt_bind &lt;- tt |&gt; select(nCount_RNA ,nFeature_RNA)
tt |&gt; ttservice::bind_cols(tt_bind)

</code></pre>

<hr>
<h2 id='cell_type_df'>Cell types of 80 PBMC single cells</h2><span id='topic+cell_type_df'></span>

<h3>Description</h3>

<p>A dataset containing the barcodes and cell types of 80 PBMC single cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cell_type_df)
</code></pre>


<h3>Format</h3>

<p>A tibble containing 80 rows and 2 columns.
Cells are a subsample of the Peripheral Blood Mononuclear Cells (PBMC) 
dataset of 2,700 single cell. Cell types were identified with SingleR.
</p>

<dl>
<dt>cell</dt><dd><p>cell identifier, barcode</p>
</dd>
<dt>first.labels</dt><dd><p>cell type</p>
</dd>
</dl>



<h3>Value</h3>

<p>'tibble'
</p>


<h3>Source</h3>

<p><a href="https://satijalab.org/seurat/v3.1/pbmc3k_tutorial.html">https://satijalab.org/seurat/v3.1/pbmc3k_tutorial.html</a>
</p>

<hr>
<h2 id='count'>Count the observations in each group</h2><span id='topic+count'></span><span id='topic+count.Seurat'></span><span id='topic+add_count.Seurat'></span><span id='topic+add_count'></span>

<h3>Description</h3>

<p><code>count()</code> lets you quickly count the unique values of one or more variables:
<code>df %&gt;% count(a, b)</code> is roughly equivalent to
<code>df %&gt;% group_by(a, b) %&gt;% summarise(n = n())</code>.
<code>count()</code> is paired with <code>tally()</code>, a lower-level helper that is equivalent
to <code>df %&gt;% summarise(n = n())</code>. Supply <code>wt</code> to perform weighted counts,
switching the summary from <code>n = n()</code> to <code>n = sum(wt)</code>.
</p>
<p><code>add_count()</code> and <code>add_tally()</code> are equivalents to <code>count()</code> and <code>tally()</code>
but use <code>mutate()</code> instead of <code>summarise()</code> so that they add a new column
with group-wise counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = NULL,
  .drop = group_by_drop_default(x)
)

## S3 method for class 'Seurat'
add_count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = NULL,
  .drop = group_by_drop_default(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_+3A_x">x</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="count_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables to group
by.</p>
</td></tr>
<tr><td><code id="count_+3A_wt">wt</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="count_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="count_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>. If there's already a column called <code>n</code>,
it will use <code>nn</code>. If there's a column called <code>n</code> and <code>nn</code>, it'll use
<code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</td></tr>
<tr><td><code id="count_+3A_.drop">.drop</code></td>
<td>
<p>Handling of factor levels that don't appear in the data, passed
on to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
</p>
<p>For <code>count()</code>: if <code>FALSE</code> will include counts for empty groups (i.e. for
levels of factors that don't exist in the data).
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> For <code>add_count()</code>: deprecated since it
can't actually affect the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. <code>count()</code> and <code>add_count()</code>
group transiently, so the output has the same groups as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; count(groups)
    
</code></pre>

<hr>
<h2 id='distinct'>Keep distinct/unique rows</h2><span id='topic+distinct'></span><span id='topic+distinct.Seurat'></span>

<h3>Description</h3>

<p>Keep only unique/distinct rows from a data frame. This is similar
to <code><a href="base.html#topic+unique.data.frame">unique.data.frame()</a></code> but considerably faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
distinct(.data, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distinct_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="distinct_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Optional variables to
use when determining uniqueness. If there are multiple rows for a given
combination of inputs, only the first row will be preserved. If omitted,
will use all variables in the data frame.</p>
</td></tr>
<tr><td><code id="distinct_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Rows are a subset of the input but appear in the same order.
</p>
</li>
<li><p> Columns are not modified if <code>...</code> is empty or <code>.keep_all</code> is <code>TRUE</code>.
Otherwise, <code>distinct()</code> first calls <code>mutate()</code> to create new columns.
</p>
</li>
<li><p> Groups are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small |&gt; distinct(groups)

</code></pre>

<hr>
<h2 id='drop_class'>Remove class to abject</h2><span id='topic+drop_class'></span>

<h3>Description</h3>

<p>Remove class to abject
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_class(var, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_class_+3A_var">var</code></td>
<td>
<p>A tibble</p>
</td></tr>
<tr><td><code id="drop_class_+3A_name">name</code></td>
<td>
<p>A character name of the class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with an additional attribute
</p>

<hr>
<h2 id='extract'>Extract a character column into multiple columns using regular
expression groups</h2><span id='topic+extract'></span><span id='topic+extract.Seurat'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>extract()</code> has been superseded in favour of <code><a href="tidyr.html#topic+separate_wider_regex">separate_wider_regex()</a></code>
because it has a more polished API and better handling of problems.
Superseded functions will not go away, but will only receive critical bug
fixes.
</p>
<p>Given a regular expression with capturing groups, <code>extract()</code> turns
each group into a new column. If the groups don't match, or the input
is NA, the output will be NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
extract(
  data,
  col,
  into,
  regex = "([[:alnum:]]+)",
  remove = TRUE,
  convert = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="extract_+3A_col">col</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Column to expand.</p>
</td></tr>
<tr><td><code id="extract_+3A_into">into</code></td>
<td>
<p>Names of new variables to create as character vector.
Use <code>NA</code> to omit the variable in the output.</p>
</td></tr>
<tr><td><code id="extract_+3A_regex">regex</code></td>
<td>
<p>A string representing a regular expression used to extract the
desired values. There should be one group (defined by <code style="white-space: pre;">&#8288;()&#8288;</code>) for each
element of <code>into</code>.</p>
</td></tr>
<tr><td><code id="extract_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input column from output data frame.</p>
</td></tr>
<tr><td><code id="extract_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will run <code><a href="utils.html#topic+type.convert">type.convert()</a></code> with
<code>as.is = TRUE</code> on new columns. This is useful if the component
columns are integer, numeric or logical.
</p>
<p>NB: this will cause string <code>"NA"</code>s to be converted to <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="extract_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'tidyseurat'
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+separate">separate()</a></code> to split up by a separator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt;
  extract(groups, 
    into="g", 
    regex="g([0-9])", 
    convert=TRUE)

</code></pre>

<hr>
<h2 id='filter'>Keep rows that match a condition</h2><span id='topic+filter'></span><span id='topic+filter.Seurat'></span>

<h3>Description</h3>

<p>The <code>filter()</code> function is used to subset a data frame,
retaining all rows that satisfy your conditions.
To be retained, the row must produce a value of <code>TRUE</code> for all conditions.
Note that when a condition evaluates to <code>NA</code>
the row will be dropped, unlike base subsetting with <code>[</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
filter(.data, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="filter_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>.data</code>. If multiple expressions are included, they are combined with the
<code>&amp;</code> operator. Only rows for which all conditions evaluate to <code>TRUE</code> are
kept.</p>
</td></tr>
<tr><td><code id="filter_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>filter()</code> function is used to subset the rows of
<code>.data</code>, applying the expressions in <code>...</code> to the column values to determine which
rows should be retained. It can be applied to both grouped and ungrouped data (see <code><a href="dplyr.html#topic+group_by">group_by()</a></code> and
<code><a href="dplyr.html#topic+ungroup">ungroup()</a></code>). However, dplyr is not yet smart enough to optimise the filtering
operation on grouped datasets that do not need grouped calculations. For this
reason, filtering is often considerably faster on ungrouped data.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following properties:
</p>

<ul>
<li><p> Rows are a subset of the input, but appear in the same order.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> The number of groups may be reduced (if <code>.preserve</code> is not <code>TRUE</code>).
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Useful filter functions</h3>

<p>There are many functions and operators that are useful when constructing the
expressions used to filter the data:
</p>

<ul>
<li> <p><code><a href="base.html#topic++3D+3D">==</a></code>, <code><a href="base.html#topic++3E">&gt;</a></code>, <code><a href="base.html#topic++3E+3D">&gt;=</a></code> etc
</p>
</li>
<li> <p><code><a href="base.html#topic++26">&amp;</a></code>, <code><a href="base.html#topic++7C">|</a></code>, <code><a href="base.html#topic++21">!</a></code>, <code><a href="base.html#topic+xor">xor()</a></code>
</p>
</li>
<li> <p><code><a href="base.html#topic+is.na">is.na()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+between">between()</a></code>, <code><a href="dplyr.html#topic+near">near()</a></code>
</p>
</li></ul>



<h3>Grouped tibbles</h3>

<p>Because filtering expressions are computed within groups, they may
yield different results on grouped tibbles. This will be the case
as soon as an aggregating, lagging, or ranking function is
involved. Compare this ungrouped filtering:
</p>
<div class="sourceCode"><pre>starwars %&gt;% filter(mass &gt; mean(mass, na.rm = TRUE))
</pre></div>
<p>With the grouped equivalent:
</p>
<div class="sourceCode"><pre>starwars %&gt;% group_by(gender) %&gt;% filter(mass &gt; mean(mass, na.rm = TRUE))
</pre></div>
<p>In the ungrouped version, <code>filter()</code> compares the value of <code>mass</code> in each row to
the global average (taken over the whole data set), keeping only the rows with
<code>mass</code> greater than this global average. In contrast, the grouped version calculates
the average mass separately for each <code>gender</code> group, and keeps rows with <code>mass</code> greater
than the relevant within-gender average.
</p>


<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="dplyr.html#topic+arrange">arrange</a>()</code>,
<code><a href="dplyr.html#topic+mutate">mutate</a>()</code>,
<code><a href="dplyr.html#topic+reframe">reframe</a>()</code>,
<code><a href="dplyr.html#topic+rename">rename</a>()</code>,
<code><a href="dplyr.html#topic+select">select</a>()</code>,
<code><a href="dplyr.html#topic+slice">slice</a>()</code>,
<code><a href="dplyr.html#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small |&gt;  filter(groups == "g1")

# Learn more in ?dplyr_eval

</code></pre>

<hr>
<h2 id='formatting'>Printing tibbles</h2><span id='topic+formatting'></span><span id='topic+print.Seurat'></span><span id='topic+print'></span>

<h3>Description</h3>

<p>One of the main features of the <code>tbl_df</code> class is the printing:
</p>

<ul>
<li><p> Tibbles only print as many rows and columns as fit on one screen,
supplemented by a summary of the remaining rows and columns.
</p>
</li>
<li><p> Tibble reveals the type of each column, which keeps the user informed about
whether a variable is, e.g., <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> or <code style="white-space: pre;">&#8288;&lt;fct&gt;&#8288;</code> (character versus factor).
See <code>vignette("types")</code> for an overview of common
type abbreviations.
</p>
</li></ul>

<p>Printing can be tweaked for a one-off call by calling <code>print()</code> explicitly
and setting arguments like <code>n</code> and <code>width</code>. More persistent control is
available by setting the options described in <a href="pillar.html#topic+pillar_options">pillar::pillar_options</a>.
See also <code>vignette("digits")</code> for a comparison to base options,
and <code>vignette("numbers")</code> that showcases <code><a href="tibble.html#topic+num">num()</a></code> and <code><a href="tibble.html#topic+char">char()</a></code>
for creating columns with custom formatting options.
</p>
<p>As of tibble 3.1.0, printing is handled entirely by the <span class="pkg">pillar</span> package.
If you implement a package that extends tibble,
the printed output can be customized in various ways.
See <code>vignette("extending", package = "pillar")</code> for details,
and <a href="pillar.html#topic+pillar_options">pillar::pillar_options</a> for options that control the display in the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
print(x, ..., n = NULL, width = NULL, n_extra = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formatting_+3A_x">x</code></td>
<td>
<p>Object to format or print.</p>
</td></tr>
<tr><td><code id="formatting_+3A_...">...</code></td>
<td>
<p>Passed on to <code><a href="pillar.html#topic+tbl_format_setup">tbl_format_setup()</a></code>.</p>
</td></tr>
<tr><td><code id="formatting_+3A_n">n</code></td>
<td>
<p>Number of rows to show. If <code>NULL</code>, the default, will print all rows
if less than the <code>print_max</code> <a href="pillar.html#topic+pillar_options">option</a>.
Otherwise, will print as many rows as specified by the
<code>print_min</code> <a href="pillar.html#topic+pillar_options">option</a>.</p>
</td></tr>
<tr><td><code id="formatting_+3A_width">width</code></td>
<td>
<p>Width of text output to generate. This defaults to <code>NULL</code>, which
means use the <code>width</code> <a href="pillar.html#topic+pillar_options">option</a>.</p>
</td></tr>
<tr><td><code id="formatting_+3A_n_extra">n_extra</code></td>
<td>
<p>Number of extra columns to print abbreviated information for,
if the width is too small for the entire tibble. If 'NULL', the default,
will print information about at most 'tibble.max_extra_cols' extra columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a message to the console describing
the contents of the 'tidyseurat'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
print(pbmc_small)

</code></pre>

<hr>
<h2 id='full_join'>Mutating joins</h2><span id='topic+full_join'></span><span id='topic+full_join.Seurat'></span>

<h3>Description</h3>

<p>Mutating joins add columns from <code>y</code> to <code>x</code>, matching observations based on
the keys. There are four mutating joins: the inner join, and the three outer
joins.
</p>


<h4>Inner join</h4>

<p>An <code>inner_join()</code> only keeps observations from <code>x</code> that have a matching key
in <code>y</code>.
</p>
<p>The most important property of an inner join is that unmatched rows in either
input are not included in the result. This means that generally inner joins
are not appropriate in most analyses, because it is too easy to lose
observations.
</p>



<h4>Outer joins</h4>

<p>The three outer joins keep observations that appear in at least one of the
data frames:
</p>

<ul>
<li><p> A <code>left_join()</code> keeps all observations in <code>x</code>.
</p>
</li>
<li><p> A <code>right_join()</code> keeps all observations in <code>y</code>.
</p>
</li>
<li><p> A <code>full_join()</code> keeps all observations in <code>x</code> and <code>y</code>.
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
full_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="full_join_+3A_x">x</code>, <code id="full_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="full_join_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="full_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="full_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="full_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>x</code> (including the same groups). The order of
the rows and columns of <code>x</code> is preserved as much as possible. The output has
the following properties:
</p>

<ul>
<li><p> The rows are affect by the join type.
</p>

<ul>
<li> <p><code>inner_join()</code> returns matched <code>x</code> rows.
</p>
</li>
<li> <p><code>left_join()</code> returns all <code>x</code> rows.
</p>
</li>
<li> <p><code>right_join()</code>  returns matched of <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li>
<li> <p><code>full_join()</code>  returns all <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li></ul>

</li>
<li><p> Output columns include all columns from <code>x</code> and all non-key columns from
<code>y</code>. If <code>keep = TRUE</code>, the key columns from <code>y</code> are included as well.
</p>
</li>
<li><p> If non-key columns in <code>x</code> and <code>y</code> have the same name, <code>suffix</code>es are added
to disambiguate. If <code>keep = TRUE</code> and key columns in <code>x</code> and <code>y</code> have
the same name, <code>suffix</code>es are added to disambiguate these as well.
</p>
</li>
<li><p> If <code>keep = FALSE</code>, output columns included in <code>by</code> are coerced to their
common type between <code>x</code> and <code>y</code>.
</p>
</li></ul>



<h3>Many-to-many relationships</h3>

<p>By default, dplyr guards against many-to-many relationships in equality joins
by throwing a warning. These occur when both of the following are true:
</p>

<ul>
<li><p> A row in <code>x</code> matches multiple rows in <code>y</code>.
</p>
</li>
<li><p> A row in <code>y</code> matches multiple rows in <code>x</code>.
</p>
</li></ul>

<p>This is typically surprising, as most joins involve a relationship of
one-to-one, one-to-many, or many-to-one, and is often the result of an
improperly specified join. Many-to-many relationships are particularly
problematic because they can result in a Cartesian explosion of the number of
rows returned from the join.
</p>
<p>If a many-to-many relationship is expected, silence this warning by
explicitly setting <code>relationship = "many-to-many"</code>.
</p>
<p>In production code, it is best to preemptively set <code>relationship</code> to whatever
relationship you expect to exist between the keys of <code>x</code> and <code>y</code>, as this
forces an error to occur immediately if the data doesn't align with your
expectations.
</p>
<p>Inequality joins typically result in many-to-many relationships by nature, so
they don't warn on them by default, but you should still take extra care when
specifying an inequality join, because they also have the capability to
return a large number of rows.
</p>
<p>Rolling joins don't warn on many-to-many relationships either, but many
rolling joins follow a many-to-one relationship, so it is often useful to
set <code>relationship = "many-to-one"</code> to enforce this.
</p>
<p>Note that in SQL, most database providers won't let you specify a
many-to-many relationship between two tables, instead requiring that you
create a third <em>junction table</em> that results in two one-to-many relationships
instead.
</p>


<h3>Methods</h3>

<p>These functions are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>inner_join()</code>: no methods found.
</p>
</li>
<li> <p><code>left_join()</code>: no methods found.
</p>
</li>
<li> <p><code>right_join()</code>: no methods found.
</p>
</li>
<li> <p><code>full_join()</code>: no methods found.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other joins: 
<code><a href="dplyr.html#topic+cross_join">cross_join</a>()</code>,
<code><a href="dplyr.html#topic+filter-joins">filter-joins</a></code>,
<code><a href="dplyr.html#topic+nest_join">nest_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
tt &lt;- pbmc_small
tt |&gt; full_join(tibble::tibble(groups="g1", other=1:4))

</code></pre>

<hr>
<h2 id='get_abundance_sc_long'>get abundance long</h2><span id='topic+get_abundance_sc_long'></span>

<h3>Description</h3>

<p>get abundance long
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_abundance_sc_long(
  .data,
  features = NULL,
  all = FALSE,
  exclude_zeros = FALSE,
  assay = Assays(.data),
  slot = "data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_abundance_sc_long_+3A_.data">.data</code></td>
<td>
<p>A tidyseurat</p>
</td></tr>
<tr><td><code id="get_abundance_sc_long_+3A_features">features</code></td>
<td>
<p>A character</p>
</td></tr>
<tr><td><code id="get_abundance_sc_long_+3A_all">all</code></td>
<td>
<p>A boolean</p>
</td></tr>
<tr><td><code id="get_abundance_sc_long_+3A_exclude_zeros">exclude_zeros</code></td>
<td>
<p>A boolean</p>
</td></tr>
<tr><td><code id="get_abundance_sc_long_+3A_assay">assay</code></td>
<td>
<p>assay name to extract feature abundance</p>
</td></tr>
<tr><td><code id="get_abundance_sc_long_+3A_slot">slot</code></td>
<td>
<p>slot in the assay, e.g. 'data' and 'scale.data'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small %&gt;%
  get_abundance_sc_long(features=c("HLA-DRA", "LYZ"))

</code></pre>

<hr>
<h2 id='get_abundance_sc_wide'>get abundance wide</h2><span id='topic+get_abundance_sc_wide'></span>

<h3>Description</h3>

<p>get abundance wide
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_abundance_sc_wide(
  .data,
  features = NULL,
  all = FALSE,
  assay = .data@active.assay,
  slot = "data",
  prefix = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_abundance_sc_wide_+3A_.data">.data</code></td>
<td>
<p>A tidyseurat</p>
</td></tr>
<tr><td><code id="get_abundance_sc_wide_+3A_features">features</code></td>
<td>
<p>A character</p>
</td></tr>
<tr><td><code id="get_abundance_sc_wide_+3A_all">all</code></td>
<td>
<p>A boolean</p>
</td></tr>
<tr><td><code id="get_abundance_sc_wide_+3A_assay">assay</code></td>
<td>
<p>assay name to extract feature abundance</p>
</td></tr>
<tr><td><code id="get_abundance_sc_wide_+3A_slot">slot</code></td>
<td>
<p>slot in the assay, e.g. 'data' and 'scale.data'</p>
</td></tr>
<tr><td><code id="get_abundance_sc_wide_+3A_prefix">prefix</code></td>
<td>
<p>prefix for the feature names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small %&gt;%
  get_abundance_sc_wide(features=c("HLA-DRA", "LYZ"))

</code></pre>

<hr>
<h2 id='ggplot'>Create a new <code>ggplot</code> from a <code>tidyseurat</code></h2><span id='topic+ggplot'></span><span id='topic+ggplot.Seurat'></span>

<h3>Description</h3>

<p><code>ggplot()</code> initializes a ggplot object. It can be used to
declare the input data frame for a graphic and to specify the
set of plot aesthetics intended to be common throughout all
subsequent layers unless specifically overridden.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
ggplot(data = NULL, mapping = aes(), ..., environment = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggplot_+3A_data">data</code></td>
<td>
<p>Default dataset to use for plot. If not already a data.frame,
will be converted to one by <code><a href="ggplot2.html#topic+fortify">fortify()</a></code>. If not specified,
must be supplied in each layer added to the plot.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_mapping">mapping</code></td>
<td>
<p>Default list of aesthetic mappings to use for plot.
If not specified, must be supplied in each layer added to the plot.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_environment">environment</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Used prior to tidy
evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggplot()</code> is used to construct the initial plot object,
and is almost always followed by a plus sign (<code>+</code>) to add
components to the plot.
</p>
<p>There are three common patterns used to invoke <code>ggplot()</code>:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;ggplot(data = df, mapping = aes(x, y, other aesthetics))&#8288;</code>
</p>
</li>
<li> <p><code>ggplot(data = df)</code>
</p>
</li>
<li> <p><code>ggplot()</code>
</p>
</li></ul>

<p>The first pattern is recommended if all layers use the same
data and the same set of aesthetics, although this method
can also be used when adding a layer using data from another
data frame.
</p>
<p>The second pattern specifies the default data frame to use
for the plot, but no aesthetics are defined up front. This
is useful when one data frame is used predominantly for the
plot, but the aesthetics vary from one layer to another.
</p>
<p>The third pattern initializes a skeleton <code>ggplot</code> object, which
is fleshed out as layers are added. This is useful when
multiple data frames are used to produce different layers, as
is often the case in complex graphics.
</p>
<p>The <code style="white-space: pre;">&#8288;data =&#8288;</code> and <code style="white-space: pre;">&#8288;mapping =&#8288;</code> specifications in the arguments are optional
(and are often omitted in practice), so long as the data and the mapping
values are passed into the function in the right order. In the examples
below, however, they are left in place for clarity.
</p>


<h3>Value</h3>

<p>'ggplot'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
data(pbmc_small)
pbmc_small |&gt; 
  ggplot(aes(groups, nCount_RNA)) +
  geom_boxplot()

</code></pre>

<hr>
<h2 id='glimpse'>Get a glimpse of your data</h2><span id='topic+glimpse'></span><span id='topic+glimpse.tidyseurat'></span>

<h3>Description</h3>

<p><code>glimpse()</code> is like a transposed version of <code>print()</code>:
columns run down the page, and data runs across.
This makes it possible to see every column in a data frame.
It's a little like <code><a href="utils.html#topic+str">str()</a></code> applied to a data frame
but it tries to show you as much data as possible.
(And it always shows the underlying data, even when applied
to a remote data source.)
</p>
<p>See <code><a href="pillar.html#topic+format_glimpse">format_glimpse()</a></code> for details on the formatting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidyseurat'
glimpse(x, width = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glimpse_+3A_x">x</code></td>
<td>
<p>An object to glimpse at.</p>
</td></tr>
<tr><td><code id="glimpse_+3A_width">width</code></td>
<td>
<p>Width of output: defaults to the setting of the
<code>width</code> <a href="pillar.html#topic+pillar_options">option</a> (if finite)
or the width of the console.</p>
</td></tr>
<tr><td><code id="glimpse_+3A_...">...</code></td>
<td>
<p>Unused, for extensibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x original x is (invisibly) returned, allowing <code>glimpse()</code> to be
used within a data pipe line.
</p>


<h3>S3 methods</h3>

<p><code>glimpse</code> is an S3 generic with a customised method for <code>tbl</code>s and
<code>data.frames</code>, and a default method that calls <code><a href="utils.html#topic+str">str()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; glimpse()

</code></pre>

<hr>
<h2 id='group_by'>Group by one or more variables</h2><span id='topic+group_by'></span><span id='topic+group_by.Seurat'></span>

<h3>Description</h3>

<p>Most data operations are done on groups defined by variables.
<code>group_by()</code> takes an existing tbl and converts it into a grouped tbl
where operations are performed &quot;by group&quot;. <code>ungroup()</code> removes grouping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
group_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_by_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="group_by_+3A_...">...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="group_by_+3A_.add">.add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td></tr>
<tr><td><code id="group_by_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grouped data frame with class <code><a href="dplyr.html#topic+grouped_df">grouped_df</a></code>,
unless the combination of <code>...</code> and <code>add</code> yields a empty set of
grouping columns, in which case a tibble will be returned.
</p>


<h3>Methods</h3>

<p>These function are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>group_by()</code>: no methods found.
</p>
</li>
<li> <p><code>ungroup()</code>: no methods found.
</p>
</li></ul>



<h3>Ordering</h3>

<p>Currently, <code>group_by()</code> internally orders the groups in ascending order. This
results in ordered output from functions that aggregate groups, such as
<code><a href="dplyr.html#topic+summarise">summarise()</a></code>.
</p>
<p>When used as grouping columns, character vectors are ordered in the C locale
for performance and reproducibility across R sessions. If the resulting
ordering of your grouped operation matters and is dependent on the locale,
you should follow up the grouped operation with an explicit call to
<code><a href="dplyr.html#topic+arrange">arrange()</a></code> and set the <code>.locale</code> argument. For example:
</p>
<div class="sourceCode"><pre>data %&gt;%
  group_by(chr) %&gt;%
  summarise(avg = mean(x)) %&gt;%
  arrange(chr, .locale = "en")
</pre></div>
<p>This is often useful as a preliminary step before generating content intended
for humans, such as an HTML table.
</p>


<h4>Legacy behavior</h4>

<p>Prior to dplyr 1.1.0, character vector grouping columns were ordered in the
system locale. If you need to temporarily revert to this behavior, you can
set the global option <code>dplyr.legacy_locale</code> to <code>TRUE</code>, but this should be
used sparingly and you should expect this option to be removed in a future
version of dplyr. It is better to update existing code to explicitly call
<code>arrange(.locale = )</code> instead. Note that setting <code>dplyr.legacy_locale</code> will
also force calls to <code><a href="dplyr.html#topic+arrange">arrange()</a></code> to use the system locale.
</p>



<h3>See Also</h3>

<p>Other grouping functions: 
<code><a href="dplyr.html#topic+group_map">group_map</a>()</code>,
<code><a href="dplyr.html#topic+group_nest">group_nest</a>()</code>,
<code><a href="dplyr.html#topic+group_split">group_split</a>()</code>,
<code><a href="dplyr.html#topic+group_trim">group_trim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small |&gt;  group_by(groups)

</code></pre>

<hr>
<h2 id='group_split'>Split data frame by groups</h2><span id='topic+group_split'></span><span id='topic+group_split.Seurat'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code><a href="dplyr.html#topic+group_split">group_split()</a></code> works like <code><a href="base.html#topic+split">base::split()</a></code> but:
</p>

<ul>
<li><p> It uses the grouping structure from <code><a href="dplyr.html#topic+group_by">group_by()</a></code> and therefore is subject
to the data mask
</p>
</li>
<li><p> It does not name the elements of the list based on the grouping as this
only works well for a single character grouping variable. Instead,
use <code><a href="dplyr.html#topic+group_keys">group_keys()</a></code> to access a data frame that defines the groups.
</p>
</li></ul>

<p><code>group_split()</code> is primarily designed to work with grouped data frames.
You can pass <code>...</code> to group and split an ungrouped data frame, but this
is generally not very useful as you want have easy access to the group
metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
group_split(.tbl, ..., .keep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_split_+3A_.tbl">.tbl</code></td>
<td>
<p>A tbl.</p>
</td></tr>
<tr><td><code id="group_split_+3A_...">...</code></td>
<td>
<p>If <code>.tbl</code> is an ungrouped data frame, a grouping specification,
forwarded to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.</p>
</td></tr>
<tr><td><code id="group_split_+3A_.keep">.keep</code></td>
<td>
<p>Should the grouping columns be kept?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tibbles. Each tibble contains the rows of <code>.tbl</code> for the
associated group and all the columns, including the grouping variables.
Note that this returns a <a href="vctrs.html#topic+list_of">list_of</a> which is slightly
stricter than a simple list but is useful for representing lists where
every element has the same type.
</p>


<h3>Lifecycle</h3>

<p><code>group_split()</code> is not stable because you can achieve very similar results by
manipulating the nested column returned from
<code><a href="tidyr.html#topic+nest">tidyr::nest(.by =)</a></code>. That also retains the group keys all
within a single data structure. <code>group_split()</code> may be deprecated in the
future.
</p>


<h3>See Also</h3>

<p>Other grouping functions: 
<code><a href="dplyr.html#topic+group_by">group_by</a>()</code>,
<code><a href="dplyr.html#topic+group_map">group_map</a>()</code>,
<code><a href="dplyr.html#topic+group_nest">group_nest</a>()</code>,
<code><a href="dplyr.html#topic+group_trim">group_trim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; group_split(groups)

</code></pre>

<hr>
<h2 id='inner_join'>Mutating joins</h2><span id='topic+inner_join'></span><span id='topic+inner_join.Seurat'></span>

<h3>Description</h3>

<p>Mutating joins add columns from <code>y</code> to <code>x</code>, matching observations based on
the keys. There are four mutating joins: the inner join, and the three outer
joins.
</p>


<h4>Inner join</h4>

<p>An <code>inner_join()</code> only keeps observations from <code>x</code> that have a matching key
in <code>y</code>.
</p>
<p>The most important property of an inner join is that unmatched rows in either
input are not included in the result. This means that generally inner joins
are not appropriate in most analyses, because it is too easy to lose
observations.
</p>



<h4>Outer joins</h4>

<p>The three outer joins keep observations that appear in at least one of the
data frames:
</p>

<ul>
<li><p> A <code>left_join()</code> keeps all observations in <code>x</code>.
</p>
</li>
<li><p> A <code>right_join()</code> keeps all observations in <code>y</code>.
</p>
</li>
<li><p> A <code>full_join()</code> keeps all observations in <code>x</code> and <code>y</code>.
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
inner_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner_join_+3A_x">x</code>, <code id="inner_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>x</code> (including the same groups). The order of
the rows and columns of <code>x</code> is preserved as much as possible. The output has
the following properties:
</p>

<ul>
<li><p> The rows are affect by the join type.
</p>

<ul>
<li> <p><code>inner_join()</code> returns matched <code>x</code> rows.
</p>
</li>
<li> <p><code>left_join()</code> returns all <code>x</code> rows.
</p>
</li>
<li> <p><code>right_join()</code>  returns matched of <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li>
<li> <p><code>full_join()</code>  returns all <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li></ul>

</li>
<li><p> Output columns include all columns from <code>x</code> and all non-key columns from
<code>y</code>. If <code>keep = TRUE</code>, the key columns from <code>y</code> are included as well.
</p>
</li>
<li><p> If non-key columns in <code>x</code> and <code>y</code> have the same name, <code>suffix</code>es are added
to disambiguate. If <code>keep = TRUE</code> and key columns in <code>x</code> and <code>y</code> have
the same name, <code>suffix</code>es are added to disambiguate these as well.
</p>
</li>
<li><p> If <code>keep = FALSE</code>, output columns included in <code>by</code> are coerced to their
common type between <code>x</code> and <code>y</code>.
</p>
</li></ul>



<h3>Many-to-many relationships</h3>

<p>By default, dplyr guards against many-to-many relationships in equality joins
by throwing a warning. These occur when both of the following are true:
</p>

<ul>
<li><p> A row in <code>x</code> matches multiple rows in <code>y</code>.
</p>
</li>
<li><p> A row in <code>y</code> matches multiple rows in <code>x</code>.
</p>
</li></ul>

<p>This is typically surprising, as most joins involve a relationship of
one-to-one, one-to-many, or many-to-one, and is often the result of an
improperly specified join. Many-to-many relationships are particularly
problematic because they can result in a Cartesian explosion of the number of
rows returned from the join.
</p>
<p>If a many-to-many relationship is expected, silence this warning by
explicitly setting <code>relationship = "many-to-many"</code>.
</p>
<p>In production code, it is best to preemptively set <code>relationship</code> to whatever
relationship you expect to exist between the keys of <code>x</code> and <code>y</code>, as this
forces an error to occur immediately if the data doesn't align with your
expectations.
</p>
<p>Inequality joins typically result in many-to-many relationships by nature, so
they don't warn on them by default, but you should still take extra care when
specifying an inequality join, because they also have the capability to
return a large number of rows.
</p>
<p>Rolling joins don't warn on many-to-many relationships either, but many
rolling joins follow a many-to-one relationship, so it is often useful to
set <code>relationship = "many-to-one"</code> to enforce this.
</p>
<p>Note that in SQL, most database providers won't let you specify a
many-to-many relationship between two tables, instead requiring that you
create a third <em>junction table</em> that results in two one-to-many relationships
instead.
</p>


<h3>Methods</h3>

<p>These functions are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>inner_join()</code>: no methods found.
</p>
</li>
<li> <p><code>left_join()</code>: no methods found.
</p>
</li>
<li> <p><code>right_join()</code>: no methods found.
</p>
</li>
<li> <p><code>full_join()</code>: no methods found.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other joins: 
<code><a href="dplyr.html#topic+cross_join">cross_join</a>()</code>,
<code><a href="dplyr.html#topic+filter-joins">filter-joins</a></code>,
<code><a href="dplyr.html#topic+nest_join">nest_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
tt &lt;- pbmc_small
tt |&gt; inner_join(tt |&gt; 
  distinct(groups) |&gt;  
  mutate(new_column=1:2) |&gt; 
  slice(1))

</code></pre>

<hr>
<h2 id='join_features'>join_features</h2><span id='topic+join_features'></span><span id='topic+join_features+2CSeurat-method'></span>

<h3>Description</h3>

<p>join_features() extracts and joins information for specific
features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Seurat'
join_features(
  .data,
  features = NULL,
  all = FALSE,
  exclude_zeros = FALSE,
  shape = "long",
  assay = NULL,
  slot = "data",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="join_features_+3A_.data">.data</code></td>
<td>
<p>A tidyseurat object</p>
</td></tr>
<tr><td><code id="join_features_+3A_features">features</code></td>
<td>
<p>A vector of feature identifiers to join</p>
</td></tr>
<tr><td><code id="join_features_+3A_all">all</code></td>
<td>
<p>If TRUE return all</p>
</td></tr>
<tr><td><code id="join_features_+3A_exclude_zeros">exclude_zeros</code></td>
<td>
<p>If TRUE exclude zero values</p>
</td></tr>
<tr><td><code id="join_features_+3A_shape">shape</code></td>
<td>
<p>Format of the returned table &quot;long&quot; or &quot;wide&quot;</p>
</td></tr>
<tr><td><code id="join_features_+3A_assay">assay</code></td>
<td>
<p>assay name to extract feature abundance</p>
</td></tr>
<tr><td><code id="join_features_+3A_slot">slot</code></td>
<td>
<p>slot name to extract feature abundance</p>
</td></tr>
<tr><td><code id="join_features_+3A_...">...</code></td>
<td>
<p>Parameters to pass to join wide, i.e. assay name to extract feature abundance from and gene prefix, for shape=&quot;wide&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts information for specified features and
returns the information in either long or wide format.
</p>


<h3>Value</h3>

<p>A 'tidyseurat' object
containing information for the specified features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small %&gt;% join_features(
  features=c("HLA-DRA", "LYZ"))

</code></pre>

<hr>
<h2 id='join_transcripts'>(DEPRECATED) Extract and join information for transcripts.</h2><span id='topic+join_transcripts'></span>

<h3>Description</h3>

<p>join_transcripts() extracts and joins information for specified transcripts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_transcripts(
  .data,
  transcripts = NULL,
  all = FALSE,
  exclude_zeros = FALSE,
  shape = "long",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="join_transcripts_+3A_.data">.data</code></td>
<td>
<p>A tidyseurat object</p>
</td></tr>
<tr><td><code id="join_transcripts_+3A_transcripts">transcripts</code></td>
<td>
<p>A vector of transcript identifiers to join</p>
</td></tr>
<tr><td><code id="join_transcripts_+3A_all">all</code></td>
<td>
<p>If TRUE return all</p>
</td></tr>
<tr><td><code id="join_transcripts_+3A_exclude_zeros">exclude_zeros</code></td>
<td>
<p>If TRUE exclude zero values</p>
</td></tr>
<tr><td><code id="join_transcripts_+3A_shape">shape</code></td>
<td>
<p>Format of the returned table &quot;long&quot; or &quot;wide&quot;</p>
</td></tr>
<tr><td><code id="join_transcripts_+3A_...">...</code></td>
<td>
<p>Parameters to pass to join wide, i.e. assay name to extract transcript abundance from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DEPRECATED, please use join_features()
</p>


<h3>Value</h3>

<p>A 'tbl' containing the information.for the specified transcripts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
print("DEPRECATED")


</code></pre>

<hr>
<h2 id='left_join'>Mutating joins</h2><span id='topic+left_join'></span><span id='topic+left_join.Seurat'></span>

<h3>Description</h3>

<p>Mutating joins add columns from <code>y</code> to <code>x</code>, matching observations based on
the keys. There are four mutating joins: the inner join, and the three outer
joins.
</p>


<h4>Inner join</h4>

<p>An <code>inner_join()</code> only keeps observations from <code>x</code> that have a matching key
in <code>y</code>.
</p>
<p>The most important property of an inner join is that unmatched rows in either
input are not included in the result. This means that generally inner joins
are not appropriate in most analyses, because it is too easy to lose
observations.
</p>



<h4>Outer joins</h4>

<p>The three outer joins keep observations that appear in at least one of the
data frames:
</p>

<ul>
<li><p> A <code>left_join()</code> keeps all observations in <code>x</code>.
</p>
</li>
<li><p> A <code>right_join()</code> keeps all observations in <code>y</code>.
</p>
</li>
<li><p> A <code>full_join()</code> keeps all observations in <code>x</code> and <code>y</code>.
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
left_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="left_join_+3A_x">x</code>, <code id="left_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="left_join_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="left_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="left_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="left_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>x</code> (including the same groups). The order of
the rows and columns of <code>x</code> is preserved as much as possible. The output has
the following properties:
</p>

<ul>
<li><p> The rows are affect by the join type.
</p>

<ul>
<li> <p><code>inner_join()</code> returns matched <code>x</code> rows.
</p>
</li>
<li> <p><code>left_join()</code> returns all <code>x</code> rows.
</p>
</li>
<li> <p><code>right_join()</code>  returns matched of <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li>
<li> <p><code>full_join()</code>  returns all <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li></ul>

</li>
<li><p> Output columns include all columns from <code>x</code> and all non-key columns from
<code>y</code>. If <code>keep = TRUE</code>, the key columns from <code>y</code> are included as well.
</p>
</li>
<li><p> If non-key columns in <code>x</code> and <code>y</code> have the same name, <code>suffix</code>es are added
to disambiguate. If <code>keep = TRUE</code> and key columns in <code>x</code> and <code>y</code> have
the same name, <code>suffix</code>es are added to disambiguate these as well.
</p>
</li>
<li><p> If <code>keep = FALSE</code>, output columns included in <code>by</code> are coerced to their
common type between <code>x</code> and <code>y</code>.
</p>
</li></ul>



<h3>Many-to-many relationships</h3>

<p>By default, dplyr guards against many-to-many relationships in equality joins
by throwing a warning. These occur when both of the following are true:
</p>

<ul>
<li><p> A row in <code>x</code> matches multiple rows in <code>y</code>.
</p>
</li>
<li><p> A row in <code>y</code> matches multiple rows in <code>x</code>.
</p>
</li></ul>

<p>This is typically surprising, as most joins involve a relationship of
one-to-one, one-to-many, or many-to-one, and is often the result of an
improperly specified join. Many-to-many relationships are particularly
problematic because they can result in a Cartesian explosion of the number of
rows returned from the join.
</p>
<p>If a many-to-many relationship is expected, silence this warning by
explicitly setting <code>relationship = "many-to-many"</code>.
</p>
<p>In production code, it is best to preemptively set <code>relationship</code> to whatever
relationship you expect to exist between the keys of <code>x</code> and <code>y</code>, as this
forces an error to occur immediately if the data doesn't align with your
expectations.
</p>
<p>Inequality joins typically result in many-to-many relationships by nature, so
they don't warn on them by default, but you should still take extra care when
specifying an inequality join, because they also have the capability to
return a large number of rows.
</p>
<p>Rolling joins don't warn on many-to-many relationships either, but many
rolling joins follow a many-to-one relationship, so it is often useful to
set <code>relationship = "many-to-one"</code> to enforce this.
</p>
<p>Note that in SQL, most database providers won't let you specify a
many-to-many relationship between two tables, instead requiring that you
create a third <em>junction table</em> that results in two one-to-many relationships
instead.
</p>


<h3>Methods</h3>

<p>These functions are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>inner_join()</code>: no methods found.
</p>
</li>
<li> <p><code>left_join()</code>: no methods found.
</p>
</li>
<li> <p><code>right_join()</code>: no methods found.
</p>
</li>
<li> <p><code>full_join()</code>: no methods found.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other joins: 
<code><a href="dplyr.html#topic+cross_join">cross_join</a>()</code>,
<code><a href="dplyr.html#topic+filter-joins">filter-joins</a></code>,
<code><a href="dplyr.html#topic+nest_join">nest_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
tt &lt;- pbmc_small
tt |&gt; left_join(tt |&gt;  
  distinct(groups) |&gt; 
  mutate(new_column=1:2))

</code></pre>

<hr>
<h2 id='mutate'>Create, modify, and delete columns</h2><span id='topic+mutate'></span><span id='topic+mutate.Seurat'></span>

<h3>Description</h3>

<p><code>mutate()</code> creates new columns that are functions of existing variables.
It can also modify (if the name is the same as an existing
column) and delete columns (by setting their value to <code>NULL</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
mutate(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="mutate_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Columns from <code>.data</code> will be preserved according to the <code>.keep</code> argument.
</p>
</li>
<li><p> Existing columns that are modified by <code>...</code> will always be returned in
their original location.
</p>
</li>
<li><p> New columns created through <code>...</code> will be placed according to the
<code>.before</code> and <code>.after</code> arguments.
</p>
</li>
<li><p> The number of rows is not affected.
</p>
</li>
<li><p> Columns given the value <code>NULL</code> will be removed.
</p>
</li>
<li><p> Groups will be recomputed if a grouping variable is mutated.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Useful mutate functions</h3>


<ul>
<li> <p><code><a href="base.html#topic++2B">+</a></code>, <code><a href="base.html#topic+-">-</a></code>, <code><a href="base.html#topic+log">log()</a></code>, etc., for their usual mathematical meanings
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+lead">lead()</a></code>, <code><a href="dplyr.html#topic+lag">lag()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+dense_rank">dense_rank()</a></code>, <code><a href="dplyr.html#topic+min_rank">min_rank()</a></code>, <code><a href="dplyr.html#topic+percent_rank">percent_rank()</a></code>, <code><a href="dplyr.html#topic+row_number">row_number()</a></code>,
<code><a href="dplyr.html#topic+cume_dist">cume_dist()</a></code>, <code><a href="dplyr.html#topic+ntile">ntile()</a></code>
</p>
</li>
<li> <p><code><a href="base.html#topic+cumsum">cumsum()</a></code>, <code><a href="dplyr.html#topic+cummean">cummean()</a></code>, <code><a href="base.html#topic+cummin">cummin()</a></code>, <code><a href="base.html#topic+cummax">cummax()</a></code>, <code><a href="dplyr.html#topic+cumany">cumany()</a></code>, <code><a href="dplyr.html#topic+cumall">cumall()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+na_if">na_if()</a></code>, <code><a href="dplyr.html#topic+coalesce">coalesce()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+if_else">if_else()</a></code>, <code><a href="dplyr.html#topic+recode">recode()</a></code>, <code><a href="dplyr.html#topic+case_when">case_when()</a></code>
</p>
</li></ul>



<h3>Grouped tibbles</h3>

<p>Because mutating expressions are computed within groups, they may
yield different results on grouped tibbles. This will be the case
as soon as an aggregating, lagging, or ranking function is
involved. Compare this ungrouped mutate:
</p>
<div class="sourceCode"><pre>starwars %&gt;%
  select(name, mass, species) %&gt;%
  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))
</pre></div>
<p>With the grouped equivalent:
</p>
<div class="sourceCode"><pre>starwars %&gt;%
  select(name, mass, species) %&gt;%
  group_by(species) %&gt;%
  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))
</pre></div>
<p>The former normalises <code>mass</code> by the global average whereas the
latter normalises by the averages within species levels.
</p>


<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+arrange">arrange</a>()</code>,
<code><a href="#topic+rename">rename</a>()</code>,
<code><a href="#topic+slice">slice</a>()</code>,
<code><a href="#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; mutate(nFeature_RNA=1)

</code></pre>

<hr>
<h2 id='nest'>Nest rows into a list-column of data frames</h2><span id='topic+nest'></span><span id='topic+nest.Seurat'></span>

<h3>Description</h3>

<p>Nesting creates a list-column of data frames; unnesting flattens it back out
into regular columns. Nesting is implicitly a summarising operation: you
get one row for each group defined by the non-nested columns. This is useful
in conjunction with other summaries that work with whole datasets, most
notably models.
</p>
<p>Learn more in <code>vignette("nest")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
nest(.data, ..., .names_sep = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nest_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="nest_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to nest; these will
appear in the inner data frames.
</p>
<p>Specified using name-variable pairs of the form
<code>new_col = c(col1, col2, col3)</code>. The right hand side can be any valid
tidyselect expression.
</p>
<p>If not supplied, then <code>...</code> is derived as all columns <em>not</em> selected by
<code>.by</code>, and will use the column name from <code>.key</code>.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
previously you could write <code>df %&gt;% nest(x, y, z)</code>.
Convert to <code>df %&gt;% nest(data = c(x, y, z))</code>.</p>
</td></tr>
<tr><td><code id="nest_+3A_.names_sep">.names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the inner names will come from
the former outer names. If a string, the  new inner names will use the
outer names with <code>names_sep</code> automatically stripped. This makes
<code>names_sep</code> roughly symmetric between nesting and unnesting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If neither <code>...</code> nor <code>.by</code> are supplied, <code>nest()</code> will nest all variables,
and will use the column name supplied through <code>.key</code>.
</p>


<h3>Value</h3>

<p>'tidyseurat_nested'
</p>


<h3>New syntax</h3>

<p>tidyr 1.0.0 introduced a new syntax for <code>nest()</code> and <code>unnest()</code> that's
designed to be more similar to other functions. Converting to the new syntax
should be straightforward (guided by the message you'll receive) but if
you just need to run an old analysis, you can easily revert to the previous
behaviour using <code><a href="tidyr.html#topic+nest_legacy">nest_legacy()</a></code> and <code><a href="tidyr.html#topic+unnest_legacy">unnest_legacy()</a></code> as follows:
</p>
<div class="sourceCode"><pre>library(tidyr)
nest &lt;- nest_legacy
unnest &lt;- unnest_legacy
</pre></div>


<h3>Grouped data frames</h3>

<p><code>df %&gt;% nest(data = c(x, y))</code> specifies the columns to be nested; i.e. the
columns that will appear in the inner data frame. <code>df %&gt;% nest(.by = c(x, y))</code> specifies the columns to nest <em>by</em>; i.e. the columns that will remain in
the outer data frame. An alternative way to achieve the latter is to <code>nest()</code>
a grouped data frame created by <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>. The grouping variables
remain in the outer data frame and the others are nested. The result
preserves the grouping of the input.
</p>
<p>Variables supplied to <code>nest()</code> will override grouping variables so that
<code>df %&gt;% group_by(x, y) %&gt;% nest(data = !z)</code> will be equivalent to
<code>df %&gt;% nest(data = !z)</code>.
</p>
<p>You can't supply <code>.by</code> with a grouped data frame, as the groups already
represent what you are nesting by.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; 
    nest(data=-groups) |&gt; 
    unnest(data)

</code></pre>

<hr>
<h2 id='pbmc_small_nested_interactions'>Intercellular ligand-receptor interactions for 
38 ligands from a single cell RNA-seq cluster.</h2><span id='topic+pbmc_small_nested_interactions'></span>

<h3>Description</h3>

<p>A dataset containing ligand-receptor interactions within a sample.
There are 38 ligands from a single cell cluster versus 35 receptors 
in 6 other clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pbmc_small_nested_interactions)
</code></pre>


<h3>Format</h3>

<p>A 'tibble' containing 100 rows and 9 columns.
Cells are a subsample of the PBMC dataset of 2,700 single cells. 
Cell interactions were identified with 'SingleCellSignalR'.
</p>

<dl>
<dt>sample</dt><dd><p>sample identifier</p>
</dd>
<dt>ligand</dt><dd><p>cluster and ligand identifier</p>
</dd>
<dt>receptor</dt><dd><p>cluster and receptor identifier</p>
</dd>
<dt>ligand.name</dt><dd><p>ligand name</p>
</dd>
<dt>receptor.name</dt><dd><p>receptor name</p>
</dd>
<dt>origin</dt><dd><p>cluster containing ligand</p>
</dd>
<dt>destination</dt><dd><p>cluster containing receptor</p>
</dd>
<dt>interaction.type</dt><dd><p>type of interation, paracrine or autocrine</p>
</dd>
<dt>LRscore</dt><dd><p>interaction score</p>
</dd>
</dl>



<h3>Value</h3>

<p>'tibble'
</p>


<h3>Source</h3>

<p><a href="https://satijalab.org/seurat/v3.1/pbmc3k_tutorial.html">https://satijalab.org/seurat/v3.1/pbmc3k_tutorial.html</a>
</p>

<hr>
<h2 id='pivot_longer'>Pivot data from wide to long</h2><span id='topic+pivot_longer'></span><span id='topic+pivot_longer.Seurat'></span>

<h3>Description</h3>

<p><code>pivot_longer()</code> &quot;lengthens&quot; data, increasing the number of rows and
decreasing the number of columns. The inverse transformation is
<code><a href="tidyr.html#topic+pivot_wider">pivot_wider()</a></code>
</p>
<p>Learn more in <code>vignette("pivot")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
pivot_longer(
  data,
  cols,
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = NULL,
  names_transform = NULL,
  names_repair = "check_unique",
  values_to = "value",
  values_drop_na = FALSE,
  values_ptypes = NULL,
  values_transform = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_longer_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to pivot into
longer format.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_to">names_to</code></td>
<td>
<p>A character vector specifying the new column or columns to
create from the information stored in the column names of <code>data</code> specified
by <code>cols</code>.
</p>

<ul>
<li><p> If length 0, or if <code>NULL</code> is supplied, no columns will be created.
</p>
</li>
<li><p> If length 1, a single column will be created which will contain the
column names specified by <code>cols</code>.
</p>
</li>
<li><p> If length &gt;1, multiple columns will be created. In this case, one of
<code>names_sep</code> or <code>names_pattern</code> must be supplied to specify how the
column names should be split. There are also two additional character
values you can take advantage of:
</p>

<ul>
<li> <p><code>NA</code> will discard the corresponding component of the column name.
</p>
</li>
<li> <p><code>".value"</code> indicates that the corresponding component of the column
name defines the name of the output column containing the cell values,
overriding <code>values_to</code> entirely.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_prefix">names_prefix</code></td>
<td>
<p>A regular expression used to remove matching text
from the start of each variable name.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_sep">names_sep</code>, <code id="pivot_longer_+3A_names_pattern">names_pattern</code></td>
<td>
<p>If <code>names_to</code> contains multiple values,
these arguments control how the column name is broken up.
</p>
<p><code>names_sep</code> takes the same specification as <code><a href="tidyr.html#topic+separate">separate()</a></code>, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).
</p>
<p><code>names_pattern</code> takes the same specification as <code><a href="tidyr.html#topic+extract">extract()</a></code>, a regular
expression containing matching groups (<code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>If these arguments do not give you enough control, use
<code>pivot_longer_spec()</code> to create a spec object and process manually as
needed.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_ptypes">names_ptypes</code>, <code id="pivot_longer_+3A_values_ptypes">values_ptypes</code></td>
<td>
<p>Optionally, a list of column name-prototype
pairs. Alternatively, a single empty prototype can be supplied, which will
be applied to all columns. A prototype (or ptype for short) is a
zero-length vector (like <code>integer()</code> or <code>numeric()</code>) that defines the type,
class, and attributes of a vector. Use these arguments if you want to
confirm that the created columns are the types that you expect. Note that
if you want to change (instead of confirm) the types of specific columns,
you should use <code>names_transform</code> or <code>values_transform</code> instead.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_transform">names_transform</code>, <code id="pivot_longer_+3A_values_transform">values_transform</code></td>
<td>
<p>Optionally, a list of column
name-function pairs. Alternatively, a single function can be supplied,
which will be applied to all columns. Use these arguments if you need to
change the types of specific columns. For example, <code>names_transform = list(week = as.integer)</code> would convert a character variable called <code>week</code>
to an integer.
</p>
<p>If not specified, the type of the columns generated from <code>names_to</code> will
be character, and the type of the variables generated from <code>values_to</code>
will be the common type of the input columns used to generate them.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_values_to">values_to</code></td>
<td>
<p>A string specifying the name of the column to create
from the data stored in cell values. If <code>names_to</code> is a character
containing the special <code>.value</code> sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p>If <code>TRUE</code>, will drop rows that contain only <code>NA</code>s
in the <code>value_to</code> column. This effectively converts explicit missing values
to implicit missing values, and should generally be used only when missing
values in <code>data</code> were created by its structure.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pivot_longer()</code> is an updated approach to <code><a href="tidyr.html#topic+gather">gather()</a></code>, designed to be both
simpler to use and to handle more use cases. We recommend you use
<code>pivot_longer()</code> for new code; <code>gather()</code> isn't going away but is no longer
under active development.
</p>


<h3>Value</h3>

<p>'tidyseurat'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; pivot_longer(
  cols=c(orig.ident, groups),
  names_to="name", values_to="value")

</code></pre>

<hr>
<h2 id='plotly'>Initiate a plotly visualization</h2><span id='topic+plotly'></span><span id='topic+plot_ly'></span><span id='topic+plot_ly.tbl_df'></span><span id='topic+plot_ly.Seurat'></span>

<h3>Description</h3>

<p>This function maps R objects to <a href="https://plotly.com/javascript/">plotly.js</a>,
an (MIT licensed) web-based interactive charting library. It provides
abstractions for doing common things (e.g. mapping data values to
fill colors (via <code>color</code>) or creating <a href="plotly.html#topic+animation">animation</a>s (via <code>frame</code>)) and sets
some different defaults to make the interface feel more 'R-like'
(i.e., closer to <code><a href="base.html#topic+plot">plot()</a></code> and <code><a href="ggplot2.html#topic+qplot">ggplot2::qplot()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ly(
  data = data.frame(),
  ...,
  type = NULL,
  name = NULL,
  color = NULL,
  colors = NULL,
  alpha = NULL,
  stroke = NULL,
  strokes = NULL,
  alpha_stroke = 1,
  size = NULL,
  sizes = c(10, 100),
  span = NULL,
  spans = c(1, 20),
  symbol = NULL,
  symbols = NULL,
  linetype = NULL,
  linetypes = NULL,
  split = NULL,
  frame = NULL,
  width = NULL,
  height = NULL,
  source = "A"
)

## S3 method for class 'tbl_df'
plot_ly(
  data = data.frame(),
  ...,
  type = NULL,
  name = NULL,
  color = NULL,
  colors = NULL,
  alpha = NULL,
  stroke = NULL,
  strokes = NULL,
  alpha_stroke = 1,
  size = NULL,
  sizes = c(10, 100),
  span = NULL,
  spans = c(1, 20),
  symbol = NULL,
  symbols = NULL,
  linetype = NULL,
  linetypes = NULL,
  split = NULL,
  frame = NULL,
  width = NULL,
  height = NULL,
  source = "A"
)

## S3 method for class 'Seurat'
plot_ly(
  data = data.frame(),
  ...,
  type = NULL,
  name = NULL,
  color = NULL,
  colors = NULL,
  alpha = NULL,
  stroke = NULL,
  strokes = NULL,
  alpha_stroke = 1,
  size = NULL,
  sizes = c(10, 100),
  span = NULL,
  spans = c(1, 20),
  symbol = NULL,
  symbols = NULL,
  linetype = NULL,
  linetypes = NULL,
  split = NULL,
  frame = NULL,
  width = NULL,
  height = NULL,
  source = "A"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotly_+3A_data">data</code></td>
<td>
<p>A data frame (optional) or <a href="crosstalk.html#topic+SharedData">crosstalk::SharedData</a> object.</p>
</td></tr>
<tr><td><code id="plotly_+3A_...">...</code></td>
<td>
<p>Arguments (i.e., attributes) passed along to the trace <code>type</code>.
See <code><a href="plotly.html#topic+schema">schema()</a></code> for a list of acceptable attributes for a given trace <code>type</code>
(by going to <code>traces</code> -&gt; <code>type</code> -&gt; <code>attributes</code>). Note that attributes
provided at this level may override other arguments
(e.g. <code>plot_ly(x = 1:10, y = 1:10, color = I("red"), marker = list(color = "blue"))</code>).</p>
</td></tr>
<tr><td><code id="plotly_+3A_type">type</code></td>
<td>
<p>A character string specifying the trace type (e.g. <code>"scatter"</code>, <code>"bar"</code>, <code>"box"</code>, etc).
If specified, it <em>always</em> creates a trace, otherwise</p>
</td></tr>
<tr><td><code id="plotly_+3A_name">name</code></td>
<td>
<p>Values mapped to the trace's name attribute. Since a trace can
only have one name, this argument acts very much like <code>split</code> in that it
creates one trace for every unique value.</p>
</td></tr>
<tr><td><code id="plotly_+3A_color">color</code></td>
<td>
<p>Values mapped to relevant 'fill-color' attribute(s)
(e.g. <a href="https://plotly.com/r/reference/#scatter-fillcolor">fillcolor</a>,
<a href="https://plotly.com/r/reference/#scatter-marker-color">marker.color</a>,
<a href="https://plotly.com/r/reference/#scatter-textfont-color">textfont.color</a>, etc.).
The mapping from data values to color codes may be controlled using
<code>colors</code> and <code>alpha</code>, or avoided altogether via <code><a href="base.html#topic+I">I()</a></code> (e.g., <code>color = I("red")</code>).
Any color understood by <code><a href="grDevices.html#topic+col2rgb">grDevices::col2rgb()</a></code> may be used in this way.</p>
</td></tr>
<tr><td><code id="plotly_+3A_colors">colors</code></td>
<td>
<p>Either a colorbrewer2.org palette name (e.g. &quot;YlOrRd&quot; or &quot;Blues&quot;),
or a vector of colors to interpolate in hexadecimal &quot;#RRGGBB&quot; format,
or a color interpolation function like <code>colorRamp()</code>.</p>
</td></tr>
<tr><td><code id="plotly_+3A_alpha">alpha</code></td>
<td>
<p>A number between 0 and 1 specifying the alpha channel applied to <code>color</code>.
Defaults to 0.5 when mapping to <a href="https://plotly.com/r/reference/#scatter-fillcolor">fillcolor</a> and 1 otherwise.</p>
</td></tr>
<tr><td><code id="plotly_+3A_stroke">stroke</code></td>
<td>
<p>Similar to <code>color</code>, but values are mapped to relevant 'stroke-color' attribute(s)
(e.g., <a href="https://plotly.com/r/reference/#scatter-marker-line-color">marker.line.color</a>
and <a href="https://plotly.com/r/reference/#scatter-line-color">line.color</a>
for filled polygons). If not specified, <code>stroke</code> inherits from <code>color</code>.</p>
</td></tr>
<tr><td><code id="plotly_+3A_strokes">strokes</code></td>
<td>
<p>Similar to <code>colors</code>, but controls the <code>stroke</code> mapping.</p>
</td></tr>
<tr><td><code id="plotly_+3A_alpha_stroke">alpha_stroke</code></td>
<td>
<p>Similar to <code>alpha</code>, but applied to <code>stroke</code>.</p>
</td></tr>
<tr><td><code id="plotly_+3A_size">size</code></td>
<td>
<p>(Numeric) values mapped to relevant 'fill-size' attribute(s)
(e.g., <a href="https://plotly.com/r/reference/#scatter-marker-size">marker.size</a>,
<a href="https://plotly.com/r/reference/#scatter-textfont-size">textfont.size</a>,
and <a href="https://plotly.com/r/reference/#scatter-error_x-width">error_x.width</a>).
The mapping from data values to symbols may be controlled using
<code>sizes</code>, or avoided altogether via <code><a href="base.html#topic+I">I()</a></code> (e.g., <code>size = I(30)</code>).</p>
</td></tr>
<tr><td><code id="plotly_+3A_sizes">sizes</code></td>
<td>
<p>A numeric vector of length 2 used to scale <code>size</code> to pixels.</p>
</td></tr>
<tr><td><code id="plotly_+3A_span">span</code></td>
<td>
<p>(Numeric) values mapped to relevant 'stroke-size' attribute(s)
(e.g.,
<a href="https://plotly.com/r/reference/#scatter-marker-line-width">marker.line.width</a>,
<a href="https://plotly.com/r/reference/#scatter-line-width">line.width</a> for filled polygons,
and <a href="https://plotly.com/r/reference/#scatter-error_x-thickness">error_x.thickness</a>)
The mapping from data values to symbols may be controlled using
<code>spans</code>, or avoided altogether via <code><a href="base.html#topic+I">I()</a></code> (e.g., <code>span = I(30)</code>).</p>
</td></tr>
<tr><td><code id="plotly_+3A_spans">spans</code></td>
<td>
<p>A numeric vector of length 2 used to scale <code>span</code> to pixels.</p>
</td></tr>
<tr><td><code id="plotly_+3A_symbol">symbol</code></td>
<td>
<p>(Discrete) values mapped to <a href="https://plotly.com/r/reference/#scatter-marker-symbol">marker.symbol</a>.
The mapping from data values to symbols may be controlled using
<code>symbols</code>, or avoided altogether via <code><a href="base.html#topic+I">I()</a></code> (e.g., <code>symbol = I("pentagon")</code>).
Any <a href="graphics.html#topic+pch">pch</a> value or <a href="https://plotly.com/r/reference/#scatter-marker-symbol">symbol name</a> may be used in this way.</p>
</td></tr>
<tr><td><code id="plotly_+3A_symbols">symbols</code></td>
<td>
<p>A character vector of <a href="graphics.html#topic+pch">pch</a> values or <a href="https://plotly.com/r/reference/#scatter-marker-symbol">symbol names</a>.</p>
</td></tr>
<tr><td><code id="plotly_+3A_linetype">linetype</code></td>
<td>
<p>(Discrete) values mapped to <a href="https://plotly.com/r/reference/#scatter-line-dash">line.dash</a>.
The mapping from data values to symbols may be controlled using
<code>linetypes</code>, or avoided altogether via <code><a href="base.html#topic+I">I()</a></code> (e.g., <code>linetype = I("dash")</code>).
Any <code>lty</code> (see <a href="graphics.html#topic+par">par</a>) value or <a href="https://plotly.com/r/reference/#scatter-line-dash">dash name</a> may be used in this way.</p>
</td></tr>
<tr><td><code id="plotly_+3A_linetypes">linetypes</code></td>
<td>
<p>A character vector of <code>lty</code> values or <a href="https://plotly.com/r/reference/#scatter-line-dash">dash names</a></p>
</td></tr>
<tr><td><code id="plotly_+3A_split">split</code></td>
<td>
<p>(Discrete) values used to create multiple traces (one trace per value).</p>
</td></tr>
<tr><td><code id="plotly_+3A_frame">frame</code></td>
<td>
<p>(Discrete) values used to create animation frames.</p>
</td></tr>
<tr><td><code id="plotly_+3A_width">width</code></td>
<td>
<p>Width in pixels (optional, defaults to automatic sizing).</p>
</td></tr>
<tr><td><code id="plotly_+3A_height">height</code></td>
<td>
<p>Height in pixels (optional, defaults to automatic sizing).</p>
</td></tr>
<tr><td><code id="plotly_+3A_source">source</code></td>
<td>
<p>a character string of length 1. Match the value of this string
with the source argument in <code><a href="plotly.html#topic+event_data">event_data()</a></code> to retrieve the
event data corresponding to a specific plot (shiny apps can have multiple plots).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unless <code>type</code> is specified, this function just initiates a plotly
object with 'global' attributes that are passed onto downstream uses of
<code><a href="plotly.html#topic+add_trace">add_trace()</a></code> (or similar). A <a href="stats.html#topic+formula">formula</a> must always be used when
referencing column name(s) in <code>data</code> (e.g. <code>plot_ly(mtcars, x = ~wt)</code>).
Formulas are optional when supplying values directly, but they do
help inform default axis/scale titles
(e.g., <code>plot_ly(x = mtcars$wt)</code> vs <code>plot_ly(x = ~mtcars$wt)</code>)
</p>


<h3>Value</h3>

<p>'plotly'
</p>


<h3>Author(s)</h3>

<p>Carson Sievert
</p>


<h3>References</h3>

<p><a href="https://plotly-r.com/overview.html">https://plotly-r.com/overview.html</a>
</p>


<h3>See Also</h3>


<ul>
<li><p> For initializing a plotly-geo object: <code><a href="plotly.html#topic+plot_geo">plot_geo()</a></code>
</p>
</li>
<li><p> For initializing a plotly-mapbox object: <code><a href="plotly.html#topic+plot_mapbox">plot_mapbox()</a></code>
</p>
</li>
<li><p> For translating a ggplot2 object to a plotly object: <code><a href="plotly.html#topic+ggplotly">ggplotly()</a></code>
</p>
</li>
<li><p> For modifying any plotly object: <code><a href="plotly.html#topic+layout">layout()</a></code>, <code><a href="plotly.html#topic+add_trace">add_trace()</a></code>, <code><a href="plotly.html#topic+style">style()</a></code>
</p>
</li>
<li><p> For linked brushing: <code><a href="plotly.html#topic+highlight">highlight()</a></code>
</p>
</li>
<li><p> For arranging multiple plots: <code><a href="plotly.html#topic+subplot">subplot()</a></code>, <code><a href="crosstalk.html#topic+bscols">crosstalk::bscols()</a></code>
</p>
</li>
<li><p> For inspecting plotly objects: <code><a href="plotly.html#topic+plotly_json">plotly_json()</a></code>
</p>
</li>
<li><p> For quick, accurate, and searchable plotly.js reference: <code><a href="plotly.html#topic+schema">schema()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
plot_ly(pbmc_small)

</code></pre>

<hr>
<h2 id='pull'>Extract a single column</h2><span id='topic+pull'></span><span id='topic+pull.Seurat'></span>

<h3>Description</h3>

<p><code>pull()</code> is similar to <code>$</code>. It's mostly useful because it looks a little
nicer in pipes, it also works with remote data frames, and it can optionally
name the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
pull(.data, var = -1, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="pull_+3A_var">var</code></td>
<td>
<p>A variable specified as:
</p>

<ul>
<li><p> a literal variable name
</p>
</li>
<li><p> a positive integer, giving the position counting from the left
</p>
</li>
<li><p> a negative integer, giving the position counting from the right.
</p>
</li></ul>

<p>The default returns the last column (on the assumption that's the
column you've created most recently).
</p>
<p>This argument is taken by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names and column locations).</p>
</td></tr>
<tr><td><code id="pull_+3A_name">name</code></td>
<td>
<p>An optional parameter that specifies the column to be used
as names for a named vector. Specified in a similar manner as <code>var</code>.</p>
</td></tr>
<tr><td><code id="pull_+3A_...">...</code></td>
<td>
<p>For use by methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same size as <code>.data</code>.
</p>


<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; pull(groups)

</code></pre>

<hr>
<h2 id='quo_names'>Convert array of quosure (e.g. c(col_a, col_b)) into character vector</h2><span id='topic+quo_names'></span>

<h3>Description</h3>

<p>Convert array of quosure (e.g. c(col_a, col_b)) into character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quo_names(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quo_names_+3A_v">v</code></td>
<td>
<p>A array of quosures (e.g. c(col_a, col_b))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='rename'>Rename columns</h2><span id='topic+rename'></span><span id='topic+rename.Seurat'></span>

<h3>Description</h3>

<p><code>rename()</code> changes the names of individual variables using
<code>new_name = old_name</code> syntax; <code>rename_with()</code> renames columns using a
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
rename(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="rename_+3A_...">...</code></td>
<td>
<p>For <code>rename()</code>: &lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Use
<code>new_name = old_name</code> to rename selected variables.
</p>
<p>For <code>rename_with()</code>: additional arguments passed onto <code>.fn</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Rows are not affected.
</p>
</li>
<li><p> Column names are changed; column order is preserved.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are updated to reflect new names.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+arrange">arrange</a>()</code>,
<code><a href="#topic+mutate">mutate</a>()</code>,
<code><a href="#topic+slice">slice</a>()</code>,
<code><a href="#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; rename(s_score=nFeature_RNA)

</code></pre>

<hr>
<h2 id='return_arguments_of'>returns variables from an expression</h2><span id='topic+return_arguments_of'></span>

<h3>Description</h3>

<p>returns variables from an expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_arguments_of(expression)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="return_arguments_of_+3A_expression">expression</code></td>
<td>
<p>an expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of symbols
</p>

<hr>
<h2 id='right_join'>Mutating joins</h2><span id='topic+right_join'></span><span id='topic+right_join.Seurat'></span>

<h3>Description</h3>

<p>Mutating joins add columns from <code>y</code> to <code>x</code>, matching observations based on
the keys. There are four mutating joins: the inner join, and the three outer
joins.
</p>


<h4>Inner join</h4>

<p>An <code>inner_join()</code> only keeps observations from <code>x</code> that have a matching key
in <code>y</code>.
</p>
<p>The most important property of an inner join is that unmatched rows in either
input are not included in the result. This means that generally inner joins
are not appropriate in most analyses, because it is too easy to lose
observations.
</p>



<h4>Outer joins</h4>

<p>The three outer joins keep observations that appear in at least one of the
data frames:
</p>

<ul>
<li><p> A <code>left_join()</code> keeps all observations in <code>x</code>.
</p>
</li>
<li><p> A <code>right_join()</code> keeps all observations in <code>y</code>.
</p>
</li>
<li><p> A <code>full_join()</code> keeps all observations in <code>x</code> and <code>y</code>.
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
right_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="right_join_+3A_x">x</code>, <code id="right_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="right_join_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="right_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="right_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="right_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>x</code> (including the same groups). The order of
the rows and columns of <code>x</code> is preserved as much as possible. The output has
the following properties:
</p>

<ul>
<li><p> The rows are affect by the join type.
</p>

<ul>
<li> <p><code>inner_join()</code> returns matched <code>x</code> rows.
</p>
</li>
<li> <p><code>left_join()</code> returns all <code>x</code> rows.
</p>
</li>
<li> <p><code>right_join()</code>  returns matched of <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li>
<li> <p><code>full_join()</code>  returns all <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li></ul>

</li>
<li><p> Output columns include all columns from <code>x</code> and all non-key columns from
<code>y</code>. If <code>keep = TRUE</code>, the key columns from <code>y</code> are included as well.
</p>
</li>
<li><p> If non-key columns in <code>x</code> and <code>y</code> have the same name, <code>suffix</code>es are added
to disambiguate. If <code>keep = TRUE</code> and key columns in <code>x</code> and <code>y</code> have
the same name, <code>suffix</code>es are added to disambiguate these as well.
</p>
</li>
<li><p> If <code>keep = FALSE</code>, output columns included in <code>by</code> are coerced to their
common type between <code>x</code> and <code>y</code>.
</p>
</li></ul>



<h3>Many-to-many relationships</h3>

<p>By default, dplyr guards against many-to-many relationships in equality joins
by throwing a warning. These occur when both of the following are true:
</p>

<ul>
<li><p> A row in <code>x</code> matches multiple rows in <code>y</code>.
</p>
</li>
<li><p> A row in <code>y</code> matches multiple rows in <code>x</code>.
</p>
</li></ul>

<p>This is typically surprising, as most joins involve a relationship of
one-to-one, one-to-many, or many-to-one, and is often the result of an
improperly specified join. Many-to-many relationships are particularly
problematic because they can result in a Cartesian explosion of the number of
rows returned from the join.
</p>
<p>If a many-to-many relationship is expected, silence this warning by
explicitly setting <code>relationship = "many-to-many"</code>.
</p>
<p>In production code, it is best to preemptively set <code>relationship</code> to whatever
relationship you expect to exist between the keys of <code>x</code> and <code>y</code>, as this
forces an error to occur immediately if the data doesn't align with your
expectations.
</p>
<p>Inequality joins typically result in many-to-many relationships by nature, so
they don't warn on them by default, but you should still take extra care when
specifying an inequality join, because they also have the capability to
return a large number of rows.
</p>
<p>Rolling joins don't warn on many-to-many relationships either, but many
rolling joins follow a many-to-one relationship, so it is often useful to
set <code>relationship = "many-to-one"</code> to enforce this.
</p>
<p>Note that in SQL, most database providers won't let you specify a
many-to-many relationship between two tables, instead requiring that you
create a third <em>junction table</em> that results in two one-to-many relationships
instead.
</p>


<h3>Methods</h3>

<p>These functions are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>inner_join()</code>: no methods found.
</p>
</li>
<li> <p><code>left_join()</code>: no methods found.
</p>
</li>
<li> <p><code>right_join()</code>: no methods found.
</p>
</li>
<li> <p><code>full_join()</code>: no methods found.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other joins: 
<code><a href="dplyr.html#topic+cross_join">cross_join</a>()</code>,
<code><a href="dplyr.html#topic+filter-joins">filter-joins</a></code>,
<code><a href="dplyr.html#topic+nest_join">nest_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
tt &lt;- pbmc_small
tt |&gt; right_join(tt |&gt; 
  distinct(groups) |&gt; 
  mutate(new_column=1:2) |&gt; 
  slice(1))

</code></pre>

<hr>
<h2 id='rowwise'>Group input by rows</h2><span id='topic+rowwise'></span><span id='topic+rowwise.Seurat'></span>

<h3>Description</h3>

<p><code>rowwise()</code> allows you to compute on a data frame a row-at-a-time.
This is most useful when a vectorised function doesn't exist.
</p>
<p>Most dplyr verbs preserve row-wise grouping. The exception is <code><a href="dplyr.html#topic+summarise">summarise()</a></code>,
which return a <a href="dplyr.html#topic+grouped_df">grouped_df</a>. You can explicitly ungroup with <code><a href="dplyr.html#topic+ungroup">ungroup()</a></code>
or <code><a href="dplyr.html#topic+as_tibble">as_tibble()</a></code>, or convert to a <a href="dplyr.html#topic+grouped_df">grouped_df</a> with <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
rowwise(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowwise_+3A_data">data</code></td>
<td>
<p>Input data frame.</p>
</td></tr>
<tr><td><code id="rowwise_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Variables to be preserved
when calling <code><a href="dplyr.html#topic+summarise">summarise()</a></code>. This is typically a set of variables whose
combination uniquely identify each row.
</p>
<p><strong>NB</strong>: unlike <code>group_by()</code> you can not create new variables here but
instead you can select multiple variables with (e.g.) <code>everything()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row-wise data frame with class <code>rowwise_df</code>. Note that a
<code>rowwise_df</code> is implicitly grouped by row, but is not a <code>grouped_df</code>.
</p>


<h3>List-columns</h3>

<p>Because a rowwise has exactly one row per group it offers a small
convenience for working with list-columns. Normally, <code>summarise()</code> and
<code>mutate()</code> extract a groups worth of data with <code>[</code>. But when you index
a list in this way, you get back another list. When you're working with
a <code>rowwise</code> tibble, then dplyr will use <code>[[</code> instead of <code>[</code> to make your
life a little easier.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+nest_by">nest_by()</a></code> for a convenient way of creating rowwise data frames
with nested data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO

</code></pre>

<hr>
<h2 id='sample_n'>Sample n rows from a table</h2><span id='topic+sample_n'></span><span id='topic+sample_n.Seurat'></span><span id='topic+sample_frac'></span><span id='topic+sample_frac.Seurat'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
<code>sample_n()</code> and <code>sample_frac()</code> have been superseded in favour of
<code><a href="dplyr.html#topic+slice_sample">slice_sample()</a></code>. While they will not be deprecated in the near future,
retirement means that we will only perform critical bug fixes, so we recommend
moving to the newer alternative.
</p>
<p>These functions were superseded because we realised it was more convenient to
have two mutually exclusive arguments to one function, rather than two
separate functions. This also made it to clean up a few other smaller
design issues with <code>sample_n()</code>/<code>sample_frac</code>:
</p>

<ul>
<li><p> The connection to <code>slice()</code> was not obvious.
</p>
</li>
<li><p> The name of the first argument, <code>tbl</code>, is inconsistent with other
single table verbs which use <code>.data</code>.
</p>
</li>
<li><p> The <code>size</code> argument uses tidy evaluation, which is surprising and
undocumented.
</p>
</li>
<li><p> It was easier to remove the deprecated <code>.env</code> argument.
</p>
</li>
<li> <p><code>...</code> was in a suboptimal position.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
sample_n(tbl, size, replace = FALSE, weight = NULL, .env = NULL, ...)

## S3 method for class 'Seurat'
sample_frac(tbl, size = 1, replace = FALSE, weight = NULL, .env = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_n_+3A_tbl">tbl</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="sample_n_+3A_size">size</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt;
For <code>sample_n()</code>, the number of rows to select.
For <code>sample_frac()</code>, the fraction of rows to select.
If <code>tbl</code> is grouped, <code>size</code> applies to each group.</p>
</td></tr>
<tr><td><code id="sample_n_+3A_replace">replace</code></td>
<td>
<p>Sample with or without replacement?</p>
</td></tr>
<tr><td><code id="sample_n_+3A_weight">weight</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Sampling weights.
This must evaluate to a vector of non-negative numbers the same length as
the input. Weights are automatically standardised to sum to 1.</p>
</td></tr>
<tr><td><code id="sample_n_+3A_.env">.env</code></td>
<td>
<p>DEPRECATED.</p>
</td></tr>
<tr><td><code id="sample_n_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; sample_n(50)
pbmc_small |&gt; sample_frac(0.1)

</code></pre>

<hr>
<h2 id='select'>Keep or drop columns using their names and types</h2><span id='topic+select'></span><span id='topic+select.Seurat'></span>

<h3>Description</h3>

<p>Select (and optionally rename) variables in a data frame, using a concise
mini-language that makes it easy to refer to variables based on their name
(e.g. <code>a:f</code> selects all columns from <code>a</code> on the left to <code>f</code> on the
right) or type (e.g. <code>where(is.numeric)</code> selects all numeric columns).
</p>


<h4>Overview of selection features</h4>

<p>Tidyverse selections implement a dialect of R where operators make
it easy to select variables:
</p>

<ul>
<li> <p><code>:</code> for selecting a range of consecutive variables.
</p>
</li>
<li> <p><code>!</code> for taking the complement of a set of variables.
</p>
</li>
<li> <p><code>&amp;</code> and <code>|</code> for selecting the intersection or the union of two
sets of variables.
</p>
</li>
<li> <p><code>c()</code> for combining selections.
</p>
</li></ul>

<p>In addition, you can use <strong>selection helpers</strong>. Some helpers select specific
columns:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+everything">everything()</a></code>: Matches all variables.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+everything">last_col()</a></code>: Select last variable, possibly with an offset.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_cols">group_cols()</a></code>: Select all grouping columns.
</p>
</li></ul>

<p>Other helpers select variables by matching patterns in their names:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+starts_with">starts_with()</a></code>: Starts with a prefix.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">ends_with()</a></code>: Ends with a suffix.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">contains()</a></code>: Contains a literal string.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">matches()</a></code>: Matches a regular expression.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">num_range()</a></code>: Matches a numerical range like x01, x02, x03.
</p>
</li></ul>

<p>Or from variables stored in a character vector:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+all_of">all_of()</a></code>: Matches variable names in a character vector. All
names must be present, otherwise an out-of-bounds error is
thrown.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+all_of">any_of()</a></code>: Same as <code>all_of()</code>, except that no error is thrown
for names that don't exist.
</p>
</li></ul>

<p>Or using a predicate function:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+where">where()</a></code>: Applies a function to all variables and selects those
for which the function returns <code>TRUE</code>.
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; One or more unquoted
expressions separated by commas. Variable names can be used as if they
were positions in the data frame, so expressions like <code>x:y</code> can
be used to select a range of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Rows are not affected.
</p>
</li>
<li><p> Output columns are a subset of input columns, potentially with a different
order. Columns will be renamed if <code>new_name = old_name</code> form is used.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are maintained; you can't select off grouping variables.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>Examples</h3>

<p>Here we show the usage for the basic selection operators. See the
specific help pages to learn about helpers like <code><a href="dplyr.html#topic+starts_with">starts_with()</a></code>.
</p>
<p>The selection language can be used in functions like
<code>dplyr::select()</code> or <code>tidyr::pivot_longer()</code>. Let's first attach
the tidyverse:
</p>
<div class="sourceCode r"><pre>library(tidyverse)

# For better printing
iris &lt;- as_tibble(iris)
</pre></div>
<p>Select variables by name:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(height)
#&gt; # A tibble: 87 x 1
#&gt;   height
#&gt;    &lt;int&gt;
#&gt; 1    172
#&gt; 2    167
#&gt; 3     96
#&gt; 4    202
#&gt; # i 83 more rows

iris %&gt;% pivot_longer(Sepal.Length)
#&gt; # A tibble: 150 x 6
#&gt;   Sepal.Width Petal.Length Petal.Width Species name         value
#&gt;         &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1         3.5          1.4         0.2 setosa  Sepal.Length   5.1
#&gt; 2         3            1.4         0.2 setosa  Sepal.Length   4.9
#&gt; 3         3.2          1.3         0.2 setosa  Sepal.Length   4.7
#&gt; 4         3.1          1.5         0.2 setosa  Sepal.Length   4.6
#&gt; # i 146 more rows
</pre></div>
<p>Select multiple variables by separating them with commas. Note how
the order of columns is determined by the order of inputs:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(homeworld, height, mass)
#&gt; # A tibble: 87 x 3
#&gt;   homeworld height  mass
#&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt;
#&gt; 1 Tatooine     172    77
#&gt; 2 Tatooine     167    75
#&gt; 3 Naboo         96    32
#&gt; 4 Tatooine     202   136
#&gt; # i 83 more rows
</pre></div>
<p>Functions like <code>tidyr::pivot_longer()</code> don't take variables with
dots. In this case use <code>c()</code> to select multiple variables:
</p>
<div class="sourceCode r"><pre>iris %&gt;% pivot_longer(c(Sepal.Length, Petal.Length))
#&gt; # A tibble: 300 x 5
#&gt;   Sepal.Width Petal.Width Species name         value
#&gt;         &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1         3.5         0.2 setosa  Sepal.Length   5.1
#&gt; 2         3.5         0.2 setosa  Petal.Length   1.4
#&gt; 3         3           0.2 setosa  Sepal.Length   4.9
#&gt; 4         3           0.2 setosa  Petal.Length   1.4
#&gt; # i 296 more rows
</pre></div>


<h4>Operators:</h4>

<p>The <code>:</code> operator selects a range of consecutive variables:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(name:mass)
#&gt; # A tibble: 87 x 3
#&gt;   name           height  mass
#&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt;
#&gt; 1 Luke Skywalker    172    77
#&gt; 2 C-3PO             167    75
#&gt; 3 R2-D2              96    32
#&gt; 4 Darth Vader       202   136
#&gt; # i 83 more rows
</pre></div>
<p>The <code>!</code> operator negates a selection:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(!(name:mass))
#&gt; # A tibble: 87 x 11
#&gt;   hair_color skin_color  eye_color birth_year sex   gender    homeworld species
#&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;  
#&gt; 1 blond      fair        blue            19   male  masculine Tatooine  Human  
#&gt; 2 &lt;NA&gt;       gold        yellow         112   none  masculine Tatooine  Droid  
#&gt; 3 &lt;NA&gt;       white, blue red             33   none  masculine Naboo     Droid  
#&gt; 4 none       white       yellow          41.9 male  masculine Tatooine  Human  
#&gt; # i 83 more rows
#&gt; # i 3 more variables: films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;

iris %&gt;% select(!c(Sepal.Length, Petal.Length))
#&gt; # A tibble: 150 x 3
#&gt;   Sepal.Width Petal.Width Species
#&gt;         &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
#&gt; 1         3.5         0.2 setosa 
#&gt; 2         3           0.2 setosa 
#&gt; 3         3.2         0.2 setosa 
#&gt; 4         3.1         0.2 setosa 
#&gt; # i 146 more rows

iris %&gt;% select(!ends_with("Width"))
#&gt; # A tibble: 150 x 3
#&gt;   Sepal.Length Petal.Length Species
#&gt;          &lt;dbl&gt;        &lt;dbl&gt; &lt;fct&gt;  
#&gt; 1          5.1          1.4 setosa 
#&gt; 2          4.9          1.4 setosa 
#&gt; 3          4.7          1.3 setosa 
#&gt; 4          4.6          1.5 setosa 
#&gt; # i 146 more rows
</pre></div>
<p><code>&amp;</code> and <code>|</code> take the intersection or the union of two selections:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(starts_with("Petal") &amp; ends_with("Width"))
#&gt; # A tibble: 150 x 1
#&gt;   Petal.Width
#&gt;         &lt;dbl&gt;
#&gt; 1         0.2
#&gt; 2         0.2
#&gt; 3         0.2
#&gt; 4         0.2
#&gt; # i 146 more rows

iris %&gt;% select(starts_with("Petal") | ends_with("Width"))
#&gt; # A tibble: 150 x 3
#&gt;   Petal.Length Petal.Width Sepal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          1.4         0.2         3.5
#&gt; 2          1.4         0.2         3  
#&gt; 3          1.3         0.2         3.2
#&gt; 4          1.5         0.2         3.1
#&gt; # i 146 more rows
</pre></div>
<p>To take the difference between two selections, combine the <code>&amp;</code> and
<code>!</code> operators:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(starts_with("Petal") &amp; !ends_with("Width"))
#&gt; # A tibble: 150 x 1
#&gt;   Petal.Length
#&gt;          &lt;dbl&gt;
#&gt; 1          1.4
#&gt; 2          1.4
#&gt; 3          1.3
#&gt; 4          1.5
#&gt; # i 146 more rows
</pre></div>



<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="dplyr.html#topic+arrange">arrange</a>()</code>,
<code><a href="dplyr.html#topic+filter">filter</a>()</code>,
<code><a href="dplyr.html#topic+mutate">mutate</a>()</code>,
<code><a href="dplyr.html#topic+reframe">reframe</a>()</code>,
<code><a href="dplyr.html#topic+rename">rename</a>()</code>,
<code><a href="dplyr.html#topic+slice">slice</a>()</code>,
<code><a href="dplyr.html#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; select(cell, orig.ident)

</code></pre>

<hr>
<h2 id='separate'>Separate a character column into multiple columns with a regular
expression or numeric locations</h2><span id='topic+separate'></span><span id='topic+separate.Seurat'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>separate()</code> has been superseded in favour of <code><a href="tidyr.html#topic+separate_wider_position">separate_wider_position()</a></code>
and <code><a href="tidyr.html#topic+separate_wider_delim">separate_wider_delim()</a></code> because the two functions make the two uses
more obvious, the API is more polished, and the handling of problems is
better. Superseded functions will not go away, but will only receive
critical bug fixes.
</p>
<p>Given either a regular expression or a vector of character positions,
<code>separate()</code> turns a single character column into multiple columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
separate(
  data,
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  extra = "warn",
  fill = "warn",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="separate_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="separate_+3A_col">col</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Column to expand.</p>
</td></tr>
<tr><td><code id="separate_+3A_into">into</code></td>
<td>
<p>Names of new variables to create as character vector.
Use <code>NA</code> to omit the variable in the output.</p>
</td></tr>
<tr><td><code id="separate_+3A_sep">sep</code></td>
<td>
<p>Separator between columns.
</p>
<p>If character, <code>sep</code> is interpreted as a regular expression. The default
value is a regular expression that matches any sequence of
non-alphanumeric values.
</p>
<p>If numeric, <code>sep</code> is interpreted as character positions to split at. Positive
values start at 1 at the far-left of the string; negative value start at -1 at
the far-right of the string. The length of <code>sep</code> should be one less than
<code>into</code>.</p>
</td></tr>
<tr><td><code id="separate_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input column from output data frame.</p>
</td></tr>
<tr><td><code id="separate_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will run <code><a href="utils.html#topic+type.convert">type.convert()</a></code> with
<code>as.is = TRUE</code> on new columns. This is useful if the component
columns are integer, numeric or logical.
</p>
<p>NB: this will cause string <code>"NA"</code>s to be converted to <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="separate_+3A_extra">extra</code></td>
<td>
<p>If <code>sep</code> is a character vector, this controls what
happens when there are too many pieces. There are three valid options:
</p>

<ul>
<li> <p><code>"warn"</code> (the default): emit a warning and drop extra values.
</p>
</li>
<li> <p><code>"drop"</code>: drop any extra values without a warning.
</p>
</li>
<li> <p><code>"merge"</code>: only splits at most <code>length(into)</code> times
</p>
</li></ul>
</td></tr>
<tr><td><code id="separate_+3A_fill">fill</code></td>
<td>
<p>If <code>sep</code> is a character vector, this controls what
happens when there are not enough pieces. There are three valid options:
</p>

<ul>
<li> <p><code>"warn"</code> (the default): emit a warning and fill from the right
</p>
</li>
<li> <p><code>"right"</code>: fill with missing values on the right
</p>
</li>
<li> <p><code>"left"</code>: fill with missing values on the left
</p>
</li></ul>
</td></tr>
<tr><td><code id="separate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'tidyseurat'
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+unite">unite()</a></code>, the complement, <code><a href="tidyr.html#topic+extract">extract()</a></code> which uses regular
expression capturing groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
un &lt;- pbmc_small |&gt; unite("new_col", c(orig.ident, groups))
un |&gt; separate(new_col, c("orig.ident", "groups"))

</code></pre>

<hr>
<h2 id='slice'>Subset rows using their positions</h2><span id='topic+slice'></span><span id='topic+slice.Seurat'></span><span id='topic+slice_head'></span><span id='topic+slice_tail'></span><span id='topic+slice_sample'></span><span id='topic+slice_min'></span><span id='topic+slice_max'></span><span id='topic+slice_sample.Seurat'></span><span id='topic+slice_head.Seurat'></span><span id='topic+slice_tail.Seurat'></span><span id='topic+slice_min.Seurat'></span><span id='topic+slice_max.Seurat'></span>

<h3>Description</h3>

<p><code>slice()</code> lets you index rows by their (integer) locations. It allows you
to select, remove, and duplicate rows. It is accompanied by a number of
helpers for common use cases:
</p>

<ul>
<li> <p><code>slice_head()</code> and <code>slice_tail()</code> select the first or last rows.
</p>
</li>
<li> <p><code>slice_sample()</code> randomly selects rows.
</p>
</li>
<li> <p><code>slice_min()</code> and <code>slice_max()</code> select rows with highest or lowest values
of a variable.
</p>
</li></ul>

<p>If <code>.data</code> is a <a href="dplyr.html#topic+grouped_df">grouped_df</a>, the operation will be performed on each group,
so that (e.g.) <code>slice_head(df, n = 5)</code> will select the first five rows in
each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
slice(.data, ..., .by = NULL, .preserve = FALSE)

## S3 method for class 'Seurat'
slice_sample(
  .data,
  ...,
  n = NULL,
  prop = NULL,
  by = NULL,
  weight_by = NULL,
  replace = FALSE
)

## S3 method for class 'Seurat'
slice_head(.data, ..., n, prop, by = NULL)

## S3 method for class 'Seurat'
slice_tail(.data, ..., n, prop, by = NULL)

## S3 method for class 'Seurat'
slice_min(
  .data,
  order_by,
  ...,
  n,
  prop,
  by = NULL,
  with_ties = TRUE,
  na_rm = FALSE
)

## S3 method for class 'Seurat'
slice_max(
  .data,
  order_by,
  ...,
  n,
  prop,
  by = NULL,
  with_ties = TRUE,
  na_rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="slice_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.</p>
</td></tr>
<tr><td><code id="slice_+3A_.by">.by</code>, <code id="slice_+3A_by">by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="slice_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
<tr><td><code id="slice_+3A_n">n</code>, <code id="slice_+3A_prop">prop</code></td>
<td>
<p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</td></tr>
<tr><td><code id="slice_+3A_weight_by">weight_by</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</td></tr>
<tr><td><code id="slice_+3A_replace">replace</code></td>
<td>
<p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</td></tr>
<tr><td><code id="slice_+3A_order_by">order_by</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</td></tr>
<tr><td><code id="slice_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="slice_+3A_na_rm">na_rm</code></td>
<td>
<p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Slice does not work with relational databases because they have no
intrinsic notion of row order. If you want to perform the equivalent
operation, use <code><a href="dplyr.html#topic+filter">filter()</a></code> and <code><a href="dplyr.html#topic+row_number">row_number()</a></code>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Each row may appear 0, 1, or many times in the output.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Groups are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Methods</h3>

<p>These function are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>slice()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_head()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_tail()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_min()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_max()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_sample()</code>: no methods found.
</p>
</li></ul>

<p>These function are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>slice()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_head()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_tail()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_min()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_max()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_sample()</code>: no methods found.
</p>
</li></ul>

<p>These function are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>slice()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_head()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_tail()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_min()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_max()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_sample()</code>: no methods found.
</p>
</li></ul>

<p>These function are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>slice()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_head()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_tail()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_min()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_max()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_sample()</code>: no methods found.
</p>
</li></ul>

<p>These function are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>slice()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_head()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_tail()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_min()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_max()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_sample()</code>: no methods found.
</p>
</li></ul>

<p>These function are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>slice()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_head()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_tail()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_min()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_max()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_sample()</code>: no methods found.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+arrange">arrange</a>()</code>,
<code><a href="#topic+mutate">mutate</a>()</code>,
<code><a href="#topic+rename">rename</a>()</code>,
<code><a href="#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; slice(1)

# Slice group-wise using .by
pbmc_small |&gt; slice(1:2, .by=groups)


# slice_sample() allows you to random select with or without replacement
pbmc_small |&gt; slice_sample(n=5)

# if using replacement, and duplicate cells are returned, a tibble will be
# returned because duplicate cells cannot exist in Seurat objects
pbmc_small |&gt; slice_sample(n=1, replace=TRUE) # returns Seurat
pbmc_small |&gt; slice_sample(n=100, replace=TRUE) # returns tibble

# weight by a variable
pbmc_small |&gt; slice_sample(n=5, weight_by=nCount_RNA)

# sample by group
pbmc_small |&gt; slice_sample(n=5, by=groups)

# sample using proportions
pbmc_small |&gt; slice_sample(prop=0.10)


# First rows based on existing order
pbmc_small |&gt; slice_head(n=5)


# Last rows based on existing order
pbmc_small |&gt; slice_tail(n=5)


# Rows with minimum and maximum values of a metadata variable
pbmc_small |&gt; slice_min(nFeature_RNA, n=5)

# slice_min() and slice_max() may return more rows than requested
# in the presence of ties.
pbmc_small |&gt;  slice_min(nFeature_RNA, n=2)

# Use with_ties=FALSE to return exactly n matches
pbmc_small |&gt; slice_min(nFeature_RNA, n=2, with_ties=FALSE)

# Or use additional variables to break the tie:
pbmc_small |&gt; slice_min(tibble::tibble(nFeature_RNA, nCount_RNA), n=2)

# Use by for group-wise operations
pbmc_small |&gt; slice_min(nFeature_RNA, n=5, by=groups)


# Rows with minimum and maximum values of a metadata variable
pbmc_small |&gt; slice_max(nFeature_RNA, n=5)

</code></pre>

<hr>
<h2 id='summarise'>Summarise each group down to one row</h2><span id='topic+summarise'></span><span id='topic+summarise.Seurat'></span><span id='topic+summarize'></span><span id='topic+summarize.Seurat'></span>

<h3>Description</h3>

<p><code>summarise()</code> creates a new data frame. It returns one row for each
combination of grouping variables; if there are no grouping variables, the
output will have a single row summarising all observations in the input. It
will contain one column for each grouping variable and one column for each of
the summary statistics that you have specified.
</p>
<p><code>summarise()</code> and <code>summarize()</code> are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
summarise(.data, ...)

## S3 method for class 'Seurat'
summarize(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="summarise_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
summary functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <em>usually</em> of the same type as <code>.data</code>.
</p>

<ul>
<li><p> The rows come from the underlying <code><a href="dplyr.html#topic+group_keys">group_keys()</a></code>.
</p>
</li>
<li><p> The columns are a combination of the grouping keys and the summary
expressions that you provide.
</p>
</li>
<li><p> The grouping structure is controlled by the <code style="white-space: pre;">&#8288;.groups=&#8288;</code> argument, the
output may be another <a href="dplyr.html#topic+grouped_df">grouped_df</a>, a <a href="dplyr.html#topic+tibble">tibble</a> or a <a href="dplyr.html#topic+rowwise">rowwise</a> data frame.
</p>
</li>
<li><p> Data frame attributes are <strong>not</strong> preserved, because <code>summarise()</code>
fundamentally creates a new data frame.
</p>
</li></ul>



<h3>Useful functions</h3>


<ul>
<li><p> Center: <code><a href="base.html#topic+mean">mean()</a></code>, <code><a href="stats.html#topic+median">median()</a></code>
</p>
</li>
<li><p> Spread: <code><a href="stats.html#topic+sd">sd()</a></code>, <code><a href="stats.html#topic+IQR">IQR()</a></code>, <code><a href="stats.html#topic+mad">mad()</a></code>
</p>
</li>
<li><p> Range: <code><a href="base.html#topic+min">min()</a></code>, <code><a href="base.html#topic+max">max()</a></code>,
</p>
</li>
<li><p> Position: <code><a href="dplyr.html#topic+first">first()</a></code>, <code><a href="dplyr.html#topic+last">last()</a></code>, <code><a href="dplyr.html#topic+nth">nth()</a></code>,
</p>
</li>
<li><p> Count: <code><a href="dplyr.html#topic+n">n()</a></code>, <code><a href="dplyr.html#topic+n_distinct">n_distinct()</a></code>
</p>
</li>
<li><p> Logical: <code><a href="base.html#topic+any">any()</a></code>, <code><a href="base.html#topic+all">all()</a></code>
</p>
</li></ul>



<h3>Backend variations</h3>

<p>The data frame backend supports creating a variable and using it in the
same summary. This means that previously created summary variables can be
further transformed or combined within the summary, as in <code><a href="dplyr.html#topic+mutate">mutate()</a></code>.
However, it also means that summary variables with the same names as previous
variables overwrite them, making those variables unavailable to later summary
variables.
</p>
<p>This behaviour may not be supported in other backends. To avoid unexpected
results, consider using new names for your summary variables, especially when
creating multiple summaries.
</p>


<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+arrange">arrange</a>()</code>,
<code><a href="#topic+mutate">mutate</a>()</code>,
<code><a href="#topic+rename">rename</a>()</code>,
<code><a href="#topic+slice">slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; summarise(mean(nCount_RNA))

</code></pre>

<hr>
<h2 id='tbl_format_header'>Format the header of a tibble</h2><span id='topic+tbl_format_header'></span><span id='topic+tbl_format_header.tidySeurat'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>For easier customization, the formatting of a tibble is split
into three components: header, body, and footer.
The <code>tbl_format_header()</code> method is responsible for formatting the header
of a tibble.
</p>
<p>Override this method if you need to change the appearance
of the entire header.
If you only need to change or extend the components shown in the header,
override or extend <code><a href="pillar.html#topic+tbl_sum">tbl_sum()</a></code> for your class which is called by the
default method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidySeurat'
tbl_format_header(x, setup, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tbl_format_header_+3A_x">x</code></td>
<td>
<p>A tibble-like object.</p>
</td></tr>
<tr><td><code id="tbl_format_header_+3A_setup">setup</code></td>
<td>
<p>A setup object returned from <code><a href="pillar.html#topic+tbl_format_setup">tbl_format_setup()</a></code>.</p>
</td></tr>
<tr><td><code id="tbl_format_header_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO

</code></pre>

<hr>
<h2 id='tidy'>tidy for 'Seurat'</h2><span id='topic+tidy'></span><span id='topic+tidy.Seurat'></span>

<h3>Description</h3>

<p>tidy for 'Seurat'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy(object)

## S3 method for class 'Seurat'
tidy(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_+3A_object">object</code></td>
<td>
<p>A 'Seurat' object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'tidyseurat' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small

</code></pre>

<hr>
<h2 id='unite'>Unite multiple columns into one by pasting strings together</h2><span id='topic+unite'></span><span id='topic+unite.Seurat'></span>

<h3>Description</h3>

<p>Convenience function to paste together multiple columns into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
unite(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unite_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unite_+3A_col">col</code></td>
<td>
<p>The name of the new column, as a string or symbol.
</p>
<p>This argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote strings
and symbols). The name is captured from the expression with
<code><a href="rlang.html#topic+defusing-advanced">rlang::ensym()</a></code> (note that this kind of interface where
symbols do not represent actual objects is now discouraged in the
tidyverse; we support it here for backward compatibility).</p>
</td></tr>
<tr><td><code id="unite_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to unite</p>
</td></tr>
<tr><td><code id="unite_+3A_sep">sep</code></td>
<td>
<p>Separator to use between values.</p>
</td></tr>
<tr><td><code id="unite_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input columns from output data frame.</p>
</td></tr>
<tr><td><code id="unite_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, missing values will be removed prior to uniting
each value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'tidyseurat'
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+separate">separate()</a></code>, the complement.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; unite(
  col="new_col", 
  c("orig.ident", "groups"))
    
</code></pre>

<hr>
<h2 id='unnest'>Unnest a list-column of data frames into rows and columns</h2><span id='topic+unnest'></span><span id='topic+unnest.tidyseurat_nested'></span><span id='topic+unnest_seurat'></span>

<h3>Description</h3>

<p>Unnest expands a list-column containing data frames into rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidyseurat_nested'
unnest(
  data,
  cols,
  ...,
  keep_empty = FALSE,
  ptype = NULL,
  names_sep = NULL,
  names_repair = "check_unique",
  .drop,
  .id,
  .sep,
  .preserve
)

unnest_seurat(
  data,
  cols,
  ...,
  keep_empty = FALSE,
  ptype = NULL,
  names_sep = NULL,
  names_repair = "check_unique",
  .drop,
  .id,
  .sep,
  .preserve
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unnest_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unnest_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; List-columns to unnest.
</p>
<p>When selecting multiple columns, values from the same row will be recycled
to their common size.</p>
</td></tr>
<tr><td><code id="unnest_+3A_...">...</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
previously you could write <code>df %&gt;% unnest(x, y, z)</code>.
Convert to <code>df %&gt;% unnest(c(x, y, z))</code>. If you previously created a new
variable in <code>unnest()</code> you'll now need to do it explicitly with <code>mutate()</code>.
Convert <code>df %&gt;% unnest(y = fun(x, y, z))</code>
to <code>df %&gt;% mutate(y = fun(x, y, z)) %&gt;% unnest(y)</code>.</p>
</td></tr>
<tr><td><code id="unnest_+3A_keep_empty">keep_empty</code></td>
<td>
<p>By default, you get one row of output for each element
of the list that you are unchopping/unnesting. This means that if there's a
size-0 element (like <code>NULL</code> or an empty data frame or vector), then that
entire row will be dropped from the output. If you want to preserve all
rows, use <code>keep_empty = TRUE</code> to replace size-0 elements with a single row
of missing values.</p>
</td></tr>
<tr><td><code id="unnest_+3A_ptype">ptype</code></td>
<td>
<p>Optionally, a named list of column name-prototype pairs to
coerce <code>cols</code> to, overriding the default that will be guessed from
combining the individual values. Alternatively, a single empty ptype
can be supplied, which will be applied to all <code>cols</code>.</p>
</td></tr>
<tr><td><code id="unnest_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the outer names will come from the
inner names. If a string, the outer names will be formed by pasting
together the outer and the inner column names, separated by <code>names_sep</code>.</p>
</td></tr>
<tr><td><code id="unnest_+3A_names_repair">names_repair</code></td>
<td>
<p>Used to check that output data frame has valid
names. Must be one of the following options:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;"minimal&#8288;</code>&quot;: no name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"unique&#8288;</code>&quot;: make sure names are unique and not empty,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"check_unique&#8288;</code>&quot;: (the default), no name repair, but check they are unique,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"universal&#8288;</code>&quot;: make the names unique and syntactic
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li>
<li> <p><a href="tidyr.html#topic+tidyr_legacy">tidyr_legacy</a>: use the name repair from tidyr 0.8.
</p>
</li>
<li><p> a formula: a purrr-style anonymous function (see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>)
</p>
</li></ul>

<p>See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for more details on these terms and the
strategies used to enforce them.</p>
</td></tr>
<tr><td><code id="unnest_+3A_.drop">.drop</code>, <code id="unnest_+3A_.preserve">.preserve</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
all list-columns are now preserved; If there are any that you
don't want in the output use <code>select()</code> to remove them prior to
unnesting.</p>
</td></tr>
<tr><td><code id="unnest_+3A_.id">.id</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
convert <code>df %&gt;% unnest(x, .id = "id")</code> to <code style="white-space: pre;">&#8288;df %&gt;% mutate(id = names(x)) %&gt;% unnest(x))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="unnest_+3A_.sep">.sep</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
use <code>names_sep</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'tidyseurat'
</p>


<h3>New syntax</h3>

<p>tidyr 1.0.0 introduced a new syntax for <code>nest()</code> and <code>unnest()</code> that's
designed to be more similar to other functions. Converting to the new syntax
should be straightforward (guided by the message you'll receive) but if
you just need to run an old analysis, you can easily revert to the previous
behaviour using <code><a href="tidyr.html#topic+nest_legacy">nest_legacy()</a></code> and <code><a href="tidyr.html#topic+unnest_legacy">unnest_legacy()</a></code> as follows:
</p>
<div class="sourceCode"><pre>library(tidyr)
nest &lt;- nest_legacy
unnest &lt;- unnest_legacy
</pre></div>


<h3>See Also</h3>

<p>Other rectangling: 
<code><a href="tidyr.html#topic+hoist">hoist</a>()</code>,
<code><a href="tidyr.html#topic+unnest_longer">unnest_longer</a>()</code>,
<code><a href="tidyr.html#topic+unnest_wider">unnest_wider</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbmc_small)
pbmc_small |&gt; 
    nest(data=-groups) |&gt; 
    unnest(data)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
