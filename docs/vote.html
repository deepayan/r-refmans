<!DOCTYPE html><html><head><title>Help for package vote</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vote}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#approval'>
<p>Approval and Plurality Vote Count</p></a></li>
<li><a href='#condorcet'>
<p>Condorcet Vote Count</p></a></li>
<li><a href='#count.votes'>
<p>Count Votes</p></a></li>
<li><a href='#dublin_west'>
<p>Election Dataset to Dublin West Constituency</p></a></li>
<li><a href='#food_election'>
<p>Example Dataset</p></a></li>
<li><a href='#ims_election'>
<p>Datasets on IMS Election</p></a></li>
<li><a href='#score'>
<p>Score Vote Count</p></a></li>
<li><a href='#stv'>
<p>Single Transferable Vote</p></a></li>
<li><a href='#tworound.runoff'>
<p>Two-Round Runoff Vote Count</p></a></li>
<li><a href='#vote-package'>
<p>Election Vote Counting</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Election Vote Counting</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Hana Sevcikova, Bernard Silverman, Adrian Raftery</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hana Sevcikova&lt;hanas@uw.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Counting election votes and determining election results by different methods, including
    the single transferable vote or ranked choice, approval, score, plurality, condorcet and two-round runoff methods (Raftery et al., 2021 &lt;<a href="https://doi.org/10.32614%2FRJ-2021-086">doi:10.32614/RJ-2021-086</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>formattable, knitr, data.table, fields</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-10 04:56:57 UTC; hana</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-10 05:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='approval'>
Approval and Plurality Vote Count
</h2><span id='topic+approval'></span><span id='topic+summary.vote.approval'></span><span id='topic+view.vote.approval'></span><span id='topic+print.summary.vote.approval'></span><span id='topic+vote.approval'></span><span id='topic+plurality'></span><span id='topic+summary.vote.plurality'></span><span id='topic+view.vote.plurality'></span><span id='topic+print.summary.vote.plurality'></span><span id='topic+vote.plurality'></span>

<h3>Description</h3>

<p>Count votes using the approval and plurality methods. Each voter can select  candidates using  1 for a selection and 0 otherwise. In the approval method, any number of candidates can be selected by a voter, while in the plurality method only one candidate can be chosen by a voter. Thus, plurality voting is a special case of approval voting. The winner(s) in either method is/are the most-approved candidate(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approval(votes, nseats = 1, fsep = "\t", quiet = FALSE, ...)

## S3 method for class 'vote.approval'
summary(object, ...)

## S3 method for class 'vote.approval'
view(object, ...)

plurality(votes, nseats = 1, fsep = "\t", quiet = FALSE, ...)

## S3 method for class 'vote.plurality'
summary(object, ...)

## S3 method for class 'vote.plurality'
view(object, ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approval_+3A_votes">votes</code></td>
<td>
<p>Matrix or data frame of zeros and ones containing the votes. Rows correspond to the votes, columns correspond to the candidates. If it is a character string it is interpreted as a file name from which the votes are to be read. Missing values (<code>NA</code>) are interpreted as zeros.</p>
</td></tr>
<tr><td><code id="approval_+3A_nseats">nseats</code></td>
<td>
<p>Number of candidates to be elected.</p>
</td></tr>
<tr><td><code id="approval_+3A_fsep">fsep</code></td>
<td>
<p>If <code>votes</code> is a file name, this argument gives the column separator in the file.</p>
</td></tr>
<tr><td><code id="approval_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code> no output is printed.</p>
</td></tr>
<tr><td><code id="approval_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="approval_+3A_object">object</code></td>
<td>
<p>Object of class <code>vote.approval</code> or <code>vote.plurality</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions <code>approval</code> and <code>plurality</code> return an object of class <code>vote.approval</code> and <code>vote.plurality</code>, respectively, both of which are lists with the following objects:
</p>
<table>
<tr><td><code>elected</code></td>
<td>
<p>Vector of names of the elected candidates in the order in which they were elected.</p>
</td></tr>
<tr><td><code>totals</code></td>
<td>
<p>Vector of total votes in the same order as candidates (columns) in the input data.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Input data with invalid votes removed.</p>
</td></tr>
<tr><td><code>invalid.votes</code></td>
<td>
<p>Matrix of invalid votes that were removed from the original dataset.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Approval_voting">https://en.wikipedia.org/wiki/Approval_voting</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Plurality_voting_method">https://en.wikipedia.org/wiki/Plurality_voting_method</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+count.votes">count.votes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example using the IMS Council dataset modified for approval voting
data(ims_approval)
approval(ims_approval)

# Example using the IMS Council dataset modified for plurality voting
data(ims_plurality)
pl.ims &lt;- plurality(ims_plurality)
invalid.votes(pl.ims)
</code></pre>

<hr>
<h2 id='condorcet'>
Condorcet Vote Count
</h2><span id='topic+condorcet'></span><span id='topic+summary.vote.condorcet'></span><span id='topic+view.vote.condorcet'></span><span id='topic+print.summary.vote.condorcet'></span><span id='topic+vote.condorcet'></span><span id='topic+image.vote.condorcet'></span>

<h3>Description</h3>

<p>Count votes using the Condorcet voting method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condorcet(votes, runoff = FALSE, fsep = '\t', quiet = FALSE, ...)

## S3 method for class 'vote.condorcet'
summary(object, ...)

## S3 method for class 'vote.condorcet'
view(object, ...)

## S3 method for class 'vote.condorcet'
image(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condorcet_+3A_votes">votes</code></td>
<td>
<p>Matrix or data frame containing the votes. Rows correspond to the votes,  columns correspond to the candidates. If it is a character string it is interpreted as a file name from which the votes are to be read. See below for more details.</p>
</td></tr>
<tr><td><code id="condorcet_+3A_runoff">runoff</code></td>
<td>
<p>Logical. If <code>TRUE</code> and no condorcet winner exists, the election goes into a run-off, see below for details. </p>
</td></tr>
<tr><td><code id="condorcet_+3A_fsep">fsep</code></td>
<td>
<p>If <code>votes</code> is a file name, this argument gives the column separator in the file.</p>
</td></tr>
<tr><td><code id="condorcet_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code> no output is printed.</p>
</td></tr>
<tr><td><code id="condorcet_+3A_object">object</code>, <code id="condorcet_+3A_x">x</code></td>
<td>
<p>Object of class <code>vote.condorcet</code>.</p>
</td></tr>
<tr><td><code id="condorcet_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying functions. For the <code>image</code> function, see arguments for <code><a href="#topic+image.vote.stv">image.vote.stv</a></code>, especially <code>xpref</code>, <code>ypref</code>, <code>all.pref</code> and <code>proportion</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Condorcet method elects the candidate that wins a majority of the ranked vote in every head-to-head election against each of the other candidates. I.e., the Condorcet winner is a candidate that beats all other candidates in pairwise comparisons. Analogously, a Condorcet loser is a candidate that loses against all other candidates.
Neither Condorcet winner nor loser might exist.
</p>
<p>If the <code>runoff</code> argument is set to <code>TRUE</code> and no Condorcet winner exists, two or more candidates with the most pairwise wins are selected and the method is applied to such subset. If more than two candidates are in such run-off, the selection is performed repeatedly, until either a winner is selected or no more selection is possible.
</p>
<p>The input data <code>votes</code> is structured the same way as for the <code><a href="#topic+stv">stv</a></code> method: Row <code class="reqn">i</code> contains the preferences of voter <code class="reqn">i</code> numbered <code class="reqn">1, 2, \dots, r, 0,0,0,0</code>, in some order, while equal preferences are allowed. The columns correspond to the candidates. The dimnames of the columns are the names of the candidates; if these are not supplied then the candidates are lettered A, B, C, .... If the dataset contains missing values (<code>NA</code>), they are replaced by zeros. 
</p>
<p>Note that if equal preferences are used, they are automatically converted into a format where for each preference <code class="reqn">i</code> that does not have any duplicate, there must be exactly <code class="reqn">i-1</code> preferences <code class="reqn">j</code> with <code class="reqn">0 &lt; j &lt; i</code>. It is the same ranking as one would obtain with <code>rank(x, ties.method = "min")</code>. If a conversion of a vote occurs, a warning is issued. That is done internally by calling the <code><a href="#topic+correct.ranking">correct.ranking</a></code> function.
</p>
<p>The <code>image</code> function visualizes the joint distribution of two preferences (if <code>all.pref=FALSE</code>) given by <code>xpref</code> and <code>ypref</code>, as well as the marginal distribution of all preferences (if <code>all.pref=TRUE</code>). The joint distribution can be shown as proportions (if <code>proportion=TRUE</code>) or raw vote counts (if <code>proportion=FALSE</code>).
</p>


<h3>Value</h3>

<p>Function <code>condorcet</code> returns an object of class <code>vote.condorcet</code> which is a list with the following objects:
</p>
<table>
<tr><td><code>elected</code></td>
<td>
<p>The Condorcet winner if exists, otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code>loser</code></td>
<td>
<p>The Condorcet loser if exists, otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code>totals</code></td>
<td>
<p>nc x nc matrix where nc is the number of candidates. Element ij = 1 if i won against j, otherwise 0.</p>
</td></tr>
<tr><td><code>runoff.winner</code></td>
<td>
<p>The run-off winner if exists and if the <code>runoff</code> argument was set to <code>TRUE</code>, otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code>runoff.participants</code></td>
<td>
<p>List of run-off participants if the <code>runoff</code> argument was set to <code>TRUE</code>, otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Input data (possibly corrected) with invalid votes removed.</p>
</td></tr>
<tr><td><code>invalid.votes</code></td>
<td>
<p>Matrix of invalid votes that were removed from the original dataset.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Salvatore Barbaro
</p>


<h3>References</h3>

<p>Condorcet, Marquis de (1785). Essai sur l'application de l'analyse a la probabilite des decisions rendues a la probabilite des voix. Paris: De l'imprimerie royale.
</p>
<p><a href="https://en.wikipedia.org/wiki/Condorcet_method">https://en.wikipedia.org/wiki/Condorcet_method</a>
</p>
<p>Sen A. (2017). Collective Choice and Social Welfare. Harvard University Press, Cambridge, Massachusetts (Chapter A4*).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(food_election)
cdc.food &lt;- condorcet(food_election)
summary(cdc.food)
# show the marginal distribution of the preferences
par(mai=c(1, 1.2, 0.8, 0.4)) # expand the left margin
image(cdc.food, all.pref = TRUE)

# Example with a runoff
votes &lt;- matrix(c(2, 1, 3, 4,
                  2, 1, 3, 4,
                  4, 3, 2, 1,
                  4, 3, 2, 1,
                  1, 4, 3, 2), byrow = TRUE, nrow = 5)
colnames(votes) &lt;- LETTERS[1:4]  
cdc.v &lt;- condorcet(votes, runoff = TRUE)
</code></pre>

<hr>
<h2 id='count.votes'>
Count Votes
</h2><span id='topic+count.votes'></span><span id='topic+invalid.votes'></span><span id='topic+valid.votes'></span><span id='topic+corrected.votes'></span>

<h3>Description</h3>

<p>Count votes using one of five methods. View valid, invalid and corrected ballots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count.votes(votes, method = c("auto", "plurality", "approval", "stv", 
    "score", "condorcet", "tworound.runoff"), fsep = "\t", ...)
	
invalid.votes(object)
valid.votes(object)
corrected.votes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count.votes_+3A_votes">votes</code></td>
<td>
<p>Matrix or data frame containing the votes. Rows correspond to the votes, columns correspond to the candidates. If it is a character string it is interpreted as a file name from which the votes are to be read. 
</p>
</td></tr>
<tr><td><code id="count.votes_+3A_method">method</code></td>
<td>
<p>Voting method to use. If &ldquo;auto&rdquo;, the input data is passed through a checker for each of the methods and the one with the largest number of valid votes is used. In case of the same number of valid votes, it goes by their ordering in the function definition. </p>
</td></tr>
<tr><td><code id="count.votes_+3A_fsep">fsep</code></td>
<td>
<p>If <code>votes</code> is a file name, this argument gives the column separator in the file.</p>
</td></tr>
<tr><td><code id="count.votes_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying functions, e.g. <code>nseats</code>, <code>max.score</code> etc.</p>
</td></tr>
<tr><td><code id="count.votes_+3A_object">object</code></td>
<td>
<p>Object returned by one of the functions <code><a href="#topic+plurality">plurality</a></code>, <code><a href="#topic+approval">approval</a></code>, <code><a href="#topic+stv">stv</a></code>, <code><a href="#topic+score">score</a></code>, <code><a href="#topic+condorcet">condorcet</a></code>, <code><a href="#topic+tworound.runoff">tworound.runoff</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending which method is used, <code>count.votes</code> returns an object of class <code><a href="#topic+vote.plurality">vote.plurality</a></code>, <code><a href="#topic+vote.approval">vote.approval</a></code>, <code><a href="#topic+vote.stv">vote.stv</a></code>, <code><a href="#topic+vote.score">vote.score</a></code>,  <code><a href="#topic+vote.condorcet">vote.condorcet</a></code>, or <code><a href="#topic+vote.tworound.runoff">vote.tworound.runoff</a></code>.
</p>
<p>Functions <code>valid.votes</code> and <code>invalid.votes</code> return a subset of the input data with valid records and invalid records, respectively. 
</p>
<p>Function <code>corrected.votes</code> can be used when votes are automatically corrected (as in <code><a href="#topic+stv">stv</a></code> and <code><a href="#topic+condorcet">condorcet</a></code>). It returns a list with the uncorrected votes (item <code>original</code>), the corrected votes (item <code>new</code>), and its indices within the original votes dataset (item <code>index</code>).
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Bernard Silverman
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stv">stv</a></code>, <code><a href="#topic+approval">approval</a></code>, <code><a href="#topic+score">score</a></code>, <code><a href="#topic+condorcet">condorcet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example using the IMS Council dataset modified for score voting
data(ims_score)
# should recognize that it is a dataset with score voting data
count.votes(ims_score, max.score = 9, larger.wins = FALSE)

# All records with score larger than 8 are excluded 
res &lt;- count.votes(ims_score, method = "score", max.score = 8)
head(invalid.votes(res))

summary(res)

# For a corrected.votes() example see ?stv
</code></pre>

<hr>
<h2 id='dublin_west'>
Election Dataset to Dublin West Constituency
</h2><span id='topic+dublin_west'></span>

<h3>Description</h3>

<p>Dataset containing ranked votes for the Dublin West constituency in 2002, Ireland. Results of that STV elections can be viewed at <a href="https://en.wikipedia.org/wiki/Dublin_West#2002_general_election">https://en.wikipedia.org/wiki/Dublin_West#2002_general_election</a>. They can be reproduced via the <code><a href="#topic+stv">stv</a></code> function, see Example below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dublin_west")
</code></pre>


<h3>Format</h3>

<p>A data frame with 29988 observations and 9 candidates. Each record corresponds to one ballot with candidates being ranked between 1 and 9 with zeros allowed. 
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Dublin_West#2002_general_election">https://en.wikipedia.org/wiki/Dublin_West#2002_general_election</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dublin_west)
head(dublin_west)

## Not run: 
# produce similar results as in the Wikipedia link above
dwstv &lt;- stv(dublin_west, nseats = 3, eps = 1, constant.quota = TRUE)

# plot results
plot(dwstv)
image(dwstv)
image(dwstv, all.pref = TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='food_election'>
Example Dataset
</h2><span id='topic+food_election'></span>

<h3>Description</h3>

<p>Dataset on food election which serves as a simple example for the STV method taken from Wikipedia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("food_election")</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations and 5 candidates (Oranges, Pears, Chocolate, Strawberries, Sweets). Each record corresponds to one ballot with ranking for each of the candidates.
</p>


<h3>Source</h3>

<p><a href="https://en.wikipedia.org/wiki/Single_transferable_vote#Example">https://en.wikipedia.org/wiki/Single_transferable_vote#Example</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(food_election)
head(food_election)
</code></pre>

<hr>
<h2 id='ims_election'>
Datasets on IMS Election
</h2><span id='topic+ims_election'></span><span id='topic+ims_stv'></span><span id='topic+ims_score'></span><span id='topic+ims_approval'></span><span id='topic+ims_plurality'></span>

<h3>Description</h3>

<p>Datasets containing anonymized votes for a past Council election of the Institute of Mathematical Statistics (IMS). The dataset <code>ims_election</code> (named also <code>ims_stv</code>) is the original dataset used with single transferable vote, where candidate names have been changed. Each of the other datasets is a  modified version of the original data to be used as an example for each of the other voting methods. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ims_election")
data("ims_stv")

data("ims_approval")
data("ims_score")
data("ims_plurality")
</code></pre>


<h3>Format</h3>

<p>A data frame with 620 observations and 10 candidates (names were made up). Each record corresponds to one ballot. Values depend on the voting method. The IMS Council voting is done using the STV method, and thus the <code>ims_election</code> dataset contains ballots with candidates being ranked between 1 and 10 with zeros allowed.
</p>


<h3>Source</h3>

<p>The original dataset (which was randomized and anonymized, with write-in votes removed) was obtained from the the Institute of Mathematical Statistics. 
</p>


<h3>References</h3>

<p><a href="https://imstat.org/elections/single-transferable-voting-system/">https://imstat.org/elections/single-transferable-voting-system/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ims_election)
head(ims_election)
</code></pre>

<hr>
<h2 id='score'>
Score Vote Count
</h2><span id='topic+score'></span><span id='topic+summary.vote.score'></span><span id='topic+view.vote.score'></span><span id='topic+print.summary.vote.score'></span><span id='topic+vote.score'></span>

<h3>Description</h3>

<p>Count votes using the score (or range) method. Voters give each candidate a score, the scores are added  and the candidate(s) with the highest (or lowest) totals is/are elected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(votes, nseats = 1, max.score = NULL, larger.wins = TRUE, 
  fsep = "\t", quiet = FALSE, ...)

## S3 method for class 'vote.score'
summary(object, ...)

## S3 method for class 'vote.score'
view(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_votes">votes</code></td>
<td>
<p>Matrix or data frame containing the votes which should be numbers between 0 and <code>max.score</code>. Rows correspond to the votes, columns correspond to the candidates. If it is a character string it is interpreted as a file name from which the votes are to be read. Missing values (<code>NA</code>) are interpreted as zeros.</p>
</td></tr>
<tr><td><code id="score_+3A_nseats">nseats</code></td>
<td>
<p>Number of candidates to be elected.</p>
</td></tr>
<tr><td><code id="score_+3A_max.score">max.score</code></td>
<td>
<p>Maximum score allowed. It is used to remove invalid votes. If not given, the maximum value contained in the data is taken and thus, all non-negative votes are valid.</p>
</td></tr>
<tr><td><code id="score_+3A_larger.wins">larger.wins</code></td>
<td>
<p>Logical argument indicating whether the winners are the candidates with the highest scores (default) or the lowest scores.</p>
</td></tr>
<tr><td><code id="score_+3A_fsep">fsep</code></td>
<td>
<p>If <code>votes</code> is a file name, this argument gives the column separator in the file.</p>
</td></tr>
<tr><td><code id="score_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code> no output is printed.</p>
</td></tr>
<tr><td><code id="score_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="score_+3A_object">object</code></td>
<td>
<p>Object of class <code>vote.score</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>score</code> returns an object of class <code>vote.score</code> which is a list with the following objects:
</p>
<table>
<tr><td><code>elected</code></td>
<td>
<p>Vector of names of the elected candidates in the order in which they were elected.</p>
</td></tr>
<tr><td><code>totals</code></td>
<td>
<p>Vector of total votes in the same order as candidates (columns) in the input data.</p>
</td></tr>
<tr><td><code>larger.wins</code></td>
<td>
<p>Input argument of the same name.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Input data with invalid votes removed.</p>
</td></tr>
<tr><td><code>invalid.votes</code></td>
<td>
<p>Number of invalid votes that were removed from the original dataset.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Range_voting">https://en.wikipedia.org/wiki/Range_voting</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+count.votes">count.votes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example using the IMS Council dataset modified for score voting
data(ims_score)
score.ims &lt;- score(ims_score, max.score = 9)
summary(score.ims)
</code></pre>

<hr>
<h2 id='stv'>
Single Transferable Vote
</h2><span id='topic+stv'></span><span id='topic+summary.vote.stv'></span><span id='topic+view.vote.stv'></span><span id='topic+view'></span><span id='topic+print.summary.vote.stv'></span><span id='topic+vote.stv'></span><span id='topic+image.vote.stv'></span><span id='topic+plot.vote.stv'></span><span id='topic+correct.ranking'></span><span id='topic+complete.ranking'></span><span id='topic+impute.ranking'></span><span id='topic+complete.ranking.vote.stv'></span><span id='topic+ordered.preferences'></span><span id='topic+ordered.tiebreak'></span><span id='topic+remove.candidate'></span>

<h3>Description</h3>

<p>Count votes using the single transferable voting method, also known as ranked choice voting or instant runoff. Raftery et al. (2021) describes the functionality in great detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stv(votes, nseats = NULL, eps = 0.001, equal.ranking = FALSE, 
  fsep = '\t', ties = c("f", "b"), constant.quota = FALSE,
  quota.hare = FALSE, group.nseats = NULL, group.members = NULL,
  complete.ranking = FALSE, invalid.partial = FALSE,
  impute.missing = FALSE, verbose = FALSE, seed = 1234, 
  quiet = FALSE, digits = 3, ...)

## S3 method for class 'vote.stv'
summary(object, ..., complete.ranking = FALSE, digits = 3)

## S3 method for class 'vote.stv'
view(object, ...)

## S3 method for class 'vote.stv'
plot(x, xlab = "Count", ylab = "Preferences", point.size = 2, ...)

## S3 method for class 'vote.stv'
image(x, xpref = 2, ypref = 1, all.pref = FALSE, proportion = TRUE, ...)

## S3 method for class 'vote.stv'
complete.ranking(object, ...)

correct.ranking(votes, partial = FALSE, quiet = FALSE)

impute.ranking(votes, equal.ranking = FALSE, quiet = TRUE)

remove.candidate(votes, can, quiet = TRUE)

ordered.tiebreak(vmat, seed = NULL)

ordered.preferences(vmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stv_+3A_votes">votes</code></td>
<td>
<p>Matrix or data frame containing the votes. Rows correspond to the votes,  columns correspond to the candidates. If it is a character string it is interpreted as a file name from which the votes are to be read. See below for more details.</p>
</td></tr>
<tr><td><code id="stv_+3A_nseats">nseats</code></td>
<td>
<p>Number of candidates to be elected. By default it is half the number of candidates standing.</p>
</td></tr>
<tr><td><code id="stv_+3A_eps">eps</code></td>
<td>
<p>Value added to the quota. I.e. the STV default Droop quota is computed as <br />
<code>number_of_first_preferences/(number_of_seats + 1) + eps</code>.</p>
</td></tr>
<tr><td><code id="stv_+3A_equal.ranking">equal.ranking</code></td>
<td>
<p>If <code>TRUE</code> equal preferences are allowed, see below.</p>
</td></tr>
<tr><td><code id="stv_+3A_fsep">fsep</code></td>
<td>
<p>If <code>votes</code> is a file name, this argument gives the column separator in the file.</p>
</td></tr>
<tr><td><code id="stv_+3A_ties">ties</code></td>
<td>
<p>Method used to break ties. By default the forwards tie-breaking is used (&ldquo;f&rdquo;). Value &ldquo;b&rdquo; invokes the backwards tie-breaking method, see O'Neill (2004).</p>
</td></tr>
<tr><td><code id="stv_+3A_constant.quota">constant.quota</code></td>
<td>
<p>Logical determining if the quota should be kept constant for all counts.</p>
</td></tr>
<tr><td><code id="stv_+3A_quota.hare">quota.hare</code></td>
<td>
<p>Changes quota calculation method from (default) Droop (<code>FALSE</code>) to Hare (<code>TRUE</code>). STV Hare quota method is computed as <br />
<code>number_of_first_preferences/number_of_seats + eps</code>. The actual Hare formula would entail <code>eps = 0</code>.</p>
</td></tr>
<tr><td><code id="stv_+3A_group.nseats">group.nseats</code></td>
<td>
<p>Minimum number of candidates to be elected who are members of a given group. I.e., number of reserved seats for a subset of candidates defined by the <code>group.members</code> argument.</p>
</td></tr>
<tr><td><code id="stv_+3A_group.members">group.members</code></td>
<td>
<p>Vector of candidate names or indices who are eligible for reserved seats given by <code>group.nseats</code>. If it is a vector of indices, the order of candidates is assumed to correspond to the columns of <code>votes</code>.</p>
</td></tr>
<tr><td><code id="stv_+3A_impute.missing">impute.missing</code></td>
<td>
<p>Logical. If <code>TRUE</code> and if the data contains values of <code class="reqn">-1</code>, those ranks are imputed while all other ranks that are equal or larger than the imputed value are shifted.</p>
</td></tr>
<tr><td><code id="stv_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> the progress of the count will be printed.</p>
</td></tr>
<tr><td><code id="stv_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed of the random number generator. Only used if there are ties that cannot be resolved by the tie-breaking method. If set to <code>NULL</code>, the RNG is not initialized.</p>
</td></tr>
<tr><td><code id="stv_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code> no output is printed.</p>
</td></tr>
<tr><td><code id="stv_+3A_object">object</code>, <code id="stv_+3A_x">x</code></td>
<td>
<p>Object of class <code>vote.stv</code>.</p>
</td></tr>
<tr><td><code id="stv_+3A_complete.ranking">complete.ranking</code></td>
<td>
<p>Logical. If <code>TRUE</code> a complete ranking is generated conditioned on the number of seats <code>nseats</code>.</p>
</td></tr>
<tr><td><code id="stv_+3A_invalid.partial">invalid.partial</code></td>
<td>
<p>Logical. If <code>TRUE</code>, partially invalid votes are corrected by removing ranking starting with the first incorrect rank, see Details below.</p>
</td></tr>
<tr><td><code id="stv_+3A_digits">digits</code></td>
<td>
<p>How many significant digits to be used in the output table.</p>
</td></tr>
<tr><td><code id="stv_+3A_xlab">xlab</code>, <code id="stv_+3A_ylab">ylab</code></td>
<td>
<p>Labels of the x- and y-axis.</p>
</td></tr>
<tr><td><code id="stv_+3A_point.size">point.size</code></td>
<td>
<p>Size of the points in the plot.</p>
</td></tr>
<tr><td><code id="stv_+3A_xpref">xpref</code>, <code id="stv_+3A_ypref">ypref</code></td>
<td>
<p>Preference for the x- and y-axis, respectively, for showing the joined distribution of the votes. It is not used if <code>all.pref</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stv_+3A_all.pref">all.pref</code></td>
<td>
<p>Logical. If <code>TRUE</code> the marginal distribution of all preferences is shown in the image. Otherwise, the joint distribution of <code>xpref</code> and <code>ypref</code> is shown.</p>
</td></tr>
<tr><td><code id="stv_+3A_proportion">proportion</code></td>
<td>
<p>If <code>TRUE</code> the preferences are shown as proportions across the x-axis, otherwise raw vote counts are shown. Only available when <code>all.pref</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="stv_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying functions.</p>
</td></tr>
<tr><td><code id="stv_+3A_partial">partial</code></td>
<td>
<p>Logical. The same meaning as <code>invalid.partial</code>.</p>
</td></tr>
<tr><td><code id="stv_+3A_can">can</code></td>
<td>
<p>Vector of candiate name(s) or indices to be removed from the set of votes.</p>
</td></tr>
<tr><td><code id="stv_+3A_vmat">vmat</code></td>
<td>
<p>Matrix of valid votes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a description of the single transferable vote system see <a href="https://imstat.org/elections/single-transferable-voting-system/">https://imstat.org/elections/single-transferable-voting-system/</a>.
</p>
<p>The input data <code>votes</code> is structured as follows: Row <code class="reqn">i</code> contains the preferences of voter <code class="reqn">i</code> numbered <code class="reqn">1, 2, \dots, r, 0,0,0,0</code>, in some order. The columns correspond to the candidates. The dimnames of the columns are the names of the candidates; if these are not supplied then the candidates are lettered A, B, C, .... If the dataset contains missing values (<code>NA</code>), they are replaced by zeros, representing lower preferences that were not expressed. 
</p>
<p>By default the preferences are not allowed to contain duplicates per vote. However, if the argument <code>equal.ranking</code> is set to <code>TRUE</code>, votes are allowed to have the same ranking for multiple candidates. The desired format is such that for each preference <code class="reqn">i</code> that does not have any duplicate, there must be exactly <code class="reqn">i-1</code> preferences <code class="reqn">j</code> with <code class="reqn">0 &lt; j &lt; i</code>. For example, valid ordered preferences are <code class="reqn">1,1,3,4,\dots</code>, or <code class="reqn">1,2,3,3,3,6,\dots</code>, but NOT <code class="reqn">1,1,2,3,\dots</code>, or NOT <code class="reqn">1,2,3,3,3,5,6,\dots</code>. If the data contain such invalid votes, they are automatically corrected and a warning is issued by calling the <code>correct.ranking</code> function. 
</p>
<p>If equal ranking is not alowed (<code>equal.ranking = FALSE</code>), the argument <code>invalid.partial</code> can be used to make ballots containing duplicates or gaps partially valid. If it is <code>TRUE</code>, a ballot is considered valid up to a preference that is in normal case not allowed. For example, ballots <code class="reqn">1,2,3,4,4,6</code> or <code class="reqn">1,2,3,5,6,7</code> would be both converted into <code class="reqn">1,2,3,0,0,0</code>, because the ballots contain valid ranking only up to the third preference. 
</p>
<p>The <code>correct.ranking</code> function does the above corrections for all records, regardless if they contain duplicates or not. Its argument <code>partial</code> determines if ballots are partially set to 0 (<code>TRUE</code>), or if it is complete re-ranking, as allowed when <code>equal.ranking = TRUE</code>. It can either be used by calling it explicitly, otherwise it is called by <code>stv</code> if <code>equal.ranking = TRUE</code> or <code>invalid.partial = TRUE</code>. The function is also called from within the <code><a href="#topic+condorcet">condorcet</a></code> function. The <code>remove.candidate</code> function removes the given candidate(s) and adjusts the ranked votes accordingly by calling the <code>correct.ranking</code> function.
</p>
<p>The function allows the user to impute missing values. It can be used for example, if a voter has a conflict of interest with one or more candidates and not voting for them would unfairly decrease the chances of those candidates being elected. (Note that missing values are not to be confused with lower preferences that are not expressed.) Preferences to be imputed should be set to <code class="reqn">-1</code> and the argument <code>impute.missing</code> to <code>TRUE</code>. Each such preference is imputed using the median rank value over the remaining votes. When computing the median rank across the votes, any value of zero is replaced by the median of the ranks not used in the corresponding vote. For example, for a ballot <code class="reqn">1,2,3,0,0,0</code>, the three zeros are replaced by the median of <code class="reqn">4, 5, 6</code>, i.e. by <code class="reqn">5</code>, which is then used to compute the missing median rank. If the final imputed rank is larger than the number of non-zero preferences (e.g. if in a ballot <code class="reqn">1,2,0,-1,0</code> the imputed value for the fourth candidate would be larger than 3), the preference is set to zero and a warning is issued.
The described functionality is implemented in the <code>impute.ranking</code> function, which is called automatically from <code>stv</code> if <code>impute.missing = TRUE</code>. It can be used explicitly as well.
</p>
<p>By default, ties in the STV algorithm are resolved using the forwards tie-breaking method, see Newland and Briton (Section 5.2.5). Argument <code>ties</code> can be set to &ldquo;b&rdquo; in order to use the backwards tie-breaking method, see O'Neill (2004). In addition, both methods are complemented by the following &ldquo;ordered&rdquo; method: Prior to the STV election candidates are ordered by the number of 1st preferences. Equal ranks are resolved by moving to the number of 2nd preferences, then 3rd and so on. Remaining ties are broken by random draws. Such complete ordering is used to break any tie that cannot be resolved by the forwards or backwards method. If there is at least one tie during the processing, the output contains a row indicating in which count a tie-break happened (see the <code>ties</code> element in the Value section for an explanation of the symbols).
</p>
<p>The ordered tiebreaking described above can be analysed from outside of the <code>stv</code> function by using the <code>ordered.tiebreak</code> function for viewing the a-priori ordering (the highest number is the best and lowest is the worst). Such ranking is produced by comparing candidates along the columns of the matrix returned by <code>ordered.preferences</code>.
</p>
<p>The <code>plot</code> function shows the evolution of the total score for each candidate as well as the quota. The <code>image</code> function visualizes the joint distribution of two preferences (if <code>all.pref=FALSE</code>) as well as the marginal distribution of all preferences (if <code>all.pref=TRUE</code>). The joint distribution can be shown either as proportions (if <code>proportion=TRUE</code>) or raw vote counts (if <code>proportion=FALSE</code>).
</p>
<p>Method <code>complete.ranking</code> produces a complete ranking of the candidates, conditioned on the number of seats selected in the <code>nseats</code> argument. It is called from the <code>summary</code> function if the <code>complete.ranking</code> argument is set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>Function <code>stv</code> returns an object of class <code>vote.stv</code> which is a list with the following objects:
</p>
<table>
<tr><td><code>elected</code></td>
<td>
<p>Vector of names of the elected candidates in the order in which they were elected.</p>
</td></tr>
<tr><td><code>preferences</code></td>
<td>
<p>Matrix of preferences. Columns correspond to the candidates and rows to the counts (i.e. voting rounds).</p>
</td></tr>
<tr><td><code>quotas</code></td>
<td>
<p>Vector of quotas, one for each count.</p>
</td></tr>
<tr><td><code>elect.elim</code></td>
<td>
<p>Matrix of the same shape as <code>preferences</code>. Value 1 means that the corresponding candidate was elected in that round; value -1 means an elimination.</p>
</td></tr>
<tr><td><code>equal.pref.allowed</code></td>
<td>
<p>Input argument <code>equal.ranking</code>.</p>
</td></tr>
<tr><td><code>ties</code></td>
<td>
<p>Character vector indicating if and what tie-break happened in each count. Possible values: &ldquo;&rdquo; (no tie-break), &ldquo;f&rdquo; (forward tie-breaking method only), &ldquo;fo&rdquo; (forward method and ordered method), &ldquo;fos&rdquo; (forward method and ordered method and sampling). If the backwards tie-breaking method is used, these values are &ldquo;b&rdquo;, &ldquo;bo&rdquo; and &ldquo;bos&rdquo;.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Input data (possibly corrected) with invalid votes removed.</p>
</td></tr>
<tr><td><code>invalid.votes</code></td>
<td>
<p>Matrix of invalid votes that were removed from the original dataset.</p>
</td></tr>
<tr><td><code>corrected.votes</code></td>
<td>
<p>List containing data about corrected votes if any. It has three or four elements, <code>original</code> (matrix of the raw votes that were corrected), (optionally) <code>imputed</code> (imputed values if any), <code>new</code> (the corrected values), <code>index</code> (index of those votes within the input <code>votes</code> dataset).</p>
</td></tr>
<tr><td><code>reserved.seats</code></td>
<td>
<p>Number of reserved seats (<code>group.nseats</code>), or <code>NULL</code> if none.</p>
</td></tr>
<tr><td><code>group.members</code></td>
<td>
<p>Vector of candidates eligible for reserved seats, or <code>NULL</code> if none.</p>
</td></tr>
</table>
<p>The <code>summary</code> function returns a data frame where columns are counts and transfers, and rows are the quota, the candidates, ties and the elected and eliminated candidates. Various attributes of the data frame contain more information about the results.
</p>
<p>The <code>correct.ranking</code> (<code>impute.ranking</code>) function returns a matrix of votes with corrected (imputed) preferences.
</p>
<p><code>remove.candidate</code> returns a matrix of votes with the given candidates removed and preferences corrected.
</p>
<p><code>complete.ranking</code> returns a data frame with a full ordering of the candidates.
</p>
<p><code>ordered.preferences</code> returns a matrix with number of preferences for each candidate and preference. These are the same values as seen by <code>image(..., all.pref = TRUE)</code>.
</p>
<p><code>ordered.tiebreak</code> returns the ranking for each candidate based on <code>ordered.preferences()</code>, with the highest number being the best and the lowest number being the worst. Its attribute &ldquo;sampled&rdquo; indicates if there was random sampling involved in ranking each candidate. 
</p>


<h3>Author(s)</h3>

<p>Bernard Silverman, Hana Sevcikova, Adrian Raftery
</p>


<h3>References</h3>

<p>Raftery, A.E., Sevcikova, H. and Silverman, B.W. (2021). The vote Package: Single Transferable Vote and Other Electoral Systems in R. The R Journal, 13(2), 673-696. <a href="https://doi.org/10.32614/RJ-2021-086">doi:10.32614/RJ-2021-086</a>.
</p>
<p>R.A. Newland and F.S. Britton (1997). How to conduct an election by the Single Transferable Vote. ERS 3rd Edition. <a href="http://www.rosenstiel.co.uk/stvrules/index.html">http://www.rosenstiel.co.uk/stvrules/index.html</a>
</p>
<p><a href="https://imstat.org/elections/single-transferable-voting-system/">https://imstat.org/elections/single-transferable-voting-system/</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Single_transferable_vote">https://en.wikipedia.org/wiki/Single_transferable_vote</a>
</p>
<p>J.C. O'Neill (2004). Tie-Breaking with the Single Transferable Vote. Voting Matters, 18, 14-17. <a href="https://www.votingmatters.org.uk/ISSUE18/I18P6.PDF">https://www.votingmatters.org.uk/ISSUE18/I18P6.PDF</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reproducing example from Wikipedia
# https://en.wikipedia.org/wiki/Single_transferable_vote#Example
# Uses eps=1
data(food_election)
stv.food &lt;- stv(food_election, nseats = 3, eps = 1)
summary(stv.food)
## Not run: 
view(stv.food)
## End(Not run)

# Example of the IMS Council voting
data(ims_election)
stv.ims &lt;- stv(ims_election, nseats = 5)
## Not run: 
view(stv.ims)
plot(stv.ims)
image(stv.ims)

# write election results into a csv file
s &lt;- summary(stv.ims)
write.csv(s, "myfile.csv")
## End(Not run)

# produce complete ranking
summary(stv.ims, complete.ranking = TRUE)

## Not run: 
# Example of Dublin West 2002 elections
# https://en.wikipedia.org/wiki/Dublin_West#2002_general_election
data(dublin_west)
stv(dublin_west, nseats = 3, eps = 1)
## End(Not run)

# Example of a small committee dataset
# with four candidates (C) and four
# voting committee members (uses tie-breaking)
votes &lt;- data.frame(C1=c(3,2,1,3), C2=c(2,1,2,4),
                    C3=c(4,3,3,1), C4=c(1,4,4,2))
stv(votes, nseats = 2, verbose = TRUE)

# Example with equal ranking and correction
votes &lt;- data.frame(C1=c(3,2,1,3), C2=c(1,1,2,0),
                    C3=c(4,3,3,1), C4=c(1,4,2,2))
stv(votes, nseats = 2, equal.ranking = TRUE)
# vote #3 was corrected by stv which used this data:
correct.ranking(votes, quiet = TRUE)

# Example of imputing preferences
# (third voter has a conflict of interest with candidate C2)
votes &lt;- data.frame(C1=c(3,2,1,3), C2=c(2,1,-1,0),
                    C3=c(4,3,3,1), C4=c(1,4,2,2))
res &lt;- stv(votes, nseats = 2, impute.missing = TRUE)
corrected.votes(res)
# imputed rank 2, as it is the median(c(2, 1, 4))
# where the last 4 was derived as the median of missing ranks 
# in vote four. The imputation can be also performed via
impute.ranking(votes)   

# Example of using reserved seats: 
# e.g. reserve two seats for students
stv(ims_election, nseats = 5, group.nseats = 2, 
    group.members = c("Declan", "Claire", "Oscar")) # students
    
# Example of removing candidates from original votes
stv(remove.candidate(ims_election, c("Jasper", "Tilmann")), nseats = 5)

# Example of accepting partially invalid ballots
res &lt;- stv(ims_election, invalid.partial = TRUE)

# There are now 24 invalid votes instead of 29, 
# because 5 were corrected (ranking before the first 
# gap/tie is valid, after that it is 0)
corrected.votes(res)
invalid.votes(res)
</code></pre>

<hr>
<h2 id='tworound.runoff'>
Two-Round Runoff Vote Count
</h2><span id='topic+tworound.runoff'></span><span id='topic+summary.vote.tworound.runoff'></span><span id='topic+view.vote.tworound.runoff'></span><span id='topic+print.summary.vote.tworound.runoff'></span><span id='topic+vote.tworound.runoff'></span><span id='topic+image.vote.tworound.runoff'></span>

<h3>Description</h3>

<p>Count votes using the two-round voting method with ranked ballots. If no candidate reaches the majority, the top two candidates go into a run-off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tworound.runoff(votes, fsep = '\t', seed = NULL, quiet = FALSE, ...)
    
## S3 method for class 'vote.tworound.runoff'
summary(object, ...)
    
## S3 method for class 'vote.tworound.runoff'
view(object, ...)
    
## S3 method for class 'vote.tworound.runoff'
image(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tworound.runoff_+3A_votes">votes</code></td>
<td>
<p>Matrix or data frame containing the votes. Rows correspond to the votes,  columns correspond to the candidates. If it is a character string it is interpreted as a file name from which the votes are to be read. See below for more details.</p>
</td></tr>
<tr><td><code id="tworound.runoff_+3A_fsep">fsep</code></td>
<td>
<p>If <code>votes</code> is a file name, this argument gives the column separator in the file.</p>
</td></tr>
<tr><td><code id="tworound.runoff_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed of the random number generator (RNG). Only used if there are ties either between candidates to enter the run-off, or between the two run-off contenders. If set to <code>NULL</code>, the RNG is not initialized.</p>
</td></tr>
<tr><td><code id="tworound.runoff_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code> no output is printed.</p>
</td></tr>
<tr><td><code id="tworound.runoff_+3A_object">object</code>, <code id="tworound.runoff_+3A_x">x</code></td>
<td>
<p>Object of class <code>vote.tworound.runoff</code>.</p>
</td></tr>
<tr><td><code id="tworound.runoff_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying functions. For the <code>image</code> function, see arguments for <code><a href="#topic+image.vote.stv">image.vote.stv</a></code>, especially <code>xpref</code>, <code>ypref</code>, <code>all.pref</code> and <code>proportion</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the number of first preferences is counted. If there is a candidate with more than 50%, that candidate gets elected. Otherwise, there is a runoff between the top two candidates.
</p>
<p>The input data <code>votes</code> is structured the same way as for the <code><a href="#topic+stv">stv</a></code> method: Row <code class="reqn">i</code> contains the preferences of voter <code class="reqn">i</code> numbered <code class="reqn">1, 2, \dots, r, 0,0,0,0</code>, in some order. Equal preferences are not allowed. The columns correspond to the candidates. The dimnames of the columns are the names of the candidates; if these are not supplied then the candidates are lettered A, B, C, .... If the dataset contains missing values (<code>NA</code>), they are replaced by zeros. 
</p>
<p>The <code>image</code> function visualizes the joint distribution of two preferences (if <code>all.pref=FALSE</code>) given by <code>xpref</code> and <code>ypref</code>, as well as the marginal distribution of all preferences (if <code>all.pref=TRUE</code>). The joint distribution can be shown as proportions (if <code>proportion=TRUE</code>) or raw vote counts (if <code>proportion=FALSE</code>).
</p>


<h3>Value</h3>

<p>Function <code>tworound.runoff</code> returns an object of class <code>vote.tworound.runoff</code> which is a list with the following objects:
</p>
<table>
<tr><td><code>elected</code></td>
<td>
<p>The elected candidate.</p>
</td></tr>
<tr><td><code>totals</code></td>
<td>
<p>Vector of total votes in the same order as candidates (columns) in the input data.</p>
</td></tr>
<tr><td><code>totals2r</code></td>
<td>
<p>Vector of total votes from the run-off (second round).</p>
</td></tr>
<tr><td><code>coin.toss.winner</code></td>
<td>
<p><code>TRUE</code> if the winner was sampled between candidates with the same score, otherwise <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>coin.toss.runoff</code></td>
<td>
<p><code>TRUE</code> if the run-off contenders were sampled from candidates with the same score. Otherwise it is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Input data (possibly corrected) with invalid votes removed.</p>
</td></tr>
<tr><td><code>invalid.votes</code></td>
<td>
<p>Matrix of invalid votes that were removed from the original dataset.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Salvatore Barbaro
</p>


<h3>References</h3>

<p>Sen A. (2017). Collective Choice and Social Welfare. Harvard University Press, Cambridge, Massachusetts, Chapter 10*3 (p. 243ff).
</p>
<p>https://en.wikipedia.org/wiki/Two-round_system
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ims_election)
trr &lt;- tworound.runoff(ims_election)
summary(trr)
</code></pre>

<hr>
<h2 id='vote-package'>
Election Vote Counting
</h2><span id='topic+vote-package'></span><span id='topic+vote'></span>

<h3>Description</h3>

<p>Counting election votes and determining election results by different methods, including the single transferable vote (ranked choice), approval, score, plurality, condorcet and two-round runoff methods. Details about the methods and package functions can be found in Raftery et al. (2021).
</p>


<h3>Details</h3>

<p>The main function of the package is called <code><a href="#topic+count.votes">count.votes</a></code>. If no specific method is passed, it decides on the basis of the available data which method is the most appropriate. Specific methods can also be invoked explicitly. 
The following voting methods are available:
</p>

<ul>
<li> <p><a href="#topic+stv">stv</a>: Single transferable vote (STV) where voters rank candidates in order. It is also known as ranked choice voting or instant runoff.
</p>
</li>
<li> <p><a href="#topic+score">score</a>: Range voting where each voter gives each candidate a 
score within a specific range.
</p>
</li>
<li> <p><a href="#topic+approval">approval</a>: Voters give each candidate one (approve) or zero (not approve).
</p>
</li>
<li> <p><a href="#topic+plurality">plurality</a>: Each voter chooses one candidate.
</p>
</li>
<li> <p><a href="#topic+condorcet">condorcet</a>: Voters rank candidates in order. The winner is determined in pairwise comparisons.
</p>
</li>
<li> <p><a href="#topic+tworound.runoff">tworound.runoff</a>: Two-round majority system with ranked ballots. If no candidate gets the majority, there is a run-off between the top two candidates. 
</p>
</li></ul>

<p>Output of these functions can be viewed using <code>summary</code> methods, or in a browser using <code>view</code> methods. The <code>summary</code> methods return a data frame which can be stored in a file, see Example below. Outputs of the <code><a href="#topic+stv">stv</a></code> method can be plotted in a graph. The joint and marginal distributions of ranked votes (for <code><a href="#topic+stv">stv</a></code>, <code><a href="#topic+condorcet">condorcet</a></code> and <code><a href="#topic+tworound.runoff">tworound.runoff</a></code>) can be visualized in an image plot. 
</p>
<p>Functions <code><a href="#topic+invalid.votes">invalid.votes</a></code>, <code><a href="#topic+valid.votes">valid.votes</a></code> and <code><a href="#topic+corrected.votes">corrected.votes</a></code> can be used to check the validity of ballots for the various methods, including corrections made within the methods. Function <code><a href="#topic+correct.ranking">correct.ranking</a></code> can be used to make ballot corrections to ranked data, including ballots with equal preferences.
</p>
<p>Example datasets are included. The <code><a href="#topic+ims_election">ims_election</a></code> dataset contains anonymized ballots from a past Council election of the Institute of Mathematical Statistics (IMS) which uses the STV method. Modifications of this dataset are available (<code><a href="#topic+ims_approval">ims_approval</a></code>, <code><a href="#topic+ims_score">ims_score</a></code>, <code><a href="#topic+ims_plurality">ims_plurality</a></code>) as examples of data required by the various methods. The <code><a href="#topic+food_election">food_election</a></code> dataset taken from Wikipedia can be used to test the STV method. Similarly, methods for ranked voting can be applied to the <code><a href="#topic+dublin_west">dublin_west</a></code> dataset which contains election ballots from the 2002 election to the Dublin West constituency in Ireland. 
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Bernard Silverman, Adrian Raftery
</p>
<p>Maintainer: Hana Sevcikova
</p>


<h3>References</h3>

<p>Raftery, A.E., Sevcikova, H. and Silverman, B.W. (2021). The vote Package: Single Transferable Vote and Other Electoral Systems in R. The R Journal, 13(2), 673-696. <a href="https://doi.org/10.32614/RJ-2021-086">doi:10.32614/RJ-2021-086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ims_election)
res &lt;- count.votes(ims_election, method = "stv", nseats = 5)
summary(res)

# View invalid votes
invalid.votes(res)

## Not run: 
# View results in a browser
view(res)

# Write election results into a csv file
s &lt;- summary(res)
write.csv(s, "IMSstvresults.csv")
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
