<!DOCTYPE html><html lang="en-GB"><head><title>Help for package sigugr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sigugr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregate_rasters'><p>Aggregate Rasters in a Folder</p></a></li>
<li><a href='#clip_layer'><p>Clip a Vector Layer with a Polygon</p></a></li>
<li><a href='#clip_multipoligon'><p>Safe Clip a Multipolygon Vector Layer</p></a></li>
<li><a href='#clip_raster'><p>Clip a raster based on a polygon</p></a></li>
<li><a href='#compose_raster'><p>Compose a Raster Layer from Multiple Files</p></a></li>
<li><a href='#copy_styles'><p>Copy Styles from a Source to a Destination</p></a></li>
<li><a href='#generate_bbox'><p>Generate a Bounding Box as an sf Object</p></a></li>
<li><a href='#geoserver'><p>GeoServer Connection Object ('geoserver' S3 Class)</p></a></li>
<li><a href='#get_layer_categories'><p>Get Layer Categories Based on Raster Values</p></a></li>
<li><a href='#publish_bands'><p>Publish Bands of a Raster to GeoServer</p></a></li>
<li><a href='#publish_layer'><p>Publish a Vector Layer to GeoServer</p></a></li>
<li><a href='#publish_layer_set'><p>Publish a Vector Layer Set to GeoServer</p></a></li>
<li><a href='#publish_raster'><p>Publish a Raster to GeoServer</p></a></li>
<li><a href='#register_datastore_postgis'><p>Register a PostGIS Database as a DataStore in GeoServer</p></a></li>
<li><a href='#store_bands'><p>Store Raster Bands to PostGIS</p></a></li>
<li><a href='#store_layers'><p>Write GeoPackage Layers with Geometry to PostGIS</p></a></li>
<li><a href='#store_raster'><p>Store Raster to PostGIS</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Workflow for Geographic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Streamlines geographic data transformation, storage and
    publication, simplifying data preparation and enhancing
    interoperability across formats and platforms.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://josesamos.github.io/sigugr/">https://josesamos.github.io/sigugr/</a>,
<a href="https://github.com/josesamos/sigugr">https://github.com/josesamos/sigugr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/josesamos/sigugr/issues">https://github.com/josesamos/sigugr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>clc, gdalUtilities, httr, jsonlite, rpostgis, sf, snakecase,
terra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>httptest2, knitr, mockery, purrr, rmarkdown, testthat (&ge;
3.0.0), withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-20 13:13:21 UTC; jsamos</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose Samos <a href="https://orcid.org/0000-0002-4457-3439"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Universidad de Granada [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose Samos &lt;jsamos@ugr.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-23 11:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggregate_rasters'>Aggregate Rasters in a Folder</h2><span id='topic+aggregate_rasters'></span>

<h3>Description</h3>

<p>Aggregates all raster files ('.tif' or '.jp2') in a specified folder by the
given factor and saves the resulting files in an output folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_rasters(dir, out_dir, factor = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate_rasters_+3A_dir">dir</code></td>
<td>
<p>A string specifying the input folder containing raster files.</p>
</td></tr>
<tr><td><code id="aggregate_rasters_+3A_out_dir">out_dir</code></td>
<td>
<p>A string specifying the output folder where the aggregated
rasters will be saved.</p>
</td></tr>
<tr><td><code id="aggregate_rasters_+3A_factor">factor</code></td>
<td>
<p>An integer specifying the aggregation factor (default is 2).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the output folder does not exist, it creates it.
</p>


<h3>Value</h3>

<p>A character vector with the paths to the processed raster files.
</p>


<h3>See Also</h3>

<p>Other transform raster functions: 
<code><a href="#topic+compose_raster">compose_raster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>temp_dir &lt;- tempdir()
input_dir &lt;- system.file("extdata", "mdt", package = "sigugr")

result_files &lt;- aggregate_rasters(input_dir, temp_dir, factor = 4)

</code></pre>

<hr>
<h2 id='clip_layer'>Clip a Vector Layer with a Polygon</h2><span id='topic+clip_layer'></span>

<h3>Description</h3>

<p>Clips a vector layer using a polygon layer. It handles CRS transformations automatically
if necessary, ensuring the output is in the same CRS as the input polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clip_layer(vector, polygon)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clip_layer_+3A_vector">vector</code></td>
<td>
<p>An 'sf' object representing the vector layer to be clipped.</p>
</td></tr>
<tr><td><code id="clip_layer_+3A_polygon">polygon</code></td>
<td>
<p>An 'sf' object representing the polygon layer used for clipping.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'sf' object containing the features of the input 'vector' that intersect with the 'polygon'.
The output will be in the CRS of the 'polygon', and it will retain all attributes of the input 'vector'.
</p>


<h3>See Also</h3>

<p>Other clip functions: 
<code><a href="#topic+clip_multipoligon">clip_multipoligon</a>()</code>,
<code><a href="#topic+clip_raster">clip_raster</a>()</code>,
<code><a href="#topic+generate_bbox">generate_bbox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gpkg_path &lt;- system.file("extdata", "clc.gpkg", package = "clc")

clc &lt;- sf::st_read(gpkg_path, layer = "clc", quiet = TRUE)
lanjaron &lt;- sf::st_read(gpkg_path, layer = "lanjaron", quiet = TRUE)

clc_clipped &lt;- clip_layer(clc, lanjaron)

</code></pre>

<hr>
<h2 id='clip_multipoligon'>Safe Clip a Multipolygon Vector Layer</h2><span id='topic+clip_multipoligon'></span>

<h3>Description</h3>

<p>Clips a 'MULTIPOLYGON' vector layer using a polygon layer, handling specific
issues that might arise with geometries encoded incorrectly or containing unknown WKB types.
It serves as a fallback when the 'clip_layer' function fails due to errors like
'ParseException: Unknown WKB type 12', which is associated with *MULTIPOLYGON* types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clip_multipoligon(vector, polygon)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clip_multipoligon_+3A_vector">vector</code></td>
<td>
<p>A 'sf' multipolygon vector layer to be clipped.</p>
</td></tr>
<tr><td><code id="clip_multipoligon_+3A_polygon">polygon</code></td>
<td>
<p>A 'sf' polygon layer used as the clipping geometry.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function ensures that the input layer is correctly encoded as 'MULTIPOLYGON' and
uses GDAL utilities for re-encoding if necessary. The output is projected to the CRS
of the clipping polygon.
</p>
<p>This solution is inspired by a discussion on handling WKB type errors in R:
&lt;https://gis.stackexchange.com/questions/389814/r-st-centroid-geos-error-unknown-wkb-type-12&gt;.
</p>


<h3>Value</h3>

<p>A 'sf' vector layer with the clipped geometries.
</p>


<h3>See Also</h3>

<p>Other clip functions: 
<code><a href="#topic+clip_layer">clip_layer</a>()</code>,
<code><a href="#topic+clip_raster">clip_raster</a>()</code>,
<code><a href="#topic+generate_bbox">generate_bbox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gpkg_path &lt;- system.file("extdata", "clc.gpkg", package = "clc")

clc &lt;- sf::st_read(gpkg_path, layer = "clc", quiet = TRUE)
lanjaron &lt;- sf::st_read(gpkg_path, layer = "lanjaron", quiet = TRUE)

clc_clipped &lt;- clip_multipoligon(clc, lanjaron)

</code></pre>

<hr>
<h2 id='clip_raster'>Clip a raster based on a polygon</h2><span id='topic+clip_raster'></span>

<h3>Description</h3>

<p>Clips a raster using a polygon, preserving the coordinate reference system (CRS)
of the raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clip_raster(raster, polygon, keep_crs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clip_raster_+3A_raster">raster</code></td>
<td>
<p>A 'terra' raster to be clipped.</p>
</td></tr>
<tr><td><code id="clip_raster_+3A_polygon">polygon</code></td>
<td>
<p>A 'sf' polygon layer used for clipping.</p>
</td></tr>
<tr><td><code id="clip_raster_+3A_keep_crs">keep_crs</code></td>
<td>
<p>Logical. If 'TRUE', retains the original CRS of the raster.
If 'FALSE', transforms the raster to the polygon CRS. Default is 'TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'terra' raster clipped to the extent of the polygon.
</p>


<h3>See Also</h3>

<p>Other clip functions: 
<code><a href="#topic+clip_layer">clip_layer</a>()</code>,
<code><a href="#topic+clip_multipoligon">clip_multipoligon</a>()</code>,
<code><a href="#topic+generate_bbox">generate_bbox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>source_gpkg &lt;- system.file("extdata", "sigugr.gpkg", package = "sigugr")
p &lt;-sf::st_read(source_gpkg, layer = 'lanjaron', quiet = TRUE)

source_tif &lt;- system.file("extdata", "sat.tif", package = "sigugr")
r &lt;- terra::rast(source_tif)

result &lt;- clip_raster(r, p)

</code></pre>

<hr>
<h2 id='compose_raster'>Compose a Raster Layer from Multiple Files</h2><span id='topic+compose_raster'></span>

<h3>Description</h3>

<p>Combines multiple raster files into a single virtual raster layer (VRT).
It accepts one or more folder names containing raster files and creates a
virtual raster file.
If no output file name is provided, a temporary file is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose_raster(dir, out_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compose_raster_+3A_dir">dir</code></td>
<td>
<p>A string or vector of strings representing folder names containing
raster files.</p>
</td></tr>
<tr><td><code id="compose_raster_+3A_out_file">out_file</code></td>
<td>
<p>A string specifying the output file name (without extension).
If 'NULL', a temporary file is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'SpatRaster' object from the 'terra' package.
</p>


<h3>See Also</h3>

<p>Other transform raster functions: 
<code><a href="#topic+aggregate_rasters">aggregate_rasters</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_dir &lt;- system.file("extdata", "mdt", package = "sigugr")

r &lt;- compose_raster(input_dir)

</code></pre>

<hr>
<h2 id='copy_styles'>Copy Styles from a Source to a Destination</h2><span id='topic+copy_styles'></span>

<h3>Description</h3>

<p>Copies layer styles from a source (GeoPackage or PostGIS database) to a destination
(GeoPackage or PostGIS database). The source and destination can be specified flexibly,
and the function supports copying styles to multiple layers in the destination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_styles(
  from,
  from_layer = NULL,
  to,
  database = NULL,
  schema = "public",
  to_layers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copy_styles_+3A_from">from</code></td>
<td>
<p>A data source for the input style. This can be:
- A string representing the path to a GeoPackage file.
- A 'DBI' database connection object to a PostGIS database, created using [RPostgres::dbConnect()].</p>
</td></tr>
<tr><td><code id="copy_styles_+3A_from_layer">from_layer</code></td>
<td>
<p>Character (optional). Name of the layer in the source to copy the style from.
If not provided, the function will use the first layer in the source with a defined style.</p>
</td></tr>
<tr><td><code id="copy_styles_+3A_to">to</code></td>
<td>
<p>A data destination for the output styles. This can be:
- A string representing the path to a GeoPackage file.
- A 'DBI' database connection object to a PostGIS database, created using [RPostgres::dbConnect()].</p>
</td></tr>
<tr><td><code id="copy_styles_+3A_database">database</code></td>
<td>
<p>Character (optional). Name of the destination PostGIS database
(required if the destination is a PostGIS connection object).</p>
</td></tr>
<tr><td><code id="copy_styles_+3A_schema">schema</code></td>
<td>
<p>Character. Schema in the destination PostGIS database where the styles will be applied.
Default is &quot;public&quot;.</p>
</td></tr>
<tr><td><code id="copy_styles_+3A_to_layers">to_layers</code></td>
<td>
<p>Character vector (optional). Names of the layers in the destination where the style
will be applied. If not provided, the style will be applied to all layers in the destination.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated 'layer_styles' table, returned invisibly.
</p>


<h3>See Also</h3>

<p>Other style functions: 
<code><a href="#topic+get_layer_categories">get_layer_categories</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ex1:
source_gpkg &lt;- system.file("extdata", "clc.gpkg", package = "clc")
layer_data &lt;- sf::st_read(source_gpkg, layer = "clc", quiet = TRUE)

dest_gpkg &lt;- tempfile(fileext = ".gpkg")
sf::st_write(layer_data, dest_gpkg, layer = "clc", quiet = TRUE)

copy_styles(from = source_gpkg, to = dest_gpkg)

## Not run: 
# Ex2:
source_gpkg &lt;- system.file("extdata", "clc.gpkg", package = "clc")
conn &lt;- DBI::dbConnect(
  RPostgres::Postgres(),
  dbname = "mydb",
  host = "localhost",
  user = "user",
  password = "password"
)

copy_styles(
  from = source_gpkg,
  to = conn,
  database = "mydb",
  schema = "public",
  to_layers = c("layer1", "layer2"),
)

DBI::dbDisconnect(conn)

## End(Not run)
</code></pre>

<hr>
<h2 id='generate_bbox'>Generate a Bounding Box as an sf Object</h2><span id='topic+generate_bbox'></span>

<h3>Description</h3>

<p>Takes an 'sf' object or a 'terra::SpatRaster' as input and returns a new 'sf' object
representing the bounding box (minimum bounding rectangle) of the input layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_bbox(layer)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_bbox_+3A_layer">layer</code></td>
<td>
<p>An 'sf' object or a 'terra::SpatRaster' object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'sf' object representing the bounding box of the input layer.
</p>


<h3>See Also</h3>

<p>Other clip functions: 
<code><a href="#topic+clip_layer">clip_layer</a>()</code>,
<code><a href="#topic+clip_multipoligon">clip_multipoligon</a>()</code>,
<code><a href="#topic+clip_raster">clip_raster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with a vector layer
source_gpkg &lt;- system.file("extdata/sigugr.gpkg", package = "sigugr")
lanjaron &lt;- sf::st_read(source_gpkg, layer = "lanjaron", quiet = TRUE)
bbox_vector &lt;- generate_bbox(lanjaron)

# Example with a raster layer
raster_file &lt;- system.file("extdata/sat.tif", package = "sigugr")
raster &lt;- terra::rast(raster_file)
bbox_raster &lt;- generate_bbox(raster)

</code></pre>

<hr>
<h2 id='geoserver'>GeoServer Connection Object ('geoserver' S3 Class)</h2><span id='topic+geoserver'></span>

<h3>Description</h3>

<p>This S3 class represents a connection to a GeoServer instance.
It stores the connection details, including the base URL, user credentials,
and the default workspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoserver(url, user, password, workspace)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geoserver_+3A_url">url</code></td>
<td>
<p>A character string specifying the base URL of the GeoServer instance
(e.g., '&quot;http://localhost:8080/geoserver&quot;').</p>
</td></tr>
<tr><td><code id="geoserver_+3A_user">user</code></td>
<td>
<p>A character string representing the GeoServer username with the
required permissions.</p>
</td></tr>
<tr><td><code id="geoserver_+3A_password">password</code></td>
<td>
<p>A character string representing the password for the specified user.</p>
</td></tr>
<tr><td><code id="geoserver_+3A_workspace">workspace</code></td>
<td>
<p>A character string specifying the default workspace to use in
GeoServer operations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'geoserver' or NULL if an error occurred.
</p>


<h3>See Also</h3>

<p>Other publish to GeoServer: 
<code><a href="#topic+publish_bands">publish_bands</a>()</code>,
<code><a href="#topic+publish_layer">publish_layer</a>()</code>,
<code><a href="#topic+publish_layer_set">publish_layer_set</a>()</code>,
<code><a href="#topic+publish_raster">publish_raster</a>()</code>,
<code><a href="#topic+register_datastore_postgis">register_datastore_postgis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gso &lt;- geoserver(
  url = "http://localhost:8080/geoserver",
  user = "admin",
  password = "geoserver",
  workspace = "sigugr_test"
)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_layer_categories'>Get Layer Categories Based on Raster Values</h2><span id='topic+get_layer_categories'></span>

<h3>Description</h3>

<p>Extracts the categories (IDs, descriptions, and colors) from the first style
definition stored in a GeoPackage or PostGIS database. The extracted categories
are filtered to include only those present in the raster values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_layer_categories(from, r_clc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_layer_categories_+3A_from">from</code></td>
<td>
<p>A data origin. This can be:
- A string representing the path to a GeoPackage file.
- A 'DBI' database connection object to a PostGIS database, created using [RPostgres::dbConnect()].</p>
</td></tr>
<tr><td><code id="get_layer_categories_+3A_r_clc">r_clc</code></td>
<td>
<p>A 'terra' raster object containing the raster values to filter the categories. If NULL,
returns all categories.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function retrieves the style definitions from the 'layer_styles' table in
the provided GeoPackage or PostGIS database. It filters the categories to include
only those whose IDs match the unique values present in the raster.
</p>
<p>It is useful for associating raster values with their corresponding descriptions
and colors, typically for visualization or analysis tasks.
</p>


<h3>Value</h3>

<p>A data frame containing the filtered categories with the following columns:
- 'id': The category ID (integer).
- 'description': The description of the category (character).
- 'color': The color associated with the category in hexadecimal format (character).
</p>


<h3>See Also</h3>

<p>Other style functions: 
<code><a href="#topic+copy_styles">copy_styles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gpkg_path &lt;- system.file("extdata", "clc.gpkg", package = "clc")

categories &lt;- get_layer_categories(from = gpkg_path)
</code></pre>

<hr>
<h2 id='publish_bands'>Publish Bands of a Raster to GeoServer</h2><span id='topic+publish_bands'></span><span id='topic+publish_bands.geoserver'></span>

<h3>Description</h3>

<p>Publishes bands of a multi-band GeoTIFF raster file as separate coverages
in a specified workspace on a GeoServer instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>publish_bands(gso, raster, prefix, postfix, bands)

## S3 method for class 'geoserver'
publish_bands(gso, raster, prefix = NULL, postfix = NULL, bands = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="publish_bands_+3A_gso">gso</code></td>
<td>
<p>An object of class 'geoserver' containing GeoServer connection details.</p>
</td></tr>
<tr><td><code id="publish_bands_+3A_raster">raster</code></td>
<td>
<p>A character string specifying the file path to the GeoTIFF raster file
to be uploaded.</p>
</td></tr>
<tr><td><code id="publish_bands_+3A_prefix">prefix</code></td>
<td>
<p>A string to prepend to each layer name. Default is 'NULL'.</p>
</td></tr>
<tr><td><code id="publish_bands_+3A_postfix">postfix</code></td>
<td>
<p>A string to append to each layer name. Default is 'NULL'.</p>
</td></tr>
<tr><td><code id="publish_bands_+3A_bands">bands</code></td>
<td>
<p>A named integer vector, index of the bands to publish with layer names.
If it is 'NULL', which is the default value, all bands are published using the band
name as the layer name. If unnamed indices are provided, the band name is also used
as the layer name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer:
</p>

<ul>
<li> <p><code>0</code> if the operation was successful or if the layer already exists.
</p>
</li>
<li> <p><code>1</code> if an error occurred.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other publish to GeoServer: 
<code><a href="#topic+geoserver">geoserver</a>()</code>,
<code><a href="#topic+publish_layer">publish_layer</a>()</code>,
<code><a href="#topic+publish_layer_set">publish_layer_set</a>()</code>,
<code><a href="#topic+publish_raster">publish_raster</a>()</code>,
<code><a href="#topic+register_datastore_postgis">register_datastore_postgis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gso &lt;- geoserver(
  url = "http://localhost:8080/geoserver",
  user = "admin",
  password = "geoserver",
  workspace = "sigugr_test"
)

source_tif &lt;- system.file("extdata/sat.tif", package = "sigugr")

gso |&gt;
  publish_bands(source_tif)

## End(Not run)
</code></pre>

<hr>
<h2 id='publish_layer'>Publish a Vector Layer to GeoServer</h2><span id='topic+publish_layer'></span><span id='topic+publish_layer.geoserver'></span>

<h3>Description</h3>

<p>Publishes a vector layer to GeoServer. The layer source must have previously
been defined as a GeoSever datastore.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>publish_layer(gso, layer, title)

## S3 method for class 'geoserver'
publish_layer(gso, layer, title = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="publish_layer_+3A_gso">gso</code></td>
<td>
<p>An object of class 'geoserver' containing GeoServer connection details.</p>
</td></tr>
<tr><td><code id="publish_layer_+3A_layer">layer</code></td>
<td>
<p>A string, the name of the layer to publish.</p>
</td></tr>
<tr><td><code id="publish_layer_+3A_title">title</code></td>
<td>
<p>A string, an optional title for the layer. Defaults to the layer
name if not provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints an appropriate message indicating success or failure.
</p>


<h3>Value</h3>

<p>An integer:
</p>

<ul>
<li> <p><code>0</code> if the operation was successful or if the layer already exists.
</p>
</li>
<li> <p><code>1</code> if an error occurred.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other publish to GeoServer: 
<code><a href="#topic+geoserver">geoserver</a>()</code>,
<code><a href="#topic+publish_bands">publish_bands</a>()</code>,
<code><a href="#topic+publish_layer_set">publish_layer_set</a>()</code>,
<code><a href="#topic+publish_raster">publish_raster</a>()</code>,
<code><a href="#topic+register_datastore_postgis">register_datastore_postgis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gso &lt;- geoserver(
  url = "http://localhost:8080/geoserver",
  user = "admin",
  password = "geoserver",
  workspace = "sigugr_test"
)

gso &lt;- gso |&gt;
  register_datastore_postgis(
    "sigugr-postgis",
    db_name = 'sigugr_example',
    host = 'localhost',
    port = 5432,
    db_user = 'user',
    db_password = 'password',
    schema = "public"
  )

gso |&gt;
  publish_layer(layer = 'sigugr_layer')

## End(Not run)
</code></pre>

<hr>
<h2 id='publish_layer_set'>Publish a Vector Layer Set to GeoServer</h2><span id='topic+publish_layer_set'></span><span id='topic+publish_layer_set.geoserver'></span>

<h3>Description</h3>

<p>Publishes a vector layer set to GeoServer. The layer source must have previously
been defined as a GeoSever datastore.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>publish_layer_set(gso, source, layers)

## S3 method for class 'geoserver'
publish_layer_set(gso, source, layers = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="publish_layer_set_+3A_gso">gso</code></td>
<td>
<p>An object of class 'geoserver' containing GeoServer connection details.</p>
</td></tr>
<tr><td><code id="publish_layer_set_+3A_source">source</code></td>
<td>
<p>A valid connection to a PostGIS database ('RPostgres' connection object).</p>
</td></tr>
<tr><td><code id="publish_layer_set_+3A_layers">layers</code></td>
<td>
<p>An optional character vector of layer names to check and publish.
If 'NULL' (default), all vector geometry layers in the source will be published.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iterates over a set of layers in a source database, checking whether each layer
contains vector geometry. If the layer meets the criteria, it is published. If the
'layers' parameter is 'NULL', the function will publish all layers with vector
geometry in the source.
</p>
<p>Prints an appropriate messages indicating success or failure.
</p>


<h3>Value</h3>

<p>An integer:
</p>

<ul>
<li> <p><code>0</code> if the operation was successful for all layers.
</p>
</li>
<li> <p><code>1</code> if an error occurred.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other publish to GeoServer: 
<code><a href="#topic+geoserver">geoserver</a>()</code>,
<code><a href="#topic+publish_bands">publish_bands</a>()</code>,
<code><a href="#topic+publish_layer">publish_layer</a>()</code>,
<code><a href="#topic+publish_raster">publish_raster</a>()</code>,
<code><a href="#topic+register_datastore_postgis">register_datastore_postgis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gso &lt;- geoserver(
  url = "http://localhost:8080/geoserver",
  user = "admin",
  password = "geoserver",
  workspace = "sigugr_test"
)

gso &lt;- gso |&gt;
  register_datastore_postgis(
    "sigugr-postgis",
    db_name = 'sigugr_example',
    host = 'localhost',
    port = 5432,
    db_user = 'user',
    db_password = 'password',
    schema = "public"
  )

source &lt;- RPostgres::dbConnect(
  RPostgres::Postgres(),
  dbname = 'mydb',
  host = 'localhost',
  port = '5432',
  user = 'user',
  password = 'password'
)

gso |&gt;
  publish_layer_set(source)

## End(Not run)
</code></pre>

<hr>
<h2 id='publish_raster'>Publish a Raster to GeoServer</h2><span id='topic+publish_raster'></span><span id='topic+publish_raster.geoserver'></span>

<h3>Description</h3>

<p>Publishes a GeoTIFF raster file to a workspace and data store on a GeoServer instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>publish_raster(gso, raster, layer)

## S3 method for class 'geoserver'
publish_raster(gso, raster, layer = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="publish_raster_+3A_gso">gso</code></td>
<td>
<p>An object of class 'geoserver' containing GeoServer connection details.</p>
</td></tr>
<tr><td><code id="publish_raster_+3A_raster">raster</code></td>
<td>
<p>A character string specifying the file path to the GeoTIFF raster file
to be uploaded.</p>
</td></tr>
<tr><td><code id="publish_raster_+3A_layer">layer</code></td>
<td>
<p>A string, the name of the layer to publish. If it is 'NULL', which is
the default value, the layer name is derived from the filename.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer:
</p>

<ul>
<li> <p><code>0</code> if the operation was successful or if the layer already exists.
</p>
</li>
<li> <p><code>1</code> if an error occurred.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other publish to GeoServer: 
<code><a href="#topic+geoserver">geoserver</a>()</code>,
<code><a href="#topic+publish_bands">publish_bands</a>()</code>,
<code><a href="#topic+publish_layer">publish_layer</a>()</code>,
<code><a href="#topic+publish_layer_set">publish_layer_set</a>()</code>,
<code><a href="#topic+register_datastore_postgis">register_datastore_postgis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gso &lt;- geoserver(
  url = "http://localhost:8080/geoserver",
  user = "admin",
  password = "geoserver",
  workspace = "sigugr_test"
)

source_tif &lt;- system.file("extdata/sat.tif", package = "sigugr")

gso |&gt;
  publish_raster(source_tif, "sat-tiff")

## End(Not run)
</code></pre>

<hr>
<h2 id='register_datastore_postgis'>Register a PostGIS Database as a DataStore in GeoServer</h2><span id='topic+register_datastore_postgis'></span><span id='topic+register_datastore_postgis.geoserver'></span>

<h3>Description</h3>

<p>Registers a PostGIS database as a 'datastore' in a specified GeoServer workspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_datastore_postgis(
  gso,
  datastore,
  db_name,
  host,
  port,
  db_user,
  db_password,
  schema
)

## S3 method for class 'geoserver'
register_datastore_postgis(
  gso,
  datastore,
  db_name,
  host,
  port = 5432,
  db_user,
  db_password,
  schema = "public"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="register_datastore_postgis_+3A_gso">gso</code></td>
<td>
<p>An object of class 'geoserver' containing GeoServer connection details.</p>
</td></tr>
<tr><td><code id="register_datastore_postgis_+3A_datastore">datastore</code></td>
<td>
<p>A character string. The name of the datastore to be created.</p>
</td></tr>
<tr><td><code id="register_datastore_postgis_+3A_db_name">db_name</code></td>
<td>
<p>A character string. The name of the PostGIS database.</p>
</td></tr>
<tr><td><code id="register_datastore_postgis_+3A_host">host</code></td>
<td>
<p>A character string. The database host.</p>
</td></tr>
<tr><td><code id="register_datastore_postgis_+3A_port">port</code></td>
<td>
<p>An integer. The database port (default: 5432).</p>
</td></tr>
<tr><td><code id="register_datastore_postgis_+3A_db_user">db_user</code></td>
<td>
<p>A character string. The database username.</p>
</td></tr>
<tr><td><code id="register_datastore_postgis_+3A_db_password">db_password</code></td>
<td>
<p>A character string. The database password.</p>
</td></tr>
<tr><td><code id="register_datastore_postgis_+3A_schema">schema</code></td>
<td>
<p>A character string. The database schema (default: &quot;public&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the 'datastore' has already been registered previously, there is no need to specify the
database connection. For subsequent operations, that 'datastore' will be used.
</p>
<p>In any case, prints an appropriate message.
</p>


<h3>Value</h3>

<p>An object of class 'geoserver' or NULL if an error occurred.
</p>


<h3>See Also</h3>

<p>Other publish to GeoServer: 
<code><a href="#topic+geoserver">geoserver</a>()</code>,
<code><a href="#topic+publish_bands">publish_bands</a>()</code>,
<code><a href="#topic+publish_layer">publish_layer</a>()</code>,
<code><a href="#topic+publish_layer_set">publish_layer_set</a>()</code>,
<code><a href="#topic+publish_raster">publish_raster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gso &lt;- geoserver(
  url = "http://localhost:8080/geoserver",
  user = "admin",
  password = "geoserver",
  workspace = "sigugr_test"
)

gso &lt;- gso |&gt;
  register_datastore_postgis(
    "sigugr-postgis",
    db_name = 'sigugr_example',
    host = 'localhost',
    port = 5432,
    db_user = 'user',
    db_password = 'password',
    schema = "public"
  )

## End(Not run)

</code></pre>

<hr>
<h2 id='store_bands'>Store Raster Bands to PostGIS</h2><span id='topic+store_bands'></span>

<h3>Description</h3>

<p>Stores each band of a raster to a specified schema in a PostGIS database. Each
band is written as a separate table in the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store_bands(
  raster,
  conn,
  schema = "public",
  prefix = NULL,
  postfix = NULL,
  bands = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="store_bands_+3A_raster">raster</code></td>
<td>
<p>A character string specifying the file path to the GeoTIFF file
containing the raster bands to be stored.</p>
</td></tr>
<tr><td><code id="store_bands_+3A_conn">conn</code></td>
<td>
<p>A database connection object to a PostGIS database (e.g., from 'RPostgres::dbConnect').</p>
</td></tr>
<tr><td><code id="store_bands_+3A_schema">schema</code></td>
<td>
<p>A string specifying the schema in the PostGIS database where
the raster layers will be stored. Default is '&quot;public&quot;'.</p>
</td></tr>
<tr><td><code id="store_bands_+3A_prefix">prefix</code></td>
<td>
<p>A string to prepend to each layer name. Default is 'NULL'.</p>
</td></tr>
<tr><td><code id="store_bands_+3A_postfix">postfix</code></td>
<td>
<p>A string to append to each layer name. Default is 'NULL'.</p>
</td></tr>
<tr><td><code id="store_bands_+3A_bands">bands</code></td>
<td>
<p>A named integer vector, index of the bands to store with layer names.
If it is 'NULL', which is the default value, all bands are stored using the band
name as the layer name. If unnamed indices are provided, the band name is also used
as the layer name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transforms the table name according to the Snake Case convention.
</p>


<h3>Value</h3>

<p>Invisibly returns a character vector of the names of the tables written to PostGIS.
</p>


<h3>See Also</h3>

<p>Other write to PostGIS: 
<code><a href="#topic+store_layers">store_layers</a>()</code>,
<code><a href="#topic+store_raster">store_raster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
conn &lt;- DBI::dbConnect(
  RPostgres::Postgres(),
  dbname = "mydb",
  host = "localhost",
  user = "user",
  password = "password"
)

sr &lt;- terra::rast(nrows = 10, ncols = 10, nlyrs = 3, vals = runif(300))
sr_file &lt;- tempfile(fileext = ".tif")
terra::writeRaster(sr, sr_file, filetype = "GTiff", overwrite = TRUE)

tables &lt;- store_bands(sr_file, conn, schema = "geodata", prefix = "example_", postfix = "_raster")

DBI::dbDisconnect(conn)

## End(Not run)

</code></pre>

<hr>
<h2 id='store_layers'>Write GeoPackage Layers with Geometry to PostGIS</h2><span id='topic+store_layers'></span>

<h3>Description</h3>

<p>Transfers vector layers with valid geometries from a GeoPackage file
to a specified PostGIS database schema. Optionally allows setting a custom
geometry column name, adding prefixes or postfixes to the table names, and
renaming the layer fields to follow the Snake Case convention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store_layers(
  gpkg,
  conn,
  schema = "public",
  prefix = NULL,
  postfix = NULL,
  layers = NULL,
  geom_colum = "geom",
  snake_case_fields = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="store_layers_+3A_gpkg">gpkg</code></td>
<td>
<p>A string, the path to the GeoPackage file.</p>
</td></tr>
<tr><td><code id="store_layers_+3A_conn">conn</code></td>
<td>
<p>A PostGIS database connection object created with [RPostgres::dbConnect()].</p>
</td></tr>
<tr><td><code id="store_layers_+3A_schema">schema</code></td>
<td>
<p>A string, the schema in PostGIS where layers will be stored. Default is '&quot;public&quot;'.</p>
</td></tr>
<tr><td><code id="store_layers_+3A_prefix">prefix</code></td>
<td>
<p>A string, an optional prefix to add to the table names in PostGIS. Default is 'NULL'.</p>
</td></tr>
<tr><td><code id="store_layers_+3A_postfix">postfix</code></td>
<td>
<p>A string, an optional postfix to add to the table names in PostGIS. Default is 'NULL'.</p>
</td></tr>
<tr><td><code id="store_layers_+3A_layers">layers</code></td>
<td>
<p>A string vector, the name of the layers to transfer. If NULL,
all vector layers are transferred.</p>
</td></tr>
<tr><td><code id="store_layers_+3A_geom_colum">geom_colum</code></td>
<td>
<p>A string, the name of the geometry column to set. Default is '&quot;geom&quot;'.</p>
</td></tr>
<tr><td><code id="store_layers_+3A_snake_case_fields">snake_case_fields</code></td>
<td>
<p>A logical, whether to convert field names to Snake Case. Default is 'TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a character vector of the names of the tables written to PostGIS.
</p>


<h3>See Also</h3>

<p>Other write to PostGIS: 
<code><a href="#topic+store_bands">store_bands</a>()</code>,
<code><a href="#topic+store_raster">store_raster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
source_gpkg &lt;- system.file("extdata", "sigugr.gpkg", package = "sigugr")

conn &lt;- DBI::dbConnect(
  RPostgres::Postgres(),
  dbname = "mydb",
  host = "localhost",
  user = "user",
  password = "password"
)

store_layers(
  source_gpkg, conn, prefix = "pre_", postfix = "_post"
)

DBI::dbDisconnect(conn)

## End(Not run)

</code></pre>

<hr>
<h2 id='store_raster'>Store Raster to PostGIS</h2><span id='topic+store_raster'></span>

<h3>Description</h3>

<p>Stores all bands of a raster to a specified schema in a PostGIS database.
All bands are written in the same table in the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store_raster(raster, conn, schema = "public", table_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="store_raster_+3A_raster">raster</code></td>
<td>
<p>A character string specifying the file path to the GeoTIFF raster file
to be stored.</p>
</td></tr>
<tr><td><code id="store_raster_+3A_conn">conn</code></td>
<td>
<p>A database connection object to a PostGIS database (e.g., from 'RPostgres::dbConnect').</p>
</td></tr>
<tr><td><code id="store_raster_+3A_schema">schema</code></td>
<td>
<p>A string specifying the schema in the PostGIS database where
the raster layers will be stored. Default is '&quot;public&quot;'.</p>
</td></tr>
<tr><td><code id="store_raster_+3A_table_name">table_name</code></td>
<td>
<p>A string, table name. If it is 'NULL', which is the default value,
the layer name is derived from the filename.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transforms the table name according to the Snake Case convention.
</p>


<h3>Value</h3>

<p>Invisibly returns a character vector of the names of the tables written to PostGIS.
</p>


<h3>See Also</h3>

<p>Other write to PostGIS: 
<code><a href="#topic+store_bands">store_bands</a>()</code>,
<code><a href="#topic+store_layers">store_layers</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
source_tif &lt;- system.file("extdata", "mdt.tif", package = "clc")

conn &lt;- DBI::dbConnect(
  RPostgres::Postgres(),
  dbname = "mydb",
  host = "localhost",
  user = "user",
  password = "password"
)

tables &lt;- store_raster(source_tif, conn, table_name = "mdt")

DBI::dbDisconnect(conn)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
