<!DOCTYPE html><html><head><title>Help for package multiness</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multiness}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agri_trade'><p>Agricultural trade multiplex network</p></a></li>
<li><a href='#ase'><p>Adjacency Spectral Embedding (ASE)</p></a></li>
<li><a href='#expit'><p>Inverse logistic link function</p></a></li>
<li><a href='#logit'><p>Logistic link function</p></a></li>
<li><a href='#multiness_fit'><p>Fit the MultiNeSS model</p></a></li>
<li><a href='#multiness_sim'><p>Simulate from the MultiNeSS model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>MULTIplex NEtworks with Shared Structure</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Model fitting and simulation for Gaussian and logistic inner 
    product MultiNeSS models for multiplex networks. The package implements 
    a convex fitting algorithm with fully adaptive parameter tuning, 
    including options for edge cross-validation. For more details see 
    MacDonald et al. (2020).  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet (&ge; 4.0.2), Matrix (&ge; 1.1.0), RSpectra (&ge; 0.16.0),</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/peterwmacd/multiness/">https://github.com/peterwmacd/multiness/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/peterwmacd/multiness/issues/">https://github.com/peterwmacd/multiness/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-21 22:20:55 UTC; pwmacdon</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter W. MacDonald
    <a href="https://orcid.org/0000-0001-7024-7242"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter W. MacDonald &lt;pwmacdon@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-25 01:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='agri_trade'>Agricultural trade multiplex network</h2><span id='topic+agri_trade'></span>

<h3>Description</h3>

<p>An undirected multiplex network containing trade volumes for 13
highly traded agricultural products for the year 2010, collected by
the Food and Agriculture Organization of the United Nations (FAO).
The original data set can be downloaded from Manlio DeDomenico's website.
Array entries are in units of tonnes (metric tons) of bilateral trade
of a given agricultural product. For further documentation and
product definitions see
<a href="https://www.fao.org/faostat/en/#definitions/">https://www.fao.org/faostat/en/#definitions/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(agri_trade)
</code></pre>


<h3>Format</h3>

<p>An array of dimension <code class="reqn">145 \times 145 \times 13</code>.
</p>


<h3>Source</h3>

<p><a href="https://manliodedomenico.com/">https://manliodedomenico.com/</a>; <a href="https://www.fao.org/faostat/en/#data/">https://www.fao.org/faostat/en/#data/</a>
</p>


<h3>References</h3>

<p>DeDomenico et al. (2015) <a href="https://www.nature.com/articles/ncomms7864/">Nature Communications</a>
</p>

<hr>
<h2 id='ase'>Adjacency Spectral Embedding (ASE)</h2><span id='topic+ase'></span>

<h3>Description</h3>

<p><code>ase</code> calculates the <code class="reqn">d</code>-dimensional adjacency spectral embedding of a symmetric
<code class="reqn">n \times n</code> matrix <code class="reqn">M</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ase(M,d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ase_+3A_m">M</code></td>
<td>
<p>A symmetric matrix.</p>
</td></tr>
<tr><td><code id="ase_+3A_d">d</code></td>
<td>
<p>A non-negative integer embedding dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">n \times d</code> matrix <code class="reqn">X</code>, defined as <code class="reqn">U |S|^{1/2}</code>
where <code class="reqn">S</code> is a diagonal matrix of the <code class="reqn">d</code> leading (in absolute value)
eigenvalues of <code class="reqn">M</code>, and <code class="reqn">U</code> is a matrix of the corresponding
eigenvectors.
</p>
<p><code class="reqn">X</code> has an additional attribute <code>"signs"</code> which gives the sign of
the eigenvalue corresponding to each column.
</p>
<p>If <code class="reqn">d=0</code>, <code>ase</code> returns an <code class="reqn">n \times 1</code>
matrix of zeros.
</p>

<hr>
<h2 id='expit'>Inverse logistic link function</h2><span id='topic+expit'></span>

<h3>Description</h3>

<p><code>expit</code> applies the inverse logistic link function <code class="reqn">f(x) = e^x / (1+e^x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expit_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>

<hr>
<h2 id='logit'>Logistic link function</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p><code>logit</code> applies the logistic link function <code class="reqn">f(x) = log(x / (1-x))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x,tol=1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>A numeric vector with values in the interval [0,1].</p>
</td></tr>
<tr><td><code id="logit_+3A_tol">tol</code></td>
<td>
<p>A positive scalar which bounds the entries of x away from 0 and 1
for numerical stability.
Defaults to <code>tol=1e-6</code></p>
</td></tr>
</table>

<hr>
<h2 id='multiness_fit'>Fit the MultiNeSS model</h2><span id='topic+multiness_fit'></span>

<h3>Description</h3>

<p><code>multiness_fit</code> fits the Gaussian or logistic MultiNeSS model
with various options for parameter tuning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiness_fit(A,model,self_loops,refit,tuning,tuning_opts,optim_opts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiness_fit_+3A_a">A</code></td>
<td>
<p>An <code class="reqn">n \times n \times m</code> array containing edge entries for
an undirected multiplex network on <code class="reqn">n</code> nodes and <code class="reqn">m</code> layers.</p>
</td></tr>
<tr><td><code id="multiness_fit_+3A_model">model</code></td>
<td>
<p>A string which provides choice of model,
either <code>'gaussian'</code> or <code>'logistic'</code>. Defaults to <code>'gaussian'</code>.</p>
</td></tr>
<tr><td><code id="multiness_fit_+3A_self_loops">self_loops</code></td>
<td>
<p>A Boolean, if <code>FALSE</code>, all diagonal entries are ignored in
optimization. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="multiness_fit_+3A_refit">refit</code></td>
<td>
<p>A Boolean, if <code>TRUE</code>, a refitting step is performed to
debias the eigenvalues of the estimates. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="multiness_fit_+3A_tuning">tuning</code></td>
<td>
<p>A string which provides the tuning method, valid options are
<code>'fixed'</code>, <code>'adaptive'</code>, or <code>'cv'</code>. Defaults to <code>'adaptive'</code>.</p>
</td></tr>
<tr><td><code id="multiness_fit_+3A_tuning_opts">tuning_opts</code></td>
<td>
<p>A list, containing additional optional arguments controlling
parameter tuning. The arguments used depends on the choice of tuning method.
If <code>tuning='fixed'</code>, <code>multiness_fit</code> will utilize the following
arguments:
</p>

<dl>
<dt>lambda</dt><dd><p>A positive scalar,
the <code class="reqn">\lambda</code> parameter in the nuclear norm penalty, see Details.
Defaults to <code>2.309 * sqrt(n*m)</code>.</p>
</dd>
<dt>alpha</dt><dd><p>A positive scalar or numeric vector of length <code>m</code>, the parameters <code class="reqn">\alpha_k</code> in the
nuclear norm penalty, see Details. If a scalar is provided all <code class="reqn">\alpha_k</code> parameters are set to that
value. Defaults to <code>1/sqrt(m)</code></p>
</dd>
</dl>

<p>If <code>tuning='adaptive'</code>, <code>multiness_fit</code> will utilize the following
arguments:
</p>

<dl>
<dt>layer_wise</dt><dd><p>A Boolean, if <code>TRUE</code>, the entry-wise variance
is estimated individually for each layer. Otherwise the estimates are
pooled. Defaults to <code>TRUE</code>.</p>
</dd>
<dt>penalty_const</dt><dd><p>A positive scalar <code class="reqn">C</code> which scales the
penalty parameters (see Details).
Defaults to <code>2.309</code>.</p>
</dd>
<dt>penalty_const_lambda</dt><dd><p>A positive scalar <code class="reqn">c</code> which scales only the <code class="reqn">\lambda</code>
penalty parameter (see Details).
Defaults to <code>1</code>.</p>
</dd>
</dl>

<p>If <code>tuning='cv'</code>, <code>multiness_fit</code> will utilize the following
arguments:
</p>

<dl>
<dt>layer_wise</dt><dd><p>A Boolean, if <code>TRUE</code>, the entry-wise variance
is estimated individually for each layer. Otherwise the estimates are
pooled. Defaults to <code>TRUE</code>.</p>
</dd>
<dt>N_cv</dt><dd><p>A positive integer, the number of repetitions of edge
cross-validation performed for each parameter setting. Defaults to <code>3</code>.</p>
</dd>
<dt>p_cv</dt><dd><p>A positive scalar in the interval (0,1), the proportion
of edge entries held out in edge cross-validation. Defaults to <code class="reqn">0.1</code>.</p>
</dd>
<dt>penalty_const_lambda</dt><dd><p>A positive scalar <code class="reqn">c</code> which scales only the <code class="reqn">\lambda</code>
penalty parameter (see Details).
Defaults to <code>1</code>.</p>
</dd>
<dt>penalty_const_vec</dt><dd><p>A numeric vector with positive entries, the candidate
values of constant <code class="reqn">C</code> to scale the penalty parameters (see Details).
An optimal constant is chosen by edge cross-validation. Defaults to
<code>c(1,1.5,...,3.5,4)</code>.</p>
</dd>
<dt>refit_cv</dt><dd><p>A Boolean, if <code>TRUE</code>, a refitting step is
performed when fitting the model for edge cross-validation. Defaults
to <code>TRUE</code></p>
</dd>
<dt>verbose_cv</dt><dd><p>A Boolean, if <code>TRUE</code>, console output will
provide updates on the progress of edge cross-validation. Defaults
to <code>FALSE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="multiness_fit_+3A_optim_opts">optim_opts</code></td>
<td>
<p>A list, containing additional optional arguments controlling
the proximal gradient descent algorithm.
</p>

<dl>
<dt>check_obj</dt><dd><p>A Boolean, if <code>TRUE</code>, convergence is determined
by checking the decrease in the objective. Otherwise it is determined by
checking the average entry-wise difference in consecutive values of <code class="reqn">F</code>.
Defaults to <code>TRUE</code>.</p>
</dd>
<dt>eig_maxitr</dt><dd><p>A positive integer, maximum iterations for internal
eigenvalue solver. Defaults to <code>1000</code>.</p>
</dd>
<dt>eig_prec</dt><dd><p>A positive scalar, estimated eigenvalues below this
threshold are set to zero. Defaults to <code>1e-2</code>.</p>
</dd>
<dt>eps</dt><dd><p>A positive scalar, convergence threshold for proximal gradient
descent. Defaults to <code>1e-6</code>.</p>
</dd>
<dt>eta</dt><dd><p>A positive scalar, step size for proximal gradient descent.
Defaults to <code>1</code> for the Gaussian model, <code>5</code> for the logistic
model.</p>
</dd>
<dt>init</dt><dd><p>A string, initialization method. Valid options are
<code>'fix'</code> (using initializers <code>optim_opts$V_init</code> and
<code>optim_opts$U_init</code>), <code>'zero'</code> (initialize all parameters at zero),
or <code>'svd'</code> (initialize with a truncated SVD with rank <code>optim_opts$init_rank</code>).
Defaults to <code>'zero'</code>.</p>
</dd>
<dt>K_max</dt><dd><p>A positive integer, maximum iterations for proximal gradient
descent. Defaults to <code>100</code>.</p>
</dd>
<dt>max_rank</dt><dd><p>A positive integer, maximum rank for internal eigenvalue
solver. Defaults to <code>sqrt(n)</code>.</p>
</dd>
<dt>missing_pattern</dt><dd><p>An <code class="reqn">n \times n \times m</code> Boolean array with <code>TRUE</code>
for each observed entry and <code>FALSE</code> for missing entries. If unspecified, it
is set to <code>!is.na(A)</code>.</p>
</dd>
<dt>positive</dt><dd><p>A Boolean, if <code>TRUE</code>, singular value thresholding only retains
positive eigenvalues. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>return_posns</dt><dd><p>A Boolean, if <code>TRUE</code>, returns estimates
of the latent positions based on ASE. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>verbose</dt><dd><p>A Boolean, if <code>TRUE</code>, console output will provide
updates on the progress of proximal gradient descent. Defaults to
<code>FALSE</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>A MultiNeSS model is fit to an <code class="reqn">n \times n \times m</code> array <code class="reqn">A</code> of
symmetric adjacency matrices on a common set of nodes. Fitting
proceeds by convex proximal gradient descent on the entries of
<code class="reqn">F = VV^{T}</code> and <code class="reqn">G_k = U_kU_k^{T}</code>, see
<a href="https://arxiv.org/abs/2012.14409">MacDonald et al., (2020)</a>,
Section 3.2. Additional optional arguments for
the gradient descent routine can be provided in <code>optim_opts</code>.
<code>refit</code> provides an option
to perform an additional refitting step to debias the eigenvalues
of the estimates, see
<a href="https://arxiv.org/abs/2012.14409">MacDonald et al., (2020)</a>, Section 3.3.
</p>
<p>By default, <code>multiness_fit</code> will return estimates of the matrices
<code class="reqn">F</code> and <code class="reqn">G_k</code>. <code>optim_opts$return_posns</code> provides an option
to instead return estimates of latent positions <code class="reqn">V</code> and <code class="reqn">U_k</code>
based on the adjacency spectral embedding (if such a factorization exists).
</p>
<p>Tuning parameters <code class="reqn">\lambda</code> and <code class="reqn">\alpha_k</code> in the nuclear norm penalty
</p>
<p style="text-align: center;"><code class="reqn">\lambda ||F||_* + \sum_k \lambda \alpha_k ||G_k||_*</code>
</p>

<p>are either set by the
user (<code>tuning='fixed'</code>), selected adaptively using a
robust estimator of the
entry-wise variance (<code>tuning='adaptive'</code>), or
selected using edge cross-validation (<code>tuning='cv'</code>). For more details
see <a href="https://arxiv.org/abs/2012.14409">MacDonald et al., (2020)</a>,
Section 3.4. Additional optional arguments for parameter tuning
can be provided in <code>tuning_opts</code>.
</p>


<h3>Value</h3>

<p>A list is returned with the MultiNeSS model estimates, dimensions of
the common and individual latent spaces, and some additional optimization
output:
</p>
<table>
<tr><td><code>F_hat</code></td>
<td>
<p>An <code class="reqn">n \times n</code> matrix estimating the common part of the expected
adjacency matrix, <code class="reqn">F = VV^{T}</code>. If <code>optim_opts$return_posns</code>
is <code>TRUE</code>, this is not returned.</p>
</td></tr>
<tr><td><code>G_hat</code></td>
<td>
<p>A list of length <code class="reqn">m</code>, the collection of <code class="reqn">n \times n</code> matrices
estimating the individual part of each adjacency matrix, <code class="reqn">G_k = U_kU_k^{T}</code>.
If <code>optim_opts$return_posns</code>
is <code>TRUE</code>, this is not returned.</p>
</td></tr>
<tr><td><code>V_hat</code></td>
<td>
<p>A matrix estimating the common latent positions.
Returned if <code>optim_opts$return_posns</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>U_hat</code></td>
<td>
<p>A list of length <code class="reqn">m</code>, the collection of matrices
estimating the individual latent positions.
Returned if <code>optim_opts$return_posns</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>d1</code></td>
<td>
<p>A non-negative integer, the estimated common dimension of the
latent space.</p>
</td></tr>
<tr><td><code>d2</code></td>
<td>
<p>An integer vector of length <code class="reqn">m</code>, the estimated individual
dimension of the latent space for each layer.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>A positive integer, the number of iterations run in proximal
gradient descent.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>An integer convergence code, <code>0</code> if proximal
gradient descent converged in fewer than <code>optim_opts$K_max</code> iterations,
<code>1</code> otherwise.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>A positive scalar, the tuned <code class="reqn">\lambda</code>
penalty parameter (see Details).</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>A numeric vector of length <code class="reqn">m</code>, the tuned <code class="reqn">\alpha</code> penalty parameters
(see Details).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># gaussian model data
data1 &lt;- multiness_sim(n=100,m=4,d1=2,d2=2,
                     model="gaussian")

# multiness_fit with fixed tuning
fit1 &lt;- multiness_fit(A=data1$A,
                      model="gaussian",
                      self_loops=TRUE,
                      refit=FALSE,
                      tuning="fixed",
                      tuning_opts=list(lambda=40,alpha=1/2),
                      optim_opts=list(max_rank=20,verbose=TRUE))

# multiness_fit with adaptive tuning
fit2 &lt;- multiness_fit(A=data1$A,
                      refit=TRUE,
                      tuning="adaptive",
                      tuning_opts=list(layer_wise=FALSE),
                      optim_opts=list(return_posns=TRUE))

# logistic model data
data2 &lt;- multiness_sim(n=100,m=4,d1=2,d2=2,
                       model="logistic",
                       self_loops=FALSE)

# multiness_fit with cv tuning
fit3 &lt;- multiness_fit(A=data2$A,
                      model="logistic",
                      self_loops=FALSE,
                      tuning="cv",
                      tuning_opts=list(N_cv=2,
                                       penalty_const_vec=c(1,2,2.309,3),
                                       verbose_cv=TRUE))

</code></pre>

<hr>
<h2 id='multiness_sim'>Simulate from the MultiNeSS model</h2><span id='topic+multiness_sim'></span>

<h3>Description</h3>

<p><code>multiness_sim</code> simulates a realization of the Gaussian
or logistic MultiNeSS model with Gaussian latent positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiness_sim(n,m,d1,d2,model,sigma,self_loops,opts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiness_sim_+3A_n">n</code></td>
<td>
<p>A positive integer, the number of nodes.</p>
</td></tr>
<tr><td><code id="multiness_sim_+3A_m">m</code></td>
<td>
<p>A positive integer, the number of layers.</p>
</td></tr>
<tr><td><code id="multiness_sim_+3A_d1">d1</code></td>
<td>
<p>A non-negative integer, the number of common latent dimensions.</p>
</td></tr>
<tr><td><code id="multiness_sim_+3A_d2">d2</code></td>
<td>
<p>A non-negative integer, the number of individual latent dimensions.</p>
</td></tr>
<tr><td><code id="multiness_sim_+3A_model">model</code></td>
<td>
<p>A string which provides choice of model,
either <code>'gaussian'</code> or <code>'logistic'</code>. Defaults to <code>'gaussian'</code>.</p>
</td></tr>
<tr><td><code id="multiness_sim_+3A_sigma">sigma</code></td>
<td>
<p>A positive scalar or numeric vector of length <code>m</code>,
the entry-wise standard deviation for the Gaussian noise for all layers
(if a scalar) or for each layer (if a vector). Ignored under the logistic
model. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="multiness_sim_+3A_self_loops">self_loops</code></td>
<td>
<p>A Boolean, if <code>FALSE</code>, all diagonal entries are set
to zero. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="multiness_sim_+3A_opts">opts</code></td>
<td>
<p>A list, containing additional optional arguments:
</p>

<dl>
<dt>density_shift</dt><dd><p>A positive scalar, for the logistic model only, a shift
subtracted from the log-odds of each edge to control overall edge density. Defaults to <code>0</code>.</p>
</dd>
<dt>dependence_type</dt><dd><p>A string, valid choices are <code>'all'</code> or
<code>'U_only'</code> for the Gaussian model; <code>'all'</code> for the logistic
model. If <code>'all'</code>, <code class="reqn">V</code> and <code class="reqn">U_k</code>; and <code class="reqn">U_k</code> and <code class="reqn">U_l</code>
(for <code class="reqn">k \neq l</code>) have expected canonical correlation approximately equal to
|<code class="reqn">rho</code>| (see <code>rho</code>).
If <code>'U_only'</code>, <code class="reqn">U_k</code> and <code class="reqn">U_l</code> (for <code class="reqn">k \neq l</code>) have expected
canonical correlation approximately equal to |<code class="reqn">rho</code>| (see <code>rho</code>).
Defaults to <code>'all'</code>.</p>
</dd>
<dt>gamma</dt><dd><p>A positive scalar, the standard deviation of the entries of
the latent position matrices <code class="reqn">V</code> and <code class="reqn">U_k</code>. Defaults to <code>1</code>.</p>
</dd>
<dt>return_density</dt><dd><p>A Boolean, if <code>TRUE</code> and <code>model='logistic'</code>, the function will return an array containing
the overall edge density. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>return_P</dt><dd><p>A Boolean, if <code>TRUE</code>, the function will return an array containing
the expected adjacency matrices. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>rho</dt><dd><p>A positive scalar in the interval (-1,1), controls the expected canonical
correlation between latent position matrices (see <code>dependence_type</code>).
Defaults to <code>0</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The common and individual latent positions, <code class="reqn">V</code> and <code class="reqn">U_k</code>
respectively, are generated as
Gaussian random variables with standard deviation <code>opts$gamma</code>, and
dependence controlled by the optional
arguments <code>opts$dependence_type</code> and <code>opts$rho</code>.
</p>
<p>Under the Gaussian model, the <code class="reqn">n \times n</code> adjacency matrix for layer <code class="reqn">k=1,...,m</code>
has independent Gaussian entries with standard deviation <code>sigma</code> and
mean given by
</p>
<p style="text-align: center;"><code class="reqn">E(A_k) = VV^{T} + U_kU_k^{T}.</code>
</p>

<p>Under the logistic model, the <code class="reqn">n \times n</code> adjacency matrix for layer <code class="reqn">k=1,...,m</code>
has independent Bernoulli entries with mean given by
</p>
<p style="text-align: center;"><code class="reqn">E(A_k) = g(VV^{T} + U_kU_k^{T}),</code>
</p>

<p>where <code class="reqn">g</code> denotes the element-wise application of the inverse logistic
link (<code><a href="#topic+expit">expit</a></code>) function. Under both models, <code>self_loops</code> provides
an option to set the diagonal entries of the adjacency matrices to zero.
</p>


<h3>Value</h3>

<p>A list is returned with the realizations of the latent dimensions
and the multiplex network:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>An array of dimension <code class="reqn">n \times n \times m</code>, the realized
multiplex network.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>A matrix of dimension <code class="reqn">n \times d1</code>, the realized common
latent positions. If <code>d1=0</code>, returns <code>NULL</code>.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>An array of dimension <code class="reqn">n \times d2 \times m</code>, the realized
individual latent positions. If <code>d2=0</code>, returns <code>NULL</code>.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>If specified, an array of dimension <code class="reqn">n \times n \times m</code>, the expected
multiplex network.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>If specified and <code>model='logistic'</code>, the overall edge density.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># gaussian model, uncorrelated latent positions
data1 &lt;- multiness_sim(n=100,m=4,d1=2,d2=2,
                      model="gaussian")

# logistic model, correlated latent positions
data2 &lt;- multiness_sim(n=100,m=4,d1=2,d2=2,
                       model="logistic",
                       self_loops=FALSE,
                       opts=list(dependence_type="all",rho=.3,return_density=TRUE))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
