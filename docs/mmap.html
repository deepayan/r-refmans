<!DOCTYPE html><html lang="en"><head><title>Help for package mmap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mmap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#C_types'>
<p>Virtual R Types On Disk.</p></a></li>
<li><a href='#make.fixedwidth'>
<p>Convert Character Vectors From Variable To Constant Width</p></a></li>
<li><a href='#mmap'>
<p>Map And Unmap Pages of Memory</p></a></li>
<li><a href='#mmap.csv'>
<p>Memory Map Text File</p></a></li>
<li><a href='#mmapFlags'>
<p>Create Bitwise Flags for mmap.</p></a></li>
<li><a href='#mprotect'>
<p>Control Protection of Pages</p></a></li>
<li><a href='#msync'>
<p>Synchronize Memory With Physical Storage</p></a></li>
<li><a href='#sizeof'>
<p>Calculate the Size of Datatypes</p></a></li>
<li><a href='#struct'>
<p>Construct a Ctype struct</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Map Pages of Memory</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-22</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey A. Ryan</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeffrey A. Ryan &lt;jeff.a.ryan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>R interface to POSIX mmap and Window's MapViewOfFile.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-08 16:51:10 UTC; jeffreyryan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='C_types'>
Virtual R Types On Disk.
</h2><span id='topic+types'></span><span id='topic+sizeofCtypes'></span><span id='topic+as.Ctype'></span><span id='topic+is.Ctype'></span><span id='topic+bits'></span><span id='topic+logi8'></span><span id='topic+logi32'></span><span id='topic+cstring'></span><span id='topic+cstring.MaxWidth'></span><span id='topic+is.cstring'></span><span id='topic+char'></span><span id='topic+uchar'></span><span id='topic+cplx'></span><span id='topic+int8'></span><span id='topic+uint8'></span><span id='topic+int16'></span><span id='topic+uint16'></span><span id='topic+int24'></span><span id='topic+uint24'></span><span id='topic+int32'></span><span id='topic+int64'></span><span id='topic+real32'></span><span id='topic+real64'></span><span id='topic+as.char'></span><span id='topic+as.uchar'></span><span id='topic+as.cplx'></span><span id='topic+as.int8'></span><span id='topic+as.uint8'></span><span id='topic+as.int16'></span><span id='topic+as.uint16'></span><span id='topic+as.int24'></span><span id='topic+as.uint24'></span><span id='topic+as.int32'></span><span id='topic+as.real32'></span><span id='topic+as.real64'></span><span id='topic+as.cstring'></span><span id='topic+nbytes'></span>

<h3>Description</h3>

<p>These functions describe the types of raw binary
data stored on disk. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char(length = 0, nul = TRUE)
uchar(length = 0)
logi8(length = 0)
logi32(length = 0)
int8(length = 0)
uint8(length = 0)
int16(length = 0)
uint16(length = 0)
int24(length = 0)
uint24(length = 0)
int32(length = 0)
int64(length = 0)
real32(length = 0)
real64(length = 0)
cplx(length = 0)
cstring(length = 0, na.strings = "NA")

as.Ctype(x)
is.Ctype(x)

cstring.MaxWidth()
sizeofCtypes()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_types_+3A_length">length</code></td>
<td>

<p>desired length. Not used when passed to mode= in mmap call.
</p>
</td></tr>
<tr><td><code id="C_types_+3A_x">x</code></td>
<td>

<p>R object to coerce or test
</p>
</td></tr>
<tr><td><code id="C_types_+3A_nul">nul</code></td>
<td>

<p>are characters delimited by a nul byte?
</p>
</td></tr>
<tr><td><code id="C_types_+3A_na.strings">na.strings</code></td>
<td>

<p>string to convert to <span class="rlang"><b>R</b></span>'s NA. See Details for current implementation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R has very limited storage types. There is one type
of integer and one type of float (double).  Storage
to disk often can be made more efficient by reducing
the precision of the data. These functions provide
for a sort of virtual mapping from disk to native
R type, for use with mmap-ed files.
</p>
<p>When a memory mapping is created, a conversion method
if declared for both extracting values from disk, as well
as replacing elements on disk.  The preceeding
functions are used in the internal compiled code to
handle the conversion.
</p>
<p>It is the user's responsibility to ensure that data
fits within the prescribed types. All fixed-width types support
extraction, replacement, and boolean Ops (e.g. <code>==</code>). See below
for note on <code>cstring</code> layout.
</p>
<p><code>cstring</code> reads nul-terminated strings from binary
C-style arrays. To minimize memory allocation, two additional
steps are carried out. First, when a memory map
is initiated, the length (N) of the character array is
calculated. The calculation of word offsets to facilitate access
are deferred until the first request <code>[</code> or a <code>Ops</code>
request. This offset calculation requires the creation of
an internal index made up of short integers, representing
the length of each character element. On most platforms, this
is at least 65534 (sizeof(short) - 1 for nul byte), 
but can be found via <code>cstring.MaxWidth</code>. 
This index will consume sizeof(short) * N memory, allocated
outside of R.
</p>
<p>At present <code>na.strings="NA"</code> is ignored and all occurances
of the (binary) string &lsquo;NA&rsquo; are converted to <code>NA_character_</code> types
in R. This is also used by the <span class="pkg">mmap</span> <code>is.na</code> function.
</p>


<h3>Value</h3>

<p>An R typed vector of length &lsquo;length&rsquo; with a
virtual type and class &lsquo;Ctype&rsquo;. Additional
information related to number of bytes and whether
the vitrual type is signed is also contained.
</p>


<h3>Warning </h3>

<p>The is no attempt to store or read metadata with
respect to the extracted or replaced data. This
is simply a low level interface to facilitate
data reading and writing. 
</p>


<h3>Note</h3>

<p>R vectors may be used to create files on disk
matching the specified type using the functions
<code>writeBin</code> with the appropriate <code>size</code>
argument. See also.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/C_variable_types_and_declarations">https://en.wikipedia.org/wiki/C_variable_types_and_declarations</a>
<a href="https://cran.r-project.org/doc/manuals/R-exts.html">https://cran.r-project.org/doc/manuals/R-exts.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+writeBin">writeBin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()

# write a 1 byte signed integer -128:127
writeBin(-127:127L, tmp, size=1L)
file.info(tmp)$size
one_byte &lt;- mmap(tmp, int8())
one_byte[]
munmap(one_byte)

# write a 1 byte unsigned integer 0:255
writeBin(0:255L, tmp, size=1L)
file.info(tmp)$size
one_byte &lt;- mmap(tmp, uint8())
one_byte[]
munmap(one_byte)

# write a 2 byte integer -32768:32767
writeBin(c(-32768L,32767L), tmp, size=2L)
file.info(tmp)$size
two_byte &lt;- mmap(tmp, int16())
two_byte[]
munmap(two_byte)

# write a 2 byte unsigned integer 0:65535
writeBin(c(0L,65535L), tmp, size=2L)
two_byte &lt;- mmap(tmp, uint16())
two_byte[]

# replacement methods automatically (watch precision!!)
two_byte[1] &lt;- 50000
two_byte[]

# values outside of range (above 65535 for uint16 will be wrong)
two_byte[1] &lt;- 65535 + 1
two_byte[]

munmap(two_byte)

# write a 4 byte integer standard R type
writeBin(1:10L, tmp, size=4L)
four_byte &lt;- mmap(tmp, int32())
four_byte[]
munmap(four_byte)

# write 32 bit integers as 64 bit longs (where supported)
int64()  # note it is a double in R, but described as int64
writeBin(1:10L, tmp, size=8L)
eight_byte &lt;- mmap(tmp, int64())
storage.mode(eight_byte[])  # using R doubles to preserve most long values
eight_byte[5] &lt;- 2^40  # write as a long, a value in R that is double ~2^53 is representable
eight_byte[5]
munmap(eight_byte)

cstring()
cstring.MaxWidth()
writeBin(c("this","is","a","sentence"), tmp)
strings &lt;- mmap(tmp, cstring())
strings[1:2]
strings[]
munmap(strings)

unlink(tmp)
</code></pre>

<hr>
<h2 id='make.fixedwidth'>
Convert Character Vectors From Variable To Constant Width
</h2><span id='topic+make.fixedwidth'></span>

<h3>Description</h3>

<p>Utility function to convert a vector of character strings
to one where each element has exactly &lsquo;width&rsquo;-bytes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.fixedwidth(x, width = NA, justify = c("left", "right"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.fixedwidth_+3A_x">x</code></td>
<td>

<p>A character vector.
</p>
</td></tr>
<tr><td><code id="make.fixedwidth_+3A_width">width</code></td>
<td>

<p>Maximum width of each element. width=NA (default)
will expand each element to the width required
to contain the largest element of x without loss
of information.
</p>
</td></tr>
<tr><td><code id="make.fixedwidth_+3A_justify">justify</code></td>
<td>

<p>How should the results be padded? &lsquo;left&rsquo; will
add spacing to the right of shorter elements in the vector
(left-justified), &lsquo;right&rsquo; will do the opposite.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current implementation of mmap only handles fixed-width
strings (nul-terminated). To simplify conversion of (potentially)
variable-width strings in a character vector, all
elements will be padded to the length of the longest string
in the vector or set to length <code>width</code> if specified.
</p>
<p>All new elements will be left or right justified based on the
<code>justify</code> argument.
</p>


<h3>Value</h3>

<p>A character vector where each element is of fixed-width.
</p>


<h3>Note</h3>

<p>Future implementions will possibly support variable-width character
vectors.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>month.name
make.fixedwidth(month.name)
</code></pre>

<hr>
<h2 id='mmap'>
Map And Unmap Pages of Memory
</h2><span id='topic+mmap'></span><span id='topic+munmap'></span><span id='topic+extractFUN'></span><span id='topic+extractFUN+3C-'></span><span id='topic+replaceFUN'></span><span id='topic+replaceFUN+3C-'></span><span id='topic+is.mmap'></span><span id='topic+as.mmap'></span><span id='topic+is.na.mmap'></span><span id='topic+dim.mmap'></span><span id='topic+dim+3C-.mmap'></span><span id='topic+dimnames.mmap'></span><span id='topic+dimnames+3C-.mmap'></span><span id='topic+is.array.mmap'></span><span id='topic+tempmmap'></span><span id='topic+pagesize'></span>

<h3>Description</h3>

<p>Wrapper to POSIX &lsquo;mmap&rsquo; and Windows MapViewOfFile system calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmap(file, mode = int32(), 
     extractFUN=NULL, replaceFUN=NULL,
     prot=mmapFlags("PROT_READ","PROT_WRITE"),
     flags=mmapFlags("MAP_SHARED"),
     len, off=0L, endian=.Platform$endian,
     ...)

munmap(x)

as.mmap(x, mode, file, ...)
is.mmap(x)

extractFUN(x)
replaceFUN(x)

extractFUN(x) &lt;- value
replaceFUN(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmap_+3A_file">file</code></td>
<td>

<p>name of file holding data to be mapped into memory
</p>
</td></tr>
<tr><td><code id="mmap_+3A_mode">mode</code></td>
<td>

<p>mode of data on disk. Use one of
&lsquo;char()&rsquo; (char &lt;-&gt; <span class="rlang"><b>R</b></span> raw),
&lsquo;int8()&rsquo; (char &lt;-&gt; <span class="rlang"><b>R</b></span> integer),
&lsquo;uint8()&rsquo; (unsigned char &lt;-&gt; <span class="rlang"><b>R</b></span> integer),
&lsquo;int16()&rsquo; (short &lt;-&gt; <span class="rlang"><b>R</b></span> integer),
&lsquo;uint16()&rsquo; (unsigned short &lt;-&gt; <span class="rlang"><b>R</b></span> integer),
&lsquo;int24()&rsquo; (3 byte integer &lt;-&gt; <span class="rlang"><b>R</b></span> integer),
&lsquo;uint24()&rsquo; (unsigned 3 byte integer &lt;-&gt; <span class="rlang"><b>R</b></span> integer),
&lsquo;int32()&rsquo; (<span class="rlang"><b>R</b></span> integer),
&lsquo;real32()&rsquo; (float &lt;-&gt; <span class="rlang"><b>R</b></span> double),
&lsquo;real64()&rsquo; (<span class="rlang"><b>R</b></span> double),
&lsquo;cplx()&rsquo; (<span class="rlang"><b>R</b></span> complex),
&lsquo;cstring()&rsquo; (<span class="rlang"><b>R</b></span> variable length character array),
&lsquo;struct()&rsquo; (Collection of Ctypes as defined by mmap).
See the related functions for details.
</p>
</td></tr>
<tr><td><code id="mmap_+3A_extractfun">extractFUN</code></td>
<td>

<p>A function to convert the raw/integer/double values
returned by subsetting into a complex R class. If no
change is needed, set to NULL (default).
</p>
</td></tr>
<tr><td><code id="mmap_+3A_replacefun">replaceFUN</code></td>
<td>

<p>A function to convert the R classes to underlying
C types for storage.
</p>
</td></tr>
<tr><td><code id="mmap_+3A_prot">prot</code></td>
<td>

<p>access permission to data being mapped.
Set via bitwise OR with <code>mmapFlags</code> to one or more of
&lsquo;PROT_READ&rsquo;: Data can be read,
&lsquo;PROT_WRITE&rsquo;: Data can be written,
&lsquo;PROT_EXEC&rsquo;: Data can be executed,
&lsquo;PROT_NONE&rsquo;: Data cannot be accessed.
Not all will apply within the context of R objects.
The default is PROT_READ | PROT_WRITE.
</p>
</td></tr>
<tr><td><code id="mmap_+3A_flags">flags</code></td>
<td>

<p>additional flags to <code>mmap</code>.
Set via bitwise OR with <code>mmapFlags</code> to one or more of
&lsquo;MAP_SHARED&rsquo;: Changes are shared (default),
&lsquo;MAP_PRIVATE&rsquo;: Changes are private,
&lsquo;MAP_FIXED&rsquo;: Interpret <em>addr</em> exactly (Not Applicable).
Not all will apply within the context of R objects.
</p>
</td></tr>
<tr><td><code id="mmap_+3A_len">len</code></td>
<td>

<p>length in bytes of mapping from offset. (EXPERT USE ONLY)
</p>
</td></tr>
<tr><td><code id="mmap_+3A_off">off</code></td>
<td>

<p>offset in bytes to start mapping. This <em>must be</em> a multiple
of the system pagesize.  No checking is currently done, nor is there
any mmap provision to find pagesize automatically. (EXPERT USE ONLY)
</p>
</td></tr>
<tr><td><code id="mmap_+3A_endian">endian</code></td>
<td>

<p>endianess of data. At present this is <em>only</em> applied to <code>int8</code>,<code>int16</code>,
<code>int32</code>,<code>float</code>,<code>real32</code>,<code>double</code>, and <code>real64</code> types for both
atomic and <code>struct</code> types. It is applied universally, and not at struct member elements.
</p>
</td></tr>
<tr><td><code id="mmap_+3A_...">...</code></td>
<td>

<p>unused
</p>
</td></tr>
<tr><td><code id="mmap_+3A_x">x</code></td>
<td>

<p>an object of class &lsquo;mmap&rsquo;
</p>
</td></tr>
<tr><td><code id="mmap_+3A_value">value</code></td>
<td>

<p>a function to apply upon extraction or replacement.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general semantics of the R function map to
the underlying operating system C function call. 
On unix-alikes this is &lsquo;mmap&rsquo;, on Windows
similar functionality is provided by the
system call &lsquo;MapViewOfFile&rsquo;. The notable
exception is the use of the R argument <code>file</code> in place of
<code>void *addr</code> and <code>int fildes</code>.  Additionally
<code>len</code> and <code>off</code> arguments are
made available to the R level call, though require
special care based on the system's mmap
and are advised for expert use only.
</p>
<p><code>as.mmap</code> allows for in-memory objects to be
converted to mmapped version on-disk.  The files are
stored in the location specified by <code>file</code>.
Passing an object that has an appropriate
as.mmap method will allow <span class="rlang"><b>R</b></span> objects to be automatically
created as memory-mapped object.  
This works for most atomic types in R, including
numeric, complex, and character vectors. A special note
on character vectors: the implementation supports both
variable width character vectors (native R) as well as
fixed width arrays requiring a constant number of bytes per element.
The current default is to use fixed width, with variable
width enabled by setting <code>mode=cstring()</code>. See <code>as.mmap.character</code> for more details.
</p>
<p>Complex data types, such as 2 dimesioned vectors (matrix)
and data.frames can be supported using appropriate
<code>extractFUN</code> and <code>replaceFUN</code> functions to convert
the raw data.  Basic object conversion is made available
in included <code>as.mmap</code> methods for boths types as of
version 0.6-3.
</p>
<p>All mode types are defined for single-column atomic
data, with the exception of structs.  Multiple column
objects are supported by the use of setting <code>dim</code>.
All data is column major. Row major orientation, as well
as supporting multiple types in one object - imitating
a data.frame, is supported via the <code>struct</code> mode. 
</p>
<p>Using <code>struct</code> as the mode will organize the
binary data on-disk (or more correctly read data organized on disk) in
a row-major orientation.  This is similar to how a row
database would be oriented, and will provide faster
access to data that is typically viewed by row.
See <code>help(struct)</code> for examples of semantics as well
as performance comparisons.
</p>


<h3>Value</h3>

<p>The mmap and as.mmap call
returns an object of class <code>mmap</code> containing
the fields: 
</p>

<dl>
<dt>data:</dt><dd>
<p>pointer to the &lsquo;mmap&rsquo;ped file.
</p>
</dd>
<dt>bytes:</dt><dd>
<p>size of file in bytes. This is not in resident memory.
</p>
</dd>
<dt>filedesc:</dt><dd>
<p>A names integer file descriptor, where the name
is path to the file mapped.
</p>
</dd>
<dt>storage.mode:</dt><dd>
<p><span class="rlang"><b>R</b></span> type of raw data on disk. See <code>types</code> for details.
</p>
</dd>
<dt>pagesize:</dt><dd>
<p>operating system pagesize.
</p>
</dd>
<dt>extractFUN:</dt><dd>
<p>conversion function on extraction (optional).
</p>
</dd>
<dt>replaceFUN:</dt><dd>
<p>conversion function for replacement (optional).
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p>mmap: <a href="http://www.opengroup.org/onlinepubs/000095399/functions/mmap.html">http://www.opengroup.org/onlinepubs/000095399/functions/mmap.html</a>
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+mmapFlags">mmapFlags</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a binary file and map into 'ints' object
# Note that we are creating a file of 1 byte integers,
# and that the conversion is handled transparently
tmp &lt;- tempfile()
ints &lt;- as.mmap(1:100L, mode=int8(), file=tmp)

ints[1]
ints[]
ints[22]
ints[21:23] &lt;- c(0,0,0)
ints[]  # changes are now on disk

# add dimension
dim(ints) &lt;- c(10,10)
ints[]
ints[6,2] # 6th row of 2nd column
ints[ ,2] # entire 2nd column
munmap(ints)

# store Dates as natural-size 'int' on disk
writeBin(as.integer(Sys.Date()+1:10), tmp)
DATE &lt;- mmap(tmp,extractFUN=function(x) structure(x,class="Date"))
DATE[]
munmap(DATE)

# store 2 decimal numeric as 'int' on disk, and convert on extraction
num &lt;- mmap(tmp,extractFUN=function(x) x/100)
num[]
munmap(num)

unlink(tmp)

# convert via as.mmap munmap
int &lt;- as.mmap(1:10L)
num &lt;- as.mmap(rnorm(10))
</code></pre>

<hr>
<h2 id='mmap.csv'>
Memory Map Text File
</h2><span id='topic+mmap.csv'></span>

<h3>Description</h3>

<p>Reads a file column by column and creates a memory mapped object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmap.csv(file, 
         header = TRUE, 
         sep = ",", 
         quote = "\"", 
         dec = ".", 
         fill = TRUE, 
         comment.char = "", 
         row.names,
         ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmap.csv_+3A_file">file</code></td>
<td>

<p>the name of the file containing the comma-separated values to be
mapped.
</p>
</td></tr>
<tr><td><code id="mmap.csv_+3A_header">header</code></td>
<td>

<p>does the file contain a header line?
</p>
</td></tr>
<tr><td><code id="mmap.csv_+3A_sep">sep</code></td>
<td>

<p>field separator character
</p>
</td></tr>
<tr><td><code id="mmap.csv_+3A_quote">quote</code></td>
<td>

<p>the set of quoting characters
</p>
</td></tr>
<tr><td><code id="mmap.csv_+3A_dec">dec</code></td>
<td>

<p>the character used for decimal points in the file
</p>
</td></tr>
<tr><td><code id="mmap.csv_+3A_fill">fill</code></td>
<td>

<p>unimplemented
</p>
</td></tr>
<tr><td><code id="mmap.csv_+3A_comment.char">comment.char</code></td>
<td>

<p>unimplemented
</p>
</td></tr>
<tr><td><code id="mmap.csv_+3A_row.names">row.names</code></td>
<td>

<p>what it says
</p>
</td></tr>
<tr><td><code id="mmap.csv_+3A_...">...</code></td>
<td>

<p>additional arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mmap.csv</code> is meant to be the analogue of read.csv in <span class="rlang"><b>R</b></span>, with the
primary difference being that data is read, by column, into memory-mapped
structs on disk. The intention is to allow for comma-separated files to
be easily mapped into memory without having to load the entire object at once.
</p>


<h3>Value</h3>

<p>An <code>mmap</code> object containing the data from the file. All types
will be set to the equivelant type from mmap
as would be in <span class="rlang"><b>R</b></span> from a call to <code>read.csv</code>.
</p>


<h3>Warning</h3>

<p>At present the memory required to memory-map a csv file will be the
memory required to load a single column from the file into R using
the traditional read.table function.  This may not be adequately efficient
for extremely large data.
</p>


<h3>Note</h3>

<p>This is currently a very simple implementation to facilitate exploration
of the mmap package.  While the interface will remain consistent with read.csv
from <span class="pkg">utils</span>, more additions to handle various out-of-core types available
in mmap as well as performance optimization will be added.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmap">mmap</a></code>, <code><a href="utils.html#topic+read.csv">read.csv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cars)
tmp &lt;- tempfile()
write.csv(cars, file=tmp, row.names=FALSE)

m &lt;- mmap.csv(tmp)

colnames(m) &lt;- colnames(cars)

m[]

extractFUN(m) &lt;- as.data.frame  # coerce list to data frame upon subset

m[1:3,]

munmap(m)
</code></pre>

<hr>
<h2 id='mmapFlags'>
Create Bitwise Flags for mmap.
</h2><span id='topic+mmapFlags'></span>

<h3>Description</h3>

<p>Allows for unquoted C constant names to
be bitwise OR'd together for passing
to <code>mmap</code> related calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmapFlags(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmapFlags_+3A_...">...</code></td>
<td>

<p>A comma or vertical bar &lsquo;|&rsquo; seperated list of zero or more
valid <code>mmap</code> constants. May be quoted or unquoted
from the following: PROT_READ, PROT_WRITE, PROT_EXEC,
PROT_NONE, MAP_SHARED, MAP_PRIVATE, MAP_FIXED, MS_ASYNC, MS_SYNC,
MS_INVALIDATE. See details for more information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument list may contain quoted or unquoted constants
as defined in <code>&lt;sys/mman.h&gt;</code>.  See invididual
functions for details on valid flags.
</p>
<p>Multiple values passed in will be bitwise OR'd
together at the C level, allowing for
semantics close to that of native C calls.
</p>


<h3>Value</h3>

<p>An integer vector of length 1.
</p>


<h3>Note</h3>

<p>Read your system's &lsquo;mmap&rsquo; man pages for use details.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+mmap">mmap</a></code>, ~~~
See Also as <code><a href="#topic+mprotect">mprotect</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mmapFlags(PROT_READ)
mmapFlags(PROT_READ | PROT_WRITE)
mmapFlags("PROT_READ" | "PROT_WRITE")
mmapFlags(PROT_READ , PROT_WRITE)
mmapFlags("PROT_READ" , "PROT_WRITE")
</code></pre>

<hr>
<h2 id='mprotect'>
Control Protection of Pages
</h2><span id='topic+mprotect'></span>

<h3>Description</h3>

<p>Wrapper to <code>mprotect</code> system call.  Not all
implementations will guarantee protection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mprotect(x, i, prot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mprotect_+3A_x">x</code></td>
<td>

<p><code>mmap</code> object.
</p>
</td></tr>
<tr><td><code id="mprotect_+3A_i">i</code></td>
<td>

<p>location and length of pages to protect.
</p>
</td></tr>
<tr><td><code id="mprotect_+3A_prot">prot</code></td>
<td>

<p>protection flag set by <code>mmapFlags</code>.
Must be one or more of:
&lsquo;PROT_NONE&rsquo;,
&lsquo;PROT_READ&rsquo;,
&lsquo;PROT_WRITE&rsquo;,
&lsquo;PROT_EXEC&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functionality is very experimental, and likely to
be of limited use with R, as the result of a page access
that is protected is a SIG that isn't likely to
be caught by R.  This may be of use for other programs
sharing resource with R.
</p>


<h3>Value</h3>

<p>0 upon success, otherwise -1.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p>&lsquo;mprotect&rsquo; man page.
</p>

<hr>
<h2 id='msync'>
Synchronize Memory With Physical Storage
</h2><span id='topic+msync'></span>

<h3>Description</h3>

<p><code>msync</code> calls the underlying system call of
the same name.  This writes modified whole pages
back to the filesystem and updates the file modification
time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msync(x, flags=mmapFlags("MS_ASYNC"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msync_+3A_x">x</code></td>
<td>

<p>An <code>mmap</code> object.
</p>
</td></tr>
<tr><td><code id="msync_+3A_flags">flags</code></td>
<td>

<p>One of the following flags:
&lsquo;MS_ASYNC&rsquo;: return immediately (default).
&lsquo;MS_SYNC&rsquo;: perform synchronous writes.
&lsquo;MS_INVALIDATE&rsquo;: invalidate all cached data.
</p>
<p>Per the man page, &lsquo;MS_ASYNC&rsquo; is not
permitted to be combined with the other flags.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the appropriate OS man page.
</p>


<h3>Value</h3>

<p>0 on success, otherwise -1.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>

<hr>
<h2 id='sizeof'>
Calculate the Size of Datatypes
</h2><span id='topic+sizeof'></span>

<h3>Description</h3>

<p>Calculate the number of bytes in an R data type used by <span class="pkg">mmap</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizeof(type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sizeof_+3A_type">type</code></td>
<td>

<p>A type constructor (function), <span class="rlang"><b>R</b></span> atomic, or <span class="pkg">mmap</span> <code>Ctype</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A constructor for the purposes of <code>sizeof</code> is a function object
used to create an atomic type for <span class="rlang"><b>R</b></span> or mmap.  These include the
base atomic type functions such as <code>integer</code>, <code>character</code>,
<code>double</code>, <code>numeric</code>, <code>single</code>, <code>complex</code> and
similar.  In addition, the Ctype constructors in <span class="pkg">mmap</span> such
as <code>int8</code>, <code>uint8</code>, <code>real32</code>, etc may be passed in.
</p>
<p>More typically a representative object of the above types can
be passed in to determine the appropriate data size.
</p>
<p>The purpose of this function is for use to help construct a proper
<code>offset</code> argument value for mmap and <code>mprotect</code>, though
neither use is common or encouraged since alignment to pagesize is
required from the system call.
</p>


<h3>Value</h3>

<p>Numeric bytes used.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pagesize">pagesize</a></code>
<code><a href="#topic+as.Ctype">as.Ctype</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># all are equal

sizeof(int32)
sizeof(int32())
sizeof(integer)
sizeof(integer())
sizeof(1L)
</code></pre>

<hr>
<h2 id='struct'>
Construct a Ctype struct
</h2><span id='topic+struct'></span><span id='topic+pad'></span><span id='topic+as.struct'></span><span id='topic+is.struct'></span><span id='topic+as.list.Ctype'></span>

<h3>Description</h3>

<p>Construct arbitarily complex &lsquo;struct&rsquo;ures
in R for use with on-disk C struct's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct(..., bytes, offset)

is.struct(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="struct_+3A_...">...</code></td>
<td>

<p>Field types contained in struct.
</p>
</td></tr>
<tr><td><code id="struct_+3A_bytes">bytes</code></td>
<td>

<p>The total number of bytes in the struct. See details.
</p>
</td></tr>
<tr><td><code id="struct_+3A_offset">offset</code></td>
<td>

<p>The byte offset of members of the struct. See details.
</p>
</td></tr>
<tr><td><code id="struct_+3A_x">x</code></td>
<td>

<p>object to test 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>struct</code> provides a high level <span class="rlang"><b>R</b></span>
based description of a C based struct
data type on disk.
</p>
<p>The types of data that can be contained within
a structure (byte array) on disk can be any
permutation of the following: int8, uint8, int16
uint16, int32, real32, and real64.  &lsquo;struct&rsquo;s
are not recursive, that is all struct's contained
within a struct must be logically flattened (core
elements extracted).
</p>
<p>All C types are converted to the appropriate <span class="rlang"><b>R</b></span>
type internally.
</p>
<p>It is best to consider a struct a simple byte array,
where at specified offsets, a valid C variable type
exists.  Describing the struct using the <span class="rlang"><b>R</b></span>
function <code>struct</code> allows mmap extraction
to proceed as if the entire structure was one block,
(a single &lsquo;i&rsquo; value), and each block
of bytes can thus be read into R with one
operation.
</p>
<p>One important distinction between the R struct (and the examples that follow)
and a C struct is related to byte-alignment.  Note that the <span class="rlang"><b>R</b></span> version
is effectively serializing the data, without padding to word boundaries.  See the
following section on ANSI C for more details for reading data generated by an external process
such as C/C++.
</p>


<h3>Value</h3>

<p>A list of values, one element for each
type of <span class="rlang"><b>R</b></span> data.
</p>


<h3>ANSI_C</h3>

<p>ANSI C struct's will typically have padding in cases where required
by the language details and/or C programs.  In general, if the struct
on disk has padding, the use of <code>bytes</code> and <code>offset</code> are required
to maintain alignment with the extraction and replacement code in mmap for <span class="rlang"><b>R</b></span>.
</p>
<p>A simple example of this is where you have an 8-byte double (real64) and
a 4-byte integer (int32).  Created by a C/C++ program, the result will be
a 16-byte struct - where the final 4-bytes will be padding.
</p>
<p>To accomodate this from mmap, it is required to specify the corrected
<code>bytes</code> (e.g. bytes=16 in this example).  For cases where padding
is not at the end of the struct (e.g. if an additional 8-byte double was
added as the final member of the previous struct), it would also
be necessary to correct the offset to reflect the internal padding. Here,
the correct setting would be <code>offset=c(0,8,16)</code> - since the 4-byte
integer will be padded to 8-bytes to allow for the final double to
begin on a word boundary (on a 64 bit platform).
</p>
<p>This is a general mechanism to adjust for offset - but requires knowledge
of both the struct on disk as well as the generating process. At some point
in the near future <code>struct</code> will attempt to properly adjust for
offset if mmap is used on data created from outside of R.
</p>
<p>It is important to note that this alignment is also dependent on the underlying
hardware word size (size_t) and is more complicated than the above example.
</p>


<h3>Note</h3>

<p>&lsquo;struct&rsquo;'s can be thought of as &lsquo;rows&rsquo;
in a database.  If many different types need always
be returned together, it will be more efficient to
store them together in a struct on disk. This reduces
the number of page hits required to fetch all required
data.  Conversley, if individual columns are desired
it will likely make sense to simply store vectors
in seperate files on disk and read in with <code>mmap</code>
individually as needed.
</p>
<p>Note that not all behavior of struct extraction and replacement
is defined for all virtual and real types yet. This is
an ongoing development and will be completed in the near future.
</p>


<h3>Author(s)</h3>

<p>Jeffrey A. Ryan
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">https://en.wikipedia.org/wiki/Struct_(C_programming_language)</a>
<a href="https://en.wikipedia.org/wiki/Data_structure_alignment">https://en.wikipedia.org/wiki/Data_structure_alignment</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+types">types</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()

f &lt;- file(tmp, open="ab")
u_int_8 &lt;- c(1L, 255L, 22L)  # 1 byte, valid range 0:255
int_8 &lt;- c(1L, -127L, -22L)  # 1 byte, valid range -128:127
u_int_16 &lt;- c(1L, 65000L, 1000L) # 2 byte, valid range 0:65+k
int_16 &lt;- c(1L, 25000L, -1000L) # 2 byte, valid range -32k:32k
int_32 &lt;- c(98743L, -9083299L, 0L) # 4 byte, standard R integer
float_32 &lt;- c(9832.22, 3.14159, 0.00001)
cplx_64 &lt;- c(1+0i, 0+8i, 2+2i)

# not yet supported in struct
char_ &lt;- writeBin(as.raw(1:3), raw())
fixed_width_string &lt;- c("ab","cd","ef")

for(i in 1:3) {
  writeBin(u_int_8[i],  f, size=1L)
  writeBin(int_8[i],    f, size=1L)
  writeBin(u_int_16[i], f, size=2L)
  writeBin(int_16[i],   f, size=2L)
  writeBin(int_32[i],   f, size=4L)
  writeBin(float_32[i], f, size=4L)  # store as 32bit - prec issues
  writeBin(float_32[i], f, size=8L)  # store as 64bit
  writeBin(cplx_64[i],  f)
  writeBin(char_[i], f)
  writeBin(fixed_width_string[i], f)
}
close(f)

m &lt;- mmap(tmp, struct(uint8(),
                      int8(),
                      uint16(),
                      int16(), 
                      int32(),
                      real32(),
                      real64(),
                      cplx(),
                      char(),  # also raw()
                      char(2)  # character array of n characters each
                     ))  
length(m) # only 3 'struct' elements
str(m[])

m[1:2]

# add a post-processing function to convert some elements (rows) to a data.frame
extractFUN(m) &lt;- function(x,i,...) {
                   x &lt;- x[i]
                   data.frame(u_int_8=x[[1]],
                                int_8=x[[2]],
                               int_16=x[[3]],
                               int_32=x[[4]],
                               float_32=x[[5]],
                               real_64=x[[6]]
                             )
                 }
m[1:2]
munmap(m)

# grouping commonly fetched data by row reduces
# disk IO, as values reside together on a page
# in memory (which is paged in by mmap). Here
# we try 3 columns, or one row of 3 values.
# note that with structs we replicate a row-based
# structure.
#
# 13 byte struct
x &lt;- c(writeBin(1L, raw(), size=1),
       writeBin(3.14, raw(), size=4),
       writeBin(100.1, raw(), size=8))
writeBin(rep(x,1e6), tmp)
length(x)
m &lt;- mmap(tmp, struct(int8(),real32(),real64()))
length(m)
m[1]

# create the columns in seperate files (like a column
# store)
t1 &lt;- tempfile()
t2 &lt;- tempfile()
t3 &lt;- tempfile()
writeBin(rep(x[1],1e6), t1)
writeBin(rep(x[2:5],1e6), t2)
writeBin(rep(x[6:13],1e6), t3)

m1 &lt;- mmap(t1, int8())
m2 &lt;- mmap(t2, real32())
m3 &lt;- mmap(t3, real64())
list(m1[1],m2[1],m3[1])

i &lt;- 5e5:6e5

# note that times are ~3x faster for the struct
# due to decreased disk IO and CPU cost to process
system.time(for(i in 1:100) m[i])
system.time(for(i in 1:100) m[i])
system.time(for(i in 1:100) list(m1[i],m2[i],m3[i]))
system.time(for(i in 1:100) list(m1[i],m2[i],m3[i]))
system.time(for(i in 1:100) {m1[i];m2[i];m3[i]}) # no cost to list()

# you can skip struct members by specifying offset and bytes
m &lt;- mmap(tmp, struct(int8(),
                     #real32(),   here we are skipping the 4 byte float
                      real64(),
                      offset=c(0,5), bytes=13))
# alternatively you can add padding directly
n &lt;- mmap(tmp, struct(int8(), pad(4), real64()))

pad(4)
pad(int32())

m[1]
n[1]

munmap(m)
munmap(n)
munmap(m1)
munmap(m2)
munmap(m3)
unlink(t1)
unlink(t2)
unlink(t3)
unlink(tmp)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
