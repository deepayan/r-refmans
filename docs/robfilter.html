<!DOCTYPE html><html><head><title>Help for package robfilter</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {robfilter}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#robfilter-package'>
<p>Robust Time Series Filters</p></a></li>
<li><a href='#adore.filter'><p>A Robust Adaptive Online Repeated Median Filter for Univariate Time Series</p></a></li>
<li><a href='#const'><p>Correction factors to achieve unbiasedness of the Qn scale estimator</p></a></li>
<li><a href='#const.Q'>
<p>Correction factors to achieve unbiasedness of the regression-free Q scale estimator</p></a></li>
<li><a href='#critvals'><p>Critical Values for the RM Goodness of Fit Test</p></a></li>
<li><a href='#dfs'>
<p>Degrees of freedom for the SCARM test statistic.</p></a></li>
<li><a href='#dr.filter'>
<p>Deepest Regression (DR) filter</p></a></li>
<li><a href='#dw.filter'><p>Robust Double Window Filtering Methods for Univariate Time Series</p></a></li>
<li><a href='#hybrid.filter'><p>Robust Hybrid Filtering Methods for Univariate Time Series</p></a></li>
<li><a href='#lms.filter'>
<p>Least Median of Squares (LMS) filter</p></a></li>
<li><a href='#lqd.filter'>
<p>Least Quartile Difference filter</p></a></li>
<li><a href='#lts.filter'>
<p>Least Trimmed Squares (LTS) filter</p></a></li>
<li><a href='#madore.filter'><p>A multivariate adaptive online repeated median filter</p></a></li>
<li><a href='#med.filter'>
<p>Median (MED) filter</p></a></li>
<li><a href='#mscarm.filter'><p>MSCARM (Multivariate Slope Comparing Adaptive Repeated Median)</p></a></li>
<li><a href='#multi.ts'><p>Generated Multivariate Time Series</p></a></li>
<li><a href='#rm.filter'>
<p>Repeated Median (RM) filter</p></a></li>
<li><a href='#robreg.filter'><p>Robust Regression Filters for Univariate Time Series</p></a></li>
<li><a href='#robust.filter'><p>Robust Filtering Methods for Univariate Time Series</p></a></li>
<li><a href='#scarm.filter'><p>SCARM (Slope Comparing Adaptive Repeated Median)</p></a></li>
<li><a href='#sizecorrection'><p>Bias correction factors for the robust scale estimators MAD, Sn, Qn, and LSH</p></a></li>
<li><a href='#timecorrection'><p>Correction factors for the scale estimation of the filtering procedure proposed by Fried (2004).</p></a></li>
<li><a href='#var.n'>
<p>Variance of the Repeated Median slope estimator.</p></a></li>
<li><a href='#wrm.filter'><p>Weighted Repeated Median Filters for Univariate Time Series</p></a></li>
<li><a href='#wrm.smooth'><p>Weighted Repeated Median Smoothing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Time Series Filters</td>
</tr>
<tr>
<td>Author:</td>
<td>Roland Fried [aut, cre],
  Karen Schettlinger [aut],
  Matthias Borowski [aut],
  Robin Nunkesser [ctb],
  Thorsten Bernholt [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roland Fried &lt;fried@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), robustbase, MASS, lattice</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations for several robust procedures that allow for (online)
        extraction of the signal of univariate or multivariate time series by
        applying robust regression techniques to a moving time window are provided.
        Included are univariate filtering procedures based on repeated-median 
        regression as well as hybrid and trimmed filters derived from it; 
        see Schettlinger et al. (2006) &lt;<a href="https://doi.org/10.1515%2FBMT.2006.010">doi:10.1515/BMT.2006.010</a>&gt;. The adaptive 
        online repeated median by Schettlinger et al. (2010) &lt;<a href="https://doi.org/10.1002%2Facs.1105">doi:10.1002/acs.1105</a>&gt; 
        and the slope comparing adaptive repeated median by Borowski and Fried (2013) 
        &lt;<a href="https://doi.org/10.1007%2Fs11222-013-9391-7">doi:10.1007/s11222-013-9391-7</a>&gt; choose the width of the moving time 
        window adaptively. Multivariate versions are also provided; see  
        Borowski et al. (2009) &lt;<a href="https://doi.org/10.1080%2F03610910802514972">doi:10.1080/03610910802514972</a>&gt; for a multivariate 
        online adaptive repeated median and Borowski (2012) &lt;<a href="https://doi.org/10.17877%2FDE290R-14393">doi:10.17877/DE290R-14393</a>&gt;  
        for a multivariate slope comparing adaptive repeated median. Furthermore, 
        a repeated-median based filter with automatic outlier replacement and 
        shift detection is provided; see Fried (2004) &lt;<a href="https://doi.org/10.1080%2F10485250410001656444">doi:10.1080/10485250410001656444</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://msnat.statistik.tu-dortmund.de/en/team/chair/">https://msnat.statistik.tu-dortmund.de/en/team/chair/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-03 19:18:09 UTC; abbas</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-06 03:30:02 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
</table>
<hr>
<h2 id='robfilter-package'>
Robust Time Series Filters
</h2><span id='topic+robfilter-package'></span><span id='topic+robfilter'></span>

<h3>Description</h3>

<p>Implementations for several robust procedures that allow for (online)
        extraction of the signal of univariate or multivariate time series by
        applying robust regression techniques to a moving time window are provided.
        Included are univariate filtering procedures based on repeated-median 
        regression as well as hybrid and trimmed filters derived from it; 
        see Schettlinger et al. (2006) &lt;doi:10.1515/BMT.2006.010&gt;. The adaptive 
        online repeated median by Schettlinger et al. (2010) &lt;doi:10.1002/acs.1105&gt; 
        and the slope comparing adaptive repeated median by Borowski and Fried (2013) 
        &lt;doi:10.1007/s11222-013-9391-7&gt; choose the width of the moving time 
        window adaptively. Multivariate versions are also provided; see  
        Borowski et al. (2009) &lt;doi:10.1080/03610910802514972&gt; for a multivariate 
        online adaptive repeated median and Borowski (2012) &lt;doi:10.17877/DE290R-14393&gt;  
        for a multivariate slope comparing adaptive repeated median. Furthermore, 
        a repeated-median based filter with automatic outlier replacement and 
        shift detection is provided; see Fried (2004) &lt;doi:10.1080/10485250410001656444&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> robfilter</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 4.1.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-12-03</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Robust Time Series Filters</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Roland", "Fried", 
                    email = "fried@statistik.tu-dortmund.de", 
                    role = c("aut", "cre")),
             person("Karen", "Schettlinger", 
                    email = "schettlinger@statistik.tu-dortmund.de",
                    role = "aut"),
             person("Matthias", "Borowski",
                    email = "borowski@statistik.tu-dortmund.de",
                    role = "aut"),
             person("Robin", "Nunkesser", 
                    role = "ctb"),
             person("Thorsten", "Bernholt",
                    role = "ctb"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Roland Fried [aut, cre],
  Karen Schettlinger [aut],
  Matthias Borowski [aut],
  Robin Nunkesser [ctb],
  Thorsten Bernholt [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Roland Fried &lt;fried@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> stats, graphics, utils</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.6.0), robustbase, MASS, lattice</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Implementations for several robust procedures that allow for (online)
        extraction of the signal of univariate or multivariate time series by
        applying robust regression techniques to a moving time window are provided.
        Included are univariate filtering procedures based on repeated-median 
        regression as well as hybrid and trimmed filters derived from it; 
        see Schettlinger et al. (2006) &lt;doi:10.1515/BMT.2006.010&gt;. The adaptive 
        online repeated median by Schettlinger et al. (2010) &lt;doi:10.1002/acs.1105&gt; 
        and the slope comparing adaptive repeated median by Borowski and Fried (2013) 
        &lt;doi:10.1007/s11222-013-9391-7&gt; choose the width of the moving time 
        window adaptively. Multivariate versions are also provided; see  
        Borowski et al. (2009) &lt;doi:10.1080/03610910802514972&gt; for a multivariate 
        online adaptive repeated median and Borowski (2012) &lt;doi:10.17877/DE290R-14393&gt;  
        for a multivariate slope comparing adaptive repeated median. Furthermore, 
        a repeated-median based filter with automatic outlier replacement and 
        shift detection is provided; see Fried (2004) &lt;doi:10.1080/10485250410001656444&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://msnat.statistik.tu-dortmund.de/en/team/chair/</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository: </td><td style="text-align: left;"> CRAN</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2022-11-06 18:08:12 UTC; abbas</td>
</tr>
<tr>
 <td style="text-align: left;">
Date/Publication: </td><td style="text-align: left;"> 2022-11-06 21:20:02 UTC</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
adore.filter            A Robust Adaptive Online Repeated Median Filter
                        for Univariate Time Series
const                   Correction factors to achieve unbiasedness of
                        the Qn scale estimator
const.Q                 Correction factors to achieve unbiasedness of
                        the regression-free Q scale estimator
critvals                Critical Values for the RM Goodness of Fit Test
dfs                     Degrees of freedom for the SCARM test
                        statistic.
dr.filter               Deepest Regression (DR) filter
dw.filter               Robust Double Window Filtering Methods for
                        Univariate Time Series
hybrid.filter           Robust Hybrid Filtering Methods for Univariate
                        Time Series
lms.filter              Least Median of Squares (LMS) filter
lqd.filter              Least Quartile Difference filter
lts.filter              Least Trimmed Squares (LTS) filter
madore.filter           A multivariate adaptive online repeated median
                        filter
med.filter              Median (MED) filter
mscarm.filter           MSCARM (Multivariate Slope Comparing Adaptive
                        Repeated Median)
multi.ts                Generated Multivariate Time Series
rm.filter               Repeated Median (RM) filter
robfilter-package       Robust Time Series Filters
robreg.filter           Robust Regression Filters for Univariate Time
                        Series
robust.filter           Robust Filtering Methods for Univariate Time
                        Series
scarm.filter            SCARM (Slope Comparing Adaptive Repeated
                        Median)
sizecorrection          Bias correction factors for the robust scale
                        estimators MAD, Sn, Qn, and LSH
timecorrection          Correction factors for the scale estimation of
                        the filtering procedure proposed by Fried
                        (2004).
var.n                   Variance of the Repeated Median slope
                        estimator.
wrm.filter              Weighted Repeated Median Filters for Univariate
                        Time Series
wrm.smooth              Weighted Repeated Median Smoothing
</pre>
<pre>
adore.filter            A Robust Adaptive Online Repeated Median Filter
                        for Univariate Time Series
const.Q                 Correction factors to achieve unbiasedness of 
                        the regression-free Q scale estimator                       
const                   Correction factors to achieve unbiasedness of
                        the Qn scale estimator
critvals                Critical Values for the RM Goodness of Fit Test
dfs                     Degrees of freedom for the SCARM test statistic
dr.filter               Deepest Regression (DR) filter
dw.filter               Robust Double Window Filtering Methods for
                        Univariate Time Series
hybrid.filter           Robust Hybrid Filtering Methods for Univariate
                        Time Series
lms.filter              Least Median of Squares (LMS) filter
lqd.filter              Least Quartile Difference (LQD) filter
lts.filter              Least Trimmed Squares (LTS) filter
madore.filter           A Robust Adaptive Online Filter for
                        Multivariate Time Series
med.filter              Median (MED) filter
multi.ts                Generated Multivariate Time Series
rm.filter               Repeated Median (RM) filter
robreg.filter           Robust Regression Filters for Univariate Time
                        Series
robust.filter           Robust Filtering Methods for Univariate Time
                        Series
scarm.filter            SCARM (Slope Comparing Adaptive Repeated Median)                        
var.n                   Variance of the Repeated Median slope estimator
wrm.filter              Weighted Repeated Median Filters for Univariate
                        Time Series
wrm.smooth              Weighted Repeated Median Smoothing
</pre>


<h3>Author(s)</h3>

<p>Roland Fried [aut, cre],
  Karen Schettlinger [aut],
  Matthias Borowski [aut],
  Robin Nunkesser [ctb],
  Thorsten Bernholt [ctb]
</p>
<p>Maintainer: Roland Fried &lt;fried@statistik.tu-dortmund.de&gt;
</p>

<hr>
<h2 id='adore.filter'>A Robust Adaptive Online Repeated Median Filter for Univariate Time Series</h2><span id='topic+adore.filter'></span>

<h3>Description</h3>

 
<p>Procedure for robust online extraction of low frequency
components (the <em>signal</em>) from a univariate time series by a moving window technique with
adaptive window width selection (ADaptive Online REpeated median FILTER).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adore.filter(y,
             p.test=15, minNonNAs=5,
             min.width=10, max.width=200,
             width.search="geometric",
             rtr=2, extrapolate=FALSE,
             calc.qn=FALSE, sign.level=0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adore.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr>
<tr><td><code id="adore.filter_+3A_p.test">p.test</code></td>
<td>
<p>defines the number of most recent Repeated Median residuals within each window used to test the goodness of fit of the online signal level. <br />
It can be either a value in (0.25, 0.3, 0.5), meaning that <code>floor(p.test*width)</code> residuals are considered for the goodness of fit test, where <code>width</code> is the currently used window width, or it can also be a positive integer <code>&gt;= 5</code> specifying a fixed number of most recent residuals (default).<br />
If the number of residuals considered for the test exceeds <code>width/2</code>, the procedure sets it to <code>floor(width/2)</code>, if it is smaller than five, the number is set to five.</p>
</td></tr>
<tr><td><code id="adore.filter_+3A_minnonnas">minNonNAs</code></td>
<td>
<p>a positive integer <code>&gt;= 5</code> defining the minimum number of non-missing observations within one window which is required for a &lsquo;sensible&rsquo; estimation.</p>
</td></tr>
<tr><td><code id="adore.filter_+3A_min.width">min.width</code></td>
<td>
<p>a positive integer <code>&gt;= 5</code> specifying the minimal window width.</p>
</td></tr>
<tr><td><code id="adore.filter_+3A_max.width">max.width</code></td>
<td>
<p>a positive integer <code>&gt;= min.width</code> specifying the maximal window width.</p>
</td></tr>
<tr><td><code id="adore.filter_+3A_width.search">width.search</code></td>
<td>
<p>a character string defining the search algorithm used for finding an adequate window width at each point in time.
</p>

<dl>
<dt><code>"linear"</code></dt><dd><p>The linear search always results in the largest window width possible and hence yields 
the smoothest online signal. 
However, if sudden changes (like level shifts) appear in the signal it requires a lot of computation time
and thus, an increased variability of the extracted signal may be observed.
</p>
</dd>
<dt><code>"binary"</code></dt><dd><p>The binary search is recommended if it can be expected that the window width needs 
to be reduced drastically from a large to a very small value at certain times (for example at level shifts or trend changes).
However, it may not always result in the largest possible window width.
</p>
</dd>
<dt><code>"geometric"</code> (default)</dt><dd><p>The geometric search is as fast as the binary search
but it puts more weight on large window widths. 
It offers a good compromise between the linear and the binary search (computation time vs. smooth output signal).
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="adore.filter_+3A_rtr">rtr</code></td>
<td>
<p>a value in 0, 1, 2 specifying whether a 'restrict to range' rule should be applied.
</p>

<dl>
<dt><code>rtr=0</code></dt><dd><p>The estimated signal level consists of the last fitted value of a Repeated Median regression fit 
within a time window of adequate width.</p>
</dd>
<dt><code>rtr=1</code></dt><dd><p>The level estimation is restricted to the range of the observations within each time window.</p>
</dd>
<dt><code>rtr=2</code> (default)</dt><dd><p>The level estimation is restricted to the range of the most recent observations 
(specified by <code>p.test</code>) i.e., to the range of the observations which are used to evaluate the goodness of fit.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="adore.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the beginning of the time series. The 
extrapolation consists of all fitted values within the first 
time window. </p>
</td></tr>
<tr><td><code id="adore.filter_+3A_calc.qn">calc.qn</code></td>
<td>
<p>a logical indicating whether the Qn scale (Rousseeuw, Croux, 1993) should also be calculated along with the signal level 
as an estimate of the standard deviation in each window.
Here, the <code>Qn</code> command from the <code>robustbase</code> library is applied with the built-in finite sample correction.
</p>
</td></tr>
<tr><td><code id="adore.filter_+3A_sign.level">sign.level</code></td>
<td>
<p>significance level of the test procedure; must be a value in <code class="reqn">(0,0.5)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>adore.filter</code> works by applying Repeated Median (RM)
regression (Siegel, 1982) to a moving time window with a length varying between 
<code>min.width</code> and <code>max.width</code>. 
</p>
<p>For each point in time, the window width is adapted to the current data situation by a goodness of fit test for
the most recent signal level estimation. 
The test uses the absolute value of the sum of the RM residuals in the subset specified by <code>p.test</code>.
The critical value for the test decision corresponds to a slightly modified 0.95-quantile of the 
distribution of the test statistic and is stored in the data set <code>critvals</code>.
</p>
<p>A more detailed description of the filter can be found in 
Schettlinger, Fried, Gather (2010).</p>


<h3>Value</h3>

 
<p><code>adore.filter</code> returns an object of class <code>adore.filter</code>.  
An object of class <code>adore.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>a numeric vector containing the signal level extracted by the RM filter 
with adaptive window width.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>a numeric vector containing the corresponding slope within each time window.</p>
</td></tr>
<tr><td><code>width</code></td>
<td>
<p>a numeric vector containing the corresponding window width used for the level and slope estimations.</p>
</td></tr>
<tr><td><code>level.list</code></td>
<td>
<p>a list which contains with as many elements as the length of the input time series.
If at time <code>t</code>, the window width was not reduced, the entry <code>level.list[[t]]</code> simply corresponds to <code>level[t]</code>.
However, if more than one iteration took place, <code>level.list[[t]]</code> is a vector which contains all level estimations which were
evaluated until the final estimate <code>mu[t]</code> passed the goodness of fit test and was stored.
</p>
</td></tr>
<tr><td><code>slope.list</code></td>
<td>
<p>a list containing the slope estimations corresponding to the values in <code>level.list</code>.
</p>
</td></tr>
<tr><td><code>width.list</code></td>
<td>
<p>a list containing the window widths used for the estimations in <code>level.list</code> and <code>slope.list</code>.
</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a numeric vector containing the corresponding scale within each time window estimated by the robust Qn estimator
(only calculated if <code>calc.qn = TRUE</code>, else <code>sigma</code> does not exist).</p>
</td></tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>min.width</code>, <code>max.width</code>, <code>width.search</code>,
<code>p.test</code>, <code>minNonNAs</code>, <code>rtr</code>, <code>extrapolate</code>, and <code>calc.qn</code>. 
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>aoRM</code> returns a plot showing the original time series 
with the filtered output. 
</p>


<h3>Author(s)</h3>

<p>Karen Schettlinger</p>


<h3>References</h3>

 
<p>Rousseeuw, P. J., Croux, C. (1993)
Alternatives to the Median Absolute Deviation,
<em>Journal of the American Statistical Association</em> <b>88</b>,
1273-1283.
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2010) 
Real Time Signal Processing by Adaptive Repeated Median Filters,
<em>International Journal of Adaptive Control and Signal Processing</em> <b>24</b>(5), 346-362.<br />
</p>
<p>Siegel, A.F. (1982)
Robust Regression Using Repeated Medians,
<em>Biometrika</em> <b>69</b> (1), 
242-244.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>, <code><a href="#topic+wrm.filter">wrm.filter</a></code>, <code><a href="#topic+madore.filter">madore.filter</a></code>, <code><a href="#topic+scarm.filter">scarm.filter</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># # # # # # # # # #
# Short and noise-free time series
series &lt;- c(rep(0,30),rep(10,30),seq(10,5,length=20),seq(5,15,length=20))

# Adaptive online signal extraction without &amp; with 'restrict to range' rule
t.without.rtr &lt;- adore.filter(series, rtr=0)
plot(t.without.rtr)
t.with.rtr1 &lt;- adore.filter(series, rtr=1)
lines(t.with.rtr1$level, col="blue")
t.with.rtr2 &lt;- adore.filter(series)
lines(t.with.rtr2$level, col="green3",lty=2)
legend("top",c("Signal with rtr=1","Signal with rtr=2"),col=c("blue","green3"),lty=c(1,2),bty="n")

# # # # # # # # # #
# Short and noise-free time series + 1 outlier
ol.series &lt;- series
ol.series[63] &lt;- 3

# Adaptive online signal extraction without &amp; with 'restrict to range' rule
t.without.rtr &lt;- adore.filter(ol.series, rtr=0)
plot(t.without.rtr)
t.with.rtr1 &lt;- adore.filter(ol.series, rtr=1)
lines(t.with.rtr1$level, col="blue")
t.with.rtr2 &lt;- adore.filter(ol.series)
lines(t.with.rtr2$level, col="green3",lty=2)
legend("top",c("Signal with rtr=1","Signal with rtr=2"),col=c("blue","green3"),lty=c(1,2),bty="n")

# # # # # # # # # #
# Noisy time series with level shifts, trend changes and shifts in the scale of the error term
true.signal  &lt;- c(rep(0,150),rep(10,150),seq(10,5,length=100),seq(5,15,length=100))
series2      &lt;- true.signal + c(rnorm(250,sd=1), rnorm(200,sd=3), rnorm(50,sd=1))

# Adaptive online signal extraction with additional Qn scale estimation
s2 &lt;- adore.filter(series2, calc.qn=TRUE)
par(mfrow=c(3,1))
plot(s2)
plot(s2$sigma,type="l",main="Corresponding Qn Scale Estimation",ylab="sigma",xlab="time")
lines(c(rep(1,250),rep(3,200),rep(1,150)),col="grey")
legend("topleft",c("True scale","Qn"),lty=c(1,1),col=c("grey","black"),bty="n")
plot(s2$width,type="l",main="Corresponding Window Width",ylab="width",xlab="time")

</code></pre>

<hr>
<h2 id='const'>Correction factors to achieve unbiasedness of the Qn scale estimator</h2><span id='topic+const'></span>

<h3>Description</h3>

<p>This matrix contains correction factors for the univariate Qn scale estimator (Rousseeuw, Croux, 1993) to achieve unbiasedness under Gaussian noise. The <code>madore.filter</code> estimates the local error covariance matrix by the orthogonalized Gnanadesikan-Kettenring estimator (Gnanadesikan, Kettenring, 1972, Maronna, Zamar, 2002) which is based on the Qn scale estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>const</code></pre>


<h3>Format</h3>

<p>A (96x2)-matrix containing the correction factors for the univariate Qn scale estimator for the samples sizes <code class="reqn">n=10,11,...,100,200,300,400,500,1000</code>.
</p>


<h3>Source</h3>

<p>The correction factors have been obtained by simulations.</p>


<h3>References</h3>

<p>Gnanadesikan, R., Kettenring, J.R. (1972)
Robust Estimates, Residuals, and Outlier Detection with Multiresponse Data,
<em>Biometrics</em> <b>28</b>, 81-124.<br />
</p>
<p>Maronna, R.A., Zamar, R.H. (2002)
Robust Estimates of Location and Dispersion for High-Dimensional Datasets,
<em>Technometrics</em> <b>44</b>, 307-317.<br />
</p>
<p>Rousseeuw, P.J., Croux, C. (1993)
Alternatives to the Median Absolute Deviation,
<em>Journal of the American Statistical Association</em> <b>88</b>, 1273-1283.
</p>

<hr>
<h2 id='const.Q'>
Correction factors to achieve unbiasedness of the regression-free Q scale estimator
</h2><span id='topic+const.Q'></span>

<h3>Description</h3>

<p>Correction factors for the regression-free Q scale estimator (Rousseeuw and Hubert, 1996, Gelper et al., 2009) to achieve unbiasedness under Gaussian noise; required by the function <code>scarm.filter</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(const.Q)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:151] NA NA NA NA 2.17 ...
</p>


<h3>Source</h3>

<p>The correction factors have been obtained by simulations.
</p>


<h3>References</h3>

<p>Rousseeuw, P. and Hubert, M. (1996)
Regression-free and robust estimation of scale for bivariate data,
<em>Computational Statistics and Data Analysis</em>, <b>21</b>(1), 67-85.<br />
</p>
<p>Gelper, S., Schettlinger, K., Croux, C., and Gather, U. (2009)
Robust online scale estimation in time series: A model-free approach,
<em>Journal of Statistical Planning and Inference</em>, <b>139</b>(2), 335-349.<br />
</p>

<hr>
<h2 id='critvals'>Critical Values for the RM Goodness of Fit Test</h2><span id='topic+critvals'></span>

<h3>Description</h3>

<p>This matrix contains critical values for the goodness of fit test
for the last fitted value of a Repeated Median regression fit
to a sample of size <code>n</code>. The critical values are based on the 0.95-quantiles
of the distribution of a test statistic corresponding to the absolute value of
the sum of a subset of residual signs. The critical value for a test based on the
last <code>nI</code> out of <code>n</code> observations corresponds to <code>critvals[n,nI]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critvals</code></pre>


<h3>Format</h3>

<p>A (600x61)-matrix containing 30550 observations.</p>


<h3>Source</h3>

<p>Simulation.</p>


<h3>References</h3>

<p>Schettlinger, K., Fried, R., Gather, U. (2008) 
Real Time Signal Processing by Adaptive Repeated Median Filters,
<em>International Journal of Adaptive Control and Signal Processing</em>, submitted.<br />
</p>
<p>Siegel, A.F. (1982)
Robust Regression Using Repeated Medians,
<em>Biometrika</em> <b>69</b> (1), 
242-244.<br />
</p>

<hr>
<h2 id='dfs'>
Degrees of freedom for the SCARM test statistic.
</h2><span id='topic+dfs'></span>

<h3>Description</h3>

<p>This matrix contains degrees of freedom for the t-distributed SCARM test statistic; required by the function <code>scarm.filter</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dfs)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 20 variables.
</p>

<dl>
<dt><code>X5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X20</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X25</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X30</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X35</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X40</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X45</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X50</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X55</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X60</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X65</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X70</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X75</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X80</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X85</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X90</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X95</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X100</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>The SCARM test from the function <code>scarm.filter</code> is based on the difference of Repeated Median slopes computed in a left-hand and right-hand window. The distribution of the SCARM test statistic is approximated by a t-distribution where the degrees of freedom depend on the width of the left- and right-hand window. This matrix delivers suitable degrees of freedom, obtained by simulations.
</p>


<h3>Source</h3>

<p>The degrees of freedom have been obtained by simulations.
</p>


<h3>References</h3>

<p>Borowski, M. and Fried, R. (2011)
Robust moving window regression for online signal extraction from
non-stationary time series: online window width adaption by testing for
signal changes, <em>submitted</em>.
</p>

<hr>
<h2 id='dr.filter'>
Deepest Regression (DR) filter
</h2><span id='topic+dr.filter'></span>

<h3>Description</h3>

<p>This function extracts signals from time series by means of Deepest regression in a moving time window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dr.filter(y, width, online = FALSE, extrapolate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dr.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr> 
<tr><td><code id="dr.filter_+3A_width">width</code></td>
<td>
<p>a positive integer defining the window width used for fitting.<br />
If <code>online=FALSE</code> (see below) this needs to be an odd integer.</p>
</td></tr>
<tr><td><code id="dr.filter_+3A_online">online</code></td>
<td>
<p>a logical indicating whether the current level estimate is 
evaluated at the most recent time within each time window 
(<code>TRUE</code>) or centred within each window (<code>FALSE</code>). 
Setting <code>online=FALSE</code> requires the <code>width</code> to be odd. 
Default is <code>online=FALSE</code>.</p>
</td></tr>  
<tr><td><code id="dr.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series. <br />
If <code>online=FALSE</code> the extrapolation consists of the 
fitted values within the first half of the first window and the 
last half of the last window; if <code>online=TRUE</code> the 
extrapolation consists of the fitted values within the first 
time window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dr.filter</code> is suitable for extracting low 
frequency components (the <em>signal</em>) from a time series which 
may be contaminated with outliers and can contain level shifts. 
For this, robust Deepest Regression is applied to a moving 
window, and the signal level is estimated by the fitted value 
either at the end of each time window for online signal 
extraction without time delay (<code>online=TRUE</code>) or in the 
centre of each time window (<code>online=FALSE</code>).
</p>


<h3>Value</h3>

<p><code>dr.filter</code> returns an object of class <code>robreg.filter</code>. 
An object of class <code>robreg.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>a data frame containing the extracted signal level.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>a data frame containing the corresponding slope within each time window.</p>
</td></tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>width</code>, <code>online</code> and <code>extrapolate</code>. 
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>robreg.filter</code> returns a plot showing the original time series 
with the filtered output. 
</p>


<h3>Author(s)</h3>

<p>Roland Fried, Karen Schettlinger and Matthias Borowski
</p>


<h3>References</h3>

<p>Davies, P.L., Fried, R., Gather, U. (2004) 
Robust Signal Extraction for On-Line Monitoring Data, 
<em>Journal of Statistical Planning and Inference</em> <b>122</b>, 
65-78.<br />
</p>
<p>Gather, U., Schettlinger, K., Fried, R. (2006)
Online Signal Extraction by Robust Linear Regression,
<em>Computational Statistics</em> <b>21</b>(1), 
33-51. <br />
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2006) 
Robust Filters for Intensive Care Monitoring: Beyond the Running Median,
<em>Biomedizinische Technik</em> <b>51</b>(2), 
49-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random time series:
y &lt;- cumsum(runif(500)) - .5*(1:500)
# Add jumps:
y[200:500] &lt;- y[200:500] + 5
y[400:500] &lt;- y[400:500] - 7
# Add noise:
n &lt;- sample(1:500, 30)
y[n] &lt;- y[n] + rnorm(30)

# Online filtering with DR filter:
y.rr &lt;- dr.filter(y,width=41,online=TRUE)
plot(y.rr)
</code></pre>

<hr>
<h2 id='dw.filter'>Robust Double Window Filtering Methods for Univariate Time Series</h2><span id='topic+dw.filter'></span><span id='topic+dw.filter.online'></span>

<h3>Description</h3>

<p>Procedures for robust (online) extraction of low frequency 
components (the <em>signal</em>) from a univariate time series 
based on a moving window technique using two nested time windows 
in each step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dw.filter(y, outer.width, inner.width, method = "all", 
             scale = "MAD", d = 2, 
             minNonNAs = 5, online = FALSE, extrapolate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dw.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr> 
<tr><td><code id="dw.filter_+3A_outer.width">outer.width</code></td>
<td>
<p>a positive integer specifying the window width 
of the outer window used for determining the final estimate. <br />
If <code>online=FALSE</code> (see below) this needs to be an odd integer.</p>
</td></tr>
<tr><td><code id="dw.filter_+3A_inner.width">inner.width</code></td>
<td>
<p>a positive integer (not larger than <code>outer.width</code>)
specifying the window width of the inner window used for determining 
the initial estimate and trimming features.<br />
If <code>online=FALSE</code> (see below) this needs to be an odd integer.</p>
</td></tr>
<tr><td><code id="dw.filter_+3A_method">method</code></td>
<td>
<p>a (vector of) character string(s) containing the method(s) to be used for the estimation
of the signal level.<br />
It is possible to specify any combination of <code>"MED"</code>, <code>"RM"</code>, <code>"MTM"</code>, <code>"TRM"</code>, 
<code>"MRM"</code>, <code>"DWRM"</code>, <code>"DWMTM"</code>, <code>"DWTRM"</code>, <code>"DWMRM"</code> and 
<code>"all"</code> (for all of the above). Default is <code>method="all"</code>. 
For a detailed description see the section &lsquo;Methods&rsquo; below.</p>
</td></tr>
<tr><td><code id="dw.filter_+3A_scale">scale</code></td>
<td>
<p>a character string specifying the method to be used for robust estimation of the local 
variability (within one time window). Possible values are:
</p>
<dl>
<dt><code>"MAD"</code></dt><dd><p>Median absolute deviation about the median (default)</p>
</dd>
<dt><code>"QN"</code></dt><dd><p>Rousseeuw's and Croux' (1993) <code class="reqn">Q_n</code> scale estimator</p>
</dd>
<dt><code>"SN"</code></dt><dd><p>Rousseeuw's and Croux' (1993) <code class="reqn">S_n</code> scale estimator</p>
</dd>
</dl>
 </td></tr>
<tr><td><code id="dw.filter_+3A_d">d</code></td>
<td>
<p>a positive integer defining factor the current scale estimate is multiplied with for
determining the trimming boundaries for outlier detection.<br />
Observations deviating more than <code class="reqn">d\cdot \hat{\sigma}_t</code> 
from the current level approximation <code class="reqn">\hat{\mu}_t</code> 
are replaced by <code class="reqn">\hat{\mu}_t</code> where 
<code class="reqn">\hat{\sigma}_t</code> denotes the current scale estimate.
Default is <code>d = 2</code> meaning a <code class="reqn">2\sigma</code> rule  for outlier 
detection.</p>
</td></tr>
<tr><td><code id="dw.filter_+3A_minnonnas">minNonNAs</code></td>
<td>
<p>a positive integer defining the minimum number 
of non-missing observations within each window which is required  
for a &lsquo;sensible&rsquo; estimation. Default: if windows contain
less than <code>minNonNAs = 5</code> observations <code>NA</code>s are returned.</p>
</td></tr>
<tr><td><code id="dw.filter_+3A_online">online</code></td>
<td>
<p>a logical indicating whether the current level and 
scale estimates are evaluated at the most recent time 
within each (inner and outer) window (<code>TRUE</code>) or centred within 
the windows (<code>FALSE</code>). Setting <code>online=FALSE</code> requires odd 
<code>inner.width</code> and <code>outer.width</code>. Default is <code>online=FALSE</code>.</p>
</td></tr>
<tr><td><code id="dw.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series. <br />
If <code>online=FALSE</code> the extrapolation consists of the 
fitted values within the first half of the first window and the 
last half of the last window; if <code>online=TRUE</code> the 
extrapolation consists of the all fitted values within the first 
time window. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dw.filter</code> is suitable for extracting low 
frequency components (the <em>signal</em>) from a time series 
which may be contaminated with outliers and can contain level 
shifts. For this, moving window techniques are applied.
</p>
<p>A short inner window of length <code>inner.width</code> is used in each 
step for calculating an initial level estimate (by using either 
the median or a robust regression fit) and a robust estimate of 
the local standard deviation. Observations deviating strongly from this 
initial fit are trimmed from an outer time window of length 
<code>outer.width</code>, and the signal level is estimated from the 
remaining observations (by using either a location or regression 
estimator). Values specified in <code>method</code> determine which 
combination of estimation methods should be applied to the inner 
and outer window (see section &lsquo;Methods&rsquo; below).
</p>
<p>The applied <code>method</code> should be chosen based on an a-priori 
guess of the underlying signal and the data quality: Location 
based method (<code>MED</code> / <code>MTM</code>) are recommended in case 
of a locally (piecewise) constant signal, regression based 
approaches (<code>RM</code> / <code>DWRM</code> / <code>TRM</code> / <code>MRM</code>) in 
case of locally linear, monotone trends. 
</p>
<p>Since no big differences have been reported between <code>TRM</code> 
and <code>MRM</code>, the quicker and somewhat more efficient 
<code>TRM</code> option might be preferred. <code>DWRM</code> is the quickest 
of all regression based methods and performs better than the 
ordinary <code>RM</code> at shifts, but it is the least robust and 
least efficient method.
</p>
<p>If location based methods are used, the <code>inner.width</code> should 
be chosen at least twice the length of expected patches of 
subsequent outliers in the time series; if regression based 
methods are used, the <code>inner.width</code> should be at least three 
times that length, otherwise outlier patches can influence the 
estimations strongly. To increase the efficiency of the final 
estimates, <code>outer.width</code> can then be chosen rather large - 
provided that it is smaller than the time between subsequent 
level shifts.
</p>
<p>For robust scale estimation, <code>MAD</code> is the classical choice; 
<code>SN</code> is a somewhat more efficient and almost equally robust 
alternative, while <code>QN</code> is much more efficient if the 
window widths are not too small, and it performs very well at the 
occurrence of level shifts.
</p>
<p>The factor <code>d</code>, specifying the trimming boundaries as a 
multiple of the estimated scale, can be chosen similarly to 
classical rules for detecting unusual observations in a Gaussian 
sample. Choosing <code>d=3</code> instead of <code>d=2</code> increases 
efficiency, but decreases robustness; <code>d=2.5</code> might be seen 
as a compromise.</p>


<h3>Value</h3>

<p><code>dw.filter</code> returns an object of class <code>dw.filter</code>.  
An object of class <code>dw.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>a data frame containing the corresponding signal level extracted by the filter(s) specified in <code>method</code>.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>a data frame containing the corresponding slope within each time window.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a data frame containing 
<code>inner.loc.sigma</code>, <code>inner.reg.sigma</code>, <code>outer.loc.sigma</code> and <code>outer.reg.sigma</code>,
the scale estimated from the observations (<code>loc</code>) or the residuals from the Repeated Median regression (<code>reg</code>) 
within the inner window of length <code>inner.width</code> or the outer window of length <code>outer.width</code>, respectively.<br />
<code>MTM</code> uses <code>outer.loc.sigma</code> for trimming outliers, 
<code>MRM</code> and <code>TRM</code> use <code>outer.reg.sigma</code> for trimming outliers,<br />
<code>DWMTM</code> uses <code>inner.loc.sigma</code> for trimming outliers, 
<code>DWMRM</code> and <code>DWTRM</code> use <code>inner.reg.sigma</code> for trimming outliers;<br />
<code>MED</code>, <code>RM</code> and <code>RM</code> require no scale estimation.<br /> 
The function only returns values for <code>inner.loc.sigma</code>, <code>inner.reg.sigma</code>,
<code>outer.loc.sigma</code> or <code>outer.reg.sigma</code> if any specified <code>method</code>
requires their estimation; otherwise <code>NA</code>s are returned.</p>
</td></tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>outer.width</code>, 
<code>inner.width</code>, <code>method</code>, <code>scale</code>, <code>d</code>, 
<code>minNonNAs</code>, <code>online</code> and <code>extrapolate</code>. 
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>dw.filter</code> returns a plot showing the original time series 
with the filtered output. 
</p>


<h3>Methods</h3>

 
<p>The following methods are available as <code>method</code> for signal extraction, 
whereby the prefix <code>DW</code> denotes the fact that different 
window widths are used in the first and second step of the 
calculations within one window (i.e. 
<code>inner.width</code>&lt;<code>outer.width</code>) while for the 
methods <code>MED</code>, <code>RM</code>, <code>MTM</code>, <code>TRM</code> and <code>MRM</code>
the first and second step take place in a window of fixed 
length <code>outer.width</code>.
</p>

<dl>
<dt><code>MED</code></dt><dd><p>ordinary running median filter. <br />
The simple median is applied to the observations within a moving 
time window of length <code>outer.width</code>.
</p>
</dd>
<dt><code>RM</code></dt><dd><p>ordinary repeated median filter. <br />
Repeated median regression is applied to the observations within 
a moving time window of length <code>outer.width</code>.
</p>
</dd>
<dt><code>MTM</code>, <code>DWMTM</code></dt><dd><p>modified trimmed mean filters. <br />
In a first step the median is applied to (<code>MTM</code>): the whole 
window with <code>outer.width</code> or (<code>DWMTM</code>): the inner window 
with <code>inner.width</code>; in a second step the mean is applied to 
the (trimmed) observations in the whole window (with 
<code>outer.width</code>).
</p>
</dd>
<dt><code>TRM</code>, <code>DWTRM</code></dt><dd><p>trimmed repeated median filters. <br />
In a first step repeated median regression is applied to 
(<code>TRM</code>): the whole window with <code>outer.width</code> or 
(<code>DWTRM</code>): the inner window with <code>inner.width</code>; in a 
second step least squares regression is applied to the (trimmed) 
observations in the whole window (with <code>outer.width</code>).
</p>
</dd>
<dt><code>MRM</code>, <code>DWMRM</code></dt><dd><p>modified repeated median filters. <br />
In a first step repeated median regression is applied to 
(<code>MRM</code>): the whole window with <code>outer.width</code> or 
(<code>DWMRM</code>): the inner window with <code>inner.width</code>; in a 
second step another repeated median regression is applied to the 
(trimmed) observations in the whole window (with 
<code>outer.width</code>).
</p>
</dd> 
<dt><code>DWRM</code></dt><dd><p>double window repeated median filter. <br /> 
In a first step repeated median regression is applied to the 
inner window with <code>inner.width</code> to determine the trend 
(slope); in a second step the median is applied to the trend 
corrected observations in the whole window with 
<code>outer.width</code> (without trimming). 
</p>
</dd>
</dl>
 


<h3>Note</h3>

<p>Missing values are treated by omitting them and thus by reducing 
the corresponding window width. <br />
<code>MED</code>, <code>RM</code>, <code>MTM</code>, <code>TRM</code> and <code>MRM</code> 
require at least <code>minNonNAs</code> non-missing observations in each 
outer window; <code>DWRM</code>, <code>DWMTM</code>, <code>DWTRM</code> and 
<code>DWMRM</code> require at least <code>minNonNAs</code> non-missing 
observations in each inner window. Otherwise <code>NA</code>s are 
returned for <code>level</code>, <code>slope</code> and <code>sigma</code>.
</p>


<h3>Author(s)</h3>

<p>Roland Fried and Karen Schettlinger</p>


<h3>References</h3>

 
<p>Bernholt, T., Fried, R., Gather, U., Wegener, I. (2006) 
Modified Repeated Median Filters, 
<em>Statistics and Computing</em> <b>16</b>, 
177-192.<br /> 
(earlier version: <a href="http://hdl.handle.net/2003/5298">http://hdl.handle.net/2003/5298</a>)
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2006) 
Robust Filters for Intensive Care Monitoring: Beyond the Running Median,
<em>Biomedizinische Technik</em> <b>51</b>(2), 
49-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>, <code><a href="#topic+robust.filter">robust.filter</a></code>, <code><a href="#topic+hybrid.filter">hybrid.filter</a></code>, <code><a href="#topic+wrm.filter">wrm.filter</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate random time series:
y &lt;- cumsum(runif(500)) - .5*(1:500)
# Add jumps:
y[200:500] &lt;- y[200:500] + 5
y[400:500] &lt;- y[400:500] - 7
# Add noise:
n &lt;- sample(1:500, 30)
y[n] &lt;- y[n] + rnorm(30)

# Filtering with all methods:
y.dw &lt;- dw.filter(y, outer.width=31, inner.width=11, method="all")
# Plot:
plot(y.dw)

# Filtering with trimmed RM and double window TRM only:
y2.dw &lt;- dw.filter(y, outer.width=31, inner.width=11, method=c("TRM","DWTRM"))
plot(y2.dw)

## End(Not run)
</code></pre>

<hr>
<h2 id='hybrid.filter'>Robust Hybrid Filtering Methods for Univariate Time Series</h2><span id='topic+hybrid.filter'></span>

<h3>Description</h3>

<p>Procedures for robust extraction of low frequency components (the 
<em>signal</em>) from a univariate time series based on a moving 
window technique using the median of several one-sided 
half-window estimates (subfilters) in each step. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hybrid.filter(y, width, method = "all", minNonNAs=3, extrapolate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hybrid.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr> 
<tr><td><code id="hybrid.filter_+3A_width">width</code></td>
<td>
<p>an odd positive integer (<code class="reqn">\geq 3</code>) 
defining the window width used for fitting.</p>
</td></tr>
<tr><td><code id="hybrid.filter_+3A_method">method</code></td>
<td>
<p>a (vector of) character string(s) containing the method(s) to be used for the estimation
of the signal level.<br />
It is possible to specify any combination of 
<code>"MED"</code>, <code>"RM"</code>, <code>"MEAN"</code>, 
<code>FMH</code>, <code>"PFMH"</code>, <code>"CFMH"</code>, 
<code>"MH"</code>, <code>"PRMH"</code>, <code>"CRMH"</code>, 
<code>"MMH"</code>, <code>"PRMMH"</code>, <code>"CRMMH"</code>, 
and <code>"all"</code> (for all of the above). Default is <code>method="all"</code>. 
For a detailed description see the section &lsquo;Methods&rsquo; below.
</p>
</td></tr>
<tr><td><code id="hybrid.filter_+3A_minnonnas">minNonNAs</code></td>
<td>
<p>a positive integer defining the minimum number 
of non-missing observations within each window (half) which is required  
for a &lsquo;sensible&rsquo; estimation. Default: if a window (half) contains
less than <code>minNonNAs = 3</code> observations an <code>NA</code> is returned (for that subfilter).</p>
</td></tr>
<tr><td><code id="hybrid.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series.
The extrapolation extends the first estimated value to the first 
time in the first window and the last estimated value to 
the last time in the last time window. Default is 
<code>extrapolate=TRUE</code>.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>hybrid.filter</code> is suitable for extracting low frequency 
components (the <em>signal</em>) from a time series which may be 
contaminated with outliers and can contain level shifts or local 
extremes. For this, moving window techniques are applied.
</p>
<p>Within each time window several subfilters are applied to 
half-windows (left and right of the centre); the final signal 
level in the centre of the time window is then estimated by the 
median of the subfilter outputs.
</p>
<p>For the subfilters, both, location-based and regression-based 
method are available, the former applying means or medians and 
the idea of a locally constant signal value, the latter using 
ordinary least squares (LS) regression or Siegel's (1982) 
repeated median (RM) and the idea of an underlying locally linear 
trend. 
</p>
<p>The methods should be chosen based on an a-priori guess of the 
underlying signal and the data quality.  Location based methods 
(<code>MED</code>, <code>MEAN</code>, <code>FMH</code>, <code>MH</code>, <code>MMH</code>)  are 
recommended in case of a locally (piecewise) constant signal. 
Regression based and predictive approaches (<code>RM</code>, 
<code>PFMH</code>, <code>PRMH</code>, <code>PRMMH</code>) in case of locally linear 
monotone trends.  The combined filters (<code>CFMH</code>, <code>CRMH</code>, 
<code>CRMMH</code>) can be seen as a compromise, but are 
computationally somewhat more expensive and may be inferior to 
the predictive filters during steep trends.
</p>
<p>The approaches based on the median and RM are robust alternatives 
to the (in Gaussian samples) more efficient mean and least 
squares methods. The hybrid filters preserve shifts and local 
extremes much better than <code>MED</code>, <code>MEAN</code> or <code>RM</code> 
for the price of decreased robustness and / or Gaussian 
efficiency.
</p>


<h3>Value</h3>

<p><code>hybrid.filter</code> returns an object of class <code>hybrid.filter</code>.  
An object of class <code>hybrid.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>a data frame containing the signal level extracted 
by the filter(s) specified in <code>method</code>.</p>
</td></tr> 
<tr><td><code>slope</code></td>
<td>
<p>a data frame (possibly) containing <code>RM</code>, 
<code>RM.left</code>, <code>RM.right</code>, <code>LS.left</code> and 
<code>LS.right</code>: the slope estimated by Repeated Median regression 
in the whole window (for <code>method="RM"</code>) or in the left and right 
window half (for any <code>method</code> in <code>"PRMH"</code>, 
<code>"CRMH"</code>, <code>"PRMMH"</code> and <code>"CRMMH"</code>) or the least 
squares slope estimated from the left and right window half (for any <code>method</code> in 
<code>"PRFMH"</code> or <code>"CFMH"</code>).<br /> Only those slopes are 
returned which are required by the filters specified in 
<code>method</code>. If only location-based filters are applied (i.e. 
<code>"MED"</code>, <code>"MEAN"</code>, <code>"FMH"</code>, <code>"MH"</code> and /or 
<code>"MMH"</code>) <code>NULL</code> is returned for the <code>slope</code>.</p>
</td></tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>width</code>, <code>method</code> and 
<code>extrapolate</code>. 
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>hybrid.filter</code> returns a plot showing the original time series 
with the filtered output. 
</p>


<h3>Methods</h3>

 
<p>The following methods are available as <code>method</code> for signal extraction.
</p>
<p>Filters applying only <em>one</em> location or regression estimate 
to the whole window of length <code>width</code> and taking the 
location (in the centre of the time window) as final signal level
estimate:
</p>

<dl>
<dt><code>MED</code></dt><dd><p>ordinary running median filter.</p>
</dd>
<dt><code>MEAN</code></dt><dd><p>ordinary moving average filter.</p>
</dd>
<dt><code>RM</code></dt><dd><p>ordinary repeated median filter. <br />
Applies repeated median regression to each time window.</p>
</dd>
</dl>

<p>Filters applying several subfilters within one window, taking the 
median of the values listed below as the final signal level 
estimate:
</p>

<dl>
<dt><code>FMH</code></dt><dd><p>FIR median hybrid filter. <br />
Uses half-window averages and the central observation.</p>
</dd> 
<dt><code>PFMH</code></dt><dd><p>predictive <code>FMH</code> filter. <br />
Uses half-window least squares regression and the central 
observation.</p>
</dd> 
<dt><code>CFMH</code></dt><dd><p>combined <code>FMH</code> filter.<br />
Uses half-window averages, half-window least squares 
regression, and the central observation.</p>
</dd> 
<dt><code>MH</code></dt><dd><p>median hybrid filter. <br />
Uses half-window medians and the central observation.</p>
</dd> 
<dt><code>PRMH</code></dt><dd><p>predictive repeated median hybrid filter. <br /> 
Uses half-window repeated median regression and the 
central observation.</p>
</dd> 
<dt><code>CRMH</code></dt><dd><p>combined repeated median hybrid filter. <br /> 
Uses half-window medians, half-window repeated median 
regression, and the central observation.</p>
</dd> 
<dt><code>MMH</code></dt><dd><p>median/median hybrid filter. <br />
Uses half-window medians and the median of all 
observations in the window.</p>
</dd> 
<dt><code>PRMMH</code></dt><dd><p>predictive repeated median/median filter. <br /> 
Uses half-window repeated median regression and the 
median of all observations in the window.</p>
</dd> 
<dt><code>CRMMH</code></dt><dd><p>combined repeated median/median filter. <br /> 
Uses half-window medians, half-window repeated median 
regression, and the median of all observations in the window.</p>
</dd>
</dl>
 


<h3>Note</h3>

<p>Missing values are treated by omitting them and thus by 
reducing the corresponding window width. <br /> 
The <code>hybrid.filter</code> function only offers filters for signal 
extraction delayed by (<code>width</code>+1)/2 time units, in contrast 
to other filters available from the <code>robfilter</code> package 
which also offer online time series analysis without time delay.
</p>


<h3>Author(s)</h3>

<p>Roland Fried and Karen Schettlinger</p>


<h3>References</h3>

<p>Fried, R., Bernholt, T., Gather, U. (2006) 
Repeated Median and Hybrid Filters, <em>Computational Statistics &amp; Data Analysis</em> <b>50</b>, 
2313-2338. <br />
(earlier version: <a href="http://hdl.handle.net/2003/4866">http://hdl.handle.net/2003/4866</a>)
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2006) 
Robust Filters for Intensive Care Monitoring: Beyond the Running Median, <em>Biomedizinische Technik</em> <b>51</b>(2), 
49-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>, <code><a href="#topic+robust.filter">robust.filter</a></code>, <code><a href="#topic+dw.filter">dw.filter</a></code>, <code><a href="#topic+wrm.filter">wrm.filter</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random time series:
y &lt;- cumsum(runif(500)) - .5*(1:500)
# Add jumps:
y[200:500] &lt;- y[200:500] + 5
y[400:500] &lt;- y[400:500] - 7
# Add noise:
n &lt;- sample(1:500, 30)
y[n] &lt;- y[n] + rnorm(30)
# Filtering with all methods:
y.hy &lt;- hybrid.filter(y, width=31)
# Plot:
plot(y.hy)

# Filtering with running median and PRMH only:
y2.hy &lt;- hybrid.filter(y, width=31, method=c("MED","PRMH"))
plot(y2.hy)
</code></pre>

<hr>
<h2 id='lms.filter'>
Least Median of Squares (LMS) filter
</h2><span id='topic+lms.filter'></span>

<h3>Description</h3>

<p>This function extracts signals from time series by means of Least Median of Squares regression in a moving time window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lms.filter(y, width, online = FALSE, extrapolate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lms.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr> 
<tr><td><code id="lms.filter_+3A_width">width</code></td>
<td>
<p>a positive integer defining the window width used for fitting.<br />
If <code>online=FALSE</code> (see below) this needs to be an odd integer.</p>
</td></tr>
<tr><td><code id="lms.filter_+3A_online">online</code></td>
<td>
<p>a logical indicating whether the current level estimate is 
evaluated at the most recent time within each time window 
(<code>TRUE</code>) or centred within each window (<code>FALSE</code>). 
Setting <code>online=FALSE</code> requires the <code>width</code> to be odd. 
Default is <code>online=FALSE</code>.</p>
</td></tr>  
<tr><td><code id="lms.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series. <br />
If <code>online=FALSE</code> the extrapolation consists of the 
fitted values within the first half of the first window and the 
last half of the last window; if <code>online=TRUE</code> the 
extrapolation consists of the fitted values within the first 
time window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lms.filter</code> is suitable for extracting low 
frequency components (the <em>signal</em>) from a time series which 
may be contaminated with outliers and can contain level shifts. 
For this, robust Least Median of Squares regression is applied to a moving 
window, and the signal level is estimated by the fitted value 
either at the end of each time window for online signal 
extraction without time delay (<code>online=TRUE</code>) or in the 
centre of each time window (<code>online=FALSE</code>).
</p>


<h3>Value</h3>

<p><code>lms.filter</code> returns an object of class <code>robreg.filter</code>. 
An object of class <code>robreg.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>a data frame containing the extracted signal level.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>a data frame containing the corresponding slope within each time window.</p>
</td></tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>width</code>, <code>online</code> and <code>extrapolate</code>. 
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>robreg.filter</code> returns a plot showing the original time series 
with the filtered output. 
</p>


<h3>Author(s)</h3>

<p>Roland Fried, Karen Schettlinger and Matthias Borowski
</p>


<h3>References</h3>

<p>Davies, P.L., Fried, R., Gather, U. (2004) 
Robust Signal Extraction for On-Line Monitoring Data, 
<em>Journal of Statistical Planning and Inference</em> <b>122</b>, 
65-78.<br />
</p>
<p>Gather, U., Schettlinger, K., Fried, R. (2006)
Online Signal Extraction by Robust Linear Regression,
<em>Computational Statistics</em> <b>21</b>(1), 
33-51. <br />
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2006) 
Robust Filters for Intensive Care Monitoring: Beyond the Running Median,
<em>Biomedizinische Technik</em> <b>51</b>(2), 
49-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random time series:
y &lt;- cumsum(runif(500)) - .5*(1:500)
# Add jumps:
y[200:500] &lt;- y[200:500] + 5
y[400:500] &lt;- y[400:500] - 7
# Add noise:
n &lt;- sample(1:500, 30)
y[n] &lt;- y[n] + rnorm(30)

# Online filtering with LMS filter:
y.rr &lt;- lms.filter(y,width=41,online=FALSE)
plot(y.rr)
</code></pre>

<hr>
<h2 id='lqd.filter'>
Least Quartile Difference filter
</h2><span id='topic+lqd.filter'></span>

<h3>Description</h3>

<p>This function extracts signals from time series by means of Least Quartile Difference regression in a moving time window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lqd.filter(y, width, online = FALSE, extrapolate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lqd.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr> 
<tr><td><code id="lqd.filter_+3A_width">width</code></td>
<td>
<p>a positive integer defining the window width used for fitting.<br />
If <code>online=FALSE</code> (see below) this needs to be an odd integer.</p>
</td></tr>
<tr><td><code id="lqd.filter_+3A_online">online</code></td>
<td>
<p>a logical indicating whether the current level estimate is 
evaluated at the most recent time within each time window 
(<code>TRUE</code>) or centred within each window (<code>FALSE</code>). 
Setting <code>online=FALSE</code> requires the <code>width</code> to be odd. 
Default is <code>online=FALSE</code>.</p>
</td></tr>  
<tr><td><code id="lqd.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series. <br />
If <code>online=FALSE</code> the extrapolation consists of the 
fitted values within the first half of the first window and the 
last half of the last window; if <code>online=TRUE</code> the 
extrapolation consists of the fitted values within the first 
time window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lqd.filter</code> is suitable for extracting low 
frequency components (the <em>signal</em>) from a time series which 
may be contaminated with outliers and can contain level shifts. 
For this, robust Least Quartile Difference regression is applied to a moving 
window, and the signal level is estimated by the fitted value 
either at the end of each time window for online signal 
extraction without time delay (<code>online=TRUE</code>) or in the 
centre of each time window (<code>online=FALSE</code>).
</p>


<h3>Value</h3>

<p><code>lqd.filter</code> returns an object of class <code>robreg.filter</code>. 
An object of class <code>robreg.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>a data frame containing the extracted signal level.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>a data frame containing the corresponding slope within each time window.</p>
</td></tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>width</code>, <code>online</code> and <code>extrapolate</code>. 
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>robreg.filter</code> returns a plot showing the original time series 
with the filtered output. 
</p>


<h3>Author(s)</h3>

<p>Roland Fried, Karen Schettlinger and Matthias Borowski
</p>


<h3>References</h3>

<p>Davies, P.L., Fried, R., Gather, U. (2004) 
Robust Signal Extraction for On-Line Monitoring Data, 
<em>Journal of Statistical Planning and Inference</em> <b>122</b>, 
65-78.<br />
</p>
<p>Gather, U., Schettlinger, K., Fried, R. (2006)
Online Signal Extraction by Robust Linear Regression,
<em>Computational Statistics</em> <b>21</b>(1), 
33-51. <br />
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2006) 
Robust Filters for Intensive Care Monitoring: Beyond the Running Median,
<em>Biomedizinische Technik</em> <b>51</b>(2), 
49-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random time series:
y &lt;- cumsum(runif(500)) - .5*(1:500)
# Add jumps:
y[200:500] &lt;- y[200:500] + 5
y[400:500] &lt;- y[400:500] - 7
# Add noise:
n &lt;- sample(1:500, 30)
y[n] &lt;- y[n] + rnorm(30)

# Online filtering with LQD filter:
y.rr &lt;- lqd.filter(y,width=41,online=FALSE)
plot(y.rr)
</code></pre>

<hr>
<h2 id='lts.filter'>
Least Trimmed Squares (LTS) filter
</h2><span id='topic+lts.filter'></span>

<h3>Description</h3>

<p>This function extracts signals from time series by means of Least Trimmed Squares regression in a moving time window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lts.filter(y, width, h = floor(width/2) + 1, online = FALSE, extrapolate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lts.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr> 
<tr><td><code id="lts.filter_+3A_width">width</code></td>
<td>
<p>a positive integer defining the window width used for fitting.<br />
If <code>online=FALSE</code> (see below) this needs to be an odd integer.</p>
</td></tr>
<tr><td><code id="lts.filter_+3A_h">h</code></td>
<td>
<p>a positive integer defining the trimming quantile.</p>
</td></tr> 
<tr><td><code id="lts.filter_+3A_online">online</code></td>
<td>
<p>a logical indicating whether the current level estimate is 
evaluated at the most recent time within each time window 
(<code>TRUE</code>) or centred within each window (<code>FALSE</code>). 
Setting <code>online=FALSE</code> requires the <code>width</code> to be odd. 
Default is <code>online=FALSE</code>.</p>
</td></tr>  
<tr><td><code id="lts.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series. <br />
If <code>online=FALSE</code> the extrapolation consists of the 
fitted values within the first half of the first window and the 
last half of the last window; if <code>online=TRUE</code> the 
extrapolation consists of the fitted values within the first 
time window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lts.filter</code> is suitable for extracting low 
frequency components (the <em>signal</em>) from a time series which 
may be contaminated with outliers and can contain level shifts. 
For this, robust Least Trimmed Squares regression is applied to a moving 
window, and the signal level is estimated by the fitted value 
either at the end of each time window for online signal 
extraction without time delay (<code>online=TRUE</code>) or in the 
centre of each time window (<code>online=FALSE</code>).
</p>


<h3>Value</h3>

<p><code>lts.filter</code> returns an object of class <code>robreg.filter</code>. 
An object of class <code>robreg.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>a data frame containing the extracted signal level.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>a data frame containing the corresponding slope within each time window.</p>
</td></tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>width</code>, <code>online</code> and <code>extrapolate</code>.
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>robreg.filter</code> returns a plot showing the original time series 
with the filtered output.
</p>


<h3>Author(s)</h3>

<p>Roland Fried, Karen Schettlinger and Matthias Borowski
</p>


<h3>References</h3>

<p>Davies, P.L., Fried, R., Gather, U. (2004) 
Robust Signal Extraction for On-Line Monitoring Data, 
<em>Journal of Statistical Planning and Inference</em> <b>122</b>, 
65-78.<br />
</p>
<p>Gather, U., Schettlinger, K., Fried, R. (2006)
Online Signal Extraction by Robust Linear Regression,
<em>Computational Statistics</em> <b>21</b>(1), 
33-51. <br />
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2006) 
Robust Filters for Intensive Care Monitoring: Beyond the Running Median,
<em>Biomedizinische Technik</em> <b>51</b>(2), 
49-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random time series:
y &lt;- cumsum(runif(500)) - .5*(1:500)
# Add jumps:
y[200:500] &lt;- y[200:500] + 5
y[400:500] &lt;- y[400:500] - 7
# Add noise:
n &lt;- sample(1:500, 30)
y[n] &lt;- y[n] + rnorm(30)

# Online filtering with LTS filter:
y.rr &lt;- lts.filter(y,width=41,online=FALSE)
plot(y.rr)
</code></pre>

<hr>
<h2 id='madore.filter'>A multivariate adaptive online repeated median filter</h2><span id='topic+madore.filter'></span>

<h3>Description</h3>

<p>Procedure for robust signal extraction from a multivariate time series by a moving window technique with adaptive window width selection (<em>m</em>ultivariate <em>ad</em>aptive <em>o</em>nline <em>re</em>peated median filter). The window width adaption is based on the univariate <code>adore.filter</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>madore.filter(Y, byrow=FALSE,
              min.width=10, max.width=200,
              test.sample.size=min.width/2,
              width.search="geometric",
              rtr.size=min.width, sign.level=0.1,
              NA.sample.size=min.width, minNonNAs=min.width/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="madore.filter_+3A_y">Y</code></td>
<td>
<p>a numeric matrix or (multivariate) time series object.</p>
</td></tr>
<tr><td><code id="madore.filter_+3A_byrow">byrow</code></td>
<td>
<p>logical. If <code>FALSE</code> (the default), the filtering is done by columns, otherwise the filtering is done by rows.</p>
</td></tr>
<tr><td><code id="madore.filter_+3A_min.width">min.width</code></td>
<td>
<p>a positive integer <code class="reqn">\ge 10</code> specifying the minimal width of the moving time window.</p>
</td></tr>
<tr><td><code id="madore.filter_+3A_max.width">max.width</code></td>
<td>
<p>a positive integer <code class="reqn">\ge</code> <code>min.width</code> specifying the maximal width of the moving time window. If <code>min.width</code> = <code>max.width</code>, the window width is fixed.</p>
</td></tr>
<tr><td><code id="madore.filter_+3A_test.sample.size">test.sample.size</code></td>
<td>
<p>a positive integer in [5, <code>min.width</code>] defining a test window of the rightmost <code>test.sample.size</code> time points within the current time window. The <em>Repeated Median</em> (RM) regression residuals within the test window are used for a goodness of fit test (see <code>adore.filter</code>) for finding an adequate window width. For more details about the test, see Schettlinger, Fried, Gather (2010).</p>
</td></tr>
<tr><td><code id="madore.filter_+3A_width.search">width.search</code></td>
<td>
<p>a character string defining the search algorithm used for finding an adequate window width at each point in time.
</p>

<dl>
<dt><code>"linear"</code></dt><dd><p>The linear search always results in the largest window width possible and hence yields 
the smoothest online signal. 
However, if sudden changes (like level shifts) appear in the signal it requires a lot of computation time
and thus, an increased variability of the extracted signal may be observed.
</p>
</dd>
<dt><code>"binary"</code></dt><dd><p>The binary search is recommended if it can be expected that the window width needs 
to be reduced drastically from a large to a very small value at certain times (for example at level shifts or trend changes).
However, it may not always result in the largest possible window width.
</p>
</dd>
<dt><code>"geometric"</code> (default)</dt><dd><p>The geometric search is as fast as the binary search
but it puts more weight on large window widths. 
It offers a good compromise between the linear and the binary search (computation time vs. smooth output signal).
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="madore.filter_+3A_rtr.size">rtr.size</code></td>
<td>
<p>a non-negative integer specifying the size of a subset of the most recent observations within each window. The signal estimation is restricted to the range of the observations within this subset.</p>
</td></tr>
<tr><td><code id="madore.filter_+3A_sign.level">sign.level</code></td>
<td>
<p>the level of significance for the goodness of fit test (see <code>adore.filter</code>) for finding an adequate window width. For more details about the test, see Schettlinger, Fried, Gather (2010).</p>
</td></tr>
<tr><td><code id="madore.filter_+3A_na.sample.size">NA.sample.size</code></td>
<td>
<p>a positive integer in [10, <code>min.width</code>] specifying the size of a subset of the most recent observations within each window. See <code>minNonNAs</code>.</p>
</td></tr>
<tr><td><code id="madore.filter_+3A_minnonnas">minNonNAs</code></td>
<td>
<p>a positive integer in [5, <code>NA.sample.size</code>]. If a variable does not offer at least <code>minNonNAs</code> non-missing observations within the subset specified by <code>NA.sample.size</code>, the signal is not estimated for this variable at this time point <code class="reqn">t</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>madore.filter</code> is based on <em>Repeated Median</em> regression (Siegel, 1982) in moving time windows and serves for separating signals from noise and outliers in multivariate time series. At each time point <code class="reqn">t</code> the test procedure of the <em>adaptive online Repeated Median</em> filter (Schettlinger, Fried, Gather, 2010) is used to determine an appropriate window width <code class="reqn">n(t)</code> in [<code>min.width</code>, <code>max.width</code>]. Then the signal vector at time <code class="reqn">t</code> is estimated within the time window <code class="reqn">(t-n(t)+1,\ldots,t)</code> by a slight modification of the multivariate <em>Trimmed Repeated Median-Least Squares</em> regression (Lanius, Gather, 2010). A more detailed description of the <code>madore.filter</code> can be found in Borowski, Schettlinger, Gather (2009).</p>


<h3>Value</h3>

<p><code>madore.filter</code> returns an object of class <code>madore.filter</code>. An object of class <code>madore.filter</code> is a list containing the following components:
</p>
<table>
<tr><td><code>signals</code></td>
<td>
<p>a matrix containing the estimated signal vectors at each time point <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code>widths</code></td>
<td>
<p>a matrix containing the individual window widths of each variable at each time point <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code>overall.width</code></td>
<td>
<p>a vector containing the overall window widths at each time point <code class="reqn">t</code>.</p>
</td></tr>
</table>
<p>In addition, the original input data is returned as list member <code>Y</code>, and the settings used for the analysis are returned as the list members <code>byrow</code>, <code>min.width</code>, <code>max.width</code>, <code>start.width</code>, <code>test.sample.size</code>, <code>width.search</code>, <code>rtr.size</code>, <code>extr.delay</code>, <code>NA.sample.size</code>, and <code>minNonNAs</code>. Application of the function <code>plot</code> to an object of class <code>madore.filter</code> returns a plot showing the original multivariate time series with the filtered output.
</p>


<h3>Author(s)</h3>

<p>Matthias Borowski</p>


<h3>References</h3>

<p>Borowski, M., Schettlinger, K., Gather, U. (2009)
Multivariate Real Time Signal Extraction by a Robust Adaptive Regression Filter, <em>Communications in Statistics - Simulation and Computation</em> <b>38</b>, 426-440.<br />
</p>
<p>Lanius, V., Gather, U. (2010)
Robust Online Signal Extraction from Multivariate Time Series, 
<em>Computational Statistics and Data Analysis</em> <b>54</b>(4), 966-975.<br />
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2010) 
Real Time Signal Processing by Adaptive Repeated Median Filters,
<em>International Journal of Adaptive Control and Signal Processing</em> <b>24</b>(5), 346-362.<br />
</p>
<p>Siegel, A.F. (1982)
Robust Regression Using Repeated Medians, 
<em>Biometrika</em> <b>69</b>(1), 242-244.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>, <code><a href="#topic+adore.filter">adore.filter</a></code>, <code><a href="#topic+scarm.filter">scarm.filter</a></code>, <code><a href="#topic+mscarm.filter">mscarm.filter</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(multi.ts)
extr &lt;- madore.filter(multi.ts)
plot(extr)

## End(Not run)   
</code></pre>

<hr>
<h2 id='med.filter'>
Median (MED) filter
</h2><span id='topic+med.filter'></span>

<h3>Description</h3>

<p>This function extracts signals from time series by means of a running median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>med.filter(y, width, minNonNAs = 5, online = FALSE, extrapolate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="med.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr> 
<tr><td><code id="med.filter_+3A_width">width</code></td>
<td>
<p>a positive integer defining the window width used for fitting.<br />
If <code>online=FALSE</code> (see below) this needs to be an odd integer.</p>
</td></tr>
<tr><td><code id="med.filter_+3A_minnonnas">minNonNAs</code></td>
<td>
<p>a positive integer defining the minimum number of
non-missing observations within one window which is required 
for a &lsquo;sensible&rsquo; estimation.</p>
</td></tr>  
<tr><td><code id="med.filter_+3A_online">online</code></td>
<td>
<p>a logical indicating whether the current level estimate is 
evaluated at the most recent time within each time window 
(<code>TRUE</code>) or centred within each window (<code>FALSE</code>). 
Setting <code>online=FALSE</code> requires the <code>width</code> to be odd. 
Default is <code>online=FALSE</code>.</p>
</td></tr>  
<tr><td><code id="med.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series. <br />
If <code>online=FALSE</code> the extrapolation consists of the 
fitted values within the first half of the first window and the 
last half of the last window; if <code>online=TRUE</code> the 
extrapolation consists of the fitted values within the first 
time window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>med.filter</code> is suitable for extracting low 
frequency components (the <em>signal</em>) from a time series which 
may be contaminated with outliers and can contain level shifts. 
For this, the median is computed in a moving 
window, and the signal level is estimated either at the end of each time window for online signal 
extraction without time delay (<code>online=TRUE</code>) or in the 
centre of each time window (<code>online=FALSE</code>).
</p>


<h3>Value</h3>

<p><code>med.filter</code> returns an object of class <code>robreg.filter</code>. 
An object of class <code>robreg.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>a data frame containing the extracted signal level.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>a data frame containing the corresponding slope within each time window.</p>
</td></tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>width</code>, <code>minNonNAs</code>, 
<code>online</code> and <code>extrapolate</code>. 
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>robreg.filter</code> returns a plot showing the original time series 
with the filtered output. 
</p>


<h3>Note</h3>

<p>Missing values are treated by omitting them and thus by reducing 
the corresponding window width. The signal estimation is 
only returned as <code>NA</code> if the window the estimation is based 
on contains less than <code>minNonNAs</code> non-missing values.
</p>


<h3>Author(s)</h3>

<p>Roland Fried, Karen Schettlinger and Matthias Borowski
</p>


<h3>References</h3>

<p>Davies, P.L., Fried, R., Gather, U. (2004) 
Robust Signal Extraction for On-Line Monitoring Data, 
<em>Journal of Statistical Planning and Inference</em> <b>122</b>, 
65-78.<br />
</p>
<p>Gather, U., Schettlinger, K., Fried, R. (2006)
Online Signal Extraction by Robust Linear Regression,
<em>Computational Statistics</em> <b>21</b>(1), 
33-51. <br />
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2006) 
Robust Filters for Intensive Care Monitoring: Beyond the Running Median,
<em>Biomedizinische Technik</em> <b>51</b>(2), 
49-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random time series:
y &lt;- cumsum(runif(500)) - .5*(1:500)
# Add jumps:
y[200:500] &lt;- y[200:500] + 5
y[400:500] &lt;- y[400:500] - 7
# Add noise:
n &lt;- sample(1:500, 30)
y[n] &lt;- y[n] + rnorm(30)

# Online filtering with MED filter:
y.rr &lt;- med.filter(y,width=41,online=FALSE)
plot(y.rr)
</code></pre>

<hr>
<h2 id='mscarm.filter'>MSCARM (Multivariate Slope Comparing Adaptive Repeated Median)</h2><span id='topic+mscarm.filter'></span>

<h3>Description</h3>

<p>A multivariate version of the <code>scarm.filter</code> which also gives information about parallel running components of the multivariate time series</p>


<h3>Usage</h3>

<pre><code class='language-R'>mscarm.filter(time.series,
              right.width=30, min.left.width=right.width,
              min.width=floor(right.width/3), max.width=200,
              sign.level=0.001, bound.noise.sd=0.01,
              rtr=TRUE, autocorrelations="automatic",
              c.bound=3, r.bound=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mscarm.filter_+3A_time.series">time.series</code></td>
<td>
<p>a numeric matrix or multivariate time series object.</p>
</td></tr>
<tr><td><code id="mscarm.filter_+3A_right.width">right.width</code></td>
<td>
<p>a positive integer <code class="reqn">\ge 5</code> defining the fixed width of the right-hand window used for the SCARM test; the choice of <code>right.width</code> is crucial to distinguish between a patch of outliers and a signal change.</p>
</td></tr>
<tr><td><code id="mscarm.filter_+3A_min.left.width">min.left.width</code></td>
<td>
<p>a positive integer <code class="reqn">\ge</code> <code>right.width</code> defining the minimum width of the left-hand window used for testing.</p>
</td></tr>
<tr><td><code id="mscarm.filter_+3A_min.width">min.width</code></td>
<td>
<p>a positive integer <code class="reqn">\ge 5</code> specifying the minimum window width.</p>
</td></tr>
<tr><td><code id="mscarm.filter_+3A_max.width">max.width</code></td>
<td>
<p>a positive integer <code class="reqn">\ge</code> <code>min.width</code> and <code class="reqn">\ge</code> <code>right.width</code> + <code>min.left.width</code> specifying the maximum window width.</p>
</td></tr>
<tr><td><code id="mscarm.filter_+3A_sign.level">sign.level</code></td>
<td>
<p>significance level of the SCARM test procedure; must be a value in <code class="reqn">(0,0.5)</code>.</p>
</td></tr>
<tr><td><code id="mscarm.filter_+3A_bound.noise.sd">bound.noise.sd</code></td>
<td>
<p>a lower bound for the estimate of the noise standard deviation; this bound ensures that the noise scale estimate cannot be zero due to ties in the data; must be a value <code class="reqn">&gt; 0</code>.</p>
</td></tr>
<tr><td><code id="mscarm.filter_+3A_rtr">rtr</code></td>
<td>
<p>if <code>rtr=TRUE</code>, the signal estimation is restricted to the range of the rightmost <code>min.width</code> observations.</p>
</td></tr>
<tr><td><code id="mscarm.filter_+3A_autocorrelations">autocorrelations</code></td>
<td>
<p>the <code>mscarm.filter</code> is developed for non-autocorrelated data, but can be adapted to work for AR(1) processes with parameter <code class="reqn">\phi = -0.9,-0.6,...,0.9</code>; <code>autocorrelations</code> must be either &quot;no&quot; (<code class="reqn">\phi=0</code>), &quot;high.positive&quot; (<code class="reqn">\phi=0.9</code>), &quot;moderate.positive&quot; (<code class="reqn">\phi=0.6</code>), &quot;small.positive&quot; (<code class="reqn">\phi=0.3</code>), &quot;small.negative&quot; (<code class="reqn">\phi=-0.3</code>), &quot;moderate.negative (<code class="reqn">\phi=-0.6</code>)&quot;, &quot;high.negative (<code class="reqn">\phi=-0.9</code>)&quot; or &quot;automatic&quot;; if <code>autocorrelations="automatic"</code>, the true parameter <code class="reqn">\phi</code> is estimated at each time point.</p>
</td></tr>
<tr><td><code id="mscarm.filter_+3A_c.bound">c.bound</code></td>
<td>
<p>the bound for the SSM (Similar Slope Monitoring) statistic which is the absolute difference of RM (Repeated Median) trend estimates (of two univariate time series) relative to the estimated standard deviation of this difference; if the SSM statistic is not larger than <code>c.bound</code>, a relationship between the two time series is assumed; <code>c.bound</code> must be a value &gt;0.</p>
</td></tr>
<tr><td><code id="mscarm.filter_+3A_r.bound">r.bound</code></td>
<td>
<p>the bound for the ratio of adapted window widths (of two univariate time series); a relationship between the two time series is only possible, if this ratio (smaller window width divided by larger window width) is smaller than <code>r.bound</code>; <code>r.bound</code> must be a value in <code class="reqn">[0,1]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mscarm.filter</code> is a procedure for real-time signal extraction from noisy and outlier-contaminated instationary multivariate time series. It is based on <em>Repeated Median</em> regression (Siegel, 1982) in moving time windows. At each time point <code class="reqn">t</code> the test procedure of the SCARM filter (Borowski and Fried, 2011) is used to determine an appropriate window width <code class="reqn">n(t)</code> in [<code>min.width</code>, <code>max.width</code>]. Then the signal vector at time <code class="reqn">t</code> is estimated within the time window <code class="reqn">(t-n(t)+1,\ldots,t)</code> by a slight modification of the multivariate <em>Trimmed Repeated Median-Least Squares</em> regression (Lanius, Gather, 2010). At each time point <code class="reqn">t</code>, the <code>mscarm.filter</code> uses the <em>Similar Slope Monitoring</em> (SSM) method to build blocks of currently interrelated univariate time series. This information is given to the user and is used to improve the signal estimations. A detailed description of the <code>mscarm.filter</code> can be found in Borowski (2012).
</p>


<h3>Value</h3>

<p><code>mscarm.filter</code> returns an object of class <code>mscarm.filter</code>.  
An object of class <code>mscarm.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>signal.est</code></td>
<td>
<p>a matrix containing the signal estimations</p>
</td></tr>
<tr><td><code>slope.est</code></td>
<td>
<p>a matrix containing the slope (or trend) estimations</p>
</td></tr>
<tr><td><code>adapted.width</code></td>
<td>
<p>a matrix containing the adapted window widths</p>
</td></tr>
<tr><td><code>noise.sd.est</code></td>
<td>
<p>a matrix containing the estimated noise standard deviations</p>
</td></tr>
<tr><td><code>scarm.signal.est</code></td>
<td>
<p>a matrix containing the signal estimates of the univariate SCARM</p>
</td></tr>
<tr><td><code>scarm.width</code></td>
<td>
<p>a matrix containing the adapted window widths of the univariate SCARM</p>
</td></tr>
<tr><td><code>scarm.statistic</code></td>
<td>
<p>a matrix containing the SCARM test statistics</p>
</td></tr>
<tr><td><code>scarm.critval</code></td>
<td>
<p>a matrix containing the critical values of the SCARM test</p>
</td></tr>
<tr><td><code>ssm.statistic</code></td>
<td>
<p>a matrix containing the SSM statistics</p>
</td></tr>
<tr><td><code>blocks</code></td>
<td>
<p>a matrix of the blocks built by the SSM procedure</p>
</td></tr>
<tr><td><code>acf.lag.one</code></td>
<td>
<p>a matrix containing the estimated autocorrelations at lag one for each time point; estimation is done on the recent <code>max.width</code> observations at each time point</p>
</td></tr>
<tr><td><code>time.series</code></td>
<td>
<p>the original input data</p>
</td></tr>
</table>
<p>In addition, the input arguments used for the analysis are returned as list members.
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>mscarm.filter</code> returns a plot showing the original time series 
with the filtered output. If <code>info==TRUE</code> (default), a plot showing the results of the SSM procedure is given.
</p>


<h3>Author(s)</h3>

<p>Matthias Borowski</p>


<h3>References</h3>

 
<p>Borowski, M. (2012)
Echtzeit-Extraktion relevanter Information aus multivariaten Zeitreihen basierend auf robuster Regression, <em>PhD thesis, TU Dortmund University (in German)</em>.<br />
</p>
<p>Borowski, M. and Fried, R. (2011)
Robust repeated median regression in moving windows with data-adaptive width selection, <em>Discussion Paper 28/2011, SFB 823, TU Dortmund University</em>.<br />
</p>
<p>Lanius, V., Gather, U. (2010)
Robust Online Signal Extraction from Multivariate Time Series, 
<em>Computational Statistics and Data Analysis</em> <b>54</b>(4), 966-975.<br />
</p>
<p>Siegel, A.F. (1982)
Robust Regression Using Repeated Medians,
<em>Biometrika</em> <b>69</b>(1), 242-244.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>, <code><a href="#topic+adore.filter">adore.filter</a></code>, <code><a href="#topic+madore.filter">madore.filter</a></code>, <code><a href="#topic+scarm.filter">scarm.filter</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Multivariate time series
data(multi.ts)

# apply MSCARM Filter 
mscarm.extr &lt;- mscarm.filter(multi.ts)
plot(mscarm.extr)

## End(Not run)
</code></pre>

<hr>
<h2 id='multi.ts'>Generated Multivariate Time Series</h2><span id='topic+multi.ts'></span>

<h3>Description</h3>

<p>This data matrix contains a 4-variate time series of length 500. It consists of two Blocks and two Doppler signals each overlaid by highly correlated bivariate Gaussian noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi.ts</code></pre>


<h3>Format</h3>

<p>A (500x4)-matrix containing a 4-variate time series of length 500.</p>


<h3>Source</h3>

<p>Data generated by means of the packages <code>wmtsa</code> and <code>MASS</code>.</p>

<hr>
<h2 id='rm.filter'>
Repeated Median (RM) filter
</h2><span id='topic+rm.filter'></span>

<h3>Description</h3>

<p>This function extracts signals from time series by means of Repeated Median regression in a moving time window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.filter(y, width, minNonNAs = 5, online = FALSE, extrapolate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr> 
<tr><td><code id="rm.filter_+3A_width">width</code></td>
<td>
<p>a positive integer defining the window width used for fitting.<br />
If <code>online=FALSE</code> (see below) this needs to be an odd integer.</p>
</td></tr>
<tr><td><code id="rm.filter_+3A_minnonnas">minNonNAs</code></td>
<td>
<p>a positive integer defining the minimum number of
non-missing observations within one window which is required 
for a &lsquo;sensible&rsquo; estimation.</p>
</td></tr>  
<tr><td><code id="rm.filter_+3A_online">online</code></td>
<td>
<p>a logical indicating whether the current level estimate is 
evaluated at the most recent time within each time window 
(<code>TRUE</code>) or centred within each window (<code>FALSE</code>). 
Setting <code>online=FALSE</code> requires the <code>width</code> to be odd. 
Default is <code>online=FALSE</code>.</p>
</td></tr>  
<tr><td><code id="rm.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series. <br />
If <code>online=FALSE</code> the extrapolation consists of the 
fitted values within the first half of the first window and the 
last half of the last window; if <code>online=TRUE</code> the 
extrapolation consists of the fitted values within the first 
time window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rm.filter</code> is suitable for extracting low 
frequency components (the <em>signal</em>) from a time series which 
may be contaminated with outliers and can contain level shifts. 
For this, robust Repeated Median regression is applied to a moving 
window, and the signal level is estimated by the fitted value 
either at the end of each time window for online signal 
extraction without time delay (<code>online=TRUE</code>) or in the 
centre of each time window (<code>online=FALSE</code>).
</p>


<h3>Value</h3>

<p><code>rm.filter</code> returns an object of class <code>robreg.filter</code>. 
An object of class <code>robreg.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>a data frame containing the extracted signal level.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>a data frame containing the corresponding slope within each time window.</p>
</td></tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>width</code>, <code>minNonNAs</code>, 
<code>online</code> and <code>extrapolate</code>. 
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>robreg.filter</code> returns a plot showing the original time series 
with the filtered output. 
</p>


<h3>Note</h3>

<p>Missing values are treated by omitting them and thus by reducing 
the corresponding window width. The estimated signal level is 
only returned as <code>NA</code> if the window the estimation is based 
on contains less than <code>minNonNAs</code> non-missing values.
</p>


<h3>Author(s)</h3>

<p>Roland Fried, Karen Schettlinger and Matthias Borowski
</p>


<h3>References</h3>

<p>Davies, P.L., Fried, R., Gather, U. (2004) 
Robust Signal Extraction for On-Line Monitoring Data, 
<em>Journal of Statistical Planning and Inference</em> <b>122</b>, 
65-78.<br />
</p>
<p>Gather, U., Schettlinger, K., Fried, R. (2006)
Online Signal Extraction by Robust Linear Regression,
<em>Computational Statistics</em> <b>21</b>(1), 
33-51. <br />
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2006) 
Robust Filters for Intensive Care Monitoring: Beyond the Running Median,
<em>Biomedizinische Technik</em> <b>51</b>(2), 
49-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a>,<a href="#topic+scarm.filter">scarm.filter</a>,<a href="#topic+adore.filter">adore.filter</a>,<a href="#topic+madore.filter">madore.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random time series:
y &lt;- cumsum(runif(500)) - .5*(1:500)
# Add jumps:
y[200:500] &lt;- y[200:500] + 5
y[400:500] &lt;- y[400:500] - 7
# Add noise:
n &lt;- sample(1:500, 30)
y[n] &lt;- y[n] + rnorm(30)

# Online filtering with RM filter:
y.rr &lt;- rm.filter(y,width=41,online=TRUE)
plot(y.rr)
</code></pre>

<hr>
<h2 id='robreg.filter'>Robust Regression Filters for Univariate Time Series</h2><span id='topic+robreg.filter'></span>

<h3>Description</h3>

<p> Procedures for robust (online) extraction of low 
frequency components (the <em>signal</em>) from a univariate time 
series by applying robust regression techniques to moving time 
windows. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robreg.filter(y, width, method = "all", h = floor(width/2)+1,   
                 minNonNAs = 5, online = FALSE, extrapolate = TRUE)

</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="robreg.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr> 
<tr><td><code id="robreg.filter_+3A_width">width</code></td>
<td>
<p>a positive integer defining the window width used for fitting.<br />
If <code>online=FALSE</code> (see below) this needs to be an odd integer.</p>
</td></tr>
<tr><td><code id="robreg.filter_+3A_method">method</code></td>
<td>
<p>a (vector of) character string(s) containing the method(s) to be used for robust 
approximation of the signal within one time window. 
It is possible to specify any combination of the values:
</p>
<dl>
<dt><code>"DR"</code></dt><dd><p>Deepest Regression</p>
</dd>
<dt><code>"LMS"</code></dt><dd><p>Least Median of Squares regression</p>
</dd> 
<dt><code>"LQD"</code></dt><dd><p>Least Quartile Difference regression</p>
</dd>
<dt><code>"LTS"</code></dt><dd><p>Least Trimmed Squares regression</p>
</dd>
<dt><code>"MED"</code></dt><dd><p>Median</p>
</dd>
<dt><code>"RM"</code></dt><dd><p>Repeated Median regression</p>
</dd>
<dt><code>"all"</code></dt><dd><p>all of the above (default)</p>
</dd> 
</dl>
 
<p>Using <code>dr.filter</code>, <code>lms.filter</code>, <code>lqd.filter</code>, <code>lts.filter</code>, <code>med.filter</code> or <code>rm.filter</code>
forces <code>"DR"</code>, <code>"LMS"</code>, <code>"LQD"</code>, <code>"LTS"</code>, <code>"MED"</code> or <code>"RM"</code> respectively. <br />
Currently, only <code>method="MED"</code> and <code>method="RM"</code> (<code>med.filter</code> / <code>rm.filter</code>) 
can handle missing values in the input time series.
For the other regression filters missing values have to be replaced before the analysis.
</p>
</td></tr>
<tr><td><code id="robreg.filter_+3A_h">h</code></td>
<td>
<p>a positive integer defining the trimming quantile for 
LTS regression.</p>
</td></tr>
<tr><td><code id="robreg.filter_+3A_minnonnas">minNonNAs</code></td>
<td>
<p>a positive integer defining the minimum number of
non-missing observations within one window which is required 
for a &lsquo;sensible&rsquo; estimation. 
Currently, this option only has an effect for the two methods <code>"MED"</code> and /or <code>"RM"</code> (see <code>method</code>).</p>
</td></tr>
<tr><td><code id="robreg.filter_+3A_online">online</code></td>
<td>
<p>a logical indicating whether the current level estimate is 
evaluated at the most recent time within each time window 
(<code>TRUE</code>) or centred within each window (<code>FALSE</code>). 
Setting <code>online=FALSE</code> requires the <code>width</code> to be odd. 
Default is <code>online=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="robreg.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series. <br />
If <code>online=FALSE</code> the extrapolation consists of the 
fitted values within the first half of the first window and the 
last half of the last window; if <code>online=TRUE</code> the 
extrapolation consists of the fitted values within the first 
time window. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>robreg.filter</code> is suitable for extracting low 
frequency components (the <em>signal</em>) from a time series which 
may be contaminated with outliers and can contain level shifts. 
For this, robust regression methods are applied to a moving 
window, and the signal level is estimated by the fitted value 
either at the end of each time window for online signal 
extraction without time delay (<code>online=TRUE</code>) or in the 
centre of each time window (<code>online=FALSE</code>).</p>


<h3>Value</h3>

<p><code>robreg.filter</code> returns an object of class <code>robreg.filter</code>. 
An object of class <code>robreg.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>a data frame containing the signal level extracted by the filter(s) specified in <code>method</code>.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>a data frame containing the corresponding slope within each time window.</p>
</td></tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>width</code>, <code>method</code>, 
<code>h</code>, <code>minNonNAs</code>, <code>online</code> and <code>extrapolate</code>. 
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>robreg.filter</code> returns a plot showing the original time series 
with the filtered output. 
</p>


<h3>Note</h3>

<p>Missing values are treated by omitting them and thus by reducing 
the corresponding window width. The estimated signal level is 
only returned as <code>NA</code> if the window the estimation is based 
on contains less than <code>minNonNAs</code> non-missing values.
</p>


<h3>Author(s)</h3>

<p>C++ code: Thorsten Bernholt and Robin Nunkesser<br />
Port to R: Roland Fried and Karen Schettlinger</p>


<h3>References</h3>

 
<p>Davies, P.L., Fried, R., Gather, U. (2004) 
Robust Signal Extraction for On-Line Monitoring Data, 
<em>Journal of Statistical Planning and Inference</em> <b>122</b>, 
65-78.<br />
(earlier version: <a href="http://hdl.handle.net/2003/5043">http://hdl.handle.net/2003/5043</a>)
</p>
<p>Gather, U., Schettlinger, K., Fried, R. (2006)
Online Signal Extraction by Robust Linear Regression,
<em>Computational Statistics</em> <b>21</b>(1), 
33-51. <br />
(earlier version: <a href="http://hdl.handle.net/2003/5305">http://hdl.handle.net/2003/5305</a>)
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2006) 
Robust Filters for Intensive Care Monitoring: Beyond the Running Median,
<em>Biomedizinische Technik</em> <b>51</b>(2), 
49-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wrm.filter">wrm.filter</a></code>, <code><a href="#topic+robust.filter">robust.filter</a></code>, <code><a href="#topic+dw.filter">dw.filter</a></code>, <code><a href="#topic+hybrid.filter">hybrid.filter</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random time series:
y &lt;- cumsum(runif(500)) - .5*(1:500)
# Add jumps:
y[200:500] &lt;- y[200:500] + 5
y[400:500] &lt;- y[400:500] - 7
# Add noise:
n &lt;- sample(1:500, 30)
y[n] &lt;- y[n] + rnorm(30)

# Filtering with all methods:
y.rr &lt;- robreg.filter(y, width=31, method=c("RM", "LMS", "LTS", "DR", "LQD"))
# Plot:
plot(y.rr)

# Delayed filtering with RM and LMS filter:
y2.rr &lt;- robreg.filter(y,width=31,method=c("RM","LMS"))
plot(y2.rr)

# Online filtering with RM filter:
y3.rr &lt;- rm.filter(y,width=41,online=TRUE)
plot(y3.rr)
</code></pre>

<hr>
<h2 id='robust.filter'>Robust Filtering Methods for Univariate Time Series</h2><span id='topic+robust.filter'></span>

<h3>Description</h3>

 
<p>Procedure for robust (online) extraction of low frequency
components (the <em>signal</em>) from a univariate time series with
optional rules for outlier replacement and shift detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust.filter(y, width, trend = "RM", scale = "QN", outlier = "T", 
                        shiftd = 2, wshift = floor(width/2), lbound = 0.1, p = 0.9,
                        adapt = 0, max.width = width, 
                        online = FALSE, extrapolate = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robust.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr>
<tr><td><code id="robust.filter_+3A_width">width</code></td>
<td>
<p>a positive integer defining the window width used for fitting.
If <code>online=FALSE</code> (default) this needs to be an odd number.</p>
</td></tr>
<tr><td><code id="robust.filter_+3A_trend">trend</code></td>
<td>
<p>a character string defining the method to be used for robust approximation of the signal 
within one time window. Possible values are:<br />
</p>

<dl>
<dt><code>"MED"</code>:</dt><dd><p>Median</p>
</dd>
<dt><code>"RM"</code>:</dt><dd><p>Repeated Median regression (default)</p>
</dd>
<dt><code>"LTS"</code>:</dt><dd><p>Least Trimmed Squares regression</p>
</dd>
<dt><code>"LMS"</code>:</dt><dd><p>Least Median of Squares regression</p>
</dd> 
</dl>

</td></tr>
<tr><td><code id="robust.filter_+3A_scale">scale</code></td>
<td>
<p>a character string defining the method to be used for robust estimation of the local 
variability (within one time window). 
Possible values are:<br />
</p>

<dl>
<dt><code>"MAD"</code>:</dt><dd><p>Median absolute deviation about the median</p>
</dd>
<dt><code>"QN"</code>:</dt><dd><p>Rousseeuw's and Croux' (1993) <code class="reqn">Q_n</code> scale estimator (default)</p>
</dd>
<dt><code>"SN"</code>:</dt><dd><p>Rousseeuw's and Croux' (1993) <code class="reqn">S_n</code> scale estimator</p>
</dd>
<dt><code>"LSH"</code>:</dt><dd><p>Length of the shortest half</p>
</dd>   
</dl>

</td></tr>
<tr><td><code id="robust.filter_+3A_outlier">outlier</code></td>
<td>
<p>a single character defining the rule to be used for outlier detection and outlier treatment. 
Observations deviating more than <code class="reqn">d\cdot \hat{\sigma}_t</code> 
from the current level approximation <code class="reqn">\hat{\mu}_t</code> 
are replaced by <code class="reqn">\hat{\mu}_t\pm k\hat{\sigma}_t</code>
where <code class="reqn">\hat{\sigma}_t</code> denotes the current scale estimate. <br />
Possible values are:<br />
</p>

<dl>
<dt><code>"T"</code>:</dt><dd><p>Replace ('trim') large outliers detected by a <code class="reqn">3\sigma</code>-rule 
(<code class="reqn">d=3</code>) by the current level estimate (<code class="reqn">k=0</code>). (default)</p>
</dd>
<dt><code>"L"</code>:</dt><dd><p>Shrink large outliers (<code class="reqn">d=3</code>) strongly 
towards the current level estimate (<code class="reqn">k=1</code>).</p>
</dd>
<dt><code>"M"</code>:</dt><dd><p>Shrink large and moderatly sized outliers (<code class="reqn">d=2</code>) strongly 
towards the current level estimate (<code class="reqn">k=1</code>).</p>
</dd>
<dt><code>"W"</code>:</dt><dd><p>Shrink large and moderatly sized outliers (<code class="reqn">d=2</code>) 
towards the current level estimate (<code class="reqn">k=2</code>).</p>
</dd>
</dl>

<p><code>W</code> is the most efficient, <code>T</code> the most robust method (which should ideally 
be combined with a suitable value of <code>lbound</code>).  </p>
</td></tr>
<tr><td><code id="robust.filter_+3A_shiftd">shiftd</code></td>
<td>
<p>a positive numeric value defining the factor the current scale estimate is multiplied 
with for shift detection. Default is <code>shiftd</code>=2 
corresponding to a <code class="reqn">2\sigma</code> rule for shift detection.</p>
</td></tr>
<tr><td><code id="robust.filter_+3A_wshift">wshift</code></td>
<td>
<p>a positive integer specifying the number of the most recent observations used for shift detection
(regulates therefore also the delay of shift detection). Only used
in the <code>online</code> mode; should be less than half the (minimal)
window width then. In the offline mode (<code>online=FALSE</code>, default), shift
detection is based on the right half of the time window, i.e. <code>wshift=floor(width/2)</code> (default).</p>
</td></tr>
<tr><td><code id="robust.filter_+3A_lbound">lbound</code></td>
<td>
<p>a positive real value specifying an optional lower bound for the scale to prevent 
the scale estimate from reaching zero (implosion). </p>
</td></tr> 
<tr><td><code id="robust.filter_+3A_p">p</code></td>
<td>
<p>a fraction <code class="reqn">\in [2/3,1]</code> of observations 
for additional rules in case of only two or three different values 
within one window.<br />
If 100 percent of the observations within one window take on 
only two different values, the current level is estimated by the 
mean of these values regardless of the <code>trend</code> 
specification. In case of three differing values the median is 
taken as the current level estimate.</p>
</td></tr>
<tr><td><code id="robust.filter_+3A_adapt">adapt</code></td>
<td>
<p>a numeric value  defining the fraction which regulates the adaption of the
moving window width. <code>adapt</code> can be either 0 or a value <code class="reqn">\in [0.6,1]</code> . 
<code>adapt = 0</code> means that a fixed window width is used. 
Otherwise, the window width is reduced whenever more than a fraction of 
<code>adapt</code> <code class="reqn">\in [0.6,1]</code> of the residuals in a
certain part of the current time window are all positive or all
negative.</p>
</td></tr>
<tr><td><code id="robust.filter_+3A_max.width">max.width</code></td>
<td>
<p>a positive integer (<code>&gt;= width</code>) specifying the maximal width of the time window.<br />
<code>width</code> specifies the minimal (and also the initial) width.</p>
</td></tr>
<tr><td><code id="robust.filter_+3A_online">online</code></td>
<td>
<p>a logical indicating whether the current level and 
scale estimates are evaluated at the most recent time 
within each window (<code>TRUE</code>) or centered within the window 
(<code>FALSE</code>). <code>online=FALSE</code> (default) requires an odd 
<code>width</code> for the window and means a time delay of 
(<code>width</code>+1)/2 time units.</p>
</td></tr>
<tr><td><code id="robust.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series. <br />
If <code>online=FALSE</code> the extrapolation consists of the 
fitted values within the first half of the first window and the 
last half of the last window; if <code>online=TRUE</code> the 
extrapolation consists of all fitted values within the first 
time window. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>robust.filter</code> works by applying the methods 
specified by <code>trend</code> and <code>scale</code> to a moving time 
window of length <code>width</code>.
</p>
<p>Before moving the time window, it is checked whether the next 
(incoming) observation is considered an 'outlier' by applying the 
rule specified by <code>outlier</code>. Therefore, the trend in the 
current time window is extrapolated to the next point in time and 
the residual of the incoming observation is standardised by the 
current scale estimate.
</p>
<p>After moving the time window, it can be tested whether a level 
shift has occurred within the window: If more than half of the 
residuals in the right part of the window are larger than 
<code>shiftd</code><code class="reqn">\cdot\sigma_t</code>, a shift is detected and 
appropriate actions are taken. In
the <code>online</code> mode, the number of the rightmost residuals can be
chosen by <code>wshift</code> to regulate the resistance of the detection
rule against outliers, its power and the time delay of detection.
</p>
<p>A more detailed description of the filter can be found in Fried 
(2004). The adaption of the window width is described by Gather and
Fried (2004). For more explanations on shift detection, see Fried
and Gather (2007).</p>


<h3>Value</h3>

 
<p><code>robust.filter</code> returns an object of class <code>robust.filter</code>.  
An object of class <code>robust.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>level</code></td>
<td>
<p>a numeric vector containing the signal level extracted by the (regression) filter specified by <code>trend</code>, <code>scale</code> and <code>outlier</code>.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>a numeric vector containing the corresponding slope within each time window.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a numeric vector containing the corresponding scale within each time window.</p>
</td></tr>
<tr><td><code>ol</code></td>
<td>
<p>an outlier indicator. 
0: no outlier, +1: positive outlier, -1: negative outlier</p>
</td></tr>
<tr><td><code>level.shift</code></td>
<td>
<p>a level shift indicator.
0: no level shift, t: positive level shift detected at processing
time t, -t: negative level shift detected at processing time t (the
position in the vector gives an estimate of the point in time before
which the shift has occurred).
</p>
</td></tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>width</code>, <code>trend</code>, 
<code>scale</code>, <code>outlier</code>, <code>shiftd</code>, 
<code>wshift</code>, <code>lbound</code>, 
<code>p</code>, <code>adapt</code>, <code>max.width</code>, <code>online</code> and <code>extrapolate</code>. 
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>robust.filter</code> returns a plot showing the original time series 
with the filtered output. 
</p>


<h3>Note</h3>

<p>Missing values have to be replaced or removed from the time series 
before applying <code>robust.filter</code>.
</p>


<h3>Author(s)</h3>

<p>Roland Fried and Karen Schettlinger</p>


<h3>References</h3>

 
<p>Fried, R. (2004), Robust Filtering of Time Series with 
Trends, <em>Journal of Nonparametric Statistics</em> <b>16</b>, 
313-328.<br />
(earlier version: <a href="http://hdl.handle.net/2003/4992">http://hdl.handle.net/2003/4992</a>)
</p>
<p>Fried, R., Gather, U. (2007), On Rank Tests for Shift Detection in Time Series, 
<em>Computational Statistics and Data Analysis, Special Issue on Machine Learning and Robust Data Mining</em> <b>52</b>, 221-233.<br />
(earlier version: <a href="http://hdl.handle.net/2003/23301">http://hdl.handle.net/2003/23301</a>) 
</p>
<p>Gather, U., Fried, R. (2004), Methods and Algorithms for Robust Filtering, 
<em>COMPSTAT 2004: Proceedings in Computational Statistics</em>, J. Antoch (eds.), Physika-Verlag, Heidelberg, 159-170. <br /> 
</p>
<p>Schettlinger, K., Fried, R., Gather, U. (2006) Robust Filters
for Intensive Care Monitoring: Beyond the Running Median,
<em>Biomedizinische Technik</em> <b>51</b>(2), 49-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>, <code><a href="#topic+hybrid.filter">hybrid.filter</a></code>, <code><a href="#topic+dw.filter">dw.filter</a></code>, <code><a href="#topic+wrm.filter">wrm.filter</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random time series:
y &lt;- cumsum(runif(500)) - .5*(1:500)
# Add jumps:
y[200:500] &lt;- y[200:500] + 5
y[400:500] &lt;- y[400:500] - 7
# Add noise:
n &lt;- sample(1:500, 30)
y[n] &lt;- y[n] + rnorm(30)

# Delayed Filtering of the time series with window width 23:
y.rf &lt;- robust.filter(y, width=23)
# Plot:
plot(y.rf)

# Delayed Filtering with different settings and fixed window width 31:
y.rf2 &lt;- robust.filter(y, width=31, trend="LMS", scale="QN", outlier="W")
plot(y.rf2)

# Online Filtering with fixed window width 24:
y.rf3 &lt;- robust.filter(y, width=24, online=TRUE)
plot(y.rf3)

# Delayed Filtering with adaptive window width (minimal width 11, maximal width 51):
y.rf4 &lt;- robust.filter(y, width=11, adapt=0.7, max.width=51)
plot(y.rf4)
</code></pre>

<hr>
<h2 id='scarm.filter'>SCARM (Slope Comparing Adaptive Repeated Median)</h2><span id='topic+scarm.filter'></span>

<h3>Description</h3>

<p>A procedure for robust online signal extraction from univariate time series (&quot;smoothing&quot;) by a moving window technique with adaptive window width selection based on Repeated Median regression</p>


<h3>Usage</h3>

<pre><code class='language-R'>scarm.filter(time.series,
             right.width=30, min.left.width=right.width,
             min.width=floor(right.width/3), max.width=200,
             sign.level=0.001, bound.noise.sd=0.01, rtr=TRUE,
             autocorrelations="automatic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scarm.filter_+3A_time.series">time.series</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td></tr>
<tr><td><code id="scarm.filter_+3A_right.width">right.width</code></td>
<td>
<p>a positive integer &gt;=5 defining the fixed width of the right-hand window used for testing; the choice of <code>right.width</code> is crucial to distinguish between a patch of outliers and a signal change.</p>
</td></tr>
<tr><td><code id="scarm.filter_+3A_min.left.width">min.left.width</code></td>
<td>
<p>a positive integer <code class="reqn">\ge</code> <code>right.width</code> defining the minimum width of the left-hand window used for testing.</p>
</td></tr>
<tr><td><code id="scarm.filter_+3A_min.width">min.width</code></td>
<td>
<p>a positive integer <code class="reqn">\ge 5</code> specifying the minimum window width.</p>
</td></tr>
<tr><td><code id="scarm.filter_+3A_max.width">max.width</code></td>
<td>
<p>a positive integer <code class="reqn">\ge</code> <code>min.width</code> and <code class="reqn">\ge</code> <code>right.width</code> + <code>min.left.width</code> specifying the maximum window width.</p>
</td></tr>
<tr><td><code id="scarm.filter_+3A_sign.level">sign.level</code></td>
<td>
<p>significance level of the test procedure; must be a value in <code class="reqn">(0,0.5)</code>.</p>
</td></tr>
<tr><td><code id="scarm.filter_+3A_bound.noise.sd">bound.noise.sd</code></td>
<td>
<p>a lower bound for the estimate of the noise standard deviation; this bound ensures that the noise scale estimate cannot be zero due to ties in the data; must be a value <code class="reqn">&gt; 0</code>.</p>
</td></tr>
<tr><td><code id="scarm.filter_+3A_rtr">rtr</code></td>
<td>
<p>if <code>rtr=TRUE</code>, the signal estimation is restricted to the range of the rightmost <code>min.width</code> observations.</p>
</td></tr>
<tr><td><code id="scarm.filter_+3A_autocorrelations">autocorrelations</code></td>
<td>
<p>the <code>scarm.filter</code> is developed for non-autocorrelated data, but can be adapted to work for AR(1) processes with parameter <code class="reqn">\phi = -0.9,-0.6,...,0.9</code>; <code>autocorrelations</code> must be either &quot;no&quot; (<code class="reqn">\phi=0</code>), &quot;high.positive&quot; (<code class="reqn">\phi=0.9</code>), &quot;moderate.positive&quot; (<code class="reqn">\phi=0.6</code>), &quot;small.positive&quot; (<code class="reqn">\phi=0.3</code>), &quot;small.negative&quot; (<code class="reqn">\phi=-0.3</code>), &quot;moderate.negative (<code class="reqn">\phi=-0.6</code>)&quot;, &quot;high.negative (<code class="reqn">\phi=-0.9</code>)&quot; or &quot;automatic&quot;; if <code>autocorrelations="automatic"</code>, the true parameter <code class="reqn">\phi</code> is estimated at each time point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>scarm.filter</code> fits a Repeated Median (RM, Siegel, 1982) regression line to a moving window sample with length varying between <code>min.width</code> and <code>max.width</code>.
</p>
<p>For each time point, the window width is adapted to the current data situation by a test comparing two RM slopes estimated in separated sub-windows, a right-hand and a left-hand window.
</p>
<p>A more detailed description of the filter can be found in Borowski and Fried (2011).
</p>


<h3>Value</h3>

<p><code>scarm.filter</code> returns an object of class <code>scarm.filter</code>.  
An object of class <code>scarm.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>signal.est</code></td>
<td>
<p>a vector containing the signal estimations</p>
</td></tr>
<tr><td><code>slope.est</code></td>
<td>
<p>a vector containing the slope (or trend) estimations</p>
</td></tr>
<tr><td><code>adapted.width</code></td>
<td>
<p>a vector containing the adapted window widths</p>
</td></tr>
<tr><td><code>test.statistic</code></td>
<td>
<p>a vector containing the SCARM test statistics</p>
</td></tr>
<tr><td><code>critvals</code></td>
<td>
<p>a vector containing the critical values for test decision</p>
</td></tr>
<tr><td><code>noise.sd</code></td>
<td>
<p>a vector containing the estimates of the noise standard deviation</p>
</td></tr>
<tr><td><code>slope.diff</code></td>
<td>
<p>a vector containing the differences of the Repeated Median slopes estimated in the left-hand and right-hand window</p>
</td></tr>
<tr><td><code>acf.lag.one</code></td>
<td>
<p>a vector containing the estimated autocorrelations at lag one for each time point; estimation is done on the recent <code>max.width</code> observations at each time point</p>
</td></tr>
<tr><td><code>time.series</code></td>
<td>
<p>the original input data</p>
</td></tr>
</table>
<p>In addition, the input arguments used for the analysis are returned as list members.
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>scarm.filter</code> returns a plot showing the original time series 
with the filtered output. If <code>info==TRUE</code> (default), a plot of the adapted window widths is also given.
</p>


<h3>Author(s)</h3>

<p>Matthias Borowski</p>


<h3>References</h3>

 
<p>Borowski, M. and Fried, R. (2011)
Robust repeated median regression in moving windows with data-adaptive width selection, <em>Discussion Paper 28/2011, SFB 823, TU Dortmund University</em>.<br />
</p>
<p>Gelper, S., Schettlinger, K., Croux, C., and Gather, U. (2009)
Robust online scale estimation in time series: A model-free approach,
<em>Journal of Statistical Planning and Inference</em>, <b>139</b>(2), 335-349.<br />
</p>
<p>Siegel, A.F. (1982)
Robust Regression Using Repeated Medians,
<em>Biometrika</em> <b>69</b>(1), 242-244.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robreg.filter">robreg.filter</a></code>, <code><a href="#topic+adore.filter">adore.filter</a></code>, <code><a href="#topic+madore.filter">madore.filter</a></code>, <code><a href="#topic+mscarm.filter">mscarm.filter</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Time series
data(multi.ts)
x &lt;- multi.ts[,1]

# apply SCARM Filter 
scarm.extr &lt;- scarm.filter(x)
plot(scarm.extr)
</code></pre>

<hr>
<h2 id='sizecorrection'>Bias correction factors for the robust scale estimators MAD, Sn, Qn, and LSH</h2><span id='topic+sizecorrection'></span>

<h3>Description</h3>

<p>This matrix contains correction factors for the MAD, Sn, Qn, and LSH scale estimators to achieve unbiasedness under Gaussian noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizecorrection</code></pre>


<h3>Format</h3>

<p>A (31x4)-matrix containing correction factors for the MAD, Sn, Qn, and LSH scale estimators.
</p>


<h3>Source</h3>

<p>The correction factors have been obtained by simulations.</p>

<hr>
<h2 id='timecorrection'>Correction factors for the scale estimation of the filtering procedure proposed by Fried (2004).</h2><span id='topic+timecorrection'></span>

<h3>Description</h3>

<p>Fried's (2004) signal extraction procedure includes optional rules for outlier replacement based on local scale estimation. Since detected outliers are treated as missing values, the finite sample correction for the scale estimation is adjusted for the reduced sample size, using the correction factors in the dataset 'timecorrection'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timecorrection</code></pre>


<h3>Format</h3>

<p>A (250x16)-matrix containing the correction factors for the scale estimators MAD, Qn, Sn, and LSH and for the outlier treatments 'trimming', 'downsizing large values', 'downsizing moderate values', and 'winsorization'.
</p>


<h3>Source</h3>

<p>The correction factors have been obtained by simulations.</p>


<h3>References</h3>

<p>Fried, R. (2004), Robust Filtering of Time Series with 
Trends, <em>Journal of Nonparametric Statistics</em> <b>16</b>, 
313-328.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robust.filter">robust.filter</a></code>.</p>

<hr>
<h2 id='var.n'>
Variance of the Repeated Median slope estimator.
</h2><span id='topic+var.n'></span>

<h3>Description</h3>

<p>Empirical variance of the Repeated Median slope estimator, computed on standard normal noise in moving windows of width n; required by the function <code>scarm.filter</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(var.n)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:300] NA NA NA NA 0.138 ...
</p>


<h3>Details</h3>

<p>The variance of the Repeated Median slope estimator depends on the size of the window sample, i.e. the window width n. These are results from simulations, where the Repeated Median slope has been computed on standard normal noise in moving windows of width n. The value <code>var.n[n]</code> is the variance for the window width n.
</p>


<h3>Source</h3>

<p>The empirical variances have been obtained by simulations.
</p>


<h3>References</h3>

<p>Borowski, M. and Fried, R. (2011)
Robust moving window regression for online signal extraction from
non-stationary time series: online window width adaption by testing for
signal changes, <em>submitted</em>.
</p>

<hr>
<h2 id='wrm.filter'>Weighted Repeated Median Filters for Univariate Time Series</h2><span id='topic+wrm.filter'></span>

<h3>Description</h3>

<p>Filtering procedure based on a weighted version of Siegel's (1982) repeated median (RM) and
a moving time window for robust extraction  of low frequency components (the signal)
in the presence of outliers and shifts.
One of several weight functions can be chosen to weight the observations in each time window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrm.filter(y, width, weight.type = 1, del = floor(width/2), extrapolate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrm.filter_+3A_y">y</code></td>
<td>
<p>a numeric vector or (univariate) time series object. </p>
</td></tr>
<tr><td><code id="wrm.filter_+3A_width">width</code></td>
<td>
<p>a positive integer defining the window width used for fitting. <br />
If <code>del = floor(width/2)</code> (default) this needs to be an odd number.</p>
</td></tr>
<tr><td><code id="wrm.filter_+3A_weight.type">weight.type</code></td>
<td>
<p>Indicates the weight function used.
</p>

<dl>
<dt><code>weight.type=0</code>:</dt><dd><p>equal weighting</p>
</dd>
<dt><code>weight.type=1</code>:</dt><dd><p>triangular weights (default)</p>
</dd>
<dt><code>weight.type=2</code>:</dt><dd><p>Epanechnikov weights</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="wrm.filter_+3A_del">del</code></td>
<td>
<p> a positve integer (smaller than width) specifying the delay of the signal extraction. <br />
<code>del=0</code> means online signal extraction without delay. <br />
Default is <code>del=floor(width/2)</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="wrm.filter_+3A_extrapolate">extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series. <br />
If <code>del = floor(width/2)</code> (default) the extrapolation consists of the 
fitted values within the first half of the first window and the 
last half of the last window; if <code>del=0</code> the 
extrapolation consists of the all fitted values within the first 
time window. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For online signal extraction without time delay, weighted repeated median filtering with triangular weights is recommendable 
in the presence of isolated outliers and abrupt level shifts
since it reacts more quickly to shifts than unweighted repeated median filtering and provides higher
efficiencies. The window width should be chosen based on a guess of the minimal time period 
in which the signal can be approximated by a straight line without abrupt shifts.
Better results can be obtained by increasing the delay, but often minimization of the time delay
itself is one of the objectives so that one prefers del=0.
The procedure replaces missing values by simple extrapolations if these are not within the
first time window used for initialization.
</p>
<p>For &quot;offline&quot; situations, it is intuitive to set <code>del</code> roughly
equal to  <code>width/2</code>. If the focus is rather on smoothing than on
signal extraction, the Epanechnikov kernel should be used rather than
the triangular kernel. In this case one can also use directly function <code><a href="#topic+wrm.smooth">wrm.smooth</a></code>.   
</p>


<h3>Value</h3>

 
<p><code>wrm.filter</code> returns an object of class 
<code>wrm.filter</code>. An 
object of class <code>wrm.filter</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>the original input time series.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>the corresponding signal level extracted by the filter.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>the corresponding slope within each time window.</p>
</td></tr>
<tr><td><code>del</code></td>
<td>
<p>the parameter specifying the delay of the signal extraction.</p>
</td></tr>
<tr><td><code>width</code></td>
<td>
<p>width of the time window.</p>
</td></tr>
<tr><td><code>weight.type</code></td>
<td>
<p>name of the weight function used for the fit.</p>
</td></tr>
</table>
<p>The function <code>plot</code> returns a plot 
showing the original time series with the filtered output. </p>


<h3>Author(s)</h3>

<p>Roland Fried and Jochen Einbeck</p>


<h3>References</h3>

<p>These filtering procedures are described and investigated in <br />
Fried, R., Einbeck, J., Gather, U. (2007), Weighted Repeated Median Smoothing and Filtering, 
<em>Journal of the American Statistical Association</em> <b>102</b>, 1300-1308. <br />
Preliminary version available as technical report from <a href="https://eldorado.tu-dortmund.de/handle/2003/21637">https://eldorado.tu-dortmund.de/handle/2003/21637</a> 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dw.filter">dw.filter</a></code>, <code><a href="#topic+hybrid.filter">hybrid.filter</a></code>, <code><a href="#topic+wrm.smooth">wrm.smooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Nile)
nile &lt;- as.numeric(Nile)
obj &lt;- wrm.filter(nile, width=11)
plot(obj)
</code></pre>

<hr>
<h2 id='wrm.smooth'>Weighted Repeated Median Smoothing</h2><span id='topic+wrm.smooth'></span>

<h3>Description</h3>

<p>A robust smoothing tool using a kernel weighted version of Siegel's (1982) repeated median.
It can be seen as an alternative to local linear L1 regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrm.smooth(x, y, h, xgrid, weight = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrm.smooth_+3A_x">x</code></td>
<td>
<p>Vector of predictors.</p>
</td></tr>
<tr><td><code id="wrm.smooth_+3A_y">y</code></td>
<td>
<p>Vector of responses, needs to have the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="wrm.smooth_+3A_h">h</code></td>
<td>
<p>Bandwidth, measured in the same units as the explanatory (independent) variable x: 
(x[0]-<code>h</code>,x[0]+<code>h</code>) is the range of x-values to be included in the local smoothing at x[0]. Needs to be a positive number.</p>
</td></tr>
<tr><td><code id="wrm.smooth_+3A_xgrid">xgrid</code></td>
<td>
<p>Grid on which fitted values are to be evaluated. The default is here to take the input
values <code>x</code> for a sample size of at most 100, and <code>seq(min(x),max(x), l=100)</code> otherwise.</p>
</td></tr>
<tr><td><code id="wrm.smooth_+3A_weight">weight</code></td>
<td>
<p>Indicates the weight function used.
</p>

<dl>
<dt><code>weight=1</code></dt><dd><p>triangular weights</p>
</dd>
<dt><code>weight=2</code></dt><dd><p>Epanechnikov weights (default)</p>
</dd>
<dt><code>weight=3</code></dt><dd><p>Gaussian weights</p>
</dd>
<dt><code>weight=4</code></dt><dd><p>Biweight</p>
</dd>
<dt><code>weight=5</code></dt><dd><p>Uniform weights</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>Weighted repeated median (WRM) smoothing was suggested in a signal extraction framework by Fried, Einbeck &amp; Gather (2007). 
It combines the advantages of weighted and repeated medians, i.e. the WRM smoother is robust to outliers and adapts to linear trends (through the slope parameter of the repeated median, which is calculated by applying two consecutive weighted medians onto the pairwise slopes).  
The theory and simulations provided by Fried, Einbeck &amp; Gather focus on online signal extraction from time series. Warning: The case of a kernel weighted repeated median smoother for arbitraty non-equidistant design (as implemented here) is not fully investigated yet.
</p>
<p>The procedure copes with missing values by omitting them.
</p>


<h3>Value</h3>

 
<p><code>wrm.smooth</code> returns an object of class 
<code>wrm.smooth</code>. An 
object of class <code>wrm.smooth</code> is a list containing the 
following components:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>the original input time series.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>the corresponding signal level extraceted by the weighted Repeated Median filter.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>the corresponding WRM slope within each time window.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>bandwidth.</p>
</td></tr>
<tr><td><code>xgrid</code></td>
<td>
<p>vector with grid values.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>name of the weight function used for the fit.</p>
</td></tr>
</table>
<p>The function <code>plot</code> returns a plot 
showing the original data with the smoothed output.</p>


<h3>Author(s)</h3>

<p>Jochen Einbeck and Roland Fried</p>


<h3>References</h3>

<p>Fried, R., Einbeck, J., Gather, U. (2007), Weighted Repeated Median Smoothing and Filtering, 
<em>Journal of the American Statistical Association</em> <b>102</b>, 1300-1308. <br />
Preliminary version available as technical report from <a href="https://eldorado.tu-dortmund.de/handle/2003/21637">https://eldorado.tu-dortmund.de/handle/2003/21637</a> 
</p>
<p>Siegel, A.F. (1982). Robust regression using repeated medians. <em>Biometrika</em> <b>68</b>, 242-244.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wrm.filter">wrm.filter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(faithful) # Old Faithful Geyser data
faith.WRM &lt;- wrm.smooth(faithful$w, faithful$e,h=4)
plot(faith.WRM)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
