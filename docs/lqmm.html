<!DOCTYPE html><html lang="en"><head><title>Help for package lqmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lqmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lqmm-package'>
<p>Linear Quantile Models and Linear Quantile Mixed Models</p></a></li>
<li><a href='#boot'>
<p>Bootstrap functions for LQM and LQMM</p></a></li>
<li><a href='#coef.lqm'>
<p>Extract LQM Coefficients</p></a></li>
<li><a href='#coef.lqmm'>
<p>Extract LQMM Coefficients</p></a></li>
<li><a href='#covHandling'>
<p>Variance-Covariance Matrix</p></a></li>
<li><a href='#dal'>
<p>The Asymmetric Laplace Distribution</p></a></li>
<li><a href='#extractBoot'>
<p>Extract Fixed and Random Bootstrapped Parameters</p></a></li>
<li><a href='#gauss.quad'>
<p>Gaussian Quadrature</p></a></li>
<li><a href='#gauss.quad.prob'>
<p>Gaussian Quadrature</p></a></li>
<li><a href='#is.positive.definite'>
<p>Test for Positive Definiteness</p></a></li>
<li><a href='#labor'><p>Labor Pain Data</p></a></li>
<li><a href='#logLik.lqm'>
<p>Extract Log-Likelihood</p></a></li>
<li><a href='#logLik.lqmm'>
<p>Extract Log-Likelihood</p></a></li>
<li><a href='#lqm'><p>Fitting Linear Quantile Models</p></a></li>
<li><a href='#lqm.counts'>
<p>Quantile Regression for Counts</p></a></li>
<li><a href='#lqm.fit.gs'>
<p>Quantile Regression Fitting by Gradient Search</p></a></li>
<li><a href='#lqmControl'>
<p>Control parameters for lqm estimation</p></a></li>
<li><a href='#lqmm'><p>Fitting Linear Quantile Mixed Models</p></a></li>
<li><a href='#lqmm-internal'><p>Internal lqmm objects</p></a></li>
<li><a href='#lqmm.fit.df'>
<p>Linear Quantile Mixed Models Fitting by Derivative-Free Optimization</p></a></li>
<li><a href='#lqmm.fit.gs'>
<p>Linear Quantile Mixed Models Fitting by Gradient Search</p></a></li>
<li><a href='#lqmmControl'>
<p>Control parameters for lqmm estimation</p></a></li>
<li><a href='#make.positive.definite'>
<p>Compute Nearest Positive Definite Matrix</p></a></li>
<li><a href='#meanAL'>
<p>Functions for Asymmetric Laplace Distribution Parameters</p></a></li>
<li><a href='#mleAL'>
<p>Maximum Likelihood Estimation of Asymmetric Laplace Distribution</p></a></li>
<li><a href='#Orthodont'><p>Growth curve data on an orthdontic measurement</p></a></li>
<li><a href='#predict.lqm'>
<p>Predictions from LQM Objects</p></a></li>
<li><a href='#predict.lqmm'>
<p>Predictions from an <code>lqmm</code> Object</p></a></li>
<li><a href='#print.lqm'>
<p>Print LQM Objects</p></a></li>
<li><a href='#print.lqmm'>
<p>Print an <code>lqmm</code> Object</p></a></li>
<li><a href='#print.summary.lqm'>
<p>Print an <code>lqm</code> Summary Object</p></a></li>
<li><a href='#print.summary.lqmm'>
<p>Print an <code>lqmm</code> Summary Object</p></a></li>
<li><a href='#ranef.lqmm'>
<p>Extract Random Effects</p></a></li>
<li><a href='#residuals.lqm'>
<p>Residuals from an LQM Objects</p></a></li>
<li><a href='#residuals.lqmm'>
<p>Residuals from an <code>lqmm</code> Object</p></a></li>
<li><a href='#summary.boot.lqm'>
<p>Summary for a <code>boot.lqm</code> Object</p></a></li>
<li><a href='#summary.boot.lqmm'>
<p>Summary for a <code>boot.lqmm</code> Object</p></a></li>
<li><a href='#summary.lqm'><p>Summary for an <code>lqm</code> Object</p></a></li>
<li><a href='#summary.lqmm'><p>Summary for an <code>lqmm</code> Object</p></a></li>
<li><a href='#VarCorr.lqmm'>
<p>Extract Variance-Covariance Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Linear Quantile Mixed Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Marco Geraci</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marco Geraci &lt;marco.geraci@uniroma1.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, nlme (&ge; 3.1-124), SparseGrid</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to fit quantile regression models for hierarchical
    data (2-level nested designs) as described in Geraci and
    Bottai (2014, Statistics and Computing) &lt;<a href="https://doi.org/10.1007%2Fs11222-013-9381-9">doi:10.1007/s11222-013-9381-9</a>&gt;.
    A vignette is given in Geraci (2014, Journal of Statistical Software)
    &lt;<a href="https://doi.org/10.18637%2Fjss.v057.i13">doi:10.18637/jss.v057.i13</a>&gt; and included in the package documents.
    The packages also provides functions to fit quantile models for
    independent	data and for count responses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-05 15:45:53 UTC; marco</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-06 13:52:30 UTC</td>
</tr>
</table>
<hr>
<h2 id='lqmm-package'>
Linear Quantile Models and Linear Quantile Mixed Models</h2><span id='topic+lqmm-package'></span>

<h3>Description</h3>

<p>Fit quantile regression models for independent and hierarchical data
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> lqmm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5.8</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-04-05</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Marco Geraci
</p>
<p>Maintainer: Marco Geraci &lt;geraci@mailbox.sc.edu&gt;
</p>


<h3>References</h3>

<p>Geraci M (2014). Linear quantile mixed models: The lqmm package for Laplace quantile regression. Journal of Statistical Software, 57(13), 1&ndash;29. &lt;doi:10.18637/jss.v057.i13&gt;
</p>
<p>Geraci M and Bottai M (2007). Quantile regression for longitudinal data using the asymmetric Laplace distribution. Biostatistics 8(1), 140&ndash;154. &lt;doi:10.1093/biostatistics/kxj039&gt;
</p>
<p>Geraci M and Bottai M (2014). Linear quantile mixed models. Statistics and Computing, 24(3), 461&ndash;479. &lt;doi:10.1007/s11222-013-9381-9&gt;.
</p>

<hr>
<h2 id='boot'>
Bootstrap functions for LQM and LQMM
</h2><span id='topic+boot.lqm'></span><span id='topic+boot.lqmm'></span><span id='topic+boot'></span>

<h3>Description</h3>

<p>This function is used to obtain a bootstrap sample of a fitted LQM or LQMM. It is a generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot(object, R = 50, seed = round(runif(1, 1, 10000)), startQR = FALSE)
## S3 method for class 'lqm'
boot(object, R = 50, seed = round(runif(1, 1, 10000)), startQR = FALSE)
## S3 method for class 'lqmm'
boot(object, R = 50, seed = round(runif(1, 1, 10000)), startQR = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> &quot;lqm&quot; or &quot;lqmm&quot;.
</p>
</td></tr>
<tr><td><code id="boot_+3A_r">R</code></td>
<td>

<p>number of bootstrap replications.
</p>
</td></tr>
<tr><td><code id="boot_+3A_seed">seed</code></td>
<td>

<p>optional random number generator seed.
</p>
</td></tr>
<tr><td><code id="boot_+3A_startqr">startQR</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the estimated parameters in <code>object</code> are used as starting values in the algorithm applied to each bootstrap sample. This may cause the algorithm to converge too often to a similar optimum, which would ultimately result in underestimated standard errors. If <code>FALSE</code> (recommended), starting values are based on <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>boot.lqm</code> is a data frame with <code>R</code> rows and <code>npars</code> columns containing the bootstrap estimates of <code>theta</code>. If <code>object</code> contains results for multiple quantiles, <code>boot.lqm</code> returns an array of dimension <code>c(R,npars,nt)</code>, where <code>nt</code> is the length of <code>tau</code>.
</p>
<p>An object of class <code>boot.lqmm</code> is a data frame with <code>R</code> rows and <code>npars</code> columns containing the bootstrap estimates of <code>theta_x</code>, <code>theta_z</code>, and <code>scale</code>. If <code>object</code> contains results for multiple quantiles, <code>boot.lqmm</code> returns an array of dimension <code>c(R,npars,nt)</code>, where <code>nt</code> is the length of <code>tau</code>. The elements of <code>theta_z</code> are labelled with <code>reStruct</code>. See function <code><a href="#topic+covHandling">covHandling</a></code> and the example below on how to derive the variance-covariance matrix of the random effects starting from <code>theta_z</code>.
</p>
<p>The following attributes are available:
</p>
<table role = "presentation">
<tr><td><code>tau</code></td>
<td>
<p>index of the quantile(s).</p>
</td></tr>
<tr><td><code>estimated</code></td>
<td>
<p>the estimated parameter as given by <code>object</code>.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>number of bootstrap replications.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>the random number generator seed used to produce the bootstrap sample.</p>
</td></tr>
<tr><td><code>npars</code></td>
<td>
<p>total numer of parameters.</p>
</td></tr>
<tr><td><code>rdf</code></td>
<td>
<p>the number of residual degrees of freedom.</p>
</td></tr>
<tr><td><code>indices</code></td>
<td>
<p>the bootstrap sample of independent data units.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# boot.lqm
set.seed(123)
n &lt;- 500
test &lt;- data.frame(x = runif(n,0,1))
test$y &lt;- 30 + test$x + rnorm(n)
fit.lqm &lt;- lqm(y ~ x, data = test, tau = 0.5)
fit.boot &lt;- boot(fit.lqm)
str(fit.boot)

# boot.lqmm
data(Orthodont)
fit &lt;- lqmm(distance ~ age, random = ~ 1, group = Subject,
	tau = 0.5, data = Orthodont)
fit.boot &lt;- boot(fit)
str(fit.boot)
</code></pre>

<hr>
<h2 id='coef.lqm'>
Extract LQM Coefficients
</h2><span id='topic+coef.lqm'></span><span id='topic+coef.lqm.counts'></span>

<h3>Description</h3>

<p><code>coef</code> extracts model coefficients from <code>lqm</code>, <code>lqm.counts</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.lqm_+3A_object">object</code></td>
<td>

<p>an <code>lqm</code> or <code>lqm.counts</code> object.
</p>
</td></tr>
<tr><td><code id="coef.lqm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector for single quantiles or a matrix for multiple quantiles. 
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqm">lqm</a></code>
<code><a href="#topic+summary.lqm">summary.lqm</a></code>
<code><a href="#topic+lqm.counts">lqm.counts</a></code>
</p>

<hr>
<h2 id='coef.lqmm'>
Extract LQMM Coefficients
</h2><span id='topic+coef.lqmm'></span>

<h3>Description</h3>

<p><code>coef</code> extracts model coefficients from <code>lqmm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqmm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.lqmm_+3A_object">object</code></td>
<td>

<p>a fitted object of <code><a href="base.html#topic+class">class</a></code> &quot;lqmm&quot;.
</p>
</td></tr>
<tr><td><code id="coef.lqmm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector for single quantiles or a matrix for multiple quantiles. 
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>
<code><a href="#topic+summary.lqmm">summary.lqmm</a></code>
</p>

<hr>
<h2 id='covHandling'>
Variance-Covariance Matrix 
</h2><span id='topic+covHandling'></span>

<h3>Description</h3>

<p>This is an auxiliary function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covHandling(theta, n, cov_name, quad_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covHandling_+3A_theta">theta</code></td>
<td>

<p>unique parameters of the variance-covariance matrix of the random effects as returned by <code><a href="#topic+lqmm">lqmm</a></code> in <code>theta_z</code>.
</p>
</td></tr>
<tr><td><code id="covHandling_+3A_n">n</code></td>
<td>

<p>dimension of the vector of random effects.
</p>
</td></tr>
<tr><td><code id="covHandling_+3A_cov_name">cov_name</code></td>
<td>

<p>see argument <code>covariance</code> in <code><a href="#topic+lqmm">lqmm</a></code>.
</p>
</td></tr>
<tr><td><code id="covHandling_+3A_quad_type">quad_type</code></td>
<td>

<p>type of quadrature &quot;c(&quot;normal&quot;,&quot;robust&quot;)&quot;.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VarCorr.lqmm">VarCorr.lqmm</a></code>
</p>

<hr>
<h2 id='dal'>
The Asymmetric Laplace Distribution
</h2><span id='topic+pal'></span><span id='topic+qal'></span><span id='topic+ral'></span><span id='topic+dal'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the asymmetric Laplace distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dal(x, mu = 0, sigma = 1, tau = 0.5, log = FALSE)
pal(x, mu = 0, sigma = 1, tau = 0.5)
qal(x, mu = 0, sigma = 1, tau = 0.5)
ral(n, mu = 0, sigma = 1, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dal_+3A_x">x</code></td>
<td>

<p>vector of quantiles (<code>dal</code>, <code>pal</code>) or probabilities (<code>qal</code>).
</p>
</td></tr>
<tr><td><code id="dal_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr>
<tr><td><code id="dal_+3A_mu">mu</code></td>
<td>

<p>location parameter.
</p>
</td></tr>
<tr><td><code id="dal_+3A_sigma">sigma</code></td>
<td>

<p>positive scale parameter.
</p>
</td></tr>
<tr><td><code id="dal_+3A_tau">tau</code></td>
<td>

<p>skewness parameter (0,1).
</p>
</td></tr>
<tr><td><code id="dal_+3A_log">log</code></td>
<td>

<p>logical; if <code>TRUE</code>, probabilities are log&ndash;transformed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The asymmetric Laplace distribution with parameters (mu, sigma, tau) has density  
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \tau(1-\tau)/\sigma e^{-1/(2\sigma) (\theta max(x,0) + (1 - \theta) max(-x,0))}</code>
</p>



<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>, <code><a href="#topic+lqm">lqm</a></code>
</p>

<hr>
<h2 id='extractBoot'>
Extract Fixed and Random Bootstrapped Parameters
</h2><span id='topic+extractBoot.boot.lqmm'></span><span id='topic+extractBoot'></span>

<h3>Description</h3>

<p>This generic function extracts the fixed and random components of bootstrapped estimates of an <code>lqmm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractBoot(object, which = "fixed")
## S3 method for class 'boot.lqmm'
extractBoot(object, which = "fixed")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractBoot_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>boot.lqmm</code>.
</p>
</td></tr>
<tr><td><code id="extractBoot_+3A_which">which</code></td>
<td>

<p>character indicating whether <code>"fixed"</code> or <code>"random"</code> parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"random"</code> parameters refer to the &quot;raw&quot; parameters of the variance-covariance matrix of the random effects as returned by <code><a href="#topic+lqmm.fit.gs">lqmm.fit.gs</a></code> and <code><a href="#topic+lqmm.fit.df">lqmm.fit.df</a></code>.
</p>


<h3>Value</h3>

<p>a matrix of bootstrapped estimates.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot.lqmm">boot.lqmm</a></code>, <code><a href="#topic+lqmm.fit.gs">lqmm.fit.gs</a></code>, <code><a href="#topic+lqmm.fit.df">lqmm.fit.df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Orthodont data
data(Orthodont)

# Random intercept model
fit &lt;- lqmm(distance ~ age, random = ~ 1, group = Subject,
	tau = 0.5, data = Orthodont)
fit.boot &lt;- boot(fit)

# extract fixed effects
B &lt;- extractBoot(fit.boot, which = "fixed")

# covariance matrix estimated fixed parameters
cov(B)

</code></pre>

<hr>
<h2 id='gauss.quad'>
Gaussian Quadrature
</h2><span id='topic+gauss.quad'></span>

<h3>Description</h3>

<p>This function calculates nodes and weights for Gaussian quadrature. See <code>help("gauss.quad")</code> from package <code>statmod</code>.
</p>


<h3>Author(s)</h3>

<p>Original version by Gordon Smyth
</p>


<h3>Source</h3>

<p>Gordon Smyth with contributions from Yifang Hu, Peter Dunn and Belinda Phipson. (2011). statmod: Statistical Modeling. R package version 1.4.11. <a href="https://CRAN.R-project.org/package=statmod">https://CRAN.R-project.org/package=statmod</a>
</p>

<hr>
<h2 id='gauss.quad.prob'>
Gaussian Quadrature
</h2><span id='topic+gauss.quad.prob'></span>

<h3>Description</h3>

<p>This function calculates nodes and weights for Gaussian quadrature in terms of probability distributions. See <code>help("gauss.quad.prob")</code> from package <code>statmod</code>.
</p>


<h3>Author(s)</h3>

<p>Original version by Gordon Smyth
</p>


<h3>Source</h3>

<p>Gordon Smyth with contributions from Yifang Hu, Peter Dunn and Belinda Phipson. (2011). statmod: Statistical Modeling. R package version 1.4.11. <a href="https://CRAN.R-project.org/package=statmod">https://CRAN.R-project.org/package=statmod</a>
</p>

<hr>
<h2 id='is.positive.definite'>
Test for Positive Definiteness
</h2><span id='topic+is.positive.definite'></span>

<h3>Description</h3>

<p>This function tests whether all eigenvalues of a symmetric matrix are positive. See <code>help("is.positive.definite")</code> from package <code>corpcor</code>.
</p>


<h3>Author(s)</h3>

<p>Original version by Korbinian Strimmer
</p>


<h3>Source</h3>

<p>Juliane Schaefer, Rainer Opgen-Rhein, Verena Zuber, A. Pedro Duarte Silva and Korbinian Strimmer. (2011). corpcor: Efficient Estimation of Covariance and (Partial) Correlation. R package version 1.6.0. <a href="https://CRAN.R-project.org/package=corpcor">https://CRAN.R-project.org/package=corpcor</a>
</p>

<hr>
<h2 id='labor'>Labor Pain Data</h2><span id='topic+labor'></span>

<h3>Description</h3>

<p>The <code>labor</code> data frame has 358 rows and 4 columns of the
change in pain over time for several 83 women in labor.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>subject</dt><dd>
<p>an ordered factor indicating the subject on which the
measurement was made.  The levels are labelled <code>1</code>
to <code>83</code>.
</p>
</dd>
<dt>pain</dt><dd>
<p>a numeric vector of self&ndash;reported pain scores on a 100mm line.
</p>
</dd>
<dt>treatment</dt><dd>
<p>a dummy variable with values
<code>1</code> for subjects who received a pain medication and
<code>0</code> for subjects who received a placebo. 
</p>
</dd>
<dt>time</dt><dd>
<p>a numeric vector of times (minutes since randomization) at which <code>pain</code> was measured.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The labor pain data were reported by Davis (1991) and successively analyzed by Jung (1996) and Geraci and Bottai (2007). The data
set consists of repeated measurements of self&ndash;reported amount of pain on N = 83 women in labor, of which 43 were randomly assigned to a pain medication group and 40 to a placebo group. The response was measured every 30 min on a 100&ndash;mm line, where 0 means no pain and 100 means extreme pain. A nearly monotone pattern of missing data was found for the response variable and the maximum number of measurements for each woman was six.
</p>


<h3>Source</h3>

<p>Davis CS (1991). Semi&ndash;parametric and non&ndash;parametric methods for the analysis of repeated measurements with applications to clinical trials. Statistics in Medicine 10, 1959&ndash;80.
</p>


<h3>References</h3>

<p>Geraci M and Bottai M (2007). Quantile regression for longitudinal data using the asymmetric Laplace distribution. Biostatistics 8(1), 140&ndash;154.
</p>
<p>Jung S (1996). Quasi&ndash;likelihood for median regression models. Journal of the American Statistical Association 91, 251&ndash;7.
</p>

<hr>
<h2 id='logLik.lqm'>
Extract Log-Likelihood
</h2><span id='topic+logLik.lqm'></span>

<h3>Description</h3>

<p><code>logLik.lqm</code> extracts the log-likelihood of a fitted LQM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqm'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.lqm_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> &quot;lqm&quot;.
</p>
</td></tr>
<tr><td><code id="logLik.lqm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqm">lqm</a></code>
<code><a href="stats.html#topic+AIC">AIC</a></code>
</p>

<hr>
<h2 id='logLik.lqmm'>
Extract Log-Likelihood
</h2><span id='topic+logLik.lqmm'></span>

<h3>Description</h3>

<p><code>logLik.lqmm</code> extracts the log-likelihood of a fitted LQMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqmm'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.lqmm_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> &quot;lqmm&quot;.
</p>
</td></tr>
<tr><td><code id="logLik.lqmm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>
<code><a href="stats.html#topic+AIC">AIC</a></code>
</p>

<hr>
<h2 id='lqm'>Fitting Linear Quantile Models</h2><span id='topic+lqm'></span>

<h3>Description</h3>

<p><code>lqm</code> is used to fit linear quantile models based on the asymmetric Laplace distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lqm(formula, data, subset, na.action, weights = NULL, tau = 0.5,
	contrasts = NULL, control = list(), fit = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lqm_+3A_formula">formula</code></td>
<td>

<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> for fixed effects: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="lqm_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>lqm</code> is called.</p>
</td></tr>
<tr><td><code id="lqm_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="lqm_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain NAs. The default is set by the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>.
</p>
</td></tr>
<tr><td><code id="lqm_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="lqm_+3A_tau">tau</code></td>
<td>

<p>the quantile(s) to be estimated. This must be a number between 0 and 1, otherwise the execution is stopped. If more than one quantile is specified, rounding off to the 4th decimal must give non&ndash;duplicated values of <code>tau</code>, otherwise the execution is stopped.
</p>
</td></tr>
<tr><td><code id="lqm_+3A_contrasts">contrasts</code></td>
<td>

<p>an optional list. See the contrasts.arg of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="lqm_+3A_control">control</code></td>
<td>

<p>list of control parameters of the fitting process. See <code><a href="#topic+lqmControl">lqmControl</a></code>.
</p>
</td></tr>
<tr><td><code id="lqm_+3A_fit">fit</code></td>
<td>

<p>logical flag. If <code>FALSE</code> the function returns a list of arguments to be passed to <code>lqm.fit.gs</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes an estimate on the tau-th quantile function of the response, conditional on the covariates, as specified by the formula argument. The quantile predictor is assumed to be linear. The function maximizes the (log)likelihood of a Laplace regression which is equivalent to the minimization of the weighted sum of absolute residuals (Koenker and Bassett, 1978). The optimization algorithm is based on the gradient of the Laplace log&ndash;likelihood (Bottai, Orsini and Geraci, 2013).
</p>


<h3>Value</h3>

<p><code>lqm</code> returns an object of <code><a href="base.html#topic+class">class</a></code> <code>lqm</code>.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the results.
</p>
<p>An object of class <code>lqm</code> is a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>theta</code></td>
<td>
<p>a vector of coefficients. <code>theta</code> is a named matrix of coefficients when <code>tau</code> is a vector of values.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the scale parameter.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>the gradient.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log&ndash;likelihood.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>details on optimization (see <code><a href="#topic+lqm.fit.gs">lqm.fit.gs</a></code>).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>term.labels</code></td>
<td>
<p>names for theta.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms object used.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>edf</code>, <code>dim_theta</code></td>
<td>
<p>the length of theta.</p>
</td></tr>
<tr><td><code>rdf</code></td>
<td>
<p>the number of residual degrees of freedom.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>the estimated quantile(s).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the model matrix.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the model response.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weights used in the fitting process (a vector of 1's if <code>weights</code> = NULL).</p>
</td></tr>
<tr><td><code>InitialPar</code></td>
<td>
<p>starting values for theta.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>list of control parameters used for optimization (see <code><a href="#topic+lqmControl">lqmControl</a></code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Updates/FAQ/news are published here <a href="https://marcogeraci.wordpress.com/">https://marcogeraci.wordpress.com/</a>. New versions are usually published here <a href="https://github.com/marco-geraci/lqmm/">https://github.com/marco-geraci/lqmm/</a> before going on CRAN.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci</p>


<h3>References</h3>

<p>Bottai M, Orsini N, Geraci M (2015). A Gradient Search Maximization Algorithm for the Asymmetric Laplace Likelihood, Journal of Statistical Computation and Simulation, 85(10), 1919-1925.
</p>
<p>Chen C (2007). A finite smoothing algorithm for quantile regression. Journal of Computational and Graphical Statistics, 16(1), 136-164. 
</p>
<p>Koenker R and Bassett G (1978). Regression Quantiles. Econometrica 46(1), 33&ndash;50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.lqm">summary.lqm</a>, <a href="#topic+coef.lqm">coef.lqm</a>, <a href="#topic+predict.lqm">predict.lqm</a>, <a href="#topic+residuals.lqm">residuals.lqm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
n &lt;- 500
p &lt;- 1:3/4
test &lt;- data.frame(x = runif(n,0,1))
test$y &lt;- 30 + test$x + rnorm(n)
fit.lqm &lt;- lqm(y ~ x, data = test, tau = p,
	control = list(verbose = FALSE, loop_tol_ll = 1e-9), fit = TRUE)
fit.lqm
</code></pre>

<hr>
<h2 id='lqm.counts'>
Quantile Regression for Counts</h2><span id='topic+lqm.counts'></span>

<h3>Description</h3>

<p>This function is used to fit a quantile regression model when the response is a count variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lqm.counts(formula, data, weights = NULL, offset = NULL, contrasts = NULL,
	tau = 0.5, M = 50, zeta = 1e-05, B = 0.999, cn = NULL, alpha = 0.05,
	control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lqm.counts_+3A_formula">formula</code></td>
<td>

<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code>: a symbolic description of the model to be fitted.
</p>
</td></tr>
<tr><td><code id="lqm.counts_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which lqm is called.
</p>
</td></tr>
<tr><td><code id="lqm.counts_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="lqm.counts_+3A_offset">offset</code></td>
<td>

<p>an optional offset to be included in the model frame.  
</p>
</td></tr>
<tr><td><code id="lqm.counts_+3A_contrasts">contrasts</code></td>
<td>

<p>an optional list. See the <code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.
</p>
</td></tr>
<tr><td><code id="lqm.counts_+3A_tau">tau</code></td>
<td>

<p>quantile to be estimated.
</p>
</td></tr>
<tr><td><code id="lqm.counts_+3A_m">M</code></td>
<td>

<p>number of dithered samples.
</p>
</td></tr>
<tr><td><code id="lqm.counts_+3A_zeta">zeta</code></td>
<td>

<p>small constant (see References).
</p>
</td></tr>
<tr><td><code id="lqm.counts_+3A_b">B</code></td>
<td>

<p>right boundary for uniform random noise U[0,B] to be added to the response variable (see References).
</p>
</td></tr>
<tr><td><code id="lqm.counts_+3A_cn">cn</code></td>
<td>

<p>small constant to be passed to <code><a href="#topic+F.lqm">F.lqm</a></code> (see References).
</p>
</td></tr>
<tr><td><code id="lqm.counts_+3A_alpha">alpha</code></td>
<td>

<p>significance level.
</p>
</td></tr>
<tr><td><code id="lqm.counts_+3A_control">control</code></td>
<td>

<p>list of control parameters of the fitting process. See <code><a href="#topic+lqmControl">lqmControl</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A linear quantile regression model if fitted to the log&ndash;transformed response. Additional tranformation functions will be implemented. The notation used here follows closely that of Machado and Santos Silva (2005).</p>


<h3>Value</h3>

<p>an object of class &quot;lqm.counts&quot; containing the following components
</p>
<table role = "presentation">
<tr><td><code>tau</code></td>
<td>
<p>the estimated quantile.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>regression quantile (on the log&ndash;scale).</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>predicted quantile (on the response scale).</p>
</td></tr>
<tr><td><code>tTable</code></td>
<td>
<p>coefficients, standard errors, etc.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the model matrix.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the model response.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>offset.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>specified number of dithered samples for standard error estimation.</p>
</td></tr>
<tr><td><code>Mn</code></td>
<td>
<p>actual number of dithered samples used for standard error estimation that gave an invertible D matrix (Machado and Santos Silva, 2005).</p>
</td></tr>
<tr><td><code>term.labels</code></td>
<td>
<p>names for theta.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms object used.</p>
</td></tr>
<tr><td><code>rdf</code></td>
<td>
<p>the number of residual degrees of freedom.</p>
</td></tr>
<tr><td><code>InitialPar</code></td>
<td>
<p>starting values for theta.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>list of control parameters used for optimization (see <code><a href="#topic+lqmControl">lqmControl</a></code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Machado JAF and Santos Silva JMC (2005). Quantiles for counts. Journal of the American Statistical Association, 100(472), 1226&ndash;1237. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 100
x &lt;- runif(n)
test &lt;- data.frame(x = x, y = rpois(n, 2*x))
lqm.counts(y ~ x, data = test, M = 50)


</code></pre>

<hr>
<h2 id='lqm.fit.gs'>
Quantile Regression Fitting by Gradient Search
</h2><span id='topic+lqm.fit.gs'></span>

<h3>Description</h3>

<p>This function controls the arguments to be passed to routines written in C for LQM estimation. The optimization algorithm is based on the gradient of the Laplace log&ndash;likelihood (Bottai, Orsini and Geraci, 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lqm.fit.gs(theta, x, y, weights, tau, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lqm.fit.gs_+3A_theta">theta</code></td>
<td>

<p>starting values for the regression coefficients.
</p>
</td></tr>
<tr><td><code id="lqm.fit.gs_+3A_x">x</code></td>
<td>

<p>the model matrix.
</p>
</td></tr>
<tr><td><code id="lqm.fit.gs_+3A_y">y</code></td>
<td>

<p>the model response.
</p>
</td></tr>
<tr><td><code id="lqm.fit.gs_+3A_weights">weights</code></td>
<td>

<p>the weights used in the fitting process.
</p>
</td></tr>
<tr><td><code id="lqm.fit.gs_+3A_tau">tau</code></td>
<td>

<p>the quantile to be estimated.
</p>
</td></tr>
<tr><td><code id="lqm.fit.gs_+3A_control">control</code></td>
<td>

<p>list of control parameters used for optimization (see <code><a href="#topic+lqmControl">lqmControl</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See argument <code>fit</code> in <code><a href="#topic+lqm">lqm</a></code> for generating a list of arguments to be called by this function.
</p>


<h3>Value</h3>

<p>An object of class <code>list</code> containing the following components:
</p>
<table role = "presentation">
<tr><td><code>theta</code></td>
<td>
<p>a vector of coefficients.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the scale parameter.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>the gradient.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log&ndash;likelihood.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>number of iterations when the estimation algorithm stopped.</p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Bottai M, Orsini N, Geraci M (2014). A Gradient Search Maximization Algorithm for the Asymmetric Laplace Likelihood, Journal of Statistical Computation and Simulation, 85, 1919-1925.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqm">lqm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
n &lt;- 500
test &lt;- data.frame(x = runif(n,0,1))
test$y &lt;- 30 + test$x + rnorm(n)
lqm.ls &lt;- lqm(y ~ x, data = test, fit = FALSE)

do.call("lqm.fit.gs", lqm.ls)
</code></pre>

<hr>
<h2 id='lqmControl'>
Control parameters for lqm estimation
</h2><span id='topic+lqmControl'></span>

<h3>Description</h3>

<p>A list of parameters for controlling the fitting process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lqmControl(method = "gs1", loop_tol_ll = 1e-5, loop_tol_theta = 1e-3,
	check_theta = FALSE, loop_step = NULL, beta = 0.5, gamma = 1.25,
	reset_step = FALSE, loop_max_iter = 1000, smooth = FALSE,
	omicron = 0.001, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lqmControl_+3A_method">method</code></td>
<td>

<p>character vector that specifies which code to use for carrying out the gradient search algorithm: &quot;gs1&quot; (default) based on C code and &quot;gs2&quot; based on R code. Method &quot;gs3&quot; uses a smoothed loss function. See details.
</p>
</td></tr>
<tr><td><code id="lqmControl_+3A_loop_tol_ll">loop_tol_ll</code></td>
<td>

<p>tolerance expressed as relative change of the log-likelihood.
</p>
</td></tr>
<tr><td><code id="lqmControl_+3A_loop_tol_theta">loop_tol_theta</code></td>
<td>

<p>tolerance expressed as relative change of the estimates.
</p>
</td></tr>
<tr><td><code id="lqmControl_+3A_check_theta">check_theta</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the algorithm performs a check on the change in the estimates in addition to the likelihood.
</p>
</td></tr>
<tr><td><code id="lqmControl_+3A_loop_step">loop_step</code></td>
<td>

<p>step size (default standard deviation of response).
</p>
</td></tr>
<tr><td><code id="lqmControl_+3A_beta">beta</code></td>
<td>

<p>decreasing step factor for line search (0,1).
</p>
</td></tr>
<tr><td><code id="lqmControl_+3A_gamma">gamma</code></td>
<td>

<p>nondecreasing step factor for line search (&gt;= 1).
</p>
</td></tr>
<tr><td><code id="lqmControl_+3A_reset_step">reset_step</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the step size is re-setted to the initial value at each iteration.
</p>
</td></tr>
<tr><td><code id="lqmControl_+3A_loop_max_iter">loop_max_iter</code></td>
<td>

<p>maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="lqmControl_+3A_smooth">smooth</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the standard loss function is replaced with a smooth approximation.
</p>
</td></tr>
<tr><td><code id="lqmControl_+3A_omicron">omicron</code></td>
<td>

<p>small constant for smoothing the loss function when using <code>smooth = TRUE</code>. See details.
</p>
</td></tr>
<tr><td><code id="lqmControl_+3A_verbose">verbose</code></td>
<td>

<p>logical flag.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods &quot;gs1&quot; and &quot;gs2&quot; implement the same algorithm (Bottai et al, 2015). The former is based on C code, the latter on R code. While the C code is faster, the R code seems to be more efficient in handling large datasets. For method &quot;gs2&quot;, it is possible to replace the classical non-differentiable loss function with a smooth version (Chen, 2007).
</p>


<h3>Value</h3>

<p>a list of control parameters.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci</p>


<h3>References</h3>

<p>Bottai M, Orsini N, Geraci M (2015). A Gradient Search Maximization Algorithm for the Asymmetric Laplace Likelihood, Journal of Statistical Computation and Simulation, 85(10), 1919-1925.
</p>
<p>Chen C (2007). A finite smoothing algorithm for quantile regression. Journal of Computational and Graphical Statistics, 16(1), 136-164. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqm">lqm</a></code>
</p>

<hr>
<h2 id='lqmm'>Fitting Linear Quantile Mixed Models</h2><span id='topic+lqmm'></span>

<h3>Description</h3>

<p><code>lqmm</code> is used to fit linear quantile mixed models based on the asymmetric Laplace distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lqmm(fixed, random, group, covariance = "pdDiag", tau = 0.5,
	nK = 7, type = "normal", rule = 1, data = sys.frame(sys.parent()),
	subset, weights, na.action = na.fail, control = list(),
	contrasts = NULL, fit = TRUE) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lqmm_+3A_fixed">fixed</code></td>
<td>

<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> for fixed effects: a symbolic description of the model to be fitted.
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_random">random</code></td>
<td>

<p>a one-sided formula of the form <code>~x1 + x2 + ... + xn</code> for random effects: a symbolic description of the model to be fitted.
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_group">group</code></td>
<td>

<p>grouping factor.
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_covariance">covariance</code></td>
<td>

<p>variance&ndash;covariance matrix of the random effects. Default is <code>pdDiag</code> (see details).
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_tau">tau</code></td>
<td>

<p>the quantile(s) to be estimated.
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_nk">nK</code></td>
<td>

<p>number of quadrature knots.
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_type">type</code></td>
<td>

<p>type of quadrature &quot;c(&quot;normal&quot;,&quot;robust&quot;)&quot; (see details).
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_rule">rule</code></td>
<td>

<p>quadrature rule (see details).
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables named in
<code>fixed</code>, <code>random</code> and <code>group</code>. By default the variables are taken from the environment from which <code>lqmm</code> is called.
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="lqmm_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process of the same length as the number of rows of <code>data</code>. Weights are given to clusters, therefore units within the same cluster receive the same weight (see details).
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.fail</code>) causes
<code>lqmm</code> to print an error message and terminate if there are any
incomplete observations.</p>
</td></tr>
<tr><td><code id="lqmm_+3A_control">control</code></td>
<td>

<p>list of control parameters of the fitting process. See <code><a href="#topic+lqmmControl">lqmmControl</a></code>.
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_contrasts">contrasts</code></td>
<td>

<p>not yet implemented.
</p>
</td></tr>
<tr><td><code id="lqmm_+3A_fit">fit</code></td>
<td>

<p>logical flag. If FALSE the function returns a list of arguments to be passed to <code>lqmm.fit</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes an estimate on the tau-th quantile function of the response, conditional on the covariates, as specified by the <code>formula</code> argument, and on random effects, as specified by the <code>random</code> argument. The quantile predictor is assumed to be linear. The function maximizes the (log)likelihood of the Laplace regression proposed by Geraci and Bottai (2014). The likelihood is numerically integrated via Gaussian quadrature techniques. The optimization algorithm is based on the gradient of the Laplace log&ndash;likelihood (<code>control = list(method = "gs")</code>). An alternative optimization algorithm is based on a Nelder-Mead algorithm (<code>control = list(method = "df")</code>) via <code><a href="stats.html#topic+optim">optim</a></code>. The scale parameter is optimized in a refinement step via <code><a href="stats.html#topic+optimize">optimize</a></code>.
</p>
<p>Quadrature approaches include Gauss-Hermite (<code>type = "normal"</code>) and Gauss-Laguerre (<code>type = "robust"</code>) quadrature. The argument <code>rule</code> takes one of the following: 1 (product rule quadrature), 2 (sparse grid quadrature), 3 (nested quadrature rule - only for <code>type = "normal"</code>), 4 (quadrature rule with the smallest number of nodes between rules 1 or 2). Rules 2 and 3 have not yet been tested extensively.
</p>
<p>Different standard types of positive&ndash;definite matrices for the random effects can be specified: <code>pdIdent</code> multiple of an identity; <code>pdCompSymm</code> compound symmetry structure (constant diagonal and constant off&ndash;diagonal elements); <code>pdDiag</code> diagonal; <code>pdSymm</code> general positive&ndash;definite matrix, with no additional structure.
</p>
<p>Weights are given to clusters, therefore it is expected that these are constant within cluster. When the weights are specified in the main call, then the first value by <code>group</code> in the vector <code>weights</code> will be replicated for the same length of each group. Alternatively, different weights within the same cluster can be introduced with a direct call to <code><a href="#topic+lqmm.fit.gs">lqmm.fit.gs</a> or <a href="#topic+lqmm.fit.df">lqmm.fit.df</a></code>.
</p>
<p>The <code>lqmm</code> vignette can be accessed by typing <code>help(package = "lqmm")</code> and then following the link 'User guides, package vignettes and other documentation'.
</p>


<h3>Value</h3>

<p><code>lqmm</code> returns an object of <code><a href="base.html#topic+class">class</a></code> <code>lqmm</code>.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the results.
</p>
<p>An object of class <code>lqmm</code> is a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>theta</code></td>
<td>
<p>a vector containing fixed regression coefficients and parameters of the variance&ndash;covariance matrix of the random effects. See <code><a href="#topic+VarCorr.lqmm">VarCorr.lqmm</a></code> to extract the variance&ndash;covariance of the random effects from an &quot;lqmm&quot; object.</p>
</td></tr>
<tr><td><code>theta_x</code>, <code>theta_z</code></td>
<td>
<p>partition of <code>theta</code>: fixed regression coefficients (<code>theta_x</code>) and unique variance&ndash;covariance parameters (<code>theta_z</code>).</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the scale parameter.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>the gradient (<code>control = list(method = "gs")</code>).</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log&ndash;likelihood.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>details on optimization (see <code><a href="#topic+lqmm.fit.gs">lqmm.fit.gs</a></code> and <code><a href="#topic+lqmm.fit.df">lqmm.fit.df</a></code>).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>nn</code></td>
<td>
<p>column names of <code>mmf</code>.</p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>column names of <code>mmr</code>.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>dim_theta</code></td>
<td>
<p>the number of columns in <code>mmf</code> and <code>mmr</code>.</p>
</td></tr>
<tr><td><code>dim_theta_z</code></td>
<td>
<p>the length of <code>theta_z</code>.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>length of <code>theta</code>.</p>
</td></tr>
<tr><td><code>rdf</code></td>
<td>
<p>the number of residual degrees of freedom.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>edf + 1 (scale parameter).</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>the estimated quantile(s).</p>
</td></tr>
<tr><td><code>mmf</code></td>
<td>
<p>the model matrix &ndash; fixed effects.</p>
</td></tr>
<tr><td><code>mmr</code></td>
<td>
<p>the model matrix &ndash; random effects.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the model response.</p>
</td></tr>
<tr><td><code>revOrder</code></td>
<td>
<p>original order of observations (now ordered according to <code>group</code>).</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the likelihood weights used in the fitting process (a vector of 1's if <code>weights</code> is missing or <code>NULL</code>).</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>the grouping factor.</p>
</td></tr>
<tr><td><code>ngroups</code></td>
<td>
<p>the number of groups.</p>
</td></tr>
<tr><td><code>QUAD</code></td>
<td>
<p>quadrature nodes and weights.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the type of quadrature.</p>
</td></tr>
<tr><td><code>rule</code></td>
<td>
<p>quadrature rule.</p>
</td></tr>
<tr><td><code>InitialPar</code></td>
<td>
<p>starting values for theta.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>list of control parameters used for optimization (see <code><a href="#topic+lqmmControl">lqmmControl</a></code>).</p>
</td></tr>
<tr><td><code>cov_name</code></td>
<td>
<p>class of variance-covariance matrix for the random effects.</p>
</td></tr>
<tr><td><code>mfArgs</code></td>
<td>
<p>arguments for <code><a href="stats.html#topic+model.frame">model.frame</a></code> to return the full data frame.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Updates/FAQ/news are published here <a href="https://marcogeraci.wordpress.com/">https://marcogeraci.wordpress.com/</a>. New versions are usually published here <a href="https://github.com/marco-geraci/lqmm/">https://github.com/marco-geraci/lqmm/</a> before going on CRAN.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Genz A, and Keister BD (1996). Fully symmetric interpolatory rules for multiple integrals over infinite regions with Gaussian weight. Journal of Computational and Applied Mathematics, 71(2), 299&ndash;309. &lt;doi:10.1016/0377-0427(95)00232-4&gt;
</p>
<p>Geraci M (2014). Linear quantile mixed models: The lqmm package for Laplace quantile regression. Journal of Statistical Software, 57(13), 1&ndash;29. &lt;doi:10.18637/jss.v057.i13&gt;
</p>
<p>Geraci M and Bottai M (2007). Quantile regression for longitudinal data using the asymmetric Laplace distribution. Biostatistics 8(1), 140&ndash;154. &lt;doi:10.1093/biostatistics/kxj039&gt;
</p>
<p>Geraci M and Bottai M (2014). Linear quantile mixed models. Statistics and Computing, 24(3), 461&ndash;479. &lt;doi:10.1007/s11222-013-9381-9&gt;.
</p>
<p>Heiss F, and Winschel V (2008). Likelihood approximation by numerical integration on sparse grids. Journal of Econometrics, 144(1), 62&ndash;80. &lt;doi:10.1016/j.jeconom.2007.12.004&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqm">lqm</a>, <a href="#topic+summary.lqmm">summary.lqmm</a>, <a href="#topic+coef.lqmm">coef.lqmm</a>, <a href="#topic+VarCorr.lqmm">VarCorr.lqmm</a>, <a href="#topic+predict.lqmm">predict.lqmm</a>, <a href="#topic+residuals.lqmm">residuals.lqmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Test example
set.seed(123)

M &lt;- 50
n &lt;- 10
test &lt;- data.frame(x = runif(n*M,0,1), group = rep(1:M,each=n))
test$y &lt;- 10*test$x + rep(rnorm(M, 0, 2), each = n) + rchisq(n*M, 3)
fit.lqmm &lt;- lqmm(fixed = y ~ x, random = ~ 1, group = group,	
	data = test, tau = 0.5, nK = 11, type = "normal")
fit.lqmm

#Call: lqmm(fixed = y ~ x, random = ~1, group = group, tau = 0.5, nK = 11, 
#    type = "normal", data = test)
#Quantile 0.5 

#Fixed effects:
#(Intercept)            x  
#      3.443        9.258  

#Covariance matrix of the random effects:
#(Intercept) 
#      3.426 

#Residual scale parameter: 0.8697 (standard deviation 2.46)
#Log-likelihood: -1178 

#Number of observations: 500 
#Number of groups: 50 


## Orthodont data
data(Orthodont)

# Random intercept model
fitOi.lqmm &lt;- lqmm(distance ~ age, random = ~ 1, group = Subject,
	tau = c(0.1,0.5,0.9), data = Orthodont)
coef(fitOi.lqmm)

# Random slope model
fitOs.lqmm &lt;- lqmm(distance ~ age, random = ~ age, group = Subject,
	tau = c(0.1,0.5,0.9), cov = "pdDiag", data = Orthodont)

# Extract estimates
VarCorr(fitOs.lqmm)
coef(fitOs.lqmm)
ranef(fitOs.lqmm)

# AIC
AIC(fitOi.lqmm)
AIC(fitOs.lqmm)

</code></pre>

<hr>
<h2 id='lqmm-internal'>Internal lqmm objects</h2><span id='topic+.First.lib'></span><span id='topic+.Last.lib'></span><span id='topic+bandwidth.rq'></span><span id='topic+errorHandling'></span><span id='topic+extractAll'></span><span id='topic+loglik.al'></span><span id='topic+loglik.s'></span><span id='topic+loglik.t'></span><span id='topic+logliki'></span><span id='topic+score.al'></span><span id='topic+gradientSi'></span><span id='topic+switch_check'></span><span id='topic+theta.z.dim'></span><span id='topic+createLaguerre'></span><span id='topic+quad'></span><span id='topic+invTfun'></span><span id='topic+Tfun'></span><span id='topic+F.lqm'></span><span id='topic+addnoise'></span><span id='topic+permutations'></span><span id='topic+asOneFormula'></span><span id='topic+allVarsRec'></span><span id='topic+nlloglikh'></span><span id='topic+rePred'></span><span id='topic+C_gradientSh'></span><span id='topic+C_gradientSi'></span><span id='topic+C_ll_h'></span>

<h3>Description</h3>

<p>Internal lqmm objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='lqmm.fit.df'>
Linear Quantile Mixed Models Fitting by Derivative-Free Optimization
</h2><span id='topic+lqmm.fit.df'></span>

<h3>Description</h3>

<p>This function controls the arguments to be passed to <code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="stats.html#topic+optimize">optimize</a></code> for LQMM estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lqmm.fit.df(theta_0, x, y, z, weights, cov_name, V, W, sigma_0,	
	tau, group, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lqmm.fit.df_+3A_theta_0">theta_0</code></td>
<td>

<p>starting values for the linear predictor.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.df_+3A_x">x</code></td>
<td>

<p>the model matrix for fixed effects (see details).
</p>
</td></tr>
<tr><td><code id="lqmm.fit.df_+3A_y">y</code></td>
<td>

<p>the model response (see details).
</p>
</td></tr>
<tr><td><code id="lqmm.fit.df_+3A_z">z</code></td>
<td>

<p>the model matrix for random effects (see details).
</p>
</td></tr>
<tr><td><code id="lqmm.fit.df_+3A_weights">weights</code></td>
<td>

<p>the weights used in the fitting process (see details).
</p>
</td></tr>
<tr><td><code id="lqmm.fit.df_+3A_cov_name">cov_name</code></td>
<td>

<p>variance&ndash;covariance matrix of the random effects. Default is <code>pdIdent</code>. See details.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.df_+3A_v">V</code></td>
<td>

<p>nodes of the quadrature.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.df_+3A_w">W</code></td>
<td>

<p>weights of the quadrature.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.df_+3A_sigma_0">sigma_0</code></td>
<td>

<p>starting value for the scale parameter.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.df_+3A_tau">tau</code></td>
<td>

<p>the quantile(s) to be estimated.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.df_+3A_group">group</code></td>
<td>

<p>the grouping factor (see details).
</p>
</td></tr>
<tr><td><code id="lqmm.fit.df_+3A_control">control</code></td>
<td>

<p>list of control parameters used for optimization (see <code><a href="#topic+lqmmControl">lqmmControl</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code><a href="#topic+lqmm">lqmm</a></code>, see argument <code>fit</code> for generating a list of arguments to be called by this function; see argument <code>covariance</code> for alternative variance&ndash;covariance matrices.
</p>
<p>NOTE: the data should be ordered by <code>group</code> when passed to <code>lqmm.fit.df</code> (such ordering is performed by <code><a href="#topic+lqmm">lqmm</a></code>). 
</p>


<h3>Value</h3>

<p>An object of class &quot;list&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>theta</code></td>
<td>
<p>a vector of coefficients, including the &quot;raw&quot; variance&ndash;covariance parameters (see <code><a href="#topic+VarCorr.lqmm">VarCorr.lqmm</a></code>).</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the scale parameter.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log&ndash;likelihood.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>number of iterations when the estimation algorithm stopped for lower (theta) and upper (scale) loop.</p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

M &lt;- 50
n &lt;- 10
test &lt;- data.frame(x = runif(n*M,0,1), group = rep(1:M,each=n))
test$y &lt;- 10*test$x + rep(rnorm(M, 0, 2), each = n) + rchisq(n*M, 3)
lqmm.ls &lt;- lqmm(fixed = y ~ x, random = ~ 1, group = group, data = test,
	fit = FALSE)

do.call("lqmm.fit.df", lqmm.ls)

</code></pre>

<hr>
<h2 id='lqmm.fit.gs'>
Linear Quantile Mixed Models Fitting by Gradient Search
</h2><span id='topic+lqmm.fit.gs'></span>

<h3>Description</h3>

<p>This function controls the arguments to be passed to routines written in C for LQMM estimation. The optimization algorithm is based on the gradient of the Laplace log&ndash;likelihood (Bottai, Orsini and Geraci, 2014; Geraci and Bottai, 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lqmm.fit.gs(theta_0, x, y, z, weights, cov_name, V, W, sigma_0, tau,
	group, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lqmm.fit.gs_+3A_theta_0">theta_0</code></td>
<td>

<p>starting values for the linear predictor.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.gs_+3A_x">x</code></td>
<td>

<p>the model matrix for fixed effects (see details).
</p>
</td></tr>
<tr><td><code id="lqmm.fit.gs_+3A_y">y</code></td>
<td>

<p>the model response (see details).
</p>
</td></tr>
<tr><td><code id="lqmm.fit.gs_+3A_z">z</code></td>
<td>

<p>the model matrix for random effects (see details).
</p>
</td></tr>
<tr><td><code id="lqmm.fit.gs_+3A_weights">weights</code></td>
<td>

<p>the weights used in the fitting process (see details).
</p>
</td></tr>
<tr><td><code id="lqmm.fit.gs_+3A_cov_name">cov_name</code></td>
<td>

<p>variance&ndash;covariance matrix of the random effects. Default is <code>pdIdent</code>. See details.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.gs_+3A_v">V</code></td>
<td>

<p>nodes of the quadrature.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.gs_+3A_w">W</code></td>
<td>

<p>weights of the quadrature.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.gs_+3A_sigma_0">sigma_0</code></td>
<td>

<p>starting value for the scale parameter.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.gs_+3A_tau">tau</code></td>
<td>

<p>the quantile(s) to be estimated.
</p>
</td></tr>
<tr><td><code id="lqmm.fit.gs_+3A_group">group</code></td>
<td>

<p>the grouping factor (see details).
</p>
</td></tr>
<tr><td><code id="lqmm.fit.gs_+3A_control">control</code></td>
<td>

<p>list of control parameters used for optimization (see <code><a href="#topic+lqmmControl">lqmmControl</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code><a href="#topic+lqmm">lqmm</a></code>, see argument <code>fit</code> for generating a list of arguments to be called by this function; see argument <code>covariance</code> for alternative variance&ndash;covariance matrices.
</p>
<p>NOTE: the data should be ordered by <code>group</code> when passed to <code>lqmm.fit.gs</code> (such ordering is performed by <code><a href="#topic+lqmm">lqmm</a></code>). 
</p>


<h3>Value</h3>

<p>An object of class &quot;list&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>theta</code></td>
<td>
<p>a vector of coefficients, including the &quot;raw&quot; variance&ndash;covariance parameters (see <code><a href="#topic+VarCorr.lqmm">VarCorr.lqmm</a></code>).</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the scale parameter.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>the gradient.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log&ndash;likelihood.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>number of iterations when the estimation algorithm stopped for lower (theta) and upper (scale) loop.</p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci</p>


<h3>References</h3>

<p>Bottai M, Orsini N, Geraci M. (2014). A gradient search maximization algorithm for the asymmetric Laplace likelihood, Journal of Statistical Computation and Simulation (in press).
</p>
<p>Geraci M and Bottai M (2014). Linear quantile mixed models. Statistics and Computing, 24(3), 461&ndash;479.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

M &lt;- 50
n &lt;- 10
test &lt;- data.frame(x = runif(n*M,0,1), group = rep(1:M,each=n))
test$y &lt;- 10*test$x + rep(rnorm(M, 0, 2), each = n) + rchisq(n*M, 3)
lqmm.ls &lt;- lqmm(fixed = y ~ x, random = ~ 1, group = group,
	data = test, fit = FALSE)

do.call("lqmm.fit.gs", lqmm.ls)

</code></pre>

<hr>
<h2 id='lqmmControl'>
Control parameters for lqmm estimation
</h2><span id='topic+lqmmControl'></span>

<h3>Description</h3>

<p>A list of parameters for controlling the fitting process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lqmmControl(method = "gs", LP_tol_ll = 1e-5, LP_tol_theta = 1e-5,
	check_theta = FALSE, LP_step = NULL, beta = 0.5, gamma = 1,
	reset_step = FALSE, LP_max_iter = 500, UP_tol = 1e-4,
	UP_max_iter = 20, startQR = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lqmmControl_+3A_method">method</code></td>
<td>

<p>character vector that specifies the estimation method: &quot;gs&quot; for gradient search (default) and &quot;df&quot; for Nelder-Mead.
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_lp_tol_ll">LP_tol_ll</code></td>
<td>

<p>tolerance expressed as absolute change of the log-likelihood.
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_lp_tol_theta">LP_tol_theta</code></td>
<td>

<p>tolerance expressed as absolute change of <code>theta</code>
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_check_theta">check_theta</code></td>
<td>

<p>logical flag. If TRUE the algorithm performs an additional check on the change in the estimates.
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_lp_step">LP_step</code></td>
<td>

<p>step size (default standard deviation of response).
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_beta">beta</code></td>
<td>

<p>decreasing step factor for line search (0,1).
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_gamma">gamma</code></td>
<td>

<p>nondecreasing step factor for line search (&gt;= 1).
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_reset_step">reset_step</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the step size is reset to the initial value at each iteration.
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_lp_max_iter">LP_max_iter</code></td>
<td>

<p>maximum number of iterations
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_up_tol">UP_tol</code></td>
<td>

<p>tolerance expressed as absolute change of the <code>scale</code> parameter.
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_up_max_iter">UP_max_iter</code></td>
<td>

<p>maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_startqr">startQR</code></td>
<td>

<p>logical flag. If <code>FALSE</code> (default) the least squares estimate of the fixed effects is used as starting value of <code>theta_x</code> and <code>scale</code>. If <code>TRUE</code> the <code><a href="#topic+lqm">lqm</a></code> estimate is used.
</p>
</td></tr>
<tr><td><code id="lqmmControl_+3A_verbose">verbose</code></td>
<td>

<p>logical flag.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>LP</code> (lower loop) refers to the estimation of regression coefficients and variance-covariance parameters. <code>UP</code> (upper loop) refers to the estimation of the scale parameter.
</p>


<h3>Value</h3>

<p>a list of control parameters.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>
</p>

<hr>
<h2 id='make.positive.definite'>
Compute Nearest Positive Definite Matrix
</h2><span id='topic+make.positive.definite'></span>

<h3>Description</h3>

<p>This function computes the nearest positive definite of a real symmetric matrix.
See <code>help("make.positive.definite")</code> from package <code>corpcor</code>.
</p>


<h3>Author(s)</h3>

<p>Original version by Korbinian Strimmer
</p>


<h3>Source</h3>

<p>Juliane Schaefer, Rainer Opgen-Rhein, Verena Zuber, A. Pedro Duarte Silva and Korbinian Strimmer. (2011). corpcor: Efficient Estimation of Covariance and (Partial) Correlation. R package version 1.6.0. <a href="https://CRAN.R-project.org/package=corpcor">https://CRAN.R-project.org/package=corpcor</a>
</p>

<hr>
<h2 id='meanAL'>
Functions for Asymmetric Laplace Distribution Parameters
</h2><span id='topic+varAL'></span><span id='topic+invvarAL'></span><span id='topic+meanAL'></span>

<h3>Description</h3>

<p>Accessory functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanAL(mu, sigma, tau)
varAL(sigma, tau)
invvarAL(x, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meanAL_+3A_mu">mu</code></td>
<td>

<p>location parameter.
</p>
</td></tr>
<tr><td><code id="meanAL_+3A_sigma">sigma</code></td>
<td>

<p>scale parameter.
</p>
</td></tr>
<tr><td><code id="meanAL_+3A_tau">tau</code></td>
<td>

<p>skewness parameter.
</p>
</td></tr>
<tr><td><code id="meanAL_+3A_x">x</code></td>
<td>

<p>numeric value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>meanAL</code> computes the mean of an asymmetric Laplace with parameters <code>mu</code>, <code>sigma</code> and <code>tau</code>.
</p>
<p><code>varAL</code> computes the variance of an asymmetric Laplace with parameters <code>sigma</code> and <code>tau</code>.
</p>
<p><code>invvarAL</code> computes the scale parameter of an asymmetric Laplace with parameter <code>tau</code> and variance <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Yu K and Zhang J (2005). A three-parameter asymmetric Laplace distribution and its extension. Communications in Statistics-Theory and Methods 34, 1867&ndash;1879.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dal">dal</a></code>, <code><a href="#topic+mleAL">mleAL</a></code>
</p>

<hr>
<h2 id='mleAL'>
Maximum Likelihood Estimation of Asymmetric Laplace Distribution</h2><span id='topic+mleAL'></span>

<h3>Description</h3>

<p>This function estimates the parameters of an asymmetric Laplace distribution for a sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mleAL(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mleAL_+3A_x">x</code></td>
<td>

<p>a numeric vector.
</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>an object of class <code>list</code> containing the following components:
</p>
<table role = "presentation">
<tr><td><code>m</code></td>
<td>
<p>location parameter</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>scale parameter</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>skewness parameter</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>number of iterations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Yu K and Zhang J (2005). A three-parameter asymmetric Laplace distribution and its extension. Communications in Statistics-Theory and Methods 34, 1867&ndash;1879.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dal">dal</a></code>, <code><a href="#topic+meanAL">meanAL</a></code>
</p>

<hr>
<h2 id='Orthodont'>Growth curve data on an orthdontic measurement</h2><span id='topic+Orthodont'></span>

<h3>Description</h3>

<p>The <code>Orthodont</code> data frame has 108 rows and 4 columns of the
change in an orthdontic measurement over time for several young subjects.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>distance</dt><dd>
<p>a numeric vector of distances from the pituitary to the
pterygomaxillary fissure (mm).  These distances are measured
on x-ray images of the skull.
</p>
</dd>
<dt>age</dt><dd>
<p>a numeric vector of ages of the subject (yr).
</p>
</dd>
<dt>Subject</dt><dd>
<p>an ordered factor indicating the subject on which the
measurement was made.  The levels are labelled <code>M01</code>
to <code>M16</code> for the males and <code>F01</code> to <code>F13</code> for
the females.  The ordering is by increasing average distance
within sex.
</p>
</dd>
<dt>Sex</dt><dd>
<p>a factor with levels
<code>Male</code> and
<code>Female</code> 
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Investigators at the University of North Carolina Dental School
followed the growth of 27 children (16 males, 11 females) from age 8
until age 14.  Every two years they measured the distance between the
pituitary and the pterygomaxillary fissure, two points that are easily
identified on x-ray exposures of the side of the head.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.17)
</p>
<p>Potthoff, R. F. and Roy,  S. N. (1964), &ldquo;A generalized multivariate
analysis of variance model useful especially for growth curve
problems&rdquo;, Biometrika, 51, 313&ndash;326.
</p>
<p>Jose Pinheiro, Douglas Bates, Saikat DebRoy, Deepayan Sarkar and the R Development Core Team (2011). nlme: Linear and Nonlinear Mixed Effects Models. R package version 3.1-100. <a href="https://CRAN.R-project.org/package=nlme">https://CRAN.R-project.org/package=nlme</a>
</p>

<hr>
<h2 id='predict.lqm'>
Predictions from LQM Objects
</h2><span id='topic+predict.lqm'></span><span id='topic+predict.lqm.counts'></span>

<h3>Description</h3>

<p>This function computes predictions based on fitted linear quantile model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqm'
predict(object, newdata, interval = FALSE,
	level = 0.95, na.action = na.pass, ...)
## S3 method for class 'lqm.counts'
predict(object, newdata,
	na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.lqm_+3A_object">object</code></td>
<td>

<p>an <code>lqm</code> or <code>lqm.counts</code> object.
</p>
</td></tr>
<tr><td><code id="predict.lqm_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.lqm_+3A_interval">interval</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, bootstrap percentile intervals for predictions are provided. This argument is for <code>lqm</code> objects only.
</p>
</td></tr>
<tr><td><code id="predict.lqm_+3A_level">level</code></td>
<td>

<p>confidence level. This argument is for <code>lqm</code> objects only.
</p>
</td></tr>
<tr><td><code id="predict.lqm_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in <code>newdata</code>. The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.lqm_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code>boot.lqm</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a matrix or an array of predictions.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.lqm">residuals.lqm</a></code>, <code><a href="#topic+residuals.lqm.counts">residuals.lqm.counts</a></code>, <code><a href="#topic+lqm">lqm</a></code>, <code><a href="#topic+lqm.counts">lqm.counts</a></code>, <code><a href="#topic+coef.lqm">coef.lqm</a></code>, <code><a href="#topic+boot.lqm">boot.lqm</a></code>
</p>

<hr>
<h2 id='predict.lqmm'>
Predictions from an <code>lqmm</code> Object
</h2><span id='topic+predint'></span><span id='topic+predint.lqmm'></span><span id='topic+predict.lqmm'></span>

<h3>Description</h3>

<p>The predictions at level 0 correspond to predictions based only on the fixed effects estimates. The predictions at level 1 are obtained by adding the best linear predictions of the random effects to the predictions at level 0. See details for interpretation. The function <code>predint</code> will produce 1-alpha confidence intervals based on bootstrap centiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqmm'
predict(object, newdata, level = 0,
	na.action = na.pass, ...)
## S3 method for class 'lqmm'
predint(object, level = 0, alpha = 0.05,
	R = 50, seed = round(runif(1, 1, 10000)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.lqmm_+3A_object">object</code></td>
<td>

<p>an <code>lqmm</code> object.
</p>
</td></tr>
<tr><td><code id="predict.lqmm_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict. If omitted, the fitted values are produced.  
</p>
</td></tr>
<tr><td><code id="predict.lqmm_+3A_level">level</code></td>
<td>

<p>an optional integer vector giving the level of grouping to be used in obtaining the predictions.
</p>
</td></tr>
<tr><td><code id="predict.lqmm_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in <code>newdata</code>. The default is to predict <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="predict.lqmm_+3A_alpha">alpha</code></td>
<td>

<p>1-<code>alpha</code> is the confidence level.  
</p>
</td></tr>
<tr><td><code id="predict.lqmm_+3A_r">R</code></td>
<td>

<p>number of bootstrap replications.
</p>
</td></tr>
<tr><td><code id="predict.lqmm_+3A_seed">seed</code></td>
<td>

<p>optional random number generator seed.
</p>
</td></tr>
<tr><td><code id="predict.lqmm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As discussed by Geraci and Bottai (2014), integrating over the random effects will give &quot;weighted averages&quot; of the cluster-specific quantile effects. These may be interpreted strictly as population regression quantiles for the median (<code>tau=0.5</code>) only. Therefore, predictions at the population level (<code>code=0</code>) should be interpreted analogously.
</p>


<h3>Value</h3>

<p>a vector or a matrix of predictions for <code>predict.lqmm</code>. A data frame or a list of data frames for <code>predint.lqmm</code> containing predictions, lower and upper bounds of prediction intervals, and standard errors.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Geraci M and Bottai M (2014). Linear quantile mixed models. Statistics and Computing, 24(3), 461&ndash;479.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>, <code><a href="#topic+ranef.lqmm">ranef.lqmm</a></code>, <code><a href="#topic+coef.lqmm">coef.lqmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Orthodont data
data(Orthodont)

# Random intercept model
fitOi.lqmm &lt;- lqmm(distance ~ age, random = ~ 1, group = Subject,
	tau = c(0.1,0.5,0.9), data = Orthodont)

# Predict (y - Xb)	
predict(fitOi.lqmm, level = 0)

# Predict (y - Xb - Zu)
predict(fitOi.lqmm, level = 1)

# 95% confidence intervals
predint(fitOi.lqmm, level = 0, alpha = 0.05)

</code></pre>

<hr>
<h2 id='print.lqm'>
Print LQM Objects
</h2><span id='topic+print.lqm'></span><span id='topic+print.lqm.counts'></span>

<h3>Description</h3>

<p>Print an object generated by <code><a href="#topic+lqm">lqm</a></code> or <code><a href="#topic+lqm.counts">lqm.counts</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqm'
print(x, digits = max(6, getOption("digits")), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lqm_+3A_x">x</code></td>
<td>

<p>an <code>lqm</code> or <code>lqm.counts</code> object.
</p>
</td></tr>
<tr><td><code id="print.lqm_+3A_digits">digits</code></td>
<td>

<p>a non-null value for digits specifies the minimum number of significant digits to be printed in values.
</p>
</td></tr>
<tr><td><code id="print.lqm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqm">lqm</a></code>, <code><a href="#topic+lqm.counts">lqm.counts</a></code>
</p>

<hr>
<h2 id='print.lqmm'>
Print an <code>lqmm</code> Object
</h2><span id='topic+print.lqmm'></span>

<h3>Description</h3>

<p>Print an object generated by <code><a href="#topic+lqmm">lqmm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqmm'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lqmm_+3A_x">x</code></td>
<td>

<p>an <code>lqmm</code> object.
</p>
</td></tr>
<tr><td><code id="print.lqmm_+3A_digits">digits</code></td>
<td>

<p>a non-null value for digits specifies the minimum number of significant digits to be printed in values.
</p>
</td></tr>
<tr><td><code id="print.lqmm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>
</p>

<hr>
<h2 id='print.summary.lqm'>
Print an <code>lqm</code> Summary Object
</h2><span id='topic+print.summary.lqm'></span>

<h3>Description</h3>

<p>Print summary of an <code>lqm</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lqm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.lqm_+3A_x">x</code></td>
<td>

<p>a <code>summary.lqm</code> object.
</p>
</td></tr>
<tr><td><code id="print.summary.lqm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqm">lqm</a></code>, <code><a href="#topic+summary.lqm">summary.lqm</a></code>
</p>

<hr>
<h2 id='print.summary.lqmm'>
Print an <code>lqmm</code> Summary Object
</h2><span id='topic+print.summary.lqmm'></span>

<h3>Description</h3>

<p>Print summary of an <code>lqmm</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lqmm'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.lqmm_+3A_x">x</code></td>
<td>

<p>a <code>summary.lqmm</code> object.
</p>
</td></tr>
<tr><td><code id="print.summary.lqmm_+3A_digits">digits</code></td>
<td>

<p>a non-null value for digits specifies the minimum number of significant digits to be printed in values.
</p>
</td></tr>
<tr><td><code id="print.summary.lqmm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>, <code><a href="#topic+summary.lqmm">summary.lqmm</a></code>
</p>

<hr>
<h2 id='ranef.lqmm'>
Extract Random Effects
</h2><span id='topic+ranef'></span><span id='topic+ranef.lqmm'></span>

<h3>Description</h3>

<p>This function computes random effects for a linear quantile mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqmm'
ranef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranef.lqmm_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>lqmm</code>.
</p>
</td></tr>
<tr><td><code id="ranef.lqmm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prediction of the random effects is done via estimated best linear prediction (Geraci and Bottai, 2014). The generic function <code>ranef</code> is imported from the <code>nlme</code> package (Pinheiro et al, 2014).
</p>


<h3>Value</h3>

<p>a data frame or a list of data frames of predicted random effects.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Geraci M and Bottai M (2014). Linear quantile mixed models. Statistics and Computing, 24(3), 461&ndash;479. doi: 10.1007/s11222-013-9381-9.
</p>
<p>Pinheiro J, Bates D, DebRoy S, Sarkar D and R Core Team (2014). nlme: Linear and Nonlinear Mixed Effects Models. R package version 3.1-117, <a href="https://CRAN.R-project.org/package=nlme">https://CRAN.R-project.org/package=nlme</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>, <code><a href="#topic+coef.lqmm">coef.lqmm</a></code>
</p>

<hr>
<h2 id='residuals.lqm'>
Residuals from an LQM Objects
</h2><span id='topic+residuals.lqm'></span><span id='topic+residuals.lqm.counts'></span>

<h3>Description</h3>

<p>This function computes the residuals from a fitted linear quantile model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.lqm_+3A_object">object</code></td>
<td>

<p>an <code>lqm</code> or <code>lqm.counts</code> object.
</p>
</td></tr>
<tr><td><code id="residuals.lqm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or matrix of residuals.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqm">lqm</a></code>, <code><a href="#topic+lqm.counts">lqm.counts</a></code>, <code><a href="#topic+predict.lqm">predict.lqm</a></code>, <code><a href="#topic+coef.lqm">coef.lqm</a></code>
</p>

<hr>
<h2 id='residuals.lqmm'>
Residuals from an <code>lqmm</code> Object
</h2><span id='topic+residuals.lqmm'></span>

<h3>Description</h3>

<p>The residuals at level 0 correspond to population residuals (based only on the fixed effects estimates). The residuals at level 1 are obtained by adding the best linear predictions of the random effects to the predictions at level 0 and the subtracting these from the model response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqmm'
residuals(object, level = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.lqmm_+3A_object">object</code></td>
<td>

<p>an <code>lqmm</code> object.
</p>
</td></tr>
<tr><td><code id="residuals.lqmm_+3A_level">level</code></td>
<td>

<p>an optional integer vector giving the level of grouping to be used in obtaining the predictions. Level zero corresponds to the population residuals.
</p>
</td></tr>
<tr><td><code id="residuals.lqmm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of residuals.
</p>


<h3>Author(s)</h3>

<p>Marco Geraci</p>


<h3>References</h3>

<p>Geraci M and Bottai M (2014). Linear quantile mixed models. Statistics and Computing, 24(3), 461&ndash;479. doi: 10.1007/s11222-013-9381-9.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>, <code><a href="#topic+predict.lqmm">predict.lqmm</a></code>, <code><a href="#topic+coef.lqmm">coef.lqmm</a></code>, <code><a href="#topic+ranef.lqmm">ranef.lqmm</a></code>,
</p>

<hr>
<h2 id='summary.boot.lqm'>
Summary for a <code>boot.lqm</code> Object
</h2><span id='topic+summary.boot.lqm'></span>

<h3>Description</h3>

<p>Summary method for class <code>boot.lqm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boot.lqm'
summary(object, alpha = 0.05, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.boot.lqm_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>lqm</code>.
</p>
</td></tr>
<tr><td><code id="summary.boot.lqm_+3A_alpha">alpha</code></td>
<td>

<p>numeric value for the interval confidence level (<code>1-alpha</code>).
</p>
</td></tr>
<tr><td><code id="summary.boot.lqm_+3A_digits">digits</code></td>
<td>

<p>a non-null value for digits specifies the minimum number of significant digits to be printed in values.</p>
</td></tr>
<tr><td><code id="summary.boot.lqm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot.lqm">boot.lqm</a></code>, <code><a href="#topic+lqm">lqm</a></code>,
</p>

<hr>
<h2 id='summary.boot.lqmm'>
Summary for a <code>boot.lqmm</code> Object
</h2><span id='topic+summary.boot.lqmm'></span>

<h3>Description</h3>

<p>This function gives a summary of a botstrapped <code>lqmm</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boot.lqmm'
summary(object, alpha = 0.05, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.boot.lqmm_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>lqmm</code>.
</p>
</td></tr>
<tr><td><code id="summary.boot.lqmm_+3A_alpha">alpha</code></td>
<td>

<p>numeric value for the interval confidence level (<code>1-alpha</code>).
</p>
</td></tr>
<tr><td><code id="summary.boot.lqmm_+3A_digits">digits</code></td>
<td>

<p>a non-null value for digits specifies the minimum number of significant digits to be printed in values.</p>
</td></tr>
<tr><td><code id="summary.boot.lqmm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Geraci M and Bottai M (2014). Linear quantile mixed models. Statistics and Computing, 24(3), 461&ndash;479. doi: 10.1007/s11222-013-9381-9.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot.lqmm">boot.lqmm</a></code>, <code><a href="#topic+lqmm">lqmm</a></code>,
</p>

<hr>
<h2 id='summary.lqm'>Summary for an <code>lqm</code> Object</h2><span id='topic+summary.lqm'></span>

<h3>Description</h3>

<p>Summary method for class <code>lqm</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqm'
summary(object, method = "boot", alpha = 0.05, covariance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lqm_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>lqm</code></p>
</td></tr>
<tr><td><code id="summary.lqm_+3A_method">method</code></td>
<td>

<p>specifies the method used to compute standard errors: &quot;boot&quot; for bootstrap (default), &quot;nid&quot; for large sample approximations under <em>nid</em> assumptions.</p>
</td></tr>
<tr><td><code id="summary.lqm_+3A_alpha">alpha</code></td>
<td>

<p>significance level.
</p>
</td></tr>
<tr><td><code id="summary.lqm_+3A_covariance">covariance</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the covariance matrix of the bootstrap estimates is provided.
</p>
</td></tr>
<tr><td><code id="summary.lqm_+3A_...">...</code></td>
<td>

<p>see <code><a href="#topic+boot.lqm">boot.lqm</a></code> for additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.lqm</code> formats the coefficients, standard errors, etc. and additionally gives &lsquo;significance stars&rsquo;.</p>


<h3>Value</h3>

<p>an object of class <code>summary.lqm</code>. The function <code>summary.lqm</code> computes and returns a list of summary statistics of the fitted linear quantile mixed model given in <code>object</code>, using the components (list elements) from its argument, plus
</p>
<table role = "presentation">
<tr><td><code>Cov</code></td>
<td>
<p>the covariance matrix obtained from the bootstrapped estimates (if <code>covariance = TRUE</code>).</p>
</td></tr>
<tr><td><code>tTable</code></td>
<td>
<p>a matrix with estimates, standard errors, etc.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci</p>


<h3>Source</h3>

<p>The code for the &quot;nid&quot; method has been adapted from the function <code>summary.rq</code> in package <code>quantreg</code>. It depends on the function <code>bandwidth.rq</code>. 
</p>
<p>Roger Koenker (2016). quantreg: Quantile Regression. R package version 5.29. <a href="https://CRAN.R-project.org/package=quantreg">https://CRAN.R-project.org/package=quantreg</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.summary.lqm">print.summary.lqm</a></code>
<code><a href="#topic+lqm">lqm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12356)
n &lt;- 200
p &lt;- 1:3/4
test &lt;- data.frame(x = runif(n,0,1))
test$y &lt;- 30 + test$x + rnorm(n)
fit.lqm &lt;- lqm(y ~ x, data = test, tau = p)
summary(fit.lqm, R = 50)

</code></pre>

<hr>
<h2 id='summary.lqmm'>Summary for an <code>lqmm</code> Object</h2><span id='topic+summary.lqmm'></span>

<h3>Description</h3>

<p>Summary method for class <code>lqmm</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqmm'
summary(object, method = "boot", alpha = 0.05, covariance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lqmm_+3A_object">object</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>lqmm</code>.
</p>
</td></tr>
<tr><td><code id="summary.lqmm_+3A_method">method</code></td>
<td>

<p>specifies the method used to compute standard errors. Currently, only the bootstrap method (&quot;boot&quot;) is available.
</p>
</td></tr>
<tr><td><code id="summary.lqmm_+3A_alpha">alpha</code></td>
<td>

<p>significance level.
</p>
</td></tr>
<tr><td><code id="summary.lqmm_+3A_covariance">covariance</code></td>
<td>

<p>logical flag. If <code>TRUE</code> the covariance matrix of the bootstrap estimates is provided.
</p>
</td></tr>
<tr><td><code id="summary.lqmm_+3A_...">...</code></td>
<td>

<p>see <code><a href="#topic+boot.lqmm">boot.lqmm</a></code> for additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.lqmm</code> formats the coefficients, standard errors, etc. and additionally gives &lsquo;significance stars&rsquo;.</p>


<h3>Value</h3>

<p>an object of class <code>summary.lqmm</code>. The function <code>summary.lqmm</code> computes and returns a list of summary statistics of the fitted linear quantile mixed model given in <code>object</code>, using the components (list elements) from its argument, plus
</p>
<table role = "presentation">
<tr><td><code>Cov</code></td>
<td>
<p>the covariance matrix obtained from the bootstrapped estimates (if <code>covariance = TRUE</code>).</p>
</td></tr>
<tr><td><code>tTable</code></td>
<td>
<p>a matrix with estimates, standard errors, etc.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the matrix of all bootstrapped parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Geraci</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.summary.lqmm">print.summary.lqmm</a></code>
<code><a href="#topic+lqmm">lqmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Orthodont)
fitOi.lqmm &lt;- lqmm(distance ~ age, random = ~ 1, group = Subject,
	tau = c(0.1,0.5,0.9), data = Orthodont)
summary(fitOi.lqmm)
</code></pre>

<hr>
<h2 id='VarCorr.lqmm'>
Extract Variance-Covariance Matrix
</h2><span id='topic+VarCorr'></span><span id='topic+VarCorr.lqmm'></span>

<h3>Description</h3>

<p>This function extracts the variance-covariance matrix of the random effects from a fitted <code>lqmm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqmm'
VarCorr(x, sigma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VarCorr.lqmm_+3A_x">x</code></td>
<td>

<p>an object of <code><a href="base.html#topic+class">class</a></code> &quot;lqmm&quot;.
</p>
</td></tr>
<tr><td><code id="VarCorr.lqmm_+3A_sigma">sigma</code></td>
<td>

<p>not used.
</p>
</td></tr>
<tr><td><code id="VarCorr.lqmm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the variance or the variance-covariance matrix of the random effects. It calls <code><a href="#topic+covHandling">covHandling</a></code> to manage the output of <code><a href="#topic+lqmm.fit.gs">lqmm.fit.gs</a></code> or <code><a href="#topic+lqmm.fit.df">lqmm.fit.df</a></code>. A post-fitting approximation to the nearest positive (semi)definite matrix (Higham, 2002) is applied if necessary. The generic function <code>VarCorr</code> is imported from the <code>nlme</code> package (Pinheiro et al, 2014).
</p>


<h3>Author(s)</h3>

<p>Marco Geraci
</p>


<h3>References</h3>

<p>Higham N (2002). Computing the Nearest Correlation Matrix - A Problem from Finance. IMA Journal of Numerical Analysis, 22, 329-343.
</p>
<p>Pinheiro J, Bates D, DebRoy S, Sarkar D and R Core Team (2014). nlme: Linear and Nonlinear Mixed Effects Models. R package version 3.1-117, <a href="https://CRAN.R-project.org/package=nlme">https://CRAN.R-project.org/package=nlme</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lqmm">lqmm</a></code>
<code><a href="#topic+coef.lqmm">coef.lqmm</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
