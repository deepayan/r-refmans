<!DOCTYPE html><html lang="en"><head><title>Help for package StratifiedMedicine</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {StratifiedMedicine}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#filter_train'><p>filter_train: Identify variables of interest</p></a></li>
<li><a href='#generate_subgrp_data'><p>Generate Subgroup Data-sets</p></a></li>
<li><a href='#param_combine'><p>Overall Population Estimate: Aggregating Subgroup-Specific Parameter Estimates</p></a></li>
<li><a href='#param_est'><p>Parameter Estimation: Across Subgroups</p></a></li>
<li><a href='#ple_train'><p>Patient-level Estimates: Train Model</p></a></li>
<li><a href='#plot_dependence'><p>Partial dependence plots: Single Variable (marginal effect) or heat map (2 to</p>
3 variables).</a></li>
<li><a href='#plot_importance'><p>Importance Plot: Visualize relative importance of variables</p></a></li>
<li><a href='#plot_ple'><p>Patient-Level Estimate Plot (plot_ple): Visualize distribution of estimates</p></a></li>
<li><a href='#plot_tree'><p>Tree Plot: Tree Structure, Subgroup-specific treatment estimates</p></a></li>
<li><a href='#plot.PRISM'><p>plot.PRISM</p></a></li>
<li><a href='#predict.ple_train'><p>Patient-level Estimates Model: Prediction</p></a></li>
<li><a href='#predict.PRISM'><p>PRISM: Patient Response Identifier for Stratified Medicine (Predictions)</p></a></li>
<li><a href='#predict.submod_train'><p>Subgroup Identification: Train Model (Predictions)</p></a></li>
<li><a href='#PRISM'><p>PRISM: Patient Response Identifier for Stratified Medicine</p></a></li>
<li><a href='#submod_train'><p>Subgroup Identification: Train Model</p></a></li>
<li><a href='#summary.PRISM'><p>PRISM: Patient Response Identifier for Stratified Medicine (Summary)</p></a></li>
<li><a href='#summary.submod_train'><p>Subgroup Identification (Summary)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stratified Medicine</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Jemielita [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Jemielita &lt;thomasjemielita@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit for stratified medicine, subgroup identification, and precision medicine.
    Current tools include (1) filtering models (reduce covariate space), (2) patient-level estimate
    models (counterfactual patient-level quantities, such as the conditional average treatment effect), 
    (3) subgroup identification models (find subsets of patients with similar treatment effects), 
    and (4) treatment effect estimation and inference (for the overall population and discovered 
    subgroups). These tools can be customized and are directly used in PRISM 
    (patient response identifiers for stratified medicine; Jemielita and Mehrotra 2019
    &lt;<a href="https://doi.org/10.48550/arXiv.1912.03337">doi:10.48550/arXiv.1912.03337</a>&gt;. This package is in beta and will be continually updated.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6),</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, partykit, ranger, survival, glmnet, ggplot2, ggparty,
mvtnorm, coin</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thomasjemielita/StratifiedMedicine">https://github.com/thomasjemielita/StratifiedMedicine</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, MASS, BART, pROC, survRM2, TH.data,
sandwich, rpart, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-29 22:42:30 UTC; jemielth</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-29 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='filter_train'>filter_train: Identify variables of interest</h2><span id='topic+filter_train'></span>

<h3>Description</h3>

<p>Wrapper function to train a filter model to determine variables associated with 
the outcome and/or treatment.. Options include elastic net (glmnet) and random 
forest based variable importance (ranger). Used directly in PRISM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_train(
  Y,
  A,
  X,
  family = "gaussian",
  filter = "glmnet",
  hyper = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_train_+3A_y">Y</code></td>
<td>
<p>The outcome variable. Must be numeric or survival (ex; Surv(time,cens) )</p>
</td></tr>
<tr><td><code id="filter_train_+3A_a">A</code></td>
<td>
<p>Treatment variable. (Default supports binary treatment, either numeric or 
factor). &quot;ple_train&quot; accomodates &gt;2 along with binary treatments.</p>
</td></tr>
<tr><td><code id="filter_train_+3A_x">X</code></td>
<td>
<p>Covariate space.</p>
</td></tr>
<tr><td><code id="filter_train_+3A_family">family</code></td>
<td>
<p>Outcome type. Options include &quot;gaussion&quot; (default), &quot;binomial&quot;, and &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="filter_train_+3A_filter">filter</code></td>
<td>
<p>Filter model to determine variables that are likely associated with the 
outcome and/or treatment. Outputs a potential reduce list of varia where X.star 
has potentially less variables than X. Default is &quot;glmnet&quot; (elastic net). Other 
options include &quot;ranger&quot; (random forest based variable importance with p-values).
See <code>filter_train</code> for more details. &quot;None&quot; uses no filter.</p>
</td></tr>
<tr><td><code id="filter_train_+3A_hyper">hyper</code></td>
<td>
<p>Hyper-parameters for the filter model (must be list). Default is NULL.
See details below.</p>
</td></tr>
<tr><td><code id="filter_train_+3A_...">...</code></td>
<td>
<p>Any additional parameters, not currently passed through.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>filter_train currently fits elastic net or random forest to
find a reduced set of variables which are likely associated with the outcome (Y) 
and/or treatment (A). Current options include:
</p>
<p>1. <strong>glmnet</strong>: Wrapper function for the function &quot;glmnet&quot; from the glmnet package. Here, 
variables with estimated elastic net coefficients of 0 are filtered. Uses LM/GLM/cox 
elastic net for family=&quot;gaussian&quot;,&quot;binomial&quot;, &quot;survival&quot; respectively. Default is to 
regress Y~ENET(X) with hyper-parameters:
</p>
<p>hyper = list(lambda=&quot;lambda.min&quot;, family=&quot;gaussian&quot;,interaction=FALSE))
</p>
<p>If interaction=TRUE, then Y~ENET(X,X*A), and variables with estimated coefficients of 
zero in both the main effects (X) and treatment-interactions (X*A) are filtered. This 
aims to find variables that are prognostic and/or predictive. 
</p>
<p>2. <strong>ranger</strong>: Wrapper function for the function &quot;ranger&quot; (ranger R package) to calculate
random forest based variable importance (VI) p-values. Here, for the test of VI&gt;0,
variables are filtered if their one-sided p-value&gt;=0.10. P-values are obtained
through subsampling based T-statistics (T=VI_j/SE(VE_j)) for feature j through the 
delete-d jackknife), as described in Ishwaran and Lu 2017. Used for continuous, binary, 
or survival outcomes. Default hyper-parameters are:
</p>
<p>hyper=list(b=0.66, K=200, DF2=FALSE, FDR=FALSE, pval.thres=0.10)
</p>
<p>where b=(% of total data to sample; default=66%), K=# of subsamples, FDR (FDR based
multiplicity correction for p-values), pval.thres=0.10 (adjust to change 
filtering threshold). DF2 fits Y~ranger(X, XA) and calculates the 
VI_2DF = VI_X+VI_XA, which is the variable importance of the main effect + the 
interaction effect (joint test). Var(VI_2DF) = Var(VI_X)+Var(VI_AX)+2cov(VI_X, VI_AX) 
where each component is calculated using the subsampling approach described above.
</p>


<h3>Value</h3>

<p>Trained filter model and vector of variable names that pass the filter. 
</p>

<ul>
<li><p> mod - trained model
</p>
</li>
<li><p> filter.vars - Variables that remain after filtering (could be all)
</p>
</li></ul>



<h3>References</h3>

<p>Friedman, J., Hastie, T. and Tibshirani, R. (2008) Regularization Paths for
Generalized Linear Models via Coordinate Descent,
<a href="https://web.stanford.edu/~hastie/Papers/glmnet.pdf">https://web.stanford.edu/~hastie/Papers/glmnet.pdf</a> Journal of Statistical 
Software, Vol. 33(1), 1-22 Feb 2010 Vol. 33(1), 1-22 Feb 2010.
</p>
<p>Wright, M. N. &amp; Ziegler, A. (2017). ranger: A fast implementation of 
random forests for high dimensional data in C++ and R. J Stat Softw 77:1-17. 
doi: <a href="https://doi.org/10.18637/jss.v077.i01">10.18637/jss.v077.i01</a>.
</p>
<p>Ishwaran, H. Lu, M. (2017). Standard errors and confidence intervals 
for variable importance in random forest regression, classification, and survival.
Statistics in Medicine 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PRISM">PRISM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(StratifiedMedicine)
## Continuous ##
dat_ctns = generate_subgrp_data(family="gaussian")
Y = dat_ctns$Y
X = dat_ctns$X
A = dat_ctns$A

# Fit ple_ranger directly (treatment-specific ranger models) #
mod1 = filter_train(Y, A, X, filter="filter_glmnet")
mod1$filter.vars

mod2 = filter_train(Y, A, X, filter="filter_glmnet", hyper=list(interaction=TRUE))
mod2$filter.vars

mod3 = filter_train(Y, A, X, filter="filter_ranger")
mod3$filter.vars




</code></pre>

<hr>
<h2 id='generate_subgrp_data'>Generate Subgroup Data-sets</h2><span id='topic+generate_subgrp_data'></span>

<h3>Description</h3>

<p>Simulation/real data-sets; useful for testing new models and PRISM configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_subgrp_data(n = 800, seed = 513413, family, null = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_subgrp_data_+3A_n">n</code></td>
<td>
<p>sample size (default=800)</p>
</td></tr>
<tr><td><code id="generate_subgrp_data_+3A_seed">seed</code></td>
<td>
<p>seed number (default=513413)</p>
</td></tr>
<tr><td><code id="generate_subgrp_data_+3A_family">family</code></td>
<td>
<p>Outcome type (&quot;gaussian&quot;, &quot;binomial&quot;, &quot;survival&quot;)</p>
</td></tr>
<tr><td><code id="generate_subgrp_data_+3A_null">null</code></td>
<td>
<p>Simulate null hypothesis of no treatment effect and no subgruops. Default
is FALSE.</p>
</td></tr>
<tr><td><code id="generate_subgrp_data_+3A_...">...</code></td>
<td>
<p>Any additional parameters, not currently passed through.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulation data set (Y=outcome, A=treatment, X=covariates)
</p>

<hr>
<h2 id='param_combine'>Overall Population Estimate: Aggregating Subgroup-Specific Parameter Estimates</h2><span id='topic+param_combine'></span>

<h3>Description</h3>

<p>Function that combines subgroup-specific estimates to obtain an overall population
estimate. Options including sample size weighting and max Z weighting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_combine(param.dat, combine = "SS", alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_combine_+3A_param.dat">param.dat</code></td>
<td>
<p>Parameter data-set with subgroup-specific point estimates, SEs, and
sample sizes.</p>
</td></tr>
<tr><td><code id="param_combine_+3A_combine">combine</code></td>
<td>
<p>Method to combine subgroup-specific estimates. Default is &quot;SS&quot;,
or sample size weighting. Another option is &quot;maxZ&quot;(see Mehrotra
and Marceau-West 2021).</p>
</td></tr>
<tr><td><code id="param_combine_+3A_alpha">alpha</code></td>
<td>
<p>Two-sided alpha level for overall population. Default=0.05</p>
</td></tr>
<tr><td><code id="param_combine_+3A_...">...</code></td>
<td>
<p>Any additional parameters, not currently passed through.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data-frame with point estimate, SE, and CI
</p>

<hr>
<h2 id='param_est'>Parameter Estimation: Across Subgroups</h2><span id='topic+param_est'></span>

<h3>Description</h3>

<p>For each identified subgroup, obtain point-estimates and variability metrics
(est, SE, CI). fit separate linear regression models. Point-estimates and
variability metrics in the overall population are obtained by aggregating subgroup
specific results (adaptive weighting or sample size weighting).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_est(
  Y,
  A,
  X,
  param,
  mu_hat = NULL,
  Subgrps,
  alpha_ovrl = 0.05,
  alpha_s = 0.05,
  combine = "SS",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_est_+3A_y">Y</code></td>
<td>
<p>The outcome variable. Must be numeric or survival (ex; Surv(time,cens) )</p>
</td></tr>
<tr><td><code id="param_est_+3A_a">A</code></td>
<td>
<p>Treatment variable. (Default supports binary treatment, either numeric or 
factor). &quot;ple_train&quot; accomodates &gt;2 along with binary treatments.</p>
</td></tr>
<tr><td><code id="param_est_+3A_x">X</code></td>
<td>
<p>Covariate space.</p>
</td></tr>
<tr><td><code id="param_est_+3A_param">param</code></td>
<td>
<p>Parameter estimation and inference function. Based on the discovered 
subgroups, estimate parameter estimates and correspond variability metrics. Options
include &quot;lm&quot; (unadjusted linear regression), &quot;dr&quot; (doubly-robust estimator),
&quot;gcomp&quot; (G-computation, average the patient-level estimates), &quot;cox&quot; (cox regression),
and &quot;rmst&quot; (RMST based estimates as in survRMST package). Default for &quot;gaussian&quot;,
&quot;binomial&quot; is &quot;dr&quot;, while default for &quot;survival&quot; is &quot;cox&quot;. Currently only available 
for binary treatments or A=NULL.</p>
</td></tr>
<tr><td><code id="param_est_+3A_mu_hat">mu_hat</code></td>
<td>
<p>Patient-level estimates (see <code>ple_train</code>)</p>
</td></tr>
<tr><td><code id="param_est_+3A_subgrps">Subgrps</code></td>
<td>
<p>Identified subgroups. Can be pre-specified, or determined
adaptively (see <code>submod_train</code>).</p>
</td></tr>
<tr><td><code id="param_est_+3A_alpha_ovrl">alpha_ovrl</code></td>
<td>
<p>Two-sided alpha level for overall population</p>
</td></tr>
<tr><td><code id="param_est_+3A_alpha_s">alpha_s</code></td>
<td>
<p>Two-sided alpha level at subgroup</p>
</td></tr>
<tr><td><code id="param_est_+3A_combine">combine</code></td>
<td>
<p>Given identified subgroups and correspond point-estimates/SEs/sample sizes,
combine=&quot;SS&quot; will use sample size weighting for estimates at the overall level. Not 
applicable for param=&quot;dr&quot;,&quot;ple&quot;.</p>
</td></tr>
<tr><td><code id="param_est_+3A_...">...</code></td>
<td>
<p>Any additional parameters, not currently passed through.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data-set with parameter estimates and corresponding
variability metrics, for overall and subgroups. Subgrps=&quot;ovrl&quot; corresponds to the overall
population by default.
</p>

<ul>
<li><p> param.dat - Parameter estimates and variability metrics (est, SE,
LCL/UCL = lower/upper confidence limits, pval = p-value).
</p>
</li></ul>



<h3>References</h3>

<p>Funk et al. Doubly Robust Estimation of Causal Effects. 
Am J Epidemiol 2011. 173(7): 761-767.
</p>
<p>Andersen, P. and Gill, R. (1982). Coxâ€™s regression model for counting 
processes, a large sample study. Annals of Statistics 10, 1100-1120.
</p>
<p>Uno et al. Moving beyond the hazard ratio in quantifying the 
between-group difference in survival analysis. Journal of clinical Oncology 2014, 
32, 2380-2385.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+param_combine">param_combine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(StratifiedMedicine)

## Continuous ##
dat_ctns = generate_subgrp_data(family="gaussian")
Y = dat_ctns$Y
X = dat_ctns$X
A = dat_ctns$A

## Identify Subgroups: MOB (lmtree) ##
res_lmtree = submod_train(Y, A, X, submod="lmtree")

## Parameter-estimation ##
param.dat = param_est(Y, A, X, param="lm", Subgrps = res_lmtree$Subgrps.train)
param.dat

</code></pre>

<hr>
<h2 id='ple_train'>Patient-level Estimates: Train Model</h2><span id='topic+ple_train'></span>

<h3>Description</h3>

<p>Wrapper function to train a patient-level estimate (ple) model. Used directly in PRISM
and can be used to directly fit a ple model by name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ple_train(
  Y,
  A,
  X,
  Xtest = NULL,
  family = "gaussian",
  propensity = FALSE,
  ple = "ranger",
  meta = ifelse(family == "survival", "T-learner", "X-learner"),
  hyper = NULL,
  tau = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ple_train_+3A_y">Y</code></td>
<td>
<p>The outcome variable. Must be numeric or survival (ex; Surv(time,cens) )</p>
</td></tr>
<tr><td><code id="ple_train_+3A_a">A</code></td>
<td>
<p>Treatment variable. (Default supports binary treatment, either numeric or 
factor). &quot;ple_train&quot; accomodates &gt;2 along with binary treatments.</p>
</td></tr>
<tr><td><code id="ple_train_+3A_x">X</code></td>
<td>
<p>Covariate space.</p>
</td></tr>
<tr><td><code id="ple_train_+3A_xtest">Xtest</code></td>
<td>
<p>Test set. Default is NULL (no test predictions). Variable types should match X.</p>
</td></tr>
<tr><td><code id="ple_train_+3A_family">family</code></td>
<td>
<p>Outcome type. Options include &quot;gaussion&quot; (default), &quot;binomial&quot;, and &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="ple_train_+3A_propensity">propensity</code></td>
<td>
<p>Propensity score estimation, P(A=a|X). Default=FALSE which 
use the marginal estimates, P(A=a) (applicable for RCT data). If TRUE, will 
use the &quot;ple&quot; base learner to estimate P(A=a|X).</p>
</td></tr>
<tr><td><code id="ple_train_+3A_ple">ple</code></td>
<td>
<p>Base-learner used to estimate patient-level equantities, such as the 
conditional average treatment effect (CATE), E(Y|A=1,X)-E(Y|A=0, X) = CATE(X). 
Default is random based based through &quot;ranger&quot;. &quot;None&quot; uses no ple. See below for 
details on estimating the treatment contrasts.</p>
</td></tr>
<tr><td><code id="ple_train_+3A_meta">meta</code></td>
<td>
<p>Using the ple model as a base learner, meta-learners can be used for 
estimating patient-level treatment differences. Options include &quot;T-learner&quot; (treatment
specific models), &quot;S-learner&quot; (single model), and &quot;X-learner&quot;. For family=&quot;gaussian&quot; &amp;
&quot;binomial&quot;, the default is &quot;X-learner&quot;, which uses a two-stage regression 
approach (See Kunzel et al 2019). For &quot;survival&quot;, the default is &quot;T-learner&quot;. &quot;X-learner&quot; 
is currently not supported for survival outcomes.</p>
</td></tr>
<tr><td><code id="ple_train_+3A_hyper">hyper</code></td>
<td>
<p>Hyper-parameters for the ple model (must be list). Default is NULL.</p>
</td></tr>
<tr><td><code id="ple_train_+3A_tau">tau</code></td>
<td>
<p>Maximum follow-up time for RMST based estimates (family=&quot;survival&quot;). 
Default=NULL, which takes min(max(time[a])), for a=1,..,A.</p>
</td></tr>
<tr><td><code id="ple_train_+3A_...">...</code></td>
<td>
<p>Any additional parameters, not currently passed through.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ple_train uses base-learners along with a meta-learner to obtain patient-level 
estimates under different treatment exposures (see Kunzel et al).  For family=&quot;gaussian&quot; 
or &quot;binomial&quot;, output estimates of <code class="reqn">\mu(a,x)=E(Y|x,a)</code> and treatment differences 
(average treatment effect or risk difference). For survival, either logHR based estimates
or RMST based estimates can be obtained. Current base-learner (&quot;ple&quot;) options include:
</p>
<p>1. <strong>linear</strong>: Uses either linear regression (family=&quot;gaussian&quot;), 
logistic regression (family=&quot;binomial&quot;), or cox regression (family=&quot;survival&quot;). 
No hyper-parameters.
</p>
<p>2. <strong>ranger</strong>: Uses random forest (&quot;ranger&quot; R package). The default hyper-parameters are: 
hyper = list(mtry=NULL, min.node.pct=0.10)
</p>
<p>where mtry is number of randomly selected variables (default=NULL; sqrt(dim(X)))
and min.node.pct is the minimum node size as a function of the total data size 
(ex: min.node.pct=10% requires at least 10
</p>
<p>3. <strong>glmnet</strong>: Uses elastic net (&quot;glmnet&quot; R package). The default hyper-parameters are: 
hyper = list(lambda=&quot;lambda.min&quot;)
</p>
<p>where lambda controls the penalty parameter for predictions. lambda=&quot;lambda.1se&quot;
will likely result in a less complex model. 
</p>
<p>4. <strong>bart</strong>:  Uses bayesian additive regression trees (Chipman et al 2010; 
BART R package). Default hyper-parameters are:
</p>
<p>hyper = list(sparse=FALSE)
</p>
<p>where sparse controls whether to perform variable selection based on a sparse 
Dirichlet prior rather than simply uniform.
</p>


<h3>Value</h3>

<p>Trained ple models and patient-level estimates for train/test sets. 
</p>

<ul>
<li><p> mod - trained model(s)
</p>
</li>
<li><p> mu_train - Patient-level estimates (training set)
</p>
</li>
<li><p> mu_test - Patient-level estimates (test set)
</p>
</li></ul>



<h3>References</h3>

<p>Wright, M. N. &amp; Ziegler, A. (2017). ranger: A fast implementation of 
random forests for high dimensional data in C++ and R. J Stat Softw 77:1-17. 
doi: <a href="https://doi.org/10.18637/jss.v077.i01">10.18637/jss.v077.i01</a>
</p>
<p>Friedman, J., Hastie, T. and Tibshirani, R. (2008) Regularization Paths for
Generalized Linear Models via Coordinate Descent,
<a href="https://web.stanford.edu/~hastie/Papers/glmnet.pdf">https://web.stanford.edu/~hastie/Papers/glmnet.pdf</a> Journal of Statistical 
Software, Vol. 33(1), 1-22 Feb 2010 Vol. 33(1), 1-22 Feb 2010.
</p>
<p>Chipman, H., George, E., and McCulloch R. (2010) Bayesian Additive 
Regression Trees. The Annals of Applied Statistics, 4,1, 266-298
</p>
<p>Kunzel S, Sekhon JS, Bickel PJ, Yu B. Meta-learners for Estimating
Hetergeneous Treatment Effects using Machine Learning. 2019.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PRISM">PRISM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(StratifiedMedicine)
## Continuous ##
dat_ctns = generate_subgrp_data(family="gaussian")
Y = dat_ctns$Y
X = dat_ctns$X
A = dat_ctns$A


# X-Learner (With ranger based learners)
mod1 = ple_train(Y=Y, A=A, X=X, Xtest=X, ple="ranger", method="X-learner")
summary(mod1$mu_train)

# T-Learner (Treatment specific)
mod2 = ple_train(Y=Y, A=A, X=X, Xtest=X, ple="ranger", method="T-learner")
summary(mod2$mu_train)


mod3 = ple_train(Y=Y, A=A, X=X, Xtest=X, ple="bart", method="X-learner")
summary(mod3$mu_train)



</code></pre>

<hr>
<h2 id='plot_dependence'>Partial dependence plots: Single Variable (marginal effect) or heat map (2 to 
3 variables).</h2><span id='topic+plot_dependence'></span>

<h3>Description</h3>

<p>Partial dependence plots: Single Variable (marginal effect) or heat map (2 to 
3 variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dependence(object, X = NULL, target = NULL, vars, grid.data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_dependence_+3A_object">object</code></td>
<td>
<p>Fitted <code>ple_train</code> or <code>PRISM</code> object</p>
</td></tr>
<tr><td><code id="plot_dependence_+3A_x">X</code></td>
<td>
<p>input covariate space. Default=NULL.</p>
</td></tr>
<tr><td><code id="plot_dependence_+3A_target">target</code></td>
<td>
<p>Which patient-level estimate to target for PDP based plots. Default=NULL, 
which uses the estimated treatment difference.</p>
</td></tr>
<tr><td><code id="plot_dependence_+3A_vars">vars</code></td>
<td>
<p>Variables to visualize (ex: c(&quot;var1&quot;, &quot;var2&quot;, &quot;var3)). If no grid.data 
provided, defaults to using seq(min(var), max(var)) for each continuous variables. 
For categorical, uses all categories.</p>
</td></tr>
<tr><td><code id="plot_dependence_+3A_grid.data">grid.data</code></td>
<td>
<p>Input grid of values for 2-3 covariates (if 3, last variable cannot
be continuous). This is required for type=&quot;heatmap&quot;. Default=NULL.</p>
</td></tr>
<tr><td><code id="plot_dependence_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot (ggplot2) object
</p>


<h3>References</h3>


<ul>
<li><p> Friedman, J. Greedy function approximation: A gradient boosting machine.
Annals of statistics (2001): 1189-1232
</p>
</li>
<li><p> Zhao, Qingyuan, and Trevor Hastie. Causal interpretations of black-box models.
Journal of Business &amp; Economic Statistics, to appear. (2017).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(StratifiedMedicine)
## Continuous ##
dat_ctns = generate_subgrp_data(family="gaussian")
Y = dat_ctns$Y
X = dat_ctns$X
A = dat_ctns$A


# Fit through ple_train wrapper #
mod = ple_train(Y=Y, A=A, X=X, Xtest=X, ple="ranger", meta="X-learner")
plot_dependence(mod, X=X, vars="X1")


</code></pre>

<hr>
<h2 id='plot_importance'>Importance Plot: Visualize relative importance of variables</h2><span id='topic+plot_importance'></span>

<h3>Description</h3>

<p>Importance is currently based on the PRISM filter model. For elastic net (filter_glmnet).
variables with non-zero coefficients are shown. For random forest variable importance 
(filter_ranger), variables are sorted by their p-values, and &quot;top_n&quot; will show only the
&quot;top_n&quot; most importance variables (based on p-values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_importance(object, top_n = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_importance_+3A_object">object</code></td>
<td>
<p>PRISM object</p>
</td></tr>
<tr><td><code id="plot_importance_+3A_top_n">top_n</code></td>
<td>
<p>Show top_n variables only, default=NULL (show all)</p>
</td></tr>
<tr><td><code id="plot_importance_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot (ggplot2) object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(StratifiedMedicine)
## Continuous ##
dat_ctns = generate_subgrp_data(family="gaussian")
Y = dat_ctns$Y
X = dat_ctns$X
A = dat_ctns$A

mod1 = filter_train(Y=Y, A=A, X=X)
plot_importance(mod1)
</code></pre>

<hr>
<h2 id='plot_ple'>Patient-Level Estimate Plot (plot_ple): Visualize distribution of estimates</h2><span id='topic+plot_ple'></span>

<h3>Description</h3>

<p>Plots based on Patient-level estimate (see <code>ple_train</code>) model results. Options 
include &quot;waterfall&quot; and &quot;density&quot;. Target controls which column of &quot;mu_train&quot; 
(from ple_train object) is shown on the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ple(object, target = NULL, type = "waterfall", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ple_+3A_object">object</code></td>
<td>
<p><code>ple_train</code> object</p>
</td></tr>
<tr><td><code id="plot_ple_+3A_target">target</code></td>
<td>
<p>Which patient-level estimate to visualize. Default=NULL, which uses 
the estimated treatment difference.</p>
</td></tr>
<tr><td><code id="plot_ple_+3A_type">type</code></td>
<td>
<p>TYpe of plot. Default=&quot;waterfall&quot;; type=&quot;density&quot; shows density plot.</p>
</td></tr>
<tr><td><code id="plot_ple_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot (ggplot2) object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(StratifiedMedicine)
## Continuous ##
dat_ctns = generate_subgrp_data(family="gaussian")
Y = dat_ctns$Y
X = dat_ctns$X
A = dat_ctns$A


mod1 = ple_train(Y=Y, A=A, X=X, Xtest=X, ple="ranger", meta="X-learner")
plot_ple(mod1)


</code></pre>

<hr>
<h2 id='plot_tree'>Tree Plot: Tree Structure, Subgroup-specific treatment estimates</h2><span id='topic+plot_tree'></span>

<h3>Description</h3>

<p>For partykit or rpart based tree models, visualize tree structure and subgroup (node)
specific treatment estimates. Plots (ggparty) can include other node-specific information, 
see below for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tree(
  object,
  prob.thres = "&gt;0",
  plots = "outcome",
  nudge_out = 0.1,
  width_out = 0.5,
  nudge_dens = ifelse(plots == "both", 0.3, 0.1),
  width_dens = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_tree_+3A_object">object</code></td>
<td>
<p>PRISM or submod_train object</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_prob.thres">prob.thres</code></td>
<td>
<p>Probability threshold, ex: P(Mean(A=1 vs A=0)&gt;c. Default=NULL, 
which defaults to using &quot;&gt;0&quot;, unless param=&quot;cox&quot;, which  &quot;P(HR(A=1 vs A=0))&lt;1&quot;. 
If a density plot is included, setting prob.thres=&quot;&gt;c&quot; will use green colors 
for values above c, and red colors for values below c. If tree.thres=&quot;&lt;c&quot;, the 
reverse color scheme is used.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_plots">plots</code></td>
<td>
<p>Type of plots to include in each node of the &quot;tree&quot; plot. Default=&quot;outcome&quot;. 
For non-survival data, if the fitted PRISM object (x) does not include patient-level 
estimates (ple=&quot;None&quot;), or if param=&quot;lm&quot;, this will plot the observed outcomes (Y) by the 
treatment assignment (A). If the fitted PRISM object includes patient-level estimates 
(ex: ple=&quot;ranger&quot;), this includes box-plots of the model-based (if param=&quot;ple&quot;) or double-robust
based (if param=&quot;dr&quot;) counter-factual estimates of E(Y|X,A=a) for continuous outcomes or 
Prob(Y=1|X,A=a) for binary outcomes (truncated to 0,1). For survival data, Kaplan-Meier 
based survival estimates are plotted by treatment group. For &quot;density&quot;, the estimated 
probability density of the treatment effects is shown (normal approximation, unless resampling is used). 
&quot;both&quot; include the &quot;outcome&quot; and &quot;density&quot; plots. If tree.plots = &quot;none&quot;, then only the 
tree structure is shown.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_nudge_out">nudge_out</code></td>
<td>
<p>Nudge tree outcome plot (see ggparty for details)</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_width_out">width_out</code></td>
<td>
<p>Width of tree outcome plot (see ggparty for details)</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_nudge_dens">nudge_dens</code></td>
<td>
<p>Nudge tree density plot</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_width_dens">width_dens</code></td>
<td>
<p>Width of density tree outcome plot</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot (ggplot2) object
</p>

<hr>
<h2 id='plot.PRISM'>plot.PRISM</h2><span id='topic+plot.PRISM'></span>

<h3>Description</h3>

<p>Plots PRISM results. Options include &quot;tree&quot;, &quot;forest&quot;, &quot;resample&quot;, and &quot;PLE:waterfall&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PRISM'
plot(
  x,
  type = "tree",
  target = NULL,
  grid.data = NULL,
  grid.thres = "&gt;0",
  prob.thres = NULL,
  tree.plots = "outcome",
  nudge_out = 0.1,
  width_out = 0.5,
  nudge_dens = ifelse(tree.plots == "both", 0.3, 0.1),
  width_dens = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.PRISM_+3A_x">x</code></td>
<td>
<p>PRISM object</p>
</td></tr>
<tr><td><code id="plot.PRISM_+3A_type">type</code></td>
<td>
<p>Type of plot (default=&quot;tree&quot;, <code>ggparty</code> based plot with parameter 
estimates, along with options for including outcome or probability based plots). 
Other options include  &quot;forest&quot; (forest plot for overall and subgroups),&quot;PLE:waterfall&quot; 
(waterfall plot of PLEs), &quot;PLE:density&quot; (density plot of PLEs), &quot;resample&quot; (resampling 
distribution of parameter estimates for overall and subgroups), and &quot;heatmap&quot; 
(heatmap of ple estimates/probabilities). For &quot;tree&quot; and &quot;forest&quot;, CIs are based on 
the observed data unless resampling is used. For bootstrap resampling, if 
calibrate=TRUE, then calibrated CIs along are shown, otherse CIs based on the 
percentile method are shown.</p>
</td></tr>
<tr><td><code id="plot.PRISM_+3A_target">target</code></td>
<td>
<p>For &quot;resample&quot; plot only, must be specify which estimand to visualize.
Default=NULL.</p>
</td></tr>
<tr><td><code id="plot.PRISM_+3A_grid.data">grid.data</code></td>
<td>
<p>Input grid of values for 2-3 covariates (if 3, last variable cannot
be continuous). This is required for type=&quot;heatmap&quot;. Default=NULL.</p>
</td></tr>
<tr><td><code id="plot.PRISM_+3A_grid.thres">grid.thres</code></td>
<td>
<p>Threshold for PLE, ex: I(PLE&gt;thres). Used to estimate P(PLE&gt;thres) for
type=&quot;heatmap&quot;. Default is &quot;&gt;0&quot;. Direction can be reversed and can include equality
sign (ex: &quot;&lt;=&quot;).</p>
</td></tr>
<tr><td><code id="plot.PRISM_+3A_prob.thres">prob.thres</code></td>
<td>
<p>Probability threshold, ex: P(Mean(A=1 vs A=0)&gt;c. Default=NULL, 
which defaults to using &quot;&gt;0&quot;, unless param=&quot;cox&quot;, which  &quot;P(HR(A=1 vs A=0))&lt;1&quot;. 
If a density plot is included, setting prob.thres=&quot;&gt;c&quot; will use green colors 
for values above c, and red colors for values below c. If prob.thres=&quot;&lt;c&quot;, the 
reverse color scheme is used.</p>
</td></tr>
<tr><td><code id="plot.PRISM_+3A_tree.plots">tree.plots</code></td>
<td>
<p>Type of plots to include in each node of the &quot;tree&quot; plot. Default=&quot;outcome&quot;. 
For non-survival data, if the fitted PRISM object (x) does not include patient-level 
estimates (ple=&quot;None&quot;), or if param=&quot;lm&quot;, this will plot the observed outcomes (Y) by the 
treatment assignment (A). If the fitted PRISM object includes patient-level estimates 
(ex: ple=&quot;ranger&quot;), this includes box-plots of the model-based (if param=&quot;ple&quot;) or double-robust
based (if param=&quot;dr&quot;) counter-factual estimates of E(Y|X,A=a) for continuous outcomes or 
Prob(Y=1|X,A=a) for binary outcomes (truncated to 0,1). For survival data, Kaplan-Meier 
based survival estimates are plotted by treatment group. For &quot;density&quot;, the estimated 
probability density of the treatment effects is shown (normal approximation, unless resampling is used). 
&quot;both&quot; include the &quot;outcome&quot; and &quot;density&quot; plots. If tree.plots = &quot;none&quot;, then only the 
tree structure is shown.</p>
</td></tr>
<tr><td><code id="plot.PRISM_+3A_nudge_out">nudge_out</code></td>
<td>
<p>Nudge tree outcome plot (see ggparty for details)</p>
</td></tr>
<tr><td><code id="plot.PRISM_+3A_width_out">width_out</code></td>
<td>
<p>Width of tree outcome plot (see ggparty for details)</p>
</td></tr>
<tr><td><code id="plot.PRISM_+3A_nudge_dens">nudge_dens</code></td>
<td>
<p>Nudge tree density plot</p>
</td></tr>
<tr><td><code id="plot.PRISM_+3A_width_dens">width_dens</code></td>
<td>
<p>Width of density tree outcome plot</p>
</td></tr>
<tr><td><code id="plot.PRISM_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot (ggplot2) object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PRISM">PRISM</a></code>
</p>

<hr>
<h2 id='predict.ple_train'>Patient-level Estimates Model: Prediction</h2><span id='topic+predict.ple_train'></span>

<h3>Description</h3>

<p>Prediction function for the trained patient-level estimate (ple) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ple_train'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ple_train_+3A_object">object</code></td>
<td>
<p>Trained ple model.</p>
</td></tr>
<tr><td><code id="predict.ple_train_+3A_newdata">newdata</code></td>
<td>
<p>Data-set to make predictions at (Default=NULL, predictions correspond
to training data).</p>
</td></tr>
<tr><td><code id="predict.ple_train_+3A_...">...</code></td>
<td>
<p>Any additional parameters, not currently passed through.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data-frame with predictions (depends on trained ple model).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PRISM">PRISM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(StratifiedMedicine)
## Continuous ##
dat_ctns = generate_subgrp_data(family="gaussian")
Y = dat_ctns$Y
X = dat_ctns$X
A = dat_ctns$A


mod1 = ple_train(Y=Y, A=A, X=X, Xtest=X, ple="ranger", meta="X-learner")
summary(mod1$mu_train)

res1 = predict(mod1, newdata=X)
summary(res1)


</code></pre>

<hr>
<h2 id='predict.PRISM'>PRISM: Patient Response Identifier for Stratified Medicine (Predictions)</h2><span id='topic+predict.PRISM'></span>

<h3>Description</h3>

<p>Predictions for PRISM algorithm. Given the training set (Y,A,X) or new test set (Xtest),
output ple predictions and identified subgroups with correspond parameter estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PRISM'
predict(object, newdata = NULL, type = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.PRISM_+3A_object">object</code></td>
<td>
<p>Trained PRISM model.</p>
</td></tr>
<tr><td><code id="predict.PRISM_+3A_newdata">newdata</code></td>
<td>
<p>Data-set to make predictions at (Default=NULL, predictions correspond
to training data).</p>
</td></tr>
<tr><td><code id="predict.PRISM_+3A_type">type</code></td>
<td>
<p>Type of prediction. Default is &quot;all&quot; (ple, submod, and param predictions).
Other options include &quot;ple&quot; (ple predictions), &quot;submod&quot; (submod predictions with
associated parameter estimates).</p>
</td></tr>
<tr><td><code id="predict.PRISM_+3A_...">...</code></td>
<td>
<p>Any additional parameters, not currently passed through.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data-frame with predictions (ple, submod, or both).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load library ##
library(StratifiedMedicine)

##### Examples: Continuous Outcome ###########

dat_ctns = generate_subgrp_data(family="gaussian")
Y = dat_ctns$Y
X = dat_ctns$X
A = dat_ctns$A

# Run Default: filter_glmnet, ple_ranger, lmtree, param_ple #
res0 = PRISM(Y=Y, A=A, X=X)
summary(predict(res0, X)) # all #
summary(predict(res0, X, type="ple"))
summary(predict(res0, X, type="submod"))



</code></pre>

<hr>
<h2 id='predict.submod_train'>Subgroup Identification: Train Model (Predictions)</h2><span id='topic+predict.submod_train'></span>

<h3>Description</h3>

<p>Prediction function for the trained subgroup identification model (submod).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'submod_train'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.submod_train_+3A_object">object</code></td>
<td>
<p>Trained submod model.</p>
</td></tr>
<tr><td><code id="predict.submod_train_+3A_newdata">newdata</code></td>
<td>
<p>Data-set to make predictions at (Default=NULL, predictions correspond
to training data).</p>
</td></tr>
<tr><td><code id="predict.submod_train_+3A_...">...</code></td>
<td>
<p>Any additional parameters, not currently passed through.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Identified subgroups with subgroup-specific predictions (depends on subgroup
model)
</p>

<ul>
<li><p> Subgrps - Identified subgroups
</p>
</li>
<li><p> pred - Predictions, depends on subgroup model
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(StratifiedMedicine)
## Continuous ##
dat_ctns = generate_subgrp_data(family="gaussian")
Y = dat_ctns$Y
X = dat_ctns$X
A = dat_ctns$A

# Fit through submod_train wrapper #
mod1 = submod_train(Y=Y, A=A, X=X, Xtest=X, submod="submod_lmtree")
out1 = predict(mod1)
table(mod1$Subgrps.train)
table(out1$Subgrps)

</code></pre>

<hr>
<h2 id='PRISM'>PRISM: Patient Response Identifier for Stratified Medicine</h2><span id='topic+PRISM'></span>

<h3>Description</h3>

<p>PRISM algorithm. Given a data-set of (Y, A, X) (Outcome, treatment, covariates),
the <code>PRISM</code> identifies potential subgroups along with point-estimate and variability
metrics; with and without resampling (bootstrap or cross-validation based). This four 
step procedure (filter, ple, submod, param) is flexible and accepts user-inputs at each
step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PRISM(
  Y,
  A = NULL,
  X,
  Xtest = NULL,
  mu_train = NULL,
  family = "gaussian",
  filter = "glmnet",
  ple = "ranger",
  submod = NULL,
  param = NULL,
  meta = ifelse(family == "survival", "T-learner", "X-learner"),
  pool = "no",
  delta = "&gt;0",
  propensity = FALSE,
  combine = "SS",
  alpha_ovrl = 0.05,
  alpha_s = 0.05,
  filter.hyper = NULL,
  ple.hyper = NULL,
  submod.hyper = NULL,
  resample = NULL,
  stratify = ifelse(!is.null(A), "trt", "no"),
  R = NULL,
  resample_submod = NULL,
  R_submod = NULL,
  resample_pool = NULL,
  R_pool = NULL,
  calibrate = FALSE,
  alpha.mat = NULL,
  filter.resamp = NULL,
  ple.resamp = NULL,
  verbose = TRUE,
  verbose.resamp = FALSE,
  seed = 777,
  efficient = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PRISM_+3A_y">Y</code></td>
<td>
<p>The outcome variable. Must be numeric or survival (ex; Surv(time,cens) )</p>
</td></tr>
<tr><td><code id="PRISM_+3A_a">A</code></td>
<td>
<p>Treatment variable. (Default supports binary treatment, either numeric or 
factor). &quot;ple_train&quot; accomodates &gt;2 along with binary treatments.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_x">X</code></td>
<td>
<p>Covariate space.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_xtest">Xtest</code></td>
<td>
<p>Test set. Default is NULL (no test predictions). Variable types should match X.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_mu_train">mu_train</code></td>
<td>
<p>Patient-level estimates in training set (see <code>ple_train</code>). 
Default=NULL</p>
</td></tr>
<tr><td><code id="PRISM_+3A_family">family</code></td>
<td>
<p>Outcome type. Options include &quot;gaussion&quot; (default), &quot;binomial&quot;, and &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_filter">filter</code></td>
<td>
<p>Filter model to determine variables that are likely associated with the 
outcome and/or treatment. Outputs a potential reduce list of varia where X.star 
has potentially less variables than X. Default is &quot;glmnet&quot; (elastic net). Other 
options include &quot;ranger&quot; (random forest based variable importance with p-values).
See <code>filter_train</code> for more details. &quot;None&quot; uses no filter.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_ple">ple</code></td>
<td>
<p>Base-learner used to estimate patient-level equantities, such as the 
conditional average treatment effect (CATE), E(Y|A=1,X)-E(Y|A=0, X) = CATE(X). 
Default is random based based through &quot;ranger&quot;. &quot;None&quot; uses no ple. See below for 
details on estimating the treatment contrasts.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_submod">submod</code></td>
<td>
<p>Subgroup identification model function. Options include tree-methods that 
target the treatment by variable interaction directly (&quot;lmtree&quot;, &quot;glmtree&quot;, &quot;mob_weib&quot;),
regress the CATE (&quot;rpart_cate&quot;, &quot;ctree_cate&quot;), and target prognostic variables (&quot;rpart&quot;, &quot;ctree&quot;).
Default for family=&quot;gaussian&quot; is &quot;lmtree&quot; (MOB with OLS loss). For &quot;binomial&quot; the default is 
&quot;glmtree&quot; (MOB with binomial loss). Default for &quot;survival&quot; is &quot;lmtree&quot; (log-rank transformation 
on survival outcomes and then fit MOB-OLS). &quot;None&quot; uses no submod. Currently only available for 
binary treatments or A=NULL.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_param">param</code></td>
<td>
<p>Parameter estimation and inference function. Based on the discovered 
subgroups, estimate parameter estimates and correspond variability metrics. Options
include &quot;lm&quot; (unadjusted linear regression), &quot;dr&quot; (doubly-robust estimator),
&quot;gcomp&quot; (G-computation, average the patient-level estimates), &quot;cox&quot; (cox regression),
and &quot;rmst&quot; (RMST based estimates as in survRMST package). Default for &quot;gaussian&quot;,
&quot;binomial&quot; is &quot;dr&quot;, while default for &quot;survival&quot; is &quot;cox&quot;. Currently only available 
for binary treatments or A=NULL.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_meta">meta</code></td>
<td>
<p>Using the ple model as a base learner, meta-learners can be used for 
estimating patient-level treatment differences. Options include &quot;T-learner&quot; (treatment
specific models), &quot;S-learner&quot; (single model), and &quot;X-learner&quot;. For family=&quot;gaussian&quot; &amp;
&quot;binomial&quot;, the default is &quot;X-learner&quot;, which uses a two-stage regression 
approach (See Kunzel et al 2019). For &quot;survival&quot;, the default is &quot;T-learner&quot;. &quot;X-learner&quot; 
is currently not supported for survival outcomes.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_pool">pool</code></td>
<td>
<p>Whether to pool the initial identified subgroups (ex: tree nodes).
Default = &quot;no&quot;. Other options include &quot;trteff&quot; or &quot;trteff_boot&quot; (check if 
naive or bootstrap treatment estimate is beyond clinical meaningful 
threshold delta, ex: trteff_boot &gt; 0), and optimal treatment regime (OTR) pooling, 
&quot;otr:logistic&quot;, &quot;otr:rf&quot;. &quot;otr:logistic&quot; fits weighted logistic regression 
with I(mu_1-mu_0&gt;delta) as the outcome, the candidate subgroups as covariates, 
and weights=abs((mu_1-mu_0) - delta). &quot;otr:rf&quot; follows the same approach but 
with weighted random forest, and also includes X in the regression. Regardless 
of the pooling approach, the key output is &quot;trt_assign&quot;, a data-frame with the 
initial subgroups and the pooled subgroups (ex: dopt=1, patient should receive
A=1, vs dopt=0, patient should receive A=0).</p>
</td></tr>
<tr><td><code id="PRISM_+3A_delta">delta</code></td>
<td>
<p>Threshold for defining benefit vs non-benefitting patients. 
Only applicable for submod=&quot;otr&quot;, and if pooling is used (see &quot;pool&quot;). 
Default=&quot;&gt;0&quot;.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_propensity">propensity</code></td>
<td>
<p>Propensity score estimation, P(A=a|X). Default=FALSE which 
use the marginal estimates, P(A=a) (applicable for RCT data). If TRUE, will 
use the &quot;ple&quot; base learner to estimate P(A=a|X).</p>
</td></tr>
<tr><td><code id="PRISM_+3A_combine">combine</code></td>
<td>
<p>Method of combining group-specific point-estimates. Options 
include &quot;SS&quot; (sample size weighting), and &quot;maxZ&quot; 
(see: Mehrotra and Marceau-West). This is used for pooling (ex: within dopt=1
groups, aggregate group-specific treatment estimates), and for calculating 
the overall population treatment effect estimate.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_alpha_ovrl">alpha_ovrl</code></td>
<td>
<p>Two-sided alpha level for overall population. Default=0.05</p>
</td></tr>
<tr><td><code id="PRISM_+3A_alpha_s">alpha_s</code></td>
<td>
<p>Two-sided alpha level at subgroup level. Default=0.05</p>
</td></tr>
<tr><td><code id="PRISM_+3A_filter.hyper">filter.hyper</code></td>
<td>
<p>Hyper-parameters for the filter function (must be list). 
Default is NULL.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_ple.hyper">ple.hyper</code></td>
<td>
<p>Hyper-parameters for the PLE function (must be list). 
Default is NULL.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_submod.hyper">submod.hyper</code></td>
<td>
<p>Hyper-parameters for the submod function (must be list). 
Default is NULL.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_resample">resample</code></td>
<td>
<p>Resampling method for resample-based treatment effect estimates 
and variability metrics. Options include &quot;Bootstrap&quot; and 
&quot;CV&quot; (cross-validation). Default=NULL (No resampling).</p>
</td></tr>
<tr><td><code id="PRISM_+3A_stratify">stratify</code></td>
<td>
<p>Stratified resampling? Default=&quot;trt&quot; (stratify by A). Other
options include &quot;sub&quot; (stratify by the identified subgroups), &quot;trt_sub&quot; 
(stratify by A and the identified subgroups), and &quot;no&quot; (no stratification).</p>
</td></tr>
<tr><td><code id="PRISM_+3A_r">R</code></td>
<td>
<p>Number of resamples (default=NULL; R=100 for Permutation/Bootstrap 
and R=5 for CV). This resamples the entire PRISM procedure.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_resample_submod">resample_submod</code></td>
<td>
<p>For submod only, resampling method for treatment effect estimates.
Options include &quot;Bootstrap&quot; or NULL (no resampling).</p>
</td></tr>
<tr><td><code id="PRISM_+3A_r_submod">R_submod</code></td>
<td>
<p>Number of resamples for resample_submod</p>
</td></tr>
<tr><td><code id="PRISM_+3A_resample_pool">resample_pool</code></td>
<td>
<p>For submod only, resampling method for pooling step. 
nly applicable if resample_submod=&quot;Bootstrap&quot; and/or pool=&quot;trteff_boot&quot;.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_r_pool">R_pool</code></td>
<td>
<p>Number of resamples for resample_pool</p>
</td></tr>
<tr><td><code id="PRISM_+3A_calibrate">calibrate</code></td>
<td>
<p>Bootstrap calibration for nominal alpha (Loh et al 2016).
Default=FALSE. For TRUE, outputs the calibrated alpha level and calibrated 
CIs for the overall population and subgroups. Not applicable for permutation 
or CV resampling.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_alpha.mat">alpha.mat</code></td>
<td>
<p>Grid of alpha values for calibration. Default=NULL, which 
uses seq(alpha/1000,alpha,by=0.005) for alpha_ovrl/alpha_s.</p>
</td></tr>
<tr><td><code id="PRISM_+3A_filter.resamp">filter.resamp</code></td>
<td>
<p>Filter function during re-sampling. Default=NULL 
(uses &quot;filter&quot;). If &quot;None&quot;, the &quot;filter&quot; model is not trained in each resample,
and instead use filtered variables from the observed data &quot;filter&quot; step. 
(less computationally expensive).</p>
</td></tr>
<tr><td><code id="PRISM_+3A_ple.resamp">ple.resamp</code></td>
<td>
<p>Ple function during re-sampling. Default=NULL 
(uses &quot;ple&quot;). If &quot;None&quot;, the &quot;ple&quot; model is not training in each resample, 
and instead the original model estimates are resampled (less computationally
expensive).</p>
</td></tr>
<tr><td><code id="PRISM_+3A_verbose">verbose</code></td>
<td>
<p>Detail progress of PRISM? Default=TRUE</p>
</td></tr>
<tr><td><code id="PRISM_+3A_verbose.resamp">verbose.resamp</code></td>
<td>
<p>Output iterations during resampling? Default=FALSE</p>
</td></tr>
<tr><td><code id="PRISM_+3A_seed">seed</code></td>
<td>
<p>Seed for PRISM run (Default=777)</p>
</td></tr>
<tr><td><code id="PRISM_+3A_efficient">efficient</code></td>
<td>
<p>If TRUE (default for PRISM), then models (filter, ple, submod) will 
store reduced set of outputs for faster speed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PRISM is a general framework with five key steps:
</p>
<p>0. Estimand: Determine the question of interest (ex: mean treatment difference)
</p>
<p>1. Filter (filter): Reduce covariate space by removing noise covariates. Options include 
elastic net (&quot;glmnet&quot;) and random forest variable importance (&quot;ranger&quot;).
</p>
<p>2. Patient-Level Estimates (ple): Estimate counterfactual patient-level quantities, 
for example, the conditional average treatment effect (CATE), E(Y|A=1,X)-E(Y|A=0,X). 
This calls the &quot;ple_train&quot; function, and follows the framework of Kunzel et al 2019. 
Base-learners include random forest (&quot;ranger&quot;), BART (&quot;bart&quot;), elastic net (&quot;glmnet&quot;), 
and linear models (LM, GLM, or Cox regression). Meta-learners include the &quot;S-Learner&quot; 
(single model), &quot;T-learner&quot; (treatment specific models), and &quot;X-learner&quot; (2-stage approach).
</p>
<p>3. Subgroup Model (submod): Currently uses tree-based methods to identify predictive 
and/or prognostic subgroups. Options include MOB OLS (&quot;lmtree&quot;), MOB GLM (&quot;glmtree&quot;), 
MOB Weibull (&quot;mob_weib&quot;), conditional inference trees (&quot;ctree&quot;, Y~ctree(X); &quot;ctree_cate&quot;, 
CATE~ctree(X)), and recursive partitioning and regression trees (&quot;rpart&quot;, Y~rpart(X); &quot;rpart_cate&quot;, 
CATE~rpart(X)), and optimal treatment regimes (&quot;otr&quot;).
</p>
<p>4. Treatment Effect Estimation (param): For the overall population and the discovered 
subgroups (if any), obtain treatment effect point-estimates and variability metrics. 
Options include: cox regression (&quot;cox&quot;), double robust estimator (&quot;dr&quot;), linear regression 
(&quot;lm&quot;), average of patient-level estimates (&quot;gcomp&quot;), and restricted mean survival 
time (&quot;rmst&quot;).
</p>
<p>Steps 1-4 also support user-specific models. If treatment is provided (A!=NULL), 
the default settings are as follows:
</p>
<p>Y is continuous (family=&quot;gaussian&quot;): 
Elastic Net Filter ==&gt; X-learner with random forest ==&gt; MOB (OLS) ==&gt; 
Double Robust estimator
</p>
<p>Y is binary (family=&quot;binomial&quot;): 
Elastic Net Filter ==&gt; X-learner with random forest ==&gt; MOB (GLM) ==&gt; 
Double Robust estimator
</p>
<p>Y is right-censored (family=&quot;survival&quot;):
Elastic Net Filter ==&gt; T-learner with random forest ==&gt; MOB (Weibull) ==&gt; 
Cox regression
</p>
<p>If treatment is not provided (A=NULL), the default settings are as follows:
</p>
<p>Y is continuous (family=&quot;gaussian&quot;): 
Elastic Net Filter ==&gt; Random Forest ==&gt; ctree ==&gt; linear regression
</p>
<p>Y is binary (family=&quot;binomial&quot;): 
Elastic Net Filter ==&gt; Random Forest ==&gt; ctree ==&gt; linear regression
</p>
<p>Y is right-censored (family=&quot;survival&quot;):
Elastic Net Filter ==&gt; Survival Random Forest ==&gt; ctree ==&gt; RMST
</p>


<h3>Value</h3>

<p>Trained PRISM object. Includes filter, ple, submod, and param outputs.
</p>

<ul>
<li><p> filter.mod - Filter model
</p>
</li>
<li><p> filter.vars - Variables remaining after filtering
</p>
</li>
<li><p> ple.fit - Fitted ple model (model fit, other fit outputs)
</p>
</li>
<li><p> mu_train - Patient-level estimates (train)
</p>
</li>
<li><p> mu_test - Patient-level estimates (test)
</p>
</li>
<li><p> submod.fit - Fitted submod model (model fit, other fit outputs)
</p>
</li>
<li><p> out.train - Training data-set with identified subgroups
</p>
</li>
<li><p> out.test - Test data-set with identified subgroups
</p>
</li>
<li><p> Rules - Subgroup rules / definitions
</p>
</li>
<li><p> param.dat - Parameter estimates and variablity metrics (depends on param)
</p>
</li>
<li><p> resamp_dist - Resampling distributions (NULL if no resampling is done)
</p>
</li></ul>



<h3>References</h3>

<p>Friedman, J., Hastie, T. and Tibshirani, R. (2008) Regularization Paths for
Generalized Linear Models via Coordinate Descent, 
<a href="https://web.stanford.edu/~hastie/Papers/glmnet.pdf">https://web.stanford.edu/~hastie/Papers/glmnet.pdf</a> Journal of Statistical 
Software, Vol. 33(1), 1-22 Feb 2010 Vol. 33(1), 1-22 Feb 2010.
</p>
<p>Jemielita T, Mehrotra D. PRISM: Patient Response Identifiers for 
Stratified Medicine. <a href="https://arxiv.org/abs/1912.03337">https://arxiv.org/abs/1912.03337</a>
</p>
<p>Hothorn T, Hornik K, Zeileis A (2006). Unbiased Recursive Partitioning: 
A Conditional Inference Framework. Journal of Computational and Graphical Statistics,
15(3), 651â€“674.
</p>
<p>Wright, M. N. &amp; Ziegler, A. (2017). ranger: A fast implementation of 
random forests for high dimensional data in C++ and R. J Stat Softw 77:1-17. 
doi: <a href="https://doi.org/10.18637/jss.v077.i01">10.18637/jss.v077.i01</a>.
</p>
<p>Zeileis A, Hothorn T, Hornik K (2008). Model-Based Recursive Partitioning. 
Journal of Computational and Graphical Statistics, 17(2), 492â€“514.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load library ##
library(StratifiedMedicine)

## Examples: Continuous Outcome ##

dat_ctns = generate_subgrp_data(family="gaussian")
Y = dat_ctns$Y
X = dat_ctns$X
A = dat_ctns$A

# Run Default: glmnet, ranger (X-learner), lmtree, dr #
res0 = PRISM(Y=Y, A=A, X=X)
summary(res0)
plot(res0)

res1 = PRISM(Y=Y, A=A, X=X, filter="None")
summary(res1)
plot(res1)


# Search for Prognostic Only (omit A from function) #

res3 = PRISM(Y=Y, X=X)
summary(res3)
plot(res3)


## With bootstrap (No filtering) ##

library(ggplot2)
  res_boot = PRISM(Y=Y, A=A, X=X, resample = "Bootstrap", R=50, verbose.resamp = TRUE)
  # Plot of distributions and P(est&gt;0) #
  plot(res_boot, type="resample", estimand = "E(Y|A=1)-E(Y|A=0)")+
  geom_vline(xintercept = 0)
  aggregate(I(est&gt;0)~Subgrps, data=res_boot$resamp_dist, FUN="mean")


## Examples: Binary Outcome ##

dat_bin = generate_subgrp_data(family="binomial")
Y = dat_bin$Y
X = dat_bin$X
A = dat_bin$A

# Run Default: glmnet, ranger, glmtree, dr #
res0 = PRISM(Y=Y, A=A, X=X)

plot(res0)


# Survival Data ##

  library(survival)
  library(ggplot2)
  require(TH.data); require(coin)
  data("GBSG2", package = "TH.data")
  surv.dat = GBSG2
  # Design Matrices ###
  Y = with(surv.dat, Surv(time, cens))
  X = surv.dat[,!(colnames(surv.dat) %in% c("time", "cens")) ]
  set.seed(513)
  A = rbinom( n = dim(X)[1], size=1, prob=0.5  )

  # PRISM: glmnet ==&gt; Random Forest to estimate Treatment-Specific RMST
  # ==&gt; MOB (Weibull) ==&gt; Cox for HRs#
  res_weib = PRISM(Y=Y, A=A, X=X)
  plot(res_weib, type="PLE:waterfall")
  plot(res_weib)
  
  #PRISM: glmnet ==&gt; Random Forest to estimate Treatment-Specific RMST
  #RPART_CATE: Regress RMST on RPART for subgroups #
  res_cate = PRISM(Y=Y, A=A, X=X, submod="rpart_cate")
  plot(res_cate)

  # PRISM: ENET ==&gt; CTREE ==&gt; Cox; with bootstrap #
  res_ctree1 = PRISM(Y=Y, A=A, X=X, ple="None", submod = "ctree",
                     resample="Bootstrap", R=50, verbose.resamp = TRUE)
  plot(res_ctree1)
  plot(res_ctree1, type="resample", estimand="HR(A=1 vs A=0)")+geom_vline(xintercept = 1)
  aggregate(I(est&lt;0)~Subgrps, data=res_ctree1$resamp_dist, FUN="mean")


</code></pre>

<hr>
<h2 id='submod_train'>Subgroup Identification: Train Model</h2><span id='topic+submod_train'></span>

<h3>Description</h3>

<p>Wrapper function to train a subgroup model (submod). Outputs subgroup assignments and 
fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submod_train(
  Y,
  A,
  X,
  Xtest = NULL,
  mu_train = NULL,
  family = "gaussian",
  submod = "lmtree",
  hyper = NULL,
  ple = "ranger",
  ple.hyper = NULL,
  meta = ifelse(family == "survival", "T-learner", "X-learner"),
  propensity = FALSE,
  pool = "no",
  delta = "&gt;0",
  param = NULL,
  resample = NULL,
  R = 20,
  resample_pool = NULL,
  R_pool = 20,
  stratify = ifelse(!is.null(A), "trt", "no"),
  combine = "SS",
  alpha_ovrl = 0.05,
  alpha_s = 0.05,
  verbose.resamp = FALSE,
  efficient = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="submod_train_+3A_y">Y</code></td>
<td>
<p>The outcome variable. Must be numeric or survival (ex; Surv(time,cens) )</p>
</td></tr>
<tr><td><code id="submod_train_+3A_a">A</code></td>
<td>
<p>Treatment variable. (Default supports binary treatment, either numeric or 
factor). &quot;ple_train&quot; accomodates &gt;2 along with binary treatments.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_x">X</code></td>
<td>
<p>Covariate space.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_xtest">Xtest</code></td>
<td>
<p>Test set. Default is NULL (no test predictions). Variable types should match X.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_mu_train">mu_train</code></td>
<td>
<p>Patient-level estimates in training set (see <code>ple_train</code>). 
Default=NULL</p>
</td></tr>
<tr><td><code id="submod_train_+3A_family">family</code></td>
<td>
<p>Outcome type. Options include &quot;gaussion&quot; (default), &quot;binomial&quot;, and &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_submod">submod</code></td>
<td>
<p>Subgroup identification model function. Options include tree-methods that 
target the treatment by variable interaction directly (&quot;lmtree&quot;, &quot;glmtree&quot;, &quot;mob_weib&quot;),
regress the CATE (&quot;rpart_cate&quot;, &quot;ctree_cate&quot;), and target prognostic variables (&quot;rpart&quot;, &quot;ctree&quot;).
Default for family=&quot;gaussian&quot; is &quot;lmtree&quot; (MOB with OLS loss). For &quot;binomial&quot; the default is 
&quot;glmtree&quot; (MOB with binomial loss). Default for &quot;survival&quot; is &quot;lmtree&quot; (log-rank transformation 
on survival outcomes and then fit MOB-OLS). &quot;None&quot; uses no submod. Currently only available for 
binary treatments or A=NULL.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_hyper">hyper</code></td>
<td>
<p>Hyper-parameters for submod (must be list). Default is NULL.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_ple">ple</code></td>
<td>
<p>Base-learner used to estimate patient-level equantities, such as the 
conditional average treatment effect (CATE), E(Y|A=1,X)-E(Y|A=0, X) = CATE(X). 
Default is random based based through &quot;ranger&quot;. &quot;None&quot; uses no ple. See below for 
details on estimating the treatment contrasts.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_ple.hyper">ple.hyper</code></td>
<td>
<p>Hyper-parameters for the PLE function (must be list). 
Default is NULL.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_meta">meta</code></td>
<td>
<p>Using the ple model as a base learner, meta-learners can be used for 
estimating patient-level treatment differences. Options include &quot;T-learner&quot; (treatment
specific models), &quot;S-learner&quot; (single model), and &quot;X-learner&quot;. For family=&quot;gaussian&quot; &amp;
&quot;binomial&quot;, the default is &quot;X-learner&quot;, which uses a two-stage regression 
approach (See Kunzel et al 2019). For &quot;survival&quot;, the default is &quot;T-learner&quot;. &quot;X-learner&quot; 
is currently not supported for survival outcomes.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_propensity">propensity</code></td>
<td>
<p>Propensity score estimation, P(A=a|X). Default=FALSE which 
use the marginal estimates, P(A=a) (applicable for RCT data). If TRUE, will 
use the &quot;ple&quot; base learner to estimate P(A=a|X).</p>
</td></tr>
<tr><td><code id="submod_train_+3A_pool">pool</code></td>
<td>
<p>Whether to pool the initial identified subgroups (ex: tree nodes).
Default = &quot;no&quot;. Other options include &quot;trteff&quot; or &quot;trteff_boot&quot; (check if 
naive or bootstrap treatment estimate is beyond clinical meaningful 
threshold delta, ex: trteff_boot &gt; 0), and optimal treatment regime (OTR) pooling, 
&quot;otr:logistic&quot;, &quot;otr:rf&quot;. &quot;otr:logistic&quot; fits weighted logistic regression 
with I(mu_1-mu_0&gt;delta) as the outcome, the candidate subgroups as covariates, 
and weights=abs((mu_1-mu_0) - delta). &quot;otr:rf&quot; follows the same approach but 
with weighted random forest, and also includes X in the regression. Regardless 
of the pooling approach, the key output is &quot;trt_assign&quot;, a data-frame with the 
initial subgroups and the pooled subgroups (ex: dopt=1, patient should receive
A=1, vs dopt=0, patient should receive A=0).</p>
</td></tr>
<tr><td><code id="submod_train_+3A_delta">delta</code></td>
<td>
<p>Threshold for defining benefit vs non-benefitting patients. 
Only applicable for submod=&quot;otr&quot;, and if pooling is used (see &quot;pool&quot;). 
Default=&quot;&gt;0&quot;.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_param">param</code></td>
<td>
<p>Parameter estimation and inference function. Based on the discovered 
subgroups, estimate parameter estimates and correspond variability metrics. Options
include &quot;lm&quot; (unadjusted linear regression), &quot;dr&quot; (doubly-robust estimator),
&quot;gcomp&quot; (G-computation, average the patient-level estimates), &quot;cox&quot; (cox regression),
and &quot;rmst&quot; (RMST based estimates as in survRMST package). Default for &quot;gaussian&quot;,
&quot;binomial&quot; is &quot;dr&quot;, while default for &quot;survival&quot; is &quot;cox&quot;. Currently only available 
for binary treatments or A=NULL.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_resample">resample</code></td>
<td>
<p>Resampling method for resample-based treatment effect estimates 
and variability metrics. Options include &quot;Bootstrap&quot; and 
&quot;CV&quot; (cross-validation). Default=NULL (No resampling).</p>
</td></tr>
<tr><td><code id="submod_train_+3A_r">R</code></td>
<td>
<p>Number of resamples (default=NULL; R=100 for Permutation/Bootstrap 
and R=5 for CV). This resamples the entire PRISM procedure.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_resample_pool">resample_pool</code></td>
<td>
<p>For submod only, resampling method for pooling step. 
nly applicable if resample_submod=&quot;Bootstrap&quot; and/or pool=&quot;trteff_boot&quot;.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_r_pool">R_pool</code></td>
<td>
<p>Number of resamples for resample_pool</p>
</td></tr>
<tr><td><code id="submod_train_+3A_stratify">stratify</code></td>
<td>
<p>Stratified resampling? Default=&quot;trt&quot; (stratify by A). Other
options include &quot;sub&quot; (stratify by the identified subgroups), &quot;trt_sub&quot; 
(stratify by A and the identified subgroups), and &quot;no&quot; (no stratification).</p>
</td></tr>
<tr><td><code id="submod_train_+3A_combine">combine</code></td>
<td>
<p>Method of combining group-specific point-estimates. Options 
include &quot;SS&quot; (sample size weighting), and &quot;maxZ&quot; 
(see: Mehrotra and Marceau-West). This is used for pooling (ex: within dopt=1
groups, aggregate group-specific treatment estimates), and for calculating 
the overall population treatment effect estimate.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_alpha_ovrl">alpha_ovrl</code></td>
<td>
<p>Two-sided alpha level for overall population. Default=0.05</p>
</td></tr>
<tr><td><code id="submod_train_+3A_alpha_s">alpha_s</code></td>
<td>
<p>Two-sided alpha level at subgroup level. Default=0.05</p>
</td></tr>
<tr><td><code id="submod_train_+3A_verbose.resamp">verbose.resamp</code></td>
<td>
<p>Output iterations during resampling? Default=FALSE</p>
</td></tr>
<tr><td><code id="submod_train_+3A_efficient">efficient</code></td>
<td>
<p>If TRUE (default for PRISM), then models (filter, ple, submod) will 
store reduced set of outputs for faster speed.</p>
</td></tr>
<tr><td><code id="submod_train_+3A_...">...</code></td>
<td>
<p>Any additional parameters, not currently passed through.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>submod_train currently fits a number of tree-based subgroup models, most of
which aim to find subgroups with varying treatment effects (i.e. predictive variables).
Let E(Y|A=1,X)-E(Y|A=0,X) = CATE(X) correspond to the estimated conditional average treatment 
effect. Current options include:
</p>
<p>1. lmtree: Wrapper function for the function &quot;lmtree&quot; from the partykit package. Here, 
model-based partitioning (MOB) with an OLS loss function, Y~MOB_OLS(A,X), is used to 
identify prognostic and/or predictive variables. If the outcome Y is survival, then 
this outcome will first be transformed via log-rank scores (coin::logrank_trafo(Y)).
</p>
<p>Default hyper-parameters are: 
hyper = list(alpha=0.05, maxdepth=4, parm=NULL, minsize=floor(dim(X)[1]*0.10)).
</p>
<p>2. glmtree: Wrapper function for the function &quot;glmtree&quot; from the partykit package. Here, 
model-based partitioning (MOB) with GLM binomial + identity link loss function, 
(Y~MOB_GLM(A,X)), is used to identify prognostic and/or predictive variables.
</p>
<p>Default hyper-parameters are:
hyper = list(link=&quot;identity&quot;, alpha=0.05, maxdepth=4, parm=NULL, minsize=floor(dim(X)[1]*0.10)).
</p>
<p>3. ctree / ctree_cate: Wrapper function for the function &quot;ctree&quot; from the partykit package. Here, 
conditional inference trees are used to identify either prognostic (&quot;ctree&quot;), Y~CTREE(X), 
or predictive variables, CATE(X) ~ CTREE(X).
</p>
<p>Default hyper-parameters are:
hyper=list(alpha=0.10, minbucket = floor(dim(X)[1]*0.10), maxdepth = 4). 
</p>
<p>4. rpart / rpart_cate: Recursive partitioning through the &quot;rpart&quot; R package. Here, 
recursive partitioning and regression trees are used to identify either prognostic (&quot;rpart&quot;),
Y~rpart(X), or predictive variables (&quot;rpart_cate&quot;), CATE(X)~rpart(X).
</p>
<p>Default hyper-parameters are:
hyper=list(alpha=0.10, minbucket = floor(dim(X)[1]*0.10), maxdepth = 4). 
</p>
<p>5. mob_weib: Wrapper function for the function &quot;mob&quot; with weibull loss function using
the partykit package. Here, model-based partitioning (MOB) with weibull loss (survival),
(Y~MOB_WEIB(A,X)), is used to identify prognostic and/or predictive variables.
</p>
<p>Default hyper-parameters are:
hyper = list(alpha=0.10, maxdepth=4, parm=NULL, minsize=floor(dim(X)[1]*0.10)).
</p>
<p>6. otr: Optimal treatment regime approach using &quot;ctree&quot;. Based on CATE estimates and 
clinically meaningful threshold delta (ex: &gt;0), fit I(CATE&gt;delta)~CTREE(X) with 
weights=abs(CATE-delta). 
</p>
<p>Default hyper-parameters are:
hyper=list(alpha=0.10, minbucket = floor(dim(X)[1]*0.10), maxdepth = 4, delta=&quot;&gt;0&quot;).
</p>


<h3>Value</h3>

<p>Trained subgroup model and subgroup predictions/estimates for train/test sets.
</p>

<ul>
<li><p> mod - trained subgroup model
</p>
</li>
<li><p> Subgrps.train - Identified subgroups (training set)
</p>
</li>
<li><p> Subgrps.test - Identified subgroups (test set)
</p>
</li>
<li><p> pred.train - Predictions (training set)
</p>
</li>
<li><p> pred.test - Predictions (test set)
</p>
</li>
<li><p> Rules - Definitions for subgroups, if provided in fitted submod output.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Zeileis A, Hothorn T, Hornik K (2008). Model-Based Recursive Partitioning. 
Journal of Computational and Graphical Statistics, 17(2), 492â€“514.
</p>
</li>
<li><p> Seibold H, Zeileis A, Hothorn T. Model-based recursive partitioning for 
subgroup analyses. Int J Biostat, 12 (2016), pp. 45-63
</p>
</li>
<li><p> Hothorn T, Hornik K, Zeileis A (2006). Unbiased Recursive Partitioning: 
A Conditional Inference Framework. Journal of Computational and Graphical Statistics,
15(3), 651â€“674.
</p>
</li>
<li><p> Zhao et al. (2012) Estimated individualized treatment rules using outcome 
weighted learning. Journal of the American Statistical Association, 107(409): 1106-1118.
</p>
</li>
<li><p> Breiman L, Friedman JH, Olshen RA, and Stone CJ. (1984) Classification 
and Regression Trees. Wadsworth
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+PRISM">PRISM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(StratifiedMedicine)
## Continuous ##
dat_ctns = generate_subgrp_data(family="gaussian")
Y = dat_ctns$Y
X = dat_ctns$X
A = dat_ctns$A

# Fit through submod_train wrapper #
mod1 = submod_train(Y=Y, A=A, X=X, Xtest=X, submod="submod_lmtree")
table(mod1$Subgrps.train)
plot(mod1$fit$mod)
mod1$trt_eff



</code></pre>

<hr>
<h2 id='summary.PRISM'>PRISM: Patient Response Identifier for Stratified Medicine (Summary)</h2><span id='topic+summary.PRISM'></span>

<h3>Description</h3>

<p>Summary for PRISM algorithm results. Outputs configuration, which variables pass the filter (if used),
subgroup summaries, and treatment effect estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PRISM'
summary(object, round_est = 4, round_SE = 4, round_CI = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PRISM_+3A_object">object</code></td>
<td>
<p>Trained PRISM model.</p>
</td></tr>
<tr><td><code id="summary.PRISM_+3A_round_est">round_est</code></td>
<td>
<p>Rounding for trt ests (default=4)</p>
</td></tr>
<tr><td><code id="summary.PRISM_+3A_round_se">round_SE</code></td>
<td>
<p>Rounding for trt SEs (default=4)</p>
</td></tr>
<tr><td><code id="summary.PRISM_+3A_round_ci">round_CI</code></td>
<td>
<p>Rounding for trt CIs (default=4)</p>
</td></tr>
<tr><td><code id="summary.PRISM_+3A_...">...</code></td>
<td>
<p>Any additional parameters, not currently passed through.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of key PRISM outputs: (1) Configuration, (2) Variables that pass filter 
(if filter is used), (3) Number of Identified Subgroups, and (4) Parameter Estimates, 
SEs, and CIs for each subgroup/estimand
</p>

<hr>
<h2 id='summary.submod_train'>Subgroup Identification (Summary)</h2><span id='topic+summary.submod_train'></span>

<h3>Description</h3>

<p>Summary for subgroup identification function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'submod_train'
summary(object, round_est = 4, round_SE = 4, round_CI = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.submod_train_+3A_object">object</code></td>
<td>
<p>Trained submod_train model.</p>
</td></tr>
<tr><td><code id="summary.submod_train_+3A_round_est">round_est</code></td>
<td>
<p>Rounding for trt ests (default=4)</p>
</td></tr>
<tr><td><code id="summary.submod_train_+3A_round_se">round_SE</code></td>
<td>
<p>Rounding for trt SEs (default=4)</p>
</td></tr>
<tr><td><code id="summary.submod_train_+3A_round_ci">round_CI</code></td>
<td>
<p>Rounding for trt CIs (default=4)</p>
</td></tr>
<tr><td><code id="summary.submod_train_+3A_...">...</code></td>
<td>
<p>Any additional parameters, not currently passed through.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of key outputs (1) Number of Identified Subgroups, and (2) Treatment effect estimates, 
SEs, and CIs for each subgroup/estimand
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
