<!DOCTYPE html><html><head><title>Help for package qtlc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qtlc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#areadens2D'><p>Area vs. x-axis</p></a></li>
<li><a href='#areadensnoisecompare2D'><p>Shows areadens2D plus background noise as segmented line</p></a></li>
<li><a href='#createTLC'><p>Creates TLC S3 object</p></a></li>
<li><a href='#matrices2D'><p>Creates spots matrices</p></a></li>
<li><a href='#matrixtoimage'><p>Converts matrix back to image</p></a></li>
<li><a href='#noisepoly2D'><p>Polynomial estimation of the image noise.</p></a></li>
<li><a href='#normalize2D'><p>Normalization of the matrix values</p></a></li>
<li><a href='#picmatrixTIFF'><p>Converting TIFF to matrix.</p></a></li>
<li><a href='#print.qtlc'><p>Print Method for <code>qtlc</code> object</p></a></li>
<li><a href='#print.summary.qtlc'><p>Summary method for <code>qtlc</code> S3 object</p></a></li>
<li><a href='#Rf'><p>Retention factor (Rf)</p></a></li>
<li><a href='#rotatev'><p>Rotate vertically</p></a></li>
<li><a href='#s3D'><p>Internal function used by showtlc3D</p></a></li>
<li><a href='#select2D'><p>Selects spots areas</p></a></li>
<li><a href='#showRf'><p>Shows Rf on the plot</p></a></li>
<li><a href='#showtlc2D'><p>Show TLC matrix as 2D plot</p></a></li>
<li><a href='#showtlc2D.qtlc'><p>Show TLC matrix as 2D plot</p></a></li>
<li><a href='#showtlc3D'><p>Shows 3D plot of the TLC matrix.</p></a></li>
<li><a href='#spot2D'><p>Locate spots manually.</p></a></li>
<li><a href='#summary.qtlc'><p>Summary method for <code>qtlc</code> S3 object</p></a></li>
<li><a href='#summat2D'><p>Summarize matrices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Densitometric Analysis of Thin-Layer Chromatography Plates</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-01-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Ivan D. Pavicevic</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ivan D. Pavicevic &lt;ivanp84@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Densitometric evaluation of the photo-archived quantitative thin-layer chromatography (TLC) plates.</td>
</tr>
<tr>
<td>Depends:</td>
<td>tiff, rgl, plot3D, graphics, grDevices, stats, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-01-04 15:28:35 UTC; ivan</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-01-04 17:46:53</td>
</tr>
</table>
<hr>
<h2 id='areadens2D'>Area vs. x-axis</h2><span id='topic+areadens2D'></span>

<h3>Description</h3>

<p>Function charts density plot of a single spot following x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areadens2D(object, spot = NULL, plot = TRUE, returndf = TRUE,
  ptype = "o", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areadens2D_+3A_object">object</code></td>
<td>
<p>S3 object of working TLC</p>
</td></tr>
<tr><td><code id="areadens2D_+3A_spot">spot</code></td>
<td>
<p>Number of the spot (counted left to right).</p>
</td></tr>
<tr><td><code id="areadens2D_+3A_plot">plot</code></td>
<td>
<p>Boolean, TRUE default and displays densitometric distribution.</p>
</td></tr>
<tr><td><code id="areadens2D_+3A_returndf">returndf</code></td>
<td>
<p>Boolean, TRUE by default, returns <code>data.frame</code> with <code>x</code> and <code>Area</code> values.</p>
</td></tr>
<tr><td><code id="areadens2D_+3A_ptype">ptype</code></td>
<td>
<p>Point type for the plot. Default &quot;o&quot; (Uses same values as <code>type</code> variable from <code>plot</code> function)</p>
</td></tr>
<tr><td><code id="areadens2D_+3A_...">...</code></td>
<td>
<p>Additional parameters (for <code>plot</code> type function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>data.frame</code> with <code>x</code> and <code>Area</code> values.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A test example
fname01 &lt;- system.file("extdata", "test025to100sp.tiff", package="qtlc")
testTLC &lt;- createTLC(fname01, RGB=FALSE)
print(testTLC)

# now we'll imitate interactive spot2D function,
# and create spots coordinates automatically,
# for interactive version run testTLC &lt;- spot2D(testTLC)
testTLC$spots$x &lt;- c(40.93354, 83.18687, 121.59899, 160.01111, 203.54485,
                     239.39616, 280.36909, 320.06161, 362.31494, 399.44666,
                     439.13919, 480.11211, 518.52423, 559.49716, 599.18969)
testTLC$spots$y &lt;- c(198.3160, 198.3160, 199.2833, 198.3160, 198.3160,
                     198.3160, 198.3160, 198.3160, 197.3487, 198.3160,
                     199.2833, 198.3160, 199.2833, 199.2833, 199.2833)

testTLC &lt;- select2D(testTLC, 30, 30)
testTLC &lt;- matrices2D(testTLC)
testTLC &lt;- summat2D(testTLC)

# and now test the areadens2D for each spot
par(mfrow=c(3,3))
for(i in 1:15) {
areadens2D(testTLC, spot=i, ptype="l")
}

</code></pre>

<hr>
<h2 id='areadensnoisecompare2D'>Shows areadens2D plus background noise as segmented line</h2><span id='topic+areadensnoisecompare2D'></span>

<h3>Description</h3>

<p>Plots area-denses of the spot and background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areadensnoisecompare2D(object, spot = NULL, plot = TRUE, returndf = TRUE,
  ptype = "o", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areadensnoisecompare2D_+3A_object">object</code></td>
<td>
<p>S3 object of working TLC</p>
</td></tr>
<tr><td><code id="areadensnoisecompare2D_+3A_spot">spot</code></td>
<td>
<p>Number of the spot (counted left to right).</p>
</td></tr>
<tr><td><code id="areadensnoisecompare2D_+3A_plot">plot</code></td>
<td>
<p>Boolean, TRUE default and displays densitometric distribution.</p>
</td></tr>
<tr><td><code id="areadensnoisecompare2D_+3A_returndf">returndf</code></td>
<td>
<p>Boolean, TRUE by default, returns <code>data.frame</code> with <code>x</code> and <code>Area</code> values.</p>
</td></tr>
<tr><td><code id="areadensnoisecompare2D_+3A_ptype">ptype</code></td>
<td>
<p>Point type for the plot. Default &quot;o&quot; (Uses same values as <code>type</code> variable from <code>plot</code> function)</p>
</td></tr>
<tr><td><code id="areadensnoisecompare2D_+3A_...">...</code></td>
<td>
<p>Additional parameters (for <code>plot</code> type function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>data.frame</code> with <code>x</code> and <code>Area</code> values.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#see areadens2D first
areadensnoisecompare2D(object, spot=3, ptype="l")

## End(Not run)

</code></pre>

<hr>
<h2 id='createTLC'>Creates TLC S3 object</h2><span id='topic+createTLC'></span>

<h3>Description</h3>

<p>Create matrix from TLC image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTLC(ttiff, turnv = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTLC_+3A_ttiff">ttiff</code></td>
<td>
<p>File name of the TIFF image with scanned TLC plate.</p>
</td></tr>
<tr><td><code id="createTLC_+3A_turnv">turnv</code></td>
<td>
<p>Boolean value determines to turn vertically data in the matrix. TRUE generates turned image which is useful for Cartesian coordinates, because without turning the coordinate system begins in the left corner of the monithor and rises left and down.</p>
</td></tr>
<tr><td><code id="createTLC_+3A_...">...</code></td>
<td>
<p>Additional parameters for TIFF image manipulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlc</code>, that contains TLC matrix and descriptions. The object contains: </p>
<table>
<tr><td><code>file_name</code></td>
<td>
<p>File name of of the TIFF image from which the TLC matrix was created.</p>
</td></tr> <tr><td><code>mat</code></td>
<td>
<p>TLC matrix (or matrices if intensities Red, Green and Blue channels are not combined.)</p>
</td></tr> <tr><td><code>spots</code></td>
<td>
<p>Coordinates of marked spots (using function <code>spot2D</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Creates test matrix.
# RGB channels stay separated, or
# intensities are combined.
fname01 &lt;- system.file("extdata", "testTIFF.tiff", package="qtlc")
testTLC &lt;- createTLC(fname01, RGB=TRUE)
print(testTLC)

</code></pre>

<hr>
<h2 id='matrices2D'>Creates spots matrices</h2><span id='topic+matrices2D'></span>

<h3>Description</h3>

<p>Using spots locations and areas this function creates a matrix for each spot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrices2D(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrices2D_+3A_object">object</code></td>
<td>
<p>S3 object of working TLC</p>
</td></tr>
<tr><td><code id="matrices2D_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters. (At this time just experimental)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns S3 object with new variable <code>object$spot_matrices</code> which is a three dimensional matrix (width, height, and pixel intensity values).
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#just makes spot matrices for selected spots of the object
object &lt;- matrices2D(object)

## End(Not run)

</code></pre>

<hr>
<h2 id='matrixtoimage'>Converts matrix back to image</h2><span id='topic+matrixtoimage'></span>

<h3>Description</h3>

<p>Using S3 qtlc object, extracts the matrix and converts to image plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixtoimage(object, show = TRUE, bkg = "thistle", axes = FALSE,
  xlab = "", ylab = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixtoimage_+3A_object">object</code></td>
<td>
<p>S3 object of working TLC.</p>
</td></tr>
<tr><td><code id="matrixtoimage_+3A_show">show</code></td>
<td>
<p>Boolean, default TRUE. Shows the plot of the image.</p>
</td></tr>
<tr><td><code id="matrixtoimage_+3A_bkg">bkg</code></td>
<td>
<p>If <code>show</code> is TRUE, then defines background color. Default is &quot;thistle&quot;.</p>
</td></tr>
<tr><td><code id="matrixtoimage_+3A_axes">axes</code></td>
<td>
<p>Boolean, default FALSE. Shows x,y axes if TRUE.</p>
</td></tr>
<tr><td><code id="matrixtoimage_+3A_xlab">xlab</code></td>
<td>
<p>Label of the x-axis.</p>
</td></tr>
<tr><td><code id="matrixtoimage_+3A_ylab">ylab</code></td>
<td>
<p>Label of the y-axis.</p>
</td></tr>
<tr><td><code id="matrixtoimage_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns image as matrix suitable for <code>plot</code>, or other graphics functinos.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Converts test image to matrix,
# then matrix back to image.
fname01 &lt;- system.file("extdata", "testTIFF.tiff", package="qtlc")
testTLC &lt;- createTLC(fname01, RGB=FALSE)
print(testTLC)
matrixtoimage(testTLC, bkg="white")

</code></pre>

<hr>
<h2 id='noisepoly2D'>Polynomial estimation of the image noise.</h2><span id='topic+noisepoly2D'></span>

<h3>Description</h3>

<p>Estimation, and noise removal using polynomial model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noisepoly2D(object, gd = 20, power = 5, col = "green")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noisepoly2D_+3A_object">object</code></td>
<td>
<p>S3 object of the working TLC</p>
</td></tr>
<tr><td><code id="noisepoly2D_+3A_gd">gd</code></td>
<td>
<p>Defines position of the center of the rectangular samples of the image background (above or bellow located spots).</p>
</td></tr>
<tr><td><code id="noisepoly2D_+3A_power">power</code></td>
<td>
<p>Order of the polynome.</p>
</td></tr>
<tr><td><code id="noisepoly2D_+3A_col">col</code></td>
<td>
<p>Color of the borders of the rectangles for bkg samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns S3 object with new variables. </p>
<table>
<tr><td><code>object$noise_mat</code></td>
<td>
<p>The 3D matrix (width, height, number of spots)</p>
</td></tr> <tr><td><code>object$noise_fit</code></td>
<td>
<p>Linear model for the polynomial fit</p>
</td></tr> <tr><td><code>object$noisefit_spot_sums</code></td>
<td>
<p>Sums of the noise samples areas</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#object is a tlc with 14 spots, and selection 50x80(wxh)
object &lt;- noisepoly2D(object, gd=80, power=13)

## End(Not run)

</code></pre>

<hr>
<h2 id='normalize2D'>Normalization of the matrix values</h2><span id='topic+normalize2D'></span>

<h3>Description</h3>

<p>Experimental function. Normalize matrix data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize2D(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize2D_+3A_mat">mat</code></td>
<td>
<p>Matrix of the TLC plate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized matrix.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
new_mat &lt;- normalize2D(mat)

## End(Not run)

</code></pre>

<hr>
<h2 id='picmatrixTIFF'>Converting TIFF to matrix.</h2><span id='topic+picmatrixTIFF'></span>

<h3>Description</h3>

<p>Mostly internal function used by <code>createTLC</code> function. Additional parameters from <code>createTLC</code> goes there (RGB, comb).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>picmatrixTIFF(ff, RGB = TRUE, comb = c(0.3, 0.59, 0.11))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="picmatrixTIFF_+3A_ff">ff</code></td>
<td>
<p>TIFF file</p>
</td></tr>
<tr><td><code id="picmatrixTIFF_+3A_rgb">RGB</code></td>
<td>
<p>Boolean, TRUE - keeps Red, Green and Blue intensities as three matrices. FALSE - using <code>comb</code> to combine intensities.</p>
</td></tr>
<tr><td><code id="picmatrixTIFF_+3A_comb">comb</code></td>
<td>
<p>Vector, combines intensities according to luma. A vector containing three values for R, G and B conversion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns combined intensities matrix, or separated R, G, B matrices.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Internal function used by createTLC(...)

## End(Not run)

</code></pre>

<hr>
<h2 id='print.qtlc'>Print Method for <code>qtlc</code> object</h2><span id='topic+print.qtlc'></span>

<h3>Description</h3>

<p>Redefined <code>print</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qtlc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.qtlc_+3A_x">x</code></td>
<td>
<p>S3 object of the working TLC.</p>
</td></tr>
<tr><td><code id="print.qtlc_+3A_...">...</code></td>
<td>
<p>Additional parameters for the <code>print</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints <code>qtlc</code> S3 object details
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
print(object)

## End(Not run)

</code></pre>

<hr>
<h2 id='print.summary.qtlc'>Summary method for <code>qtlc</code> S3 object</h2><span id='topic+print.summary.qtlc'></span>

<h3>Description</h3>

<p>Summary method for <code>qtlc</code> S3 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.qtlc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.qtlc_+3A_x">x</code></td>
<td>
<p>S3 object of the working TLC.</p>
</td></tr>
<tr><td><code id="print.summary.qtlc_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summary(object)

## End(Not run)

</code></pre>

<hr>
<h2 id='Rf'>Retention factor (Rf)</h2><span id='topic+Rf'></span>

<h3>Description</h3>

<p>Calculates Rf values of the spots based on the marked start and stop of the solvent path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rf(object, sf = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rf_+3A_object">object</code></td>
<td>
<p>S3 object of the working TLC</p>
</td></tr>
<tr><td><code id="Rf_+3A_sf">sf</code></td>
<td>
<p>Boolean, default FALSE - Start and Front should be marked. If TRUE, Start and Front were defined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns S3 object with new variables. </p>
<table>
<tr><td><code>object$Rf_start</code></td>
<td>
<p>Location of the solvent start on the TLC plate</p>
</td></tr> <tr><td><code>object$Rf_front</code></td>
<td>
<p>Location of the solvent end on the TLC plate</p>
</td></tr> <tr><td><code>object$Rf</code></td>
<td>
<p>Rf values of the spots</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#for more interactive variant; locate using mouse
object &lt;- Rf(object, sf=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='rotatev'>Rotate vertically</h2><span id='topic+rotatev'></span>

<h3>Description</h3>

<p>Rotate entire matrix vertically. Mostly internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotatev(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotatev_+3A_mat">mat</code></td>
<td>
<p>The matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rotated matrix.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
new_mat &lt;- rotatev(mat)

## End(Not run)

</code></pre>

<hr>
<h2 id='s3D'>Internal function used by showtlc3D</h2><span id='topic+s3D'></span>

<h3>Description</h3>

<p>Internal function used by showtlc3D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s3D(mat, ogl, grey, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s3D_+3A_mat">mat</code></td>
<td>
<p>Matrix with x,y,Intensity dimensions</p>
</td></tr>
<tr><td><code id="s3D_+3A_ogl">ogl</code></td>
<td>
<p>If TLC 3D plot use OpenGL library for fast and interactive 3D plot. (This functionality is based on the <code>rgl</code> package.) Otherwise the function is based on the plot3D package.</p>
</td></tr>
<tr><td><code id="s3D_+3A_grey">grey</code></td>
<td>
<p>Boolean, if TRUE, then tlc is greyscaled. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="s3D_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Internal function.

## End(Not run)

</code></pre>

<hr>
<h2 id='select2D'>Selects spots areas</h2><span id='topic+select2D'></span>

<h3>Description</h3>

<p>Based on the located spots centers (manualy with mouse and function <code>spot2D</code>) this function defines spots areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select2D(object, w, h, col = "white")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select2D_+3A_object">object</code></td>
<td>
<p>S3 object of the working TLC.</p>
</td></tr>
<tr><td><code id="select2D_+3A_w">w</code></td>
<td>
<p>Width of the spot area.</p>
</td></tr>
<tr><td><code id="select2D_+3A_h">h</code></td>
<td>
<p>Height of the spot area.</p>
</td></tr>
<tr><td><code id="select2D_+3A_col">col</code></td>
<td>
<p>Color of the border (default white)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return S3 object with new variable <code>object$mat_cell</code> which is list with &quot;w&quot; and &quot;h&quot; values.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
select2D(object, 80, 50)

## End(Not run)

</code></pre>

<hr>
<h2 id='showRf'>Shows Rf on the plot</h2><span id='topic+showRf'></span>

<h3>Description</h3>

<p>Shows prior analysed Rf on the new plot of the 2D matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showRf(object, col = "green", adjust = NULL, cex = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showRf_+3A_object">object</code></td>
<td>
<p>S3 object of the working TLC</p>
</td></tr>
<tr><td><code id="showRf_+3A_col">col</code></td>
<td>
<p>Color of the lines.</p>
</td></tr>
<tr><td><code id="showRf_+3A_adjust">adjust</code></td>
<td>
<p>Adjustment for the space of the text. Default value is usualy just OK.</p>
</td></tr>
<tr><td><code id="showRf_+3A_cex">cex</code></td>
<td>
<p>A zoom factor for the text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
showRf(object)

## End(Not run)

</code></pre>

<hr>
<h2 id='showtlc2D'>Show TLC matrix as 2D plot</h2><span id='topic+showtlc2D'></span>

<h3>Description</h3>

<p>Using TLC matrix width, height, and intensity parameters this function plot 2D heatmap of the TLC matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showtlc2D(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showtlc2D_+3A_object">object</code></td>
<td>
<p>S3 object of the working TLC</p>
</td></tr>
<tr><td><code id="showtlc2D_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
showtlc2D(object)

## End(Not run)

</code></pre>

<hr>
<h2 id='showtlc2D.qtlc'>Show TLC matrix as 2D plot</h2><span id='topic+showtlc2D.qtlc'></span>

<h3>Description</h3>

<p>Using TLC matrix width, height, and intensity parameters this function plot 2D heatmap of the TLC matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qtlc'
showtlc2D(object, specific = NULL, RGB = "", main = "",
  correction = TRUE, grey = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showtlc2D.qtlc_+3A_object">object</code></td>
<td>
<p>S3 object of the working TLC</p>
</td></tr>
<tr><td><code id="showtlc2D.qtlc_+3A_specific">specific</code></td>
<td>
<p>Matrix of the specific spot (from object$spot_matrices)</p>
</td></tr>
<tr><td><code id="showtlc2D.qtlc_+3A_rgb">RGB</code></td>
<td>
<p>RGB matrices (if they are present in the object) are separated on the plot. Values of the RGB = &quot;R&quot;, or &quot;G&quot;, or &quot;B&quot;.</p>
</td></tr>
<tr><td><code id="showtlc2D.qtlc_+3A_main">main</code></td>
<td>
<p>Main title of the plot.</p>
</td></tr>
<tr><td><code id="showtlc2D.qtlc_+3A_correction">correction</code></td>
<td>
<p>Experimental option, currently not in use.</p>
</td></tr>
<tr><td><code id="showtlc2D.qtlc_+3A_grey">grey</code></td>
<td>
<p>Boolean, if TRUE, then TLC plate is greyscaled. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="showtlc2D.qtlc_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
showtlc2D(object, specific=object$spot_matrices[3], grey=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='showtlc3D'>Shows 3D plot of the TLC matrix.</h2><span id='topic+showtlc3D'></span>

<h3>Description</h3>

<p>The function uses TLC matrix width, height and intensity values to make 3D plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showtlc3D(object, spot = NULL, ogl = FALSE, RGB = NULL, grey = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showtlc3D_+3A_object">object</code></td>
<td>
<p>S3 object of the working TLC.</p>
</td></tr>
<tr><td><code id="showtlc3D_+3A_spot">spot</code></td>
<td>
<p>If the specific spot should be represented in 3D, but not entire TLC matrix. (Spot number is given as value, and spots are counted from left to right.)</p>
</td></tr>
<tr><td><code id="showtlc3D_+3A_ogl">ogl</code></td>
<td>
<p>If TLC 3D plot use OpenGL library for fast and interactive 3D plot. (This functionality is based on the <code>rgl</code> package.) Otherwise the function is based on the plot3D package.</p>
</td></tr>
<tr><td><code id="showtlc3D_+3A_rgb">RGB</code></td>
<td>
<p>If RGB matrices are present in the object, choose between R, G, or B.</p>
</td></tr>
<tr><td><code id="showtlc3D_+3A_grey">grey</code></td>
<td>
<p>Boolean, if TRUE, then tlc is greyscaled. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="showtlc3D_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Tests 3D plot of the entire matrix
fname01 &lt;- system.file("extdata", "test025to100sp.tiff", package="qtlc")
testTLC &lt;- createTLC(fname01, RGB=FALSE)

# now we'll imitate interactive spot2D function,
# and create spots coordinates automatically,
# for interactive version run testTLC &lt;- spot2D(testTLC)
testTLC$spots$x &lt;- c(40.93354, 83.18687, 121.59899, 160.01111, 203.54485,
                     239.39616, 280.36909, 320.06161, 362.31494, 399.44666,
                     439.13919, 480.11211, 518.52423, 559.49716, 599.18969)
testTLC$spots$y &lt;- c(198.3160, 198.3160, 199.2833, 198.3160, 198.3160,
                     198.3160, 198.3160, 198.3160, 197.3487, 198.3160,
                     199.2833, 198.3160, 199.2833, 199.2833, 199.2833)

testTLC &lt;- select2D(testTLC, 30, 30)
testTLC &lt;- matrices2D(testTLC)
testTLC &lt;- summat2D(testTLC)

# 3D without OpenGL, shows only spot 13
showtlc3D(testTLC, spot=13, ogl=FALSE, grey=FALSE)
# without openGL and greyscaled
showtlc3D(testTLC, spot=13, ogl=FALSE, grey=TRUE)
#openGL showtime
showtlc3D(testTLC, spot=13, ogl=TRUE)

</code></pre>

<hr>
<h2 id='spot2D'>Locate spots manually.</h2><span id='topic+spot2D'></span>

<h3>Description</h3>

<p>The function should be used after 2D TLC matrix was plotted. After function call, the user should manually locate centers of the spots using mouse. (Left click for locate, right for the end of the process.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot2D(object, col = "white", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spot2D_+3A_object">object</code></td>
<td>
<p>S3 object of the working TLC.</p>
</td></tr>
<tr><td><code id="spot2D_+3A_col">col</code></td>
<td>
<p>Color of the spot locator (default is white)</p>
</td></tr>
<tr><td><code id="spot2D_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 object with 'object$spots' added.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
print(object)
object &lt;- spot2D(object)

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.qtlc'>Summary method for <code>qtlc</code> S3 object</h2><span id='topic+summary.qtlc'></span>

<h3>Description</h3>

<p>Summary method for <code>qtlc</code> S3 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qtlc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.qtlc_+3A_object">object</code></td>
<td>
<p>S3 object of the working TLC.</p>
</td></tr>
<tr><td><code id="summary.qtlc_+3A_...">...</code></td>
<td>
<p>Additional parameters for the <code>summary</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summary(object)

## End(Not run)

</code></pre>

<hr>
<h2 id='summat2D'>Summarize matrices</h2><span id='topic+summat2D'></span>

<h3>Description</h3>

<p>The function summarize matrices areas of the located spot matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summat2D(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summat2D_+3A_object">object</code></td>
<td>
<p>S3 object of working TLC</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns S3 object with new values <code>object$spot_sums</code>.
</p>


<h3>Author(s)</h3>

<p>Ivan D. Pavicevic, <a href="mailto:ivanp84@gmail.com">ivanp84@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This interactive example shows the most
# common usage of the qtlc library.
fname01 &lt;- system.file("extdata", "test025to100sp.tiff", package="qtlc")
testTLC &lt;- createTLC(fname01, RGB=FALSE)
print(testTLC)

# now using mouse select the spots with testTLC &lt;- spot2D(testTLC)
# but, for automatic tests, we'll imitate that step...
testTLC$spots$x &lt;- c(40.93354, 83.18687, 121.59899, 160.01111, 203.54485,
                     239.39616, 280.36909, 320.06161, 362.31494, 399.44666,
                     439.13919, 480.11211, 518.52423, 559.49716, 599.18969)
testTLC$spots$y &lt;- c(198.3160, 198.3160, 199.2833, 198.3160, 198.3160,
                     198.3160, 198.3160, 198.3160, 197.3487, 198.3160,
                     199.2833, 198.3160, 199.2833, 199.2833, 199.2833)

# and now the select2D selects 30x30 pixels areas around spots
testTLC &lt;- select2D(testTLC, 30, 30)

# forming spots matrices
testTLC &lt;- matrices2D(testTLC)

# and finaly sumarizing spots areas
testTLC &lt;- summat2D(testTLC)

#eventually we'll examine the linear model
C &lt;- rep(c(0.25, 1, 6.25, 25, 100), each=3) #imaginative concentrations
#now creates data frame with values
testTLC.df &lt;- data.frame(C, testTLC$spot_sums)
names(testTLC.df) &lt;- c("Concentration", "Signal")
# now the linear model
testTLC.lm &lt;- with(testTLC.df, lm(Signal ~ Concentration))
# and finaly the plot
plot(testTLC.df)
abline(testTLC.lm)
summary(testTLC.lm)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
