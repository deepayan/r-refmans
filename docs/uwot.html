<!DOCTYPE html><html><head><title>Help for package uwot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {uwot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#load_uwot'><p>Save or Load a Model</p></a></li>
<li><a href='#lvish'><p>Dimensionality Reduction with a LargeVis-like method</p></a></li>
<li><a href='#optimize_graph_layout'><p>Optimize Graph Layout</p></a></li>
<li><a href='#save_uwot'><p>Save or Load a Model</p></a></li>
<li><a href='#similarity_graph'><p>Similarity Graph</p></a></li>
<li><a href='#simplicial_set_intersect'><p>Merge Similarity Graph by Simplicial Set Intersection</p></a></li>
<li><a href='#simplicial_set_union'><p>Merge Similarity Graph by Simplicial Set Union</p></a></li>
<li><a href='#tumap'><p>Dimensionality Reduction Using t-Distributed UMAP (t-UMAP)</p></a></li>
<li><a href='#umap'><p>Dimensionality Reduction with UMAP</p></a></li>
<li><a href='#umap_transform'><p>Add New Points to an Existing Embedding</p></a></li>
<li><a href='#umap2'><p>Dimensionality Reduction with UMAP</p></a></li>
<li><a href='#unload_uwot'><p>Unload a Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>The Uniform Manifold Approximation and Projection (UMAP) Method
for Dimensionality Reduction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the Uniform Manifold Approximation and
    Projection dimensionality reduction by McInnes et al. (2018)
    &lt;<a href="https://doi.org/10.48550%2FarXiv.1802.03426">doi:10.48550/arXiv.1802.03426</a>&gt;. It also provides means to transform new data and
    to carry out supervised dimensionality reduction. An implementation of
    the related LargeVis method of Tang et al. (2016) &lt;<a href="https://doi.org/10.48550%2FarXiv.1602.00370">doi:10.48550/arXiv.1602.00370</a>&gt;
    is also provided. This is a complete re-implementation in R (and C++,
    via the 'Rcpp' package): no Python installation is required. See the
    uwot website (<a href="https://github.com/jlmelville/uwot">https://github.com/jlmelville/uwot</a>) for more
    documentation and examples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jlmelville/uwot">https://github.com/jlmelville/uwot</a>,
<a href="https://jlmelville.github.io/uwot/">https://jlmelville.github.io/uwot/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jlmelville/uwot/issues">https://github.com/jlmelville/uwot/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>FNN, irlba, methods, Rcpp, RcppAnnoy (&ge; 0.0.17), RSpectra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bigstatsr, covr, knitr, RcppHNSW, rmarkdown, rnndescent,
testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>dqrng, Rcpp, RcppAnnoy, RcppProgress</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-21 05:21:17 UTC; jlmel</td>
</tr>
<tr>
<td>Author:</td>
<td>James Melville [aut, cre, cph],
  Aaron Lun [ctb],
  Mohamed Nadhir Djekidel [ctb],
  Yuhan Hao [ctb],
  Dirk Eddelbuettel [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Melville &lt;jlmelville@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-21 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='load_uwot'>Save or Load a Model</h2><span id='topic+load_uwot'></span>

<h3>Description</h3>

<p>Functions to write a UMAP model to a file, and to restore.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_uwot(file, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_uwot_+3A_file">file</code></td>
<td>
<p>name of the file where the model is to be saved or read from.</p>
</td></tr>
<tr><td><code id="load_uwot_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, log information to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The model saved at <code>file</code>, for use with
<code><a href="#topic+umap_transform">umap_transform</a></code>. Additionally, it contains an extra item:
<code>mod_dir</code>, which contains the path to the temporary working directory
used during loading of the model. This directory cannot be removed until
this model has been unloaded by using <code><a href="#topic+unload_uwot">unload_uwot</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save_uwot">save_uwot</a></code>, <code><a href="#topic+unload_uwot">unload_uwot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RSpectra)

iris_train &lt;- iris[c(1:10, 51:60), ]
iris_test &lt;- iris[100:110, ]

# create model
model &lt;- umap(iris_train, ret_model = TRUE, n_epochs = 20)

# save without unloading: this leaves behind a temporary working directory
model_file &lt;- tempfile("iris_umap")
model &lt;- save_uwot(model, file = model_file)

# The model can continue to be used
test_embedding &lt;- umap_transform(iris_test, model)

# To manually unload the model from memory when finished and to clean up
# the working directory (this doesn't touch your model file)
unload_uwot(model)

# At this point, model cannot be used with umap_transform, this would fail:
# test_embedding2 &lt;- umap_transform(iris_test, model)

# restore the model: this also creates a temporary working directory
model2 &lt;- load_uwot(file = model_file)
test_embedding2 &lt;- umap_transform(iris_test, model2)

# Unload and clean up the loaded model temp directory
unload_uwot(model2)

# clean up the model file
unlink(model_file)

# save with unloading: this deletes the temporary working directory but
# doesn't allow the model to be re-used
model3 &lt;- umap(iris_train, ret_model = TRUE, n_epochs = 20)
model_file3 &lt;- tempfile("iris_umap")
model3 &lt;- save_uwot(model3, file = model_file3, unload = TRUE)

</code></pre>

<hr>
<h2 id='lvish'>Dimensionality Reduction with a LargeVis-like method</h2><span id='topic+lvish'></span>

<h3>Description</h3>

<p>Carry out dimensionality reduction of a dataset using a method similar to
LargeVis (Tang et al., 2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lvish(
  X,
  perplexity = 50,
  n_neighbors = perplexity * 3,
  n_components = 2,
  metric = "euclidean",
  n_epochs = -1,
  learning_rate = 1,
  scale = "maxabs",
  init = "lvrandom",
  init_sdev = NULL,
  repulsion_strength = 7,
  negative_sample_rate = 5,
  nn_method = NULL,
  n_trees = 50,
  search_k = 2 * n_neighbors * n_trees,
  n_threads = NULL,
  n_sgd_threads = 0,
  grain_size = 1,
  kernel = "gauss",
  pca = NULL,
  pca_center = TRUE,
  pcg_rand = TRUE,
  fast_sgd = FALSE,
  ret_nn = FALSE,
  ret_extra = c(),
  tmpdir = tempdir(),
  verbose = getOption("verbose", TRUE),
  batch = FALSE,
  opt_args = NULL,
  epoch_callback = NULL,
  pca_method = NULL,
  binary_edge_weights = FALSE,
  nn_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lvish_+3A_x">X</code></td>
<td>
<p>Input data. Can be a <code><a href="base.html#topic+data.frame">data.frame</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code> object or <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.
Matrix and data frames should contain one observation per row. Data frames
will have any non-numeric columns removed, although factor columns will be
used if explicitly included via <code>metric</code> (see the help for
<code>metric</code> for details). A sparse matrix is interpreted as a distance
matrix, and is assumed to be symmetric, so you can also pass in an
explicitly upper or lower triangular sparse matrix to save storage. There
must be at least <code>n_neighbors</code> non-zero distances for each row. Both
implicit and explicit zero entries are ignored. Set zero distances you want
to keep to an arbitrarily small non-zero value (e.g. <code>1e-10</code>).
<code>X</code> can also be <code>NULL</code> if pre-computed nearest neighbor data is
passed to <code>nn_method</code>, and <code>init</code> is not <code>"spca"</code> or
<code>"pca"</code>.</p>
</td></tr>
<tr><td><code id="lvish_+3A_perplexity">perplexity</code></td>
<td>
<p>Controls the size of the local neighborhood used for
manifold approximation. This is the analogous to <code>n_neighbors</code> in
<code><a href="#topic+umap">umap</a></code>. Change this, rather than <code>n_neighbors</code>.</p>
</td></tr>
<tr><td><code id="lvish_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>The number of neighbors to use when calculating the
<code>perplexity</code>. Usually set to three times the value of the
<code>perplexity</code>. Must be at least as large as <code>perplexity</code>.</p>
</td></tr>
<tr><td><code id="lvish_+3A_n_components">n_components</code></td>
<td>
<p>The dimension of the space to embed into. This defaults
to <code>2</code> to provide easy visualization, but can reasonably be set to any
integer value in the range <code>2</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="lvish_+3A_metric">metric</code></td>
<td>
<p>Type of distance metric to use to find nearest neighbors. For
<code>nn_method = "annoy"</code> this can be one of:
</p>

<ul>
<li> <p><code>"euclidean"</code> (the default)
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"manhattan"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"correlation"</code> (a distance based on the Pearson correlation)
</p>
</li>
<li> <p><code>"categorical"</code> (see below)
</p>
</li></ul>

<p>For <code>nn_method = "hnsw"</code> this can be one of:
</p>

<ul>
<li> <p><code>"euclidean"</code>
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"correlation"</code>
</p>
</li></ul>

<p>If <a href="https://cran.r-project.org/package=rnndescent">rnndescent</a> is
installed and <code>nn_method = "nndescent"</code> is specified then many more
metrics are avaiable, including:
</p>

<ul>
<li> <p><code>"braycurtis"</code>
</p>
</li>
<li> <p><code>"canberra"</code>
</p>
</li>
<li> <p><code>"chebyshev"</code>
</p>
</li>
<li> <p><code>"dice"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"hellinger"</code>
</p>
</li>
<li> <p><code>"jaccard"</code>
</p>
</li>
<li> <p><code>"jensenshannon"</code>
</p>
</li>
<li> <p><code>"kulsinski"</code>
</p>
</li>
<li> <p><code>"rogerstanimoto"</code>
</p>
</li>
<li> <p><code>"russellrao"</code>
</p>
</li>
<li> <p><code>"sokalmichener"</code>
</p>
</li>
<li> <p><code>"sokalsneath"</code>
</p>
</li>
<li> <p><code>"spearmanr"</code>
</p>
</li>
<li> <p><code>"symmetrickl"</code>
</p>
</li>
<li> <p><code>"tsss"</code>
</p>
</li>
<li> <p><code>"yule"</code>
</p>
</li></ul>

<p>For more details see the package documentation of <code>rnndescent</code>.
For <code>nn_method = "fnn"</code>, the distance metric is always &quot;euclidean&quot;.
</p>
<p>If <code>X</code> is a data frame or matrix, then multiple metrics can be
specified, by passing a list to this argument, where the name of each item in
the list is one of the metric names above. The value of each list item should
be a vector giving the names or integer ids of the columns to be included in
a calculation, e.g. <code>metric = list(euclidean = 1:4, manhattan = 5:10)</code>.
</p>
<p>Each metric calculation results in a separate fuzzy simplicial set, which are
intersected together to produce the final set. Metric names can be repeated.
Because non-numeric columns are removed from the data frame, it is safer to
use column names than integer ids.
</p>
<p>Factor columns can also be used by specifying the metric name
<code>"categorical"</code>. Factor columns are treated different from numeric
columns and although multiple factor columns can be specified in a vector,
each factor column specified is processed individually. If you specify
a non-factor column, it will be coerced to a factor.
</p>
<p>For a given data block, you may override the <code>pca</code> and <code>pca_center</code>
arguments for that block, by providing a list with one unnamed item
containing the column names or ids, and then any of the <code>pca</code> or
<code>pca_center</code> overrides as named items, e.g. <code>metric =
list(euclidean = 1:4, manhattan = list(5:10, pca_center = FALSE))</code>. This
exists to allow mixed binary and real-valued data to be included and to have
PCA applied to both, but with centering applied only to the real-valued data
(it is typical not to apply centering to binary data before PCA is applied).</p>
</td></tr>
<tr><td><code id="lvish_+3A_n_epochs">n_epochs</code></td>
<td>
<p>Number of epochs to use during the optimization of the
embedded coordinates. The default is calculate the number of epochs
dynamically based on dataset size, to give the same number of edge samples
as the LargeVis defaults. This is usually substantially larger than the
UMAP defaults. If <code>n_epochs = 0</code>, then coordinates determined by
<code>"init"</code> will be returned.</p>
</td></tr>
<tr><td><code id="lvish_+3A_learning_rate">learning_rate</code></td>
<td>
<p>Initial learning rate used in optimization of the
coordinates.</p>
</td></tr>
<tr><td><code id="lvish_+3A_scale">scale</code></td>
<td>
<p>Scaling to apply to <code>X</code> if it is a data frame or matrix:
</p>

<ul>
<li><p><code>"none"</code> or <code>FALSE</code> or <code>NULL</code> No scaling.
</p>
</li>
<li><p><code>"Z"</code> or <code>"scale"</code> or <code>TRUE</code> Scale each column to
zero mean and variance 1.
</p>
</li>
<li><p><code>"maxabs"</code> Center each column to mean 0, then divide each
element by the maximum absolute value over the entire matrix.
</p>
</li>
<li><p><code>"range"</code> Range scale the entire matrix, so the smallest
element is 0 and the largest is 1.
</p>
</li>
<li><p><code>"colrange"</code> Scale each column in the range (0,1).
</p>
</li></ul>

<p>For lvish, the default is <code>"maxabs"</code>, for consistency with LargeVis.</p>
</td></tr>
<tr><td><code id="lvish_+3A_init">init</code></td>
<td>
<p>Type of initialization for the coordinates. Options are:
</p>

<ul>
<li> <p><code>"spectral"</code> Spectral embedding using the normalized Laplacian
of the fuzzy 1-skeleton, with Gaussian noise added.
</p>
</li>
<li> <p><code>"normlaplacian"</code>. Spectral embedding using the normalized
Laplacian of the fuzzy 1-skeleton, without noise.
</p>
</li>
<li> <p><code>"random"</code>. Coordinates assigned using a uniform random
distribution between -10 and 10.
</p>
</li>
<li> <p><code>"lvrandom"</code>. Coordinates assigned using a Gaussian
distribution with standard deviation 1e-4, as used in LargeVis
(Tang et al., 2016) and t-SNE.
</p>
</li>
<li> <p><code>"laplacian"</code>. Spectral embedding using the Laplacian Eigenmap
(Belkin and Niyogi, 2002).
</p>
</li>
<li> <p><code>"pca"</code>. The first two principal components from PCA of
<code>X</code> if <code>X</code> is a data frame, and from a 2-dimensional classical
MDS if <code>X</code> is of class <code>"dist"</code>.
</p>
</li>
<li> <p><code>"spca"</code>. Like <code>"pca"</code>, but each dimension is then scaled
so the standard deviation is 1e-4, to give a distribution similar to that
used in t-SNE and LargeVis. This is an alias for <code>init = "pca",
   init_sdev = 1e-4</code>.
</p>
</li>
<li> <p><code>"agspectral"</code> An &quot;approximate global&quot; modification of
<code>"spectral"</code> which all edges in the graph to a value of 1, and then
sets a random number of edges (<code>negative_sample_rate</code> edges per
vertex) to 0.1, to approximate the effect of non-local affinities.
</p>
</li>
<li><p> A matrix of initial coordinates.
</p>
</li></ul>

<p>For spectral initializations, (<code>"spectral"</code>, <code>"normlaplacian"</code>,
<code>"laplacian"</code>, <code>"agspectral"</code>), if more than one connected
component is identified, no spectral initialization is attempted. Instead
a PCA-based initialization is attempted. If <code>verbose = TRUE</code> the
number of connected components are logged to the console. The existence of
multiple connected components implies that a global view of the data cannot
be attained with this initialization. Increasing the value of
<code>n_neighbors</code> may help.</p>
</td></tr>
<tr><td><code id="lvish_+3A_init_sdev">init_sdev</code></td>
<td>
<p>If non-<code>NULL</code>, scales each dimension of the initialized
coordinates (including any user-supplied matrix) to this standard
deviation. By default no scaling is carried out, except when <code>init =
"spca"</code>, in which case the value is <code>0.0001</code>. Scaling the input may
help if the unscaled versions result in initial coordinates with large
inter-point distances or outliers. This usually results in small gradients
during optimization and very little progress being made to the layout.
Shrinking the initial embedding by rescaling can help under these
circumstances. Scaling the result of <code>init = "pca"</code> is usually
recommended and <code>init = "spca"</code> as an alias for <code>init = "pca",
init_sdev = 1e-4</code> but for the spectral initializations the scaled versions
usually aren't necessary unless you are using a large value of
<code>n_neighbors</code> (e.g. <code>n_neighbors = 150</code> or higher). For
compatibility with recent versions of the Python UMAP package, if you are
using <code>init = "spectral"</code>, then you should also set
<code>init_sdev = "range"</code>, which will range scale each of the columns
containing the initial data between 0-10. This is not set by default to
maintain backwards compatibility with previous versions of uwot.</p>
</td></tr>
<tr><td><code id="lvish_+3A_repulsion_strength">repulsion_strength</code></td>
<td>
<p>Weighting applied to negative samples in low
dimensional embedding optimization. Values higher than one will result in
greater weight being given to negative samples.</p>
</td></tr>
<tr><td><code id="lvish_+3A_negative_sample_rate">negative_sample_rate</code></td>
<td>
<p>The number of negative edge/1-simplex samples to
use per positive edge/1-simplex sample in optimizing the low dimensional
embedding.</p>
</td></tr>
<tr><td><code id="lvish_+3A_nn_method">nn_method</code></td>
<td>
<p>Method for finding nearest neighbors. Options are:
</p>

<ul>
<li> <p><code>"fnn"</code>. Use exact nearest neighbors via the
<a href="https://cran.r-project.org/package=FNN">FNN</a> package.
</p>
</li>
<li> <p><code>"annoy"</code> Use approximate nearest neighbors via the
<a href="https://cran.r-project.org/package=RcppAnnoy">RcppAnnoy</a> package.
</p>
</li>
<li> <p><code>"hnsw"</code> Use approximate nearest neighbors with the
Hierarchical Navigable Small World (HNSW) method (Malkov and Yashunin,
2018) via the
<a href="https://cran.r-project.org/package=RcppHNSW">RcppHNSW</a> package.
<code>RcppHNSW</code> is not a dependency of this package: this option is
only available if you have installed <code>RcppHNSW</code> yourself. Also,
HNSW only supports the following arguments for <code>metric</code>:
<code>"euclidean"</code>, <code>"cosine"</code> and <code>"correlation"</code>.
</p>
</li>
<li> <p><code>"nndescent"</code> Use approximate nearest neighbors with the
Nearest Neighbor Descent method (Dong et al., 2011) via the
<a href="https://cran.r-project.org/package=rnndescent">rnndescent</a>
package. <code>rnndescent</code> is not a dependency of this package: this
option is only available if you have installed <code>rnndescent</code>
yourself.
</p>
</li></ul>

<p>By default, if <code>X</code> has less than 4,096 vertices, the exact nearest
neighbors are found. Otherwise, approximate nearest neighbors are used.
You may also pass precalculated nearest neighbor data to this argument. It
must be a list consisting of two elements:
</p>

<ul>
<li> <p><code>"idx"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the integer indexes of the nearest neighbors in <code>X</code>. Each
vertex is considered to be its own nearest neighbor, i.e.
<code>idx[, 1] == 1:n_vertices</code>.
</p>
</li>
<li> <p><code>"dist"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the distances of the nearest neighbors.
</p>
</li></ul>

<p>Multiple nearest neighbor data (e.g. from two different precomputed
metrics) can be passed by passing a list containing the nearest neighbor
data lists as items.
The <code>n_neighbors</code> parameter is ignored when using precomputed
nearest neighbor data.</p>
</td></tr>
<tr><td><code id="lvish_+3A_n_trees">n_trees</code></td>
<td>
<p>Number of trees to build when constructing the nearest
neighbor index. The more trees specified, the larger the index, but the
better the results. With <code>search_k</code>, determines the accuracy of the
Annoy nearest neighbor search. Only used if the <code>nn_method</code> is
<code>"annoy"</code>. Sensible values are between <code>10</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="lvish_+3A_search_k">search_k</code></td>
<td>
<p>Number of nodes to search during the neighbor retrieval. The
larger k, the more the accurate results, but the longer the search takes.
With <code>n_trees</code>, determines the accuracy of the Annoy nearest neighbor
search. Only used if the <code>nn_method</code> is <code>"annoy"</code>.</p>
</td></tr>
<tr><td><code id="lvish_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use (except during stochastic gradient
descent). Default is half the number of concurrent threads supported by the
system. For nearest neighbor search, only applies if
<code>nn_method = "annoy"</code>. If <code>n_threads &gt; 1</code>, then the Annoy index
will be temporarily written to disk in the location determined by
<code><a href="base.html#topic+tempfile">tempfile</a></code>.</p>
</td></tr>
<tr><td><code id="lvish_+3A_n_sgd_threads">n_sgd_threads</code></td>
<td>
<p>Number of threads to use during stochastic gradient
descent. If set to &gt; 1, then be aware that if <code>batch = FALSE</code>, results
will <em>not</em> be reproducible, even if <code>set.seed</code> is called with a
fixed seed before running. Set to <code>"auto"</code> to use the same value as
<code>n_threads</code>.</p>
</td></tr>
<tr><td><code id="lvish_+3A_grain_size">grain_size</code></td>
<td>
<p>The minimum amount of work to do on each thread. If this
value is set high enough, then less than <code>n_threads</code> or
<code>n_sgd_threads</code> will be used for processing, which might give a
performance improvement if the overhead of thread management and context
switching was outweighing the improvement due to concurrent processing.
This should be left at default (<code>1</code>) and work will be spread evenly
over all the threads specified.</p>
</td></tr>
<tr><td><code id="lvish_+3A_kernel">kernel</code></td>
<td>
<p>Type of kernel function to create input probabilities. Can be
one of <code>"gauss"</code> (the default) or <code>"knn"</code>. <code>"gauss"</code> uses
the usual Gaussian weighted similarities. <code>"knn"</code> assigns equal
probabilities to every edge in the nearest neighbor graph, and zero
otherwise, using <code>perplexity</code> nearest neighbors. The <code>n_neighbors</code>
parameter is ignored in this case.</p>
</td></tr>
<tr><td><code id="lvish_+3A_pca">pca</code></td>
<td>
<p>If set to a positive integer value, reduce data to this number of
columns using PCA. Doesn't applied if the distance <code>metric</code> is
<code>"hamming"</code>, or the dimensions of the data is larger than the
number specified (i.e. number of rows and columns must be larger than the
value of this parameter). If you have &gt; 100 columns in a data frame or
matrix, reducing the number of columns in this way may substantially
increase the performance of the nearest neighbor search at the cost of a
potential decrease in accuracy. In many t-SNE applications, a value of 50
is recommended, although there's no guarantee that this is appropriate for
all settings.</p>
</td></tr>
<tr><td><code id="lvish_+3A_pca_center">pca_center</code></td>
<td>
<p>If <code>TRUE</code>, center the columns of <code>X</code> before
carrying out PCA. For binary data, it's recommended to set this to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lvish_+3A_pcg_rand">pcg_rand</code></td>
<td>
<p>If <code>TRUE</code>, use the PCG random number generator (O'Neill,
2014) during optimization. Otherwise, use the faster (but probably less
statistically good) Tausworthe &quot;taus88&quot; generator. The default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lvish_+3A_fast_sgd">fast_sgd</code></td>
<td>
<p>If <code>TRUE</code>, then the following combination of parameters
is set: <code>pcg_rand = TRUE</code> and <code>n_sgd_threads = "auto"</code>. The
default is <code>FALSE</code>. Setting this to <code>TRUE</code> will speed up the
stochastic optimization phase, but give a potentially less accurate
embedding, and which will not be exactly reproducible even with a fixed
seed. For visualization, <code>fast_sgd = TRUE</code> will give perfectly good
results. For more generic dimensionality reduction, it's safer to leave
<code>fast_sgd = FALSE</code>. If <code>fast_sgd = TRUE</code>, then user-supplied
values of <code>pcg_rand</code> and <code>n_sgd_threads</code>, are ignored.</p>
</td></tr>
<tr><td><code id="lvish_+3A_ret_nn">ret_nn</code></td>
<td>
<p>If <code>TRUE</code>, then in addition to the embedding, also return
nearest neighbor data that can be used as input to <code>nn_method</code> to
avoid the overhead of repeatedly calculating the nearest neighbors when
manipulating unrelated parameters (e.g. <code>min_dist</code>, <code>n_epochs</code>,
<code>init</code>). See the &quot;Value&quot; section for the names of the list items. If
<code>FALSE</code>, just return the coordinates. Note that the nearest neighbors
could be sensitive to data scaling, so be wary of reusing nearest neighbor
data if modifying the <code>scale</code> parameter.</p>
</td></tr>
<tr><td><code id="lvish_+3A_ret_extra">ret_extra</code></td>
<td>
<p>A vector indicating what extra data to return. May contain
any combination of the following strings:
</p>

<ul>
<li> <p><code>"nn"</code> same as setting <code>ret_nn = TRUE</code>.
</p>
</li>
<li> <p><code>"P"</code> the high dimensional probability matrix. The graph
is returned as a sparse symmetric N x N matrix of class
<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a>, where a non-zero entry (i, j) gives the
input probability (or similarity or affinity) of the edge connecting
vertex i and vertex j. Note that the graph is further sparsified by
removing edges with sufficiently low membership strength that they
would not be sampled by the probabilistic edge sampling employed for
optimization and therefore the number of non-zero elements in the
matrix is dependent on <code>n_epochs</code>. If you are only interested in
the fuzzy input graph (e.g. for clustering), setting
<code>n_epochs = 0</code> will avoid any further sparsifying. Be aware that
setting <code>binary_edge_weights = TRUE</code> will affect this graph (all
non-zero edge weights will be 1).
</p>
</li>
<li> <p><code>sigma</code> a vector of the bandwidths used to calibrate the input
Gaussians to reproduce the target <code>"perplexity"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="lvish_+3A_tmpdir">tmpdir</code></td>
<td>
<p>Temporary directory to store nearest neighbor indexes during
nearest neighbor search. Default is <code><a href="base.html#topic+tempdir">tempdir</a></code>. The index is
only written to disk if <code>n_threads &gt; 1</code> and
<code>nn_method = "annoy"</code>; otherwise, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="lvish_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, log details to the console.</p>
</td></tr>
<tr><td><code id="lvish_+3A_batch">batch</code></td>
<td>
<p>If <code>TRUE</code>, then embedding coordinates are updated at the
end of each epoch rather than during the epoch. In batch mode, results are
reproducible with a fixed random seed even with <code>n_sgd_threads &gt; 1</code>,
at the cost of a slightly higher memory use. You may also have to modify
<code>learning_rate</code> and increase <code>n_epochs</code>, so whether this provides
a speed increase over the single-threaded optimization is likely to be
dataset and hardware-dependent.</p>
</td></tr>
<tr><td><code id="lvish_+3A_opt_args">opt_args</code></td>
<td>
<p>A list of optimizer parameters, used when
<code>batch = TRUE</code>. The default optimization method used is Adam (Kingma
and Ba, 2014).
</p>

<ul>
<li> <p><code>method</code> The optimization method to use. Either <code>"adam"</code>
or <code>"sgd"</code> (stochastic gradient descent). Default: <code>"adam"</code>.
</p>
</li>
<li> <p><code>beta1</code> (Adam only). The weighting parameter for the
exponential moving average of the first moment estimator. Effectively the
momentum parameter. Should be a floating point value between 0 and 1.
Higher values can smooth oscillatory updates in poorly-conditioned
situations and may allow for a larger <code>learning_rate</code> to be
specified, but too high can cause divergence. Default: <code>0.5</code>.
</p>
</li>
<li> <p><code>beta2</code> (Adam only). The weighting parameter for the
exponential moving average of the uncentered second moment estimator.
Should be a floating point value between 0 and 1. Controls the degree of
adaptivity in the step-size. Higher values put more weight on previous
time steps. Default: <code>0.9</code>.
</p>
</li>
<li> <p><code>eps</code> (Adam only). Intended to be a small value to prevent
division by zero, but in practice can also affect convergence due to its
interaction with <code>beta2</code>. Higher values reduce the effect of the
step-size adaptivity and bring the behavior closer to stochastic gradient
descent with momentum. Typical values are between 1e-8 and 1e-3. Default:
<code>1e-7</code>.
</p>
</li>
<li> <p><code>alpha</code> The initial learning rate. Default: the value of the
<code>learning_rate</code> parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="lvish_+3A_epoch_callback">epoch_callback</code></td>
<td>
<p>A function which will be invoked at the end of every
epoch. Its signature should be: <code>(epoch, n_epochs, coords)</code>, where:
</p>

<ul>
<li> <p><code>epoch</code> The current epoch number (between <code>1</code> and
<code>n_epochs</code>).
</p>
</li>
<li> <p><code>n_epochs</code> Number of epochs to use during the optimization of
the embedded coordinates.
</p>
</li>
<li> <p><code>coords</code> The embedded coordinates as of the end of the current
epoch, as a matrix with dimensions (N, <code>n_components</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="lvish_+3A_pca_method">pca_method</code></td>
<td>
<p>Method to carry out any PCA dimensionality reduction when
the <code>pca</code> parameter is specified. Allowed values are:
</p>

<ul>
<li><p><code>"irlba"</code>. Uses <code><a href="irlba.html#topic+prcomp_irlba">prcomp_irlba</a></code> from the
<a href="https://cran.r-project.org/package=irlba">irlba</a> package.
</p>
</li>
<li><p><code>"rsvd"</code>. Uses 5 iterations of <code><a href="irlba.html#topic+svdr">svdr</a></code> from
the <a href="https://cran.r-project.org/package=irlba">irlba</a> package.
This is likely to give much faster but potentially less accurate results
than using <code>"irlba"</code>. For the purposes of nearest neighbor
calculation and coordinates initialization, any loss of accuracy doesn't
seem to matter much.
</p>
</li>
<li><p><code>"bigstatsr"</code>. Uses <code><a href="bigstatsr.html#topic+big_randomSVD">big_randomSVD</a></code>
from the <a href="https://cran.r-project.org/package=bigstatsr">bigstatsr</a>
package. The SVD methods used in <code>bigstatsr</code> may be faster on
systems without access to efficient linear algebra libraries (e.g.
Windows). <strong>Note</strong>: <code>bigstatsr</code> is <em>not</em> a dependency of
uwot: if you choose to use this package for PCA, you <em>must</em> install
it yourself.
</p>
</li>
<li><p><code>"svd"</code>. Uses <code><a href="base.html#topic+svd">svd</a></code> for the SVD. This is
likely to be slow for all but the smallest datasets.
</p>
</li>
<li><p><code>"auto"</code> (the default). Uses <code>"irlba"</code>, unless more than
50
case <code>"svd"</code> is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="lvish_+3A_binary_edge_weights">binary_edge_weights</code></td>
<td>
<p>If <code>TRUE</code> then edge weights in the input
graph are treated as binary (0/1) rather than real valued. This affects the
sampling frequency of neighbors and is the strategy used by the PaCMAP
method (Wang and co-workers, 2020). Practical (Böhm and co-workers, 2020)
and theoretical (Damrich and Hamprecht, 2021) work suggests this has little
effect on UMAP's performance.</p>
</td></tr>
<tr><td><code id="lvish_+3A_nn_args">nn_args</code></td>
<td>
<p>A list containing additional arguments to pass to the nearest
neighbor method. For <code>nn_method = "annoy"</code>, you can specify
<code>"n_trees"</code> and <code>"search_k"</code>, and these will override the
<code>n_trees</code> and <code>search_k</code> parameters.
For <code>nn_method = "hnsw"</code>, you may specify the following arguments:
</p>

<ul>
<li> <p><code>M</code> The maximum number of neighbors to keep for each vertex.
Reasonable values are <code>2</code> to <code>100</code>. Higher values give better
recall at the cost of more memory. Default value is <code>16</code>.
</p>
</li>
<li> <p><code>ef_construction</code> A positive integer specifying the size of
the dynamic list used during index construction. A higher value will
provide better results at the cost of a longer time to build the index.
Default is <code>200</code>.
</p>
</li>
<li> <p><code>ef</code> A positive integer specifying the size of the dynamic
list used during search. This cannot be smaller than <code>n_neighbors</code>
and cannot be higher than the number of items in the index. Default is
<code>10</code>.
</p>
</li></ul>

<p>For <code>nn_method = "nndescent"</code>, you may specify the following
arguments:
</p>

<ul>
<li> <p><code>n_trees</code> The number of trees to use in a random projection
forest to initialize the search. A larger number will give more accurate
results at the cost of a longer computation time. The default of
<code>NULL</code> means that the number is chosen based on the number of
observations in <code>X</code>.
</p>
</li>
<li> <p><code>max_candidates</code> The number of potential neighbors to explore
per iteration. By default, this is set to <code>n_neighbors</code> or <code>60</code>,
whichever is smaller. A larger number will give more accurate results at
the cost of a longer computation time.
</p>
</li>
<li> <p><code>n_iters</code> The number of iterations to run the search. A larger
number will give more accurate results at the cost of a longer computation
time. By default, this will be chosen based on the number of observations
in <code>X</code>. You may also need to modify the convergence criterion
<code>delta</code>.
</p>
</li>
<li> <p><code>delta</code> The minimum relative change in the neighbor graph
allowed before early stopping. Should be a value between 0 and 1. The
smaller the value, the smaller the amount of progress between iterations is
allowed. Default value of <code>0.001</code> means that at least 0.1
neighbor graph must be updated at each iteration.
</p>
</li>
<li> <p><code>init</code> How to initialize the nearest neighbor descent. By
default this is set to <code>"tree"</code> and uses a random project forest.
If you set this to <code>"rand"</code>, then a random selection is used. Usually
this is less accurate than using RP trees, but for high-dimensional cases,
there may be little difference in the quality of the initialization and
random initialization will be a lot faster. If you set this to
<code>"rand"</code>, then the <code>n_trees</code> parameter is ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lvish</code> differs from the official LargeVis implementation in the
following:
</p>

<ul>
<li><p> Only the nearest-neighbor index search phase is multi-threaded.
</p>
</li>
<li><p> Matrix input data is not normalized.
</p>
</li>
<li><p> The <code>n_trees</code> parameter cannot be dynamically chosen based on
data set size.
</p>
</li>
<li><p> Nearest neighbor results are not refined via the
neighbor-of-my-neighbor method. The <code>search_k</code> parameter is twice
as large than default to compensate.
</p>
</li>
<li><p> Gradient values are clipped to <code>4.0</code> rather than <code>5.0</code>.
</p>
</li>
<li><p> Negative edges are generated by uniform sampling of vertexes rather
than their degree ^ 0.75.
</p>
</li>
<li><p> The default number of samples is much reduced. The default number of
epochs, <code>n_epochs</code>, is set to <code>5000</code>, much larger than for
<code><a href="#topic+umap">umap</a></code>, but may need to be increased further depending on your
dataset. Using <code>init = "spectral"</code> can help.
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix of optimized coordinates, or:
</p>

<ul>
<li><p> if <code>ret_nn = TRUE</code> (or <code>ret_extra</code> contains <code>"nn"</code>),
returns the nearest neighbor data as a list called <code>nn</code>. This
contains one list for each <code>metric</code> calculated, itself containing a
matrix <code>idx</code> with the integer ids of the neighbors; and a matrix
<code>dist</code> with the distances. The <code>nn</code> list (or a sub-list) can be
used as input to the <code>nn_method</code> parameter.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"P"</code>, returns the high
dimensional probability matrix as a sparse matrix called <code>P</code>, of
type <a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a>.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"sigma"</code>, returns a vector of
the high dimensional gaussian bandwidths for each point, and
<code>"dint"</code> a vector of estimates of the intrinsic dimensionality at
each point, based on the method given by Lee and co-workers (2015).
</p>
</li></ul>

<p>The returned list contains the combined data from any combination of
specifying <code>ret_nn</code> and <code>ret_extra</code>.
</p>


<h3>References</h3>

<p>Belkin, M., &amp; Niyogi, P. (2002).
Laplacian eigenmaps and spectral techniques for embedding and clustering.
In <em>Advances in neural information processing systems</em>
(pp. 585-591).
<a href="http://papers.nips.cc/paper/1961-laplacian-eigenmaps-and-spectral-techniques-for-embedding-and-clustering.pdf">http://papers.nips.cc/paper/1961-laplacian-eigenmaps-and-spectral-techniques-for-embedding-and-clustering.pdf</a>
</p>
<p>Böhm, J. N., Berens, P., &amp; Kobak, D. (2020).
A unifying perspective on neighbor embeddings along the attraction-repulsion spectrum.
<em>arXiv preprint</em> <em>arXiv:2007.08902</em>.
<a href="https://arxiv.org/abs/2007.08902">https://arxiv.org/abs/2007.08902</a>
</p>
<p>Damrich, S., &amp; Hamprecht, F. A. (2021).
On UMAP's true loss function.
<em>Advances in Neural Information Processing Systems</em>, <em>34</em>.
<a href="https://proceedings.neurips.cc/paper/2021/hash/2de5d16682c3c35007e4e92982f1a2ba-Abstract.html">https://proceedings.neurips.cc/paper/2021/hash/2de5d16682c3c35007e4e92982f1a2ba-Abstract.html</a>
</p>
<p>Dong, W., Moses, C., &amp; Li, K. (2011, March).
Efficient k-nearest neighbor graph construction for generic similarity measures.
In <em>Proceedings of the 20th international conference on World Wide Web</em>
(pp. 577-586).
ACM.
<a href="https://doi.org/10.1145/1963405.1963487">doi:10.1145/1963405.1963487</a>.
</p>
<p>Kingma, D. P., &amp; Ba, J. (2014).
Adam: A method for stochastic optimization.
<em>arXiv preprint</em> <em>arXiv</em>:1412.6980.
<a href="https://arxiv.org/abs/1412.6980">https://arxiv.org/abs/1412.6980</a>
</p>
<p>Lee, J. A., Peluffo-Ordóñez, D. H., &amp; Verleysen, M. (2015).
Multi-scale similarities in stochastic neighbour embedding: Reducing
dimensionality while preserving both local and global structure.
<em>Neurocomputing</em>, <em>169</em>, 246-261.
</p>
<p>Malkov, Y. A., &amp; Yashunin, D. A. (2018).
Efficient and robust approximate nearest neighbor search using hierarchical
navigable small world graphs.
<em>IEEE transactions on pattern analysis and machine intelligence</em>, <em>42</em>(4), 824-836.
</p>
<p>McInnes, L., Healy, J., &amp; Melville, J. (2018).
UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction
<em>arXiv preprint</em> <em>arXiv</em>:1802.03426.
<a href="https://arxiv.org/abs/1802.03426">https://arxiv.org/abs/1802.03426</a>
</p>
<p>O’Neill, M. E. (2014).
<em>PCG: A family of simple fast space-efficient statistically good
algorithms for random number generation</em>
(Report No. HMC-CS-2014-0905). Harvey Mudd College.
</p>
<p>Tang, J., Liu, J., Zhang, M., &amp; Mei, Q. (2016, April).
Visualizing large-scale and high-dimensional data.
In <em>Proceedings of the 25th International Conference on World Wide Web</em>
(pp. 287-297).
International World Wide Web Conferences Steering Committee.
<a href="https://arxiv.org/abs/1602.00370">https://arxiv.org/abs/1602.00370</a>
</p>
<p>Van der Maaten, L., &amp; Hinton, G. (2008).
Visualizing data using t-SNE.
<em>Journal of Machine Learning Research</em>, <em>9</em> (2579-2605).
<a href="https://www.jmlr.org/papers/v9/vandermaaten08a.html">https://www.jmlr.org/papers/v9/vandermaaten08a.html</a>
</p>
<p>Wang, Y., Huang, H., Rudin, C., &amp; Shaposhnik, Y. (2021).
Understanding How Dimension Reduction Tools Work: An Empirical Approach to Deciphering t-SNE, UMAP, TriMap, and PaCMAP for Data Visualization.
<em>Journal of Machine Learning Research</em>, <em>22</em>(201), 1-73.
<a href="https://www.jmlr.org/papers/v22/20-1061.html">https://www.jmlr.org/papers/v22/20-1061.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default number of epochs is much larger than for UMAP, assumes random
# initialization. Use perplexity rather than n_neighbors to control the size
# of the local neighborhood 20 epochs may be too small for a random
# initialization
iris_lvish &lt;- lvish(iris,
  perplexity = 50, learning_rate = 0.5,
  init = "random", n_epochs = 20
)

</code></pre>

<hr>
<h2 id='optimize_graph_layout'>Optimize Graph Layout</h2><span id='topic+optimize_graph_layout'></span>

<h3>Description</h3>

<p>Carry out dimensionality reduction on an input graph, where the distances in
the low dimensional space attempt to reproduce the neighbor relations in the
input data. By default, the cost function used to optimize the output
coordinates use the Uniform Manifold Approximation and Projection (UMAP)
method (McInnes et al., 2018), but the approach from LargeVis (Tang et al.,
2016) can also be used. This function can be used to produce a low
dimensional representation of the graph produced by
<code><a href="#topic+similarity_graph">similarity_graph</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_graph_layout(
  graph,
  X = NULL,
  n_components = 2,
  n_epochs = NULL,
  learning_rate = 1,
  init = "spectral",
  init_sdev = NULL,
  spread = 1,
  min_dist = 0.01,
  repulsion_strength = 1,
  negative_sample_rate = 5,
  a = NULL,
  b = NULL,
  method = "umap",
  approx_pow = FALSE,
  pcg_rand = TRUE,
  fast_sgd = FALSE,
  n_sgd_threads = 0,
  grain_size = 1,
  verbose = getOption("verbose", TRUE),
  batch = FALSE,
  opt_args = NULL,
  epoch_callback = NULL,
  pca_method = NULL,
  binary_edge_weights = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_graph_layout_+3A_graph">graph</code></td>
<td>
<p>A sparse, symmetric N x N weighted adjacency matrix
representing a graph. Non-zero entries indicate an edge between two nodes
with a given edge weight. There can be a varying number of non-zero entries
in each row/column.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_x">X</code></td>
<td>
<p>Optional input data. Used only for PCA-based initialization.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_n_components">n_components</code></td>
<td>
<p>The dimension of the space to embed into. This defaults
to <code>2</code> to provide easy visualization, but can reasonably be set to any
integer value in the range <code>2</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_n_epochs">n_epochs</code></td>
<td>
<p>Number of epochs to use during the optimization of the
embedded coordinates. By default, this value is set to <code>500</code> for
datasets containing 10,000 vertices or less, and <code>200</code> otherwise.
If <code>n_epochs = 0</code>, then coordinates determined by <code>"init"</code> will
be returned.
For UMAP, the default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_learning_rate">learning_rate</code></td>
<td>
<p>Initial learning rate used in optimization of the
coordinates.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_init">init</code></td>
<td>
<p>Type of initialization for the coordinates. Options are:
</p>

<ul>
<li> <p><code>"spectral"</code> Spectral embedding using the normalized Laplacian
of the fuzzy 1-skeleton, with Gaussian noise added.
</p>
</li>
<li> <p><code>"normlaplacian"</code>. Spectral embedding using the normalized
Laplacian of the fuzzy 1-skeleton, without noise.
</p>
</li>
<li> <p><code>"random"</code>. Coordinates assigned using a uniform random
distribution between -10 and 10.
</p>
</li>
<li> <p><code>"lvrandom"</code>. Coordinates assigned using a Gaussian
distribution with standard deviation 1e-4, as used in LargeVis
(Tang et al., 2016) and t-SNE.
</p>
</li>
<li> <p><code>"laplacian"</code>. Spectral embedding using the Laplacian Eigenmap.
</p>
</li>
<li> <p><code>"pca"</code>. The first two principal components from PCA of
<code>X</code> if <code>X</code> is a data frame, and from a 2-dimensional classical
MDS if <code>X</code> is of class <code>"dist"</code>.
</p>
</li>
<li> <p><code>"spca"</code>. Like <code>"pca"</code>, but each dimension is then scaled
so the standard deviation is 1e-4, to give a distribution similar to that
used in t-SNE. This is an alias for <code>init = "pca", init_sdev =
   1e-4</code>.
</p>
</li>
<li> <p><code>"agspectral"</code> An &quot;approximate global&quot; modification of
<code>"spectral"</code> which all edges in the graph to a value of 1, and then
sets a random number of edges (<code>negative_sample_rate</code> edges per
vertex) to 0.1, to approximate the effect of non-local affinities.
</p>
</li>
<li><p> A matrix of initial coordinates.
</p>
</li></ul>

<p>For spectral initializations, (<code>"spectral"</code>, <code>"normlaplacian"</code>,
<code>"laplacian"</code>, <code>"agspectral"</code>), if more than one connected
component is identified, no spectral initialization is attempted. Instead
a PCA-based initialization is attempted. If <code>verbose = TRUE</code> the
number of connected components are logged to the console. The existence of
multiple connected components implies that a global view of the data cannot
be attained with this initialization. Increasing the value of
<code>n_neighbors</code> may help.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_init_sdev">init_sdev</code></td>
<td>
<p>If non-<code>NULL</code>, scales each dimension of the initialized
coordinates (including any user-supplied matrix) to this standard
deviation. By default no scaling is carried out, except when <code>init =
"spca"</code>, in which case the value is <code>0.0001</code>. Scaling the input may
help if the unscaled versions result in initial coordinates with large
inter-point distances or outliers. This usually results in small gradients
during optimization and very little progress being made to the layout.
Shrinking the initial embedding by rescaling can help under these
circumstances. Scaling the result of <code>init = "pca"</code> is usually
recommended and <code>init = "spca"</code> as an alias for <code>init = "pca",
init_sdev = 1e-4</code> but for the spectral initializations the scaled versions
usually aren't necessary unless you are using a large value of
<code>n_neighbors</code> (e.g. <code>n_neighbors = 150</code> or higher). For
compatibility with recent versions of the Python UMAP package, if you are
using <code>init = "spectral"</code>, then you should also set
<code>init_sdev = "range"</code>, which will range scale each of the columns
containing the initial data between 0-10. This is not set by default to
maintain backwards compatibility with previous versions of uwot.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_spread">spread</code></td>
<td>
<p>The effective scale of embedded points. In combination with
<code>min_dist</code>, this determines how clustered/clumped the embedded points
are.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_min_dist">min_dist</code></td>
<td>
<p>The effective minimum distance between embedded points.
Smaller values will result in a more clustered/clumped embedding where
nearby points on the manifold are drawn closer together, while larger
values will result on a more even dispersal of points. The value should be
set relative to the <code>spread</code> value, which determines the scale at
which embedded points will be spread out.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_repulsion_strength">repulsion_strength</code></td>
<td>
<p>Weighting applied to negative samples in low
dimensional embedding optimization. Values higher than one will result in
greater weight being given to negative samples.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_negative_sample_rate">negative_sample_rate</code></td>
<td>
<p>The number of negative edge/1-simplex samples to
use per positive edge/1-simplex sample in optimizing the low dimensional
embedding.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_a">a</code></td>
<td>
<p>More specific parameters controlling the embedding. If <code>NULL</code>
these values are set automatically as determined by <code>min_dist</code> and
<code>spread</code>.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_b">b</code></td>
<td>
<p>More specific parameters controlling the embedding. If <code>NULL</code>
these values are set automatically as determined by <code>min_dist</code> and
<code>spread</code>.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_method">method</code></td>
<td>
<p>Cost function to optimize. One of:
</p>

<ul>
<li><p><code>"umap"</code>. The UMAP method of McInnes and co-workers (2018).
</p>
</li>
<li><p><code>"tumap"</code>. UMAP with the <code>a</code> and <code>b</code> parameters fixed
to 1.
</p>
</li>
<li><p><code>"largevis"</code>. The LargeVis method Tang and co-workers (2016).
</p>
</li></ul>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_approx_pow">approx_pow</code></td>
<td>
<p>If <code>TRUE</code>, use an approximation to the power function
in the UMAP gradient, from
<a href="https://martin.ankerl.com/2012/01/25/optimized-approximative-pow-in-c-and-cpp/">https://martin.ankerl.com/2012/01/25/optimized-approximative-pow-in-c-and-cpp/</a>.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_pcg_rand">pcg_rand</code></td>
<td>
<p>If <code>TRUE</code>, use the PCG random number generator (O'Neill,
2014) during optimization. Otherwise, use the faster (but probably less
statistically good) Tausworthe &quot;taus88&quot; generator. The default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_fast_sgd">fast_sgd</code></td>
<td>
<p>If <code>TRUE</code>, then the following combination of parameters
is set: <code>pcg_rand = TRUE</code>, <code>n_sgd_threads = "auto"</code> and
<code>approx_pow = TRUE</code>. The default is <code>FALSE</code>. Setting this to
<code>TRUE</code> will speed up the stochastic optimization phase, but give a
potentially less accurate embedding, and which will not be exactly
reproducible even with a fixed seed. For visualization, <code>fast_sgd =
TRUE</code> will give perfectly good results. For more generic dimensionality
reduction, it's safer to leave <code>fast_sgd = FALSE</code>. If <code>fast_sgd =
TRUE</code>, then user-supplied values of <code>pcg_rand</code>, <code>n_sgd_threads</code>,
and <code>approx_pow</code> are ignored.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_n_sgd_threads">n_sgd_threads</code></td>
<td>
<p>Number of threads to use during stochastic gradient
descent. If set to &gt; 1, then be aware that if <code>batch = FALSE</code>, results
will <em>not</em> be reproducible, even if <code>set.seed</code> is called with a
fixed seed before running. If set to <code>"auto"</code> then half the number of
concurrent threads supported by the system will be used.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_grain_size">grain_size</code></td>
<td>
<p>The minimum amount of work to do on each thread. If this
value is set high enough, then less than <code>n_threads</code> or
<code>n_sgd_threads</code> will be used for processing, which might give a
performance improvement if the overhead of thread management and context
switching was outweighing the improvement due to concurrent processing.
This should be left at default (<code>1</code>) and work will be spread evenly
over all the threads specified.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, log details to the console.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_batch">batch</code></td>
<td>
<p>If <code>TRUE</code>, then embedding coordinates are updated at the
end of each epoch rather than during the epoch. In batch mode, results are
reproducible with a fixed random seed even with <code>n_sgd_threads &gt; 1</code>,
at the cost of a slightly higher memory use. You may also have to modify
<code>learning_rate</code> and increase <code>n_epochs</code>, so whether this provides
a speed increase over the single-threaded optimization is likely to be
dataset and hardware-dependent.</p>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_opt_args">opt_args</code></td>
<td>
<p>A list of optimizer parameters, used when
<code>batch = TRUE</code>. The default optimization method used is Adam (Kingma
and Ba, 2014).
</p>

<ul>
<li> <p><code>method</code> The optimization method to use. Either <code>"adam"</code>
or <code>"sgd"</code> (stochastic gradient descent). Default: <code>"adam"</code>.
</p>
</li>
<li> <p><code>beta1</code> (Adam only). The weighting parameter for the
exponential moving average of the first moment estimator. Effectively the
momentum parameter. Should be a floating point value between 0 and 1.
Higher values can smooth oscillatory updates in poorly-conditioned
situations and may allow for a larger <code>learning_rate</code> to be
specified, but too high can cause divergence. Default: <code>0.5</code>.
</p>
</li>
<li> <p><code>beta2</code> (Adam only). The weighting parameter for the
exponential moving average of the uncentered second moment estimator.
Should be a floating point value between 0 and 1. Controls the degree of
adaptivity in the step-size. Higher values put more weight on previous
time steps. Default: <code>0.9</code>.
</p>
</li>
<li> <p><code>eps</code> (Adam only). Intended to be a small value to prevent
division by zero, but in practice can also affect convergence due to its
interaction with <code>beta2</code>. Higher values reduce the effect of the
step-size adaptivity and bring the behavior closer to stochastic gradient
descent with momentum. Typical values are between 1e-8 and 1e-3. Default:
<code>1e-7</code>.
</p>
</li>
<li> <p><code>alpha</code> The initial learning rate. Default: the value of the
<code>learning_rate</code> parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_epoch_callback">epoch_callback</code></td>
<td>
<p>A function which will be invoked at the end of every
epoch. Its signature should be: <code>(epoch, n_epochs, coords)</code>, where:
</p>

<ul>
<li> <p><code>epoch</code> The current epoch number (between <code>1</code> and
<code>n_epochs</code>).
</p>
</li>
<li> <p><code>n_epochs</code> Number of epochs to use during the optimization of
the embedded coordinates.
</p>
</li>
<li> <p><code>coords</code> The embedded coordinates as of the end of the current
epoch, as a matrix with dimensions (N, <code>n_components</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_pca_method">pca_method</code></td>
<td>
<p>Method to carry out any PCA dimensionality reduction when
the <code>pca</code> parameter is specified. Allowed values are:
</p>

<ul>
<li><p><code>"irlba"</code>. Uses <code><a href="irlba.html#topic+prcomp_irlba">prcomp_irlba</a></code> from the
<a href="https://cran.r-project.org/package=irlba">irlba</a> package.
</p>
</li>
<li><p><code>"rsvd"</code>. Uses 5 iterations of <code><a href="irlba.html#topic+svdr">svdr</a></code> from
the <a href="https://cran.r-project.org/package=irlba">irlba</a> package.
This is likely to give much faster but potentially less accurate results
than using <code>"irlba"</code>. For the purposes of nearest neighbor
calculation and coordinates initialization, any loss of accuracy doesn't
seem to matter much.
</p>
</li>
<li><p><code>"bigstatsr"</code>. Uses <code><a href="bigstatsr.html#topic+big_randomSVD">big_randomSVD</a></code>
from the <a href="https://cran.r-project.org/package=bigstatsr">bigstatsr</a>
package. The SVD methods used in <code>bigstatsr</code> may be faster on
systems without access to efficient linear algebra libraries (e.g.
Windows). <strong>Note</strong>: <code>bigstatsr</code> is <em>not</em> a dependency of
uwot: if you choose to use this package for PCA, you <em>must</em> install
it yourself.
</p>
</li>
<li><p><code>"svd"</code>. Uses <code><a href="base.html#topic+svd">svd</a></code> for the SVD. This is
likely to be slow for all but the smallest datasets.
</p>
</li>
<li><p><code>"auto"</code> (the default). Uses <code>"irlba"</code>, unless more than
50
case <code>"svd"</code> is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="optimize_graph_layout_+3A_binary_edge_weights">binary_edge_weights</code></td>
<td>
<p>If <code>TRUE</code> then edge weights in the input
graph are treated as binary (0/1) rather than real valued.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of optimized coordinates.
</p>


<h3>References</h3>

<p>Kingma, D. P., &amp; Ba, J. (2014).
Adam: A method for stochastic optimization.
<em>arXiv preprint</em> <em>arXiv</em>:1412.6980.
<a href="https://arxiv.org/abs/1412.6980">https://arxiv.org/abs/1412.6980</a>
</p>
<p>McInnes, L., Healy, J., &amp; Melville, J. (2018).
UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction
<em>arXiv preprint</em> <em>arXiv</em>:1802.03426.
<a href="https://arxiv.org/abs/1802.03426">https://arxiv.org/abs/1802.03426</a>
</p>
<p>O’Neill, M. E. (2014).
<em>PCG: A family of simple fast space-efficient statistically good
algorithms for random number generation</em>
(Report No. HMC-CS-2014-0905). Harvey Mudd College.
</p>
<p>Tang, J., Liu, J., Zhang, M., &amp; Mei, Q. (2016, April).
Visualizing large-scale and high-dimensional data.
In <em>Proceedings of the 25th International Conference on World Wide Web</em>
(pp. 287-297).
International World Wide Web Conferences Steering Committee.
<a href="https://arxiv.org/abs/1602.00370">https://arxiv.org/abs/1602.00370</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris30 &lt;- iris[c(1:10, 51:60, 101:110), ]

# return a 30 x 30 sparse matrix with similarity data based on 10 nearest
# neighbors per item
iris30_sim_graph &lt;- similarity_graph(iris30, n_neighbors = 10)
# produce 2D coordinates replicating the neighbor relations in the similarity
# graph
set.seed(42)
iris30_opt &lt;- optimize_graph_layout(iris30_sim_graph, X = iris30)

# the above two steps are the same as:
# set.seed(42); iris_umap &lt;- umap(iris30, n_neighbors = 10)

</code></pre>

<hr>
<h2 id='save_uwot'>Save or Load a Model</h2><span id='topic+save_uwot'></span>

<h3>Description</h3>

<p>Functions to write a UMAP model to a file, and to restore.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_uwot(model, file, unload = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_uwot_+3A_model">model</code></td>
<td>
<p>a UMAP model create by <code><a href="#topic+umap">umap</a></code>.</p>
</td></tr>
<tr><td><code id="save_uwot_+3A_file">file</code></td>
<td>
<p>name of the file where the model is to be saved or read from.</p>
</td></tr>
<tr><td><code id="save_uwot_+3A_unload">unload</code></td>
<td>
<p>if <code>TRUE</code>, unload all nearest neighbor indexes for the
model. The <code>model</code> will no longer be valid for use in
<code><a href="#topic+umap_transform">umap_transform</a></code> and the temporary working directory used
during model saving will be deleted. You will need to reload the model with
<code>load_uwot</code> to use the model. If <code>FALSE</code>, then the model can be
re-used without reloading, but you must manually unload the NN index when
you are finished using it if you want to delete the temporary working
directory. To unload manually, use <code><a href="#topic+unload_uwot">unload_uwot</a></code>. The absolute
path of the working directory is found in the <code>mod_dir</code> item of the
return value.</p>
</td></tr>
<tr><td><code id="save_uwot_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, log information to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>model</code> with one extra item: <code>mod_dir</code>, which contains the
path to the working directory. If <code>unload = FALSE</code> then this directory
still exists after this function returns, and can be cleaned up with
<code><a href="#topic+unload_uwot">unload_uwot</a></code>. If you don't care about cleaning up this
directory, or <code>unload = TRUE</code>, then you can ignore the return value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_uwot">load_uwot</a></code>, <code><a href="#topic+unload_uwot">unload_uwot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris_train &lt;- iris[c(1:10, 51:60), ]
iris_test &lt;- iris[100:110, ]

# create model
model &lt;- umap(iris_train, ret_model = TRUE, n_epochs = 20)

# save without unloading: this leaves behind a temporary working directory
model_file &lt;- tempfile("iris_umap")
model &lt;- save_uwot(model, file = model_file)

# The model can continue to be used
test_embedding &lt;- umap_transform(iris_test, model)

# To manually unload the model from memory when finished and to clean up
# the working directory (this doesn't touch your model file)
unload_uwot(model)

# At this point, model cannot be used with umap_transform, this would fail:
# test_embedding2 &lt;- umap_transform(iris_test, model)

# restore the model: this also creates a temporary working directory
model2 &lt;- load_uwot(file = model_file)
test_embedding2 &lt;- umap_transform(iris_test, model2)

# Unload and clean up the loaded model temp directory
unload_uwot(model2)

# clean up the model file
unlink(model_file)

# save with unloading: this deletes the temporary working directory but
# doesn't allow the model to be re-used
model3 &lt;- umap(iris_train, ret_model = TRUE, n_epochs = 20)
model_file3 &lt;- tempfile("iris_umap")
model3 &lt;- save_uwot(model3, file = model_file3, unload = TRUE)

</code></pre>

<hr>
<h2 id='similarity_graph'>Similarity Graph</h2><span id='topic+similarity_graph'></span>

<h3>Description</h3>

<p>Create a graph (as a sparse symmetric weighted adjacency matrix) representing
the similarities between items in a data set. No dimensionality reduction is
carried out. By default, the similarities are calculated using the merged
fuzzy simplicial set approach in the Uniform Manifold Approximation and
Projection (UMAP) method (McInnes et al., 2018), but the approach from
LargeVis (Tang et al., 2016) can also be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity_graph(
  X = NULL,
  n_neighbors = NULL,
  metric = "euclidean",
  scale = NULL,
  set_op_mix_ratio = 1,
  local_connectivity = 1,
  nn_method = NULL,
  n_trees = 50,
  search_k = 2 * n_neighbors * n_trees,
  perplexity = 50,
  method = "umap",
  y = NULL,
  target_n_neighbors = n_neighbors,
  target_metric = "euclidean",
  target_weight = 0.5,
  pca = NULL,
  pca_center = TRUE,
  ret_extra = c(),
  n_threads = NULL,
  grain_size = 1,
  kernel = "gauss",
  tmpdir = tempdir(),
  verbose = getOption("verbose", TRUE),
  pca_method = NULL,
  binary_edge_weights = FALSE,
  nn_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarity_graph_+3A_x">X</code></td>
<td>
<p>Input data. Can be a <code><a href="base.html#topic+data.frame">data.frame</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code> object or <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.
Matrix and data frames should contain one observation per row. Data frames
will have any non-numeric columns removed, although factor columns will be
used if explicitly included via <code>metric</code> (see the help for
<code>metric</code> for details). A sparse matrix is interpreted as a distance
matrix, and is assumed to be symmetric, so you can also pass in an
explicitly upper or lower triangular sparse matrix to save storage. There
must be at least <code>n_neighbors</code> non-zero distances for each row. Both
implicit and explicit zero entries are ignored. Set zero distances you want
to keep to an arbitrarily small non-zero value (e.g. <code>1e-10</code>).
<code>X</code> can also be <code>NULL</code> if pre-computed nearest neighbor data is
passed to <code>nn_method</code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>The size of local neighborhood (in terms of number of
neighboring sample points) used for manifold approximation. Larger values
result in more global views of the manifold, while smaller values result in
more local data being preserved. In general values should be in the range
<code>2</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_metric">metric</code></td>
<td>
<p>Type of distance metric to use to find nearest neighbors. For
<code>nn_method = "annoy"</code> this can be one of:
</p>

<ul>
<li> <p><code>"euclidean"</code> (the default)
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"manhattan"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"correlation"</code> (a distance based on the Pearson correlation)
</p>
</li>
<li> <p><code>"categorical"</code> (see below)
</p>
</li></ul>

<p>For <code>nn_method = "hnsw"</code> this can be one of:
</p>

<ul>
<li> <p><code>"euclidean"</code>
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"correlation"</code>
</p>
</li></ul>

<p>If <a href="https://cran.r-project.org/package=rnndescent">rnndescent</a> is
installed and <code>nn_method = "nndescent"</code> is specified then many more
metrics are avaiable, including:
</p>

<ul>
<li> <p><code>"braycurtis"</code>
</p>
</li>
<li> <p><code>"canberra"</code>
</p>
</li>
<li> <p><code>"chebyshev"</code>
</p>
</li>
<li> <p><code>"dice"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"hellinger"</code>
</p>
</li>
<li> <p><code>"jaccard"</code>
</p>
</li>
<li> <p><code>"jensenshannon"</code>
</p>
</li>
<li> <p><code>"kulsinski"</code>
</p>
</li>
<li> <p><code>"rogerstanimoto"</code>
</p>
</li>
<li> <p><code>"russellrao"</code>
</p>
</li>
<li> <p><code>"sokalmichener"</code>
</p>
</li>
<li> <p><code>"sokalsneath"</code>
</p>
</li>
<li> <p><code>"spearmanr"</code>
</p>
</li>
<li> <p><code>"symmetrickl"</code>
</p>
</li>
<li> <p><code>"tsss"</code>
</p>
</li>
<li> <p><code>"yule"</code>
</p>
</li></ul>

<p>For more details see the package documentation of <code>rnndescent</code>.
For <code>nn_method = "fnn"</code>, the distance metric is always &quot;euclidean&quot;.
</p>
<p>If <code>X</code> is a data frame or matrix, then multiple metrics can be
specified, by passing a list to this argument, where the name of each item in
the list is one of the metric names above. The value of each list item should
be a vector giving the names or integer ids of the columns to be included in
a calculation, e.g. <code>metric = list(euclidean = 1:4, manhattan = 5:10)</code>.
</p>
<p>Each metric calculation results in a separate fuzzy simplicial set, which are
intersected together to produce the final set. Metric names can be repeated.
Because non-numeric columns are removed from the data frame, it is safer to
use column names than integer ids.
</p>
<p>Factor columns can also be used by specifying the metric name
<code>"categorical"</code>. Factor columns are treated different from numeric
columns and although multiple factor columns can be specified in a vector,
each factor column specified is processed individually. If you specify
a non-factor column, it will be coerced to a factor.
</p>
<p>For a given data block, you may override the <code>pca</code> and <code>pca_center</code>
arguments for that block, by providing a list with one unnamed item
containing the column names or ids, and then any of the <code>pca</code> or
<code>pca_center</code> overrides as named items, e.g. <code>metric =
list(euclidean = 1:4, manhattan = list(5:10, pca_center = FALSE))</code>. This
exists to allow mixed binary and real-valued data to be included and to have
PCA applied to both, but with centering applied only to the real-valued data
(it is typical not to apply centering to binary data before PCA is applied).</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_scale">scale</code></td>
<td>
<p>Scaling to apply to <code>X</code> if it is a data frame or matrix:
</p>

<ul>
<li><p><code>"none"</code> or <code>FALSE</code> or <code>NULL</code> No scaling.
</p>
</li>
<li><p><code>"Z"</code> or <code>"scale"</code> or <code>TRUE</code> Scale each column to
zero mean and variance 1.
</p>
</li>
<li><p><code>"maxabs"</code> Center each column to mean 0, then divide each
element by the maximum absolute value over the entire matrix.
</p>
</li>
<li><p><code>"range"</code> Range scale the entire matrix, so the smallest
element is 0 and the largest is 1.
</p>
</li>
<li><p><code>"colrange"</code> Scale each column in the range (0,1).
</p>
</li></ul>

<p>For <code>method</code> <code>"umap"</code>, the default is <code>"none"</code>. For
<code>"largevis"</code>, the default is <code>"maxabs"</code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_set_op_mix_ratio">set_op_mix_ratio</code></td>
<td>
<p>Interpolate between (fuzzy) union and intersection as
the set operation used to combine local fuzzy simplicial sets to obtain a
global fuzzy simplicial sets. Both fuzzy set operations use the product
t-norm. The value of this parameter should be between <code>0.0</code> and
<code>1.0</code>; a value of <code>1.0</code> will use a pure fuzzy union, while
<code>0.0</code> will use a pure fuzzy intersection. Ignored if
<code>method = "largevis"</code></p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_local_connectivity">local_connectivity</code></td>
<td>
<p>The local connectivity required &ndash; i.e. the number
of nearest neighbors that should be assumed to be connected at a local
level. The higher this value the more connected the manifold becomes
locally. In practice this should be not more than the local intrinsic
dimension of the manifold. Ignored if <code>method = "largevis"</code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_nn_method">nn_method</code></td>
<td>
<p>Method for finding nearest neighbors. Options are:
</p>

<ul>
<li> <p><code>"fnn"</code>. Use exact nearest neighbors via the
<a href="https://cran.r-project.org/package=FNN">FNN</a> package.
</p>
</li>
<li> <p><code>"annoy"</code> Use approximate nearest neighbors via the
<a href="https://cran.r-project.org/package=RcppAnnoy">RcppAnnoy</a> package.
</p>
</li>
<li> <p><code>"hnsw"</code> Use approximate nearest neighbors with the
Hierarchical Navigable Small World (HNSW) method (Malkov and Yashunin,
2018) via the
<a href="https://cran.r-project.org/package=RcppHNSW">RcppHNSW</a> package.
<code>RcppHNSW</code> is not a dependency of this package: this option is
only available if you have installed <code>RcppHNSW</code> yourself. Also,
HNSW only supports the following arguments for <code>metric</code> and
<code>target_metric</code>: <code>"euclidean"</code>, <code>"cosine"</code> and
<code>"correlation"</code>.
</p>
</li>
<li> <p><code>"nndescent"</code> Use approximate nearest neighbors with the
Nearest Neighbor Descent method (Dong et al., 2011) via the
<a href="https://cran.r-project.org/package=rnndescent">rnndescent</a>
package. <code>rnndescent</code> is not a dependency of this package: this
option is only available if you have installed <code>rnndescent</code>
yourself.
</p>
</li></ul>

<p>By default, if <code>X</code> has less than 4,096 vertices, the exact nearest
neighbors are found. Otherwise, approximate nearest neighbors are used.
You may also pass pre-calculated nearest neighbor data to this argument. It
must be one of two formats, either a list consisting of two elements:
</p>

<ul>
<li> <p><code>"idx"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the integer indexes of the nearest neighbors in <code>X</code>. Each
vertex is considered to be its own nearest neighbor, i.e.
<code>idx[, 1] == 1:n_vertices</code>.
</p>
</li>
<li> <p><code>"dist"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the distances of the nearest neighbors.
</p>
</li></ul>

<p>or a sparse distance matrix of type <code>dgCMatrix</code>, with dimensions
<code>n_vertices x n_vertices</code>. Distances should be arranged by column,
i.e. a non-zero entry in row <code>j</code> of the <code>i</code>th column indicates
that the <code>j</code>th observation in <code>X</code> is a nearest neighbor of the
<code>i</code>th observation with the distance given by the value of that
element.
The <code>n_neighbors</code> parameter is ignored when using precomputed
nearest neighbor data. If using the sparse distance matrix input, each
column can contain a different number of neighbors.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_n_trees">n_trees</code></td>
<td>
<p>Number of trees to build when constructing the nearest
neighbor index. The more trees specified, the larger the index, but the
better the results. With <code>search_k</code>, determines the accuracy of the
Annoy nearest neighbor search. Only used if the <code>nn_method</code> is
<code>"annoy"</code>. Sensible values are between <code>10</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_search_k">search_k</code></td>
<td>
<p>Number of nodes to search during the neighbor retrieval. The
larger k, the more the accurate results, but the longer the search takes.
With <code>n_trees</code>, determines the accuracy of the Annoy nearest neighbor
search. Only used if the <code>nn_method</code> is <code>"annoy"</code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_perplexity">perplexity</code></td>
<td>
<p>Used only if <code>method = "largevis"</code>. Controls the size
of the local neighborhood used for manifold approximation. Should be a
value between 1 and one less than the number of items in <code>X</code>. If
specified, you should <em>not</em> specify a value for <code>n_neighbors</code>
unless you know what you are doing.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_method">method</code></td>
<td>
<p>How to generate the similarities between items. One of:
</p>

<ul>
<li> <p><code>"umap"</code> The UMAP method of McInnes et al. (2018).
</p>
</li>
<li> <p><code>"largevis"</code> The LargeVis method of Tang et al. (2016).
</p>
</li></ul>
</td></tr>
<tr><td><code id="similarity_graph_+3A_y">y</code></td>
<td>
<p>Optional target data to add supervised or semi-supervised weighting
to the similarity graph . Can be a vector, matrix or data frame. Use the
<code>target_metric</code> parameter to specify the metrics to use, using the
same syntax as <code>metric</code>. Usually either a single numeric or factor
column is used, but more complex formats are possible. The following types
are allowed:
</p>

<ul>
<li><p> Factor columns with the same length as <code>X</code>. <code>NA</code> is
allowed for any observation with an unknown level, in which case
UMAP operates as a form of semi-supervised learning. Each column is
treated separately.
</p>
</li>
<li><p> Numeric data. <code>NA</code> is <em>not</em> allowed in this case. Use the
parameter <code>target_n_neighbors</code> to set the number of neighbors used
with <code>y</code>. If unset, <code>n_neighbors</code> is used. Unlike factors,
numeric columns are grouped into one block unless <code>target_metric</code>
specifies otherwise. For example, if you wish columns <code>a</code> and
<code>b</code> to be treated separately, specify
<code>target_metric = list(euclidean = "a", euclidean = "b")</code>. Otherwise,
the data will be effectively treated as a matrix with two columns.
</p>
</li>
<li><p> Nearest neighbor data, consisting of a list of two matrices,
<code>idx</code> and <code>dist</code>. These represent the precalculated nearest
neighbor indices and distances, respectively. This
is the same format as that expected for precalculated data in
<code>nn_method</code>. This format assumes that the underlying data was a
numeric vector. Any user-supplied value of the <code>target_n_neighbors</code>
parameter is ignored in this case, because the the number of columns in
the matrices is used for the value. Multiple nearest neighbor data using
different metrics can be supplied by passing a list of these lists.
</p>
</li></ul>

<p>Unlike <code>X</code>, all factor columns included in <code>y</code> are automatically
used. This parameter is ignored if <code>method = "largevis"</code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_target_n_neighbors">target_n_neighbors</code></td>
<td>
<p>Number of nearest neighbors to use to construct the
target simplicial set. Default value is <code>n_neighbors</code>. Applies only if
<code>y</code> is non-<code>NULL</code> and <code>numeric</code>.  This parameter is ignored
if <code>method = "largevis"</code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_target_metric">target_metric</code></td>
<td>
<p>The metric used to measure distance for <code>y</code> if
using supervised dimension reduction. Used only if <code>y</code> is numeric.
This parameter is ignored if <code>method = "largevis"</code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_target_weight">target_weight</code></td>
<td>
<p>Weighting factor between data topology and target
topology. A value of 0.0 weights entirely on data, a value of 1.0 weights
entirely on target. The default of 0.5 balances the weighting equally
between data and target. Only applies if <code>y</code> is non-<code>NULL</code>. This
parameter is ignored if <code>method = "largevis"</code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_pca">pca</code></td>
<td>
<p>If set to a positive integer value, reduce data to this number of
columns using PCA. Doesn't applied if the distance <code>metric</code> is
<code>"hamming"</code>, or the dimensions of the data is larger than the
number specified (i.e. number of rows and columns must be larger than the
value of this parameter). If you have &gt; 100 columns in a data frame or
matrix, reducing the number of columns in this way may substantially
increase the performance of the nearest neighbor search at the cost of a
potential decrease in accuracy. In many t-SNE applications, a value of 50
is recommended, although there's no guarantee that this is appropriate for
all settings.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_pca_center">pca_center</code></td>
<td>
<p>If <code>TRUE</code>, center the columns of <code>X</code> before
carrying out PCA. For binary data, it's recommended to set this to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_ret_extra">ret_extra</code></td>
<td>
<p>A vector indicating what extra data to return. May contain
any combination of the following strings:
</p>

<ul>
<li> <p><code>"nn"</code> nearest neighbor data that can be used as input to
<code>nn_method</code> to avoid the overhead of repeatedly calculating the
nearest neighbors when manipulating unrelated parameters. See the
&quot;Value&quot; section for the names of the list items. Note that the nearest
neighbors could be sensitive to data scaling, so be wary of reusing
nearest neighbor data if modifying the <code>scale</code> parameter.
</p>
</li>
<li> <p><code>"sigma"</code> the normalization value for each observation in the
dataset when constructing the smoothed distances to each of its
neighbors. This gives some sense of the local density of each
observation in the high dimensional space: higher values of
<code>sigma</code> indicate a higher dispersion or lower density.
</p>
</li></ul>
</td></tr>
<tr><td><code id="similarity_graph_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use. Default is half the number of
concurrent threads supported by the system. For nearest neighbor search,
only applies if <code>nn_method = "annoy"</code>. If <code>n_threads &gt; 1</code>, then
the Annoy index will be temporarily written to disk in the location
determined by <code><a href="base.html#topic+tempfile">tempfile</a></code>.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_grain_size">grain_size</code></td>
<td>
<p>The minimum amount of work to do on each thread. If this
value is set high enough, then less than <code>n_threads</code> will be used for
processing, which might give a performance improvement if the overhead of
thread management and context switching was outweighing the improvement due
to concurrent processing. This should be left at default (<code>1</code>) and
work will be spread evenly over all the threads specified.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_kernel">kernel</code></td>
<td>
<p>Used only if <code>method = "largevis"</code>. Type of kernel
function to create input similiarties. Can be one of <code>"gauss"</code> (the
default) or <code>"knn"</code>. <code>"gauss"</code> uses the usual Gaussian weighted
similarities. <code>"knn"</code> assigns equal similiarties. to every edge in the
nearest neighbor graph, and zero otherwise, using <code>perplexity</code> nearest
neighbors. The <code>n_neighbors</code> parameter is ignored in this case.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_tmpdir">tmpdir</code></td>
<td>
<p>Temporary directory to store nearest neighbor indexes during
nearest neighbor search. Default is <code><a href="base.html#topic+tempdir">tempdir</a></code>. The index is
only written to disk if <code>n_threads &gt; 1</code> and
<code>nn_method = "annoy"</code>; otherwise, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, log details to the console.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_pca_method">pca_method</code></td>
<td>
<p>Method to carry out any PCA dimensionality reduction when
the <code>pca</code> parameter is specified. Allowed values are:
</p>

<ul>
<li><p><code>"irlba"</code>. Uses <code><a href="irlba.html#topic+prcomp_irlba">prcomp_irlba</a></code> from the
<a href="https://cran.r-project.org/package=irlba">irlba</a> package.
</p>
</li>
<li><p><code>"rsvd"</code>. Uses 5 iterations of <code><a href="irlba.html#topic+svdr">svdr</a></code> from
the <a href="https://cran.r-project.org/package=irlba">irlba</a> package.
This is likely to give much faster but potentially less accurate results
than using <code>"irlba"</code>. For the purposes of nearest neighbor
calculation and coordinates initialization, any loss of accuracy doesn't
seem to matter much.
</p>
</li>
<li><p><code>"bigstatsr"</code>. Uses <code><a href="bigstatsr.html#topic+big_randomSVD">big_randomSVD</a></code>
from the <a href="https://cran.r-project.org/package=bigstatsr">bigstatsr</a>
package. The SVD methods used in <code>bigstatsr</code> may be faster on
systems without access to efficient linear algebra libraries (e.g.
Windows). <strong>Note</strong>: <code>bigstatsr</code> is <em>not</em> a dependency of
uwot: if you choose to use this package for PCA, you <em>must</em> install
it yourself.
</p>
</li>
<li><p><code>"svd"</code>. Uses <code><a href="base.html#topic+svd">svd</a></code> for the SVD. This is
likely to be slow for all but the smallest datasets.
</p>
</li>
<li><p><code>"auto"</code> (the default). Uses <code>"irlba"</code>, unless more than
50
case <code>"svd"</code> is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="similarity_graph_+3A_binary_edge_weights">binary_edge_weights</code></td>
<td>
<p>If <code>TRUE</code> then edge weights of the returned
graph are binary (0/1) rather than reflecting the degree of similarity.</p>
</td></tr>
<tr><td><code id="similarity_graph_+3A_nn_args">nn_args</code></td>
<td>
<p>A list containing additional arguments to pass to the nearest
neighbor method. For <code>nn_method = "annoy"</code>, you can specify
<code>"n_trees"</code> and <code>"search_k"</code>, and these will override the
<code>n_trees</code> and <code>search_k</code> parameters.
For <code>nn_method = "hnsw"</code>, you may specify the following arguments:
</p>

<ul>
<li> <p><code>M</code> The maximum number of neighbors to keep for each vertex.
Reasonable values are <code>2</code> to <code>100</code>. Higher values give better
recall at the cost of more memory. Default value is <code>16</code>.
</p>
</li>
<li> <p><code>ef_construction</code> A positive integer specifying the size of
the dynamic list used during index construction. A higher value will
provide better results at the cost of a longer time to build the index.
Default is <code>200</code>.
</p>
</li>
<li> <p><code>ef</code> A positive integer specifying the size of the dynamic
list used during search. This cannot be smaller than <code>n_neighbors</code>
and cannot be higher than the number of items in the index. Default is
<code>10</code>.
</p>
</li></ul>

<p>For <code>nn_method = "nndescent"</code>, you may specify the following
arguments:
</p>

<ul>
<li> <p><code>n_trees</code> The number of trees to use in a random projection
forest to initialize the search. A larger number will give more accurate
results at the cost of a longer computation time. The default of
<code>NULL</code> means that the number is chosen based on the number of
observations in <code>X</code>.
</p>
</li>
<li> <p><code>max_candidates</code> The number of potential neighbors to explore
per iteration. By default, this is set to <code>n_neighbors</code> or <code>60</code>,
whichever is smaller. A larger number will give more accurate results at
the cost of a longer computation time.
</p>
</li>
<li> <p><code>n_iters</code> The number of iterations to run the search. A larger
number will give more accurate results at the cost of a longer computation
time. By default, this will be chosen based on the number of observations
in <code>X</code>. You may also need to modify the convergence criterion
<code>delta</code>.
</p>
</li>
<li> <p><code>delta</code> The minimum relative change in the neighbor graph
allowed before early stopping. Should be a value between 0 and 1. The
smaller the value, the smaller the amount of progress between iterations is
allowed. Default value of <code>0.001</code> means that at least 0.1
neighbor graph must be updated at each iteration.
</p>
</li>
<li> <p><code>init</code> How to initialize the nearest neighbor descent. By
default this is set to <code>"tree"</code> and uses a random project forest.
If you set this to <code>"rand"</code>, then a random selection is used. Usually
this is less accurate than using RP trees, but for high-dimensional cases,
there may be little difference in the quality of the initialization and
random initialization will be a lot faster. If you set this to
<code>"rand"</code>, then the <code>n_trees</code> parameter is ignored.
</p>
</li>
<li> <p><code>pruning_degree_multiplier</code> The maximum number of edges per node
to retain in the search graph, relative to <code>n_neighbors</code>. A larger
value will give more accurate results at the cost of a longer computation
time. Default is <code>1.5</code>. This parameter only affects neighbor search
when transforming new data with <code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li>
<li> <p><code>epsilon</code> Controls the degree of the back-tracking when
traversing the search graph. Setting this to <code>0.0</code> will do a greedy
search with no back-tracking. A larger value will give more accurate
results at the cost of a longer computation time. Default is <code>0.1</code>.
This parameter only affects neighbor search when transforming new data with
<code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li>
<li> <p><code>max_search_fraction</code> Specifies the maximum fraction of the
search graph to traverse. By default, this is set to <code>1.0</code>, so the
entire graph (i.e. all items in <code>X</code>) may be visited. You may want to
set this to a smaller value if you have a very large dataset (in
conjunction with <code>epsilon</code>) to avoid an inefficient exhaustive search
of the data in <code>X</code>. This parameter only affects neighbor search when
transforming new data with <code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This is equivalent to running <code><a href="#topic+umap">umap</a></code> with the
<code>ret_extra = c("fgraph")</code> parameter, but without the overhead of
calculating (or returning) the optimized low-dimensional coordinates.
</p>


<h3>Value</h3>

<p>A sparse symmetrized matrix of the similarities between the items in
<code>X</code> or if <code>nn_method</code> contains pre-computed nearest neighbor
data, the items in <code>nn_method</code>. Because of the symmetrization, there
may be more non-zero items in each column than the specified value of
<code>n_neighbors</code> (or pre-computed neighbors in <code>nn_method</code>).
If <code>ret_extra</code> is specified then the return value will be a list
containing:
</p>

<ul>
<li> <p><code>similarity_graph</code> the similarity graph as a sparse matrix
as described above.
</p>
</li>
<li> <p><code>nn</code> (if <code>ret_extra</code> contained <code>"nn"</code>) the nearest
neighbor data as a list called <code>nn</code>. This contains one list for each
<code>metric</code> calculated, itself containing a matrix <code>idx</code> with the
integer ids of the neighbors; and a matrix <code>dist</code> with the
distances. The <code>nn</code> list (or a sub-list) can be used as input to the
<code>nn_method</code> parameter.
</p>
</li>
<li> <p><code>sigma</code> (if <code>ret_extra</code> contains <code>"sigma"</code>),
a vector of calibrated parameters, one for each item in the input data,
reflecting the local data density for that item. The exact definition of
the values depends on the choice of the <code>method</code> parameter.
</p>
</li>
<li> <p><code>rho</code> (if <code>ret_extra</code> contains <code>"sigma"</code>), a
vector containing the largest distance to the locally connected neighbors
of each item in the input data. This will exist only if
<code>method = "umap"</code>.
</p>
</li>
<li> <p><code>localr</code> (if <code>ret_extra</code> contains <code>"localr"</code>) a
vector of the estimated local radii, the sum of <code>"sigma"</code> and
<code>"rho"</code>. This will exist only if <code>method = "umap"</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Dong, W., Moses, C., &amp; Li, K. (2011, March).
Efficient k-nearest neighbor graph construction for generic similarity measures.
In <em>Proceedings of the 20th international conference on World Wide Web</em>
(pp. 577-586).
ACM.
<a href="https://doi.org/10.1145/1963405.1963487">doi:10.1145/1963405.1963487</a>.
</p>
<p>Malkov, Y. A., &amp; Yashunin, D. A. (2018).
Efficient and robust approximate nearest neighbor search using hierarchical
navigable small world graphs.
<em>IEEE transactions on pattern analysis and machine intelligence</em>, <em>42</em>(4), 824-836.
</p>
<p>McInnes, L., Healy, J., &amp; Melville, J. (2018).
UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction
<em>arXiv preprint</em> <em>arXiv</em>:1802.03426.
<a href="https://arxiv.org/abs/1802.03426">https://arxiv.org/abs/1802.03426</a>
</p>
<p>Tang, J., Liu, J., Zhang, M., &amp; Mei, Q. (2016, April).
Visualizing large-scale and high-dimensional data.
In <em>Proceedings of the 25th International Conference on World Wide Web</em>
(pp. 287-297).
International World Wide Web Conferences Steering Committee.
<a href="https://arxiv.org/abs/1602.00370">https://arxiv.org/abs/1602.00370</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris30 &lt;- iris[c(1:10, 51:60, 101:110), ]

# return a 30 x 30 sparse matrix with similarity data based on 10 nearest
# neighbors per item
iris30_sim_graph &lt;- similarity_graph(iris30, n_neighbors = 10)

# Default is to use the UMAP method of calculating similarities, but LargeVis
# is also available: for that method, use perplexity instead of n_neighbors
# to control neighborhood size. Use ret_extra = "nn" to return nearest
# neighbor data as well as the similarity graph. Return value is a list
# containing similarity_graph' and 'nn' items.
iris30_lv_graph &lt;- similarity_graph(iris30,
  perplexity = 10,
  method = "largevis", ret_extra = "nn"
)
# If you have the neighbor information you don't need the original data
iris30_lv_graph_nn &lt;- similarity_graph(
  nn_method = iris30_lv_graph$nn,
  perplexity = 10, method = "largevis"
)
all(iris30_lv_graph_nn == iris30_lv_graph$similarity_graph)

</code></pre>

<hr>
<h2 id='simplicial_set_intersect'>Merge Similarity Graph by Simplicial Set Intersection</h2><span id='topic+simplicial_set_intersect'></span>

<h3>Description</h3>

<p>Combine two similarity graphs by treating them as fuzzy topological sets and
forming the intersection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplicial_set_intersect(x, y, weight = 0.5, n_threads = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplicial_set_intersect_+3A_x">x</code></td>
<td>
<p>A sparse matrix representing the first similarity graph in the
intersection operation.</p>
</td></tr>
<tr><td><code id="simplicial_set_intersect_+3A_y">y</code></td>
<td>
<p>A sparse matrix representing the second similarity graph in the
intersection operation.</p>
</td></tr>
<tr><td><code id="simplicial_set_intersect_+3A_weight">weight</code></td>
<td>
<p>A value between <code>0 - 1</code>, controlling the relative
influence of <code>x</code> and <code>y</code> in the intersection. Default
(<code>0.5</code>) gives equal influence. Values smaller than <code>0.5</code> put more
weight on <code>x</code>. Values greater than <code>0.5</code> put more weight on
<code>y</code>.</p>
</td></tr>
<tr><td><code id="simplicial_set_intersect_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use when resetting the local metric.
Default is half the number of concurrent threads supported by the system.</p>
</td></tr>
<tr><td><code id="simplicial_set_intersect_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, log progress to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix containing the intersection of <code>x</code> and
<code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Form two different "views" of the same data
iris30 &lt;- iris[c(1:10, 51:60, 101:110), ]
iris_sg12 &lt;- similarity_graph(iris30[, 1:2], n_neighbors = 5)
iris_sg34 &lt;- similarity_graph(iris30[, 3:4], n_neighbors = 5)

# Combine the two representations into one
iris_combined &lt;- simplicial_set_intersect(iris_sg12, iris_sg34)

# Optimize the layout based on the combined view
iris_combined_umap &lt;- optimize_graph_layout(iris_combined, n_epochs = 100)
</code></pre>

<hr>
<h2 id='simplicial_set_union'>Merge Similarity Graph by Simplicial Set Union</h2><span id='topic+simplicial_set_union'></span>

<h3>Description</h3>

<p>Combine two similarity graphs by treating them as fuzzy topological sets and
forming the union.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplicial_set_union(x, y, n_threads = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplicial_set_union_+3A_x">x</code></td>
<td>
<p>A sparse matrix representing the first similarity graph in the union
operation.</p>
</td></tr>
<tr><td><code id="simplicial_set_union_+3A_y">y</code></td>
<td>
<p>A sparse matrix representing the second similarity graph in the
union operation.</p>
</td></tr>
<tr><td><code id="simplicial_set_union_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use when resetting the local metric.
Default is half the number of concurrent threads supported by the system.</p>
</td></tr>
<tr><td><code id="simplicial_set_union_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, log progress to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix containing the union of <code>x</code> and <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Form two different "views" of the same data
iris30 &lt;- iris[c(1:10, 51:60, 101:110), ]
iris_sg12 &lt;- similarity_graph(iris30[, 1:2], n_neighbors = 5)
iris_sg34 &lt;- similarity_graph(iris30[, 3:4], n_neighbors = 5)

# Combine the two representations into one
iris_combined &lt;- simplicial_set_union(iris_sg12, iris_sg34)

# Optimize the layout based on the combined view
iris_combined_umap &lt;- optimize_graph_layout(iris_combined, n_epochs = 100)
</code></pre>

<hr>
<h2 id='tumap'>Dimensionality Reduction Using t-Distributed UMAP (t-UMAP)</h2><span id='topic+tumap'></span>

<h3>Description</h3>

<p>A faster (but less flexible) version of the UMAP (McInnes et al, 2018)
gradient. For more detail on UMAP, see the <code><a href="#topic+umap">umap</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tumap(
  X,
  n_neighbors = 15,
  n_components = 2,
  metric = "euclidean",
  n_epochs = NULL,
  learning_rate = 1,
  scale = FALSE,
  init = "spectral",
  init_sdev = NULL,
  set_op_mix_ratio = 1,
  local_connectivity = 1,
  bandwidth = 1,
  repulsion_strength = 1,
  negative_sample_rate = 5,
  nn_method = NULL,
  n_trees = 50,
  search_k = 2 * n_neighbors * n_trees,
  n_threads = NULL,
  n_sgd_threads = 0,
  grain_size = 1,
  y = NULL,
  target_n_neighbors = n_neighbors,
  target_metric = "euclidean",
  target_weight = 0.5,
  pca = NULL,
  pca_center = TRUE,
  pcg_rand = TRUE,
  fast_sgd = FALSE,
  ret_model = FALSE,
  ret_nn = FALSE,
  ret_extra = c(),
  tmpdir = tempdir(),
  verbose = getOption("verbose", TRUE),
  batch = FALSE,
  opt_args = NULL,
  epoch_callback = NULL,
  pca_method = NULL,
  binary_edge_weights = FALSE,
  seed = NULL,
  nn_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tumap_+3A_x">X</code></td>
<td>
<p>Input data. Can be a <code><a href="base.html#topic+data.frame">data.frame</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code> object or <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.
Matrix and data frames should contain one observation per row. Data frames
will have any non-numeric columns removed, although factor columns will be
used if explicitly included via <code>metric</code> (see the help for
<code>metric</code> for details). A sparse matrix is interpreted as a distance
matrix, and is assumed to be symmetric, so you can also pass in an
explicitly upper or lower triangular sparse matrix to save storage. There
must be at least <code>n_neighbors</code> non-zero distances for each row. Both
implicit and explicit zero entries are ignored. Set zero distances you want
to keep to an arbitrarily small non-zero value (e.g. <code>1e-10</code>).
<code>X</code> can also be <code>NULL</code> if pre-computed nearest neighbor data is
passed to <code>nn_method</code>, and <code>init</code> is not <code>"spca"</code> or
<code>"pca"</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>The size of local neighborhood (in terms of number of
neighboring sample points) used for manifold approximation. Larger values
result in more global views of the manifold, while smaller values result in
more local data being preserved. In general values should be in the range
<code>2</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_n_components">n_components</code></td>
<td>
<p>The dimension of the space to embed into. This defaults
to <code>2</code> to provide easy visualization, but can reasonably be set to any
integer value in the range <code>2</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_metric">metric</code></td>
<td>
<p>Type of distance metric to use to find nearest neighbors. For
<code>nn_method = "annoy"</code> this can be one of:
</p>

<ul>
<li> <p><code>"euclidean"</code> (the default)
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"manhattan"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"correlation"</code> (a distance based on the Pearson correlation)
</p>
</li>
<li> <p><code>"categorical"</code> (see below)
</p>
</li></ul>

<p>For <code>nn_method = "hnsw"</code> this can be one of:
</p>

<ul>
<li> <p><code>"euclidean"</code>
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"correlation"</code>
</p>
</li></ul>

<p>If <a href="https://cran.r-project.org/package=rnndescent">rnndescent</a> is
installed and <code>nn_method = "nndescent"</code> is specified then many more
metrics are avaiable, including:
</p>

<ul>
<li> <p><code>"braycurtis"</code>
</p>
</li>
<li> <p><code>"canberra"</code>
</p>
</li>
<li> <p><code>"chebyshev"</code>
</p>
</li>
<li> <p><code>"dice"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"hellinger"</code>
</p>
</li>
<li> <p><code>"jaccard"</code>
</p>
</li>
<li> <p><code>"jensenshannon"</code>
</p>
</li>
<li> <p><code>"kulsinski"</code>
</p>
</li>
<li> <p><code>"rogerstanimoto"</code>
</p>
</li>
<li> <p><code>"russellrao"</code>
</p>
</li>
<li> <p><code>"sokalmichener"</code>
</p>
</li>
<li> <p><code>"sokalsneath"</code>
</p>
</li>
<li> <p><code>"spearmanr"</code>
</p>
</li>
<li> <p><code>"symmetrickl"</code>
</p>
</li>
<li> <p><code>"tsss"</code>
</p>
</li>
<li> <p><code>"yule"</code>
</p>
</li></ul>

<p>For more details see the package documentation of <code>rnndescent</code>.
For <code>nn_method = "fnn"</code>, the distance metric is always &quot;euclidean&quot;.
</p>
<p>If <code>X</code> is a data frame or matrix, then multiple metrics can be
specified, by passing a list to this argument, where the name of each item in
the list is one of the metric names above. The value of each list item should
be a vector giving the names or integer ids of the columns to be included in
a calculation, e.g. <code>metric = list(euclidean = 1:4, manhattan = 5:10)</code>.
</p>
<p>Each metric calculation results in a separate fuzzy simplicial set, which are
intersected together to produce the final set. Metric names can be repeated.
Because non-numeric columns are removed from the data frame, it is safer to
use column names than integer ids.
</p>
<p>Factor columns can also be used by specifying the metric name
<code>"categorical"</code>. Factor columns are treated different from numeric
columns and although multiple factor columns can be specified in a vector,
each factor column specified is processed individually. If you specify
a non-factor column, it will be coerced to a factor.
</p>
<p>For a given data block, you may override the <code>pca</code> and <code>pca_center</code>
arguments for that block, by providing a list with one unnamed item
containing the column names or ids, and then any of the <code>pca</code> or
<code>pca_center</code> overrides as named items, e.g. <code>metric =
list(euclidean = 1:4, manhattan = list(5:10, pca_center = FALSE))</code>. This
exists to allow mixed binary and real-valued data to be included and to have
PCA applied to both, but with centering applied only to the real-valued data
(it is typical not to apply centering to binary data before PCA is applied).</p>
</td></tr>
<tr><td><code id="tumap_+3A_n_epochs">n_epochs</code></td>
<td>
<p>Number of epochs to use during the optimization of the
embedded coordinates. By default, this value is set to <code>500</code> for
datasets containing 10,000 vertices or less, and <code>200</code> otherwise.
If <code>n_epochs = 0</code>, then coordinates determined by <code>"init"</code> will
be returned.</p>
</td></tr>
<tr><td><code id="tumap_+3A_learning_rate">learning_rate</code></td>
<td>
<p>Initial learning rate used in optimization of the
coordinates.</p>
</td></tr>
<tr><td><code id="tumap_+3A_scale">scale</code></td>
<td>
<p>Scaling to apply to <code>X</code> if it is a data frame or matrix:
</p>

<ul>
<li><p><code>"none"</code> or <code>FALSE</code> or <code>NULL</code> No scaling.
</p>
</li>
<li><p><code>"Z"</code> or <code>"scale"</code> or <code>TRUE</code> Scale each column to
zero mean and variance 1.
</p>
</li>
<li><p><code>"maxabs"</code> Center each column to mean 0, then divide each
element by the maximum absolute value over the entire matrix.
</p>
</li>
<li><p><code>"range"</code> Range scale the entire matrix, so the smallest
element is 0 and the largest is 1.
</p>
</li>
<li><p><code>"colrange"</code> Scale each column in the range (0,1).
</p>
</li></ul>

<p>For t-UMAP, the default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_init">init</code></td>
<td>
<p>Type of initialization for the coordinates. Options are:
</p>

<ul>
<li> <p><code>"spectral"</code> Spectral embedding using the normalized Laplacian
of the fuzzy 1-skeleton, with Gaussian noise added.
</p>
</li>
<li> <p><code>"normlaplacian"</code>. Spectral embedding using the normalized
Laplacian of the fuzzy 1-skeleton, without noise.
</p>
</li>
<li> <p><code>"random"</code>. Coordinates assigned using a uniform random
distribution between -10 and 10.
</p>
</li>
<li> <p><code>"lvrandom"</code>. Coordinates assigned using a Gaussian
distribution with standard deviation 1e-4, as used in LargeVis
(Tang et al., 2016) and t-SNE.
</p>
</li>
<li> <p><code>"laplacian"</code>. Spectral embedding using the Laplacian Eigenmap
(Belkin and Niyogi, 2002).
</p>
</li>
<li> <p><code>"pca"</code>. The first two principal components from PCA of
<code>X</code> if <code>X</code> is a data frame, and from a 2-dimensional classical
MDS if <code>X</code> is of class <code>"dist"</code>.
</p>
</li>
<li> <p><code>"spca"</code>. Like <code>"pca"</code>, but each dimension is then scaled
so the standard deviation is 1e-4, to give a distribution similar to that
used in t-SNE. This is an alias for <code>init = "pca", init_sdev =
   1e-4</code>.
</p>
</li>
<li> <p><code>"agspectral"</code> An &quot;approximate global&quot; modification of
<code>"spectral"</code> which all edges in the graph to a value of 1, and then
sets a random number of edges (<code>negative_sample_rate</code> edges per
vertex) to 0.1, to approximate the effect of non-local affinities.
</p>
</li>
<li><p> A matrix of initial coordinates.
</p>
</li></ul>

<p>For spectral initializations, (<code>"spectral"</code>, <code>"normlaplacian"</code>,
<code>"laplacian"</code>, <code>"agspectral"</code>), if more than one connected
component is identified, no spectral initialization is attempted. Instead
a PCA-based initialization is attempted. If <code>verbose = TRUE</code> the
number of connected components are logged to the console. The existence of
multiple connected components implies that a global view of the data cannot
be attained with this initialization. Increasing the value of
<code>n_neighbors</code> may help.</p>
</td></tr>
<tr><td><code id="tumap_+3A_init_sdev">init_sdev</code></td>
<td>
<p>If non-<code>NULL</code>, scales each dimension of the initialized
coordinates (including any user-supplied matrix) to this standard
deviation. By default no scaling is carried out, except when <code>init =
"spca"</code>, in which case the value is <code>0.0001</code>. Scaling the input may
help if the unscaled versions result in initial coordinates with large
inter-point distances or outliers. This usually results in small gradients
during optimization and very little progress being made to the layout.
Shrinking the initial embedding by rescaling can help under these
circumstances. Scaling the result of <code>init = "pca"</code> is usually
recommended and <code>init = "spca"</code> as an alias for <code>init = "pca",
init_sdev = 1e-4</code> but for the spectral initializations the scaled versions
usually aren't necessary unless you are using a large value of
<code>n_neighbors</code> (e.g. <code>n_neighbors = 150</code> or higher). For
compatibility with recent versions of the Python UMAP package, if you are
using <code>init = "spectral"</code>, then you should also set
<code>init_sdev = "range"</code>, which will range scale each of the columns
containing the initial data between 0-10. This is not set by default to
maintain backwards compatibility with previous versions of uwot.</p>
</td></tr>
<tr><td><code id="tumap_+3A_set_op_mix_ratio">set_op_mix_ratio</code></td>
<td>
<p>Interpolate between (fuzzy) union and intersection as
the set operation used to combine local fuzzy simplicial sets to obtain a
global fuzzy simplicial sets. Both fuzzy set operations use the product
t-norm. The value of this parameter should be between <code>0.0</code> and
<code>1.0</code>; a value of <code>1.0</code> will use a pure fuzzy union, while
<code>0.0</code> will use a pure fuzzy intersection.</p>
</td></tr>
<tr><td><code id="tumap_+3A_local_connectivity">local_connectivity</code></td>
<td>
<p>The local connectivity required &ndash; i.e. the number
of nearest neighbors that should be assumed to be connected at a local
level. The higher this value the more connected the manifold becomes
locally. In practice this should be not more than the local intrinsic
dimension of the manifold.</p>
</td></tr>
<tr><td><code id="tumap_+3A_bandwidth">bandwidth</code></td>
<td>
<p>The effective bandwidth of the kernel if we view the
algorithm as similar to Laplacian Eigenmaps. Larger values induce more
connectivity and a more global view of the data, smaller values concentrate
more locally.</p>
</td></tr>
<tr><td><code id="tumap_+3A_repulsion_strength">repulsion_strength</code></td>
<td>
<p>Weighting applied to negative samples in low
dimensional embedding optimization. Values higher than one will result in
greater weight being given to negative samples.</p>
</td></tr>
<tr><td><code id="tumap_+3A_negative_sample_rate">negative_sample_rate</code></td>
<td>
<p>The number of negative edge/1-simplex samples to
use per positive edge/1-simplex sample in optimizing the low dimensional
embedding.</p>
</td></tr>
<tr><td><code id="tumap_+3A_nn_method">nn_method</code></td>
<td>
<p>Method for finding nearest neighbors. Options are:
</p>

<ul>
<li> <p><code>"fnn"</code>. Use exact nearest neighbors via the
<a href="https://cran.r-project.org/package=FNN">FNN</a> package.
</p>
</li>
<li> <p><code>"annoy"</code> Use approximate nearest neighbors via the
<a href="https://cran.r-project.org/package=RcppAnnoy">RcppAnnoy</a> package.
</p>
</li>
<li> <p><code>"hnsw"</code> Use approximate nearest neighbors with the
Hierarchical Navigable Small World (HNSW) method (Malkov and Yashunin,
2018) via the
<a href="https://cran.r-project.org/package=RcppHNSW">RcppHNSW</a> package.
<code>RcppHNSW</code> is not a dependency of this package: this option is
only available if you have installed <code>RcppHNSW</code> yourself. Also,
HNSW only supports the following arguments for <code>metric</code> and
<code>target_metric</code>: <code>"euclidean"</code>, <code>"cosine"</code> and
<code>"correlation"</code>.
</p>
</li>
<li> <p><code>"nndescent"</code> Use approximate nearest neighbors with the
Nearest Neighbor Descent method (Dong et al., 2011) via the
<a href="https://cran.r-project.org/package=rnndescent">rnndescent</a>
package. <code>rnndescent</code> is not a dependency of this package: this
option is only available if you have installed <code>rnndescent</code>
yourself.
</p>
</li></ul>

<p>By default, if <code>X</code> has less than 4,096 vertices, the exact nearest
neighbors are found. Otherwise, approximate nearest neighbors are used.
You may also pass pre-calculated nearest neighbor data to this argument. It
must be one of two formats, either a list consisting of two elements:
</p>

<ul>
<li> <p><code>"idx"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the integer indexes of the nearest neighbors in <code>X</code>. Each
vertex is considered to be its own nearest neighbor, i.e.
<code>idx[, 1] == 1:n_vertices</code>.
</p>
</li>
<li> <p><code>"dist"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the distances of the nearest neighbors.
</p>
</li></ul>

<p>or a sparse distance matrix of type <code>dgCMatrix</code>, with dimensions
<code>n_vertices x n_vertices</code>. Distances should be arranged by column,
i.e. a non-zero entry in row <code>j</code> of the <code>i</code>th column indicates
that the <code>j</code>th observation in <code>X</code> is a nearest neighbor of the
<code>i</code>th observation with the distance given by the value of that
element.
The <code>n_neighbors</code> parameter is ignored when using precomputed
nearest neighbor data. If using the sparse distance matrix input, each
column can contain a different number of neighbors.</p>
</td></tr>
<tr><td><code id="tumap_+3A_n_trees">n_trees</code></td>
<td>
<p>Number of trees to build when constructing the nearest
neighbor index. The more trees specified, the larger the index, but the
better the results. With <code>search_k</code>, determines the accuracy of the
Annoy nearest neighbor search. Only used if the <code>nn_method</code> is
<code>"annoy"</code>. Sensible values are between <code>10</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_search_k">search_k</code></td>
<td>
<p>Number of nodes to search during the neighbor retrieval. The
larger k, the more the accurate results, but the longer the search takes.
With <code>n_trees</code>, determines the accuracy of the Annoy nearest neighbor
search. Only used if the <code>nn_method</code> is <code>"annoy"</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use (except during stochastic gradient
descent). Default is half the number of concurrent threads supported by the
system. For nearest neighbor search, only applies if
<code>nn_method = "annoy"</code>. If <code>n_threads &gt; 1</code>, then the Annoy index
will be temporarily written to disk in the location determined by
<code><a href="base.html#topic+tempfile">tempfile</a></code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_n_sgd_threads">n_sgd_threads</code></td>
<td>
<p>Number of threads to use during stochastic gradient
descent. If set to &gt; 1, then be aware that if <code>batch = FALSE</code>, results
will <em>not</em> be reproducible, even if <code>set.seed</code> is called with a
fixed seed before running. Set to <code>"auto"</code> to use the same value as
<code>n_threads</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_grain_size">grain_size</code></td>
<td>
<p>The minimum amount of work to do on each thread. If this
value is set high enough, then less than <code>n_threads</code> or
<code>n_sgd_threads</code> will be used for processing, which might give a
performance improvement if the overhead of thread management and context
switching was outweighing the improvement due to concurrent processing.
This should be left at default (<code>1</code>) and work will be spread evenly
over all the threads specified.</p>
</td></tr>
<tr><td><code id="tumap_+3A_y">y</code></td>
<td>
<p>Optional target data for supervised dimension reduction. Can be a
vector, matrix or data frame. Use the <code>target_metric</code> parameter to
specify the metrics to use, using the same syntax as <code>metric</code>. Usually
either a single numeric or factor column is used, but more complex formats
are possible. The following types are allowed:
</p>

<ul>
<li><p> Factor columns with the same length as <code>X</code>. <code>NA</code> is
allowed for any observation with an unknown level, in which case
UMAP operates as a form of semi-supervised learning. Each column is
treated separately.
</p>
</li>
<li><p> Numeric data. <code>NA</code> is <em>not</em> allowed in this case. Use the
parameter <code>target_n_neighbors</code> to set the number of neighbors used
with <code>y</code>. If unset, <code>n_neighbors</code> is used. Unlike factors,
numeric columns are grouped into one block unless <code>target_metric</code>
specifies otherwise. For example, if you wish columns <code>a</code> and
<code>b</code> to be treated separately, specify
<code>target_metric = list(euclidean = "a", euclidean = "b")</code>. Otherwise,
the data will be effectively treated as a matrix with two columns.
</p>
</li>
<li><p> Nearest neighbor data, consisting of a list of two matrices,
<code>idx</code> and <code>dist</code>. These represent the precalculated nearest
neighbor indices and distances, respectively. This
is the same format as that expected for precalculated data in
<code>nn_method</code>. This format assumes that the underlying data was a
numeric vector. Any user-supplied value of the <code>target_n_neighbors</code>
parameter is ignored in this case, because the the number of columns in
the matrices is used for the value. Multiple nearest neighbor data using
different metrics can be supplied by passing a list of these lists.
</p>
</li></ul>

<p>Unlike <code>X</code>, all factor columns included in <code>y</code> are automatically
used.</p>
</td></tr>
<tr><td><code id="tumap_+3A_target_n_neighbors">target_n_neighbors</code></td>
<td>
<p>Number of nearest neighbors to use to construct the
target simplicial set. Default value is <code>n_neighbors</code>. Applies only if
<code>y</code> is non-<code>NULL</code> and <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_target_metric">target_metric</code></td>
<td>
<p>The metric used to measure distance for <code>y</code> if
using supervised dimension reduction. Used only if <code>y</code> is numeric.</p>
</td></tr>
<tr><td><code id="tumap_+3A_target_weight">target_weight</code></td>
<td>
<p>Weighting factor between data topology and target
topology. A value of 0.0 weights entirely on data, a value of 1.0 weights
entirely on target. The default of 0.5 balances the weighting equally
between data and target. Only applies if <code>y</code> is non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_pca">pca</code></td>
<td>
<p>If set to a positive integer value, reduce data to this number of
columns using PCA. Doesn't applied if the distance <code>metric</code> is
<code>"hamming"</code>, or the dimensions of the data is larger than the
number specified (i.e. number of rows and columns must be larger than the
value of this parameter). If you have &gt; 100 columns in a data frame or
matrix, reducing the number of columns in this way may substantially
increase the performance of the nearest neighbor search at the cost of a
potential decrease in accuracy. In many t-SNE applications, a value of 50
is recommended, although there's no guarantee that this is appropriate for
all settings.</p>
</td></tr>
<tr><td><code id="tumap_+3A_pca_center">pca_center</code></td>
<td>
<p>If <code>TRUE</code>, center the columns of <code>X</code> before
carrying out PCA. For binary data, it's recommended to set this to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_pcg_rand">pcg_rand</code></td>
<td>
<p>If <code>TRUE</code>, use the PCG random number generator (O'Neill,
2014) during optimization. Otherwise, use the faster (but probably less
statistically good) Tausworthe &quot;taus88&quot; generator. The default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_fast_sgd">fast_sgd</code></td>
<td>
<p>If <code>TRUE</code>, then the following combination of parameters
is set: <code>pcg_rand = TRUE</code> and <code>n_sgd_threads = "auto"</code>. The
default is <code>FALSE</code>. Setting this to <code>TRUE</code> will speed up the
stochastic optimization phase, but give a potentially less accurate
embedding, and which will not be exactly reproducible even with a fixed
seed. For visualization, <code>fast_sgd = TRUE</code> will give perfectly good
results. For more generic dimensionality reduction, it's safer to leave
<code>fast_sgd = FALSE</code>. If <code>fast_sgd = TRUE</code>, then user-supplied
values of <code>pcg_rand</code> and <code>n_sgd_threads</code>, are ignored.</p>
</td></tr>
<tr><td><code id="tumap_+3A_ret_model">ret_model</code></td>
<td>
<p>If <code>TRUE</code>, then return extra data that can be used to
add new data to an existing embedding via <code><a href="#topic+umap_transform">umap_transform</a></code>. The
embedded coordinates are returned as the list item <code>embedding</code>. If
<code>FALSE</code>, just return the coordinates. This parameter can be used in
conjunction with <code>ret_nn</code> and <code>ret_extra</code>. Note that some
settings are incompatible with the production of a UMAP model: external
neighbor data (passed via a list to <code>nn_method</code>), and factor columns
that were included via the <code>metric</code> parameter. In the latter case, the
model produced is based only on the numeric data. A transformation using
new data is possible, but the factor columns in the new data are ignored.
Note that setting <code>ret_model = TRUE</code> forces the use of the approximate
nearest neighbors method. Because small datasets would otherwise use exact
nearest neighbor calculations, setting <code>ret_model = TRUE</code> means that
different results may be returned for small datasets in terms of both the
returned nearest neighbors (if requested) and the final embedded
coordinates, compared to <code>ret_model = FALSE</code>, even if the random
number seed is fixed. To avoid this, explicitly set
<code>nn_method = "annoy"</code> in the <code>ret_model = FALSE</code> case.</p>
</td></tr>
<tr><td><code id="tumap_+3A_ret_nn">ret_nn</code></td>
<td>
<p>If <code>TRUE</code>, then in addition to the embedding, also return
nearest neighbor data that can be used as input to <code>nn_method</code> to
avoid the overhead of repeatedly calculating the nearest neighbors when
manipulating unrelated parameters (e.g. <code>min_dist</code>, <code>n_epochs</code>,
<code>init</code>). See the &quot;Value&quot; section for the names of the list items. If
<code>FALSE</code>, just return the coordinates. Note that the nearest neighbors
could be sensitive to data scaling, so be wary of reusing nearest neighbor
data if modifying the <code>scale</code> parameter. This parameter can be used in
conjunction with <code>ret_model</code> and <code>ret_extra</code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_ret_extra">ret_extra</code></td>
<td>
<p>A vector indicating what extra data to return. May contain
any combination of the following strings:
</p>

<ul>
<li> <p><code>"model"</code> Same as setting <code>ret_model = TRUE</code>.
</p>
</li>
<li> <p><code>"nn"</code> Same as setting <code>ret_nn = TRUE</code>.
</p>
</li>
<li> <p><code>"fgraph"</code> the high dimensional fuzzy graph (i.e. the fuzzy
simplicial set of the merged local views of the input data). The graph
is returned as a sparse symmetric N x N matrix of class
<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a>, where a non-zero entry (i, j) gives the
membership strength of the edge connecting vertex i and vertex j. This
can be considered analogous to the input probability (or similarity or
affinity) used in t-SNE and LargeVis. Note that the graph is further
sparsified by removing edges with sufficiently low membership strength
that they would not be sampled by the probabilistic edge sampling
employed for optimization and therefore the number of non-zero elements
in the matrix is dependent on <code>n_epochs</code>. If you are only
interested in the fuzzy input graph (e.g. for clustering), setting
<code>n_epochs = 0</code> will avoid any further sparsifying. Be aware that
setting <code>binary_edge_weights = TRUE</code> will affect this graph (all
non-zero edge weights will be 1).
</p>
</li>
<li> <p><code>"sigma"</code> the normalization value for each observation in the
dataset when constructing the smoothed distances to each of its
neighbors. This gives some sense of the local density of each
observation in the high dimensional space: higher values of
<code>sigma</code> indicate a higher dispersion or lower density.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tumap_+3A_tmpdir">tmpdir</code></td>
<td>
<p>Temporary directory to store nearest neighbor indexes during
nearest neighbor search. Default is <code><a href="base.html#topic+tempdir">tempdir</a></code>. The index is
only written to disk if <code>n_threads &gt; 1</code> and
<code>nn_method = "annoy"</code>; otherwise, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="tumap_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, log details to the console.</p>
</td></tr>
<tr><td><code id="tumap_+3A_batch">batch</code></td>
<td>
<p>If <code>TRUE</code>, then embedding coordinates are updated at the
end of each epoch rather than during the epoch. In batch mode, results are
reproducible with a fixed random seed even with <code>n_sgd_threads &gt; 1</code>,
at the cost of a slightly higher memory use. You may also have to modify
<code>learning_rate</code> and increase <code>n_epochs</code>, so whether this provides
a speed increase over the single-threaded optimization is likely to be
dataset and hardware-dependent.</p>
</td></tr>
<tr><td><code id="tumap_+3A_opt_args">opt_args</code></td>
<td>
<p>A list of optimizer parameters, used when
<code>batch = TRUE</code>. The default optimization method used is Adam (Kingma
and Ba, 2014).
</p>

<ul>
<li> <p><code>method</code> The optimization method to use. Either <code>"adam"</code>
or <code>"sgd"</code> (stochastic gradient descent). Default: <code>"adam"</code>.
</p>
</li>
<li> <p><code>beta1</code> (Adam only). The weighting parameter for the
exponential moving average of the first moment estimator. Effectively the
momentum parameter. Should be a floating point value between 0 and 1.
Higher values can smooth oscillatory updates in poorly-conditioned
situations and may allow for a larger <code>learning_rate</code> to be
specified, but too high can cause divergence. Default: <code>0.5</code>.
</p>
</li>
<li> <p><code>beta2</code> (Adam only). The weighting parameter for the
exponential moving average of the uncentered second moment estimator.
Should be a floating point value between 0 and 1. Controls the degree of
adaptivity in the step-size. Higher values put more weight on previous
time steps. Default: <code>0.9</code>.
</p>
</li>
<li> <p><code>eps</code> (Adam only). Intended to be a small value to prevent
division by zero, but in practice can also affect convergence due to its
interaction with <code>beta2</code>. Higher values reduce the effect of the
step-size adaptivity and bring the behavior closer to stochastic gradient
descent with momentum. Typical values are between 1e-8 and 1e-3. Default:
<code>1e-7</code>.
</p>
</li>
<li> <p><code>alpha</code> The initial learning rate. Default: the value of the
<code>learning_rate</code> parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tumap_+3A_epoch_callback">epoch_callback</code></td>
<td>
<p>A function which will be invoked at the end of every
epoch. Its signature should be: <code>(epoch, n_epochs, coords)</code>, where:
</p>

<ul>
<li> <p><code>epoch</code> The current epoch number (between <code>1</code> and
<code>n_epochs</code>).
</p>
</li>
<li> <p><code>n_epochs</code> Number of epochs to use during the optimization of
the embedded coordinates.
</p>
</li>
<li> <p><code>coords</code> The embedded coordinates as of the end of the current
epoch, as a matrix with dimensions (N, <code>n_components</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="tumap_+3A_pca_method">pca_method</code></td>
<td>
<p>Method to carry out any PCA dimensionality reduction when
the <code>pca</code> parameter is specified. Allowed values are:
</p>

<ul>
<li><p><code>"irlba"</code>. Uses <code><a href="irlba.html#topic+prcomp_irlba">prcomp_irlba</a></code> from the
<a href="https://cran.r-project.org/package=irlba">irlba</a> package.
</p>
</li>
<li><p><code>"rsvd"</code>. Uses 5 iterations of <code><a href="irlba.html#topic+svdr">svdr</a></code> from
the <a href="https://cran.r-project.org/package=irlba">irlba</a> package.
This is likely to give much faster but potentially less accurate results
than using <code>"irlba"</code>. For the purposes of nearest neighbor
calculation and coordinates initialization, any loss of accuracy doesn't
seem to matter much.
</p>
</li>
<li><p><code>"bigstatsr"</code>. Uses <code><a href="bigstatsr.html#topic+big_randomSVD">big_randomSVD</a></code>
from the <a href="https://cran.r-project.org/package=bigstatsr">bigstatsr</a>
package. The SVD methods used in <code>bigstatsr</code> may be faster on
systems without access to efficient linear algebra libraries (e.g.
Windows). <strong>Note</strong>: <code>bigstatsr</code> is <em>not</em> a dependency of
uwot: if you choose to use this package for PCA, you <em>must</em> install
it yourself.
</p>
</li>
<li><p><code>"svd"</code>. Uses <code><a href="base.html#topic+svd">svd</a></code> for the SVD. This is
likely to be slow for all but the smallest datasets.
</p>
</li>
<li><p><code>"auto"</code> (the default). Uses <code>"irlba"</code>, unless more than
50
case <code>"svd"</code> is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tumap_+3A_binary_edge_weights">binary_edge_weights</code></td>
<td>
<p>If <code>TRUE</code> then edge weights in the input
graph are treated as binary (0/1) rather than real valued. This affects the
sampling frequency of neighbors and is the strategy used by the PaCMAP
method (Wang and co-workers, 2020). Practical (Böhm and co-workers, 2020)
and theoretical (Damrich and Hamprecht, 2021) work suggests this has little
effect on UMAP's performance.</p>
</td></tr>
<tr><td><code id="tumap_+3A_seed">seed</code></td>
<td>
<p>Integer seed to use to initialize the random number generator
state. Combined with <code>n_sgd_threads = 1</code> or <code>batch = TRUE</code>, this
should give consistent output across multiple runs on a given installation.
Setting this value is equivalent to calling <code><a href="base.html#topic+set.seed">set.seed</a></code>,
but it may be more convenient in some situations than having to call a
separate function. The default is to not set a seed. If
<code>ret_model = TRUE</code>, the seed will be stored in the output model and
then used to set the seed inside <code><a href="#topic+umap_transform">umap_transform</a></code>.</p>
</td></tr>
<tr><td><code id="tumap_+3A_nn_args">nn_args</code></td>
<td>
<p>A list containing additional arguments to pass to the nearest
neighbor method. For <code>nn_method = "annoy"</code>, you can specify
<code>"n_trees"</code> and <code>"search_k"</code>, and these will override the
<code>n_trees</code> and <code>search_k</code> parameters.
For <code>nn_method = "hnsw"</code>, you may specify the following arguments:
</p>

<ul>
<li> <p><code>M</code> The maximum number of neighbors to keep for each vertex.
Reasonable values are <code>2</code> to <code>100</code>. Higher values give better
recall at the cost of more memory. Default value is <code>16</code>.
</p>
</li>
<li> <p><code>ef_construction</code> A positive integer specifying the size of
the dynamic list used during index construction. A higher value will
provide better results at the cost of a longer time to build the index.
Default is <code>200</code>.
</p>
</li>
<li> <p><code>ef</code> A positive integer specifying the size of the dynamic
list used during search. This cannot be smaller than <code>n_neighbors</code>
and cannot be higher than the number of items in the index. Default is
<code>10</code>.
</p>
</li></ul>

<p>For <code>nn_method = "nndescent"</code>, you may specify the following
arguments:
</p>

<ul>
<li> <p><code>n_trees</code> The number of trees to use in a random projection
forest to initialize the search. A larger number will give more accurate
results at the cost of a longer computation time. The default of
<code>NULL</code> means that the number is chosen based on the number of
observations in <code>X</code>.
</p>
</li>
<li> <p><code>max_candidates</code> The number of potential neighbors to explore
per iteration. By default, this is set to <code>n_neighbors</code> or <code>60</code>,
whichever is smaller. A larger number will give more accurate results at
the cost of a longer computation time.
</p>
</li>
<li> <p><code>n_iters</code> The number of iterations to run the search. A larger
number will give more accurate results at the cost of a longer computation
time. By default, this will be chosen based on the number of observations
in <code>X</code>. You may also need to modify the convergence criterion
<code>delta</code>.
</p>
</li>
<li> <p><code>delta</code> The minimum relative change in the neighbor graph
allowed before early stopping. Should be a value between 0 and 1. The
smaller the value, the smaller the amount of progress between iterations is
allowed. Default value of <code>0.001</code> means that at least 0.1
neighbor graph must be updated at each iteration.
</p>
</li>
<li> <p><code>init</code> How to initialize the nearest neighbor descent. By
default this is set to <code>"tree"</code> and uses a random project forest.
If you set this to <code>"rand"</code>, then a random selection is used. Usually
this is less accurate than using RP trees, but for high-dimensional cases,
there may be little difference in the quality of the initialization and
random initialization will be a lot faster. If you set this to
<code>"rand"</code>, then the <code>n_trees</code> parameter is ignored.
</p>
</li>
<li> <p><code>pruning_degree_multiplier</code> The maximum number of edges per node
to retain in the search graph, relative to <code>n_neighbors</code>. A larger
value will give more accurate results at the cost of a longer computation
time. Default is <code>1.5</code>. This parameter only affects neighbor search
when transforming new data with <code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li>
<li> <p><code>epsilon</code> Controls the degree of the back-tracking when
traversing the search graph. Setting this to <code>0.0</code> will do a greedy
search with no back-tracking. A larger value will give more accurate
results at the cost of a longer computation time. Default is <code>0.1</code>.
This parameter only affects neighbor search when transforming new data with
<code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li>
<li> <p><code>max_search_fraction</code> Specifies the maximum fraction of the
search graph to traverse. By default, this is set to <code>1.0</code>, so the
entire graph (i.e. all items in <code>X</code>) may be visited. You may want to
set this to a smaller value if you have a very large dataset (in
conjunction with <code>epsilon</code>) to avoid an inefficient exhaustive search
of the data in <code>X</code>. This parameter only affects neighbor search when
transforming new data with <code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li></ul>

<p>For <code>nn_method = "nndescent"</code>, you may specify the following
arguments:
</p>

<ul>
<li> <p><code>n_trees</code> The number of trees to use in a random projection
forest to initialize the search. A larger number will give more accurate
results at the cost of a longer computation time. The default of
<code>NULL</code> means that the number is chosen based on the number of
observations in <code>X</code>.
</p>
</li>
<li> <p><code>max_candidates</code> The number of potential neighbors to explore
per iteration. By default, this is set to <code>n_neighbors</code> or <code>60</code>,
whichever is smaller. A larger number will give more accurate results at
the cost of a longer computation time.
</p>
</li>
<li> <p><code>n_iters</code> The number of iterations to run the search. A larger
number will give more accurate results at the cost of a longer computation
time. By default, this will be chosen based on the number of observations
in <code>X</code>. You may also need to modify the convergence criterion
<code>delta</code>.
</p>
</li>
<li> <p><code>delta</code> The minimum relative change in the neighbor graph
allowed before early stopping. Should be a value between 0 and 1. The
smaller the value, the smaller the amount of progress between iterations is
allowed. Default value of <code>0.001</code> means that at least 0.1
neighbor graph must be updated at each iteration.
</p>
</li>
<li> <p><code>init</code> How to initialize the nearest neighbor descent. By
default this is set to <code>"tree"</code> and uses a random project forest. If
you set this to <code>"rand"</code>, then a random selection is used. Usually
this is less accurate than using RP trees, but for high-dimensional cases,
there may be little difference in the quality of the initialization and
random initialization will be a lot faster. If you set this to
<code>"rand"</code>, then the <code>n_trees</code> parameter is ignored.
</p>
</li>
<li> <p><code>pruning_degree_multiplier</code> The maximum number of edges per node
to retain in the search graph, relative to <code>n_neighbors</code>. A larger
value will give more accurate results at the cost of a longer computation
time. Default is <code>1.5</code>. This parameter only affects neighbor search
when transforming new data with <code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li>
<li> <p><code>epsilon</code> Controls the degree of the back-tracking when
traversing the search graph. Setting this to <code>0.0</code> will do a greedy
search with no back-tracking. A larger value will give more accurate
results at the cost of a longer computation time. Default is <code>0.1</code>.
This parameter only affects neighbor search when transforming new data with
<code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li>
<li> <p><code>max_search_fraction</code> Specifies the maximum fraction of the
search graph to traverse. By default, this is set to <code>1.0</code>, so the
entire graph (i.e. all items in <code>X</code>) may be visited. You may want to
set this to a smaller value if you have a very large dataset (in
conjunction with <code>epsilon</code>) to avoid an inefficient exhaustive search
of the data in <code>X</code>. This parameter only affects neighbor search when
transforming new data with <code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>By setting the UMAP curve parameters <code>a</code> and <code>b</code> to <code>1</code>, you
get back the Cauchy distribution as used in t-SNE (van der Maaten and Hinton,
2008) and LargeVis (Tang et al., 2016). It also results in a substantially
simplified gradient expression. This can give a speed improvement of around
50%.
</p>


<h3>Value</h3>

<p>A matrix of optimized coordinates, or:
</p>

<ul>
<li><p> if <code>ret_model = TRUE</code> (or <code>ret_extra</code> contains
<code>"model"</code>), returns a list containing extra information that can be
used to add new data to an existing embedding via
<code><a href="#topic+umap_transform">umap_transform</a></code>. In this case, the coordinates are available
in the list item <code>embedding</code>. <b>NOTE</b>: The contents of
the <code>model</code> list should <em>not</em> be considered stable or part of
the public API, and are purposely left undocumented.
</p>
</li>
<li><p> if <code>ret_nn = TRUE</code> (or <code>ret_extra</code> contains <code>"nn"</code>),
returns the nearest neighbor data as a list called <code>nn</code>. This
contains one list for each <code>metric</code> calculated, itself containing a
matrix <code>idx</code> with the integer ids of the neighbors; and a matrix
<code>dist</code> with the distances. The <code>nn</code> list (or a sub-list) can be
used as input to the <code>nn_method</code> parameter.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"fgraph"</code> returns the high
dimensional fuzzy graph as a sparse matrix called <code>fgraph</code>, of type
<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a>.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"sigma"</code>, returns a vector of the
smooth knn distance normalization terms for each observation as
<code>"sigma"</code> and a vector <code>"rho"</code> containing the largest
distance to the locally connected neighbors of each observation.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"localr"</code>, returns a vector of
the estimated local radii, the sum of <code>"sigma"</code> and <code>"rho"</code>.
</p>
</li></ul>

<p>The returned list contains the combined data from any combination of
specifying <code>ret_model</code>, <code>ret_nn</code> and <code>ret_extra</code>.
</p>


<h3>References</h3>

<p>Belkin, M., &amp; Niyogi, P. (2002).
Laplacian eigenmaps and spectral techniques for embedding and clustering.
In <em>Advances in neural information processing systems</em>
(pp. 585-591).
<a href="http://papers.nips.cc/paper/1961-laplacian-eigenmaps-and-spectral-techniques-for-embedding-and-clustering.pdf">http://papers.nips.cc/paper/1961-laplacian-eigenmaps-and-spectral-techniques-for-embedding-and-clustering.pdf</a>
</p>
<p>Böhm, J. N., Berens, P., &amp; Kobak, D. (2020).
A unifying perspective on neighbor embeddings along the attraction-repulsion spectrum.
<em>arXiv preprint</em> <em>arXiv:2007.08902</em>.
<a href="https://arxiv.org/abs/2007.08902">https://arxiv.org/abs/2007.08902</a>
</p>
<p>Damrich, S., &amp; Hamprecht, F. A. (2021).
On UMAP's true loss function.
<em>Advances in Neural Information Processing Systems</em>, <em>34</em>.
<a href="https://proceedings.neurips.cc/paper/2021/hash/2de5d16682c3c35007e4e92982f1a2ba-Abstract.html">https://proceedings.neurips.cc/paper/2021/hash/2de5d16682c3c35007e4e92982f1a2ba-Abstract.html</a>
</p>
<p>Dong, W., Moses, C., &amp; Li, K. (2011, March).
Efficient k-nearest neighbor graph construction for generic similarity measures.
In <em>Proceedings of the 20th international conference on World Wide Web</em>
(pp. 577-586).
ACM.
<a href="https://doi.org/10.1145/1963405.1963487">doi:10.1145/1963405.1963487</a>.
</p>
<p>Kingma, D. P., &amp; Ba, J. (2014).
Adam: A method for stochastic optimization.
<em>arXiv preprint</em> <em>arXiv</em>:1412.6980.
<a href="https://arxiv.org/abs/1412.6980">https://arxiv.org/abs/1412.6980</a>
</p>
<p>Malkov, Y. A., &amp; Yashunin, D. A. (2018).
Efficient and robust approximate nearest neighbor search using hierarchical
navigable small world graphs.
<em>IEEE transactions on pattern analysis and machine intelligence</em>, <em>42</em>(4), 824-836.
</p>
<p>McInnes, L., Healy, J., &amp; Melville, J. (2018).
UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction
<em>arXiv preprint</em> <em>arXiv</em>:1802.03426.
<a href="https://arxiv.org/abs/1802.03426">https://arxiv.org/abs/1802.03426</a>
</p>
<p>O’Neill, M. E. (2014).
<em>PCG: A family of simple fast space-efficient statistically good
algorithms for random number generation</em>
(Report No. HMC-CS-2014-0905). Harvey Mudd College.
</p>
<p>Tang, J., Liu, J., Zhang, M., &amp; Mei, Q. (2016, April).
Visualizing large-scale and high-dimensional data.
In <em>Proceedings of the 25th International Conference on World Wide Web</em>
(pp. 287-297).
International World Wide Web Conferences Steering Committee.
<a href="https://arxiv.org/abs/1602.00370">https://arxiv.org/abs/1602.00370</a>
</p>
<p>Van der Maaten, L., &amp; Hinton, G. (2008).
Visualizing data using t-SNE.
<em>Journal of Machine Learning Research</em>, <em>9</em> (2579-2605).
<a href="https://www.jmlr.org/papers/v9/vandermaaten08a.html">https://www.jmlr.org/papers/v9/vandermaaten08a.html</a>
</p>
<p>Wang, Y., Huang, H., Rudin, C., &amp; Shaposhnik, Y. (2021).
Understanding How Dimension Reduction Tools Work: An Empirical Approach to Deciphering t-SNE, UMAP, TriMap, and PaCMAP for Data Visualization.
<em>Journal of Machine Learning Research</em>, <em>22</em>(201), 1-73.
<a href="https://www.jmlr.org/papers/v22/20-1061.html">https://www.jmlr.org/papers/v22/20-1061.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris_tumap &lt;- tumap(iris, n_neighbors = 50, learning_rate = 0.5)

</code></pre>

<hr>
<h2 id='umap'>Dimensionality Reduction with UMAP</h2><span id='topic+umap'></span>

<h3>Description</h3>

<p>Carry out dimensionality reduction of a dataset using the Uniform Manifold
Approximation and Projection (UMAP) method (McInnes et al., 2018). Some of
the following help text is lifted verbatim from the Python reference
implementation at <a href="https://github.com/lmcinnes/umap">https://github.com/lmcinnes/umap</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>umap(
  X,
  n_neighbors = 15,
  n_components = 2,
  metric = "euclidean",
  n_epochs = NULL,
  learning_rate = 1,
  scale = FALSE,
  init = "spectral",
  init_sdev = NULL,
  spread = 1,
  min_dist = 0.01,
  set_op_mix_ratio = 1,
  local_connectivity = 1,
  bandwidth = 1,
  repulsion_strength = 1,
  negative_sample_rate = 5,
  a = NULL,
  b = NULL,
  nn_method = NULL,
  n_trees = 50,
  search_k = 2 * n_neighbors * n_trees,
  approx_pow = FALSE,
  y = NULL,
  target_n_neighbors = n_neighbors,
  target_metric = "euclidean",
  target_weight = 0.5,
  pca = NULL,
  pca_center = TRUE,
  pcg_rand = TRUE,
  fast_sgd = FALSE,
  ret_model = FALSE,
  ret_nn = FALSE,
  ret_extra = c(),
  n_threads = NULL,
  n_sgd_threads = 0,
  grain_size = 1,
  tmpdir = tempdir(),
  verbose = getOption("verbose", TRUE),
  batch = FALSE,
  opt_args = NULL,
  epoch_callback = NULL,
  pca_method = NULL,
  binary_edge_weights = FALSE,
  dens_scale = NULL,
  seed = NULL,
  nn_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="umap_+3A_x">X</code></td>
<td>
<p>Input data. Can be a <code><a href="base.html#topic+data.frame">data.frame</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code> object or <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.
Matrix and data frames should contain one observation per row. Data frames
will have any non-numeric columns removed, although factor columns will be
used if explicitly included via <code>metric</code> (see the help for
<code>metric</code> for details). A sparse matrix is interpreted as a distance
matrix, and is assumed to be symmetric, so you can also pass in an
explicitly upper or lower triangular sparse matrix to save storage. There
must be at least <code>n_neighbors</code> non-zero distances for each row. Both
implicit and explicit zero entries are ignored. Set zero distances you want
to keep to an arbitrarily small non-zero value (e.g. <code>1e-10</code>).
<code>X</code> can also be <code>NULL</code> if pre-computed nearest neighbor data is
passed to <code>nn_method</code>, and <code>init</code> is not <code>"spca"</code> or
<code>"pca"</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>The size of local neighborhood (in terms of number of
neighboring sample points) used for manifold approximation. Larger values
result in more global views of the manifold, while smaller values result in
more local data being preserved. In general values should be in the range
<code>2</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_n_components">n_components</code></td>
<td>
<p>The dimension of the space to embed into. This defaults
to <code>2</code> to provide easy visualization, but can reasonably be set to any
integer value in the range <code>2</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_metric">metric</code></td>
<td>
<p>Type of distance metric to use to find nearest neighbors. For
<code>nn_method = "annoy"</code> this can be one of:
</p>

<ul>
<li> <p><code>"euclidean"</code> (the default)
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"manhattan"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"correlation"</code> (a distance based on the Pearson correlation)
</p>
</li>
<li> <p><code>"categorical"</code> (see below)
</p>
</li></ul>

<p>For <code>nn_method = "hnsw"</code> this can be one of:
</p>

<ul>
<li> <p><code>"euclidean"</code>
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"correlation"</code>
</p>
</li></ul>

<p>If <a href="https://cran.r-project.org/package=rnndescent">rnndescent</a> is
installed and <code>nn_method = "nndescent"</code> is specified then many more
metrics are avaiable, including:
</p>

<ul>
<li> <p><code>"braycurtis"</code>
</p>
</li>
<li> <p><code>"canberra"</code>
</p>
</li>
<li> <p><code>"chebyshev"</code>
</p>
</li>
<li> <p><code>"dice"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"hellinger"</code>
</p>
</li>
<li> <p><code>"jaccard"</code>
</p>
</li>
<li> <p><code>"jensenshannon"</code>
</p>
</li>
<li> <p><code>"kulsinski"</code>
</p>
</li>
<li> <p><code>"rogerstanimoto"</code>
</p>
</li>
<li> <p><code>"russellrao"</code>
</p>
</li>
<li> <p><code>"sokalmichener"</code>
</p>
</li>
<li> <p><code>"sokalsneath"</code>
</p>
</li>
<li> <p><code>"spearmanr"</code>
</p>
</li>
<li> <p><code>"symmetrickl"</code>
</p>
</li>
<li> <p><code>"tsss"</code>
</p>
</li>
<li> <p><code>"yule"</code>
</p>
</li></ul>

<p>For more details see the package documentation of <code>rnndescent</code>.
For <code>nn_method = "fnn"</code>, the distance metric is always &quot;euclidean&quot;.
</p>
<p>If <code>X</code> is a data frame or matrix, then multiple metrics can be
specified, by passing a list to this argument, where the name of each item in
the list is one of the metric names above. The value of each list item should
be a vector giving the names or integer ids of the columns to be included in
a calculation, e.g. <code>metric = list(euclidean = 1:4, manhattan = 5:10)</code>.
</p>
<p>Each metric calculation results in a separate fuzzy simplicial set, which are
intersected together to produce the final set. Metric names can be repeated.
Because non-numeric columns are removed from the data frame, it is safer to
use column names than integer ids.
</p>
<p>Factor columns can also be used by specifying the metric name
<code>"categorical"</code>. Factor columns are treated different from numeric
columns and although multiple factor columns can be specified in a vector,
each factor column specified is processed individually. If you specify
a non-factor column, it will be coerced to a factor.
</p>
<p>For a given data block, you may override the <code>pca</code> and <code>pca_center</code>
arguments for that block, by providing a list with one unnamed item
containing the column names or ids, and then any of the <code>pca</code> or
<code>pca_center</code> overrides as named items, e.g. <code>metric =
list(euclidean = 1:4, manhattan = list(5:10, pca_center = FALSE))</code>. This
exists to allow mixed binary and real-valued data to be included and to have
PCA applied to both, but with centering applied only to the real-valued data
(it is typical not to apply centering to binary data before PCA is applied).</p>
</td></tr>
<tr><td><code id="umap_+3A_n_epochs">n_epochs</code></td>
<td>
<p>Number of epochs to use during the optimization of the
embedded coordinates. By default, this value is set to <code>500</code> for
datasets containing 10,000 vertices or less, and <code>200</code> otherwise.
If <code>n_epochs = 0</code>, then coordinates determined by <code>"init"</code> will
be returned.</p>
</td></tr>
<tr><td><code id="umap_+3A_learning_rate">learning_rate</code></td>
<td>
<p>Initial learning rate used in optimization of the
coordinates.</p>
</td></tr>
<tr><td><code id="umap_+3A_scale">scale</code></td>
<td>
<p>Scaling to apply to <code>X</code> if it is a data frame or matrix:
</p>

<ul>
<li><p><code>"none"</code> or <code>FALSE</code> or <code>NULL</code> No scaling.
</p>
</li>
<li><p><code>"Z"</code> or <code>"scale"</code> or <code>TRUE</code> Scale each column to
zero mean and variance 1.
</p>
</li>
<li><p><code>"maxabs"</code> Center each column to mean 0, then divide each
element by the maximum absolute value over the entire matrix.
</p>
</li>
<li><p><code>"range"</code> Range scale the entire matrix, so the smallest
element is 0 and the largest is 1.
</p>
</li>
<li><p><code>"colrange"</code> Scale each column in the range (0,1).
</p>
</li></ul>

<p>For UMAP, the default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_init">init</code></td>
<td>
<p>Type of initialization for the coordinates. Options are:
</p>

<ul>
<li> <p><code>"spectral"</code> Spectral embedding using the normalized Laplacian
of the fuzzy 1-skeleton, with Gaussian noise added.
</p>
</li>
<li> <p><code>"normlaplacian"</code>. Spectral embedding using the normalized
Laplacian of the fuzzy 1-skeleton, without noise.
</p>
</li>
<li> <p><code>"random"</code>. Coordinates assigned using a uniform random
distribution between -10 and 10.
</p>
</li>
<li> <p><code>"lvrandom"</code>. Coordinates assigned using a Gaussian
distribution with standard deviation 1e-4, as used in LargeVis
(Tang et al., 2016) and t-SNE.
</p>
</li>
<li> <p><code>"laplacian"</code>. Spectral embedding using the Laplacian Eigenmap
(Belkin and Niyogi, 2002).
</p>
</li>
<li> <p><code>"pca"</code>. The first two principal components from PCA of
<code>X</code> if <code>X</code> is a data frame, and from a 2-dimensional classical
MDS if <code>X</code> is of class <code>"dist"</code>.
</p>
</li>
<li> <p><code>"spca"</code>. Like <code>"pca"</code>, but each dimension is then scaled
so the standard deviation is 1e-4, to give a distribution similar to that
used in t-SNE. This is an alias for <code>init = "pca", init_sdev =
   1e-4</code>.
</p>
</li>
<li> <p><code>"agspectral"</code> An &quot;approximate global&quot; modification of
<code>"spectral"</code> which all edges in the graph to a value of 1, and then
sets a random number of edges (<code>negative_sample_rate</code> edges per
vertex) to 0.1, to approximate the effect of non-local affinities.
</p>
</li>
<li><p> A matrix of initial coordinates.
</p>
</li></ul>

<p>For spectral initializations, (<code>"spectral"</code>, <code>"normlaplacian"</code>,
<code>"laplacian"</code>, <code>"agspectral"</code>), if more than one connected
component is identified, no spectral initialization is attempted. Instead
a PCA-based initialization is attempted. If <code>verbose = TRUE</code> the
number of connected components are logged to the console. The existence of
multiple connected components implies that a global view of the data cannot
be attained with this initialization. Increasing the value of
<code>n_neighbors</code> may help.</p>
</td></tr>
<tr><td><code id="umap_+3A_init_sdev">init_sdev</code></td>
<td>
<p>If non-<code>NULL</code>, scales each dimension of the initialized
coordinates (including any user-supplied matrix) to this standard
deviation. By default no scaling is carried out, except when <code>init =
"spca"</code>, in which case the value is <code>0.0001</code>. Scaling the input may
help if the unscaled versions result in initial coordinates with large
inter-point distances or outliers. This usually results in small gradients
during optimization and very little progress being made to the layout.
Shrinking the initial embedding by rescaling can help under these
circumstances. Scaling the result of <code>init = "pca"</code> is usually
recommended and <code>init = "spca"</code> as an alias for <code>init = "pca",
init_sdev = 1e-4</code> but for the spectral initializations the scaled versions
usually aren't necessary unless you are using a large value of
<code>n_neighbors</code> (e.g. <code>n_neighbors = 150</code> or higher). For
compatibility with recent versions of the Python UMAP package, if you are
using <code>init = "spectral"</code>, then you should also set
<code>init_sdev = "range"</code>, which will range scale each of the columns
containing the initial data between 0-10. This is not set by default to
maintain backwards compatibility with previous versions of uwot.</p>
</td></tr>
<tr><td><code id="umap_+3A_spread">spread</code></td>
<td>
<p>The effective scale of embedded points. In combination with
<code>min_dist</code>, this determines how clustered/clumped the embedded points
are.</p>
</td></tr>
<tr><td><code id="umap_+3A_min_dist">min_dist</code></td>
<td>
<p>The effective minimum distance between embedded points.
Smaller values will result in a more clustered/clumped embedding where
nearby points on the manifold are drawn closer together, while larger
values will result on a more even dispersal of points. The value should be
set relative to the <code>spread</code> value, which determines the scale at
which embedded points will be spread out.</p>
</td></tr>
<tr><td><code id="umap_+3A_set_op_mix_ratio">set_op_mix_ratio</code></td>
<td>
<p>Interpolate between (fuzzy) union and intersection as
the set operation used to combine local fuzzy simplicial sets to obtain a
global fuzzy simplicial sets. Both fuzzy set operations use the product
t-norm. The value of this parameter should be between <code>0.0</code> and
<code>1.0</code>; a value of <code>1.0</code> will use a pure fuzzy union, while
<code>0.0</code> will use a pure fuzzy intersection.</p>
</td></tr>
<tr><td><code id="umap_+3A_local_connectivity">local_connectivity</code></td>
<td>
<p>The local connectivity required &ndash; i.e. the number
of nearest neighbors that should be assumed to be connected at a local
level. The higher this value the more connected the manifold becomes
locally. In practice this should be not more than the local intrinsic
dimension of the manifold.</p>
</td></tr>
<tr><td><code id="umap_+3A_bandwidth">bandwidth</code></td>
<td>
<p>The effective bandwidth of the kernel if we view the
algorithm as similar to Laplacian Eigenmaps. Larger values induce more
connectivity and a more global view of the data, smaller values concentrate
more locally.</p>
</td></tr>
<tr><td><code id="umap_+3A_repulsion_strength">repulsion_strength</code></td>
<td>
<p>Weighting applied to negative samples in low
dimensional embedding optimization. Values higher than one will result in
greater weight being given to negative samples.</p>
</td></tr>
<tr><td><code id="umap_+3A_negative_sample_rate">negative_sample_rate</code></td>
<td>
<p>The number of negative edge/1-simplex samples to
use per positive edge/1-simplex sample in optimizing the low dimensional
embedding.</p>
</td></tr>
<tr><td><code id="umap_+3A_a">a</code></td>
<td>
<p>More specific parameters controlling the embedding. If <code>NULL</code>
these values are set automatically as determined by <code>min_dist</code> and
<code>spread</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_b">b</code></td>
<td>
<p>More specific parameters controlling the embedding. If <code>NULL</code>
these values are set automatically as determined by <code>min_dist</code> and
<code>spread</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_nn_method">nn_method</code></td>
<td>
<p>Method for finding nearest neighbors. Options are:
</p>

<ul>
<li> <p><code>"fnn"</code>. Use exact nearest neighbors via the
<a href="https://cran.r-project.org/package=FNN">FNN</a> package.
</p>
</li>
<li> <p><code>"annoy"</code> Use approximate nearest neighbors via the
<a href="https://cran.r-project.org/package=RcppAnnoy">RcppAnnoy</a> package.
</p>
</li>
<li> <p><code>"hnsw"</code> Use approximate nearest neighbors with the
Hierarchical Navigable Small World (HNSW) method (Malkov and Yashunin,
2018) via the
<a href="https://cran.r-project.org/package=RcppHNSW">RcppHNSW</a> package.
<code>RcppHNSW</code> is not a dependency of this package: this option is
only available if you have installed <code>RcppHNSW</code> yourself. Also,
HNSW only supports the following arguments for <code>metric</code> and
<code>target_metric</code>: <code>"euclidean"</code>, <code>"cosine"</code> and
<code>"correlation"</code>.
</p>
</li>
<li> <p><code>"nndescent"</code> Use approximate nearest neighbors with the
Nearest Neighbor Descent method (Dong et al., 2011) via the
<a href="https://cran.r-project.org/package=rnndescent">rnndescent</a>
package. <code>rnndescent</code> is not a dependency of this package: this
option is only available if you have installed <code>rnndescent</code>
yourself.
</p>
</li></ul>

<p>By default, if <code>X</code> has less than 4,096 vertices, the exact nearest
neighbors are found. Otherwise, approximate nearest neighbors are used.
You may also pass pre-calculated nearest neighbor data to this argument. It
must be one of two formats, either a list consisting of two elements:
</p>

<ul>
<li> <p><code>"idx"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the integer indexes of the nearest neighbors in <code>X</code>. Each
vertex is considered to be its own nearest neighbor, i.e.
<code>idx[, 1] == 1:n_vertices</code>.
</p>
</li>
<li> <p><code>"dist"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the distances of the nearest neighbors.
</p>
</li></ul>

<p>or a sparse distance matrix of type <code>dgCMatrix</code>, with dimensions
<code>n_vertices x n_vertices</code>. Distances should be arranged by column,
i.e. a non-zero entry in row <code>j</code> of the <code>i</code>th column indicates
that the <code>j</code>th observation in <code>X</code> is a nearest neighbor of the
<code>i</code>th observation with the distance given by the value of that
element.
The <code>n_neighbors</code> parameter is ignored when using precomputed
nearest neighbor data. If using the sparse distance matrix input, each
column can contain a different number of neighbors.</p>
</td></tr>
<tr><td><code id="umap_+3A_n_trees">n_trees</code></td>
<td>
<p>Number of trees to build when constructing the nearest
neighbor index. The more trees specified, the larger the index, but the
better the results. With <code>search_k</code>, determines the accuracy of the
Annoy nearest neighbor search. Only used if the <code>nn_method</code> is
<code>"annoy"</code>. Sensible values are between <code>10</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_search_k">search_k</code></td>
<td>
<p>Number of nodes to search during the neighbor retrieval. The
larger k, the more the accurate results, but the longer the search takes.
With <code>n_trees</code>, determines the accuracy of the Annoy nearest neighbor
search. Only used if the <code>nn_method</code> is <code>"annoy"</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_approx_pow">approx_pow</code></td>
<td>
<p>If <code>TRUE</code>, use an approximation to the power function
in the UMAP gradient, from
<a href="https://martin.ankerl.com/2012/01/25/optimized-approximative-pow-in-c-and-cpp/">https://martin.ankerl.com/2012/01/25/optimized-approximative-pow-in-c-and-cpp/</a>.
Ignored if <code>dens_scale</code> is non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_y">y</code></td>
<td>
<p>Optional target data for supervised dimension reduction. Can be a
vector, matrix or data frame. Use the <code>target_metric</code> parameter to
specify the metrics to use, using the same syntax as <code>metric</code>. Usually
either a single numeric or factor column is used, but more complex formats
are possible. The following types are allowed:
</p>

<ul>
<li><p> Factor columns with the same length as <code>X</code>. <code>NA</code> is
allowed for any observation with an unknown level, in which case
UMAP operates as a form of semi-supervised learning. Each column is
treated separately.
</p>
</li>
<li><p> Numeric data. <code>NA</code> is <em>not</em> allowed in this case. Use the
parameter <code>target_n_neighbors</code> to set the number of neighbors used
with <code>y</code>. If unset, <code>n_neighbors</code> is used. Unlike factors,
numeric columns are grouped into one block unless <code>target_metric</code>
specifies otherwise. For example, if you wish columns <code>a</code> and
<code>b</code> to be treated separately, specify
<code>target_metric = list(euclidean = "a", euclidean = "b")</code>. Otherwise,
the data will be effectively treated as a matrix with two columns.
</p>
</li>
<li><p> Nearest neighbor data, consisting of a list of two matrices,
<code>idx</code> and <code>dist</code>. These represent the precalculated nearest
neighbor indices and distances, respectively. This
is the same format as that expected for precalculated data in
<code>nn_method</code>. This format assumes that the underlying data was a
numeric vector. Any user-supplied value of the <code>target_n_neighbors</code>
parameter is ignored in this case, because the the number of columns in
the matrices is used for the value. Multiple nearest neighbor data using
different metrics can be supplied by passing a list of these lists.
</p>
</li></ul>

<p>Unlike <code>X</code>, all factor columns included in <code>y</code> are automatically
used.</p>
</td></tr>
<tr><td><code id="umap_+3A_target_n_neighbors">target_n_neighbors</code></td>
<td>
<p>Number of nearest neighbors to use to construct the
target simplicial set. Default value is <code>n_neighbors</code>. Applies only if
<code>y</code> is non-<code>NULL</code> and <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_target_metric">target_metric</code></td>
<td>
<p>The metric used to measure distance for <code>y</code> if
using supervised dimension reduction. Used only if <code>y</code> is numeric.</p>
</td></tr>
<tr><td><code id="umap_+3A_target_weight">target_weight</code></td>
<td>
<p>Weighting factor between data topology and target
topology. A value of 0.0 weights entirely on data, a value of 1.0 weights
entirely on target. The default of 0.5 balances the weighting equally
between data and target. Only applies if <code>y</code> is non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_pca">pca</code></td>
<td>
<p>If set to a positive integer value, reduce data to this number of
columns using PCA. Doesn't applied if the distance <code>metric</code> is
<code>"hamming"</code>, or the dimensions of the data is larger than the
number specified (i.e. number of rows and columns must be larger than the
value of this parameter). If you have &gt; 100 columns in a data frame or
matrix, reducing the number of columns in this way may substantially
increase the performance of the nearest neighbor search at the cost of a
potential decrease in accuracy. In many t-SNE applications, a value of 50
is recommended, although there's no guarantee that this is appropriate for
all settings.</p>
</td></tr>
<tr><td><code id="umap_+3A_pca_center">pca_center</code></td>
<td>
<p>If <code>TRUE</code>, center the columns of <code>X</code> before
carrying out PCA. For binary data, it's recommended to set this to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_pcg_rand">pcg_rand</code></td>
<td>
<p>If <code>TRUE</code>, use the PCG random number generator (O'Neill,
2014) during optimization. Otherwise, use the faster (but probably less
statistically good) Tausworthe &quot;taus88&quot; generator. The default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_fast_sgd">fast_sgd</code></td>
<td>
<p>If <code>TRUE</code>, then the following combination of parameters
is set: <code>pcg_rand = TRUE</code>, <code>n_sgd_threads = "auto"</code> and
<code>approx_pow = TRUE</code>. The default is <code>FALSE</code>. Setting this to
<code>TRUE</code> will speed up the stochastic optimization phase, but give a
potentially less accurate embedding, and which will not be exactly
reproducible even with a fixed seed. For visualization, <code>fast_sgd =
TRUE</code> will give perfectly good results. For more generic dimensionality
reduction, it's safer to leave <code>fast_sgd = FALSE</code>. If <code>fast_sgd =
TRUE</code>, then user-supplied values of <code>pcg_rand</code>, <code>n_sgd_threads</code>,
and <code>approx_pow</code> are ignored.</p>
</td></tr>
<tr><td><code id="umap_+3A_ret_model">ret_model</code></td>
<td>
<p>If <code>TRUE</code>, then return extra data that can be used to
add new data to an existing embedding via <code><a href="#topic+umap_transform">umap_transform</a></code>. The
embedded coordinates are returned as the list item <code>embedding</code>. If
<code>FALSE</code>, just return the coordinates. This parameter can be used in
conjunction with <code>ret_nn</code> and <code>ret_extra</code>. Note that some
settings are incompatible with the production of a UMAP model: external
neighbor data (passed via a list to <code>nn_method</code>), and factor columns
that were included via the <code>metric</code> parameter. In the latter case, the
model produced is based only on the numeric data. A transformation using
new data is possible, but the factor columns in the new data are ignored.
Note that setting <code>ret_model = TRUE</code> forces the use of the approximate
nearest neighbors method. Because small datasets would otherwise use exact
nearest neighbor calculations, setting <code>ret_model = TRUE</code> means that
different results may be returned for small datasets in terms of both the
returned nearest neighbors (if requested) and the final embedded
coordinates, compared to <code>ret_model = FALSE</code>, even if the random
number seed is fixed. To avoid this, explicitly set
<code>nn_method = "annoy"</code> in the <code>ret_model = FALSE</code> case.</p>
</td></tr>
<tr><td><code id="umap_+3A_ret_nn">ret_nn</code></td>
<td>
<p>If <code>TRUE</code>, then in addition to the embedding, also return
nearest neighbor data that can be used as input to <code>nn_method</code> to
avoid the overhead of repeatedly calculating the nearest neighbors when
manipulating unrelated parameters (e.g. <code>min_dist</code>, <code>n_epochs</code>,
<code>init</code>). See the &quot;Value&quot; section for the names of the list items. If
<code>FALSE</code>, just return the coordinates. Note that the nearest neighbors
could be sensitive to data scaling, so be wary of reusing nearest neighbor
data if modifying the <code>scale</code> parameter. This parameter can be used in
conjunction with <code>ret_model</code> and <code>ret_extra</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_ret_extra">ret_extra</code></td>
<td>
<p>A vector indicating what extra data to return. May contain
any combination of the following strings:
</p>

<ul>
<li> <p><code>"model"</code> Same as setting <code>ret_model = TRUE</code>.
</p>
</li>
<li> <p><code>"nn"</code> Same as setting <code>ret_nn = TRUE</code>.
</p>
</li>
<li> <p><code>"fgraph"</code> the high dimensional fuzzy graph (i.e. the fuzzy
simplicial set of the merged local views of the input data). The graph
is returned as a sparse symmetric N x N matrix of class
<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a>, where a non-zero entry (i, j) gives the
membership strength of the edge connecting vertex i and vertex j. This
can be considered analogous to the input probability (or similarity or
affinity) used in t-SNE and LargeVis. Note that the graph is further
sparsified by removing edges with sufficiently low membership strength
that they would not be sampled by the probabilistic edge sampling
employed for optimization and therefore the number of non-zero elements
in the matrix is dependent on <code>n_epochs</code>. If you are only
interested in the fuzzy input graph (e.g. for clustering), setting
<code>n_epochs = 0</code> will avoid any further sparsifying.
Be aware that setting 'binary_edge_weights = TRUE' will affect this
graph (all non-zero edge weights will be 1).
</p>
</li>
<li> <p><code>"sigma"</code> the normalization value for each observation in the
dataset when constructing the smoothed distances to each of its
neighbors. This gives some sense of the local density of each
observation in the high dimensional space: higher values of
<code>sigma</code> indicate a higher dispersion or lower density.
</p>
</li></ul>
</td></tr>
<tr><td><code id="umap_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use (except during stochastic gradient
descent). Default is half the number of concurrent threads supported by the
system. For nearest neighbor search, only applies if
<code>nn_method = "annoy"</code>. If <code>n_threads &gt; 1</code>, then the Annoy index
will be temporarily written to disk in the location determined by
<code><a href="base.html#topic+tempfile">tempfile</a></code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_n_sgd_threads">n_sgd_threads</code></td>
<td>
<p>Number of threads to use during stochastic gradient
descent. If set to &gt; 1, then be aware that if <code>batch = FALSE</code>, results
will <em>not</em> be reproducible, even if <code>set.seed</code> is called with a
fixed seed before running. Set to <code>"auto"</code> to use the same value as
<code>n_threads</code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_grain_size">grain_size</code></td>
<td>
<p>The minimum amount of work to do on each thread. If this
value is set high enough, then less than <code>n_threads</code> or
<code>n_sgd_threads</code> will be used for processing, which might give a
performance improvement if the overhead of thread management and context
switching was outweighing the improvement due to concurrent processing.
This should be left at default (<code>1</code>) and work will be spread evenly
over all the threads specified.</p>
</td></tr>
<tr><td><code id="umap_+3A_tmpdir">tmpdir</code></td>
<td>
<p>Temporary directory to store nearest neighbor indexes during
nearest neighbor search. Default is <code><a href="base.html#topic+tempdir">tempdir</a></code>. The index is
only written to disk if <code>n_threads &gt; 1</code> and
<code>nn_method = "annoy"</code>; otherwise, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="umap_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, log details to the console.</p>
</td></tr>
<tr><td><code id="umap_+3A_batch">batch</code></td>
<td>
<p>If <code>TRUE</code>, then embedding coordinates are updated at the
end of each epoch rather than during the epoch. In batch mode, results are
reproducible with a fixed random seed even with <code>n_sgd_threads &gt; 1</code>,
at the cost of a slightly higher memory use. You may also have to modify
<code>learning_rate</code> and increase <code>n_epochs</code>, so whether this provides
a speed increase over the single-threaded optimization is likely to be
dataset and hardware-dependent.</p>
</td></tr>
<tr><td><code id="umap_+3A_opt_args">opt_args</code></td>
<td>
<p>A list of optimizer parameters, used when
<code>batch = TRUE</code>. The default optimization method used is Adam (Kingma
and Ba, 2014).
</p>

<ul>
<li> <p><code>method</code> The optimization method to use. Either <code>"adam"</code>
or <code>"sgd"</code> (stochastic gradient descent). Default: <code>"adam"</code>.
</p>
</li>
<li> <p><code>beta1</code> (Adam only). The weighting parameter for the
exponential moving average of the first moment estimator. Effectively the
momentum parameter. Should be a floating point value between 0 and 1.
Higher values can smooth oscillatory updates in poorly-conditioned
situations and may allow for a larger <code>learning_rate</code> to be
specified, but too high can cause divergence. Default: <code>0.5</code>.
</p>
</li>
<li> <p><code>beta2</code> (Adam only). The weighting parameter for the
exponential moving average of the uncentered second moment estimator.
Should be a floating point value between 0 and 1. Controls the degree of
adaptivity in the step-size. Higher values put more weight on previous
time steps. Default: <code>0.9</code>.
</p>
</li>
<li> <p><code>eps</code> (Adam only). Intended to be a small value to prevent
division by zero, but in practice can also affect convergence due to its
interaction with <code>beta2</code>. Higher values reduce the effect of the
step-size adaptivity and bring the behavior closer to stochastic gradient
descent with momentum. Typical values are between 1e-8 and 1e-3. Default:
<code>1e-7</code>.
</p>
</li>
<li> <p><code>alpha</code> The initial learning rate. Default: the value of the
<code>learning_rate</code> parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="umap_+3A_epoch_callback">epoch_callback</code></td>
<td>
<p>A function which will be invoked at the end of every
epoch. Its signature should be: <code>(epoch, n_epochs, coords)</code>, where:
</p>

<ul>
<li> <p><code>epoch</code> The current epoch number (between <code>1</code> and
<code>n_epochs</code>).
</p>
</li>
<li> <p><code>n_epochs</code> Number of epochs to use during the optimization of
the embedded coordinates.
</p>
</li>
<li> <p><code>coords</code> The embedded coordinates as of the end of the current
epoch, as a matrix with dimensions (N, <code>n_components</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="umap_+3A_pca_method">pca_method</code></td>
<td>
<p>Method to carry out any PCA dimensionality reduction when
the <code>pca</code> parameter is specified. Allowed values are:
</p>

<ul>
<li><p><code>"irlba"</code>. Uses <code><a href="irlba.html#topic+prcomp_irlba">prcomp_irlba</a></code> from the
<a href="https://cran.r-project.org/package=irlba">irlba</a> package.
</p>
</li>
<li><p><code>"rsvd"</code>. Uses 5 iterations of <code><a href="irlba.html#topic+svdr">svdr</a></code> from
the <a href="https://cran.r-project.org/package=irlba">irlba</a> package.
This is likely to give much faster but potentially less accurate results
than using <code>"irlba"</code>. For the purposes of nearest neighbor
calculation and coordinates initialization, any loss of accuracy doesn't
seem to matter much.
</p>
</li>
<li><p><code>"bigstatsr"</code>. Uses <code><a href="bigstatsr.html#topic+big_randomSVD">big_randomSVD</a></code>
from the <a href="https://cran.r-project.org/package=bigstatsr">bigstatsr</a>
package. The SVD methods used in <code>bigstatsr</code> may be faster on
systems without access to efficient linear algebra libraries (e.g.
Windows). <strong>Note</strong>: <code>bigstatsr</code> is <em>not</em> a dependency of
uwot: if you choose to use this package for PCA, you <em>must</em> install
it yourself.
</p>
</li>
<li><p><code>"svd"</code>. Uses <code><a href="base.html#topic+svd">svd</a></code> for the SVD. This is
likely to be slow for all but the smallest datasets.
</p>
</li>
<li><p><code>"auto"</code> (the default). Uses <code>"irlba"</code>, unless more than
50
case <code>"svd"</code> is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="umap_+3A_binary_edge_weights">binary_edge_weights</code></td>
<td>
<p>If <code>TRUE</code> then edge weights in the input
graph are treated as binary (0/1) rather than real valued. This affects the
sampling frequency of neighbors and is the strategy used by the PaCMAP
method (Wang and co-workers, 2020). Practical (Böhm and co-workers, 2020)
and theoretical (Damrich and Hamprecht, 2021) work suggests this has little
effect on UMAP's performance.</p>
</td></tr>
<tr><td><code id="umap_+3A_dens_scale">dens_scale</code></td>
<td>
<p>A value between 0 and 1. If &gt; 0 then the output attempts
to preserve relative local density around each observation. This uses an
approximation to the densMAP method (Narayan and co-workers, 2021). The
larger the value of <code>dens_scale</code>, the greater the range of output
densities that will be used to map the input densities. This option is
ignored if using multiple <code>metric</code> blocks.</p>
</td></tr>
<tr><td><code id="umap_+3A_seed">seed</code></td>
<td>
<p>Integer seed to use to initialize the random number generator
state. Combined with <code>n_sgd_threads = 1</code> or <code>batch = TRUE</code>, this
should give consistent output across multiple runs on a given installation.
Setting this value is equivalent to calling <code><a href="base.html#topic+set.seed">set.seed</a></code>,
but it may be more convenient in some situations than having to call a
separate function. The default is to not set a seed. If
<code>ret_model = TRUE</code>, the seed will be stored in the output model and
then used to set the seed inside <code><a href="#topic+umap_transform">umap_transform</a></code>.</p>
</td></tr>
<tr><td><code id="umap_+3A_nn_args">nn_args</code></td>
<td>
<p>A list containing additional arguments to pass to the nearest
neighbor method. For <code>nn_method = "annoy"</code>, you can specify
<code>"n_trees"</code> and <code>"search_k"</code>, and these will override the
<code>n_trees</code> and <code>search_k</code> parameters.
For <code>nn_method = "hnsw"</code>, you may specify the following arguments:
</p>

<ul>
<li> <p><code>M</code> The maximum number of neighbors to keep for each vertex.
Reasonable values are <code>2</code> to <code>100</code>. Higher values give better
recall at the cost of more memory. Default value is <code>16</code>.
</p>
</li>
<li> <p><code>ef_construction</code> A positive integer specifying the size of
the dynamic list used during index construction. A higher value will
provide better results at the cost of a longer time to build the index.
Default is <code>200</code>.
</p>
</li>
<li> <p><code>ef</code> A positive integer specifying the size of the dynamic
list used during search. This cannot be smaller than <code>n_neighbors</code>
and cannot be higher than the number of items in the index. Default is
<code>10</code>.
</p>
</li></ul>

<p>For <code>nn_method = "nndescent"</code>, you may specify the following
arguments:
</p>

<ul>
<li> <p><code>n_trees</code> The number of trees to use in a random projection
forest to initialize the search. A larger number will give more accurate
results at the cost of a longer computation time. The default of
<code>NULL</code> means that the number is chosen based on the number of
observations in <code>X</code>.
</p>
</li>
<li> <p><code>max_candidates</code> The number of potential neighbors to explore
per iteration. By default, this is set to <code>n_neighbors</code> or <code>60</code>,
whichever is smaller. A larger number will give more accurate results at
the cost of a longer computation time.
</p>
</li>
<li> <p><code>n_iters</code> The number of iterations to run the search. A larger
number will give more accurate results at the cost of a longer computation
time. By default, this will be chosen based on the number of observations
in <code>X</code>. You may also need to modify the convergence criterion
<code>delta</code>.
</p>
</li>
<li> <p><code>delta</code> The minimum relative change in the neighbor graph
allowed before early stopping. Should be a value between 0 and 1. The
smaller the value, the smaller the amount of progress between iterations is
allowed. Default value of <code>0.001</code> means that at least 0.1
neighbor graph must be updated at each iteration.
</p>
</li>
<li> <p><code>init</code> How to initialize the nearest neighbor descent. By
default this is set to <code>"tree"</code> and uses a random project forest.
If you set this to <code>"rand"</code>, then a random selection is used. Usually
this is less accurate than using RP trees, but for high-dimensional cases,
there may be little difference in the quality of the initialization and
random initialization will be a lot faster. If you set this to
<code>"rand"</code>, then the <code>n_trees</code> parameter is ignored.
</p>
</li>
<li> <p><code>pruning_degree_multiplier</code> The maximum number of edges per node
to retain in the search graph, relative to <code>n_neighbors</code>. A larger
value will give more accurate results at the cost of a longer computation
time. Default is <code>1.5</code>. This parameter only affects neighbor search
when transforming new data with <code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li>
<li> <p><code>epsilon</code> Controls the degree of the back-tracking when
traversing the search graph. Setting this to <code>0.0</code> will do a greedy
search with no back-tracking. A larger value will give more accurate
results at the cost of a longer computation time. Default is <code>0.1</code>.
This parameter only affects neighbor search when transforming new data with
<code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li>
<li> <p><code>max_search_fraction</code> Specifies the maximum fraction of the
search graph to traverse. By default, this is set to <code>1.0</code>, so the
entire graph (i.e. all items in <code>X</code>) may be visited. You may want to
set this to a smaller value if you have a very large dataset (in
conjunction with <code>epsilon</code>) to avoid an inefficient exhaustive search
of the data in <code>X</code>. This parameter only affects neighbor search when
transforming new data with <code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of optimized coordinates, or:
</p>

<ul>
<li><p> if <code>ret_model = TRUE</code> (or <code>ret_extra</code> contains
<code>"model"</code>), returns a list containing extra information that can be
used to add new data to an existing embedding via
<code><a href="#topic+umap_transform">umap_transform</a></code>. In this case, the coordinates are available
in the list item <code>embedding</code>. <b>NOTE</b>: The contents of
the <code>model</code> list should <em>not</em> be considered stable or part of
the public API, and are purposely left undocumented.
</p>
</li>
<li><p> if <code>ret_nn = TRUE</code> (or <code>ret_extra</code> contains <code>"nn"</code>),
returns the nearest neighbor data as a list called <code>nn</code>. This
contains one list for each <code>metric</code> calculated, itself containing a
matrix <code>idx</code> with the integer ids of the neighbors; and a matrix
<code>dist</code> with the distances. The <code>nn</code> list (or a sub-list) can be
used as input to the <code>nn_method</code> parameter.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"fgraph"</code>, returns the high
dimensional fuzzy graph as a sparse matrix called <code>fgraph</code>, of type
<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a>.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"sigma"</code>, returns a vector of the
smooth knn distance normalization terms for each observation as
<code>"sigma"</code> and a vector <code>"rho"</code> containing the largest
distance to the locally connected neighbors of each observation.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"localr"</code>, returns a vector of
the estimated local radii, the sum of <code>"sigma"</code> and <code>"rho"</code>.
</p>
</li></ul>

<p>The returned list contains the combined data from any combination of
specifying <code>ret_model</code>, <code>ret_nn</code> and <code>ret_extra</code>.
</p>


<h3>References</h3>

<p>Belkin, M., &amp; Niyogi, P. (2002).
Laplacian eigenmaps and spectral techniques for embedding and clustering.
In <em>Advances in neural information processing systems</em>
(pp. 585-591).
<a href="http://papers.nips.cc/paper/1961-laplacian-eigenmaps-and-spectral-techniques-for-embedding-and-clustering.pdf">http://papers.nips.cc/paper/1961-laplacian-eigenmaps-and-spectral-techniques-for-embedding-and-clustering.pdf</a>
</p>
<p>Böhm, J. N., Berens, P., &amp; Kobak, D. (2020).
A unifying perspective on neighbor embeddings along the attraction-repulsion spectrum.
<em>arXiv preprint</em> <em>arXiv:2007.08902</em>.
<a href="https://arxiv.org/abs/2007.08902">https://arxiv.org/abs/2007.08902</a>
</p>
<p>Damrich, S., &amp; Hamprecht, F. A. (2021).
On UMAP's true loss function.
<em>Advances in Neural Information Processing Systems</em>, <em>34</em>.
<a href="https://proceedings.neurips.cc/paper/2021/hash/2de5d16682c3c35007e4e92982f1a2ba-Abstract.html">https://proceedings.neurips.cc/paper/2021/hash/2de5d16682c3c35007e4e92982f1a2ba-Abstract.html</a>
</p>
<p>Dong, W., Moses, C., &amp; Li, K. (2011, March).
Efficient k-nearest neighbor graph construction for generic similarity measures.
In <em>Proceedings of the 20th international conference on World Wide Web</em>
(pp. 577-586).
ACM.
<a href="https://doi.org/10.1145/1963405.1963487">doi:10.1145/1963405.1963487</a>.
</p>
<p>Kingma, D. P., &amp; Ba, J. (2014).
Adam: A method for stochastic optimization.
<em>arXiv preprint</em> <em>arXiv</em>:1412.6980.
<a href="https://arxiv.org/abs/1412.6980">https://arxiv.org/abs/1412.6980</a>
</p>
<p>Malkov, Y. A., &amp; Yashunin, D. A. (2018).
Efficient and robust approximate nearest neighbor search using hierarchical
navigable small world graphs.
<em>IEEE transactions on pattern analysis and machine intelligence</em>, <em>42</em>(4), 824-836.
</p>
<p>McInnes, L., Healy, J., &amp; Melville, J. (2018).
UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction
<em>arXiv preprint</em> <em>arXiv</em>:1802.03426.
<a href="https://arxiv.org/abs/1802.03426">https://arxiv.org/abs/1802.03426</a>
</p>
<p>Narayan, A., Berger, B., &amp; Cho, H. (2021).
Assessing single-cell transcriptomic variability through density-preserving data visualization.
<em>Nature biotechnology</em>, <em>39</em>(6), 765-774.
<a href="https://doi.org/10.1038/s41587-020-00801-7">doi:10.1038/s41587-020-00801-7</a>
</p>
<p>O’Neill, M. E. (2014).
<em>PCG: A family of simple fast space-efficient statistically good
algorithms for random number generation</em>
(Report No. HMC-CS-2014-0905). Harvey Mudd College.
</p>
<p>Tang, J., Liu, J., Zhang, M., &amp; Mei, Q. (2016, April).
Visualizing large-scale and high-dimensional data.
In <em>Proceedings of the 25th International Conference on World Wide Web</em>
(pp. 287-297).
International World Wide Web Conferences Steering Committee.
<a href="https://arxiv.org/abs/1602.00370">https://arxiv.org/abs/1602.00370</a>
</p>
<p>Van der Maaten, L., &amp; Hinton, G. (2008).
Visualizing data using t-SNE.
<em>Journal of Machine Learning Research</em>, <em>9</em> (2579-2605).
<a href="https://www.jmlr.org/papers/v9/vandermaaten08a.html">https://www.jmlr.org/papers/v9/vandermaaten08a.html</a>
</p>
<p>Wang, Y., Huang, H., Rudin, C., &amp; Shaposhnik, Y. (2021).
Understanding How Dimension Reduction Tools Work: An Empirical Approach to Deciphering t-SNE, UMAP, TriMap, and PaCMAP for Data Visualization.
<em>Journal of Machine Learning Research</em>, <em>22</em>(201), 1-73.
<a href="https://www.jmlr.org/papers/v22/20-1061.html">https://www.jmlr.org/papers/v22/20-1061.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris30 &lt;- iris[c(1:10, 51:60, 101:110), ]

# Non-numeric columns are automatically removed so you can pass data frames
# directly in a lot of cases without pre-processing
iris_umap &lt;- umap(iris30, n_neighbors = 5, learning_rate = 0.5, init = "random", n_epochs = 20)

# Faster approximation to the gradient and return nearest neighbors
iris_umap &lt;- umap(iris30, n_neighbors = 5, approx_pow = TRUE, ret_nn = TRUE, n_epochs = 20)

# Can specify min_dist and spread parameters to control separation and size
# of clusters and reuse nearest neighbors for efficiency
nn &lt;- iris_umap$nn
iris_umap &lt;- umap(iris30, n_neighbors = 5, min_dist = 1, spread = 5, nn_method = nn, n_epochs = 20)

# Supervised dimension reduction using the 'Species' factor column
iris_sumap &lt;- umap(iris30,
  n_neighbors = 5, min_dist = 0.001, y = iris30$Species,
  target_weight = 0.5, n_epochs = 20
)

# Calculate Petal and Sepal neighbors separately (uses intersection of the resulting sets):
iris_umap &lt;- umap(iris30, metric = list(
  "euclidean" = c("Sepal.Length", "Sepal.Width"),
  "euclidean" = c("Petal.Length", "Petal.Width")
))

</code></pre>

<hr>
<h2 id='umap_transform'>Add New Points to an Existing Embedding</h2><span id='topic+umap_transform'></span>

<h3>Description</h3>

<p>Carry out an embedding of new data using an existing embedding. Requires
using the result of calling <code><a href="#topic+umap">umap</a></code> or <code><a href="#topic+tumap">tumap</a></code> with
<code>ret_model = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>umap_transform(
  X = NULL,
  model = NULL,
  nn_method = NULL,
  init_weighted = TRUE,
  search_k = NULL,
  tmpdir = tempdir(),
  n_epochs = NULL,
  n_threads = NULL,
  n_sgd_threads = 0,
  grain_size = 1,
  verbose = FALSE,
  init = "weighted",
  batch = NULL,
  learning_rate = NULL,
  opt_args = NULL,
  epoch_callback = NULL,
  ret_extra = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="umap_transform_+3A_x">X</code></td>
<td>
<p>The new data to be transformed, either a matrix of data frame. Must
have the same columns in the same order as the input data used to generate
the <code>model</code>.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_model">model</code></td>
<td>
<p>Data associated with an existing embedding.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_nn_method">nn_method</code></td>
<td>
<p>Optional pre-calculated nearest neighbor data. There are
two supported formats. The first is a list consisting of two elements:
</p>

<ul>
<li> <p><code>"idx"</code>. A <code>n_vertices x n_neighbors</code> matrix where
<code>n_vertices</code> is the number of observations in <code>X</code>. The contents
of the matrix should be the integer indexes of the data used to generate
the <code>model</code>, which are the <code>n_neighbors</code>-nearest neighbors of
the data to be transformed.
</p>
</li>
<li> <p><code>"dist"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the distances of the nearest neighbors.
</p>
</li></ul>

<p>The second supported format is a sparse distance matrix of type
<code>dgCMatrix</code>, with dimensions <code>n_model_vertices x n_vertices</code>.
where <code>n_model_vertices</code> is the number of observations in the original
data that generated the model. Distances should be arranged by column, i.e.
a non-zero entry in row <code>j</code> of the <code>i</code>th column indicates that
the <code>j</code>th observation in the original data used to generate the
<code>model</code> is a nearest neighbor of the <code>i</code>th observation in the new
data, with the distance given by the value of that element. In this format,
a different number of neighbors is allowed for each observation, i.e.
each column can contain a different number of non-zero values.
Multiple nearest neighbor data (e.g. from two different pre-calculated
metrics) can be passed by passing a list containing the nearest neighbor
data lists as items.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_init_weighted">init_weighted</code></td>
<td>
<p>If <code>TRUE</code>, then initialize the embedded coordinates
of <code>X</code> using a weighted average of the coordinates of the nearest
neighbors from the original embedding in <code>model</code>, where the weights
used are the edge weights from the UMAP smoothed knn distances. Otherwise,
use an un-weighted average.
This parameter will be deprecated and removed at version 1.0 of this
package. Use the <code>init</code> parameter as a replacement, replacing
<code>init_weighted = TRUE</code> with <code>init = "weighted"</code> and
<code>init_weighted = FALSE</code> with <code>init = "average"</code>.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_search_k">search_k</code></td>
<td>
<p>Number of nodes to search during the neighbor retrieval. The
larger k, the more the accurate results, but the longer the search takes.
Default is the value used in building the <code>model</code> is used.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_tmpdir">tmpdir</code></td>
<td>
<p>Temporary directory to store nearest neighbor indexes during
nearest neighbor search. Default is <code><a href="base.html#topic+tempdir">tempdir</a></code>. The index is
only written to disk if <code>n_threads &gt; 1</code>; otherwise, this parameter is
ignored.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_n_epochs">n_epochs</code></td>
<td>
<p>Number of epochs to use during the optimization of the
embedded coordinates. A value between <code>30 - 100</code> is a reasonable trade
off between speed and thoroughness. By default, this value is set to one
third the number of epochs used to build the <code>model</code>.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use, (except during stochastic gradient
descent). Default is half the number of concurrent threads supported by the
system.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_n_sgd_threads">n_sgd_threads</code></td>
<td>
<p>Number of threads to use during stochastic gradient
descent. If set to &gt; 1, then be aware that if <code>batch = FALSE</code>, results
will <em>not</em> be reproducible, even if <code>set.seed</code> is called with a
fixed seed before running. Set to <code>"auto"</code> to use the same value as
<code>n_threads</code>.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_grain_size">grain_size</code></td>
<td>
<p>Minimum batch size for multithreading. If the number of
items to process in a thread falls below this number, then no threads will
be used. Used in conjunction with <code>n_threads</code> and
<code>n_sgd_threads</code>.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, log details to the console.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_init">init</code></td>
<td>
<p>how to initialize the transformed coordinates. One of:
</p>

<ul>
<li> <p><code>"weighted"</code> (The default). Use a weighted average of the
coordinates of the nearest neighbors from the original embedding in
<code>model</code>, where the weights used are the edge weights from the UMAP
smoothed knn distances. Equivalent to <code>init_weighted = TRUE</code>.
</p>
</li>
<li> <p><code>"average"</code>. Use the mean average of the coordinates of
the nearest neighbors from the original embedding in <code>model</code>.
Equivalent to <code>init_weighted = FALSE</code>.
</p>
</li>
<li><p> A matrix of user-specified input coordinates, which must have
dimensions the same as <code>(nrow(X), ncol(model$embedding))</code>.
</p>
</li></ul>

<p>This parameter should be used in preference to <code>init_weighted</code>.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_batch">batch</code></td>
<td>
<p>If <code>TRUE</code>, then embedding coordinates are updated at the
end of each epoch rather than during the epoch. In batch mode, results are
reproducible with a fixed random seed even with <code>n_sgd_threads &gt; 1</code>,
at the cost of a slightly higher memory use. You may also have to modify
<code>learning_rate</code> and increase <code>n_epochs</code>, so whether this provides
a speed increase over the single-threaded optimization is likely to be
dataset and hardware-dependent. If <code>NULL</code>, the transform will use the
value provided in the <code>model</code>, if available. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_learning_rate">learning_rate</code></td>
<td>
<p>Initial learning rate used in optimization of the
coordinates. This overrides the value associated with the <code>model</code>.
This should be left unspecified under most circumstances.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_opt_args">opt_args</code></td>
<td>
<p>A list of optimizer parameters, used when
<code>batch = TRUE</code>. The default optimization method used is Adam (Kingma
and Ba, 2014).
</p>

<ul>
<li> <p><code>method</code> The optimization method to use. Either <code>"adam"</code>
or <code>"sgd"</code> (stochastic gradient descent). Default: <code>"adam"</code>.
</p>
</li>
<li> <p><code>beta1</code> (Adam only). The weighting parameter for the
exponential moving average of the first moment estimator. Effectively the
momentum parameter. Should be a floating point value between 0 and 1.
Higher values can smooth oscillatory updates in poorly-conditioned
situations and may allow for a larger <code>learning_rate</code> to be
specified, but too high can cause divergence. Default: <code>0.5</code>.
</p>
</li>
<li> <p><code>beta2</code> (Adam only). The weighting parameter for the
exponential moving average of the uncentered second moment estimator.
Should be a floating point value between 0 and 1. Controls the degree of
adaptivity in the step-size. Higher values put more weight on previous
time steps. Default: <code>0.9</code>.
</p>
</li>
<li> <p><code>eps</code> (Adam only). Intended to be a small value to prevent
division by zero, but in practice can also affect convergence due to its
interaction with <code>beta2</code>. Higher values reduce the effect of the
step-size adaptivity and bring the behavior closer to stochastic gradient
descent with momentum. Typical values are between 1e-8 and 1e-3. Default:
<code>1e-7</code>.
</p>
</li>
<li> <p><code>alpha</code> The initial learning rate. Default: the value of the
<code>learning_rate</code> parameter.
</p>
</li></ul>

<p>If <code>NULL</code>, the transform will use the value provided in the
<code>model</code>, if available.</p>
</td></tr>
<tr><td><code id="umap_transform_+3A_epoch_callback">epoch_callback</code></td>
<td>
<p>A function which will be invoked at the end of every
epoch. Its signature should be:
<code>(epoch, n_epochs, coords, fixed_coords)</code>, where:
</p>

<ul>
<li> <p><code>epoch</code> The current epoch number (between <code>1</code> and
<code>n_epochs</code>).
</p>
</li>
<li> <p><code>n_epochs</code> Number of epochs to use during the optimization of
the embedded coordinates.
</p>
</li>
<li> <p><code>coords</code> The embedded coordinates as of the end of the current
epoch, as a matrix with dimensions (N, <code>n_components</code>).
</p>
</li>
<li> <p><code>fixed_coords</code> The originally embedded coordinates from the
<code>model</code>. These are fixed and do not change. A matrix with dimensions
(Nmodel, <code>n_components</code>) where <code>Nmodel</code> is the number of
observations in the original data.
</p>
</li></ul>
</td></tr>
<tr><td><code id="umap_transform_+3A_ret_extra">ret_extra</code></td>
<td>
<p>A vector indicating what extra data to return. May contain
any combination of the following strings:
</p>

<ul>
<li> <p><code>"fgraph"</code> the high dimensional fuzzy graph (i.e. the fuzzy
simplicial set of the merged local views of the input data). The graph
is returned as a sparse matrix of class <a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a>
with dimensions <code>NX</code> x <code>Nmodel</code>, where <code>NX</code> is the number
of items in the data to transform in <code>X</code>, and <code>NModel</code> is
the number of items in the data used to build the UMAP <code>model</code>.
A non-zero entry (i, j) gives the membership strength of the edge
connecting the vertex representing the ith item in <code>X</code> to the
jth item in the data used to build the <code>model</code>. Note that the
graph is further sparsified by removing edges with sufficiently low
membership strength that they would not be sampled by the probabilistic
edge sampling employed for optimization and therefore the number of
non-zero elements in the matrix is dependent on <code>n_epochs</code>. If you
are only interested in the fuzzy input graph (e.g. for clustering),
setting <code>n_epochs = 0</code> will avoid any further sparsifying.
</p>
</li></ul>
</td></tr>
<tr><td><code id="umap_transform_+3A_seed">seed</code></td>
<td>
<p>Integer seed to use to initialize the random number generator
state. Combined with <code>n_sgd_threads = 1</code> or <code>batch = TRUE</code>, this
should give consistent output across multiple runs on a given installation.
Setting this value is equivalent to calling <code><a href="base.html#topic+set.seed">set.seed</a></code>,
but it may be more convenient in some situations than having to call a
separate function. The default is to not set a seed, in which case this
function uses the behavior specified by the supplied <code>model</code>: If the
model specifies a seed, then the model seed will be used to seed then
random number generator, and results will still be consistent (if
<code>n_sgd_threads = 1</code>). If you want to force the seed to not be set,
even if it is set in <code>model</code>, set <code>seed = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that some settings are incompatible with the production of a UMAP model
via <code><a href="#topic+umap">umap</a></code>: external neighbor data (passed via a list to the
argument of the <code>nn_method</code> parameter), and factor columns that were
included in the UMAP calculation via the <code>metric</code> parameter. In the
latter case, the model produced is based only on the numeric data.
A transformation is possible, but factor columns in the new data are ignored.
</p>


<h3>Value</h3>

<p>A matrix of coordinates for <code>X</code> transformed into the space
of the <code>model</code>, or if <code>ret_extra</code> is specified, a list
containing:
</p>

<ul>
<li> <p><code>embedding</code> the matrix of optimized coordinates.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"fgraph"</code>, an item of the same
name containing the high-dimensional fuzzy graph as a sparse matrix, of
type <a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a>.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"sigma"</code>, returns a vector of
the smooth knn distance normalization terms for each observation as
<code>"sigma"</code> and a vector <code>"rho"</code> containing the largest
distance to the locally connected neighbors of each observation.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"localr"</code>, an item of the same
name containing a vector of the estimated local radii, the sum of
<code>"sigma"</code> and <code>"rho"</code>.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"nn"</code>, an item of the same name
containing the nearest neighbors of each item in <code>X</code> (with respect
to the items that created the <code>model</code>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
iris_train &lt;- iris[1:100, ]
iris_test &lt;- iris[101:150, ]

# You must set ret_model = TRUE to return extra data needed
iris_train_umap &lt;- umap(iris_train, ret_model = TRUE)
iris_test_umap &lt;- umap_transform(iris_test, iris_train_umap)
</code></pre>

<hr>
<h2 id='umap2'>Dimensionality Reduction with UMAP</h2><span id='topic+umap2'></span>

<h3>Description</h3>

<p>Carry out dimensionality reduction of a dataset using the Uniform Manifold
Approximation and Projection (UMAP) method (McInnes et al., 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>umap2(
  X,
  n_neighbors = 15,
  n_components = 2,
  metric = "euclidean",
  n_epochs = NULL,
  learning_rate = 1,
  scale = FALSE,
  init = "spectral",
  init_sdev = "range",
  spread = 1,
  min_dist = 0.1,
  set_op_mix_ratio = 1,
  local_connectivity = 1,
  bandwidth = 1,
  repulsion_strength = 1,
  negative_sample_rate = 5,
  a = NULL,
  b = NULL,
  nn_method = NULL,
  n_trees = 50,
  search_k = 2 * n_neighbors * n_trees,
  approx_pow = FALSE,
  y = NULL,
  target_n_neighbors = n_neighbors,
  target_metric = "euclidean",
  target_weight = 0.5,
  pca = NULL,
  pca_center = TRUE,
  pcg_rand = TRUE,
  fast_sgd = FALSE,
  ret_model = FALSE,
  ret_nn = FALSE,
  ret_extra = c(),
  n_threads = NULL,
  n_sgd_threads = 0,
  grain_size = 1,
  tmpdir = tempdir(),
  verbose = getOption("verbose", TRUE),
  batch = TRUE,
  opt_args = NULL,
  epoch_callback = NULL,
  pca_method = NULL,
  binary_edge_weights = FALSE,
  dens_scale = NULL,
  seed = NULL,
  nn_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="umap2_+3A_x">X</code></td>
<td>
<p>Input data. Can be a <code><a href="base.html#topic+data.frame">data.frame</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code> object or <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.
Matrix and data frames should contain one observation per row. Data frames
will have any non-numeric columns removed, although factor columns will be
used if explicitly included via <code>metric</code> (see the help for
<code>metric</code> for details). Sparse matrices must be in the <code>dgCMatrix</code>
format, and you must also install
<a href="https://cran.r-project.org/package=rnndescent">rnndescent</a>
and set <code>nn_method = "nndescent"</code>
<code>X</code> can also be <code>NULL</code> if pre-computed nearest neighbor data is
passed to <code>nn_method</code>, and <code>init</code> is not <code>"spca"</code> or
<code>"pca"</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>The size of local neighborhood (in terms of number of
neighboring sample points) used for manifold approximation. Larger values
result in more global views of the manifold, while smaller values result in
more local data being preserved. In general values should be in the range
<code>2</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_n_components">n_components</code></td>
<td>
<p>The dimension of the space to embed into. This defaults
to <code>2</code> to provide easy visualization, but can reasonably be set to any
integer value in the range <code>2</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_metric">metric</code></td>
<td>
<p>Type of distance metric to use to find nearest neighbors. For
<code>nn_method = "annoy"</code> this can be one of:
</p>

<ul>
<li> <p><code>"euclidean"</code> (the default)
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"manhattan"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"correlation"</code> (a distance based on the Pearson correlation)
</p>
</li>
<li> <p><code>"categorical"</code> (see below)
</p>
</li></ul>

<p>For <code>nn_method = "hnsw"</code> this can be one of:
</p>

<ul>
<li> <p><code>"euclidean"</code>
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"correlation"</code>
</p>
</li></ul>

<p>If <a href="https://cran.r-project.org/package=rnndescent">rnndescent</a> is
installed and <code>nn_method = "nndescent"</code> is specified then many more
metrics are avaiable, including:
</p>

<ul>
<li> <p><code>"braycurtis"</code>
</p>
</li>
<li> <p><code>"canberra"</code>
</p>
</li>
<li> <p><code>"chebyshev"</code>
</p>
</li>
<li> <p><code>"dice"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"hellinger"</code>
</p>
</li>
<li> <p><code>"jaccard"</code>
</p>
</li>
<li> <p><code>"jensenshannon"</code>
</p>
</li>
<li> <p><code>"kulsinski"</code>
</p>
</li>
<li> <p><code>"rogerstanimoto"</code>
</p>
</li>
<li> <p><code>"russellrao"</code>
</p>
</li>
<li> <p><code>"sokalmichener"</code>
</p>
</li>
<li> <p><code>"sokalsneath"</code>
</p>
</li>
<li> <p><code>"spearmanr"</code>
</p>
</li>
<li> <p><code>"symmetrickl"</code>
</p>
</li>
<li> <p><code>"tsss"</code>
</p>
</li>
<li> <p><code>"yule"</code>
</p>
</li></ul>

<p>For more details see the package documentation of <code>rnndescent</code>.
For <code>nn_method = "fnn"</code>, the distance metric is always &quot;euclidean&quot;.
</p>
<p>If <code>X</code> is a data frame or matrix, then multiple metrics can be
specified, by passing a list to this argument, where the name of each item in
the list is one of the metric names above. The value of each list item should
be a vector giving the names or integer ids of the columns to be included in
a calculation, e.g. <code>metric = list(euclidean = 1:4, manhattan = 5:10)</code>.
</p>
<p>Each metric calculation results in a separate fuzzy simplicial set, which are
intersected together to produce the final set. Metric names can be repeated.
Because non-numeric columns are removed from the data frame, it is safer to
use column names than integer ids.
</p>
<p>Factor columns can also be used by specifying the metric name
<code>"categorical"</code>. Factor columns are treated different from numeric
columns and although multiple factor columns can be specified in a vector,
each factor column specified is processed individually. If you specify
a non-factor column, it will be coerced to a factor.
</p>
<p>For a given data block, you may override the <code>pca</code> and <code>pca_center</code>
arguments for that block, by providing a list with one unnamed item
containing the column names or ids, and then any of the <code>pca</code> or
<code>pca_center</code> overrides as named items, e.g. <code>metric =
list(euclidean = 1:4, manhattan = list(5:10, pca_center = FALSE))</code>. This
exists to allow mixed binary and real-valued data to be included and to have
PCA applied to both, but with centering applied only to the real-valued data
(it is typical not to apply centering to binary data before PCA is applied).</p>
</td></tr>
<tr><td><code id="umap2_+3A_n_epochs">n_epochs</code></td>
<td>
<p>Number of epochs to use during the optimization of the
embedded coordinates. By default, this value is set to <code>500</code> for
datasets containing 10,000 vertices or less, and <code>200</code> otherwise.
If <code>n_epochs = 0</code>, then coordinates determined by <code>"init"</code> will
be returned.</p>
</td></tr>
<tr><td><code id="umap2_+3A_learning_rate">learning_rate</code></td>
<td>
<p>Initial learning rate used in optimization of the
coordinates.</p>
</td></tr>
<tr><td><code id="umap2_+3A_scale">scale</code></td>
<td>
<p>Scaling to apply to <code>X</code> if it is a data frame or matrix:
</p>

<ul>
<li><p><code>"none"</code> or <code>FALSE</code> or <code>NULL</code> No scaling.
</p>
</li>
<li><p><code>"Z"</code> or <code>"scale"</code> or <code>TRUE</code> Scale each column to
zero mean and variance 1.
</p>
</li>
<li><p><code>"maxabs"</code> Center each column to mean 0, then divide each
element by the maximum absolute value over the entire matrix.
</p>
</li>
<li><p><code>"range"</code> Range scale the entire matrix, so the smallest
element is 0 and the largest is 1.
</p>
</li>
<li><p><code>"colrange"</code> Scale each column in the range (0,1).
</p>
</li></ul>

<p>For UMAP, the default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_init">init</code></td>
<td>
<p>Type of initialization for the coordinates. Options are:
</p>

<ul>
<li> <p><code>"spectral"</code> Spectral embedding using the normalized Laplacian
of the fuzzy 1-skeleton, with Gaussian noise added.
</p>
</li>
<li> <p><code>"normlaplacian"</code>. Spectral embedding using the normalized
Laplacian of the fuzzy 1-skeleton, without noise.
</p>
</li>
<li> <p><code>"random"</code>. Coordinates assigned using a uniform random
distribution between -10 and 10.
</p>
</li>
<li> <p><code>"lvrandom"</code>. Coordinates assigned using a Gaussian
distribution with standard deviation 1e-4, as used in LargeVis
(Tang et al., 2016) and t-SNE.
</p>
</li>
<li> <p><code>"laplacian"</code>. Spectral embedding using the Laplacian Eigenmap
(Belkin and Niyogi, 2002).
</p>
</li>
<li> <p><code>"pca"</code>. The first two principal components from PCA of
<code>X</code> if <code>X</code> is a data frame, and from a 2-dimensional classical
MDS if <code>X</code> is of class <code>"dist"</code>.
</p>
</li>
<li> <p><code>"spca"</code>. Like <code>"pca"</code>, but each dimension is then scaled
so the standard deviation is 1e-4, to give a distribution similar to that
used in t-SNE. This is an alias for <code>init = "pca", init_sdev =
   1e-4</code>.
</p>
</li>
<li> <p><code>"agspectral"</code> An &quot;approximate global&quot; modification of
<code>"spectral"</code> which all edges in the graph to a value of 1, and then
sets a random number of edges (<code>negative_sample_rate</code> edges per
vertex) to 0.1, to approximate the effect of non-local affinities.
</p>
</li>
<li><p> A matrix of initial coordinates.
</p>
</li></ul>

<p>For spectral initializations, (<code>"spectral"</code>, <code>"normlaplacian"</code>,
<code>"laplacian"</code>, <code>"agspectral"</code>), if more than one connected
component is identified, no spectral initialization is attempted. Instead
a PCA-based initialization is attempted. If <code>verbose = TRUE</code> the
number of connected components are logged to the console. The existence of
multiple connected components implies that a global view of the data cannot
be attained with this initialization. Increasing the value of
<code>n_neighbors</code> may help.</p>
</td></tr>
<tr><td><code id="umap2_+3A_init_sdev">init_sdev</code></td>
<td>
<p>If non-<code>NULL</code>, scales each dimension of the initialized
coordinates (including any user-supplied matrix) to this standard
deviation. By default, (<code>init_sdev = "range"</code>), each column of the
initial coordinates are range scaled between 0-10. Scaling the input may
help if the unscaled versions result in initial coordinates with large
inter-point distances or outliers. This usually results in small gradients
during optimization and very little progress being made to the layout.
Shrinking the initial embedding by rescaling can help under these
circumstances. Scaling the result of <code>init = "pca"</code> is usually
recommended and <code>init = "spca"</code> as an alias for <code>init = "pca",
init_sdev = 1e-4</code> but for the spectral initializations the scaled versions
usually aren't necessary unless you are using a large value of
<code>n_neighbors</code> (e.g. <code>n_neighbors = 150</code> or higher).</p>
</td></tr>
<tr><td><code id="umap2_+3A_spread">spread</code></td>
<td>
<p>The effective scale of embedded points. In combination with
<code>min_dist</code>, this determines how clustered/clumped the embedded points
are.</p>
</td></tr>
<tr><td><code id="umap2_+3A_min_dist">min_dist</code></td>
<td>
<p>The effective minimum distance between embedded points.
Smaller values will result in a more clustered/clumped embedding where
nearby points on the manifold are drawn closer together, while larger
values will result on a more even dispersal of points. The value should be
set relative to the <code>spread</code> value, which determines the scale at
which embedded points will be spread out.</p>
</td></tr>
<tr><td><code id="umap2_+3A_set_op_mix_ratio">set_op_mix_ratio</code></td>
<td>
<p>Interpolate between (fuzzy) union and intersection as
the set operation used to combine local fuzzy simplicial sets to obtain a
global fuzzy simplicial sets. Both fuzzy set operations use the product
t-norm. The value of this parameter should be between <code>0.0</code> and
<code>1.0</code>; a value of <code>1.0</code> will use a pure fuzzy union, while
<code>0.0</code> will use a pure fuzzy intersection.</p>
</td></tr>
<tr><td><code id="umap2_+3A_local_connectivity">local_connectivity</code></td>
<td>
<p>The local connectivity required &ndash; i.e. the number
of nearest neighbors that should be assumed to be connected at a local
level. The higher this value the more connected the manifold becomes
locally. In practice this should be not more than the local intrinsic
dimension of the manifold.</p>
</td></tr>
<tr><td><code id="umap2_+3A_bandwidth">bandwidth</code></td>
<td>
<p>The effective bandwidth of the kernel if we view the
algorithm as similar to Laplacian Eigenmaps. Larger values induce more
connectivity and a more global view of the data, smaller values concentrate
more locally.</p>
</td></tr>
<tr><td><code id="umap2_+3A_repulsion_strength">repulsion_strength</code></td>
<td>
<p>Weighting applied to negative samples in low
dimensional embedding optimization. Values higher than one will result in
greater weight being given to negative samples.</p>
</td></tr>
<tr><td><code id="umap2_+3A_negative_sample_rate">negative_sample_rate</code></td>
<td>
<p>The number of negative edge/1-simplex samples to
use per positive edge/1-simplex sample in optimizing the low dimensional
embedding.</p>
</td></tr>
<tr><td><code id="umap2_+3A_a">a</code></td>
<td>
<p>More specific parameters controlling the embedding. If <code>NULL</code>
these values are set automatically as determined by <code>min_dist</code> and
<code>spread</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_b">b</code></td>
<td>
<p>More specific parameters controlling the embedding. If <code>NULL</code>
these values are set automatically as determined by <code>min_dist</code> and
<code>spread</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_nn_method">nn_method</code></td>
<td>
<p>Method for finding nearest neighbors. Options are:
</p>

<ul>
<li> <p><code>"fnn"</code>. Use exact nearest neighbors via the
<a href="https://cran.r-project.org/package=FNN">FNN</a> package.
</p>
</li>
<li> <p><code>"annoy"</code> Use approximate nearest neighbors via the
<a href="https://cran.r-project.org/package=RcppAnnoy">RcppAnnoy</a> package.
</p>
</li>
<li> <p><code>"hnsw"</code> Use approximate nearest neighbors with the
Hierarchical Navigable Small World (HNSW) method (Malkov and Yashunin,
2018) via the
<a href="https://cran.r-project.org/package=RcppHNSW">RcppHNSW</a> package.
<code>RcppHNSW</code> is not a dependency of this package: this option is
only available if you have installed <code>RcppHNSW</code> yourself. Also,
HNSW only supports the following arguments for <code>metric</code> and
<code>target_metric</code>: <code>"euclidean"</code>, <code>"cosine"</code> and
<code>"correlation"</code>.
</p>
</li>
<li> <p><code>"nndescent"</code> Use approximate nearest neighbors with the
Nearest Neighbor Descent method (Dong et al., 2011) via the
<a href="https://cran.r-project.org/package=rnndescent">rnndescent</a>
package. <code>rnndescent</code> is not a dependency of this package: this
option is only available if you have installed <code>rnndescent</code>
yourself.
</p>
</li></ul>

<p>By default, if <code>X</code> has less than 4,096 vertices, the exact nearest
neighbors are found. Otherwise, approximate nearest neighbors are used.
You may also pass pre-calculated nearest neighbor data to this argument. It
must be one of two formats, either a list consisting of two elements:
</p>

<ul>
<li> <p><code>"idx"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the integer indexes of the nearest neighbors in <code>X</code>. Each
vertex is considered to be its own nearest neighbor, i.e.
<code>idx[, 1] == 1:n_vertices</code>.
</p>
</li>
<li> <p><code>"dist"</code>. A <code>n_vertices x n_neighbors</code> matrix
containing the distances of the nearest neighbors.
</p>
</li></ul>

<p>or a sparse distance matrix of type <code>dgCMatrix</code>, with dimensions
<code>n_vertices x n_vertices</code>. Distances should be arranged by column,
i.e. a non-zero entry in row <code>j</code> of the <code>i</code>th column indicates
that the <code>j</code>th observation in <code>X</code> is a nearest neighbor of the
<code>i</code>th observation with the distance given by the value of that
element.
The <code>n_neighbors</code> parameter is ignored when using precomputed
nearest neighbor data. If using the sparse distance matrix input, each
column can contain a different number of neighbors.</p>
</td></tr>
<tr><td><code id="umap2_+3A_n_trees">n_trees</code></td>
<td>
<p>Number of trees to build when constructing the nearest
neighbor index. The more trees specified, the larger the index, but the
better the results. With <code>search_k</code>, determines the accuracy of the
Annoy nearest neighbor search. Only used if the <code>nn_method</code> is
<code>"annoy"</code>. Sensible values are between <code>10</code> to <code>100</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_search_k">search_k</code></td>
<td>
<p>Number of nodes to search during the neighbor retrieval. The
larger k, the more the accurate results, but the longer the search takes.
With <code>n_trees</code>, determines the accuracy of the Annoy nearest neighbor
search. Only used if the <code>nn_method</code> is <code>"annoy"</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_approx_pow">approx_pow</code></td>
<td>
<p>If <code>TRUE</code>, use an approximation to the power function
in the UMAP gradient, from
<a href="https://martin.ankerl.com/2012/01/25/optimized-approximative-pow-in-c-and-cpp/">https://martin.ankerl.com/2012/01/25/optimized-approximative-pow-in-c-and-cpp/</a>.
Ignored if <code>dens_scale</code> is non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_y">y</code></td>
<td>
<p>Optional target data for supervised dimension reduction. Can be a
vector, matrix or data frame. Use the <code>target_metric</code> parameter to
specify the metrics to use, using the same syntax as <code>metric</code>. Usually
either a single numeric or factor column is used, but more complex formats
are possible. The following types are allowed:
</p>

<ul>
<li><p> Factor columns with the same length as <code>X</code>. <code>NA</code> is
allowed for any observation with an unknown level, in which case
UMAP operates as a form of semi-supervised learning. Each column is
treated separately.
</p>
</li>
<li><p> Numeric data. <code>NA</code> is <em>not</em> allowed in this case. Use the
parameter <code>target_n_neighbors</code> to set the number of neighbors used
with <code>y</code>. If unset, <code>n_neighbors</code> is used. Unlike factors,
numeric columns are grouped into one block unless <code>target_metric</code>
specifies otherwise. For example, if you wish columns <code>a</code> and
<code>b</code> to be treated separately, specify
<code>target_metric = list(euclidean = "a", euclidean = "b")</code>. Otherwise,
the data will be effectively treated as a matrix with two columns.
</p>
</li>
<li><p> Nearest neighbor data, consisting of a list of two matrices,
<code>idx</code> and <code>dist</code>. These represent the precalculated nearest
neighbor indices and distances, respectively. This
is the same format as that expected for precalculated data in
<code>nn_method</code>. This format assumes that the underlying data was a
numeric vector. Any user-supplied value of the <code>target_n_neighbors</code>
parameter is ignored in this case, because the the number of columns in
the matrices is used for the value. Multiple nearest neighbor data using
different metrics can be supplied by passing a list of these lists.
</p>
</li></ul>

<p>Unlike <code>X</code>, all factor columns included in <code>y</code> are automatically
used.</p>
</td></tr>
<tr><td><code id="umap2_+3A_target_n_neighbors">target_n_neighbors</code></td>
<td>
<p>Number of nearest neighbors to use to construct the
target simplicial set. Default value is <code>n_neighbors</code>. Applies only if
<code>y</code> is non-<code>NULL</code> and <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_target_metric">target_metric</code></td>
<td>
<p>The metric used to measure distance for <code>y</code> if
using supervised dimension reduction. Used only if <code>y</code> is numeric.</p>
</td></tr>
<tr><td><code id="umap2_+3A_target_weight">target_weight</code></td>
<td>
<p>Weighting factor between data topology and target
topology. A value of 0.0 weights entirely on data, a value of 1.0 weights
entirely on target. The default of 0.5 balances the weighting equally
between data and target. Only applies if <code>y</code> is non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_pca">pca</code></td>
<td>
<p>If set to a positive integer value, reduce data to this number of
columns using PCA. Doesn't applied if the distance <code>metric</code> is
<code>"hamming"</code>, or the dimensions of the data is larger than the
number specified (i.e. number of rows and columns must be larger than the
value of this parameter). If you have &gt; 100 columns in a data frame or
matrix, reducing the number of columns in this way may substantially
increase the performance of the nearest neighbor search at the cost of a
potential decrease in accuracy. In many t-SNE applications, a value of 50
is recommended, although there's no guarantee that this is appropriate for
all settings.</p>
</td></tr>
<tr><td><code id="umap2_+3A_pca_center">pca_center</code></td>
<td>
<p>If <code>TRUE</code>, center the columns of <code>X</code> before
carrying out PCA. For binary data, it's recommended to set this to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_pcg_rand">pcg_rand</code></td>
<td>
<p>If <code>TRUE</code>, use the PCG random number generator (O'Neill,
2014) during optimization. Otherwise, use the faster (but probably less
statistically good) Tausworthe &quot;taus88&quot; generator. The default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_fast_sgd">fast_sgd</code></td>
<td>
<p>If <code>TRUE</code>, then the following combination of parameters
is set: <code>pcg_rand = TRUE</code>, <code>n_sgd_threads = "auto"</code> and
<code>approx_pow = TRUE</code>. The default is <code>FALSE</code>. Setting this to
<code>TRUE</code> will speed up the stochastic optimization phase, but give a
potentially less accurate embedding, and which will not be exactly
reproducible even with a fixed seed. For visualization, <code>fast_sgd =
TRUE</code> will give perfectly good results. For more generic dimensionality
reduction, it's safer to leave <code>fast_sgd = FALSE</code>. If <code>fast_sgd =
TRUE</code>, then user-supplied values of <code>pcg_rand</code>, <code>n_sgd_threads</code>,
and <code>approx_pow</code> are ignored.</p>
</td></tr>
<tr><td><code id="umap2_+3A_ret_model">ret_model</code></td>
<td>
<p>If <code>TRUE</code>, then return extra data that can be used to
add new data to an existing embedding via <code><a href="#topic+umap_transform">umap_transform</a></code>. The
embedded coordinates are returned as the list item <code>embedding</code>. If
<code>FALSE</code>, just return the coordinates. This parameter can be used in
conjunction with <code>ret_nn</code> and <code>ret_extra</code>. Note that some
settings are incompatible with the production of a UMAP model: external
neighbor data (passed via a list to <code>nn_method</code>), and factor columns
that were included via the <code>metric</code> parameter. In the latter case, the
model produced is based only on the numeric data. A transformation using
new data is possible, but the factor columns in the new data are ignored.
Note that setting <code>ret_model = TRUE</code> forces the use of the approximate
nearest neighbors method. Because small datasets would otherwise use exact
nearest neighbor calculations, setting <code>ret_model = TRUE</code> means that
different results may be returned for small datasets in terms of both the
returned nearest neighbors (if requested) and the final embedded
coordinates, compared to <code>ret_model = FALSE</code>, even if the random
number seed is fixed. To avoid this, explicitly set
<code>nn_method = "annoy"</code> in the <code>ret_model = FALSE</code> case.</p>
</td></tr>
<tr><td><code id="umap2_+3A_ret_nn">ret_nn</code></td>
<td>
<p>If <code>TRUE</code>, then in addition to the embedding, also return
nearest neighbor data that can be used as input to <code>nn_method</code> to
avoid the overhead of repeatedly calculating the nearest neighbors when
manipulating unrelated parameters (e.g. <code>min_dist</code>, <code>n_epochs</code>,
<code>init</code>). See the &quot;Value&quot; section for the names of the list items. If
<code>FALSE</code>, just return the coordinates. Note that the nearest neighbors
could be sensitive to data scaling, so be wary of reusing nearest neighbor
data if modifying the <code>scale</code> parameter. This parameter can be used in
conjunction with <code>ret_model</code> and <code>ret_extra</code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_ret_extra">ret_extra</code></td>
<td>
<p>A vector indicating what extra data to return. May contain
any combination of the following strings:
</p>

<ul>
<li> <p><code>"model"</code> Same as setting <code>ret_model = TRUE</code>.
</p>
</li>
<li> <p><code>"nn"</code> Same as setting <code>ret_nn = TRUE</code>.
</p>
</li>
<li> <p><code>"fgraph"</code> the high dimensional fuzzy graph (i.e. the fuzzy
simplicial set of the merged local views of the input data). The graph
is returned as a sparse symmetric N x N matrix of class
<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a>, where a non-zero entry (i, j) gives the
membership strength of the edge connecting vertex i and vertex j. This
can be considered analogous to the input probability (or similarity or
affinity) used in t-SNE and LargeVis. Note that the graph is further
sparsified by removing edges with sufficiently low membership strength
that they would not be sampled by the probabilistic edge sampling
employed for optimization and therefore the number of non-zero elements
in the matrix is dependent on <code>n_epochs</code>. If you are only
interested in the fuzzy input graph (e.g. for clustering), setting
<code>n_epochs = 0</code> will avoid any further sparsifying.
Be aware that setting 'binary_edge_weights = TRUE' will affect this
graph (all non-zero edge weights will be 1).
</p>
</li>
<li> <p><code>"sigma"</code> the normalization value for each observation in the
dataset when constructing the smoothed distances to each of its
neighbors. This gives some sense of the local density of each
observation in the high dimensional space: higher values of
<code>sigma</code> indicate a higher dispersion or lower density.
</p>
</li></ul>
</td></tr>
<tr><td><code id="umap2_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use (except during stochastic gradient
descent). Default is half the number of concurrent threads supported by the
system. For nearest neighbor search, only applies if
<code>nn_method = "annoy"</code>. If <code>n_threads &gt; 1</code>, then the Annoy index
will be temporarily written to disk in the location determined by
<code><a href="base.html#topic+tempfile">tempfile</a></code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_n_sgd_threads">n_sgd_threads</code></td>
<td>
<p>Number of threads to use during stochastic gradient
descent. If set to &gt; 1, then be aware that if <code>batch = FALSE</code>, results
will <em>not</em> be reproducible, even if <code>set.seed</code> is called with a
fixed seed before running. Set to <code>"auto"</code> to use the same value as
<code>n_threads</code>. Default is to use only one thread, unless
<code>batch = TRUE</code> in which case <code>"auto"</code> used.</p>
</td></tr>
<tr><td><code id="umap2_+3A_grain_size">grain_size</code></td>
<td>
<p>The minimum amount of work to do on each thread. If this
value is set high enough, then less than <code>n_threads</code> or
<code>n_sgd_threads</code> will be used for processing, which might give a
performance improvement if the overhead of thread management and context
switching was outweighing the improvement due to concurrent processing.
This should be left at default (<code>1</code>) and work will be spread evenly
over all the threads specified.</p>
</td></tr>
<tr><td><code id="umap2_+3A_tmpdir">tmpdir</code></td>
<td>
<p>Temporary directory to store nearest neighbor indexes during
nearest neighbor search. Default is <code><a href="base.html#topic+tempdir">tempdir</a></code>. The index is
only written to disk if <code>n_threads &gt; 1</code> and
<code>nn_method = "annoy"</code>; otherwise, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="umap2_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, log details to the console.</p>
</td></tr>
<tr><td><code id="umap2_+3A_batch">batch</code></td>
<td>
<p>If <code>TRUE</code>, then embedding coordinates are updated at the
end of each epoch rather than during the epoch. In batch mode, results are
reproducible with a fixed random seed even with <code>n_sgd_threads &gt; 1</code>,
at the cost of a slightly higher memory use. You may also have to modify
<code>learning_rate</code> and increase <code>n_epochs</code>, so whether this provides
a speed increase over the single-threaded optimization is likely to be
dataset and hardware-dependent.</p>
</td></tr>
<tr><td><code id="umap2_+3A_opt_args">opt_args</code></td>
<td>
<p>A list of optimizer parameters, used when
<code>batch = TRUE</code>. The default optimization method used is Adam (Kingma
and Ba, 2014).
</p>

<ul>
<li> <p><code>method</code> The optimization method to use. Either <code>"adam"</code>
or <code>"sgd"</code> (stochastic gradient descent). Default: <code>"adam"</code>.
</p>
</li>
<li> <p><code>beta1</code> (Adam only). The weighting parameter for the
exponential moving average of the first moment estimator. Effectively the
momentum parameter. Should be a floating point value between 0 and 1.
Higher values can smooth oscillatory updates in poorly-conditioned
situations and may allow for a larger <code>learning_rate</code> to be
specified, but too high can cause divergence. Default: <code>0.5</code>.
</p>
</li>
<li> <p><code>beta2</code> (Adam only). The weighting parameter for the
exponential moving average of the uncentered second moment estimator.
Should be a floating point value between 0 and 1. Controls the degree of
adaptivity in the step-size. Higher values put more weight on previous
time steps. Default: <code>0.9</code>.
</p>
</li>
<li> <p><code>eps</code> (Adam only). Intended to be a small value to prevent
division by zero, but in practice can also affect convergence due to its
interaction with <code>beta2</code>. Higher values reduce the effect of the
step-size adaptivity and bring the behavior closer to stochastic gradient
descent with momentum. Typical values are between 1e-8 and 1e-3. Default:
<code>1e-7</code>.
</p>
</li>
<li> <p><code>alpha</code> The initial learning rate. Default: the value of the
<code>learning_rate</code> parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="umap2_+3A_epoch_callback">epoch_callback</code></td>
<td>
<p>A function which will be invoked at the end of every
epoch. Its signature should be: <code>(epoch, n_epochs, coords)</code>, where:
</p>

<ul>
<li> <p><code>epoch</code> The current epoch number (between <code>1</code> and
<code>n_epochs</code>).
</p>
</li>
<li> <p><code>n_epochs</code> Number of epochs to use during the optimization of
the embedded coordinates.
</p>
</li>
<li> <p><code>coords</code> The embedded coordinates as of the end of the current
epoch, as a matrix with dimensions (N, <code>n_components</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="umap2_+3A_pca_method">pca_method</code></td>
<td>
<p>Method to carry out any PCA dimensionality reduction when
the <code>pca</code> parameter is specified. Allowed values are:
</p>

<ul>
<li><p><code>"irlba"</code>. Uses <code><a href="irlba.html#topic+prcomp_irlba">prcomp_irlba</a></code> from the
<a href="https://cran.r-project.org/package=irlba">irlba</a> package.
</p>
</li>
<li><p><code>"rsvd"</code>. Uses 5 iterations of <code><a href="irlba.html#topic+svdr">svdr</a></code> from
the <a href="https://cran.r-project.org/package=irlba">irlba</a> package.
This is likely to give much faster but potentially less accurate results
than using <code>"irlba"</code>. For the purposes of nearest neighbor
calculation and coordinates initialization, any loss of accuracy doesn't
seem to matter much.
</p>
</li>
<li><p><code>"bigstatsr"</code>. Uses <code><a href="bigstatsr.html#topic+big_randomSVD">big_randomSVD</a></code>
from the <a href="https://cran.r-project.org/package=bigstatsr">bigstatsr</a>
package. The SVD methods used in <code>bigstatsr</code> may be faster on
systems without access to efficient linear algebra libraries (e.g.
Windows). <strong>Note</strong>: <code>bigstatsr</code> is <em>not</em> a dependency of
uwot: if you choose to use this package for PCA, you <em>must</em> install
it yourself.
</p>
</li>
<li><p><code>"svd"</code>. Uses <code><a href="base.html#topic+svd">svd</a></code> for the SVD. This is
likely to be slow for all but the smallest datasets.
</p>
</li>
<li><p><code>"auto"</code> (the default). Uses <code>"irlba"</code>, unless more than
50
case <code>"svd"</code> is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="umap2_+3A_binary_edge_weights">binary_edge_weights</code></td>
<td>
<p>If <code>TRUE</code> then edge weights in the input
graph are treated as binary (0/1) rather than real valued. This affects the
sampling frequency of neighbors and is the strategy used by the PaCMAP
method (Wang and co-workers, 2020). Practical (Böhm and co-workers, 2020)
and theoretical (Damrich and Hamprecht, 2021) work suggests this has little
effect on UMAP's performance.</p>
</td></tr>
<tr><td><code id="umap2_+3A_dens_scale">dens_scale</code></td>
<td>
<p>A value between 0 and 1. If &gt; 0 then the output attempts
to preserve relative local density around each observation. This uses an
approximation to the densMAP method (Narayan and co-workers, 2021). The
larger the value of <code>dens_scale</code>, the greater the range of output
densities that will be used to map the input densities. This option is
ignored if using multiple <code>metric</code> blocks.</p>
</td></tr>
<tr><td><code id="umap2_+3A_seed">seed</code></td>
<td>
<p>Integer seed to use to initialize the random number generator
state. Combined with <code>n_sgd_threads = 1</code> or <code>batch = TRUE</code>, this
should give consistent output across multiple runs on a given installation.
Setting this value is equivalent to calling <code><a href="base.html#topic+set.seed">set.seed</a></code>,
but it may be more convenient in some situations than having to call a
separate function. The default is to not set a seed. If
<code>ret_model = TRUE</code>, the seed will be stored in the output model and
then used to set the seed inside <code><a href="#topic+umap_transform">umap_transform</a></code>.</p>
</td></tr>
<tr><td><code id="umap2_+3A_nn_args">nn_args</code></td>
<td>
<p>A list containing additional arguments to pass to the nearest
neighbor method. For <code>nn_method = "annoy"</code>, you can specify
<code>"n_trees"</code> and <code>"search_k"</code>, and these will override the
<code>n_trees</code> and <code>search_k</code> parameters.
For <code>nn_method = "hnsw"</code>, you may specify the following arguments:
</p>

<ul>
<li> <p><code>M</code> The maximum number of neighbors to keep for each vertex.
Reasonable values are <code>2</code> to <code>100</code>. Higher values give better
recall at the cost of more memory. Default value is <code>16</code>.
</p>
</li>
<li> <p><code>ef_construction</code> A positive integer specifying the size of
the dynamic list used during index construction. A higher value will
provide better results at the cost of a longer time to build the index.
Default is <code>200</code>.
</p>
</li>
<li> <p><code>ef</code> A positive integer specifying the size of the dynamic
list used during search. This cannot be smaller than <code>n_neighbors</code>
and cannot be higher than the number of items in the index. Default is
<code>10</code>.
</p>
</li></ul>

<p>For <code>nn_method = "nndescent"</code>, you may specify the following
arguments:
</p>

<ul>
<li> <p><code>n_trees</code> The number of trees to use in a random projection
forest to initialize the search. A larger number will give more accurate
results at the cost of a longer computation time. The default of
<code>NULL</code> means that the number is chosen based on the number of
observations in <code>X</code>.
</p>
</li>
<li> <p><code>max_candidates</code> The number of potential neighbors to explore
per iteration. By default, this is set to <code>n_neighbors</code> or <code>60</code>,
whichever is smaller. A larger number will give more accurate results at
the cost of a longer computation time.
</p>
</li>
<li> <p><code>n_iters</code> The number of iterations to run the search. A larger
number will give more accurate results at the cost of a longer computation
time. By default, this will be chosen based on the number of observations
in <code>X</code>. You may also need to modify the convergence criterion
<code>delta</code>.
</p>
</li>
<li> <p><code>delta</code> The minimum relative change in the neighbor graph
allowed before early stopping. Should be a value between 0 and 1. The
smaller the value, the smaller the amount of progress between iterations is
allowed. Default value of <code>0.001</code> means that at least 0.1
neighbor graph must be updated at each iteration.
</p>
</li>
<li> <p><code>init</code> How to initialize the nearest neighbor descent. By
default this is set to <code>"tree"</code> and uses a random project forest.
If you set this to <code>"rand"</code>, then a random selection is used. Usually
this is less accurate than using RP trees, but for high-dimensional cases,
there may be little difference in the quality of the initialization and
random initialization will be a lot faster. If you set this to
<code>"rand"</code>, then the <code>n_trees</code> parameter is ignored.
</p>
</li>
<li> <p><code>pruning_degree_multiplier</code> The maximum number of edges per node
to retain in the search graph, relative to <code>n_neighbors</code>. A larger
value will give more accurate results at the cost of a longer computation
time. Default is <code>1.5</code>. This parameter only affects neighbor search
when transforming new data with <code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li>
<li> <p><code>epsilon</code> Controls the degree of the back-tracking when
traversing the search graph. Setting this to <code>0.0</code> will do a greedy
search with no back-tracking. A larger value will give more accurate
results at the cost of a longer computation time. Default is <code>0.1</code>.
This parameter only affects neighbor search when transforming new data with
<code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li>
<li> <p><code>max_search_fraction</code> Specifies the maximum fraction of the
search graph to traverse. By default, this is set to <code>1.0</code>, so the
entire graph (i.e. all items in <code>X</code>) may be visited. You may want to
set this to a smaller value if you have a very large dataset (in
conjunction with <code>epsilon</code>) to avoid an inefficient exhaustive search
of the data in <code>X</code>. This parameter only affects neighbor search when
transforming new data with <code><a href="#topic+umap_transform">umap_transform</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function behaves like <code><a href="#topic+umap">umap</a></code> except with some updated
defaults that make it behave more like the Python implementation and which
cannot be added to <code><a href="#topic+umap">umap</a></code> without breaking backwards
compatibility. In addition:
</p>

<ul>
<li><p> if <a href="https://cran.r-project.org/package=RcppHNSW">RcppHNSW</a> is
installed, it will be used in preference to Annoy if a compatible metric
is requested.
</p>
</li>
<li><p> if RcppHNSW is not present, but
<a href="https://cran.r-project.org/package=rnndescent">rnndescent</a> is
installed, it will be used in preference to Annoy if a compatible metric
is requested.
</p>
</li>
<li><p> if <code>batch = TRUE</code> then the default <code>n_sgd_threads</code> is set
to the same value as <code>n_threads</code>.
</p>
</li>
<li><p> if the input data <code>X</code> is a sparse matrix, it is interpreted
similarly to a dense matrix or dataframe, and not as a distance matrix.
This requires <code>rnndescent</code> package to be installed.
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix of optimized coordinates, or:
</p>

<ul>
<li><p> if <code>ret_model = TRUE</code> (or <code>ret_extra</code> contains
<code>"model"</code>), returns a list containing extra information that can be
used to add new data to an existing embedding via
<code><a href="#topic+umap_transform">umap_transform</a></code>. In this case, the coordinates are available
in the list item <code>embedding</code>. <b>NOTE</b>: The contents of
the <code>model</code> list should <em>not</em> be considered stable or part of
the public API, and are purposely left undocumented.
</p>
</li>
<li><p> if <code>ret_nn = TRUE</code> (or <code>ret_extra</code> contains <code>"nn"</code>),
returns the nearest neighbor data as a list called <code>nn</code>. This
contains one list for each <code>metric</code> calculated, itself containing a
matrix <code>idx</code> with the integer ids of the neighbors; and a matrix
<code>dist</code> with the distances. The <code>nn</code> list (or a sub-list) can be
used as input to the <code>nn_method</code> parameter.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"fgraph"</code>, returns the high
dimensional fuzzy graph as a sparse matrix called <code>fgraph</code>, of type
<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a>.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"sigma"</code>, returns a vector of the
smooth knn distance normalization terms for each observation as
<code>"sigma"</code> and a vector <code>"rho"</code> containing the largest
distance to the locally connected neighbors of each observation.
</p>
</li>
<li><p> if <code>ret_extra</code> contains <code>"localr"</code>, returns a vector of
the estimated local radii, the sum of <code>"sigma"</code> and <code>"rho"</code>.
</p>
</li></ul>

<p>The returned list contains the combined data from any combination of
specifying <code>ret_model</code>, <code>ret_nn</code> and <code>ret_extra</code>.
</p>


<h3>References</h3>

<p>Belkin, M., &amp; Niyogi, P. (2002).
Laplacian eigenmaps and spectral techniques for embedding and clustering.
In <em>Advances in neural information processing systems</em>
(pp. 585-591).
<a href="http://papers.nips.cc/paper/1961-laplacian-eigenmaps-and-spectral-techniques-for-embedding-and-clustering.pdf">http://papers.nips.cc/paper/1961-laplacian-eigenmaps-and-spectral-techniques-for-embedding-and-clustering.pdf</a>
</p>
<p>Böhm, J. N., Berens, P., &amp; Kobak, D. (2020).
A unifying perspective on neighbor embeddings along the attraction-repulsion spectrum.
<em>arXiv preprint</em> <em>arXiv:2007.08902</em>.
<a href="https://arxiv.org/abs/2007.08902">https://arxiv.org/abs/2007.08902</a>
</p>
<p>Damrich, S., &amp; Hamprecht, F. A. (2021).
On UMAP's true loss function.
<em>Advances in Neural Information Processing Systems</em>, <em>34</em>.
<a href="https://proceedings.neurips.cc/paper/2021/hash/2de5d16682c3c35007e4e92982f1a2ba-Abstract.html">https://proceedings.neurips.cc/paper/2021/hash/2de5d16682c3c35007e4e92982f1a2ba-Abstract.html</a>
</p>
<p>Dong, W., Moses, C., &amp; Li, K. (2011, March).
Efficient k-nearest neighbor graph construction for generic similarity measures.
In <em>Proceedings of the 20th international conference on World Wide Web</em>
(pp. 577-586).
ACM.
<a href="https://doi.org/10.1145/1963405.1963487">doi:10.1145/1963405.1963487</a>.
</p>
<p>Kingma, D. P., &amp; Ba, J. (2014).
Adam: A method for stochastic optimization.
<em>arXiv preprint</em> <em>arXiv</em>:1412.6980.
<a href="https://arxiv.org/abs/1412.6980">https://arxiv.org/abs/1412.6980</a>
</p>
<p>Malkov, Y. A., &amp; Yashunin, D. A. (2018).
Efficient and robust approximate nearest neighbor search using hierarchical
navigable small world graphs.
<em>IEEE transactions on pattern analysis and machine intelligence</em>, <em>42</em>(4), 824-836.
</p>
<p>McInnes, L., Healy, J., &amp; Melville, J. (2018).
UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction
<em>arXiv preprint</em> <em>arXiv</em>:1802.03426.
<a href="https://arxiv.org/abs/1802.03426">https://arxiv.org/abs/1802.03426</a>
</p>
<p>Narayan, A., Berger, B., &amp; Cho, H. (2021).
Assessing single-cell transcriptomic variability through density-preserving data visualization.
<em>Nature biotechnology</em>, <em>39</em>(6), 765-774.
<a href="https://doi.org/10.1038/s41587-020-00801-7">doi:10.1038/s41587-020-00801-7</a>
</p>
<p>O’Neill, M. E. (2014).
<em>PCG: A family of simple fast space-efficient statistically good
algorithms for random number generation</em>
(Report No. HMC-CS-2014-0905). Harvey Mudd College.
</p>
<p>Tang, J., Liu, J., Zhang, M., &amp; Mei, Q. (2016, April).
Visualizing large-scale and high-dimensional data.
In <em>Proceedings of the 25th International Conference on World Wide Web</em>
(pp. 287-297).
International World Wide Web Conferences Steering Committee.
<a href="https://arxiv.org/abs/1602.00370">https://arxiv.org/abs/1602.00370</a>
</p>
<p>Van der Maaten, L., &amp; Hinton, G. (2008).
Visualizing data using t-SNE.
<em>Journal of Machine Learning Research</em>, <em>9</em> (2579-2605).
<a href="https://www.jmlr.org/papers/v9/vandermaaten08a.html">https://www.jmlr.org/papers/v9/vandermaaten08a.html</a>
</p>
<p>Wang, Y., Huang, H., Rudin, C., &amp; Shaposhnik, Y. (2021).
Understanding How Dimension Reduction Tools Work: An Empirical Approach to Deciphering t-SNE, UMAP, TriMap, and PaCMAP for Data Visualization.
<em>Journal of Machine Learning Research</em>, <em>22</em>(201), 1-73.
<a href="https://www.jmlr.org/papers/v22/20-1061.html">https://www.jmlr.org/papers/v22/20-1061.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris30 &lt;- iris[c(1:10, 51:60, 101:110), ]
iris_umap &lt;- umap2(iris30, n_neighbors = 5)

</code></pre>

<hr>
<h2 id='unload_uwot'>Unload a Model</h2><span id='topic+unload_uwot'></span>

<h3>Description</h3>

<p>Unloads the UMAP model. This prevents the model being used with
<code><a href="#topic+umap_transform">umap_transform</a></code>, but allows the temporary working directory
associated with saving or loading the model to be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unload_uwot(model, cleanup = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unload_uwot_+3A_model">model</code></td>
<td>
<p>a UMAP model create by <code><a href="#topic+umap">umap</a></code>.</p>
</td></tr>
<tr><td><code id="unload_uwot_+3A_cleanup">cleanup</code></td>
<td>
<p>if <code>TRUE</code>, attempt to delete the temporary working
directory that was used in either the save or load of the model.</p>
</td></tr>
<tr><td><code id="unload_uwot_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, log information to the console.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+save_uwot">save_uwot</a></code>, <code><a href="#topic+load_uwot">load_uwot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris_train &lt;- iris[c(1:10, 51:60), ]
iris_test &lt;- iris[100:110, ]

# create model
model &lt;- umap(iris_train, ret_model = TRUE, n_epochs = 20)

# save without unloading: this leaves behind a temporary working directory
model_file &lt;- tempfile("iris_umap")
model &lt;- save_uwot(model, file = model_file)

# The model can continue to be used
test_embedding &lt;- umap_transform(iris_test, model)

# To manually unload the model from memory when finished and to clean up
# the working directory (this doesn't touch your model file)
unload_uwot(model)

# At this point, model cannot be used with umap_transform, this would fail:
# test_embedding2 &lt;- umap_transform(iris_test, model)

# restore the model: this also creates a temporary working directory
model2 &lt;- load_uwot(file = model_file)
test_embedding2 &lt;- umap_transform(iris_test, model2)

# Unload and clean up the loaded model temp directory
unload_uwot(model2)

# clean up the model file
unlink(model_file)

# save with unloading: this deletes the temporary working directory but
# doesn't allow the model to be re-used
model3 &lt;- umap(iris_train, ret_model = TRUE, n_epochs = 20)
model_file3 &lt;- tempfile("iris_umap")
model3 &lt;- save_uwot(model3, file = model_file3, unload = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
