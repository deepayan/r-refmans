<!DOCTYPE html><html><head><title>Help for package igcop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {igcop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.onUnload'><p>Clean up DLL</p></a></li>
<li><a href='#.u'><p>Test data</p></a></li>
<li><a href='#check_alpha'><p>Check validity of copula parameters</p></a></li>
<li><a href='#dig_vec'><p>Select IG copula quantities: matching inputs</p></a></li>
<li><a href='#formals_to'><p>Send arguments to a function after vectorizing</p></a></li>
<li><a href='#igcop'><p>igcop: Computational Tools for the IG and IGL Copula Families</p></a></li>
<li><a href='#igl_gen_vec'><p>IG/IGL Generators and Related Functions: matching inputs</p></a></li>
<li><a href='#interp_gen_inv'><p>IG/IGL Generators and Related Functions</p></a></li>
<li><a href='#pcondig21'><p>IG Copula Family Functions</p></a></li>
<li><a href='#qcondigl'><p>IGL Copula Family Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Computational Tools for the IG and IGL Copula Families</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute distributional quantities for an
    Integrated Gamma (IG) or Integrated Gamma Limit (IGL) copula, such
    as a cdf and density. Compute corresponding conditional quantities
    such as the cdf and quantiles. Generate
    data from an IG or IGL copula. See the vignette for formulas,
    or for a derivation, see Coia, V (2017) "Forecasting of Nonlinear 
    Extreme Quantiles Using Copula Models." PhD Dissertation, 
    The University of British Columbia.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, tibble, covr, ggplot2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, vctrs, Rcpp, rlang</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-14 05:51:02 UTC; vcoia</td>
</tr>
<tr>
<td>Author:</td>
<td>Vincenzo Coia [aut, cre],
  Harry Joe [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vincenzo Coia &lt;vincenzo.coia@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-14 12:43:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='.onUnload'>Clean up DLL</h2><span id='topic+.onUnload'></span>

<h3>Description</h3>

<p>As recommended in the &quot;Compiled Code&quot; chapter of the book
&quot;R packages&quot; (Version 2) by Hadley Wickham and Jenny Bryan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onUnload(libpath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onUnload_+3A_libpath">libpath</code></td>
<td>
<p>Argument</p>
</td></tr>
</table>

<hr>
<h2 id='.u'>Test data</h2><span id='topic+.u'></span><span id='topic+.v'></span><span id='topic+.cpar'></span><span id='topic+.theta'></span><span id='topic+.alpha'></span>

<h3>Description</h3>

<p>Internal data used in the test scripts. <code>.u</code> and <code>.v</code> are vectors of
matching length containing values between 0 and 1 and reasonably cover
the unit square. <code>.cpar</code> is a list of IG copula parameter pairs
<code>c(theta, alpha)</code>, and <code>.theta</code> and <code>.alpha</code> are the corresponding
(unique) individual values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.u

.v

.cpar

.theta

.alpha
</code></pre>


<h3>Format</h3>

<p>Everything is a numeric vector, except <code>.cpar</code>, which is a list
of bivariate numeric vectors. <code>.u</code> and <code>.v</code> are of matching
length; the rest are not intended to have matching lengths.
</p>
<p>An object of class <code>numeric</code> of length 17.
</p>
<p>An object of class <code>list</code> of length 25.
</p>
<p>An object of class <code>numeric</code> of length 14.
</p>
<p>An object of class <code>numeric</code> of length 11.
</p>

<hr>
<h2 id='check_alpha'>Check validity of copula parameters</h2><span id='topic+check_alpha'></span><span id='topic+check_theta'></span>

<h3>Description</h3>

<p>Ensures input values are non-negative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_alpha(alpha)

check_theta(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_alpha_+3A_alpha">alpha</code></td>
<td>
<p>Values of alpha to check.</p>
</td></tr>
<tr><td><code id="check_alpha_+3A_theta">theta</code></td>
<td>
<p>Values of theta to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error if any theta or alpha is negative;
an invisible value otherwise. <code>NA</code> values do not throw an error.
</p>

<hr>
<h2 id='dig_vec'>Select IG copula quantities: matching inputs</h2><span id='topic+dig_vec'></span><span id='topic+pcondig12_vec'></span><span id='topic+qcondig12_vec'></span>

<h3>Description</h3>

<p>The density function, 1|2 conditional cdf,
and 1|2 conditional quantile function of the IG
copula family. Inputs
need to be vectors of the same length.
These functions are called by the R functions of the
same name, without the <code style="white-space: pre;">&#8288;_vec&#8288;</code> suffix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig_vec(u, v, theta, alpha)

pcondig12_vec(u, v, theta, alpha)

qcondig12_vec(p, v, theta, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dig_vec_+3A_u">u</code>, <code id="dig_vec_+3A_v">v</code></td>
<td>
<p>Copula arguments. Vector of values between 0 and 1.</p>
</td></tr>
<tr><td><code id="dig_vec_+3A_theta">theta</code>, <code id="dig_vec_+3A_alpha">alpha</code></td>
<td>
<p>IG copula parameters. Vector of positive values.</p>
</td></tr>
<tr><td><code id="dig_vec_+3A_p">p</code></td>
<td>
<p>Function inverse argument. Vector of values between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>qcondig12()</code> function needs its own Newton
Raphson algorithm. It also needs access to some version
of <code>pcondig12()</code> and <code>dig()</code>. So, these three functions
are coded up in C++, each with a scalar and vector pair
of functions.
</p>


<h3>Note</h3>

<p>If calling these functions manually, make sure each input
are vectors of a common length.
</p>


<h3>See Also</h3>

<p><code>dig()</code>, <code>pcondig12()</code>, and <code>qcondig12()</code>;
and <code>igl_gen_vec()</code> and family.
</p>

<hr>
<h2 id='formals_to'>Send arguments to a function after vectorizing</h2><span id='topic+formals_to'></span>

<h3>Description</h3>

<p>When used within a (encapsulating) function, <code>formals_to</code>
recycles the inputs of the encapsulating function so that
they are vectors of the same length, and then sends these
updated arguments to some specified function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formals_to(.fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formals_to_+3A_.fn">.fn</code></td>
<td>
<p>The function you want to send the recycled arguments to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>.fn</code> evaluated with the arguments given in
the encapsulating function.
</p>

<hr>
<h2 id='igcop'>igcop: Computational Tools for the IG and IGL Copula Families</h2><span id='topic+igcop'></span><span id='topic+igcop-package'></span>

<h3>Description</h3>

<p>Compute distributional quantities for an
Integrated Gamma (IG) or IG Limit (IGL) copula, such
as a cdf and density, along with conditional quantities
such as the cdf, quantiles, and densities. Generate
data from a copula.
</p>


<h3>Usage</h3>

<p>Access copula quantities by starting with the <code>p</code>, <code>d</code>, <code>q</code>, or <code>r</code>
prefixes, followed by the copula name &ndash; either <code>ig</code> or <code>igl</code>, or
their conditional versions, <code>condig</code> or <code>condigl</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Vincenzo Coia <a href="mailto:vincenzo.coia@gmail.com">vincenzo.coia@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Harry Joe
</p>
</li></ul>


<hr>
<h2 id='igl_gen_vec'>IG/IGL Generators and Related Functions: matching inputs</h2><span id='topic+igl_gen_vec'></span><span id='topic+igl_gen_D_vec'></span><span id='topic+igl_gen_inv_vec'></span><span id='topic+igl_kappa_vec'></span><span id='topic+igl_kappa_D_vec'></span><span id='topic+igl_kappa_inv_vec'></span><span id='topic+interp_gen_vec'></span><span id='topic+interp_gen_inv_vec'></span><span id='topic+interp_kappa_vec'></span><span id='topic+interp_kappa_inv_vec'></span>

<h3>Description</h3>

<p>These are the psi, H, and kappa functions
of the IG and IGL copula families, but with inputs
needing to be vectors of the same length.
These functions are called by the R functions of the
same name, without the <code style="white-space: pre;">&#8288;_vec&#8288;</code> suffix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igl_gen_vec(x, alpha)

igl_gen_D_vec(x, alpha)

igl_gen_inv_vec(p, alpha)

igl_kappa_vec(x, alpha)

igl_kappa_D_vec(x, alpha)

igl_kappa_inv_vec(p, alpha)

interp_gen_vec(x, eta, alpha)

interp_gen_inv_vec(p, eta, alpha)

interp_kappa_vec(x, eta, alpha)

interp_kappa_inv_vec(p, eta, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igl_gen_vec_+3A_x">x</code></td>
<td>
<p>Function argument. Vector of non-negative values.</p>
</td></tr>
<tr><td><code id="igl_gen_vec_+3A_p">p</code></td>
<td>
<p>Function inverse argument. Vector of values between 0 and 1.</p>
</td></tr>
<tr><td><code id="igl_gen_vec_+3A_eta">eta</code>, <code id="igl_gen_vec_+3A_alpha">alpha</code></td>
<td>
<p>Function parameters. Vector of positive values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If calling this function manually, make sure each input
are vectors of a common length.
</p>


<h3>See Also</h3>

<p><code>igl_gen()</code> and family;
<code>dig_vec()</code>, <code>pcondig12_vec()</code>, and <code>qcondig12_vec()</code>.
</p>

<hr>
<h2 id='interp_gen_inv'>IG/IGL Generators and Related Functions</h2><span id='topic+interp_gen_inv'></span><span id='topic+interp_kappa'></span><span id='topic+interp_kappa_inv'></span><span id='topic+interp_gen'></span><span id='topic+igl_kappa'></span><span id='topic+igl_kappa_D'></span><span id='topic+igl_kappa_inv'></span><span id='topic+igl_gen'></span><span id='topic+igl_gen_D'></span><span id='topic+igl_gen_inv'></span>

<h3>Description</h3>

<p>These are the psi, H, and kappa functions
of the IG and IGL copula families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp_gen_inv(p, eta, alpha)

interp_kappa(x, eta, alpha)

interp_kappa_inv(p, eta, alpha)

interp_gen(x, eta, alpha)

igl_kappa(x, alpha)

igl_kappa_D(x, alpha)

igl_kappa_inv(p, alpha)

igl_gen(x, alpha)

igl_gen_D(x, alpha)

igl_gen_inv(p, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interp_gen_inv_+3A_p">p</code></td>
<td>
<p>Function inverse argument. Vector of values between 0 and 1.</p>
</td></tr>
<tr><td><code id="interp_gen_inv_+3A_eta">eta</code>, <code id="interp_gen_inv_+3A_alpha">alpha</code></td>
<td>
<p>Function parameters. Vector of positive values.</p>
</td></tr>
<tr><td><code id="interp_gen_inv_+3A_x">x</code></td>
<td>
<p>Function argument. Vector of non-negative values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kappa function and its relatives have prefix <code>igl_kappa</code>;
Psi function and its relatives have prefix <code>igl_gen</code>;
Interpolating function H with either kappa or psi has
<code>igl</code> prefix replaced with <code>interp</code>. Relatives of these functions:
suffix <code>inv</code> indicates inverse; suffix <code>D</code> represents function
derivative, and <code>D1</code> derivative with respect to the first argument.
. Suffix <code style="white-space: pre;">&#8288;_vec&#8288;</code> indicates that the entries must be vectors of
the same length; <code style="white-space: pre;">&#8288;_single&#8288;</code> means entries must be
scalars.
</p>


<h3>Value</h3>

<p>The function values, as a vector.
</p>


<h3>Note</h3>

<p>Inputs must be recyclable via <code>vctrs::vec_recycle_common()</code>.
</p>

<hr>
<h2 id='pcondig21'>IG Copula Family Functions</h2><span id='topic+pcondig21'></span><span id='topic+qcondig21'></span><span id='topic+qcondig'></span><span id='topic+pcondig'></span><span id='topic+pcondig12'></span><span id='topic+qcondig12'></span><span id='topic+dig'></span><span id='topic+logdig'></span><span id='topic+pig'></span><span id='topic+rig'></span>

<h3>Description</h3>

<p>Functions related to the IG copula family, denoted  by <code>'ig'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcondig21(v, u, theta, alpha)

qcondig21(p, u, theta, alpha)

qcondig(p, u, theta, alpha)

pcondig(v, u, theta, alpha)

pcondig12(u, v, theta, alpha)

qcondig12(p, v, theta, alpha)

dig(u, v, theta, alpha)

logdig(u, v, theta, alpha)

pig(u, v, theta, alpha)

rig(n, theta, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcondig21_+3A_u">u</code>, <code id="pcondig21_+3A_v">v</code></td>
<td>
<p>Vectors of values between 0 and 1 representing values of the first
and second copula variables.</p>
</td></tr>
<tr><td><code id="pcondig21_+3A_theta">theta</code></td>
<td>
<p>Parameter of the IG copula family. Vectorized; &gt;0.</p>
</td></tr>
<tr><td><code id="pcondig21_+3A_alpha">alpha</code></td>
<td>
<p>Parameter of the IG copula family. Vectorized; &gt;0.</p>
</td></tr>
<tr><td><code id="pcondig21_+3A_p">p</code></td>
<td>
<p>Vector of quantile levels between 0 and 1
to evaluate a quantile function at.</p>
</td></tr>
<tr><td><code id="pcondig21_+3A_n">n</code></td>
<td>
<p>Positive integer. Number of observations to randomly draw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length equal to the length of the input vector(s).
</p>


<h3>Note</h3>

<p>Inputting two vectors greater than length 1 is allowed, if they're
the same length.
Also, <code>qcondig21</code> and <code>pcondig21</code> are the same as
<code>qcondig</code> and <code>pcondig</code> &ndash; they're the distributions of
variable 2 given 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- runif(10)
v &lt;- runif(10)
pig(u, v, theta = 5, alpha = 1)
dig(u, v, theta = 2, alpha = 2)
logdig(u, v, theta = 2, alpha = 2)
pcondig21(v, u, theta = 3, alpha = 6)
qcondig21(v, u, theta = 3, alpha = 6)
pcondig12(u, v, theta = 3, alpha = 6)
qcondig12(u, v, theta = 3, alpha = 6)
rig(10, theta = 3, alpha = 3)

# log density available for extra precision
log(dig(0.1, 0.1, 2.5, 12.3)) == logdig(0.1, 0.1, 2.5, 12.3)
</code></pre>

<hr>
<h2 id='qcondigl'>IGL Copula Family Functions</h2><span id='topic+qcondigl'></span><span id='topic+pcondigl'></span><span id='topic+qcondigl21'></span><span id='topic+pcondigl21'></span><span id='topic+pcondigl12'></span><span id='topic+qcondigl12'></span><span id='topic+digl'></span><span id='topic+pigl'></span><span id='topic+rigl'></span><span id='topic+logdigl'></span>

<h3>Description</h3>

<p>Functions related to the IGL copula family, denoted  by <code>'igl'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcondigl(p, u, alpha)

pcondigl(v, u, alpha)

qcondigl21(p, u, alpha)

pcondigl21(v, u, alpha)

pcondigl12(u, v, alpha)

qcondigl12(p, v, alpha)

digl(u, v, alpha)

pigl(u, v, alpha)

rigl(n, alpha)

logdigl(u, v, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qcondigl_+3A_p">p</code></td>
<td>
<p>Vector of quantile levels between 0 and 1 to
evaluate a quantile function at.</p>
</td></tr>
<tr><td><code id="qcondigl_+3A_u">u</code>, <code id="qcondigl_+3A_v">v</code></td>
<td>
<p>Vectors of values between 0 and 1 representing values of the first
and second copula variables.</p>
</td></tr>
<tr><td><code id="qcondigl_+3A_alpha">alpha</code></td>
<td>
<p>Single numeric &gt;0; corresponds to parameter <code>alpha</code> in the
IGL copula family.</p>
</td></tr>
<tr><td><code id="qcondigl_+3A_n">n</code></td>
<td>
<p>Positive integer. Number of observations to randomly draw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length equal to the length of the input vector(s).
</p>


<h3>Note</h3>

<p>Inputting two vectors greater than length 1 is allowed, if they're
the same length.
Also, <code>qcondigl21</code> and <code>pcondigl21</code> are the same as
<code>qcondigl</code> and <code>pcondigl</code> &ndash; they are the distributions of
variable 2 given 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
u &lt;- runif(10)
v &lt;- runif(10)
pigl(u, v, alpha = 1)
digl(u, v, alpha = 2)
logdigl(u, v, alpha = 0.4)
pcondigl21(v, u, alpha = 6)
qcondigl21(v, u, alpha = 6)
pcondigl12(u, v, alpha = 6)
qcondigl12(u, v, alpha = 6)
rigl(10, alpha = 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
