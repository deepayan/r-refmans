<!DOCTYPE html><html lang="en"><head><title>Help for package spbal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spbal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BAS'><p>Balanced Acceptance Sampling (BAS).</p></a></li>
<li><a href='#BoundingBox'><p>Create a bounding box for a study region.</p></a></li>
<li><a href='#contains_feature'><p>Check if the sf object contains a specified feature.</p></a></li>
<li><a href='#cppBASpts'><p>Generate numbers from a Halton Sequence.</p></a></li>
<li><a href='#cppBASptsIndexed'><p>Generate numbers from a Halton Sequence along a specified set of indices.</p></a></li>
<li><a href='#cppRSHalton_br'><p>Generate numbers from a Halton Sequence with a random start</p></a></li>
<li><a href='#filterOnDistance'><p>Filter sample using a minimum distance.</p></a></li>
<li><a href='#findFirstStudyRegionPoint'><p>Get a randomly chosen Halton point from within the study area and the associated seeds.</p></a></li>
<li><a href='#generateUVector'><p>Generate a vector of two random seeds.</p></a></li>
<li><a href='#getBASSample'><p>Generate the BAS sample.</p></a></li>
<li><a href='#getBASSampleDriver'><p>Manage BAS sampling.</p></a></li>
<li><a href='#getHaltonFrame'><p>Obtain a Halton Frame over a shapefile.</p></a></li>
<li><a href='#getHaltonPointsFromExpandableGrid'><p>Generate a Halton frame.</p></a></li>
<li><a href='#getPanel'><p>Extract all points with a specified panel id from a sample.</p></a></li>
<li><a href='#getSample'><p>Extract a sample of a specified size from a master sample.</p></a></li>
<li><a href='#HaltonFrame'><p>Create a Halton Frame.</p></a></li>
<li><a href='#HaltonFrameBase'><p>Generate a Halton Frame.</p></a></li>
<li><a href='#HIP'><p>Halton Iterative Partitioning (HIP).</p></a></li>
<li><a href='#hipIndexRandomPermutation'><p>Permute Halton indices.</p></a></li>
<li><a href='#hipPartition'><p>Partition the population.</p></a></li>
<li><a href='#hipX1split'><p>First dimension split.</p></a></li>
<li><a href='#hipX2split'><p>Second dimension split.</p></a></li>
<li><a href='#is_sf_points'><p>Check if an object is an sf points object.</p></a></li>
<li><a href='#log_a_to_base_b'><p>Compute the log of a to base b.</p></a></li>
<li><a href='#mod'><p>Vector modulus.</p></a></li>
<li><a href='#PanelDesignAssignPanelids'><p>Assign panel ids to the samples.</p></a></li>
<li><a href='#removeDuplicates'><p>Remove duplicate values from a NumericVector.</p></a></li>
<li><a href='#rot'><p>Generate a rotation matrix for rotating objects later.</p></a></li>
<li><a href='#rotate.scale.coords'><p>Scale and rotate points from the unit square to a defined projection.</p></a></li>
<li><a href='#setBASIndex'><p>Finds a set of Halton indices that will create BAS points within a shape bounding box.</p></a></li>
<li><a href='#SRS'><p>Simple random sampling.</p></a></li>
<li><a href='#validate_parameters'><p>Validate spbal function parameters.</p></a></li>
<li><a href='#ValidatePanelDesign'><p>Validate the panels and panel_overlap parameters.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatially Balanced Sampling Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Encapsulates a number of spatially balanced sampling algorithms,
    namely, Balanced Acceptance Sampling (equal, unequal, seed point, panels), Halton frames 
    (for discretizing a continuous resource), Halton Iterative Partitioning (equal probability) 
    and Simple Random Sampling.
    Robertson, B. L., Brown, J. A., McDonald, T. and Jaksons, P. (2013) &lt;<a href="https://doi.org/10.1111%2Fbiom.12059">doi:10.1111/biom.12059</a>&gt;.
    Robertson, B. L., McDonald, T., Price, C. J. and Brown, J. A. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.spl.2017.05.004">doi:10.1016/j.spl.2017.05.004</a>&gt;.
    Robertson, B. L., McDonald, T., Price, C. J. and Brown, J. A. (2018) &lt;<a href="https://doi.org/10.1007%2Fs10651-018-0406-6">doi:10.1007/s10651-018-0406-6</a>&gt;.
    Robertson, B. L., van Dam-Bates, P. and Gansell, O. (2021a) &lt;<a href="https://doi.org/10.1007%2Fs10651-020-00481-1">doi:10.1007/s10651-020-00481-1</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>units, sf, Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), bookdown, ggplot2,
gridExtra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppThread</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-17 11:27:33 UTC; phil</td>
</tr>
<tr>
<td>Author:</td>
<td>Phil Davies [aut, cre],
  Blair Robertson [aut],
  Paul van Dam-Bates [aut],
  Oliver Gansell [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Phil Davies &lt;philip.davies@canterbury.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-17 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BAS'>Balanced Acceptance Sampling (BAS).</h2><span id='topic+BAS'></span>

<h3>Description</h3>

<p>BAS draws spatially balanced samples from areal resources. To draw BAS samples,
spbal requires a study region shapefile and the regionâ€™s bounding box. An initial sample size
is also needed, which can be easily increased or decreased within spbal for master sampling
applications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BAS(
  shapefile = NULL,
  n = 100,
  boundingbox = NULL,
  minRadius = NULL,
  panels = NULL,
  panel_overlap = NULL,
  stratum = NULL,
  seeds = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BAS_+3A_shapefile">shapefile</code></td>
<td>
<p>Shape file as a polygon (sp or sf) to select sites for.</p>
</td></tr>
<tr><td><code id="BAS_+3A_n">n</code></td>
<td>
<p>Number of sites to select. If using stratification it is a named vector containing
sample sizes of each group.</p>
</td></tr>
<tr><td><code id="BAS_+3A_boundingbox">boundingbox</code></td>
<td>
<p>Bounding box around the study area. If a bounding box is not supplied
then spbal will generate a bounding box for the shapefile.</p>
</td></tr>
<tr><td><code id="BAS_+3A_minradius">minRadius</code></td>
<td>
<p>If specified, the minimum distance, in meters, allowed between sample
points. This is applied to the $sample points. Points that meet the minRadius criteria
are retuned in the minRadius output variable.</p>
</td></tr>
<tr><td><code id="BAS_+3A_panels">panels</code></td>
<td>
<p>A list of integers that define the size of each panel in a
non-overlapping panels design. The length of the list determines the number of
panels required. The sum of the integers in the panels parameter will determine
the total number of samples selected, n. The default value for panels is NULL,
this indicates that a non-overlapping panel design is not wanted.</p>
</td></tr>
<tr><td><code id="BAS_+3A_panel_overlap">panel_overlap</code></td>
<td>
<p>A list of integers that define the overlap into the previous
panel. Is only used when the panels parameter is not NULL. The default value for
panel_overlap is NULL. The length of panel_overlap must be equal to the length
of panels. The first value is always forced to zero as the first panel never
overlaps any region.</p>
</td></tr>
<tr><td><code id="BAS_+3A_stratum">stratum</code></td>
<td>
<p>The name of a column in the data.frame attached to shapefile that defines
the strata of interest.</p>
</td></tr>
<tr><td><code id="BAS_+3A_seeds">seeds</code></td>
<td>
<p>A vector of 2 seeds, u1 and u2. If not specified, the default is NULL and will
be defined randomly using function <code>generateUVector</code>.</p>
</td></tr>
<tr><td><code id="BAS_+3A_verbose">verbose</code></td>
<td>
<p>Boolean if you want to see any output printed to screen. Helpful if taking a
long time. Default is FALSE i.e. no informational messages are displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three variables, <code>$sample</code> containing locations in the BAS sample,
in BAS order, <code>$seeds</code>, the u1 and u2 seeds used to generate the sample and <code>$minRadius</code>
containing points from $sample that meet the minRadius criteria. If the minRadius
parameter is NULL then the $minRadius returned will also be NULL.
</p>
<p>The sample points are returned in the form of a simple feature collection of POINT objects.
They have the following attributes:
</p>

<ul>
<li> <p><code>SiteID</code> A unique identifier for every sample point. This
encodes the BAS order.
</p>
</li>
<li> <p><code>spbalSeqID</code> A unique identifier for every sample point. This
encodes the BAS sample order.
</p>
</li>
<li> <p><code>geometry</code> The XY co-ordinates of the sample point in the CRS of the original
shapefile.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>This function was first written by Paul van Dam-Bates for the
package BASMasterSample and later simplified by Phil Davies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Equal probability BAS sample ----------------------------------------------

# Use the North Carolina shapefile supplied in the sf R package.
shp_file &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"))
shp_gates &lt;- shp_file[shp_file$NAME == "Gates",]

# Vertically aligned master sample bounding box.
bb &lt;- spbal::BoundingBox(shapefile = shp_gates)

set.seed(511)
n_samples &lt;- 20
# Equal probability BAS sample.
result &lt;- spbal::BAS(shapefile = shp_gates,
                     n = n_samples,
                     boundingbox = bb)
BAS20 &lt;- result$sample
# display first three sample points.
BAS20[1:3,]

# Increase the BAS sample size ----------------------------------------------
n_samples &lt;- 50
result2 &lt;- spbal::BAS(shapefile = shp_gates,
                      n = n_samples,
                      boundingbox = bb,
                      seeds = result$seed)
BAS50 &lt;- result2$sample
BAS50[1:3,]

# Check, first n_samples points in both samples must be the same.
all.equal(BAS20$geometry, BAS50$geometry[1:20])

</code></pre>

<hr>
<h2 id='BoundingBox'>Create a bounding box for a study region.</h2><span id='topic+BoundingBox'></span>

<h3>Description</h3>

<p>Randomly generate a seed from 10,000 possible values in right now 2 dimensions.
Note that in van Dam-Bates et al. (2018) we required that the random seed falls into main
object shape, such as one of the islands in New Zealand, or within marine environment for
BC west coast. However, with a random rotation, we are able to ignore that detail. If this
function is used without a random rotation, we recommend running it until
the first master sample point does indeed fall within the largest scale of the master sample use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoundingBox(shapefile, d = 2, rotate = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BoundingBox_+3A_shapefile">shapefile</code></td>
<td>
<p>Spatial feature that defines the boundary of the area to define a bounding
box over.</p>
</td></tr>
<tr><td><code id="BoundingBox_+3A_d">d</code></td>
<td>
<p>Dimension of the new Master Sample, at this stage we only work with d=2.</p>
</td></tr>
<tr><td><code id="BoundingBox_+3A_rotate">rotate</code></td>
<td>
<p>Boolean of whether or not to randomly rotate the bounding box. This parameter
is not supported at this time.</p>
</td></tr>
<tr><td><code id="BoundingBox_+3A_verbose">verbose</code></td>
<td>
<p>Print the rotation and random seed when it is generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bounding box for a study area.
</p>


<h3>Author(s)</h3>

<p>This function was first written by Paul van Dam-Bates for the
package BASMasterSample and later ported to this package, spbal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a bounding box for the Gates, North Carolina study area -------------
# Use the North Carolina shapefile supplied in the sf R package.
shp_file &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"))
shp_gates &lt;- shp_file[shp_file$NAME == "Gates",]
# Vertically aligned master sample bounding box.
bb &lt;- spbal::BoundingBox(shapefile = shp_gates)
bb

</code></pre>

<hr>
<h2 id='contains_feature'>Check if the sf object contains a specified feature.</h2><span id='topic+contains_feature'></span>

<h3>Description</h3>

<p>Used to check if a simple file object contains a feature. This
is an internal only function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contains_feature(sf_object, feature_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contains_feature_+3A_sf_object">sf_object</code></td>
<td>
<p>Simple file object that we want to verify if it contains
a feature called feature_name.</p>
</td></tr>
<tr><td><code id="contains_feature_+3A_feature_name">feature_name</code></td>
<td>
<p>The feature name we want to find in the simple file
object sf_object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if the simple file object sf_object contains the feature
feature_name. Otherwise FALSE is returned.
</p>


<h3>Author(s)</h3>

<p>Phil Davies.
</p>

<hr>
<h2 id='cppBASpts'>Generate numbers from a Halton Sequence.</h2><span id='topic+cppBASpts'></span>

<h3>Description</h3>

<p>For efficiency, this function can generate points along a random start
Halton Sequence for a predefined Halton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cppBASpts(
  n = 10L,
  seeds = as.integer(c()),
  bases = as.numeric(c()),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cppBASpts_+3A_n">n</code></td>
<td>
<p>Number of points required.</p>
</td></tr>
<tr><td><code id="cppBASpts_+3A_seeds">seeds</code></td>
<td>
<p>Random starting point in each dimension.</p>
</td></tr>
<tr><td><code id="cppBASpts_+3A_bases">bases</code></td>
<td>
<p>Co-prime base for the Halton Sequence.</p>
</td></tr>
<tr><td><code id="cppBASpts_+3A_verbose">verbose</code></td>
<td>
<p>A boolean indicating whether informational messages are to be issued.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with the columns, order of points, x in [0,1) and y in [0,1)
</p>


<h3>Author(s)</h3>

<p>This function was first written in R by Blair Robertson, subsequently it was
re-written in C/C++ by Phil Davies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First 10 points in the Halton Sequence for base 2,3
spbal::cppBASpts(n = 10)
# First 10 points in the Halton Sequence for base 2,3 with
# starting point at the 15th and 22nd index.
spbal::cppBASpts(n = 10, seeds = c(14, 21))

</code></pre>

<hr>
<h2 id='cppBASptsIndexed'>Generate numbers from a Halton Sequence along a specified set of indices.</h2><span id='topic+cppBASptsIndexed'></span>

<h3>Description</h3>

<p>For efficiency, this function can generate points along a random start
Halton Sequence for a predefined set of indices away from the seed.
When boxes are provided it will calculate the Halton Sequence only
at those boxes and not along the entire sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cppBASptsIndexed(
  n = 10L,
  seeds = as.integer(c()),
  bases = as.numeric(c()),
  boxes = as.integer(c()),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cppBASptsIndexed_+3A_n">n</code></td>
<td>
<p>Number of points required.</p>
</td></tr>
<tr><td><code id="cppBASptsIndexed_+3A_seeds">seeds</code></td>
<td>
<p>Random starting point in each dimension.</p>
</td></tr>
<tr><td><code id="cppBASptsIndexed_+3A_bases">bases</code></td>
<td>
<p>Co-prime base for the Halton Sequence.</p>
</td></tr>
<tr><td><code id="cppBASptsIndexed_+3A_boxes">boxes</code></td>
<td>
<p>Integer vector of indices to sample along the Halton sequence (default 1:n).</p>
</td></tr>
<tr><td><code id="cppBASptsIndexed_+3A_verbose">verbose</code></td>
<td>
<p>A boolean indicating whether informational messages are to be issued.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When not all points along the Halton sequence are required, this function efficiently generates the points
that are needed along a sequence. Taking all points from the random seed equates to boxes = 1:n. However, taking
advantage of how the Halton Sequence repeats itself by B = prod(base^J), where $J$ is an integer. We can also select
every Bth box to efficiently generate values at specific locations along the sequence. This reduces future computation
when bounding boxes are large in comparison to the polygon being sampled.
</p>


<h3>Value</h3>

<p>Matrix with the columns, order of points, x in [0,1) and y in [0,1)
</p>


<h3>Author(s)</h3>

<p>Phil Davies, Paul van Dam-Bates, Blair Robertson.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First 10 points in the Halton Sequence for base 2,3
spbal::cppBASptsIndexed(n = 10)
# First 10 points in the Halton Sequence for base 2,3 with
# starting point at the 15th and 22nd index.
spbal::cppBASptsIndexed(n = 10, seeds = c(14, 21))

</code></pre>

<hr>
<h2 id='cppRSHalton_br'>Generate numbers from a Halton Sequence with a random start</h2><span id='topic+cppRSHalton_br'></span>

<h3>Description</h3>

<p>For efficiency, this function can generate points along a random start
Halton Sequence for a predefined Halton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cppRSHalton_br(
  n = 10L,
  bases = as.numeric(c()),
  seeds = as.numeric(c()),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cppRSHalton_br_+3A_n">n</code></td>
<td>
<p>Number of points required</p>
</td></tr>
<tr><td><code id="cppRSHalton_br_+3A_bases">bases</code></td>
<td>
<p>Co-prime base for the Halton Sequence</p>
</td></tr>
<tr><td><code id="cppRSHalton_br_+3A_seeds">seeds</code></td>
<td>
<p>Random starting point in each dimension</p>
</td></tr>
<tr><td><code id="cppRSHalton_br_+3A_verbose">verbose</code></td>
<td>
<p>A boolean indicating whether informational messages are to be issued.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with the columns, order of point, x in [0,1) and y in [0,1).
</p>


<h3>Author(s)</h3>

<p>This function was first written in R by Blair Robertson, subsequently it was written
in C/C++ by Phil Davies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First 10 points in the Halton Sequence for base 2,3
 spbal::cppRSHalton_br(n = 10)
# First 10 points in the Halton Sequence for base 2,3 with
# starting point at the 15th and 22nd index.
 spbal::cppRSHalton_br(n = 10, seeds = c(14, 21))

</code></pre>

<hr>
<h2 id='filterOnDistance'>Filter sample using a minimum distance.</h2><span id='topic+filterOnDistance'></span>

<h3>Description</h3>

<p>The input parameter minRadius &gt;= 0 is the minimum distance between any two
points in the sample. My idea is to apply this condition to the points in the over-sample,
result$overSample. Let's call these points x1, x2, ..., xB. Create a new set S = (x1).
Starting from x1, we check if dist(S,x2) &gt; minRadius. If it is, add x2 to S. For x3, we check
if dist(S,x3) &gt; minRadius, where dist is the smallest distance from a point in S to x3
(single linkage distance). If dist(S,x3) &gt; minRadius, add x3 to S. Continue until you reach xB.
</p>
<p>The distances are calculated as great circles over an oblate spheroid and the units are meters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterOnDistance(overSample, minRadius)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterOnDistance_+3A_oversample">overSample</code></td>
<td>
<p>A HIP sample.</p>
</td></tr>
<tr><td><code id="filterOnDistance_+3A_minradius">minRadius</code></td>
<td>
<p>The minimum distance between any two points in the sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Key points:
</p>

<ul>
<li> <p><code>result$minRadius</code> is nonempty (it always contains x1). Hence, if the user chooses a crazy minRadius, they get one point.
</p>
</li>
<li> <p><code>result$minRadius</code> is a subset of result$overSample.
</p>
</li>
<li><p> The number of points in result$minRadius is random. That's fine!
</p>
</li>
<li><p> If they want n points and result$minRadius has less than n, too bad! They can reduce minRadius and/or increase the iterations parameter.
</p>
</li>
<li><p> If they want a sample with the minimum radius property, they use:
</p>

<ul>
<li> <p><code>smp &lt;- result$minRadius</code>
</p>
</li>
<li> <p><code>sample &lt;- smp[1:n,]</code>
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>S The set of points that are more than minRadius from each other.
</p>


<h3>Author(s)</h3>

<p>Phil Davies.
</p>

<hr>
<h2 id='findFirstStudyRegionPoint'>Get a randomly chosen Halton point from within the study area and the associated seeds.</h2><span id='topic+findFirstStudyRegionPoint'></span>

<h3>Description</h3>

<p>This function repeatedly calls function spbal::getBASSample
to generate the Halton frame sample. This function selects the first point at random from those
points in the study area. This point and the seeds used to generate the sample are returned to
the caller.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFirstStudyRegionPoint(shapefile, bb, seeds, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findFirstStudyRegionPoint_+3A_shapefile">shapefile</code></td>
<td>
<p>Shape file as a polygon (sp or sf) of the study area(s).</p>
</td></tr>
<tr><td><code id="findFirstStudyRegionPoint_+3A_bb">bb</code></td>
<td>
<p>Bounding box which defines the Master Sample. A bounding box must be
supplied.</p>
</td></tr>
<tr><td><code id="findFirstStudyRegionPoint_+3A_seeds">seeds</code></td>
<td>
<p>A vector of 2 seeds, u1 and u2. If not specified, the default is NULL and will
be defined randomly using function <code>generateUVector</code>.</p>
</td></tr>
<tr><td><code id="findFirstStudyRegionPoint_+3A_verbose">verbose</code></td>
<td>
<p>Boolean if you want to see any output printed to screen. Helpful if taking a
long time. Default is FALSE i.e. no informational messages are displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three variables:
</p>

<ul>
<li> <p><code>seeds</code> The u1 and u2 seeds used to generate the first point.
</p>
</li>
<li> <p><code>k</code> The index of the first point in the initial sample.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>This function was written by Phil Davies.
</p>

<hr>
<h2 id='generateUVector'>Generate a vector of two random seeds.</h2><span id='topic+generateUVector'></span>

<h3>Description</h3>

<p>This function generates two seeds, u1 and u2, in the range 0 to 2^11 and 0 to 3^7
respectively. These are returned to the caller in the form of a vector. This is for internal
use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateUVector()
</code></pre>


<h3>Value</h3>

<p>A vector containing two seeds, u1 and u2.
</p>


<h3>Author(s)</h3>

<p>Phil Davies.
</p>

<hr>
<h2 id='getBASSample'>Generate the BAS sample.</h2><span id='topic+getBASSample'></span>

<h3>Description</h3>

<p>This function is repeatedly called from function spbal::getBASSampleDriver
to generate a BAS sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBASSample(shapefile, bb, n, seeds, boxes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBASSample_+3A_shapefile">shapefile</code></td>
<td>
<p>Shape file as a polygon (sp or sf) to select sites for.</p>
</td></tr>
<tr><td><code id="getBASSample_+3A_bb">bb</code></td>
<td>
<p>Bounding box which defines the area around the study area. A bounding box must be
supplied.</p>
</td></tr>
<tr><td><code id="getBASSample_+3A_n">n</code></td>
<td>
<p>Number of sites to select. If using stratification it is a named vector containing
sample sizes of each group.</p>
</td></tr>
<tr><td><code id="getBASSample_+3A_seeds">seeds</code></td>
<td>
<p>A vector of 2 seeds, u1 and u2. seeds must have a value when this function is called.</p>
</td></tr>
<tr><td><code id="getBASSample_+3A_boxes">boxes</code></td>
<td>
<p>A vector of integers for which points along the Halton random starting point to sample from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two variables, <code>$sample</code> containing locations in the BAS sample,
in BAS order and <code>$seeds</code>, the u1 and u2 seeds used to generate the sample.
</p>


<h3>Author(s)</h3>

<p>This function was written by Phil Davies.
</p>

<hr>
<h2 id='getBASSampleDriver'>Manage BAS sampling.</h2><span id='topic+getBASSampleDriver'></span>

<h3>Description</h3>

<p>This function repeatedly calls function spbal::getBASSample to generate the BAS
sample. Once the requested number of points within the intersection of the shapefile and the
study area have been obtained, the sample and seeds are returned to the caller.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBASSampleDriver(shapefile, bb, n, seeds, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBASSampleDriver_+3A_shapefile">shapefile</code></td>
<td>
<p>sf shape file as a polygon to select sites from.</p>
</td></tr>
<tr><td><code id="getBASSampleDriver_+3A_bb">bb</code></td>
<td>
<p>Bounding box which defines the area around the study area. A bounding box must be
supplied.</p>
</td></tr>
<tr><td><code id="getBASSampleDriver_+3A_n">n</code></td>
<td>
<p>Number of sites to select. If using stratification it is a named vector containing
sample sizes of each group.</p>
</td></tr>
<tr><td><code id="getBASSampleDriver_+3A_seeds">seeds</code></td>
<td>
<p>A vector of 2 seeds, u1 and u2. If not specified, the default is NULL and will
be defined randomly.</p>
</td></tr>
<tr><td><code id="getBASSampleDriver_+3A_verbose">verbose</code></td>
<td>
<p>Boolean if you want to see any output printed to screen. Helpful if taking a
long time. Default is FALSE i.e. no informational messages are displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two variables, <code>$sample</code> containing locations in the BAS sample,
in BAS order and <code>$seeds</code>, the u1 and u2 seeds used to generate the sample.
</p>


<h3>Author(s)</h3>

<p>This function was written by Phil Davies based on origin code by Paul van Dam-Bates
from the BASMasterSample package.
</p>

<hr>
<h2 id='getHaltonFrame'>Obtain a Halton Frame over a shapefile.</h2><span id='topic+getHaltonFrame'></span>

<h3>Description</h3>

<p>An internal only function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHaltonFrame(shapefile, J, i, bases, seeds, crs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHaltonFrame_+3A_shapefile">shapefile</code></td>
<td>
<p>A MULTIPOINT or POINT object that we want to generate a halton frame for.</p>
</td></tr>
<tr><td><code id="getHaltonFrame_+3A_j">J</code></td>
<td>
<p>The number of grid cells. A list of 2 values.</p>
</td></tr>
<tr><td><code id="getHaltonFrame_+3A_i">i</code></td>
<td>
<p>An integer to add to the J parameter elements to expand the Halton Frame in both
directions if the required number of sample points cannot be found in the region of interest
in the current Halton frame.</p>
</td></tr>
<tr><td><code id="getHaltonFrame_+3A_bases">bases</code></td>
<td>
<p>Co-prime base for the Halton Sequence.</p>
</td></tr>
<tr><td><code id="getHaltonFrame_+3A_seeds">seeds</code></td>
<td>
<p>A list of 2 seeds, u1 and u2.</p>
</td></tr>
<tr><td><code id="getHaltonFrame_+3A_crs">crs</code></td>
<td>
<p>Coordinate reference system for the shapefile.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was written by Phil Davies.
</p>


<h3>Value</h3>

<p>A list containing the following variables: hf_, sample, pts.shp, bb.new, seeds
</p>

<hr>
<h2 id='getHaltonPointsFromExpandableGrid'>Generate a Halton frame.</h2><span id='topic+getHaltonPointsFromExpandableGrid'></span>

<h3>Description</h3>

<p>Find the requested number of Halton points from within a study area using the
supplied J and seeds parameters. If the number of points are not found on the first attempt,
the frame is expanded, and spbal::getHaltonFrame is called again. This process is repeated
until the requested number of points are found. The points and the seeds used to generate
the sample are returned to the caller.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHaltonPointsFromExpandableGrid(
  shapefile,
  N,
  J = base::c(4, 3),
  bases,
  seeds,
  crs,
  verbose = FALSE,
  stratify_found_first = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHaltonPointsFromExpandableGrid_+3A_shapefile">shapefile</code></td>
<td>
<p>Shape file as a polygon (sp or sf) of the study area(s).</p>
</td></tr>
<tr><td><code id="getHaltonPointsFromExpandableGrid_+3A_n">N</code></td>
<td>
<p>Number of sites to select. If using stratification it is a named vector containing
sample sizes of each group.</p>
</td></tr>
<tr><td><code id="getHaltonPointsFromExpandableGrid_+3A_j">J</code></td>
<td>
<p>The number of grid cells. A list of 2 values. The default value is c(3, 2).</p>
</td></tr>
<tr><td><code id="getHaltonPointsFromExpandableGrid_+3A_bases">bases</code></td>
<td>
<p>Co-prime base for the Halton Sequence. The default value is c(2, 3).</p>
</td></tr>
<tr><td><code id="getHaltonPointsFromExpandableGrid_+3A_seeds">seeds</code></td>
<td>
<p>A vector of 2 seeds, u1 and u2.</p>
</td></tr>
<tr><td><code id="getHaltonPointsFromExpandableGrid_+3A_crs">crs</code></td>
<td>
<p>Coordinate reference system for the shapefile.</p>
</td></tr>
<tr><td><code id="getHaltonPointsFromExpandableGrid_+3A_verbose">verbose</code></td>
<td>
<p>Boolean if you want to see any output printed to screen. Helpful if taking a
long time. Default is FALSE i.e. no informational messages are displayed.</p>
</td></tr>
<tr><td><code id="getHaltonPointsFromExpandableGrid_+3A_stratify_found_first">stratify_found_first</code></td>
<td>
<p>A flag to indicate whether we have found the first point in the
study region or not. Default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing five variables:
</p>

<ul>
<li> <p><code>i</code> The index of the first point chosen at random in the study area.
</p>
</li>
<li> <p><code>diff_</code> Halton points, the intersection of the bounding box and the study area.
</p>
</li>
<li> <p><code>pts.shp</code> Halton frame, the sample points within the study area.
</p>
</li>
<li> <p><code>bb.new</code> The bounding box.
</p>
</li>
<li> <p><code>seeds</code> The u1 and u2 seeds used to generate the sample.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Phil Davies.
</p>

<hr>
<h2 id='getPanel'>Extract all points with a specified panel id from a sample.</h2><span id='topic+getPanel'></span>

<h3>Description</h3>

<p>This is the main function for selecting sites using the BAS master
sample. It assumes that you have already defined the master sample using the
BoundingBox() function or will be selecting a marine master sample site in BC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPanel(shapefile, panelid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPanel_+3A_shapefile">shapefile</code></td>
<td>
<p>Shape file as a polygon (sp or sf) containing a sample that
contains a feature column named panel_id.</p>
</td></tr>
<tr><td><code id="getPanel_+3A_panelid">panelid</code></td>
<td>
<p>The overlapped panel in the shapefile shp the user wants
sample points from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sample for the specified panel.
</p>


<h3>Author(s)</h3>

<p>Phil Davies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Halton frame overlapping panel design showing use of getPanel.

# Use the North Carolina shapefile supplied in the sf R package.
shp_file &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"))
shp_gates &lt;- shp_file[shp_file$NAME == "Gates",]

# Vertically aligned master sample bounding box.
bb &lt;- spbal::BoundingBox(shapefile = shp_gates)

# Three panels, of 20 samples each.
panels &lt;- c(20, 20, 20)

# second panel overlaps first panel by 5, and third panel
# overlaps second panel by 5.
panel_overlap &lt;- c(0, 5, 5)

# generate the sample.
samp &lt;- spbal::HaltonFrame(J = c(4, 3),
                           boundingbox = bb,
                           panels = panels,
                           panel_overlap = panel_overlap,
                           shapefile = shp_gates)

# get halton frame data from our sample.
samp3 &lt;- samp$hf.pts.shp
samp3

panelid &lt;- 1
olPanel_1 &lt;- spbal::getPanel(samp3, panelid)

</code></pre>

<hr>
<h2 id='getSample'>Extract a sample of a specified size from a master sample.</h2><span id='topic+getSample'></span>

<h3>Description</h3>

<p>A description of this useful function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSample(shapefile, n, randomStart = FALSE, strata = NULL, stratum = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSample_+3A_shapefile">shapefile</code></td>
<td>
<p>A MULTIPOINT or POINT object from where to take the sample.</p>
</td></tr>
<tr><td><code id="getSample_+3A_n">n</code></td>
<td>
<p>The number of sample points to return.</p>
</td></tr>
<tr><td><code id="getSample_+3A_randomstart">randomStart</code></td>
<td>
<p>Whether a spatially balanced sample will be randomly drawn from
the frame or not. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="getSample_+3A_strata">strata</code></td>
<td>
<p>to be added</p>
</td></tr>
<tr><td><code id="getSample_+3A_stratum">stratum</code></td>
<td>
<p>The name of a column in the dataframe attached to shapefile that defines
the strata of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following variable:
</p>

<ul>
<li> <p><code>sample</code> The sample from the shapefile POINTS.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Phil Davies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Draw a spatially balanced sample of n = 25 from a Halton Frame over Gates --

# Use the North Carolina shapefile supplied in the sf R package.
shp_file &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"))
shp_gates &lt;- shp_file[shp_file$NAME == "Gates",]

# Vertically aligned master sample bounding box.
bb &lt;- spbal::BoundingBox(shapefile = shp_gates)

set.seed(511)
result7 &lt;- spbal::HaltonFrame(shapefile = shp_gates,
                              J = c(6, 4),
                              boundingbox = bb)
Frame &lt;- result7$hf.pts.shp

# Get the first 25 sites from a B = (2^6) * (3^4) Halton Frame (62,208 grid
# points covering Gates).
n_samples &lt;- 25
FrameSample &lt;-getSample(shapefile = Frame,
                        n = n_samples)
FrameSample &lt;- FrameSample$sample
FrameSample

</code></pre>

<hr>
<h2 id='HaltonFrame'>Create a Halton Frame.</h2><span id='topic+HaltonFrame'></span>

<h3>Description</h3>

<p>Halton frames discretize an areal resource into a spatially ordered grid,
where samples of consecutive frame points are spatially balanced. To generate Halton Frames,
spbal requires a study region <code>shapefile</code> and the regionâ€™s <code>bounding box</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HaltonFrame(
  N = 1,
  J = base::c(3, 2),
  bases = base::c(2, 3),
  boundingbox = NULL,
  shapefile = NULL,
  panels = NULL,
  panel_overlap = NULL,
  seeds = NULL,
  stratum = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HaltonFrame_+3A_n">N</code></td>
<td>
<p>The number of points in the frame to generate.</p>
</td></tr>
<tr><td><code id="HaltonFrame_+3A_j">J</code></td>
<td>
<p>The number of grid cells. A list of 2 values. The default value is c(3, 2).</p>
</td></tr>
<tr><td><code id="HaltonFrame_+3A_bases">bases</code></td>
<td>
<p>Co-prime base for the Halton Sequence. The default value is c(2, 3).</p>
</td></tr>
<tr><td><code id="HaltonFrame_+3A_boundingbox">boundingbox</code></td>
<td>
<p>Bounding box around the study area. If a bounding box is not supplied
then spbal will generate a bounding box for the shapefile.</p>
</td></tr>
<tr><td><code id="HaltonFrame_+3A_shapefile">shapefile</code></td>
<td>
<p>A sf object. If the shapefile parameter is NULL then function
HaltonFrameBase is called directly.</p>
</td></tr>
<tr><td><code id="HaltonFrame_+3A_panels">panels</code></td>
<td>
<p>A list of integers that define the size of each panel in a
non-overlapping panels design. The length of the list determines the number of
panels required. The sum of the integers in the panels parameter will determine
the total number of samples selected, n. The default value for panels is NULL,
this indicates that a non-overlapping panel design is not wanted.</p>
</td></tr>
<tr><td><code id="HaltonFrame_+3A_panel_overlap">panel_overlap</code></td>
<td>
<p>A list of integers that define the overlap into the previous
panel. Is only used when the panels parameter is not NULL. The default value for
panel_overlap is NULL. The length of panel_overlap must be equal to the length
of panels. The first value is always forced to zero as the first panel never
overlaps any region.</p>
</td></tr>
<tr><td><code id="HaltonFrame_+3A_seeds">seeds</code></td>
<td>
<p>A vector of 2 seeds, u1 and u2. If not specified, the default is NULL.</p>
</td></tr>
<tr><td><code id="HaltonFrame_+3A_stratum">stratum</code></td>
<td>
<p>Name of column in shapefile that makes up the strata.</p>
</td></tr>
<tr><td><code id="HaltonFrame_+3A_verbose">verbose</code></td>
<td>
<p>Boolean if you want to see any output printed to screen. Helpful if taking a
long time. Default is FALSE i.e. no informational messages are displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing five variables:
</p>

<ul>
<li> <p><code>J</code> The number of grid cells. A list of 2 values that were used to generate this
Halton grid and frame.
</p>
</li>
<li> <p><code>hg.pts.shp</code> Halton grid over the bounding box and study area.
</p>
</li>
<li> <p><code>hf.pts.shp</code> Halton frame, the sample points within the study area.
</p>
</li>
<li> <p><code>bb</code> The bounding box.
</p>
</li>
<li> <p><code>seeds</code> The u1 and u2 seeds used to generate the sample.
</p>
</li></ul>

<p>The sample points in <code>hf.pts.shp</code> are returned in the form of a simple feature
collection of POINT objects. As well as having the features from the original <code>shapefile</code>,
the following new attributes have been added:
</p>

<ul>
<li> <p><code>spbalSeqID</code>: A unique identifier for every sample point.
</p>
</li>
<li> <p><code>ID</code>: A unique identifier, the Halton frame point order.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Phil Davies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># we discretize the Gates study region into a coarse grid using
# B = 2^{J_1} * 3^{J_2}= (2^3) * (3^2) (9 by 8 grid) ------------------------

# Use the North Carolina shapefile supplied in the sf R package.
shp_file &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"))
shp_gates &lt;- shp_file[shp_file$NAME == "Gates",]

# Vertically aligned master sample bounding box.
bb &lt;- spbal::BoundingBox(shapefile = shp_gates)

set.seed(511)
result6 &lt;- spbal::HaltonFrame(shapefile = shp_gates,
                              J = c(3, 2),
                              boundingbox = bb)
# get the frame points.
Frame &lt;- result6$hf.pts.shp
Frame
# get the grid points.
Grid &lt;- result6$hg.pts.shp
Grid

</code></pre>

<hr>
<h2 id='HaltonFrameBase'>Generate a Halton Frame.</h2><span id='topic+HaltonFrameBase'></span>

<h3>Description</h3>

<p>A description of this useful function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HaltonFrameBase(
  n = (bases[1]^J[1]) * (bases[2]^J[2]),
  J = base::c(3, 2),
  bases = base::c(2, 3),
  seeds = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HaltonFrameBase_+3A_n">n</code></td>
<td>
<p>The number of points in the frame to generate.</p>
</td></tr>
<tr><td><code id="HaltonFrameBase_+3A_j">J</code></td>
<td>
<p>The number of grid cells. A list of 2 values. The default value is c(3, 2), we could also use c(5, 3).</p>
</td></tr>
<tr><td><code id="HaltonFrameBase_+3A_bases">bases</code></td>
<td>
<p>Co-prime base for the Halton Sequence. The default value is c(2, 3).</p>
</td></tr>
<tr><td><code id="HaltonFrameBase_+3A_seeds">seeds</code></td>
<td>
<p>The u1 and u2 seeds to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was written by Phil Davies.
</p>


<h3>Value</h3>

<p>A list containing the following four variables:
halton_seq -
halton_seq_div -
Z -
halton_frame -
</p>

<hr>
<h2 id='HIP'>Halton Iterative Partitioning (HIP).</h2><span id='topic+HIP'></span>

<h3>Description</h3>

<p>HIP draws spatially balanced samples and over-samples from point
resources by partitioning the resource into boxes with the same nested structure
as Halton boxes. The <strong>spbal</strong> parameter <strong>iterations</strong> defines the number of
boxes used in the HIP partition and should be larger than the sample size but
less than the population size. The <strong>iterations parameter</strong> also defines the
number of units available in the HIP over-sample, where the over-sample contains
one unit from each box in the HIP partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HIP(
  population = NULL,
  n = 20,
  iterations = 7,
  minRadius = NULL,
  panels = NULL,
  panel_overlap = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HIP_+3A_population">population</code></td>
<td>
<p>A population of point pairs.</p>
</td></tr>
<tr><td><code id="HIP_+3A_n">n</code></td>
<td>
<p>The number of points to draw from the population. Default 20.</p>
</td></tr>
<tr><td><code id="HIP_+3A_iterations">iterations</code></td>
<td>
<p>The levels of partitioning required. Default 7.</p>
</td></tr>
<tr><td><code id="HIP_+3A_minradius">minRadius</code></td>
<td>
<p>If specified, the minimum distance, in meters, allowed between sample
points. This is applied to the $overSample.</p>
</td></tr>
<tr><td><code id="HIP_+3A_panels">panels</code></td>
<td>
<p>A list of integers that define the size of each panel in a
non-overlapping panels design. The length of the list determines the number of
panels required. The sum of the integers in the panels parameter will determine
the total number of samples selected, n. The default value for panels is NULL,
this indicates that a non-overlapping panel design is not wanted.</p>
</td></tr>
<tr><td><code id="HIP_+3A_panel_overlap">panel_overlap</code></td>
<td>
<p>A list of integers that define the overlap into the previous
panel. Is only used when the panels parameter is not NULL. The default value for
panel_overlap is NULL. The length of panel_overlap must be equal to the length
of panels. The first value is always forced to zero as the first panel never
overlaps any region.</p>
</td></tr>
<tr><td><code id="HIP_+3A_verbose">verbose</code></td>
<td>
<p>Boolean if you want to see any output printed to screen. Helpful if taking a
long time. Default is FALSE i.e. no informational messages are displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Halton iterative partitioning (HIP) extends Basic acceptance
sampling (BAS) to point resources. It partitions the resource into $B &gt;= n$
boxes that have the same nested structure as in BAS, but different sizes.
These boxes are then uniquely numbered using a random-start Halton sequence
of length $B$. The HIP sample is obtained by randomly drawing one point from
each of the boxes numbered $1, 2, . . . , n$.
</p>


<h3>Value</h3>

<p>Return a list containing the following five variables:
</p>

<ul>
<li> <p><code>Population</code> Original population point pairs as an sf object.
</p>
</li>
<li> <p><code>HaltonIndex</code> The Halton index for the point. Points will be spread equally across
all Halton indices.
</p>
</li>
<li> <p><code>sample</code> The sample from the population of size n.
</p>
</li>
<li> <p><code>overSample</code> The overSample contains one point from each Halton box. All contiguous
sub-samples from oversample are spatially balanced, and the first n points are identical to sample.
</p>
</li>
<li> <p><code>minRadius</code> This result variable contains the sample created using the minRadius
parameter. If the minRadius parameter is not specified then the minRadius variable will contain NULL.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Phil Davies, Blair Robertson.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating 20 points from a population of 5,000 (random) points with 7
# levels of partitioning (4 in the first dimension and 3 in the second) to
# give (2^4) * (3^3) = 32 * 27, resulting in 864 boxes ----------------------

# set random seed
set.seed(511)

# define HIP parameters.
pop &lt;- matrix(runif(5000*2), nrow = 5000, ncol = 2)
n &lt;- 20
its &lt;- 7

# Convert the population matrix to an sf point object.
sf_points &lt;- sf::st_as_sf(data.frame(pop), coords = c("X1", "X2"))
dim(sf::st_coordinates(sf_points))

# generate HIP sample.
result &lt;- spbal::HIP(population = sf_points,
                     n = n,
                     iterations =  its)

# HaltonIndex
HaltonIndex &lt;- result$HaltonIndex
table(HaltonIndex)

# Population Sample
HIPsample &lt;- result$sample
HIPsample

</code></pre>

<hr>
<h2 id='hipIndexRandomPermutation'>Permute Halton indices.</h2><span id='topic+hipIndexRandomPermutation'></span>

<h3>Description</h3>

<p>A description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hipIndexRandomPermutation(its)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hipIndexRandomPermutation_+3A_its">its</code></td>
<td>
<p>The number of partitioning iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following variables:
</p>

<ul>
<li> <p><code>permHaltonIndex</code> The permuted halton indices for all points.
</p>
</li>
<li> <p><code>B</code> The number of Halton boxes.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Phil Davies, Blair Robertson.
</p>

<hr>
<h2 id='hipPartition'>Partition the population.</h2><span id='topic+hipPartition'></span>

<h3>Description</h3>

<p>Partition the resource into boxes with the same nested structure as Halton boxes.
The <strong>spbal</strong> parameter <strong>iterations</strong> defines the number of boxes used in the HIP partition and
should be larger than the sample size but less than the population size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hipPartition(pts, its)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hipPartition_+3A_pts">pts</code></td>
<td>
<p>The population of points.</p>
</td></tr>
<tr><td><code id="hipPartition_+3A_its">its</code></td>
<td>
<p>The number of partitioning iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following variables:
</p>

<ul>
<li> <p><code>ptsIndex</code> The population index.
</p>
</li>
<li> <p><code>HaltonIndex</code> Updated Halton indices for all points in pts.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Phil Davies, Blair Robertson.
</p>

<hr>
<h2 id='hipX1split'>First dimension split.</h2><span id='topic+hipX1split'></span>

<h3>Description</h3>

<p>Split point pairs using the first dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hipX1split(x1pts, HaltonIndex, BoxIndex, xlevel, x1Hpts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hipX1split_+3A_x1pts">x1pts</code></td>
<td>
<p>First dimension component of point pair.</p>
</td></tr>
<tr><td><code id="hipX1split_+3A_haltonindex">HaltonIndex</code></td>
<td>
<p>Halton indices for all points in x1Hpts.</p>
</td></tr>
<tr><td><code id="hipX1split_+3A_boxindex">BoxIndex</code></td>
<td>
<p>Index of current box to process.</p>
</td></tr>
<tr><td><code id="hipX1split_+3A_xlevel">xlevel</code></td>
<td>
<p>The current iteration level.</p>
</td></tr>
<tr><td><code id="hipX1split_+3A_x1hpts">x1Hpts</code></td>
<td>
<p>First dimension component of Halton point pair.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable called HaltonIndex, the updated Halton indices for all points in x1Hpts.
</p>


<h3>Author(s)</h3>

<p>Phil Davies, Blair Robertson.
</p>

<hr>
<h2 id='hipX2split'>Second dimension split.</h2><span id='topic+hipX2split'></span>

<h3>Description</h3>

<p>Split point pairs using the second dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hipX2split(x2pts, HaltonIndex, BoxIndex, xlevel, x2Hpts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hipX2split_+3A_x2pts">x2pts</code></td>
<td>
<p>Second dimension component of point pair.</p>
</td></tr>
<tr><td><code id="hipX2split_+3A_haltonindex">HaltonIndex</code></td>
<td>
<p>Halton indices for all points in x2Hpts.</p>
</td></tr>
<tr><td><code id="hipX2split_+3A_boxindex">BoxIndex</code></td>
<td>
<p>Index of current box to process.</p>
</td></tr>
<tr><td><code id="hipX2split_+3A_xlevel">xlevel</code></td>
<td>
<p>The current iteration level.</p>
</td></tr>
<tr><td><code id="hipX2split_+3A_x2hpts">x2Hpts</code></td>
<td>
<p>Second dimension component of Halton point pair.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable called HaltonIndex, the updated Halton indices for all points in x2Hpts.
</p>


<h3>Author(s)</h3>

<p>Phil Davies, Blair Robertson.
</p>

<hr>
<h2 id='is_sf_points'>Check if an object is an sf points object.</h2><span id='topic+is_sf_points'></span>

<h3>Description</h3>

<p>Tests if the object passed to the function is a sf points object or not.
An internal only function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_sf_points(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_sf_points_+3A_x">x</code></td>
<td>
<p>A probable sf points object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Detect if an object is a sf points object or not.
</p>


<h3>Value</h3>

<p>Either TRUE or FALSE.
</p>


<h3>Author(s)</h3>

<p>Phil Davies, Blair Robertson.
</p>

<hr>
<h2 id='log_a_to_base_b'>Compute the log of a to base b.</h2><span id='topic+log_a_to_base_b'></span>

<h3>Description</h3>

<p>Compute the log of a to base b.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_a_to_base_b_+3A_a">a</code></td>
<td>
<p>Integer to find the log to base b of.</p>
</td></tr>
<tr><td><code id="log_a_to_base_b_+3A_b">b</code></td>
<td>
<p>Base</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of a to base b.
</p>


<h3>Author(s)</h3>

<p>Phil Davies.
</p>

<hr>
<h2 id='mod'>Vector modulus.</h2><span id='topic+mod'></span>

<h3>Description</h3>

<p>Computes the remainder of dividing a by n using the modulo operator.
This function uses a trick to avoid using the modulo operator directly, which can be slow
for large values of a and n.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mod_+3A_a">a</code></td>
<td>
<p>The input value of type T. This is a NumericVector.</p>
</td></tr>
<tr><td><code id="mod_+3A_n">n</code></td>
<td>
<p>The divisor of type int.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The remainder of dividing a by n, of type T in the form of a NumericVector.
</p>


<h3>Author(s)</h3>

<p>Phil Davies.
</p>

<hr>
<h2 id='PanelDesignAssignPanelids'>Assign panel ids to the samples.</h2><span id='topic+PanelDesignAssignPanelids'></span>

<h3>Description</h3>

<p>This function assigns panel id's to each sample based on values in the
panels and panel_overlap parameters. This is an internal only function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PanelDesignAssignPanelids(
  smp,
  panels,
  panel_overlap,
  panel_design,
  number_panels,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PanelDesignAssignPanelids_+3A_smp">smp</code></td>
<td>
<p>The shapefile for the region under study.</p>
</td></tr>
<tr><td><code id="PanelDesignAssignPanelids_+3A_panels">panels</code></td>
<td>
<p>A list of integers that defines the size of each panel in a
non-overlapping panels design. The length of the list determines the number of
panels required. The sum of the integers in the panels parameter will determine
the total number of samples selected, n. The default value for panels is NULL,
this indicates that a non-overlapping panel design is not wanted.</p>
</td></tr>
<tr><td><code id="PanelDesignAssignPanelids_+3A_panel_overlap">panel_overlap</code></td>
<td>
<p>A list of integers that define the overlap into the previous
panel. Is only used when the panels parameter is not NULL. The default value for
panel_overlap is NULL. The length of panel_overlap must be equal to the length
of panels. The first value is always forced to zero as the first panel never
overlaps any region.</p>
</td></tr>
<tr><td><code id="PanelDesignAssignPanelids_+3A_panel_design">panel_design</code></td>
<td>
<p>A flag, when TRUE, indicates that we are performing a panel design and
the parameters used are specified in the panels and panel_overlap parameters.</p>
</td></tr>
<tr><td><code id="PanelDesignAssignPanelids_+3A_number_panels">number_panels</code></td>
<td>
<p>The number of sample panels required.</p>
</td></tr>
<tr><td><code id="PanelDesignAssignPanelids_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, set TRUE if you want to see output messaged to screen. Default is FALSE
i.e. no informational messages are displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of the following variables:
</p>

<ul>
<li> <p><code>sample</code> This is a sample from the original shapefile that has had the
appropriate panel id's add as a feature. The panel id values are determined by the
panels and panel_overlap parameters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Phil Davies.
</p>

<hr>
<h2 id='removeDuplicates'>Remove duplicate values from a NumericVector.</h2><span id='topic+removeDuplicates'></span>

<h3>Description</h3>

<p>Sort the input numeric vector and removes any duplicate values.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeDuplicates_+3A_vec">vec</code></td>
<td>
<p>A NumericVector that may contain duplicate values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A NumericVector that is sorted with duplicates removed.
</p>


<h3>Author(s)</h3>

<p>Phil Davies.
</p>

<hr>
<h2 id='rot'>Generate a rotation matrix for rotating objects later.</h2><span id='topic+rot'></span>

<h3>Description</h3>

<p>Generate a rotation matrix for rotating objects later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rot(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rot_+3A_a">a</code></td>
<td>
<p>radians of rotation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>This function was first written by Paul van Dam-Bates for the
package BASMasterSample.
</p>

<hr>
<h2 id='rotate.scale.coords'>Scale and rotate points from the unit square to a defined projection.</h2><span id='topic+rotate.scale.coords'></span>

<h3>Description</h3>

<p>Given some coordinates on [0,1)x[0,1), shift and scale them to the bounding box, and then rotate
them given the bounding box rotation defined by the Master Sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate.scale.coords(coords, bb, back = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate.scale.coords_+3A_coords">coords</code></td>
<td>
<p>Output from RSHalton() to be converted to the spatial surface of interest.</p>
</td></tr>
<tr><td><code id="rotate.scale.coords_+3A_bb">bb</code></td>
<td>
<p>Special shape file defining the bounding box with attributes for centroid and rotation.</p>
</td></tr>
<tr><td><code id="rotate.scale.coords_+3A_back">back</code></td>
<td>
<p>Boolean for whether or not the rotation is back to the original rotated bounding box.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf spatial points with projection defined in bb.
</p>


<h3>Author(s)</h3>

<p>This function was first written by Paul van Dam-Bates for the
package BASMasterSample.
</p>

<hr>
<h2 id='setBASIndex'>Finds a set of Halton indices that will create BAS points within a shape bounding box.</h2><span id='topic+setBASIndex'></span>

<h3>Description</h3>

<p>This function is designed to be called internally for efficiency in site selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setBASIndex(shapefile, bb, seeds = base::c(0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setBASIndex_+3A_shapefile">shapefile</code></td>
<td>
<p>Shape file as a polygon (sp or sf) to select sites for.</p>
</td></tr>
<tr><td><code id="setBASIndex_+3A_bb">bb</code></td>
<td>
<p>Bounding box which defines the area around the study area. A bounding box must be
supplied.</p>
</td></tr>
<tr><td><code id="setBASIndex_+3A_seeds">seeds</code></td>
<td>
<p>A vector of 2 seeds, u1 and u2. seeds must have a value when this function is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To be used when doing a Master Sample and the bounding box of the greater frame is potentially much
larger than the the polygon being sampled. In this case, we don't want to generate points across the
entire larger bounding box region and then clip them. Instead, we can make use of the Halton sequence
and only generate BAS points near to the shape being sampled. This function finds returns those indices.
</p>


<h3>Value</h3>

<p>A list containing two variables, <code>$boxes</code> containing indices of the BAS sample that fall
into the bounding box, <code>$J</code>, the number of subdivision powers taken to find those boxes, <code>$B</code>,
the number of boxes that the indices relate to <code>(1-B)</code>, <code>$xlim</code>, the ylimit of the
bounding box of the shapefile, shifted to the <code>base[1]^J[1]</code> coordinates on the unit box
<code>[0,1)</code>, <code>$ylim</code>, the ylimit of the bounding box of the shapefile, shifted to the
<code>base[2]^J[2]</code> coordinates on the unit box <code>[0,1)</code>.
</p>

<hr>
<h2 id='SRS'>Simple random sampling.</h2><span id='topic+SRS'></span>

<h3>Description</h3>

<p>This function invokes base::sample() to draw a random sample using
a user specified random seed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SRS(seed = 511, total_rows = 0, sample_size = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SRS_+3A_seed">seed</code></td>
<td>
<p>The random seed to be used to draw the current sample.</p>
</td></tr>
<tr><td><code id="SRS_+3A_total_rows">total_rows</code></td>
<td>
<p>The total number of rows in our input dataset.</p>
</td></tr>
<tr><td><code id="SRS_+3A_sample_size">sample_size</code></td>
<td>
<p>The number of rows wanted in our random sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was written by Phil Davies.
</p>


<h3>Value</h3>

<p>A random sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random sample with a seed of 99 ----------------------------------
spbal::SRS(seed = 99, total_rows = 100, sample_size = 20)

# Create a random sample with a seed of 42 ----------------------------------
spbal::SRS(seed = 42, total_rows = 100, sample_size = 20)

# Create a random sample with a seed of 99 ----------------------------------
spbal::SRS(seed = 99, total_rows = 100, sample_size = 25)

</code></pre>

<hr>
<h2 id='validate_parameters'>Validate spbal function parameters.</h2><span id='topic+validate_parameters'></span>

<h3>Description</h3>

<p>This function is used to validate parameters passed to
all spbal functions that may be called by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_parameters(parm, parm_value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_parameters_+3A_parm">parm</code></td>
<td>
<p>The parameter to be validated.</p>
</td></tr>
<tr><td><code id="validate_parameters_+3A_parm_value">parm_value</code></td>
<td>
<p>The value of the parameter to be validated. Must be defined as a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns TRUE indicating that the parameter was parsed successfully. If
a parameter fails validation further execution is terminated using the STOP function.
</p>


<h3>Author(s)</h3>

<p>Phil Davies.
</p>

<hr>
<h2 id='ValidatePanelDesign'>Validate the panels and panel_overlap parameters.</h2><span id='topic+ValidatePanelDesign'></span>

<h3>Description</h3>

<p>This function is used to validate the panels and panel_overlap
parameters. The panel_design flag is set TRUE when the panels and/or panel_overlap
parameters are not NULL. This is an internal only function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ValidatePanelDesign(panels, panel_overlap, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ValidatePanelDesign_+3A_panels">panels</code></td>
<td>
<p>A list of integers that define the size of each panel in a
non-overlapping panels design. The length of the list determines the number of
panels required. The sum of the integers in the panels parameter will determine
the total number of samples selected, n. The default value for panels is NULL,
this indicates that a non-overlapping panel design is not wanted.</p>
</td></tr>
<tr><td><code id="ValidatePanelDesign_+3A_panel_overlap">panel_overlap</code></td>
<td>
<p>A list of integers that define the overlap into the previous
panel. It is only used when the panels parameter is not NULL. The default value for
panel_overlap is NULL. The length of panel_overlap must be equal to the length
of panels. The first value is always forced to zero as the first panel never
overlaps any region.</p>
</td></tr>
<tr><td><code id="ValidatePanelDesign_+3A_n">n</code></td>
<td>
<p>The number of samples required. Only used when panels and panel_overlap are NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing four variables, they are detailed below.
</p>

<ul>
<li> <p><code>n</code> When the <code>panels</code> parameter is not null, the <code>n</code> parameter is set
using the sum of all the panel sizes in <code>panels</code>.
</p>
</li>
<li> <p><code>panel_design</code> A boolean, TRUE, indicates that the user wants a panels design.
</p>
</li>
<li> <p><code>number_panels</code> The number of panels specified in the panel design.
</p>
</li>
<li> <p><code>panel_overlap</code> Updated panel_overlap vector, the first element is always forced
to zero irrespective of what the user specified.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Phil Davies.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
