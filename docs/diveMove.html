<!DOCTYPE html><html lang="en"><head><title>Help for package diveMove</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {diveMove}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#diveMove-package'><p>Dive Analysis and Calibration</p></a></li>
<li><a href='#.detPhase'><p>Detect phases of activity from depth readings</p></a></li>
<li><a href='#.runquantile'><p>Quantile of Moving Window</p></a></li>
<li><a href='#austFilter'><p>Filter satellite locations</p></a></li>
<li><a href='#bec+2Cnls-method'><p>Calculate bout ending criteria from model coefficients</p></a></li>
<li><a href='#boutfreqs'><p>Histogram of log-transformed frequencies</p></a></li>
<li><a href='#boutinit+2Cdata.frame-method'><p>Fit &quot;broken stick&quot; model to log frequency data for identification of</p>
bouts of behaviour</a></li>
<li><a href='#Bouts-class'><p>Class &quot;Bouts&quot; for representing Poisson mixtures for identification of</p>
behavioural bouts</a></li>
<li><a href='#boutsCDF'><p>Estimated cumulative frequency for two- or three-process Poisson</p>
mixture models</a></li>
<li><a href='#boutsMLEll.chooser'><p>Log likelihood function of parameters given observed data</p></a></li>
<li><a href='#boutsNLSll+2CBouts-method'><p>Generalized log likelihood function taking any number of Poisson</p>
processes in a &quot;broken-stick&quot; model</a></li>
<li><a href='#calc.p'><p>Utilities for Poisson mixture analyses</p></a></li>
<li><a href='#calibrateDepth'><p>Calibrate Depth and Generate a &quot;TDRcalibrate&quot; object</p></a></li>
<li><a href='#calibrateSpeed'><p>Calibrate and build a &quot;TDRcalibrate&quot; object</p></a></li>
<li><a href='#createTDR'><p>Read comma-delimited file with &quot;TDR&quot; data</p></a></li>
<li><a href='#detDive-internal'><p>Detect dives from depth readings</p></a></li>
<li><a href='#distSpeed'><p>Calculate distance and speed between locations</p></a></li>
<li><a href='#diveModel-class'><p>Class &quot;diveModel&quot; for representing a model for identifying dive phases</p></a></li>
<li><a href='#diveMove-defunct'><p>Defunct functions in package &lsquo;diveMove&rsquo;</p></a></li>
<li><a href='#diveMove-deprecated'><p>Deprecated functions in diveMove</p></a></li>
<li><a href='#diveMove-internal'><p>Internal diveMove Functions</p></a></li>
<li><a href='#dives'><p>Sample of TDR data from a fur seal</p></a></li>
<li><a href='#diveStats'><p>Per-dive statistics</p></a></li>
<li><a href='#extractDive+2CTDR+2Cnumeric+2Cnumeric-method'><p>Extract Dives from &quot;TDR&quot; or &quot;TDRcalibrate&quot; Objects</p></a></li>
<li><a href='#fitMLEbouts+2Cnumeric-method'><p>Maximum Likelihood Model of mixtures of 2 or 3 Poisson Processes</p></a></li>
<li><a href='#fitNLSbouts+2Cdata.frame-method'><p>Fit mixture of Poisson Processes to Log Frequency data via Non-linear</p>
Least Squares regression</a></li>
<li><a href='#labDive-internal'><p>Internal Functions used for Detection of Dives</p></a></li>
<li><a href='#labelBouts+2Cnumeric-method'><p>Label each vector element or matrix row with bout membership number</p></a></li>
<li><a href='#plotBouts+2Cnls+2Cdata.frame-method'><p>Plot fitted Poisson mixture model and data</p></a></li>
<li><a href='#plotBoutsCDF+2Cnls+2Cnumeric-method'><p>Plot empirical and deterministic cumulative frequency distribution</p>
Poisson mixture data and model</a></li>
<li><a href='#plotDiveModel+2CdiveModel+2Cmissing-method'><p>Methods for plotting models of dive phases</p></a></li>
<li><a href='#plotTDR+2CPOSIXt+2Cnumeric-method'><p>Methods for plotting objects of class &quot;TDR&quot; and &quot;TDRcalibrate&quot;</p></a></li>
<li><a href='#plotZOC+2CTDR+2Cmatrix-method'><p>Methods for visually assessing results of ZOC procedure</p></a></li>
<li><a href='#readLocs'><p>Read comma-delimited file with location data</p></a></li>
<li><a href='#rmixexp'><p>Generate samples from a mixture of exponential distributions</p></a></li>
<li><a href='#rqPlot'><p>Plot of quantile regression for speed calibrations</p></a></li>
<li><a href='#sealLocs'><p>Ringed and Gray Seal ARGOS Satellite Location Data</p></a></li>
<li><a href='#TDR-accessors'><p>Coerce, Extractor, and Replacement methods for class &quot;TDR&quot;</p>
objects</a></li>
<li><a href='#TDR-class'><p>Classes &quot;TDR&quot; and &quot;TDRspeed&quot; for representing TDR information</p></a></li>
<li><a href='#TDRcalibrate-accessors'><p>Methods to Show and Extract Basic Information from &quot;TDRcalibrate&quot;</p>
Objects</a></li>
<li><a href='#TDRcalibrate-class'><p>Class &quot;TDRcalibrate&quot; for dive analysis</p></a></li>
<li><a href='#timeBudget+2CTDRcalibrate+2Clogical-method'><p>Describe the Time Budget of Major Activities from &quot;TDRcalibrate&quot;</p>
object.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dive Analysis and Calibration</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.4</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.4.0), methods, stats4</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, lattice, pander, rmarkdown, tinytest</td>
</tr>
<tr>
<td>Imports:</td>
<td>geosphere, KernSmooth, plotly, quantreg, uniReg</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian P. Luque
    <a href="https://orcid.org/0000-0002-9647-3691"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian P. Luque &lt;spluque@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilities to represent, visualize, filter, analyse, and summarize
	     time-depth recorder (TDR) data.  Miscellaneous functions for
	     handling location data are also provided.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ZipData:</td>
<td>no</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>AllClass.R AllGenerics.R AllMethod.R austFilter.R
bouts_helpers.R bouts.R calibrate.R detDive.R detPhase.R
distSpeed.R diveStats.R oneDiveStats.R plotTDR.R plotZOC.R
readLocs.R readTDR.R runquantile.R speedStats.R stampDive.R
zoc.R diveMove-deprecated.R diveMove-defunct.R zzz.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/spluque/diveMove">https://github.com/spluque/diveMove</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/spluque/diveMove/issues">https://github.com/spluque/diveMove/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-13 00:11:08 UTC; sluque</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-13 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='diveMove-package'>Dive Analysis and Calibration</h2><span id='topic+diveMove-package'></span><span id='topic+diveMove'></span>

<h3>Description</h3>

<p>This package is a collection of functions for visualizing and
analyzing depth and speed data from time-depth recorders <abbr><span class="acronym">TDR</span></abbr>s.
These can be used to zero-offset correct depth, calibrate speed, and
divide the record into different phases, or time budget.  Functions are
provided for calculating summary dive statistics for the whole record, or
at smaller scales within dives.</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a></p>


<h3>See Also</h3>

<p>A vignette with a guide to this package is available by doing
<code>vignette("diveMove")</code>.
<code><a href="#topic+diveMove-package">TDR-class</a></code>,
<code><a href="#topic+diveMove-package">calibrateDepth</a></code>,
<code><a href="#topic+diveMove-package">calibrateSpeed</a></code>,
<code><a href="#topic+diveMove-package">timeBudget</a></code>,
<code><a href="#topic+diveMove-package">stampDive</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Too long for checks
## read in data and create a TDR object
zz &lt;- system.file(file.path("data", "dives.csv"),
                  package="diveMove", mustWork=TRUE)
(sealX &lt;- readTDR(zz, speed=TRUE, sep=";", na.strings="", as.is=TRUE))

if (dev.interactive(orNone=TRUE)) plotTDR(sealX)  # html plotly

## detect periods of activity, and calibrate depth, creating
## a "TDRcalibrate" object
if (dev.interactive(orNone=TRUE)) dcalib &lt;- calibrateDepth(sealX)
## Use the "offset" ZOC method to zero-offset correct depth at 3 m
(dcalib &lt;- calibrateDepth(sealX, zoc.method="offset", offset=3))

if (dev.interactive(orNone=TRUE)) {
    ## plot all readings and label them with the phase of the record
    ## they belong to, excluding surface readings
    plotTDR(dcalib, surface=FALSE)
    ## plot the first 300 dives, showing dive phases and surface readings
    plotTDR(dcalib, diveNo=seq(300), surface=TRUE)
}

## calibrate speed (using changes in depth &gt; 1 m and default remaining arguments)
(vcalib &lt;- calibrateSpeed(dcalib, z=1))

## Obtain dive statistics for all dives detected
dives &lt;- diveStats(vcalib)
head(dives)

## Attendance table
att &lt;- timeBudget(vcalib, FALSE) # taking trivial aquatic activities into account
att &lt;- timeBudget(vcalib, TRUE)  # ignoring them
## Identify which phase each dive belongs to
stamps &lt;- stampDive(vcalib)
sumtab &lt;- data.frame(stamps, dives)
head(sumtab)



</code></pre>

<hr>
<h2 id='.detPhase'>Detect phases of activity from depth readings</h2><span id='topic+.detPhase'></span>

<h3>Description</h3>

<p>Functions to identify sections of a <abbr><span class="acronym">TDR</span></abbr> record displaying one
of three possible activities: dry, wet, and trivial wet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.detPhase(time, depth, dry.thr, wet.cond, wet.thr, interval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".detPhase_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> object with date and time for all depths.</p>
</td></tr>
<tr><td><code id=".detPhase_+3A_depth">depth</code></td>
<td>
<p>numeric vector with depth readings.</p>
</td></tr>
<tr><td><code id=".detPhase_+3A_dry.thr">dry.thr</code>, <code id=".detPhase_+3A_wet.cond">wet.cond</code>, <code id=".detPhase_+3A_wet.thr">wet.thr</code></td>
<td>
<p>As passed from
<code><a href="#topic+calibrateDepth">calibrateDepth</a></code>.</p>
</td></tr>
<tr><td><code id=".detPhase_+3A_interval">interval</code></td>
<td>
<p>As passed from <code><a href="#topic+calibrateDepth">calibrateDepth</a></code>; sampling
interval in seconds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+calibrateDepth">calibrateDepth</a></code>.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>phase.id</code></td>
<td>
<p>Numeric vector identifying each activity phase,
starting from 1 for every input record.</p>
</td></tr>
<tr><td><code>activity</code></td>
<td>
<p>Factor with levels &ldquo;L&rdquo; indicating dry,
&ldquo;W&rdquo; indicating wet, &ldquo;U&rdquo; for underwater (above dive
criterion), &ldquo;D&rdquo; for diving, &ldquo;Z&rdquo; for trivial wet animal
activities.  Only &ldquo;L&rdquo;, &ldquo;W&rdquo;, and &ldquo;Z&rdquo; are actually
represented.</p>
</td></tr>
<tr><td><code>begin</code></td>
<td>
<p>A <code><a href="base.html#topic+POSIXct">POSIXct</a></code> object as long as the number of
unique activity phases identified, indicating the start times for each
activity phase.</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>A <code><a href="base.html#topic+POSIXct">POSIXct</a></code> object as long as the number of
unique activity phases identified, indicating the end times for each
activity phase.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a> and Andy Liaw.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.detDive">.detDive</a></code>, <code><a href="#topic+calibrateDepth">calibrateDepth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(divesTDR)
depths &lt;- getDepth(divesTDR)
times &lt;- getTime(divesTDR)

detp &lt;- diveMove:::.detPhase(times, depths, dry.thr=70, wet.thr=3610,
                             interval=getDtime(divesTDR))
## Plot detected phases
plotTDR(times, depths)
rect(xleft=detp$begin, xright=detp$end, ybottom=0, ytop=-4,
     col=seq_along(detp$begin))
</code></pre>

<hr>
<h2 id='.runquantile'>Quantile of Moving Window</h2><span id='topic+.runquantile'></span>

<h3>Description</h3>

<p>Moving (aka running, rolling) Window Quantile calculated over a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.runquantile(
  x,
  k,
  probs,
  type = 7,
  endrule = c("quantile", "NA", "trim", "keep", "constant", "func"),
  align = c("center", "left", "right")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".runquantile_+3A_x">x</code></td>
<td>
<p>numeric vector of length n or matrix with n rows. If <code>x</code>
is a matrix than each column will be processed separately.</p>
</td></tr>
<tr><td><code id=".runquantile_+3A_k">k</code></td>
<td>
<p>width of moving window; must be an integer between one and n.</p>
</td></tr>
<tr><td><code id=".runquantile_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1] range
used by <code>runquantile</code>.</p>
</td></tr>
<tr><td><code id=".runquantile_+3A_type">type</code></td>
<td>
<p>an integer between 1 and 9 selecting one of the nine
quantile algorithms, same as <code>type</code> in <code><a href="stats.html#topic+quantile">quantile</a></code>
function.  Another even more readable description of nine ways to
calculate quantiles can be found at
<a href="http://mathworld.wolfram.com/Quantile.html">http://mathworld.wolfram.com/Quantile.html</a>.</p>
</td></tr>
<tr><td><code id=".runquantile_+3A_endrule">endrule</code></td>
<td>
<p>character string indicating how the values at the beginning and the
end, of the array, should be treated. Only first and last <code>k2</code>
values at both ends are affected, where <code>k2</code> is the half-bandwidth
<code>k2 = k %/% 2</code>.
</p>
<p>* <code>"quantile"</code> Applies the <code><a href="stats.html#topic+quantile">quantile</a></code> function to
smaller and smaller sections of the array. Equivalent to: <code>for(i
  in 1:k2) out[i]=quantile(x[1:(i+k2)])</code>.
* <code>"trim"</code> Trim the ends; output array length is equal to
<code>length(x)-2*k2 (out = out[(k2+1):(n-k2)])</code>. This option mimics
output of <code><a href="base.html#topic+apply">apply</a></code> <code>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code> and
other related functions.
* <code>"keep"</code> Fill the ends with numbers from <code>x</code> vector
<code>(out[1:k2] = x[1:k2])</code>
* <code>"constant"</code> Fill the ends with first and last calculated value
in output array <code>(out[1:k2] = out[k2+1])</code>
* <code>"NA"</code> Fill the ends with NA's <code>(out[1:k2] = NA)</code>
* <code>"func"</code> Same as <code>"quantile"</code> but implimented in R. This
option could be very slow, and is included mostly for testing</p>
</td></tr>
<tr><td><code id=".runquantile_+3A_align">align</code></td>
<td>
<p>specifies whether result should be centered (default),
left-aligned or right-aligned.  If <code>endrule</code>=&quot;quantile&quot; then
setting <code>align</code> to &quot;left&quot; or &quot;right&quot; will fall back on slower
implementation equivalent to <code>endrule</code>=&quot;func&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apart from the end values, the result of y = runquantile(x, k) is the
same as &ldquo;<code>for(j=(1+k2):(n-k2))
y[j]=quintile(x[(j-k2):(j+k2)],na.rm = TRUE)</code>&rdquo;. It can handle
non-finite numbers like NaN's and Inf's (like <code><a href="stats.html#topic+quantile">quantile</a>(x,
na.rm = TRUE)</code>).
</p>
<p>The main incentive to write this set of functions was relative slowness
of majority of moving window functions available in R and its packages.
All functions listed in &quot;see also&quot; section are slower than very
inefficient &ldquo;<code><a href="base.html#topic+apply">apply</a>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code>&rdquo;
approach. Relative speeds of <code>runquantile</code> is O(n*k)
</p>
<p>Function <code>runquantile</code> uses insertion sort to sort the moving
window, but gain speed by remembering results of the previous
sort. Since each time the window is moved, only one point changes, all
but one points in the window are already sorted. Insertion sort can fix
that in O(k) time.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a matrix than function <code>runquantile</code> returns a
matrix of size [n <code class="reqn">\times</code> <code><a href="base.html#topic+length">length</a></code>(probs)]. If
<code>x</code> is vactor a than function <code>runquantile</code> returns a matrix
of size [<code><a href="base.html#topic+dim">dim</a></code>(x) <code class="reqn">\times</code>
<code><a href="base.html#topic+length">length</a></code>(probs)].  If <code>endrule="trim"</code> the output will
have fewer rows.
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a>
</p>


<h3>References</h3>

<p>About quantiles: Hyndman, R. J. and Fan, Y. (1996) <em>Sample
quantiles in statistical packages, American Statistician</em>, 50, 361.
</p>
<p>About quantiles: Eric W. Weisstein. <em>Quantile</em>. From MathWorld&ndash; A
Wolfram Web Resource. <a href="http://mathworld.wolfram.com/Quantile.html">http://mathworld.wolfram.com/Quantile.html</a>
</p>
<p>About insertion sort used in <code>runmad</code> and <code>runquantile</code>: R.
Sedgewick (1988): <em>Algorithms</em>. Addison-Wesley (page 99)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## show plot using runquantile
k &lt;- 31; n &lt;- 200
x &lt;- rnorm(n, sd=30) + abs(seq(n)-n/4)
y &lt;- diveMove:::.runquantile(x, k, probs=c(0.05, 0.25, 0.5, 0.75, 0.95))
col &lt;- c("black", "red", "green", "blue", "magenta", "cyan")
plot(x, col=col[1], main="Moving Window Quantiles")
lines(y[,1], col=col[2])
lines(y[,2], col=col[3])
lines(y[,3], col=col[4])
lines(y[,4], col=col[5])
lines(y[,5], col=col[6])
lab=c("data", "runquantile(.05)", "runquantile(.25)", "runquantile(0.5)",
      "runquantile(.75)", "runquantile(.95)")
legend(0,230, lab, col=col, lty=1)

## basic tests against apply/embed
a &lt;- diveMove:::.runquantile(x, k, c(0.3, 0.7), endrule="trim")
b &lt;- t(apply(embed(x, k), 1, quantile, probs=c(0.3, 0.7)))
eps &lt;- .Machine$double.eps ^ 0.5
stopifnot(all(abs(a - b) &lt; eps))

## Test against loop approach

## This test works fine at the R prompt but fails during package check -
## need to investigate
k &lt;- 25; n &lt;- 200
x &lt;- rnorm(n, sd=30) + abs(seq(n) - n / 4) # create random data
x[seq(1, n, 11)] &lt;- NaN;                   # add NANs
k2 &lt;- k %/% 2
k1 &lt;- k - k2 - 1
a &lt;- diveMove:::.runquantile(x, k, probs=c(0.3, 0.8))
b &lt;- matrix(0, n, 2)
for(j in 1:n) {
    lo &lt;- max(1, j - k1)
    hi &lt;- min(n, j + k2)
    b[j, ] &lt;- quantile(x[lo:hi], probs=c(0.3, 0.8), na.rm=TRUE)
}
## stopifnot(all(abs(a-b)&lt;eps));

## Compare calculation of array ends
a &lt;- diveMove:::.runquantile(x, k, probs=0.4,
                             endrule="quantile") # fast C code
b &lt;- diveMove:::.runquantile(x, k, probs=0.4,
                             endrule="func")     # slow R code
stopifnot(all(abs(a - b) &lt; eps))

## Test if moving windows forward and backward gives the same results
k &lt;- 51
a &lt;- diveMove:::.runquantile(x, k, probs=0.4)
b &lt;- diveMove:::.runquantile(x[n:1], k, probs=0.4)
stopifnot(all(a[n:1]==b, na.rm=TRUE))

## Test vector vs. matrix inputs, especially for the edge handling
nRow &lt;- 200; k &lt;- 25; nCol &lt;- 10
x &lt;- rnorm(nRow, sd=30) + abs(seq(nRow) - n / 4)
x[seq(1, nRow, 10)] &lt;- NaN              # add NANs
X &lt;- matrix(rep(x, nCol), nRow, nCol)   # replicate x in columns of X
a &lt;- diveMove:::.runquantile(x, k, probs=0.6)
b &lt;- diveMove:::.runquantile(X, k, probs=0.6)
stopifnot(all(abs(a - b[, 1]) &lt; eps))    # vector vs. 2D array
stopifnot(all(abs(b[, 1] - b[, nCol]) &lt; eps)) # compare rows within 2D array

## Exhaustive testing of runquantile to standard R approach
numeric.test &lt;- function (x, k) {
  probs &lt;- c(1, 25, 50, 75, 99) / 100
  a &lt;- diveMove:::.runquantile(x, k, c(0.3, 0.7), endrule="trim")
  b &lt;- t(apply(embed(x, k), 1, quantile, probs=c(0.3, 0.7), na.rm=TRUE))
  eps &lt;- .Machine$double.eps ^ 0.5
  stopifnot(all(abs(a - b) &lt; eps))
}
n &lt;- 50
x &lt;- rnorm(n,sd=30) + abs(seq(n) - n / 4) # nice behaving data
for(i in 2:5) numeric.test(x, i)          # test small window sizes
for(i in 1:5) numeric.test(x, n - i + 1)  # test large window size
x[seq(1, 50, 10)] &lt;- NaN                  # add NANs and repet the test
for(i in 2:5) numeric.test(x, i)          # test small window sizes
for(i in 1:5) numeric.test(x, n - i + 1)  # test large window size

## Speed comparison
## Not run: 
x &lt;- runif(1e6); k=1e3 + 1
system.time(diveMove:::.runquantile(x, k, 0.5)) # Speed O(n*k)

## End(Not run)
</code></pre>

<hr>
<h2 id='austFilter'>Filter satellite locations</h2><span id='topic+austFilter'></span><span id='topic+grpSpeedFilter'></span><span id='topic+rmsDistFilter'></span>

<h3>Description</h3>

<p>Apply a three stage algorithm to eliminate erroneous locations, based
on established procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>austFilter(
  time,
  lon,
  lat,
  id = gl(1, 1, length(time)),
  speed.thr,
  dist.thr,
  window = 5,
  ...
)

grpSpeedFilter(x, speed.thr, window = 5, ...)

rmsDistFilter(x, speed.thr, window = 5, dist.thr, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="austFilter_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> object with dates and times for each point.</p>
</td></tr>
<tr><td><code id="austFilter_+3A_lon">lon</code></td>
<td>
<p>numeric vectors of longitudes, in decimal degrees.</p>
</td></tr>
<tr><td><code id="austFilter_+3A_lat">lat</code></td>
<td>
<p>numeric vector of latitudes, in decimal degrees.</p>
</td></tr>
<tr><td><code id="austFilter_+3A_id">id</code></td>
<td>
<p>A factor grouping points in different categories
(e.g. individuals).</p>
</td></tr>
<tr><td><code id="austFilter_+3A_speed.thr">speed.thr</code></td>
<td>
<p>numeric scalar: speed threshold (m/s) above which
filter tests should fail any given point.</p>
</td></tr>
<tr><td><code id="austFilter_+3A_dist.thr">dist.thr</code></td>
<td>
<p>numeric scalar: distance threshold (km) above which the
last filter test should fail any given point.</p>
</td></tr>
<tr><td><code id="austFilter_+3A_window">window</code></td>
<td>
<p>integer: the size of the moving window over which tests
should be carried out.</p>
</td></tr>
<tr><td><code id="austFilter_+3A_...">...</code></td>
<td>
<p>Arguments ultimately passed to <code><a href="#topic+distSpeed">distSpeed</a></code>.</p>
</td></tr>
<tr><td><code id="austFilter_+3A_x">x</code></td>
<td>
<p>3-column matrix with column 1: <code>POSIXct</code> vector; column
2: numeric longitude vector; column 3: numeric latitude vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implement the location filtering procedure outlined in
Austin et al. (2003).  <code>grpSpeedFilter</code> and <code>rmsDistFilter</code>
can be used to perform only the first stage or the second and third
stages of the algorithm on their own, respectively.  Alternatively, the
three filters can be run in a single call using <code>austFilter</code>.
</p>
<p>The first stage of the filter is an iterative process which tests every
point, except the first and last (<var>w</var>/2) - 1 (where <var>w</var> is the
window size) points, for travel velocity relative to the
preceeding/following (<var>w</var>/2) - 1 points. If all <var>w</var> - 1 speeds
are greater than the specified threshold, the point is marked as
failing the first stage. In this case, the next point is tested,
removing the failing point from the set of test points.
</p>
<p>The second stage runs McConnell et al. (1992) algorithm, which tests
all the points that passed the first stage, in the same manner as
above. The root mean square of all <var>w</var> - 1 speeds is calculated,
and if it is greater than the specified threshold, the point is marked
as failing the second stage (see Warning section below).
</p>
<p>The third stage is run simultaneously with the second stage, but if the
mean distance of all <var>w</var> - 1 pairs of points is greater than the
specified threshold, then the point is marked as failing the third
stage.
</p>
<p>The speed and distance threshold should be obtained separately (see
<code><a href="#topic+distSpeed">distSpeed</a></code>).
</p>


<h3>Value</h3>

<p><code>rmsDistFilter</code> and <code>austFilter</code> return a matrix with 2 or 3
columns, respectively, of logical vectors with values TRUE for points
that passed each stage.  For the latter, positions that fail the first
stage fail the other stages too.  The second and third columns returned
by <code>austFilter</code>, as well as those returned by <code>rmsDistFilter</code>
are independent of one another; i.e. positions that fail stage 2 do not
necessarily fail stage 3.
</p>
<p><code>grpSpeedFilter</code> logical vector indicating those lines
that passed the test.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>grpSpeedFilter</code>: Do stage one on 3-column matrix <code>x</code>
</p>
</li>
<li> <p><code>rmsDistFilter</code>: Apply McConnell et al's filter and Austin et
al's last stage
</p>
</li></ul>


<h3>Warning</h3>

<p>This function applies McConnell et al.'s filter as described in Freitas
et al. (2008).  According to the original description of the algorithm
in McConnell et al. (1992), the filter makes a single pass through all
locations.  Austin et al. (2003) and other authors may have used the
filter this way.  However, as Freitas et al. (2008) noted, this causes
locations adjacent to those flagged as failing to fail also, thereby
rejecting too many locations.  In diveMove, the algorithm was modified
to reject only the &ldquo;peaks&rdquo; in each series of consecutive
locations having root mean square speed higher than threshold.
</p>


<h3>Author(s)</h3>

<p>Sebastian Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a> and Andy Liaw.
</p>


<h3>References</h3>

<p>McConnell BJ, Chambers C, Fedak MA. 1992. Foraging ecology of southern
elephant seals in relation to bathymetry and productivity of the
Southern Ocean. <em>Antarctic Science</em> 4:393-398.
</p>
<p>Austin D, McMillan JI, Bowen D. 2003. A three-stage algorithm for
filtering erroneous Argos satellite locations. <em>Marine Mammal
Science</em> 19: 371-383.
</p>
<p>Freitas C, Lydersen, C, Fedak MA, Kovacs KM. 2008. A simple new
algorithm to filter marine mammal ARGOS locations. Marine Mammal
Science DOI: 10.1111/j.1748-7692.2007.00180.x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distSpeed">distSpeed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the Example from '?readLocs':
utils::example("readLocs", package="diveMove",
               ask=FALSE, echo=FALSE)
ringy &lt;- subset(locs, id == "ringy" &amp; !is.na(lon) &amp; !is.na(lat))

## Examples below use default Meeus algorithm for computing distances.
## See ?distSpeed for specifying other methods.
## Austin et al.'s group filter alone
grp &lt;- grpSpeedFilter(ringy[, 3:5], speed.thr=1.1)

## McConnell et al.'s filter (root mean square test), and distance test
## alone
rms &lt;- rmsDistFilter(ringy[, 3:5], speed.thr=1.1, dist.thr=300)

## Show resulting tracks
n &lt;- nrow(ringy)
plot.nofilter &lt;- function(main) {
    plot(lat ~ lon, ringy, type="n", main=main)
    with(ringy, segments(lon[-n], lat[-n], lon[-1], lat[-1]))
}
layout(matrix(1:4, ncol=2, byrow=TRUE))
plot.nofilter(main="Unfiltered Track")
plot.nofilter(main="Group Filter")
n1 &lt;- length(which(grp))
with(ringy[grp, ], segments(lon[-n1], lat[-n1], lon[-1], lat[-1],
                            col="blue"))
plot.nofilter(main="Root Mean Square Filter")
n2 &lt;- length(which(rms[, 1]))
with(ringy[rms[, 1], ], segments(lon[-n2], lat[-n2], lon[-1], lat[-1],
                                 col="red"))
plot.nofilter(main="Distance Filter")
n3 &lt;- length(which(rms[, 2]))
with(ringy[rms[, 2], ], segments(lon[-n3], lat[-n3], lon[-1], lat[-1],
                                 col="green"))

## All three tests (Austin et al. procedure)
austin &lt;- with(ringy, austFilter(time, lon, lat, speed.thr=1.1,
                                 dist.thr=300))
layout(matrix(1:4, ncol=2, byrow=TRUE))
plot.nofilter(main="Unfiltered Track")
plot.nofilter(main="Stage 1")
n1 &lt;- length(which(austin[, 1]))
with(ringy[austin[, 1], ], segments(lon[-n1], lat[-n1], lon[-1], lat[-1],
                                    col="blue"))
plot.nofilter(main="Stage 2")
n2 &lt;- length(which(austin[, 2]))
with(ringy[austin[, 2], ], segments(lon[-n2], lat[-n2], lon[-1], lat[-1],
                                    col="red"))
plot.nofilter(main="Stage 3")
n3 &lt;- length(which(austin[, 3]))
with(ringy[austin[, 3], ], segments(lon[-n3], lat[-n3], lon[-1], lat[-1],
                                    col="green"))
</code></pre>

<hr>
<h2 id='bec+2Cnls-method'>Calculate bout ending criteria from model coefficients</h2><span id='topic+bec+2Cnls-method'></span><span id='topic+bec'></span><span id='topic+bec+2Cmle-method'></span>

<h3>Description</h3>

<p>Calculate bout ending criteria from model coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nls'
bec(fit)

## S4 method for signature 'mle'
bec(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bec+2B2Cnls-method_+3A_fit">fit</code></td>
<td>
<p>Object of class <code>nls</code> or <code>mle</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> vector with the bout ending criterion or
criteria derived from the model.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>bec,nls-method</code>: Calculate BEC on <code>nls</code> object
</p>
</li>
<li> <p><code>bec,mle-method</code>: Calculate BEC on <code>mle</code> object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>

<hr>
<h2 id='boutfreqs'>Histogram of log-transformed frequencies</h2><span id='topic+boutfreqs'></span>

<h3>Description</h3>

<p>Histogram of log-transformed frequencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boutfreqs(x, bw, method = c("standard", "seq.diff"), plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boutfreqs_+3A_x">x</code></td>
<td>
<p>numeric vector on which bouts will be identified based on
&ldquo;method&rdquo;. For <code>labelBouts</code> it can also be a matrix with
different variables for which bouts should be identified.</p>
</td></tr>
<tr><td><code id="boutfreqs_+3A_bw">bw</code></td>
<td>
<p>numeric scalar: bin width for the histogram.</p>
</td></tr>
<tr><td><code id="boutfreqs_+3A_method">method</code></td>
<td>
<p>character: method used for calculating the frequencies:
&ldquo;standard&rdquo; simply uses x, while &ldquo;seq.diff&rdquo; uses the
sequential differences method.</p>
</td></tr>
<tr><td><code id="boutfreqs_+3A_plot">plot</code></td>
<td>
<p>logical, whether to plot results or not.</p>
</td></tr>
<tr><td><code id="boutfreqs_+3A_...">...</code></td>
<td>
<p>For <code>boutfreqs</code>, arguments passed to hist (must exclude
<code>breaks</code> and <code>include.lowest</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>boutfreqs</code> returns an object of class <code>Bouts</code>, with slot
<code>lnfreq</code> consisting of a data frame with components <var>lnfreq</var>
containing the log frequencies and <var>x</var>, containing the
corresponding mid points of the histogram.  Empty bins are excluded. A
plot (histogram of <em>input data</em>) is produced as a side effect if
argument plot is <code>TRUE</code>.  See the Details section.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>

<hr>
<h2 id='boutinit+2Cdata.frame-method'>Fit &quot;broken stick&quot; model to log frequency data for identification of
bouts of behaviour</h2><span id='topic+boutinit+2Cdata.frame-method'></span><span id='topic+boutinit'></span><span id='topic+boutinit+2CBouts-method'></span>

<h3>Description</h3>

<p>Fits &quot;broken stick&quot; model to the log frequencies modelled as a function
of <var>x</var> (well, the midpoints of the binned data), using chosen
value(s) to separate the two or three processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
boutinit(obj, x.break, plot = TRUE, ...)

## S4 method for signature 'Bouts'
boutinit(obj, x.break, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boutinit+2B2Cdata.frame-method_+3A_obj">obj</code></td>
<td>
<p>Object of class <code><a href="#topic+Bouts">Bouts</a></code> or
<code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="boutinit+2B2Cdata.frame-method_+3A_x.break">x.break</code></td>
<td>
<p>Numeric vector of length 1 or 2 with <code>x</code> value(s)
defining the break(s) point(s) for broken stick model, such that
<code>x</code> &lt; <code>x.break</code>[1] is 1st process, and <code>x</code> &gt;=
<code>x.break</code>[1] &amp; <code>x</code> &lt; <code>x.break</code>[2] is 2nd one, and
<code>x</code> &gt;= <code>x.break</code>[2] is 3rd one.</p>
</td></tr>
<tr><td><code id="boutinit+2B2Cdata.frame-method_+3A_plot">plot</code></td>
<td>
<p>logical, whether to plot results or not.</p>
</td></tr>
<tr><td><code id="boutinit+2B2Cdata.frame-method_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+plot">plot</a></code> (must exclude
<code>type</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(2,N) matrix with as many columns as the number of processes
implied by <code>x.break</code> (i.e. <code>length(x.break) + 1</code>). Rows
are named <code>a</code> and <code>lambda</code>, corresponding to starting
values derived from broken stick model.  A plot is produced as a
side effect if argument <code>plot</code> is <code>TRUE</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>data.frame</code>: Fit &quot;broken-stick&quot; model on <code>data.frame</code>
object
</p>
</li>
<li> <p><code>Bouts</code>: Fit &quot;broken-stick&quot; model on <code>Bouts</code> object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 2-process
utils::example("rmixexp", package="diveMove", ask=FALSE)
## 'rndproc2' is a random sample vector from the example
xbouts2 &lt;- boutfreqs(rndprocs2, 5)  # Bouts class result
(startval2 &lt;- boutinit(xbouts2, 80))

## 3-process
## 'rndproc3' is a random sample vector from the example
xbouts3 &lt;- boutfreqs(rndprocs3, 5)
(startval3 &lt;- boutinit(xbouts3, c(75, 220)))
</code></pre>

<hr>
<h2 id='Bouts-class'>Class &quot;Bouts&quot; for representing Poisson mixtures for identification of
behavioural bouts</h2><span id='topic+Bouts-class'></span><span id='topic+Bouts'></span>

<h3>Description</h3>

<p>Base class for storing key information for modelling and detecting
bouts in behavioural data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>Object of class <code>"numeric"</code>.  Data to be modelled.</p>
</dd>
<dt><code>method</code></dt><dd><p>Object of class <code>"character"</code>.  A string indicating
the type of frequency to calculate from <code>x</code>: &quot;standard&quot; or
&quot;seq.diff&quot;.  If &quot;standard&quot;, frequencies are calculated directly
from <code>x</code>, and from the sequential differences in <code>x</code>
otherwise.</p>
</dd>
<dt><code>lnfreq</code></dt><dd><p>Object of class <code><a href="base.html#topic+data.frame">data.frame</a></code>.  Columns named
<var>lnfreq</var> (log frequencies) and <var>x</var> (mid points of histogram
bins).</p>
</dd>
</dl>


<h3>Objects from the class</h3>

<p>Objects can be created most conveniently via the
<code><a href="#topic+boutfreqs">boutfreqs</a></code> function, which sets the <code>lnfreq</code> slot,
but can also be created via <code>new("Bouts")</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boutfreqs">boutfreqs</a></code>
</p>

<hr>
<h2 id='boutsCDF'>Estimated cumulative frequency for two- or three-process Poisson
mixture models</h2><span id='topic+boutsCDF'></span>

<h3>Description</h3>

<p>Estimated cumulative frequency for two- or three-process Poisson
mixture models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boutsCDF(x, p, lambdas)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boutsCDF_+3A_x">x</code></td>
<td>
<p>numeric vector described by model.</p>
</td></tr>
<tr><td><code id="boutsCDF_+3A_p">p</code></td>
<td>
<p>numeric scalar or vector of proportion parameters.</p>
</td></tr>
<tr><td><code id="boutsCDF_+3A_lambdas">lambdas</code></td>
<td>
<p>numeric vector of rate parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with cumulative frequency.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::example("rmixexp", package="diveMove", ask=FALSE)
## boutsCDF(rndprocs3, p=p_true, lambdas=lda_true)
</code></pre>

<hr>
<h2 id='boutsMLEll.chooser'>Log likelihood function of parameters given observed data</h2><span id='topic+boutsMLEll.chooser'></span><span id='topic+.bouts2MLEll'></span><span id='topic+.bouts3MLEll'></span>

<h3>Description</h3>

<p>This function defines a closure, where <code>x</code> will be the object
passed to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boutsMLEll.chooser(x, x0, transformed = TRUE)

.bouts2MLEll(x, p, lambda0, lambda1)

.bouts3MLEll(x, p0, p1, lambda0, lambda1, lambda2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boutsMLEll.chooser_+3A_x">x</code></td>
<td>
<p>numeric vector of independent data to be described by the
function.</p>
</td></tr>
<tr><td><code id="boutsMLEll.chooser_+3A_x0">x0</code></td>
<td>
<p>numerical one-dimensional vector of coefficients.</p>
</td></tr>
<tr><td><code id="boutsMLEll.chooser_+3A_transformed">transformed</code></td>
<td>
<p>logical indicating whether coefficients need to be
transformed back to original scale to compute the negative log
likelihood.</p>
</td></tr>
<tr><td><code id="boutsMLEll.chooser_+3A_p">p</code>, <code id="boutsMLEll.chooser_+3A_lambda0">lambda0</code>, <code id="boutsMLEll.chooser_+3A_lambda1">lambda1</code></td>
<td>
<p>numeric: parameters of the model.</p>
</td></tr>
<tr><td><code id="boutsMLEll.chooser_+3A_p0">p0</code>, <code id="boutsMLEll.chooser_+3A_p1">p1</code>, <code id="boutsMLEll.chooser_+3A_lambda2">lambda2</code></td>
<td>
<p>numeric: parameters of the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ll.chooser</code> returns the negative log likelihood function
of the joint distribution.
</p>
<p>numeric vector
</p>
<p>numeric vector
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>.bouts2MLEll</code>: Log likelihood function in a 2-process Poisson
mixture
</p>
</li>
<li> <p><code>.bouts3MLEll</code>: Log likelihood function in a 3-process Poisson
mixture
</p>
</li></ul>

<hr>
<h2 id='boutsNLSll+2CBouts-method'>Generalized log likelihood function taking any number of Poisson
processes in a &quot;broken-stick&quot; model</h2><span id='topic+boutsNLSll+2CBouts-method'></span><span id='topic+boutsNLSll'></span><span id='topic+boutsNLSll+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generalized log likelihood function taking any number of Poisson
processes in a &quot;broken-stick&quot; model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Bouts'
boutsNLSll(obj, coefs)

## S4 method for signature 'numeric'
boutsNLSll(obj, coefs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boutsNLSll+2B2CBouts-method_+3A_obj">obj</code></td>
<td>
<p>Object of class <code><a href="#topic+Bouts">Bouts</a></code> or numeric vector of
independent data to be described by the function.</p>
</td></tr>
<tr><td><code id="boutsNLSll+2B2CBouts-method_+3A_coefs">coefs</code></td>
<td>
<p>matrix of coefficients (<code>a</code> and <code>lambda</code>) in
rows for each process of the model in columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector as <code>x</code> with the evaluated function.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>Bouts</code>: Log likelihood <code>Bouts</code> method
</p>
</li>
<li> <p><code>numeric</code>: Log likelihood function <code>numeric</code> method
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>

<hr>
<h2 id='calc.p'>Utilities for Poisson mixture analyses</h2><span id='topic+calc.p'></span><span id='topic+build.p.lambda'></span><span id='topic+logit'></span><span id='topic+unLogit'></span>

<h3>Description</h3>

<p><code>calc.p</code> computes <code>p</code> (proportion) parameter from <code>a</code>
and <code>lambda</code> coefficients in a broken stick model.
</p>
<p><code>build.p.lambda</code> parses the <code>x</code> vector, usually returned by
the <code>coef</code> method, where <code class="reqn">x =
(p_0,\dots,p_n,\lambda_1,\dots,\lambda_{n+1})</code>,
and build a named list with <code>p</code> and <code>lambda</code> elements to use
in fitting functions.
</p>
<p><code>logit</code> and <code>unLogit</code> are helpful for reparameterizing the
negative maximum likelihood function, if using Langton et al. (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.p(coefs)

build.p.lambda(x)

logit(p)

unLogit(logit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.p_+3A_coefs">coefs</code></td>
<td>
<p>numeric matrix [2,N] of coefficients (<code>a</code> and
<code>lambda</code>) in rows for each process of the model in columns.
Columns are assumed to be in decreasing order with respect to
<code>lambda</code></p>
</td></tr>
<tr><td><code id="calc.p_+3A_x">x</code></td>
<td>
<p>numeric vector of coefficients</p>
</td></tr>
<tr><td><code id="calc.p_+3A_p">p</code></td>
<td>
<p>numeric vector of proportions (0-1) to transform to the logit
scale.</p>
</td></tr>
<tr><td><code id="calc.p_+3A_logit">logit</code></td>
<td>
<p>numeric scalar: logit value to transform back to original
scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with proportion parameters implied by
<code>coefs</code>.
</p>
<p>named (<code>p</code>, <code>lambda</code>) list with parsed coefficients.
</p>
<p><code>unLogit</code> and <code>logit</code> return a numeric vector with
the (un)transformed arguments.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>

<hr>
<h2 id='calibrateDepth'>Calibrate Depth and Generate a &quot;TDRcalibrate&quot; object</h2><span id='topic+calibrateDepth'></span>

<h3>Description</h3>

<p>Detect periods of major activities in a <abbr><span class="acronym">TDR</span></abbr> record, calibrate
depth readings, and generate a <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> object
essential for subsequent summaries of diving behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrateDepth(
  x,
  dry.thr = 70,
  wet.cond,
  wet.thr = 3610,
  dive.thr = 4,
  zoc.method = c("visual", "offset", "filter"),
  ...,
  interp.wet = FALSE,
  dive.model = c("unimodal", "smooth.spline"),
  smooth.par = 0.1,
  knot.factor = 3,
  descent.crit.q = 0,
  ascent.crit.q = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibrateDepth_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+TDR">TDR</a></code> for
<code><a href="#topic+calibrateDepth">calibrateDepth</a></code> or an object of class
<code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> for <code><a href="#topic+calibrateSpeed">calibrateSpeed</a></code>.</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_dry.thr">dry.thr</code></td>
<td>
<p>numeric: dry error threshold in seconds.  Dry phases
shorter than this threshold will be considered as wet.</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_wet.cond">wet.cond</code></td>
<td>
<p>logical: indicates which observations should be
considered wet.  If it is not provided, records with non-missing
depth are assumed to correspond to wet conditions (see
&lsquo;Details&rsquo; and &lsquo;Note&rsquo; below).</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_wet.thr">wet.thr</code></td>
<td>
<p>numeric: wet threshold in seconds. At-sea phases shorter
than this threshold will be considered as trivial wet.</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_dive.thr">dive.thr</code></td>
<td>
<p>numeric: threshold depth below which an underwater
phase should be considered a dive.</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_zoc.method">zoc.method</code></td>
<td>
<p>character string to indicate the method to use for
zero offset correction.  One of &ldquo;visual&rdquo;, &ldquo;offset&rdquo;,
or &ldquo;filter&rdquo; (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_...">...</code></td>
<td>
<p>Arguments required for ZOC methods <code>filter</code> (<code>k</code>,
<code>probs</code>, <code>depth.bounds</code> (defaults to range), <code>na.rm</code>
(defaults to TRUE)) and <code>offset</code> (<code>offset</code>).</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_interp.wet">interp.wet</code></td>
<td>
<p>logical: if TRUE (default is FALSE), then an
interpolating spline function is used to impute NA depths in wet
periods (<em>after ZOC</em>).  <em>Use with caution</em>: it may only
be useful in cases where the missing data pattern in wet periods is
restricted to shallow depths near the beginning and end of dives.
This pattern is common in some satellite-linked <abbr><span class="acronym">TDR</span></abbr>s.</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_dive.model">dive.model</code></td>
<td>
<p>character string specifying what model to use for
each dive for the purpose of dive phase identification.  One of
&ldquo;smooth.spline&rdquo; or &ldquo;unimodal&rdquo;, to choose among
smoothing spline or unimodal regression (see &lsquo;Details&rsquo;).
For dives with less than five observations, smoothing spline
regression is used regardless (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_smooth.par">smooth.par</code></td>
<td>
<p>numeric scalar representing amount of smoothing
(argument <code>spar</code> in <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>) when
<code>dive.model="smooth.spline"</code>.  If it is NULL, then the
smoothing parameter is determined by Generalized Cross-validation
(GCV). Ignored with default <code>dive.model="unimodal"</code>.</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_knot.factor">knot.factor</code></td>
<td>
<p>numeric scalar that multiplies the number of samples
in the dive.  This is used to construct the time predictor for the
derivative.</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_descent.crit.q">descent.crit.q</code></td>
<td>
<p>numeric: critical quantile of rates of descent
below which descent is deemed to have ended.</p>
</td></tr>
<tr><td><code id="calibrateDepth_+3A_ascent.crit.q">ascent.crit.q</code></td>
<td>
<p>numeric: critical quantile of rates of ascent
above which ascent is deemed to have started.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is really a wrapper around <code>.detPhase</code>,
<code>.detDive</code>, and <code>.zoc</code> which perform the work on simplified
objects.  It performs wet/dry phase detection, zero-offset correction
of depth, and detection of dives, as well as proper labelling of the
latter.
</p>
<p>The procedure starts by zero-offset correcting depth (see &lsquo;ZOC&rsquo;
below), and then a factor is created with value &ldquo;L&rdquo; (dry) for
rows with NAs for <code>depth</code> and value &ldquo;W&rdquo; (wet) otherwise.
This assumes that <abbr><span class="acronym">TDR</span></abbr>s were programmed to turn off recording
of depth when instrument is dry (typically by means of a salt-water
switch).  If this assumption cannot be made for any reason, then a
logical vector as long as the time series should be supplied as
argument <code>wet.cond</code> to indicate which observations should be
considered wet.  This argument is directly analogous to the
<code>subset</code> argument in <code><a href="base.html#topic+subset.data.frame">subset.data.frame</a></code>, so it can
refer to any variable in the <code><a href="#topic+TDR">TDR</a></code> object (see
&lsquo;Note&rsquo; section below).  The duration of each of these phases of
activity is subsequently calculated.  If the duration of a dry phase
(&ldquo;L&rdquo;) is less than <code>dry.thr</code>, then the values in the factor
for that phase are changed to &ldquo;W&rdquo; (wet).  The duration of phases
is then recalculated, and if the duration of a phase of wet activity is
less than <code>wet.thr</code>, then the corresponding value for the factor
is changed to &ldquo;Z&rdquo; (trivial wet).  The durations of all phases
are recalculated a third time to provide final phase durations.
</p>
<p>Some instruments produce a peculiar pattern of missing data near the
surface, at the beginning and/or end of dives.  The argument
<code>interp.wet</code> may help to rectify this problem by using an
interpolating spline function to impute the missing data, constraining
the result to a minimum depth of zero.  Please note that this optional
step is performed after ZOC and before identifying dives, so that
interpolation is performed through dry phases coded as wet because
their duration was briefer than <code>dry.thr</code>.  Therefore,
<code>dry.thr</code> must be chosen carefully to avoid interpolation through
legitimate dry periods.
</p>
<p>The next step is to detect dives whenever the zero-offset corrected
depth in an underwater phase is below the specified dive threshold.  A
new factor with finer levels of activity is thus generated, including
&ldquo;U&rdquo; (underwater), and &ldquo;D&rdquo; (diving) in addition to the
ones described above.
</p>
<p>Once dives have been detected and assigned to a period of wet activity,
phases within dives are identified using the descent, ascent and wiggle
criteria (see &lsquo;Detection of dive phases&rsquo; below).  This procedure
generates a factor with levels &ldquo;D&rdquo;, &ldquo;DB&rdquo;, &ldquo;B&rdquo;,
&ldquo;BA&rdquo;, &ldquo;DA&rdquo;, &ldquo;A&rdquo;, and &ldquo;X&rdquo;, breaking the
input into descent, descent/bottom, bottom, bottom/ascent, ascent,
descent/ascent (ocurring when no bottom phase can be detected) and
non-dive (surface), respectively.
</p>
<p>## ZOC
</p>
<p>This procedure is required to correct drifts in the pressure transducer
of <abbr><span class="acronym">TDR</span></abbr> records and noise in depth measurements.  Three
methods are available to perform this correction.
</p>
<p>Method &ldquo;visual&rdquo; calls <code><a href="#topic+plotTDR">plotTDR</a></code>, which plots depth
and, optionally, speed vs. time with the ability of zooming in and out
on time, changing maximum depths displayed, and panning through time.
The button to zero-offset correct sections of the record allows for the
collection of &lsquo;x&rsquo; and &lsquo;y&rsquo; coordinates for two points,
obtained by clicking on the plot region. The first point clicked
represents the offset and beginning time of section to correct, and the
second one represents the ending time of the section to correct.
Multiple sections of the record can be corrected in this manner, by
panning through the time and repeating the procedure.  In case there's
overlap between zero offset corrected windows, the last one prevails.
</p>
<p>Method &ldquo;offset&rdquo; can be used when the offset is known in advance,
and this value is used to correct the entire time series.  Therefore,
offset=0 specifies no correction.
</p>
<p>Method &ldquo;filter&rdquo; implements a smoothing/filtering mechanism where
running quantiles can be applied to depth measurements in a recursive
manner (Luque and Fried 2011), using <code>.depth.filter</code>.  The method
calculates the first running quantile defined by <code>probs[1]</code> on a
moving window of size <code>k[1]</code>.  The next running quantile, defined
by <code>probs[2]</code> and <code>k[2]</code>, is applied to the smoothed/filtered
depth measurements from the previous step, and so on.  The corrected
depth measurements (d) are calculated as:
</p>
<p style="text-align: center;"><code class="reqn">d=d_{0} - d_{n}</code>
</p>

<p>where <code class="reqn">d_{0}</code> is original depth and <code class="reqn">d_{n}</code> is the
last smoothed/filtered depth.  This method is under development, but
reasonable results can be achieved by applying two filters (see
&lsquo;Examples&rsquo;).  The default <code>na.rm=TRUE</code> works well when
there are no level shifts between non-NA phases in the data, but
<code>na.rm=FALSE</code> is better in the presence of such shifts.  In other
words, there is no reason to pollute the moving window with NAs when
non-NA phases can be regarded as a continuum, so splicing non-NA phases
makes sense.  Conversely, if there are level shifts between non-NA
phases, then it is better to retain NA phases to help the algorithm
recognize the shifts while sliding the window(s).  The search for the
surface can be limited to specified bounds during smoothing/filtering,
so that observations outside these bounds are interpolated using the
bounded smoothed/filtered series.
</p>
<p>Once the whole record has been zero-offset corrected, remaining depths
below zero, are set to zero, as these are assumed to indicate values at
the surface.
</p>
<p>## Detection of dive phases
</p>
<p>The process for each dive begins by taking all observations below the
dive detection threshold, and setting the beginning and end depths to
zero, at time steps prior to the first and after the last,
respectively.  The latter ensures that descent and ascent derivatives
are non-negative and non-positive, respectively, so that the end and
beginning of these phases are not truncated.  The next step is to fit a
model to each dive.  Two models can be chosen for this purpose:
&lsquo;unimodal&rsquo; (default) and &lsquo;smooth.spline&rsquo;.
</p>
<p>Both models consist of a cubic spline, and its first derivative is
evaluated to investigate changes in vertical rate.  Therefore, at least
4 observations are required for each dive, so the time series is
linearly interpolated at equally spaced time steps if this limit is not
achieved in the current dive.  Wiggles at the beginning and end of the
dive are assumed to be zero offset correction errors, so depth
observations at these extremes are interpolated between zero and the
next observations when this occurs.
</p>
<p>### &lsquo;unimodal&rsquo;
</p>
<p>In this default model, the spline is constrained to be unimodal
(Koellmann et al. 2014), assuming the diver must return to the surface
to breathe.  The model is fitted using the uniReg package (see
<code><a href="uniReg.html#topic+unireg">unireg</a></code>).  This model and constraint are
consistent with the definition of dives in air-breathers, so is
certainly appropriate for this group of divers.  A major advantage of
this approach over the next one is that the degree of smoothing is
determined via restricted maximum likelihood, and has no influence on
identifying the transition between descent and ascent.  Therefore,
unimodal regression splines make the latter transition clearer compared
to using smoothing splines.
</p>
<p>However, note that dives with less than five samples are fit using
smoothing splines (see section below) regardless, as they produce the
same fit as unimodal regression but much faster.  Therefore, ensure
that the parameters for that model are appropriate for the data,
although defaults are reasonable.
</p>
<p>### &lsquo;smooth.spline&rsquo;
</p>
<p>In this model, specified via <code>dive.model="smooth.spline"</code>, a
smoothing spline is used to model each dive (see
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>), using the chosen smoothing parameter.
</p>
<p>Dive phases identified via this model, however, are highly sensitive to
the degree of smoothing (<code>smooth.par</code>) used, thus making it
difficult to determine what amount of smoothing is adequate.
</p>
<p>A comparison of these methods is shown in the Examples section of
<code><a href="#topic+diveModel">diveModel</a></code>.
</p>
<p>The first derivate of the spline is evaluated at a set of knots to
calculate the vertical rate throughout the dive and determine the end
of descent and beginning of ascent.  This set of knots is established
using a regular time sequence with beginning and end equal to the
extremes of the input sequence, and with length equal to <code class="reqn">N \times
knot.factor</code>.  Equivalent procedures are used
for detecting descent and ascent phases.
</p>
<p>Once one of the models above has been fitted to each dive, the quantile
corresponding to (<code>descent.crit.q</code>) of all the positive
derivatives (rate of descent) at the beginning of the dive is used as
threshold for determining the end of descent.  Descent is deemed to
have ended at the <em>first</em> minimum derivative, and the nearest
input time observation is considered to indicate the end of descent.
The sign of the comparisons is reversed for detecting the ascent.  If
observed depth to the left and right of the derivative defining the
ascent are the same, the right takes precedence.
</p>
<p>The particular dive phase categories are subsequently defined using
simple set operations.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code>.
</p>


<h3>Note</h3>

<p>Note that the condition implied with argument <code>wet.cond</code> is
evaluated after the ZOC procedure, so it can refer to corrected
depth.  In many cases, not all variables in the <code><a href="#topic+TDR">TDR</a></code>
object are sampled with the same frequency, so they may need to be
interpolated before using them for this purpose.  Note also that
any of these variables may contain similar problems as those dealth
with during ZOC, so programming instruments to record depth only
when wet is likely the best way to ensure proper detection of
wet/dry conditions.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>References</h3>

<p>Koellmann, C., Ickstadt, K. and Fried, R. (2016) Beyond unimodal
regression: modelling multimodality with piecewise unimodal or
deconvolution models. Technical Report
<a href="https://arxiv.org/abs/1606.01666">https://arxiv.org/abs/1606.01666</a>, Technische Universitt Dortmund
</p>
<p>Luque, S.P. and Fried, R. (2011) Recursive filtering for zero offset
correction of diving depth time series. PLoS ONE 6:e15850
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code>, <code><a href="#topic+.zoc">.zoc</a></code>,
<code><a href="#topic+.depthFilter">.depthFilter</a></code>, <code><a href="#topic+.detPhase">.detPhase</a></code>,
<code><a href="#topic+.detDive">.detDive</a></code>, <code><a href="#topic+plotTDR">plotTDR</a></code>, and
<code><a href="#topic+plotZOC">plotZOC</a></code> to visually assess ZOC procedure. See
<code><a href="#topic+diveModel">diveModel</a></code>, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>,
<code><a href="uniReg.html#topic+unireg">unireg</a></code> for dive models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(divesTDR)
divesTDR

## Too long for checks
## Consider a 3 m offset, a dive threshold of 3 m, the 1% quantile for
## critical vertical rates, and a set of knots 20 times as long as the
## observed time steps. Default smoothing spline model for dive phase
## detection, using default smoothing parameter.
(dcalib &lt;- calibrateDepth(divesTDR, dive.thr=3, zoc.method="offset",
                          offset=3, descent.crit.q=0.01, ascent.crit.q=0,
                          knot.factor=20))

## Or ZOC algorithmically with method="filter":
## dcalib &lt;- calibrateDepth(divesTDR, dive.thr=3, zoc.method="filter",
##                          k=c(3, 5760), probs=c(0.5, 0.02), na.rm=TRUE,
##                          descent.crit.q=0.01, ascent.crit.q=0,
##                          knot.factor=20))

## If no ZOC required:
data(divesTDRzoc)
(dcalib &lt;- calibrateDepth(divesTDRzoc, dive.thr=3, zoc.method="offset",
                          offset=0, descent.crit.q=0.01, ascent.crit.q=0,
                          knot.factor=20))


</code></pre>

<hr>
<h2 id='calibrateSpeed'>Calibrate and build a &quot;TDRcalibrate&quot; object</h2><span id='topic+calibrateSpeed'></span>

<h3>Description</h3>

<p>These functions create a <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> object which is
necessary to obtain dive summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrateSpeed(
  x,
  tau = 0.1,
  contour.level = 0.1,
  z = 0,
  bad = c(0, 0),
  main = slot(getTDR(x), "file"),
  coefs,
  plot = TRUE,
  postscript = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibrateSpeed_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+TDR">TDR</a></code> for
<code><a href="#topic+calibrateDepth">calibrateDepth</a></code> or an object of class
<code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> for <code><a href="#topic+calibrateSpeed">calibrateSpeed</a></code>.</p>
</td></tr>
<tr><td><code id="calibrateSpeed_+3A_tau">tau</code></td>
<td>
<p>numeric scalar: quantile on which to regress speed on rate
of depth change; passed to <code><a href="quantreg.html#topic+rq">rq</a></code>.</p>
</td></tr>
<tr><td><code id="calibrateSpeed_+3A_contour.level">contour.level</code></td>
<td>
<p>numeric scalar: the mesh obtained from the
bivariate kernel density estimation corresponding to this contour
will be used for the quantile regression to define the calibration
line.</p>
</td></tr>
<tr><td><code id="calibrateSpeed_+3A_z">z</code></td>
<td>
<p>numeric scalar: only changes in depth larger than this value
will be used for calibration.</p>
</td></tr>
<tr><td><code id="calibrateSpeed_+3A_bad">bad</code></td>
<td>
<p>numeric vector of length 2 indicating that only rates of
depth change and speed greater than the given value should be used
for calibration, respectively.</p>
</td></tr>
<tr><td><code id="calibrateSpeed_+3A_main">main</code>, <code id="calibrateSpeed_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+rqPlot">rqPlot</a></code>.</p>
</td></tr>
<tr><td><code id="calibrateSpeed_+3A_coefs">coefs</code></td>
<td>
<p>numeric: known speed calibration coefficients from
quantile regression as a vector of length 2 (intercept, slope).  If
provided, these coefficients are used for calibrating speed,
ignoring all other arguments, except <code>x</code>.</p>
</td></tr>
<tr><td><code id="calibrateSpeed_+3A_plot">plot</code></td>
<td>
<p>logical: whether to plot the results.</p>
</td></tr>
<tr><td><code id="calibrateSpeed_+3A_postscript">postscript</code></td>
<td>
<p>logical: whether to produce postscript file output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calibrates speed readings following the procedure outlined in
Blackwell et al. (1999).
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>References</h3>

<p>Blackwell S, Haverl C, Le Boeuf B, Costa D (1999). A method for calibrating
swim-speed recorders.  Marine Mammal Science 15(3):894-905.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Too long for checks
## Continuing the Example from '?calibrateDepth':
utils::example("calibrateDepth", package="diveMove",
               ask=FALSE, echo=FALSE, run.donttest=TRUE)
dcalib		# the 'TDRcalibrate' that was created

## Calibrate speed using only changes in depth &gt; 2 m
vcalib &lt;- calibrateSpeed(dcalib, z=2)
vcalib


</code></pre>

<hr>
<h2 id='createTDR'>Read comma-delimited file with &quot;TDR&quot; data</h2><span id='topic+createTDR'></span><span id='topic+readTDR'></span>

<h3>Description</h3>

<p>Read a delimited (*.csv) file containing time-depth recorder
(<dfn>TDR</dfn>) data from various <abbr><span class="acronym">TDR</span></abbr> models.  Return a
<code>TDR</code> or <code>TDRspeed</code> object. <code>createTDR</code> creates an
object of one of these classes from other objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTDR(
  time,
  depth,
  concurrentData = data.frame(matrix(ncol = 0, nrow = length(time))),
  speed = FALSE,
  dtime,
  file
)

readTDR(
  file,
  dateCol = 1,
  timeCol = 2,
  depthCol = 3,
  speed = FALSE,
  subsamp = 5,
  concurrentCols = 4:6,
  dtformat = "%d/%m/%Y %H:%M:%S",
  tz = "GMT",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createTDR_+3A_time">time</code></td>
<td>
<p>A <code>POSIXct</code> object with date and time readings for
each reading.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_depth">depth</code></td>
<td>
<p>numeric vector with depth readings.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_concurrentdata">concurrentData</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">data.frame</a></code> with additional,
concurrent data collected.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_speed">speed</code></td>
<td>
<p>logical: whether speed is included in one of the columns
of concurrentCols.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_dtime">dtime</code></td>
<td>
<p>numeric scalar: sampling interval used in seconds.  If
missing, it is calculated from the <code>time</code> argument.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_file">file</code></td>
<td>
<p>character: a string indicating the path to the file to
read.  This can also be a text-mode connection, as allowed in
<code><a href="utils.html#topic+read.csv">read.csv</a></code>.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_datecol">dateCol</code></td>
<td>
<p>integer: column number containing dates, and optionally,
times.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_timecol">timeCol</code></td>
<td>
<p>integer: column number with times.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_depthcol">depthCol</code></td>
<td>
<p>integer: column number containing depth readings.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_subsamp">subsamp</code></td>
<td>
<p>numeric scalar: subsample rows in <code>file</code> with
<code>subsamp</code> interval, in s.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_concurrentcols">concurrentCols</code></td>
<td>
<p>integer vector of column numbers to include as
concurrent data collected.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_dtformat">dtformat</code></td>
<td>
<p>character: a string specifying the format in which the
date and time columns, when pasted together, should be interpreted
(see <code><a href="base.html#topic+strptime">strptime</a></code>).</p>
</td></tr>
<tr><td><code id="createTDR_+3A_tz">tz</code></td>
<td>
<p>character: a string indicating the time zone assumed for the
date and time readings.</p>
</td></tr>
<tr><td><code id="createTDR_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="utils.html#topic+read.csv">read.csv</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file is assumed to have a header row identifying each field,
and all rows must be complete (i.e. have the same number of fields).
Field names need not follow any convention.  However, depth and speed
are assumed to be in m, and <code class="reqn">m \cdot s^{-1}</code>, respectively,
for further analyses.
</p>
<p>If <var>speed</var> is TRUE and concurrentCols contains a column named speed
or velocity, then an object of class <code><a href="#topic+TDRspeed">TDRspeed</a></code> is created,
where speed is considered to be the column matching this name.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+TDR">TDR</a></code> or <code><a href="#topic+TDRspeed">TDRspeed</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>readTDR</code>: Create TDR object from file
</p>
</li></ul>


<h3>Note</h3>

<p>Although <code><a href="#topic+TDR">TDR</a></code> and <code><a href="#topic+TDRspeed">TDRspeed</a></code> classes
check that time stamps are in increasing order, the integrity of
the input must be thoroughly verified for common errors present in
text output from <abbr><span class="acronym">TDR</span></abbr> devices such as duplicate records,
missing time stamps and non-numeric characters in numeric fields.
These errors are much more efficiently dealt with outside of
<abbr><span class="acronym">GNU</span></abbr> using tools like <code>GNU awk</code> or <code>GNU sed</code>, so
<code><a href="#topic+diveMove">diveMove</a></code> does not currently attempt to fix these
errors.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Do example to define object zz with location of dataset
utils::example("dives", package="diveMove",
               ask=FALSE, echo=FALSE)
srcfn &lt;- basename(zz)
readTDR(zz, speed=TRUE, sep=";", na.strings="", as.is=TRUE)

## Or more pedestrian
tdrX &lt;- read.csv(zz, sep=";", na.strings="", as.is=TRUE)
date.time &lt;- paste(tdrX$date, tdrX$time)
tdr.time &lt;- as.POSIXct(strptime(date.time, format="%d/%m/%Y %H:%M:%S"),
                       tz="GMT")
createTDR(tdr.time, tdrX$depth, concurrentData=data.frame(speed=tdrX$speed),
          file=srcfn, speed=TRUE)
</code></pre>

<hr>
<h2 id='detDive-internal'>Detect dives from depth readings</h2><span id='topic+detDive-internal'></span><span id='topic+.detDive'></span>

<h3>Description</h3>

<p>Identify dives in <abbr><span class="acronym">TDR</span></abbr> records based on a dive threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.detDive(zdepth, act, dive.thr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detDive-internal_+3A_zdepth">zdepth</code></td>
<td>
<p>numeric vector of zero-offset corrected depths.</p>
</td></tr>
<tr><td><code id="detDive-internal_+3A_act">act</code></td>
<td>
<p>factor as long as <code>depth</code> coding activity, with levels
specified as in <code><a href="#topic+.detPhase">.detPhase</a></code>.</p>
</td></tr>
<tr><td><code id="detDive-internal_+3A_dive.thr">dive.thr</code></td>
<td>
<p>numeric scalar: threshold depth below which an
underwater phase should be considered a dive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with the following elements for
<code>.detDive</code>
</p>
<table role = "presentation">
<tr><td><code>dive.id</code></td>
<td>
<p>Numeric vector numbering each dive in the record.</p>
</td></tr>
<tr><td><code>dive.activity</code></td>
<td>
<p>Factor with levels &ldquo;L&rdquo;, &ldquo;W&rdquo;,
&ldquo;U&rdquo;, &ldquo;D&rdquo;, and &ldquo;Z&rdquo;, see <code><a href="#topic+.detPhase">.detPhase</a></code>.
All levels may be represented.</p>
</td></tr>
<tr><td><code>postdive.id</code></td>
<td>
<p>Numeric vector numbering each postdive interval with
the same value as the preceding dive.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.detPhase">.detPhase</a></code>, <code><a href="#topic+.zoc">.zoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Too long for checks
## Continuing the Example from '?calibrateDepth':
utils::example("calibrateDepth", package="diveMove",
               ask=FALSE, echo=FALSE, run.donttest=TRUE)
dcalib		# the 'TDRcalibrate' that was created

tdr &lt;- getTDR(dcalib)

## Extract the gross activity from an already calibrated TDR object
gross.act &lt;- getGAct(dcalib)
detd &lt;- diveMove:::.detDive(getDepth(tdr), gross.act[[2]], 3)


</code></pre>

<hr>
<h2 id='distSpeed'>Calculate distance and speed between locations</h2><span id='topic+distSpeed'></span>

<h3>Description</h3>

<p>Calculate distance, time difference, and speed between pairs of points
defined by latitude and longitude, given the time at which all points were
measured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distSpeed(pt1, pt2, method = c("Meeus", "VincentyEllipsoid"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distSpeed_+3A_pt1">pt1</code></td>
<td>
<p>A matrix or <code><a href="base.html#topic+data.frame">data.frame</a></code> with three columns; the
first a <code>POSIXct</code> object with dates and times for all points, the
second and third numeric vectors of longitude and latitude for all points,
respectively, in decimal degrees.</p>
</td></tr>
<tr><td><code id="distSpeed_+3A_pt2">pt2</code></td>
<td>
<p>A matrix with the same size and structure as <code>pt1</code>.</p>
</td></tr>
<tr><td><code id="distSpeed_+3A_method">method</code></td>
<td>
<p>character indicating which of the distance algorithms from
<code><a href="geosphere.html#topic+geosphere-package">geosphere-package</a></code> to use (only default parameters
used).  Only <code>Meeus</code> and <code>VincentyEllipsoid</code> are supported for
now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with three columns: distance (km), time difference (s),
and speed (m/s).
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the Example from '?readLocs':
utils::example("readLocs", package="diveMove",
               ask=FALSE, echo=FALSE)

## Travel summary between successive standard locations
locs.std &lt;- subset(locs, subset=class == "0" | class == "1" |
                   class == "2" | class == "3" &amp;
                   !is.na(lon) &amp; !is.na(lat))
## Default Meeus method
locs.std.tr &lt;- by(locs.std, locs.std$id, function(x) {
    distSpeed(x[-nrow(x), 3:5], x[-1, 3:5])
})
lapply(locs.std.tr, head)

## Particular quantiles from travel summaries
lapply(locs.std.tr, function(x) {
    quantile(x[, 3], seq(0.90, 0.99, 0.01), na.rm=TRUE) # speed
})
lapply(locs.std.tr, function(x) {
    quantile(x[, 1], seq(0.90, 0.99, 0.01), na.rm=TRUE) # distance
})

## Travel summary between two arbitrary sets of points
pts &lt;- seq(10)
(meeus &lt;- distSpeed(locs[pts, 3:5], locs[pts + 1, 3:5]))
(vincenty &lt;- distSpeed(locs[pts, 3:5],
                       locs[pts + 1, 3:5],
                       method="VincentyEllipsoid"))
meeus - vincenty
</code></pre>

<hr>
<h2 id='diveModel-class'>Class &quot;diveModel&quot; for representing a model for identifying dive phases</h2><span id='topic+diveModel-class'></span><span id='topic+diveModel'></span>

<h3>Description</h3>

<p>Details of model used to identify the different phases of a dive.
</p>


<h3>Slots</h3>


<dl>
<dt><code>label.matrix</code></dt><dd><p>Object of class <code>"matrix"</code>.  A 2-column
character matrix with row numbers matching each observation to the
full <code><a href="#topic+TDR">TDR</a></code> object, and a vector labelling the phases of
each dive.</p>
</dd>
<dt><code>model</code></dt><dd><p>Object of class <code>"character"</code>.  A string identifying
the specific model fit to dives for the purpose of dive phase
identification.  It should be one of &lsquo;smooth.spline&rsquo; or
&lsquo;unimodal&rsquo;.</p>
</dd>
<dt><code>dive.spline</code></dt><dd><p>Object of class <code>"smooth.spline"</code>. Details of
cubic smoothing spline fit (see
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>).</p>
</dd>
<dt><code>spline.deriv</code></dt><dd><p>Object of class <code>"list"</code>.  A list with the
first derivative of the smoothing spline (see
<code><a href="stats.html#topic+predict.smooth.spline">predict.smooth.spline</a></code>).</p>
</dd>
<dt><code>descent.crit</code></dt><dd><p>Object of class <code>"numeric"</code>.  The index of the
observation at which the descent was deemed to have ended (from
initial surface observation).</p>
</dd>
<dt><code>ascent.crit</code></dt><dd><p>Object of class <code>"numeric"</code>.  the index of the
observation at which the ascent was deemed to have ended (from
initial surface observation).</p>
</dd>
<dt><code>descent.crit.rate</code></dt><dd><p>Object of class <code>"numeric"</code>. The rate of
descent corresponding to the critical quantile used.</p>
</dd>
<dt><code>ascent.crit.rate</code></dt><dd><p>Object of class <code>"numeric"</code>. The rate of
ascent corresponding to the critical quantile used.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("diveModel",
    ...)</code>.
</p>
<p>&lsquo;diveModel&rsquo; objects contain all relevant details of the process to
identify phases of a dive.  Objects of this class are typically generated
during depth calibration, using <code><a href="#topic+calibrateDepth">calibrateDepth</a></code>, more
specifically <code><a href="#topic+.cutDive">.cutDive</a></code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDiveDeriv">getDiveDeriv</a></code>, <code><a href="#topic+plotDiveModel">plotDiveModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("diveModel")

## Too long for checks
## Continuing the Example from '?calibrateDepth':
utils::example("calibrateDepth", package="diveMove",
               ask=FALSE, echo=FALSE, run.donttest=TRUE)
dcalib		# the 'TDRcalibrate' that was created

## Compare dive models for dive phase detection
diveNo &lt;- 255
diveX &lt;- as.data.frame(extractDive(dcalib, diveNo=diveNo))
diveX.m &lt;- cbind(as.numeric(row.names(diveX[-c(1, nrow(diveX)), ])),
                 diveX$depth[-c(1, nrow(diveX))],
                 diveX$time[-c(1, nrow(diveX))])

## calibrateDepth() default unimodal regression. Number of inner knots is
## either 10 or the number of samples in the dive, whichever is larger.
(phases.uni &lt;- diveMove:::.cutDive(diveX.m, smooth.par=0.2, knot.factor=20,
                                   dive.model="unimodal",
                                   descent.crit.q=0.01, ascent.crit.q=0))
## Smoothing spline model, using default smoothing parameter.
(phases.spl &lt;- diveMove:::.cutDive(diveX.m, smooth.par=0.2, knot.factor=20,
                                   dive.model="smooth.spline",
                                   descent.crit.q=0.01, ascent.crit.q=0))
plotDiveModel(phases.spl,
              diveNo=paste(diveNo, ", smooth.par=", 0.2, sep=""))
plotDiveModel(phases.uni, diveNo=paste(diveNo))


</code></pre>

<hr>
<h2 id='diveMove-defunct'>Defunct functions in package &lsquo;diveMove&rsquo;</h2><span id='topic+diveMove-defunct'></span><span id='topic+bouts2.ll'></span><span id='topic+bouts2.LL'></span><span id='topic+bouts.mle'></span>

<h3>Description</h3>

<p>These functions are defunct and no longer available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bouts2.ll()

bouts2.LL()

bouts.mle()
</code></pre>


<h3><code>bouts2.ll</code> and <code>bouts2.LL</code></h3>

<p>These functions have been superseded by the new function generator
<code><a href="#topic+boutsMLEll.chooser">boutsMLEll.chooser</a></code>
</p>

<hr>
<h2 id='diveMove-deprecated'>Deprecated functions in diveMove</h2><span id='topic+diveMove-deprecated'></span><span id='topic+bouts2.nlsFUN'></span><span id='topic+bouts2.nls'></span><span id='topic+bec2'></span><span id='topic+bec3'></span><span id='topic+bouts3.nlsFUN'></span><span id='topic+bouts3.nls'></span><span id='topic+bouts2.mleFUN'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of
&lsquo;diveMove&rsquo; only, and will be removed (defunct) in the next
release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bouts2.nlsFUN(x, a1, lambda1, a2, lambda2)

bouts2.nls(lnfreq, start, maxiter)

bec2(fit)

bec3(fit)

bouts3.nlsFUN(x, a1, lambda1, a2, lambda2, a3, lambda3)

bouts3.nls(lnfreq, start, maxiter)

bouts2.mleFUN(x, p, lambda1, lambda2)
</code></pre>


<h3><code>bouts2.nlsFUN</code></h3>

<p>For <code>bouts2.nlsFUN</code>, use <code><a href="#topic+boutsNLSll">boutsNLSll</a></code>.
</p>


<h3><code>bouts2.nls</code></h3>

<p>For <code>bouts2.nls</code>, use <code><a href="#topic+fitNLSbouts">fitNLSbouts</a></code>.
</p>


<h3><code>bec2</code></h3>

<p>For <code>bec2</code>, use <code><a href="#topic+bec">bec</a></code>.
</p>


<h3><code>bec3</code></h3>

<p>For <code>bec3</code>, use <code><a href="#topic+bec">bec</a></code>.
</p>


<h3><code>bouts3.nlsFUN</code></h3>

<p>For <code>bouts3.nlsFUN</code>, use <code><a href="#topic+boutsNLSll">boutsNLSll</a></code>.
</p>


<h3><code>bouts3.nls</code></h3>

<p>For <code>bouts3.nls</code>, use <code><a href="#topic+fitNLSbouts">fitNLSbouts</a></code>.
</p>


<h3><code>bouts2.mleFUN</code></h3>

<p>For <code>bouts2.mleFUN</code>, use <code><a href="#topic+.bouts2MLEll">.bouts2MLEll</a></code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>

<hr>
<h2 id='diveMove-internal'>Internal diveMove Functions</h2><span id='topic+.depthFilter'></span><span id='topic+.derivStats'></span><span id='topic+.diveIndices'></span><span id='topic+.diveMatches'></span><span id='topic+.getInterval'></span><span id='topic+.plotTDR'></span><span id='topic+.plotlyTDR'></span><span id='topic+.plotZOCfilters'></span><span id='topic+.plotZOCtdrs'></span><span id='topic+.speedStats'></span><span id='topic+.night'></span><span id='topic+.rleActivity'></span><span id='topic+.speedNames'></span><span id='topic+.speedCol'></span><span id='topic+.zoc'></span>

<h3>Description</h3>

<p>Functions used for very particular tasks within larger
functions in diveMove</p>


<h3>Usage</h3>

<pre><code class='language-R'>.depthFilter(depth, k, probs, depth.bounds, na.rm)
.derivStats(x, diveNo)
.diveIndices(diveID, diveNo)
.diveMatches(diveID, diveNo)
.getInterval(time)
.speedStats(x, vdist)
.night(time, sunrise.time, sunset.time)
.rleActivity(time, act, interval)
.speedCol(x)
.zoc(time, depth, method, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diveMove-internal_+3A_depth">depth</code></td>
<td>
<p>Numeric vector with depth in m.</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_k">k</code></td>
<td>
<p>Vector of moving window width integers (coerced to integer by
<code><a href="#topic+.runquantile">.runquantile</a></code>) to be applied sequentially.</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_probs">probs</code></td>
<td>
<p>Vector of quantiles to extract at each step indicated by
<code>k</code> (so it must be as long as <code>k</code>).</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_depth.bounds">depth.bounds</code></td>
<td>
<p>Numeric vector of length two, with minimum and
maximum depth to bound the search for the surface.</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code><a href="base.html#topic+NA">NA</a></code> values be removed prior to
calculating running quantiles?</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_diveid">diveID</code></td>
<td>
<p>Numeric (or character for <code>.diveMatches</code>) vector of
all dive and non dive IDs.</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_diveno">diveNo</code></td>
<td>
<p>Numeric vector of unique dive indices to extract from
<code>diveID</code>, or <code>x</code> in the case of <code>.derivStats</code>.  For
<code>.derivStats</code> any duplicates are ignored.</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> object representing time.</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_x">x</code></td>
<td>
<p>For <code>.speedStats</code>, a matrix with a dive's section data.
A single dive's data: 3-col matrix with time, depth, and speed.  For
.speedCol, a <code><a href="base.html#topic+data.frame">data.frame</a></code> where names are searched for
strings matching <code>.speedNames</code> (see Details).  For
<code>.derivStats</code>, a <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> object.</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_vdist">vdist</code></td>
<td>
<p>Vertical distance travelled during this time.  If
<code>vdist</code> is missing, then it's all horizontal movements (no
angles).</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_sunrise.time">sunrise.time</code>, <code id="diveMove-internal_+3A_sunset.time">sunset.time</code></td>
<td>
<p>Passed from <code>plotTDR</code>.</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_act">act</code></td>
<td>
<p>A numeric vector indicating the activity for every element
of <code>time</code>.</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_interval">interval</code></td>
<td>
<p>Sampling interval in seconds.</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_method">method</code></td>
<td>
<p>Character string to indicate the method to use for
zero offset correction.  One of &ldquo;visual&rdquo;, &ldquo;offset&rdquo;, or
&ldquo;filter&rdquo; (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="diveMove-internal_+3A_control">control</code></td>
<td>
<p>Named list of control parameters to be used for ZOC
method <code>filter</code> (<code>k</code>, <code>probs</code>, <code>na.rm</code>,
<code>depth.bounds</code>) and <code>offset</code> (<code>offset</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are not meant to be called directly by the
user, as he/she could not care less (right?).  This may change in the
future.  Nonetheless, they can be called in the usual way for
functions that are not exported: <code>diveMove:::.functionName</code>.
</p>
<p><code>.depthFilter</code> performs the zero-offset correction with
method=&ldquo;filter&rdquo;.  It takes a numeric vector and applies a
running quantile to it, and the process is repeated zero or more times
on the filtered/smooth vector from the previous process.
</p>
<p><code>.derivStats</code> obtains summary statistics (summary() and sd()) of
derivatives for descent, bottom, and ascent phases for each dive.
It takes a <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> object.
</p>
<p><code>.diveIndices</code> takes a numeric vector with sequences of dive
numbers, and selects the indices of dive numbers listed uniquely in
the vector given as its second argument.
</p>
<p><code>.diveMatches</code> takes a numeric or character vector with sequences
of dive numbers, and selects the indices of dive numbers listed
uniquely in the vector given as its first argument.  Stops if no
matches are found, and warns if some were ignored.
</p>
<p><code>.getInterval</code> takes a <code><a href="base.html#topic+POSIXct">POSIXct</a></code> object and
calculates the the most frequent interval between successive elements.
</p>
<p><code>.plotTDR</code> is the underlying plotting function for
<code><a href="#topic+TDR">TDR</a></code> objects.  Arguments are documented in the main S4
method (<code><a href="#topic+plotTDR">plotTDR</a></code>).
</p>
<p><code>.plotZOCfilters</code> and <code>plotZOCtdrs</code> are the underlying
plotting functions for visually assessing the ZOC procedure.
Arguments are documented in the main S4 methods
(<code><a href="#topic+plotZOC">plotZOC</a></code>).
</p>
<p><code>.speedStats</code> takes matrix of time and speed, and an optional
vector of vertical distance travelled between segments, and calculates
the total vertical distance travelled, mean speed, and angle.  Input
and output correspond to a single section of a dive.
</p>
<p><code>.night</code> takes a <code><a href="base.html#topic+POSIXct">POSIXct</a></code> object, sunrise and sunset
time strings to provide a list of sunrise and sunset times for each
day in the <code><a href="base.html#topic+POSIXct">POSIXct</a></code> input.
</p>
<p><code>.rleActivity</code> takes a factor indicating different activity
phases, their associated time, and the sampling interval to return a
factor uniquely identifying each phase of activity, i.e. labelling
them.  In addition, it returns the duration of each phase, and their
beginning and end times.
</p>
<p><code>.speedNames</code> is a character vector with possible names for a
speed vector.
</p>
<p><code>.speedCol</code> takes a <code><a href="base.html#topic+data.frame">data.frame</a></code> and checks whether
there is a column with a name matching one of those in
<code><a href="#topic+.speedNames">.speedNames</a></code>.
</p>
<p><code>.zoc</code> is the main workhorse for the zero-offset correction
<abbr><span class="acronym">ZOC</span></abbr> procedure in <code><a href="#topic+calibrateDepth">calibrateDepth</a></code>.  It takes a
<code><a href="base.html#topic+POSIXct">POSIXct</a></code> object, corresponding <code><a href="base.html#topic+numeric">numeric</a></code>
depth vector, a string representing a method to use for the procedure,
and a list of control parameters for the chosen method to perform ZOC.
</p>


<h3>Value</h3>

<p><code>.diveIndices</code> returns a numeric vector with the indices of dives
(and their beginning/end indices) in <code>diveID</code>.
</p>
<p><code>.getInterval</code> returns a scalar, the mode of intervals between
time readings.
</p>
<p><code>.speedStats</code> returns a 3-column matrix with total distance, mean
speed, and angle for a section of a dive.
</p>
<p><code>.night</code> returns a list with sunrise and sunset times for dates
in <code>time</code>.
</p>
<p><code>.speedCol</code> returns column number where speed is located in x.
</p>
<p><code>.rleActivity</code> returns a list with components:
</p>

<ul>
<li> <p><code>time.br</code> A factor dividing <code>act</code> into different periods
of activity.
</p>
</li>
<li> <p><code>time.peract</code> The duration of each period of activity.
</p>
</li>
<li> <p><code>beg.time, end.time</code> POSIXct objects indicating the beginning
and ending times of each period of activity.
</p>
</li></ul>

<p><code>.zoc</code> returns a vector with all corrected depths based on
&lsquo;method&rsquo;.  Depths &lt; 0 are set to 0.
</p>
<p><code>.depthFilter</code> returns a <code><a href="base.html#topic+matrix">matrix</a></code> with the filtered
depths at each step, and corrected depth as last column, so it has
dimensions <code>length(depth)</code> rows by <code>length(k) + 1</code> columns.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(divesTDR)

times &lt;- getTime(divesTDR)
depths &lt;- getDepth(divesTDR)

## This can take too long
## .depthFilter

d.filter &lt;- diveMove:::.depthFilter(depth=depths, k=c(3, 5760),
                                    probs=c(0.5, 0.02), depth.bounds=c(0, 5),
                                    na.rm=TRUE)
## Set negative depths to zero
d.filter[d.filter[, 3] &lt; 0, 3] &lt;- 0

## Plotting

idx &lt;- seq(95, 6000)		# try different slices
idx &lt;- seq(nrow(d.filter))
## Look at the top 10 m only plus a few meters above
ylim &lt;- c(-10, 5)

layout(seq(3))
plot(times[idx], -depths[idx], type="l", col="gray",
     ylab="Depth (m)", ylim=ylim)
abline(h=0, lty=2)
legend("topleft", legend="original", lty=1, col="gray")
plot(times[idx], -d.filter[idx, 1], type="l", col=2,
     ylab="Depth (m)", ylim=ylim)
abline(h=0, lty=2)
lines(times[idx], -d.filter[idx, 2])
legend("topleft", legend=colnames(d.filter)[-3],
       lty=1, col=c(2, 1))
plot(times[idx], -d.filter[idx, 3], type="l", ylim=ylim,
     ylab="Depth (m)"); abline(h=0, lty=2)
legend("topleft", legend=paste("Original -", colnames(d.filter)[2]),
       lty=1)


</code></pre>

<hr>
<h2 id='dives'>Sample of TDR data from a fur seal</h2><span id='topic+dives'></span><span id='topic+divesTDR'></span><span id='topic+divesTDRzoc'></span>

<h3>Description</h3>

<p>This data set is meant to show a typical organization of a
<abbr><span class="acronym">TDR</span></abbr> *.csv file, suitable as input for <code><a href="#topic+readTDR">readTDR</a></code>,
or to construct a <code><a href="#topic+TDR">TDR</a></code> object.  <code>divesTDR</code> is an
example <code><a href="#topic+TDR">TDR</a></code> object.</p>


<h3>Format</h3>

<p>Bzip2-compressed file.  A comma separated value (csv) file with 34199
<abbr><span class="acronym">TDR</span></abbr> readings, measured at 5 s intervals, with the following
columns:
</p>

<dl>
<dt>date</dt><dd><p>Date</p>
</dd>
<dt>time</dt><dd><p>Time</p>
</dd>
<dt>depth</dt><dd><p>Depth in m</p>
</dd>
<dt>light</dt><dd><p>Light level</p>
</dd>
<dt>temperature</dt><dd><p>Temperature in degrees Celsius</p>
</dd>
<dt>speed</dt><dd><p>Speed in m/s</p>
</dd>
</dl>

<p>The data are also provided as a <code><a href="#topic+TDR">TDR</a></code> object (*.RData
format) for convenience.
</p>


<h3>Details</h3>

<p>The data are a subset of an entire <abbr><span class="acronym">TDR</span></abbr> record, so they are
not meant to make valid inferences from this particular
individual/deployment.
</p>
<p><code>divesTDR</code> is a <code><a href="#topic+TDR">TDR</a></code> object representation of the
data in <code>dives</code>.
</p>
<p><code>divesTDRzoc</code> is the same data, but has been zero-offset corrected
with the &quot;filter&quot; method (<code>k=c(3, 5760), probs=c(0.5, 0.02),
  na.rm=TRUE, depth.bounds=range(getDepth(divesTDR))</code>).
</p>


<h3>Source</h3>

<p>Sebastian P. Luque, Christophe Guinet, John P.Y. Arnould</p>


<h3>See Also</h3>

<p><code><a href="#topic+readTDR">readTDR</a></code>, <code><a href="#topic+diveStats">diveStats</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zz &lt;- system.file(file.path("data", "dives.csv"),
                  package="diveMove", mustWork=TRUE)
str(read.csv(zz, sep=";", na.strings=""))

</code></pre>

<hr>
<h2 id='diveStats'>Per-dive statistics</h2><span id='topic+diveStats'></span><span id='topic+oneDiveStats'></span><span id='topic+stampDive'></span>

<h3>Description</h3>

<p>Calculate dive statistics in <abbr><span class="acronym">TDR</span></abbr> records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diveStats(x, depth.deriv = TRUE)

oneDiveStats(x, interval, speed = FALSE)

stampDive(x, ignoreZ = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diveStats_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TDRcalibrate-class">TDRcalibrate-class</a></code> object for <code>diveStats</code>
and <code>stampDive</code>, and a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing a
single dive's data (a factor identifying the dive phases, a POSIXct
object with the time for each reading, a numeric depth vector, and
a numeric speed vector) for <code>oneDiveStats</code>.</p>
</td></tr>
<tr><td><code id="diveStats_+3A_depth.deriv">depth.deriv</code></td>
<td>
<p>logical: should depth derivative statistics be
calculated?</p>
</td></tr>
<tr><td><code id="diveStats_+3A_interval">interval</code></td>
<td>
<p>numeric scalar: sampling interval for interpreting
<code>x</code>.</p>
</td></tr>
<tr><td><code id="diveStats_+3A_speed">speed</code></td>
<td>
<p>logical: should speed statistics be calculated?</p>
</td></tr>
<tr><td><code id="diveStats_+3A_ignorez">ignoreZ</code></td>
<td>
<p>logical: whether phases should be numbered considering
all aquatic activities (&ldquo;W&rdquo; and &ldquo;Z&rdquo;) or ignoring
&ldquo;Z&rdquo; activities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>diveStats</code> calculates various dive statistics based on time and
depth for an entire <abbr><span class="acronym">TDR</span></abbr> record.  <code>oneDiveStats</code> obtains
these statistics from a single dive, and <code>stampDive</code> stamps each
dive with associated phase information.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with one row per dive detected
(durations are in s, and linear variables in m):
</p>
<table role = "presentation">
<tr><td><code>begdesc</code></td>
<td>
<p>A <code>POSIXct</code> object, specifying the start time of
each dive.</p>
</td></tr>
<tr><td><code>enddesc</code></td>
<td>
<p>A <code>POSIXct</code> object, as <code>begdesc</code> indicating
descent's end time.</p>
</td></tr>
<tr><td><code>begasc</code></td>
<td>
<p>A <code>POSIXct</code> object, as <code>begdesc</code> indicating the
time ascent began.</p>
</td></tr>
<tr><td><code>desctim</code></td>
<td>
<p>Descent duration of each dive.</p>
</td></tr>
<tr><td><code>botttim</code></td>
<td>
<p>Bottom duration of each dive.</p>
</td></tr>
<tr><td><code>asctim</code></td>
<td>
<p>Ascent duration of each dive.</p>
</td></tr>
<tr><td><code>divetim</code></td>
<td>
<p>Dive duration.</p>
</td></tr>
<tr><td><code>descdist</code></td>
<td>
<p>Numeric vector with last descent depth.</p>
</td></tr>
<tr><td><code>bottdist</code></td>
<td>
<p>Numeric vector with the sum of absolute depth
differences while at the bottom of each dive; measure of amount of
&ldquo;wiggling&rdquo; while at bottom.</p>
</td></tr>
<tr><td><code>ascdist</code></td>
<td>
<p>Numeric vector with first ascent depth.</p>
</td></tr>
<tr><td><code>bottdep.mean</code></td>
<td>
<p>Mean bottom depth.</p>
</td></tr>
<tr><td><code>bottdep.median</code></td>
<td>
<p>Median bottom depth.</p>
</td></tr>
<tr><td><code>bottdep.sd</code></td>
<td>
<p>Standard deviation of bottom depths.</p>
</td></tr>
<tr><td><code>maxdep</code></td>
<td>
<p>Numeric vector with maximum depth.</p>
</td></tr>
<tr><td><code>desc.tdist</code></td>
<td>
<p>Numeric vector with descent total distance, estimated
from speed.</p>
</td></tr>
<tr><td><code>desc.mean.speed</code></td>
<td>
<p>Numeric vector with descent mean speed.</p>
</td></tr>
<tr><td><code>desc.angle</code></td>
<td>
<p>Numeric vector with descent angle, from the surface
plane.</p>
</td></tr>
<tr><td><code>bott.tdist</code></td>
<td>
<p>Numeric vector with bottom total distance, estimated
from speed.</p>
</td></tr>
<tr><td><code>bott.mean.speed</code></td>
<td>
<p>Numeric vector with bottom mean speed.</p>
</td></tr>
<tr><td><code>asc.tdist</code></td>
<td>
<p>Numeric vector with ascent total distance, estimated
from speed.</p>
</td></tr>
<tr><td><code>asc.mean.speed</code></td>
<td>
<p>Numeric vector with ascent mean speed.</p>
</td></tr>
<tr><td><code>asc.angle</code></td>
<td>
<p>Numeric vector with ascent angle, from the bottom plane.</p>
</td></tr>
<tr><td><code>postdive.dur</code></td>
<td>
<p>Postdive duration.</p>
</td></tr>
<tr><td><code>postdive.tdist</code></td>
<td>
<p>Numeric vector with postdive total distance,
estimated from speed.</p>
</td></tr>
<tr><td><code>postdive.mean.speed</code></td>
<td>
<p>Numeric vector with postdive mean speed.</p>
</td></tr>
</table>
<p>If <code>depth.deriv=TRUE</code>, 21 additional columns with the minimum,
first quartile, median, mean, third quartile, maximum, and standard
deviation of the depth derivative for each phase of the dive.  The
number of columns also depends on argument <code>speed</code>.
</p>
<p><code>stampDive</code> returns a <code><a href="base.html#topic+data.frame">data.frame</a></code> with phase number,
activity, and start and end times for each dive.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>oneDiveStats</code>: Calculate dive statistics for a single dive
</p>
</li>
<li> <p><code>stampDive</code>: Stamp dives
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibrateDepth">calibrateDepth</a></code>, <code><a href="#topic+.detPhase">.detPhase</a></code>,
<code><a href="#topic+TDRcalibrate-class">TDRcalibrate-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Too long for checks
## Continuing the Example from '?calibrateDepth':
utils::example("calibrateDepth", package="diveMove",
               ask=FALSE, echo=FALSE, run.donttest=TRUE)
dcalib		# the 'TDRcalibrate' that was created

tdrX &lt;- diveStats(dcalib)
stamps &lt;- stampDive(dcalib, ignoreZ=TRUE)
tdrX.tab &lt;- data.frame(stamps, tdrX)
summary(tdrX.tab)


</code></pre>

<hr>
<h2 id='extractDive+2CTDR+2Cnumeric+2Cnumeric-method'>Extract Dives from &quot;TDR&quot; or &quot;TDRcalibrate&quot; Objects</h2><span id='topic+extractDive+2CTDR+2Cnumeric+2Cnumeric-method'></span><span id='topic+extractDive'></span><span id='topic+extractDive+2CTDRcalibrate+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Extract data corresponding to a particular dive(s), referred to by
number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TDR,numeric,numeric'
extractDive(obj, diveNo, id)

## S4 method for signature 'TDRcalibrate,numeric,missing'
extractDive(obj, diveNo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractDive+2B2CTDR+2B2Cnumeric+2B2Cnumeric-method_+3A_obj">obj</code></td>
<td>
<p><code><a href="#topic+TDR">TDR</a></code> object.</p>
</td></tr>
<tr><td><code id="extractDive+2B2CTDR+2B2Cnumeric+2B2Cnumeric-method_+3A_diveno">diveNo</code></td>
<td>
<p>numeric vector or scalar with dive numbers to
extract. Duplicates are ignored.</p>
</td></tr>
<tr><td><code id="extractDive+2B2CTDR+2B2Cnumeric+2B2Cnumeric-method_+3A_id">id</code></td>
<td>
<p>numeric vector or scalar of dive numbers from where
<code>diveNo</code> should be chosen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+TDR">TDR</a></code> or <code><a href="#topic+TDRspeed">TDRspeed</a></code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>obj = TDR,diveNo = numeric,id = numeric</code>: Extract data on TDR object
</p>
</li>
<li> <p><code>obj = TDRcalibrate,diveNo = numeric,id = missing</code>: Extract data on TDRcalibrate object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Too long for checks
## Continuing the Example from '?calibrateDepth':
utils::example("calibrateDepth", package="diveMove",
               ask=FALSE, echo=FALSE, run.donttest=TRUE)
dcalib		# the 'TDRcalibrate' that was created

diveX &lt;- extractDive(divesTDR, 9, getDAct(dcalib, "dive.id"))
plotTDR(diveX)

diveX &lt;- extractDive(dcalib, 5:10)
plotTDR(diveX)


</code></pre>

<hr>
<h2 id='fitMLEbouts+2Cnumeric-method'>Maximum Likelihood Model of mixtures of 2 or 3 Poisson Processes</h2><span id='topic+fitMLEbouts+2Cnumeric-method'></span><span id='topic+fitMLEbouts'></span><span id='topic+fitMLEbouts+2CBouts-method'></span>

<h3>Description</h3>

<p>Functions to model a mixture of 2 random Poisson processes to identify
bouts of behaviour.  This follows Langton et al. (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
fitMLEbouts(obj, start, optim_opts0 = NULL, optim_opts1 = NULL)

## S4 method for signature 'Bouts'
fitMLEbouts(obj, start, optim_opts0 = NULL, optim_opts1 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitMLEbouts+2B2Cnumeric-method_+3A_obj">obj</code></td>
<td>
<p>Object of class <code><a href="#topic+Bouts">Bouts</a></code>.</p>
</td></tr>
<tr><td><code id="fitMLEbouts+2B2Cnumeric-method_+3A_start">start</code></td>
<td>
<p>passed to <code><a href="stats4.html#topic+mle">mle</a></code>.  A row- and
column-named (2,N) matrix, as returned by <code><a href="#topic+boutinit">boutinit</a></code>.</p>
</td></tr>
<tr><td><code id="fitMLEbouts+2B2Cnumeric-method_+3A_optim_opts0">optim_opts0</code></td>
<td>
<p>named list of optional arguments passed to
<code><a href="stats4.html#topic+mle">mle</a></code> for fitting the first model with
transformed parameters.</p>
</td></tr>
<tr><td><code id="fitMLEbouts+2B2Cnumeric-method_+3A_optim_opts1">optim_opts1</code></td>
<td>
<p>named list of optional arguments passed to
<code><a href="stats4.html#topic+mle">mle</a></code> for fitting the second model with
parameters retrieved from the first model, untransformed to
original scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixtures of 2 or 3 Poisson processes are supported. Even in this
relatively simple case, it is very important to provide good starting
values for the parameters.
</p>
<p>One useful strategy to get good starting parameter values is to proceed
in 4 steps.  First, fit a broken stick model to the log frequencies of
binned data (see <code><a href="#topic+boutinit">boutinit</a></code>), to obtain estimates of 4
parameters in a 2-process model (Sibly et al. 1990), or 6 in a
3-process model.  Second, calculate parameter(s) <var>p</var> from the alpha
parameters obtained from the broken stick model, to get tentative
initial values as in Langton et al. (1995). Third, obtain MLE estimates
for these parameters, but using a reparameterized version of the -log
L2 function.  Lastly, obtain the final MLE estimates for the 3
parameters by using the estimates from step 3, un-transformed back to
their original scales, maximizing the original parameterization of the
-log L2 function.
</p>
<p><code><a href="#topic+boutinit">boutinit</a></code> can be used to perform step 1.  Calculation of
the mixing parameters <var>p</var> in step 2 is trivial from these
estimates.  Function <code><a href="#topic+boutsMLEll.chooser">boutsMLEll.chooser</a></code> defines a
reparameterized version of the -log L2 function given by Langton et
al. (1995), so can be used for step 3.  This uses a logit (see
<code><a href="#topic+logit">logit</a></code>) transformation of the mixing parameter <var>p</var>,
and log transformations for both density parameters <var>lambda1</var> and
<var>lambda2</var>.  Function <code><a href="#topic+boutsMLEll.chooser">boutsMLEll.chooser</a></code> can be used
again to define the -log L2 function corresponding to the
un-transformed model for step 4.
</p>
<p><code>fitMLEbouts</code> is the function performing the main job of
maximizing the -log L2 functions, and is essentially a wrapper around
<code><a href="stats4.html#topic+mle">mle</a></code>.  It only takes the -log L2 function, a list
of starting values, and the variable to be modelled, all of which are
passed to <code><a href="stats4.html#topic+mle">mle</a></code> for optimization.  Additionally,
any other arguments are also passed to <code><a href="stats4.html#topic+mle">mle</a></code>, hence
great control is provided for fitting any of the -log L2 functions.
</p>
<p>In practice, step 3 does not pose major problems using the
reparameterized -log L2 function, but it might be useful to use method
&ldquo;L-BFGS-B&rdquo; with appropriate lower and upper bounds.  Step 4 can
be a bit more problematic, because the parameters are usually on very
different scales and there can be multiple minima.  Therefore, it is
almost always the rule to use method &ldquo;L-BFGS-B&rdquo;, again bounding
the parameter search, as well as passing a <code>control</code> list with
proper <code>parscale</code> for controlling the optimization.  See
<code>Note</code> below for useful constraints which can be tried.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="stats4.html#topic+mle">mle</a></code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>numeric</code>: Fit model via MLE on numeric vector.
</p>
</li>
<li> <p><code>Bouts</code>: Fit model via MLE on <code><a href="#topic+Bouts">Bouts</a></code>
object.
</p>
</li></ul>


<h3>Note</h3>

<p>In the case of a mixture of 2 Poisson processes, useful values for
lower bounds for the transformed negative log likelihood
reparameterization are <code>c(-2, -5, -10)</code>.  For the un-transformed
parameterization, useful lower bounds are <code>rep(1e-08, 3)</code>.  A
useful parscale argument for the latter is <code>c(1, 0.1, 0.01)</code>.
However, I have only tested this for cases of diving behaviour in
pinnipeds, so these suggested values may not be useful in other cases.
</p>
<p>The lambdas can be very small for some data, particularly
<code>lambda2</code>, so the default <code>ndeps</code> in <code><a href="stats.html#topic+optim">optim</a></code> can
be so large as to push the search outside the bounds given.  To avoid
this problem, provide a smaller <code>ndeps</code> value.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>References</h3>

<p>Langton, S.; Collett, D. and Sibly, R. (1995) Splitting behaviour into
bouts; a maximum likelihood approach.  Behaviour <b>132</b>, 9-10.
</p>
<p>Luque, S.P. and Guinet, C. (2007) A maximum likelihood approach for
identifying dive bouts improves accuracy, precision, and
objectivity. Behaviour, <b>144</b>, 1315-1332.
</p>
<p>Sibly, R.; Nott, H. and Fletcher, D. (1990) Splitting behaviour into
bouts.  Animal Behaviour <b>39</b>, 63-69.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Run example to retrieve random samples for two- and three-process
## Poisson mixtures with known parameters as 'Bouts' objects
## ('xbouts2', and 'xbouts3'), as well as starting values from
## broken-stick model ('startval2' and 'startval3')
utils::example("boutinit", package="diveMove", ask=FALSE)

## 2-process
opts0 &lt;- list(method="L-BFGS-B", lower=c(-2, -5, -10))
opts1 &lt;- list(method="L-BFGS-B", lower=c(1e-1, 1e-3, 1e-6))
bouts2.fit &lt;- fitMLEbouts(xbouts2, start=startval2, optim_opts0=opts0,
                          optim_opts1=opts1)
plotBouts(bouts2.fit, xbouts2)

## 3-process
opts0 &lt;- list(method="L-BFGS-B", lower=c(-5, -5, -6, -8, -12))
## We know 0 &lt; p &lt; 1, and can provide bounds for lambdas within an
## order of magnitude for a rough box constraint.
lo &lt;- c(9e-2, 9e-2, 2e-3, 1e-3, 1e-5)
hi &lt;- c(9e-1, 9.9e-1, 2e-1, 9e-2, 5e-3)
## Important to set the step size to avoid running below zero for
## the last lambda.
ndeps &lt;- c(1e-3, 1e-3, 1e-3, 1e-3, 1e-5)
opts1 &lt;- list(method="L-BFGS-B", lower=lo, upper=hi,
              control=list(ndeps=ndeps))
bout3.fit &lt;- fitMLEbouts(xbouts3, start=startval3, optim_opts0=opts0,
                         optim_opts1=opts1)
bec(bout3.fit)
plotBoutsCDF(bout3.fit, xbouts3)
</code></pre>

<hr>
<h2 id='fitNLSbouts+2Cdata.frame-method'>Fit mixture of Poisson Processes to Log Frequency data via Non-linear
Least Squares regression</h2><span id='topic+fitNLSbouts+2Cdata.frame-method'></span><span id='topic+fitNLSbouts'></span><span id='topic+fitNLSbouts+2CBouts-method'></span>

<h3>Description</h3>

<p>Methods for modelling a mixture of 2 or 3 random Poisson processes to
histogram-like data of log frequency vs interval mid points.  This
follows Sibly et al. (1990) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
fitNLSbouts(obj, start, maxiter, ...)

## S4 method for signature 'Bouts'
fitNLSbouts(obj, start, maxiter, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitNLSbouts+2B2Cdata.frame-method_+3A_obj">obj</code></td>
<td>
<p>Object of class <code><a href="#topic+Bouts">Bouts</a></code>, or
<code><a href="base.html#topic+data.frame">data.frame</a></code> with named components <var>lnfreq</var> (log
frequencies) and corresponding <var>x</var> (mid points of histogram
bins).</p>
</td></tr>
<tr><td><code id="fitNLSbouts+2B2Cdata.frame-method_+3A_start">start</code>, <code id="fitNLSbouts+2B2Cdata.frame-method_+3A_maxiter">maxiter</code></td>
<td>
<p>Arguments passed to <code><a href="stats.html#topic+nls">nls</a></code>.</p>
</td></tr>
<tr><td><code id="fitNLSbouts+2B2Cdata.frame-method_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="stats.html#topic+nls">nls</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nls</code> object resulting from fitting this model to data.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>data.frame</code>: Fit NLS model on <code>data.frame</code>
</p>
</li>
<li> <p><code>Bouts</code>: Fit NLS model on <code>Bouts</code> object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>References</h3>

<p>Sibly, R.; Nott, H. and Fletcher, D. (1990) Splitting behaviour into
bouts Animal Behaviour <b>39</b>, 63-69.
</p>


<h3>See Also</h3>

<p><code>fitMLEbouts</code> for a better approach;
<code><a href="#topic+boutfreqs">boutfreqs</a></code>; <code><a href="#topic+boutinit">boutinit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Run example to retrieve random samples for two- and three-process
## Poisson mixtures with known parameters as 'Bouts' objects
## ('xbouts2', and 'xbouts3'), as well as starting values from
## broken-stick model ('startval2' and 'startval3')
utils::example("boutinit", package="diveMove", ask=FALSE)

## 2-process
bout2.fit &lt;- fitNLSbouts(xbouts2, start=startval2, maxiter=500)
summary(bout2.fit)
bec(bout2.fit)

## 3-process
## The problem requires using bound constraints, which is available
## via the 'port' algorithm
l_bnds &lt;- c(100, 1e-3, 100, 1e-3, 100, 1e-6)
u_bnds &lt;- c(5e4, 1, 5e4, 1, 5e4, 1)
bout3.fit &lt;- fitNLSbouts(xbouts3, start=startval3, maxiter=500,
                         lower=l_bnds, upper=u_bnds, algorithm="port")
plotBouts(bout3.fit, xbouts3)
</code></pre>

<hr>
<h2 id='labDive-internal'>Internal Functions used for Detection of Dives</h2><span id='topic+labDive-internal'></span><span id='topic+.cutDive'></span><span id='topic+.labDive'></span><span id='topic+.labDivePhase'></span>

<h3>Description</h3>

<p>These functions provide information for particular dives,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cutDive(x, dive.model, smooth.par=NULL, knot.factor, sigmasq=2,
         g=min(max(10, nrow(x) - 4), 25), ordpen=2,
         descent.crit.q, ascent.crit.q)
.labDive(act, string)
.labDivePhase(x, diveID, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labDive-internal_+3A_x">x</code></td>
<td>
<p>For <code>.labDivePhase</code>, a class <code><a href="#topic+TDR">TDR</a></code> object.
For <code>.cutDive</code>, a 3-col matrix with subscript in original TDR
object, non NA depths, and numeric vector representing
<code><a href="base.html#topic+POSIXct">POSIXct</a></code> times.</p>
</td></tr>
<tr><td><code id="labDive-internal_+3A_dive.model">dive.model</code>, <code id="labDive-internal_+3A_smooth.par">smooth.par</code>, <code id="labDive-internal_+3A_knot.factor">knot.factor</code>, <code id="labDive-internal_+3A_descent.crit.q">descent.crit.q</code>, <code id="labDive-internal_+3A_ascent.crit.q">ascent.crit.q</code></td>
<td>
<p>Passed from <code>calibrateDepth</code>.</p>
</td></tr>
<tr><td><code id="labDive-internal_+3A_sigmasq">sigmasq</code>, <code id="labDive-internal_+3A_g">g</code>, <code id="labDive-internal_+3A_ordpen">ordpen</code></td>
<td>
<p>default arguments for
<code><a href="uniReg.html#topic+unireg">unireg</a></code>, so only relevant for
<code>divemodel="unimodal"</code>.</p>
</td></tr>
<tr><td><code id="labDive-internal_+3A_act">act</code></td>
<td>
<p>factor with values to label.</p>
</td></tr>
<tr><td><code id="labDive-internal_+3A_string">string</code></td>
<td>
<p>character string belonging to a level of <code>act</code> to
search for and label sequentially.</p>
</td></tr>
<tr><td><code id="labDive-internal_+3A_diveid">diveID</code></td>
<td>
<p>numeric vector indexing each dive (non-dives should be
0)</p>
</td></tr>
<tr><td><code id="labDive-internal_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>.cutDive</code> (<code>smooth.par</code>
and <code>knot.factor</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are for internal use and are not meant to be
called by the user.</p>


<h3>Value</h3>

<p><code>.labDive</code> returns a matrix with as many rows as its first two
arguments with two columns: dive.id, and postdive.id, each one
sequentially numbering each dive and postdive period.
</p>
<p><code>.labDivePhase</code> returns a list with a factor having levels
&ldquo;D&rdquo;, &ldquo;DB&rdquo;, &ldquo;B&rdquo;, &ldquo;BA&rdquo;, &ldquo;A&rdquo;,
&ldquo;DA&rdquo;, and &ldquo;X&rdquo;, breaking the input into descent,
descent/bottom, bottom, bottom/ascent, ascent, and non-dive,
respectively.  If <code>x</code> contains no dives, only level &ldquo;X&rdquo; is
present for all readings.  The list also contains another list with
<code><a href="#topic+diveModel">diveModel</a></code> objects for each dive.
</p>
<p><code>.cutDive</code> generates a <code><a href="#topic+diveModel">diveModel</a></code> object with
details of model used to detect dive phases using cubic spline
smoothing and its first derivative.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a></p>

<hr>
<h2 id='labelBouts+2Cnumeric-method'>Label each vector element or matrix row with bout membership number</h2><span id='topic+labelBouts+2Cnumeric-method'></span><span id='topic+labelBouts'></span><span id='topic+labelBouts+2CBouts-method'></span>

<h3>Description</h3>

<p>Identify which bout an observation belongs to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
labelBouts(obj, becs, bec.method = c("standard", "seq.diff"))

## S4 method for signature 'Bouts'
labelBouts(obj, becs, bec.method = c("standard", "seq.diff"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labelBouts+2B2Cnumeric-method_+3A_obj">obj</code></td>
<td>
<p>Object of class <code><a href="#topic+Bouts">Bouts</a></code> object, or numeric
vector or matrix with independent data modelled as a Poisson
process mixture.</p>
</td></tr>
<tr><td><code id="labelBouts+2B2Cnumeric-method_+3A_becs">becs</code></td>
<td>
<p>numeric vector or matrix with values for the bout ending
criterion which should be compared against the values in x for
identifying the bouts.  It needs to have the same dimensions as
<code>x</code> to allow for situations where <code>bec</code> is within
<code>x</code>.</p>
</td></tr>
<tr><td><code id="labelBouts+2B2Cnumeric-method_+3A_bec.method">bec.method</code></td>
<td>
<p>character: method used for calculating the
frequencies: &ldquo;standard&rdquo; simply uses x, while
&ldquo;seq.diff&rdquo; uses the sequential differences method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>labelBouts</code> returns a numeric vector sequentially
labelling each row or element of <var>x</var>, which associates it with
a particular bout. <code>unLogit</code> and <code>logit</code> return a numeric
vector with the (un)transformed arguments.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>numeric</code>: Label data on vector or matrix objects.
</p>
</li>
<li> <p><code>Bouts</code>: Label data on <code><a href="#topic+Bouts">Bouts</a></code> object
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Run example to retrieve random samples for two- and three-process
## Poisson mixtures with known parameters as 'Bouts' objects
## ('xbouts2', and 'xbouts3'), as well as starting values from
## broken-stick model ('startval2' and 'startval3')
utils::example("boutinit", package="diveMove", ask=FALSE)

## 2-process
opts0 &lt;- list(method="L-BFGS-B", lower=c(-2, -5, -10))
opts1 &lt;- list(method="L-BFGS-B", lower=c(1e-1, 1e-3, 1e-6))
bouts2.fit &lt;- fitMLEbouts(xbouts2, start=startval2, optim_opts0=opts0,
                          optim_opts1=opts1)
bec2 &lt;- bec(bouts2.fit)
## labelBouts() expects its second argument to have the same
## dimensions as the data
labelBouts(xbouts2, becs=rep(bec2, length(xbouts2@x)))
</code></pre>

<hr>
<h2 id='plotBouts+2Cnls+2Cdata.frame-method'>Plot fitted Poisson mixture model and data</h2><span id='topic+plotBouts+2Cnls+2Cdata.frame-method'></span><span id='topic+plotBouts'></span><span id='topic+plotBouts+2Cnls+2CBouts-method'></span><span id='topic+plotBouts+2Cmle+2Cnumeric-method'></span><span id='topic+plotBouts+2Cmle+2CBouts-method'></span>

<h3>Description</h3>

<p>Plot fitted Poisson mixture model and data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nls,data.frame'
plotBouts(fit, obj, bec.lty = 2, ...)

## S4 method for signature 'nls,Bouts'
plotBouts(fit, obj, bec.lty = 2, ...)

## S4 method for signature 'mle,numeric'
plotBouts(fit, obj, xlab = "x", ylab = "Log Frequency", bec.lty = 2, ...)

## S4 method for signature 'mle,Bouts'
plotBouts(fit, obj, xlab = "x", ylab = "Log Frequency", bec.lty = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBouts+2B2Cnls+2B2Cdata.frame-method_+3A_fit">fit</code></td>
<td>
<p>Object of class <code>nls</code> or <code>mle</code>.</p>
</td></tr>
<tr><td><code id="plotBouts+2B2Cnls+2B2Cdata.frame-method_+3A_obj">obj</code></td>
<td>
<p>Object of class <code><a href="#topic+Bouts">Bouts</a></code>,
<code><a href="base.html#topic+data.frame">data.frame</a></code> with columns named <code>lnfreq</code> and
<code>x</code> (when <code>fit -&gt; nls object</code>, or numeric vector (valid
when <code>fit -&gt; mle object</code>.</p>
</td></tr>
<tr><td><code id="plotBouts+2B2Cnls+2B2Cdata.frame-method_+3A_bec.lty">bec.lty</code></td>
<td>
<p>Line type specification for drawing the BEC reference
line.</p>
</td></tr>
<tr><td><code id="plotBouts+2B2Cnls+2B2Cdata.frame-method_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="plotBouts+2B2Cnls+2B2Cdata.frame-method_+3A_xlab">xlab</code>, <code id="plotBouts+2B2Cnls+2B2Cdata.frame-method_+3A_ylab">ylab</code></td>
<td>
<p>Label for x and y axis, respectively.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fit = nls,obj = data.frame</code>: Plot fitted <code>nls</code> model on <code>data.frame</code>
object
</p>
</li>
<li> <p><code>fit = nls,obj = Bouts</code>: Plot fitted <code>nls</code> model on <code>Bouts</code>
object
</p>
</li>
<li> <p><code>fit = mle,obj = numeric</code>: Plot fitted <code>mle</code> model on <code>numeric</code>
object
</p>
</li>
<li> <p><code>fit = mle,obj = Bouts</code>: Plot fitted <code>mle</code> model on <code>Bouts</code>
object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boutfreqs">boutfreqs</a></code>, <code><a href="#topic+fitNLSbouts">fitNLSbouts</a></code>,
<code><a href="#topic+fitMLEbouts">fitMLEbouts</a></code>
</p>

<hr>
<h2 id='plotBoutsCDF+2Cnls+2Cnumeric-method'>Plot empirical and deterministic cumulative frequency distribution
Poisson mixture data and model</h2><span id='topic+plotBoutsCDF+2Cnls+2Cnumeric-method'></span><span id='topic+plotBoutsCDF'></span><span id='topic+plotBoutsCDF+2Cnls+2CBouts-method'></span><span id='topic+plotBoutsCDF+2Cmle+2Cnumeric-method'></span><span id='topic+plotBoutsCDF+2Cmle+2CBouts-method'></span>

<h3>Description</h3>

<p>Plot empirical and deterministic cumulative frequency distribution
Poisson mixture data and model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nls,numeric'
plotBoutsCDF(fit, obj, xlim, draw.bec = FALSE, bec.lty = 2, ...)

## S4 method for signature 'nls,Bouts'
plotBoutsCDF(fit, obj, xlim, draw.bec = FALSE, bec.lty = 2, ...)

## S4 method for signature 'mle,numeric'
plotBoutsCDF(fit, obj, xlim, draw.bec = FALSE, bec.lty = 2, ...)

## S4 method for signature 'mle,Bouts'
plotBoutsCDF(fit, obj, xlim, draw.bec = FALSE, bec.lty = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBoutsCDF+2B2Cnls+2B2Cnumeric-method_+3A_fit">fit</code></td>
<td>
<p>Object of class <code>nls</code> or <code>mle</code>.</p>
</td></tr>
<tr><td><code id="plotBoutsCDF+2B2Cnls+2B2Cnumeric-method_+3A_obj">obj</code></td>
<td>
<p>Object of class <code><a href="#topic+Bouts">Bouts</a></code>.</p>
</td></tr>
<tr><td><code id="plotBoutsCDF+2B2Cnls+2B2Cnumeric-method_+3A_xlim">xlim</code></td>
<td>
<p>2-length vector with limits for the x axis.  If omitted, a
sensible default is calculated.</p>
</td></tr>
<tr><td><code id="plotBoutsCDF+2B2Cnls+2B2Cnumeric-method_+3A_draw.bec">draw.bec</code></td>
<td>
<p>logical; whether to draw the BECs</p>
</td></tr>
<tr><td><code id="plotBoutsCDF+2B2Cnls+2B2Cnumeric-method_+3A_bec.lty">bec.lty</code></td>
<td>
<p>Line type specification for drawing the BEC reference
line.</p>
</td></tr>
<tr><td><code id="plotBoutsCDF+2B2Cnls+2B2Cnumeric-method_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fit = nls,obj = numeric</code>: Plot (E)CDF on <code><a href="stats.html#topic+nls">nls</a></code> fit object
and numeric vector
</p>
</li>
<li> <p><code>fit = nls,obj = Bouts</code>: Plot (E)CDF on <code><a href="stats.html#topic+nls">nls</a></code> fit object
and <code><a href="#topic+Bouts">Bouts</a></code> object
</p>
</li>
<li> <p><code>fit = mle,obj = numeric</code>: Plot (E)CDF on numeric vector
</p>
</li>
<li> <p><code>fit = mle,obj = Bouts</code>: Plot (E)CDF on <code><a href="stats4.html#topic+mle">mle</a></code> fit object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>

<hr>
<h2 id='plotDiveModel+2CdiveModel+2Cmissing-method'>Methods for plotting models of dive phases</h2><span id='topic+plotDiveModel+2CdiveModel+2Cmissing-method'></span><span id='topic+plotDiveModel'></span><span id='topic+plotDiveModel+2CTDRcalibrate+2Cmissing-method'></span><span id='topic+plotDiveModel+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>All methods produce a double panel plot.  The top panel shows the depth
against time, the cubic spline smoother, the identified descent and
ascent phases (which form the basis for identifying the rest of the
dive phases), while the bottom panel shows the first derivative of the
smooth trace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'diveModel,missing'
plotDiveModel(x, diveNo)

## S4 method for signature 'TDRcalibrate,missing'
plotDiveModel(x, diveNo)

## S4 method for signature 'numeric,numeric'
plotDiveModel(
  x,
  y,
  times.s,
  depths.s,
  d.crit,
  a.crit,
  diveNo = 1,
  times.deriv,
  depths.deriv,
  d.crit.rate,
  a.crit.rate
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotDiveModel+2B2CdiveModel+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+diveModel">diveModel</a></code> (diveModel,missing method),
<code><a href="base.html#topic+numeric">numeric</a></code> vector of time step observations
(numeric,numeric method), or <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> object
(TDRcalibrate,numeric method).</p>
</td></tr>
<tr><td><code id="plotDiveModel+2B2CdiveModel+2B2Cmissing-method_+3A_diveno">diveNo</code></td>
<td>
<p>integer representing the dive number selected for
plotting.</p>
</td></tr>
<tr><td><code id="plotDiveModel+2B2CdiveModel+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>numeric vector with depth observations at each time step.</p>
</td></tr>
<tr><td><code id="plotDiveModel+2B2CdiveModel+2B2Cmissing-method_+3A_times.s">times.s</code></td>
<td>
<p>numeric vector with time steps used to generate the
smoothing spline (i.e. the knots, see <code><a href="#topic+diveModel">diveModel</a></code>).</p>
</td></tr>
<tr><td><code id="plotDiveModel+2B2CdiveModel+2B2Cmissing-method_+3A_depths.s">depths.s</code></td>
<td>
<p>numeric vector with smoothed depth (see
<code><a href="#topic+diveModel">diveModel</a></code>).</p>
</td></tr>
<tr><td><code id="plotDiveModel+2B2CdiveModel+2B2Cmissing-method_+3A_d.crit">d.crit</code></td>
<td>
<p>integer denoting the index where descent ends in the
observed time series (see <code><a href="#topic+diveModel">diveModel</a></code>).</p>
</td></tr>
<tr><td><code id="plotDiveModel+2B2CdiveModel+2B2Cmissing-method_+3A_a.crit">a.crit</code></td>
<td>
<p>integer denoting the index where ascent begins in the
observed time series (see <code><a href="#topic+diveModel">diveModel</a></code>).</p>
</td></tr>
<tr><td><code id="plotDiveModel+2B2CdiveModel+2B2Cmissing-method_+3A_times.deriv">times.deriv</code></td>
<td>
<p>numeric vector representing the time steps where the
derivative of the smoothing spline was evaluated (see
<code><a href="#topic+diveModel">diveModel</a></code>).</p>
</td></tr>
<tr><td><code id="plotDiveModel+2B2CdiveModel+2B2Cmissing-method_+3A_depths.deriv">depths.deriv</code></td>
<td>
<p>numeric vector representing the derivative of the
smoothing spline evaluated at <code>times.deriv</code> (see
<code><a href="#topic+diveModel">diveModel</a></code>).</p>
</td></tr>
<tr><td><code id="plotDiveModel+2B2CdiveModel+2B2Cmissing-method_+3A_d.crit.rate">d.crit.rate</code></td>
<td>
<p>numeric scalar: vertical rate of descent
corresponding to the quantile used (see <code><a href="#topic+diveModel">diveModel</a></code>).</p>
</td></tr>
<tr><td><code id="plotDiveModel+2B2CdiveModel+2B2Cmissing-method_+3A_a.crit.rate">a.crit.rate</code></td>
<td>
<p>numeric scalar: vertical rate of ascent
corresponding to the quantile used (see <code><a href="#topic+diveModel">diveModel</a></code>).</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>x = diveModel,y = missing</code>: Given a <code><a href="#topic+diveModel">diveModel</a></code> object and
(possibly) the dive number that it corresponds to, the plot shows
the model data.
</p>
</li>
<li> <p><code>x = TDRcalibrate,y = missing</code>: Given a <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> object and
a dive number to extract from it, this method plots the observed
data and the model.  The intended use of this method is through
<code><a href="#topic+plotTDR">plotTDR</a></code> when <code>what="dive.model"</code>.
</p>
</li>
<li> <p><code>x = numeric,y = numeric</code>: Base method, requiring all aspects of the
model to be provided.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diveModel">diveModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Too long for checks

## Continuing the Example from '?calibrateDepth':
utils::example("calibrateDepth", package="diveMove",
               ask=FALSE, echo=FALSE, run.donttest=TRUE)

## 'diveModel' method
dm &lt;- getDiveModel(dcalib, 100)
plotDiveModel(dm, diveNo=100)

## 'TDRcalibrate' method
plotDiveModel(dcalib, diveNo=100)


</code></pre>

<hr>
<h2 id='plotTDR+2CPOSIXt+2Cnumeric-method'>Methods for plotting objects of class &quot;TDR&quot; and &quot;TDRcalibrate&quot;</h2><span id='topic+plotTDR+2CPOSIXt+2Cnumeric-method'></span><span id='topic+plotTDR'></span><span id='topic+plotTDR+2CTDR+2Cmissing-method'></span><span id='topic+plotTDR+2CTDRcalibrate+2Cmissing-method'></span>

<h3>Description</h3>

<p>Main plotting method for objects of these classes.  Plot and optionally
set zero-offset correction windows in <abbr><span class="acronym">TDR</span></abbr> records, with the
aid of a graphical user interface (GUI), allowing for dynamic selection
of offset and multiple time windows to perform the adjustment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'POSIXt,numeric'
plotTDR(
  x,
  y,
  concurVars = NULL,
  xlim = NULL,
  depth.lim = NULL,
  ylab.depth = "depth (m)",
  concurVarTitles = deparse(substitute(concurVars)),
  sunrise.time = "06:00:00",
  sunset.time = "18:00:00",
  night.col = "gray60",
  dry.time = NULL,
  phase.factor = NULL
)

## S4 method for signature 'TDR,missing'
plotTDR(x, y, concurVars, concurVarTitles, ...)

## S4 method for signature 'TDRcalibrate,missing'
plotTDR(
  x,
  y,
  what = c("phases", "dive.model"),
  diveNo = seq(max(getDAct(x, "dive.id"))),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_x">x</code></td>
<td>
<p><code>POSIXct</code> object with date and time, <code><a href="#topic+TDR">TDR</a></code>,
or <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> object.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_y">y</code></td>
<td>
<p>numeric vector with depth in m.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_concurvars">concurVars</code></td>
<td>
<p>matrix with additional variables in each column to
plot concurrently with depth.  For the (<code>TDR</code>,<code>missing</code>)
and (<code>TDRcalibrate</code>,<code>missing</code>) methods, a
<code><a href="base.html#topic+character">character</a></code> vector naming additional variables from the
<code>concurrentData</code> slot to plot, if any.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_xlim">xlim</code></td>
<td>
<p><code>POSIXct</code> or numeric vector of length 2, with lower
and upper limits of time to be plotted.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_depth.lim">depth.lim</code></td>
<td>
<p>numeric vector of length 2, with the lower and upper
limits of depth to be plotted.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_ylab.depth">ylab.depth</code></td>
<td>
<p>character string to label the corresponding y-axes.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_concurvartitles">concurVarTitles</code></td>
<td>
<p>character vector of titles to label each new
variable given in <var>concurVars</var>.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_sunrise.time">sunrise.time</code>, <code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_sunset.time">sunset.time</code></td>
<td>
<p>character string with time of sunrise
and sunset, respectively, in 24 hr format.  This is used for
shading night time.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_night.col">night.col</code></td>
<td>
<p>color for shading night time.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_dry.time">dry.time</code></td>
<td>
<p>subset of time corresponding to observations considered
to be dry.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_phase.factor">phase.factor</code></td>
<td>
<p>factor dividing rows into sections.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_...">...</code></td>
<td>
<p>Arguments for the <code>(POSIXt,numeric)</code> method.  For
<code>(TDRcalibrate,missing)</code>, these are arguments for the
appropriate methods.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_what">what</code></td>
<td>
<p>character: what aspect of the <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> to
plot, which selects the method to use for plotting.</p>
</td></tr>
<tr><td><code id="plotTDR+2B2CPOSIXt+2B2Cnumeric-method_+3A_diveno">diveNo</code></td>
<td>
<p>numeric vector or scalar with dive numbers to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If called with the <code>interact</code> argument set to <code>TRUE</code>,
returns a list (invisibly) with as many components as sections of
the record that were zero-offset corrected, each consisting of two
further lists with the same components as those returned by
<code><a href="graphics.html#topic+locator">locator</a></code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>x = POSIXt,y = numeric</code>: Base method plotting numeric vector against POSIXt
object
</p>
</li>
<li> <p><code>x = TDR,y = missing</code>: Interactive graphical display of time-depth data,
with zooming and panning capabilities.
</p>
</li>
<li> <p><code>x = TDRcalibrate,y = missing</code>: plot selected aspects of <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code>
object.  Currently, two aspects have plotting methods:
</p>
<p>* <code>phases</code> (Optional arguments: <code>concurVars</code>, <code>surface</code>)
Plots all dives, labelled by the activity phase they belong to.  It
produces a plot consisting of one or more panels; the first panel
shows depth against time, and additional panels show other concurrent
data in the object.  Optional argument <code>concurVars</code> is a
character vector indicating which additional components from the
<code>concurrentData</code> slot to plot, if any.  Optional argument
<code>surface</code> is a logical: whether to plot surface readings.
</p>
<p>* <code>dive.model</code> Plots the dive model for the selected dive number
(<code>diveNo</code> argument).
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>, with many ideas
from CRAN package sfsmisc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibrateDepth">calibrateDepth</a></code>, <code><a href="#topic+.zoc">.zoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Too long for checks

## Continuing the Example from '?calibrateDepth':
utils::example("calibrateDepth", package="diveMove",
               ask=FALSE, echo=FALSE, run.donttest=TRUE)
## Use interact=TRUE (default) to set an offset interactively
## Plot the 'TDR' object
plotTDR(getTime(divesTDR), getDepth(divesTDR))
plotTDR(divesTDR)

## Plot different aspects of the 'TDRcalibrate' object
plotTDR(dcalib)
plotTDR(dcalib, diveNo=19:25)
plotTDR(dcalib, what="dive.model", diveNo=25)
if (dev.interactive(orNone=TRUE)) {
    ## Add surface observations and interact
    plotTDR(dcalib, surface=TRUE)
    ## Plot one dive
    plotTDR(dcalib, diveNo=200)
}


</code></pre>

<hr>
<h2 id='plotZOC+2CTDR+2Cmatrix-method'>Methods for visually assessing results of ZOC procedure</h2><span id='topic+plotZOC+2CTDR+2Cmatrix-method'></span><span id='topic+plotZOC'></span><span id='topic+plotZOC+2CTDR+2CTDRcalibrate-method'></span>

<h3>Description</h3>

<p>Plots for comparing the zero-offset corrected depth from a
<code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> object with the uncorrected data in a
<code><a href="#topic+TDR">TDR</a></code> object, or the progress in each of the filters during
recursive filtering for ZOC (<code><a href="#topic+calibrateDepth">calibrateDepth</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TDR,matrix'
plotZOC(x, y, xlim, ylim, ylab = "Depth (m)", ...)

## S4 method for signature 'TDR,TDRcalibrate'
plotZOC(x, y, xlim, ylim, ylab = "Depth (m)", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotZOC+2B2CTDR+2B2Cmatrix-method_+3A_x">x</code></td>
<td>
<p><code>TDR</code> object.</p>
</td></tr>
<tr><td><code id="plotZOC+2B2CTDR+2B2Cmatrix-method_+3A_y">y</code></td>
<td>
<p>matrix with the same number of rows as there are observations
in <code>x</code>, or a <code>TDRcalibrate</code> object.</p>
</td></tr>
<tr><td><code id="plotZOC+2B2CTDR+2B2Cmatrix-method_+3A_xlim">xlim</code></td>
<td>
<p><code>POSIXct</code> or numeric vector of length 2, with lower
and upper limits of time to be plotted.  Defaults to time range of
input.</p>
</td></tr>
<tr><td><code id="plotZOC+2B2CTDR+2B2Cmatrix-method_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector of length 2 (upper, lower) with axis limits.
Defaults to range of input.</p>
</td></tr>
<tr><td><code id="plotZOC+2B2CTDR+2B2Cmatrix-method_+3A_ylab">ylab</code></td>
<td>
<p>character strings to label the corresponding y-axis.</p>
</td></tr>
<tr><td><code id="plotZOC+2B2CTDR+2B2Cmatrix-method_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>TDR</code>,<code>matrix</code> method produces a plot like those shown in
Luque and Fried (2011).
</p>
<p>The <code>TDR</code>,<code>TDRcalibrate</code> method overlays the corrected depth
from the second argument over that from the first.
</p>


<h3>Value</h3>

<p>Nothing; a plot as side effect.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>x = TDR,y = matrix</code>: This plot helps in finding appropriate parameters
for <code>diveMove:::.depthFilter</code>, and consists of three panels.
The upper panel shows the original data, the middle panel shows the
filters, and the last panel shows the corrected
data. method=&ldquo;visual&rdquo; in <code><a href="#topic+calibrateDepth">calibrateDepth</a></code>.
</p>
</li>
<li> <p><code>x = TDR,y = TDRcalibrate</code>: This plots depth from the <code>TDRcalibrate</code>
object over the one from the <code>TDR</code> object.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>References</h3>

<p>Luque, S.P. and Fried, R. (2011) Recursive filtering for zero offset
correction of diving depth time series. PLoS ONE 6:e15850
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibrateDepth">calibrateDepth</a></code>, <code><a href="#topic+.zoc">.zoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the Example from '?diveStats':
## Too long for checks

utils::example("diveStats", package="diveMove",
               ask=FALSE, echo=FALSE, run.donttest=TRUE)

## Plot filters for ZOC
## Work on first phase (trip) subset, to save processing time, since
## there's no drift nor shifts between trips
tdr &lt;- divesTDR[1:15000]
## Try window widths (K), quantiles (P) and bound the search (db)
K &lt;- c(3, 360); P &lt;- c(0.5, 0.02); db &lt;- c(0, 5)
d.filter &lt;- diveMove:::.depthFilter(depth=getDepth(tdr),
                                    k=K, probs=P, depth.bounds=db,
                                    na.rm=TRUE)
old.par &lt;- par(no.readonly=TRUE)
plotZOC(tdr, d.filter, ylim=c(0, 6))
par(old.par)

## Plot corrected and uncorrected depth, regardless of method
## Look at three different scales
xlim1 &lt;- c(getTime(divesTDR)[7100], getTime(divesTDR)[11700])
xlim2 &lt;- c(getTime(divesTDR)[7100], getTime(divesTDR)[7400])
xlim3 &lt;- c(getTime(divesTDR)[7100], getTime(divesTDR)[7200])
par(mar=c(3, 4, 0, 1) + 0.1, cex=1.1, las=1)
layout(seq(3))
plotZOC(divesTDR, dcalib, xlim=xlim1, ylim=c(0, 6))
plotZOC(divesTDR, dcalib, xlim=xlim2, ylim=c(0, 70))
plotZOC(divesTDR, dcalib, xlim=xlim3, ylim=c(0, 70))
par(old.par)


</code></pre>

<hr>
<h2 id='readLocs'>Read comma-delimited file with location data</h2><span id='topic+readLocs'></span>

<h3>Description</h3>

<p>Read a delimited (*.csv) file with (at least) time, latitude, longitude
readings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readLocs(
  locations,
  loc.idCol,
  idCol,
  dateCol,
  timeCol = NULL,
  dtformat = "%m/%d/%Y %H:%M:%S",
  tz = "GMT",
  classCol,
  lonCol,
  latCol,
  alt.lonCol = NULL,
  alt.latCol = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readLocs_+3A_locations">locations</code></td>
<td>
<p>character: a string indicating the path to the file to
read, or a <code><a href="base.html#topic+data.frame">data.frame</a></code> available in the search
list. Provide the entire path if the file is not on the current
directory.  This can also be a text-mode connection, as allowed in
<code><a href="utils.html#topic+read.csv">read.csv</a></code>.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_loc.idcol">loc.idCol</code></td>
<td>
<p>integer: column number containing location ID.  If
missing, a <code>loc.id</code> column is generated with sequential
integers as long as the input.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_idcol">idCol</code></td>
<td>
<p>integer: column number containing an identifier for
locations belonging to different groups.  If missing, an id column
is generated with number one repeated as many times as the input.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_datecol">dateCol</code></td>
<td>
<p>integer: column number containing dates, and,
optionally, times.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_timecol">timeCol</code></td>
<td>
<p>integer: column number containing times.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_dtformat">dtformat</code></td>
<td>
<p>character: a string specifying the format in which the
date and time columns, when pasted together, should be interpreted
(see <code><a href="base.html#topic+strptime">strptime</a></code>) in <code>file</code>.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_tz">tz</code></td>
<td>
<p>character: a string indicating the time zone for the date and
time readings.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_classcol">classCol</code></td>
<td>
<p>integer: column number containing the ARGOS rating for
each location.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_loncol">lonCol</code></td>
<td>
<p>integer: column number containing longitude readings.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_latcol">latCol</code></td>
<td>
<p>integer: column number containing latitude readings.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_alt.loncol">alt.lonCol</code></td>
<td>
<p>integer: column number containing alternative
longitude readings.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_alt.latcol">alt.latCol</code></td>
<td>
<p>integer: Column number containing alternative
latitude readings.</p>
</td></tr>
<tr><td><code id="readLocs_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="utils.html#topic+read.csv">read.csv</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file must have a header row identifying each field, and all rows
must be complete (i.e. have the same number of fields). Field names
need not follow any convention.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Do example to define object zz with location of dataset
utils::example("sealLocs", package="diveMove",
               ask=FALSE, echo=FALSE)
locs &lt;- readLocs(zz, idCol=1, dateCol=2,
                 dtformat="%Y-%m-%d %H:%M:%S", classCol=3,
                 lonCol=4, latCol=5, sep=";")

summary(locs)
</code></pre>

<hr>
<h2 id='rmixexp'>Generate samples from a mixture of exponential distributions</h2><span id='topic+rmixexp'></span>

<h3>Description</h3>

<p><code>rmixexp</code> uses a special definition for the probabilities
<code>p_i</code> to generate random samples from a mixed Poisson distribution
with known parameters for each process.  In the two-process case,
<code>p</code> represents the proportion of &quot;fast&quot; to &quot;slow&quot; events in the
mixture.  In the three-process case, <code>p_0</code> represents the
proportion of &quot;fast&quot; to &quot;slow&quot; events, and <code>p_1</code> represents the
proportion of &quot;slow&quot; to &quot;slow&quot; *and* &quot;very slow&quot; events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmixexp(n, p, lambdas)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmixexp_+3A_n">n</code></td>
<td>
<p>integer output sample size.</p>
</td></tr>
<tr><td><code id="rmixexp_+3A_p">p</code></td>
<td>
<p>numeric probabilities for processes generating the output
mixture sample.</p>
</td></tr>
<tr><td><code id="rmixexp_+3A_lambdas">lambdas</code></td>
<td>
<p>numeric <code>lambda</code> (rate) for each process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Draw samples from a mixture where the first process occurs with
## p &lt; 0.7, and the second process occurs with the remaining
## probability.
p &lt;- 0.7
lda &lt;- c(0.05, 0.005)
(rndprocs2 &lt;- rmixexp(1000, p, lda))

## 3-process
p_f &lt;- 0.6    # fast to slow
p_svs &lt;- 0.7  # prop of slow to (slow + very slow) procs
p_true &lt;- c(p_f, p_svs)
lda_true &lt;- c(0.05, 0.01, 8e-4)
(rndprocs3 &lt;- rmixexp(1000, p_true, lda_true))
</code></pre>

<hr>
<h2 id='rqPlot'>Plot of quantile regression for speed calibrations</h2><span id='topic+rqPlot'></span>

<h3>Description</h3>

<p>Plot of quantile regression for assessing quality of speed calibrations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqPlot(
  rddepth,
  speed,
  z,
  contours,
  rqFit,
  main = "qtRegression",
  xlab = "rate of depth change (m/s)",
  ylab = "speed (m/s)",
  colramp = colorRampPalette(c("white", "darkblue")),
  col.line = "red",
  cex.pts = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rqPlot_+3A_rddepth">rddepth</code></td>
<td>
<p>numeric vector with rate of depth change.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_speed">speed</code></td>
<td>
<p>numeric vector with speed in m/s.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_z">z</code></td>
<td>
<p>list with the bivariate kernel density estimates (1st
component the x points of the mesh, 2nd the y points, and 3rd the
matrix of densities).</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_contours">contours</code></td>
<td>
<p>list with components: <code>pts</code> which should be a
matrix with columns named <code>x</code> and <code>y</code>, <code>level</code> a
number indicating the contour level the points in <code>pts</code>
correspond to.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_rqfit">rqFit</code></td>
<td>
<p>object of class &ldquo;rq&rdquo; representing a quantile
regression fit of rate of depth change on mean speed.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_main">main</code></td>
<td>
<p>character: string with title prefix to include in ouput
plot.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_xlab">xlab</code>, <code id="rqPlot_+3A_ylab">ylab</code></td>
<td>
<p>character vectors with axis labels.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_colramp">colramp</code></td>
<td>
<p>function taking an integer n as an argument and
returning n colors.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_col.line">col.line</code></td>
<td>
<p>color to use for the regression line.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_cex.pts">cex.pts</code></td>
<td>
<p>numeric: value specifying the amount by which to enlarge
the size of points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dashed line in the plot represents a reference indicating a one to
one relationship between speed and rate of depth change.  The other
line represent the quantile regression fit.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diveStats">diveStats</a></code>
</p>

<hr>
<h2 id='sealLocs'>Ringed and Gray Seal ARGOS Satellite Location Data</h2><span id='topic+sealLocs'></span>

<h3>Description</h3>

<p>Satellite locations of a gray (Stephanie) and a ringed
(Ringy) seal caught and released in New York.</p>


<h3>Format</h3>

<p>Bzip2-compressed file.  A <code><a href="base.html#topic+data.frame">data.frame</a></code> with the
following information:
</p>

<dl>
<dt>id</dt><dd><p>String naming the seal the data come from.</p>
</dd>
<dt>time</dt><dd><p>The date and time of the location.</p>
</dd>
<dt>class</dt><dd><p>The ARGOS location quality classification.</p>
</dd>
<dt>lon, lat</dt><dd><p>x and y geographic coordinates of each location.</p>
</dd>
</dl>



<h3>Source</h3>

<p>WhaleNet Satellite Tracking Program
<a href="http://whale.wheelock.edu">http://whale.wheelock.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+readLocs">readLocs</a></code>, <code><a href="#topic+distSpeed">distSpeed</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zz &lt;- system.file(file.path("data", "sealLocs.csv"),
                  package="diveMove", mustWork=TRUE)
str(read.csv(zz, sep=";"))

</code></pre>

<hr>
<h2 id='TDR-accessors'>Coerce, Extractor, and Replacement methods for class &quot;TDR&quot;
objects</h2><span id='topic+TDR-methods'></span><span id='topic+TDR-accessors'></span><span id='topic+as.TDRspeed'></span><span id='topic+ccData+3C-'></span><span id='topic+depth+3C-'></span><span id='topic+speed+3C-'></span><span id='topic+getCCData'></span><span id='topic+getDepth'></span><span id='topic+getDtime'></span><span id='topic+getFileName'></span><span id='topic+getTime'></span><span id='topic+getSpeed'></span><span id='topic++5B+2CTDR+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic+as.data.frame+2CTDR-method'></span><span id='topic+coerce+2CTDR+2Cdata.frame-method'></span><span id='topic+as.TDRspeed+2CTDR-method'></span><span id='topic+coerce+2CTDR+2CTDRspeed-method'></span><span id='topic+getCCData+2CTDR+2Cmissing-method'></span><span id='topic+getCCData+2CTDR+2Ccharacter-method'></span><span id='topic+ccData+3C-+2CTDR+2Cdata.frame-method'></span><span id='topic+getDepth+2CTDR-method'></span><span id='topic+getDtime+2CTDR-method'></span><span id='topic+depth+3C-+2CTDR+2Cnumeric-method'></span><span id='topic+getFileName+2CTDR-method'></span><span id='topic+show+2CTDR-method'></span><span id='topic+getTime+2CTDR-method'></span><span id='topic+getSpeed+2CTDRspeed-method'></span><span id='topic+speed+3C-+2CTDRspeed+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Basic methods for manipulating objects of class
<code><a href="#topic+TDR">TDR</a></code>. </p>


<h3>Show Method</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object="TDR")</code>: print an informative
summary of the data.</p>
</dd>
</dl>



<h3>Coerce Methods</h3>


<dl>
<dt>as.data.frame</dt><dd><p><code>signature(x="TDR")</code>: Coerce object to
data.frame.  This method returns a data frame, with attributes
&ldquo;file&rdquo; and &ldquo;dtime&rdquo; indicating the source file and
the interval between samples.</p>
</dd>
<dt>as.data.frame</dt><dd><p><code>signature(x="TDRspeed")</code>: Coerce object
to data.frame.  Returns an object as for <code><a href="#topic+TDR">TDR</a></code>
objects.</p>
</dd>
<dt>as.TDRspeed</dt><dd><p><code>signature(x="TDR")</code>: Coerce object to
<code><a href="#topic+TDRspeed">TDRspeed</a></code> class.</p>
</dd>
</dl>



<h3>Extractor Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x="TDR", i="numeric", j="missing",
	drop="missing")</code>: Subset a TDR object; these objects can be
subsetted on a single index <var>i</var>.  Selects given rows from
object.</p>
</dd>
<dt>getDepth</dt><dd><p><code>signature(x = "TDR")</code>: depth slot accessor.</p>
</dd>
<dt>getCCData</dt><dd><p><code>signature(x="TDR", y="missing")</code>:
concurrentData slot accessor.</p>
</dd>
<dt>getCCData</dt><dd><p><code>signature(x="TDR", y="character")</code>: access
component named <var>y</var> in <var>x</var>.</p>
</dd>
<dt>getDtime</dt><dd><p><code>signature(x = "TDR")</code>: sampling interval
accessor.</p>
</dd>
<dt>getFileName</dt><dd><p><code>signature(x="TDR")</code>: source file name
accessor.</p>
</dd>
<dt>getTime</dt><dd><p><code>signature(x = "TDR")</code>: time slot accessor.</p>
</dd>
<dt>getSpeed</dt><dd><p><code>signature(x = "TDRspeed")</code>: speed accessor for
<code>TDRspeed</code> objects.</p>
</dd>
</dl>



<h3>Replacement Methods</h3>


<dl>
<dt>depth&lt;-</dt><dd><p><code>signature(x="TDR")</code>: depth replacement.</p>
</dd>
<dt>speed&lt;-</dt><dd><p><code>signature(x="TDR")</code>: speed replacement.</p>
</dd>
<dt>ccData&lt;-</dt><dd><p><code>signature(x="TDR")</code>: concurrent data frame
replacement.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+extractDive">extractDive</a></code>, <code><a href="#topic+plotTDR">plotTDR</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(divesTDR)

## Retrieve the name of the source file
getFileName(divesTDR)
## Retrieve concurrent temperature measurements
temp &lt;- getCCData(divesTDR, "temperature"); head(temp)
temp &lt;- getCCData(divesTDR); head(temp)

## Coerce to a data frame
dives.df &lt;- as.data.frame(divesTDR)
head(dives.df)

## Replace speed measurements
newspeed &lt;- getSpeed(divesTDR) + 2
speed(divesTDR) &lt;- newspeed
</code></pre>

<hr>
<h2 id='TDR-class'>Classes &quot;TDR&quot; and &quot;TDRspeed&quot; for representing TDR information</h2><span id='topic+TDR-class'></span><span id='topic+TDR'></span><span id='topic+TDRspeed-class'></span><span id='topic+TDRspeed'></span>

<h3>Description</h3>

<p>These classes store information gathered by time-depth recorders.
</p>


<h3>Details</h3>

<p>Since the data to store in objects of these clases usually come from a
file, the easiest way to construct such objects is with the function
<code><a href="#topic+readTDR">readTDR</a></code> to retrieve all the necessary information.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>TDRspeed-class</code>: Class <code>TDRspeed</code>
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>file</code></dt><dd><p>Object of class &lsquo;character&rsquo;, string indicating the
file where the data comes from.</p>
</dd>
<dt><code>dtime</code></dt><dd><p>Object of class &lsquo;numeric&rsquo;, sampling interval in
seconds.</p>
</dd>
<dt><code>time</code></dt><dd><p>Object of class <code><a href="base.html#topic+POSIXct">POSIXct</a></code>, time stamp for every
reading.</p>
</dd>
<dt><code>depth</code></dt><dd><p>Object of class &lsquo;numeric&rsquo;, depth (m) readings.</p>
</dd>
<dt><code>concurrentData</code></dt><dd><p>Object of class <code><a href="base.html#topic+data.frame">data.frame</a></code>, optional
data collected concurrently.</p>
</dd>
</dl>


<h3>Objects from the class</h3>

<p>Objects can be created by calls of the form <code>new("TDR", ...)</code>
and <code>new("TDRspeed", ...)</code>.
</p>
<p>&lsquo;TDR&rsquo; objects contain concurrent time and depth readings, as
well as a string indicating the file the data originates from, and a
number indicating the sampling interval for these data.
&lsquo;TDRspeed&rsquo; extends &lsquo;TDR&rsquo; objects containing additional
concurrent speed readings.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readTDR">readTDR</a></code>, <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code>.
</p>

<hr>
<h2 id='TDRcalibrate-accessors'>Methods to Show and Extract Basic Information from &quot;TDRcalibrate&quot;
Objects</h2><span id='topic+TDRcalibrate-methods'></span><span id='topic+TDRcalibrate-accessors'></span><span id='topic+getDAct'></span><span id='topic+getDPhaseLab'></span><span id='topic+getDiveModel'></span><span id='topic+getDiveDeriv'></span><span id='topic+getGAct'></span><span id='topic+getSpeedCoef'></span><span id='topic+getTDR'></span><span id='topic+getDAct+2CTDRcalibrate+2Cmissing-method'></span><span id='topic+getDAct+2CTDRcalibrate+2Ccharacter-method'></span><span id='topic+getDPhaseLab+2CTDRcalibrate+2Cmissing-method'></span><span id='topic+getDPhaseLab+2CTDRcalibrate+2Cnumeric-method'></span><span id='topic+getDiveModel+2CTDRcalibrate+2Cmissing-method'></span><span id='topic+getDiveModel+2CTDRcalibrate+2Cnumeric-method'></span><span id='topic+getDiveDeriv+2CdiveModel-method'></span><span id='topic+getDiveDeriv+2CTDRcalibrate-method'></span><span id='topic+getGAct+2CTDRcalibrate+2Cmissing-method'></span><span id='topic+getGAct+2CTDRcalibrate+2Ccharacter-method'></span><span id='topic+show+2CTDRcalibrate-method'></span><span id='topic+show+2CdiveModel-method'></span><span id='topic+getSpeedCoef+2CTDRcalibrate-method'></span><span id='topic+getTDR+2CTDRcalibrate-method'></span>

<h3>Description</h3>

<p> Show and extract information from
<code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> objects. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TDRcalibrate,missing'
getDAct(x)
## S4 method for signature 'TDRcalibrate,character'
getDAct(x, y)
## S4 method for signature 'TDRcalibrate,missing'
getDPhaseLab(x)
## S4 method for signature 'TDRcalibrate,numeric'
getDPhaseLab(x, diveNo)
## S4 method for signature 'TDRcalibrate,missing'
getDiveModel(x)
## S4 method for signature 'TDRcalibrate,numeric'
getDiveModel(x, diveNo)
## S4 method for signature 'diveModel'
getDiveDeriv(x, phase=c("all", "descent", "bottom", "ascent"))
## S4 method for signature 'TDRcalibrate'
getDiveDeriv(x, diveNo, phase=c("all", "descent", "bottom", "ascent"))
## S4 method for signature 'TDRcalibrate,missing'
getGAct(x)
## S4 method for signature 'TDRcalibrate,character'
getGAct(x, y)
## S4 method for signature 'TDRcalibrate'
getSpeedCoef(x)
## S4 method for signature 'TDRcalibrate'
getTDR(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TDRcalibrate-accessors_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> object.</p>
</td></tr>
<tr><td><code id="TDRcalibrate-accessors_+3A_diveno">diveNo</code></td>
<td>
<p>numeric vector with dive numbers to extract information
from.</p>
</td></tr>
<tr><td><code id="TDRcalibrate-accessors_+3A_y">y</code></td>
<td>
<p>string; &ldquo;dive.id&rdquo;, &ldquo;dive.activity&rdquo;, or
&ldquo;postdive.id&rdquo; in the case of <code>getDAct</code>, to extract the
numeric dive ID, the factor identifying activity phases (with
underwater and diving levels possibly represented), or the numeric
postdive ID, respectively.  In the case of <code>getGAct</code> it should
be one of &ldquo;phase.id&rdquo;, &ldquo;activity&rdquo;, &ldquo;begin&rdquo;, or
&ldquo;end&rdquo;, to extract the numeric phase ID for each observation,
a factor indicating what major activity the observation corresponds
to (where diving and underwater levels are not represented), or the
beginning and end times of each phase in the record, respectively.</p>
</td></tr>
<tr><td><code id="TDRcalibrate-accessors_+3A_phase">phase</code></td>
<td>
<p>character vector indicating phase of the dive for which
to extract the derivative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> The extractor methods return an object of the same class as
elements of the slot they extracted. </p>


<h3>Show Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object="TDRcalibrate")</code>: prints an
informative summary of the data.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object="diveModel")</code>: prints an
informative summary of a dive model.</p>
</dd>
</dl>



<h3>Extractor Methods</h3>


<dl>
<dt>getDAct</dt><dd><p><code>signature(x="TDRcalibrate", y="missing")</code>: this
accesses the <code>dive.activity</code> slot of
<code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> objects.  Thus, it extracts a data
frame with vectors identifying all readings to a particular dive
and postdive number, and a factor identifying all readings to a
particular activity.</p>
</dd>
<dt>getDAct</dt><dd><p><code>signature(x="TDRcalibrate", y="character")</code>: as
the method for missing <code>y</code>, but selects a particular vector
to extract.  See <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> for possible
strings.</p>
</dd>
<dt>getDPhaseLab</dt><dd><p><code>signature(x="TDRcalibrate",
	diveNo="missing")</code>: extracts a factor identifying all readings
to a particular dive phase.  This accesses the
<code>dive.phases</code> slot of <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> objects,
which is a factor.</p>
</dd>
<dt>getDPhaseLab</dt><dd><p><code>signature(x="TDRcalibrate",
	diveNo="numeric")</code>: as the method for missing <code>y</code>, but
selects data from a particular dive number to extract.</p>
</dd>
<dt>getDiveModel</dt><dd><p><code>signature(x="TDRcalibrate",
	diveNo="missing")</code>: extracts a list with all dive phase models.
This accesses the dive.models slot of <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code>
objects.</p>
</dd>
<dt>getDiveModel</dt><dd><p><code>signature(x="TDRcalibrate",
	diveNo="numeric")</code>: as the method for missing <code>diveNo</code>, but
selects data from a particular dive number to extract.</p>
</dd>
<dt>getDiveDeriv</dt><dd><p><code>signature(x="TDRcalibrate")</code>: extracts the
derivative (list) of the dive model (smoothing spline) from the
dive.models slot of <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> objects for one
or all phases of a dive.</p>
</dd>
<dt>getDiveDeriv</dt><dd><p><code>signature(x="diveModel")</code>: as the method
for <code>TDRcalibrate</code>, but selects data from one or all phases
of a dive.</p>
</dd>
<dt>getGAct</dt><dd><p><code>signature(x="TDRcalibrate", y="missing")</code>: this
accesses the <code>gross.activity</code> slot of
<code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> objects, which is a named list.  It
extracts elements that divide the data into major wet and dry
activities.</p>
</dd>
<dt>getGAct</dt><dd><p><code>signature(x="TDRcalibrate", y="character")</code>: as
the method for missing <code>y</code>, but extracts particular
elements.</p>
</dd>
<dt>getTDR</dt><dd><p><code>signature(x="TDRcalibrate")</code>: this accesses the
tdr slot of <code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> objects, which is a
<code><a href="#topic+TDR">TDR</a></code> object.</p>
</dd>
<dt>getSpeedCoef</dt><dd><p><code>signature(x="TDRcalibrate")</code>: this
accesses the <code>speed.calib.coefs</code> slot of
<code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> objects; the speed calibration
coefficients.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+diveModel">diveModel</a></code>, <code><a href="#topic+plotDiveModel">plotDiveModel</a></code>,
<code><a href="#topic+plotTDR">plotTDR</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Too long for checks
## Continuing the Example from '?calibrateDepth':
utils::example("calibrateDepth", package="diveMove",
               ask=FALSE, echo=FALSE, , run.donttest=TRUE)
dcalib		# the 'TDRcalibrate' that was created

## Beginning times of each successive phase in record
getGAct(dcalib, "begin")

## Factor of dive IDs
dids &lt;- getDAct(dcalib, "dive.id")
table(dids[dids &gt; 0])		# samples per dive

## Factor of dive phases for given dive
getDPhaseLab(dcalib, 19)
## Full dive model
(dm &lt;- getDiveModel(dcalib, 19))
str(dm)

## Derivatives
getDiveDeriv(dcalib, diveNo=19)
(derivs.desc &lt;- getDiveDeriv(dcalib, diveNo=19, phase="descent"))
(derivs.bott &lt;- getDiveDeriv(dcalib, diveNo=19, phase="bottom"))
(derivs.asc &lt;- getDiveDeriv(dcalib, diveNo=19, phase="ascent"))
if (require(lattice)) {
    fl &lt;- c("descent", "bottom", "ascent")
    bwplot(~ derivs.desc$y + derivs.bott$y + derivs.asc$y,
           outer=TRUE, allow.multiple=TRUE, layout=c(1, 3),
           xlab=expression(paste("Vertical rate (", m %.% s^-1, ")")),
           strip=strip.custom(factor.levels=fl))
}



</code></pre>

<hr>
<h2 id='TDRcalibrate-class'>Class &quot;TDRcalibrate&quot; for dive analysis</h2><span id='topic+TDRcalibrate-class'></span><span id='topic+TDRcalibrate'></span>

<h3>Description</h3>

<p>This class holds information produced at various stages of dive
analysis.  Methods are provided for extracting data from each slot.
</p>


<h3>Details</h3>

<p>This is perhaps the most important class in diveMove, as it holds all
the information necessary for calculating requested summaries for a
TDR.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>Object of class <code><a href="base.html#topic+call">call</a></code>.  The matched call to the
function that created the object.</p>
</dd>
<dt><code>tdr</code></dt><dd><p>Object of class <code><a href="#topic+TDR">TDR</a></code>.  This slot contains the
time, zero-offset corrected depth, and possibly a data frame.  If
the object is also of class &quot;TDRspeed&quot;, then the data frame might
contain calibrated or uncalibrated speed.  See
<code><a href="#topic+readTDR">readTDR</a></code> and the accessor function
<code><a href="#topic+getTDR">getTDR</a></code> for this slot.</p>
</dd>
<dt><code>gross.activity</code></dt><dd><p>Object of class &lsquo;list&rsquo;. This slot holds a
list of the form returned by <code><a href="#topic+.detPhase">.detPhase</a></code>, composed of 4
elements.  It contains a vector (named <code>phase.id</code>) numbering
each major activity phase found in the record, a factor (named
<code>activity</code>) labelling each row as being dry, wet, or trivial
wet activity.  These two elements are as long as there are rows in
<code>tdr</code>.  This list also contains two more vectors, named
<code>begin</code> and <code>end</code>: one with the beginning time of each
phase, and another with the ending time; both represented as
<code><a href="base.html#topic+POSIXct">POSIXct</a></code> objects. See <code><a href="#topic+.detPhase">.detPhase</a></code>.</p>
</dd>
<dt><code>dive.activity</code></dt><dd><p>Object of class <code><a href="base.html#topic+data.frame">data.frame</a></code>.  This
slot contains a <code><a href="base.html#topic+data.frame">data.frame</a></code> of the form returned by
<code><a href="#topic+.detDive">.detDive</a></code>, with as many rows as those in <code>tdr</code>,
consisting of three vectors named: <code>dive.id</code>, which is an
integer vector, sequentially numbering each dive (rows that are not
part of a dive are labelled 0), dive.activity is a factor which
completes that in <code>activity</code> above, further identifying rows
in the record belonging to a dive.  The third vector in
<code>dive.activity</code> is an integer vector sequentially numbering
each postdive interval (all rows that belong to a dive are labelled
0).  See <code><a href="#topic+.detDive">.detDive</a></code>, and <code><a href="#topic+getDAct">getDAct</a></code> to
access all or any one of these vectors.</p>
</dd>
<dt><code>dive.phases</code></dt><dd><p>Object of class &lsquo;factor&rsquo;.  This slot is a
factor that labels each row in the record as belonging to a
particular phase of a dive.  It has the same form as the
&ldquo;phase.labels&rdquo; component of the list returned by
<code><a href="#topic+.labDivePhase">.labDivePhase</a></code>.</p>
</dd>
<dt><code>dive.models</code></dt><dd><p>Object of class &lsquo;list&rsquo;.  This slot contains
the details of the process of dive phase identification for each
dive.  It has the same form as the <code>dive.models</code> component of
the list returned by <code><a href="#topic+.labDivePhase">.labDivePhase</a></code>.  It has as many
components as there are dives in the <code><a href="#topic+TDR">TDR</a></code> object, each
of them of class <code><a href="#topic+diveModel">diveModel</a></code>.</p>
</dd>
<dt><code>dry.thr</code></dt><dd><p>Object of class &lsquo;numeric&rsquo;.  The temporal criteria
used for detecting dry periods that should be considered as wet.</p>
</dd>
<dt><code>wet.thr</code></dt><dd><p>Object of class &lsquo;numeric&rsquo; the temporal criteria
used for detecting periods wet that should not be considered as
foraging time.</p>
</dd>
<dt><code>dive.thr</code></dt><dd><p>Object of class &lsquo;numeric&rsquo;.  The temporal criteria
used for detecting periods wet that should not be considered as
foraging time.</p>
</dd>
<dt><code>speed.calib.coefs</code></dt><dd><p>Object of class &lsquo;numeric&rsquo;.  The
intercept and slope derived from the speed calibration procedure.
Defaults to c(0, 1) meaning uncalibrated speeds.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("TDRcalibrate",
...{})</code>.  The objects of this class contain information necessary to
divide the record into sections (e.g.  dry/water), dive/surface, and
different sections within dives.  They also contain the parameters used
to calibrate speed and criteria to divide the record into phases.
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TDR">TDR</a></code> for links to other classes in the package.
<code><a href="#topic+TDRcalibrate-methods">TDRcalibrate-methods</a></code> for the various methods
available.
</p>

<hr>
<h2 id='timeBudget+2CTDRcalibrate+2Clogical-method'>Describe the Time Budget of Major Activities from &quot;TDRcalibrate&quot;
object.</h2><span id='topic+timeBudget+2CTDRcalibrate+2Clogical-method'></span><span id='topic+timeBudget'></span>

<h3>Description</h3>

<p>Summarize the major activities recognized into a time budget.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TDRcalibrate,logical'
timeBudget(obj, ignoreZ)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timeBudget+2B2CTDRcalibrate+2B2Clogical-method_+3A_obj">obj</code></td>
<td>
<p><code><a href="#topic+TDRcalibrate">TDRcalibrate</a></code> object.</p>
</td></tr>
<tr><td><code id="timeBudget+2B2CTDRcalibrate+2B2Clogical-method_+3A_ignorez">ignoreZ</code></td>
<td>
<p>logical: whether to ignore trivial aquatic periods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ignored trivial aquatic periods are collapsed into the enclosing dry
period.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with components:
</p>
<table role = "presentation">
<tr><td><code>phaseno</code></td>
<td>
<p>A numeric vector numbering each period of activity.</p>
</td></tr>
<tr><td><code>activity</code></td>
<td>
<p>A factor labelling the period with the corresponding
activity.</p>
</td></tr>
<tr><td><code>beg</code>, <code>end</code></td>
<td>
<p><code><a href="base.html#topic+POSIXct">POSIXct</a></code> objects indicating the beginning
and end of each period.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>obj = TDRcalibrate,ignoreZ = logical</code>: Base method for computing time budget from
TDRcalibrate object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibrateDepth">calibrateDepth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Too long for checks
## Continuing the Example from '?calibrateDepth':
utils::example("calibrateDepth", package="diveMove",
               ask=FALSE, echo=FALSE, run.donttest=TRUE)
dcalib		# the 'TDRcalibrate' that was created

timeBudget(dcalib, TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
