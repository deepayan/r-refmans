<!DOCTYPE html><html><head><title>Help for package bayesbr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesbr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIC_bayesbr'><p>Akaike Information Criterion</p></a></li>
<li><a href='#bayesbr'><p>Bayesian Beta Regression with RStan</p></a></li>
<li><a href='#bayesbr_app'><p>The bayesbr Application</p></a></li>
<li><a href='#bayesbr-package'><p>bayesbr: A package for Bayesian Beta Regression</p></a></li>
<li><a href='#BIC_bayesbr'><p>Bayesian Information Criterion</p></a></li>
<li><a href='#bodyfat'><p>Percentage of Body Fat</p></a></li>
<li><a href='#CarTask'><p>Probability Judgment for Car Dealership with Partition</p></a></li>
<li><a href='#DIC_bayesbr'><p>Deviance Information Criterion</p></a></li>
<li><a href='#envelope'><p>Envelope Graph: Residuals vs Half-Normal Values</p></a></li>
<li><a href='#fitted.values'><p>Fitted Values for Theta on Beta Regression</p></a></li>
<li><a href='#FoodExpenditure'><p>Spending on Food by Household Income</p></a></li>
<li><a href='#formula'><p>Formula Variables</p></a></li>
<li><a href='#GasolineYield'><p>Estimation of Gasoline Yields from Crude Oil</p></a></li>
<li><a href='#ImpreciseTask'><p>Imprecise Probabilities for Sunday Weather and Boeing Stock Task</p></a></li>
<li><a href='#logLik.bayesbr'><p>Model Log Likelihood for <code>bayesbr</code> Objects</p></a></li>
<li><a href='#loglikPlot'><p>Plot Chain of Loglik Using GGplot</p></a></li>
<li><a href='#MockJurors'><p>Mock Jurors' Confidence in Their Verdicts</p></a></li>
<li><a href='#model_frame'><p>Model Matrix/Frame with All Variables for <code>bayesbr</code> Objects</p></a></li>
<li><a href='#model_matrix'><p>Model Matrix/Frame with All Variables for <code>bayesbr</code> Objects</p></a></li>
<li><a href='#model.bayesbr'><p>Matrix with All Variables for <code>bayesbr</code> Objects</p></a></li>
<li><a href='#pmse'><p>Prediction Mean Squared Error in a Beta Regression on a Bayesian Model</p></a></li>
<li><a href='#predict.bayesbr'><p>Prediction Method for <code>bayesbr</code> Objects</p></a></li>
<li><a href='#print.bayesbr'><p>Print for <code>bayesbr</code> Objects</p></a></li>
<li><a href='#pseudo.r.squared'><p>Pseudo R Squared Calculate</p></a></li>
<li><a href='#ReadingSkills'><p>Dyslexia and IQ Predicting Reading Accuracy</p></a></li>
<li><a href='#residuals.bayesbr'><p>Residuals for <code>bayesbr</code> Objects</p></a></li>
<li><a href='#StressAnxiety'><p>Dependency of Anxiety on Stress</p></a></li>
<li><a href='#summary_delta'><p>Coefficients for deltas</p></a></li>
<li><a href='#summary_mean'><p>Variable Coefficients for Theta</p></a></li>
<li><a href='#summary_precision'><p>Variable Coefficients for Zeta</p></a></li>
<li><a href='#summary_tau_delta'><p>Coefficients for tau_delta</p></a></li>
<li><a href='#summary_tau_xi'><p>Coefficients for tau_xi</p></a></li>
<li><a href='#summary_xi'><p>Coefficients for xis</p></a></li>
<li><a href='#summary.bayesbr'><p>Summary for <code>bayesbr</code> Objects</p></a></li>
<li><a href='#values'><p>Values of a Posteriori Distribution</p></a></li>
<li><a href='#WeatherTask'><p>Precise and Imprecise Probabilities and Priming for Weather Task</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Beta Regression on a Bayesian Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Applies the Beta regression model in the Bayesian statistical view with the possibility of adding a spatial effect in the parameters, the Beta regression is used when the response variable is a proportion variable, that is, it only accepts values between 0 and 1.
    The package 'bayesbr' uses 'rstan' package to build the Bayesian statistical models. The main function of the package receives as a parameter a form informing the independent variable and the co-variables of the model to be made, as output it returns a list with the results of the model. For more details see Ferrari and Cribari-Neto (2004) &lt;<a href="https://doi.org/10.1080%2F0266476042000214501">doi:10.1080/0266476042000214501</a>&gt; and Hoffman and Gelman (2014) &lt;<a href="https://arxiv.org/abs/1111.4246">arXiv:1111.4246</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.12.0), rstan (&ge; 2.18.1), rstantools (&ge;
2.0.0), coda, tidyr, dplyr, stringr, ggplot2, magrittr, fdrtool
(&ge; 1.2.15), Formula(&ge; 1.2-3), loo(&ge; 2.2.0), RcppParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
rstan (&ge; 2.18.1), StanHeaders (&ge; 2.18.0), RcppParallel</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pjoao266/bayesbr">https://github.com/pjoao266/bayesbr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pjoao266/bayesbr/issues">https://github.com/pjoao266/bayesbr/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, shiny, highcharter, DT, shinydashboard,
dashboardthemes, shinyalert, shinyjs, openxlsx, tidyverse</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-16 18:39:04 UTC; JoaoPedro</td>
</tr>
<tr>
<td>Author:</td>
<td>Joao Melo [aut, cre],
  Vinicius Mayrink [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joao Melo &lt;pjoao266@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-16 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIC_bayesbr'>Akaike Information Criterion</h2><span id='topic+AIC_bayesbr'></span>

<h3>Description</h3>

<p>A function that receives the estimated model data, uses the information from the loglik and the number of estimated parameters and returns the AIC, an estimator for the quality of the estimation of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AIC_bayesbr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC_bayesbr_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Proposed by Akaike (1974) the AIC (Akaike Information Criterion) measures the quality of the adjustment made by the model, when comparing adjusted models with the same data, the smaller the AIC the better the adjustment.
</p>
<p>The AIC theory requires that the log-likelihood has been maximized, but as we are in the context of Bayesian statistics, the log-likelihood as explained in the <code><a href="#topic+logLik.bayesbr">logLik.bayesbr</a></code> is made with the average of the a priori distribution for each theta and applying this value in the formula to calculate the loglik.
The AIC is calculated by
</p>
<p style="text-align: center;"><code class="reqn">AIC = 2 * k - 2 * L ,</code>
</p>

<p>where <code>k</code> is the number of covariates used in the model, and <code>L</code> is the average of the loglik chain returned by the function <code><a href="#topic+logLik.bayesbr">logLik.bayesbr</a></code>.
</p>


<h3>Value</h3>

<p>A number corresponding to the AIC (Akaike Information Criterion) of the estimated model.
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.1109/TAC.1974.1100705">10.1109/TAC.1974.1100705</a> Akaike, H. (1974). A new look at the statistical model identification. <em>IEEE transactions on automatic control</em>, <b>19</b>(6), 716-723.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logLik.bayesbr">logLik.bayesbr</a></code>,<code><a href="#topic+BIC_bayesbr">BIC_bayesbr</a></code>,<code><a href="#topic+DIC_bayesbr">DIC_bayesbr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CarTask",package = "bayesbr")

car_bayesbr &lt;- bayesbr(probability ~ NFCCscale + task,
                      data = CarTask,iter =100)
aic = AIC_bayesbr(car_bayesbr)
</code></pre>

<hr>
<h2 id='bayesbr'>Bayesian Beta Regression with RStan</h2><span id='topic+bayesbr'></span>

<h3>Description</h3>

<p>Fit of beta regression model under the view of Bayesian statistics,
using the mean of the posterior distribution as estimates for the mean (theta) and the precision parameter (zeta).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesbr(formula=NULL,data=NULL,m_neighborhood = NULL,
na.action=c("exclude","replace"),mean_betas = NULL,
variance_betas = NULL,mean_gammas = NULL,
variance_gammas = NULL ,iter = 10000,warmup = iter/2,
chains = 1,pars=NULL,a = NULL,b = NULL,
atau_delta = NULL, btau_delta = NULL,atau_xi = NULL,
btau_xi = NULL,rho = NULL,spatial_theta = NULL,spatial_zeta=NULL,
resid.type = c("quantile","sweighted",
            "pearson","ordinary"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesbr_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model (of type <code>y ~ x</code> or <code>y ~ x | z</code>;). See more at <code><a href="#topic+formula">formula</a></code></p>
</td></tr>
<tr><td><code id="bayesbr_+3A_data">data</code></td>
<td>
<p>data frame or list with the variables passed in the formula parameter, if <code>data = NULL</code> the function will use the existing variables in the global environment.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_m_neighborhood">m_neighborhood</code></td>
<td>
<p>A neighborhood matrix with n rows and n columns, with n the number of observations of the model to be adjusted. This matrix should only contain a value of 0 on the main diagonal, and a value of 0 or 1 at position i j, to inform whether observation i is next to observation j. It must be symmetric, because if i is a neighbor of j, j is also a neighbor of i. This matrix will be used to calculate the model's covariance matrix, if one of the conditions is not accepted or the neighborhood matrix is not informed, the model will be adjusted without the spatial effect.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_na.action">na.action</code></td>
<td>
<p>Characters provided or treatment used in NA values. If <code>na.action</code> is equal to exclude (default value), the row containing the NA will be excluded in all variables of the model. If <code>na.action</code> is equal to replace, the row containing the NA will be replaced by the average of the variable in all variables of the model.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_mean_betas">mean_betas</code>, <code id="bayesbr_+3A_variance_betas">variance_betas</code></td>
<td>
<p>vectors including a priori information of mean and variance for the estimated beta respectively, beta is the name given to the coefficient of each covariate that influences theta. PS: the size of the vectors must equal p + 1, p being the number of covariates for theta.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_mean_gammas">mean_gammas</code>, <code id="bayesbr_+3A_variance_gammas">variance_gammas</code></td>
<td>
<p>vectors including a priori information of mean and variance for the estimated ranges respectively, gamma is the name given to the coefficient of each covariate that influences zeta. PS: the size of the vectors must be equal to q + 1, q being the number of covariates for zeta.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_iter">iter</code></td>
<td>
<p>A positive integer specifying the number of iterations for each chain (including warmup). The default is 10000.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying the number of iterations that will be in the warm-up period,
will soon be discarded when making the estimates and inferences. Warmup must be less than <code>iter</code> and its default value is <code>iter/2</code>.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_chains">chains</code></td>
<td>
<p>A positive integer specifying the number of Markov chains. The default is 1.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_pars">pars</code></td>
<td>
<p>A vector of character strings specifying parameters of interest. The default is NULL indicating all parameters in the model.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_a">a</code>, <code id="bayesbr_+3A_b">b</code></td>
<td>
<p>Positive integer specifying the a priori information of the parameters of the gamma distribution for the zeta, if there are covariables explaining zeta <code>a</code> and <code>b</code> they will not be used. The default value for <code>a</code> is 1 and default value for <code>b</code> is 0.01 .</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_atau_delta">atau_delta</code>, <code id="bayesbr_+3A_btau_delta">btau_delta</code>, <code id="bayesbr_+3A_atau_xi">atau_xi</code>, <code id="bayesbr_+3A_btau_xi">btau_xi</code></td>
<td>
<p>Positive integer specifying the a priori information of tau parameter of the gamma distribution. The default value for <code>atau_delta</code> and <code>atau_xi</code> is 0.1 and default value for <code>btau_delta</code> and <code>btau_xi</code> is 0.1.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_rho">rho</code></td>
<td>
<p>value of the time scaling parameter for calculate the covariance matrix.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_spatial_theta">spatial_theta</code>, <code id="bayesbr_+3A_spatial_zeta">spatial_zeta</code></td>
<td>
<p>A Boolean variable to inform whether the adjusted model will have an effect on the theta parameter, or on the zeta parameter or both parameters.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_resid.type">resid.type</code></td>
<td>
<p>A character containing the residual type returned by the model among the possibilities. The type of residue can be <em>quantile</em>, <em>sweighted</em>, <em>pearson</em> or <em>ordinary</em>. The default is <em>quantile</em>.</p>
</td></tr>
<tr><td><code id="bayesbr_+3A_...">...</code></td>
<td>
<p>Other optional parameters from RStan</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beta Regression was suggested by Ferrari and Cribari-Neto (2004), but with the look of classical statistics, this package makes use of the <code>Rstan</code> to, from the prior distribution of the data, obtain the posterior distribution and the estimates from a Bayesian perspective. Beta regression is useful when the response variable is in the range between 0 and 1, being used for adjusting probabilities and proportions.
</p>
<p>It is possible to estimate coefficients for the explanatory covariates for the theta and zeta parameters of the Beta distribution. Linear predictors are passed as parameters for both zeta and zeta, from these linear predictors a transformation of scales is made.
</p>
<p>Hamiltonian Monte Carlo (HMC) is a Markov chain Monte Carlo (MCMC) algorithm, from the HMC there is an extension known as the No-U-Turn Sampler (NUTS) that makes use of recursion to obtain its calculations and is used by <code>RStan</code>. In the context of the <code>bayesbr</code> package, NUTS was used to obtain a posteriori distribution from model data and a priori distribution.
</p>
<p>See <code><a href="#topic+predict.bayesbr">predict.bayesbr</a></code>, <code><a href="#topic+residuals.bayesbr">residuals.bayesbr</a></code>,<code><a href="#topic+summary.bayesbr">summary.bayesbr</a></code>,<code><a href="#topic+logLik.bayesbr">logLik.bayesbr</a></code> and <code><a href="#topic+pseudo.r.squared">pseudo.r.squared</a></code> for more details on all methods. Because it is in the context of Bayesian statistics, in all calculations that were defined using maximum verisimilitude, this was sub-replaced by the mean of the posterior distribution of the parameters of interest of the formula.
</p>


<h3>Value</h3>

<p><code>bayesbr</code> return an object of class <em>bayesbr</em>, a list of the following items.
</p>
<dl>
<dt>coefficients</dt><dd><p>a list with the mean and precision elements containing the estimated coefficients of model and table with the means, medians, standard deviations and the Highest Posterior Density (HPD) Interval,</p>
</dd>
<dt>call</dt><dd><p>the original function call,</p>
</dd>
<dt>formula</dt><dd><p>the original formula,</p>
</dd>
<dt>y</dt><dd><p>the response proportion vector,</p>
</dd>
<dt>stancode</dt><dd><p>lines of code containing the .STAN file used to estimate the model,</p>
</dd>
<dt>info</dt><dd><p>a list containing model information such as the argument pars passed as argument, name of variables, indicator for effect spatial in model, number of: iterations, warmups, chains, covariables for theta, covariables for zeta and observations of the sample. In addition there is an element called samples, with the posterior distribution of the parameters of interest,</p>
</dd>
<dt>fitted.values</dt><dd><p>a vector containing the estimates for the values corresponding to the theta of each observation of the variable response, the estimate is made using the mean of the a prior theta distribution,</p>
</dd>
<dt>model</dt><dd><p>the full model frame,</p>
</dd>
<dt>residuals</dt><dd><p>a vector of residuals,</p>
</dd>
<dt>residuals.type</dt><dd><p>the type of returned residual,</p>
</dd>
<dt>delta</dt><dd><p>a matrix with the means, medians, standard deviations and the Highest Posterior Density (HPD) Interval of the delta parameter (spatial effect in theta parameter). The estimation for the delta parameter, informs the influence that a given region has on the response variable, neighboring observations are expected to have close estimates for delta.</p>
</dd>
<dt>xi</dt><dd><p>a matrix with the means, medians, standard deviations and the Highest Posterior Density (HPD) Interval of the xi parameter (spatial effect in zeta parameter). The estimation for the xi parameter, informs the influence that a given region has on the response variable, neighboring observations are expected to have close estimates for xi.</p>
</dd>
<dt>loglik</dt><dd><p>log-likelihood of the fitted model(using the mean of the parameters in the posterior distribution),</p>
</dd>
<dt>AIC</dt><dd><p>a value containing the Akaike's Information Criterion (AIC) of the fitted model,</p>
</dd>
<dt>BIC</dt><dd><p>a value containing the Bayesian Information Criterion (BIC) of the fitted model,</p>
</dd>
<dt>DIC</dt><dd><p>a value containing the Deviance Information Criterion (DIC) of the fitted model,</p>
</dd>
<dt>WAIC</dt><dd><p>a vector containing the Widely Applicable Information Criterion (WAIC) of the fitted model and their standard error, see more in <code><a href="loo.html#topic+waic">waic</a></code></p>
</dd>
<dt>LOOIC</dt><dd><p>a vector containing the LOO (Efficient approximate leave-one-out cross-validation) Information Criterion of the fitted model and their standard error, see more in <code><a href="rstan.html#topic+loo">loo</a></code></p>
</dd>
<dt>pseudo.r.squared</dt><dd><p>pseudo-value of the square R (correlation to the square of the linear predictor and the a posteriori means of theta).</p>
</dd></dl>



<h3>References</h3>

<p>doi: <a href="https://doi.org/10.1080/0266476042000214501">10.1080/0266476042000214501</a> Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions. <em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>
<p><a href="https://arxiv.org/abs/1111.4246">arXiv:1111.4246</a> Hoffman, M. D., and Gelman, A. (2014). The No-U-Turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo. <em>Journal of Machine Learning Research</em>, <b>15</b>(1), 1593-1623.
</p>
<p>doi: <a href="https://doi.org/10.18637/jss.v076.i01">10.18637/jss.v076.i01</a> Carpenter, B., Gelman, A., Hoffman, M. D., Lee, D., Goodrich, B., Betancourt, M., ... &amp; Riddell, A. (2017). Stan: A probabilistic programming language. <em>Journal of statistical software</em>, <b>76</b>(1).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.bayesbr">summary.bayesbr</a></code>, <code><a href="#topic+residuals.bayesbr">residuals.bayesbr</a></code>, <code><a href="#topic+formula">formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("StressAnxiety",package="bayesbr")

bbr = bayesbr(anxiety ~ stress | stress, data = StressAnxiety,
             iter = 100)
summary(bbr)
residuals(bbr, type="ordinary")
print(bbr)



data("StressAnxiety", package = "bayesbr")
bbr2 &lt;- bayesbr(anxiety ~ stress | stress,
               data = StressAnxiety, iter = 1000,
               warmup= 450, mean_betas = c(0,1),
               variance_betas = 15)

envelope(bbr2,sim=100,conf=0.95)
loglikPlot(bbr2$loglik)

</code></pre>

<hr>
<h2 id='bayesbr_app'>The bayesbr Application</h2><span id='topic+bayesbr_app'></span><span id='topic+bayesbr_app+2C'></span><span id='topic+bayesbr_shiny'></span>

<h3>Description</h3>

<p>A function that runs the shiny application designed for using bayesbr package functions through a visual interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesbr_app()
</code></pre>


<h3>Details</h3>

<p>See the application manual: How to use bayesbr shiny app in vignnetes of bayesbr package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>
</p>

<hr>
<h2 id='bayesbr-package'>bayesbr: A package for Bayesian Beta Regression</h2><span id='topic+bayesbr-package'></span>

<h3>Description</h3>

<p>The package fits or the beta regression model under the view of Bayesian statistics using the No-U-Turn-Sampler (NUTS) method for computational calculations.The model can be adjusted considering or not the spatial effect on the parameters. In addition to showing the coefficients, the package also has functions for displaying residuals, checking the model's convergence, checking the quality of the model and other utilities that may be useful.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1111.4246">arXiv:1111.4246</a> Hoffman, M. D., and Gelman, A. (2014). The No-U-Turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo. <em>Journal of Machine Learning Research</em>, <b>15</b>(1), 1593-1623.
</p>
<p>doi: <a href="https://doi.org/10.1080/0266476042000214501">10.1080/0266476042000214501</a> Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions. <em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>

<hr>
<h2 id='BIC_bayesbr'>Bayesian Information Criterion</h2><span id='topic+BIC_bayesbr'></span>

<h3>Description</h3>

<p>A function that receives data from the estimated model, uses the information from the loglik, the number of observations of the model and the number of estimated parameters and returns the BIC, an estimator for the quality of the estimation of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BIC_bayesbr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC_bayesbr_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Proposed by Stone (1979) the BIC (Bayesian Information Criterion) measures the quality of the adjustment made by the model, when comparing adjusted models with the same data, the smaller the BIC the better the adjustment.
</p>
<p>The BIC theory requires that the log-likelihood has been maximized, but as we are in the context of Bayesian statistics, the log-likelihood as explained in the <code><a href="#topic+logLik.bayesbr">logLik.bayesbr</a></code> is made with the average of the a priori distribution for each theta and applying this value in the formula to calculate the loglik.
</p>
<p>The BIC is calculated by
</p>
<p style="text-align: center;"><code class="reqn"> BIC = log(n)*k - 2 * L ,</code>
</p>

<p>where <code>n</code> is the number of observations of the model variables, <code>k</code> is the number of covariates used in the model, and L is the average of the loglik chain returned by the function <code><a href="#topic+logLik.bayesbr">logLik.bayesbr</a></code>.
</p>


<h3>Value</h3>

<p>A number corresponding to the BIC (Bayesian Information Criterion) of the estimated model.
</p>


<h3>References</h3>

<p>Schwarz, G. (1978). Estimating the dimension of a model. <em>The annals of statistics</em>, <b>6</b>(2), 461-464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>, <code><a href="#topic+AIC_bayesbr">AIC_bayesbr</a></code>, <code><a href="#topic+DIC_bayesbr">DIC_bayesbr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CarTask",package = "bayesbr")

car_bayesbr &lt;- bayesbr(probability ~ NFCCscale + task, data = CarTask,
                      iter =100)
bic = BIC_bayesbr(car_bayesbr)
</code></pre>

<hr>
<h2 id='bodyfat'>Percentage of Body Fat</h2><span id='topic+bodyfat'></span>

<h3>Description</h3>

<p>A data frame that contains the proportion of cord fat for individuals calculated through various body measurements of weight, height and circumferences of 252 men who participated in the study by Dr. A. Garth Fisher, Human Performance Research Center, Brigham Young University.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bodyfat)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the observations of 252 men:
</p>

<dl>
<dt>case</dt><dd><p>Case number.</p>
</dd>
<dt>brozek</dt><dd><p>Percent body fat using Brozek's equation: 457/Density - 414.2</p>
</dd>
<dt>siri</dt><dd><p>Percent body fat using Siri's equation: 495/Density - 450</p>
</dd>
<dt>density</dt><dd><p>Density determined from underwater weighing (gm/cm**3).</p>
</dd>
<dt>age</dt><dd><p>Age (years).</p>
</dd>
<dt>weight</dt><dd><p>Weight (kg/100).</p>
</dd>
<dt>height</dt><dd><p>Height (m).</p>
</dd>
<dt>neck</dt><dd><p>Neck circumference (m).</p>
</dd>
<dt>chest</dt><dd><p>Chest circumference (m).</p>
</dd>
<dt>abdomen</dt><dd><p>Abdomen circumference (m) &rdquo;at the umbilicus and level
with the iliac crest&rdquo;.</p>
</dd>
<dt>forearm</dt><dd><p>Forearm circumference (m).</p>
</dd>
<dt>hip</dt><dd><p>Hip circumference (m).</p>
</dd>
<dt>thigh</dt><dd><p>Thigh circumference (m).</p>
</dd>
<dt>knee</dt><dd><p>Knee circumference (m).</p>
</dd>
<dt>ankle</dt><dd><p>Ankle circumference (m).</p>
</dd>
<dt>biceps</dt><dd><p>Biceps (extended) circumference (m).</p>
</dd>
<dt>wrist</dt><dd><p>Wrist circumference (m) &rdquo;distal to the styloid processes&rdquo;.</p>
</dd>
</dl>



<h3>Details</h3>

<p>It is possible to find some errors in the table or strange data:
</p>
<p>One man (case 42) was measured with over 200 pounds in weight who is less than 3 feet tall, considered that he had a typo when typing 29.5 inches and transformed the data into 69.5 inches;
</p>
<p>There was a man with a negative percentage of body fat, it was decided to exclude this data from the table.
</p>
<p>Changes to units of measure:
</p>
<p>Weight was transformed from lbs to kg / 100 (value 1 corresponds to 100kg);
</p>
<p>Height has been transformed from inches to meters;
</p>
<p>All columns that were represented in centimeters were transformed into meters.
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.1080/10691898.1996.11910505">10.1080/10691898.1996.11910505</a> Johnson, R. W. (1996). Fitting percentage of body fat to simple body measurements. <em>Journal of Statistics Education</em>, <b>4</b>(1).
</p>
<p>doi: <a href="https://doi.org/10.1249/00005768-198504000-00037">10.1249/00005768-198504000-00037</a> Penrose, K. W., Nelson, A. G., &amp; Fisher, A. G. (1985). Generalized body composition prediction equation for men using simple measurement techniques. <em>Medicine &amp; Science in Sports &amp; Exercise</em>, <b>17</b>(2), 189.
</p>
<p>doi: <a href="https://doi.org/10.1016/j.csda.2006.05.006">10.1016/j.csda.2006.05.006</a> Royston, P., &amp; Sauerbrei, W. (2007). Improving the robustness of fractional polynomial models by preliminary covariate transformation: A pragmatic approach. <em>Computational statistics &amp; data analysis</em>, <b>51</b>(9), 4240-4253.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bodyfat,package="bayesbr")

bbr = bayesbr(siri ~ age+wrist*neck+chest+
             thigh+wrist| wrist, data = bodyfat,
             iter = 100)

summary(bbr)


bbr = bayesbr(siri ~ I(age/100)+height+chest+
             thigh+wrist| wrist,
             data = bodyfat,iter = 1000)


</code></pre>

<hr>
<h2 id='CarTask'>Probability Judgment for Car Dealership with Partition</h2><span id='topic+CarTask'></span>

<h3>Description</h3>

<p>Participants who responded to the study were expected to judge the likelihood of a customer trades in a coupe or that a customer buys a car from a specific seller among four possible sellers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CarTask)
</code></pre>


<h3>Format</h3>

<p>A data frame with 155 observations on the following 3 variables.
</p>

<dl>
<dt><code>task</code></dt><dd><p>A variable specified as conditions. When 0 the set value is <code>Car</code>, when 1 the set value is <code>Salesperson</code>.</p>
</dd>
<dt><code>probability</code></dt><dd><p>a numeric vector of the estimated probability.</p>
</dd>
<dt><code>NFCCscale</code></dt><dd><p>a numeric vector of the NFCC scale.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Study participants were graduate students from The Australian National University, some students received credits in Psychology for participating in the study.
</p>
<p>With the Needs for Closing and Needs for Certainty scales strongly correlated, the NFCCscale is a combined scale between the previous two.
</p>
<p>For <code>task</code> the questions were:
</p>

<dl>
<dt>Car</dt><dd><p>What is the probability that a customer trades in a coupe?</p>
</dd>
<dt>Salesperson</dt><dd><p>What is the probability that a customer buys a
car from Carlos?</p>
</dd>
</dl>

<p>The <code>task</code> variable that was a qualitative variable was transformed into a quantitative variable to be used by the package functions.
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.3102/1076998610396893">10.3102/1076998610396893</a> Smithson, M., Merkle, E.C., and Verkuilen, J. (2011). Beta
Regression Finite Mixture Models of Polarization and Priming.
<em>Journal of Educational and Behavioral Statistics</em>, <b>36</b>(6), 804&ndash;831.
</p>
<p>doi: <a href="https://doi.org/10.1080/15598608.2009.10411918">10.1080/15598608.2009.10411918</a> Smithson, M., and Segale, C. (2009). Partition Priming in Judgments of
Imprecise Probabilities. <em>Journal of Statistical Theory and
Practice</em>, <b>3</b>(1), 169&ndash;181.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CarTask", package = "bayesbr")

car_bayesbr &lt;- bayesbr(probability ~ NFCCscale + task, data = CarTask,
                      iter =100)
</code></pre>

<hr>
<h2 id='DIC_bayesbr'>Deviance Information Criterion</h2><span id='topic+DIC_bayesbr'></span>

<h3>Description</h3>

<p>A function that receives data from the estimated model, uses the information from the loglik and returns the DIC, an estimator for the quality of the estimation of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIC_bayesbr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIC_bayesbr_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Proposed by Spiegelhalter (2002) the DIC (Deviance Information Criterion) measures the quality of the adjustment made by the model, when comparing adjusted models with the same data, the smaller the BIC the better the adjustment.
</p>
<p>It is particularly useful in Bayesian model selection problems where the posterior distributions of the models have been obtained by Markov chain Monte Carlo (MCMC) simulation. DIC is an asymptotic approximation as the sample size becomes large, like AIC. It is only valid when the posterior distribution is approximately multivariate normal.
</p>
<p>DIC is calculate using the loglik calculated from the posterior distribution of the parameters and a calculation from the average of the posterior distribution of the parameters. To see the formula visit <a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/1467-9868.00353">Spiegelhalter (2002)</a>.
</p>


<h3>Value</h3>

<p>A number corresponding to the DIC (Deviance Information Criterion) of the estimated model.
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.1111/1467-9868.00353">10.1111/1467-9868.00353</a> Spiegelhalter, D. J., Best, N. G., Carlin, B. P., &amp; Van Der Linde, A. (2002). Bayesian measures of model complexity and fit. <em>Journal of the royal statistical society: Series b (statistical methodology)</em>, <b>64</b>(4), 583-639.
</p>
<p>doi: <a href="https://doi.org/10.1111/j.1467-9574.2005.00278.x">10.1111/j.1467-9574.2005.00278.x</a> Van Der Linde, A. (2005). DIC in variable selection. <em>Statistica Neerlandica</em>, <b>59</b>(1), 45-56.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>, <code><a href="#topic+AIC_bayesbr">AIC_bayesbr</a></code>, <code><a href="#topic+BIC_bayesbr">BIC_bayesbr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CarTask",package="bayesbr")

car_bayesbr &lt;- bayesbr(probability ~ NFCCscale + task, data = CarTask,
                      iter =100)
dic = DIC_bayesbr(car_bayesbr)
</code></pre>

<hr>
<h2 id='envelope'>Envelope Graph: Residuals vs Half-Normal Values</h2><span id='topic+envelope'></span>

<h3>Description</h3>

<p>A graph showing the absolute values of the residuals ordered against the quantiles of simulations of the half-normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envelope(x, sim = 1000, conf = 0.95, resid.type = c("",
"quantile", "sweighted","pearson","ordinary"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="envelope_+3A_sim">sim</code></td>
<td>
<p>a positive integer containing the number of simulations of the half-normal distribution.</p>
</td></tr>
<tr><td><code id="envelope_+3A_conf">conf</code></td>
<td>
<p>a probability containing the confidence level for the quantiles made under the half-normal samples.</p>
</td></tr>
<tr><td><code id="envelope_+3A_resid.type">resid.type</code></td>
<td>
<p>the residual type that will be used in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Atkinson (1985) proposed to use quantiles from a simulated population of the halfnormal distribution, this is used because (blablabla read the book, right). From the distribution of the absolute values of the residual in the graph, it is possible to measure the quality of the model estimation.
</p>


<h3>Value</h3>

<p>A graph showing the absolute values of the residuals ordered against the quantiles of simulations of the half-normal distribution.
</p>


<h3>References</h3>

<p>Atkinson, A. C. (1985). Plots, transformations, and regression: An introduction to graphical methods of diagnostic regression analysis. <em>Oxford: Clarendon Press</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.bayesbr">residuals.bayesbr</a></code>, <code><a href="#topic+loglikPlot">loglikPlot</a></code>, <code><a href="#topic+bayesbr">bayesbr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CarTask", package = "bayesbr")

bbr = bayesbr(probability~task + NFCCscale, iter = 100,
            data=CarTask, mean_betas = c(1, 0.5,1.2),variance_betas=10)

envelope(bbr,sim = 100, conf=0.9, resid.type="quantile")

envelope(bbr,sim = 1000, conf=0.99, resid.type="ordinary")
</code></pre>

<hr>
<h2 id='fitted.values'>Fitted Values for Theta on Beta Regression</h2><span id='topic+fitted.values'></span>

<h3>Description</h3>

<p>A function that receives information from an estimated model uses data from the estimated theta for each iteration and returns the average of each theta in the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitted.values(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.values_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the average of theta estimates in the iterations (excluding warmup). The vector size is equal to the number of model observations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>,<code><a href="#topic+predict.bayesbr">predict.bayesbr</a></code>
</p>

<hr>
<h2 id='FoodExpenditure'>Spending on Food by Household Income</h2><span id='topic+FoodExpenditure'></span>

<h3>Description</h3>

<p>Data frame on the proportion of food expenses per household income. 38 house rents were evaluated in a random sample from a large city in the United States.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("FoodExpenditure")
</code></pre>


<h3>Format</h3>

<p>A data frame containing 38 observations on 3 variables.
</p>

<dl>
<dt>food</dt><dd><p>household expenditures for food.</p>
</dd>
<dt>income</dt><dd><p>household income.</p>
</dd>
<dt>proportion</dt><dd><p>proportion of household income spent on food.</p>
</dd>
<dt>persons</dt><dd><p>number of persons living in household.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Originally, the <code>proportion</code> column did not exist, it was created by the bayesbr package.
</p>


<h3>Source</h3>

<p>Taken from Griffiths et al. (1993, Table 15.4).
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a> Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
</p>
<p>doi: <a href="https://doi.org/10.1080/0266476042000214501">10.1080/0266476042000214501</a> Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions.
<em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>
<p>doi10.1002/jae.3950090208 Griffiths, W.E., Hill, R.C., and Judge, G.G. (1993).
<em>Learning and Practicing Econometrics</em>
New York: John Wiley and Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("FoodExpenditure", package = "bayesbr")

bbr &lt;- bayesbr(proportion ~ income + persons, data = FoodExpenditure,
             iter=100)
residuals(bbr, type="quantile")


pmse &lt;-pmse(proportion ~ income + persons, test.set=0.4,
          data = FoodExpenditure, iter=100)$PMSE

</code></pre>

<hr>
<h2 id='formula'>Formula Variables</h2><span id='topic+formula'></span>

<h3>Description</h3>

<p>Transforming a formula object into a list with the variables and their names for the beta regression model of the bayesbr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula(formula, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model (of type <code>y ~ x</code> or <code>y ~ x | z</code>;).</p>
</td></tr>
<tr><td><code id="formula_+3A_data">data</code></td>
<td>
<p>Data frame with regression observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The form of the formula used for the <code>Bayesbr</code> package follows the pattern proposed in <code><a href="Formula.html#topic+Formula">Formula</a></code>. The expression y ~ represents that y is the response variable of the beta regression, everything to the right of the ~ operator represents covariates or intercepts for the parameter <code class="reqn">\theta</code> or <code class="reqn">\zeta</code> of the variable response .
</p>
<p>The + operator adds one more explanatory covariate for the parameter,the operator : indicates interaction between variables adjacent to the operator,
operator * adds the variables adjacent to the operator as covariable and the interaction between them
the operator | represents that the next covariates are explanatory
for <code class="reqn">\zeta</code> and those that were before the operator are explanatory
for <code class="reqn">\theta</code>. So, in the formula <code>y ~ x1 + x2 | x3 + x4</code> x1 and x2
are the covariates for the parameter <code class="reqn">\theta</code> and x3 and x4 are the
covariates of <code class="reqn">\zeta</code>. <code class="reqn">\theta</code> and <code class="reqn">\zeta</code> are parameters
of the variable y answer. The numbers 1 and 0 represent, respectively,
the presence or not of the intercept in the construction of the model.
By default, the intercept is included, so the number 1 is
necessary only when the user wants to include only the intercept for
the estimation of the parameter in question. Here are some examples:
</p>
<p><code>y ~ 0 | x1</code>: No estimate for <code class="reqn">\theta</code>
</p>
<p><code>y ~ 1 | 0 + x2</code>: The estimation for <code class="reqn">\theta</code> will be made only with the intercept, and the estimation for <code class="reqn">\zeta</code> will not use the intercept only the covariable x2
</p>
<p><code>y~ x3*x4 | x5:x6</code>: The estimation for <code class="reqn">\theta</code> will be with the covariables <code>x3</code> and <code>x4</code> and the interaction between them, and the estimation for <code class="reqn">\zeta</code> will be the interaction between variables <code>x5</code> and <code>x6</code>.
</p>
<p>The variables passed to the formula can be environment variables or columns of a dataframe, in which case the dataframe must be informed.
</p>


<h3>Value</h3>

<p>A list containing the following items:
</p>
<dl>
<dt>Y</dt><dd><p>A vector containing the model response variable,</p>
</dd>
<dt>X</dt><dd><p>A matrix containing the covariates for theta of the model,</p>
</dd>
<dt>W</dt><dd><p>A matrix containing the covariates of the model for zeta</p>
</dd>
<dt>name_y</dt><dd><p>The name passed in the call to the <code><a href="#topic+bayesbr">bayesbr</a></code> function for the variable response,</p>
</dd>
<dt>name_x</dt><dd><p>The name passed in the call to the <code><a href="#topic+bayesbr">bayesbr</a></code> function for the covariates for theta,</p>
</dd>
<dt>name_w</dt><dd><p>The name passed in the call to the <code><a href="#topic+bayesbr">bayesbr</a></code> function for covariates for zeta.</p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>
</p>

<hr>
<h2 id='GasolineYield'>Estimation of Gasoline Yields from Crude Oil</h2><span id='topic+GasolineYield'></span>

<h3>Description</h3>

<p>Proportion of crude oil converted to gasoline after the transformation processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("GasolineYield")
</code></pre>


<h3>Format</h3>

<p>A data frame containing 32 observations on 6 variables.
</p>

<dl>
<dt>yield</dt><dd><p>proportion of crude oil converted to gasoline after distillation and fractionation.</p>
</dd>
<dt>gravity</dt><dd><p>crude oil gravity (degrees API).</p>
</dd>
<dt>pressure</dt><dd><p>vapor pressure of crude oil (lbf/in2).</p>
</dd>
<dt>temp10</dt><dd><p>temperature (degrees F) at which 10 percent of crude oil has vaporized.</p>
</dd>
<dt>temp</dt><dd><p>temperature (degrees F) at which all gasoline has vaporized.</p>
</dd>
<dt>batch</dt><dd><p>factor indicating unique batch of conditions <code>gravity</code>,
<code>pressure</code>, and <code>temp10</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset were analyzed by Atkinson (1985) when he used a linear regression model and observed that the linear regression model failed to describe the data well, generating large residues.
</p>
<p>The dataset contains 32 observations on the response and on the independent
variables. It was observed that there are only ten sets of values for the first three explanatory variables, so these sets served as conditions for controlled distillation. These conditions are listed in the variable \ code batch.
</p>
<p>With the Needs for Closing and Needs for Certainty scales strongly correlated, the NFCCscale is a combined scale between the previous two.
</p>


<h3>References</h3>

<p>Atkinson, A.C. (1985). <em>Plots, Transformations and Regression: An Introduction to Graphical Methods of Diagnostic Regression Analysis</em>. New York: Oxford University Press.
</p>
<p>doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a> Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
</p>
<p>Daniel, C., and Wood, F.S. (1971).
<em>Fitting Equations to Data</em>.
New York: John Wiley and Sons.
</p>
<p>doi: <a href="https://doi.org/10.1080/0266476042000214501">10.1080/0266476042000214501</a> Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions.
<em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GasolineYield", package = "bayesbr")


bbr = bayesbr(yield ~ temp + batch, iter = 100,
             data = GasolineYield)

envelope(bbr, conf=0.95, sim = 100, resid.type="quantile")
</code></pre>

<hr>
<h2 id='ImpreciseTask'>Imprecise Probabilities for Sunday Weather and Boeing Stock Task</h2><span id='topic+ImpreciseTask'></span>

<h3>Description</h3>

<p>In this study, participants had to respond to the greater and lesser probability of the event happening.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ImpreciseTask)
</code></pre>


<h3>Format</h3>

<p>A data frame with 242 observations on the following 3 variables.
</p>

<dl>
<dt><code>task</code></dt><dd><p>a variable with responses 0 and 1. If 0 <code>task</code> is <code>Boeing stock</code>, if 1 <code>task</code> is <code>Sunday weather</code>.</p>
</dd>
<dt><code>location</code></dt><dd><p>a numeric vector of the average of the lower
estimate for the event not to occur and the upper estimate for the
event to occur.</p>
</dd>
<dt><code>difference</code></dt><dd><p>a numeric vector of the differences of the
lower and upper estimate for the event to occur.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All study participants were from the first or second year, none of the participants had an in-depth knowledge of probability.
</p>
<p>For the sunday weather task see <code><a href="#topic+WeatherTask">WeatherTask</a></code>. For the Boeing
stock task participants were asked to estimate the probability that
Boeing's stock would rise more than those in a list of 30 companies.
For each task participants were asked to provide lower and upper
estimates for the event to occur and not to occur.
</p>
<p>The <code>task</code> variable that was a qualitative variable was transformed into a quantitative variable to be used by the package functions.#'
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.3102/1076998610396893">10.3102/1076998610396893</a> Smithson, M., Merkle, E.C., and Verkuilen, J. (2011). Beta
Regression Finite Mixture Models of Polarization and Priming.
<em>Journal of Educational and Behavioral Statistics</em>, <b>36</b>(6), 804&ndash;831.
</p>
<p>doi: <a href="https://doi.org/10.3102/1076998610396893">10.3102/1076998610396893</a> Smithson, M., and Segale, C. (2009). Partition Priming in Judgments of Imprecise Probabilities. <em>Journal of Statistical Theory and Practice</em>, <b>3</b>(1), 169&ndash;181.
<em>Journal of Educational and Behavioral Statistics</em>, <b>36</b>(6), 804&ndash;831.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ImpreciseTask", package = "bayesbr")

bbr = bayesbr(location~difference,iter=100,
             data = ImpreciseTask)
</code></pre>

<hr>
<h2 id='logLik.bayesbr'>Model Log Likelihood for <code>bayesbr</code> Objects</h2><span id='topic+logLik.bayesbr'></span>

<h3>Description</h3>

<p>A function that receives the information from the estimated model, the response variable and the theta and zeta chains and returns a vector containing loglik values for each iteration excluding warmups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesbr'
logLik(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.bayesbr_+3A_object">object</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="logLik.bayesbr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Loglik is commonly used to measure fit quality, or to assess whether an fit has converged. The loglik is calculated using maximum likelihood, but as we are in the Bayesian context we will use the mean of the posterior distribution of the parameters, so the calculation occurs from an adaptation of the original form to the loglik.
</p>


<h3>Value</h3>

<p>The function returns a list with </p>
<dl>
<dt>loglik</dt><dd><p>A vector with the estimated model loglik chain,</p>
</dd><dt>matrix_loglik</dt><dd><p>A matrix with all loglik's chain.</p>
</dd></dl>



<h3>References</h3>

<p>doi: <a href="https://doi.org/10.1080/0266476042000214501">10.1080/0266476042000214501</a> Ferrari, S.L.P., and Cribari-Neto, F. (2004). Beta Regression for Modeling Rates and Proportions. <em>Journal of Applied Statistics</em>, <b>31</b>(7), 799–815.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>,<code><a href="#topic+residuals.bayesbr">residuals.bayesbr</a></code>,<code><a href="#topic+loglikPlot">loglikPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CarTask", package = "bayesbr")
bbr = bayesbr(probability~task + NFCCscale, iter = 100,
             data=CarTask, mean_betas = c(1, 0.5,1.2))
loglik = bbr$loglik

loglikPlot(loglik)
</code></pre>

<hr>
<h2 id='loglikPlot'>Plot Chain of Loglik Using GGplot</h2><span id='topic+loglikPlot'></span>

<h3>Description</h3>

<p>The function receives a vector containing the model's loglik chain and displays it through a graph using the GGplot package, through this graph it is possible to see if the model has converged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikPlot(loglik)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikPlot_+3A_loglik">loglik</code></td>
<td>
<p>A vector with the estimated model loglik chain</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+logLik.bayesbr">logLik.bayesbr</a></code>,<code><a href="#topic+envelope">envelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CarTask", package = "bayesbr")

bbr = bayesbr(probability~task + NFCCscale,data = CarTask,
             iter = 100, mean_betas = c(1, 0.5,1.2))
loglik = bbr$loglik

loglikPlot(loglik)
</code></pre>

<hr>
<h2 id='MockJurors'>Mock Jurors' Confidence in Their Verdicts</h2><span id='topic+MockJurors'></span>

<h3>Description</h3>

<p>Answers from mock jurors. It presents the difference in the juror's confidence in a conventional two-option verdict (guilt x absolution) versus a three-option verdict (the new option is &quot;unproven&quot;), in the presence or absence of conflicting testimonial evidence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("MockJurors")
</code></pre>


<h3>Format</h3>

<p>A data frame containing 104 observations on 3 variables.
</p>

<dl>
<dt>verdict</dt><dd><p>a variable indicating whether a two-option or
three-option verdict is requested. If <code>verdict</code> is 0 is interpreted as two-option, if <code>verdict</code> is 1 is interpreted as three-option.</p>
</dd>
<dt>conflict</dt><dd><p>Is there conflicting testimonial evidence? If 0, yes. If 1, no.</p>
</dd>
<dt>confidence</dt><dd><p>jurors degree of confidence in his/her verdict,
scaled to the open unit interval.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were collected by Professor Daily at the Australian National University among first-year psychology students. Smithson and Verkuilen (2006) used the original confidence data and transformed it to a scale of 0 to 1, using the following calculation: <code>((original_confidence/100) * 103 - 0.5) / 104</code>.
</p>
<p>The <code>verdict</code> and <code>conflict</code> variables that was a qualitative variable was transformed into a quantitative variable to be used by the package functions.
</p>


<h3>Source</h3>

<p>Example 1 from Smithson and Verkuilen (2006) supplements.
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.1037/1082-989X.11.1.54">10.1037/1082-989X.11.1.54</a> Smithson, M., and Verkuilen, J. (2006).
A Better Lemon Squeezer? Maximum-Likelihood Regression with
Beta-Distributed Dependent Variables.
<em>Psychological Methods</em>, <b>11</b>(7), 54&ndash;71.
</p>
<p>doi: <a href="https://doi.org/10.1080/10888430709336633">10.1080/10888430709336633</a> Pammer, K., and Kevan, A. (2004).
The Contribution of Visual Sensitivity, Phonological Processing
and Non-Verbal IQ to Children's Reading.
<em>Unpublished manuscript</em>, The Australian National University, Canberra.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("MockJurors", package = "bayesbr")


bbr = bayesbr(confidence~verdict+conflict, iter=1000,
             data = MockJurors)
</code></pre>

<hr>
<h2 id='model_frame'>Model Matrix/Frame with All Variables for <code>bayesbr</code> Objects</h2><span id='topic+model_frame'></span>

<h3>Description</h3>

<p>The function receives all variables and their respective names, and concatenates them in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_frame(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_frame_+3A_object">object</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="model_frame_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or Frame containing all variables in the model and their names used as column names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+values">values</a></code>,<code><a href="#topic+bayesbr">bayesbr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bodyfat",package="bayesbr")

bbr = bayesbr(siri ~ wrist +I(age/100)|chest, data = bodyfat,
             iter = 100)
model_matrix(bbr)

model_frame(bbr)
</code></pre>

<hr>
<h2 id='model_matrix'>Model Matrix/Frame with All Variables for <code>bayesbr</code> Objects</h2><span id='topic+model_matrix'></span>

<h3>Description</h3>

<p>The function receives all variables and their respective names, and concatenates them in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_matrix(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_matrix_+3A_object">object</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or Frame containing all variables in the model and their names used as column names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+values">values</a></code>,<code><a href="#topic+bayesbr">bayesbr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bodyfat",package="bayesbr")

bbr = bayesbr(siri ~ wrist +I(age/100)|chest, data = bodyfat,
             iter = 100)
model_matrix(bbr)

model_frame(bbr)
</code></pre>

<hr>
<h2 id='model.bayesbr'>Matrix with All Variables for <code>bayesbr</code> Objects</h2><span id='topic+model.bayesbr'></span>

<h3>Description</h3>

<p>The function receives all variables and their respective names, and concatenates them in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesbr'
model(Y,X = NULL,W = NULL,name_y,names_x = NULL,
             names_w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.bayesbr_+3A_y">Y</code></td>
<td>
<p>A vector containing the model response variable,</p>
</td></tr>
<tr><td><code id="model.bayesbr_+3A_x">X</code></td>
<td>
<p>A matrix containing the covariates for theta of the model,</p>
</td></tr>
<tr><td><code id="model.bayesbr_+3A_w">W</code></td>
<td>
<p>A matrix containing the covariates of the model for zeta,</p>
</td></tr>
<tr><td><code id="model.bayesbr_+3A_name_y">name_y</code></td>
<td>
<p>The name passed in the call to the <code><a href="#topic+bayesbr">bayesbr</a></code> function for the variable response,</p>
</td></tr>
<tr><td><code id="model.bayesbr_+3A_names_x">names_x</code></td>
<td>
<p>The name passed in the call to the <code><a href="#topic+bayesbr">bayesbr</a></code> function for the covariates for theta,</p>
</td></tr>
<tr><td><code id="model.bayesbr_+3A_names_w">names_w</code></td>
<td>
<p>The name passed in the call to the <code><a href="#topic+bayesbr">bayesbr</a></code> function for covariates for zeta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing all variables in the model and their names used as column names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+values">values</a></code>,<code><a href="#topic+bayesbr">bayesbr</a></code>
</p>

<hr>
<h2 id='pmse'>Prediction Mean Squared Error in a Beta Regression on a Bayesian Model</h2><span id='topic+pmse'></span>

<h3>Description</h3>

<p>A function that selects a part of the database to fit a beta regression model and another part of this database to test the built model, returning the PMSE (prediction mean squared error) that reports the quality of the estimation for that database. In addition, the function also contains all the information that the bayesbr function returns, making it possible to do all analyzes on the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmse(formula = NULL, data = NULL, test.set = 0.3,
na.action = c("exclude", "replace"),mean_betas = NULL,
   variance_betas = NULL,mean_gammas = NULL, variance_gammas = NULL,
    iter = 10000, warmup = iter/2,chains = 1, pars = NULL,
     a = NULL, b = NULL, resid.type = c("quantile",
     "sweighted", "pearson", "ordinary"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmse_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model (of type <code>y ~ x</code> or <code>y ~ x | z</code>;). See more at <code><a href="#topic+formula">formula</a></code></p>
</td></tr>
<tr><td><code id="pmse_+3A_data">data</code></td>
<td>
<p>data frame or list with the variables passed in the formula parameter, if <code>data = NULL</code> the function will use the existing variables in the global environment.</p>
</td></tr>
<tr><td><code id="pmse_+3A_test.set">test.set</code></td>
<td>
<p>Defines the proportion of the database that will be used for testing the adjusted model and calculating the PMSE. The rest of the database will be used for modeling. Test.set must be less than &quot;0.5&quot;, so that more than 50% of the database is used to adjust the model.</p>
</td></tr>
<tr><td><code id="pmse_+3A_na.action">na.action</code></td>
<td>
<p>Characters provided or treatment used in NA values. If <code>na.action</code> is equal to exclude (default value), the row containing the NA will be excluded in all variables of the model. If <code>na.action</code> is equal to replace, the row containing the NA will be replaced by the average of the variable in all variables of the model.</p>
</td></tr>
<tr><td><code id="pmse_+3A_mean_betas">mean_betas</code>, <code id="pmse_+3A_variance_betas">variance_betas</code></td>
<td>
<p>vectors including a priori information of mean and variance for the estimated beta respectively, beta is the name given to the coefficient of each covariate that influences theta. PS: the size of the vectors must equal p + 1, p being the number of covariates for theta.</p>
</td></tr>
<tr><td><code id="pmse_+3A_mean_gammas">mean_gammas</code>, <code id="pmse_+3A_variance_gammas">variance_gammas</code></td>
<td>
<p>vectors including a priori information of mean and variance for the estimated ranges respectively, gamma is the name given to the coefficient of each covariate that influences zeta. PS: the size of the vectors must be equal to q + 1, q being the number of covariates for zeta.</p>
</td></tr>
<tr><td><code id="pmse_+3A_iter">iter</code></td>
<td>
<p>A positive integer specifying the number of iterations for each chain (including warmup). The default is 10000.</p>
</td></tr>
<tr><td><code id="pmse_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying the number of iterations that will be in the warm-up period,
will soon be discarded when making the estimates and inferences. Warmup must be less than <code>iter</code> and its default value is <code>iter/2</code>.</p>
</td></tr>
<tr><td><code id="pmse_+3A_chains">chains</code></td>
<td>
<p>A positive integer specifying the number of Markov chains. The default is 1.</p>
</td></tr>
<tr><td><code id="pmse_+3A_pars">pars</code></td>
<td>
<p>A vector of character strings specifying parameters of interest. The default is NULL indicating all parameters in the model.</p>
</td></tr>
<tr><td><code id="pmse_+3A_a">a</code>, <code id="pmse_+3A_b">b</code></td>
<td>
<p>Positive integer specifying the a priori information of the parameters of the gamma distribution for the zeta, if there are covariables explaining zeta <code>a</code> and <code>b</code> they will not be used.</p>
</td></tr>
<tr><td><code id="pmse_+3A_resid.type">resid.type</code></td>
<td>
<p>A character containing the residual type returned by the model among the possibilities. The type of residue can be <em>quantile</em>, <em>sweighted</em>, <em>pearson</em> or <em>ordinary</em>. The default is <em>quantile</em>.</p>
</td></tr>
<tr><td><code id="pmse_+3A_...">...</code></td>
<td>
<p>Other optional parameters from RStan</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pmse</code> return an object of class <em>pmse_bayesbr</em> containing the value of the prediction mean squared error and an object of the class <em>bayesbr</em> with the following items:
</p>
<dl>
<dt>coefficients</dt><dd><p>a list with the mean and precision elements containing the estimated coefficients of model and table with the means, medians, standard deviations and the Highest Posterior Density (HPD) Interval,</p>
</dd>
<dt>call</dt><dd><p>the original function call,</p>
</dd>
<dt>formula</dt><dd><p>the original formula,</p>
</dd>
<dt>y</dt><dd><p>the response proportion vector,</p>
</dd>
<dt>stancode</dt><dd><p>lines of code containing the .STAN file used to estimate the model,</p>
</dd>
<dt>info</dt><dd><p>a list containing model information such as the argument pars passed as argument, name of variables, number of: iterations, warmups, chains, covariables for theta, covariables for zeta and observations of the sample. In addition there is an element called samples, with the posterior distribution of the parameters of interest,</p>
</dd>
<dt>fitted.values</dt><dd><p>a vector containing the estimates for the values corresponding to the theta of each observation of the variable response, the estimate is made using the mean of the a prior theta distribution,</p>
</dd>
<dt>model</dt><dd><p>the full model frame,</p>
</dd>
<dt>residuals</dt><dd><p>a vector of residuals</p>
</dd>
<dt>residuals.type</dt><dd><p>the type of returned residual,</p>
</dd>
<dt>loglik</dt><dd><p>log-likelihood of the fitted model(using the mean of the parameters in the posterior distribution),</p>
</dd>
<dt>BIC</dt><dd><p>a value containing the Bayesian Information Criterion (BIC) of the fitted model,</p>
</dd>
<dt>pseudo.r.squared</dt><dd><p>pseudo-value of the square R (correlation to the square of the linear predictor and the a posteriori means of theta).</p>
</dd></dl>



<h3>References</h3>

<p>doi: <a href="https://doi.org/10.1080/0266476042000214501">10.1080/0266476042000214501</a> Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions. <em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>
<p>doi: <a href="https://doi.org/10.1016/j.jeconom.2005.07.014">10.1016/j.jeconom.2005.07.014</a> Clark, T. E., &amp; West, K. D. (2006). Using out-of-sample mean squared prediction errors to test the martingale difference hypothesis. <em>Journal of econometrics</em>, <b>135</b>(1-2), 155-186.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>,<code><a href="#topic+residuals.bayesbr">residuals.bayesbr</a></code>,<code><a href="#topic+predict.bayesbr">predict.bayesbr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bodyfat",package="bayesbr")

bbr = pmse(siri ~ age + weight| biceps + forearm, data = bodyfat,
             test.set = 0.25, iter = 100)

pmse = bbr$PMSE
model = bbr$model
summary(model)
residuals(model,type="sweighted")

bbr2 = pmse(siri ~ age + weight + height +
              wrist | biceps + forearm, data = bodyfat,
              test.set = 0.4, iter = 1000,
              mean_betas = 3,variance_betas = 10)
pmse2 = bbr2$PMSE
model2 = bbr2$model
residuals(model2,type="sweighted")

</code></pre>

<hr>
<h2 id='predict.bayesbr'>Prediction Method for <code>bayesbr</code> Objects</h2><span id='topic+predict.bayesbr'></span>

<h3>Description</h3>

<p>A function that informs various types of prediction through a beta regression by the Bayesian view.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesbr'
predict(object, newdata = NULL, type = c("response", "link",
"precision", "variance", "quantile"), na.action=c("exclude",
"replace"),at = 0.5,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bayesbr_+3A_object">object</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="predict.bayesbr_+3A_newdata">newdata</code></td>
<td>
<p>A data frame in which to look for variables with which to predict. If omitted, the original observations are used.</p>
</td></tr>
<tr><td><code id="predict.bayesbr_+3A_type">type</code></td>
<td>
<p>A character containing the types of predictions: if type is <em>&quot;response&quot;</em> the function will calculate fitted values for theta; if type is <em>&quot;link&quot;</em> the function will calculate the linear predictor for theta and zeta;if type is <em>&quot;precision&quot;</em> the function will calculate fitted values for zeta parameter;if type is <em>&quot;variance&quot;</em> the function will calculate fitted variances of response; if type is <em>&quot;quantile&quot;</em> the function will calculate fitted quantiles of theta values;</p>
</td></tr>
<tr><td><code id="predict.bayesbr_+3A_na.action">na.action</code></td>
<td>
<p>Characters provided or treatment used in NA values. If <code>na.action</code> is equal to exclude (default value), the row containing the NA will be excluded in all variables of the model. If <code>na.action</code> is equal to replace, the row containing the NA will be replaced by the average of the variable in all variables of the model.</p>
</td></tr>
<tr><td><code id="predict.bayesbr_+3A_at">at</code></td>
<td>
<p>numeric vector indicating the quantiles that will be informed by the function (only if <code>type = "quantile"</code>). Its default is 0.5.</p>
</td></tr>
<tr><td><code id="predict.bayesbr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>,<code><a href="#topic+residuals.bayesbr">residuals.bayesbr</a></code>,<code><a href="#topic+pmse">pmse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CarTask", package = "bayesbr")

bbr = bayesbr(probability~ NFCCscale,data=CarTask,
             iter = 100, mean_betas = c(1,1.2))

predict(bbr, type = "response")
predict(bbr, type = "link")
predict(bbr, type = "precision")
predict(bbr, type = "variance")
predict(bbr, type = "quantile", at = c(0.25, 0.5, 0.75))


df = data.frame(NFCCscale = rnorm(10,4,1.4))

predict(bbr, newdata = df, type = "response")
predict(bbr, newdata = df, type = "link")
predict(bbr, newdata = df, type = "precision")
predict(bbr, newdata = df, type = "variance")
predict(bbr, newdata = df, type = "quantile", at = c(0.25, 0.5, 0.75))
</code></pre>

<hr>
<h2 id='print.bayesbr'>Print for <code>bayesbr</code> Objects</h2><span id='topic+print.bayesbr'></span>

<h3>Description</h3>

<p>A method that receives a list of the bayesbr type and its items and displays the estimated coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesbr'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bayesbr_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="print.bayesbr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>, <code><a href="#topic+summary.bayesbr">summary.bayesbr</a></code>, <code><a href="#topic+residuals.bayesbr">residuals.bayesbr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bodyfat",package="bayesbr")

bbr = bayesbr(brozek ~ wrist + density:thigh |chest, data = bodyfat,
             iter = 100)
print(bbr)
</code></pre>

<hr>
<h2 id='pseudo.r.squared'>Pseudo R Squared Calculate</h2><span id='topic+pseudo.r.squared'></span>

<h3>Description</h3>

<p>The function receives the model information, as well as the variable response and the predicted theta values and calculates the model's pseudo.r.squared, using the formula proposed by Cribarri-Neto and Ferrari.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo.r.squared(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo.r.squared_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ferarri and Cribari-Neto (2004) defined the pseudo.r.squared as the square of the correlation between the theta estimated by the maximum likelihood and the logis of the variable response of the model. But as we are in the context of Bayesian statistics, the estimated theta is given by the mean of the posterior distribution of the parameter. So the informed pseudo.r.squared is a Bayesian adaptation to what was suggested by Ferarri and Cribari-Neto (2004).
</p>


<h3>Value</h3>

<p>A number containing the pseudo r squared of the adjusted model, this value can be used to assess the quality of the model.
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.1080/0266476042000214501">10.1080/0266476042000214501</a> Ferrari, S., &amp; Cribari-Neto, F. (2004). Beta regression for modelling rates and proportions. <em>Journal of applied statistics</em>, <b>31</b>(7), 799-815.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>,<code><a href="#topic+fitted.values">fitted.values</a></code>,<code><a href="#topic+AIC_bayesbr">AIC_bayesbr</a></code>
</p>

<hr>
<h2 id='ReadingSkills'>Dyslexia and IQ Predicting Reading Accuracy</h2><span id='topic+ReadingSkills'></span>

<h3>Description</h3>

<p>Data to verify the importance of non-verbal IQ in children's reading skills in dyslexic and non-dyslexic children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ReadingSkills")
</code></pre>


<h3>Format</h3>

<p>A data frame containing 44 observations on 3 variables.
</p>

<dl>
<dt>accuracy</dt><dd><p>reading score scaled to the open unit interval (see below).</p>
</dd>
<dt>dyslexia</dt><dd><p>Is the child dyslexic? If 0, no; If 1, yes.</p>
</dd>
<dt>iq</dt><dd><p>non-verbal intelligence quotient transformed to z-scores.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were collected by Pammer and Kevan (2004). The original precision score was transformed by Smithson and Verkuilen (2006) so that the values of <code>precision</code> are always between 0 to 1, enabling the use of beta regression.
</p>
<p>First, the original accuracy was scaled using the minimal and maximal score (<code>a</code> and <code>b</code>, respectively) that can be obtained in the test: <code>(original_accuracy - a) / (b - a)</code> (<code>a</code> and <code>b</code> are not provided). Subsequently, the scaled score is transformed to the unit interval using a continuity correction: <code>(scaled_accuracy * (n-1) - 0.5) / n</code>(either with some rounding or using <code>n = 50</code> rather than 44).
</p>
<p>The <code>dyslexia</code> variable that was a qualitative variable was transformed into a quantitative variable to be used by the package functions.
</p>


<h3>Source</h3>

<p>Example 3 from Smithson and Verkuilen (2006) supplements.
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a> Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
<a href="https://www.jstatsoft.org/article/view/v034i02">https://www.jstatsoft.org/article/view/v034i02</a>.
</p>
<p>doi: <a href="https://doi.org/10.18637/jss.v048.i11">10.18637/jss.v048.i11</a> Grün, B., Kosmidis, I., and Zeileis, A. (2012).
Extended Beta Regression in R: Shaken, Stirred, Mixed, and Partitioned.
<em>Journal of Statistical Software</em>, <b>48</b>(11), 1&ndash;25.
<a href="https://www.jstatsoft.org/article/view/v048i11">https://www.jstatsoft.org/article/view/v048i11</a>.
</p>
<p>doi: <a href="https://doi.org/10.1080/10888430709336633">10.1080/10888430709336633</a> Pammer, K., and Kevan, A. (2004).
The Contribution of Visual Sensitivity, Phonological Processing
and Non-Verbal IQ to Children's Reading.
<em>Unpublished manuscript</em>, The Australian National University, Canberra.
</p>
<p>doi: <a href="https://doi.org/10.1037/1082-989X.11.1.54">10.1037/1082-989X.11.1.54</a> Smithson, M., and Verkuilen, J. (2006).
A Better Lemon Squeezer? Maximum-Likelihood Regression with
Beta-Distributed Dependent Variables.
<em>Psychological Methods</em>, <b>11</b>(7), 54&ndash;71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ReadingSkills", package = "bayesbr")

bbr = bayesbr(accuracy~iq+dyslexia, iter=1000,warmup=300,
             data=ReadingSkills)
summary(bbr)
</code></pre>

<hr>
<h2 id='residuals.bayesbr'>Residuals for <code>bayesbr</code> Objects</h2><span id='topic+residuals.bayesbr'></span>

<h3>Description</h3>

<p>A function that receives model information and calculates the residuals according to the required residual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesbr'
residuals(object, type = c("", "quantile", "sweighted", "pearson","ordinary"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.bayesbr_+3A_object">object</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="residuals.bayesbr_+3A_type">type</code></td>
<td>
<p>A character containing the residual type returned by the model among the possibilities. The type of residue can be <em>quantile</em>, <em>sweighted</em>, <em>pearson</em> or <em>ordinary</em>. The default is <em>quantile</em>.</p>
</td></tr>
<tr><td><code id="residuals.bayesbr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definitions of the waste generated by the package are available in Espinheira (2008): &quot;pearson&quot; in Equation 2, &quot;sweighted&quot; in Equation 7; and in Pereira (2019): &quot;quantile&quot; in Equation 5;
</p>
<p>The type of residue &quot;response&quot; is calculated from the difference between the estimated theta and the variable response of the model.
</p>


<h3>Value</h3>

<p>A vector containing the model residual according to the type of residual calculated
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.1080/0266476042000214501">10.1080/0266476042000214501</a> Ferrari, S., &amp; Cribari-Neto, F. (2004). Beta regression for modelling rates and proportions. <em>Journal of applied statistics</em>, <b>31</b>(7), 799-815.
</p>
<p>doi: <a href="https://doi.org/10.1080/00949650701829380">10.1080/00949650701829380</a> Simas, A. B., &amp; Cordeiro, G. M. (2009). Adjusted Pearson residuals in exponential family nonlinear models. <em>Journal of Statistical Computation and Simulation</em>, <b>79</b>(4), 411-425.
</p>
<p>doi: <a href="https://doi.org/10.1080/02664760701834931">10.1080/02664760701834931</a> Espinheira, P. L., Ferrari, S. L., &amp; Cribari-Neto, F. (2008). On beta regression residuals. <em>Journal of Applied Statistics</em>, <b>35</b>(4), 407-419.
</p>
<p>doi: <a href="https://doi.org/10.1080/00949655.2012.736993">10.1080/00949655.2012.736993</a> Anholeto, T., Sandoval, M. C., &amp; Botter, D. A. (2014). Adjusted Pearson residuals in beta regression models. <em>Journal of Statistical Computation and Simulation</em>, <b>84</b>(5), 999-1014.
</p>
<p>doi: <a href="https://doi.org/10.1080/03610918.2017.1381740">10.1080/03610918.2017.1381740</a> Pereira, G. H. (2019). On quantile residuals in beta regression. <em>Communications in Statistics-Simulation and Computation</em>, <b>48</b>(1), 302-316.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>,<code><a href="#topic+summary.bayesbr">summary.bayesbr</a></code>,<code><a href="#topic+predict.bayesbr">predict.bayesbr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CarTask", package = "bayesbr")

bbr = bayesbr(probability~task + NFCCscale,data=CarTask,
             iter = 100, mean_betas = c(1, 0.5,1.2))

residuals(bbr, type = "quantile")
residuals(bbr, type = "ordinary")
residuals(bbr, type = "sweighted")
residuals(bbr, type = "pearson")
</code></pre>

<hr>
<h2 id='StressAnxiety'>Dependency of Anxiety on Stress</h2><span id='topic+StressAnxiety'></span>

<h3>Description</h3>

<p>For this data, stress and anxiety were measured among nonclinical women in Townsville, Queensland, Australia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("StressAnxiety")
</code></pre>


<h3>Format</h3>

<p>A data frame containing 166 observations on 2 variables.
</p>

<dl>
<dt>stress</dt><dd><p>score, linearly transformed to the open unit
interval (see below).</p>
</dd>
<dt>anxiety</dt><dd><p>score, linearly transformed to the open unit
interval (see below).</p>
</dd>
</dl>



<h3>Details</h3>

<p>Both variables were evaluated on the scales from 0 to 42, Smithson and Verkuilen (2006) transformed them in a range from 0 to 1.
</p>


<h3>Source</h3>

<p>Example 2 from Smithson and Verkuilen (2006) supplements.
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.1037/1082-989X.11.1.54">10.1037/1082-989X.11.1.54</a> Smithson, M., and Verkuilen, J. (2006).
A Better Lemon Squeezer? Maximum-Likelihood Regression with
Beta-Distributed Dependent Variables.
<em>Psychological Methods</em>, <b>11</b>(7), 54&ndash;71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("StressAnxiety", package = "bayesbr")
bbr &lt;- bayesbr(anxiety ~ stress | stress,
              data = StressAnxiety, iter = 100)

summary(bbr)
</code></pre>

<hr>
<h2 id='summary_delta'>Coefficients for deltas</h2><span id='topic+summary_delta'></span>

<h3>Description</h3>

<p>A function that uses posterior distribution values of the model and calculates the estimates for delta parametrer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_delta(x,prob=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_delta_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="summary_delta_+3A_prob">prob</code></td>
<td>
<p>a probability containing the credibility index for the HPD interval for the coefficients of the covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimates for delta parametrer, this list contains the following items:
</p>

<dl>
<dt>table</dt><dd><p>a table with the means, medians, standard deviations and the Highest Posterior Density (HPD) Interval,</p>
</dd>
<dt>coeff</dt><dd><p>a vector containing the estimated coefficients.</p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+summary_xi">summary_xi</a></code>,<code><a href="#topic+values">values</a></code>,<code><a href="#topic+summary.bayesbr">summary.bayesbr</a></code>
</p>

<hr>
<h2 id='summary_mean'>Variable Coefficients for Theta</h2><span id='topic+summary_mean'></span>

<h3>Description</h3>

<p>A function that uses the beta values of the posterior distribution of the model and calculates the estimates for each theta covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_mean(x,prob=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_mean_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="summary_mean_+3A_prob">prob</code></td>
<td>
<p>a probability containing the credibility index for the HPD interval for the coefficients of the covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimates for the covariables of theta, this list contains the following items:
</p>

<dl>
<dt>table</dt><dd><p>a table with the means, medians, standard deviations and the Highest Posterior Density (HPD) Interval,</p>
</dd>
<dt>coeff</dt><dd><p>a vector containing the estimated coefficients for the variables.</p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+summary_precision">summary_precision</a></code>,<code><a href="#topic+values">values</a></code>,<code><a href="#topic+summary.bayesbr">summary.bayesbr</a></code>
</p>

<hr>
<h2 id='summary_precision'>Variable Coefficients for Zeta</h2><span id='topic+summary_precision'></span>

<h3>Description</h3>

<p>A function that uses the gamma values of the posterior distribution of the model and calculates the estimates for each zeta covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_precision(x,prob=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_precision_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="summary_precision_+3A_prob">prob</code></td>
<td>
<p>a probability containing the credibility index for the HPD interval for the coefficients of the covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimates for the covariables of zeta, this list contains the following items:
</p>

<dl>
<dt>table</dt><dd><p>a table with the means, medians, standard deviations and the Highest Posterior Density (HPD) Interval,</p>
</dd>
<dt>coeff</dt><dd><p>a vector containing the estimated coefficients for the variables.</p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+summary_mean">summary_mean</a></code>,<code><a href="#topic+values">values</a></code>,<code><a href="#topic+summary.bayesbr">summary.bayesbr</a></code>
</p>

<hr>
<h2 id='summary_tau_delta'>Coefficients for tau_delta</h2><span id='topic+summary_tau_delta'></span>

<h3>Description</h3>

<p>A function that uses values of the posterior distribution of the model and calculates the estimates for tau_delta parametrer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_tau_delta(x,prob=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_tau_delta_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="summary_tau_delta_+3A_prob">prob</code></td>
<td>
<p>a probability containing the credibility index for the HPD interval for the coefficients of the covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimates for tau parametrer, this list contains the following items:
</p>

<dl>
<dt>table</dt><dd><p>a table with the means, medians, standard deviations and the Highest Posterior Density (HPD) Interval,</p>
</dd>
<dt>coeff</dt><dd><p>a vector containing the estimated coefficients.</p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+summary_delta">summary_delta</a></code>,<code><a href="#topic+values">values</a></code>,<code><a href="#topic+summary_tau_xi">summary_tau_xi</a></code>
</p>

<hr>
<h2 id='summary_tau_xi'>Coefficients for tau_xi</h2><span id='topic+summary_tau_xi'></span>

<h3>Description</h3>

<p>A function that uses values of the posterior distribution of the model and calculates the estimates for tau_xi parametrer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_tau_xi(x,prob=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_tau_xi_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="summary_tau_xi_+3A_prob">prob</code></td>
<td>
<p>a probability containing the credibility index for the HPD interval for the coefficients of the covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimates for tau parametrer, this list contains the following items:
</p>

<dl>
<dt>table</dt><dd><p>a table with the means, medians, standard deviations and the Highest Posterior Density (HPD) Interval,</p>
</dd>
<dt>coeff</dt><dd><p>a vector containing the estimated coefficients.</p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+summary_xi">summary_xi</a></code>,<code><a href="#topic+values">values</a></code>,<code><a href="#topic+summary_tau_delta">summary_tau_delta</a></code>
</p>

<hr>
<h2 id='summary_xi'>Coefficients for xis</h2><span id='topic+summary_xi'></span>

<h3>Description</h3>

<p>A function that uses posterior distribution values of the model and calculates the estimates for xi parametrer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_xi(x,prob=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_xi_+3A_x">x</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="summary_xi_+3A_prob">prob</code></td>
<td>
<p>a probability containing the credibility index for the HPD interval for the coefficients of the covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimates for xi parametrer, this list contains the following items:
</p>

<dl>
<dt>table</dt><dd><p>a table with the means, medians, standard deviations and the Highest Posterior Density (HPD) Interval,</p>
</dd>
<dt>coeff</dt><dd><p>a vector containing the estimated coefficients.</p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+summary_delta">summary_delta</a></code>,<code><a href="#topic+values">values</a></code>,<code><a href="#topic+summary.bayesbr">summary.bayesbr</a></code>
</p>

<hr>
<h2 id='summary.bayesbr'>Summary for <code>bayesbr</code> Objects</h2><span id='topic+summary.bayesbr'></span>

<h3>Description</h3>

<p>A method that receives a list of the bayesbr type and its items and displays the main information of the model, such as the residuals, a table containing statistics on the estimated coefficients and information to evaluate the quality of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesbr'
summary(object,type = c("","quantile","sweighted",
"pearson","ordinary"), prob = 0.95,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bayesbr_+3A_object">object</code></td>
<td>
<p>an object of the class <em>bayesbr</em>, containing the list returned from the <code><a href="#topic+bayesbr">bayesbr</a></code> function.</p>
</td></tr>
<tr><td><code id="summary.bayesbr_+3A_type">type</code></td>
<td>
<p>A character containing the residual type returned by the model among the possibilities. The type of residue can be <em>quantile</em>, <em>sweighted</em>, <em>pearson</em> or <em>ordinary</em>. The default is <em>quantile</em>.</p>
</td></tr>
<tr><td><code id="summary.bayesbr_+3A_prob">prob</code></td>
<td>
<p>a probability containing the credibility index for the HPD interval for the coefficients of the covariates.</p>
</td></tr>
<tr><td><code id="summary.bayesbr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bayesbr">bayesbr</a></code>,<code><a href="#topic+residuals.bayesbr">residuals.bayesbr</a></code>,<code><a href="#topic+print.bayesbr">print.bayesbr</a></code>,<code><a href="#topic+predict.bayesbr">predict.bayesbr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bodyfat",package="bayesbr")

bbr = bayesbr(siri ~ age + weight +
              wrist | biceps + forearm,
              data = bodyfat, iter = 100)

summary(bbr)
summary(bbr, type="pearson")
summary(bbr, prob = 0.9)
summary(bbr, prob = 0.99, resid.type="sweighted")

bbr2 = bayesbr(siri ~ age + weight + height +
           wrist | biceps + forearm, data = bodyfat,
           iter = 100,mean_betas = 3,
           variance_betas = 10)

summary(bbr2)
summary(bbr2, type="sweighted")
summary(bbr2, prob = 0.96)
summary(bbr2, prob = 0.95, resid.type="quantile")

</code></pre>

<hr>
<h2 id='values'>Values of a Posteriori Distribution</h2><span id='topic+values'></span>

<h3>Description</h3>

<p>A function that uses the values returned from the sampling function of RStan and returns the parameter chain of the posterior distribution, the parameters can be beta, gamma, theta or zeta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>values(
  type = c("beta", "gamma", "theta", "zeta", "tau_delta", "tau_xi", "xi", "delta"),
  obj,
  iter,
  warmup,
  n,
  par
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="values_+3A_type">type</code></td>
<td>
<p>Characters indicating which values will be returned by the function</p>
</td></tr>
<tr><td><code id="values_+3A_obj">obj</code></td>
<td>
<p>containing the data returned from the sampling function of the Rstan package. This type of object is used because it returns the values of the posterior distribution of the model.</p>
</td></tr>
<tr><td><code id="values_+3A_iter">iter</code></td>
<td>
<p>A positive integer specifying the number of iterations for each chain (including warmup).</p>
</td></tr>
<tr><td><code id="values_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying the number of iterations that will be in the warm-up period.</p>
</td></tr>
<tr><td><code id="values_+3A_n">n</code></td>
<td>
<p>The number of observations of the model's variable response.</p>
</td></tr>
<tr><td><code id="values_+3A_par">par</code></td>
<td>
<p>A number containing the number of parameters for theta or zeta. If type is equal to beta or theta par is similar to p (number of parameters for theta), otherwise even is similar to q (number of parameters for zeta). When type is equal to 'delta', 'xi', 'tau_xi', or 'tau_delta' the par variable verify spatial effect in adjusted model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>values</code> returns the parameter of interest by taking the data returned by the Stan function excluding the warmup period data. All data returned is in the format of 5 decimal places.
</p>


<h3>Value</h3>

<p>A list containing the values according to the type argument, the values are returned excluding the warmups.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary_mean">summary_mean</a></code>,<code><a href="#topic+summary_precision">summary_precision</a></code>,<code><a href="#topic+model.bayesbr">model.bayesbr</a></code>
</p>

<hr>
<h2 id='WeatherTask'>Precise and Imprecise Probabilities and Priming for Weather Task</h2><span id='topic+WeatherTask'></span>

<h3>Description</h3>

<p>In this experiment, participants judged the likelihood of Sunday being the hottest day of week
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(WeatherTask)
</code></pre>


<h3>Format</h3>

<p>A data frame with 345 observations on the following 3 variables.
</p>

<dl>
<dt><code>priming</code></dt><dd><p>a variable. If 0, <code>two-fold</code> (case
prime); If 1, <code>seven-fold</code> (class prime).</p>
</dd>
<dt><code>eliciting</code></dt><dd><p>a variable. If 0, <code>precise</code>;If 1,
<code>imprecise</code> (lower and upper limit).</p>
</dd>
<dt><code>agreement</code></dt><dd><p>a numeric vector, probability indicated by
participants or the average between minimum and maximum
probability indicated.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All study participants were from the first or second year, none of the participants had an in-depth knowledge of probability.
</p>
<p>For <code>priming</code> the questions were:
</p>

<dl>
<dt>two-fold</dt><dd><p>[What is the probability that] the temperature at
Canberra airport on Sunday will be higher than every other day
next week?</p>
</dd>
<dt>seven-fold</dt><dd><p>[What is the probability that] the highest
temperature of the week at Canberra airport will occur on Sunday?</p>
</dd>
</dl>

<p>For <code>eliciting</code> the instructions were if
</p>

<dl>
<dt>precise</dt><dd><p>to assign a probability estimate,</p>
</dd>
<dt>imprecise</dt><dd><p>to assign a lower and upper probability estimate.</p>
</dd>
</dl>

<p>The <code>priming</code> and <code>eliciting</code> variables that was a qualitative variable was transformed into a quantitative variable to be used by the package functions.
</p>


<h3>Source</h3>

<p>Taken from Smithson et al. (2011) supplements.
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.3102/1076998610396893">10.3102/1076998610396893</a> Smithson, M., Merkle, E.C., and Verkuilen, J. (2011). Beta
Regression Finite Mixture Models of Polarization and Priming.
<em>Journal of Educational and Behavioral Statistics</em>, <b>36</b>(6), 804&ndash;831.
</p>
<p>doi: <a href="https://doi.org/10.3102/1076998610396893">10.3102/1076998610396893</a> Smithson, M., and Segale, C. (2009). Partition Priming in Judgments of
Imprecise Probabilities. <em>Journal of Statistical Theory and
Practice</em>, <b>3</b>(1), 169&ndash;181.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("WeatherTask", package = "bayesbr")

bbr &lt;- bayesbr(agreement~eliciting+priming, data = WeatherTask,
              iter = 200)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
