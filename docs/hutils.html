<!DOCTYPE html><html><head><title>Help for package hutils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hutils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%ein%'><p>Exists and (not) in</p></a></li>
<li><a href='#%notchin%'><p>Negation of in (character)</p></a></li>
<li><a href='#%notin%'><p>Negation of in</p></a></li>
<li><a href='#%pin%'><p>Partial in</p></a></li>
<li><a href='#ahull'><p>Maximum area given x and y coordinates</p></a></li>
<li><a href='#aliases'><p>Aliases</p></a></li>
<li><a href='#all_same_sign'><p>Determine whether a vector is all of the same sign</p></a></li>
<li><a href='#any_grepl'><p>Does the pattern appear anywhere?</p></a></li>
<li><a href='#auc'><p>AUC</p></a></li>
<li><a href='#average_bearing'><p>Average of bearings</p></a></li>
<li><a href='#bearing'><p>Bearing calculations</p></a></li>
<li><a href='#coalesce'><p>Find first non-missing element</p></a></li>
<li><a href='#dev_copy2a4'><p>Copy device to an A4 PDF</p></a></li>
<li><a href='#dir2'><p>List many files</p></a></li>
<li><a href='#drop_col'><p>Drop column or columns</p></a></li>
<li><a href='#drop_colr'><p>Drop columns whose names match a pattern</p></a></li>
<li><a href='#drop_constant_cols'><p>Drop constant columns</p></a></li>
<li><a href='#drop_empty_cols'><p>Drop empty columns</p></a></li>
<li><a href='#duplicated_rows'><p>Return duplicated rows of data.table</p></a></li>
<li><a href='#find_pattern_in'><p>Find string pattern in (text) file</p></a></li>
<li><a href='#fst_columns'><p>Utilities for 'fst' files</p></a></li>
<li><a href='#generate_LaTeX_manual'><p>Generate LaTeX manual of installed package</p></a></li>
<li><a href='#haversine_distance'><p>Distance between two points on the Earth</p></a></li>
<li><a href='#hutils-package'><p>hutils package</p></a></li>
<li><a href='#if_else'><p>Vectorized if</p></a></li>
<li><a href='#implies'><p>#' Logical implies</p></a></li>
<li><a href='#isAttached'><p>Is a package attached?</p></a></li>
<li><a href='#isTrueFalse'><p>Logical assertions</p></a></li>
<li><a href='#longest_affix'><p>Longest common prefix/suffix</p></a></li>
<li><a href='#mean_na'><p>Proportion of values that are NA.</p></a></li>
<li><a href='#Mode'><p>Statistical mode</p></a></li>
<li><a href='#mutate_ntile'><p>Add a column of ntiles to a data table</p></a></li>
<li><a href='#mutate_other'><p>Group infrequent entries into 'Other category'</p></a></li>
<li><a href='#ngrep'><p>Anti-grep</p></a></li>
<li><a href='#prohibit_unequal_length_vectors'><p>Prohibit unequal length vectors</p></a></li>
<li><a href='#prohibit_vector_recycling'><p>Prohibit vector recycling</p></a></li>
<li><a href='#provide.dir'><p>Provide directory</p></a></li>
<li><a href='#provide.file'><p>Provide a file</p></a></li>
<li><a href='#replace_pattern_in'><p>Replace string pattern in text file</p></a></li>
<li><a href='#report_error'><p>Report errors and warnings</p></a></li>
<li><a href='#RQ'><p>Shorthand for <code>requireNamespace</code></p></a></li>
<li><a href='#samp'><p>Safer sampler</p></a></li>
<li><a href='#select_grep'><p>Select names matching a pattern</p></a></li>
<li><a href='#select_which'><p>Select columns satisfying a condition</p></a></li>
<li><a href='#selector'><p>Fast selection of <code>data.table</code> columns</p></a></li>
<li><a href='#seq_nrow'><p>Generate sequence of row numbers</p></a></li>
<li><a href='#set_cols_first'><p>Put columns first or last</p></a></li>
<li><a href='#swap'><p>Swap assignment</p></a></li>
<li><a href='#Switch'><p>Vectorized switch</p></a></li>
<li><a href='#unique-keys'><p>Unique keys</p></a></li>
<li><a href='#weight2rows'><p>Expand a weighted data frame to an equivalent unweighted</p></a></li>
<li><a href='#weighted_ntile'><p>Weighted (ranked) quantiles</p></a></li>
<li><a href='#weighted_quantile'><p>Weighted quantile</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous R Functions and Aliases</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hugh Parsonage &lt;hugh.parsonage@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides utility functions for, and drawing on, the 'data.table' package. The package also collates useful miscellaneous functions extending base R not available elsewhere. The name is a portmanteau of 'utils' and the author.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hughparsonage/hutils/issues">https://github.com/hughparsonage/hutils/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hughparsonage/hutils">https://github.com/hughparsonage/hutils</a>,
<a href="https://hughparsonage.github.io/hutils/">https://hughparsonage.github.io/hutils/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, magrittr, stats, utils, fastmatch, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), datasets, desc, dplyr, digest, fst,
Hmisc, hutilscpp, microbenchmark, knitr, rmarkdown,
nycflights13, geosphere, ggplot2, readr, rcheology, rstudioapi,
survey, tibble, tidyr, withr (&ge; 2.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-13 14:45:58 UTC; hughp</td>
</tr>
<tr>
<td>Author:</td>
<td>Hugh Parsonage [aut, cre],
  Michael Frasco [ctb],
  Ben Hamner [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-13 15:12:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25ein+25'>Exists and (not) in</h2><span id='topic++25ein+25'></span><span id='topic++25enotin+25'></span>

<h3>Description</h3>

<p>A common blunder in R programming is to mistype one of a set of filters without realizing. 
This function will error if any member of the values to be matched against is not present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %ein% rhs

lhs %enotin% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25ein+2B25_+3A_lhs">lhs</code></td>
<td>
<p>Values to be matched</p>
</td></tr>
<tr><td><code id="+2B25ein+2B25_+3A_rhs">rhs</code></td>
<td>
<p>Values to be matched against.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as <code>%in%</code> and <code>%notin%</code>, unless an element of <code>rhs</code> is not present in <code>lhs</code>, in which case, an error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Incorrectly assumed to include two Species
iris[iris$Species %in% c("setosa", "versicolour"), ]
## Not run: 
# Error:
iris[iris$Species %ein% c("setosa", "versicolour"), ]

## End(Not run)
</code></pre>

<hr>
<h2 id='+25notchin+25'>Negation of in (character)</h2><span id='topic++25notchin+25'></span>

<h3>Description</h3>

<p>Negation of in (character)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %notchin% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25notchin+2B25_+3A_x">x</code></td>
<td>
<p>Values to be matched.</p>
</td></tr>
<tr><td><code id="+2B25notchin+2B25_+3A_y">y</code></td>
<td>
<p>Values to be matched against.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>y</code> is <code>NULL</code>, then <code>x</code> is <code>TRUE</code> for consistency with
<code>%in%</code>. If <code>x</code> and <code>y</code> are not both character, the function simply
falls back to <code>%in%</code> rather than erroring.
</p>

<hr>
<h2 id='+25notin+25'>Negation of in</h2><span id='topic++25notin+25'></span>

<h3>Description</h3>

<p>Negation of in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %notin% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25notin+2B25_+3A_x">x</code></td>
<td>
<p>Values to be matched</p>
</td></tr>
<tr><td><code id="+2B25notin+2B25_+3A_y">y</code></td>
<td>
<p>Values to be matched against.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>y</code> is <code>NULL</code>, then <code>x</code> is <code>TRUE</code> for consistency with
<code>%in%</code>. Note that the function uses <code><a href="fastmatch.html#topic+fmatch">fmatch</a></code> internally for 
performance on large <code>y</code>. Accordingly, <code>y</code> will be modified by adding
a <code>.match.hash</code> attribute and thus must not be used in packages where <code>y</code>
is a constant, or for things like names of <code>data.table</code>.
</p>

<hr>
<h2 id='+25pin+25'>Partial in</h2><span id='topic++25pin+25'></span>

<h3>Description</h3>

<p>Analogue of <code>%in%</code> but indicating partial match of the left operand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %pin% Y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25pin+2B25_+3A_x">x</code></td>
<td>
<p>The values to be matched. Same as <code>%in%</code>.</p>
</td></tr>
<tr><td><code id="+2B25pin+2B25_+3A_y">Y</code></td>
<td>
<p>A vector of values (perl regular expressions) to be matched against.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for every <code>x</code> for which any <code>grepl</code> is <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("Sydney Airport", "Melbourne Airport")

x %pin% c("Syd", "Melb")



</code></pre>

<hr>
<h2 id='ahull'>Maximum area given x and y coordinates</h2><span id='topic+ahull'></span>

<h3>Description</h3>

<p>Present since <code>hutils 1.2.0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahull(
  DT,
  x = DT$x,
  y = DT$y,
  minH = 0,
  minW = 0,
  maximize = "area",
  incl_negative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahull_+3A_dt">DT</code>, <code id="ahull_+3A_x">x</code>, <code id="ahull_+3A_y">y</code></td>
<td>
<p>Coordinates of a curve containing a rectangle. 
Either as a list, <code>DT</code>, containing columns <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="ahull_+3A_minh">minH</code></td>
<td>
<p>The minimum height of the rectangles.</p>
</td></tr>
<tr><td><code id="ahull_+3A_minw">minW</code></td>
<td>
<p>The minimum width of the rectangles.</p>
</td></tr>
<tr><td><code id="ahull_+3A_maximize">maximize</code></td>
<td>
<p>How the rectangle should be selected. Currently, only <code>"area"</code> supported.</p>
</td></tr>
<tr><td><code id="ahull_+3A_incl_negative">incl_negative</code></td>
<td>
<p>Should areas below the x-axis be considered?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code>: The coordinates of a rectangle, from (0, 0), (1, 0), (1, 1), (0, 1), south-west clockwise, 
that is contained within the area of the chart for positive values only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ahull(, c(0, 1, 2, 3, 4), c(0, 1, 2, 0, 0))

</code></pre>

<hr>
<h2 id='aliases'>Aliases</h2><span id='topic+aliases'></span><span id='topic+AND'></span><span id='topic+OR'></span><span id='topic+nor'></span><span id='topic+neither'></span><span id='topic+NOR'></span><span id='topic+NEITHER'></span><span id='topic+pow'></span><span id='topic+XOR'></span>

<h3>Description</h3>

<p>These simple aliases can be useful to avoid operator precedence ambiguity,
or to make use of indents from commas within your text editor. The all-caps versions accept
single-length (capable of 'short-circuits') logical conditions only.
</p>
<p>Neithers and nors are identical except have slightly different short-circuits.
<code>NOR</code> uses negation once so may be quicker if the first argument is very, very prompt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AND(x, y)

OR(x, y)

nor(x, y)

neither(x, y)

NOR(x, y)

NEITHER(x, y)

pow()

XOR(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aliases_+3A_x">x</code>, <code id="aliases_+3A_y">y</code></td>
<td>
<p>Logical conditions.</p>
</td></tr>
</table>

<hr>
<h2 id='all_same_sign'>Determine whether a vector is all of the same sign</h2><span id='topic+all_same_sign'></span>

<h3>Description</h3>

<p>Present since <code>hutils 1.2.0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_same_sign(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_same_sign_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all elements of <code>x</code> have the same sign. Zero is a separate sign from positive and negative. All vectors of length-1 or length-0 return <code>TRUE</code>, even if <code>x</code> = <code>NA</code>, (since although the value is unknown, it must have a unique sign), and non-numeric <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all_same_sign(1:10)
all_same_sign(1:10 - 1)
all_same_sign(0)
all_same_sign(NA)
all_same_sign(c(NA, 1))
all_same_sign("surprise?")
all_same_sign(c(0, 0.1 + 0.2 - 0.3))

if (requireNamespace("microbenchmark", quietly = TRUE)) {
  library(microbenchmark)
  microbenchmark(base = length(unique(sign(1:1e5), nmax = 3)) == 1L, 
                 all_same_sign(1:1e5))
}
# Unit: microseconds
#                   expr  min   lq mean median   uq  max neval cld
#                   base 2012 2040 2322   2047 2063 9324   100   b
# all_same_sign(1:1e+05)   86   86   94     89   93  290   100  a 

</code></pre>

<hr>
<h2 id='any_grepl'>Does the pattern appear anywhere?</h2><span id='topic+any_grepl'></span>

<h3>Description</h3>

<p>Shortcut for <code>any(grepl(...))</code>, mostly for consistency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any_grepl(
  x,
  pattern,
  perl = TRUE,
  ignore.case = FALSE,
  fixed = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="any_grepl_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="any_grepl_+3A_pattern">pattern</code>, <code id="any_grepl_+3A_perl">perl</code>, <code id="any_grepl_+3A_ignore.case">ignore.case</code>, <code id="any_grepl_+3A_fixed">fixed</code></td>
<td>
<p>As in <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="any_grepl_+3A_quiet">quiet</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) If <code>TRUE</code>, silences any messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From version <code>v 1.4.0</code>, <code>any_grepl(a, bb)</code> will be internally
reversed to <code>any_grepl(bb, a)</code> if <code>length(bb) &gt; 1</code> and <code>length(a) == 1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>any_grepl(c("A_D_E", "K0j"), "[a-z]")

</code></pre>

<hr>
<h2 id='auc'>AUC</h2><span id='topic+auc'></span>

<h3>Description</h3>

<p>Returns the area under the curve (&quot;AUC&quot;) of a receiver-operating characteristic curve for the given predicted and actual values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(actual, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_actual">actual</code></td>
<td>
<p>Logical vector: <code>TRUE</code> for positive class. 
If not a logical vector, the result is interpreted as one if safe to do so,
<em>viz.</em> if <code>actual</code> contains precisely two unique values and is either a numeric vector,
an ordered factor, or the unique values are <code>FALSE</code> and <code>TRUE</code> (case-insensitively).
Anything else is an error.</p>
</td></tr>
<tr><td><code id="auc_+3A_pred">pred</code></td>
<td>
<p>Numeric (double) vector the same length as <code>actual</code> giving the predicted probability of <code>TRUE</code>. Must be a numeric vector the same length as <code>actual</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Copyright (c) 2012, Ben Hamner
Author: Ben Hamner (ben@benhamner.com)
All rights reserved.
</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
</p>
<p>1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.
</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</p>


<h3>Source</h3>

<p>Source code based on <code>Metrics::auc</code> from Ben Hamner and Michael Frasco and Erin LeDell from the Metrics package.
</p>

<hr>
<h2 id='average_bearing'>Average of bearings</h2><span id='topic+average_bearing'></span><span id='topic+average_bearing_n'></span>

<h3>Description</h3>

<p>Average of bearings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_bearing(theta1, theta2, average_of_opposite = NULL)

average_bearing_n(thetas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_bearing_+3A_theta1">theta1</code>, <code id="average_bearing_+3A_theta2">theta2</code></td>
<td>
<p>Bearings, expressed in degrees.</p>
</td></tr>
<tr><td><code id="average_bearing_+3A_average_of_opposite">average_of_opposite</code></td>
<td>
<p>The average of opposing bearings (e.g. average of north
and south) is not well-defined. If <code>NULL</code>, the result for opposing vectors is 
undefined; if <code>"right"</code>, returns 
<code>theta1 + 90</code>; if <code>"left"</code> then <code>theta2 + 90</code>. Can also be 
a single numeric to provide a specific value when the vectors point in opposite 
directions.</p>
</td></tr>
<tr><td><code id="average_bearing_+3A_thetas">thetas</code></td>
<td>
<p>A vector of bearings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For 'average_bearing', the bearing bisecting the two bearings.
</p>
<p>For 'average_bearing_n', the average bearing of the bearing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>average_bearing(0, 90)
average_bearing(0, 270)
average_bearing(90, 180)

average_bearing(0, 180)
average_bearing(0, 180, average_of_opposite = 3)
average_bearing(0, 180, average_of_opposite = "left")

average_bearing_n(1:179)

</code></pre>

<hr>
<h2 id='bearing'>Bearing calculations</h2><span id='topic+bearing'></span><span id='topic+compass2bearing'></span><span id='topic+easterly_component'></span><span id='topic+northerly_component'></span>

<h3>Description</h3>

<p>Bearing calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bearing(lat_orig, lon_orig, lat_dest, lon_dest)

compass2bearing(compass)

easterly_component(compass)

northerly_component(compass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bearing_+3A_lat_orig">lat_orig</code>, <code id="bearing_+3A_lon_orig">lon_orig</code>, <code id="bearing_+3A_lat_dest">lat_dest</code>, <code id="bearing_+3A_lon_dest">lon_dest</code></td>
<td>
<p>Latitude and longitude
of origin and destination.</p>
</td></tr>
<tr><td><code id="bearing_+3A_compass">compass</code></td>
<td>
<p>A character vector of compass rose points, such as 
<code>c("NW", "E", "SSW")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>bearing</code></dt><dd><p>An approximate bearing from <code>_orig</code> and <code>_dest</code>.</p>
</dd>
<dt><code>compass2bearing</code></dt><dd><p>The bearing encoded by the compass input.</p>
</dd>
<dt><code>easterly_component</code></dt><dd><p>The easterly component of a unit vector
pointing in the direction provided.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>bearing(0, 0, 90, 0)
bearing(-35, 151, 51, 0)

compass2bearing("NW")
easterly_component("E")
easterly_component("NW")


</code></pre>

<hr>
<h2 id='coalesce'>Find first non-missing element</h2><span id='topic+coalesce'></span>

<h3>Description</h3>

<p>Lightweight version of <code>dplyr::coalesce</code>, with all the vices and virtues that come from such an
approach. 
Very similar logic (and timings to <code>dplyr::coalesce</code>), though no ability to use quosures etc.
One exception is that if <code>x</code> does not contain any missing values, it is returned immediately,
and ignores <code>...</code>. For example, <code>dplyr::coalesce(1:2, 1:3)</code> is an error, but 
<code>hutils::coalesce(1:2, 1:3)</code> is not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalesce_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="coalesce_+3A_...">...</code></td>
<td>
<p>Successive vectors whose values will replace the corresponding values in <code>x</code> if the value is 
(still) missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with missing values replaced by the first non-missing corresponding elements in <code>...</code>.
That is, if <code>... = A, B, C</code> and <code>x[i]</code> is missing, then <code>x[i]</code> is replaced by
<code>A[i]</code>. If <code>x[i]</code> is still missing (i.e. <code>A[i]</code> was itself <code>NA</code>), then it
is replaced by <code>B[i]</code>, <code>C[i]</code> until it is no longer missing or the list has been exhausted.
</p>


<h3>Source</h3>

<p>Original source code but obviously inspired by <code>dplyr::coalesce</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coalesce(c(1, NA, NA, 4), c(1, 2, NA, NA), c(3, 4, 5, NA))
</code></pre>

<hr>
<h2 id='dev_copy2a4'>Copy device to an A4 PDF</h2><span id='topic+dev_copy2a4'></span>

<h3>Description</h3>

<p>Simply a wrapper around <code>dev.copy2pdf</code>, but without the need to remember that an A4 sheet of paper is 8.27 in by 11.69 in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dev_copy2a4(filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dev_copy2a4_+3A_filename">filename</code></td>
<td>
<p>A string giving the name of the PDF file to write to, must end in <code>.pdf</code>.</p>
</td></tr>
<tr><td><code id="dev_copy2a4_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="grDevices.html#topic+pdf">pdf</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As in <code><a href="grDevices.html#topic+dev2">dev2</a></code>.
</p>

<hr>
<h2 id='dir2'>List many files</h2><span id='topic+dir2'></span>

<h3>Description</h3>

<p>(Windows only) Same as <code><a href="base.html#topic+list.files">list.files</a></code> but much faster.
</p>
<p>Present since <code>v1.4.0.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir2(
  path = ".",
  file_ext = NULL,
  full.names = TRUE,
  recursive = TRUE,
  pattern = NULL,
  fixed = FALSE,
  perl = TRUE &amp;&amp; missing(fixed) &amp;&amp; !fixed,
  ignore.case = FALSE,
  invert = FALSE,
  .dont_use = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dir2_+3A_path">path</code></td>
<td>
<p>A string representing the trunk path to search within.</p>
</td></tr>
<tr><td><code id="dir2_+3A_file_ext">file_ext</code></td>
<td>
<p>A string like '*.txt' or '.csv' to limit the result to files 
with that extension.</p>
</td></tr>
<tr><td><code id="dir2_+3A_full.names">full.names</code></td>
<td>
<p><code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="dir2_+3A_recursive">recursive</code></td>
<td>
<p><code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="dir2_+3A_pattern">pattern</code>, <code id="dir2_+3A_perl">perl</code>, <code id="dir2_+3A_ignore.case">ignore.case</code>, <code id="dir2_+3A_fixed">fixed</code>, <code id="dir2_+3A_invert">invert</code></td>
<td>
<p>As in <code>grep</code> but with different defaults.
Used to filter files with extension <code>file_ext</code>.</p>
</td></tr>
<tr><td><code id="dir2_+3A_.dont_use">.dont_use</code></td>
<td>
<p>Only used for tests to simulate non-Windows systems.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same as <code><a href="base.html#topic+list.files">list.files</a></code>, a character vector of files sought.
</p>

<hr>
<h2 id='drop_col'>Drop column or columns</h2><span id='topic+drop_col'></span><span id='topic+drop_cols'></span>

<h3>Description</h3>

<p>Drop column or columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_col(DT, var, checkDT = TRUE)

drop_cols(DT, vars, checkDT = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_col_+3A_dt">DT</code></td>
<td>
<p>A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="drop_col_+3A_var">var</code></td>
<td>
<p>Quoted column to drop.</p>
</td></tr>
<tr><td><code id="drop_col_+3A_checkdt">checkDT</code></td>
<td>
<p>Should the function check <code>DT</code> is a <code>data.table</code>?</p>
</td></tr>
<tr><td><code id="drop_col_+3A_vars">vars</code></td>
<td>
<p>Character vector of columns to drop. Only the intersection is dropped; 
if any <code>vars</code> are not in <code>names(DT)</code>, no warning is emitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DT</code> with specified columns removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("data.table", quietly = TRUE)) {
  library(data.table)
  DT &lt;- data.table(x = 1, y = 2, z = 3)
  
  drop_col(DT, "x")
}

</code></pre>

<hr>
<h2 id='drop_colr'>Drop columns whose names match a pattern</h2><span id='topic+drop_colr'></span><span id='topic+drop_grep'></span>

<h3>Description</h3>

<p><code>drop_colr</code> present since <code>hutils 1.0.0</code>.
</p>
<p><code>drop_grep</code> is identical but only present since <code>hutils 1.2.0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_colr(DT, pattern, ..., checkDT = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_colr_+3A_dt">DT</code></td>
<td>
<p>A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="drop_colr_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression as in <code>grepl</code>.</p>
</td></tr>
<tr><td><code id="drop_colr_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>grepl</code>.</p>
</td></tr>
<tr><td><code id="drop_colr_+3A_checkdt">checkDT</code></td>
<td>
<p>If <code>TRUE</code> (the default), will error if <code>DT</code> is not a <code>data.table</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
dt &lt;- data.table(x1 = 1, x2 = 2, y = 3)
drop_grep(dt, "x")


</code></pre>

<hr>
<h2 id='drop_constant_cols'>Drop constant columns</h2><span id='topic+drop_constant_cols'></span>

<h3>Description</h3>

<p>Drops columns that have only one value in a <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_constant_cols(DT, copy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_constant_cols_+3A_dt">DT</code></td>
<td>
<p>A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="drop_constant_cols_+3A_copy">copy</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) Whether the <code>data.table</code> should be copied before any columns are dropped. If <code>FALSE</code>, the default, columns are dropped from <code>DT</code> by reference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>DT</code> is a <code>data.frame</code> that is not a <code>data.table</code>,
constant columns are still dropped, but since <code>DT</code> will be copied, <code>copy</code> should be set 
to <code>TRUE</code> to avoid a warning. If <code>DT</code> is a <code>data.frame</code> and all but one
of the columns are constant, a <code>data.frame</code>
will still be returned, as opposed to the values of the sole remaining column, which is the 
default behaviour of base <code>data.frame</code>.
</p>
<p>If all columns are constant, <code>drop_constant_cols</code> returns a Null data table if <code>DT</code> is a <code>data.table</code>,
but a data frame with 0 columns and <code>nrow(DT)</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
X &lt;- data.table(x = c(1, 1), y = c(1, 2))
drop_constant_cols(X)



</code></pre>

<hr>
<h2 id='drop_empty_cols'>Drop empty columns</h2><span id='topic+drop_empty_cols'></span>

<h3>Description</h3>

<p>Removes columns from a <code>data.table</code> where all the values are missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_empty_cols(DT, copy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_empty_cols_+3A_dt">DT</code></td>
<td>
<p>A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="drop_empty_cols_+3A_copy">copy</code></td>
<td>
<p>Copies the <code>data.table</code> so the original can be retained. 
Not applicable if <code>DT</code> is not a <code>data.table</code>.
If <code>FALSE</code>, the default, <code>DT</code> itself will be modified.</p>
</td></tr>
</table>

<hr>
<h2 id='duplicated_rows'>Return duplicated rows of data.table</h2><span id='topic+duplicated_rows'></span>

<h3>Description</h3>

<p>This function differs from <code>duplicated</code> in that it returns both the duplicate row and the row which has been duplicated.
This may prove useful in combination with the <code>by</code> argument for determining whether two observations are identical across
more than just the specified columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicated_rows(
  DT,
  by = names(DT),
  na.rm = FALSE,
  order = TRUE,
  copyDT = TRUE,
  na.last = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicated_rows_+3A_dt">DT</code></td>
<td>
<p>A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="duplicated_rows_+3A_by">by</code></td>
<td>
<p>Character vector of columns to evaluate duplicates over.</p>
</td></tr>
<tr><td><code id="duplicated_rows_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) Should <code>NA</code>s in <code>by</code> be removed before returning duplicates? (Default <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="duplicated_rows_+3A_order">order</code></td>
<td>
<p>(logical) Should the result be ordered so that duplicate rows are adjacent? (Default <code>TRUE</code>.)</p>
</td></tr>
<tr><td><code id="duplicated_rows_+3A_copydt">copyDT</code></td>
<td>
<p>(logical) Should <code>DT</code> be copied prior to detecting duplicates. If <code>FALSE</code>, the ordering of <code>DT</code> will be changed by reference.</p>
</td></tr>
<tr><td><code id="duplicated_rows_+3A_na.last">na.last</code></td>
<td>
<p>(logical) If <code>order</code> is TRUE, should <code>NA</code>s be ordered first or last?. Passed to <code>data.table::setorderv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Duplicate rows of <code>DT</code> by <code>by</code>. For interactive use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("data.table", quietly = TRUE)) {
  library(data.table)

  DT &lt;- data.table(x = rep(1:4, 3),
                   y = rep(1:2, 6),
                   z = rep(1:3, 4))

  # No duplicates
  duplicated_rows(DT)

  # x and y have duplicates
  duplicated_rows(DT, by = c("x", "y"), order = FALSE)

  # By default, the duplicate rows are presented adjacent to each other.
  duplicated_rows(DT, by = c("x", "y"))
}

</code></pre>

<hr>
<h2 id='find_pattern_in'>Find string pattern in (text) file</h2><span id='topic+find_pattern_in'></span><span id='topic+goto_pattern_in'></span>

<h3>Description</h3>

<p><code>goto_pattern_in</code> present from 1.6.0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_pattern_in(
  file_contents,
  basedir = ".",
  dir_recursive = TRUE,
  reader = readLines,
  include.comments = FALSE,
  comment.char = NULL,
  use.OS = FALSE,
  file_pattern = "\\.(R|r)(nw|md)?$",
  file_contents_perl = TRUE,
  file_contents_fixed = FALSE,
  file_contents_ignore_case = FALSE,
  file.ext = NULL,
  which_lines = c("first", "all")
)

goto_pattern_in(file_contents, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_pattern_in_+3A_file_contents">file_contents</code></td>
<td>
<p>A perl-regular expression as a search query.</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_basedir">basedir</code></td>
<td>
<p>The root of the directory tree in which files will be searched recursively.</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_dir_recursive">dir_recursive</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Search within subdirectories of <code>basedir</code>?</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_reader">reader</code></td>
<td>
<p>A function, akin to <code>base::readLines</code>, the default, that accepts a filename and returns a character vector.</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_include.comments">include.comments</code></td>
<td>
<p>If <code>FALSE</code>, the default, comments (i.e. anything after a <code>\#</code>) are not searched.</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_comment.char">comment.char</code></td>
<td>
<p>If <code>include.comments</code> is <code>FALSE</code>, what character marks a comment character? By default, <code>NULL</code>, which sets the correct comment symbol for R and TeX files.</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_use.os">use.OS</code></td>
<td>
<p>Use the operating system to determine file list. Only available on Windows. If it fails, a fall-back option
(using <code>dir</code>) is used.</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_file_pattern">file_pattern</code></td>
<td>
<p>A regular expression passed to <code>list.files(pattern = file.ext)</code>.
By default, <code>"\.(R|r)(nw|md)?$"</code>, i.e. all R and Sweave files. (Does not have to be a file extension.)</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_file_contents_perl">file_contents_perl</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Should <code>file_contents</code> 
be interpreted as a <code>perl</code> regex?</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_file_contents_fixed">file_contents_fixed</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) Should <code>file_contents</code> 
be interpreted as a <code>fixed</code> regex?</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_file_contents_ignore_case">file_contents_ignore_case</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) As in <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_file.ext">file.ext</code></td>
<td>
<p>A file extension passed to the operating system if <code>use.OS</code> is used.</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_which_lines">which_lines</code></td>
<td>
<p>One of <code>"first"</code> and <code>"all"</code>. If <code>"first"</code> only the first match in any file is returned in the result; if <code>"all"</code>, all matches are.</p>
</td></tr>
<tr><td><code id="find_pattern_in_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>find_pattern_in</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For convenience, if <code>file_contents</code> appears to be a directory
and <code>basedir</code> does not, the arguments are swapped, but with a warning.
</p>


<h3>Value</h3>

<p>A <code>data.table</code>, showing the matches per file.
</p>
<p><code>goto_pattern_in</code> additionally prompts for a row of the returned results.
Using the <code>rstudioapi</code>, if available, RStudio will jump to the file 
and line number.
</p>

<hr>
<h2 id='fst_columns'>Utilities for 'fst' files</h2><span id='topic+fst_columns'></span><span id='topic+fst_nrow'></span>

<h3>Description</h3>

<p>Utilities for 'fst' files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fst_columns(file.fst)

fst_nrow(file.fst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fst_columns_+3A_file.fst">file.fst</code></td>
<td>
<p>Path to file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Various outputs:
</p>

<dl>
<dt><code>fst_columns</code></dt><dd><p>Returns the names of the columns in <code>file.fst</code>.</p>
</dd>
<dt><code>fst_nrow</code></dt><dd><p>Returns the number of rows in <code>file.fst</code>.</p>
</dd>
</dl>


<hr>
<h2 id='generate_LaTeX_manual'>Generate LaTeX manual of installed package</h2><span id='topic+generate_LaTeX_manual'></span>

<h3>Description</h3>

<p>Generate LaTeX manual of installed package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_LaTeX_manual(pkg, launch = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_LaTeX_manual_+3A_pkg">pkg</code></td>
<td>
<p>Quoted package name (must be installed).</p>
</td></tr>
<tr><td><code id="generate_LaTeX_manual_+3A_launch">launch</code></td>
<td>
<p>Should the PDF created be launched using the viewer (<code>TRUE</code> by default)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="base.html#topic+system">system</a></code>.
Called for its side-effect: creates a PDF in the current working directory. Requires a TeX distribution.
</p>


<h3>Source</h3>

<p><a href="https://stackoverflow.com/a/30608000/1664978">https://stackoverflow.com/a/30608000/1664978</a>
</p>

<hr>
<h2 id='haversine_distance'>Distance between two points on the Earth</h2><span id='topic+haversine_distance'></span>

<h3>Description</h3>

<p>Distance between two points on the Earth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haversine_distance(lat1, lon1, lat2, lon2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haversine_distance_+3A_lat1">lat1</code>, <code id="haversine_distance_+3A_lon1">lon1</code>, <code id="haversine_distance_+3A_lat2">lat2</code>, <code id="haversine_distance_+3A_lon2">lon2</code></td>
<td>
<p>That latitudes and longitudes of the two points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is reasonably accurate for distances in the order of 1 to 1000 km.
</p>


<h3>Value</h3>

<p>The distance in kilometres between the two points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Distance from YMEL to YSSY
haversine_distance(-37 - 40/60, 144 + 50/60, -33 - 56/60, 151 + 10/60)

</code></pre>

<hr>
<h2 id='hutils-package'>hutils package</h2><span id='topic+hutils-package'></span>

<h3>Description</h3>

<p>Provides utility functions for, and drawing on, the 'data.table' package. The package also collates useful miscellaneous functions extending base R not available elsewhere. The name is a portmanteau of 'utils' and the author.
</p>


<h3>Details</h3>

<p>The package attempts to provide lightweight, fast, and stable functions 
for common operations. 
</p>
<p>By <strong>lightweight</strong>, I mean in terms of dependencies:
we import <code>package:data.table</code> and <code>package:fastmatch</code> which do require
compilation, but in C. Otherwise, all dependencies do not require compilation.
</p>
<p>By <strong>fast</strong>, I mean essentially as fast as possible without using compilation.
</p>
<p>By <strong>stable</strong>, I mean that unit tests <em>should not change</em> unless the major
version also changes.  To make this completely transparent, tests include the version
of their introduction and are guaranteed to not be modified (not even in the sense of
adding extra, independent tests) while the major version is <code>1</code>. Tests that do
not include the version in their filename may be modified from version to version 
(though this will be avoided).
</p>

<hr>
<h2 id='if_else'>Vectorized if</h2><span id='topic+if_else'></span>

<h3>Description</h3>

<p>Lightweight <code>dplyr::if_else</code> with the virtues and vices that come from such an approach.
Attempts to replicate <code>dplyr::if_else</code> but written in base R for faster compile time.
<code>hutils::if_else</code> should be faster than <code>dplyr::if_else</code> ... when it works, 
but will not work on lists or on factors. 
Additional attributes may be dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_else(condition, true, false, missing = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_else_+3A_condition">condition</code></td>
<td>
<p>Logical vector.</p>
</td></tr>
<tr><td><code id="if_else_+3A_true">true</code>, <code id="if_else_+3A_false">false</code></td>
<td>
<p>Where condition is <code>TRUE</code>/<code>FALSE</code>, use the corresponding<code>true</code>/<code>no</code> value.
They must have the same <code><a href="base.html#topic+typeof">typeof</a></code> as each other and be the same length as <code>condition</code> or length-one.</p>
</td></tr>
<tr><td><code id="if_else_+3A_missing">missing</code></td>
<td>
<p>If condition is <code>NA</code>, use the corresponding <code>na</code> value. Like<code>true</code> and<code>false</code>, must
be of the same type and have the same length as condition, unless it has length one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the result is expected to be a factor then the conditions for type safety
are strict and may be made stricter in future.
</p>


<h3>Value</h3>

<p>Where <code>condition</code> is <code>TRUE</code>, the corresponding value in <code>true</code>; 
where <code>condition</code> is <code>FALSE</code>, the corresponding value in <code>false</code>.
Where <code>condition</code> is <code>NA</code>, then the corresponding value in <code>na</code> &ndash; 
unless <code>na</code> is <code>NULL</code> (the default) in which case the value will be <code>NA</code> (with the same
type as <code>true</code>.)
</p>


<h3>Source</h3>

<p>Original code but obviously heavily inspired by <a href="https://CRAN.R-project.org/package=dplyr">https://CRAN.R-project.org/package=dplyr</a>.
</p>

<hr>
<h2 id='implies'>#' Logical implies</h2><span id='topic+implies'></span><span id='topic++25implies+25'></span>

<h3>Description</h3>

<p>Returns the result of <code class="reqn">x\Longrightarrow y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>implies(x, y)

x %implies% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="implies_+3A_x">x</code>, <code id="implies_+3A_y">y</code></td>
<td>
<p>Logical vectors of the same length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical implies: <code>TRUE</code> unless <code>x</code> is <code>TRUE</code> and <code>y</code> is <code>FALSE</code>.
</p>
<p><code>NA</code> in either <code>x</code> or <code>y</code> results in <code>NA</code> if and only if the result is unknown.
In particular <code>NA %implies% TRUE</code> is <code>TRUE</code> and <code>FALSE %implies% NA</code> is <code>TRUE</code>.
</p>
<p>If <code>x</code> or <code>y</code> are length-one, the function proceeds as if the length-one vector were recycled
to the length of the other.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
library(data.table)
CJ(x = c(TRUE,
         FALSE),
   y = c(TRUE,
         FALSE))[, ` x =&gt; y` := x %implies% y][]

#&gt;        x     y  x =&gt; y
#&gt; 1: FALSE FALSE    TRUE
#&gt; 2: FALSE  TRUE    TRUE
#&gt; 3:  TRUE FALSE   FALSE
#&gt; 4:  TRUE  TRUE    TRUE

# NA results:
#&gt; 5:    NA    NA      NA
#&gt; 6:    NA FALSE      NA
#&gt; 7:    NA  TRUE    TRUE
#&gt; 8: FALSE    NA    TRUE
#&gt; 9:  TRUE    NA      NA
</code></pre>

<hr>
<h2 id='isAttached'>Is a package attached?</h2><span id='topic+isAttached'></span>

<h3>Description</h3>

<p>Is a package attached?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isAttached(pkg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isAttached_+3A_pkg">pkg</code></td>
<td>
<p>Either character or unquoted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>pkg</code> is attached.
</p>

<hr>
<h2 id='isTrueFalse'>Logical assertions</h2><span id='topic+isTrueFalse'></span>

<h3>Description</h3>

<p>Logical assertions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isTrueFalse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isTrueFalse_+3A_x">x</code></td>
<td>
<p>An object whose values are to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>isTrueFalse</code>, <code>TRUE</code> if and only if <code>x</code> is <code>TRUE</code> or <code>FALSE</code> identically (perhaps with attributes).
</p>

<hr>
<h2 id='longest_affix'>Longest common prefix/suffix</h2><span id='topic+longest_affix'></span><span id='topic+trim_common_affixes'></span><span id='topic+longest_suffix'></span><span id='topic+longest_prefix'></span>

<h3>Description</h3>

<p>Longest common prefix/suffix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_common_affixes(
  x,
  .x = NULL,
  na.rm = TRUE,
  prefixes = TRUE,
  suffixes = TRUE,
  warn_if_no_prefix = TRUE,
  warn_if_no_suffix = TRUE
)

longest_suffix(x, .x = NULL, na.rm = TRUE, warn_if_no_suffix = TRUE)

longest_prefix(x, .x = NULL, na.rm = TRUE, warn_if_no_prefix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longest_affix_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="longest_affix_+3A_.x">.x</code></td>
<td>
<p>If <code>NULL</code>, the default, ignored. May be used if <code>x</code> is
known to be free of <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="longest_affix_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) If <code>FALSE</code>, an <code>NA</code> in 
<code>x</code> means <code>""</code> is the only common affix. If <code>NA</code>, the longest 
prefix/suffix is <code>NA_character_</code> (provided <code>anyNA(x)</code>).
</p>
<p>If <code>anyNA(x) == FALSE</code> <code>na.rm</code> has no effect.</p>
</td></tr>
<tr><td><code id="longest_affix_+3A_prefixes">prefixes</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) If <code>TRUE</code>, trim prefixes.</p>
</td></tr>
<tr><td><code id="longest_affix_+3A_suffixes">suffixes</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) If <code>TRUE</code>, trim suffixes.</p>
</td></tr>
<tr><td><code id="longest_affix_+3A_warn_if_no_prefix">warn_if_no_prefix</code>, <code id="longest_affix_+3A_warn_if_no_suffix">warn_if_no_suffix</code></td>
<td>
<p>(logical, default: <code>TRUE</code>)
If <code>FALSE</code>, if <code>x</code> has no common affixes the warning is suppressed.
(If no common prefix/suffix then the common affix returned will be <code>""</code>
(the empty string).)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The longest common substring in <code>x</code> either at the start or end of each string.
For <code>trim_common_affixes</code> <code>x</code> with common prefix and common suffix
removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>longest_prefix(c("totalx", "totaly", "totalz"))
longest_suffix(c("ztotal", "ytotal", "xtotal"))
</code></pre>

<hr>
<h2 id='mean_na'>Proportion of values that are NA.</h2><span id='topic+mean_na'></span>

<h3>Description</h3>

<p>Proportion of values that are NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_na(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_na_+3A_v">v</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double, <code>mean(is.na(v))</code>.
</p>

<hr>
<h2 id='Mode'>Statistical mode</h2><span id='topic+Mode'></span>

<h3>Description</h3>

<p>Present since <code>hutils 1.4.0</code>. The most common element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mode_+3A_x">x</code></td>
<td>
<p>A vector for which the mode is desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The most common element of <code>x</code>.
</p>
<p>If the mode is not unique, only one of these values is returned, for simplicity.
</p>
<p>If <code>x</code> has length zero, <code>Mode(x) = x</code>.
</p>

<hr>
<h2 id='mutate_ntile'>Add a column of ntiles to a data table</h2><span id='topic+mutate_ntile'></span>

<h3>Description</h3>

<p>Add a column of ntiles to a data table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_ntile(
  DT,
  col,
  n,
  weights = NULL,
  by = NULL,
  keyby = NULL,
  new.col = NULL,
  character.only = FALSE,
  overwrite = TRUE,
  check.na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_ntile_+3A_dt">DT</code></td>
<td>
<p>A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="mutate_ntile_+3A_col">col</code></td>
<td>
<p>The column name (quoted or unquoted) for which quantiles are desired.</p>
</td></tr>
<tr><td><code id="mutate_ntile_+3A_n">n</code></td>
<td>
<p>A positive integer, the number of groups to split <code>col</code>.</p>
</td></tr>
<tr><td><code id="mutate_ntile_+3A_weights">weights</code></td>
<td>
<p>If <code>NULL</code>, the default, use unweighted quantiles.
Otherwise, a string designating the column that is passed to 
<code><a href="#topic+weighted_ntile">weighted_ntile</a></code>.</p>
</td></tr>
<tr><td><code id="mutate_ntile_+3A_by">by</code>, <code id="mutate_ntile_+3A_keyby">keyby</code></td>
<td>
<p>Produce a grouped quantile column, as in <code><a href="data.table.html#topic+data.table">data.table</a></code>.
<code>keyby</code> will set a key on the result (<em>i.e.</em> order by <code>keyby</code>).</p>
</td></tr>
<tr><td><code id="mutate_ntile_+3A_new.col">new.col</code></td>
<td>
<p>If not <code>NULL</code>, the name of the column to be added. 
If <code>NULL</code> (the default) a name will be inferred from <code>n</code>. 
(For example, <code>n = 100</code> will be <code>&lt;col&gt;Percentile</code>).</p>
</td></tr>
<tr><td><code id="mutate_ntile_+3A_character.only">character.only</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) Do not contemplate 
<code>col</code> to be an unquoted column name.</p>
</td></tr>
<tr><td><code id="mutate_ntile_+3A_overwrite">overwrite</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) If <code>TRUE</code> and
<code>new.col</code> already exists in <code>DT</code>, the column will be overwritten.
If <code>FALSE</code>, attempting to overwrite an existing column is an error.</p>
</td></tr>
<tr><td><code id="mutate_ntile_+3A_check.na">check.na</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) If <code>TRUE</code>, <code>NA</code>s
in <code>DT[[col]]</code> will throw an error. If <code>NA</code>'s are present, the 
corresponding n-tile may take any value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DT</code> with a new integer column <code>new.col</code> containing the
quantiles. If <code>DT</code> is not a <code>data.table</code> its class may be preserved
unless <code>keyby</code> is used, where it will always be a <code>data.table</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
DT &lt;- data.table(x = 1:20, y = 2:1)
mutate_ntile(DT, "x", n = 10)
mutate_ntile(DT, "x", n = 5)
mutate_ntile(DT, "x", n = 10, by = "y")
mutate_ntile(DT, "x", n = 10, keyby = "y")

y &lt;- "x"
DT &lt;- data.table(x = 1:20, y = 2:1)
mutate_ntile(DT, y, n = 5)                        # Use DT$y
mutate_ntile(DT, y, n = 5, character.only = TRUE) # Use DT$x

</code></pre>

<hr>
<h2 id='mutate_other'>Group infrequent entries into 'Other category'</h2><span id='topic+mutate_other'></span>

<h3>Description</h3>

<p>Useful when you want to constrain the number of unique values in a column by keeping only the most common values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_other(
  .data,
  var,
  n = 5,
  count,
  by = NULL,
  var.weight = NULL,
  mass = NULL,
  copy = TRUE,
  other.category = "Other"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_other_+3A_.data">.data</code></td>
<td>
<p>Data containing variable.</p>
</td></tr>
<tr><td><code id="mutate_other_+3A_var">var</code></td>
<td>
<p>Variable containing infrequent entries, to be collapsed into &quot;Other&quot;.</p>
</td></tr>
<tr><td><code id="mutate_other_+3A_n">n</code></td>
<td>
<p>Threshold for total number of categories above &quot;Other&quot;.</p>
</td></tr>
<tr><td><code id="mutate_other_+3A_count">count</code></td>
<td>
<p>Threshold for total count of observations before &quot;Other&quot;.</p>
</td></tr>
<tr><td><code id="mutate_other_+3A_by">by</code></td>
<td>
<p>Extra variables to group by when calculating <code>n</code> or <code>count</code>.</p>
</td></tr>
<tr><td><code id="mutate_other_+3A_var.weight">var.weight</code></td>
<td>
<p>Variable to act as a weight: <code>var</code>'s where the sum of this variable exceeds 
<code>mass</code> will be kept, others set to <code>other.category</code>.</p>
</td></tr>
<tr><td><code id="mutate_other_+3A_mass">mass</code></td>
<td>
<p>Threshold for sum of <code>var.weight</code>: any <code>var</code> where the aggregated sum of <code>var.weight</code> exceeds <code>mass</code> will be kept and other <code>var</code> will be set to <code>other.category</code>. By default (<code>mass = NULL</code>), 
the value of <code>mass</code> is <code class="reqn">-\infty</code>, with a warning. You may set it explicitly to <code>-Inf</code> if you really want to avoid a warning that this function will have no effect.</p>
</td></tr>
<tr><td><code id="mutate_other_+3A_copy">copy</code></td>
<td>
<p>Should <code>.data</code> be copied? Currently only <code>TRUE</code> is supported.</p>
</td></tr>
<tr><td><code id="mutate_other_+3A_other.category">other.category</code></td>
<td>
<p>Value that infrequent entries are to be collapsed into. Defaults to <code>"Other"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> but with <code>var</code> changed so that infrequent values have the same value (<code>other.category</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
library(magrittr)

DT &lt;- data.table(City = c("A", "A", "B", "B", "C", "D"),
                 value = c(1, 9, 4, 4, 5, 11))

DT %&gt;%
  mutate_other("City", var.weight = "value", mass = 10) %&gt;%
  .[]
  
</code></pre>

<hr>
<h2 id='ngrep'>Anti-grep</h2><span id='topic+ngrep'></span>

<h3>Description</h3>

<p>It is not simple to negate a regular expression. This obviates the need 
takes the long way round: negating the corresponding <code>grepl</code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngrep(pattern, x, value = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngrep_+3A_x">x</code>, <code id="ngrep_+3A_value">value</code>, <code id="ngrep_+3A_pattern">pattern</code></td>
<td>
<p>As in <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="ngrep_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>grepl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>value</code> is <code>FALSE</code> (the default), indices of <code>x</code> which do not match the 
pattern; if <code>TRUE</code>, the values of <code>x</code> themselves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> grep("[a-h]", letters)
ngrep("[a-h]", letters)

txt &lt;- c("The", "licenses", "for", "most", "software", "are",
"designed", "to", "take", "away", "your", "freedom",
"to", "share", "and", "change", "it.",
"", "By", "contrast,", "the", "GNU", "General", "Public", "License",
"is", "intended", "to", "guarantee", "your", "freedom", "to",
"share", "and", "change", "free", "software", "--",
"to", "make", "sure", "the", "software", "is",
"free", "for", "all", "its", "users")

 grep("[gu]", txt, value = TRUE)
ngrep("[gu]", txt, value = TRUE)

</code></pre>

<hr>
<h2 id='prohibit_unequal_length_vectors'>Prohibit unequal length vectors</h2><span id='topic+prohibit_unequal_length_vectors'></span>

<h3>Description</h3>

<p>Tests whether all vectors have the same length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prohibit_unequal_length_vectors(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prohibit_unequal_length_vectors_+3A_...">...</code></td>
<td>
<p>Vectors to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error message unless all of <code>...</code> have the same length in which case <code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='prohibit_vector_recycling'>Prohibit vector recycling</h2><span id='topic+prohibit_vector_recycling'></span><span id='topic+prohibit_vector_recycling.MAXLENGTH'></span>

<h3>Description</h3>

<p>Tests (harshly) whether the vectors can be recycled safely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prohibit_vector_recycling(...)

prohibit_vector_recycling.MAXLENGTH(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prohibit_vector_recycling_+3A_...">...</code></td>
<td>
<p>A list of vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error message if the vectors are of different length (unless the alternative length is 1). 
The functions differ in their return values on success: <code>prohibit_vector_recycling.MAXLENGTH</code> 
returns the maximum of the lengths whereas <code>prohibit_vector_recyling</code> returns <code>NULL</code>. 
(Both functions return their values invisibly.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Returns nothing because they are of the same length
prohibit_vector_recycling(c(2, 2), c(2, 2))
# Returns nothing also, because the only different length is 1
prohibit_vector_recycling(c(2, 2), 1)
# Returns an error:
prohibit_vector_recycling(c(2, 2), 1, c(3, 3, 3))

## End(Not run)
</code></pre>

<hr>
<h2 id='provide.dir'>Provide directory</h2><span id='topic+provide.dir'></span>

<h3>Description</h3>

<p>Provide directory. Create directory only if it does not exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>provide.dir(path, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="provide.dir_+3A_path">path</code></td>
<td>
<p>Path to create.</p>
</td></tr>
<tr><td><code id="provide.dir_+3A_...">...</code></td>
<td>
<p>Passed to <code>dir.create</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>path</code> on success, the empty string <code>character(1)</code> on failure.
</p>

<hr>
<h2 id='provide.file'>Provide a file</h2><span id='topic+provide.file'></span>

<h3>Description</h3>

<p>Present since <code>hutils v1.5.0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>provide.file(path, on_failure = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="provide.file_+3A_path">path</code></td>
<td>
<p>A string. The path to a filename that requires existence.</p>
</td></tr>
<tr><td><code id="provide.file_+3A_on_failure">on_failure</code></td>
<td>
<p>The return value on failure. By default, an empty string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>path</code> for success. Or <code>on_failure</code> if the <code>path</code> cannot be provided.
</p>

<hr>
<h2 id='replace_pattern_in'>Replace string pattern in text file</h2><span id='topic+replace_pattern_in'></span>

<h3>Description</h3>

<p>Replace string pattern in text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_pattern_in(
  file_contents,
  replace,
  basedir = ".",
  dir_recursive = TRUE,
  reader = readLines,
  file_pattern = "\\.(R|r)(nw|md)?$",
  file_contents_perl = TRUE,
  file_contents_fixed = FALSE,
  file_contents_ignore_case = FALSE,
  writer = writeLines
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_pattern_in_+3A_file_contents">file_contents</code></td>
<td>
<p>Character string containing a regular expression to be matched in the 
given character vector. Passed to <code>pattern</code> in <code><a href="base.html#topic+grep">gsub</a></code>.</p>
</td></tr>
<tr><td><code id="replace_pattern_in_+3A_replace">replace</code></td>
<td>
<p>The replacement, passed to <code>replacement</code> in <code><a href="base.html#topic+grep">gsub</a></code>.</p>
</td></tr>
<tr><td><code id="replace_pattern_in_+3A_basedir">basedir</code></td>
<td>
<p>The root of the directory tree in which files will be searched recursively.</p>
</td></tr>
<tr><td><code id="replace_pattern_in_+3A_dir_recursive">dir_recursive</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Search within subdirectories of <code>basedir</code>?</p>
</td></tr>
<tr><td><code id="replace_pattern_in_+3A_reader">reader</code></td>
<td>
<p>A function, akin to <code>base::readLines</code>, the default, that accepts a filename and returns a character vector.</p>
</td></tr>
<tr><td><code id="replace_pattern_in_+3A_file_pattern">file_pattern</code></td>
<td>
<p>A regular expression passed to <code>list.files(pattern = file.ext)</code>.
By default, <code>"\.(R|r)(nw|md)?$"</code>, i.e. all R and Sweave files. (Does not have to be a file extension.)</p>
</td></tr>
<tr><td><code id="replace_pattern_in_+3A_file_contents_perl">file_contents_perl</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Should <code>file_contents</code> 
be interpreted as a <code>perl</code> regex?</p>
</td></tr>
<tr><td><code id="replace_pattern_in_+3A_file_contents_fixed">file_contents_fixed</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) Should <code>file_contents</code> 
be interpreted as a <code>fixed</code> regex?</p>
</td></tr>
<tr><td><code id="replace_pattern_in_+3A_file_contents_ignore_case">file_contents_ignore_case</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) As in <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="replace_pattern_in_+3A_writer">writer</code></td>
<td>
<p>A function that will rewrite the file from the character vector read in.</p>
</td></tr>
</table>

<hr>
<h2 id='report_error'>Report errors and warnings</h2><span id='topic+report_error'></span>

<h3>Description</h3>

<p>Provides a consistent style for errors and warnings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report_error(
  faulty_input,
  error_condition,
  requirement,
  context = NULL,
  advice,
  hint = NULL,
  halt = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_error_+3A_faulty_input">faulty_input</code></td>
<td>
<p>Unquoted function argument that is the cause of the error condition.</p>
</td></tr>
<tr><td><code id="report_error_+3A_error_condition">error_condition</code></td>
<td>
<p>A sentence explaining the condition that invoked the error.</p>
</td></tr>
<tr><td><code id="report_error_+3A_requirement">requirement</code></td>
<td>
<p>A sentence that explains what is required.</p>
</td></tr>
<tr><td><code id="report_error_+3A_context">context</code></td>
<td>
<p>(Optional) A sentence that contextualizes the error</p>
</td></tr>
<tr><td><code id="report_error_+3A_advice">advice</code></td>
<td>
<p>Advice for the user to avoid the error.</p>
</td></tr>
<tr><td><code id="report_error_+3A_hint">hint</code></td>
<td>
<p>If the input can be guessed,</p>
</td></tr>
<tr><td><code id="report_error_+3A_halt">halt</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Should the function signal an error and halt?</p>
</td></tr>
</table>

<hr>
<h2 id='RQ'>Shorthand for <code>requireNamespace</code></h2><span id='topic+RQ'></span>

<h3>Description</h3>

<p>Present since <code>hutils v1.2.0</code>. Alias for <code>if (!requireNamespace(pkg, quietly = TRUE))</code> <em>yes</em> <code>else</code> <em>no</em>.
Typical use-case would be <code>RQ(pkg, install.packages("pkg"))].</code>
</p>
<p>Default values for <code>yes</code> and <code>no</code> from <code>hutils v1.5.0</code>.
</p>
<p>This function is not recommended for use in scripts as it is a bit cryptic; its 
use-case is for bash scripts and the like where calls like this would otherwise
be frequent and cloud the message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RQ(pkg, yes = NULL, no = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RQ_+3A_pkg">pkg</code></td>
<td>
<p>Package to test whether the package is not yet installed.</p>
</td></tr>
<tr><td><code id="RQ_+3A_yes">yes</code></td>
<td>
<p>Response if <code>pkg</code> is <strong>not</strong> installed.</p>
</td></tr>
<tr><td><code id="RQ_+3A_no">no</code></td>
<td>
<p>(optional) Response if <code>pkg</code> is installed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 RQ("dplyr", "dplyr needs installing")

## End(Not run)


</code></pre>

<hr>
<h2 id='samp'>Safer sampler</h2><span id='topic+samp'></span>

<h3>Description</h3>

<p>Present since <code>hutils v1.4.0</code>. 
Same as <code><a href="base.html#topic+sample">sample</a></code>, but avoiding the behaviour when 
<code>length(x) == 1L</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samp(x, size = length(x), replace = size &gt; length(x), loud = TRUE, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samp_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="samp_+3A_size">size</code></td>
<td>
<p>A non-negative integer, the number of items to return.</p>
</td></tr>
<tr><td><code id="samp_+3A_replace">replace</code></td>
<td>
<p>Should the sampling be done with replacement? Defaults to <code>TRUE</code> if 
<code>size &gt; length(x)</code>, with a message.</p>
</td></tr>
<tr><td><code id="samp_+3A_loud">loud</code></td>
<td>
<p>If <code>TRUE</code>, the default, any behaviour known to be different from 
<code><a href="base.html#topic+sample">sample</a></code> is flagged with a message.</p>
</td></tr>
<tr><td><code id="samp_+3A_prob">prob</code></td>
<td>
<p>As in <code><a href="base.html#topic+sample">sample</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>samp(1:5)
sample(1:5)

samp(1:5, size = 10)  # no error
tryCatch(sample(1:5, size = 10), 
         error = function(e) print(e$m))

samp(5, size = 3)
sample(5, size = 3)


</code></pre>

<hr>
<h2 id='select_grep'>Select names matching a pattern</h2><span id='topic+select_grep'></span>

<h3>Description</h3>

<p>Select names matching a pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_grep(
  DT,
  patterns,
  .and = NULL,
  .but.not = NULL,
  ignore.case = FALSE,
  perl = TRUE,
  fixed = FALSE,
  useBytes = FALSE,
  invert = FALSE,
  .warn.fixed.mismatch = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_grep_+3A_dt">DT</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="select_grep_+3A_patterns">patterns</code></td>
<td>
<p>Regular expressions to be matched against the names of <code>DT</code>. If <code>length(patterns) &gt; 1</code> the patterns are concatenated using alternation.</p>
</td></tr>
<tr><td><code id="select_grep_+3A_.and">.and</code></td>
<td>
<p>Character or integer positions of names to select, regardless of whether or not they are matched by <code>patterns</code>.</p>
</td></tr>
<tr><td><code id="select_grep_+3A_.but.not">.but.not</code></td>
<td>
<p>Character or integer positions of names to drop, regardless of whether or not they are matched by <code>patterns</code> or whether they are explicitly added by <code>.and</code>.</p>
</td></tr>
<tr><td><code id="select_grep_+3A_ignore.case">ignore.case</code>, <code id="select_grep_+3A_perl">perl</code>, <code id="select_grep_+3A_fixed">fixed</code>, <code id="select_grep_+3A_usebytes">useBytes</code>, <code id="select_grep_+3A_invert">invert</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+grep">grep</a></code>. Note that <code>perl = TRUE</code> by default (unlike <code>grep</code>) unless <code>fixed = TRUE</code> (and <code>perl</code> is missing).</p>
</td></tr>
<tr><td><code id="select_grep_+3A_.warn.fixed.mismatch">.warn.fixed.mismatch</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) If <code>TRUE</code>, the default, selecting <code>fixed = TRUE</code> with <code>perl = TRUE</code> or <code>ignore.case = TRUE</code> results in <code>perl</code> and <code>ignore.case</code> being reset to <code>FALSE</code> with a warning (as in <code>grep</code>), even if it makes no difference to the columns eventually selected. If <code>FALSE</code> unambiguous results are allowed; if <code>ignore.case = TRUE</code> and <code>fixed = TRUE</code>, the result is <strong>unambiguous</strong> if <code>select_grep(DT, tolower(patterns), fixed = TRUE)</code> and <code>select_grep(DT, toupper(patterns), fixed = TRUE)</code> are identical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DT</code> with the selected names.
</p>
<p>integer vector of positions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
dt &lt;- data.table(x1 = 1, x2 = 2, y = 0)
select_grep(dt, "x")
select_grep(dt, "x", .and = "y")
select_grep(dt, "x", .and = "y", .but.not = "x2")

</code></pre>

<hr>
<h2 id='select_which'>Select columns satisfying a condition</h2><span id='topic+select_which'></span>

<h3>Description</h3>

<p>Select columns satisfying a condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_which(DT, Which, .and.dots = NULL, checkDT = TRUE, .and.grep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_which_+3A_dt">DT</code></td>
<td>
<p>A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="select_which_+3A_which">Which</code></td>
<td>
<p>A function that takes a vector and returns <code>TRUE</code> or <code>FALSE</code>. <code>TRUE</code> columns are selected.</p>
</td></tr>
<tr><td><code id="select_which_+3A_.and.dots">.and.dots</code></td>
<td>
<p>Optional extra columns to include. May be a character vector of <code>names(DT)</code> or numeric (positions) or logical. If provided, the columns so added (if they do not satisfy <code>Which</code>) will be after all the columns <code>Which</code> do so satisfy.</p>
</td></tr>
<tr><td><code id="select_which_+3A_checkdt">checkDT</code></td>
<td>
<p>If <code>TRUE</code> (the default), an informative error message is provided if <code>DT</code> is not a <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="select_which_+3A_.and.grep">.and.grep</code></td>
<td>
<p>A character vector of regular expressions to match to the names
of <code>DT</code>. The corresponding columns will be included in the result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DT</code> with the selected variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
DT &lt;- data.table(x = 1:5,
                 y = letters[1:5],
                 AB = c(NA, TRUE, FALSE))
select_which(DT, anyNA, .and.dots = "y")
</code></pre>

<hr>
<h2 id='selector'>Fast selection of <code>data.table</code> columns</h2><span id='topic+selector'></span>

<h3>Description</h3>

<p>Present since <code>hutils 1.2.0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selector(DT, ..., cols = NULL, preserve.key = TRUE, shallow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selector_+3A_dt">DT</code></td>
<td>
<p>A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="selector_+3A_...">...</code></td>
<td>
<p>Unquoted columns names.</p>
</td></tr>
<tr><td><code id="selector_+3A_cols">cols</code></td>
<td>
<p>Character vector of column names.</p>
</td></tr>
<tr><td><code id="selector_+3A_preserve.key">preserve.key</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Reapply the key (if <code>DT</code> has one)?</p>
</td></tr>
<tr><td><code id="selector_+3A_shallow">shallow</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) Should the result be a shallow
<code><a href="data.table.html#topic+copy">copy</a></code> of 
<code>DT</code>'s columns or should the columns be assigned by reference? If <code>TRUE</code>,
any modification to the result also modifies the selected columns in <code>DT</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DT</code> with the selected columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RQ("nycflights13", no = {
 library(nycflights13)
 library(data.table)
 fs &lt;- as.data.table(flights)
 fs1 &lt;- selector(fs, year, month, day, arr_delay)
 fs1[, arr_delay := NA]
})
</code></pre>

<hr>
<h2 id='seq_nrow'>Generate sequence of row numbers</h2><span id='topic+seq_nrow'></span>

<h3>Description</h3>

<p>Generate sequence of row numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_nrow(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_nrow_+3A_x">x</code></td>
<td>
<p>An object that admits an <code>nrow</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent to <code>seq_len(nrow(x))</code>
</p>

<hr>
<h2 id='set_cols_first'>Put columns first or last</h2><span id='topic+set_cols_first'></span><span id='topic+set_cols_last'></span><span id='topic+set_colsuborder'></span>

<h3>Description</h3>

<p>Reorder columns of a <code>data.table</code> (via <code>setcolorder</code>) so that particular columns 
appear first (or last), or in a particular order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_cols_first(DT, cols, intersection = TRUE)

set_cols_last(DT, cols, intersection = TRUE)

set_colsuborder(DT, cols, intersection = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_cols_first_+3A_dt">DT</code></td>
<td>
<p>A data.table.</p>
</td></tr>
<tr><td><code id="set_cols_first_+3A_cols">cols</code></td>
<td>
<p>Character vector of columns to put before (after) all others or, in the case of <code>set_colsuborder</code>,
a vector of columns in the order requested.</p>
</td></tr>
<tr><td><code id="set_cols_first_+3A_intersection">intersection</code></td>
<td>
<p>Use the intersection of the names of <code>DT</code> and <code>cols</code>. If <code>FALSE</code> 
any <code>cols</code> are not the names of <code>DT</code>, the function may error on behalf of <code>data.table</code>.
Not available for <code>set_colsuborder</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of <code>set_colsuborder</code> the group of columns <code>cols</code> occupy the same positions
in <code>DT</code> but in a different order. See examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
  
DT &lt;- data.table(y = 1:5, z = 11:15, x = letters[1:5])
set_cols_first(DT, "x")[]
set_cols_last(DT, "x")[]
set_colsuborder(DT, c("x", "y"))[]

</code></pre>

<hr>
<h2 id='swap'>Swap assignment</h2><span id='topic+swap'></span><span id='topic++25+3C-+3E+25'></span>

<h3>Description</h3>

<p>Swap values simultaneously. Present since <code>hutils 1.4.0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %&lt;-&gt;% value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_+3A_x">x</code>, <code id="swap_+3A_value">value</code></td>
<td>
<p>Objects whose values are to be reassigned by swapping.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> invisibly. Called for its side-effect: the values
of <code>x</code> and <code>value</code> are swapped. So
</p>
<pre>x %&lt;-&gt;% value</pre> 
<p>is equivalent to
</p>
<pre>temp &lt;- x
x &lt;- value
value &lt;- temp
rm(temp)</pre>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 1
b &lt;- 2
a %&lt;-&gt;% b
a
b

</code></pre>

<hr>
<h2 id='Switch'>Vectorized switch</h2><span id='topic+Switch'></span>

<h3>Description</h3>

<p>Present since <code>hutils 1.2.0</code>. Vectorized version of <code>switch</code>. Used to avoid or make clearer the result of 
<code>if_else(Expr == , ..1, if_else(Expr == , ..2, ...))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Switch(Expr, ..., DEFAULT, IF_NA = NULL, MUST_MATCH = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Switch_+3A_expr">Expr</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="Switch_+3A_...">...</code></td>
<td>
<p>As in <code><a href="base.html#topic+switch">switch</a></code>, a list of named alternatives.
Unlike <code>switch</code>, unnamed vectors are taken to match <code>""</code>. Likewise, 
<code>NA</code> values in <code>Expr</code> must be assigned via <code>IF_NA</code>.</p>
</td></tr>
<tr><td><code id="Switch_+3A_default">DEFAULT</code></td>
<td>
<p>A mandatory default value should any name of <code>...</code> be left unmatched.</p>
</td></tr>
<tr><td><code id="Switch_+3A_if_na">IF_NA</code></td>
<td>
<p>Optional value to replace missing (<code>NA_character_</code>) values in <code>Expr</code>.</p>
</td></tr>
<tr><td><code id="Switch_+3A_must_match">MUST_MATCH</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) Must every value in <code>Expr</code> be matched by a conversion in <code>...</code>? 
If <code>TRUE</code> any output equal to the value of <code>DEFAULT</code> is an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For every element of <code>...</code> whose name matches an element of <code>Expr</code>, 
that element's value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Switch(c("a", "b", "c", "a"),
       "a" = 1, 
       "b" = 2, 
       "c" = 3, 
       "4" = 4, 
       DEFAULT = 0)

</code></pre>

<hr>
<h2 id='unique-keys'>Unique keys</h2><span id='topic+unique-keys'></span><span id='topic+has_unique_key'></span><span id='topic+set_unique_key'></span>

<h3>Description</h3>

<p>A <code>data.table</code>'s <code>key</code> need not be unique, but there are frequently circumstances
where non-unique keys can wreak havoc.
<code>has_unique_key</code> reports the existence of a unique key, and 
<code>set_unique_key</code> both sets and ensures the uniqueness of keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_unique_key(DT)

set_unique_key(DT, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique-keys_+3A_dt">DT</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="unique-keys_+3A_...">...</code></td>
<td>
<p>keys to set</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>has_unique_key</code> returns <code>TRUE</code> if <code>DT</code> has a unique key, <code>FALSE</code> otherwise. 
<code>set_unique_key</code> runs <code>setkey(DT, ...)</code> then checks whether the key is unique, returning the keyed 
<code>data.table</code> if the key is unique, or an error message otherwise.
</p>

<hr>
<h2 id='weight2rows'>Expand a weighted data frame to an equivalent unweighted</h2><span id='topic+weight2rows'></span>

<h3>Description</h3>

<p>Present since <code>v1.0.0</code>.
Argument <code>rows.out</code> available since <code>v1.3.0</code>; 
<code>rows.out &lt; 1</code> supported since <code>v 1.4.0</code>.
Argument <code>discard_weight.var</code> available since <code>v1.3.0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight2rows(DT, weight.var, rows.out = NULL, discard_weight.var = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight2rows_+3A_dt">DT</code></td>
<td>
<p>A <code>data.table</code>. Will be converted to one if possible.</p>
</td></tr>
<tr><td><code id="weight2rows_+3A_weight.var">weight.var</code></td>
<td>
<p>Variable in <code>DT</code> to be used as weights.</p>
</td></tr>
<tr><td><code id="weight2rows_+3A_rows.out">rows.out</code></td>
<td>
<p>If not <code>NULL</code> (the default) specifies the number of rows in the result;
otherwise the number of rows will be <code>sum(DT[[weight.var]])</code>.
(Due to rounding, this figures are inexact.)
</p>
<p>Since <code>v1.4.0</code>, if <code>0 &lt; rows.out &lt; 1</code> then taken to be a sample of
the unweighted table. (So <code>rows.out = 0.1</code> would give a 10% sample.)</p>
</td></tr>
<tr><td><code id="weight2rows_+3A_discard_weight.var">discard_weight.var</code></td>
<td>
<p>If <code>FALSE</code>, the default, <code>weight.var</code>
in <code>DT</code> will be <code>1</code> for each row in the result or a new weight 
if <code>rows.out</code> is given. Otherwise, <code>TRUE</code> drops the column entirely.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DT</code> but with the number of rows expanded to <code>sum(DT[[weight.var]])</code> to reflect the weighting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
DT &lt;- data.table(x = 1:5, y = c(1, 1, 1, 1, 2))
weight2rows(DT, "y")
weight2rows(DT, "y", rows.out = 5)

</code></pre>

<hr>
<h2 id='weighted_ntile'>Weighted (ranked) quantiles</h2><span id='topic+weighted_ntile'></span>

<h3>Description</h3>

<p>Weighted (ranked) quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_ntile(vector, weights = rep(1, times = length(vector)), n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_ntile_+3A_vector">vector</code></td>
<td>
<p>The vector for which quantiles are desired.</p>
</td></tr>
<tr><td><code id="weighted_ntile_+3A_weights">weights</code></td>
<td>
<p>The weights associated with the vector. None should be <code>NA</code> or zero.</p>
</td></tr>
<tr><td><code id="weighted_ntile_+3A_n">n</code></td>
<td>
<p>The number of quantiles desired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With a short-length vector, or with weights of a high variance, the results may be unexpected.
</p>


<h3>Value</h3>

<p>A vector of integers corresponding to the ntiles. (As in <code>dplyr::ntile</code>.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>weighted_ntile(1:10, n = 5)
weighted_ntile(1:10, weights = c(rep(4, 5), rep(1, 5)), n = 5)
</code></pre>

<hr>
<h2 id='weighted_quantile'>Weighted quantile</h2><span id='topic+weighted_quantile'></span>

<h3>Description</h3>

<p><code>quantile</code> when the values are weighted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_quantile(v, w = NULL, p = (0:4)/4, v_is_sorted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_quantile_+3A_v">v</code></td>
<td>
<p>A vector from which sample quantiles are desired.</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_w">w</code></td>
<td>
<p>Weights corresponding to each <code>v</code>.</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_p">p</code></td>
<td>
<p>Numeric vector of probabilities. Missing values or values outside
<code class="reqn">[0, 1]</code> raise an error.</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_v_is_sorted">v_is_sorted</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) If <code>TRUE</code>, ordering
<code>v</code> is assumed to be sorted. Only set to <code>TRUE</code> when it is certain
that <code>v</code> is sorted (as within groups of tables).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code>p</code>, the quantiles corresponding
to each element of <code>p</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
