<!DOCTYPE html><html><head><title>Help for package surtvep</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {surtvep}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baseline'><p>calculating baseline hazard and baseline cumulative hazard using the result from a <code>coxtv</code> or <code>coxtp</code> object</p></a></li>
<li><a href='#confint.coxtp'><p>get confidence intervals of time-varying coefficients from a fitted object</p></a></li>
<li><a href='#coxtp'><p>fit a Cox non-proportional hazards model with P-spline or Smoothing-spline, with penalization tuning parameter chosen by information criteria or cross-validation</p></a></li>
<li><a href='#coxtv'><p>fit a Cox non-proportional hazards model</p></a></li>
<li><a href='#cv.coxtp'><p>fit a cross-validated Cox non-proportional hazards model with P-spline or Smoothing-spline where penalization tuning parameter is provided by cross-validation</p></a></li>
<li><a href='#ExampleData'><p>example data with 2000 observations of 2 continuous variables</p></a></li>
<li><a href='#ExampleDataBinary'><p>example data with 2000 observations of 2 binary variables</p></a></li>
<li><a href='#get.tvcoef'><p>helper function to get time-varying coefficients</p></a></li>
<li><a href='#IC'><p>calculating information criteria from a <code>coxtp</code> object</p></a></li>
<li><a href='#plot.baseline'><p>plotting the baseline hazard</p></a></li>
<li><a href='#plot.coxtp'><p>plotting results from a fitted <code>coxtp</code> object</p></a></li>
<li><a href='#plot.coxtv'><p>plotting results from a fitted <code>coxtv</code> object</p></a></li>
<li><a href='#StrataExample'><p>example data for stratified model illustration</p></a></li>
<li><a href='#support'><p>Study to Understand Prognoses Preferences Outcomes and Risks of Treatment</p></a></li>
<li><a href='#tvef.ph'><p>testing the proportional hazards assumption from a <code>coxtv</code> or <code>coxtp</code> object</p></a></li>
<li><a href='#tvef.zero'><p>testing the significance of the covariates from a <code>coxtv</code> or <code>coxtp</code> object</p></a></li>
<li><a href='#tvef.zero.time'><p>testing the significance of the covariates from a <code>coxtv</code> or <code>coxtp</code> object using a Wald test statistic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Cox Non-Proportional Hazards Model with Time-Varying
Coefficients</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/UM-KevinHe/surtvep">https://github.com/UM-KevinHe/surtvep</a>,
<a href="https://um-kevinhe.github.io/surtvep/">https://um-kevinhe.github.io/surtvep/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/UM-KevinHe/surtvep/issues">https://github.com/UM-KevinHe/surtvep/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Cox non-proportional hazards models with time-varying coefficients. 
    Both unpenalized procedures (Newton and proximal Newton) and penalized procedures 
    (P-splines and smoothing splines) are included using B-spline basis functions for 
    estimating time-varying coefficients. For penalized procedures, cross validations, 
    mAIC, TIC or GIC are implemented to select tuning parameters. Utilities for 
    carrying out post-estimation visualization, summarization, point-wise confidence 
    interval and hypothesis testing are also provided.
    For more information, see Wu et al. (2022) &lt;<a href="https://doi.org/10.1007%2Fs10985-021-09544-2">doi:10.1007/s10985-021-09544-2</a>&gt; and 
    Luo et al. (2023) &lt;<a href="https://doi.org/10.1177%2F09622802231181471">doi:10.1177/09622802231181471</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, splines, ggplot2, ggpubr, stats, tibble, rlang</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-16 20:46:56 UTC; lingfengluo</td>
</tr>
<tr>
<td>Author:</td>
<td>Lingfeng Luo [aut, cre],
  Wenbo Wu [aut],
  Kevin He [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lingfeng Luo &lt;lfluo@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-17 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='baseline'>calculating baseline hazard and baseline cumulative hazard using the result from a <code>coxtv</code> or <code>coxtp</code> object</h2><span id='topic+baseline'></span>

<h3>Description</h3>

<p>The baseline estimation is the baseline hazard at each observed failure time when
holding all the covariates to be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline_+3A_fit">fit</code></td>
<td>
<p>model from <code>coxtv</code> or <code>coxtp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three components:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>the unique observed failure times.</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>the baseline hazard corresponding to each unique failure time point.</p>
</td></tr>
<tr><td><code>cumulHaz</code></td>
<td>
<p>the cumulative baseline hazard corresponding to each unique failure time point.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleData)
z &lt;- ExampleData$z
time  &lt;- ExampleData$time
event &lt;- ExampleData$event

fit   &lt;- coxtv(event = event, z = z, time = time)
base.est &lt;- baseline(fit)


</code></pre>

<hr>
<h2 id='confint.coxtp'>get confidence intervals of time-varying coefficients from a fitted object</h2><span id='topic+confint.coxtp'></span><span id='topic+confint.coxtv'></span>

<h3>Description</h3>

<p>Get confidence intervals of time-varying coefficients from a fitted <code>coxtv</code> or <code>coxtp</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxtp'
confint(object, parm, level = 0.95, time, ...)

## S3 method for class 'coxtv'
confint(object, parm, level = 0.95, time, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.coxtp_+3A_object">object</code></td>
<td>
<p>fitted <code>"coxtv"</code> model.</p>
</td></tr>
<tr><td><code id="confint.coxtp_+3A_parm">parm</code></td>
<td>
<p>the names of parameters.</p>
</td></tr>
<tr><td><code id="confint.coxtp_+3A_level">level</code></td>
<td>
<p>the confidence level. The default value is 0.95.</p>
</td></tr>
<tr><td><code id="confint.coxtp_+3A_time">time</code></td>
<td>
<p>the time points for which the confidence intervals to be estimated.
The default value is the unique observed event times in the dataset fitting the time-varying effects model.</p>
</td></tr>
<tr><td><code id="confint.coxtp_+3A_...">...</code></td>
<td>
<p>other parameters to function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each element corresponds to one of the parameters specified in <code>parm</code>. Each element in the
list is a matrix, with rows corresponding to the specified <code>time</code> points and three columns representing the
estimated values of the parameter, and the lower and upper bounds of the confidence interval at the specified
confidence <code>level</code>. The length of the list is determined by the number of parameters in <code>parm</code>, and each matrix
has rows equal to the number of specified <code>time</code> points.
</p>
<p>A list where each element corresponds to one of the parameters specified in <code>parm</code>. Each element in the
list is a matrix, with rows corresponding to the specified <code>time</code> points and three columns representing the
estimated values of the parameter, and the lower and upper bounds of the confidence interval at the specified
confidence <code>level</code>. The length of the list is determined by the number of parameters in <code>parm</code>, and each matrix
has rows equal to the number of specified <code>time</code> points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ExampleData)
z &lt;- ExampleData$z
time &lt;- ExampleData$time
event &lt;- ExampleData$event
fit &lt;- coxtp(event = event, z = z, time = time)
IC  &lt;- IC(fit)
confint(IC$model.mAIC)


data(ExampleData)
z &lt;- ExampleData$z
time &lt;- ExampleData$time
event &lt;- ExampleData$event
fit &lt;- coxtv(event = event, z = z, time = time)
confint &lt;- confint(fit)

</code></pre>

<hr>
<h2 id='coxtp'>fit a Cox non-proportional hazards model with P-spline or Smoothing-spline, with penalization tuning parameter chosen by information criteria or cross-validation</h2><span id='topic+coxtp'></span>

<h3>Description</h3>

<p>Fit a Cox non-proportional hazards model via penalized maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxtp(
  event,
  z,
  time,
  strata = NULL,
  penalty = "Smooth-spline",
  nsplines = 8,
  lambda = c(0.1, 1, 10),
  degree = 3L,
  knots = NULL,
  ties = "Breslow",
  tol = 1e-06,
  iter.max = 20L,
  method = "ProxN",
  gamma = 1e+08,
  btr = "dynamic",
  tau = 0.5,
  stop = "ratch",
  parallel = FALSE,
  threads = 2L,
  fixedstep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxtp_+3A_event">event</code></td>
<td>
<p>failure event response variable of length <code>nobs</code>, where <code>nobs</code> denotes the number of observations. It should be a vector containing 0 or 1.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_z">z</code></td>
<td>
<p>input covariate matrix, with <code>nobs</code> rows and <code>nvars</code> columns; each row is an observation.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_time">time</code></td>
<td>
<p>observed event times, which should be a vector with non-negative values.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_strata">strata</code></td>
<td>
<p>a vector of indicators for stratification.
Default = <code>NULL</code> (i.e. no stratification group in the data), an unstratified model is implemented.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_penalty">penalty</code></td>
<td>
<p>a character string specifying the spline term for the penalized Newton method.
This term is added to the log-partial likelihood, and the penalized log-partial likelihood serves as the new objective function to
control the smoothness of the time-varying coefficients.
Default is <code>P-spline</code>. Three options are <code>P-spline</code>, <code>Smooth-spline</code> and <code>NULL</code>.
If <code>NULL</code>, the method will be the same as <code>coxtv</code> (unpenalized time-varying effects models) and <code>lambda</code> (defined below)
will be set as 0.
</p>
<p><code>P-spline</code> stands for Penalized B-spline. It combines the B-spline basis with a discrete quadratic penalty on the difference of basis coefficients between adjacent knots.
When <code>lambda</code> goes to infinity, the time-varying effects are reduced to be constant.
</p>
<p><code>Smooth-spline</code> refers to the Smoothing-spline, the derivative-based penalties combined with B-splines. See <code>degree</code> for different choices.
When <code>degree=3</code>, we use the cubic B-spline penalizing the second-order derivative, which reduces the time-varying effect to a linear term when <code>lambda</code> goes to infinity.
When <code>degree=2</code>, we use the quadratic B-spline penalizing first-order derivative, which reduces the time-varying effect to a constant when <code>lambda</code> goes to infinity. See Wood (2017) for details.
</p>
<p>If <code>P-spline</code> or <code>Smooth-spline</code>, then <code>lambda</code> is initialized as a sequence (0.1, 1, 10). Users can modify <code>lambda</code>. See details in <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_nsplines">nsplines</code></td>
<td>
<p>number of basis functions in the splines to span the time-varying effects. The default value is 8.
We use the R function <code>splines::bs</code> to generate the B-splines.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_lambda">lambda</code></td>
<td>
<p>a user-specified <code>lambda</code> sequence as the penalization coefficients in front of the spline term specified by <code>penalty</code>.
This is the tuning parameter for penalization. The function <code>IC</code> can be used to select the best tuning parameter based on the information criteria.
Alternatively, cross-validation can be used via the <code>cv.coxtp</code> function.
When <code>lambda</code> is <code>0</code>, Newton method without penalization is fitted.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_degree">degree</code></td>
<td>
<p>degree of the piecewise polynomial for generating the B-spline basis functions&mdash;default is 3 for cubic splines.
<code>degree = 2</code> results in the quadratic B-spline basis functions.
</p>
<p>If the <code>penalty</code> is <code>P-spline</code> or <code>NULL</code>, <code>degree</code>'s default value is 3.
</p>
<p>If the <code>penalty</code> is <code>Smooth-spline</code>, <code>degree</code>'s default value is 2.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_knots">knots</code></td>
<td>
<p>the internal knot locations (breakpoints) that define the B-splines.
The number of the internal knots should be <code>nsplines</code>-<code>degree</code>-1.
If <code>NULL</code>, the locations of knots are chosen as quantiles of distinct failure time points.
This choice leads to more stable results in most cases.
Users can specify the internal knot locations by themselves.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_ties">ties</code></td>
<td>
<p>a character string specifying the method for tie handling. If there are no tied events,
the methods are equivalent.
By default <code>"Breslow"</code> uses the Breslow approximation, which can be faster when many ties are present.
If <code>ties = "none"</code>, no approximation will be used to handle ties.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_tol">tol</code></td>
<td>
<p>tolerance used for stopping the algorithm. See details in <code>stop</code> below.
The default value is  <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_iter.max">iter.max</code></td>
<td>
<p>maximum iteration number if the stopping criterion specified by <code>stop</code> is not satisfied. The default value is  20.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_method">method</code></td>
<td>
<p>a character string specifying whether to use Newton method or proximal Newton method.  If <code>Newton</code> then Hessian is used,
while the default method <code>"ProxN"</code> implements the proximal Newton which can be faster and more stable when there exists ill-conditioned second-order information of the log-partial likelihood.
See details in Wu et al. (2022).</p>
</td></tr>
<tr><td><code id="coxtp_+3A_gamma">gamma</code></td>
<td>
<p>parameter for proximal Newton method <code>"ProxN"</code>. The default value is <code>1e8</code>.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_btr">btr</code></td>
<td>
<p>a character string specifying the backtracking line-search approach. <code>"dynamic"</code> is a typical way to perform backtracking line-search.
See details in Convex Optimization by Boyd and Vandenberghe (2004).
<code>"static"</code> limits Newton's increment and can achieve more stable results in some extreme cases, such as ill-conditioned second-order information of the log-partial likelihood,
which usually occurs when some predictors are categorical with low frequency for some categories.
Users should be careful with <code>static</code>, as this may lead to under-fitting.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_tau">tau</code></td>
<td>
<p>a positive scalar used to control the step size inside the backtracking line-search. The default value is 0.5.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_stop">stop</code></td>
<td>
<p>a character string specifying the stopping rule to determine convergence.
<code>"incre"</code> means we stop the algorithm when Newton's increment is less than the <code>tol</code>. See details in Convex Optimization (Chapter 10) by Boyd and Vandenberghe (2004).
<code>"relch"</code> means we stop the algorithm when the <code class="reqn">(loglik(m)-loglik(m-1))/(loglik(m))</code> is less than the <code>tol</code>,
where <code class="reqn">loglik(m)</code> denotes the log-partial likelihood at iteration step m.
<code>"ratch"</code> means we stop the algorithm when <code class="reqn">(loglik(m)-loglik(m-1))/(loglik(m)-loglik(0))</code> is less than the <code>tol</code>.
<code>"all"</code> means we stop the algorithm when all the stopping rules (<code>"incre"</code>, <code>"relch"</code>, <code>"ratch"</code>) are met.
The default value is <code>ratch</code>.
If <code>iter.max</code> is achieved, it overrides any stop rule for algorithm termination.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, then the parallel computation is enabled. The number of threads in use is determined by <code>threads</code>.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_threads">threads</code></td>
<td>
<p>an integer indicating the number of threads to be used for parallel computation. The default value is <code>2</code>. If <code>parallel</code> is false, then the value of <code>threads</code> has no effect.</p>
</td></tr>
<tr><td><code id="coxtp_+3A_fixedstep">fixedstep</code></td>
<td>
<p>if <code>TRUE</code>, the algorithm will be forced to run <code>iter.max</code> steps regardless of the stopping criterion specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of models implied by <code>lambda.spline</code> is fit by the (proximal) Newton method.
The objective function is </p>
<p style="text-align: center;"><code class="reqn">loglik - P_{\lambda},</code>
</p>

<p>where <code class="reqn">P_{\lambda}</code> is a penalty matrix for <code>P-spline</code> or <code>Smooth-spline</code>.
The <code class="reqn">\lambda</code> is the tuning  parameter (See details in <code>lambda</code>). Users can define the initial sequence.
The function <code>IC</code> below provides different information criteria to choose the tuning parameter <code class="reqn">\lambda</code>. Another function <code>cv.coxtp</code> uses the cross-validation to choose the tuning parameter.
</p>


<h3>Value</h3>

<p>A list of objects with S3 class <code>"coxtp"</code>. The length is the same as that of <code>lambda</code>; each represents the model output with each value of the tuning parameter <code>lambda</code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the estimated time-varying coefficient for each predictor at each unique time.
It is a matrix of dimension <code>len_unique_t</code> by <code>nvars</code>,
where <code>len_unique_t</code> is the length of unique observed event <code>time</code>s.</p>
</td></tr>
<tr><td><code>bases</code></td>
<td>
<p>the basis matrix used in model fitting. If <code>ties="none"</code>, the dimension of the basis matrix is <code>nvars</code> by <code>nsplines</code>;
if <code>ties="Breslow"</code>, the dimension is <code>len_unique_t</code> by <code>nsplines</code>. The matrix is constructed using the <code>bs::splines</code> function.</p>
</td></tr>
<tr><td><code>ctrl.pts</code></td>
<td>
<p>estimated coefficient of the basis matrix of dimension <code>nvars</code> by <code>nsplines</code>.
Each row represents a covariate's coefficient on the <code>nsplines</code>-dimensional basis functions.</p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>the Hessian matrix of the log-partial likelihood, of which the dimension is <code>nsplines * nvars</code> by <code>nsplines * nvars</code>.</p>
</td></tr>
<tr><td><code>internal.knots</code></td>
<td>
<p>the internal knot locations (breakpoints) that define the B-splines.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>the spline term <code>penalty</code> specified by user.</p>
</td></tr>
<tr><td><code>theta.list</code></td>
<td>
<p>the history of <code>ctrl.pts</code> of length <code>m</code> (the length of algorithm iterations), including <code>ctrl.pts</code> for each algorithm iteration.</p>
</td></tr>
<tr><td><code>VarianceMatrix</code></td>
<td>
<p>the variance matrix of the estimated coefficients of the basis matrix,
which is the inverse of the negative Hessian matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Boyd, S., and Vandenberghe, L. (2004) Convex optimization.
<em>Cambridge University Press</em>.
<br />
</p>
<p>Gray, R. J. (1992) Flexible methods for analyzing survival data using splines, with applications to breast cancer prognosis.
<em>Journal of the American Statistical Association</em>, <strong>87(420)</strong>: 942-951.
<br />
</p>
<p>Gray, R. J. (1994) Spline-based tests in survival analysis.
<em>Biometrics</em>, <strong>50(3)</strong>: 640-652.
<br />
</p>
<p>Luo, L., He, K., Wu, W., and Taylor, J. M. (2023) Using information criteria to select smoothing parameters when analyzing survival data with time-varying coefficient hazard models.
<em>Statistical Methods in Medical Research</em>, <strong>in press</strong>.
<br />
</p>
<p>Perperoglou, A., le Cessie, S., and van Houwelingen, H. C. (2006) A fast routine for fitting Cox models with time varying effects of the covariates.
<em>Computer Methods and Programs in Biomedicine</em>, <strong>81(2)</strong>: 154-161.
<br />
</p>
<p>Wu, W., Taylor, J. M., Brouwer, A. F., Luo, L., Kang, J., Jiang, H., and He, K. (2022) Scalable proximal methods for cause-specific hazard modeling with time-varying coefficients.
<em>Lifetime Data Analysis</em>, <strong>28(2)</strong>: 194-218.
<br />
</p>
<p>Wood, S. N. (2017) P-splines with derivative based penalties and tensor product smoothing of unevenly distributed data.
<em>Statistics and Computing</em>, <strong>27(4)</strong>: 985-989.
<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC">IC</a></code>, <code><a href="#topic+cv.coxtp">cv.coxtp</a></code> <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="#topic+get.tvcoef">get.tvcoef</a></code> and <code><a href="#topic+baseline">baseline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleData)
z &lt;- ExampleData$z
time  &lt;- ExampleData$time
event &lt;- ExampleData$event

lambda  = c(0,1)
fit   &lt;- coxtp(event = event, z = z, time = time, lambda=lambda)



</code></pre>

<hr>
<h2 id='coxtv'>fit a Cox non-proportional hazards model</h2><span id='topic+coxtv'></span>

<h3>Description</h3>

<p>Fit a Cox non-proportional hazards model via maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxtv(
  event,
  z,
  time,
  strata = NULL,
  nsplines = 8,
  knots = NULL,
  degree = 3,
  ties = "Breslow",
  stop = "ratch",
  tol = 1e-06,
  iter.max = 20,
  method = "ProxN",
  gamma = 1e+08,
  btr = "dynamic",
  tau = 0.5,
  parallel = FALSE,
  threads = 2L,
  fixedstep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxtv_+3A_event">event</code></td>
<td>
<p>failure event response variable of length <code>nobs</code>, where <code>nobs</code> denotes the number of observations. It should be a vector containing 0 or 1.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_z">z</code></td>
<td>
<p>input covariate matrix, with <code>nobs</code> rows and <code>nvars</code> columns; each row is an observation.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_time">time</code></td>
<td>
<p>observed event times, which should be a vector with non-negative values.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_strata">strata</code></td>
<td>
<p>a vector of indicators for stratification.
Default = <code>NULL</code> (i.e. no stratification group in the data), an unstratified model is implemented.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_nsplines">nsplines</code></td>
<td>
<p>number of basis functions in the splines to span the time-varying effects. The default value is 8.
We use the R function <code>splines::bs</code> to generate the B-splines.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_knots">knots</code></td>
<td>
<p>the internal knot locations (breakpoints) that define the B-splines.
The number of the internal knots should be <code>nsplines</code>-<code>degree</code>-1.
If <code>NULL</code>, the locations of knots are chosen as quantiles of distinct failure time points.
This choice leads to more stable results in most cases.
Users can specify the internal knot locations by themselves.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_degree">degree</code></td>
<td>
<p>degree of the piecewise polynomial for generating the B-spline basis functions&mdash;default is 3 for cubic splines.
<code>degree = 2</code> results in the quadratic B-spline basis functions.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_ties">ties</code></td>
<td>
<p>a character string specifying the method for tie handling. If there are no tied events,
the methods are equivalent.
By default <code>"Breslow"</code> uses the Breslow approximation, which can be faster when many ties are present.
If <code>ties = "none"</code>, no approximation will be used to handle ties.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_stop">stop</code></td>
<td>
<p>a character string specifying the stopping rule to determine convergence.
<code>"incre"</code> means we stop the algorithm when Newton's increment is less than the <code>tol</code>. See details in Convex Optimization (Chapter 10) by Boyd and Vandenberghe (2004).
<code>"relch"</code> means we stop the algorithm when the <code class="reqn">(loglik(m)-loglik(m-1))/(loglik(m))</code> is less than the <code>tol</code>,
where <code class="reqn">loglik(m)</code> denotes the log-partial likelihood at iteration step m.
<code>"ratch"</code> means we stop the algorithm when <code class="reqn">(loglik(m)-loglik(m-1))/(loglik(m)-loglik(0))</code> is less than the <code>tol</code>.
<code>"all"</code> means we stop the algorithm when all the stopping rules (<code>"incre"</code>, <code>"relch"</code>, <code>"ratch"</code>) are met.
The default value is <code>ratch</code>.
If <code>iter.max</code> is achieved, it overrides any stop rule for algorithm termination.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_tol">tol</code></td>
<td>
<p>tolerance used for stopping the algorithm. See details in <code>stop</code> below.
The default value is  <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_iter.max">iter.max</code></td>
<td>
<p>maximum iteration number if the stopping criterion specified by <code>stop</code> is not satisfied. The default value is  20.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_method">method</code></td>
<td>
<p>a character string specifying whether to use Newton method or proximal Newton method.  If <code>"Newton"</code> then Hessian is used,
while the default method <code>"ProxN"</code> implements the proximal Newton which can be faster and more stable when there exists ill-conditioned second-order information of the log-partial likelihood.
See details in Wu et al. (2022).</p>
</td></tr>
<tr><td><code id="coxtv_+3A_gamma">gamma</code></td>
<td>
<p>parameter for proximal Newton method <code>"ProxN"</code>. The default value is <code>1e8</code>.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_btr">btr</code></td>
<td>
<p>a character string specifying the backtracking line-search approach. <code>"dynamic"</code> is a typical way to perform backtracking line-search.
See details in Convex Optimization by Boyd and Vandenberghe (2004).
<code>"static"</code> limits Newton's increment and can achieve more stable results in some extreme cases, such as ill-conditioned second-order information of the log-partial likelihood,
which usually occurs when some predictors are categorical with low frequency for some categories.
Users should be careful with <code>static</code>, as this may lead to under-fitting.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_tau">tau</code></td>
<td>
<p>a positive scalar used to control the step size inside the backtracking line-search. The default value is 0.5.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, then the parallel computation is enabled. The number of threads in use is determined by <code>threads</code>.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_threads">threads</code></td>
<td>
<p>an integer indicating the number of threads to be used for parallel computation. The default value is <code>2</code>. If <code>parallel</code> is false, then the value of <code>threads</code> has no effect.</p>
</td></tr>
<tr><td><code id="coxtv_+3A_fixedstep">fixedstep</code></td>
<td>
<p>if <code>TRUE</code>, the algorithm will be forced to run <code>iter.max</code> steps regardless of the stopping criterion specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fit by Newton method (proximal Newton method).
</p>


<h3>Value</h3>

<p>An object with S3 class <code>coxtv</code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the estimated time-varying coefficient for each predictor at each unique time.
It is a matrix of dimension <code>len_unique_t</code> by <code>nvars</code>,
where <code>len_unique_t</code> is the length of unique observed event <code>time</code>s.</p>
</td></tr>
<tr><td><code>bases</code></td>
<td>
<p>the basis matrix used in model fitting. If <code>ties="none"</code>, the dimension of the basis matrix is <code>nvars</code> by <code>nsplines</code>;
if <code>ties="Breslow"</code>, the dimension is <code>len_unique_t</code> by <code>nsplines</code>. The matrix is constructed using the <code>bs::splines</code> function.</p>
</td></tr>
<tr><td><code>ctrl.pts</code></td>
<td>
<p>estimated coefficient of the basis matrix of dimension <code>nvars</code> by <code>nsplines</code>.
Each row represents a covariate's coefficient on the <code>nsplines</code>-dimensional basis functions.</p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>the Hessian matrix of the log-partial likelihood, of which the dimension is <code>nsplines * nvars</code> by <code>nsplines * nvars</code>.</p>
</td></tr>
<tr><td><code>internal.knots</code></td>
<td>
<p>the internal knot locations (breakpoints) that define the B-splines.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>theta.list</code></td>
<td>
<p>the history of <code>ctrl.pts</code> of length <code>m</code> (the length of algorithm iterations), including <code>ctrl.pts</code> for each algorithm iteration.</p>
</td></tr>
<tr><td><code>VarianceMatrix</code></td>
<td>
<p>the variance matrix of the estimated coefficients of the basis matrix,
which is the inverse of the negative Hessian matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Boyd, S., and Vandenberghe, L. (2004) Convex optimization.
<em>Cambridge University Press</em>.
<br />
</p>
<p>Gray, R. J. (1992) Flexible methods for analyzing survival data using splines, with applications to breast cancer prognosis.
<em>Journal of the American Statistical Association</em>, <strong>87(420)</strong>: 942-951.
<br />
</p>
<p>Gray, R. J. (1994) Spline-based tests in survival analysis.
<em>Biometrics</em>, <strong>50(3)</strong>: 640-652.
<br />
</p>
<p>Luo, L., He, K., Wu, W., and Taylor, J. M. (2023) Using information criteria to select smoothing parameters when analyzing survival data with time-varying coefficient hazard models.
<br />
</p>
<p>Perperoglou, A., le Cessie, S., and van Houwelingen, H. C. (2006) A fast routine for fitting Cox models with time varying effects of the covariates.
<em>Computer Methods and Programs in Biomedicine</em>, <strong>81(2)</strong>: 154-161.
<br />
</p>
<p>Wu, W., Taylor, J. M., Brouwer, A. F., Luo, L., Kang, J., Jiang, H., and He, K. (2022) Scalable proximal methods for cause-specific hazard modeling with time-varying coefficients.
<em>Lifetime Data Analysis</em>, <strong>28(2)</strong>: 194-218.
<br />
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, and the <code><a href="#topic+coxtp">coxtp</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleData)
z &lt;- ExampleData$z
time &lt;- ExampleData$time
event &lt;- ExampleData$event
fit &lt;- coxtv(event = event, z = z, time = time)

</code></pre>

<hr>
<h2 id='cv.coxtp'>fit a cross-validated Cox non-proportional hazards model with P-spline or Smoothing-spline where penalization tuning parameter is provided by cross-validation</h2><span id='topic+cv.coxtp'></span>

<h3>Description</h3>

<p>Fit a Cox non-proportional hazards model via penalized maximum likelihood. The penalization tuning parameter is provided by cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.coxtp(
  event,
  z,
  time,
  strata = NULL,
  lambda = c(0.1, 1, 10),
  nfolds = 5,
  foldid = NULL,
  knots = NULL,
  penalty = "Smooth-spline",
  nsplines = 8,
  ties = "Breslow",
  tol = 1e-06,
  iter.max = 20L,
  method = "ProxN",
  gamma = 1e+08,
  btr = "dynamic",
  tau = 0.5,
  stop = "ratch",
  parallel = FALSE,
  threads = 1L,
  degree = 3L,
  fixedstep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.coxtp_+3A_event">event</code></td>
<td>
<p>failure event response variable of length <code>nobs</code>, where <code>nobs</code> denotes the number of observations. It should be a vector containing 0 or 1.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_z">z</code></td>
<td>
<p>input covariate matrix, with <code>nobs</code> rows and <code>nvars</code> columns; each row is an observation.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_time">time</code></td>
<td>
<p>observed event times, which should be a vector with non-negative values.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_strata">strata</code></td>
<td>
<p>a vector of indicators for stratification.
Default = <code>NULL</code> (i.e. no stratification group in the data), an unstratified model is implemented.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_lambda">lambda</code></td>
<td>
<p>a user specified sequence as the penalization coefficients in front of the spline term specified by <code>penalty</code>.
This is the tuning parameter for penalization.  The function <code>IC</code> can be used to select the best tuning parameter based on the information criteria.
Users can specify larger values when the absolute values of the estimated time-varying effects are too large.
When <code>lambda</code> is <code>0</code>, Newton method without penalization is fitted.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds for cross-validation, the default value is 5. The smallest value allowable is <code>nfolds</code>=3.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfolds</code> identifying what fold each observation is in. If supplied, <code>nfolds</code> can be missing.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_knots">knots</code></td>
<td>
<p>the internal knot locations (breakpoints) that define the B-splines.
The number of the internal knots should be <code>nsplines</code>-<code>degree</code>-1.
If <code>NULL</code>, the locations of knots are chosen as quantiles of distinct failure time points.
This choice leads to more stable results in most cases.
Users can specify the internal knot locations by themselves.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_penalty">penalty</code></td>
<td>
<p>a character string specifying the spline term for the penalized Newton method.
This term is added to the log-partial likelihood, and the penalized log-partial likelihood serves as the new objective function to
control the smoothness of the time-varying coefficients.
Default is <code>P-spline</code>. Three options are <code>P-spline</code>, <code>Smooth-spline</code> and <code>NULL</code>.
If <code>NULL</code>, the method will be the same as <code>coxtv</code> (unpenalized time-varying effects models) and <code>lambda</code> (defined below)
will be set as 0.
</p>
<p><code>P-spline</code> stands for Penalized B-spline. It combines the B-spline basis with a discrete quadratic penalty on the difference of basis coefficients between adjacent knots.
When <code>lambda</code> goes to infinity, the time-varying effects are reduced to be constant.
</p>
<p><code>Smooth-spline</code> refers to the Smoothing-spline, the derivative-based penalties combined with B-splines. See <code>degree</code> for different choices.
When <code>degree=3</code>, we use the cubic B-spline penalizing the second-order derivative, which reduces the time-varying effect to a linear term when <code>lambda</code> goes to infinity.
When <code>degree=2</code>, we use the quadratic B-spline penalizing first-order derivative, which reduces the time-varying effect to a constant when <code>lambda</code> goes to infinity. See Wood (2017) for details.
</p>
<p>If <code>P-spline</code> or <code>Smooth-spline</code>, then <code>lambda</code> is initialized as a sequence (0.1, 1, 10). Users can modify <code>lambda</code>. See details in <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_nsplines">nsplines</code></td>
<td>
<p>number of basis functions in the splines to span the time-varying effects. The default value is 8.
We use the R function <code>splines::bs</code> to generate the B-splines.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_ties">ties</code></td>
<td>
<p>a character string specifying the method for tie handling. If there are no tied events,
the methods are equivalent.
By default <code>"Breslow"</code> uses the Breslow approximation, which can be faster when many ties are present.
If <code>ties = "none"</code>, no approximation will be used to handle ties.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_tol">tol</code></td>
<td>
<p>tolerance used for stopping the algorithm. See details in <code>stop</code> below.
The default value is  <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_iter.max">iter.max</code></td>
<td>
<p>maximum iteration number if the stopping criterion specified by <code>stop</code> is not satisfied. The default value is  <code>20</code>.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_method">method</code></td>
<td>
<p>a character string specifying whether to use Newton method or proximal Newton method.  If <code>"Newton"</code> then Hessian is used,
while the default method <code>"ProxN"</code> implements the proximal Newton which can be faster and more stable when there exists ill-conditioned second-order information of the log-partial likelihood.
See details in Wu et al. (2022).</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_gamma">gamma</code></td>
<td>
<p>parameter for proximal Newton method <code>"ProxN"</code>. The default value is <code>1e8</code>.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_btr">btr</code></td>
<td>
<p>a character string specifying the backtracking line-search approach. <code>"dynamic"</code> is a typical way to perform backtracking line-search.
See details in Convex Optimization by Boyd and Vandenberghe (2004).
<code>"static"</code> limits Newton's increment and can achieve more stable results in some extreme cases, such as ill-conditioned second-order information of the log-partial likelihood,
which usually occurs when some predictors are categorical with low frequency for some categories.
Users should be careful with <code>static</code>, as this may lead to under-fitting.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_tau">tau</code></td>
<td>
<p>a positive scalar used to control the step size inside the backtracking line-search. The default value is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_stop">stop</code></td>
<td>
<p>a character string specifying the stopping rule to determine convergence.
<code>"incre"</code> means we stop the algorithm when Newton's increment is less than the <code>tol</code>. See details in Convex Optimization (Chapter 10) by Boyd and Vandenberghe (2004).
<code>"relch"</code> means we stop the algorithm when the <code class="reqn">(loglik(m)-loglik(m-1))/(loglik(m))</code> is less than the <code>tol</code>,
where <code class="reqn">loglik(m)</code> denotes the log-partial likelihood at iteration step m.
<code>"ratch"</code> means we stop the algorithm when <code class="reqn">(loglik(m)-loglik(m-1))/(loglik(m)-loglik(0))</code> is less than the <code>tol</code>.
<code>"all"</code> means we stop the algorithm when all the stopping rules (<code>"incre"</code>, <code>"relch"</code>, <code>"ratch"</code>) are met.
The default value is <code>ratch</code>.
If <code>iter.max</code> is achieved, it overrides any stop rule for algorithm termination.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, then the parallel computation is enabled. The number of threads in use is determined by <code>threads</code>.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_threads">threads</code></td>
<td>
<p>an integer indicating the number of threads to be used for parallel computation. The default value is <code>2</code>. If <code>parallel</code> is false, then the value of <code>threads</code> has no effect.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_degree">degree</code></td>
<td>
<p>degree of the piecewise polynomial for generating the B-spline basis functions&mdash;default is 3 for cubic splines.
<code>degree = 2</code> results in the quadratic B-spline basis functions.
</p>
<p>If <code>penalty</code> is <code>P-spline</code> or <code>NULL</code>, <code>degree</code>'s default value is 3.
</p>
<p>If <code>penalty</code> is <code>Smooth-spline</code>, <code>degree</code>'s default value is 2.</p>
</td></tr>
<tr><td><code id="cv.coxtp_+3A_fixedstep">fixedstep</code></td>
<td>
<p>if <code>TRUE</code>, the algorithm will be forced to run <code>iter.max</code> steps regardless of the stopping criterion specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>coxtp</code> length of <code>lambda</code> by <code>nfolds</code> times; each is to compute the fit with each of the folds omitted.
</p>


<h3>Value</h3>

<p>An object of class <code>"cv.coxtp"</code> is returned, which is a list with the ingredients of the cross-validation fit.
</p>
<table>
<tr><td><code>model.cv</code></td>
<td>
<p>a <code>"coxtp"</code> object with tuning parameter chosen based on cross-validation.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the fits.</p>
</td></tr>
<tr><td><code>cve</code></td>
<td>
<p>the mean cross-validated error - a vector having the same length as lambda.
For the k-th testing fold (k = 1, ..., <code>nfolds</code>), we take the remaining folds as the training folds.
Based on the model trained on the training folds, we calculate the log-partial likelihood on all the folds <code class="reqn">loglik0</code> and training folds  <code class="reqn">loglik1</code>.
The <code>cve</code> is equal to <code class="reqn">-2*(loglik0 - loglik1)</code>. See details in Verweij (1993). This approach avoids the construction of a partial likelihood on the test set so that the risk set is always sufficiently large.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>the value of <code>lambda</code> that gives minimum <code>cve</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Boyd, S., and Vandenberghe, L. (2004) Convex optimization.
<em>Cambridge University Press</em>.
<br />
</p>
<p>Gray, R. J. (1992) Flexible methods for analyzing survival data using splines, with applications to breast cancer prognosis.
<em>Journal of the American Statistical Association</em>, <strong>87(420)</strong>: 942-951.
<br />
</p>
<p>Gray, R. J. (1994) Spline-based tests in survival analysis.
<em>Biometrics</em>, <strong>50(3)</strong>: 640-652.
<br />
</p>
<p>Luo, L., He, K., Wu, W., and Taylor, J. M. (2023) Using information criteria to select smoothing parameters when analyzing survival data with time-varying coefficient hazard models.
<em>Statistical Methods in Medical Research</em>, <strong>in press</strong>.
<br />
</p>
<p>Perperoglou, A., le Cessie, S., and van Houwelingen, H. C. (2006) A fast routine for fitting Cox models with time varying effects of the covariates.
<em>Computer Methods and Programs in Biomedicine</em>, <strong>81(2)</strong>: 154-161.
<br />
</p>
<p>Verweij, P. J., and Van Houwelingen, H. C. (1993) Cross‐validation in survival analysis.
<em>Statistics in Medicine</em>, <strong>12(24)</strong>: 2305-2314.
<br />
</p>
<p>Wu, W., Taylor, J. M., Brouwer, A. F., Luo, L., Kang, J., Jiang, H., and He, K. (2022) Scalable proximal methods for cause-specific hazard modeling with time-varying coefficients.
<em>Lifetime Data Analysis</em>, <strong>28(2)</strong>: 194-218.
<br />
</p>
<p>Wood, S. N. (2017) P-splines with derivative based penalties and tensor product smoothing of unevenly distributed data.
<em>Statistics and Computing</em>, <strong>27(4)</strong>: 985-989.
<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleData)
z &lt;- ExampleData$z
time  &lt;- ExampleData$time
event &lt;- ExampleData$event
lambda  = c(0.1, 1)
fit  &lt;- cv.coxtp(event = event, z = z, time = time, lambda=lambda, nfolds = 5)

</code></pre>

<hr>
<h2 id='ExampleData'>example data with 2000 observations of 2 continuous variables</h2><span id='topic+ExampleData'></span>

<h3>Description</h3>

<p>A simulated data set containing 2 continuous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ExampleData)
</code></pre>


<h3>Format</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>z</dt><dd><p>simulated continuous covariates V1 and V2, with a time-independent coefficient <code class="reqn">\beta_1(t)=1</code>
and a time-varying coefficient <code class="reqn">\beta_2(t)=sin(3\pi t/4).</code></p>
</dd>
<dt>event</dt><dd><p>simulated failure event response; binary variable with 0 or 1.</p>
</dd>
<dt>time</dt><dd><p>simulated observed event times; continuous variable with non-negative values.</p>
</dd>
</dl>


<hr>
<h2 id='ExampleDataBinary'>example data with 2000 observations of 2 binary variables</h2><span id='topic+ExampleDataBinary'></span>

<h3>Description</h3>

<p>A simulated data set containing 2 binary variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ExampleDataBinary)
</code></pre>


<h3>Format</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>z</dt><dd><p>simulated binary covariates V1 and V2, with a time-independent coefficient <code class="reqn">\beta_1(t)=1</code>
and a time-varying coefficient <code class="reqn">\beta_2(t)=exp(-1.5t).</code></p>
</dd>
<dt>event</dt><dd><p>simulated failure event response; binary variable with 0 or 1.</p>
</dd>
<dt>time</dt><dd><p>simulated observed event times; continuous variable with non-negative values. </p>
</dd>
</dl>


<hr>
<h2 id='get.tvcoef'>helper function to get time-varying coefficients</h2><span id='topic+get.tvcoef'></span>

<h3>Description</h3>

<p>The function gives the time-varying coefficients based on a fitted <code>coxtv</code> or <code>coxtp</code> subject.
Users can specify the time points to calculate the time-varying coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tvcoef(fit, time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.tvcoef_+3A_fit">fit</code></td>
<td>
<p>model from <code>coxtv</code> or <code>coxtp</code>.</p>
</td></tr>
<tr><td><code id="get.tvcoef_+3A_time">time</code></td>
<td>
<p>time points to calculate the time-varying coefficients. If <code>NULL</code>, the observed event times for fitting the model will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the time-varying coefficients. The dimension is the length of <code>time</code> by <code>nvars</code>, where <code>nvars</code> is the number
of covariates in the fitted mode.
Each row represents the time-varying coefficients at the corresponding time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z     &lt;- ExampleData$z
time  &lt;- ExampleData$time
event &lt;- ExampleData$event
fit   &lt;- coxtv(event = event, z = z, time = time, degree = 2)
coef  &lt;- get.tvcoef(fit)


</code></pre>

<hr>
<h2 id='IC'>calculating information criteria from a <code>coxtp</code> object</h2><span id='topic+IC'></span>

<h3>Description</h3>

<p>This function is to calculate information criteria from a <code>coxtp</code> object to select the penalization tuning parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC(fit, IC.prox)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC_+3A_fit">fit</code></td>
<td>
<p>model from <code>coxtp</code>.</p>
</td></tr>
<tr><td><code id="IC_+3A_ic.prox">IC.prox</code></td>
<td>
<p>when calculating information criteria, there might be numerical issues (e.g. the Hessian matrix is close to be singular).
In such cases, warnings will be given.
If <code>IC.prox = TRUE</code>, we modify the diagonal of the Hessian matrix following the same approach as the proximal method detailed in Wu et al. (2022), which can lead to more stable estimates.
The default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to select the proper smoothing parameter, we utilize the idea of information criteria.
We provide four different information criteria to select the optimal smoothing parameter <code class="reqn">\lambda</code>.
Generally, mAIC, TIC and GIC select similar parameters and the difference of resulting estimates are barely noticeable.
See details in the Luo et al. (2023).
</p>


<h3>Value</h3>

<table>
<tr><td><code>model.mAIC</code></td>
<td>
<p>an object with S3 class <code>"coxtp"</code> using mAIC to select the tuning parameter.</p>
</td></tr>
<tr><td><code>model.TIC</code></td>
<td>
<p>an object with S3 class <code>"coxtp"</code> using TIC to select the tuning parameter.</p>
</td></tr>
<tr><td><code>model.GIC</code></td>
<td>
<p>an object with S3 class <code>"coxtp"</code> using GIC to select the tuning parameter.</p>
</td></tr>
<tr><td><code>mAIC</code></td>
<td>
<p>a sequence of mAIC values corresponding to each of the tuning parameter <code>lambda</code> from <code>"coxtp"</code>.</p>
</td></tr>
<tr><td><code>TIC</code></td>
<td>
<p>a sequence of TIC values corresponding to each of the tuning parameter <code>lambda</code> from <code>"coxtp"</code>.</p>
</td></tr>
<tr><td><code>GIC</code></td>
<td>
<p>a sequence of GIC values corresponding to each of the tuning parameter <code>lambda</code> from <code>"coxtp"</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Akaike, H. (1998) Information theory and an extension of the maximum likelihood principle.
<em>In Selected Papers of Hirotugu Akaike</em>. 199–213.
<br />
</p>
<p>Luo, L., He, K., Wu, W., and Taylor, J. M. (2023) Using information criteria to select smoothing parameters when analyzing survival data with time-varying coefficient hazard models.
<em>Statistical Methods in Medical Research</em>, <strong>in press</strong>.
<br />
</p>
<p>Takeuchi, K. (1976) Distribution of information statistics and criteria for adequacy of models.
<em>Mathematical Sciences</em>, <strong>153</strong>: 12–18.
<br />
</p>
<p>Wu, W., Taylor, J. M., Brouwer, A. F., Luo, L., Kang, J., Jiang, H., and He, K. (2022) Scalable proximal methods for cause-specific hazard modeling with time-varying coefficients.
<em>Lifetime Data Analysis</em>, <strong>28(2)</strong>: 194-218.
<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleData)
z &lt;- ExampleData$z
time &lt;- ExampleData$time
event &lt;- ExampleData$event
fit &lt;- coxtp(event = event, z = z, time = time)
IC  &lt;- IC(fit)


</code></pre>

<hr>
<h2 id='plot.baseline'>plotting the baseline hazard</h2><span id='topic+plot.baseline'></span>

<h3>Description</h3>

<p>Plotting the baseline hazard from a fitted <code>baseline</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baseline'
plot(x, xlab, ylab, xlim, ylim, title, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.baseline_+3A_x">x</code></td>
<td>
<p>fitted object from <code>baseline</code> function.</p>
</td></tr>
<tr><td><code id="plot.baseline_+3A_xlab">xlab</code></td>
<td>
<p>the title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.baseline_+3A_ylab">ylab</code></td>
<td>
<p>the title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.baseline_+3A_xlim">xlim</code></td>
<td>
<p>the limits of the x axis.</p>
</td></tr>
<tr><td><code id="plot.baseline_+3A_ylim">ylim</code></td>
<td>
<p>the limits of the y axis.</p>
</td></tr>
<tr><td><code id="plot.baseline_+3A_title">title</code></td>
<td>
<p>the title for the plot.</p>
</td></tr>
<tr><td><code id="plot.baseline_+3A_...">...</code></td>
<td>
<p>other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is produced, and nothing is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleData)
z &lt;- ExampleData$z
time  &lt;- ExampleData$time
event &lt;- ExampleData$event

fit   &lt;- coxtv(event = event, z = z, time = time)
base.est &lt;- baseline(fit)
plot(base.est)
</code></pre>

<hr>
<h2 id='plot.coxtp'>plotting results from a fitted <code>coxtp</code> object</h2><span id='topic+plot.coxtp'></span>

<h3>Description</h3>

<p>This function creates a plot of the time-varying coefficients from a fitted <code>coxtp</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxtp'
plot(
  x,
  parm,
  CI = TRUE,
  level = 0.95,
  exponentiate = FALSE,
  xlab,
  ylab,
  xlim,
  ylim,
  allinone = FALSE,
  title,
  linetype,
  color,
  fill,
  time,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.coxtp_+3A_x">x</code></td>
<td>
<p>model obtained from <code>coxtp</code>.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_parm">parm</code></td>
<td>
<p>covariate names fitted in the model to be plotted. If <code>NULL</code>, all covariates are plotted.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_ci">CI</code></td>
<td>
<p>if <code>TRUE</code>, confidence intervals are displayed. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_level">level</code></td>
<td>
<p>the level of confidence intervals. The default value is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_exponentiate">exponentiate</code></td>
<td>
<p>if <code>TRUE</code>, exponential scale of the fitted coefficients (hazard ratio) for each covariate is plotted.
If <code>FALSE</code>, the fitted time-varying coefficients (log hazard ratio) are plotted.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_xlab">xlab</code></td>
<td>
<p>the title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_ylab">ylab</code></td>
<td>
<p>the title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_xlim">xlim</code></td>
<td>
<p>the limits for the x axis.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_ylim">ylim</code></td>
<td>
<p>the limits for the y axis.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_allinone">allinone</code></td>
<td>
<p>if <code>TRUE</code>, the time-varying trajectories for different covariates are combined into a single plot. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_title">title</code></td>
<td>
<p>the title for the plot.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_linetype">linetype</code></td>
<td>
<p>the line type for the plot.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_color">color</code></td>
<td>
<p>the aesthetics parameter for the plot.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_fill">fill</code></td>
<td>
<p>the aesthetics parameter for the plot.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_time">time</code></td>
<td>
<p>the time points for which the time-varying coefficients to be plotted.
The default value is the unique observed event times in the dataset fitting the time-varying effects model.</p>
</td></tr>
<tr><td><code id="plot.coxtp_+3A_...">...</code></td>
<td>
<p>other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is produced, and nothing is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleData)
z &lt;- ExampleData$z
time &lt;- ExampleData$time
event &lt;- ExampleData$event
fit &lt;- coxtp(event = event, z = z, time = time)
plot(fit$lambda1)
</code></pre>

<hr>
<h2 id='plot.coxtv'>plotting results from a fitted <code>coxtv</code> object</h2><span id='topic+plot.coxtv'></span>

<h3>Description</h3>

<p>This function creates a plot of the time-varying coefficients from a fitted <code>coxtv</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxtv'
plot(
  x,
  parm,
  CI = TRUE,
  level = 0.95,
  exponentiate = FALSE,
  xlab,
  ylab,
  xlim,
  ylim,
  allinone = FALSE,
  title,
  linetype,
  color,
  fill,
  time,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.coxtv_+3A_x">x</code></td>
<td>
<p>model obtained from <code>coxtv</code>.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_parm">parm</code></td>
<td>
<p>covariate names fitted in the model to be plotted. If <code>NULL</code>, all covariates are plotted.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_ci">CI</code></td>
<td>
<p>if <code>TRUE</code>, confidence intervals are displayed. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_level">level</code></td>
<td>
<p>the level of confidence intervals. The default value is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_exponentiate">exponentiate</code></td>
<td>
<p>if <code>TRUE</code>, exponential scale of the fitted coefficients (hazard ratio) for each covariate is plotted.
If <code>FALSE</code>, the fitted time-varying coefficients (log hazard ratio) are plotted.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_xlab">xlab</code></td>
<td>
<p>the title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_ylab">ylab</code></td>
<td>
<p>the title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_xlim">xlim</code></td>
<td>
<p>the limits for the x axis.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_ylim">ylim</code></td>
<td>
<p>the limits for the y axis.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_allinone">allinone</code></td>
<td>
<p>if <code>TRUE</code>, the time-varying trajectories for different covariates are combined into a single plot. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_title">title</code></td>
<td>
<p>the title for the plot.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_linetype">linetype</code></td>
<td>
<p>the line type for the plot.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_color">color</code></td>
<td>
<p>the aesthetics parameter for the plot.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_fill">fill</code></td>
<td>
<p>the aesthetics parameter for the plot.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_time">time</code></td>
<td>
<p>the time points for which the time-varying coefficients to be plotted.
The default value is the unique observed event times in the dataset fitting the time-varying effects model.</p>
</td></tr>
<tr><td><code id="plot.coxtv_+3A_...">...</code></td>
<td>
<p>other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is produced, and nothing is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleData)
z &lt;- ExampleData$z
time &lt;- ExampleData$time
event &lt;- ExampleData$event
fit &lt;- coxtv(event = event, z = z, time = time)
plot(fit)

</code></pre>

<hr>
<h2 id='StrataExample'>example data for stratified model illustration</h2><span id='topic+StrataExample'></span>

<h3>Description</h3>

<p>A simulated data set containing 2 binary variables from 10 distinct stratums.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(StrataExample)
</code></pre>


<h3>Format</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>z</dt><dd><p>simulated binary covariates V1 and V2, with a time-independent coefficient <code class="reqn">\beta_1(t)=1</code>
and a time-varying coefficient <code class="reqn">\beta_2(t)=sin(3\pi t/4).</code></p>
</dd>
<dt>event</dt><dd><p>simulated failure event response; binary variable with 0 or 1.</p>
</dd>
<dt>time</dt><dd><p>simulated observed event times; continuous variable with non-negative values. </p>
</dd>
<dt>strata</dt><dd><p>simulated strata variable; patients in different stratums have different baseline hazards.</p>
</dd>
</dl>


<hr>
<h2 id='support'>Study to Understand Prognoses Preferences Outcomes and Risks of Treatment</h2><span id='topic+support'></span>

<h3>Description</h3>

<p>The SUPPORT dataset tracks five response variables: hospital
death, severe functional disability, hospital costs, and time until death
and death itself. The patients are followed for up to 5.56 years. See Bhatnagar et al. (2020) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(support)
</code></pre>


<h3>Format</h3>

<p>A data frame with 9,104 observations and 34 variables after imputation
and the removal of response variables like hospital charges, patient ratio
of costs to charges and micro-costs following Bhatnagar et al. (2020).
Ordinal variables, namely functional disability and income, were also removed.
Finally, Surrogate activities of daily living were removed due to sparsity.
There were 6 other model scores in the data-set and they were removed; only aps and sps were kept.
</p>

<dl>
<dt>age</dt><dd><p> stores a double representing age. </p>
</dd>
<dt>death</dt><dd>
<p>death at any time up to NDI (National Death Index) date: 12/31/1994. </p>
</dd>
<dt>sex</dt><dd><p> 0=female, 1=male. </p>
</dd>
<dt>slos</dt><dd><p> days from study entry to discharge. </p>
</dd>
<dt>d.time</dt><dd><p> days of
follow-up. </p>
</dd>
<dt>dzgroup</dt><dd><p> each level of dzgroup: ARF/MOSF w/Sepsis,
COPD, CHF, Cirrhosis, Coma, Colon Cancer, Lung Cancer, MOSF with
malignancy. </p>
</dd>
<dt>dzclass</dt><dd><p> ARF/MOSF, COPD/CHF/Cirrhosis, Coma and cancer disease classes. </p>
</dd>
<dt>num.co</dt><dd><p> the number of comorbidities. </p>
</dd>
<dt>edu</dt><dd><p> years of education of patients. </p>
</dd>
<dt>scoma</dt><dd><p> the SUPPORT coma score based on Glasgow D3. </p>
</dd>
<dt>avtisst</dt><dd><p> average TISS, days 3-25. </p>
</dd>
<dt>race</dt><dd><p> indicates race: White, Black, Asian, Hispanic or other. </p>
</dd>
<dt>hday</dt><dd><p> day in Hospital at Study Admit.</p>
</dd>
<dt>diabetes</dt><dd><p>diabetes (Com27-28, Dx 73).</p>
</dd>
<dt>dementia</dt><dd><p>dementia (Comorbidity 6).</p>
</dd>
<dt>ca</dt><dd><p>cancer state. </p>
</dd>
<dt>meanbp</dt><dd><p> mean arterial blood pressure day 3. </p>
</dd>
<dt>wblc</dt><dd><p> white blood cell count on day 3. </p>
</dd>
<dt>hrt</dt><dd><p> heart rate day 3. </p>
</dd>
<dt>resp</dt><dd><p> respiration rate day 3. </p>
</dd>
<dt>temp</dt><dd><p> temperature, in Celsius, on day 3. </p>
</dd>
<dt>pafi</dt><dd><p> PaO2/(0.01*FiO2) day 3. </p>
</dd>
<dt>alb</dt><dd><p>serum albumin day 3. </p>
</dd>
<dt>bili</dt><dd><p> bilirubin day 3. </p>
</dd>
<dt>crea</dt><dd><p> serum creatinine day 3. </p>
</dd>
<dt>sod</dt><dd><p> serum sodium day 3. </p>
</dd>
<dt>ph</dt><dd><p> serum pH (in arteries) day 3. </p>
</dd>
<dt>glucose</dt><dd><p> serum glucose day 3. </p>
</dd>
<dt>bun</dt><dd><p> bun day 3. </p>
</dd>
<dt>urine</dt><dd><p> urine output day 3. </p>
</dd>
<dt>adlp</dt><dd><p> adl patient day 3. </p>
</dd>
<dt>adlsc</dt><dd><p> imputed adl calibrated to surrogate, if a surrogate was used for a follow up.</p>
</dd>
<dt>sps</dt><dd><p>SUPPORT physiology score.</p>
</dd>
<dt>aps</dt><dd><p>apache III physiology score.</p>
</dd> </dl>



<h3>Details</h3>

<p>Some of the original data was missing. Before imputation, there were
a total of 9,104 individuals and 47 variables. Following Bhatnagar et al. (2020), a few variables
were removed. Three response variables were removed:
hospital charges, patient ratio of costs to charges and patient
micro-costs. Hospital death was also removed as it was directly informative
of the event of interest, namely death. Additionally, functional disability and
income were removed as they are ordinal covariates. Finally, 8
covariates were removed related to the results of previous findings: SUPPORT
day 3 physiology score (<code>sps</code>), APACHE III day 3 physiology score
(<code>aps</code>), SUPPORT model 2-month survival estimate, SUPPORT model
6-month survival estimate, Physician's 2-month survival estimate for pt.,
Physician's 6-month survival estimate for pt., Patient had Do Not
Resuscitate (DNR) order, and Day of DNR order (&lt;0 if before study). Of
these, <code>sps</code> and <code>aps</code> were added on after imputation, as they
were missing only 1 observation. First the imputation is done manually using the normal
values for physiological measures recommended by Knaus et al. (1995). Next,
a single dataset was imputed using <span class="pkg">mice</span> with default settings. After
imputation, the covariate for surrogate activities of daily
living was not imputed. This is due to collinearity between the other two
covariates for activities of daily living. Therefore, surrogate activities
of daily living were removed. See details in the R package (casebase) by Bhatnagar et al. (2020).
</p>


<h3>Source</h3>

<p>Available at the following website:
<a href="https://biostat.app.vumc.org/wiki/Main/SupportDesc">https://biostat.app.vumc.org/wiki/Main/SupportDesc</a>.
</p>


<h3>References</h3>

<p>Bhatnagar, S., Turgeon, M., Islam, J., Hanley, J. A., and Saarela, O. (2020) casebase: Fitting Flexible Smooth-in-Time
Hazards and Risk Functions via Logistic and Multinomial Regression.
<em>R package version 0.9.0</em>,
<a href="https://CRAN.R-project.org/package=casebase">https://CRAN.R-project.org/package=casebase</a>.
</p>
<p>Knaus, W. A., Harrell, F. E., Lynn, J., Goldman, L., Phillips, R. S., Connors, A. F., et al. (1995)
The SUPPORT prognostic model: Objective estimates of survival for seriously ill hospitalized adults.
<em>Annals of Internal Medicine</em>, <strong>122(3)</strong>: 191-203.
<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(support)
support &lt;- support[support$ca %in% c("metastatic"),]
time &lt;- support$d.time
death &lt;- support$death
diabetes &lt;-  model.matrix(~factor(support$diabetes))[,-1]
#sex: female as the reference group
sex &lt;- model.matrix(~support$sex)[,-1]
#age: continuous variable
age &lt;-support$age
age[support$age&lt;=50] &lt;- "&lt;50"
age[support$age&gt;50 &amp; support$age&lt;=60] &lt;- "50-59"
age[support$age&gt;60 &amp; support$age&lt;70] &lt;- "60-69"
age[support$age&gt;=70] &lt;- "70+"
age &lt;- factor(age, levels = c("60-69", "&lt;50", "50-59", "70+"))
z_age &lt;- model.matrix(~age)[,-1]
z &lt;- data.frame(z_age, sex, diabetes)
colnames(z) &lt;- c("age_50", "age_50_59", "age_70", "diabetes", "male")
data &lt;- data.frame(time, death, z)
fit.coxtv &lt;- coxtv(event = death, z = z, time = time)
</code></pre>

<hr>
<h2 id='tvef.ph'>testing the proportional hazards assumption from a <code>coxtv</code> or <code>coxtp</code> object</h2><span id='topic+tvef.ph'></span>

<h3>Description</h3>

<p>Testing the proportional hazards assumption using a Wald test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvef.ph(fit, parm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvef.ph_+3A_fit">fit</code></td>
<td>
<p>fitted <code>coxtv</code> or <code>coxtp</code>  model.</p>
</td></tr>
<tr><td><code id="tvef.ph_+3A_parm">parm</code></td>
<td>
<p>the names of parameters to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tvef.ph</code> produces a matrix. Each row corresponds to a covariate from the fitted object. The three
columns give the test statistic, degrees of freedom and P-value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tvef.zero">tvef.zero</a></code> <code><a href="#topic+tvef.zero.time">tvef.zero.time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleData)
z &lt;- ExampleData$z
time &lt;- ExampleData$time
event &lt;- ExampleData$event
fit &lt;- coxtv(event = event, z = z, time = time)
tvef.ph(fit)

</code></pre>

<hr>
<h2 id='tvef.zero'>testing the significance of the covariates from a <code>coxtv</code> or <code>coxtp</code> object</h2><span id='topic+tvef.zero'></span>

<h3>Description</h3>

<p>Testing the significance of the covariates from a <code>coxtv</code> or <code>coxtp</code> object using a Wald test statistic.
The null hypothesis <code class="reqn">H_0: \beta(t) = 0</code> for any <code class="reqn">t</code>, where  <code class="reqn">t</code> denotes the event time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvef.zero(fit, parm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvef.zero_+3A_fit">fit</code></td>
<td>
<p>fitted <code>coxtv</code> or <code>coxtp</code>  model.</p>
</td></tr>
<tr><td><code id="tvef.zero_+3A_parm">parm</code></td>
<td>
<p>the names of parameters to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tvef.zero</code> produces a matrix. Each row corresponds to a covariate from the fitted object. The three
columns give the test statistic, degrees of freedom and P-value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tvef.ph">tvef.ph</a></code> <code><a href="#topic+tvef.zero.time">tvef.zero.time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleData)
z &lt;- ExampleData$z
time &lt;- ExampleData$time
event &lt;- ExampleData$event
fit &lt;- coxtv(event = event, z = z, time = time)
tvef.ph(fit)

</code></pre>

<hr>
<h2 id='tvef.zero.time'>testing the significance of the covariates from a <code>coxtv</code> or <code>coxtp</code> object using a Wald test statistic</h2><span id='topic+tvef.zero.time'></span>

<h3>Description</h3>

<p>Testing the significance of the covariates at each time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvef.zero.time(fit, time, parm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvef.zero.time_+3A_fit">fit</code></td>
<td>
<p>fitted <code>coxtv</code> or <code>coxtp</code>  model.</p>
</td></tr>
<tr><td><code id="tvef.zero.time_+3A_time">time</code></td>
<td>
<p>the time points to test if the covariate is significant or not.</p>
</td></tr>
<tr><td><code id="tvef.zero.time_+3A_parm">parm</code></td>
<td>
<p>the names of parameters to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tvef.zero.time</code> produces a list of length <code>nvars</code>. Each element of the list is a matrix with respect to a
covariate. The matrix is of dimension <code>len_unique_t</code> by 4, where <code>len_unique_t</code> is the length of unique observed event time.
Each row corresponds to the testing result at that time.  The four
columns give the estimations, standard error, test-statistic and  P-value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tvef.ph">tvef.ph</a></code> <code><a href="#topic+tvef.zero">tvef.zero</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExampleData)
z &lt;- ExampleData$z
time  &lt;- ExampleData$time
event &lt;- ExampleData$event
fit   &lt;- coxtv(event = event, z = z, time = time)
test  &lt;- tvef.zero.time(fit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
