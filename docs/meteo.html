<!DOCTYPE html><html><head><title>Help for package meteo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {meteo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acc.metric.fun'><p>Accuracy metrics calculation</p></a></li>
<li><a href='#cv.rfsi'><p>Nested k-fold cross-validation for Random Forest Spatial Interpolation (RFSI)</p></a></li>
<li><a href='#cv.strk'><p>k-fold cross-validation for spatio-temporal regression kriging</p></a></li>
<li><a href='#data.prepare'><p>Prepare data</p></a></li>
<li><a href='#dem_twi_srb'><p>Digital Elevation Model (DEM) and Topographic Wetness Index (TWI) for Serbia</p></a></li>
<li><a href='#dprec'><p>Daily precipitation amount in mm for July 2011</p></a></li>
<li><a href='#dslp'><p>Mean sea level pressure in hPa for July 2011</p></a></li>
<li><a href='#dsndp'><p>Daily snow depth in cm for July 2011</p></a></li>
<li><a href='#dtemp_maxc'><p>Maximum daily temperature in degrees Celsius for July 2011</p></a></li>
<li><a href='#dtemp_minc'><p>Minimum daily temperature in degrees Celsius for July 2011</p></a></li>
<li><a href='#dtempc'><p>Mean daily temperature in degrees Celsius for July 2011</p></a></li>
<li><a href='#dtempc_ogimet'><p>Mean daily temperature in degrees Celsius for the year 2019 for Serbia</p></a></li>
<li><a href='#dwdsp'><p>Daily mean wind speed in m/s for July 2011</p></a></li>
<li><a href='#get_meteo'><p>Get daily meteorological data for specific location and dates.</p></a></li>
<li><a href='#meteo2STFDF'><p>Create an object of STFDF-class class from two data frames (observation and stations)</p></a></li>
<li><a href='#near.obs'><p>Finds n nearest observations from given locations.</p></a></li>
<li><a href='#near.obs.soil'><p>Finds n nearest observations from given locations for soil mapping.</p></a></li>
<li><a href='#nlmodis20110704'><p>MODIS LST 8 day images image for the Netherlands ('2011-07-04')</p></a></li>
<li><a href='#nlmodis20110712'><p>MODIS LST 8 day images image for the Netherlands ('2011-07-12')</p></a></li>
<li><a href='#NLpol'><p>The Netherlands border polygon from WCAB</p></a></li>
<li><a href='#pred.rfsi'><p>Random Forest Spatial Interpolation (RFSI) prediction</p></a></li>
<li><a href='#pred.strk'><p>Spatio-temporal regression kriging prediction</p></a></li>
<li><a href='#regdata'><p>Dynamic and static covariates for spatio-temporal regression kriging</p></a></li>
<li><a href='#rfillspgaps'><p>Close gaps of a grid or raster Layer data</p></a></li>
<li><a href='#rfilltimegaps'><p>Disaggregation in the time dimension through the use of splines for each pixel</p></a></li>
<li><a href='#rfsi'><p>Random Forest Spatial Interpolation (RFSI) model</p></a></li>
<li><a href='#rm.dupl'><p>Find point pairs with equal spatial coordinates from STFDF-class object.</p></a></li>
<li><a href='#stations'><p>Data frame containing stations' information</p></a></li>
<li><a href='#stations_ogimet'><p>Data frame containing stations' information from the OGIMET service for Serbian territory</p></a></li>
<li><a href='#temp_geom'><p>Calculate geometrical temperature trend</p></a></li>
<li><a href='#tgeom2STFDF'><p>Calculate geometrical temperature trend</p></a></li>
<li><a href='#tiling'><p>Tiling raster or Spatial-class Grid or Pixels object</p></a></li>
<li><a href='#tregcoef'><p>Multiple linear regression coefficients for global and local daily air temperatures</p></a></li>
<li><a href='#tune.rfsi'><p>Tuning of Random Forest Spatial Interpolation (RFSI) model</p></a></li>
<li><a href='#tvgms'><p>Spatio-temporal variogram models for global and local daily air temperatures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-09</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>RFSI and Spatio-Temporal Geostatistical Interpolation for
Meteorological and Other Environmental Variables</td>
</tr>
<tr>
<td>Author:</td>
<td>Milan Kilibarda <a href="https://orcid.org/0000-0002-2930-3596"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Aleksandar Sekulić
    <a href="https://orcid.org/0000-0002-5515-2779"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Tomislav Hengl [ctb],
  Edzer Pebesma [ctb],
  Benedikt Graeler [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aleksandar Sekulić &lt;asekulic@grf.bg.ac.rs&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>RFSI and spatio-temporal geostatistical interpolation for meteorological and other environmental variables. Global spatio-temporal models calculated using publicly available data are stored in package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENCE [expanded from: GPL (&ge; 2.0) | file LICENCE]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-pkg.org/pkg/meteo">https://www.r-pkg.org/pkg/meteo</a>,
<a href="https://r-forge.r-project.org/projects/meteo/">https://r-forge.r-project.org/projects/meteo/</a>,
<a href="https://github.com/AleksandarSekulic/Rmeteo">https://github.com/AleksandarSekulic/Rmeteo</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, stats, DescTools, caret, data.table, dplyr,
sp, spacetime, gstat, foreach, parallel, snowfall, doParallel,
plyr, units, nabor, CAST, ranger, sf, sftime, raster, terra</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AleksandarSekulic/Rmeteo/issues">https://github.com/AleksandarSekulic/Rmeteo/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-14 07:56:58 UTC; sekulic</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-14 12:50:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='acc.metric.fun'>Accuracy metrics calculation</h2><span id='topic+acc.metric.fun'></span>

<h3>Description</h3>

<p>Calculates classification and regression accuracy metrics for given coresponding observation and prediction vectors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>acc.metric.fun(obs, pred, acc.m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acc.metric.fun_+3A_obs">obs</code></td>
<td>
<p><code>numeric or factor vector;</code> Observations.</p>
</td></tr>
<tr><td><code id="acc.metric.fun_+3A_pred">pred</code></td>
<td>
<p><code>numeric or factor vector;</code> Predictions.</p>
</td></tr>
<tr><td><code id="acc.metric.fun_+3A_acc.m">acc.m</code></td>
<td>
<p><code>character</code>; Accuracy metric. Possible values for regression: &quot;ME&quot;, &quot;MAE&quot;, &quot;NMAE&quot;, &quot;RMSE&quot;, &quot;NRMSE&quot;, &quot;R2&quot;, &quot;CCC&quot;. Possible values for classification: &quot;Accuracy&quot;, &quot;Kappa&quot;, &quot;AccuracyLower&quot;, &quot;AccuracyUpper&quot;, &quot;AccuracyNull&quot;, &quot;AccuracyPValue&quot;, &quot;McnemarPValue&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Accuracy metric value.
</p>


<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Sekulić, A., Kilibarda, M., Heuvelink, G. B., Nikolić, M. &amp; Bajat, B. Random Forest Spatial Interpolation.Remote. Sens. 12, 1687, https://doi.org/10.3390/rs12101687 (2020).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acc.metric.fun">acc.metric.fun</a></code>
<code><a href="#topic+rfsi">rfsi</a></code>
<code><a href="#topic+pred.rfsi">pred.rfsi</a></code>
<code><a href="#topic+tune.rfsi">tune.rfsi</a></code>
<code><a href="#topic+cv.rfsi">cv.rfsi</a></code>
<code><a href="#topic+pred.strk">pred.strk</a></code>
<code><a href="#topic+cv.strk">cv.strk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
library(sf)
library(CAST)
library(ranger)
library(plyr)
library(meteo)

# preparing data
demo(meuse, echo=FALSE)
meuse &lt;- meuse[complete.cases(meuse@data),]
data = st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
fm.RFSI &lt;- as.formula("zinc ~ dist + soil + ffreq")

# making tgrid
n.obs &lt;- 1:3
min.node.size &lt;- 2:10
sample.fraction &lt;- seq(1, 0.632, -0.05) # 0.632 without / 1 with replacement
splitrule &lt;- "variance"
ntree &lt;- 250 # 500
mtry &lt;- 3:(2+2*max(n.obs))
tgrid = expand.grid(min.node.size=min.node.size, num.trees=ntree,
                    mtry=mtry, n.obs=n.obs, sample.fraction=sample.fraction)

## Not run: 
# do cross-validation
rfsi_cv &lt;- cv.rfsi(formula=fm.RFSI, # without nearest obs
                   data = data,
                   zero.tol=0,
                   tgrid = tgrid, # combinations for tuning
                   tgrid.n = 5, # number of randomly selected combinations from tgrid for tuning
                   tune.type = "LLO", # Leave-Location-Out CV
                   k = 5, # number of folds
                   seed = 42,
                   acc.metric = "RMSE", # R2, CCC, MAE
                   output.format = "data.frame",
                   cpus=detectCores()-1,
                   progress=1,
                   importance = "impurity")
summary(rfsi_cv)

# accuracy metric calculation
acc.metric.fun(rfsi_cv$obs, rfsi_cv$pred, "R2")
acc.metric.fun(rfsi_cv$obs, rfsi_cv$pred, "RMSE")
acc.metric.fun(rfsi_cv$obs, rfsi_cv$pred, "NRMSE")
acc.metric.fun(rfsi_cv$obs, rfsi_cv$pred, "MAE")
acc.metric.fun(rfsi_cv$obs, rfsi_cv$pred, "NMAE")
acc.metric.fun(rfsi_cv$obs, rfsi_cv$pred, "CCC")

## End(Not run)
</code></pre>

<hr>
<h2 id='cv.rfsi'>Nested k-fold cross-validation for Random Forest Spatial Interpolation (RFSI)</h2><span id='topic+cv.rfsi'></span>

<h3>Description</h3>

<p>Function for nested k-fold cross-validation function for Random Forest Spatial Interpolation (RFSI) (Sekulić et al. 2020). It is based on <a href="#topic+rfsi">rfsi</a>, <a href="#topic+pred.rfsi">pred.rfsi</a>, and <a href="#topic+tune.rfsi">tune.rfsi</a> functions. Currently, only spatial (leave-location-out) cross-validation is implemented. Temporal and spatio-temporal cross-validation will be implemented in the future.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.rfsi(formula,
        data,
        data.staid.x.y.z = NULL,
        use.idw = FALSE,
        s.crs = NA,
        p.crs = NA,
        tgrid,
        tgrid.n=10,
        tune.type = "LLO",
        k = 5,
        seed=42,
        out.folds,
        in.folds,
        acc.metric,
        output.format = "data.frame",
        cpus = detectCores()-1,
        progress = 1,
        soil3d = FALSE,
        no.obs = 'increase',
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.rfsi_+3A_formula">formula</code></td>
<td>
<p>formula; Formula for specifying target variable and covariates (without nearest observations and distances to them). If <code>z~1</code>, an RFSI model using only nearest obsevrations and distances to them as covariates will be cross-validated.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_data">data</code></td>
<td>
<p><a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> or <a href="base.html#topic+data.frame">data.frame</a>; Contains target variable (observations) and covariates used for making an RFSI model. If <a href="base.html#topic+data.frame">data.frame</a> object, it should have next columns: station ID (staid), longitude (x), latitude (y), 3rd component - time, depth, ... (z) of the observation, observation value (obs) and covariates (cov1, cov2, ...). If covariates are missing, the RFSI model using only nearest obsevrations and distances to them as covariates (<code>formula=z~1</code>) will be cross-validated.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_data.staid.x.y.z">data.staid.x.y.z</code></td>
<td>
<p>numeric or character vector; Positions or names of the station ID (staid), longitude (x), latitude (y) and 3rd component (z) columns in <a href="base.html#topic+data.frame">data.frame</a> object (e.g. c(1,2,3,4)). If <code>data</code> is <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> object, <code>data.staid.x.y.z</code> is used to point staid and z position. Set z position to NA (e.g. c(1,2,3,NA)) or ommit it (e.g. c(1,2,3)) for spatial interpolation. Default is NULL.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_use.idw">use.idw</code></td>
<td>
<p>boolean; IDW prediction as covariate - will IDW predictions from <code>n.obs</code> nearest observations be calculated and tuned (see function <a href="#topic+near.obs">near.obs</a>). Default is FALSE.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_s.crs">s.crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Source CRS of <code>data</code>. If <code>data</code> contains crs, <code>s.crs</code> will be overwritten. Default is NA.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_p.crs">p.crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Projection CRS for <code>data</code> reprojection. If NA, <code>s.crs</code> will be used for distance calculation. Note that observations should be in projection for finding nearest observations based on Eucleadean distances (see function <a href="#topic+near.obs">near.obs</a>). Default is NA.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_tgrid">tgrid</code></td>
<td>
<p>data.frame; Possible tuning parameters for nested folds. The column names are same as the tuning parameters. Possible tuning parameters are: <code>n.obs</code>, <code>num.trees</code>, <code>mtry</code>, <code>min.node.size</code>, <code>sample.fraction</code>, <code>splirule</code>, <code>idw.p</code>, and <code>depth.range</code>.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_tgrid.n">tgrid.n</code></td>
<td>
<p>numeric; Number of randomly chosen <code>tgrid</code> combinations for nested tuning of RFSI. If larger than <code>tgrid</code>, will be set to <code>length(tgrid)</code></p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_tune.type">tune.type</code></td>
<td>
<p>character; Type of nested cross-validation: leave-location-out (&quot;LLO&quot;), leave-time-out (&quot;LTO&quot;) - TO DO, and leave-location-time-out (&quot;LLTO&quot;) - TO DO. Default is &quot;LLO&quot;.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_k">k</code></td>
<td>
<p>numeric; Number of random outer and inner folds (i.e. for cross-validation and nested tuning) that will be created with <a href="CAST.html#topic+CreateSpacetimeFolds">CreateSpacetimeFolds</a> function. Default is 5.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_seed">seed</code></td>
<td>
<p>numeric; Random seed that will be used to generate outer  and inner folds with <a href="CAST.html#topic+CreateSpacetimeFolds">CreateSpacetimeFolds</a> function.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_out.folds">out.folds</code></td>
<td>
<p>numeric or character vector or value; Showing outer folds column (if value) or rows (vector) of <code>data</code> observations used for cross-validation. If missing, will be created with <a href="CAST.html#topic+CreateSpacetimeFolds">CreateSpacetimeFolds</a> function.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_in.folds">in.folds</code></td>
<td>
<p>numeric or character vector or value; Showing innner folds column (if value) or rows (vector) of <code>data</code> observations used for cross-validation. If missing, will be created with <a href="CAST.html#topic+CreateSpacetimeFolds">CreateSpacetimeFolds</a> function.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_acc.metric">acc.metric</code></td>
<td>
<p>character; Accuracy metric that will be used as a criteria for choosing an optimal RFSI model in nested tuning. Possible values for regression: &quot;ME&quot;, &quot;MAE&quot;, &quot;NMAE&quot;, &quot;RMSE&quot; (default), &quot;NRMSE&quot;, &quot;R2&quot;, &quot;CCC&quot;. Possible values for classification: &quot;Accuracy&quot;,&quot;Kappa&quot; (default), &quot;AccuracyLower&quot;, &quot;AccuracyUpper&quot;, &quot;AccuracyNull&quot;, &quot;AccuracyPValue&quot;, &quot;McnemarPValue&quot;.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_output.format">output.format</code></td>
<td>
<p>character; Format of the output, <a href="base.html#topic+data.frame">data.frame</a> (default), <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a>.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_cpus">cpus</code></td>
<td>
<p>numeric; Number of processing units. Default is detectCores()-1.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_progress">progress</code></td>
<td>
<p>numeric; If progress bar is shown. 0 is no progress bar, 1 is outer folds results, 2 is + innner folds results, 3 is + prediction progress bar. Default is 1.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_soil3d">soil3d</code></td>
<td>
<p>logical; If 3D soil modellig is performed and <a href="#topic+near.obs.soil">near.obs.soil</a> function is used for finding n nearest observations and distances to them. In this case, z position of the <code>data.staid.x.y.z</code> points to the depth column.</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_no.obs">no.obs</code></td>
<td>
<p>character; Possible values are <code>increase</code> (default) and <code>exactly</code>. If set to <code>increase</code>, in case if there is no <code>n.obs</code> observations in <code>depth.range</code> for a specific location, the <code>depth.range</code> is increased (multiplied by 2, 3, ...) until the number of observations are larger or equal to <code>n.obs</code>. If set to <code>exactly</code>, the function will raise an error when it come to the first location with no <code>n.obs</code> observations in specified <code>depth.range</code> (see function <a href="#topic+near.obs.soil">near.obs.soil</a>).</p>
</td></tr>
<tr><td><code id="cv.rfsi_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="ranger.html#topic+ranger">ranger</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+data.frame">data.frame</a>, <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> object (depends on <code>output.format</code> argument), with columns:
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>Observations.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Predictions from cross-validation.</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>Folds used for cross-validation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Sekulić, A., Kilibarda, M., Heuvelink, G. B., Nikolić, M. &amp; Bajat, B. Random Forest Spatial Interpolation. Remote. Sens. 12, 1687, https://doi.org/10.3390/rs12101687 (2020).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+near.obs">near.obs</a></code>
<code><a href="#topic+rfsi">rfsi</a></code>
<code><a href="#topic+pred.rfsi">pred.rfsi</a></code>
<code><a href="#topic+tune.rfsi">tune.rfsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CAST)
library(doParallel)
library(ranger)
library(sp)
library(sf)
library(terra)
library(meteo)

# prepare data
demo(meuse, echo=FALSE)
meuse &lt;- meuse[complete.cases(meuse@data),]
data = st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
# data = terra::vect(meuse)
# data.frame
# data &lt;- as.data.frame(meuse)
# data$id = 1:nrow(data)
# data.staid.x.y.z &lt;- c(15,"x","y",NA)
fm.RFSI &lt;- as.formula("zinc ~ dist + soil + ffreq")

# making tgrid
n.obs &lt;- 1:6
min.node.size &lt;- 2:10
sample.fraction &lt;- seq(1, 0.632, -0.05) # 0.632 without / 1 with replacement
splitrule &lt;- "variance"
ntree &lt;- 250 # 500
mtry &lt;- 3:(2+2*max(n.obs))
tgrid = expand.grid(min.node.size=min.node.size, num.trees=ntree,
                    mtry=mtry, n.obs=n.obs, sample.fraction=sample.fraction)
## Not run: 
# Cross-validation of RFSI
rfsi_cv &lt;- cv.rfsi(formula=fm.RFSI, # without nearest obs
                   data = data,
                   # data.staid.x.y.z = c("id", "x", "y", NA), # only if class(data) == data.frame
                   # s.crs=NA,
                   # t.crs=NA,
                   tgrid = tgrid, # combinations for tuning
                   tgrid.n = 2, # number of randomly selected combinations from tgrid for tuning
                   tune.type = "LLO", # Leave-Location-Out CV
                   k = 5, # number of folds
                   seed = 42,
                   acc.metric = "RMSE", # R2, CCC, MAE
                   output.format = "sf", # "data.frame", # "SpatVector",
                   cpus=detectCores()-1,
                   progress=1,
                   importance = "impurity") # ranger parameter

summary(rfsi_cv)
rfsi_cv$dif &lt;- rfsi_cv$obs - rfsi_cv$pred
# plot(rfsi_cv["dif"])
# spplot(rfsi_cv[, , "obs"])
acc.metric.fun(rfsi_cv$obs, rfsi_cv$pred, "R2")
acc.metric.fun(rfsi_cv$obs, rfsi_cv$pred, "RMSE")
acc.metric.fun(rfsi_cv$obs, rfsi_cv$pred, "MAE")
acc.metric.fun(rfsi_cv$obs, rfsi_cv$pred, "CCC")

## End(Not run)
</code></pre>

<hr>
<h2 id='cv.strk'>k-fold cross-validation for spatio-temporal regression kriging</h2><span id='topic+cv.strk'></span>

<h3>Description</h3>

<p>k-fold cross-validation function for spatio-temporal regression kriging based on <a href="#topic+pred.strk">pred.strk</a>. Currently, only spatial (leave-location-out) cross-validation is implemented. Temporal and spatio-temporal cross-validation will be implemented in the future.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.strk(data,
        obs.col=1,
        data.staid.x.y.z = NULL,
        crs = NA,
        zero.tol=0,
        reg.coef,
        vgm.model,
        sp.nmax=20,
        time.nmax=2,
        type = "LLO",
        k = 5,
        seed = 42,
        folds,
        refit = TRUE,
        output.format = "STFDF",
        parallel.processing = FALSE,
        pp.type = "snowfall",
        cpus=detectCores()-1,
        progress=TRUE,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.strk_+3A_data">data</code></td>
<td>
<p><a href="spacetime.html#topic+STFDF-class">STFDF-class</a>, <a href="spacetime.html#topic+STSDF-class">STSDF-class</a>, <a href="spacetime.html#topic+STIDF-class">STIDF-class</a>, <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> or <a href="base.html#topic+data.frame">data.frame</a>; Contains target variable (observations) and covariates in space and time used to perform STRK cross validation. If <a href="base.html#topic+data.frame">data.frame</a> object, it should have next columns: station ID (staid), longitude (x), latitude (y), 3rd component - time, depth, ... (z) of the observation, observation value (obs), and covariates (cov1, cov2, ...). Covariate names should be the same as in the <code>reg.coef</code> (see below). If covariates are missing, then spatio-temporal ordinary kriging cross validation is performed.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_obs.col">obs.col</code></td>
<td>
<p>numeric or character; Column name or number showing position of the observation column in the <code>data</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_data.staid.x.y.z">data.staid.x.y.z</code></td>
<td>
<p>numeric or character vector; Positions or names of the station ID (staid), longitude (x), latitude (y) and 3rd component - time, depth (z) columns in <a href="base.html#topic+data.frame">data.frame</a> object (e.g. c(1,2,3,4)). If <code>data</code> is <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> object, <code>data.staid.x.y.z</code> is used to point staid and z position. If <code>data</code> is <a href="spacetime.html#topic+STFDF-class">STFDF-class</a>, <a href="spacetime.html#topic+STSDF-class">STSDF-class</a>, <a href="spacetime.html#topic+STIDF-class">STIDF-class</a> object, <code>data.staid.x.y.z</code> is used to point only staid position. Default is NULL.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_crs">crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Source CRS of <code>data</code>. If <code>data</code> contains crs, <code>crs</code> will not be used. Default is NA.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_zero.tol">zero.tol</code></td>
<td>
<p>numeric; A distance value below (or equal to) which locations are considered as duplicates. Default is 0. See <a href="#topic+rm.dupl">rm.dupl</a>. Duplicates are removed to avoid singular covariance matrices in kriging.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_reg.coef">reg.coef</code></td>
<td>
<p>numeric; Vector of named linear regression coefficients. Names of the coefficients (e.g. &quot;Intercept&quot;, &quot;temp_geo&quot;, &quot;modis&quot;, &quot;dem&quot;, &quot;twi&quot;) will be used to match appropriate covariates from <code>data</code>. Coefficients for metorological variables (temperature, precipitation, etc.) can be taken from data(<a href="#topic+tregcoef">tregcoef</a>) or can be specified by the user.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_vgm.model">vgm.model</code></td>
<td>
<p>StVariogramModel list; Spatio-temporal variogram of regression residuals (or observations if spatio-temporal ordinary kriging). See <a href="gstat.html#topic+vgmST">vgmST</a>. Spatio-temporal variogram model on residuals for metorological variables (temperature, precipitation, etc.) can be taken from data(<a href="#topic+tvgms">tvgms</a>) or can be specified by the user as a <a href="gstat.html#topic+vgmST">vgmST</a> object.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_sp.nmax">sp.nmax</code></td>
<td>
<p>numeric; A number of spatially nearest observations that should be used for kriging predictions. If <code>tiling</code> is TRUE (see below), then is a number of spatially nearest observations that should be used for each tile. Deafult is 20.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_time.nmax">time.nmax</code></td>
<td>
<p>numeric; A number of temporally nearest observations that should be used for kriging predictions Deafult is 2.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_type">type</code></td>
<td>
<p>character; Type of cross-validation: leave-location-out (&quot;LLO&quot;), leave-time-out (&quot;LTO&quot;), and leave-location-time-out (&quot;LLTO&quot;). Default is &quot;LLO&quot;. &quot;LTO&quot; and &quot;LLTO&quot; are not implemented yet. Will be in the future.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_k">k</code></td>
<td>
<p>numeric; Number of random folds that will be created with <a href="CAST.html#topic+CreateSpacetimeFolds">CreateSpacetimeFolds</a> function. Default is 5.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_seed">seed</code></td>
<td>
<p>numeric; Random seed that will be used to generate outer  and inner folds with <a href="CAST.html#topic+CreateSpacetimeFolds">CreateSpacetimeFolds</a> function.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_folds">folds</code></td>
<td>
<p>numeric or character vector or value; Showing folds column (if value) or rows (vector) of <code>data</code> observations used for cross-validation. If missing, will be created with <a href="CAST.html#topic+CreateSpacetimeFolds">CreateSpacetimeFolds</a> function.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_refit">refit</code></td>
<td>
<p>logical; If refit of linear regression trend and spatio-teporal variogram should be performed. Spatio-teporal variogram is fit using <code>vgm.model</code> as desired spatio-temporal model for <a href="gstat.html#topic+fit.StVariogram">fit.StVariogram</a> function. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_output.format">output.format</code></td>
<td>
<p>character; Format of the output, <a href="spacetime.html#topic+STFDF-class">STFDF-class</a> (default), <a href="spacetime.html#topic+STSDF-class">STSDF-class</a>, <a href="spacetime.html#topic+STIDF-class">STIDF-class</a>, <a href="base.html#topic+data.frame">data.frame</a>, <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a>.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_parallel.processing">parallel.processing</code></td>
<td>
<p>logical; If parallel processing is performed. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_pp.type">pp.type</code></td>
<td>
<p>character; Type (R package) of parallel processing, &quot;snowfall&quot; (default) or &quot;doParallel&quot;.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_cpus">cpus</code></td>
<td>
<p>numeric; Number of processing units. Default is detectCores()-1.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_progress">progress</code></td>
<td>
<p>logical; If progress bar is shown. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cv.strk_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="gstat.html#topic+krigeST">krigeST</a> or <a href="#topic+pred.strk">pred.strk</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="spacetime.html#topic+STFDF-class">STFDF-class</a> (default), <a href="spacetime.html#topic+STSDF-class">STSDF-class</a>, <a href="spacetime.html#topic+STIDF-class">STIDF-class</a>, <a href="base.html#topic+data.frame">data.frame</a>, <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> object (depends on <code>output.format</code> argument), with columns:
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>Observations.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Predictions from cross-validation.</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>Folds used for cross-validation.</p>
</td></tr>
</table>
<p>For accuracy metrics see <a href="#topic+acc.metric.fun">acc.metric.fun</a> function.
</p>


<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a>, Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Kilibarda, M., T. Hengl, G. B. M. Heuvelink, B. Graeler, E. Pebesma, M. Percec Tadic, and B. Bajat (2014), Spatio-temporal interpolation of daily temperatures for global land areas at 1 km resolution, J. Geophys. Res. Atmos., 119, 2294-2313, doi:10.1002/2013JD020803.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acc.metric.fun">acc.metric.fun</a></code>
<code><a href="#topic+pred.strk">pred.strk</a></code>
<code><a href="#topic+tregcoef">tregcoef</a></code>
<code><a href="#topic+tvgms">tvgms</a></code>
<code><a href="#topic+regdata">regdata</a></code>
<code><a href="#topic+meteo2STFDF">meteo2STFDF</a></code>
<code><a href="#topic+tgeom2STFDF">tgeom2STFDF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
library(spacetime)
library(gstat)
library(plyr)
library(CAST)
library(doParallel)
library(ranger)
# preparing data
data(dtempc) 
data(stations)
data(regdata) # covariates, made by mete2STFDF function

regdata@sp@proj4string &lt;- CRS('+proj=longlat +datum=WGS84')
data(tvgms) # ST variogram models
data(tregcoef) # MLR coefficients

lonmin=18 ;lonmax=22.5 ; latmin=40 ;latmax=46
serbia = point.in.polygon(stations$lon, stations$lat, c(lonmin,lonmax,lonmax,lonmin), 
                          c(latmin,latmin,latmax,latmax))
st = stations[ serbia!=0, ] # stations in Serbia approx.
crs = CRS('+proj=longlat +datum=WGS84')

# create STFDF
stfdf &lt;- meteo2STFDF(obs = dtempc,
                     stations = st,
                     crs = crs)

# Cross-validation for mean temperature for days "2011-07-05" and "2011-07-06" 
# global model is used for regression and variogram

# Overlay observations with covariates
time &lt;- index(stfdf@time)
covariates.df &lt;- as.data.frame(regdata)
names_covar &lt;- names(tregcoef[[1]])[-1]
for (covar in names_covar){
  nrowsp &lt;- length(stfdf@sp)
  regdata@sp=as(regdata@sp,'SpatialPixelsDataFrame')
  ov &lt;- sapply(time, function(i) 
    if (covar %in% names(regdata@data)) {
      if (as.Date(i) %in% as.Date(index(regdata@time))) {
        over(stfdf@sp, as(regdata[, i, covar], 'SpatialPixelsDataFrame'))[, covar]
      } else {
        rep(NA, length(stfdf@sp))
      }
    } else {
      over(stfdf@sp, as(regdata@sp[covar], 'SpatialPixelsDataFrame'))[, covar]
    }
  )
  ov &lt;- as.vector(ov)
  if (all(is.na(ov))) {
    stop(paste('There is no overlay of data with covariates!', sep = ""))
  }
  stfdf@data[covar] &lt;- ov
}

# Remove stations out of covariates
for (covar in names_covar){
  # count NAs per stations
  numNA &lt;- apply(matrix(stfdf@data[,covar],
                        nrow=nrowsp,byrow= FALSE), MARGIN=1,
                 FUN=function(x) sum(is.na(x)))
  rem &lt;- numNA != length(time)
  stfdf &lt;-  stfdf[rem,drop= FALSE]
}

# Remove dates out of covariates
rm.days &lt;- c()
for (t in 1:length(time)) {
  if(sum(complete.cases(stfdf[, t]@data)) == 0) {
    rm.days &lt;- c(rm.days, t)
  }
}
if(!is.null(rm.days)){
  stfdf &lt;- stfdf[,-rm.days]
}

### Example with STFDF and without parallel processing and without refitting of variogram
results &lt;- cv.strk(data = stfdf,
                   obs.col = 1, # "tempc"
                   data.staid.x.y.z = c(1,NA,NA,NA),
                   reg.coef = tregcoef[[1]],
                   vgm.model = tvgms[[1]],
                   sp.nmax = 20,
                   time.nmax = 2,
                   type = "LLO",
                   k = 5,
                   seed = 42,
                   refit = FALSE,
                   progress = TRUE
)

# stplot(results[,,"pred"])
summary(results)
# accuracy
acc.metric.fun(results@data$obs, results@data$pred, "R2")
acc.metric.fun(results@data$obs, results@data$pred, "RMSE")
acc.metric.fun(results@data$obs, results@data$pred, "MAE")
acc.metric.fun(results@data$obs, results@data$pred, "CCC")

</code></pre>

<hr>
<h2 id='data.prepare'>Prepare data</h2><span id='topic+data.prepare'></span>

<h3>Description</h3>

<p>Function for data preparation for RFSI and STRK functions. It transforms data to a data.frame.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.prepare(data,
             data.staid.x.y.z=NULL,
             obs.col=NULL,
             s.crs=NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.prepare_+3A_data">data</code></td>
<td>
<p><a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a>, <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a> or <a href="base.html#topic+data.frame">data.frame</a>; Contains target variable (observations) and covariates. If <a href="base.html#topic+data.frame">data.frame</a> object, it should have next columns: station ID (staid), longitude (x), latitude (y), 3rd component - time, depth, ... (z) of the observation, and observation value (obs).</p>
</td></tr>
<tr><td><code id="data.prepare_+3A_data.staid.x.y.z">data.staid.x.y.z</code></td>
<td>
<p>numeric or character vector; Positions or names of the station ID (staid), longitude (x), latitude (y) and 3rd component (z) columns in <a href="base.html#topic+data.frame">data.frame</a> object (e.g. c(1,2,3,4)). If <code>data</code> is <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> object, <code>data.staid.x.y.z</code> is used to point staid and z position. Set z position to NA (e.g. c(1,2,3,NA)) or ommit it (e.g. c(1,2,3)) for spatial interpolation. Default is NULL.</p>
</td></tr>
<tr><td><code id="data.prepare_+3A_obs.col">obs.col</code></td>
<td>
<p>numeric or character; Column name or number showing position of the observation column in the <code>data</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="data.prepare_+3A_s.crs">s.crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Source CRS of <code>data</code>. If <code>data</code> contains crs, <code>s.crs</code> will not be used. Default is NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>data.df</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> obtained from <code>data</code>.</p>
</td></tr>
<tr><td><code>data.staid.x.y.z</code></td>
<td>
<p>Positions of the station ID (staid), longitude (x), latitude (y) and 3rd component (z) columns in <a href="base.html#topic+data.frame">data.frame</a> object (e.g. c(1,2,3,4)).</p>
</td></tr>
<tr><td><code>s.crs</code></td>
<td>
<p>Source CRS of <code>data</code>.</p>
</td></tr>
<tr><td><code>obs.col</code></td>
<td>
<p>Column number showing position of the observation column in the <code>data</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Sekulić, A., Kilibarda, M., Heuvelink, G. B., Nikolić, M. &amp; Bajat, B. Random Forest Spatial Interpolation. Remote. Sens. 12, 1687, https://doi.org/10.3390/rs12101687 (2020).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+near.obs">near.obs</a></code>
<code><a href="#topic+rfsi">rfsi</a></code>
<code><a href="#topic+tune.rfsi">tune.rfsi</a></code>
<code><a href="#topic+cv.rfsi">cv.rfsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
library(meteo)
library(sp)

# prepare data
demo(meuse, echo=FALSE)
meuse &lt;- meuse[complete.cases(meuse@data),]
data = st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
data.df &lt;- data.prepare(data,
                        obs.col="zinc")
str(data.df)
</code></pre>

<hr>
<h2 id='dem_twi_srb'>Digital Elevation Model (DEM) and Topographic Wetness Index (TWI) for Serbia</h2><span id='topic+dem_twi_srb'></span>

<h3>Description</h3>

<p>Digital Elevation Model (DEM) and Topographic Wetness Index (TWI) for Serbia in <a href="terra.html#topic+SpatRaster">SpatRaster</a> format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dem_twi_srb)</code></pre>


<h3>Format</h3>

<p>The <code>dem_twi_srb</code> contains the following layers:
</p>

<dl>
<dt><code>dem</code></dt><dd><p>Digital Elevation Model (DEM) in meters</p>
</dd>
<dt><code>twi</code></dt><dd><p>Topographic Wetness Index (TWI)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
## load data 
data(dem_twi_srb)
terra::unwrap(dem_twi_srb)
</code></pre>

<hr>
<h2 id='dprec'>Daily precipitation amount in mm for July 2011</h2><span id='topic+dprec'></span>

<h3>Description</h3>

<p>Sample data set showing values of merged daily precipitation amount measurements from the Global Surface Summary of Day data (GSOD) with European Climate Assessment &amp; Data set (ECA&amp;D) for the month July 2011.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dprec)</code></pre>


<h3>Format</h3>

<p>The <code>dprec</code> contains the following columns:
</p>

<dl>
<dt><code>staid</code></dt><dd><p>character; station ID from GSOD or ECA&amp;D data set</p>
</dd>
<dt><code>time</code></dt><dd><p>Date; day of the measurement</p>
</dd>
<dt><code>prec</code></dt><dd><p>numeric; daily precipitation amount in mm</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data summaries provided here are based on data exchanged under the World Meteorological Organization (WMO) World Weather Watch Program. To prepare a point map, merge with the <code><a href="#topic+stations">stations</a></code> table containing stations' coordinates.</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda and Tomislav Hengl</p>


<h3>References</h3>


<ul>
<li><p> Global Surface Summary of the day data (<a href="ftp://ftp.ncdc.noaa.gov/pub/data/gsod/">ftp://ftp.ncdc.noaa.gov/pub/data/gsod/</a>) 
</p>
</li>
<li><p> European Climate Assessment &amp; Dataset (<a href="https://www.ecad.eu/dailydata/predefinedseries.php">https://www.ecad.eu/dailydata/predefinedseries.php</a>) 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load data 
data(dprec)
str(dprec)
</code></pre>

<hr>
<h2 id='dslp'>Mean sea level pressure in hPa for July 2011</h2><span id='topic+dslp'></span>

<h3>Description</h3>

<p>Sample data set showing values of merged mean sea level pressure measurements from the Global Surface Summary of Day data (GSOD) with European Climate Assessment &amp; Data set (ECA&amp;D) for the month July 2011.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dslp)</code></pre>


<h3>Format</h3>

<p>The <code>dslp</code> contains the following columns:
</p>

<dl>
<dt><code>staid</code></dt><dd><p>character; station ID from GSOD or ECA&amp;D data set</p>
</dd>
<dt><code>time</code></dt><dd><p>Date; day of the measurement</p>
</dd>
<dt><code>slp</code></dt><dd><p>numeric; mean sea level pressure amount in hPa</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data summaries provided here are based on data exchanged under the World Meteorological Organization (WMO) World Weather Watch Program. To prepare a point map, merge with the <code><a href="#topic+stations">stations</a></code> table containing stations' coordinates.</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda and Tomislav Hengl</p>


<h3>References</h3>


<ul>
<li><p> Global Surface Summary of the day data (<a href="ftp://ftp.ncdc.noaa.gov/pub/data/gsod/">ftp://ftp.ncdc.noaa.gov/pub/data/gsod/</a>) 
</p>
</li>
<li><p> European Climate Assessment &amp; Dataset (<a href="https://www.ecad.eu/dailydata/predefinedseries.php">https://www.ecad.eu/dailydata/predefinedseries.php</a>) 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load data
data(dslp)
str(dslp)
</code></pre>

<hr>
<h2 id='dsndp'>Daily snow depth in cm for July 2011</h2><span id='topic+dsndp'></span>

<h3>Description</h3>

<p>Sample data set showing values of merged daily snow depth measurements from the Global Surface Summary of Day data (GSOD) with European Climate Assessment &amp; Data set (ECA&amp;D) for the month July 2011.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dsndp)</code></pre>


<h3>Format</h3>

<p>The <code>dsndp</code> contains the following columns:
</p>

<dl>
<dt><code>staid</code></dt><dd><p>character; station ID from GSOD or ECA&amp;D data set</p>
</dd>
<dt><code>time</code></dt><dd><p>Date; day of the measurement</p>
</dd>
<dt><code>sndp</code></dt><dd><p>numeric; daily snow depth in cm</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data summaries provided here are based on data exchanged under the World Meteorological Organization (WMO) World Weather Watch Program. To prepare a point map, merge with the <code><a href="#topic+stations">stations</a></code> table containing stations' coordinates.</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda and Tomislav Hengl</p>


<h3>References</h3>


<ul>
<li><p> Global Surface Summary of the day data (<a href="ftp://ftp.ncdc.noaa.gov/pub/data/gsod/">ftp://ftp.ncdc.noaa.gov/pub/data/gsod/</a>) 
</p>
</li>
<li><p> European Climate Assessment &amp; Dataset (<a href="https://www.ecad.eu/dailydata/predefinedseries.php">https://www.ecad.eu/dailydata/predefinedseries.php</a>) 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load data 
data(dsndp)
str(dsndp)
</code></pre>

<hr>
<h2 id='dtemp_maxc'>Maximum daily temperature in degrees Celsius for July 2011</h2><span id='topic+dtemp_maxc'></span>

<h3>Description</h3>

<p>Sample data set showing values of merged maximum daily temperature measurements from the Global Surface Summary of Day data (GSOD) with European Climate Assessment &amp; Dataset (ECA&amp;D) data for the month July 2011.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dtemp_maxc)</code></pre>


<h3>Format</h3>

<p>The <code>dtemp_maxc</code> contains the following columns:
</p>

<dl>
<dt><code>staid</code></dt><dd><p>character; station ID from GSOD or ECA&amp;D dataset</p>
</dd>
<dt><code>time</code></dt><dd><p>Date; day of the measurement</p>
</dd>
<dt><code>temp_minc</code></dt><dd><p>numeric; maximum daily temperature in degrees Celsius</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data summaries provided here are based on data exchanged under the World Meteorological Organization (WMO) World Weather Watch Program. To prepare a point map, merge with the <code><a href="#topic+stations">stations</a></code> table containing stations' coordinates.</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda and Tomislav Hengl</p>


<h3>References</h3>


<ul>
<li><p> Global Surface Summary of the day data (<a href="ftp://ftp.ncdc.noaa.gov/pub/data/gsod/">ftp://ftp.ncdc.noaa.gov/pub/data/gsod/</a>) 
</p>
</li>
<li><p> European Climate Assessment &amp; Dataset (<a href="https://www.ecad.eu/dailydata/predefinedseries.php">https://www.ecad.eu/dailydata/predefinedseries.php</a>) 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load data 
data(dtemp_maxc)
str(dtemp_maxc)
</code></pre>

<hr>
<h2 id='dtemp_minc'>Minimum daily temperature in degrees Celsius for July 2011</h2><span id='topic+dtemp_minc'></span>

<h3>Description</h3>

<p>Sample data set showing values of merged minimum daily temperature measurements from the Global Surface Summary of Day data (GSOD) with European Climate Assessment &amp; Data set (ECA&amp;D) for the month July 2011.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dtemp_minc)</code></pre>


<h3>Format</h3>

<p>The <code>dtemp_minc</code> contains the following columns:
</p>

<dl>
<dt><code>staid</code></dt><dd><p>character; station ID from GSOD or ECA&amp;D data set</p>
</dd>
<dt><code>time</code></dt><dd><p>Date; day of the measurement</p>
</dd>
<dt><code>temp_minc</code></dt><dd><p>numeric; minimum daily temperature in degrees Celsius</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data summaries provided here are based on data exchanged under the World Meteorological Organization (WMO) World Weather Watch Program. To prepare a point map, merge with the <code><a href="#topic+stations">stations</a></code> table containing stations' coordinates.</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda and Tomislav Hengl</p>


<h3>References</h3>


<ul>
<li><p> Global Surface Summary of the day data (<a href="ftp://ftp.ncdc.noaa.gov/pub/data/gsod/">ftp://ftp.ncdc.noaa.gov/pub/data/gsod/</a>) 
</p>
</li>
<li><p> European Climate Assessment &amp; Dataset (<a href="https://www.ecad.eu/dailydata/predefinedseries.php">https://www.ecad.eu/dailydata/predefinedseries.php</a>) 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load data
data(dtemp_minc)
str(dtemp_minc)
</code></pre>

<hr>
<h2 id='dtempc'>Mean daily temperature in degrees Celsius for July 2011</h2><span id='topic+dtempc'></span>

<h3>Description</h3>

<p>Sample data set showing values of merged mean daily temperature measurements from the Global Surface Summary of Day data (GSOD) with European Climate Assessment &amp; Dataset (ECA&amp;D) data for the month July 2011.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dtempc)</code></pre>


<h3>Format</h3>

<p>The <code>dtempc</code> contains the following columns:
</p>

<dl>
<dt><code>staid</code></dt><dd><p>character; station ID from GSOD or ECA&amp;D dataset</p>
</dd>
<dt><code>time</code></dt><dd><p>Date; day of the measurement</p>
</dd>
<dt><code>tempc</code></dt><dd><p>numeric; mean daily temperature in degrees Celsius</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data summaries provided here are based on data exchanged under the World Meteorological Organization (WMO) World Weather Watch Program. To prepare a point map, merge with the <code><a href="#topic+stations">stations</a></code> table containing stations' coordinates.</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda and Tomislav Hengl</p>


<h3>References</h3>


<ul>
<li><p> Global Surface Summary of the day data (<a href="ftp://ftp.ncdc.noaa.gov/pub/data/gsod/">ftp://ftp.ncdc.noaa.gov/pub/data/gsod/</a>) 
</p>
</li>
<li><p> European Climate Assessment &amp; Dataset (<a href="https://www.ecad.eu/dailydata/predefinedseries.php">https://www.ecad.eu/dailydata/predefinedseries.php</a>)  
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load data 
data(dtempc)
str(dtempc)
</code></pre>

<hr>
<h2 id='dtempc_ogimet'>Mean daily temperature in degrees Celsius for the year 2019 for Serbia</h2><span id='topic+dtempc_ogimet'></span>

<h3>Description</h3>

<p>Sample data set of mean daily temperature measurements from the OGIMET service for the year 2019 for Serbian territory.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dtempc_ogimet)</code></pre>


<h3>Format</h3>

<p>The <code>dtempc_ogimet</code> contains the following columns:
</p>

<dl>
<dt><code>staid</code></dt><dd><p>character; station ID from OGIMET</p>
</dd>
<dt><code>name</code></dt><dd><p>character; station name</p>
</dd>
<dt><code>lon</code></dt><dd><p>numeric; Longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>numeric; Latitude</p>
</dd>
<dt><code>elevation</code></dt><dd><p>numeric; Hight</p>
</dd>
<dt><code>time</code></dt><dd><p>Date; day of the measurement</p>
</dd>
<dt><code>tmean</code></dt><dd><p>numeric; mean daily temperature in degrees Celsius</p>
</dd>
<dt><code>dem</code></dt><dd><p>numeric; Digital Elevation Model (DEM) in meters</p>
</dd>
<dt><code>twi</code></dt><dd><p>numeric; Topographic Wetness Index (TWI)</p>
</dd>
<dt><code>cdate</code></dt><dd><p>numeric; Cumulative day from 1960</p>
</dd>
<dt><code>doy</code></dt><dd><p>numeric; Day of year</p>
</dd>
<dt><code>gtt</code></dt><dd><p>numeric; Geometrical temperature trend</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>


<ul>
<li><p> OGIMET service (<a href="https://www.ogimet.com/">https://www.ogimet.com/</a>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load data 
data(dtempc_ogimet)
str(dtempc)
</code></pre>

<hr>
<h2 id='dwdsp'>Daily mean wind speed in m/s for July 2011</h2><span id='topic+dwdsp'></span>

<h3>Description</h3>

<p>Sample data set showing values of merged daily mean wind speed measurements from the Global Surface Summary of Day data (GSOD) with European Climate Assessment &amp; Data set (ECA&amp;D) for the month July 2011.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dwdsp)</code></pre>


<h3>Format</h3>

<p>The <code>dwdsp</code> contains the following columns:
</p>

<dl>
<dt><code>staid</code></dt><dd><p>character; station ID from GSOD or ECA&amp;D data set</p>
</dd>
<dt><code>time</code></dt><dd><p>Date; day of the measurement</p>
</dd>
<dt><code>wdsp</code></dt><dd><p>numeric; daily mean wind speed in m/s</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data summaries provided here are based on data exchanged under the World Meteorological Organization (WMO) World Weather Watch Program. To prepare a point map, merge with the <code><a href="#topic+stations">stations</a></code> table containing stations' coordinates.</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda and Tomislav Hengl</p>


<h3>References</h3>


<ul>
<li><p> Global Surface Summary of the day data (<a href="ftp://ftp.ncdc.noaa.gov/pub/data/gsod/">ftp://ftp.ncdc.noaa.gov/pub/data/gsod/</a>) 
</p>
</li>
<li><p> European Climate Assessment &amp; Dataset (<a href="https://www.ecad.eu/dailydata/predefinedseries.php">https://www.ecad.eu/dailydata/predefinedseries.php</a>) 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load data 
data(dwdsp)
str(dwdsp)
</code></pre>

<hr>
<h2 id='get_meteo'>Get daily meteorological data for specific location and dates.</h2><span id='topic+get_meteo'></span>

<h3>Description</h3>

<p>The function gives back daily metorological data for specific location and dates for Europe for 1991-2020 period (from MeteoEurope1km dataset).</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_meteo(loc,
          dates,
          var = "tmean",
          source = "MeteoEurope1km")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_meteo_+3A_loc">loc</code></td>
<td>
<p><code>sf</code>, <code>SpatVector</code>, <a href="base.html#topic+data.frame">data.frame</a>, <code>matrix</code>, <code>numeric</code> or <code>integer</code>; Locations in WGS84 (EPSG:4326). If <a href="base.html#topic+data.frame">data.frame</a> or <code>matrix</code> columns are lon/lat.</p>
</td></tr>
<tr><td><code id="get_meteo_+3A_dates">dates</code></td>
<td>
<p><code>Date</code> or <code>character</code>; Date(s).</p>
</td></tr>
<tr><td><code id="get_meteo_+3A_var">var</code></td>
<td>
<p><code>character</code>; Daily meteorological variable. Possible values are: <code>"tmean"</code> (default), <code>"tmax"</code>, <code>"tmin"</code>, <code>"prcp"</code>, or <code>"slp"</code>.</p>
</td></tr>
<tr><td><code id="get_meteo_+3A_source">source</code></td>
<td>
<p><code>character</code>; Data source. Possible values are: <code>"MeteoEurope1km"</code> (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+data.frame">data.frame</a> object with daily meteorological values for specific locations (rows) and specific dates (columns). First column is location ID.</p>


<h3>Author(s)</h3>

<p>Aleksandar Sekulić <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pred.strk">pred.strk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

loc &lt;- c(21, 45)
# loc &lt;- as.data.frame(rbind(c(21, 45),
#                            c(21,45.5),
#                            c(21.5,45),
#                            c(21.5,45.5)))

dates &lt;- as.Date("2020-12-25")
# dates &lt;- seq(as.Date("2020-12-25"), as.Date("2020-12-31"), by="day")

tmean &lt;- get_meteo(loc,
                   dates,
                   var = "tmean", # "tmax" "tmin" "prcp" "slp"
                   source = "MeteoEurope1km")
</code></pre>

<hr>
<h2 id='meteo2STFDF'>Create an object of <a href="spacetime.html#topic+STFDF-class">STFDF-class</a> class from two data frames (observation and stations) </h2><span id='topic+meteo2STFDF'></span>

<h3>Description</h3>

<p>The function creates an object of <a href="spacetime.html#topic+STFDF-class">STFDF-class</a> class, spatio-temporal data with full space-time grid, from two data frames (observation and stations). Observations data frame minimum contains station ID column, time column (day of observation) and measured variable column. Stations data frame contains at least station ID column, longitude (or x) and latitude (or y) column.</p>


<h3>Usage</h3>

<pre><code class='language-R'>meteo2STFDF(obs,
            stations,
            obs.staid.time = c(1, 2),
            stations.staid.lon.lat = c(1, 2, 3),
            crs=CRS(as.character(NA)),
            delta=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meteo2STFDF_+3A_obs">obs</code></td>
<td>
<p> data.frame; observations data frame minimum contains station ID column, time column (day of observation) and measured variable column. It can contain additional variables (columns).</p>
</td></tr>
<tr><td><code id="meteo2STFDF_+3A_stations">stations</code></td>
<td>
<p> data.frame; Stations data frame contains at least station ID column, longitude (or x) and latitude (or y) column.It can contain additional variables (columns).</p>
</td></tr>
<tr><td><code id="meteo2STFDF_+3A_obs.staid.time">obs.staid.time</code></td>
<td>
<p> numeric; records the column positions where in <code>obs</code> (observation) data frame the station ID and time values are stored.</p>
</td></tr>
<tr><td><code id="meteo2STFDF_+3A_stations.staid.lon.lat">stations.staid.lon.lat</code></td>
<td>
<p> numeric; records the column positions where in <code>stations</code> data frame the station ID, longitude (x) and latitude (y) values are stored.</p>
</td></tr>
<tr><td><code id="meteo2STFDF_+3A_crs">crs</code></td>
<td>
<p> CRS; coordinate reference system (see <a href="sp.html#topic+CRS-class">CRS-class</a>) of <code>stations</code> coordinates
</p>
</td></tr>
<tr><td><code id="meteo2STFDF_+3A_delta">delta</code></td>
<td>
<p> time;  time interval to end points in seconds
</p>
</td></tr>
</table>


<h3>Value</h3>

 <p><a href="spacetime.html#topic+STFDF-class">STFDF-class</a> object</p>


<h3>Note</h3>

<p>The function is intended for conversion of meteorological data to <a href="spacetime.html#topic+STFDF-class">STFDF-class</a> object, but can be used for similar spatio temporal data stored in two separated tables.</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a>, Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+tgeom2STFDF">tgeom2STFDF</a></code>,
<code><a href="#topic+pred.strk">pred.strk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare data
# load observation - data.frame of mean temperatures
data(dtempc) 
# str(dtempc)
data(stations)
# str(stations)
lonmin=18 ;lonmax=22.5 ; latmin=40 ;latmax=46
library(sp)
library(spacetime)
serbia = point.in.polygon(stations$lon, stations$lat, c(lonmin,lonmax,lonmax,lonmin), 
                          c(latmin,latmin,latmax,latmax))
st= stations[ serbia!=0, ] # stations in Serbia approx.
# create STFDF
temp &lt;- meteo2STFDF(dtempc,st, crs= CRS('+proj=longlat +datum=WGS84'))
# str(temp)

</code></pre>

<hr>
<h2 id='near.obs'>Finds n nearest observations from given locations.</h2><span id='topic+near.obs'></span>

<h3>Description</h3>

<p>The function finds n nearest observations from given locations and creates an object of <a href="base.html#topic+data.frame">data.frame</a> class.
First n columns are Euclidean distances to n nearest locations and next n columns are observations at n nearest stations, and rows are given locations. Further more it can calculate averages in circles with different radiuses, can find nearest observation in quadrants (directions) and calculate IDW predictions from nearest observations. It is based on <a href="nabor.html#topic+knn">knn</a> function of package nabor.</p>


<h3>Usage</h3>

<pre><code class='language-R'>near.obs(locations,
         locations.x.y = c(1,2),
         observations,
         observations.x.y = c(1,2),
         obs.col = 3,
         n.obs = 10,
         rm.dupl = TRUE,
         avg = FALSE,
         increment,
         range,
         quadrant = FALSE,
         idw=FALSE,
         idw.p=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="near.obs_+3A_locations">locations</code></td>
<td>
<p>data.frame with x and y coordinates columns, or <a href="sf.html#topic+sf">sf-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> or <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a> object; Locations (FROM) for which n nearest observations are found and distances are calculated.</p>
</td></tr>
<tr><td><code id="near.obs_+3A_locations.x.y">locations.x.y</code></td>
<td>
<p>numeric or character vector; Positions or names of the x and y columns in <code>locations</code> if data.frame. Default is c(1,2).</p>
</td></tr>
<tr><td><code id="near.obs_+3A_observations">observations</code></td>
<td>
<p>data.frame with x, y and observation columns, or <a href="sf.html#topic+sf">sf-class</a> or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> object with an observation column; Observations (TO).</p>
</td></tr>
<tr><td><code id="near.obs_+3A_observations.x.y">observations.x.y</code></td>
<td>
<p>numeric or character vector; Positions or names of the x and y columns in <code>observations</code> if data.frame. Default is c(1,2).</p>
</td></tr>
<tr><td><code id="near.obs_+3A_obs.col">obs.col</code></td>
<td>
<p>numeric or character; Column name or number showing position of the observation column in the <code>observations</code>. Default is 3.</p>
</td></tr>
<tr><td><code id="near.obs_+3A_n.obs">n.obs</code></td>
<td>
<p>numeric; Number of nearest observations to be found. Note that it cannot be larger than number of obsevrations. Default is 10.</p>
</td></tr>
<tr><td><code id="near.obs_+3A_rm.dupl">rm.dupl</code></td>
<td>
<p>boolean; Remove spatial duplicates - will the spatial duplicates (nearest observations where Euclidean distance is 0) be removed from the result. Default is TRUE.</p>
</td></tr>
<tr><td><code id="near.obs_+3A_avg">avg</code></td>
<td>
<p>boolean; Averages in circles - will averages in circles with different radiuses be calculated. Default is FALSE.</p>
</td></tr>
<tr><td><code id="near.obs_+3A_increment">increment</code></td>
<td>
<p>numeric; Increment of radiuses for calculation of averages in circles with different radiuses. Units depends on CRS.</p>
</td></tr>
<tr><td><code id="near.obs_+3A_range">range</code></td>
<td>
<p>numeric; Maximum radius for calculation of averages in circles with different radiuses. Units depends on CRS.</p>
</td></tr>
<tr><td><code id="near.obs_+3A_quadrant">quadrant</code></td>
<td>
<p>boolean; Nearest observations in quadrants - will nearest observation in quadrants be calculated. Default is FALSE.</p>
</td></tr>
<tr><td><code id="near.obs_+3A_idw">idw</code></td>
<td>
<p>boolean; IDW prediction as predictor - will IDW predictions from <code>n.obs</code> nearest observations be calculated. Default is FALSE.</p>
</td></tr>
<tr><td><code id="near.obs_+3A_idw.p">idw.p</code></td>
<td>
<p>numeric; Exponent parameter for IDW weights. Default is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

 <p><a href="base.html#topic+data.frame">data.frame</a> object.  Rows represents specific locations. First <code>n.obs</code> columns are Euclidean distances to <code>n.obs</code> nearest observations. Next <code>n.obs</code> columns are observations at <code>n.obs</code> nearest stations. The following columns are averages in circles with different radiuses if <code>avg</code> is set to TRUE. The following columns are nearest observation in quadrants if <code>direct</code> is set to TRUE. The following columns are IDW prediction from nearest observation if <code>idw</code> is set to TRUE.
</p>


<h3>Note</h3>

<p>The function can be used in any case if it is needed to find n nearest observations from given locations and distances to them.</p>


<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Sekulić, A., Kilibarda, M., Heuvelink, G. B., Nikolić, M. &amp; Bajat, B. Random Forest Spatial Interpolation. Remote. Sens. 12, 1687, https://doi.org/10.3390/rs12101687 (2020).
</p>


<h3>See Also</h3>

<p><code><a href="nabor.html#topic+knn">knn</a></code>
<code><a href="#topic+rfsi">rfsi</a></code>
<code><a href="#topic+pred.rfsi">pred.rfsi</a></code>
<code><a href="#topic+tune.rfsi">tune.rfsi</a></code>
<code><a href="#topic+cv.rfsi">cv.rfsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
library(sf)
library(terra)
library(meteo)
# prepare data
# load observation - data.frame of mean temperatures
demo(meuse, echo=FALSE)
meuse &lt;- meuse[complete.cases(meuse@data),]
locations = terra::rast(meuse.grid)
observations = st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
# find 5 nearest observations and distances to them (remove duplicates)
nearest_obs &lt;- near.obs(locations = locations, # from
                        observations = observations, # to
                        obs.col = "zinc",
                        n.obs = 5, # number of nearest observations
                        rm.dupl = TRUE) 
str(nearest_obs)
summary(nearest_obs)
</code></pre>

<hr>
<h2 id='near.obs.soil'>Finds n nearest observations from given locations for soil mapping.</h2><span id='topic+near.obs.soil'></span>

<h3>Description</h3>

<p>The function finds n nearest observations from given locations and at specific depth range from location min depth and creates an object of <a href="base.html#topic+data.frame">data.frame</a> class.
First n columns are Euclidean distances to n nearest locations and next n columns are observations at n nearest stations, and rows are given locations. It is based on <a href="nabor.html#topic+knn">knn</a> function of package nabor.</p>


<h3>Usage</h3>

<pre><code class='language-R'>near.obs.soil(locations,
              locations.x.y.md = c(1,2,3),
              observations,
              observations.x.y.md = c(1,2,3),
              obs.col = 4,
              n.obs = 5,
              depth.range = 0.1,
              no.obs = 'increase',
              parallel.processing = TRUE,
              pp.type = "doParallel", # "snowfall"
              cpus = detectCores()-1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="near.obs.soil_+3A_locations">locations</code></td>
<td>
<p>data.frame with x and y coordinates and mid depth columns, or <a href="sf.html#topic+sf">sf-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> or <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a> object; Locations (FROM) for which n nearest observations are found and distances are calculated.</p>
</td></tr>
<tr><td><code id="near.obs.soil_+3A_locations.x.y.md">locations.x.y.md</code></td>
<td>
<p>numeric or character vector; Positions or names of the x, y, and mid depth columns in <code>locations</code> if data.frame. Default is c(1,2,3).</p>
</td></tr>
<tr><td><code id="near.obs.soil_+3A_observations">observations</code></td>
<td>
<p>data.frame with x, y, mid depth and observation columns, or <a href="sf.html#topic+sf">sf-class</a> or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> object with mid depth and observation columns; Observations (TO).</p>
</td></tr>
<tr><td><code id="near.obs.soil_+3A_observations.x.y.md">observations.x.y.md</code></td>
<td>
<p>numeric or character vector; positions or names of the x, y, and mid depth columns in <code>observations</code> if data.frame. Default is c(1,2,3).</p>
</td></tr>
<tr><td><code id="near.obs.soil_+3A_obs.col">obs.col</code></td>
<td>
<p>numeric or character; Column name or number showing position of the observation column in the <code>observations</code>. Default is 4.</p>
</td></tr>
<tr><td><code id="near.obs.soil_+3A_n.obs">n.obs</code></td>
<td>
<p>numeric; Number of nearest observations to be found. Note that it cannot be larger than number of obsevrations. Default is 5.</p>
</td></tr>
<tr><td><code id="near.obs.soil_+3A_depth.range">depth.range</code></td>
<td>
<p>numeric; Depth range for location mid depth in which to search for nearest observations. It's in the mid depth units. Default is 0.1.</p>
</td></tr>
<tr><td><code id="near.obs.soil_+3A_no.obs">no.obs</code></td>
<td>
<p>character; Possible values are <code>increase</code> (default) and <code>exactly</code>. If set to <code>increase</code>, in case if there is no <code>n.obs</code> observations in <code>depth.range</code> for a specific location, the <code>depth.range</code> is increased (multiplied by 2, 3, ...) until the number of observations are larger or equal to <code>n.obs</code>. If set to <code>exactly</code>, the function will raise an error when it come to the first location with no <code>n.obs</code> observations in specified <code>depth.range</code>.</p>
</td></tr>
<tr><td><code id="near.obs.soil_+3A_parallel.processing">parallel.processing</code></td>
<td>
<p>logical; If parallel processing is performed. Default is FALSE.</p>
</td></tr>
<tr><td><code id="near.obs.soil_+3A_pp.type">pp.type</code></td>
<td>
<p>character; Type (R package) used for parallel processing, &quot;doParallel&quot; (default) or &quot;snowfall&quot;.</p>
</td></tr>
<tr><td><code id="near.obs.soil_+3A_cpus">cpus</code></td>
<td>
<p>numeric; Number of processing units. Default is detectCores()-1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+data.frame">data.frame</a> object.  Rows represents specific locations. First <code>n.obs</code> columns are Euclidean distances to <code>n.obs</code> nearest observations. Next <code>n.obs</code> columns are observations at <code>n.obs</code> nearest stations.
</p>


<h3>Note</h3>

<p>The function is intended for soil mapping applications.</p>


<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a>, Anatol Helfenstein <a href="mailto:anatol.helfenstein@wur.nl">anatol.helfenstein@wur.nl</a></p>


<h3>See Also</h3>

<p><code><a href="nabor.html#topic+knn">knn</a></code>
<code><a href="#topic+near.obs">near.obs</a></code>
<code><a href="#topic+rfsi">rfsi</a></code>
<code><a href="#topic+pred.rfsi">pred.rfsi</a></code>
<code><a href="#topic+tune.rfsi">tune.rfsi</a></code>
<code><a href="#topic+cv.rfsi">cv.rfsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
library(sf)
library(meteo)
# prepare data
# load observation - data.frame of mean temperatures
demo(meuse, echo=FALSE)
meuse &lt;- meuse[complete.cases(meuse@data),]
locations = st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
locations = # terra::rast(meuse.grid)
observations = st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
# find 5 nearest observations and distances to them (remove duplicates)
nearest_obs &lt;- near.obs.soil(locations = locations, # from
                             locations.x.y.md =  c("x","y","dist"),
                             observations = observations, # to
                             observations.x.y.md= c("x","y","dist"),
                             obs.col = "zinc",
                             n.obs = 5) # number of nearest observations
str(nearest_obs)
summary(nearest_obs)
</code></pre>

<hr>
<h2 id='nlmodis20110704'>MODIS LST 8 day images image for the Netherlands ('2011-07-04') 
</h2><span id='topic+nlmodis20110704'></span>

<h3>Description</h3>

<p>The original 8 day MODIS LST images were also converted from Kelvin to degrees Celsius using the formula indicated in the MODIS user's manual.<a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nlmodis20110704)</code></pre>


<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Wan, Z., Y. Zhang, Q. Zhang, and Z.-L. Li (2004), Quality assessment and validation of the MODIS global land surface temperature, Int. J. Remote Sens., 25(1), 261-274</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nlmodis20110704)
# spplot(nlmodis20110704)
</code></pre>

<hr>
<h2 id='nlmodis20110712'>MODIS LST 8 day images image for the Netherlands ('2011-07-12') 
</h2><span id='topic+nlmodis20110712'></span>

<h3>Description</h3>

<p>The original 8 day MODIS LST images were also converted from Kelvin to degrees Celsius using the formula indicated in the MODIS user's manual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nlmodis20110712)</code></pre>


<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Wan, Z., Y. Zhang, Q. Zhang, and Z.-L. Li (2004), Quality assessment and validation of the MODIS global land surface temperature, Int. J. Remote Sens., 25(1), 261-274</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nlmodis20110712)
# spplot(nlmodis20110712)
</code></pre>

<hr>
<h2 id='NLpol'>The Netherlands border polygon from WCAB
</h2><span id='topic+NLpol'></span>

<h3>Description</h3>

<p><a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a> from World Country Admin Boundary Shapefile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NLpol)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(NLpol)
##  plot(NLpol) ...
</code></pre>

<hr>
<h2 id='pred.rfsi'>Random Forest Spatial Interpolation (RFSI) prediction</h2><span id='topic+pred.rfsi'></span>

<h3>Description</h3>

<p>Function for spatial/spatio-temporal prediction based on Random Forest Spatial Interpolation (RFSI) model (Sekulić et al. 2020).</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.rfsi(model,
          data,
          obs.col=1,
          data.staid.x.y.z = NULL,
          newdata,
          newdata.staid.x.y.z = NULL,
          z.value = NULL,
          s.crs = NA,
          newdata.s.crs=NA,
          p.crs = NA,
          output.format = "data.frame",
          cpus = detectCores()-1,
          progress = TRUE,
          soil3d = FALSE, # soil RFSI
          depth.range = 0.1, # in units of depth
          no.obs = 'increase',
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.rfsi_+3A_model">model</code></td>
<td>
<p>ranger; An RFSI model made by <a href="#topic+rfsi">rfsi</a> function.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_data">data</code></td>
<td>
<p><a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> or <a href="base.html#topic+data.frame">data.frame</a>; Contains target variable (observations) and covariates used for RFSI prediction. If <a href="base.html#topic+data.frame">data.frame</a> object, it should have next columns: station ID (staid), longitude (x), latitude (y), 3rd component - time, depth, ... (z) of the observation, and observation value (obs).</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_obs.col">obs.col</code></td>
<td>
<p>numeric or character; Column name or number showing position of the observation column in the <code>data</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_data.staid.x.y.z">data.staid.x.y.z</code></td>
<td>
<p>numeric or character vector; Positions or names of the station ID (staid), longitude (x), latitude (y) and 3rd component (z) columns in <a href="base.html#topic+data.frame">data.frame</a> object (e.g. c(1,2,3,4)). If <code>data</code> is <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> object, <code>data.staid.x.y.z</code> is used to point staid and z position. Set z position to NA (e.g. c(1,2,3,NA)) or ommit it (e.g. c(1,2,3)) for spatial interpolation. Default is NULL.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_newdata">newdata</code></td>
<td>
<p><a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a>, <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a> or <a href="base.html#topic+data.frame">data.frame</a>; Contains prediction locations and covariates used for RFSI prediction. If <a href="base.html#topic+data.frame">data.frame</a> object, it should have next columns: prediction location ID (staid), longitude (x), latitude (y), 3rd component - time, depth, ... (z), and covariates (cov1, cov2, ...). Covariate names have to be the same as in the <code>model</code>.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_newdata.staid.x.y.z">newdata.staid.x.y.z</code></td>
<td>
<p>numeric or character vector; Positions or names of the prediction location ID (staid), longitude (x), latitude (y) and 3rd component (z) columns in data.frame <code>newdata</code> object (e.g. c(1,2,3,4)). If <code>newdata</code> is <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> or <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a> object, <code>newdata.staid.x.y.z</code> is used to point staid and z position. Set z position to NA (e.g. c(1,2,3,NA)) or ommit it (e.g. c(1,2,3)) for spatial interpolation. Default is NULL.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_z.value">z.value</code></td>
<td>
<p>vector; A vector of 3rd component - time, depth, ... (z) values if <code>newdata</code> is <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a>.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_s.crs">s.crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Source CRS of <code>data</code>. If <code>data</code> contains crs, <code>s.crs</code> will not be used. Default is NA.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_newdata.s.crs">newdata.s.crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Source CRS of <code>newdata</code>. If <code>newdata</code> contains crs, <code>newdata.s.crs</code> will not be used. Default is NA.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_p.crs">p.crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Projection CRS for <code>data</code> reprojection. If NA, <code>s.crs</code> will be used for distance calculation. Note that observations should be in projection for finding nearest observations based on Eucleadean distances (see function <a href="#topic+near.obs">near.obs</a>). Default is NA.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_output.format">output.format</code></td>
<td>
<p>character; Format of the output, <a href="base.html#topic+data.frame">data.frame</a> (default), <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a>, or <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a>.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_cpus">cpus</code></td>
<td>
<p>numeric; Number of processing units. Default is detectCores()-1.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_progress">progress</code></td>
<td>
<p>logical; If progress bar is shown. Default is TRUE.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_soil3d">soil3d</code></td>
<td>
<p>logical; If 3D soil modellig is performed and <a href="#topic+near.obs.soil">near.obs.soil</a> function is used for finding n nearest observations and distances to them. In this case, z position of the <code>data.staid.x.y.z</code> points to the depth column.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_depth.range">depth.range</code></td>
<td>
<p>numeric; Depth range for location mid depth in which to search for nearest observations (see function <a href="#topic+near.obs.soil">near.obs.soil</a>). It's in the mid depth units. Default is 0.1.</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_no.obs">no.obs</code></td>
<td>
<p>character; Possible values are <code>increase</code> (default) and <code>exactly</code>. If set to <code>increase</code>, in case if there is no <code>n.obs</code> observations in <code>depth.range</code> for a specific location, the <code>depth.range</code> is increased (multiplied by 2, 3, ...) until the number of observations are larger or equal to <code>n.obs</code>. If set to <code>exactly</code>, the function will raise an error when it come to the first location with no <code>n.obs</code> observations in specified <code>depth.range</code> (see function <a href="#topic+near.obs.soil">near.obs.soil</a>).</p>
</td></tr>
<tr><td><code id="pred.rfsi_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="ranger.html#topic+predict.ranger">predict.ranger</a> function, such as <code>type = "quantile"</code> and <code>quantiles = c(0.1,0.5,0.9)</code> for quantile regression, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+data.frame">data.frame</a>, <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a>, or <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a> object (depends on <code>output.format</code> argument) with prediction - <code>pred</code> or <code>quantile..X.X</code> (quantile regression) columns.
</p>


<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Sekulić, A., Kilibarda, M., Heuvelink, G. B., Nikolić, M. &amp; Bajat, B. Random Forest Spatial Interpolation. Remote. Sens. 12, 1687, https://doi.org/10.3390/rs12101687 (2020).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+near.obs">near.obs</a></code>
<code><a href="#topic+rfsi">rfsi</a></code>
<code><a href="#topic+tune.rfsi">tune.rfsi</a></code>
<code><a href="#topic+cv.rfsi">cv.rfsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ranger)
library(sp)
library(sf)
library(terra)
library(meteo)

# prepare data
demo(meuse, echo=FALSE)
meuse &lt;- meuse[complete.cases(meuse@data),]
data = st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
# data = terra::vect(meuse)
# data.frame
# data &lt;- as.data.frame(meuse)
# data$id = 1:nrow(data)
# data.staid.x.y.z &lt;- c("id","x","y",NA)
fm.RFSI &lt;- as.formula("zinc ~ dist + soil + ffreq")

# fit the RFSI model
rfsi_model &lt;- rfsi(formula = fm.RFSI,
                   data = data, # meuse.df (use data.staid.x.y.z)
                   # data.staid.x.y.z = data.staid.x.y.z, # only if class(data) == data.frame
                   n.obs = 5, # number of nearest observations
                   # s.crs = st_crs(data), # nedded only if the coordinates are lon/lat (WGS84)
                   # p.crs = st_crs(data), # nedded only if the coordinates are lon/lat (WGS84)
                   cpus = detectCores()-1,
                   progress = TRUE,
                   # ranger parameters
                   importance = "impurity",
                   seed = 42,
                   num.trees = 250,
                   mtry = 5,
                   splitrule = "variance",
                   min.node.size = 5,
                   sample.fraction = 0.95,
                   quantreg = FALSE)
                   # quantreg = TRUE) # for quantile regression

rfsi_model
# OOB prediction error (MSE):       47758.14 
# R squared (OOB):                  0.6435869 
sort(rfsi_model$variable.importance)
sum("obs" == substr(rfsi_model$forest$independent.variable.names, 1, 3))

# Make RFSI prediction
# data.frame
# newdata &lt;- as.data.frame(meuse.grid)
# newdata$id &lt;- 1:nrow(newdata)
# newdata &lt;- meuse.grid
newdata &lt;- terra::rast(meuse.grid)
class(newdata)

# prediction
rfsi_prediction &lt;- pred.rfsi(model = rfsi_model,
                             data = data, # meuse.df (use data.staid.x.y.z)
                             obs.col = "zinc",
                             # data.staid.x.y.z = data.staid.x.y.z, # data.frame
                             newdata = newdata, # meuse.grid.df (use newdata.staid.x.y.z)
                             # newdata.staid.x.y.z = c("id", "x", "y", NA), # data.frame
                             output.format = "SpatRaster", # "sf", # "SpatVector", 
                             zero.tol = 0,
                             # s.crs = st_crs(data), # meuse@proj4string, # NA # st_crs(data)
                             # newdata.s.crs = st_crs(data), # meuse@proj4string, # NA
                             # p.crs = st_crs(data), # meuse@proj4string, # NA
                             cpus = 1, # detectCores()-1,
                             progress = TRUE,
                             # type = "quantiles", # for quantile regression
                             # quantiles = c(0.1, 0.5, 0.9) # for quantile regression
)
class(rfsi_prediction)
names(rfsi_prediction)
# head(rfsi_prediction)

# plot(rfsi_prediction)
# plot(rfsi_prediction['pred'])
# plot(rfsi_prediction['quantile..0.1'])
# plot(rfsi_prediction['quantile..0.5'])
# plot(rfsi_prediction['quantile..0.9'])
</code></pre>

<hr>
<h2 id='pred.strk'>Spatio-temporal regression kriging prediction</h2><span id='topic+pred.strk'></span>

<h3>Description</h3>

<p>Function for spatio-temporal regression kriging prediction based on <a href="gstat.html#topic+krigeST">krigeST</a>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.strk(data,
          obs.col=1,
          data.staid.x.y.z = NULL,
          newdata,
          newdata.staid.x.y.z = NULL,
          z.value = NULL,
          crs = NA,
          zero.tol=0,
          reg.coef,
          vgm.model,
          sp.nmax=20,
          time.nmax=2,
          by='time',
          tiling= FALSE,
          ntiles=64,
          output.format = "STFDF",
          parallel.processing = FALSE,
          pp.type = "snowfall",
          cpus=detectCores()-1,
          computeVar=FALSE,
          progress=TRUE,
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.strk_+3A_data">data</code></td>
<td>
<p><a href="spacetime.html#topic+STFDF-class">STFDF-class</a>, <a href="spacetime.html#topic+STSDF-class">STSDF-class</a>, <a href="spacetime.html#topic+STIDF-class">STIDF-class</a>, <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> or <a href="base.html#topic+data.frame">data.frame</a>; Contains target variable (observations) and covariates in space and time used to perform STRK. If <a href="base.html#topic+data.frame">data.frame</a> object, it should have next columns: station ID (staid), longitude (x), latitude (y), 3rd component - time, depth, ... (z) of the observation, observation value (obs), and covariates (cov1, cov2, ...). Covariate names should be the same as in the <code>reg.coef</code> (see below). If covariates are missing, overlay with <code>newdata</code> is tried. If overlay with <code>newdata</code> is not possible, then spatio-temporal ordinary kriging is performed.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_obs.col">obs.col</code></td>
<td>
<p>numeric or character; Column name or number showing position of the observation column in the <code>data</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_data.staid.x.y.z">data.staid.x.y.z</code></td>
<td>
<p>numeric or character vector; Positions or names of the station ID (staid), longitude (x), latitude (y) and 3rd component - time, depth (z) columns in <a href="base.html#topic+data.frame">data.frame</a> object (e.g. c(1,2,3,4)). If <code>data</code> is <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> object, <code>data.staid.x.y.z</code> is used to point staid and z position. Default is NULL.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_newdata">newdata</code></td>
<td>
<p><a href="spacetime.html#topic+STFDF-class">STFDF-class</a>, <a href="spacetime.html#topic+STSDF-class">STSDF-class</a>, <a href="spacetime.html#topic+STIDF-class">STIDF-class</a>, <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a>, <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a> or <a href="base.html#topic+data.frame">data.frame</a>; Contains prediction locations and covariates used for STRK prediction. If <a href="base.html#topic+data.frame">data.frame</a> object, it should have next columns: prediction location ID (staid), longitude (x), latitude (y), 3rd component - time, depth, ... (z), and covariates (cov1, cov2, ...). Covariate names have to be the same as in the <code>reg.coef</code> (see below).</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_newdata.staid.x.y.z">newdata.staid.x.y.z</code></td>
<td>
<p>numeric or character vector; Positions or names of the prediction location ID (staid), longitude (x), latitude (y) and 3rd component (z) columns in data.frame <code>newdata</code> object (e.g. c(1,2,3,4)). If <code>newdata</code> is <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> or <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a> object, <code>newdata.staid.x.y.z</code> is used to point staid and z position. Default is NULL.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_z.value">z.value</code></td>
<td>
<p>vector; A vector of 3rd component - time, depth, ... (z) values if <code>newdata</code> is <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a>.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_crs">crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Source CRS of <code>data</code> and <code>newdata</code>. If <code>data</code> or <code>newdata</code> contains crs, <code>crs</code> will not be used. Default is NA.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_zero.tol">zero.tol</code></td>
<td>
<p>numeric; A distance value below (or equal to) which locations are considered as duplicates. Default is 0. See <a href="#topic+rm.dupl">rm.dupl</a>. Duplicates are removed to avoid singular covariance matrices in kriging.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_reg.coef">reg.coef</code></td>
<td>
<p>numeric; Vector of named linear regression coefficients. Names of the coefficients (e.g. &quot;Intercept&quot;, &quot;temp_geo&quot;, &quot;modis&quot;, &quot;dem&quot;, &quot;twi&quot;) will be used to match appropriate covariates from <code>data</code>. Coefficients for metorological variables (temperature, precipitation, etc.) can be taken from data(<a href="#topic+tregcoef">tregcoef</a>) or can be specified by the user.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_vgm.model">vgm.model</code></td>
<td>
<p>StVariogramModel list; Spatio-temporal variogram of regression residuals (or observations if spatio-temporal ordinary kriging). See <a href="gstat.html#topic+vgmST">vgmST</a>. Spatio-temporal variogram model on residuals for metorological variables (temperature, precipitation, etc.) can be taken from data(<a href="#topic+tvgms">tvgms</a>) or can be specified by the user as a <a href="gstat.html#topic+vgmST">vgmST</a> object.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_sp.nmax">sp.nmax</code></td>
<td>
<p>numeric; A number of spatially nearest observations that should be used for kriging predictions. If <code>tiling</code> is TRUE (see below), then is a number of spatially nearest observations that should be used for each tile. Deafult is 20.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_time.nmax">time.nmax</code></td>
<td>
<p>numeric; A number of temporally nearest observations that should be used for kriging predictions Deafult is 2.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_by">by</code></td>
<td>
<p>cahracter; Will foreach loop by time (default) or station. If station is set, <code>sp.nmax</code> will be used for each station prediction.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_tiling">tiling</code></td>
<td>
<p>logical; Should simplified local kriging be used. Default is FALSE. If TRUE, area is divided in tiles and kriging calculation is done for each tile separately. Number of observation used per tile is defined with <code>sp.nmax</code> and <code>time.nmax</code>. If <code>FALSE</code>, temporal local kriging will be applied defined.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_ntiles">ntiles</code></td>
<td>
<p>numeric; A number of tiles for tilling. Default is 64. Ideally, each tile should contain less observations than <code>sp.nmax</code> and observations fall in neighboring tiles.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_output.format">output.format</code></td>
<td>
<p>character; Format of the output, <a href="spacetime.html#topic+STFDF-class">STFDF-class</a> (default), <a href="spacetime.html#topic+STSDF-class">STSDF-class</a>, <a href="spacetime.html#topic+STIDF-class">STIDF-class</a>, <a href="base.html#topic+data.frame">data.frame</a>, <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a>, or <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a>.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_parallel.processing">parallel.processing</code></td>
<td>
<p>logical; If parallel processing is performed. Default is FALSE.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_pp.type">pp.type</code></td>
<td>
<p>character; Type (<code>R</code> package) for parallel processing, &quot;snowfall&quot; (default) or &quot;doParallel&quot;.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_cpus">cpus</code></td>
<td>
<p>numeric; Number of processing units. Default is detectCores()-1.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_computevar">computeVar</code></td>
<td>
<p>logical; If kriging variance is computed. Default is FALSE.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_progress">progress</code></td>
<td>
<p>logical; If progress bar is shown. Default is TRUE.</p>
</td></tr>
<tr><td><code id="pred.strk_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="gstat.html#topic+krigeST">krigeST</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="spacetime.html#topic+STFDF-class">STFDF-class</a>, <a href="spacetime.html#topic+STSDF-class">STSDF-class</a>, <a href="spacetime.html#topic+STIDF-class">STIDF-class</a>, <a href="base.html#topic+data.frame">data.frame</a>, <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a>, or <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a> object (depends on <code>output.format</code> argument), with columns (elements):
</p>
<table>
<tr><td><code>pred</code></td>
<td>
<p>Predictions.</p>
</td></tr>
<tr><td><code>tlm</code></td>
<td>
<p>Trend.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>Kriging variance, if <code>computeVar=TRUE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a>, Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Kilibarda, M., T. Hengl, G. B. M. Heuvelink, B. Graeler, E. Pebesma, M. Percec Tadic, and B. Bajat (2014), Spatio-temporal interpolation of daily temperatures for global land areas at 1 km resolution, J. Geophys. Res. Atmos., 119, 2294-2313, doi:10.1002/2013JD020803.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tregcoef">tregcoef</a></code>
<code><a href="#topic+tvgms">tvgms</a></code>
<code><a href="#topic+regdata">regdata</a></code>
<code><a href="#topic+meteo2STFDF">meteo2STFDF</a></code>
<code><a href="#topic+tgeom2STFDF">tgeom2STFDF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
library(spacetime)
library(sf)
library(gstat)
library(plyr)
# prepare data
# load observation - data.frame of mean temperatures
# preparing data
data(dtempc) 
data(stations)
data(regdata) # covariates, made by mete2STFDF function
regdata@sp@proj4string &lt;- CRS('+proj=longlat +datum=WGS84')

lonmin=18 ;lonmax=22.5 ; latmin=40 ;latmax=46
serbia = point.in.polygon(stations$lon, stations$lat, c(lonmin,lonmax,lonmax,lonmin), 
                          c(latmin,latmin,latmax,latmax))
st = stations[ serbia!=0, ] # stations in Serbia approx.
obs.staid.time = c("staid", "time")
stations.staid.lon.lat = c(1,2,3)
crs = CRS('+proj=longlat +datum=WGS84')
delta = NULL

## Not run: 
# create STFDF
stfdf &lt;- meteo2STFDF(obs = dtempc,
                     stations = st,
                     crs = crs)

# Calculate prediction of mean temperatures for "2011-07-05" and "2011-07-06" 
# global model is used for regression and variogram
# load precalculated variograms
data(tvgms) # ST variogram models
data(tregcoef) # MLR coefficients

### Example with STFDF and without parallel processing
results &lt;- pred.strk(data = stfdf, # observations
                     newdata = regdata, # prediction locations with covariates
                     # newdata = regdata[,2,drop=FALSE], # for one day only
                     output.format = "STFDF", # data.frame | sf | sftime | SpatVector | SpatRaster 
                     reg.coef = tregcoef[[1]], # MLR coefficients
                     vgm.model = tvgms[[1]], # STRK variogram model
                     sp.nmax = 20,
                     time.nmax = 2,
                     computeVar=TRUE
)
class(results)
# plot prediction
# results@sp=as(results@sp,'SpatialPixelsDataFrame')
# stplot(results[,,"pred", drop= FALSE], col.regions=bpy.colors())
# stplot(results[,,"var", drop= FALSE], col.regions=bpy.colors())

## End(Not run)

## Not run: 
### Example with data.frames and parallel processing - SpatRaster output
library(terra)
library(doParallel)
# create data.frame
stfdf.df &lt;- join(dtempc, st)
summary(stfdf.df)
regdata.df &lt;- as.data.frame(regdata)
results &lt;- pred.strk(data = stfdf.df,
                     obs.col = 3,
                     data.staid.x.y.z = c(1,4,5,2),
                     newdata = regdata.df,
                     newdata.staid.x.y.z = c(3,1,2,4),
                     crs = CRS("EPSG:4326"),
                     output.format = "SpatRaster", # STFDF |data.frame | sf | sftime | SpatVector
                     reg.coef = tregcoef[[1]],
                     vgm.model = tvgms[[1]],
                     sp.nmax = 20,
                     time.nmax = 2,
                     parallel.processing = TRUE,
                     pp.type = "doParallel", # "snowfall"
                     cpus = 1, # detectCores()-1,
                     computeVar = TRUE,
                     progress = TRUE
)
# plot prediction
# plot(results$`2011-07-06`[["pred"]])
# plot(results$`2011-07-06`[["var"]])

## End(Not run)
</code></pre>

<hr>
<h2 id='regdata'>Dynamic and static covariates for spatio-temporal regression kriging</h2><span id='topic+regdata'></span><span id='topic+regdata'></span>

<h3>Description</h3>

<p>Dynamic and static covariates for spatio-temporal regression kriging of <a href="spacetime.html#topic+STFDF-class">STFDF-class</a>. The <code>regdata</code> contains geometrical temperature trend, MODIS LST 8-day splined at daily resolution, elevation and topographic wetness index. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(regdata)</code></pre>


<h3>Format</h3>

<p>The <code>regdata</code> contains the following dynamic and static covariates:
</p>

<dl>
<dt><code>regdata$temp_geo</code></dt><dd><p>numeric; geometrical temperature trend for mean temperature, calculated with <code><a href="#topic+tgeom2STFDF">tgeom2STFDF</a></code> ; from 2011-07-05 to 2011-07-09, in degree Celsius  </p>
</dd>
<dt><code>regdata$modis</code></dt><dd><p>numeric;  MODIS LST 8-day splined at daily resolution, missing pixels are filtered by spatial splines and 8-day values are splined at daily level; from 2011-07-05 to 2011-07-09, in degree Celsius  </p>
</dd>
<dt><code>regdata@sp$dem</code></dt><dd><p>numeric; elevation data obtained from Worldgrids (depricated)</p>
</dd>
<dt><code>regdata@sp$twi</code></dt><dd><p>numeric; SAGA Topographic Wetness Index (TWI) from Worldgrids (depricated)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(regdata)
str(regdata)
library(sp) # spplot
library(spacetime) # stplot

# stplot(regdata[,,'modis']) # plot modis data
# spplot(regdata@sp,zcol='twi', col.regions = bpy.colors() ) # plot TWI
# spplot(regdata@sp,zcol='dem', col.regions = bpy.colors() ) # plot dem
</code></pre>

<hr>
<h2 id='rfillspgaps'>Close gaps of a grid or raster Layer data</h2><span id='topic+rfillspgaps'></span>

<h3>Description</h3>

<p>The function close gaps of a raster data by using IDW.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfillspgaps(rasterLayer,
            maskPol=NULL,
            nmax =50,
            zcol=1,
            ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfillspgaps_+3A_rasterlayer">rasterLayer</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a>, <a href="raster.html#topic+RasterLayer-class">RasterLayer-class</a>, <a href="sp.html#topic+SpatialGrid-class">SpatialGrid-class</a> or <a href="sp.html#topic+SpatialPixels-class">SpatialPixels-class</a>; Raster that contains NAs.</p>
</td></tr>
<tr><td><code id="rfillspgaps_+3A_maskpol">maskPol</code></td>
<td>
<p><a href="sf.html#topic+sf">sf-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a>, <a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a> or <a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a>; Area of interest to spatially fill <code>rasterLayer</code> missing values and to mask <code>rasterLayer</code>.</p>
</td></tr>
<tr><td><code id="rfillspgaps_+3A_nmax">nmax</code></td>
<td>
<p>see <a href="gstat.html#topic+krige">krige</a>, idw function.</p>
</td></tr>
<tr><td><code id="rfillspgaps_+3A_zcol">zcol</code></td>
<td>
<p><code>integer</code> or <code>character</code>; variable column name or number showing position of a variable in <code>rasterLayer</code> to be interpolated.</p>
</td></tr>
<tr><td><code id="rfillspgaps_+3A_...">...</code></td>
<td>
<p>arguments passed to <a href="gstat.html#topic+krige">krige</a>, idw function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>raster object with NA replaced using IDW in <code>rasterLayer</code> format.</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Kilibarda, M., T. Hengl, G. B. M. Heuvelink, B. Graeler, E. Pebesma, M. Percec Tadic, and B. Bajat (2014), Spatio-temporal interpolation of daily temperatures for global land areas at 1 km resolution, J. Geophys. Res. Atmos., 119, 2294-2313, doi:10.1002/2013JD020803;
</p>
<p>Kilibarda M., M. Percec Tadic, T. Hengl, J. Lukovic, B. Bajat - Spatial Statistics (2015), Global geographic and feature space coverage of temperature data in the context of spatio-temporal interpolation, doi:10.1016/j.spasta.2015.04.005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfilltimegaps">rfilltimegaps</a></code>
<code><a href="#topic+pred.strk">pred.strk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   library(terra)
   data(nlmodis20110712)
   data(NLpol)
   
   nlmodis20110712 &lt;- terra::rast(nlmodis20110712)
   # SpaVector
   NLpol = vect(NLpol)
   crs(NLpol) &lt;- "epsg:4326"
   # # sf
   # NLpol &lt;- st_as_sf(NLpol) #, crs = st_crs(4326))
   
   # plot(nlmodis20110712)
   # fill spatial gaps
   r=rfillspgaps(nlmodis20110712,NLpol)
   # plot(r)
  
</code></pre>

<hr>
<h2 id='rfilltimegaps'>Disaggregation in the time dimension through the use of splines for each pixel</h2><span id='topic+rfilltimegaps'></span>

<h3>Description</h3>

<p>The function creates an object of <a href="spacetime.html#topic+STFDF-class">STFDF-class</a> class, spatio-temporal data with full space-time grid, from another <a href="spacetime.html#topic+STFDF-class">STFDF-class</a> and fills attribute data for missing values in time using splines.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfilltimegaps(stfdf,
              tunits="day",
              attrname=1,
              ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfilltimegaps_+3A_stfdf">stfdf</code></td>
<td>
<p><a href="spacetime.html#topic+STFDF-class">STFDF-class</a>; object with time information of minimum length 2, and gap in time dimension.</p>
</td></tr>
<tr><td><code id="rfilltimegaps_+3A_tunits">tunits</code></td>
<td>
<p><code>character</code>; increment of the sequence used to generete time infromation for temporal gap. See 'Details'.</p>
</td></tr>
<tr><td><code id="rfilltimegaps_+3A_attrname">attrname</code></td>
<td>
<p><code>integer</code> or <code>character</code>; varible from <a href="spacetime.html#topic+STFDF-class">STFDF-class</a> to be splined in time.</p>
</td></tr>
<tr><td><code id="rfilltimegaps_+3A_...">...</code></td>
<td>
<p>arguments passed to <a href="stats.html#topic+splinefun">splinefun</a>, function spline.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tunits</code> can be specified in several ways:
</p>

<ul>
<li><p>A number, taken to be in seconds
</p>
</li>
<li><p>A object of class <a href="base.html#topic+difftime">difftime</a>
</p>
</li>
<li><p>A character string, containing one of <code>"sec"</code>, <code>"min"</code>, <code>"hour"</code>, <code>"day"</code>, <code>"DSTday"</code>, <code>"week"</code>, <code>"month"</code>, <code>"quarter"</code> or <code>"year"</code>. This can optionally be preceded by a (positive or negative) integer and a space, or followed by <code>"s"</code>
</p>
</li></ul>

<p>The difference between <code>"day"</code> and <code>"DSTday"</code> is that the former ignores changes to/from daylight savings time and the latter takes the same clock time each day. (<code>"week"</code> ignores DST (it is a period of 144 hours), but <code>"7 DSTdays"</code>) can be used as an alternative. <code>"month"</code> and <code>"year"</code> allow for DST.)
</p>


<h3>Value</h3>

<p><a href="spacetime.html#topic+STFDF-class">STFDF-class</a> object with filled temporal gaps.</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Kilibarda, M., T. Hengl, G. B. M. Heuvelink, B. Graeler, E. Pebesma, M. Percec Tadic, and B. Bajat (2014), Spatio-temporal interpolation of daily temperatures for global land areas at 1 km resolution, J. Geophys. Res. Atmos., 119, 2294-2313, doi:10.1002/2013JD020803;
</p>
<p>Kilibarda M., M. Percec Tadic, T. Hengl, J. Lukovic, B. Bajat - Spatial Statistics (2015), Global geographic and feature space coverage of temperature data in the context of spatio-temporal interpolation, doi:10.1016/j.spasta.2015.04.005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfillspgaps">rfillspgaps</a></code>
<code><a href="#topic+pred.strk">pred.strk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(nlmodis20110704)
  data(nlmodis20110712)
  data(NLpol)

  # fill spatial gaps
  library(raster)
  NLpol@proj4string &lt;- nlmodis20110704@proj4string
  
  ## Not run: 
  nlmodis20110704 &lt;- rfillspgaps(nlmodis20110704,NLpol)
  nlmodis20110712 &lt;- rfillspgaps(nlmodis20110712,NLpol)
  
  nlmodis20110704 &lt;- as(nlmodis20110704,"SpatialPixelsDataFrame")
  names(nlmodis20110704)='m1'
  nlmodis20110712 &lt;- as(nlmodis20110712,"SpatialPixelsDataFrame")
  names(nlmodis20110712)='m2'
  
  nlmodis20110704@data &lt;- cbind(nlmodis20110704@data, nlmodis20110712@data)
  
  df&lt;-reshape(nlmodis20110704@data , varying=list(1:2), v.names="modis",direction="long", 
            times=as.Date(c('2011-07-04','2011-07-12')), ids=1:dim(nlmodis20110704)[1])
  
  library(spacetime)
  stMODIS&lt;- STFDF(as( nlmodis20110704, "SpatialPixels"), 
                  time= as.Date(c('2011-07-04','2011-07-12')), 
                  data.frame(modis=df[,'modis']))
  
  # stplot(stMODIS, col.regions=bpy.colors())
  stMODIS &lt;- rfilltimegaps(stMODIS)
  # stplot(stMODIS, col.regions=bpy.colors())
  
## End(Not run)
</code></pre>

<hr>
<h2 id='rfsi'>Random Forest Spatial Interpolation (RFSI) model</h2><span id='topic+rfsi'></span>

<h3>Description</h3>

<p>Function for creation of Random Forest Spatial Interpolation (RFSI) model (Sekulić et al. 2020). Besides environmental covariates, RFSI uses additional spatial covariates: (1) observations at n nearest locations and (2) distances to them, in order to include spatial context into the random forest.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfsi(formula,
     data,
     data.staid.x.y.z = NULL,
     n.obs = 5,
     avg = FALSE,
     increment = 10000,
     range = 50000,
     quadrant = FALSE,
     use.idw = FALSE,
     idw.p = 2,
     s.crs = NA,
     p.crs = NA,
     cpus = detectCores()-1,
     progress = TRUE,
     soil3d = FALSE,
     depth.range = 0.1,
     no.obs = 'increase',
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfsi_+3A_formula">formula</code></td>
<td>
<p>formula; Formula for specifying target variable and covariates (without nearest observations and distances to them). If <code>z~1</code>, an RFSI model using only nearest obsevrations and distances to them as covariates will be made.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_data">data</code></td>
<td>
<p><a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> or <a href="base.html#topic+data.frame">data.frame</a>; Contains target variable (observations) and covariates used for making an RFSI model. If <a href="base.html#topic+data.frame">data.frame</a> object, it should have next columns: station ID (staid), longitude (x), latitude (y), 3rd component - time, depth, ... (z) of the observation, observation value (obs) and covariates (cov1, cov2, ...). If covariates are missing, the RFSI model using only nearest obsevrations and distances to them as covariates (<code>formula=z~1</code>) will be made.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_data.staid.x.y.z">data.staid.x.y.z</code></td>
<td>
<p>numeric or character vector; Positions or names of the station ID (staid), longitude (x), latitude (y) and 3rd component (z) columns in <a href="base.html#topic+data.frame">data.frame</a> object (e.g. c(1,2,3,4)). If <code>data</code> is <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> object, <code>data.staid.x.y.z</code> is used to point staid and z position. Set z position to NA (e.g. c(1,2,3,NA)) or ommit it (e.g. c(1,2,3)) for spatial interpolation. Default is NULL.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_n.obs">n.obs</code></td>
<td>
<p>numeric; Number of nearest observations to be used as covariates in RFSI model (see function <a href="#topic+near.obs">near.obs</a>). Note that it cannot be larger than number of obsevrations. Default is 5.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_avg">avg</code></td>
<td>
<p>boolean; Averages in circles covariate - will averages in circles with different radiuses be calculated (see function <a href="#topic+near.obs">near.obs</a>). Default is FALSE.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_increment">increment</code></td>
<td>
<p>numeric; Increment of radiuses for calculation of averages in circles with different radiuses (see function <a href="#topic+near.obs">near.obs</a>). Units depends on CRS.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_range">range</code></td>
<td>
<p>numeric; Maximum radius for calculation of averages in circles with different radiuses (see function <a href="#topic+near.obs">near.obs</a>). Units depends on CRS.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_quadrant">quadrant</code></td>
<td>
<p>boolean; Nearest observations in quadrants covariate - will nearest observation in quadrants be calculated (see function <a href="#topic+near.obs">near.obs</a>). Default is FALSE.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_use.idw">use.idw</code></td>
<td>
<p>boolean; IDW prediction as covariate - will IDW predictions from <code>n.obs</code> nearest observations be calculated (see function <a href="#topic+near.obs">near.obs</a>). Default is FALSE.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_idw.p">idw.p</code></td>
<td>
<p>numeric; Exponent parameter for IDW weights (see function <a href="#topic+near.obs">near.obs</a>). Default is 2.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_s.crs">s.crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Source CRS of <code>data</code>. If <code>data</code> contains crs, <code>s.crs</code> will be overwritten. Default is NA.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_p.crs">p.crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Projection CRS for <code>data</code> reprojection. If NA, <code>s.crs</code> will be used for distance calculation. Note that observations should be in projection for finding nearest observations based on Eucleadean distances (see function <a href="#topic+near.obs">near.obs</a>). Default is NA.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_cpus">cpus</code></td>
<td>
<p>numeric; Number of processing units. Default is detectCores()-1.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_progress">progress</code></td>
<td>
<p>logical; If progress bar is shown. Default is TRUE.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_soil3d">soil3d</code></td>
<td>
<p>logical; If 3D soil modellig is performed and <a href="#topic+near.obs.soil">near.obs.soil</a> function is used for finding n nearest observations and distances to them. In this case, z position of the <code>data.staid.x.y.z</code> points to the depth column.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_depth.range">depth.range</code></td>
<td>
<p>numeric; Depth range for location mid depth in which to search for nearest observations (see function <a href="#topic+near.obs.soil">near.obs.soil</a>). It's in the mid depth units. Default is 0.1.</p>
</td></tr>
<tr><td><code id="rfsi_+3A_no.obs">no.obs</code></td>
<td>
<p>character; Possible values are <code>increase</code> (default) and <code>exactly</code>. If set to <code>increase</code>, in case if there is no <code>n.obs</code> observations in <code>depth.range</code> for a specific location, the <code>depth.range</code> is increased (multiplied by 2, 3, ...) until the number of observations are larger or equal to <code>n.obs</code>. If set to <code>exactly</code>, the function will raise an error when it come to the first location with no <code>n.obs</code> observations in specified <code>depth.range</code> (see function <a href="#topic+near.obs.soil">near.obs.soil</a>).</p>
</td></tr>
<tr><td><code id="rfsi_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="ranger.html#topic+ranger">ranger</a>, such as <code>quantreg</code>, <code>importance</code>, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RFSI model of class <a href="ranger.html#topic+ranger">ranger</a>.
</p>


<h3>Note</h3>

<p>Observations should be in projection for finding nearest observations based on Eucleadean distances (see function <a href="#topic+near.obs">near.obs</a>). If crs is not specified in the <code>data</code> object or through the <code>s.crs</code> parameter, the coordinates will be used as they are in projection. Use <code>s.crs</code> and <code>p.crs</code> if the coordinates of the <code>data</code> object are in lon/lat (WGS84).</p>


<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Sekulić, A., Kilibarda, M., Heuvelink, G. B., Nikolić, M. &amp; Bajat, B. Random Forest Spatial Interpolation. Remote. Sens. 12, 1687, https://doi.org/10.3390/rs12101687 (2020).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+near.obs">near.obs</a></code>
<code><a href="#topic+pred.rfsi">pred.rfsi</a></code>
<code><a href="#topic+tune.rfsi">tune.rfsi</a></code>
<code><a href="#topic+cv.rfsi">cv.rfsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ranger)
library(sp)
library(sf)
library(terra)
library(meteo)
# prepare data
demo(meuse, echo=FALSE)
meuse &lt;- meuse[complete.cases(meuse@data),]
data = st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
# data = terra::vect(meuse)
# data.frame
# data &lt;- as.data.frame(meuse)
# data$id = 1:nrow(data)
# data.staid.x.y.z &lt;- c(15,"x","y",NA)
fm.RFSI &lt;- as.formula("zinc ~ dist + soil + ffreq")

# fit the RFSI model
rfsi_model &lt;- rfsi(formula = fm.RFSI,
                   data = data, # meuse.df (use data.staid.x.y.z)
                   # data.staid.x.y.z = data.staid.x.y.z, # only if class(data) == data.frame
                   n.obs = 5, # number of nearest observations
                   # s.crs = st_crs(data), # nedded only if the coordinates are lon/lat (WGS84)
                   # p.crs = st_crs(data), # nedded only if the coordinates are lon/lat (WGS84)
                   cpus = detectCores()-1,
                   progress = TRUE,
                   # ranger parameters
                   importance = "impurity",
                   seed = 42,
                   num.trees = 250,
                   mtry = 5,
                   splitrule = "variance",
                   min.node.size = 5,
                   sample.fraction = 0.95,
                   quantreg = FALSE)

rfsi_model
# OOB prediction error (MSE):       47758.14 
# R squared (OOB):                  0.6435869 
sort(rfsi_model$variable.importance)
sum("obs" == substr(rfsi_model$forest$independent.variable.names, 1, 3))

</code></pre>

<hr>
<h2 id='rm.dupl'>Find point pairs with equal spatial coordinates from <a href="spacetime.html#topic+STFDF-class">STFDF-class</a> object.
</h2><span id='topic+rm.dupl'></span>

<h3>Description</h3>

 
<p>This function finds point pairs with equal spatial coordinates from <a href="spacetime.html#topic+STFDF-class">STFDF-class</a> object and remove locations with less observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.dupl(obj, zcol = 1, zero.tol = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm.dupl_+3A_obj">obj</code></td>
<td>
 <p><a href="spacetime.html#topic+STFDF-class">STFDF-class</a> object</p>
</td></tr>
<tr><td><code id="rm.dupl_+3A_zcol">zcol</code></td>
<td>
<p> variable column name, or column number, from obj@data </p>
</td></tr>
<tr><td><code id="rm.dupl_+3A_zero.tol">zero.tol</code></td>
<td>
<p>distance values less than or equal to this threshold value are considered as duplicates; units are those of the coordinates for projected data or unknown projection, or km if coordinates are defined to be longitute/latitude</p>
</td></tr>
</table>


<h3>Value</h3>

 <p><a href="spacetime.html#topic+STFDF-class">STFDF-class</a> object with removed duplicate locations. Stations with less observation is removed, if number of observation is the same for two stations the first is removed.
</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tgeom2STFDF">tgeom2STFDF</a></code>,
<code><a href="#topic+pred.strk">pred.strk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
# load observation - data frame
data(dtempc) 
# load stations - data frame
data(stations)

str(dtempc)
str(stations)

## Not run: 
# create STFDF - from 2 data frames
temp &lt;- meteo2STFDF(dtempc,
                    stations,
                    crs = CRS('+proj=longlat +datum=WGS84'))

nrow(temp@sp) # number of stations before removing dupl.

temp2 &lt;-rm.dupl(temp, zcol = 1, zero.tol = 50) # 50 km
nrow(temp2@sp) # number of stations after

## End(Not run)
</code></pre>

<hr>
<h2 id='stations'>Data frame containing stations' information </h2><span id='topic+stations'></span>

<h3>Description</h3>

<p>Data frame containing stations' information of merged daily observations from the Global Surface Summary of Day (GSOD) with European Climate Assessment &amp; Data set (ECA&amp;D) for the month July 2011.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stations)</code></pre>


<h3>Format</h3>

<p>The <code>stations</code> contains the following columns:
</p>

<dl>
<dt><code>staid</code></dt><dd><p>character; station ID from GSOD or ECA&amp;D data set</p>
</dd>
<dt><code>lon</code></dt><dd><p>numeric; longitude coordinate</p>
</dd>
<dt><code>lat</code></dt><dd><p>numeric; longitude coordinate</p>
</dd>
<dt><code>elev_1m</code></dt><dd><p>numeric; elevation derived from station metadata in m</p>
</dd>
<dt><code>data_source</code></dt><dd><p>Factor; data source, GSOD or ECA&amp;D</p>
</dd>
<dt><code>station_name</code></dt><dd><p>character; station name</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Milan Kilibarda and Tomislav Hengl</p>


<h3>References</h3>


<ul>
<li><p> Global Surface Summary of the day data (<a href="ftp://ftp.ncdc.noaa.gov/pub/data/gsod/">ftp://ftp.ncdc.noaa.gov/pub/data/gsod/</a>) 
</p>
</li>
<li><p> European Climate Assessment &amp; Dataset (<a href="https://www.ecad.eu/dailydata/predefinedseries.php">https://www.ecad.eu/dailydata/predefinedseries.php</a>) 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load data:
data(stations)
str(stations)
library(sp)
coordinates(stations) &lt;-~ lon +lat
stations@proj4string &lt;-CRS('+proj=longlat +datum=WGS84')
# plot(stations)
</code></pre>

<hr>
<h2 id='stations_ogimet'>Data frame containing stations' information from the OGIMET service for Serbian territory</h2><span id='topic+stations_ogimet'></span>

<h3>Description</h3>

<p>Data frame containing stations' information of daily observations from the OGIMET service for the year 2019 for Serbian territory.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stations_ogimet)</code></pre>


<h3>Format</h3>

<p>The <code>dtempc_ogimet</code> contains the following columns:
</p>

<dl>
<dt><code>staid</code></dt><dd><p>character; station ID from OGIMET</p>
</dd>
<dt><code>name</code></dt><dd><p>character; station name</p>
</dd>
<dt><code>lon</code></dt><dd><p>numeric; Longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>numeric; Latitude</p>
</dd>
<dt><code>elevation</code></dt><dd><p>numeric; Hight</p>
</dd>
<dt><code>dem</code></dt><dd><p>numeric; Digital Elevation Model (DEM) in meters</p>
</dd>
<dt><code>twi</code></dt><dd><p>numeric; Topographic Wetness Index (TWI)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>


<ul>
<li><p> OGIMET service (<a href="https://www.ogimet.com/">https://www.ogimet.com/</a>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load data:
data(stations_ogimet)
str(stations)
library(sp)
coordinates(stations) &lt;-~ lon +lat
stations@proj4string &lt;-CRS('+proj=longlat +datum=WGS84')
# plot(stations)
</code></pre>

<hr>
<h2 id='temp_geom'>Calculate geometrical temperature trend
</h2><span id='topic+temp_geom'></span>

<h3>Description</h3>

<p>Calculate geometrical temperature trend for mean, minimum or maximum temperature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temp_geom(day,
          fi,
          variable="mean",
          ab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temp_geom_+3A_day">day</code></td>
<td>
<p>integer; Day of the year (from 1 to 366). Single value or vector of days of the year (only if <code>fi</code> is single value).</p>
</td></tr>
<tr><td><code id="temp_geom_+3A_fi">fi</code></td>
<td>
<p>numeric; Latitude. Single value or vector of latitudes (only if <code>day</code> is single value).</p>
</td></tr>
<tr><td><code id="temp_geom_+3A_variable">variable</code></td>
<td>
<p>character; Geometrical temperature trend calculated for mean, minimum or maximum temperature; Possible values are <code>'mean'</code>, <code>'min'</code> or <code>'max'</code>. <code>'mean'</code> is default.</p>
</td></tr>
<tr><td><code id="temp_geom_+3A_ab">ab</code></td>
<td>
<p>Predefined coefficients to be used instead of incorporated.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>A numerical single value or <code>vector</code> with calculated geometrical temperature trend.
</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a>, Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Kilibarda, M., T. Hengl, G. B. M. Heuvelink, B. Graeler, E. Pebesma, M. Percec Tadic, and B. Bajat (2014), Spatio-temporal interpolation of daily temperatures for global land areas at 1 km resolution, J. Geophys. Res. Atmos., 119, 2294-2313, doi:10.1002/2013JD020803.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tgeom &lt;- temp_geom(day = 1,
          fi = 45.33,
          variable="mean")
          
tgeom_vect &lt;- temp_geom(day = 1:365,
          fi = 45.33,
          variable="mean")
          
tgeom_vect2 &lt;- temp_geom(day = 1,
          fi = seq(35, 45, 0.5),
          variable="mean")
</code></pre>

<hr>
<h2 id='tgeom2STFDF'>Calculate geometrical temperature trend
</h2><span id='topic+tgeom2STFDF'></span>

<h3>Description</h3>

<p>Calculate geometrical temperature trend for mean, minimum or maximum temperature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgeom2STFDF(grid,
            time,
            variable = "mean",
            ab=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tgeom2STFDF_+3A_grid">grid</code></td>
<td>
<p><a href="sp.html#topic+Spatial-class">Spatial-class</a> (Points, Grid or Pixels), <a href="sf.html#topic+sf">sf-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a>, <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a>; Locations for which gtt is calculated with associated coordinate reference systems (<a href="sp.html#topic+CRS-class">CRS-class</a>). If CRS is not defined longitude latitude is assumed.</p>
</td></tr>
<tr><td><code id="tgeom2STFDF_+3A_time">time</code></td>
<td>
<p>date or datetime; Object holding time information, reasonably it is day (calendar date), or vector of days.</p>
</td></tr>
<tr><td><code id="tgeom2STFDF_+3A_variable">variable</code></td>
<td>
<p>character; Geometrical temperature trend calculated for mean, minimum or maximum temperature; Possible values are <code>'mean'</code>, <code>'min'</code> or <code>'max'</code>. <code>'mean'</code> is default.</p>
</td></tr>
<tr><td><code id="tgeom2STFDF_+3A_ab">ab</code></td>
<td>
<p>Predefined coefficients to be used instead of incorporated.</p>
</td></tr>
</table>


<h3>Value</h3>

 <p><a href="spacetime.html#topic+STFDF-class">STFDF-class</a> object with calculated <code>temp_geo</code> geometrical temperature trend. The calculated values are stored in <code>obj@data</code> slot.
</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a>, Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Kilibarda, M., T. Hengl, G. B. M. Heuvelink, B. Graeler, E. Pebesma, M. Percec Tadic, and B. Bajat (2014), Spatio-temporal interpolation of daily temperatures for global land areas at 1 km resolution, J. Geophys. Res. Atmos., 119, 2294-2313, doi:10.1002/2013JD020803.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
library(spacetime)
## create one point from lon lat
pos &lt;- SpatialPoints(coords = cbind(19.22,45.33)) 
## temp_geom for 1st Jan 2011
tg1 &lt;- tgeom2STFDF(pos,as.POSIXct("2011-01-01") )  
tg1

## temp_geom for the 2011 at pos location
tg365&lt;- tgeom2STFDF(pos,time = seq(as.POSIXct("2011-01-01"), as.POSIXct("2011-12-31"), 
                    by="day") ) 
# stplot(tg365, mode='ts')

data(regdata) 
## DEM and TWI data for Serbia at 1 km resolution
# str(regdata@sp)
# spplot(regdata@sp, zcol='dem', col.regions=bpy.colors() )

## temp_geom for Serbia 1st and 2nd Jully 2011
tgSrb&lt;- tgeom2STFDF(regdata@sp,time = seq(as.POSIXct("2011-07-01"), 
                    as.POSIXct("2011-07-02"), by="day") ) 

## temp_geom for "2011-07-01" , "2011-07-02"
# stplot(tgSrb, col.regions = bpy.colors() ) 

</code></pre>

<hr>
<h2 id='tiling'>Tiling <a href="raster.html#topic+raster">raster</a> or <a href="sp.html#topic+Spatial-class">Spatial-class</a> Grid or Pixels object</h2><span id='topic+tiling'></span>

<h3>Description</h3>

<p>Tiling <a href="raster.html#topic+raster">raster</a> or <a href="sp.html#topic+Spatial-class">Spatial-class</a> Grid or Pixels (data frame) object to smaller parts with optional overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiling(rast,
       tilesize=500,
       overlapping=50,
       aspoints= NA, 
       asfiles=FALSE,
       tilename="tile",
       tiles_folder=paste(getwd(),'tiles',sep='/'),
       parallel.processing=FALSE,
       cpus=6,
       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tiling_+3A_rast">rast</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster">SpatRaster</a>, SpatialPixels* object, SpatialGrid* object or file path to raster object stored on the disk (can be read via <a href="terra.html#topic+rast">rast</a>), for more details see <a href="terra.html#topic+SpatRaster">SpatRaster</a>. The resolution of the raster should be the same in x and y direction.
</p>
</td></tr>
<tr><td><code id="tiling_+3A_tilesize">tilesize</code></td>
<td>
<p>integer or vector; tile size in number of cells. Can be a vector of tilesize in x and y direction. Total number of tile cells is <code>tilesize[1]</code> x <code>tilesize[2]</code>.</p>
</td></tr>
<tr><td><code id="tiling_+3A_overlapping">overlapping</code></td>
<td>
<p>integer or vector; overlapping in number of cells. Can be a vector of overlapping in x and y direction.</p>
</td></tr>
<tr><td><code id="tiling_+3A_aspoints">aspoints</code></td>
<td>
<p>character; Posiible values are <code>sf</code>, <code>terra</code> <code>sp</code>. If specified, tiles are returned in form of points as <a href="sf.html#topic+sf">sf-class</a>, <a href="terra.html#topic+SpatVector">SpatVector</a> or <a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a>.</p>
</td></tr>
<tr><td><code id="tiling_+3A_asfiles">asfiles</code></td>
<td>
<p>boolean; if TRUE tiles are stored on local drive as raster objects.</p>
</td></tr>
<tr><td><code id="tiling_+3A_tilename">tilename</code></td>
<td>
<p>character; prefix given to file names</p>
</td></tr>
<tr><td><code id="tiling_+3A_tiles_folder">tiles_folder</code></td>
<td>
<p>character; destination folder where tiles will be stored. If doesn't exist, the folder will be created.</p>
</td></tr>
<tr><td><code id="tiling_+3A_parallel.processing">parallel.processing</code></td>
<td>
<p>boolean; if TRUE parralel processing is performed via  <a href="snowfall.html#topic+snowfall-calculation">snowfall-calculation</a>, sfLapply function.</p>
</td></tr>
<tr><td><code id="tiling_+3A_cpus">cpus</code></td>
<td>
<p>integer; number of proccesing units.</p>
</td></tr>
<tr><td><code id="tiling_+3A_...">...</code></td>
<td>
<p>character; additional arguments for for writing files, see <a href="terra.html#topic+writeRaster">writeRaster</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> The list of tiles in <a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a> format or in <a href="sf.html#topic+sf">sf-class</a>, <a href="terra.html#topic+SpatVector">SpatVector</a> or <a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a> format if <code>aspoints=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+pred.strk">pred.strk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
demo(meuse, echo=FALSE)
rast &lt;- terra::rast(meuse.grid[, "dist"])

# tiling dem in tiles 250x250 with 25 cells overlap
tiles = tiling(rast,
               tilesize=20,
               overlapping=5,
               aspoints=TRUE)
# number of tiles
length(tiles)

# plot(rast)
# plot(tiles[[1]] , pch='-' ,col ='green', add=T)
# plot(tiles[[2]], pch='.', add=T)

str(tiles[[1]])

</code></pre>

<hr>
<h2 id='tregcoef'>Multiple linear regression coefficients for global and local daily air temperatures</h2><span id='topic+tregcoef'></span>

<h3>Description</h3>

<p>Multiple linear regression coefficients for mean, minimum, maximum daily temperature on geometric temperature trend (GTT), MODIS LST, digital elevation model (DEM) and topographic wetness index (TWI). The models are computed from GSOD, ECA&amp;D, GHCN-Daily or local meteorological stations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tregcoef)</code></pre>


<h3>Format</h3>

<p>A list of 9 multiple linear regression coefficients for daily air temperatures.
</p>

<dl>
<dt><code>tmeanGSODECAD</code></dt><dd><p>Multiple linear regression coefficients of global mean daily temperature on GTT, MODIS LST, DEM and TWI. Data used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tmeanGSODECAD_noMODIS</code></dt><dd><p>Multiple linear regression coefficients of global mean daily temperature on GTT, DEM, and TWI. Data used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tminGSODECAD</code></dt><dd><p>Multiple linear regression coefficients of global minimum daily temperature on GTT, MODIS LST, DEM, and TWI. Data used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tminGHCND</code></dt><dd><p>Multiple linear regression coefficients of global minimum daily temperature on GTT, MODIS LST, DEM, and TWI. Data used: GHCN-Daily</p>
</dd>
<dt><code>tminGSODECAD_noMODIS</code></dt><dd><p>Multiple linear regression coefficients of global minimum daily temperature on GTT, DEM, and TWI. Data used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tmaxGSODECAD</code></dt><dd><p>Multiple linear regression coefficients of global maximum daily temperature on GTT, MODIS LST, DEM, and TWI. Data used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tmaxGHCND</code></dt><dd><p>Multiple linear regression coefficients of global maximum daily temperature on GTT, MODIS LST, DEM, and TWI. Data used: GHCN-Daily</p>
</dd>
<dt><code>tmaxGSODECAD_noMODIS</code></dt><dd><p>Multiple linear regression coefficients of global maximum daily temperature on GTT, DEM, and TWI. Data used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tmeanHR</code></dt><dd><p>Multiple linear regression coefficients of Croatian mean daily temperature on GTT, DEM, and TWI. Data used: Croatian mean daily temperature dataset for the year 2008 (Croatian national meteorological network)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a>, Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Kilibarda, M., T. Hengl, G. B. M. Heuvelink, B. Graeler, E. Pebesma, M. Percec Tadic, and B. Bajat (2014), Spatio-temporal interpolation of daily temperatures for global land areas at 1 km resolution, J. Geophys. Res. Atmos., 119, 2294-2313, doi:10.1002/2013JD020803.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tregcoef)
tregcoef[[1]] # model for mean daily temp.
</code></pre>

<hr>
<h2 id='tune.rfsi'>Tuning of Random Forest Spatial Interpolation (RFSI) model</h2><span id='topic+tune.rfsi'></span>

<h3>Description</h3>

<p>Function for tuning of Random Forest Spatial Interpolation (RFSI) model using k-fold leave-location-out cross-validation (Sekulić et al. 2020).</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune.rfsi(formula,
          data,
          data.staid.x.y.z = NULL,
          use.idw = FALSE,
          s.crs = NA,
          p.crs = NA,
          tgrid,
          tgrid.n=10,
          tune.type = "LLO",
          k = 5,
          seed=42,
          folds,
          acc.metric,
          fit.final.model=TRUE,
          cpus = detectCores()-1,
          progress = TRUE,
          soil3d = FALSE,
          no.obs = 'increase',
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune.rfsi_+3A_formula">formula</code></td>
<td>
<p>formula; Formula for specifying target variable and covariates (without nearest observations and distances to them). If <code>z~1</code>, an RFSI model using only nearest obsevrations and distances to them as covariates will be tuned.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_data">data</code></td>
<td>
<p><a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> or <a href="base.html#topic+data.frame">data.frame</a>; Contains target variable (observations) and covariates used for making an RFSI model. If <a href="base.html#topic+data.frame">data.frame</a> object, it should have next columns: station ID (staid), longitude (x), latitude (y), 3rd component - time, depth, ... (z) of the observation, observation value (obs) and covariates (cov1, cov2, ...). If covariates are missing, the RFSI model using only nearest obsevrations and distances to them as covariates (<code>formula=z~1</code>) will be tuned.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_data.staid.x.y.z">data.staid.x.y.z</code></td>
<td>
<p>numeric or character vector; Positions or names of the station ID (staid), longitude (x), latitude (y) and 3rd component (z) columns in <a href="base.html#topic+data.frame">data.frame</a> object (e.g. c(1,2,3,4)). If <code>data</code> is <a href="sf.html#topic+sf">sf-class</a>, <a href="sftime.html#topic+st_sftime">sftime-class</a>, or <a href="terra.html#topic+SpatVector-class">SpatVector-class</a> object, <code>data.staid.x.y.z</code> is used to point staid and z position. Set z position to NA (e.g. c(1,2,3,NA)) or ommit it (e.g. c(1,2,3)) for spatial interpolation. Default is NULL.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_use.idw">use.idw</code></td>
<td>
<p>boolean; IDW prediction as covariate - will IDW predictions from <code>n.obs</code> nearest observations be calculated and tuned (see function <a href="#topic+near.obs">near.obs</a>). Default is FALSE.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_s.crs">s.crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Source CRS of <code>data</code>. If <code>data</code> contains crs, <code>s.crs</code> will be overwritten. Default is NA.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_p.crs">p.crs</code></td>
<td>
<p><a href="sf.html#topic+st_crs">st_crs</a> or <a href="terra.html#topic+crs">crs</a>; Projection CRS for <code>data</code> reprojection. If NA, <code>s.crs</code> will be used for distance calculation. Note that observations should be in projection for finding nearest observations based on Eucleadean distances (see function <a href="#topic+near.obs">near.obs</a>). Default is NA.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_tgrid">tgrid</code></td>
<td>
<p>data.frame; Possible tuning parameters. The column names are same as the tuning parameters. Possible tuning parameters are: <code>n.obs</code>, <code>num.trees</code>, <code>mtry</code>, <code>min.node.size</code>, <code>sample.fraction</code>, <code>splirule</code>, <code>idw.p</code>, and <code>depth.range</code>.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_tgrid.n">tgrid.n</code></td>
<td>
<p>numeric; Number of randomly chosen <code>tgrid</code> combinations for tuning of RFSI. If larger than <code>tgrid</code>, will be set to <code>length(tgrid)</code></p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_tune.type">tune.type</code></td>
<td>
<p>character; Type of cross-validation: leave-location-out (&quot;LLO&quot;), leave-time-out (&quot;LTO&quot;) - TO DO, and leave-location-time-out (&quot;LLTO&quot;) - TO DO. Default is &quot;LLO&quot;.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_k">k</code></td>
<td>
<p>numeric; Number of random folds that will be created with <a href="CAST.html#topic+CreateSpacetimeFolds">CreateSpacetimeFolds</a> function if <code>folds</code> is column. Default is 5.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_seed">seed</code></td>
<td>
<p>numeric; Random seed that will be used to generate folds with <a href="CAST.html#topic+CreateSpacetimeFolds">CreateSpacetimeFolds</a> function.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_folds">folds</code></td>
<td>
<p>numeric or character vector or value; Showing folds column (if value) or rows (vector) of <code>data</code> observations used for cross-validation. If missing, will be created with <a href="CAST.html#topic+CreateSpacetimeFolds">CreateSpacetimeFolds</a> function.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_acc.metric">acc.metric</code></td>
<td>
<p>character; Accuracy metric that will be used as a criteria for choosing an optimal RFSI model. Possible values for regression: &quot;ME&quot;, &quot;MAE&quot;, &quot;NMAE&quot;, &quot;RMSE&quot; (default), &quot;NRMSE&quot;, &quot;R2&quot;, &quot;CCC&quot;. Possible values for classification: &quot;Accuracy&quot;,&quot;Kappa&quot; (default), &quot;AccuracyLower&quot;, &quot;AccuracyUpper&quot;, &quot;AccuracyNull&quot;, &quot;AccuracyPValue&quot;, &quot;McnemarPValue&quot;.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_fit.final.model">fit.final.model</code></td>
<td>
<p>boolean; Fit the final RFSI model. Defailt is TRUE.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_cpus">cpus</code></td>
<td>
<p>numeric; Number of processing units. Default is detectCores()-1.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_progress">progress</code></td>
<td>
<p>logical; If progress bar is shown. Default is TRUE.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_soil3d">soil3d</code></td>
<td>
<p>logical; If 3D soil modellig is performed and <a href="#topic+near.obs.soil">near.obs.soil</a> function is used for finding n nearest observations and distances to them. In this case, z position of the <code>data.staid.x.y.z</code> points to the depth column.</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_no.obs">no.obs</code></td>
<td>
<p>character; Possible values are <code>increase</code> (default) and <code>exactly</code>. If set to <code>increase</code>, in case if there is no <code>n.obs</code> observations in <code>depth.range</code> for a specific location, the <code>depth.range</code> is increased (multiplied by 2, 3, ...) until the number of observations are larger or equal to <code>n.obs</code>. If set to <code>exactly</code>, the function will raise an error when it come to the first location with no <code>n.obs</code> observations in specified <code>depth.range</code> (see function <a href="#topic+near.obs.soil">near.obs.soil</a>).</p>
</td></tr>
<tr><td><code id="tune.rfsi_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="ranger.html#topic+ranger">ranger</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>combinations</code></td>
<td>
<p>data.frame; All tuned parameter combinations with chosen accuracy metric value.</p>
</td></tr>
<tr><td><code>tuned.parameters</code></td>
<td>
<p>numeric vector; Tuned parameters with chosen accuracy metric value.</p>
</td></tr>
<tr><td><code>final.model</code></td>
<td>
<p><a href="ranger.html#topic+ranger">ranger</a>; Final RFSI model (if <code>fit.final.model=TRUE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Sekulić, A., Kilibarda, M., Heuvelink, G. B., Nikolić, M. &amp; Bajat, B. Random Forest Spatial Interpolation. Remote. Sens. 12, 1687, https://doi.org/10.3390/rs12101687 (2020).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+near.obs">near.obs</a></code>
<code><a href="#topic+rfsi">rfsi</a></code>
<code><a href="#topic+pred.rfsi">pred.rfsi</a></code>
<code><a href="#topic+cv.rfsi">cv.rfsi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CAST)
library(doParallel)
library(ranger)
library(sp)
library(sf)
library(terra)
library(meteo)

# prepare data
demo(meuse, echo=FALSE)
meuse &lt;- meuse[complete.cases(meuse@data),]
data = st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
# data = terra::vect(meuse)
# data.frame
# data &lt;- as.data.frame(meuse)
# data$id = 1:nrow(data)
# data.staid.x.y.z &lt;- c(15,"x","y",NA)
fm.RFSI &lt;- as.formula("zinc ~ dist + soil + ffreq")

# making tgrid
n.obs &lt;- 1:6
min.node.size &lt;- 2:10
sample.fraction &lt;- seq(1, 0.632, -0.05) # 0.632 without / 1 with replacement
splitrule &lt;- "variance"
ntree &lt;- 250 # 500
mtry &lt;- 3:(2+2*max(n.obs))
tgrid = expand.grid(min.node.size=min.node.size, num.trees=ntree,
                    mtry=mtry, n.obs=n.obs, sample.fraction=sample.fraction)

## Not run: 
# Tune RFSI model
rfsi_tuned &lt;- tune.rfsi(formula = fm.RFSI,
                        data = data,
                        # data.staid.x.y.z = data.staid.x.y.z, # data.frame
                        # s.crs = st_crs(data),
                        # p.crs = st_crs(data),
                        tgrid = tgrid, # combinations for tuning
                        tgrid.n = 20, # number of randomly selected combinations from tgrid
                        tune.type = "LLO", # Leave-Location-Out CV
                        k = 5, # number of folds
                        seed = 42,
                        acc.metric = "RMSE", # R2, CCC, MAE
                        fit.final.model = TRUE,
                        cpus = detectCores()-1,
                        progress = TRUE,
                        importance = "impurity") # ranger parameter

rfsi_tuned$combinations
rfsi_tuned$tuned.parameters
# min.node.size num.trees mtry n.obs sample.fraction     RMSE
# 3701             3       250    6     5            0.75 222.6752
rfsi_tuned$final.model
# OOB prediction error (MSE):       46666.51 
# R squared (OOB):                  0.6517336 

## End(Not run)
</code></pre>

<hr>
<h2 id='tvgms'>Spatio-temporal variogram models for global and local daily air temperatures</h2><span id='topic+tvgms'></span>

<h3>Description</h3>

<p>Variograms of residuals from multiple linear regression of mean, minimum, maximum daily temperatures on geometric temperature trend (GTT), MODIS LST, digital elevation model (DEM) and topographic wetness index (TWI). The models is computed from GSOD, ECA&amp;D, GHCN-Daily or local meteorological stations. The obtained global or local models for mean, minimum, and maximum temperature can be used to produce gridded images of daily temperatures at high spatial and temporal resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tvgms)</code></pre>


<h3>Format</h3>

<p>A list of 9 space-time sum-metric models for daily air temperatures, units: space km, time days.
</p>

<dl>
<dt><code>tmeanGSODECAD</code></dt><dd><p>Variogram for residuals from multiple linear regression of global mean daily temperature on GTT, MODIS LST, DEM, and TWI. D used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tmeanGSODECAD_noMODIS</code></dt><dd><p>Variogram for residuals from multiple linear regression of global mean daily temperature on GTT, DEM, and TWI. Data used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tminGSODECAD</code></dt><dd><p>Variogram for residuals from multiple linear regression of global minimum daily temperature on GTT, MODIS LST, DEM, and TWI. Data used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tminGHCND</code></dt><dd><p>Variogram for residuals from multiple linear regression of global minimum daily temperature on GTT, MODIS LST, DEM, and TWI. Data used: GHCN-Daily</p>
</dd>
<dt><code>tminGSODECAD_noMODIS</code></dt><dd><p>Variogram for residuals from multiple linear regression of global minimum daily temperature on GTT, DEM, and TWI. Data used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tmaxGSODECAD</code></dt><dd><p>Variogram for residuals from multiple linear regression of global maximum daily temperature on GTT, MODIS LST, DEM, and TWI. Data used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tmaxGHCND</code></dt><dd><p>Variogram for residuals from multiple linear regression of global maximum daily temperature on GTT, MODIS LST, DEM, and TWI. Data used: GHCN-Daily</p>
</dd>
<dt><code>tmaxGSODECAD_noMODIS</code></dt><dd><p>Variogram for residuals from multiple linear regression of global maximum daily temperature on GTT,  DEM, and TWI. Data used: GSOD and ECA&amp;D</p>
</dd>
<dt><code>tmeanHR</code></dt><dd><p>Variogram for residuals from multiple linear regression of Croatian mean daily temperature on GTT, DEM, and TWI. Data used: Croatian mean daily temperature dataset for the year 2008 (Croatian national meteorological network)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Milan Kilibarda <a href="mailto:kili@grf.bg.ac.rs">kili@grf.bg.ac.rs</a>, Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Kilibarda, M., T. Hengl, G. B. M. Heuvelink, B. Graeler, E. Pebesma, M. Percec Tadic, and B. Bajat (2014), Spatio-temporal interpolation of daily temperatures for global land areas at 1 km resolution, J. Geophys. Res. Atmos., 119, 2294-2313, doi:10.1002/2013JD020803.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tvgms)
tvgms[[1]] # model for mean daily temp.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
