<!DOCTYPE html><html lang="en"><head><title>Help for package clipp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clipp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clipp-package'><p>clipp: Calculate Likelihoods by Pedigree Paring</p></a></li>
<li><a href='#combine_loci'><p>Combine the genotype frequencies and transition matrices of two genetic loci</p></a></li>
<li><a href='#dat_large'><p>Simulated data on one family with approximately 10,000 members</p></a></li>
<li><a href='#dat_small'><p>Simulated data on 10 families with approximately 100 members each</p></a></li>
<li><a href='#geno_freq_monogenic'><p>Calculate genotype frequencies from allele frequencies using Hardy-Weinberg equilibrium</p></a></li>
<li><a href='#geno_freq_phased'><p>Calculate phased genotype frequencies from allele frequencies,</p>
assuming Hardy-Weinberg equilibrium</a></li>
<li><a href='#geno_freq_polygenic'><p>Genotype frequencies for the hypergeometric polygenic model</p></a></li>
<li><a href='#genotype_probabilities'><p>Calculate genotype probabilities for a target person</p></a></li>
<li><a href='#pedigree_loglikelihood'><p>Calculate the log-likelihoods of pedigrees</p></a></li>
<li><a href='#penet_large'><p>A penetrance matrix relating the phenotypes in <code>dat_large</code> to three genotypes</p></a></li>
<li><a href='#penet_small'><p>A penetrance matrix relating the phenotypes of <code>dat_small</code> to three genotypes</p></a></li>
<li><a href='#trans_monogenic'><p>The transmission matrix for a single genetic locus</p></a></li>
<li><a href='#trans_phased'><p>The transmission matrix for phased genotypes</p></a></li>
<li><a href='#trans_polygenic'><p>The transmission matrix for the hypergeometric polygenic model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculating Likelihoods by Pedigree Paring</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A fast and general implementation of the Elston-Stewart algorithm
 that can calculate the likelihoods of large and complex pedigrees. 
 References for the Elston-Stewart algorithm are
 Elston &amp; Stewart (1971) &lt;<a href="https://doi.org/10.1159%2F000152448">doi:10.1159/000152448</a>&gt;,
 Lange &amp; Elston (1975) &lt;<a href="https://doi.org/10.1159%2F000152714">doi:10.1159/000152714</a>&gt; and
 Cannings et al. (1978) &lt;<a href="https://doi.org/10.2307%2F1426718">doi:10.2307/1426718</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-12 05:10:00 UTC; jdowty</td>
</tr>
<tr>
<td>Author:</td>
<td>James Dowty [aut, cre],
  Kevin Wong [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Dowty &lt;jgdowty@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-12 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='clipp-package'>clipp: Calculate Likelihoods by Pedigree Paring</h2><span id='topic+clipp'></span><span id='topic+clipp-package'></span>

<h3>Description</h3>

<p><code>clipp</code> provides a fast and general implementation of the Elston-Stewart
algorithm, and can calculate the log-likelihoods of large and complex pedigrees,
including those with loops.  General references for the Elston-Stewart algorithm are
(Elston &amp; Stewart, 1971), (Lange &amp; Elston, 1975) and (Cannings et al., 1978).
</p>


<h3>Details</h3>

<p>The main function is <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>, which calculates
the pedigree likelihood on page 117 of (Lange, 2002) for almost any choice of
genotype frequencies, transmission matrix and penetrance matrix.  Helper
functions are provided to calculate the genotype frequencies and transmission
matrices for genetic models that often arise in applications.  The function
<code><a href="#topic+genotype_probabilities">genotype_probabilities</a></code> calculates genotype probabilities
for a target person within a family, given the family's phenotypes.
</p>
<p>The <code>clipp</code> package can handle pedigree loops, such as those
caused by inbreeding or by two sisters having children with two brothers
from an unrelated family (see (Totir et al., 2009) for a precise definition).
However, pedigrees with more than a few loops could greatly reduce the speed
of the calculation.
</p>
<p>It is feasible to apply <code>clipp</code> to very large families.  For instance,
in the examples for <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>,
the log-likelihood of one family with approximately 10,000 members is calculated
in less than one minute on a standard desktop computer.
Numerical issues will eventually limit the family size,
though <code>clipp</code> takes care to avoid arithmetic underflow and other issues.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: James Dowty <a href="mailto:jgdowty@gmail.com">jgdowty@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Kevin Wong <a href="mailto:wongck.kevin@gmail.com">wongck.kevin@gmail.com</a>
</p>
</li></ul>



<h3>References</h3>

<p>Cannings C, Thompson E, Skolnick M. Probability functions
on complex pedigrees. Advances in Applied Probability, 1978;10(1):26-61.
</p>
<p>Elston RC, Stewart J. A general model for the genetic analysis of pedigree
data. Hum Hered. 1971;21(6):523-542.
</p>
<p>Lange K.  Mathematical and Statistical Methods for Genetic Analysis
(second edition). Springer, New York. 2002.
</p>
<p>Lange K, Elston RC. Extensions to pedigree analysis I. Likehood calculations
for simple and complex pedigrees. Hum Hered. 1975;25(2):95-105.
</p>
<p>Totir LR, Fernando RL, Abraham J. An efficient algorithm to compute marginal
posterior genotype probabilities for every member of a pedigree with loops.
Genet Sel Evol. 2009;41(1):52.
</p>

<hr>
<h2 id='combine_loci'>Combine the genotype frequencies and transition matrices of two genetic loci</h2><span id='topic+combine_loci'></span>

<h3>Description</h3>

<p>A function to calculate the genotype frequencies and the transition matrices
for the joint genotypes of two unlinked genetic loci in linkage
equilibrium, given the corresponding objects for the separate loci.
The results from this function can be used as inputs to
<code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code> or
<code><a href="#topic+genotype_probabilities">genotype_probabilities</a></code>
to model the combined effect of the two loci on phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_loci(geno_freq1, geno_freq2, trans1, trans2, annotate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_loci_+3A_geno_freq1">geno_freq1</code></td>
<td>
<p>A vector of strictly positive numbers that sum to <code>1</code>,
with <code>geno_freq1[i]</code> interpreted as the population genotype frequency of the
<code>i</code>th possible genotype at a genetic locus (locus 1).
When <code>annotate</code> is <code>TRUE</code>, the names of the genotypes at locus 1 will be
taken to be <code>names(geno_freq1)</code> or, if <code>names(geno_freq1)</code> is <code>NULL</code>, to be
<code>1:length(geno_freq1)</code>.</p>
</td></tr>
<tr><td><code id="combine_loci_+3A_geno_freq2">geno_freq2</code></td>
<td>
<p>Similar to <code>geno_freq1</code> (above) but interpreted as the
population genotype frequencies for a different genetic locus (locus 2).</p>
</td></tr>
<tr><td><code id="combine_loci_+3A_trans1">trans1</code></td>
<td>
<p>An <code>ngeno1^2</code> by <code>ngeno1</code> matrix of non-negative numbers
whose rows sum to <code>1</code>, where <code>ngeno1 = length(geno_freq1)</code>.
This matrix is usually generated by <code><a href="#topic+trans_monogenic">trans_monogenic</a></code> or a similar
helper function, and its elements are interpreted as genetic
transmission probabilities for locus 1 (see <code><a href="#topic+trans_monogenic">trans_monogenic</a></code>
for more details).  If <code>trans1</code> has <code>ngeno1 + 2</code> instead of <code>ngeno1</code> columns,
as could occur if it was generated by
<code><a href="#topic+trans_monogenic">trans_monogenic</a></code> with <code>annotate = TRUE</code>, then the first two
columns will be deleted and <code>trans1</code> will be converted to a matrix.</p>
</td></tr>
<tr><td><code id="combine_loci_+3A_trans2">trans2</code></td>
<td>
<p>Similar to <code>trans1</code> (above) but interpreted as the
genetic transmission probabilities for locus 2.</p>
</td></tr>
<tr><td><code id="combine_loci_+3A_annotate">annotate</code></td>
<td>
<p>A logical flag. When <code>FALSE</code> (the default), the function
returns objects that can be used as the <code>geno_freq</code> and <code>trans</code> arguments of
<code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>. When <code>TRUE</code>, the function annotates
these objects (and converts <code>trans</code> to a data frame) to make the output more
easily understood by humans.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines the genotype frequencies and transition
probabilities of two unlinked genetic loci that are in linkage equilibrium
in a given population.  Because
the loci are unlinked, any person's genotypes at the two loci are
conditionally independent given his or her parental genotypes,
and because the loci are in linkage equilibrium, the genotypes at the two
loci for a random person from the population are independent.
This function uses these assumptions to calculate the population frequencies
and transition probabilities for the joint genotypes of the two loci, where a
joint genotype is just a pair consisting of a genotype at locus 1
and a genotype at locus 2.  If the <code>annotate</code> option is set to <code>FALSE</code> then
these frequencies and probabilities can be used in
<code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code> to model the combined effect of the two
loci on the phenotypes.  By a repeated application of this function, more
than two genetic loci can be included in the genetic model.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>geno_freq</code></td>
<td>
<p>A vector of strictly positive numbers (the joint genotype
frequencies) that sum to <code>1</code>, with genotype names added when <code>annotate</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>Either a matrix of genetic transmission probabilities suitable to be
used as the <code>trans</code> argument of <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>
(if <code>annotate</code> is <code>FALSE</code>), or a data frame that is an annotated version of
this matrix (if <code>annotate</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code>genotype_decoder</code></td>
<td>
<p>A data frame giving the locus 1 and locus 2 genotypes
that correspond to each joint genotype.  In some cases, this could aid the user's
calculation of the <code>penet</code> argument of <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>pa1 &lt;- c(0.9, 0.1); names(pa1) &lt;- c("-","+")
pa2 &lt;- c(0.5, 0.5); names(pa2) &lt;- c("A","a")
(geno_freq1 &lt;- geno_freq_monogenic(pa1, TRUE))
(geno_freq2 &lt;- geno_freq_monogenic(pa2, TRUE))
(trans1 &lt;- trans_monogenic(2, TRUE))
(trans2 &lt;- trans_monogenic(2))
(cl &lt;- combine_loci(geno_freq1, geno_freq2, trans1, trans2, TRUE))
sum(cl$geno_freq)
apply(cl$trans[,-(1:2)], 1, sum)

</code></pre>

<hr>
<h2 id='dat_large'>Simulated data on one family with approximately 10,000 members</h2><span id='topic+dat_large'></span>

<h3>Description</h3>

<p>A dataset giving the relationship structure of one large family
and phenotypic data on the family members
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat_large
</code></pre>


<h3>Format</h3>

<p>A data frame with 10,002 rows (corresponding to persons) and the
following 6 variables:
</p>

<dl>
<dt><code>indiv</code></dt><dd><p>an individual identifier for each person</p>
</dd>
<dt><code>mother</code></dt><dd><p>the individual identifier of the person's mother</p>
</dd>
<dt><code>father</code></dt><dd><p>the individual identifier of the person's father</p>
</dd>
<dt><code>sex</code></dt><dd><p>the person's sex (1 = male, 2 = female)</p>
</dd>
<dt><code>aff</code></dt><dd><p>the person's disease status (1 = case, 0 = control)</p>
</dd>
<dt><code>age</code></dt><dd><p>the person's last known age in years (for controls) or
age at diagnosis in years (for cases)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='dat_small'>Simulated data on 10 families with approximately 100 members each</h2><span id='topic+dat_small'></span>

<h3>Description</h3>

<p>A dataset giving the relationship structure of 10 families
and phenotypic data on the family members
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat_small
</code></pre>


<h3>Format</h3>

<p>A data frame with 1018 rows (corresponding to persons) and the
following 7 variables:
</p>

<dl>
<dt><code>family</code></dt><dd><p>an identifier for each person's family</p>
</dd>
<dt><code>indiv</code></dt><dd><p>an individual identifier for each person</p>
</dd>
<dt><code>mother</code></dt><dd><p>the individual identifier of the person's mother</p>
</dd>
<dt><code>father</code></dt><dd><p>the individual identifier of the person's father</p>
</dd>
<dt><code>sex</code></dt><dd><p>the person's sex (1 = male, 2 = female)</p>
</dd>
<dt><code>aff</code></dt><dd><p>the person's disease status (1 = case, 0 = control)</p>
</dd>
<dt><code>age</code></dt><dd><p>the person's last known age in years (for controls) or
age at diagnosis in years (for cases)</p>
</dd>
<dt><code>geno</code></dt><dd><p>the person's genotype, or blank (<code>""</code>) if not known</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='geno_freq_monogenic'>Calculate genotype frequencies from allele frequencies using Hardy-Weinberg equilibrium</h2><span id='topic+geno_freq_monogenic'></span>

<h3>Description</h3>

<p>A function to calculate the unphased genotype frequencies for a single
autosomal genetic locus that has given allele frequencies and is at
Hardy-Weinberg equilibrium (HWE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno_freq_monogenic(p_alleles, annotate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geno_freq_monogenic_+3A_p_alleles">p_alleles</code></td>
<td>
<p>A vector of strictly positive numbers that sum to <code>1</code>, with
<code>p_alleles[i]</code> interpreted as the allele frequency of the <code>i</code>th allele of the
genetic locus.  When <code>annotate</code> is <code>TRUE</code>, the names of the alleles will be
taken to be <code>names(p_alleles)</code> or, if <code>names(p_alleles)</code> is <code>NULL</code>, to be
<code>1:length(p_alleles)</code>.</p>
</td></tr>
<tr><td><code id="geno_freq_monogenic_+3A_annotate">annotate</code></td>
<td>
<p>A logical flag.  When <code>FALSE</code> (the default), the function
returns a vector suitable to be used as the <code>geno_freq</code> argument of
<code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>.  When <code>TRUE</code>, the function adds a
<code>names</code> attribute to this vector to indicate which genotype corresponds
to which element.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a genetic locus at Hardy-Weinberg equilibrium, the population
allele frequencies at the locus determine the population genotype frequencies;
see Sections 1.2 and 1.3 of (Lange, 2002).
Given a vector <code>p_alleles</code> containing the allele
frequencies, this function returns the frequencies of the possible unphased
genotypes, in a particular order that can be viewed by setting <code>annotate</code> to
<code>TRUE</code>. If the alleles are named <code>1:length(p_alleles)</code>, so that <code>p_alleles[i]</code>
is the frequency of allele <code>i</code>, then the unphased genotypes are named
<code style="white-space: pre;">&#8288;1/1, 1/2, ...&#8288;</code>.  Note that if the output of this function is to be used
as the <code>geno_freq</code> argument of <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>
then the <code>annotate</code> option must be set to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>A vector of strictly positive numbers (the genotype frequencies)
that sum to <code>1</code>, named with the genotype names if <code>annotate</code> is <code>TRUE</code>.
</p>


<h3>References</h3>

<p>Lange K.  Mathematical and Statistical Methods for Genetic Analysis (second edition).
Springer, New York.  2002.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Genotype frequencies for a biallelic locus at HWE and with a minor allele frequency of 10%
p_alleles &lt;- c(0.9, 0.1)
geno_freq_monogenic(p_alleles, annotate = TRUE)

# Genotype frequencies for a triallelic locus at Hardy-Weinberg equilibrium
p_alleles &lt;- c(0.85, 0.1, 0.05)
geno_freq_monogenic(p_alleles, annotate = TRUE)
sum(geno_freq_monogenic(p_alleles))

</code></pre>

<hr>
<h2 id='geno_freq_phased'>Calculate phased genotype frequencies from allele frequencies,
assuming Hardy-Weinberg equilibrium</h2><span id='topic+geno_freq_phased'></span>

<h3>Description</h3>

<p>A function to calculate the population frequencies of the phased genotypes
at a single autosomal genetic locus that has given allele frequencies and
is at Hardy-Weinberg equilibrium.  Phased genotypes can be used to
investigate parent-of-origin effects, e.g. see (van Vliet et al., 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno_freq_phased(p_alleles, annotate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geno_freq_phased_+3A_p_alleles">p_alleles</code></td>
<td>
<p>A vector of strictly positive numbers that sum to <code>1</code>,
with <code>p_alleles[i]</code> interpreted as the allele frequency of the <code>i</code>th allele
of the genetic locus.  When <code>annotate</code> is <code>TRUE</code>, the names of the alleles
will be taken to be <code>names(p_alleles)</code> or, if <code>names(p_alleles)</code> is <code>NULL</code>,
to be <code>1:length(p_alleles)</code>.</p>
</td></tr>
<tr><td><code id="geno_freq_phased_+3A_annotate">annotate</code></td>
<td>
<p>A logical flag.  When <code>FALSE</code> (the default), the function
returns a vector suitable to be used as the <code>geno_freq</code> argument of
<code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>.  When <code>TRUE</code>, the function adds a
<code>names</code> attribute to this vector to indicate which element corresponds to
which phased genotype.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a genetic locus that is at Hardy-Weinberg equilibrium in a
particular population, the population allele frequencies at
the locus determine the population genotype frequencies; see Sections 1.2 and
1.3 of (Lange, 2002) for the unphased version of this law.  When a genetic
locus is at Hardy-Weinberg equilibrium, the maternal and paternal alleles of a
random person from the population are independent.  A phased genotype at a
genetic locus is an ordered pair consisting of a maternal
and paternal allele at the locus.  So to any heterozygous unphased genotype,
there are two corresponding phased genotypes, and these two phased genotypes
have equal frequencies under Hardy-Weinberg equilibrium.
</p>
<p>Given a vector <code>p_alleles</code> containing the allele frequencies,
this function returns the frequencies of the possible phased genotypes,
in a particular order that can be viewed by setting <code>annotate</code> to <code>TRUE</code>.
If the alleles are named <code>1:length(p_alleles)</code>, so that <code>p_alleles[i]</code> is
the frequency of allele <code>i</code>, then the phased genotypes are of the form
<code style="white-space: pre;">&#8288;1|1, 1|2, ...&#8288;</code>, where <code>a|b</code> means the maternal allele is <code>a</code> and the
paternal allele is <code>b</code>. Note that if the output of this function is to be
used as the <code>geno_freq</code> argument of <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>
then the <code>annotate</code> option must be set to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>A vector of strictly positive numbers (the genotype frequencies)
that sum to <code>1</code>, named with the genotype names if <code>annotate</code> is <code>TRUE</code>.
</p>


<h3>References</h3>

<p>Lange K.  Mathematical and Statistical Methods for Genetic Analysis (second edition).
Springer, New York.  2002.
</p>
<p>van Vliet CM, Dowty JG, van Vliet JL, et al. Dependence of colorectal cancer
risk on the parent-of-origin of mutations in DNA mismatch repair genes.
Hum Mutat. 2011;32(2):207-212.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Genotype frequencies for a biallelic locus at Hardy-Weinberg equilibrium
# and with a minor allele frequency of 10%
p_alleles &lt;- c(0.9, 0.1)
geno_freq_phased(p_alleles, annotate = TRUE)

# Genotype frequencies for a triallelic locus at Hardy-Weinberg equilibrium
p_alleles &lt;- c(0.85, 0.1, 0.05)
geno_freq_phased(p_alleles, annotate = TRUE)
sum(geno_freq_phased(p_alleles))

</code></pre>

<hr>
<h2 id='geno_freq_polygenic'>Genotype frequencies for the hypergeometric polygenic model</h2><span id='topic+geno_freq_polygenic'></span>

<h3>Description</h3>

<p>A function to calculate the genotype frequencies for the hypergeometric
polygenic model of (Cannings et al., 1978), see Section 8.9 of (Lange, 2002)
for a nice description of this model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno_freq_polygenic(n_loci, annotate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geno_freq_polygenic_+3A_n_loci">n_loci</code></td>
<td>
<p>A positive integer, interpreted as the number of biallelic
genetic loci that contribute to the polygene.  The polygene will have
<code>2*n_loci + 1</code> genotypes, so <code>n_loci</code> is typically fairly small, e.g. <code>4</code>.</p>
</td></tr>
<tr><td><code id="geno_freq_polygenic_+3A_annotate">annotate</code></td>
<td>
<p>A logical flag.  When <code>FALSE</code> (the default), the function
returns a vector suitable to be used as the <code>geno_freq</code> argument of
<code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>.  When <code>TRUE</code>, the function adds a
<code>names</code> attribute to this vector to indicate which element corresponds to
which genotype.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hypergeometric polygenic model
(Cannings et al., 1978; Lange, 2002) is a computationally feasible
genetic model that approximates the combined effect of a given number
(<code>n_loci</code>) of unlinked biallelic genetic loci.  This model is often used to model
the effect of such loci on a trait when the alleles at these loci either
increase the trait by a certain, locus-independent amount (if a 'positive'
allele) or decrease
the trait by the same amount (if a 'negative' allele), with 'positive' and
'negative' alleles equally likely at each locus.  In this case, the only
relevant aspect of the <code>3 ^ n_loci</code> possible joint genotypes is the total number
of 'positive' alleles, so the possible genotypes of
the hypergeometric polygenic model are taken to be <code>0:(2*n_loci)</code>.
The transmission probabilities and genotype frequencies of the hypergeometric
polygenic model approximate these quantities for the combination of the <code>n_loci</code>
biallelic genetic loci described above.  Under this model, the polygenic
genotype for each person is approximately normally distributed, and these
genotypes are correlated within families with correlation coefficients
(in non-inbred families) equal to the kinship coefficients (Lange, 2002).
</p>
<p>Setting <code>annotate</code> to <code>TRUE</code> names each element of the output vector with
the corresponding genotype. The <code>annotate</code> option must be set to <code>FALSE</code>
if the output of this function is to be used as the <code>geno_freq</code> argument of
<code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>.
</p>


<h3>Value</h3>

<p>A vector of strictly positive numbers (the genotype frequencies)
that sum to <code>1</code>, named with the genotype names if <code>annotate</code> is <code>TRUE</code>.
</p>


<h3>References</h3>

<p>Cannings C, Thompson E, Skolnick M. Probability functions
on complex pedigrees. Advances in Applied Probability, 1978;10(1):26-61.
</p>
<p>Lange K.  Mathematical and Statistical Methods for Genetic Analysis
(second edition). Springer, New York. 2002.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geno_freq_polygenic(4, annotate = TRUE)
sum(geno_freq_polygenic(4))

</code></pre>

<hr>
<h2 id='genotype_probabilities'>Calculate genotype probabilities for a target person</h2><span id='topic+genotype_probabilities'></span>

<h3>Description</h3>

<p>For a chosen individual within a specified family, calculate the person's
conditional genotype probabilities, given the family's phenotypes and
relationship structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotype_probabilities(target, fam, geno_freq, trans, penet, monozyg = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genotype_probabilities_+3A_target">target</code></td>
<td>
<p>The individual identifier (an element of <code>fam$indiv</code>)
of the person in the pedigree <code>fam</code> whose genotype probabilities are being
sought.</p>
</td></tr>
<tr><td><code id="genotype_probabilities_+3A_fam">fam</code></td>
<td>
<p>A data frame specifying the family's relationship structure,
with rows corresponding to people and columns
corresponding to the following variables (other variables can be included
but will be ignored), which will be coerced to <code>character</code> type:
</p>

<ul>
<li> <p><code>indiv</code>, an identifier for each individual person, with no duplicates
in <code>fam</code>.
</p>
</li>
<li> <p><code>mother</code>, the individual identifier of each person's mother, or missing
(<code>NA</code>) for founders.
</p>
</li>
<li> <p><code>father</code>, the individual identifier of each person's father, or missing
(<code>NA</code>) for founders.
</p>
</li></ul>
</td></tr>
<tr><td><code id="genotype_probabilities_+3A_geno_freq">geno_freq</code></td>
<td>
<p>A vector of strictly positive numbers that sum to <code>1</code>.
If the possible genotypes of the underlying genetic model are
<code>1:length(geno_freq)</code> then <code>geno_freq[j]</code> is interpreted as the population
frequency of genotype <code>j</code>.
For certain genetic models that often occur in applications, these genotype
frequencies can be calculated by <code><a href="#topic+geno_freq_monogenic">geno_freq_monogenic</a></code>,
<code><a href="#topic+geno_freq_phased">geno_freq_phased</a></code>, etc.</p>
</td></tr>
<tr><td><code id="genotype_probabilities_+3A_trans">trans</code></td>
<td>
<p>An <code>ngeno^2</code> by <code>ngeno</code> matrix of non-negative numbers whose rows
all sum to <code>1</code>, where <code>ngeno = length(geno_freq)</code> is the number of possible
genotypes.  The rows of <code>trans</code> correspond to joint parental
genotypes and the columns correspond to offspring genotypes.
If the possible genotypes are <code>1:length(geno_freq)</code> then the element
<code>trans[ngeno * gm + gf - ngeno, go]</code> is interpreted as the conditional
probability that a person has genotype <code>go</code>, given that his or her
biological mother and father have genotypes <code>gm</code> and <code>gf</code>, respectively.
For certain genetic models that often occur in applications,
this transmission matrix can be calculated by <code><a href="#topic+trans_monogenic">trans_monogenic</a></code>,
<code><a href="#topic+trans_phased">trans_phased</a></code>, etc.</p>
</td></tr>
<tr><td><code id="genotype_probabilities_+3A_penet">penet</code></td>
<td>
<p>An <code>nrow(fam)</code> by <code>length(geno_freq)</code> matrix of non-negative
numbers. The element <code>penet[i,j]</code> is interpreted as the conditional
probability (or probability density) of the phenotype of the person
corresponding to row <code>i</code> of <code>fam</code>, given that his or her genotype is <code>j</code>
(where the possible genotypes are <code>1:length(geno_freq)</code>).
Note that genotype data can be incorporated into <code>penet</code> by regarding
observed genotypes as part of the phenotype, i.e. by regarding observed
genotypes as (possibly noisy) measurements of the underlying true genotypes.
For example, if the observed genotype of person <code>i</code> is <code>1</code>
(and if genotype measurement error is negligible) then <code>penet[i,j]</code>
should be <code>0</code> for <code>j != 1</code> and <code>penet[i,1]</code> should be the same as if
person <code>i</code> were ungenotyped.</p>
</td></tr>
<tr><td><code id="genotype_probabilities_+3A_monozyg">monozyg</code></td>
<td>
<p>An optional list that can be used to specify genetically
identical persons, such as monozygotic twins, monozygotic triplets,
a monozygotic pair within a set of dizygotic triplets, etc.
Each element of the list should be a vector containing the individual
identifiers of a group of genetically identical persons, e.g. if <code>fam</code>
contains a set of monozygotic twins (and no other genetically identical
persons) then <code>monozyg</code> will be a list
with one element, and that element will be a vector of length two containing
the individual identifiers of the twins.  The order of the list
and the orders of its elements do not affect the output of the function.
Each group of genetically identical persons should contain two or more
persons, the groups should not overlap, and all persons in each group must
have the same (non-missing) parents.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genotype probabilities are calculated by essentially the same algorithm
as <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>;
see there for details.  The genotype probabilities only depend on the
connected component of the pedigree that contains <code>target</code>, so the
function first restricts <code>fam</code> and <code>penet</code> to the rows corresponding to this
connected component.  For example, if <code>fam</code> is the union of two
unrelated families then this function will restrict to the subfamily
containing <code>target</code> before performing the calculation.
</p>


<h3>Value</h3>

<p>A vector of length <code>length(geno_freq)</code>, whose <code>j</code>th element is
the conditional probability that the target person has genotype <code>j</code>,
given the family's relationship structure and phenotypes.  A vector of <code>NA</code>s
will be returned if a row of <code>penet</code> consists entirely of zeroes or if
the pedigree is impossible for any other reason
(after restricting <code>fam</code> and <code>penet</code> to the connected component of
the pedigree containing <code>target</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read in some sample data
data("dat_small", "penet_small")
str(dat_small)
str(penet_small)

# Calculate the genotype probabilities for individual "ora008" in the family "ora"
w &lt;- which(dat_small$family == "ora")
fam &lt;- dat_small[w, -1]
penet &lt;- penet_small[w, ]
monozyg &lt;- list(c("ora024", "ora027"))  # ora024 and ora027 are identical twins
trans &lt;- trans_monogenic(2)
geno_freq &lt;- geno_freq_monogenic(p_alleles = c(0.9, 0.1))
genotype_probabilities(target = "ora008", fam, geno_freq, trans, penet, monozyg)

</code></pre>

<hr>
<h2 id='pedigree_loglikelihood'>Calculate the log-likelihoods of pedigrees</h2><span id='topic+pedigree_loglikelihood'></span>

<h3>Description</h3>

<p>For one or more pedigrees, this function calculates the natural logarithm of
the pedigree likelihood that is on page 117 of (Lange, 2002), given inputs
that correspond to the terms in this formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigree_loglikelihood(
  dat,
  geno_freq,
  trans,
  penet,
  monozyg = NULL,
  sum_loglik = TRUE,
  ncores = 1,
  load_balancing = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pedigree_loglikelihood_+3A_dat">dat</code></td>
<td>
<p>A data frame with rows corresponding to people and columns
corresponding to the following variables (other variables can be included
but will be ignored), which will be coerced to <code>character</code> type:
</p>

<ul>
<li> <p><code>family</code> (optional), an identifier for each person's family, constant
within families.  If this variable is not supplied then <code>dat</code> will be
treated as a single pedigree.
</p>
</li>
<li> <p><code>indiv</code>, an individual identifier for each person.  If there are any
duplicated identifiers in the dataset then the family and an underscore
(<code style="white-space: pre;">&#8288;_&#8288;</code>) will be prepended to all identifiers, and if any duplicates remain
after this then the function will stop executing, with an error message.
</p>
</li>
<li> <p><code>mother</code>, the individual identifier of each person's mother, or missing
(<code>NA</code>) for founders.
</p>
</li>
<li> <p><code>father</code>, the individual identifier of each person's father, or missing
(<code>NA</code>) for founders.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pedigree_loglikelihood_+3A_geno_freq">geno_freq</code></td>
<td>
<p>A vector of strictly positive numbers that sum to <code>1</code>.
If the possible genotypes of the underlying genetic model are
<code>1:length(geno_freq)</code> then <code>geno_freq[j]</code> is interpreted as the population
frequency of genotype <code>j</code>, so <code>geno_freq</code> is essentially the
function <code>Prior</code> in the pedigree likelihood on page 117 of (Lange, 2002).
For certain genetic models that often occur in applications, these genotype
frequencies can be calculated by <code><a href="#topic+geno_freq_monogenic">geno_freq_monogenic</a></code>,
<code><a href="#topic+geno_freq_phased">geno_freq_phased</a></code>, etc.</p>
</td></tr>
<tr><td><code id="pedigree_loglikelihood_+3A_trans">trans</code></td>
<td>
<p>An <code>ngeno^2</code> by <code>ngeno</code> matrix of non-negative numbers whose rows
all sum to <code>1</code>, where <code>ngeno = length(geno_freq)</code> is the number of possible
genotypes. The rows of <code>trans</code> correspond to joint parental genotypes and
the columns correspond to offspring genotypes.  If the possible genotypes
are <code>1:length(geno_freq)</code> then the element
<code>trans[ngeno * gm + gf - ngeno, go]</code> is interpreted as the conditional
probability that a person has genotype <code>go</code>, given that his or her
biological mother and father have genotypes <code>gm</code> and <code>gf</code>, respectively.
So <code>trans</code> is essentially the transmission function <code>Tran</code> on page 117 of
(Lange, 2002).  For certain genetic models that often occur in applications,
this transmission matrix can be calculated by <code><a href="#topic+trans_monogenic">trans_monogenic</a></code>,
<code><a href="#topic+trans_phased">trans_phased</a></code>, etc.</p>
</td></tr>
<tr><td><code id="pedigree_loglikelihood_+3A_penet">penet</code></td>
<td>
<p>An <code>nrow(dat)</code> by <code>length(geno_freq)</code> matrix of non-negative
numbers. The element <code>penet[i,j]</code> is interpreted as the conditional
probability (or probability density) of the phenotype of the person
corresponding to row <code>i</code> of <code>dat</code>, given that his or her genotype is <code>j</code>
(where the possible genotypes are <code>1:length(geno_freq)</code>).
Therefore, <code>penet</code> is essentially the penetrance function <code>Pen</code> on page 117
of (Lange, 2002).  If any row of <code>penet</code> consists entirely of zeroes then
the likelihood is <code>0</code>, so the returned log-likelihood will be <code>-Inf</code>.
Note that genotype data can be incorporated into <code>penet</code> by regarding
observed genotypes as part of the phenotype, i.e. by regarding observed
genotypes as (possibly noisy) measurements of the underlying true genotypes.
For example, if the observed genotype of person <code>i</code> is <code>1</code>
(and if genotype measurement error is negligible) then <code>penet[i,j]</code>
should be <code>0</code> for <code>j != 1</code> and <code>penet[i,1]</code> should be the same as if
person <code>i</code> were ungenotyped.</p>
</td></tr>
<tr><td><code id="pedigree_loglikelihood_+3A_monozyg">monozyg</code></td>
<td>
<p>An optional list that can be used to specify genetically
identical persons, such as monozygotic twins, monozygotic triplets,
a monozygotic pair within a set of dizygotic triplets, etc.
Each element of the list should be a vector containing the individual
identifiers of a group of genetically identical persons, e.g. if <code>dat</code>
contains six sets of monozygotic twins and one set of monozygotic triplets
then <code>monozyg</code> will be a list with seven elements, one element a vector of length
three and the other six elements all vectors of length two. The order of the list and
the orders within its elements do not affect the output of the function.
Each group of genetically identical persons should contain two or more
persons, the groups should not overlap, and all persons in each group must
have the same (non-missing) parents.</p>
</td></tr>
<tr><td><code id="pedigree_loglikelihood_+3A_sum_loglik">sum_loglik</code></td>
<td>
<p>A logical flag.  Return a named vector giving the
log-likelihood of each family if <code>sum_loglik</code> is <code>FALSE</code>, or return the sum
of these log-likelihoods if <code>sum_loglik</code> is <code>TRUE</code> (the default).</p>
</td></tr>
<tr><td><code id="pedigree_loglikelihood_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to be used, with <code>ncores = 1</code> (the
default) corresponding to non-parallel computing.  When <code>ncores &gt; 1</code>,
the <code>parallel</code> package is used to parallelize the calculation by dividing
the pedigrees among the different cores.</p>
</td></tr>
<tr><td><code id="pedigree_loglikelihood_+3A_load_balancing">load_balancing</code></td>
<td>
<p>A logical flag.  When <code>ncores &gt; 1</code>, parallelization is
achieved either with the function <code>parallel::parLapply</code> (if <code>load_balancing</code>
is <code>FALSE</code>) or with the load-balancing function <code>parallel::parLapplyLB</code>
(if <code>load_balancing</code> is <code>TRUE</code>, the default). The load-balancing version
will usually, but not always, be faster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a fast and general implementation of the
Elston-Stewart algorithm to calculate the log-likelihoods of potentially
large and complex pedigrees.  General references for the Elston-Stewart
algorithm are (Elston &amp; Stewart, 1971), (Lange &amp; Elston, 1975) and
(Cannings et al., 1978).
</p>
<p>Each family within <code>dat</code> should be a complete pedigree, meaning that each
person should either have both parental identifiers missing (if a founder)
or both non-missing (if a non-founder), and each (non-missing) mother or
father should have a corresponding row of <code>dat</code>.
</p>
<p>Observed genotypes should be incorporated into <code>penet</code>, as described above.
</p>
<p>The function can handle pedigree loops, such as those
caused by inbreeding or by two sisters having children with two brothers
from an unrelated family (see (Totir et al., 2009) for a precise definition),
though pedigrees with more than a few loops could greatly reduce the speed of
the calculation.
</p>
<p>In <code>geno_freq</code>, <code>trans</code> and <code>penet</code>, the order of the possible genotypes
must match, in the sense that the genotype that corresponds to element <code>j</code>
of <code>geno_freq</code> must also correspond to column <code>j</code> of <code>trans</code> and <code>penet</code>,
for each <code>j</code> in <code>1:length(geno_freq)</code>.
</p>
<p>Sex-specific genetics, such as X-linked genes or genetic loci with sex-specific
recombination fractions, can be modelled by letting genotypes <code>1:nm</code> be
the possible male genotypes and letting <code>(nm+1):(nm+nf)</code> be the possible
female genotypes, where <code>nm</code> and <code>nf</code> are the number of possible genotypes
for males and females, respectively.  Then, for example, <code>penet[i,j]</code> will
be <code>0</code> if <code>j %in% 1:nm</code> and row <code>i</code> of <code>dat</code> corresponds to a female, and
<code>penet[i,j]</code> will be <code>0</code> if <code>j %in% (nm+1):(nm+nf)</code> and row <code>i</code> of
<code>dat</code> corresponds to a male.
</p>


<h3>Value</h3>

<p>Either a named vector giving the log-likelihood of each family
or the sum of these log-likelihoods, depending on <code>sum_loglik</code> (see above).
</p>


<h3>References</h3>

<p>Cannings C, Thompson E, Skolnick M. Probability functions
on complex pedigrees. Advances in Applied Probability, 1978;10(1):26-61.
</p>
<p>Elston RC, Stewart J. A general model for the genetic analysis of pedigree
data. Hum Hered. 1971;21(6):523-542.
</p>
<p>Lange K.  Mathematical and Statistical Methods for Genetic Analysis
(second edition). Springer, New York. 2002.
</p>
<p>Lange K, Elston RC. Extensions to pedigree analysis I. Likehood calculations
for simple and complex pedigrees. Hum Hered. 1975;25(2):95-105.
</p>
<p>Totir LR, Fernando RL, Abraham J. An efficient algorithm to compute marginal
posterior genotype probabilities for every member of a pedigree with loops.
Genet Sel Evol. 2009;41(1):52.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load pedigree files and penetrance matrices
data("dat_small", "penet_small", "dat_large", "penet_large")

# Settings for a single biallelic locus in Hardy-Weinberg equilibrium
# and with a minor allele frequency of 10%
geno_freq &lt;- geno_freq_monogenic(c(0.9, 0.1))
trans &lt;- trans_monogenic(2)

# In dat_small, ora024 and ora027 are identical twins, and so are aey063 and aey064
monozyg_small &lt;- list(c("ora024", "ora027"), c("aey063", "aey064"))

# Calculate the log-likelihoods for 10 families, each with approximately
# 100 family members
pedigree_loglikelihood(
  dat_small, geno_freq, trans, penet_small, monozyg_small, sum_loglik = FALSE, ncores = 2
)

# Calculate the log-likelihood for one family with approximately 10,000 family members
# Note:  this calculation should take less than a minute on a standard desktop computer
# Note:  parallelization would achieve nothing here because there is only one family
str(dat_large)

system.time(
  ll &lt;- pedigree_loglikelihood(dat_large, geno_freq, trans, penet_large)
)
ll


</code></pre>

<hr>
<h2 id='penet_large'>A penetrance matrix relating the phenotypes in <code>dat_large</code> to three genotypes</h2><span id='topic+penet_large'></span>

<h3>Description</h3>

<p>A matrix relating the phenotypes of <code>dat_large</code> to the three unphased
genotypes of a single biallelic, autosomal genetic locus.
The element <code>penet_large[i,j]</code> is the conditional probability of
the phenotypes (i.e. <code>sex</code>, <code>aff</code> and <code>age</code>) of the person
in row <code>i</code> of <code>dat_large</code>, given that
his or her genotype is <code>j</code> (here labelling the genotypes as <code style="white-space: pre;">&#8288;1, 2, 3&#8288;</code>,
where genotype <code>2</code> is the heterozygous genotype).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penet_large
</code></pre>


<h3>Format</h3>

<p>A matrix with 10,002 rows (corresponding to persons) and 3
columns (corresponding to genotypes).
</p>


<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='penet_small'>A penetrance matrix relating the phenotypes of <code>dat_small</code> to three genotypes</h2><span id='topic+penet_small'></span>

<h3>Description</h3>

<p>A matrix relating the phenotypes of <code>dat_small</code> to the three unphased
genotypes of a single biallelic, autosomal genetic locus.
The element <code>penet_small[i,j]</code> is the conditional probability of
the phenotypes (i.e. <code>sex</code>, <code>aff</code> and <code>age</code>) of the person
in row <code>i</code> of <code>dat_small</code>, given that
his or her genotype is <code>j</code> (here labelling the genotypes as <code style="white-space: pre;">&#8288;1, 2, 3&#8288;</code>,
where genotype <code>2</code> is the heterozygous genotype).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penet_small
</code></pre>


<h3>Format</h3>

<p>A matrix with 1018 rows (corresponding to persons) and 3
columns (corresponding to genotypes).
</p>


<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='trans_monogenic'>The transmission matrix for a single genetic locus</h2><span id='topic+trans_monogenic'></span>

<h3>Description</h3>

<p>A function to calculate the transmission matrix for a single autosomal
genetic locus with an arbitrary number of alleles and unphased genotypes,
based on Mendel's laws of inheritance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_monogenic(n_alleles, annotate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trans_monogenic_+3A_n_alleles">n_alleles</code></td>
<td>
<p>A positive integer, interpreted as the number of possible
alleles at the genetic locus.</p>
</td></tr>
<tr><td><code id="trans_monogenic_+3A_annotate">annotate</code></td>
<td>
<p>A logical flag. When <code>FALSE</code> (the default), the function
returns a matrix suitable to be used as the <code>trans</code> argument of
<code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>. When <code>TRUE</code>, the function annotates
this matrix (and converts it to a data frame) to make the output more
easily understood by humans.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>annotate</code> is <code>FALSE</code>, this function returns a matrix of
genetic transmission probabilities, whose rows corresponding to the possible
joint parental genotypes and whose columns corresponding to the possible
offspring genotypes.  There are <code>ngeno = n_alleles * (n_alleles + 1) / 2</code> possible
unphased genotypes, and by choosing an order on these genotypes (which can be
viewed by setting <code>annotate</code> to <code>TRUE</code>, see below)
we can label the set of possible genotypes as <code>1:ngeno</code>.
Then the <code style="white-space: pre;">&#8288;(ngeno * gm + gf - ngeno, go)&#8288;</code>th element of the outputted matrix is
the conditional probability that a person has genotype <code>go</code>, given that his
or her biological mother and father have genotypes <code>gm</code> and <code>gf</code>,
respectively.
</p>
<p>When <code>annotate</code> is <code>TRUE</code>, the function converts this matrix to a data frame,
adds column names giving the offspring genotype corresponding to each
column, and adds columns <code>gm</code> and <code>gf</code> describing the parental genotypes
corresponding to each row.  In this data frame, genotypes are written
in the usual form <code style="white-space: pre;">&#8288;1/1, 1/2, ...&#8288;</code> for the alleles <code>1:n_alleles</code>.
</p>
<p>Note that if the output of this function is to be used as the <code>trans</code>
argument of <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code> then the <code>annotate</code> option
must be set to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>Either a matrix of genetic transmission probabilities suitable to be
used as the <code>trans</code> argument of <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>
(if <code>annotate</code> is <code>FALSE</code>), or a data frame that is an annotated version of
this matrix (if <code>annotate</code> is <code>TRUE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The transition matrix for a biallelic, autosomal locus with unphased genotypes
trans_monogenic(2)
trans_monogenic(2, annotate = TRUE)

</code></pre>

<hr>
<h2 id='trans_phased'>The transmission matrix for phased genotypes</h2><span id='topic+trans_phased'></span>

<h3>Description</h3>

<p>A function to calculate the transmission matrix for a single autosomal
genetic locus with an arbitrary number of alleles and phased genotypes,
based on Mendel's laws of inheritance.  Phased genotypes can be used to
investigate parent-of-origin effects, e.g. see (van Vliet et al., 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_phased(n_alleles, annotate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trans_phased_+3A_n_alleles">n_alleles</code></td>
<td>
<p>A positive integer, interpreted as the number of possible
alleles at the genetic locus.</p>
</td></tr>
<tr><td><code id="trans_phased_+3A_annotate">annotate</code></td>
<td>
<p>A logical flag. When <code>FALSE</code> (the default), the function
returns a matrix suitable to be used as the <code>trans</code> argument of
<code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>. When <code>TRUE</code>, the function annotates
this matrix (and converts it to a data frame) to make the output more
easily understood by humans.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>annotate</code> is <code>FALSE</code>, a matrix of genetic transmission
probabilities is returned, with rows corresponding to the possible joint
parental genotypes and columns corresponding to the possible offspring
genotypes.
There are <code>ngeno = n_alleles^2</code> possible phased genotypes,
and by choosing an order on these genotypes (which can be
viewed by setting <code>annotate</code> to <code>TRUE</code>, see below)
we can label the set of possible phased genotypes as <code>1:ngeno</code>.
Then the <code style="white-space: pre;">&#8288;(ngeno * gm + gf - ngeno, go)&#8288;</code>th element of the outputted matrix is
the conditional probability that a person has genotype <code>go</code>, given that his
or her biological mother and father have genotypes <code>gm</code> and <code>gf</code>,
respectively.
</p>
<p>When <code>annotate</code> is <code>TRUE</code>, the function converts this matrix to a data frame,
adds column names giving the offspring genotype corresponding to each
column, and adds columns <code>gm</code> and <code>gf</code> describing the parental genotypes
corresponding to each row.
In this data frame, phased genotypes are written in the usual form
<code style="white-space: pre;">&#8288;1|1, 1|2, ...&#8288;</code> for the alleles <code>1:n_alleles</code>, where <code>a|b</code> means the
maternal allele is <code>a</code> and the paternal allele is <code>b</code>.
</p>
<p>Note that if the output of this function is to be used as the <code>trans</code>
argument of <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code> then the <code>annotate</code> option
must be set to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>Either a matrix of genetic transmission probabilities suitable to be
used as the <code>trans</code> argument of <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>
(if <code>annotate</code> is <code>FALSE</code>), or a data frame that is an annotated version of
this matrix (if <code>annotate</code> is <code>TRUE</code>).
</p>


<h3>References</h3>

<p>van Vliet CM, Dowty JG, van Vliet JL, et al. Dependence of colorectal cancer
risk on the parent-of-origin of mutations in DNA mismatch repair genes.
Hum Mutat. 2011;32(2):207-212.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The transition matrix for a biallelic, autosomal locus with phased genotypes
trans_phased(2)
trans_phased(2, annotate = TRUE)

</code></pre>

<hr>
<h2 id='trans_polygenic'>The transmission matrix for the hypergeometric polygenic model</h2><span id='topic+trans_polygenic'></span>

<h3>Description</h3>

<p>A function to calculate the transmission matrix for the hypergeometric
polygenic model of (Cannings et al., 1978), see also Section 8.9 of
(Lange, 2002) for a nice description of this model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_polygenic(n_loci, annotate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trans_polygenic_+3A_n_loci">n_loci</code></td>
<td>
<p>A positive integer, interpreted as the number of biallelic
genetic loci that contribute to the polygene.  The polygene will have
<code>2*n_loci + 1</code> genotypes, so <code>n_loci</code> is typically fairly small, e.g. <code>4</code>.</p>
</td></tr>
<tr><td><code id="trans_polygenic_+3A_annotate">annotate</code></td>
<td>
<p>A logical flag. When <code>FALSE</code> (the default), the function
returns a matrix suitable to be used as the <code>trans</code> argument of
<code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>. When <code>TRUE</code>, the function annotates
this matrix (and converts it to a data frame) to make the output more
easily understood by humans.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the genetic transmission probabilities
(i.e. the conditional probability of a person's genotype, given his
or her biological parents' genotypes) for the hypergeometric polygenic model,
which is described in <code><a href="#topic+geno_freq_polygenic">geno_freq_polygenic</a></code>.
</p>
<p>When <code>annotate</code> is <code>FALSE</code>,
a matrix of transmission probabilities is returned, with rows
corresponding to the possible joint parental genotypes and columns
corresponding to the possible offspring genotypes.
Setting <code>annotate</code> to <code>TRUE</code> shows which rows and columns correspond to
which genotypes,  by adding offspring genotypes as column names and adding
columns <code>gm</code> and <code>gf</code> containing (respectively) the mother's and father's
genotypes. Note that if the output of this function is to be used as the <code>trans</code>
argument of <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code> then the <code>annotate</code> option
must be set to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>Either a matrix of genetic transmission probabilities suitable to be
used as the <code>trans</code> argument of <code><a href="#topic+pedigree_loglikelihood">pedigree_loglikelihood</a></code>
(if <code>annotate</code> is <code>FALSE</code>), or a data frame that is an annotated version of
this matrix (if <code>annotate</code> is <code>TRUE</code>).
</p>


<h3>References</h3>

<p>Cannings C, Thompson E, Skolnick M. Probability functions
on complex pedigrees. Advances in Applied Probability, 1978;10(1):26-61.
</p>
<p>Lange K.  Mathematical and Statistical Methods for Genetic Analysis
(second edition). Springer, New York. 2002.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trans_polygenic(4, annotate = TRUE)
apply(trans_polygenic(4), 1, sum)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
